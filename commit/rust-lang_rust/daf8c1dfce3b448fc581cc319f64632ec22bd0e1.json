{"sha": "daf8c1dfce3b448fc581cc319f64632ec22bd0e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhZjhjMWRmY2UzYjQ0OGZjNTgxY2MzMTlmNjQ2MzJlYzIyYmQwZTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-05T20:53:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-05T20:53:04Z"}, "message": "Auto merge of #38117 - michaelwoerister:hidden-symbols, r=alexcrichton\n\nImprove symbol visibility handling for dynamic libraries.\n\nThis will hopefully fix issue https://github.com/rust-lang/rust/issues/37530 and maybe also https://github.com/rust-lang/rust/issues/32887.\n\nI'm relying on @m4b to post some numbers on how awesome the improvement for cdylibs is `:)`\n\ncc @rust-lang/compiler @rust-lang/tools @cuviper @froydnj\nr? @alexcrichton", "tree": {"sha": "738b0a50c9e964ded18a0dd406902b8ca17e5b3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/738b0a50c9e964ded18a0dd406902b8ca17e5b3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/daf8c1dfce3b448fc581cc319f64632ec22bd0e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/daf8c1dfce3b448fc581cc319f64632ec22bd0e1", "html_url": "https://github.com/rust-lang/rust/commit/daf8c1dfce3b448fc581cc319f64632ec22bd0e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06b8d1d3611dc9ebd37dd464b39d5d1565bbcd96", "url": "https://api.github.com/repos/rust-lang/rust/commits/06b8d1d3611dc9ebd37dd464b39d5d1565bbcd96", "html_url": "https://github.com/rust-lang/rust/commit/06b8d1d3611dc9ebd37dd464b39d5d1565bbcd96"}, {"sha": "8ecdc4ee3bde4a7986bafe4010f5358d89a4eeab", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ecdc4ee3bde4a7986bafe4010f5358d89a4eeab", "html_url": "https://github.com/rust-lang/rust/commit/8ecdc4ee3bde4a7986bafe4010f5358d89a4eeab"}], "stats": {"total": 866, "additions": 623, "deletions": 243}, "files": [{"sha": "4357518b332cc64a911958b2c3980314dcf9e1e5", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=daf8c1dfce3b448fc581cc319f64632ec22bd0e1", "patch": "@@ -328,8 +328,9 @@ pub trait CrateStore<'tcx> {\n     fn crate_hash(&self, cnum: CrateNum) -> Svh;\n     fn crate_disambiguator(&self, cnum: CrateNum) -> Symbol;\n     fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>;\n+    fn derive_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>;\n     fn native_libraries(&self, cnum: CrateNum) -> Vec<NativeLibrary>;\n-    fn reachable_ids(&self, cnum: CrateNum) -> Vec<DefId>;\n+    fn exported_symbols(&self, cnum: CrateNum) -> Vec<DefId>;\n     fn is_no_builtins(&self, cnum: CrateNum) -> bool;\n \n     // resolve\n@@ -491,9 +492,11 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n                            -> Symbol { bug!(\"crate_disambiguator\") }\n     fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n         { bug!(\"plugin_registrar_fn\") }\n+    fn derive_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n+        { bug!(\"derive_registrar_fn\") }\n     fn native_libraries(&self, cnum: CrateNum) -> Vec<NativeLibrary>\n         { bug!(\"native_libraries\") }\n-    fn reachable_ids(&self, cnum: CrateNum) -> Vec<DefId> { bug!(\"reachable_ids\") }\n+    fn exported_symbols(&self, cnum: CrateNum) -> Vec<DefId> { bug!(\"exported_symbols\") }\n     fn is_no_builtins(&self, cnum: CrateNum) -> bool { bug!(\"is_no_builtins\") }\n \n     // resolve"}, {"sha": "d2592a3acee473fa49d1090fd65656e28331f54c", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=daf8c1dfce3b448fc581cc319f64632ec22bd0e1", "patch": "@@ -64,6 +64,15 @@ pub enum Linkage {\n     CommonLinkage = 10,\n }\n \n+// LLVMRustVisibility\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[repr(C)]\n+pub enum Visibility {\n+    Default = 0,\n+    Hidden = 1,\n+    Protected = 2,\n+}\n+\n /// LLVMDiagnosticSeverity\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n@@ -399,13 +408,6 @@ pub type OperandBundleDefRef = *mut OperandBundleDef_opaque;\n pub type DiagnosticHandler = unsafe extern \"C\" fn(DiagnosticInfoRef, *mut c_void);\n pub type InlineAsmDiagHandler = unsafe extern \"C\" fn(SMDiagnosticRef, *const c_void, c_uint);\n \n-/// LLVMVisibility\n-#[repr(C)]\n-pub enum Visibility {\n-    Default,\n-    Hidden,\n-    Protected,\n-}\n \n pub mod debuginfo {\n     use super::MetadataRef;\n@@ -655,7 +657,8 @@ extern \"C\" {\n     pub fn LLVMRustSetLinkage(Global: ValueRef, RustLinkage: Linkage);\n     pub fn LLVMGetSection(Global: ValueRef) -> *const c_char;\n     pub fn LLVMSetSection(Global: ValueRef, Section: *const c_char);\n-    pub fn LLVMSetVisibility(Global: ValueRef, Viz: Visibility);\n+    pub fn LLVMRustGetVisibility(Global: ValueRef) -> Visibility;\n+    pub fn LLVMRustSetVisibility(Global: ValueRef, Viz: Visibility);\n     pub fn LLVMGetAlignment(Global: ValueRef) -> c_uint;\n     pub fn LLVMSetAlignment(Global: ValueRef, Bytes: c_uint);\n     pub fn LLVMSetDLLStorageClass(V: ValueRef, C: DLLStorageClass);"}, {"sha": "aca1d2f76128128f92e1d2236a3d1c05f5af2d49", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=daf8c1dfce3b448fc581cc319f64632ec22bd0e1", "patch": "@@ -306,14 +306,22 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         })\n     }\n \n+    fn derive_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n+    {\n+        self.get_crate_data(cnum).root.macro_derive_registrar.map(|index| DefId {\n+            krate: cnum,\n+            index: index\n+        })\n+    }\n+\n     fn native_libraries(&self, cnum: CrateNum) -> Vec<NativeLibrary>\n     {\n         self.get_crate_data(cnum).get_native_libraries()\n     }\n \n-    fn reachable_ids(&self, cnum: CrateNum) -> Vec<DefId>\n+    fn exported_symbols(&self, cnum: CrateNum) -> Vec<DefId>\n     {\n-        self.get_crate_data(cnum).get_reachable_ids()\n+        self.get_crate_data(cnum).get_exported_symbols()\n     }\n \n     fn is_no_builtins(&self, cnum: CrateNum) -> bool {"}, {"sha": "43635eae76c0f223f37f247aa4a165b9d66d4452", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=daf8c1dfce3b448fc581cc319f64632ec22bd0e1", "patch": "@@ -1038,8 +1038,8 @@ impl<'a, 'tcx> CrateMetadata {\n         arg_names.decode(self).collect()\n     }\n \n-    pub fn get_reachable_ids(&self) -> Vec<DefId> {\n-        self.root.reachable_ids.decode(self).map(|index| self.local_def_id(index)).collect()\n+    pub fn get_exported_symbols(&self) -> Vec<DefId> {\n+        self.root.exported_symbols.decode(self).map(|index| self.local_def_id(index)).collect()\n     }\n \n     pub fn get_macro(&self, id: DefIndex) -> (ast::Name, MacroDef) {"}, {"sha": "01cb0f823e8efae6455f31a11bec20f9e2234661", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=daf8c1dfce3b448fc581cc319f64632ec22bd0e1", "patch": "@@ -50,7 +50,7 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     reexports: &'a def::ExportMap,\n     link_meta: &'a LinkMeta,\n     cstore: &'a cstore::CStore,\n-    reachable: &'a NodeSet,\n+    exported_symbols: &'a NodeSet,\n \n     lazy_state: LazyState,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n@@ -1223,16 +1223,16 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.lazy_seq(all_impls)\n     }\n \n-    // Encodes all reachable symbols in this crate into the metadata.\n+    // Encodes all symbols exported from this crate into the metadata.\n     //\n     // This pass is seeded off the reachability list calculated in the\n     // middle::reachable module but filters out items that either don't have a\n     // symbol associated with them (they weren't translated) or if they're an FFI\n     // definition (as that's not defined in this crate).\n-    fn encode_reachable(&mut self) -> LazySeq<DefIndex> {\n-        let reachable = self.reachable;\n+    fn encode_exported_symbols(&mut self) -> LazySeq<DefIndex> {\n+        let exported_symbols = self.exported_symbols;\n         let tcx = self.tcx;\n-        self.lazy_seq(reachable.iter().map(|&id| tcx.map.local_def_id(id).index))\n+        self.lazy_seq(exported_symbols.iter().map(|&id| tcx.map.local_def_id(id).index))\n     }\n \n     fn encode_dylib_dependency_formats(&mut self) -> LazySeq<Option<LinkagePreference>> {\n@@ -1278,10 +1278,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let impls = self.encode_impls();\n         let impl_bytes = self.position() - i;\n \n-        // Encode reachability info.\n+        // Encode exported symbols info.\n         i = self.position();\n-        let reachable_ids = self.encode_reachable();\n-        let reachable_bytes = self.position() - i;\n+        let exported_symbols = self.encode_exported_symbols();\n+        let exported_symbols_bytes = self.position() - i;\n \n         // Encode and index the items.\n         i = self.position();\n@@ -1319,7 +1319,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             native_libraries: native_libraries,\n             codemap: codemap,\n             impls: impls,\n-            reachable_ids: reachable_ids,\n+            exported_symbols: exported_symbols,\n             index: index,\n         });\n \n@@ -1339,7 +1339,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             println!(\"          native bytes: {}\", native_lib_bytes);\n             println!(\"         codemap bytes: {}\", codemap_bytes);\n             println!(\"            impl bytes: {}\", impl_bytes);\n-            println!(\"       reachable bytes: {}\", reachable_bytes);\n+            println!(\"    exp. symbols bytes: {}\", exported_symbols_bytes);\n             println!(\"            item bytes: {}\", item_bytes);\n             println!(\"           index bytes: {}\", index_bytes);\n             println!(\"            zero bytes: {}\", zero_bytes);\n@@ -1377,7 +1377,7 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  cstore: &cstore::CStore,\n                                  reexports: &def::ExportMap,\n                                  link_meta: &LinkMeta,\n-                                 reachable: &NodeSet)\n+                                 exported_symbols: &NodeSet)\n                                  -> Vec<u8> {\n     let mut cursor = Cursor::new(vec![]);\n     cursor.write_all(METADATA_HEADER).unwrap();\n@@ -1392,7 +1392,7 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             reexports: reexports,\n             link_meta: link_meta,\n             cstore: cstore,\n-            reachable: reachable,\n+            exported_symbols: exported_symbols,\n             lazy_state: LazyState::NoNode,\n             type_shorthands: Default::default(),\n             predicate_shorthands: Default::default(),"}, {"sha": "f92051cbf1943a03338f8b3e8b1d8bcc5f4464f0", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=daf8c1dfce3b448fc581cc319f64632ec22bd0e1", "patch": "@@ -180,7 +180,7 @@ pub struct CrateRoot {\n     pub native_libraries: LazySeq<NativeLibrary>,\n     pub codemap: LazySeq<syntax_pos::FileMap>,\n     pub impls: LazySeq<TraitImpls>,\n-    pub reachable_ids: LazySeq<DefIndex>,\n+    pub exported_symbols: LazySeq<DefIndex>,\n     pub index: LazySeq<index::Index>,\n }\n "}, {"sha": "d59ee5d825d8619d6f16bc7b295d7666aabf6c70", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 43, "deletions": 56, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=daf8c1dfce3b448fc581cc319f64632ec22bd0e1", "patch": "@@ -17,11 +17,11 @@ use std::path::{Path, PathBuf};\n use std::process::Command;\n \n use context::SharedCrateContext;\n-use monomorphize::Instance;\n \n use back::archive;\n+use back::symbol_export::{self, ExportedSymbols};\n use middle::dependency_format::Linkage;\n-use rustc::hir::def_id::CrateNum;\n+use rustc::hir::def_id::{LOCAL_CRATE, CrateNum};\n use session::Session;\n use session::config::CrateType;\n use session::config;\n@@ -34,10 +34,10 @@ pub struct LinkerInfo {\n \n impl<'a, 'tcx> LinkerInfo {\n     pub fn new(scx: &SharedCrateContext<'a, 'tcx>,\n-               reachable: &[String]) -> LinkerInfo {\n+               exports: &ExportedSymbols) -> LinkerInfo {\n         LinkerInfo {\n             exports: scx.sess().crate_types.borrow().iter().map(|&c| {\n-                (c, exported_symbols(scx, reachable, c))\n+                (c, exported_symbols(scx, exports, c))\n             }).collect(),\n         }\n     }\n@@ -253,46 +253,47 @@ impl<'a> Linker for GnuLinker<'a> {\n         let mut arg = OsString::new();\n         let path = tmpdir.join(\"list\");\n \n-        if self.sess.target.target.options.is_like_solaris {\n+        debug!(\"EXPORTED SYMBOLS:\");\n+\n+        if self.sess.target.target.options.is_like_osx {\n+            // Write a plain, newline-separated list of symbols\n             let res = (|| -> io::Result<()> {\n                 let mut f = BufWriter::new(File::create(&path)?);\n-                writeln!(f, \"{{\\n  global:\")?;\n                 for sym in self.info.exports[&crate_type].iter() {\n-                    writeln!(f, \"    {};\", sym)?;\n+                    debug!(\"  _{}\", sym);\n+                    writeln!(f, \"_{}\", sym)?;\n                 }\n-                writeln!(f, \"\\n  local:\\n    *;\\n}};\")?;\n                 Ok(())\n             })();\n             if let Err(e) = res {\n-                self.sess.fatal(&format!(\"failed to write version script: {}\", e));\n+                self.sess.fatal(&format!(\"failed to write lib.def file: {}\", e));\n             }\n-\n-            arg.push(\"-Wl,-M,\");\n-            arg.push(&path);\n         } else {\n-            let prefix = if self.sess.target.target.options.is_like_osx {\n-                \"_\"\n-            } else {\n-                \"\"\n-            };\n+            // Write an LD version script\n             let res = (|| -> io::Result<()> {\n                 let mut f = BufWriter::new(File::create(&path)?);\n+                writeln!(f, \"{{\\n  global:\")?;\n                 for sym in self.info.exports[&crate_type].iter() {\n-                    writeln!(f, \"{}{}\", prefix, sym)?;\n+                    debug!(\"    {};\", sym);\n+                    writeln!(f, \"    {};\", sym)?;\n                 }\n+                writeln!(f, \"\\n  local:\\n    *;\\n}};\")?;\n                 Ok(())\n             })();\n             if let Err(e) = res {\n-                self.sess.fatal(&format!(\"failed to write lib.def file: {}\", e));\n-            }\n-            if self.sess.target.target.options.is_like_osx {\n-                arg.push(\"-Wl,-exported_symbols_list,\");\n-            } else {\n-                arg.push(\"-Wl,--retain-symbols-file=\");\n+                self.sess.fatal(&format!(\"failed to write version script: {}\", e));\n             }\n-            arg.push(&path);\n         }\n \n+        if self.sess.target.target.options.is_like_osx {\n+            arg.push(\"-Wl,-exported_symbols_list,\");\n+        } else if self.sess.target.target.options.is_like_solaris {\n+            arg.push(\"-Wl,-M,\");\n+        } else {\n+            arg.push(\"-Wl,--version-script=\");\n+        }\n+\n+        arg.push(&path);\n         self.cmd.arg(arg);\n     }\n \n@@ -473,43 +474,29 @@ impl<'a> Linker for MsvcLinker<'a> {\n }\n \n fn exported_symbols(scx: &SharedCrateContext,\n-                    reachable: &[String],\n+                    exported_symbols: &ExportedSymbols,\n                     crate_type: CrateType)\n                     -> Vec<String> {\n-    // See explanation in GnuLinker::export_symbols, for\n-    // why we don't ever need dylib symbols on non-MSVC.\n-    if crate_type == CrateType::CrateTypeDylib ||\n-       crate_type == CrateType::CrateTypeProcMacro {\n-        if !scx.sess().target.target.options.is_like_msvc {\n-            return vec![];\n-        }\n-    }\n+    let export_threshold = symbol_export::crate_export_threshold(crate_type);\n \n-    let mut symbols = reachable.to_vec();\n+    let mut symbols = Vec::new();\n+    exported_symbols.for_each_exported_symbol(LOCAL_CRATE, export_threshold, |name, _| {\n+        symbols.push(name.to_owned());\n+    });\n \n-    // If we're producing anything other than a dylib then the `reachable` array\n-    // above is the exhaustive set of symbols we should be exporting.\n-    //\n-    // For dylibs, however, we need to take a look at how all upstream crates\n-    // are linked into this dynamic library. For all statically linked\n-    // libraries we take all their reachable symbols and emit them as well.\n-    if crate_type != CrateType::CrateTypeDylib {\n-        return symbols\n-    }\n-\n-    let cstore = &scx.sess().cstore;\n     let formats = scx.sess().dependency_formats.borrow();\n     let deps = formats[&crate_type].iter();\n-    symbols.extend(deps.enumerate().filter_map(|(i, f)| {\n-        if *f == Linkage::Static {\n-            Some(CrateNum::new(i + 1))\n-        } else {\n-            None\n+\n+    for (index, dep_format) in deps.enumerate() {\n+        let cnum = CrateNum::new(index + 1);\n+        // For each dependency that we are linking to statically ...\n+        if *dep_format == Linkage::Static {\n+            // ... we add its symbol list to our export list.\n+            exported_symbols.for_each_exported_symbol(cnum, export_threshold, |name, _| {\n+                symbols.push(name.to_owned());\n+            })\n         }\n-    }).flat_map(|cnum| {\n-        cstore.reachable_ids(cnum)\n-    }).map(|did| -> String {\n-        Instance::mono(scx, did).symbol_name(scx)\n-    }));\n+    }\n+\n     symbols\n }"}, {"sha": "f137bfff034d0e37c7cc9af7afd364a86d42064b", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 51, "deletions": 16, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=daf8c1dfce3b448fc581cc319f64632ec22bd0e1", "patch": "@@ -8,14 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::link;\n-use super::write;\n+use back::link;\n+use back::write;\n+use back::symbol_export::{self, ExportedSymbols};\n use rustc::session::{self, config};\n use llvm;\n use llvm::archive_ro::ArchiveRO;\n use llvm::{ModuleRef, TargetMachineRef, True, False};\n use rustc::util::common::time;\n use rustc::util::common::path2cstr;\n+use rustc::hir::def_id::LOCAL_CRATE;\n use back::write::{ModuleConfig, with_llvm_pmb};\n \n use libc;\n@@ -24,8 +26,23 @@ use flate;\n use std::ffi::CString;\n use std::path::Path;\n \n-pub fn run(sess: &session::Session, llmod: ModuleRef,\n-           tm: TargetMachineRef, reachable: &[String],\n+pub fn crate_type_allows_lto(crate_type: config::CrateType) -> bool {\n+    match crate_type {\n+        config::CrateTypeExecutable |\n+        config::CrateTypeStaticlib  |\n+        config::CrateTypeCdylib     => true,\n+\n+        config::CrateTypeDylib     |\n+        config::CrateTypeRlib      |\n+        config::CrateTypeMetadata  |\n+        config::CrateTypeProcMacro => false,\n+    }\n+}\n+\n+pub fn run(sess: &session::Session,\n+           llmod: ModuleRef,\n+           tm: TargetMachineRef,\n+           exported_symbols: &ExportedSymbols,\n            config: &ModuleConfig,\n            temp_no_opt_bc_filename: &Path) {\n     if sess.opts.cg.prefer_dynamic {\n@@ -38,17 +55,31 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n \n     // Make sure we actually can run LTO\n     for crate_type in sess.crate_types.borrow().iter() {\n-        match *crate_type {\n-            config::CrateTypeExecutable |\n-            config::CrateTypeCdylib |\n-            config::CrateTypeStaticlib => {}\n-            _ => {\n-                sess.fatal(\"lto can only be run for executables and \\\n+        if !crate_type_allows_lto(*crate_type) {\n+            sess.fatal(\"lto can only be run for executables, cdylibs and \\\n                             static library outputs\");\n-            }\n         }\n     }\n \n+    let export_threshold =\n+        symbol_export::crates_export_threshold(&sess.crate_types.borrow()[..]);\n+\n+    let symbol_filter = &|&(ref name, level): &(String, _)| {\n+        if symbol_export::is_below_threshold(level, export_threshold) {\n+            let mut bytes = Vec::with_capacity(name.len() + 1);\n+            bytes.extend(name.bytes());\n+            Some(CString::new(bytes).unwrap())\n+        } else {\n+            None\n+        }\n+    };\n+\n+    let mut symbol_white_list: Vec<CString> = exported_symbols\n+        .exported_symbols(LOCAL_CRATE)\n+        .iter()\n+        .filter_map(symbol_filter)\n+        .collect();\n+\n     // For each of our upstream dependencies, find the corresponding rlib and\n     // load the bitcode from the archive. Then merge it into the current LLVM\n     // module that we've got.\n@@ -58,6 +89,11 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n             return;\n         }\n \n+        symbol_white_list.extend(\n+            exported_symbols.exported_symbols(cnum)\n+                            .iter()\n+                            .filter_map(symbol_filter));\n+\n         let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n         let bytecodes = archive.iter().filter_map(|child| {\n             child.ok().and_then(|c| c.name().map(|name| (name, c)))\n@@ -118,11 +154,10 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n         }\n     });\n \n-    // Internalize everything but the reachable symbols of the current module\n-    let cstrs: Vec<CString> = reachable.iter().map(|s| {\n-        CString::new(s.clone()).unwrap()\n-    }).collect();\n-    let arr: Vec<*const libc::c_char> = cstrs.iter().map(|c| c.as_ptr()).collect();\n+    // Internalize everything but the exported symbols of the current module\n+    let arr: Vec<*const libc::c_char> = symbol_white_list.iter()\n+                                                         .map(|c| c.as_ptr())\n+                                                         .collect();\n     let ptr = arr.as_ptr();\n     unsafe {\n         llvm::LLVMRustRunRestrictionPass(llmod,"}, {"sha": "f99f543d9b7dfa9c025c4785736956008c943ef0", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=daf8c1dfce3b448fc581cc319f64632ec22bd0e1", "patch": "@@ -0,0 +1,193 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use context::SharedCrateContext;\n+use monomorphize::Instance;\n+use symbol_map::SymbolMap;\n+use util::nodemap::FxHashMap;\n+use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n+use rustc::session::config;\n+use syntax::attr;\n+use trans_item::TransItem;\n+\n+/// The SymbolExportLevel of a symbols specifies from which kinds of crates\n+/// the symbol will be exported. `C` symbols will be exported from any\n+/// kind of crate, including cdylibs which export very few things.\n+/// `Rust` will only be exported if the crate produced is a Rust\n+/// dylib.\n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+pub enum SymbolExportLevel {\n+    C,\n+    Rust,\n+}\n+\n+/// The set of symbols exported from each crate in the crate graph.\n+pub struct ExportedSymbols {\n+    exports: FxHashMap<CrateNum, Vec<(String, SymbolExportLevel)>>,\n+}\n+\n+impl ExportedSymbols {\n+\n+    pub fn empty() -> ExportedSymbols {\n+        ExportedSymbols {\n+            exports: FxHashMap(),\n+        }\n+    }\n+\n+    pub fn compute_from<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+                                  symbol_map: &SymbolMap<'tcx>)\n+                                  -> ExportedSymbols {\n+        let mut local_crate: Vec<_> = scx\n+            .exported_symbols()\n+            .iter()\n+            .map(|&node_id| {\n+                scx.tcx().map.local_def_id(node_id)\n+            })\n+            .map(|def_id| {\n+                (symbol_for_def_id(scx, def_id, symbol_map),\n+                 export_level(scx, def_id))\n+            })\n+            .collect();\n+\n+        if scx.sess().entry_fn.borrow().is_some() {\n+            local_crate.push((\"main\".to_string(), SymbolExportLevel::C));\n+        }\n+\n+        if let Some(id) = scx.sess().derive_registrar_fn.get() {\n+            let svh = &scx.link_meta().crate_hash;\n+            let def_id = scx.tcx().map.local_def_id(id);\n+            let idx = def_id.index;\n+            let registrar = scx.sess().generate_derive_registrar_symbol(svh, idx);\n+            local_crate.push((registrar, SymbolExportLevel::C));\n+        }\n+\n+        if scx.sess().crate_types.borrow().contains(&config::CrateTypeDylib) {\n+            local_crate.push((scx.metadata_symbol_name(),\n+                              SymbolExportLevel::Rust));\n+        }\n+\n+        let mut exports = FxHashMap();\n+        exports.insert(LOCAL_CRATE, local_crate);\n+\n+        for cnum in scx.sess().cstore.crates() {\n+            debug_assert!(cnum != LOCAL_CRATE);\n+\n+            if scx.sess().cstore.plugin_registrar_fn(cnum).is_some() ||\n+               scx.sess().cstore.derive_registrar_fn(cnum).is_some() {\n+                continue;\n+            }\n+\n+            let crate_exports = scx\n+                .sess()\n+                .cstore\n+                .exported_symbols(cnum)\n+                .iter()\n+                .map(|&def_id| {\n+                    debug!(\"EXTERN-SYMBOL: {:?}\", def_id);\n+                    let name = Instance::mono(scx, def_id).symbol_name(scx);\n+                    (name, export_level(scx, def_id))\n+                })\n+                .collect();\n+\n+            exports.insert(cnum, crate_exports);\n+        }\n+\n+        return ExportedSymbols {\n+            exports: exports\n+        };\n+\n+        fn export_level(scx: &SharedCrateContext,\n+                        sym_def_id: DefId)\n+                        -> SymbolExportLevel {\n+            let attrs = scx.tcx().get_attrs(sym_def_id);\n+            if attr::contains_extern_indicator(scx.sess().diagnostic(), &attrs) {\n+                SymbolExportLevel::C\n+            } else {\n+                SymbolExportLevel::Rust\n+            }\n+        }\n+    }\n+\n+    pub fn exported_symbols(&self,\n+                            cnum: CrateNum)\n+                            -> &[(String, SymbolExportLevel)] {\n+        match self.exports.get(&cnum) {\n+            Some(exports) => &exports[..],\n+            None => &[]\n+        }\n+    }\n+\n+    pub fn for_each_exported_symbol<F>(&self,\n+                                       cnum: CrateNum,\n+                                       export_threshold: SymbolExportLevel,\n+                                       mut f: F)\n+        where F: FnMut(&str, SymbolExportLevel)\n+    {\n+        for &(ref name, export_level) in self.exported_symbols(cnum) {\n+            if is_below_threshold(export_level, export_threshold) {\n+                f(&name[..], export_level)\n+            }\n+        }\n+    }\n+}\n+\n+pub fn crate_export_threshold(crate_type: config::CrateType)\n+                                     -> SymbolExportLevel {\n+    match crate_type {\n+        config::CrateTypeExecutable |\n+        config::CrateTypeStaticlib  |\n+        config::CrateTypeProcMacro  |\n+        config::CrateTypeCdylib     => SymbolExportLevel::C,\n+        config::CrateTypeRlib       |\n+        config::CrateTypeMetadata   |\n+        config::CrateTypeDylib      => SymbolExportLevel::Rust,\n+    }\n+}\n+\n+pub fn crates_export_threshold(crate_types: &[config::CrateType])\n+                                      -> SymbolExportLevel {\n+    if crate_types.iter().any(|&crate_type| {\n+        crate_export_threshold(crate_type) == SymbolExportLevel::Rust\n+    }) {\n+        SymbolExportLevel::Rust\n+    } else {\n+        SymbolExportLevel::C\n+    }\n+}\n+\n+pub fn is_below_threshold(level: SymbolExportLevel,\n+                          threshold: SymbolExportLevel)\n+                          -> bool {\n+    if threshold == SymbolExportLevel::Rust {\n+        // We export everything from Rust dylibs\n+        true\n+    } else {\n+        level == SymbolExportLevel::C\n+    }\n+}\n+\n+fn symbol_for_def_id<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+                               def_id: DefId,\n+                               symbol_map: &SymbolMap<'tcx>)\n+                               -> String {\n+    // Just try to look things up in the symbol map. If nothing's there, we\n+    // recompute.\n+    if let Some(node_id) = scx.tcx().map.as_local_node_id(def_id) {\n+        if let Some(sym) = symbol_map.get(TransItem::Static(node_id)) {\n+            return sym.to_owned();\n+        }\n+    }\n+\n+    let instance = Instance::mono(scx, def_id);\n+\n+    symbol_map.get(TransItem::Fn(instance))\n+              .map(str::to_owned)\n+              .unwrap_or_else(|| instance.symbol_name(scx))\n+}"}, {"sha": "ffab0bde7abde743cff20dce98787caeb0e4df62", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=daf8c1dfce3b448fc581cc319f64632ec22bd0e1", "patch": "@@ -10,6 +10,7 @@\n \n use back::lto;\n use back::link::{get_linker, remove};\n+use back::symbol_export::ExportedSymbols;\n use rustc_incremental::{save_trans_partition, in_incr_comp_dir};\n use session::config::{OutputFilenames, OutputTypes, Passes, SomePasses, AllPasses};\n use session::Session;\n@@ -328,7 +329,7 @@ impl ModuleConfig {\n struct CodegenContext<'a> {\n     // Extra resources used for LTO: (sess, reachable).  This will be `None`\n     // when running in a worker thread.\n-    lto_ctxt: Option<(&'a Session, &'a [String])>,\n+    lto_ctxt: Option<(&'a Session, &'a ExportedSymbols)>,\n     // Handler to use for diagnostics produced during codegen.\n     handler: &'a Handler,\n     // LLVM passes added by plugins.\n@@ -343,9 +344,11 @@ struct CodegenContext<'a> {\n }\n \n impl<'a> CodegenContext<'a> {\n-    fn new_with_session(sess: &'a Session, reachable: &'a [String]) -> CodegenContext<'a> {\n+    fn new_with_session(sess: &'a Session,\n+                        exported_symbols: &'a ExportedSymbols)\n+                        -> CodegenContext<'a> {\n         CodegenContext {\n-            lto_ctxt: Some((sess, reachable)),\n+            lto_ctxt: Some((sess, exported_symbols)),\n             handler: sess.diagnostic(),\n             plugin_passes: sess.plugin_llvm_passes.borrow().clone(),\n             remark: sess.opts.cg.remark.clone(),\n@@ -516,14 +519,14 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         llvm::LLVMDisposePassManager(mpm);\n \n         match cgcx.lto_ctxt {\n-            Some((sess, reachable)) if sess.lto() =>  {\n+            Some((sess, exported_symbols)) if sess.lto() =>  {\n                 time(sess.time_passes(), \"all lto passes\", || {\n                     let temp_no_opt_bc_filename =\n                         output_names.temp_path_ext(\"no-opt.lto.bc\", module_name);\n                     lto::run(sess,\n                              llmod,\n                              tm,\n-                             reachable,\n+                             exported_symbols,\n                              &config,\n                              &temp_no_opt_bc_filename);\n                 });\n@@ -753,7 +756,7 @@ pub fn run_passes(sess: &Session,\n     //       potentially create hundreds of them).\n     let num_workers = work_items.len() - 1;\n     if num_workers == 1 {\n-        run_work_singlethreaded(sess, &trans.reachable, work_items);\n+        run_work_singlethreaded(sess, &trans.exported_symbols, work_items);\n     } else {\n         run_work_multithreaded(sess, work_items, num_workers);\n     }\n@@ -997,9 +1000,9 @@ fn execute_work_item(cgcx: &CodegenContext,\n }\n \n fn run_work_singlethreaded(sess: &Session,\n-                           reachable: &[String],\n+                           exported_symbols: &ExportedSymbols,\n                            work_items: Vec<WorkItem>) {\n-    let cgcx = CodegenContext::new_with_session(sess, reachable);\n+    let cgcx = CodegenContext::new_with_session(sess, exported_symbols);\n \n     // Since we're running single-threaded, we can pass the session to\n     // the proc, allowing `optimize_and_codegen` to perform LTO."}, {"sha": "a31b61e42c440a2434c0433a4eacc55dc25be3e4", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 103, "deletions": 123, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=daf8c1dfce3b448fc581cc319f64632ec22bd0e1", "patch": "@@ -33,10 +33,10 @@ use super::ModuleTranslation;\n use assert_module_sources;\n use back::link;\n use back::linker::LinkerInfo;\n+use back::symbol_export::{self, ExportedSymbols};\n use llvm::{Linkage, ValueRef, Vector, get_param};\n use llvm;\n-use rustc::hir::def::Def;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n use rustc::ty::subst::Substs;\n use rustc::traits;\n@@ -84,7 +84,6 @@ use util::nodemap::{NodeSet, FxHashMap, FxHashSet};\n use arena::TypedArena;\n use libc::c_uint;\n use std::ffi::{CStr, CString};\n-use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n use std::ptr;\n use std::rc::Rc;\n@@ -1243,7 +1242,7 @@ fn contains_null(s: &str) -> bool {\n }\n \n fn write_metadata(cx: &SharedCrateContext,\n-                  reachable_ids: &NodeSet) -> Vec<u8> {\n+                  exported_symbols: &NodeSet) -> Vec<u8> {\n     use flate;\n \n     #[derive(PartialEq, Eq, PartialOrd, Ord)]\n@@ -1275,7 +1274,7 @@ fn write_metadata(cx: &SharedCrateContext,\n     let metadata = cstore.encode_metadata(cx.tcx(),\n                                           cx.export_map(),\n                                           cx.link_meta(),\n-                                          reachable_ids);\n+                                          exported_symbols);\n     if kind == MetadataKind::Uncompressed {\n         return metadata;\n     }\n@@ -1313,51 +1312,67 @@ fn write_metadata(cx: &SharedCrateContext,\n fn internalize_symbols<'a, 'tcx>(sess: &Session,\n                                  ccxs: &CrateContextList<'a, 'tcx>,\n                                  symbol_map: &SymbolMap<'tcx>,\n-                                 reachable: &FxHashSet<&str>) {\n+                                 exported_symbols: &ExportedSymbols) {\n+    let export_threshold =\n+        symbol_export::crates_export_threshold(&sess.crate_types.borrow()[..]);\n+\n+    let exported_symbols = exported_symbols\n+        .exported_symbols(LOCAL_CRATE)\n+        .iter()\n+        .filter(|&&(_, export_level)| {\n+            symbol_export::is_below_threshold(export_level, export_threshold)\n+        })\n+        .map(|&(ref name, _)| &name[..])\n+        .collect::<FxHashSet<&str>>();\n+\n     let scx = ccxs.shared();\n     let tcx = scx.tcx();\n \n-    // In incr. comp. mode, we can't necessarily see all refs since we\n-    // don't generate LLVM IR for reused modules, so skip this\n-    // step. Later we should get smarter.\n-    if sess.opts.debugging_opts.incremental.is_some() {\n-        return;\n-    }\n+    let incr_comp = sess.opts.debugging_opts.incremental.is_some();\n \n     // 'unsafe' because we are holding on to CStr's from the LLVM module within\n     // this block.\n     unsafe {\n         let mut referenced_somewhere = FxHashSet();\n \n         // Collect all symbols that need to stay externally visible because they\n-        // are referenced via a declaration in some other codegen unit.\n-        for ccx in ccxs.iter_need_trans() {\n-            for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n-                let linkage = llvm::LLVMRustGetLinkage(val);\n-                // We only care about external declarations (not definitions)\n-                // and available_externally definitions.\n-                let is_available_externally = linkage == llvm::Linkage::AvailableExternallyLinkage;\n-                let is_decl = llvm::LLVMIsDeclaration(val) != 0;\n-\n-                if is_decl || is_available_externally {\n-                    let symbol_name = CStr::from_ptr(llvm::LLVMGetValueName(val));\n-                    referenced_somewhere.insert(symbol_name);\n+        // are referenced via a declaration in some other codegen unit. In\n+        // incremental compilation, we don't need to collect. See below for more\n+        // information.\n+        if !incr_comp {\n+            for ccx in ccxs.iter_need_trans() {\n+                for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n+                    let linkage = llvm::LLVMRustGetLinkage(val);\n+                    // We only care about external declarations (not definitions)\n+                    // and available_externally definitions.\n+                    let is_available_externally =\n+                        linkage == llvm::Linkage::AvailableExternallyLinkage;\n+                    let is_decl = llvm::LLVMIsDeclaration(val) == llvm::True;\n+\n+                    if is_decl || is_available_externally {\n+                        let symbol_name = CStr::from_ptr(llvm::LLVMGetValueName(val));\n+                        referenced_somewhere.insert(symbol_name);\n+                    }\n                 }\n             }\n         }\n \n         // Also collect all symbols for which we cannot adjust linkage, because\n-        // it is fixed by some directive in the source code (e.g. #[no_mangle]).\n-        let linkage_fixed_explicitly: FxHashSet<_> = scx\n-            .translation_items()\n-            .borrow()\n-            .iter()\n-            .cloned()\n-            .filter(|trans_item|{\n-                trans_item.explicit_linkage(tcx).is_some()\n-            })\n-            .map(|trans_item| symbol_map.get_or_compute(scx, trans_item))\n-            .collect();\n+        // it is fixed by some directive in the source code.\n+        let (locally_defined_symbols, linkage_fixed_explicitly) = {\n+            let mut locally_defined_symbols = FxHashSet();\n+            let mut linkage_fixed_explicitly = FxHashSet();\n+\n+            for trans_item in scx.translation_items().borrow().iter() {\n+                let symbol_name = symbol_map.get_or_compute(scx, *trans_item);\n+                if trans_item.explicit_linkage(tcx).is_some() {\n+                    linkage_fixed_explicitly.insert(symbol_name.clone());\n+                }\n+                locally_defined_symbols.insert(symbol_name);\n+            }\n+\n+            (locally_defined_symbols, linkage_fixed_explicitly)\n+        };\n \n         // Examine each external definition.  If the definition is not used in\n         // any other compilation unit, and is not reachable from other crates,\n@@ -1369,23 +1384,46 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n                 let is_externally_visible = (linkage == llvm::Linkage::ExternalLinkage) ||\n                                             (linkage == llvm::Linkage::LinkOnceODRLinkage) ||\n                                             (linkage == llvm::Linkage::WeakODRLinkage);\n-                let is_definition = llvm::LLVMIsDeclaration(val) == 0;\n-\n-                // If this is a definition (as opposed to just a declaration)\n-                // and externally visible, check if we can internalize it\n-                if is_definition && is_externally_visible {\n-                    let name_cstr = CStr::from_ptr(llvm::LLVMGetValueName(val));\n-                    let name_str = name_cstr.to_str().unwrap();\n-                    let name_cow = Cow::Borrowed(name_str);\n-\n-                    let is_referenced_somewhere = referenced_somewhere.contains(&name_cstr);\n-                    let is_reachable = reachable.contains(&name_str);\n-                    let has_fixed_linkage = linkage_fixed_explicitly.contains(&name_cow);\n-\n-                    if !is_referenced_somewhere && !is_reachable && !has_fixed_linkage {\n-                        llvm::LLVMRustSetLinkage(val, llvm::Linkage::InternalLinkage);\n-                        llvm::LLVMSetDLLStorageClass(val,\n-                                                     llvm::DLLStorageClass::Default);\n+\n+                if !is_externally_visible {\n+                    // This symbol is not visible outside of its codegen unit,\n+                    // so there is nothing to do for it.\n+                    continue;\n+                }\n+\n+                let name_cstr = CStr::from_ptr(llvm::LLVMGetValueName(val));\n+                let name_str = name_cstr.to_str().unwrap();\n+\n+                if exported_symbols.contains(&name_str) {\n+                    // This symbol is explicitly exported, so we can't\n+                    // mark it as internal or hidden.\n+                    continue;\n+                }\n+\n+                let is_declaration = llvm::LLVMIsDeclaration(val) == llvm::True;\n+\n+                if is_declaration {\n+                    if locally_defined_symbols.contains(name_str) {\n+                        // Only mark declarations from the current crate as hidden.\n+                        // Otherwise we would mark things as hidden that are\n+                        // imported from other crates or native libraries.\n+                        llvm::LLVMRustSetVisibility(val, llvm::Visibility::Hidden);\n+                    }\n+                } else {\n+                    let has_fixed_linkage = linkage_fixed_explicitly.contains(name_str);\n+\n+                    if !has_fixed_linkage {\n+                        // In incremental compilation mode, we can't be sure that\n+                        // we saw all references because we don't know what's in\n+                        // cached compilation units, so we always assume that the\n+                        // given item has been referenced.\n+                        if incr_comp || referenced_somewhere.contains(&name_cstr) {\n+                            llvm::LLVMRustSetVisibility(val, llvm::Visibility::Hidden);\n+                        } else {\n+                            llvm::LLVMRustSetLinkage(val, llvm::Linkage::InternalLinkage);\n+                        }\n+\n+                        llvm::LLVMSetDLLStorageClass(val, llvm::DLLStorageClass::Default);\n                         llvm::UnsetComdat(val);\n                     }\n                 }\n@@ -1481,7 +1519,7 @@ fn iter_functions(llmod: llvm::ModuleRef) -> ValueIter {\n ///\n /// This list is later used by linkers to determine the set of symbols needed to\n /// be exposed from a dynamic library and it's also encoded into the metadata.\n-pub fn filter_reachable_ids(tcx: TyCtxt, reachable: NodeSet) -> NodeSet {\n+pub fn find_exported_symbols(tcx: TyCtxt, reachable: NodeSet) -> NodeSet {\n     reachable.into_iter().filter(|&id| {\n         // Next, we want to ignore some FFI functions that are not exposed from\n         // this crate. Reachable FFI functions can be lumped into two\n@@ -1535,7 +1573,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let krate = tcx.map.krate();\n \n     let ty::CrateAnalysis { export_map, reachable, name, .. } = analysis;\n-    let reachable = filter_reachable_ids(tcx, reachable);\n+    let exported_symbols = find_exported_symbols(tcx, reachable);\n \n     let check_overflow = if let Some(v) = tcx.sess.opts.debugging_opts.force_overflow_checks {\n         v\n@@ -1548,11 +1586,11 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let shared_ccx = SharedCrateContext::new(tcx,\n                                              export_map,\n                                              link_meta.clone(),\n-                                             reachable,\n+                                             exported_symbols,\n                                              check_overflow);\n     // Translate the metadata.\n     let metadata = time(tcx.sess.time_passes(), \"write metadata\", || {\n-        write_metadata(&shared_ccx, shared_ccx.reachable())\n+        write_metadata(&shared_ccx, shared_ccx.exported_symbols())\n     });\n \n     let metadata_module = ModuleTranslation {\n@@ -1602,13 +1640,13 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Skip crate items and just output metadata in -Z no-trans mode.\n     if tcx.sess.opts.debugging_opts.no_trans ||\n        tcx.sess.crate_types.borrow().iter().all(|ct| ct == &config::CrateTypeMetadata) {\n-        let linker_info = LinkerInfo::new(&shared_ccx, &[]);\n+        let linker_info = LinkerInfo::new(&shared_ccx, &ExportedSymbols::empty());\n         return CrateTranslation {\n             modules: modules,\n             metadata_module: metadata_module,\n             link: link_meta,\n             metadata: metadata,\n-            reachable: vec![],\n+            exported_symbols: ExportedSymbols::empty(),\n             no_builtins: no_builtins,\n             linker_info: linker_info,\n             windows_subsystem: None,\n@@ -1688,56 +1726,17 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     let sess = shared_ccx.sess();\n-    let mut reachable_symbols = shared_ccx.reachable().iter().map(|&id| {\n-        let def_id = shared_ccx.tcx().map.local_def_id(id);\n-        symbol_for_def_id(def_id, &shared_ccx, &symbol_map)\n-    }).collect::<Vec<_>>();\n-\n-    if sess.entry_fn.borrow().is_some() {\n-        reachable_symbols.push(\"main\".to_string());\n-    }\n-\n-    if sess.crate_types.borrow().contains(&config::CrateTypeDylib) {\n-        reachable_symbols.push(shared_ccx.metadata_symbol_name());\n-    }\n \n-    // For the purposes of LTO or when creating a cdylib, we add to the\n-    // reachable set all of the upstream reachable extern fns. These functions\n-    // are all part of the public ABI of the final product, so we need to\n-    // preserve them.\n-    //\n-    // Note that this happens even if LTO isn't requested or we're not creating\n-    // a cdylib. In those cases, though, we're not even reading the\n-    // `reachable_symbols` list later on so it should be ok.\n-    for cnum in sess.cstore.crates() {\n-        let syms = sess.cstore.reachable_ids(cnum);\n-        reachable_symbols.extend(syms.into_iter().filter(|&def_id| {\n-            let applicable = match sess.cstore.describe_def(def_id) {\n-                Some(Def::Static(..)) => true,\n-                Some(Def::Fn(_)) => {\n-                    shared_ccx.tcx().item_generics(def_id).types.is_empty()\n-                }\n-                _ => false\n-            };\n-\n-            if applicable {\n-                let attrs = shared_ccx.tcx().get_attrs(def_id);\n-                attr::contains_extern_indicator(sess.diagnostic(), &attrs)\n-            } else {\n-                false\n-            }\n-        }).map(|did| {\n-            symbol_for_def_id(did, &shared_ccx, &symbol_map)\n-        }));\n-    }\n+    let exported_symbols = ExportedSymbols::compute_from(&shared_ccx,\n+                                                         &symbol_map);\n \n+    // Now that we have all symbols that are exported from the CGUs of this\n+    // crate, we can run the `internalize_symbols` pass.\n     time(shared_ccx.sess().time_passes(), \"internalize symbols\", || {\n         internalize_symbols(sess,\n                             &crate_context_list,\n                             &symbol_map,\n-                            &reachable_symbols.iter()\n-                                              .map(|s| &s[..])\n-                                              .collect())\n+                            &exported_symbols);\n     });\n \n     if tcx.sess.opts.debugging_opts.print_type_sizes {\n@@ -1749,7 +1748,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         create_imps(&crate_context_list);\n     }\n \n-    let linker_info = LinkerInfo::new(&shared_ccx, &reachable_symbols);\n+    let linker_info = LinkerInfo::new(&shared_ccx, &exported_symbols);\n \n     let subsystem = attr::first_attr_value_str_by_name(&krate.attrs,\n                                                        \"windows_subsystem\");\n@@ -1767,7 +1766,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         metadata_module: metadata_module,\n         link: link_meta,\n         metadata: metadata,\n-        reachable: reachable_symbols,\n+        exported_symbols: exported_symbols,\n         no_builtins: no_builtins,\n         linker_info: linker_info,\n         windows_subsystem: windows_subsystem,\n@@ -2107,22 +2106,3 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n \n     (codegen_units, symbol_map)\n }\n-\n-fn symbol_for_def_id<'a, 'tcx>(def_id: DefId,\n-                               scx: &SharedCrateContext<'a, 'tcx>,\n-                               symbol_map: &SymbolMap<'tcx>)\n-                               -> String {\n-    // Just try to look things up in the symbol map. If nothing's there, we\n-    // recompute.\n-    if let Some(node_id) = scx.tcx().map.as_local_node_id(def_id) {\n-        if let Some(sym) = symbol_map.get(TransItem::Static(node_id)) {\n-            return sym.to_owned();\n-        }\n-    }\n-\n-    let instance = Instance::mono(scx, def_id);\n-\n-    symbol_map.get(TransItem::Fn(instance))\n-              .map(str::to_owned)\n-              .unwrap_or_else(|| instance.symbol_name(scx))\n-}"}, {"sha": "262b83623977c6ccaccbfc962f6f003ceb0dcdc2", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=daf8c1dfce3b448fc581cc319f64632ec22bd0e1", "patch": "@@ -67,7 +67,7 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n     metadata_llcx: ContextRef,\n \n     export_map: ExportMap,\n-    reachable: NodeSet,\n+    exported_symbols: NodeSet,\n     link_meta: LinkMeta,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     stats: Stats,\n@@ -437,7 +437,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     pub fn new(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n                export_map: ExportMap,\n                link_meta: LinkMeta,\n-               reachable: NodeSet,\n+               exported_symbols: NodeSet,\n                check_overflow: bool)\n                -> SharedCrateContext<'b, 'tcx> {\n         let (metadata_llcx, metadata_llmod) = unsafe {\n@@ -454,7 +454,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         // they're not available to be linked against. This poses a few problems\n         // for the compiler, some of which are somewhat fundamental, but we use\n         // the `use_dll_storage_attrs` variable below to attach the `dllexport`\n-        // attribute to all LLVM functions that are reachable (e.g. they're\n+        // attribute to all LLVM functions that are exported e.g. they're\n         // already tagged with external linkage). This is suboptimal for a few\n         // reasons:\n         //\n@@ -493,7 +493,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n             metadata_llmod: metadata_llmod,\n             metadata_llcx: metadata_llcx,\n             export_map: export_map,\n-            reachable: reachable,\n+            exported_symbols: exported_symbols,\n             link_meta: link_meta,\n             tcx: tcx,\n             stats: Stats {\n@@ -527,8 +527,8 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         &self.export_map\n     }\n \n-    pub fn reachable<'a>(&'a self) -> &'a NodeSet {\n-        &self.reachable\n+    pub fn exported_symbols<'a>(&'a self) -> &'a NodeSet {\n+        &self.exported_symbols\n     }\n \n     pub fn trait_cache(&self) -> &RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>> {\n@@ -768,8 +768,8 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.shared.export_map\n     }\n \n-    pub fn reachable<'a>(&'a self) -> &'a NodeSet {\n-        &self.shared.reachable\n+    pub fn exported_symbols<'a>(&'a self) -> &'a NodeSet {\n+        &self.shared.exported_symbols\n     }\n \n     pub fn link_meta<'a>(&'a self) -> &'a LinkMeta {"}, {"sha": "3ee2497009f6513135438a7bb31ccd1bf75d683e", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=daf8c1dfce3b448fc581cc319f64632ec22bd0e1", "patch": "@@ -34,7 +34,7 @@ pub fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n     // visible). It might better to use the `exported_items` set from\n     // `driver::CrateAnalysis` in the future, but (atm) this set is not\n     // available in the translation pass.\n-    !cx.reachable().contains(&node_id)\n+    !cx.exported_symbols().contains(&node_id)\n }\n \n #[allow(non_snake_case)]"}, {"sha": "eef3b9b11474bee1d9c6e2fc052ebdf437435834", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=daf8c1dfce3b448fc581cc319f64632ec22bd0e1", "patch": "@@ -78,7 +78,7 @@ fn declare_raw_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty:\n     // don't want the symbols to get exported.\n     if attr::contains_name(ccx.tcx().map.krate_attrs(), \"compiler_builtins\") {\n         unsafe {\n-            llvm::LLVMSetVisibility(llfn, llvm::Visibility::Hidden);\n+            llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n         }\n     }\n "}, {"sha": "e2da635b1592ae3ac1992f83e25fdbb95eb102a3", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=daf8c1dfce3b448fc581cc319f64632ec22bd0e1", "patch": "@@ -78,6 +78,7 @@ pub mod back {\n     pub mod linker;\n     pub mod link;\n     pub mod lto;\n+    pub mod symbol_export;\n     pub mod symbol_names;\n     pub mod write;\n     pub mod msvc;\n@@ -169,7 +170,7 @@ pub struct CrateTranslation {\n     pub metadata_module: ModuleTranslation,\n     pub link: middle::cstore::LinkMeta,\n     pub metadata: Vec<u8>,\n-    pub reachable: Vec<String>,\n+    pub exported_symbols: back::symbol_export::ExportedSymbols,\n     pub no_builtins: bool,\n     pub windows_subsystem: Option<String>,\n     pub linker_info: back::linker::LinkerInfo"}, {"sha": "6a95b65d5e92f66e704e42ec3f0ec87e3d1be6a0", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=daf8c1dfce3b448fc581cc319f64632ec22bd0e1", "patch": "@@ -1408,3 +1408,45 @@ extern \"C\" void LLVMRustSetLinkage(LLVMValueRef V, LLVMRustLinkage RustLinkage)\n extern \"C\" LLVMContextRef LLVMRustGetValueContext(LLVMValueRef V) {\n     return wrap(&unwrap(V)->getContext());\n }\n+\n+enum class LLVMRustVisibility {\n+    Default = 0,\n+    Hidden = 1,\n+    Protected = 2,\n+};\n+\n+static LLVMRustVisibility to_rust(LLVMVisibility vis) {\n+    switch (vis) {\n+        case LLVMDefaultVisibility:\n+            return LLVMRustVisibility::Default;\n+        case LLVMHiddenVisibility:\n+            return LLVMRustVisibility::Hidden;\n+        case LLVMProtectedVisibility:\n+            return LLVMRustVisibility::Protected;\n+\n+        default:\n+            llvm_unreachable(\"Invalid LLVMRustVisibility value!\");\n+    }\n+}\n+\n+static LLVMVisibility from_rust(LLVMRustVisibility vis) {\n+    switch (vis) {\n+        case LLVMRustVisibility::Default:\n+            return LLVMDefaultVisibility;\n+        case LLVMRustVisibility::Hidden:\n+            return LLVMHiddenVisibility;\n+        case LLVMRustVisibility::Protected:\n+            return LLVMProtectedVisibility;\n+\n+        default:\n+            llvm_unreachable(\"Invalid LLVMRustVisibility value!\");\n+    }\n+}\n+\n+extern \"C\" LLVMRustVisibility LLVMRustGetVisibility(LLVMValueRef V) {\n+    return to_rust(LLVMGetVisibility(V));\n+}\n+\n+extern \"C\" void LLVMRustSetVisibility(LLVMValueRef V, LLVMRustVisibility RustVisibility) {\n+    LLVMSetVisibility(V, from_rust(RustVisibility));\n+}"}, {"sha": "720dfff2c0438cefaa1e7815daf04e9f4be4ed80", "filename": "src/test/run-make/sepcomp-inlining/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Ftest%2Frun-make%2Fsepcomp-inlining%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Ftest%2Frun-make%2Fsepcomp-inlining%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsepcomp-inlining%2FMakefile?ref=daf8c1dfce3b448fc581cc319f64632ec22bd0e1", "patch": "@@ -10,5 +10,5 @@ all:\n \t$(RUSTC) foo.rs --emit=llvm-ir -C codegen-units=3\n \t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c define\\ i32\\ .*inlined)\" -eq \"0\" ]\n \t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c define\\ internal\\ i32\\ .*inlined)\" -eq \"2\" ]\n-\t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c define\\ i32\\ .*normal)\" -eq \"1\" ]\n-\t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c declare\\ i32\\ .*normal)\" -eq \"2\" ]\n+\t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c define\\ hidden\\ i32\\ .*normal)\" -eq \"1\" ]\n+\t[ \"$$(cat \"$(TMPDIR)\"/foo.?.ll | grep -c declare\\ hidden\\ i32\\ .*normal)\" -eq \"2\" ]"}, {"sha": "988c9473f6a7ef89af7eebc5e6be6d8373a248e6", "filename": "src/test/run-make/symbol-visibility/Makefile", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Ftest%2Frun-make%2Fsymbol-visibility%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Ftest%2Frun-make%2Fsymbol-visibility%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsymbol-visibility%2FMakefile?ref=daf8c1dfce3b448fc581cc319f64632ec22bd0e1", "patch": "@@ -0,0 +1,50 @@\n+include ../tools.mk\n+\n+ifdef IS_WINDOWS\n+# Do nothing on MSVC.\n+# On MINGW the --version-script, --dynamic-list, and --retain-symbol args don't\n+# seem to work reliably.\n+all:\n+\texit 0\n+else\n+\n+NM=nm -D\n+DYLIB_EXT=so\n+CDYLIB_NAME=liba_cdylib.so\n+RDYLIB_NAME=liba_rust_dylib.so\n+EXE_NAME=an_executable\n+\n+ifeq ($(UNAME),Darwin)\n+NM=nm -gU\n+DYLIB_EXT=dylib\n+CDYLIB_NAME=liba_cdylib.dylib\n+RDYLIB_NAME=liba_rust_dylib.dylib\n+EXE_NAME=an_executable\n+endif\n+\n+all:\n+\t$(RUSTC) an_rlib.rs\n+\t$(RUSTC) a_cdylib.rs\n+\t$(RUSTC) a_rust_dylib.rs\n+\t$(RUSTC) an_executable.rs\n+\n+\t# Check that a cdylib exports its public #[no_mangle] functions\n+\t[ \"$$($(NM) $(TMPDIR)/$(CDYLIB_NAME) | grep -c public_c_function_from_cdylib)\" -eq \"1\" ]\n+\t# Check that a cdylib exports the public #[no_mangle] functions of dependencies\n+\t[ \"$$($(NM) $(TMPDIR)/$(CDYLIB_NAME) | grep -c public_c_function_from_rlib)\" -eq \"1\" ]\n+\t# Check that a cdylib DOES NOT export any public Rust functions\n+\t[ \"$$($(NM) $(TMPDIR)/$(CDYLIB_NAME) | grep -c _ZN.*h.*E)\" -eq \"0\" ]\n+\n+\t# Check that a Rust dylib exports its monomorphic functions\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_c_function_from_rust_dylib)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c _ZN.*public_rust_function_from_rust_dylib.*E)\" -eq \"1\" ]\n+\n+\t# Check that a Rust dylib exports the monomorphic functions from its dependencies\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_c_function_from_rlib)\" -eq \"1\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(RDYLIB_NAME) | grep -c public_rust_function_from_rlib)\" -eq \"1\" ]\n+\n+\t# Check that an executable does not export any dynamic symbols\n+\t[ \"$$($(NM) $(TMPDIR)/$(EXE_NAME) | grep -c public_c_function_from_rlib)\" -eq \"0\" ]\n+\t[ \"$$($(NM) $(TMPDIR)/$(EXE_NAME) | grep -c public_rust_function_from_exe)\" -eq \"0\" ]\n+\n+endif"}, {"sha": "9a70542c06ca726c38bcfe097064430d32227573", "filename": "src/test/run-make/symbol-visibility/a_cdylib.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Ftest%2Frun-make%2Fsymbol-visibility%2Fa_cdylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Ftest%2Frun-make%2Fsymbol-visibility%2Fa_cdylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsymbol-visibility%2Fa_cdylib.rs?ref=daf8c1dfce3b448fc581cc319f64632ec22bd0e1", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type=\"cdylib\"]\n+\n+extern crate an_rlib;\n+\n+// This should not be exported\n+pub fn public_rust_function_from_cdylib() {}\n+\n+// This should be exported\n+#[no_mangle]\n+pub extern \"C\" fn public_c_function_from_cdylib() {\n+    an_rlib::public_c_function_from_rlib();\n+}"}, {"sha": "b826211c9a42afab0b1aefc0161b1e37ace56d88", "filename": "src/test/run-make/symbol-visibility/a_rust_dylib.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Ftest%2Frun-make%2Fsymbol-visibility%2Fa_rust_dylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Ftest%2Frun-make%2Fsymbol-visibility%2Fa_rust_dylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsymbol-visibility%2Fa_rust_dylib.rs?ref=daf8c1dfce3b448fc581cc319f64632ec22bd0e1", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type=\"dylib\"]\n+\n+extern crate an_rlib;\n+\n+// This should be exported\n+pub fn public_rust_function_from_rust_dylib() {}\n+\n+// This should be exported\n+#[no_mangle]\n+pub extern \"C\" fn public_c_function_from_rust_dylib() {}"}, {"sha": "73059c5e374f2da24a68e9b1454079048bb617ba", "filename": "src/test/run-make/symbol-visibility/an_executable.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Ftest%2Frun-make%2Fsymbol-visibility%2Fan_executable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Ftest%2Frun-make%2Fsymbol-visibility%2Fan_executable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsymbol-visibility%2Fan_executable.rs?ref=daf8c1dfce3b448fc581cc319f64632ec22bd0e1", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type=\"bin\"]\n+\n+extern crate an_rlib;\n+\n+pub fn public_rust_function_from_exe() {}\n+\n+fn main() {}"}, {"sha": "cd19500d14021f0e253fb75067c5caf4b20084a0", "filename": "src/test/run-make/symbol-visibility/an_rlib.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Ftest%2Frun-make%2Fsymbol-visibility%2Fan_rlib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daf8c1dfce3b448fc581cc319f64632ec22bd0e1/src%2Ftest%2Frun-make%2Fsymbol-visibility%2Fan_rlib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsymbol-visibility%2Fan_rlib.rs?ref=daf8c1dfce3b448fc581cc319f64632ec22bd0e1", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type=\"rlib\"]\n+\n+pub fn public_rust_function_from_rlib() {}\n+\n+#[no_mangle]\n+pub extern \"C\" fn public_c_function_from_rlib() {}"}]}