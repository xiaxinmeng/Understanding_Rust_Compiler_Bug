{"sha": "2a106d68f4987733b150e4a8b2f8be209ab6ae14", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhMTA2ZDY4ZjQ5ODc3MzNiMTUwZTRhOGIyZjhiZTIwOWFiNmFlMTQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-18T15:02:54Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-18T16:51:09Z"}, "message": "Rollup merge of #23428 - Manishearth:ast-doc, r=huon\n\n I often have to run `ast-json` or look into the pretty-printer source to figure out what the fields of an AST enum mean. I've tried to document most of what I know (and some semi-obvious stuff).\n\nr? @steveklabnik\n\nf? @eddyb", "tree": {"sha": "1ead2554c428c121991282ebeae87f6609c729b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ead2554c428c121991282ebeae87f6609c729b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a106d68f4987733b150e4a8b2f8be209ab6ae14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a106d68f4987733b150e4a8b2f8be209ab6ae14", "html_url": "https://github.com/rust-lang/rust/commit/2a106d68f4987733b150e4a8b2f8be209ab6ae14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a106d68f4987733b150e4a8b2f8be209ab6ae14/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e245e65ef8ddb8c047cafcd3d0c30f427a33e6c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e245e65ef8ddb8c047cafcd3d0c30f427a33e6c4", "html_url": "https://github.com/rust-lang/rust/commit/e245e65ef8ddb8c047cafcd3d0c30f427a33e6c4"}, {"sha": "a5828ff7b0203ac378974c2d30ed94a14073895a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5828ff7b0203ac378974c2d30ed94a14073895a", "html_url": "https://github.com/rust-lang/rust/commit/a5828ff7b0203ac378974c2d30ed94a14073895a"}], "stats": {"total": 172, "additions": 157, "deletions": 15}, "files": [{"sha": "5c2757153521c3f024c9412fc8dd677e24f1d471", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 157, "deletions": 15, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/2a106d68f4987733b150e4a8b2f8be209ab6ae14/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a106d68f4987733b150e4a8b2f8be209ab6ae14/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=2a106d68f4987733b150e4a8b2f8be209ab6ae14", "patch": "@@ -150,7 +150,7 @@ impl PartialEq for Ident {\n \n /// A SyntaxContext represents a chain of macro-expandings\n /// and renamings. Each macro expansion corresponds to\n-/// a fresh usize\n+/// a fresh u32\n \n // I'm representing this syntax context as an index into\n // a table, in order to work around a compiler bug\n@@ -216,6 +216,7 @@ pub struct Lifetime {\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+/// A lifetime definition, eg `'a: 'b+'c+'d`\n pub struct LifetimeDef {\n     pub lifetime: Lifetime,\n     pub bounds: Vec<Lifetime>\n@@ -251,7 +252,9 @@ pub struct PathSegment {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum PathParameters {\n+    /// The `<'a, A,B,C>` in `foo::bar::baz::<'a, A,B,C>`\n     AngleBracketedParameters(AngleBracketedParameterData),\n+    /// The `(A,B)` and `C` in `Foo(A,B) -> C`\n     ParenthesizedParameters(ParenthesizedParameterData),\n }\n \n@@ -436,34 +439,45 @@ impl Generics {\n     }\n }\n \n+/// A `where` clause in a definition\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereClause {\n     pub id: NodeId,\n     pub predicates: Vec<WherePredicate>,\n }\n \n+/// A single predicate in a `where` clause\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum WherePredicate {\n+    /// A type binding, eg `for<'c> Foo: Send+Clone+'c`\n     BoundPredicate(WhereBoundPredicate),\n+    /// A lifetime predicate, e.g. `'a: 'b+'c`\n     RegionPredicate(WhereRegionPredicate),\n+    /// An equality predicate (unsupported)\n     EqPredicate(WhereEqPredicate)\n }\n \n+/// A type bound, eg `for<'c> Foo: Send+Clone+'c`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereBoundPredicate {\n     pub span: Span,\n+    /// Any lifetimes from a `for` binding\n     pub bound_lifetimes: Vec<LifetimeDef>,\n+    /// The type being bounded\n     pub bounded_ty: P<Ty>,\n+    /// Trait and lifetime bounds (`Clone+Send+'static`)\n     pub bounds: OwnedSlice<TyParamBound>,\n }\n \n+/// A lifetime predicate, e.g. `'a: 'b+'c`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereRegionPredicate {\n     pub span: Span,\n     pub lifetime: Lifetime,\n     pub bounds: Vec<Lifetime>,\n }\n \n+/// An equality predicate (unsupported), e.g. `T=int`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereEqPredicate {\n     pub id: NodeId,\n@@ -521,9 +535,13 @@ impl PartialEq for MetaItem_ {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Block {\n+    /// Statements in a block\n     pub stmts: Vec<P<Stmt>>,\n+    /// An expression at the end of the block\n+    /// without a semicolon, if any\n     pub expr: Option<P<Expr>>,\n     pub id: NodeId,\n+    /// Distinguishes between `unsafe { ... }` and `{ ... }`\n     pub rules: BlockCheckMode,\n     pub span: Span,\n }\n@@ -535,9 +553,16 @@ pub struct Pat {\n     pub span: Span,\n }\n \n+/// A single field in a struct pattern\n+///\n+/// Patterns like the fields of Foo `{ x, ref y, ref mut z }`\n+/// are treated the same as` x: x, y: ref y, z: ref mut z`,\n+/// except is_shorthand is true\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct FieldPat {\n+    /// The identifier for the field\n     pub ident: Ident,\n+    /// The pattern the field is destructured to\n     pub pat: P<Pat>,\n     pub is_shorthand: bool,\n }\n@@ -574,15 +599,23 @@ pub enum Pat_ {\n     /// \"None\" means a * pattern where we don't bind the fields to names.\n     PatEnum(Path, Option<Vec<P<Pat>>>),\n \n+    /// Destructuring of a struct, e.g. `Foo {x, y, ..}`\n+    /// The `bool` is `true` in the presence of a `..`\n     PatStruct(Path, Vec<Spanned<FieldPat>>, bool),\n+    /// A tuple pattern `(a, b)`\n     PatTup(Vec<P<Pat>>),\n+    /// A `box` pattern\n     PatBox(P<Pat>),\n-    PatRegion(P<Pat>, Mutability), // reference pattern\n+    /// A reference pattern, e.g. `&mut (a, b)`\n+    PatRegion(P<Pat>, Mutability),\n+    /// A literal\n     PatLit(P<Expr>),\n+    /// A range pattern, e.g. `1...2`\n     PatRange(P<Expr>, P<Expr>),\n     /// [a, b, ..i, y, z] is represented as:\n     ///     PatVec(box [a, b], Some(i), box [y, z])\n     PatVec(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n+    /// A macro pattern; pre-expansion\n     PatMac(Mac),\n }\n \n@@ -594,36 +627,59 @@ pub enum Mutability {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum BinOp_ {\n+    /// The `+` operator (addition)\n     BiAdd,\n+    /// The `-` operator (subtraction)\n     BiSub,\n+    /// The `*` operator (multiplication)\n     BiMul,\n+    /// The `/` operator (division)\n     BiDiv,\n+    /// The `%` operator (modulus)\n     BiRem,\n+    /// The `&&` operator (logical and)\n     BiAnd,\n+    /// The `||` operator (logical or)\n     BiOr,\n+    /// The `^` operator (bitwise xor)\n     BiBitXor,\n+    /// The `&` operator (bitwise and)\n     BiBitAnd,\n+    /// The `|` operator (bitwise or)\n     BiBitOr,\n+    /// The `<<` operator (shift left)\n     BiShl,\n+    /// The `>>` operator (shift right)\n     BiShr,\n+    /// The `==` operator (equality)\n     BiEq,\n+    /// The `<` operator (less than)\n     BiLt,\n+    /// The `<=` operator (less than or equal to)\n     BiLe,\n+    /// The `!=` operator (not equal to)\n     BiNe,\n+    /// The `>=` operator (greater than or equal to)\n     BiGe,\n+    /// The `>` operator (greater than)\n     BiGt,\n }\n \n pub type BinOp = Spanned<BinOp_>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum UnOp {\n+    /// The `box` operator\n     UnUniq,\n+    /// The `*` operator for dereferencing\n     UnDeref,\n+    /// The `!` operator for logical inversion\n     UnNot,\n+    /// The `-` operator for negation\n     UnNeg\n }\n \n+/// A statement\n pub type Stmt = Spanned<Stmt_>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -668,6 +724,7 @@ pub enum LocalSource {\n pub struct Local {\n     pub pat: P<Pat>,\n     pub ty: Option<P<Ty>>,\n+    /// Initializer expression to set the value, if any\n     pub init: Option<P<Expr>>,\n     pub id: NodeId,\n     pub span: Span,\n@@ -714,6 +771,7 @@ pub enum UnsafeSource {\n     UserProvided,\n }\n \n+/// An expression\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Expr {\n     pub id: NodeId,\n@@ -725,55 +783,109 @@ pub struct Expr {\n pub enum Expr_ {\n     /// First expr is the place; second expr is the value.\n     ExprBox(Option<P<Expr>>, P<Expr>),\n+    /// An array (`[a, b, c, d]`)\n     ExprVec(Vec<P<Expr>>),\n+    /// A function call\n+    /// The first field resolves to the function itself,\n+    /// and the second field is the list of arguments\n     ExprCall(P<Expr>, Vec<P<Expr>>),\n+    /// A method call (`x.foo::<Bar, Baz>(a, b, c, d)`)\n+    /// The `SpannedIdent` is the identifier for the method name\n+    /// The vector of `Ty`s are the ascripted type parameters for the method\n+    /// (within the angle brackets)\n+    /// The first element of the vector of `Expr`s is the expression that evaluates\n+    /// to the object on which the method is being called on (the receiver),\n+    /// and the remaining elements are the rest of the arguments.\n+    /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n+    /// `ExprMethodCall(foo, [Bar, Baz], [x, a, b, c, d])`\n     ExprMethodCall(SpannedIdent, Vec<P<Ty>>, Vec<P<Expr>>),\n+    /// A tuple (`(a, b, c ,d)`)\n     ExprTup(Vec<P<Expr>>),\n+    /// A binary operation (For example: `a + b`, `a * b`)\n     ExprBinary(BinOp, P<Expr>, P<Expr>),\n+    /// A unary operation (For example: `!x`, `*x`)\n     ExprUnary(UnOp, P<Expr>),\n+    /// A literal (For example: `1u8`, `\"foo\"`)\n     ExprLit(P<Lit>),\n+    /// A cast (`foo as f64`)\n     ExprCast(P<Expr>, P<Ty>),\n+    /// An `if` block, with an optional else block\n+    /// `if expr { block } else { expr }`\n     ExprIf(P<Expr>, P<Block>, Option<P<Expr>>),\n+    /// An `if let` expression with an optional else block\n+    /// `if let pat = expr { block } else { expr }`\n+    /// This is desugared to a `match` expression\n     ExprIfLet(P<Pat>, P<Expr>, P<Block>, Option<P<Expr>>),\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n+    /// A while loop, with an optional label\n+    /// `'label: while expr { block }`\n     ExprWhile(P<Expr>, P<Block>, Option<Ident>),\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n+    /// A while-let loop, with an optional label\n+    /// `'label: while let pat = expr { block }`\n+    /// This is desugared to a combination of `loop` and `match` expressions\n     ExprWhileLet(P<Pat>, P<Expr>, P<Block>, Option<Ident>),\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n+    /// A for loop, with an optional label\n+    /// `'label: for pat in expr { block }`\n+    /// This is desugared to a combination of `loop` and `match` expressions\n     ExprForLoop(P<Pat>, P<Expr>, P<Block>, Option<Ident>),\n-    // Conditionless loop (can be exited with break, cont, or ret)\n+    /// Conditionless loop (can be exited with break, continue, or return)\n+    /// `'label: loop { block }`\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     ExprLoop(P<Block>, Option<Ident>),\n+    /// A `match` block, with a source that indicates whether or not it is\n+    /// the result of a desugaring, and if so, which kind\n     ExprMatch(P<Expr>, Vec<Arm>, MatchSource),\n+    /// A closure (for example, `move |a, b, c| {a + b + c}`)\n     ExprClosure(CaptureClause, P<FnDecl>, P<Block>),\n+    /// A block (`{ ... }`)\n     ExprBlock(P<Block>),\n \n+    /// An assignment (`a = foo()`)\n     ExprAssign(P<Expr>, P<Expr>),\n+    /// An assignment with an operator\n+    /// For example, `a += 1`\n     ExprAssignOp(BinOp, P<Expr>, P<Expr>),\n+    /// Access of a named struct field (`obj.foo`)\n     ExprField(P<Expr>, SpannedIdent),\n+    /// Access of an unnamed field of a struct or tuple-struct\n+    /// For example, `foo.0`\n     ExprTupField(P<Expr>, Spanned<usize>),\n+    /// An indexing operation (`foo[2]`)\n     ExprIndex(P<Expr>, P<Expr>),\n+    /// A range (`1..2`, `1..`, or `..2`)\n     ExprRange(Option<P<Expr>>, Option<P<Expr>>),\n \n     /// Variable reference, possibly containing `::` and/or type\n     /// parameters, e.g. foo::bar::<baz>. Optionally \"qualified\",\n     /// e.g. `<Vec<T> as SomeTrait>::SomeType`.\n     ExprPath(Option<QSelf>, Path),\n \n+    /// A referencing operation (`&a` or `&mut a`)\n     ExprAddrOf(Mutability, P<Expr>),\n+    /// A `break`, with an optional label to break\n     ExprBreak(Option<Ident>),\n+    /// A `continue`, with an optional label\n     ExprAgain(Option<Ident>),\n+    /// A `return`, with an optional value to be returned\n     ExprRet(Option<P<Expr>>),\n \n+    /// Output of the `asm!()` macro\n     ExprInlineAsm(InlineAsm),\n \n+    /// A macro invocation; pre-expansion\n     ExprMac(Mac),\n \n     /// A struct literal expression.\n-    ExprStruct(Path, Vec<Field>, Option<P<Expr>> /* base */),\n+    /// For example, `Foo {x: 1, y: 2}`, or\n+    /// `Foo {x: 1, .. base}`, where `base` is the `Option<Expr>`\n+    ExprStruct(Path, Vec<Field>, Option<P<Expr>>),\n \n     /// A vector literal constructed from one repeated element.\n-    ExprRepeat(P<Expr> /* element */, P<Expr> /* count */),\n+    /// For example, `[1u8; 5]`. The first expression is the element\n+    /// to be repeated; the second is the number of times to repeat it\n+    ExprRepeat(P<Expr>, P<Expr>),\n \n     /// No-op: used solely so we can pretty-print faithfully\n     ExprParen(P<Expr>)\n@@ -880,7 +992,6 @@ pub enum KleeneOp {\n /// The RHS of an MBE macro is the only place `SubstNt`s are substituted.\n /// Nothing special happens to misnamed or misplaced `SubstNt`s.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-#[doc=\"For macro invocations; parsing is delegated to the macro\"]\n pub enum TokenTree {\n     /// A single token\n     TtToken(Span, token::Token),\n@@ -991,10 +1102,14 @@ pub enum Mac_ {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum StrStyle {\n+    /// A regular string, like `\"foo\"`\n     CookedStr,\n+    /// A raw string, like `r##\"foo\"##`\n+    /// The uint is the number of `#` symbols used\n     RawStr(usize)\n }\n \n+/// A literal\n pub type Lit = Spanned<Lit_>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -1032,13 +1147,21 @@ impl LitIntType {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Lit_ {\n+    /// A string literal (`\"foo\"`)\n     LitStr(InternedString, StrStyle),\n+    /// A byte string (`b\"foo\"`)\n     LitBinary(Rc<Vec<u8>>),\n+    /// A byte char (`b'f'`)\n     LitByte(u8),\n+    /// A character literal (`'a'`)\n     LitChar(char),\n+    /// An integer liteal (`1u8`)\n     LitInt(u64, LitIntType),\n+    /// A float literal (`1f64` or `1E10f64`)\n     LitFloat(InternedString, FloatTy),\n+    /// A float literal without a suffix (`1.0 or 1.0E10`)\n     LitFloatUnsuffixed(InternedString),\n+    /// A boolean literal\n     LitBool(bool),\n }\n \n@@ -1361,9 +1484,9 @@ impl fmt::Display for Unsafety {\n \n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub enum ImplPolarity {\n-    /// impl Trait for Type\n+    /// `impl Trait for Type`\n     Positive,\n-    /// impl !Trait for Type\n+    /// `impl !Trait for Type`\n     Negative,\n }\n \n@@ -1379,10 +1502,10 @@ impl fmt::Debug for ImplPolarity {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum FunctionRetTy {\n-    /// Functions with return type ! that always\n+    /// Functions with return type `!`that always\n     /// raise an error or exit (i.e. never return to the caller)\n     NoReturn(Span),\n-    /// Return type is not specified. Functions default to () and\n+    /// Return type is not specified. Functions default to `()` and\n     /// closures default to inference. Span points to where return\n     /// type would be inserted.\n     DefaultReturn(Span),\n@@ -1438,7 +1561,9 @@ pub struct VariantArg {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum VariantKind {\n+    /// Tuple variant, e.g. `Foo(A, B)`\n     TupleVariantKind(Vec<VariantArg>),\n+    /// Struct variant, e.g. `Foo {x: A, y: B}`\n     StructVariantKind(P<StructDef>),\n }\n \n@@ -1453,6 +1578,7 @@ pub struct Variant_ {\n     pub attrs: Vec<Attribute>,\n     pub kind: VariantKind,\n     pub id: NodeId,\n+    /// Explicit discriminant, eg `Foo = 1`\n     pub disr_expr: Option<P<Expr>>,\n     pub vis: Visibility,\n }\n@@ -1603,6 +1729,9 @@ pub struct StructDef {\n   FIXME (#3300): Should allow items to be anonymous. Right now\n   we just use dummy names for anon items.\n  */\n+/// An item\n+///\n+/// The name might be a dummy name in case of anonymous items\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Item {\n     pub ident: Ident,\n@@ -1615,19 +1744,27 @@ pub struct Item {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Item_ {\n-    // Optional location (containing arbitrary characters) from which\n-    // to fetch the crate sources.\n-    // For example, extern crate whatever = \"github.com/rust-lang/rust\".\n+    /// An`extern crate` item, with optional original crate name,\n+    /// e.g. `extern crate foo` or `extern crate \"foo-bar\" as foo`\n     ItemExternCrate(Option<(InternedString, StrStyle)>),\n+    /// A `use` or `pub use` item\n     ItemUse(P<ViewPath>),\n \n+    /// A `static` item\n     ItemStatic(P<Ty>, Mutability, P<Expr>),\n+    /// A `const` item\n     ItemConst(P<Ty>, P<Expr>),\n+    /// A function declaration\n     ItemFn(P<FnDecl>, Unsafety, Abi, Generics, P<Block>),\n+    /// A module\n     ItemMod(Mod),\n+    /// An external module\n     ItemForeignMod(ForeignMod),\n+    /// A type alias, e.g. `type Foo = Bar<u8>`\n     ItemTy(P<Ty>, Generics),\n+    /// An enum definition, e.g. `enum Foo<A, B> {C<A>, D<B>}`\n     ItemEnum(EnumDef, Generics),\n+    /// A struct definition, e.g. `struct Foo<A> {x: A}`\n     ItemStruct(P<StructDef>, Generics),\n     /// Represents a Trait Declaration\n     ItemTrait(Unsafety,\n@@ -1636,8 +1773,9 @@ pub enum Item_ {\n               Vec<P<TraitItem>>),\n \n     // Default trait implementations\n-    // `impl Trait for ..`\n+    // `impl Trait for .. {}`\n     ItemDefaultImpl(Unsafety, TraitRef),\n+    /// An implementation, eg `impl<A> Trait for Foo { .. }`\n     ItemImpl(Unsafety,\n              ImplPolarity,\n              Generics,\n@@ -1679,10 +1817,14 @@ pub struct ForeignItem {\n     pub vis: Visibility,\n }\n \n+/// An item within an `extern` block\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ForeignItem_ {\n+    /// A foreign function\n     ForeignItemFn(P<FnDecl>, Generics),\n-    ForeignItemStatic(P<Ty>, /* is_mutbl */ bool),\n+    /// A foreign static item (`static ext: u8`), with optional mutability\n+    /// (the boolean is true when mutable)\n+    ForeignItemStatic(P<Ty>, bool),\n }\n \n impl ForeignItem_ {"}]}