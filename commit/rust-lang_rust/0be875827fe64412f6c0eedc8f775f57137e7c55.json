{"sha": "0be875827fe64412f6c0eedc8f775f57137e7c55", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiZTg3NTgyN2ZlNjQ0MTJmNmMwZWVkYzhmNzc1ZjU3MTM3ZTdjNTU=", "commit": {"author": {"name": "ubsan", "email": "npmazzuca@gmail.com", "date": "2017-05-03T17:54:03Z"}, "committer": {"name": "ubsan", "email": "npmazzuca@gmail.com", "date": "2017-05-07T08:20:15Z"}, "message": "fix the easy features in libsyntax", "tree": {"sha": "7f38ced0fca141a5bbb9283c57ce5398250115a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f38ced0fca141a5bbb9283c57ce5398250115a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0be875827fe64412f6c0eedc8f775f57137e7c55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0be875827fe64412f6c0eedc8f775f57137e7c55", "html_url": "https://github.com/rust-lang/rust/commit/0be875827fe64412f6c0eedc8f775f57137e7c55", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0be875827fe64412f6c0eedc8f775f57137e7c55/comments", "author": {"login": "ubsan", "id": 60298436, "node_id": "MDQ6VXNlcjYwMjk4NDM2", "avatar_url": "https://avatars.githubusercontent.com/u/60298436?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubsan", "html_url": "https://github.com/ubsan", "followers_url": "https://api.github.com/users/ubsan/followers", "following_url": "https://api.github.com/users/ubsan/following{/other_user}", "gists_url": "https://api.github.com/users/ubsan/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubsan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubsan/subscriptions", "organizations_url": "https://api.github.com/users/ubsan/orgs", "repos_url": "https://api.github.com/users/ubsan/repos", "events_url": "https://api.github.com/users/ubsan/events{/privacy}", "received_events_url": "https://api.github.com/users/ubsan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ubsan", "id": 60298436, "node_id": "MDQ6VXNlcjYwMjk4NDM2", "avatar_url": "https://avatars.githubusercontent.com/u/60298436?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubsan", "html_url": "https://github.com/ubsan", "followers_url": "https://api.github.com/users/ubsan/followers", "following_url": "https://api.github.com/users/ubsan/following{/other_user}", "gists_url": "https://api.github.com/users/ubsan/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubsan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubsan/subscriptions", "organizations_url": "https://api.github.com/users/ubsan/orgs", "repos_url": "https://api.github.com/users/ubsan/repos", "events_url": "https://api.github.com/users/ubsan/events{/privacy}", "received_events_url": "https://api.github.com/users/ubsan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8305394b4c32c2576bb02a026c05f01c96f46d92", "url": "https://api.github.com/repos/rust-lang/rust/commits/8305394b4c32c2576bb02a026c05f01c96f46d92", "html_url": "https://github.com/rust-lang/rust/commit/8305394b4c32c2576bb02a026c05f01c96f46d92"}], "stats": {"total": 61, "additions": 30, "deletions": 31}, "files": [{"sha": "3e0e63396928c3cc1bc0fb8fa23f3bcc7eb5a50e", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0be875827fe64412f6c0eedc8f775f57137e7c55/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0be875827fe64412f6c0eedc8f775f57137e7c55/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=0be875827fe64412f6c0eedc8f775f57137e7c55", "patch": "@@ -858,8 +858,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n name = \"syntax\"\n version = \"0.0.0\"\n dependencies = [\n+ \"bitflags 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc_bitflags 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n  \"serialize 0.0.0\","}, {"sha": "82e7cfa0032ce5ed9221e12b4f9610857260ab92", "filename": "src/libsyntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0be875827fe64412f6c0eedc8f775f57137e7c55/src%2Flibsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0be875827fe64412f6c0eedc8f775f57137e7c55/src%2Flibsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2FCargo.toml?ref=0be875827fe64412f6c0eedc8f775f57137e7c55", "patch": "@@ -11,7 +11,7 @@ crate-type = [\"dylib\"]\n [dependencies]\n serialize = { path = \"../libserialize\" }\n log = \"0.3\"\n-rustc_bitflags = { path = \"../librustc_bitflags\" }\n+bitflags = \"0.8\"\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "89c67b88cbde6dccaa7c0006cefc9152aac9a747", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0be875827fe64412f6c0eedc8f775f57137e7c55/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0be875827fe64412f6c0eedc8f775f57137e7c55/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=0be875827fe64412f6c0eedc8f775f57137e7c55", "patch": "@@ -24,20 +24,15 @@\n        test(attr(deny(warnings))))]\n #![deny(warnings)]\n \n-#![feature(associated_consts)]\n-#![feature(const_fn)]\n-#![feature(optin_builtin_traits)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(str_escape)]\n #![feature(unicode)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(specialization)]\n #![feature(i128_type)]\n \n extern crate serialize;\n #[macro_use] extern crate log;\n-#[macro_use] #[no_link] extern crate rustc_bitflags;\n+#[macro_use] extern crate bitflags;\n extern crate std_unicode;\n pub extern crate rustc_errors as errors;\n extern crate syntax_pos;"}, {"sha": "fe3ca1cf2305c0341ae3fb50db3616cb0e581c1b", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0be875827fe64412f6c0eedc8f775f57137e7c55/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0be875827fe64412f6c0eedc8f775f57137e7c55/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=0be875827fe64412f6c0eedc8f775f57137e7c55", "patch": "@@ -261,10 +261,14 @@ pub fn char_lit(lit: &str) -> (char, isize) {\n     }\n }\n \n+pub fn escape_default(s: &str) -> String {\n+    s.chars().map(char::escape_default).flat_map(|x| x).collect()\n+}\n+\n /// Parse a string representing a string literal into its final form. Does\n /// unescaping.\n pub fn str_lit(lit: &str) -> String {\n-    debug!(\"parse_str_lit: given {}\", lit.escape_default());\n+    debug!(\"parse_str_lit: given {}\", escape_default(lit));\n     let mut res = String::with_capacity(lit.len());\n \n     // FIXME #8372: This could be a for-loop if it didn't borrow the iterator\n@@ -339,7 +343,7 @@ pub fn str_lit(lit: &str) -> String {\n /// Parse a string representing a raw string literal into its final form. The\n /// only operation this does is convert embedded CRLF into a single LF.\n pub fn raw_str_lit(lit: &str) -> String {\n-    debug!(\"raw_str_lit: given {}\", lit.escape_default());\n+    debug!(\"raw_str_lit: given {}\", escape_default(lit));\n     let mut res = String::with_capacity(lit.len());\n \n     // FIXME #8372: This could be a for-loop if it didn't borrow the iterator"}, {"sha": "0a59d2a089df713e6e7312a22ba78c302143e0e4", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0be875827fe64412f6c0eedc8f775f57137e7c55/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0be875827fe64412f6c0eedc8f775f57137e7c55/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0be875827fe64412f6c0eedc8f775f57137e7c55", "patch": "@@ -64,7 +64,7 @@ use std::path::{self, Path, PathBuf};\n use std::slice;\n \n bitflags! {\n-    flags Restrictions: u8 {\n+    pub flags Restrictions: u8 {\n         const RESTRICTION_STMT_EXPR         = 1 << 0,\n         const RESTRICTION_NO_STRUCT_LITERAL = 1 << 1,\n     }\n@@ -2291,7 +2291,7 @@ impl<'a> Parser<'a> {\n                     let e = if self.token.can_begin_expr()\n                                && !(self.token == token::OpenDelim(token::Brace)\n                                     && self.restrictions.contains(\n-                                           Restrictions::RESTRICTION_NO_STRUCT_LITERAL)) {\n+                                           RESTRICTION_NO_STRUCT_LITERAL)) {\n                         Some(self.parse_expr()?)\n                     } else {\n                         None\n@@ -2318,7 +2318,7 @@ impl<'a> Parser<'a> {\n                         // This is a struct literal, unless we're prohibited\n                         // from parsing struct literals here.\n                         let prohibited = self.restrictions.contains(\n-                            Restrictions::RESTRICTION_NO_STRUCT_LITERAL\n+                            RESTRICTION_NO_STRUCT_LITERAL\n                         );\n                         if !prohibited {\n                             return self.parse_struct_expr(lo, pth, attrs);\n@@ -2722,7 +2722,7 @@ impl<'a> Parser<'a> {\n             token::Ident(..) if self.token.is_keyword(keywords::In) => {\n                 self.bump();\n                 let place = self.parse_expr_res(\n-                    Restrictions::RESTRICTION_NO_STRUCT_LITERAL,\n+                    RESTRICTION_NO_STRUCT_LITERAL,\n                     None,\n                 )?;\n                 let blk = self.parse_block()?;\n@@ -2785,7 +2785,7 @@ impl<'a> Parser<'a> {\n \n             let cur_op_span = self.span;\n             let restrictions = if op.is_assign_like() {\n-                self.restrictions & Restrictions::RESTRICTION_NO_STRUCT_LITERAL\n+                self.restrictions & RESTRICTION_NO_STRUCT_LITERAL\n             } else {\n                 self.restrictions\n             };\n@@ -2835,21 +2835,21 @@ impl<'a> Parser<'a> {\n \n             let rhs = match op.fixity() {\n                 Fixity::Right => self.with_res(\n-                    restrictions - Restrictions::RESTRICTION_STMT_EXPR,\n+                    restrictions - RESTRICTION_STMT_EXPR,\n                     |this| {\n                         this.parse_assoc_expr_with(op.precedence(),\n                             LhsExpr::NotYetParsed)\n                 }),\n                 Fixity::Left => self.with_res(\n-                    restrictions - Restrictions::RESTRICTION_STMT_EXPR,\n+                    restrictions - RESTRICTION_STMT_EXPR,\n                     |this| {\n                         this.parse_assoc_expr_with(op.precedence() + 1,\n                             LhsExpr::NotYetParsed)\n                 }),\n                 // We currently have no non-associative operators that are not handled above by\n                 // the special cases. The code is here only for future convenience.\n                 Fixity::None => self.with_res(\n-                    restrictions - Restrictions::RESTRICTION_STMT_EXPR,\n+                    restrictions - RESTRICTION_STMT_EXPR,\n                     |this| {\n                         this.parse_assoc_expr_with(op.precedence() + 1,\n                             LhsExpr::NotYetParsed)\n@@ -2959,7 +2959,7 @@ impl<'a> Parser<'a> {\n         if self.token.can_begin_expr() {\n             // parse `for i in 1.. { }` as infinite loop, not as `for i in (1..{})`.\n             if self.token == token::OpenDelim(token::Brace) {\n-                return !self.restrictions.contains(Restrictions::RESTRICTION_NO_STRUCT_LITERAL);\n+                return !self.restrictions.contains(RESTRICTION_NO_STRUCT_LITERAL);\n             }\n             true\n         } else {\n@@ -2973,7 +2973,7 @@ impl<'a> Parser<'a> {\n             return self.parse_if_let_expr(attrs);\n         }\n         let lo = self.prev_span;\n-        let cond = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n+        let cond = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let thn = self.parse_block()?;\n         let mut els: Option<P<Expr>> = None;\n         let mut hi = thn.span;\n@@ -2992,7 +2992,7 @@ impl<'a> Parser<'a> {\n         self.expect_keyword(keywords::Let)?;\n         let pat = self.parse_pat()?;\n         self.expect(&token::Eq)?;\n-        let expr = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n+        let expr = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let thn = self.parse_block()?;\n         let (hi, els) = if self.eat_keyword(keywords::Else) {\n             let expr = self.parse_else_expr()?;\n@@ -3046,7 +3046,7 @@ impl<'a> Parser<'a> {\n \n         let pat = self.parse_pat()?;\n         self.expect_keyword(keywords::In)?;\n-        let expr = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n+        let expr = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let (iattrs, loop_block) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n \n@@ -3061,7 +3061,7 @@ impl<'a> Parser<'a> {\n         if self.token.is_keyword(keywords::Let) {\n             return self.parse_while_let_expr(opt_ident, span_lo, attrs);\n         }\n-        let cond = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n+        let cond = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n         let span = span_lo.to(body.span);\n@@ -3075,7 +3075,7 @@ impl<'a> Parser<'a> {\n         self.expect_keyword(keywords::Let)?;\n         let pat = self.parse_pat()?;\n         self.expect(&token::Eq)?;\n-        let expr = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n+        let expr = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n         let span = span_lo.to(body.span);\n@@ -3105,7 +3105,7 @@ impl<'a> Parser<'a> {\n     fn parse_match_expr(&mut self, mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         let match_span = self.prev_span;\n         let lo = self.prev_span;\n-        let discriminant = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL,\n+        let discriminant = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL,\n                                                None)?;\n         if let Err(mut e) = self.expect(&token::OpenDelim(token::Brace)) {\n             if self.token == token::Token::Semi {\n@@ -3146,7 +3146,7 @@ impl<'a> Parser<'a> {\n             guard = Some(self.parse_expr()?);\n         }\n         self.expect(&token::FatArrow)?;\n-        let expr = self.parse_expr_res(Restrictions::RESTRICTION_STMT_EXPR, None)?;\n+        let expr = self.parse_expr_res(RESTRICTION_STMT_EXPR, None)?;\n \n         let require_comma =\n             !classify::expr_is_simple_block(&expr)\n@@ -3727,7 +3727,7 @@ impl<'a> Parser<'a> {\n         self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace)) &&\n \n         // prevent `while catch {} {}`, `if catch {} {} else {}`, etc.\n-        !self.restrictions.contains(Restrictions::RESTRICTION_NO_STRUCT_LITERAL)\n+        !self.restrictions.contains(RESTRICTION_NO_STRUCT_LITERAL)\n     }\n \n     fn is_union_item(&self) -> bool {\n@@ -3799,7 +3799,7 @@ impl<'a> Parser<'a> {\n                     self.mk_expr(lo.to(hi), ExprKind::Path(None, pth), ThinVec::new())\n                 };\n \n-                let expr = self.with_res(Restrictions::RESTRICTION_STMT_EXPR, |this| {\n+                let expr = self.with_res(RESTRICTION_STMT_EXPR, |this| {\n                     let expr = this.parse_dot_or_call_expr_with(expr, lo, attrs.into())?;\n                     this.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(expr))\n                 })?;\n@@ -3939,7 +3939,7 @@ impl<'a> Parser<'a> {\n \n                     // Remainder are line-expr stmts.\n                     let e = self.parse_expr_res(\n-                        Restrictions::RESTRICTION_STMT_EXPR, Some(attrs.into()))?;\n+                        RESTRICTION_STMT_EXPR, Some(attrs.into()))?;\n                     Stmt {\n                         id: ast::DUMMY_NODE_ID,\n                         span: lo.to(e.span),\n@@ -3952,7 +3952,7 @@ impl<'a> Parser<'a> {\n \n     /// Is this expression a successfully-parsed statement?\n     fn expr_is_complete(&mut self, e: &Expr) -> bool {\n-        self.restrictions.contains(Restrictions::RESTRICTION_STMT_EXPR) &&\n+        self.restrictions.contains(RESTRICTION_STMT_EXPR) &&\n             !classify::expr_requires_semi_to_be_stmt(e)\n     }\n "}, {"sha": "0c7e8fda83766cbdbc8f4f0df87c1e42b5f9c523", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0be875827fe64412f6c0eedc8f775f57137e7c55/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0be875827fe64412f6c0eedc8f775f57137e7c55/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=0be875827fe64412f6c0eedc8f775f57137e7c55", "patch": "@@ -677,7 +677,7 @@ pub trait PrintState<'a> {\n                     style: ast::StrStyle) -> io::Result<()> {\n         let st = match style {\n             ast::StrStyle::Cooked => {\n-                (format!(\"\\\"{}\\\"\", st.escape_default()))\n+                (format!(\"\\\"{}\\\"\", parse::escape_default(st)))\n             }\n             ast::StrStyle::Raw(n) => {\n                 (format!(\"r{delim}\\\"{string}\\\"{delim}\","}]}