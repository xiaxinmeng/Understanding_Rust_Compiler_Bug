{"sha": "35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1ZTg5MjRkYzVkNWNjMjQ4ZjMzNzY3ZmYzNWY3YWViNzk3YTcxZWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-18T01:31:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-18T01:31:01Z"}, "message": "Auto merge of #37660 - nikomatsakis:incremental-36349, r=eddyb\n\nSeparate impl items from the parent impl\n\nThis change separates impl item bodies out of the impl itself. This gives incremental more resolution. In so doing, it refactors how the visitors work, and cleans up a bit of the collect/check logic (mostly by moving things out of collect that didn't really belong there, because they were just checking conditions).\n\nHowever, this is not as effective as I expected, for a kind of frustrating reason. In particular, when invoking `foo.bar()` you still wind up with dependencies on private items. The problem is that the method resolution code scans that list for methods with the name `bar` -- and this winds up touching *all* the methods, even private ones.\n\nI can imagine two obvious ways to fix this:\n\n- separating fn bodies from fn sigs (#35078, currently being pursued by @flodiebold)\n- a more aggressive model of incremental that @michaelwoerister has been advocating, in which we hash the intermediate results (e.g., the outputs of collect) so that we can see that the intermediate result hasn't changed, even if a particular impl item has changed.\n\nSo all in all I'm not quite sure whether to land this or not. =) It still seems like it has to be a win in some cases, but not with the test cases we have just now. I can try to gin up some test cases, but I'm not sure if they will be totally realistic. On the other hand, some of the early refactorings to the visitor trait seem worthwhile to me regardless.\n\ncc #36349 -- well, this is basically a fix for that issue, I guess\n\nr? @michaelwoerister\n\nNB: Based atop of @eddyb's PR https://github.com/rust-lang/rust/pull/37402; don't land until that lands.", "tree": {"sha": "aa089b5c80ee7312c3b4f367288755334073049d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa089b5c80ee7312c3b4f367288755334073049d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "html_url": "https://github.com/rust-lang/rust/commit/35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3565372c30257bccb127ee188a4d1f25f621db7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3565372c30257bccb127ee188a4d1f25f621db7", "html_url": "https://github.com/rust-lang/rust/commit/c3565372c30257bccb127ee188a4d1f25f621db7"}, {"sha": "c938007f90711d6acc8b55e15a5e3cf7cc147e91", "url": "https://api.github.com/repos/rust-lang/rust/commits/c938007f90711d6acc8b55e15a5e3cf7cc147e91", "html_url": "https://github.com/rust-lang/rust/commit/c938007f90711d6acc8b55e15a5e3cf7cc147e91"}], "stats": {"total": 2395, "additions": 1765, "deletions": 630}, "files": [{"sha": "e365cea6d0e5ea8e553fbff25c72efff2bfb1333", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -25,5 +25,5 @@ pub use self::dep_node::WorkProductId;\n pub use self::graph::DepGraph;\n pub use self::graph::WorkProduct;\n pub use self::query::DepGraphQuery;\n-pub use self::visit::visit_all_items_in_krate;\n+pub use self::visit::visit_all_item_likes_in_krate;\n pub use self::raii::DepTask;"}, {"sha": "600732fc6f70b3e602d570ef5c9fb80d374a089a", "filename": "src/librustc/dep_graph/visit.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fvisit.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -10,31 +10,30 @@\n \n use hir;\n use hir::def_id::DefId;\n-use hir::intravisit::Visitor;\n+use hir::itemlikevisit::ItemLikeVisitor;\n use ty::TyCtxt;\n \n use super::dep_node::DepNode;\n \n-\n /// Visit all the items in the krate in some order. When visiting a\n /// particular item, first create a dep-node by calling `dep_node_fn`\n /// and push that onto the dep-graph stack of tasks, and also create a\n /// read edge from the corresponding AST node. This is used in\n /// compiler passes to automatically record the item that they are\n /// working on.\n-pub fn visit_all_items_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                mut dep_node_fn: F,\n-                                                visitor: &mut V)\n-    where F: FnMut(DefId) -> DepNode<DefId>, V: Visitor<'tcx>\n+pub fn visit_all_item_likes_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                     mut dep_node_fn: F,\n+                                                     visitor: &mut V)\n+    where F: FnMut(DefId) -> DepNode<DefId>, V: ItemLikeVisitor<'tcx>\n {\n     struct TrackingVisitor<'visit, 'tcx: 'visit, F: 'visit, V: 'visit> {\n         tcx: TyCtxt<'visit, 'tcx, 'tcx>,\n         dep_node_fn: &'visit mut F,\n         visitor: &'visit mut V\n     }\n \n-    impl<'visit, 'tcx, F, V> Visitor<'tcx> for TrackingVisitor<'visit, 'tcx, F, V>\n-        where F: FnMut(DefId) -> DepNode<DefId>, V: Visitor<'tcx>\n+    impl<'visit, 'tcx, F, V> ItemLikeVisitor<'tcx> for TrackingVisitor<'visit, 'tcx, F, V>\n+        where F: FnMut(DefId) -> DepNode<DefId>, V: ItemLikeVisitor<'tcx>\n     {\n         fn visit_item(&mut self, i: &'tcx hir::Item) {\n             let item_def_id = self.tcx.map.local_def_id(i.id);\n@@ -46,6 +45,17 @@ pub fn visit_all_items_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             self.visitor.visit_item(i);\n             debug!(\"Ended task {:?}\", task_id);\n         }\n+\n+        fn visit_impl_item(&mut self, i: &'tcx hir::ImplItem) {\n+            let impl_item_def_id = self.tcx.map.local_def_id(i.id);\n+            let task_id = (self.dep_node_fn)(impl_item_def_id);\n+            let _task = self.tcx.dep_graph.in_task(task_id.clone());\n+            debug!(\"Started task {:?}\", task_id);\n+            assert!(!self.tcx.map.is_inlined_def_id(impl_item_def_id));\n+            self.tcx.dep_graph.read(DepNode::Hir(impl_item_def_id));\n+            self.visitor.visit_impl_item(i);\n+            debug!(\"Ended task {:?}\", task_id);\n+        }\n     }\n \n     let krate = tcx.dep_graph.with_ignore(|| tcx.map.krate());\n@@ -54,5 +64,5 @@ pub fn visit_all_items_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         dep_node_fn: &mut dep_node_fn,\n         visitor: visitor\n     };\n-    krate.visit_all_items(&mut tracking_visitor)\n+    krate.visit_all_item_likes(&mut tracking_visitor)\n }"}, {"sha": "feefc43f4013e682af3628f86cb1353ae81f0397", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -106,7 +106,7 @@ pub type DefMap = NodeMap<PathResolution>;\n // within.\n pub type ExportMap = NodeMap<Vec<Export>>;\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct Export {\n     pub name: ast::Name, // The name of the target.\n     pub def: Def, // The definition of the target."}, {"sha": "4cfa889ec561676f7e1156bd7c55cb4afd51827a", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 110, "deletions": 14, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -8,7 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! HIR walker. Each overridden visit method has full control over what\n+//! HIR walker for walking the contents of nodes.\n+//!\n+//! **For an overview of the visitor strategy, see the docs on the\n+//! `super::itemlikevisit::ItemLikeVisitor` trait.**\n+//!\n+//! If you have decided to use this visitor, here are some general\n+//! notes on how to do it:\n+//!\n+//! Each overridden visit method has full control over what\n //! happens with its node, it can do its own traversal of the node's children,\n //! call `intravisit::walk_*` to apply the default traversal algorithm, or prevent\n //! deeper traversal by doing nothing.\n@@ -30,6 +38,8 @@ use syntax::ast::{NodeId, CRATE_NODE_ID, Name, Attribute};\n use syntax::codemap::Spanned;\n use syntax_pos::Span;\n use hir::*;\n+use hir::map::Map;\n+use super::itemlikevisit::DeepVisitor;\n \n use std::cmp;\n use std::u32;\n@@ -76,22 +86,70 @@ pub trait Visitor<'v> : Sized {\n     ///////////////////////////////////////////////////////////////////////////\n     // Nested items.\n \n-    /// Invoked when a nested item is encountered. By default, does\n-    /// nothing. If you want a deep walk, you need to override to\n-    /// fetch the item contents. But most of the time, it is easier\n-    /// (and better) to invoke `Crate::visit_all_items`, which visits\n-    /// all items in the crate in some order (but doesn't respect\n-    /// nesting).\n+    /// The default versions of the `visit_nested_XXX` routines invoke\n+    /// this method to get a map to use; if they get back `None`, they\n+    /// just skip nested things. Otherwise, they will lookup the\n+    /// nested item-like things in the map and visit it. So the best\n+    /// way to implement a nested visitor is to override this method\n+    /// to return a `Map`; one advantage of this is that if we add\n+    /// more types of nested things in the future, they will\n+    /// automatically work.\n+    ///\n+    /// **If for some reason you want the nested behavior, but don't\n+    /// have a `Map` are your disposal:** then you should override the\n+    /// `visit_nested_XXX` methods, and override this method to\n+    /// `panic!()`. This way, if a new `visit_nested_XXX` variant is\n+    /// added in the future, we will see the panic in your code and\n+    /// fix it appropriately.\n+    fn nested_visit_map(&mut self) -> Option<&Map<'v>> {\n+        None\n+    }\n+\n+    /// Invoked when a nested item is encountered. By default does\n+    /// nothing unless you override `nested_visit_map` to return\n+    /// `Some(_)`, in which case it will walk the item. **You probably\n+    /// don't want to override this method** -- instead, override\n+    /// `nested_visit_map` or use the \"shallow\" or \"deep\" visit\n+    /// patterns described on `itemlikevisit::ItemLikeVisitor`. The only\n+    /// reason to override this method is if you want a nested pattern\n+    /// but cannot supply a `Map`; see `nested_visit_map` for advice.\n     #[allow(unused_variables)]\n     fn visit_nested_item(&mut self, id: ItemId) {\n+        let opt_item = self.nested_visit_map()\n+                           .map(|map| map.expect_item(id.id));\n+        if let Some(item) = opt_item {\n+            self.visit_item(item);\n+        }\n     }\n \n-    /// Visit the top-level item and (optionally) nested items. See\n+    /// Like `visit_nested_item()`, but for impl items. See\n+    /// `visit_nested_item()` for advice on when to override this\n+    /// method.\n+    #[allow(unused_variables)]\n+    fn visit_nested_impl_item(&mut self, id: ImplItemId) {\n+        let opt_item = self.nested_visit_map()\n+                           .map(|map| map.impl_item(id));\n+        if let Some(item) = opt_item {\n+            self.visit_impl_item(item);\n+        }\n+    }\n+\n+    /// Visit the top-level item and (optionally) nested items / impl items. See\n     /// `visit_nested_item` for details.\n     fn visit_item(&mut self, i: &'v Item) {\n         walk_item(self, i)\n     }\n \n+    /// When invoking `visit_all_item_likes()`, you need to supply an\n+    /// item-like visitor.  This method converts a \"intra-visit\"\n+    /// visitor into an item-like visitor that walks the entire tree.\n+    /// If you use this, you probably don't want to process the\n+    /// contents of nested item-like things, since the outer loop will\n+    /// visit them as well.\n+    fn as_deep_visitor<'s>(&'s mut self) -> DeepVisitor<'s, Self> {\n+        DeepVisitor::new(self)\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n \n     fn visit_id(&mut self, _node_id: NodeId) {\n@@ -147,6 +205,9 @@ pub trait Visitor<'v> : Sized {\n     fn visit_impl_item(&mut self, ii: &'v ImplItem) {\n         walk_impl_item(self, ii)\n     }\n+    fn visit_impl_item_ref(&mut self, ii: &'v ImplItemRef) {\n+        walk_impl_item_ref(self, ii)\n+    }\n     fn visit_trait_ref(&mut self, t: &'v TraitRef) {\n         walk_trait_ref(self, t)\n     }\n@@ -206,6 +267,12 @@ pub trait Visitor<'v> : Sized {\n     fn visit_vis(&mut self, vis: &'v Visibility) {\n         walk_vis(self, vis)\n     }\n+    fn visit_associated_item_kind(&mut self, kind: &'v AssociatedItemKind) {\n+        walk_associated_item_kind(self, kind);\n+    }\n+    fn visit_defaultness(&mut self, defaultness: &'v Defaultness) {\n+        walk_defaultness(self, defaultness);\n+    }\n }\n \n pub fn walk_opt_name<'v, V: Visitor<'v>>(visitor: &mut V, span: Span, opt_name: Option<Name>) {\n@@ -341,12 +408,14 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_id(item.id);\n             visitor.visit_trait_ref(trait_ref)\n         }\n-        ItemImpl(.., ref type_parameters, ref opt_trait_reference, ref typ, ref impl_items) => {\n+        ItemImpl(.., ref type_parameters, ref opt_trait_reference, ref typ, ref impl_item_refs) => {\n             visitor.visit_id(item.id);\n             visitor.visit_generics(type_parameters);\n             walk_list!(visitor, visit_trait_ref, opt_trait_reference);\n             visitor.visit_ty(typ);\n-            walk_list!(visitor, visit_impl_item, impl_items);\n+            for impl_item_ref in impl_item_refs {\n+                visitor.visit_impl_item_ref(impl_item_ref);\n+            }\n         }\n         ItemStruct(ref struct_definition, ref generics) |\n         ItemUnion(ref struct_definition, ref generics) => {\n@@ -677,10 +746,14 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n }\n \n pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem) {\n-    visitor.visit_vis(&impl_item.vis);\n-    visitor.visit_name(impl_item.span, impl_item.name);\n-    walk_list!(visitor, visit_attribute, &impl_item.attrs);\n-    match impl_item.node {\n+    // NB: Deliberately force a compilation error if/when new fields are added.\n+    let ImplItem { id: _, name, ref vis, ref defaultness, ref attrs, ref node, span } = *impl_item;\n+\n+    visitor.visit_name(span, name);\n+    visitor.visit_vis(vis);\n+    visitor.visit_defaultness(defaultness);\n+    walk_list!(visitor, visit_attribute, attrs);\n+    match *node {\n         ImplItemKind::Const(ref ty, ref expr) => {\n             visitor.visit_id(impl_item.id);\n             visitor.visit_ty(ty);\n@@ -703,6 +776,17 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n     }\n }\n \n+pub fn walk_impl_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, impl_item_ref: &'v ImplItemRef) {\n+    // NB: Deliberately force a compilation error if/when new fields are added.\n+    let ImplItemRef { id, name, ref kind, span, ref vis, ref defaultness } = *impl_item_ref;\n+    visitor.visit_nested_impl_item(id);\n+    visitor.visit_name(span, name);\n+    visitor.visit_associated_item_kind(kind);\n+    visitor.visit_vis(vis);\n+    visitor.visit_defaultness(defaultness);\n+}\n+\n+\n pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V, struct_definition: &'v VariantData) {\n     visitor.visit_id(struct_definition.id());\n     walk_list!(visitor, visit_struct_field, struct_definition.fields());\n@@ -872,6 +956,18 @@ pub fn walk_vis<'v, V: Visitor<'v>>(visitor: &mut V, vis: &'v Visibility) {\n     }\n }\n \n+pub fn walk_associated_item_kind<'v, V: Visitor<'v>>(_: &mut V, _: &'v AssociatedItemKind) {\n+    // No visitable content here: this fn exists so you can call it if\n+    // the right thing to do, should content be added in the future,\n+    // would be to walk it.\n+}\n+\n+pub fn walk_defaultness<'v, V: Visitor<'v>>(_: &mut V, _: &'v Defaultness) {\n+    // No visitable content here: this fn exists so you can call it if\n+    // the right thing to do, should content be added in the future,\n+    // would be to walk it.\n+}\n+\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, PartialEq, Eq)]\n pub struct IdRange {\n     pub min: NodeId,"}, {"sha": "1e373441e9e85251d1ca4c4aa97a1b343f83c6da", "filename": "src/librustc/hir/itemlikevisit.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -0,0 +1,84 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::{Item, ImplItem};\n+use super::intravisit::Visitor;\n+\n+/// The \"item-like visitor\" visitor defines only the top-level methods\n+/// that can be invoked by `Crate::visit_all_item_likes()`. Whether\n+/// this trait is the right one to implement will depend on the\n+/// overall pattern you need. Here are the three available patterns,\n+/// in roughly the order of desirability:\n+///\n+/// 1. **Shallow visit**: Get a simple callback for every item (or item-like thing) in the HIR.\n+///    - Example: find all items with a `#[foo]` attribute on them.\n+///    - How: Implement `ItemLikeVisitor` and call `tcx.visit_all_item_likes_in_krate()`.\n+///    - Pro: Efficient; just walks the lists of item-like things, not the nodes themselves.\n+///    - Pro: Integrates well into dependency tracking.\n+///    - Con: Don't get information about nesting\n+///    - Con: Don't have methods for specific bits of HIR, like \"on\n+///      every expr, do this\".\n+/// 2. **Deep visit**: Want to scan for specific kinds of HIR nodes within\n+///    an item, but don't care about how item-like things are nested\n+///    within one another.\n+///    - Example: Examine each expression to look for its type and do some check or other.\n+///    - How: Implement `intravisit::Visitor` and use\n+///      `tcx.visit_all_item_likes_in_krate(visitor.as_deep_visitor())`. Within\n+///      your `intravisit::Visitor` impl, implement methods like\n+///      `visit_expr()`; don't forget to invoke\n+///      `intravisit::walk_visit_expr()` to keep walking the subparts.\n+///    - Pro: Visitor methods for any kind of HIR node, not just item-like things.\n+///    - Pro: Integrates well into dependency tracking.\n+///    - Con: Don't get information about nesting between items\n+/// 3. **Nested visit**: Want to visit the whole HIR and you care about the nesting between\n+///    item-like things.\n+///    - Example: Lifetime resolution, which wants to bring lifetimes declared on the\n+///      impl into scope while visiting the impl-items, and then back out again.\n+///    - How: Implement `intravisit::Visitor` and override the `visit_nested_foo()` foo methods\n+///      as needed. Walk your crate with `intravisit::walk_crate()` invoked on `tcx.map.krate()`.\n+///    - Pro: Visitor methods for any kind of HIR node, not just item-like things.\n+///    - Pro: Preserves nesting information\n+///    - Con: Does not integrate well into dependency tracking.\n+///\n+/// Note: the methods of `ItemLikeVisitor` intentionally have no\n+/// defaults, so that as we expand the list of item-like things, we\n+/// revisit the various visitors to see if they need to change. This\n+/// is harder to do with `intravisit::Visitor`, so when you add a new\n+/// `visit_nested_foo()` method, it is recommended that you search for\n+/// existing `fn visit_nested` methods to see where changes are\n+/// needed.\n+pub trait ItemLikeVisitor<'hir> {\n+    fn visit_item(&mut self, item: &'hir Item);\n+    fn visit_impl_item(&mut self, impl_item: &'hir ImplItem);\n+}\n+\n+pub struct DeepVisitor<'v, V: 'v> {\n+    visitor: &'v mut V,\n+}\n+\n+impl<'v, 'hir, V> DeepVisitor<'v, V>\n+    where V: Visitor<'hir> + 'v\n+{\n+    pub fn new(base: &'v mut V) -> Self {\n+        DeepVisitor { visitor: base }\n+    }\n+}\n+\n+impl<'v, 'hir, V> ItemLikeVisitor<'hir> for DeepVisitor<'v, V>\n+    where V: Visitor<'hir>\n+{\n+    fn visit_item(&mut self, item: &'hir Item) {\n+        self.visitor.visit_item(item);\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &'hir ImplItem) {\n+        self.visitor.visit_impl_item(impl_item);\n+    }\n+}"}, {"sha": "05c4ae521803aa36f1425fff099ed21c2ce8193f", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -105,6 +105,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_crate(&mut self, c: &Crate) -> hir::Crate {\n         struct ItemLowerer<'lcx, 'interner: 'lcx> {\n             items: BTreeMap<NodeId, hir::Item>,\n+            impl_items: BTreeMap<hir::ImplItemId, hir::ImplItem>,\n             lctx: &'lcx mut LoweringContext<'interner>,\n         }\n \n@@ -113,12 +114,20 @@ impl<'a> LoweringContext<'a> {\n                 self.items.insert(item.id, self.lctx.lower_item(item));\n                 visit::walk_item(self, item);\n             }\n+\n+            fn visit_impl_item(&mut self, item: &ImplItem) {\n+                let id = self.lctx.lower_impl_item_ref(item).id;\n+                self.impl_items.insert(id, self.lctx.lower_impl_item(item));\n+                visit::walk_impl_item(self, item);\n+            }\n         }\n \n-        let items = {\n-            let mut item_lowerer = ItemLowerer { items: BTreeMap::new(), lctx: self };\n+        let (items, impl_items) = {\n+            let mut item_lowerer = ItemLowerer { items: BTreeMap::new(),\n+                                                 impl_items: BTreeMap::new(),\n+                                                 lctx: self };\n             visit::walk_crate(&mut item_lowerer, c);\n-            item_lowerer.items\n+            (item_lowerer.items, item_lowerer.impl_items)\n         };\n \n         hir::Crate {\n@@ -127,6 +136,7 @@ impl<'a> LoweringContext<'a> {\n             span: c.span,\n             exported_macros: c.exported_macros.iter().map(|m| self.lower_macro_def(m)).collect(),\n             items: items,\n+            impl_items: impl_items,\n         }\n     }\n \n@@ -631,7 +641,7 @@ impl<'a> LoweringContext<'a> {\n             }\n             ItemKind::Impl(unsafety, polarity, ref generics, ref ifce, ref ty, ref impl_items) => {\n                 let new_impl_items = impl_items.iter()\n-                                               .map(|item| self.lower_impl_item(item))\n+                                               .map(|item| self.lower_impl_item_ref(item))\n                                                .collect();\n                 let ifce = ifce.as_ref().map(|trait_ref| self.lower_trait_ref(trait_ref));\n                 hir::ItemImpl(self.lower_unsafety(unsafety),\n@@ -689,7 +699,7 @@ impl<'a> LoweringContext<'a> {\n                 name: i.ident.name,\n                 attrs: this.lower_attrs(&i.attrs),\n                 vis: this.lower_visibility(&i.vis),\n-                defaultness: this.lower_defaultness(i.defaultness),\n+                defaultness: this.lower_defaultness(i.defaultness, true /* [1] */),\n                 node: match i.node {\n                     ImplItemKind::Const(ref ty, ref expr) => {\n                         hir::ImplItemKind::Const(this.lower_ty(ty), this.lower_expr(expr))\n@@ -705,6 +715,28 @@ impl<'a> LoweringContext<'a> {\n                 span: i.span,\n             }\n         })\n+\n+        // [1] since `default impl` is not yet implemented, this is always true in impls\n+    }\n+\n+    fn lower_impl_item_ref(&mut self, i: &ImplItem) -> hir::ImplItemRef {\n+        hir::ImplItemRef {\n+            id: hir::ImplItemId { node_id: i.id },\n+            name: i.ident.name,\n+            span: i.span,\n+            vis: self.lower_visibility(&i.vis),\n+            defaultness: self.lower_defaultness(i.defaultness, true /* [1] */),\n+            kind: match i.node {\n+                ImplItemKind::Const(..) => hir::AssociatedItemKind::Const,\n+                ImplItemKind::Type(..) => hir::AssociatedItemKind::Type,\n+                ImplItemKind::Method(ref sig, _) => hir::AssociatedItemKind::Method {\n+                    has_self: sig.decl.get_self().is_some(),\n+                },\n+                ImplItemKind::Macro(..) => unimplemented!(),\n+            },\n+        }\n+\n+        // [1] since `default impl` is not yet implemented, this is always true in impls\n     }\n \n     fn lower_mod(&mut self, m: &Mod) -> hir::Mod {\n@@ -1620,10 +1652,13 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_defaultness(&mut self, d: Defaultness) -> hir::Defaultness {\n+    fn lower_defaultness(&mut self, d: Defaultness, has_value: bool) -> hir::Defaultness {\n         match d {\n-            Defaultness::Default => hir::Defaultness::Default,\n-            Defaultness::Final => hir::Defaultness::Final,\n+            Defaultness::Default => hir::Defaultness::Default { has_value: has_value },\n+            Defaultness::Final => {\n+                assert!(has_value);\n+                hir::Defaultness::Final\n+            }\n         }\n     }\n "}, {"sha": "51a378a08336e93c22a4a2d5e2a10bc4589818f8", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -92,13 +92,22 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     /// Because we want to track parent items and so forth, enable\n     /// deep walking so that we walk nested items in the context of\n     /// their outer items.\n+\n+    fn nested_visit_map(&mut self) -> Option<&map::Map<'ast>> {\n+        panic!(\"visit_nested_xxx must be manually implemented in this visitor\")\n+    }\n+\n     fn visit_nested_item(&mut self, item: ItemId) {\n         debug!(\"visit_nested_item: {:?}\", item);\n         if !self.ignore_nested_items {\n             self.visit_item(self.krate.item(item.id))\n         }\n     }\n \n+    fn visit_nested_impl_item(&mut self, item_id: ImplItemId) {\n+        self.visit_impl_item(self.krate.impl_item(item_id))\n+    }\n+\n     fn visit_item(&mut self, i: &'ast Item) {\n         debug!(\"visit_item: {:?}\", i);\n "}, {"sha": "06cfc8aee8c9d382b69c04d3f2b7f197e540bce9", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -254,9 +254,14 @@ impl<'ast> Map<'ast> {\n                         return DepNode::Hir(def_id);\n                     }\n \n+                    EntryImplItem(..) => {\n+                        let def_id = self.local_def_id(id);\n+                        assert!(!self.is_inlined_def_id(def_id));\n+                        return DepNode::Hir(def_id);\n+                    }\n+\n                     EntryForeignItem(p, _) |\n                     EntryTraitItem(p, _) |\n-                    EntryImplItem(p, _) |\n                     EntryVariant(p, _) |\n                     EntryExpr(p, _) |\n                     EntryStmt(p, _) |\n@@ -378,6 +383,14 @@ impl<'ast> Map<'ast> {\n         self.forest.krate()\n     }\n \n+    pub fn impl_item(&self, id: ImplItemId) -> &'ast ImplItem {\n+        self.read(id.node_id);\n+\n+        // NB: intentionally bypass `self.forest.krate()` so that we\n+        // do not trigger a read of the whole krate here\n+        self.forest.krate.impl_item(id)\n+    }\n+\n     /// Get the attributes on the krate. This is preferable to\n     /// invoking `krate.attrs` because it registers a tighter\n     /// dep-graph access."}, {"sha": "9f5ff6914b0cc0b2b29b5064db5943bd4ca5588a", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 57, "deletions": 5, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -68,6 +68,7 @@ pub mod check_attr;\n pub mod def;\n pub mod def_id;\n pub mod intravisit;\n+pub mod itemlikevisit;\n pub mod lowering;\n pub mod map;\n pub mod pat_util;\n@@ -423,13 +424,19 @@ pub struct Crate {\n     // detected, which in turn can make compile-fail tests yield\n     // slightly different results.\n     pub items: BTreeMap<NodeId, Item>,\n+\n+    pub impl_items: BTreeMap<ImplItemId, ImplItem>,\n }\n \n impl Crate {\n     pub fn item(&self, id: NodeId) -> &Item {\n         &self.items[&id]\n     }\n \n+    pub fn impl_item(&self, id: ImplItemId) -> &ImplItem {\n+        &self.impl_items[&id]\n+    }\n+\n     /// Visits all items in the crate in some determinstic (but\n     /// unspecified) order. If you just need to process every item,\n     /// but don't care about nesting, this method is the best choice.\n@@ -438,12 +445,16 @@ impl Crate {\n     /// follows lexical scoping rules -- then you want a different\n     /// approach. You should override `visit_nested_item` in your\n     /// visitor and then call `intravisit::walk_crate` instead.\n-    pub fn visit_all_items<'hir, V>(&'hir self, visitor: &mut V)\n-        where V: intravisit::Visitor<'hir>\n+    pub fn visit_all_item_likes<'hir, V>(&'hir self, visitor: &mut V)\n+        where V: itemlikevisit::ItemLikeVisitor<'hir>\n     {\n         for (_, item) in &self.items {\n             visitor.visit_item(item);\n         }\n+\n+        for (_, impl_item) in &self.impl_items {\n+            visitor.visit_impl_item(impl_item);\n+        }\n     }\n }\n \n@@ -1041,6 +1052,14 @@ pub enum TraitItem_ {\n     TypeTraitItem(TyParamBounds, Option<P<Ty>>),\n }\n \n+// The bodies for items are stored \"out of line\", in a separate\n+// hashmap in the `Crate`. Here we just record the node-id of the item\n+// so it can fetched later.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct ImplItemId {\n+    pub node_id: NodeId,\n+}\n+\n /// Represents anything within an `impl` block\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ImplItem {\n@@ -1240,17 +1259,27 @@ pub enum Constness {\n \n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Defaultness {\n-    Default,\n+    Default { has_value: bool },\n     Final,\n }\n \n impl Defaultness {\n+    pub fn has_value(&self) -> bool {\n+        match *self {\n+            Defaultness::Default { has_value, .. } => has_value,\n+            Defaultness::Final => true,\n+        }\n+    }\n+\n     pub fn is_final(&self) -> bool {\n         *self == Defaultness::Final\n     }\n \n     pub fn is_default(&self) -> bool {\n-        *self == Defaultness::Default\n+        match *self {\n+            Defaultness::Default { .. } => true,\n+            _ => false,\n+        }\n     }\n }\n \n@@ -1527,7 +1556,7 @@ pub enum Item_ {\n              Generics,\n              Option<TraitRef>, // (optional) trait this impl implements\n              P<Ty>, // self\n-             HirVec<ImplItem>),\n+             HirVec<ImplItemRef>),\n }\n \n impl Item_ {\n@@ -1551,6 +1580,29 @@ impl Item_ {\n     }\n }\n \n+/// A reference from an impl to one of its associated items. This\n+/// contains the item's id, naturally, but also the item's name and\n+/// some other high-level details (like whether it is an associated\n+/// type or method, and whether it is public). This allows other\n+/// passes to find the impl they want without loading the id (which\n+/// means fewer edges in the incremental compilation graph).\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct ImplItemRef {\n+    pub id: ImplItemId,\n+    pub name: Name,\n+    pub kind: AssociatedItemKind,\n+    pub span: Span,\n+    pub vis: Visibility,\n+    pub defaultness: Defaultness,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum AssociatedItemKind {\n+    Const,\n+    Method { has_self: bool },\n+    Type,\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ForeignItem {\n     pub name: Name,"}, {"sha": "807bbec3b58888e36f0037d8df436ded6db16063", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -809,7 +809,7 @@ impl<'a> State<'a> {\n                 self.bopen()?;\n                 self.print_inner_attributes(&item.attrs)?;\n                 for impl_item in impl_items {\n-                    self.print_impl_item(impl_item)?;\n+                    self.print_impl_item_ref(impl_item)?;\n                 }\n                 self.bclose(item.span)?;\n             }\n@@ -1020,14 +1020,25 @@ impl<'a> State<'a> {\n         self.ann.post(self, NodeSubItem(ti.id))\n     }\n \n+    pub fn print_impl_item_ref(&mut self, item_ref: &hir::ImplItemRef) -> io::Result<()> {\n+        if let Some(krate) = self.krate {\n+            // skip nested items if krate context was not provided\n+            let item = &krate.impl_item(item_ref.id);\n+            self.print_impl_item(item)\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n     pub fn print_impl_item(&mut self, ii: &hir::ImplItem) -> io::Result<()> {\n         self.ann.pre(self, NodeSubItem(ii.id))?;\n         self.hardbreak_if_not_bol()?;\n         self.maybe_print_comment(ii.span.lo)?;\n         self.print_outer_attributes(&ii.attrs)?;\n \n-        if let hir::Defaultness::Default = ii.defaultness {\n-            self.word_nbsp(\"default\")?;\n+        match ii.defaultness {\n+            hir::Defaultness::Default { .. } => self.word_nbsp(\"default\")?,\n+            hir::Defaultness::Final => (),\n         }\n \n         match ii.node {"}, {"sha": "a490b58964a71f04c67a589e018ff61faf7bd0d4", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -792,16 +792,15 @@ impl<'a> LintContext for EarlyContext<'a> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n+impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     /// Because lints are scoped lexically, we want to walk nested\n     /// items in the context of the outer item, so enable\n     /// deep-walking.\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        let tcx = self.tcx;\n-        self.visit_item(tcx.map.expect_item(item.id))\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n+        Some(&self.tcx.map)\n     }\n \n-    fn visit_item(&mut self, it: &hir::Item) {\n+    fn visit_item(&mut self, it: &'tcx hir::Item) {\n         self.with_lint_attrs(&it.attrs, |cx| {\n             run_lints!(cx, check_item, late_passes, it);\n             cx.visit_ids(|v| v.visit_item(it));\n@@ -810,27 +809,27 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n         })\n     }\n \n-    fn visit_foreign_item(&mut self, it: &hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem) {\n         self.with_lint_attrs(&it.attrs, |cx| {\n             run_lints!(cx, check_foreign_item, late_passes, it);\n             hir_visit::walk_foreign_item(cx, it);\n             run_lints!(cx, check_foreign_item_post, late_passes, it);\n         })\n     }\n \n-    fn visit_pat(&mut self, p: &hir::Pat) {\n+    fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n         run_lints!(self, check_pat, late_passes, p);\n         hir_visit::walk_pat(self, p);\n     }\n \n-    fn visit_expr(&mut self, e: &hir::Expr) {\n+    fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n         self.with_lint_attrs(&e.attrs, |cx| {\n             run_lints!(cx, check_expr, late_passes, e);\n             hir_visit::walk_expr(cx, e);\n         })\n     }\n \n-    fn visit_stmt(&mut self, s: &hir::Stmt) {\n+    fn visit_stmt(&mut self, s: &'tcx hir::Stmt) {\n         // statement attributes are actually just attributes on one of\n         // - item\n         // - local\n@@ -840,40 +839,43 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n         hir_visit::walk_stmt(self, s);\n     }\n \n-    fn visit_fn(&mut self, fk: hir_visit::FnKind<'v>, decl: &'v hir::FnDecl,\n-                body: &'v hir::Expr, span: Span, id: ast::NodeId) {\n+    fn visit_fn(&mut self, fk: hir_visit::FnKind<'tcx>, decl: &'tcx hir::FnDecl,\n+                body: &'tcx hir::Expr, span: Span, id: ast::NodeId) {\n         run_lints!(self, check_fn, late_passes, fk, decl, body, span, id);\n         hir_visit::walk_fn(self, fk, decl, body, span, id);\n         run_lints!(self, check_fn_post, late_passes, fk, decl, body, span, id);\n     }\n \n     fn visit_variant_data(&mut self,\n-                        s: &hir::VariantData,\n+                        s: &'tcx hir::VariantData,\n                         name: ast::Name,\n-                        g: &hir::Generics,\n+                        g: &'tcx hir::Generics,\n                         item_id: ast::NodeId,\n                         _: Span) {\n         run_lints!(self, check_struct_def, late_passes, s, name, g, item_id);\n         hir_visit::walk_struct_def(self, s);\n         run_lints!(self, check_struct_def_post, late_passes, s, name, g, item_id);\n     }\n \n-    fn visit_struct_field(&mut self, s: &hir::StructField) {\n+    fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n         self.with_lint_attrs(&s.attrs, |cx| {\n             run_lints!(cx, check_struct_field, late_passes, s);\n             hir_visit::walk_struct_field(cx, s);\n         })\n     }\n \n-    fn visit_variant(&mut self, v: &hir::Variant, g: &hir::Generics, item_id: ast::NodeId) {\n+    fn visit_variant(&mut self,\n+                     v: &'tcx hir::Variant,\n+                     g: &'tcx hir::Generics,\n+                     item_id: ast::NodeId) {\n         self.with_lint_attrs(&v.node.attrs, |cx| {\n             run_lints!(cx, check_variant, late_passes, v, g);\n             hir_visit::walk_variant(cx, v, g, item_id);\n             run_lints!(cx, check_variant_post, late_passes, v, g);\n         })\n     }\n \n-    fn visit_ty(&mut self, t: &hir::Ty) {\n+    fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n         run_lints!(self, check_ty, late_passes, t);\n         hir_visit::walk_ty(self, t);\n     }\n@@ -882,45 +884,45 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n         run_lints!(self, check_name, late_passes, sp, name);\n     }\n \n-    fn visit_mod(&mut self, m: &hir::Mod, s: Span, n: ast::NodeId) {\n+    fn visit_mod(&mut self, m: &'tcx hir::Mod, s: Span, n: ast::NodeId) {\n         run_lints!(self, check_mod, late_passes, m, s, n);\n         hir_visit::walk_mod(self, m, n);\n         run_lints!(self, check_mod_post, late_passes, m, s, n);\n     }\n \n-    fn visit_local(&mut self, l: &hir::Local) {\n+    fn visit_local(&mut self, l: &'tcx hir::Local) {\n         self.with_lint_attrs(&l.attrs, |cx| {\n             run_lints!(cx, check_local, late_passes, l);\n             hir_visit::walk_local(cx, l);\n         })\n     }\n \n-    fn visit_block(&mut self, b: &hir::Block) {\n+    fn visit_block(&mut self, b: &'tcx hir::Block) {\n         run_lints!(self, check_block, late_passes, b);\n         hir_visit::walk_block(self, b);\n         run_lints!(self, check_block_post, late_passes, b);\n     }\n \n-    fn visit_arm(&mut self, a: &hir::Arm) {\n+    fn visit_arm(&mut self, a: &'tcx hir::Arm) {\n         run_lints!(self, check_arm, late_passes, a);\n         hir_visit::walk_arm(self, a);\n     }\n \n-    fn visit_decl(&mut self, d: &hir::Decl) {\n+    fn visit_decl(&mut self, d: &'tcx hir::Decl) {\n         run_lints!(self, check_decl, late_passes, d);\n         hir_visit::walk_decl(self, d);\n     }\n \n-    fn visit_expr_post(&mut self, e: &hir::Expr) {\n+    fn visit_expr_post(&mut self, e: &'tcx hir::Expr) {\n         run_lints!(self, check_expr_post, late_passes, e);\n     }\n \n-    fn visit_generics(&mut self, g: &hir::Generics) {\n+    fn visit_generics(&mut self, g: &'tcx hir::Generics) {\n         run_lints!(self, check_generics, late_passes, g);\n         hir_visit::walk_generics(self, g);\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         self.with_lint_attrs(&trait_item.attrs, |cx| {\n             run_lints!(cx, check_trait_item, late_passes, trait_item);\n             cx.visit_ids(|v| hir_visit::walk_trait_item(v, trait_item));\n@@ -929,7 +931,7 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n         });\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         self.with_lint_attrs(&impl_item.attrs, |cx| {\n             run_lints!(cx, check_impl_item, late_passes, impl_item);\n             cx.visit_ids(|v| hir_visit::walk_impl_item(v, impl_item));\n@@ -938,20 +940,20 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n         });\n     }\n \n-    fn visit_lifetime(&mut self, lt: &hir::Lifetime) {\n+    fn visit_lifetime(&mut self, lt: &'tcx hir::Lifetime) {\n         run_lints!(self, check_lifetime, late_passes, lt);\n     }\n \n-    fn visit_lifetime_def(&mut self, lt: &hir::LifetimeDef) {\n+    fn visit_lifetime_def(&mut self, lt: &'tcx hir::LifetimeDef) {\n         run_lints!(self, check_lifetime_def, late_passes, lt);\n     }\n \n-    fn visit_path(&mut self, p: &hir::Path, id: ast::NodeId) {\n+    fn visit_path(&mut self, p: &'tcx hir::Path, id: ast::NodeId) {\n         run_lints!(self, check_path, late_passes, p, id);\n         hir_visit::walk_path(self, p);\n     }\n \n-    fn visit_path_list_item(&mut self, prefix: &hir::Path, item: &hir::PathListItem) {\n+    fn visit_path_list_item(&mut self, prefix: &'tcx hir::Path, item: &'tcx hir::PathListItem) {\n         run_lints!(self, check_path_list_item, late_passes, item);\n         hir_visit::walk_path_list_item(self, prefix, item);\n     }\n@@ -1116,7 +1118,6 @@ struct IdVisitor<'a, 'b: 'a, 'tcx: 'a+'b> {\n \n // Output any lints that were previously added to the session.\n impl<'a, 'b, 'tcx, 'v> hir_visit::Visitor<'v> for IdVisitor<'a, 'b, 'tcx> {\n-\n     fn visit_id(&mut self, id: ast::NodeId) {\n         if let Some(lints) = self.cx.sess().lints.borrow_mut().remove(&id) {\n             debug!(\"LateContext::visit_id: id={:?} lints={:?}\", id, lints);"}, {"sha": "991398813752f8a5991536259f804b0d1a8f0749", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -16,6 +16,7 @@ use dep_graph::DepNode;\n use hir::map as ast_map;\n use hir::{self, pat_util, PatKind};\n use hir::intravisit::{self, Visitor};\n+use hir::itemlikevisit::ItemLikeVisitor;\n \n use middle::privacy;\n use ty::{self, TyCtxt};\n@@ -329,11 +330,12 @@ fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n //   or\n //   2) We are not sure to be live or not\n //     * Implementation of a trait method\n-struct LifeSeeder {\n-    worklist: Vec<ast::NodeId>\n+struct LifeSeeder<'k> {\n+    worklist: Vec<ast::NodeId>,\n+    krate: &'k hir::Crate,\n }\n \n-impl<'v> Visitor<'v> for LifeSeeder {\n+impl<'v, 'k> ItemLikeVisitor<'v> for LifeSeeder<'k> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         let allow_dead_code = has_allow_dead_code_or_lang_attr(&item.attrs);\n         if allow_dead_code {\n@@ -357,17 +359,22 @@ impl<'v> Visitor<'v> for LifeSeeder {\n                     }\n                 }\n             }\n-            hir::ItemImpl(.., ref opt_trait, _, ref impl_items) => {\n-                for impl_item in impl_items {\n+            hir::ItemImpl(.., ref opt_trait, _, ref impl_item_refs) => {\n+                for impl_item_ref in impl_item_refs {\n+                    let impl_item = self.krate.impl_item(impl_item_ref.id);\n                     if opt_trait.is_some() ||\n                             has_allow_dead_code_or_lang_attr(&impl_item.attrs) {\n-                        self.worklist.push(impl_item.id);\n+                        self.worklist.push(impl_item_ref.id.node_id);\n                     }\n                 }\n             }\n             _ => ()\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _item: &hir::ImplItem) {\n+        // ignore: we are handling this in `visit_item` above\n+    }\n }\n \n fn create_and_seed_worklist<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -386,9 +393,10 @@ fn create_and_seed_worklist<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Seed implemented trait items\n     let mut life_seeder = LifeSeeder {\n-        worklist: worklist\n+        worklist: worklist,\n+        krate: krate,\n     };\n-    krate.visit_all_items(&mut life_seeder);\n+    krate.visit_all_item_likes(&mut life_seeder);\n \n     return life_seeder.worklist;\n }\n@@ -503,17 +511,16 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n     /// Walk nested items in place so that we don't report dead-code\n     /// on inner functions when the outer function is already getting\n     /// an error. We could do this also by checking the parents, but\n     /// this is how the code is setup and it seems harmless enough.\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        let tcx = self.tcx;\n-        self.visit_item(tcx.map.expect_item(item.id))\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n+        Some(&self.tcx.map)\n     }\n \n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n         if self.should_warn_about_item(item) {\n             self.warn_dead_code(\n                 item.id,\n@@ -527,7 +534,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_variant(&mut self, variant: &hir::Variant, g: &hir::Generics, id: ast::NodeId) {\n+    fn visit_variant(&mut self,\n+                     variant: &'tcx hir::Variant,\n+                     g: &'tcx hir::Generics,\n+                     id: ast::NodeId) {\n         if self.should_warn_about_variant(&variant.node) {\n             self.warn_dead_code(variant.node.data.id(), variant.span,\n                                 variant.node.name, \"variant\");\n@@ -536,14 +546,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_foreign_item(&mut self, fi: &hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, fi: &'tcx hir::ForeignItem) {\n         if !self.symbol_is_live(fi.id, None) {\n             self.warn_dead_code(fi.id, fi.span, fi.name, fi.node.descriptive_variant());\n         }\n         intravisit::walk_foreign_item(self, fi);\n     }\n \n-    fn visit_struct_field(&mut self, field: &hir::StructField) {\n+    fn visit_struct_field(&mut self, field: &'tcx hir::StructField) {\n         if self.should_warn_about_field(&field) {\n             self.warn_dead_code(field.id, field.span,\n                                 field.name, \"field\");\n@@ -552,7 +562,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n         intravisit::walk_struct_field(self, field);\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         match impl_item.node {\n             hir::ImplItemKind::Const(_, ref expr) => {\n                 if !self.symbol_is_live(impl_item.id, None) {\n@@ -573,7 +583,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n     }\n \n     // Overwrite so that we don't warn the trait item itself.\n-    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         match trait_item.node {\n             hir::ConstTraitItem(_, Some(ref body))|\n             hir::MethodTraitItem(_, Some(ref body)) => {"}, {"sha": "25fe407271bc02c08e0ee9323faee8cfcc61a6f6", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -235,5 +235,5 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         unsafe_context: UnsafeContext::new(SafeContext),\n     };\n \n-    tcx.map.krate().visit_all_items(&mut visitor);\n+    tcx.map.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n }"}, {"sha": "9dd54457a3499b442952af6a82939692b10b9584", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -17,8 +17,8 @@ use syntax::ast::NodeId;\n use syntax::attr;\n use syntax::entry::EntryPointType;\n use syntax_pos::Span;\n-use hir::{Item, ItemFn};\n-use hir::intravisit::Visitor;\n+use hir::{Item, ItemFn, ImplItem};\n+use hir::itemlikevisit::ItemLikeVisitor;\n \n struct EntryContext<'a, 'tcx: 'a> {\n     session: &'a Session,\n@@ -39,13 +39,17 @@ struct EntryContext<'a, 'tcx: 'a> {\n     non_main_fns: Vec<(NodeId, Span)> ,\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for EntryContext<'a, 'tcx> {\n+impl<'a, 'tcx> ItemLikeVisitor<'tcx> for EntryContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx Item) {\n         let def_id = self.map.local_def_id(item.id);\n         let def_key = self.map.def_key(def_id);\n         let at_root = def_key.parent == Some(CRATE_DEF_INDEX);\n         find_item(item, self, at_root);\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &'tcx ImplItem) {\n+        // entry fn is never an impl item\n+    }\n }\n \n pub fn find_entry_point(session: &Session, ast_map: &ast_map::Map) {\n@@ -74,7 +78,7 @@ pub fn find_entry_point(session: &Session, ast_map: &ast_map::Map) {\n         non_main_fns: Vec::new(),\n     };\n \n-    ast_map.krate().visit_all_items(&mut ctxt);\n+    ast_map.krate().visit_all_item_likes(&mut ctxt);\n \n     configure_main(&mut ctxt);\n }"}, {"sha": "cf08b59312d50a55d38f8e8fc401a70334799b73", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -26,7 +26,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut visitor = ItemVisitor {\n         tcx: tcx\n     };\n-    tcx.visit_all_items_in_krate(DepNode::IntrinsicCheck, &mut visitor);\n+    tcx.visit_all_item_likes_in_krate(DepNode::IntrinsicCheck, &mut visitor.as_deep_visitor());\n }\n \n struct ItemVisitor<'a, 'tcx: 'a> {"}, {"sha": "9b4b1396669a3a6ab5242977b2bed3d74bddc788", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -31,7 +31,7 @@ use util::nodemap::FxHashMap;\n \n use syntax::ast;\n use syntax::parse::token::InternedString;\n-use hir::intravisit::Visitor;\n+use hir::itemlikevisit::ItemLikeVisitor;\n use hir;\n \n // The actual lang items defined come at the end of this file in one handy table.\n@@ -149,7 +149,7 @@ struct LanguageItemCollector<'a, 'tcx: 'a> {\n     item_refs: FxHashMap<&'static str, usize>,\n }\n \n-impl<'a, 'v, 'tcx> Visitor<'v> for LanguageItemCollector<'a, 'tcx> {\n+impl<'a, 'v, 'tcx> ItemLikeVisitor<'v> for LanguageItemCollector<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let Some(value) = extract(&item.attrs) {\n             let item_index = self.item_refs.get(&value[..]).cloned();\n@@ -164,6 +164,10 @@ impl<'a, 'v, 'tcx> Visitor<'v> for LanguageItemCollector<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+        // at present, lang items are always items, not impl items\n+    }\n }\n \n impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n@@ -219,7 +223,7 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n     }\n \n     pub fn collect_local_language_items(&mut self, krate: &hir::Crate) {\n-        krate.visit_all_items(self);\n+        krate.visit_all_item_likes(self);\n     }\n \n     pub fn collect_external_language_items(&mut self) {"}, {"sha": "d381188d56b542de5cb8e146264623835b8cec28", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -196,7 +196,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IrMaps<'a, 'tcx> {\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _task = tcx.dep_graph.in_task(DepNode::Liveness);\n-    tcx.map.krate().visit_all_items(&mut IrMaps::new(tcx));\n+    tcx.map.krate().visit_all_item_likes(&mut IrMaps::new(tcx).as_deep_visitor());\n     tcx.sess.abort_if_errors();\n }\n "}, {"sha": "ac614494355a26c37277ebc4f7e1a8aca87d1c4d", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -29,6 +29,7 @@ use syntax::ast;\n use syntax::attr;\n use hir;\n use hir::intravisit::Visitor;\n+use hir::itemlikevisit::ItemLikeVisitor;\n use hir::intravisit;\n \n // Returns true if the given set of generics implies that the item it's\n@@ -324,17 +325,21 @@ struct CollectPrivateImplItemsVisitor<'a> {\n     worklist: &'a mut Vec<ast::NodeId>,\n }\n \n-impl<'a, 'v> Visitor<'v> for CollectPrivateImplItemsVisitor<'a> {\n+impl<'a, 'v> ItemLikeVisitor<'v> for CollectPrivateImplItemsVisitor<'a> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         // We need only trait impls here, not inherent impls, and only non-exported ones\n-        if let hir::ItemImpl(.., Some(_), _, ref impl_items) = item.node {\n+        if let hir::ItemImpl(.., Some(_), _, ref impl_item_refs) = item.node {\n             if !self.access_levels.is_reachable(item.id) {\n-                for impl_item in impl_items {\n-                    self.worklist.push(impl_item.id);\n+                for impl_item_ref in impl_item_refs {\n+                    self.worklist.push(impl_item_ref.id.node_id);\n                 }\n             }\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+        // processed in visit_item above\n+    }\n }\n \n pub fn find_reachable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -364,7 +369,7 @@ pub fn find_reachable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             access_levels: access_levels,\n             worklist: &mut reachable_context.worklist,\n         };\n-        tcx.map.krate().visit_all_items(&mut collect_private_impl_items);\n+        tcx.map.krate().visit_all_item_likes(&mut collect_private_impl_items);\n     }\n \n     // Step 2: Mark all symbols that the symbols on the worklist touch."}, {"sha": "5f9a6b283c6a06c42c921b9d8afd951851dc752a", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -1235,7 +1235,7 @@ pub fn resolve_crate(sess: &Session, map: &ast_map::Map) -> RegionMaps {\n             },\n             terminating_scopes: NodeSet()\n         };\n-        krate.visit_all_items(&mut visitor);\n+        krate.visit_all_item_likes(&mut visitor.as_deep_visitor());\n     }\n     return maps;\n }"}, {"sha": "f682dfbf1be9526550bed9b052bb611d154549be", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -119,22 +119,29 @@ pub fn krate(sess: &Session,\n         late_bound: NodeMap(),\n     };\n     sess.track_errors(|| {\n-        krate.visit_all_items(&mut LifetimeContext {\n+        intravisit::walk_crate(&mut LifetimeContext {\n             sess: sess,\n             hir_map: hir_map,\n             map: &mut map,\n             scope: &ROOT_SCOPE,\n             def_map: def_map,\n             trait_ref_hack: false,\n             labels_in_fn: vec![],\n-        });\n+        }, krate);\n     })?;\n     Ok(map)\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item) {\n-        assert!(self.labels_in_fn.is_empty());\n+impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n+    // Override the nested functions -- lifetimes follow lexical scope,\n+    // so it's convenient to walk the tree in lexical order.\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n+        Some(&self.hir_map)\n+    }\n+\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        // Save labels for nested items.\n+        let saved_labels_in_fn = replace(&mut self.labels_in_fn, vec![]);\n \n         // Items always introduce a new root scope\n         self.with(RootScope, |_, this| {\n@@ -175,10 +182,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n         });\n \n         // Done traversing the item; remove any labels it created\n-        self.labels_in_fn.truncate(0);\n+        self.labels_in_fn = saved_labels_in_fn;\n     }\n \n-    fn visit_foreign_item(&mut self, item: &hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem) {\n         // Items save/restore the set of labels. This way inner items\n         // can freely reuse names, be they loop labels or lifetimes.\n         let saved = replace(&mut self.labels_in_fn, vec![]);\n@@ -201,8 +208,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n         replace(&mut self.labels_in_fn, saved);\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'v>, decl: &'v hir::FnDecl,\n-                b: &'v hir::Expr, s: Span, fn_id: ast::NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'tcx>, decl: &'tcx hir::FnDecl,\n+                b: &'tcx hir::Expr, s: Span, fn_id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(_, generics, ..) => {\n                 self.visit_early_late(fn_id,decl, generics, |this| {\n@@ -227,7 +234,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_ty(&mut self, ty: &hir::Ty) {\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         match ty.node {\n             hir::TyBareFn(ref c) => {\n                 self.with(LateScope(&c.lifetimes, self.scope), |old_scope, this| {\n@@ -257,7 +264,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         // We reset the labels on every trait item, so that different\n         // methods in an impl can reuse label names.\n         let saved = replace(&mut self.labels_in_fn, vec![]);\n@@ -274,15 +281,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n         replace(&mut self.labels_in_fn, saved);\n     }\n \n-    fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n+    fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n         if lifetime_ref.name == keywords::StaticLifetime.name() {\n             self.insert_lifetime(lifetime_ref, DefStaticRegion);\n             return;\n         }\n         self.resolve_lifetime_ref(lifetime_ref);\n     }\n \n-    fn visit_generics(&mut self, generics: &hir::Generics) {\n+    fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n         for ty_param in generics.ty_params.iter() {\n             walk_list!(self, visit_ty_param_bound, &ty_param.bounds);\n             if let Some(ref ty) = ty_param.default {\n@@ -331,8 +338,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_poly_trait_ref(&mut self,\n-                            trait_ref: &hir::PolyTraitRef,\n-                            _modifier: &hir::TraitBoundModifier) {\n+                            trait_ref: &'tcx hir::PolyTraitRef,\n+                            _modifier: &'tcx hir::TraitBoundModifier) {\n         debug!(\"visit_poly_trait_ref trait_ref={:?}\", trait_ref);\n \n         if !self.trait_ref_hack || !trait_ref.bound_lifetimes.is_empty() {\n@@ -490,13 +497,12 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: &hir::Expr) {\n }\n \n impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n-    fn add_scope_and_walk_fn<'b>(&mut self,\n-                                 fk: FnKind,\n-                                 fd: &hir::FnDecl,\n-                                 fb: &'b hir::Expr,\n-                                 _span: Span,\n-                                 fn_id: ast::NodeId) {\n-\n+    fn add_scope_and_walk_fn(&mut self,\n+                             fk: FnKind<'tcx>,\n+                             fd: &'tcx hir::FnDecl,\n+                             fb: &'tcx hir::Expr,\n+                             _span: Span,\n+                             fn_id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(_, generics, ..) => {\n                 intravisit::walk_fn_decl(self, fd);\n@@ -519,8 +525,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                   |_old_scope, this| this.visit_expr(fb))\n     }\n \n+    // FIXME(#37666) this works around a limitation in the region inferencer\n+    fn hack<F>(&mut self, f: F) where\n+        F: for<'b> FnOnce(&mut LifetimeContext<'b, 'tcx>),\n+    {\n+        f(self)\n+    }\n+\n     fn with<F>(&mut self, wrap_scope: ScopeChain, f: F) where\n-        F: FnOnce(Scope, &mut LifetimeContext),\n+        F: for<'b> FnOnce(Scope, &mut LifetimeContext<'b, 'tcx>),\n     {\n         let LifetimeContext {sess, hir_map, ref mut map, ..} = *self;\n         let mut this = LifetimeContext {\n@@ -557,10 +570,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// ordering is not important there.\n     fn visit_early_late<F>(&mut self,\n                            fn_id: ast::NodeId,\n-                           decl: &hir::FnDecl,\n-                           generics: &hir::Generics,\n+                           decl: &'tcx hir::FnDecl,\n+                           generics: &'tcx hir::Generics,\n                            walk: F) where\n-        F: FnOnce(&mut LifetimeContext),\n+        F: for<'b, 'c> FnOnce(&'b mut LifetimeContext<'c, 'tcx>),\n     {\n         let fn_def_id = self.hir_map.local_def_id(fn_id);\n         insert_late_bound_lifetimes(self.map,\n@@ -590,11 +603,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         }\n \n-        let this = self;\n-        this.with(EarlyScope(&early, start as u32, this.scope), move |old_scope, this| {\n+        self.with(EarlyScope(&early, start as u32, self.scope), move |old_scope, this| {\n             this.with(LateScope(&late, this.scope), move |_, this| {\n                 this.check_lifetime_defs(old_scope, &generics.lifetimes);\n-                walk(this);\n+                this.hack(walk); // FIXME(#37666) workaround in place of `walk(this)`\n             });\n         });\n     }"}, {"sha": "7e4efc7ddca06382c7c25e482399dbd661f542fb", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -120,7 +120,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n     // stability. The stability is recorded in the index and used as the parent.\n     fn annotate<F>(&mut self, id: NodeId, attrs: &[Attribute],\n                    item_sp: Span, kind: AnnotationKind, visit_children: F)\n-        where F: FnOnce(&mut Annotator)\n+        where F: FnOnce(&mut Self)\n     {\n         if self.index.staged_api[&LOCAL_CRATE] && self.tcx.sess.features.borrow().staged_api {\n             debug!(\"annotate(id = {:?}, attrs = {:?})\", id, attrs);\n@@ -234,16 +234,15 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     /// Because stability levels are scoped lexically, we want to walk\n     /// nested items in the context of the outer item, so enable\n     /// deep-walking.\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        let tcx = self.tcx;\n-        self.visit_item(tcx.map.expect_item(item.id))\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n+        Some(&self.tcx.map)\n     }\n \n-    fn visit_item(&mut self, i: &Item) {\n+    fn visit_item(&mut self, i: &'tcx Item) {\n         let orig_in_trait_impl = self.in_trait_impl;\n         let mut kind = AnnotationKind::Required;\n         match i.node {\n@@ -272,13 +271,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n         self.in_trait_impl = orig_in_trait_impl;\n     }\n \n-    fn visit_trait_item(&mut self, ti: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n         self.annotate(ti.id, &ti.attrs, ti.span, AnnotationKind::Required, |v| {\n             intravisit::walk_trait_item(v, ti);\n         });\n     }\n \n-    fn visit_impl_item(&mut self, ii: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n         let kind = if self.in_trait_impl {\n             AnnotationKind::Prohibited\n         } else {\n@@ -289,25 +288,25 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n         });\n     }\n \n-    fn visit_variant(&mut self, var: &Variant, g: &'v Generics, item_id: NodeId) {\n+    fn visit_variant(&mut self, var: &'tcx Variant, g: &'tcx Generics, item_id: NodeId) {\n         self.annotate(var.node.data.id(), &var.node.attrs, var.span, AnnotationKind::Required, |v| {\n             intravisit::walk_variant(v, var, g, item_id);\n         })\n     }\n \n-    fn visit_struct_field(&mut self, s: &StructField) {\n+    fn visit_struct_field(&mut self, s: &'tcx StructField) {\n         self.annotate(s.id, &s.attrs, s.span, AnnotationKind::Required, |v| {\n             intravisit::walk_struct_field(v, s);\n         });\n     }\n \n-    fn visit_foreign_item(&mut self, i: &hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem) {\n         self.annotate(i.id, &i.attrs, i.span, AnnotationKind::Required, |v| {\n             intravisit::walk_foreign_item(v, i);\n         });\n     }\n \n-    fn visit_macro_def(&mut self, md: &'v hir::MacroDef) {\n+    fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n         if md.imported_from.is_none() {\n             self.annotate(md.id, &md.attrs, md.span, AnnotationKind::Required, |_| {});\n         }\n@@ -444,16 +443,15 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n     /// Because stability levels are scoped lexically, we want to walk\n     /// nested items in the context of the outer item, so enable\n     /// deep-walking.\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        let tcx = self.tcx;\n-        self.visit_item(tcx.map.expect_item(item.id))\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n+        Some(&self.tcx.map)\n     }\n \n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n         // When compiling with --test we don't enforce stability on the\n         // compiler-generated test module, demarcated with `DUMMY_SP` plus the\n         // name `__test`\n@@ -464,31 +462,31 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n         intravisit::walk_item(self, item);\n     }\n \n-    fn visit_expr(&mut self, ex: &hir::Expr) {\n+    fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n         check_expr(self.tcx, ex,\n                    &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n         intravisit::walk_expr(self, ex);\n     }\n \n-    fn visit_path(&mut self, path: &hir::Path, id: ast::NodeId) {\n+    fn visit_path(&mut self, path: &'tcx hir::Path, id: ast::NodeId) {\n         check_path(self.tcx, path, id,\n                    &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n         intravisit::walk_path(self, path)\n     }\n \n-    fn visit_path_list_item(&mut self, prefix: &hir::Path, item: &hir::PathListItem) {\n+    fn visit_path_list_item(&mut self, prefix: &'tcx hir::Path, item: &'tcx hir::PathListItem) {\n         check_path_list_item(self.tcx, item,\n                    &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n         intravisit::walk_path_list_item(self, prefix, item)\n     }\n \n-    fn visit_pat(&mut self, pat: &hir::Pat) {\n+    fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n         check_pat(self.tcx, pat,\n                   &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n         intravisit::walk_pat(self, pat)\n     }\n \n-    fn visit_block(&mut self, b: &hir::Block) {\n+    fn visit_block(&mut self, b: &'tcx hir::Block) {\n         let old_skip_count = self.in_skip_block;\n         match b.rules {\n             hir::BlockCheckMode::PushUnstableBlock => {\n@@ -527,9 +525,10 @@ pub fn check_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // For implementations of traits, check the stability of each item\n         // individually as it's possible to have a stable trait with unstable\n         // items.\n-        hir::ItemImpl(.., Some(ref t), _, ref impl_items) => {\n+        hir::ItemImpl(.., Some(ref t), _, ref impl_item_refs) => {\n             let trait_did = tcx.expect_def(t.ref_id).def_id();\n-            for impl_item in impl_items {\n+            for impl_item_ref in impl_item_refs {\n+                let impl_item = tcx.map.impl_item(impl_item_ref.id);\n                 let item = tcx.associated_items(trait_did)\n                     .find(|item| item.name == impl_item.name).unwrap();\n                 if warn_about_defns {"}, {"sha": "12d32bf31b13dee60224341e288a6652bd5c35f8", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -50,7 +50,7 @@ pub fn check_crate(krate: &hir::Crate,\n \n     {\n         let mut cx = Context { sess: sess, items: items };\n-        krate.visit_all_items(&mut cx);\n+        krate.visit_all_item_likes(&mut cx.as_deep_visitor());\n     }\n     verify(sess, items);\n }"}, {"sha": "a2d45fa271499a02405732e49f83f364c8fb2b5b", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -940,7 +940,7 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                         // an error when we confirm the candidate\n                         // (which will ultimately lead to `normalize_to_error`\n                         // being invoked).\n-                        node_item.item.has_value\n+                        node_item.item.defaultness.has_value()\n                     } else {\n                         node_item.item.defaultness.is_default()\n                     };\n@@ -1004,8 +1004,9 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                     // types, which appear not to unify -- so the\n                     // overlap check succeeds, when it should\n                     // fail.\n-                    bug!(\"Tried to project an inherited associated type during \\\n-                          coherence checking, which is currently not supported.\");\n+                    span_bug!(obligation.cause.span,\n+                              \"Tried to project an inherited associated type during \\\n+                               coherence checking, which is currently not supported.\");\n                 };\n                 candidate_set.vec.extend(new_candidate);\n             }\n@@ -1295,7 +1296,7 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n \n     match assoc_ty {\n         Some(node_item) => {\n-            let ty = if !node_item.item.has_value {\n+            let ty = if !node_item.item.defaultness.has_value() {\n                 // This means that the impl is missing a definition for the\n                 // associated type. This error will be reported by the type\n                 // checker method `check_impl_items_against_trait`, so here we"}, {"sha": "f5c23401a4e679785a31547ba91d9f9c3f4ffcba", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 111, "deletions": 69, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -50,7 +50,7 @@ use syntax_pos::{DUMMY_SP, Span};\n use rustc_const_math::ConstInt;\n \n use hir;\n-use hir::intravisit::Visitor;\n+use hir::itemlikevisit::ItemLikeVisitor;\n \n pub use self::sty::{Binder, DebruijnIndex};\n pub use self::sty::{BuiltinBound, BuiltinBounds};\n@@ -189,7 +189,6 @@ pub struct AssociatedItem {\n     pub kind: AssociatedKind,\n     pub vis: Visibility,\n     pub defaultness: hir::Defaultness,\n-    pub has_value: bool,\n     pub container: AssociatedItemContainer,\n \n     /// Whether this is a method with an explicit self\n@@ -2072,7 +2071,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn provided_trait_methods(self, id: DefId) -> Vec<AssociatedItem> {\n         self.associated_items(id)\n-            .filter(|item| item.kind == AssociatedKind::Method && item.has_value)\n+            .filter(|item| item.kind == AssociatedKind::Method && item.defaultness.has_value())\n             .collect()\n     }\n \n@@ -2113,69 +2112,109 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                            .expect(\"missing AssociatedItem in metadata\");\n             }\n \n+            // When the user asks for a given associated item, we\n+            // always go ahead and convert all the associated items in\n+            // the container. Note that we are also careful only to\n+            // ever register a read on the *container* of the assoc\n+            // item, not the assoc item itself. This prevents changes\n+            // in the details of an item (for example, the type to\n+            // which an associated type is bound) from contaminating\n+            // those tasks that just need to scan the names of items\n+            // and so forth.\n+\n             let id = self.map.as_local_node_id(def_id).unwrap();\n             let parent_id = self.map.get_parent(id);\n             let parent_def_id = self.map.local_def_id(parent_id);\n-            match self.map.get(id) {\n-                ast_map::NodeTraitItem(trait_item) => {\n-                    let (kind, has_self, has_value) = match trait_item.node {\n-                        hir::MethodTraitItem(ref sig, ref body) => {\n-                            (AssociatedKind::Method, sig.decl.get_self().is_some(),\n-                             body.is_some())\n-                        }\n-                        hir::ConstTraitItem(_, ref value) => {\n-                            (AssociatedKind::Const, false, value.is_some())\n-                        }\n-                        hir::TypeTraitItem(_, ref ty) => {\n-                            (AssociatedKind::Type, false, ty.is_some())\n-                        }\n-                    };\n-\n-                    AssociatedItem {\n-                        name: trait_item.name,\n-                        kind: kind,\n-                        vis: Visibility::from_hir(&hir::Inherited, id, self),\n-                        defaultness: hir::Defaultness::Default,\n-                        has_value: has_value,\n-                        def_id: def_id,\n-                        container: TraitContainer(parent_def_id),\n-                        method_has_self_argument: has_self\n+            let parent_item = self.map.expect_item(parent_id);\n+            match parent_item.node {\n+                hir::ItemImpl(.., ref impl_trait_ref, _, ref impl_item_refs) => {\n+                    for impl_item_ref in impl_item_refs {\n+                        let assoc_item =\n+                            self.associated_item_from_impl_item_ref(parent_def_id,\n+                                                                    impl_trait_ref.is_some(),\n+                                                                    impl_item_ref);\n+                        self.associated_items.borrow_mut().insert(assoc_item.def_id, assoc_item);\n                     }\n                 }\n-                ast_map::NodeImplItem(impl_item) => {\n-                    let (kind, has_self) = match impl_item.node {\n-                        hir::ImplItemKind::Method(ref sig, _) => {\n-                            (AssociatedKind::Method, sig.decl.get_self().is_some())\n-                        }\n-                        hir::ImplItemKind::Const(..) => (AssociatedKind::Const, false),\n-                        hir::ImplItemKind::Type(..) => (AssociatedKind::Type, false)\n-                    };\n-\n-                    // Trait impl items are always public.\n-                    let public = hir::Public;\n-                    let parent_item = self.map.expect_item(parent_id);\n-                    let vis = if let hir::ItemImpl(.., Some(_), _, _) = parent_item.node {\n-                        &public\n-                    } else {\n-                        &impl_item.vis\n-                    };\n-\n-                    AssociatedItem {\n-                        name: impl_item.name,\n-                        kind: kind,\n-                        vis: Visibility::from_hir(vis, id, self),\n-                        defaultness: impl_item.defaultness,\n-                        has_value: true,\n-                        def_id: def_id,\n-                        container: ImplContainer(parent_def_id),\n-                        method_has_self_argument: has_self\n+\n+                hir::ItemTrait(.., ref trait_items) => {\n+                    for trait_item in trait_items {\n+                        let assoc_item =\n+                            self.associated_item_from_trait_item_ref(parent_def_id, trait_item);\n+                        self.associated_items.borrow_mut().insert(assoc_item.def_id, assoc_item);\n                     }\n                 }\n-                item => bug!(\"associated_item: {:?} not an associated item\", item)\n+\n+                ref r => {\n+                    panic!(\"unexpected container of associated items: {:?}\", r)\n+                }\n             }\n+\n+            // memoize wants us to return something, so return\n+            // the one we generated for this def-id\n+            *self.associated_items.borrow().get(&def_id).unwrap()\n         })\n     }\n \n+    fn associated_item_from_trait_item_ref(self,\n+                                           parent_def_id: DefId,\n+                                           trait_item: &hir::TraitItem)\n+                                           -> AssociatedItem {\n+        let def_id = self.map.local_def_id(trait_item.id);\n+\n+        let (kind, has_self, has_value) = match trait_item.node {\n+            hir::MethodTraitItem(ref sig, ref body) => {\n+                (AssociatedKind::Method, sig.decl.get_self().is_some(),\n+                 body.is_some())\n+            }\n+            hir::ConstTraitItem(_, ref value) => {\n+                (AssociatedKind::Const, false, value.is_some())\n+            }\n+            hir::TypeTraitItem(_, ref ty) => {\n+                (AssociatedKind::Type, false, ty.is_some())\n+            }\n+        };\n+\n+        AssociatedItem {\n+            name: trait_item.name,\n+            kind: kind,\n+            vis: Visibility::from_hir(&hir::Inherited, trait_item.id, self),\n+            defaultness: hir::Defaultness::Default { has_value: has_value },\n+            def_id: def_id,\n+            container: TraitContainer(parent_def_id),\n+            method_has_self_argument: has_self\n+        }\n+    }\n+\n+    fn associated_item_from_impl_item_ref(self,\n+                                          parent_def_id: DefId,\n+                                          from_trait_impl: bool,\n+                                          impl_item_ref: &hir::ImplItemRef)\n+                                          -> AssociatedItem {\n+        let def_id = self.map.local_def_id(impl_item_ref.id.node_id);\n+        let (kind, has_self) = match impl_item_ref.kind {\n+            hir::AssociatedItemKind::Const => (ty::AssociatedKind::Const, false),\n+            hir::AssociatedItemKind::Method { has_self } => {\n+                (ty::AssociatedKind::Method, has_self)\n+            }\n+            hir::AssociatedItemKind::Type => (ty::AssociatedKind::Type, false),\n+        };\n+\n+        // Trait impl items are always public.\n+        let public = hir::Public;\n+        let vis = if from_trait_impl { &public } else { &impl_item_ref.vis };\n+\n+        ty::AssociatedItem {\n+            name: impl_item_ref.name,\n+            kind: kind,\n+            vis: ty::Visibility::from_hir(vis, impl_item_ref.id.node_id, self),\n+            defaultness: impl_item_ref.defaultness,\n+            def_id: def_id,\n+            container: ImplContainer(parent_def_id),\n+            method_has_self_argument: has_self\n+        }\n+    }\n+\n     pub fn associated_item_def_ids(self, def_id: DefId) -> Rc<Vec<DefId>> {\n         self.associated_item_def_ids.memoize(def_id, || {\n             if !def_id.is_local() {\n@@ -2184,19 +2223,22 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n             let id = self.map.as_local_node_id(def_id).unwrap();\n             let item = self.map.expect_item(id);\n-            match item.node {\n+            let vec: Vec<_> = match item.node {\n                 hir::ItemTrait(.., ref trait_items) => {\n-                    Rc::new(trait_items.iter().map(|trait_item| {\n-                        self.map.local_def_id(trait_item.id)\n-                    }).collect())\n+                    trait_items.iter()\n+                               .map(|trait_item| trait_item.id)\n+                               .map(|id| self.map.local_def_id(id))\n+                               .collect()\n                 }\n-                hir::ItemImpl(.., ref impl_items) => {\n-                    Rc::new(impl_items.iter().map(|impl_item| {\n-                        self.map.local_def_id(impl_item.id)\n-                    }).collect())\n+                hir::ItemImpl(.., ref impl_item_refs) => {\n+                    impl_item_refs.iter()\n+                                  .map(|impl_item_ref| impl_item_ref.id)\n+                                  .map(|id| self.map.local_def_id(id.node_id))\n+                                  .collect()\n                 }\n                 _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\")\n-            }\n+            };\n+            Rc::new(vec)\n         })\n     }\n \n@@ -2695,12 +2737,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_region(ty::ReScope(self.region_maps.node_extent(id)))\n     }\n \n-    pub fn visit_all_items_in_krate<V,F>(self,\n-                                         dep_node_fn: F,\n-                                         visitor: &mut V)\n-        where F: FnMut(DefId) -> DepNode<DefId>, V: Visitor<'gcx>\n+    pub fn visit_all_item_likes_in_krate<V,F>(self,\n+                                              dep_node_fn: F,\n+                                              visitor: &mut V)\n+        where F: FnMut(DefId) -> DepNode<DefId>, V: ItemLikeVisitor<'gcx>\n     {\n-        dep_graph::visit_all_items_in_krate(self.global_tcx(), dep_node_fn, visitor);\n+        dep_graph::visit_all_item_likes_in_krate(self.global_tcx(), dep_node_fn, visitor);\n     }\n \n     /// Looks up the span of `impl_did` if the impl is local; otherwise returns `Err`"}, {"sha": "5e54e333bb90ce469a431a8bf659388c6aa2a03a", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -110,7 +110,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         }\n     };\n \n-    tcx.visit_all_items_in_krate(DepNode::BorrowCheck, &mut bccx);\n+    tcx.visit_all_item_likes_in_krate(DepNode::BorrowCheck, &mut bccx.as_deep_visitor());\n \n     if tcx.sess.borrowck_stats() {\n         println!(\"--- borrowck stats ---\");"}, {"sha": "f63a27e0d7563fd5df3af52c4d8000f7de7c1c48", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -78,7 +78,8 @@ impl<'a, 'v, 'tcx> Visitor<'v> for OuterVisitor<'a, 'tcx> {\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.visit_all_items_in_krate(DepNode::MatchCheck, &mut OuterVisitor { tcx: tcx });\n+    tcx.visit_all_item_likes_in_krate(DepNode::MatchCheck,\n+                                      &mut OuterVisitor { tcx: tcx }.as_deep_visitor());\n     tcx.sess.abort_if_errors();\n }\n "}, {"sha": "4db620b2bec3b1ec507be9519bcf13e70ae1a09f", "filename": "src/librustc_driver/derive_registrar.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_driver%2Fderive_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_driver%2Fderive_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fderive_registrar.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc::dep_graph::DepNode;\n-use rustc::hir::intravisit::Visitor;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::map::Map;\n use rustc::hir;\n use syntax::ast;\n@@ -20,18 +20,22 @@ pub fn find(hir_map: &Map) -> Option<ast::NodeId> {\n     let krate = hir_map.krate();\n \n     let mut finder = Finder { registrar: None };\n-    krate.visit_all_items(&mut finder);\n+    krate.visit_all_item_likes(&mut finder);\n     finder.registrar\n }\n \n struct Finder {\n     registrar: Option<ast::NodeId>,\n }\n \n-impl<'v> Visitor<'v> for Finder {\n+impl<'v> ItemLikeVisitor<'v> for Finder {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if attr::contains_name(&item.attrs, \"rustc_derive_registrar\") {\n             self.registrar = Some(item.id);\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }\n+"}, {"sha": "998cbae2cce150b94bace00a20f21653a69520c1", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -51,7 +51,7 @@ use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::{Direction, INCOMING, OUTGOING, NodeIndex};\n use rustc::hir;\n-use rustc::hir::intravisit::Visitor;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use graphviz::IntoCow;\n use std::env;\n use std::fs::File;\n@@ -81,7 +81,7 @@ pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n                                           if_this_changed: vec![],\n                                           then_this_would_need: vec![] };\n         visitor.process_attrs(ast::CRATE_NODE_ID, &tcx.map.krate().attrs);\n-        tcx.map.krate().visit_all_items(&mut visitor);\n+        tcx.map.krate().visit_all_item_likes(&mut visitor);\n         (visitor.if_this_changed, visitor.then_this_would_need)\n     };\n \n@@ -167,10 +167,14 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for IfThisChanged<'a, 'tcx> {\n+impl<'a, 'tcx> ItemLikeVisitor<'tcx> for IfThisChanged<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         self.process_attrs(item.id, &item.attrs);\n     }\n+\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n+        self.process_attrs(impl_item.id, &impl_item.attrs);\n+    }\n }\n \n fn check_paths<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "c08519090d2735fe78988e30f2a1b6de8ccd7750", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -34,6 +34,7 @@ use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::hir::intravisit as visit;\n+use rustc::hir::intravisit::Visitor;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashMap;\n use rustc::util::common::record_time;\n@@ -107,7 +108,8 @@ pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n     record_time(&tcx.sess.perf_stats.incr_comp_hashes_time, || {\n         visitor.calculate_def_id(DefId::local(CRATE_DEF_INDEX),\n                                  |v| visit::walk_crate(v, krate));\n-        krate.visit_all_items(&mut visitor);\n+        // FIXME(#37713) if foreign items were item likes, could use ItemLikeVisitor\n+        krate.visit_all_item_likes(&mut visitor.as_deep_visitor());\n     });\n \n     tcx.sess.perf_stats.incr_comp_hashes_count.set(visitor.hashes.len() as u64);\n@@ -199,12 +201,17 @@ impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n }\n \n \n-impl<'a, 'tcx> visit::Visitor<'tcx> for HashItemsVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for HashItemsVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         self.calculate_node_id(item.id, |v| v.visit_item(item));\n         visit::walk_item(self, item);\n     }\n \n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n+        self.calculate_node_id(impl_item.id, |v| v.visit_impl_item(impl_item));\n+        visit::walk_impl_item(self, impl_item);\n+    }\n+\n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem) {\n         self.calculate_node_id(item.id, |v| v.visit_foreign_item(item));\n         visit::walk_foreign_item(self, item);"}, {"sha": "fa2eff817eaa8e33685cfe282d7cd255c4a6af55", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -199,6 +199,8 @@ enum SawAbiComponent<'a> {\n     SawExpr(SawExprComponent<'a>),\n     SawStmt,\n     SawVis,\n+    SawAssociatedItemKind(hir::AssociatedItemKind),\n+    SawDefaultness(hir::Defaultness),\n     SawWherePredicate,\n     SawTyParamBound,\n     SawPolyTraitRef,\n@@ -499,10 +501,6 @@ macro_rules! hash_span {\n }\n \n impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n-    fn visit_nested_item(&mut self, _: ItemId) {\n-        // Each item is hashed independently; ignore nested items.\n-    }\n-\n     fn visit_variant_data(&mut self,\n                           s: &'tcx VariantData,\n                           name: Name,\n@@ -697,6 +695,18 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n         visit::walk_vis(self, v)\n     }\n \n+    fn visit_associated_item_kind(&mut self, kind: &'tcx AssociatedItemKind) {\n+        debug!(\"visit_associated_item_kind: st={:?}\", self.st);\n+        SawAssociatedItemKind(*kind).hash(self.st);\n+        visit::walk_associated_item_kind(self, kind);\n+    }\n+\n+    fn visit_defaultness(&mut self, defaultness: &'tcx Defaultness) {\n+        debug!(\"visit_associated_item_kind: st={:?}\", self.st);\n+        SawDefaultness(*defaultness).hash(self.st);\n+        visit::walk_defaultness(self, defaultness);\n+    }\n+\n     fn visit_where_predicate(&mut self, predicate: &'tcx WherePredicate) {\n         debug!(\"visit_where_predicate: st={:?}\", self.st);\n         SawWherePredicate.hash(self.st);"}, {"sha": "0cd1c88fb877bb7e007444b2e63cd0d3c4da0344", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -45,7 +45,7 @@ use super::load::DirtyNodes;\n use rustc::dep_graph::{DepGraphQuery, DepNode};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::intravisit::Visitor;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use syntax::ast::{self, Attribute, NestedMetaItem};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use syntax::parse::token::InternedString;\n@@ -74,7 +74,7 @@ pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let query = tcx.dep_graph.query();\n     debug!(\"query-nodes: {:?}\", query.nodes());\n     let krate = tcx.map.krate();\n-    krate.visit_all_items(&mut DirtyCleanVisitor {\n+    krate.visit_all_item_likes(&mut DirtyCleanVisitor {\n         tcx: tcx,\n         query: &query,\n         dirty_inputs: dirty_inputs,\n@@ -169,7 +169,7 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for DirtyCleanVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> ItemLikeVisitor<'tcx> for DirtyCleanVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let def_id = self.tcx.map.local_def_id(item.id);\n         for attr in self.tcx.get_attrs(def_id).iter() {\n@@ -184,6 +184,9 @@ impl<'a, 'tcx> Visitor<'tcx> for DirtyCleanVisitor<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }\n \n pub fn check_dirty_clean_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -195,7 +198,7 @@ pub fn check_dirty_clean_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     tcx.dep_graph.with_ignore(||{\n         let krate = tcx.map.krate();\n-        krate.visit_all_items(&mut DirtyCleanMetadataVisitor {\n+        krate.visit_all_item_likes(&mut DirtyCleanMetadataVisitor {\n             tcx: tcx,\n             prev_metadata_hashes: prev_metadata_hashes,\n             current_metadata_hashes: current_metadata_hashes,\n@@ -209,7 +212,7 @@ pub struct DirtyCleanMetadataVisitor<'a, 'tcx:'a, 'm> {\n     current_metadata_hashes: &'m FxHashMap<DefId, Fingerprint>,\n }\n \n-impl<'a, 'tcx, 'm> Visitor<'tcx> for DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {\n+impl<'a, 'tcx, 'm> ItemLikeVisitor<'tcx> for DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let def_id = self.tcx.map.local_def_id(item.id);\n \n@@ -225,6 +228,9 @@ impl<'a, 'tcx, 'm> Visitor<'tcx> for DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {\n             }\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }\n \n impl<'a, 'tcx, 'm> DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {"}, {"sha": "2572a9c1d78f6ea91e8d0d909de15022aff01e84", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -201,6 +201,19 @@ pub fn prepare_session_directory(tcx: TyCtxt) -> Result<bool, ()> {\n     debug!(\"crate-dir: {}\", crate_dir.display());\n     try!(create_dir(tcx.sess, &crate_dir, \"crate\"));\n \n+    // Hack: canonicalize the path *after creating the directory*\n+    // because, on windows, long paths can cause problems;\n+    // canonicalization inserts this weird prefix that makes windows\n+    // tolerate long paths.\n+    let crate_dir = match crate_dir.canonicalize() {\n+        Ok(v) => v,\n+        Err(err) => {\n+            tcx.sess.err(&format!(\"incremental compilation: error canonicalizing path `{}`: {}\",\n+                                  crate_dir.display(), err));\n+            return Err(());\n+        }\n+    };\n+\n     let mut source_directories_already_tried = FxHashSet();\n \n     loop {"}, {"sha": "51ffb1ebc8e99ae1d687fa5c8cfe99e1b1198890", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -387,16 +387,16 @@ impl LateLintPass for MissingDoc {\n                 \"a trait\"\n             }\n             hir::ItemTy(..) => \"a type alias\",\n-            hir::ItemImpl(.., Some(ref trait_ref), _, ref impl_items) => {\n+            hir::ItemImpl(.., Some(ref trait_ref), _, ref impl_item_refs) => {\n                 // If the trait is private, add the impl items to private_traits so they don't get\n                 // reported for missing docs.\n                 let real_trait = cx.tcx.expect_def(trait_ref.ref_id).def_id();\n                 if let Some(node_id) = cx.tcx.map.as_local_node_id(real_trait) {\n                     match cx.tcx.map.find(node_id) {\n                         Some(hir_map::NodeItem(item)) => {\n                             if item.vis == hir::Visibility::Inherited {\n-                                for itm in impl_items {\n-                                    self.private_traits.insert(itm.id);\n+                                for impl_item_ref in impl_item_refs {\n+                                    self.private_traits.insert(impl_item_ref.id.node_id);\n                                 }\n                             }\n                         }"}, {"sha": "3af9d291ae55a4056c2d153eae2195d7bef5b92c", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -850,7 +850,6 @@ impl<'a, 'tcx> CrateMetadata {\n                     kind: ty::AssociatedKind::Const,\n                     vis: item.visibility,\n                     defaultness: container.defaultness(),\n-                    has_value: container.has_value(),\n                     def_id: self.local_def_id(id),\n                     container: container.with_def_id(parent),\n                     method_has_self_argument: false\n@@ -864,7 +863,6 @@ impl<'a, 'tcx> CrateMetadata {\n                     kind: ty::AssociatedKind::Method,\n                     vis: item.visibility,\n                     defaultness: data.container.defaultness(),\n-                    has_value: data.container.has_value(),\n                     def_id: self.local_def_id(id),\n                     container: data.container.with_def_id(parent),\n                     method_has_self_argument: data.has_self\n@@ -877,7 +875,6 @@ impl<'a, 'tcx> CrateMetadata {\n                     kind: ty::AssociatedKind::Type,\n                     vis: item.visibility,\n                     defaultness: container.defaultness(),\n-                    has_value: container.has_value(),\n                     def_id: self.local_def_id(id),\n                     container: container.with_def_id(parent),\n                     method_has_self_argument: false"}, {"sha": "3ab542442a1fbe4fbf1eca6b4d224f6f3e956462", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -38,6 +38,7 @@ use syntax;\n use syntax_pos;\n \n use rustc::hir::{self, PatKind};\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::intravisit::Visitor;\n use rustc::hir::intravisit;\n \n@@ -459,10 +460,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let ast_item = tcx.map.expect_trait_item(node_id);\n         let trait_item = tcx.associated_item(def_id);\n \n-        let container = if trait_item.has_value {\n-            AssociatedContainer::TraitWithDefault\n-        } else {\n-            AssociatedContainer::TraitRequired\n+        let container = match trait_item.defaultness {\n+            hir::Defaultness::Default { has_value: true } =>\n+                AssociatedContainer::TraitWithDefault,\n+            hir::Defaultness::Default { has_value: false } =>\n+                AssociatedContainer::TraitRequired,\n+            hir::Defaultness::Final =>\n+                span_bug!(ast_item.span, \"traits cannot have final items\"),\n         };\n \n         let kind = match trait_item.kind {\n@@ -500,7 +504,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     Some(self.encode_item_type(def_id))\n                 }\n                 ty::AssociatedKind::Type => {\n-                    if trait_item.has_value {\n+                    if trait_item.defaultness.has_value() {\n                         Some(self.encode_item_type(def_id))\n                     } else {\n                         None\n@@ -529,8 +533,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let impl_def_id = impl_item.container.id();\n \n         let container = match impl_item.defaultness {\n-            hir::Defaultness::Default => AssociatedContainer::ImplDefault,\n+            hir::Defaultness::Default { has_value: true } => AssociatedContainer::ImplDefault,\n             hir::Defaultness::Final => AssociatedContainer::ImplFinal,\n+            hir::Defaultness::Default { has_value: false } =>\n+                span_bug!(ast_item.span, \"impl items always have values (currently)\"),\n         };\n \n         let kind = match impl_item.kind {\n@@ -1074,7 +1080,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                      EncodeContext::encode_info_for_mod,\n                      FromId(CRATE_NODE_ID, (&krate.module, &krate.attrs, &hir::Public)));\n         let mut visitor = EncodeVisitor { index: index };\n-        krate.visit_all_items(&mut visitor);\n+        krate.visit_all_item_likes(&mut visitor.as_deep_visitor());\n         for macro_def in &krate.exported_macros {\n             visitor.visit_macro_def(macro_def);\n         }\n@@ -1159,7 +1165,7 @@ struct ImplVisitor<'a, 'tcx: 'a> {\n     impls: FxHashMap<DefId, Vec<DefIndex>>,\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let hir::ItemImpl(..) = item.node {\n             let impl_id = self.tcx.map.local_def_id(item.id);\n@@ -1171,6 +1177,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &'v hir::ImplItem) {\n+        // handled in `visit_item` above\n+    }\n }\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n@@ -1180,7 +1190,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             tcx: self.tcx,\n             impls: FxHashMap(),\n         };\n-        self.tcx.map.krate().visit_all_items(&mut visitor);\n+        self.tcx.map.krate().visit_all_item_likes(&mut visitor);\n \n         let all_impls: Vec<_> = visitor.impls\n             .into_iter()"}, {"sha": "32c8c5e2ee87996536b634662fd3c1ce209fbe76", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -310,21 +310,16 @@ impl AssociatedContainer {\n         }\n     }\n \n-    pub fn has_value(&self) -> bool {\n-        match *self {\n-            AssociatedContainer::TraitRequired => false,\n-\n-            AssociatedContainer::TraitWithDefault |\n-            AssociatedContainer::ImplDefault |\n-            AssociatedContainer::ImplFinal => true,\n-        }\n-    }\n-\n     pub fn defaultness(&self) -> hir::Defaultness {\n         match *self {\n-            AssociatedContainer::TraitRequired |\n+            AssociatedContainer::TraitRequired => hir::Defaultness::Default {\n+                has_value: false,\n+            },\n+\n             AssociatedContainer::TraitWithDefault |\n-            AssociatedContainer::ImplDefault => hir::Defaultness::Default,\n+            AssociatedContainer::ImplDefault => hir::Defaultness::Default {\n+                has_value: true,\n+            },\n \n             AssociatedContainer::ImplFinal => hir::Defaultness::Final,\n         }"}, {"sha": "992c0e9b5fc85739931bfbfc4bf3d1959f0eed75", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -38,9 +38,9 @@ use syntax_pos::Span;\n use std::mem;\n \n pub fn build_mir_for_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.visit_all_items_in_krate(DepNode::Mir, &mut BuildMir {\n+    tcx.visit_all_item_likes_in_krate(DepNode::Mir, &mut BuildMir {\n         tcx: tcx\n-    });\n+    }.as_deep_visitor());\n }\n \n /// A pass to lift all the types and substitutions in a Mir"}, {"sha": "4ff2beb3fdb77a519333e37ad13827572b347bb0", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -277,8 +277,12 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                             .and_then(|impl_node_id| self.tcx.map.find(impl_node_id))\n                             .map(|node| {\n                                 if let hir_map::NodeItem(item) = node {\n-                                    if let hir::ItemImpl(_, _, _, _, _, ref methods) = item.node {\n-                                        span = methods.first().map(|method| method.span);\n+                                    if let hir::ItemImpl(.., ref impl_item_refs) = item.node {\n+                                        span = impl_item_refs.first()\n+                                                             .map(|iiref| {\n+                                                                 self.tcx.map.impl_item(iiref.id)\n+                                                                             .span\n+                                                             });\n                                     }\n                                 }\n                             });"}, {"sha": "5df8accd8cef13d024cf039be3a2b176e578c785", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -644,13 +644,13 @@ fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Exp\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.visit_all_items_in_krate(DepNode::CheckConst,\n-                                 &mut CheckCrateVisitor {\n-                                     tcx: tcx,\n-                                     mode: Mode::Var,\n-                                     qualif: ConstQualif::NOT_CONST,\n-                                     rvalue_borrows: NodeMap(),\n-                                 });\n+    tcx.visit_all_item_likes_in_krate(DepNode::CheckConst,\n+                                      &mut CheckCrateVisitor {\n+                                          tcx: tcx,\n+                                          mode: Mode::Var,\n+                                          qualif: ConstQualif::NOT_CONST,\n+                                          rvalue_borrows: NodeMap(),\n+                                      }.as_deep_visitor());\n     tcx.sess.abort_if_errors();\n }\n "}, {"sha": "3bdaf276b40cef489bc43a4514b63f07847186e6", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -106,12 +106,20 @@ impl<'k> StatCollector<'k> {\n }\n \n impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'v>> {\n+        panic!(\"visit_nested_xxx must be manually implemented in this visitor\")\n+    }\n \n     fn visit_nested_item(&mut self, id: hir::ItemId) {\n         let nested_item = self.krate.unwrap().item(id.id);\n         self.visit_item(nested_item)\n     }\n \n+    fn visit_nested_impl_item(&mut self, impl_item_id: hir::ImplItemId) {\n+        let nested_impl_item = self.krate.unwrap().impl_item(impl_item_id);\n+        self.visit_impl_item(nested_impl_item)\n+    }\n+\n     fn visit_item(&mut self, i: &'v hir::Item) {\n         self.record(\"Item\", Id::Node(i.id), i);\n         hir_visit::walk_item(self, i)"}, {"sha": "724100e02237f74304c0f79ab1188df519e37b58", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -33,17 +33,21 @@ struct CheckLoopVisitor<'a> {\n pub fn check_crate(sess: &Session, map: &Map) {\n     let _task = map.dep_graph.in_task(DepNode::CheckLoops);\n     let krate = map.krate();\n-    krate.visit_all_items(&mut CheckLoopVisitor {\n+    krate.visit_all_item_likes(&mut CheckLoopVisitor {\n         sess: sess,\n         cx: Normal,\n-    });\n+    }.as_deep_visitor());\n }\n \n impl<'a, 'v> Visitor<'v> for CheckLoopVisitor<'a> {\n     fn visit_item(&mut self, i: &hir::Item) {\n         self.with_context(Normal, |v| intravisit::walk_item(v, i));\n     }\n \n+    fn visit_impl_item(&mut self, i: &hir::ImplItem) {\n+        self.with_context(Normal, |v| intravisit::walk_impl_item(v, i));\n+    }\n+\n     fn visit_expr(&mut self, e: &hir::Expr) {\n         match e.node {\n             hir::ExprWhile(ref e, ref b, _) => {"}, {"sha": "7386be2528c9b4524c2309454d76517bfd94cefc", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -18,20 +18,20 @@ use rustc::ty::{self, TyCtxt, ParameterEnvironment};\n use rustc::traits::Reveal;\n \n use rustc::hir;\n-use rustc::hir::intravisit;\n+use rustc::hir::intravisit::{self, Visitor};\n use syntax::ast;\n use syntax_pos::Span;\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut rvcx = RvalueContext { tcx: tcx };\n-    tcx.visit_all_items_in_krate(DepNode::RvalueCheck, &mut rvcx);\n+    tcx.visit_all_item_likes_in_krate(DepNode::RvalueCheck, &mut rvcx.as_deep_visitor());\n }\n \n struct RvalueContext<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n-impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> Visitor<'v> for RvalueContext<'a, 'tcx> {\n     fn visit_fn(&mut self,\n                 fk: intravisit::FnKind<'v>,\n                 fd: &'v hir::FnDecl,"}, {"sha": "5f76f865c4acaa9f42fcf042a0ca1ee414d8dcd1", "filename": "src/librustc_passes/static_recursion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -100,7 +100,8 @@ pub fn check_crate<'ast>(sess: &Session,\n         discriminant_map: RefCell::new(NodeMap()),\n     };\n     sess.track_errors(|| {\n-        ast_map.krate().visit_all_items(&mut visitor);\n+        // FIXME(#37712) could use ItemLikeVisitor if trait items were item-like\n+        ast_map.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n     })\n }\n "}, {"sha": "75046f6aeb8742fd581b3f669bcdb30ffeb98126", "filename": "src/librustc_plugin/build.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_plugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_plugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fbuild.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -16,14 +16,14 @@ use errors;\n use syntax_pos::Span;\n use rustc::dep_graph::DepNode;\n use rustc::hir::map::Map;\n-use rustc::hir::intravisit::Visitor;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir;\n \n struct RegistrarFinder {\n     registrars: Vec<(ast::NodeId, Span)> ,\n }\n \n-impl<'v> Visitor<'v> for RegistrarFinder {\n+impl<'v> ItemLikeVisitor<'v> for RegistrarFinder {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let hir::ItemFn(..) = item.node {\n             if attr::contains_name(&item.attrs,\n@@ -32,6 +32,9 @@ impl<'v> Visitor<'v> for RegistrarFinder {\n             }\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }\n \n /// Find the function marked with `#[plugin_registrar]`, if any.\n@@ -42,7 +45,7 @@ pub fn find_plugin_registrar(diagnostic: &errors::Handler,\n     let krate = hir_map.krate();\n \n     let mut finder = RegistrarFinder { registrars: Vec::new() };\n-    krate.visit_all_items(&mut finder);\n+    krate.visit_all_item_likes(&mut finder);\n \n     match finder.registrars.len() {\n         0 => None,"}, {"sha": "b116408269e4dd10a3236b75ace6d4e961698295", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 79, "deletions": 59, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -31,6 +31,7 @@ use rustc::hir::{self, PatKind};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor};\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::lint;\n use rustc::middle::privacy::{AccessLevel, AccessLevels};\n@@ -115,15 +116,14 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        let tcx = self.tcx;\n-        self.visit_item(tcx.map.expect_item(item.id))\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n+        Some(&self.tcx.map)\n     }\n \n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let inherited_item_level = match item.node {\n             // Impls inherit level from their types and traits\n             hir::ItemImpl(.., None, ref ty, _) => {\n@@ -158,15 +158,17 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ItemImpl(.., None, _, ref impl_items) => {\n-                for impl_item in impl_items {\n+            hir::ItemImpl(.., None, _, ref impl_item_refs) => {\n+                for impl_item_ref in impl_item_refs {\n+                    let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n                     if impl_item.vis == hir::Public {\n                         self.update(impl_item.id, item_level);\n                     }\n                 }\n             }\n-            hir::ItemImpl(.., Some(_), _, ref impl_items) => {\n-                for impl_item in impl_items {\n+            hir::ItemImpl(.., Some(_), _, ref impl_item_refs) => {\n+                for impl_item_ref in impl_item_refs {\n+                    let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n                     self.update(impl_item.id, item_level);\n                 }\n             }\n@@ -249,11 +251,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             // The interface is empty\n             hir::ItemDefaultImpl(..) => {}\n             // Visit everything except for private impl items\n-            hir::ItemImpl(.., ref generics, None, _, ref impl_items) => {\n+            hir::ItemImpl(.., ref generics, None, _, ref impl_item_refs) => {\n                 if item_level.is_some() {\n                     self.reach().visit_generics(generics);\n-                    for impl_item in impl_items {\n-                        if self.get(impl_item.id).is_some() {\n+                    for impl_item_ref in impl_item_refs {\n+                        if self.get(impl_item_ref.id.node_id).is_some() {\n+                            let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n                             self.reach().visit_impl_item(impl_item);\n                         }\n                     }\n@@ -269,7 +272,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         self.prev_level = orig_level;\n     }\n \n-    fn visit_block(&mut self, b: &'v hir::Block) {\n+    fn visit_block(&mut self, b: &'tcx hir::Block) {\n         let orig_level = replace(&mut self.prev_level, None);\n \n         // Blocks can have public items, for example impls, but they always\n@@ -280,7 +283,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         self.prev_level = orig_level;\n     }\n \n-    fn visit_mod(&mut self, m: &hir::Mod, _sp: Span, id: ast::NodeId) {\n+    fn visit_mod(&mut self, m: &'tcx hir::Mod, _sp: Span, id: ast::NodeId) {\n         // This code is here instead of in visit_item so that the\n         // crate module gets processed as well.\n         if self.prev_level.is_some() {\n@@ -296,14 +299,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         intravisit::walk_mod(self, m, id);\n     }\n \n-    fn visit_macro_def(&mut self, md: &'v hir::MacroDef) {\n+    fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n         self.update(md.id, Some(AccessLevel::Public));\n     }\n }\n \n impl<'b, 'a, 'tcx: 'a> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n     // Make the type hidden under a type alias reachable\n-    fn reach_aliased_type(&mut self, item: &hir::Item, path: &hir::Path) {\n+    fn reach_aliased_type(&mut self, item: &'tcx hir::Item, path: &'tcx hir::Path) {\n         if let hir::ItemTy(ref ty, ref generics) = item.node {\n             // See `fn is_public_type_alias` for details\n             self.visit_ty(ty);\n@@ -317,8 +320,14 @@ impl<'b, 'a, 'tcx: 'a> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n     }\n }\n \n-impl<'b, 'a, 'tcx: 'a, 'v> Visitor<'v> for ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n-    fn visit_ty(&mut self, ty: &hir::Ty) {\n+impl<'b, 'a, 'tcx: 'a> Visitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n+    fn visit_nested_impl_item(&mut self, item_id: hir::ImplItemId) {\n+        // when we visit an impl, its methods and items are part of its \"interface\"\n+        let impl_item = self.ev.tcx.map.impl_item(item_id);\n+        self.visit_impl_item(impl_item)\n+    }\n+\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         if let hir::TyPath(_, ref path) = ty.node {\n             let def = self.ev.tcx.expect_def(ty.id);\n             match def {\n@@ -350,7 +359,7 @@ impl<'b, 'a, 'tcx: 'a, 'v> Visitor<'v> for ReachEverythingInTheInterfaceVisitor<\n         intravisit::walk_ty(self, ty);\n     }\n \n-    fn visit_trait_ref(&mut self, trait_ref: &hir::TraitRef) {\n+    fn visit_trait_ref(&mut self, trait_ref: &'tcx hir::TraitRef) {\n         let def_id = self.ev.tcx.expect_def(trait_ref.ref_id).def_id();\n         if let Some(node_id) = self.ev.tcx.map.as_local_node_id(def_id) {\n             let item = self.ev.tcx.map.expect_item(node_id);\n@@ -412,21 +421,20 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        let tcx = self.tcx;\n-        self.visit_item(tcx.map.expect_item(item.id))\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n+        Some(&self.tcx.map)\n     }\n \n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let orig_curitem = replace(&mut self.curitem, item.id);\n         intravisit::walk_item(self, item);\n         self.curitem = orig_curitem;\n     }\n \n-    fn visit_expr(&mut self, expr: &hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n@@ -486,7 +494,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         intravisit::walk_expr(self, expr);\n     }\n \n-    fn visit_pat(&mut self, pattern: &hir::Pat) {\n+    fn visit_pat(&mut self, pattern: &'tcx hir::Pat) {\n         // Foreign functions do not have their patterns mapped in the def_map,\n         // and there's nothing really relevant there anyway, so don't bother\n         // checking privacy. If you can name the type then you can pass it to an\n@@ -522,7 +530,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         intravisit::walk_pat(self, pattern);\n     }\n \n-    fn visit_foreign_item(&mut self, fi: &hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, fi: &'tcx hir::ForeignItem) {\n         self.in_foreign = true;\n         intravisit::walk_foreign_item(self, fi);\n         self.in_foreign = false;\n@@ -616,15 +624,14 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for ObsoleteCheckTypeForPrivatenessVisitor<'a\n     fn visit_expr(&mut self, _: &hir::Expr) {}\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        let tcx = self.tcx;\n-        self.visit_item(tcx.map.expect_item(item.id))\n+    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n+        Some(&self.tcx.map)\n     }\n \n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n             // contents of a private mod can be reexported, so we need\n             // to check internals.\n@@ -649,7 +656,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n             // (i.e. we could just return here to not check them at\n             // all, or some worse estimation of whether an impl is\n             // publicly visible).\n-            hir::ItemImpl(.., ref g, ref trait_ref, ref self_, ref impl_items) => {\n+            hir::ItemImpl(.., ref g, ref trait_ref, ref self_, ref impl_item_refs) => {\n                 // `impl [... for] Private` is never visible.\n                 let self_contains_private;\n                 // impl [... for] Public<...>, but not `impl [... for]\n@@ -694,16 +701,17 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n                 // are private (because `T` won't be visible externally).\n                 let trait_or_some_public_method =\n                     trait_ref.is_some() ||\n-                    impl_items.iter()\n-                              .any(|impl_item| {\n-                                  match impl_item.node {\n-                                      hir::ImplItemKind::Const(..) |\n-                                      hir::ImplItemKind::Method(..) => {\n-                                          self.access_levels.is_reachable(impl_item.id)\n-                                      }\n-                                      hir::ImplItemKind::Type(_) => false,\n-                                  }\n-                              });\n+                    impl_item_refs.iter()\n+                                 .any(|impl_item_ref| {\n+                                     let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n+                                     match impl_item.node {\n+                                         hir::ImplItemKind::Const(..) |\n+                                         hir::ImplItemKind::Method(..) => {\n+                                             self.access_levels.is_reachable(impl_item.id)\n+                                         }\n+                                         hir::ImplItemKind::Type(_) => false,\n+                                     }\n+                                 });\n \n                 if !self_contains_private &&\n                         not_private_trait &&\n@@ -713,12 +721,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n \n                     match *trait_ref {\n                         None => {\n-                            for impl_item in impl_items {\n+                            for impl_item_ref in impl_item_refs {\n                                 // This is where we choose whether to walk down\n                                 // further into the impl to check its items. We\n                                 // should only walk into public items so that we\n                                 // don't erroneously report errors for private\n                                 // types in private items.\n+                                let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n                                 match impl_item.node {\n                                     hir::ImplItemKind::Const(..) |\n                                     hir::ImplItemKind::Method(..)\n@@ -750,7 +759,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n                             intravisit::walk_path(self, &tr.path);\n \n                             // Those in 3. are warned with this call.\n-                            for impl_item in impl_items {\n+                            for impl_item_ref in impl_item_refs {\n+                                let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n                                 if let hir::ImplItemKind::Type(ref ty) = impl_item.node {\n                                     self.visit_ty(ty);\n                                 }\n@@ -761,7 +771,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n                     // impl Public<Private> { ... }. Any public static\n                     // methods will be visible as `Public::foo`.\n                     let mut found_pub_static = false;\n-                    for impl_item in impl_items {\n+                    for impl_item_ref in impl_item_refs {\n+                        let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n                         match impl_item.node {\n                             hir::ImplItemKind::Const(..) => {\n                                 if self.item_is_public(&impl_item.id, &impl_item.vis) {\n@@ -805,7 +816,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n         intravisit::walk_item(self, item);\n     }\n \n-    fn visit_generics(&mut self, generics: &hir::Generics) {\n+    fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n         for ty_param in generics.ty_params.iter() {\n             for bound in ty_param.bounds.iter() {\n                 self.check_ty_param_bound(bound)\n@@ -826,13 +837,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n         }\n     }\n \n-    fn visit_foreign_item(&mut self, item: &hir::ForeignItem) {\n+    fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem) {\n         if self.access_levels.is_reachable(item.id) {\n             intravisit::walk_foreign_item(self, item)\n         }\n     }\n \n-    fn visit_ty(&mut self, t: &hir::Ty) {\n+    fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n         if let hir::TyPath(..) = t.node {\n             if self.path_is_private_type(t.id) {\n                 self.old_error_set.insert(t.id);\n@@ -841,15 +852,18 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n         intravisit::walk_ty(self, t)\n     }\n \n-    fn visit_variant(&mut self, v: &hir::Variant, g: &hir::Generics, item_id: ast::NodeId) {\n+    fn visit_variant(&mut self,\n+                     v: &'tcx hir::Variant,\n+                     g: &'tcx hir::Generics,\n+                     item_id: ast::NodeId) {\n         if self.access_levels.is_reachable(v.node.data.id()) {\n             self.in_variant = true;\n             intravisit::walk_variant(self, v, g, item_id);\n             self.in_variant = false;\n         }\n     }\n \n-    fn visit_struct_field(&mut self, s: &hir::StructField) {\n+    fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n         if s.vis == hir::Public || self.in_variant {\n             intravisit::walk_struct_field(self, s);\n         }\n@@ -859,8 +873,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n     // expression/block context can't possibly contain exported things.\n     // (Making them no-ops stops us from traversing the whole AST without\n     // having to be super careful about our `walk_...` calls above.)\n-    fn visit_block(&mut self, _: &hir::Block) {}\n-    fn visit_expr(&mut self, _: &hir::Expr) {}\n+    fn visit_block(&mut self, _: &'tcx hir::Block) {}\n+    fn visit_expr(&mut self, _: &'tcx hir::Expr) {}\n }\n \n ///////////////////////////////////////////////////////////////////////////////\n@@ -1039,7 +1053,7 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         let min = |vis1: ty::Visibility, vis2| {\n             if vis1.is_at_least(vis2, &self.tcx.map) { vis2 } else { vis1 }\n@@ -1085,12 +1099,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tc\n             hir::ItemDefaultImpl(..) => {}\n             // An inherent impl is public when its type is public\n             // Subitems of inherent impls have their own publicity\n-            hir::ItemImpl(.., ref generics, None, ref ty, ref impl_items) => {\n+            hir::ItemImpl(.., ref generics, None, ref ty, ref impl_item_refs) => {\n                 let ty_vis = self.ty_visibility(ty);\n                 check.required_visibility = ty_vis;\n                 check.visit_generics(generics);\n \n-                for impl_item in impl_items {\n+                for impl_item_ref in impl_item_refs {\n+                    let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n                     let impl_item_vis =\n                         ty::Visibility::from_hir(&impl_item.vis, item.id, self.tcx);\n                     check.required_visibility = min(impl_item_vis, ty_vis);\n@@ -1099,16 +1114,21 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tc\n             }\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity\n-            hir::ItemImpl(.., ref generics, Some(ref trait_ref), ref ty, ref impl_items) => {\n+            hir::ItemImpl(.., ref generics, Some(ref trait_ref), ref ty, ref impl_item_refs) => {\n                 let vis = min(self.ty_visibility(ty), self.trait_ref_visibility(trait_ref));\n                 check.required_visibility = vis;\n                 check.visit_generics(generics);\n-                for impl_item in impl_items {\n+                for impl_item_ref in impl_item_refs {\n+                    let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n                     check.visit_impl_item(impl_item);\n                 }\n             }\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &'v hir::ImplItem) {\n+        // handled in `visit_item` above\n+    }\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -1161,7 +1181,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             tcx: tcx,\n             old_error_set: &visitor.old_error_set,\n         };\n-        krate.visit_all_items(&mut visitor);\n+        krate.visit_all_item_likes(&mut visitor);\n     }\n \n     visitor.access_levels"}, {"sha": "778f0184141651061552c44dbe7e0d655d84962f", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -536,7 +536,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 let def_id = if decl_id.is_local() {\n                     let ti = self.tcx.associated_item(decl_id);\n                     self.tcx.associated_items(ti.container.id())\n-                        .find(|item| item.name == ti.name && item.has_value)\n+                        .find(|item| item.name == ti.name && item.defaultness.has_value())\n                         .map(|item| item.def_id)\n                 } else {\n                     None"}, {"sha": "df56e27128c7ec65d01f303c0b936f1f27249a6f", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -600,13 +600,8 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // reference. It also occurs when testing libcore and in some\n     // other weird situations. Annoying.\n \n-    let fn_ptr_ty = match fn_ty.sty {\n-        ty::TyFnDef(.., fty) => {\n-            // Create a fn pointer with the substituted signature.\n-            tcx.mk_fn_ptr(fty)\n-        }\n-        _ => bug!(\"expected fn item type, found {}\", fn_ty)\n-    };\n+    // Create a fn pointer with the substituted signature.\n+    let fn_ptr_ty = tcx.mk_fn_ptr(tcx.mk_bare_fn(common::ty_fn_ty(ccx, fn_ty).into_owned()));\n     let llptrty = type_of::type_of(ccx, fn_ptr_ty);\n \n     let llfn = if let Some(llfn) = declare::get_declared_value(ccx, &sym) {"}, {"sha": "5902b0b1ce0755ec463354d90e634ef69fd4cc91", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -189,7 +189,7 @@\n //! regardless of whether it is actually needed or not.\n \n use rustc::hir;\n-use rustc::hir::intravisit as hir_visit;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n@@ -306,10 +306,9 @@ fn collect_roots<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             scx: scx,\n             mode: mode,\n             output: &mut roots,\n-            enclosing_item: None,\n         };\n \n-        scx.tcx().map.krate().visit_all_items(&mut visitor);\n+        scx.tcx().map.krate().visit_all_item_likes(&mut visitor);\n     }\n \n     roots\n@@ -1030,14 +1029,10 @@ struct RootCollector<'b, 'a: 'b, 'tcx: 'a + 'b> {\n     scx: &'b SharedCrateContext<'a, 'tcx>,\n     mode: TransItemCollectionMode,\n     output: &'b mut Vec<TransItem<'tcx>>,\n-    enclosing_item: Option<&'tcx hir::Item>,\n }\n \n-impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n+impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n-        let old_enclosing_item = self.enclosing_item;\n-        self.enclosing_item = Some(item);\n-\n         match item.node {\n             hir::ItemExternCrate(..) |\n             hir::ItemUse(..)         |\n@@ -1094,9 +1089,6 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                 }\n             }\n         }\n-\n-        hir_visit::walk_item(self, item);\n-        self.enclosing_item = old_enclosing_item;\n     }\n \n     fn visit_impl_item(&mut self, ii: &'v hir::ImplItem) {\n@@ -1131,8 +1123,6 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n             }\n             _ => { /* Nothing to do here */ }\n         }\n-\n-        hir_visit::walk_impl_item(self, ii)\n     }\n }\n \n@@ -1145,7 +1135,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n                       _,\n                       ref generics,\n                       ..,\n-                      ref items) => {\n+                      ref impl_item_refs) => {\n             if generics.is_type_parameterized() {\n                 return\n             }\n@@ -1157,9 +1147,10 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n \n             if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n                 let callee_substs = tcx.erase_regions(&trait_ref.substs);\n-                let overridden_methods: FxHashSet<_> = items.iter()\n-                                                            .map(|item| item.name)\n-                                                            .collect();\n+                let overridden_methods: FxHashSet<_> =\n+                    impl_item_refs.iter()\n+                                  .map(|iiref| iiref.name)\n+                                  .collect();\n                 for method in tcx.provided_trait_methods(trait_ref.def_id) {\n                     if overridden_methods.contains(&method.name) {\n                         continue;"}, {"sha": "aa23a1817227657f8e71aad3d0051ca8ae4c8082", "filename": "src/librustc_trans/symbol_names_test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_names_test.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -35,7 +35,8 @@ pub fn report_symbol_names(scx: &SharedCrateContext) {\n \n     let _ignore = tcx.dep_graph.in_ignore();\n     let mut visitor = SymbolNamesTest { scx: scx };\n-    tcx.map.krate().visit_all_items(&mut visitor);\n+    // FIXME(#37712) could use ItemLikeVisitor if trait items were item-like\n+    tcx.map.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n }\n \n struct SymbolNamesTest<'a, 'tcx:'a> {"}, {"sha": "f08d26373e50e979ef977f2c2346a77275eda918", "filename": "src/librustc_typeck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2FCargo.toml?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -18,6 +18,7 @@ rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_platform_intrinsics = { path = \"../librustc_platform_intrinsics\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "4ae15740cf2a66a66a3065a5b9b99a994cbc28f5", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -439,7 +439,7 @@ impl Ord for TraitInfo {\n /// Retrieve all traits in this crate and any dependent crates.\n pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n     if ccx.all_traits.borrow().is_none() {\n-        use rustc::hir::intravisit;\n+        use rustc::hir::itemlikevisit;\n \n         let mut traits = vec![];\n \n@@ -450,7 +450,7 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n             map: &'a hir_map::Map<'tcx>,\n             traits: &'a mut AllTraitsVec,\n         }\n-        impl<'v, 'a, 'tcx> intravisit::Visitor<'v> for Visitor<'a, 'tcx> {\n+        impl<'v, 'a, 'tcx> itemlikevisit::ItemLikeVisitor<'v> for Visitor<'a, 'tcx> {\n             fn visit_item(&mut self, i: &'v hir::Item) {\n                 match i.node {\n                     hir::ItemTrait(..) => {\n@@ -460,8 +460,11 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n                     _ => {}\n                 }\n             }\n+\n+            fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+            }\n         }\n-        ccx.tcx.map.krate().visit_all_items(&mut Visitor {\n+        ccx.tcx.map.krate().visit_all_item_likes(&mut Visitor {\n             map: &ccx.tcx.map,\n             traits: &mut traits,\n         });"}, {"sha": "f08178e49fb2e835eb12768c32ec484ffa076e35", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -121,6 +121,7 @@ use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{self, BytePos, Span};\n \n use rustc::hir::intravisit::{self, Visitor};\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::{self, PatKind};\n use rustc::hir::print as pprust;\n use rustc_back::slice;\n@@ -525,30 +526,35 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &'tcx hir::Item) {\n         check_item_body(self.ccx, i);\n     }\n+\n+    fn visit_impl_item(&mut self, _item: &'tcx hir::ImplItem) {\n+        // done as part of `visit_item` above\n+    }\n }\n \n pub fn check_wf_new(ccx: &CrateCtxt) -> CompileResult {\n     ccx.tcx.sess.track_errors(|| {\n         let mut visit = wfcheck::CheckTypeWellFormedVisitor::new(ccx);\n-        ccx.tcx.visit_all_items_in_krate(DepNode::WfCheck, &mut visit);\n+        ccx.tcx.visit_all_item_likes_in_krate(DepNode::WfCheck, &mut visit.as_deep_visitor());\n     })\n }\n \n pub fn check_item_types(ccx: &CrateCtxt) -> CompileResult {\n     ccx.tcx.sess.track_errors(|| {\n         let mut visit = CheckItemTypesVisitor { ccx: ccx };\n-        ccx.tcx.visit_all_items_in_krate(DepNode::TypeckItemType, &mut visit);\n+        ccx.tcx.visit_all_item_likes_in_krate(DepNode::TypeckItemType,\n+                                              &mut visit.as_deep_visitor());\n     })\n }\n \n pub fn check_item_bodies(ccx: &CrateCtxt) -> CompileResult {\n     ccx.tcx.sess.track_errors(|| {\n         let mut visit = CheckItemBodiesVisitor { ccx: ccx };\n-        ccx.tcx.visit_all_items_in_krate(DepNode::TypeckItemBody, &mut visit);\n+        ccx.tcx.visit_all_item_likes_in_krate(DepNode::TypeckItemBody, &mut visit);\n \n         // Process deferred obligations, now that all functions\n         // bodies have been fully inferred.\n@@ -809,15 +815,15 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n                             it.id);\n       }\n       hir::ItemFn(..) => {} // entirely within check_item_body\n-      hir::ItemImpl(.., ref impl_items) => {\n+      hir::ItemImpl(.., ref impl_item_refs) => {\n           debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n           let impl_def_id = ccx.tcx.map.local_def_id(it.id);\n           if let Some(impl_trait_ref) = ccx.tcx.impl_trait_ref(impl_def_id) {\n               check_impl_items_against_trait(ccx,\n                                              it.span,\n                                              impl_def_id,\n                                              impl_trait_ref,\n-                                             impl_items);\n+                                             impl_item_refs);\n               let trait_def_id = impl_trait_ref.def_id;\n               check_on_unimplemented(ccx, trait_def_id, it);\n           }\n@@ -879,10 +885,11 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n       hir::ItemFn(ref decl, .., ref body) => {\n         check_bare_fn(ccx, &decl, &body, it.id, it.span);\n       }\n-      hir::ItemImpl(.., ref impl_items) => {\n+      hir::ItemImpl(.., ref impl_item_refs) => {\n         debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n \n-        for impl_item in impl_items {\n+        for impl_item_ref in impl_item_refs {\n+            let impl_item = ccx.tcx.map.impl_item(impl_item_ref.id);\n             match impl_item.node {\n                 hir::ImplItemKind::Const(_, ref expr) => {\n                     check_const(ccx, &expr, impl_item.id)\n@@ -1019,7 +1026,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                             impl_span: Span,\n                                             impl_id: DefId,\n                                             impl_trait_ref: ty::TraitRef<'tcx>,\n-                                            impl_items: &[hir::ImplItem]) {\n+                                            impl_item_refs: &[hir::ImplItemRef]) {\n     // If the trait reference itself is erroneous (so the compilation is going\n     // to fail), skip checking the items here -- the `impl_item` table in `tcx`\n     // isn't populated for such impls.\n@@ -1030,9 +1037,11 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let trait_def = tcx.lookup_trait_def(impl_trait_ref.def_id);\n     let mut overridden_associated_type = None;\n \n+    let impl_items = || impl_item_refs.iter().map(|iiref| ccx.tcx.map.impl_item(iiref.id));\n+\n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n-    for impl_item in impl_items {\n+    for impl_item in impl_items() {\n         let ty_impl_item = tcx.associated_item(tcx.map.local_def_id(impl_item.id));\n         let ty_trait_item = tcx.associated_items(impl_trait_ref.def_id)\n             .find(|ac| ac.name == ty_impl_item.name);\n@@ -1101,7 +1110,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 }\n                 hir::ImplItemKind::Type(_) => {\n                     if ty_trait_item.kind == ty::AssociatedKind::Type {\n-                        if ty_trait_item.has_value {\n+                        if ty_trait_item.defaultness.has_value() {\n                             overridden_associated_type = Some(impl_item);\n                         }\n                     } else {\n@@ -1135,7 +1144,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             .unwrap_or(false);\n \n         if !is_implemented {\n-            if !trait_item.has_value {\n+            if !trait_item.defaultness.has_value() {\n                 missing_items.push(trait_item);\n             } else if associated_type_overridden {\n                 invalidated_items.push(trait_item.name);"}, {"sha": "1ad81660f836a40b84b46bd6296ed7a226672dbb", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -203,7 +203,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                                                free_id_outlive, self_ty);\n                 }\n                 ty::AssociatedKind::Type => {\n-                    if item.has_value {\n+                    if item.defaultness.has_value() {\n                         let ty = fcx.tcx.item_type(item.def_id);\n                         let ty = fcx.instantiate_type_scheme(span, free_substs, &ty);\n                         fcx.register_wf_obligation(ty, span, code.clone());"}, {"sha": "b4a10c52270e2f9f5560ec8e02e1a1668dcfa1d0", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -16,7 +16,7 @@ use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n \n use rustc::hir;\n-use rustc::hir::intravisit::Visitor;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n struct UnusedTraitImportVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -40,7 +40,7 @@ impl<'a, 'tcx> UnusedTraitImportVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for UnusedTraitImportVisitor<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for UnusedTraitImportVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if item.vis == hir::Public || item.span == DUMMY_SP {\n             return;\n@@ -58,10 +58,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for UnusedTraitImportVisitor<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _task = tcx.dep_graph.in_task(DepNode::UnusedTraitCheck);\n     let mut visitor = UnusedTraitImportVisitor { tcx: tcx };\n-    tcx.map.krate().visit_all_items(&mut visitor);\n+    tcx.map.krate().visit_all_item_likes(&mut visitor);\n }"}, {"sha": "2663739e36b289462876c1d6d072aa63218c3d5a", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -34,7 +34,7 @@ use rustc::infer::{self, InferCtxt};\n use syntax_pos::Span;\n use rustc::dep_graph::DepNode;\n use rustc::hir::map as hir_map;\n-use rustc::hir::intravisit;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::{Item, ItemImpl};\n use rustc::hir;\n \n@@ -51,12 +51,15 @@ struct CoherenceCheckVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     cc: &'a CoherenceChecker<'a, 'gcx, 'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx, 'v> intravisit::Visitor<'v> for CoherenceCheckVisitor<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx, 'v> ItemLikeVisitor<'v> for CoherenceCheckVisitor<'a, 'gcx, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n         if let ItemImpl(..) = item.node {\n             self.cc.check_implementation(item)\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n@@ -87,8 +90,9 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n         // Check implementations and traits. This populates the tables\n         // containing the inherent methods and extension methods. It also\n         // builds up the trait inheritance table.\n-        self.crate_context.tcx.visit_all_items_in_krate(DepNode::CoherenceCheckImpl,\n-                                                        &mut CoherenceCheckVisitor { cc: self });\n+        self.crate_context.tcx.visit_all_item_likes_in_krate(\n+            DepNode::CoherenceCheckImpl,\n+            &mut CoherenceCheckVisitor { cc: self });\n \n         // Populate the table of destructors. It might seem a bit strange to\n         // do this here, but it's actually the most convenient place, since"}, {"sha": "a507077bef77e21eb27b11619cc8d5d40ee625a3", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -17,12 +17,12 @@ use rustc::ty::{self, TyCtxt};\n use syntax::ast;\n use syntax_pos::Span;\n use rustc::dep_graph::DepNode;\n-use rustc::hir::intravisit;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir;\n \n pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut orphan = OrphanChecker { tcx: tcx };\n-    tcx.visit_all_items_in_krate(DepNode::CoherenceOrphanCheck, &mut orphan);\n+    tcx.visit_all_item_likes_in_krate(DepNode::CoherenceOrphanCheck, &mut orphan);\n }\n \n struct OrphanChecker<'cx, 'tcx: 'cx> {\n@@ -380,8 +380,12 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'tcx, 'v> intravisit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n+impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         self.check_item(item);\n     }\n+\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }"}, {"sha": "e5be7f63067a886231cff304d6556557ca230161", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -18,7 +18,7 @@ use rustc::ty::{self, TyCtxt, TypeFoldable};\n use syntax::ast;\n use rustc::dep_graph::DepNode;\n use rustc::hir;\n-use rustc::hir::intravisit;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use util::nodemap::DefIdMap;\n use lint;\n \n@@ -30,7 +30,7 @@ pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n     // this secondary walk specifically checks for some other cases,\n     // like defaulted traits, for which additional overlap rules exist\n-    tcx.visit_all_items_in_krate(DepNode::CoherenceOverlapCheckSpecial, &mut overlap);\n+    tcx.visit_all_item_likes_in_krate(DepNode::CoherenceOverlapCheckSpecial, &mut overlap);\n }\n \n struct OverlapChecker<'cx, 'tcx: 'cx> {\n@@ -97,7 +97,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'tcx, 'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n+impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OverlapChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n             hir::ItemEnum(..) |\n@@ -205,4 +205,7 @@ impl<'cx, 'tcx, 'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n             _ => {}\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }"}, {"sha": "6d5de8f250655e614603578355481a5ed210bc34", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -12,12 +12,12 @@\n //! crate or pertains to a type defined in this crate.\n \n use rustc::ty::TyCtxt;\n-use rustc::hir::intravisit;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::{self, Unsafety};\n \n pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    let mut orphan = UnsafetyChecker { tcx: tcx };\n-    tcx.map.krate().visit_all_items(&mut orphan);\n+    let mut unsafety = UnsafetyChecker { tcx: tcx };\n+    tcx.map.krate().visit_all_item_likes(&mut unsafety);\n }\n \n struct UnsafetyChecker<'cx, 'tcx: 'cx> {\n@@ -94,7 +94,7 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'tcx, 'v> intravisit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n+impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n             hir::ItemDefaultImpl(unsafety, _) => {\n@@ -106,4 +106,7 @@ impl<'cx, 'tcx, 'v> intravisit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n             _ => {}\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }"}, {"sha": "535b6bcdcba177dff99ac1d7429bbbcc54cbfaf9", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 62, "deletions": 178, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -77,13 +77,13 @@ use CrateCtxt;\n use rustc_const_math::ConstInt;\n \n use std::cell::RefCell;\n-use std::collections::hash_map::Entry::{Occupied, Vacant};\n \n use syntax::{abi, ast, attr};\n use syntax::parse::token::{self, keywords};\n use syntax_pos::Span;\n \n-use rustc::hir::{self, intravisit, map as hir_map, print as pprust};\n+use rustc::hir::{self, map as hir_map, print as pprust};\n+use rustc::hir::intravisit::{self, Visitor};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n \n@@ -92,7 +92,7 @@ use rustc::hir::def_id::DefId;\n \n pub fn collect_item_types(ccx: &CrateCtxt) {\n     let mut visitor = CollectItemTypesVisitor { ccx: ccx };\n-    ccx.tcx.visit_all_items_in_krate(DepNode::CollectItem, &mut visitor);\n+    ccx.tcx.visit_all_item_likes_in_krate(DepNode::CollectItem, &mut visitor.as_deep_visitor());\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -128,7 +128,7 @@ struct CollectItemTypesVisitor<'a, 'tcx: 'a> {\n     ccx: &'a CrateCtxt<'a, 'tcx>\n }\n \n-impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         convert_item(self.ccx, item);\n         intravisit::walk_item(self, item);\n@@ -148,6 +148,11 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx>\n         }\n         intravisit::walk_ty(self, ty);\n     }\n+\n+    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n+        convert_impl_item(self.ccx, impl_item);\n+        intravisit::walk_impl_item(self, impl_item);\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -726,7 +731,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                       ref generics,\n                       ref opt_trait_ref,\n                       ref selfty,\n-                      ref impl_items) => {\n+                      _) => {\n             // Create generics from the generics specified in the impl head.\n             debug!(\"convert: ast_generics={:?}\", generics);\n             let def_id = ccx.tcx.map.local_def_id(it.id);\n@@ -747,73 +752,16 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             });\n             tcx.impl_trait_refs.borrow_mut().insert(def_id, trait_ref);\n \n-            enforce_impl_params_are_constrained(ccx, generics, &mut ty_predicates, def_id);\n-            tcx.predicates.borrow_mut().insert(def_id, ty_predicates.clone());\n-\n-\n-            // Convert all the associated consts.\n-            // Also, check if there are any duplicate associated items\n-            let mut seen_type_items = FxHashMap();\n-            let mut seen_value_items = FxHashMap();\n-\n-            for impl_item in impl_items {\n-                let seen_items = match impl_item.node {\n-                    hir::ImplItemKind::Type(_) => &mut seen_type_items,\n-                    _                    => &mut seen_value_items,\n-                };\n-                match seen_items.entry(impl_item.name) {\n-                    Occupied(entry) => {\n-                        let mut err = struct_span_err!(tcx.sess, impl_item.span, E0201,\n-                                                       \"duplicate definitions with name `{}`:\",\n-                                                       impl_item.name);\n-                        err.span_label(*entry.get(),\n-                                   &format!(\"previous definition of `{}` here\",\n-                                        impl_item.name));\n-                        err.span_label(impl_item.span, &format!(\"duplicate definition\"));\n-                        err.emit();\n-                    }\n-                    Vacant(entry) => {\n-                        entry.insert(impl_item.span);\n-                    }\n-                }\n-\n-                if let hir::ImplItemKind::Const(ref ty, _) = impl_item.node {\n-                    let const_def_id = ccx.tcx.map.local_def_id(impl_item.id);\n-                    generics_of_def_id(ccx, const_def_id);\n-                    let ty = ccx.icx(&ty_predicates)\n-                                .to_ty(&ExplicitRscope, &ty);\n-                    tcx.item_types.borrow_mut().insert(const_def_id, ty);\n-                    convert_associated_const(ccx, ImplContainer(def_id),\n-                                             impl_item.id, ty);\n-                }\n-            }\n-\n-            // Convert all the associated types.\n-            for impl_item in impl_items {\n-                if let hir::ImplItemKind::Type(ref ty) = impl_item.node {\n-                    let type_def_id = ccx.tcx.map.local_def_id(impl_item.id);\n-                    generics_of_def_id(ccx, type_def_id);\n-\n-                    if opt_trait_ref.is_none() {\n-                        span_err!(tcx.sess, impl_item.span, E0202,\n-                                  \"associated types are not allowed in inherent impls\");\n-                    }\n-\n-                    let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, ty);\n-\n-                    convert_associated_type(ccx, ImplContainer(def_id), impl_item.id, Some(typ));\n-                }\n-            }\n-\n-            for impl_item in impl_items {\n-                if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n-                    convert_method(ccx, ImplContainer(def_id),\n-                                   impl_item.id, sig, selfty,\n-                                   &ty_predicates);\n-                }\n-            }\n+            // Subtle: before we store the predicates into the tcx, we\n+            // sort them so that predicates like `T: Foo<Item=U>` come\n+            // before uses of `U`.  This avoids false ambiguity errors\n+            // in trait checking. See `setup_constraining_predicates`\n+            // for details.\n+            ctp::setup_constraining_predicates(&mut ty_predicates.predicates,\n+                                               trait_ref,\n+                                               &mut ctp::parameters_for_impl(selfty, trait_ref));\n \n-            enforce_impl_lifetimes_are_constrained(ccx, generics, def_id, impl_items);\n+            tcx.predicates.borrow_mut().insert(def_id, ty_predicates.clone());\n         },\n         hir::ItemTrait(.., ref trait_items) => {\n             let trait_def = trait_def_of_item(ccx, it);\n@@ -899,6 +847,49 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n     }\n }\n \n+fn convert_impl_item(ccx: &CrateCtxt, impl_item: &hir::ImplItem) {\n+    let tcx = ccx.tcx;\n+\n+    // we can lookup details about the impl because items are visited\n+    // before impl-items\n+    let impl_def_id = tcx.map.get_parent_did(impl_item.id);\n+    let impl_predicates = tcx.item_predicates(impl_def_id);\n+    let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n+    let impl_self_ty = tcx.item_type(impl_def_id);\n+\n+    match impl_item.node {\n+        hir::ImplItemKind::Const(ref ty, _) => {\n+            let const_def_id = ccx.tcx.map.local_def_id(impl_item.id);\n+            generics_of_def_id(ccx, const_def_id);\n+            let ty = ccx.icx(&impl_predicates)\n+                        .to_ty(&ExplicitRscope, &ty);\n+            tcx.item_types.borrow_mut().insert(const_def_id, ty);\n+            convert_associated_const(ccx, ImplContainer(impl_def_id),\n+                                     impl_item.id, ty);\n+        }\n+\n+        hir::ImplItemKind::Type(ref ty) => {\n+            let type_def_id = ccx.tcx.map.local_def_id(impl_item.id);\n+            generics_of_def_id(ccx, type_def_id);\n+\n+            if impl_trait_ref.is_none() {\n+                span_err!(tcx.sess, impl_item.span, E0202,\n+                          \"associated types are not allowed in inherent impls\");\n+            }\n+\n+            let typ = ccx.icx(&impl_predicates).to_ty(&ExplicitRscope, ty);\n+\n+            convert_associated_type(ccx, ImplContainer(impl_def_id), impl_item.id, Some(typ));\n+        }\n+\n+        hir::ImplItemKind::Method(ref sig, _) => {\n+            convert_method(ccx, ImplContainer(impl_def_id),\n+                           impl_item.id, sig, impl_self_ty,\n+                           &impl_predicates);\n+        }\n+    }\n+}\n+\n fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                   ctor_id: ast::NodeId,\n                                   variant: ty::VariantDef<'tcx>,\n@@ -2067,110 +2058,3 @@ pub fn mk_item_substs<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n                      |def, _| tcx.mk_region(def.to_early_bound_region()),\n                      |def, _| tcx.mk_param_from_def(def))\n }\n-\n-/// Checks that all the type parameters on an impl\n-fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                                 generics: &hir::Generics,\n-                                                 impl_predicates: &mut ty::GenericPredicates<'tcx>,\n-                                                 impl_def_id: DefId)\n-{\n-    let impl_ty = ccx.tcx.item_type(impl_def_id);\n-    let impl_trait_ref = ccx.tcx.impl_trait_ref(impl_def_id);\n-\n-    // The trait reference is an input, so find all type parameters\n-    // reachable from there, to start (if this is an inherent impl,\n-    // then just examine the self type).\n-    let mut input_parameters: FxHashSet<_> =\n-        ctp::parameters_for(&impl_ty, false).into_iter().collect();\n-    if let Some(ref trait_ref) = impl_trait_ref {\n-        input_parameters.extend(ctp::parameters_for(trait_ref, false));\n-    }\n-\n-    ctp::setup_constraining_predicates(&mut impl_predicates.predicates,\n-                                       impl_trait_ref,\n-                                       &mut input_parameters);\n-\n-    let ty_generics = generics_of_def_id(ccx, impl_def_id);\n-    for (ty_param, param) in ty_generics.types.iter().zip(&generics.ty_params) {\n-        let param_ty = ty::ParamTy::for_def(ty_param);\n-        if !input_parameters.contains(&ctp::Parameter::from(param_ty)) {\n-            report_unused_parameter(ccx, param.span, \"type\", &param_ty.to_string());\n-        }\n-    }\n-}\n-\n-fn enforce_impl_lifetimes_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                                    ast_generics: &hir::Generics,\n-                                                    impl_def_id: DefId,\n-                                                    impl_items: &[hir::ImplItem])\n-{\n-    // Every lifetime used in an associated type must be constrained.\n-    let impl_ty = ccx.tcx.item_type(impl_def_id);\n-    let impl_predicates = ccx.tcx.item_predicates(impl_def_id);\n-    let impl_trait_ref = ccx.tcx.impl_trait_ref(impl_def_id);\n-\n-    let mut input_parameters: FxHashSet<_> =\n-        ctp::parameters_for(&impl_ty, false).into_iter().collect();\n-    if let Some(ref trait_ref) = impl_trait_ref {\n-        input_parameters.extend(ctp::parameters_for(trait_ref, false));\n-    }\n-    ctp::identify_constrained_type_params(\n-        &impl_predicates.predicates.as_slice(), impl_trait_ref, &mut input_parameters);\n-\n-    let lifetimes_in_associated_types: FxHashSet<_> = impl_items.iter()\n-        .map(|item|  ccx.tcx.map.local_def_id(item.id))\n-        .filter(|&def_id| {\n-            let item = ccx.tcx.associated_item(def_id);\n-            item.kind == ty::AssociatedKind::Type && item.has_value\n-        })\n-        .flat_map(|def_id| {\n-            ctp::parameters_for(&ccx.tcx.item_type(def_id), true)\n-        }).collect();\n-\n-    for (ty_lifetime, lifetime) in ccx.tcx.item_generics(impl_def_id).regions.iter()\n-        .zip(&ast_generics.lifetimes)\n-    {\n-        let param = ctp::Parameter::from(ty_lifetime.to_early_bound_region_data());\n-\n-        if\n-            lifetimes_in_associated_types.contains(&param) && // (*)\n-            !input_parameters.contains(&param)\n-        {\n-            report_unused_parameter(ccx, lifetime.lifetime.span,\n-                                    \"lifetime\", &lifetime.lifetime.name.to_string());\n-        }\n-    }\n-\n-    // (*) This is a horrible concession to reality. I think it'd be\n-    // better to just ban unconstrianed lifetimes outright, but in\n-    // practice people do non-hygenic macros like:\n-    //\n-    // ```\n-    // macro_rules! __impl_slice_eq1 {\n-    //     ($Lhs: ty, $Rhs: ty, $Bound: ident) => {\n-    //         impl<'a, 'b, A: $Bound, B> PartialEq<$Rhs> for $Lhs where A: PartialEq<B> {\n-    //            ....\n-    //         }\n-    //     }\n-    // }\n-    // ```\n-    //\n-    // In a concession to backwards compatbility, we continue to\n-    // permit those, so long as the lifetimes aren't used in\n-    // associated types. I believe this is sound, because lifetimes\n-    // used elsewhere are not projected back out.\n-}\n-\n-fn report_unused_parameter(ccx: &CrateCtxt,\n-                           span: Span,\n-                           kind: &str,\n-                           name: &str)\n-{\n-    struct_span_err!(\n-        ccx.tcx.sess, span, E0207,\n-        \"the {} parameter `{}` is not constrained by the \\\n-        impl trait, self type, or predicates\",\n-        kind, name)\n-        .span_label(span, &format!(\"unconstrained {} parameter\", kind))\n-        .emit();\n-}"}, {"sha": "22be4491273ef751ecdfd351bef02aa3e317ed80", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -23,6 +23,18 @@ impl From<ty::EarlyBoundRegion> for Parameter {\n     fn from(param: ty::EarlyBoundRegion) -> Self { Parameter(param.index) }\n }\n \n+/// Return the set of parameters constrained by the impl header.\n+pub fn parameters_for_impl<'tcx>(impl_self_ty: Ty<'tcx>,\n+                                 impl_trait_ref: Option<ty::TraitRef<'tcx>>)\n+                                 -> FxHashSet<Parameter>\n+{\n+    let vec = match impl_trait_ref {\n+        Some(tr) => parameters_for(&tr, false),\n+        None => parameters_for(&impl_self_ty, false),\n+    };\n+    vec.into_iter().collect()\n+}\n+\n /// If `include_projections` is false, returns the list of parameters that are\n /// constrained by `t` - i.e. the value of each parameter in the list is\n /// uniquely determined by `t` (see RFC 447). If it is true, return the list"}, {"sha": "9f5b73d9b30752ed45f31aead3cda46a24e9958b", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -0,0 +1,203 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This pass enforces various \"well-formedness constraints\" on impls.\n+//! Logically, it is part of wfcheck -- but we do it early so that we\n+//! can stop compilation afterwards, since part of the trait matching\n+//! infrastructure gets very grumpy if these conditions don't hold. In\n+//! particular, if there are type parameters that are not part of the\n+//! impl, then coherence will report strange inference ambiguity\n+//! errors; if impls have duplicate items, we get misleading\n+//! specialization errors. These things can (and probably should) be\n+//! fixed, but for the moment it's easier to do these checks early.\n+\n+use constrained_type_params as ctp;\n+use rustc::dep_graph::DepNode;\n+use rustc::hir;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n+use rustc::hir::def_id::DefId;\n+use rustc::ty;\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n+use std::collections::hash_map::Entry::{Occupied, Vacant};\n+\n+use syntax_pos::Span;\n+\n+use CrateCtxt;\n+\n+/// Checks that all the type/lifetime parameters on an impl also\n+/// appear in the trait ref or self-type (or are constrained by a\n+/// where-clause). These rules are needed to ensure that, given a\n+/// trait ref like `<T as Trait<U>>`, we can derive the values of all\n+/// parameters on the impl (which is needed to make specialization\n+/// possible).\n+///\n+/// However, in the case of lifetimes, we only enforce these rules if\n+/// the lifetime parameter is used in an associated type.  This is a\n+/// concession to backwards compatibility; see comment at the end of\n+/// the fn for details.\n+///\n+/// Example:\n+///\n+/// ```\n+/// impl<T> Trait<Foo> for Bar { ... }\n+///      ^ T does not appear in `Foo` or `Bar`, error!\n+///\n+/// impl<T> Trait<Foo<T>> for Bar { ... }\n+///      ^ T appears in `Foo<T>`, ok.\n+///\n+/// impl<T> Trait<Foo> for Bar where Bar: Iterator<Item=T> { ... }\n+///      ^ T is bound to `<Bar as Iterator>::Item`, ok.\n+///\n+/// impl<'a> Trait<Foo> for Bar { }\n+///      ^ 'a is unused, but for back-compat we allow it\n+///\n+/// impl<'a> Trait<Foo> for Bar { type X = &'a i32; }\n+///      ^ 'a is unused and appears in assoc type, error\n+/// ```\n+pub fn impl_wf_check<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>) {\n+    // We will tag this as part of the WF check -- logically, it is,\n+    // but it's one that we must perform earlier than the rest of\n+    // WfCheck.\n+    ccx.tcx.visit_all_item_likes_in_krate(DepNode::WfCheck, &mut ImplWfCheck { ccx: ccx });\n+}\n+\n+struct ImplWfCheck<'a, 'tcx: 'a> {\n+    ccx: &'a CrateCtxt<'a, 'tcx>,\n+}\n+\n+impl<'a, 'tcx> ItemLikeVisitor<'tcx> for ImplWfCheck<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        match item.node {\n+            hir::ItemImpl(.., ref generics, _, _, ref impl_item_refs) => {\n+                let impl_def_id = self.ccx.tcx.map.local_def_id(item.id);\n+                enforce_impl_params_are_constrained(self.ccx,\n+                                                    generics,\n+                                                    impl_def_id,\n+                                                    impl_item_refs);\n+                enforce_impl_items_are_distinct(self.ccx, impl_item_refs);\n+            }\n+            _ => { }\n+        }\n+    }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &'tcx hir::ImplItem) { }\n+}\n+\n+fn enforce_impl_params_are_constrained<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                                 impl_hir_generics: &hir::Generics,\n+                                                 impl_def_id: DefId,\n+                                                 impl_item_refs: &[hir::ImplItemRef])\n+{\n+    // Every lifetime used in an associated type must be constrained.\n+    let impl_self_ty = ccx.tcx.item_type(impl_def_id);\n+    let impl_generics = ccx.tcx.item_generics(impl_def_id);\n+    let impl_predicates = ccx.tcx.item_predicates(impl_def_id);\n+    let impl_trait_ref = ccx.tcx.impl_trait_ref(impl_def_id);\n+\n+    let mut input_parameters = ctp::parameters_for_impl(impl_self_ty, impl_trait_ref);\n+    ctp::identify_constrained_type_params(\n+        &impl_predicates.predicates.as_slice(), impl_trait_ref, &mut input_parameters);\n+\n+    // Disallow ANY unconstrained type parameters.\n+    for (ty_param, param) in impl_generics.types.iter().zip(&impl_hir_generics.ty_params) {\n+        let param_ty = ty::ParamTy::for_def(ty_param);\n+        if !input_parameters.contains(&ctp::Parameter::from(param_ty)) {\n+            report_unused_parameter(ccx, param.span, \"type\", &param_ty.to_string());\n+        }\n+    }\n+\n+    // Disallow unconstrained lifetimes, but only if they appear in assoc types.\n+    let lifetimes_in_associated_types: FxHashSet<_> = impl_item_refs.iter()\n+        .map(|item_ref|  ccx.tcx.map.local_def_id(item_ref.id.node_id))\n+        .filter(|&def_id| {\n+            let item = ccx.tcx.associated_item(def_id);\n+            item.kind == ty::AssociatedKind::Type && item.defaultness.has_value()\n+        })\n+        .flat_map(|def_id| {\n+            ctp::parameters_for(&ccx.tcx.item_type(def_id), true)\n+        }).collect();\n+    for (ty_lifetime, lifetime) in impl_generics.regions.iter()\n+        .zip(&impl_hir_generics.lifetimes)\n+    {\n+        let param = ctp::Parameter::from(ty_lifetime.to_early_bound_region_data());\n+\n+        if\n+            lifetimes_in_associated_types.contains(&param) && // (*)\n+            !input_parameters.contains(&param)\n+        {\n+            report_unused_parameter(ccx, lifetime.lifetime.span,\n+                                    \"lifetime\", &lifetime.lifetime.name.to_string());\n+        }\n+    }\n+\n+    // (*) This is a horrible concession to reality. I think it'd be\n+    // better to just ban unconstrianed lifetimes outright, but in\n+    // practice people do non-hygenic macros like:\n+    //\n+    // ```\n+    // macro_rules! __impl_slice_eq1 {\n+    //     ($Lhs: ty, $Rhs: ty, $Bound: ident) => {\n+    //         impl<'a, 'b, A: $Bound, B> PartialEq<$Rhs> for $Lhs where A: PartialEq<B> {\n+    //            ....\n+    //         }\n+    //     }\n+    // }\n+    // ```\n+    //\n+    // In a concession to backwards compatbility, we continue to\n+    // permit those, so long as the lifetimes aren't used in\n+    // associated types. I believe this is sound, because lifetimes\n+    // used elsewhere are not projected back out.\n+}\n+\n+fn report_unused_parameter(ccx: &CrateCtxt,\n+                           span: Span,\n+                           kind: &str,\n+                           name: &str)\n+{\n+    struct_span_err!(\n+        ccx.tcx.sess, span, E0207,\n+        \"the {} parameter `{}` is not constrained by the \\\n+        impl trait, self type, or predicates\",\n+        kind, name)\n+        .span_label(span, &format!(\"unconstrained {} parameter\", kind))\n+        .emit();\n+}\n+\n+/// Enforce that we do not have two items in an impl with the same name.\n+fn enforce_impl_items_are_distinct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                             impl_item_refs: &[hir::ImplItemRef])\n+{\n+    let tcx = ccx.tcx;\n+    let mut seen_type_items = FxHashMap();\n+    let mut seen_value_items = FxHashMap();\n+    for impl_item_ref in impl_item_refs {\n+        let impl_item = tcx.map.impl_item(impl_item_ref.id);\n+        let seen_items = match impl_item.node {\n+            hir::ImplItemKind::Type(_) => &mut seen_type_items,\n+            _                    => &mut seen_value_items,\n+        };\n+        match seen_items.entry(impl_item.name) {\n+            Occupied(entry) => {\n+                let mut err = struct_span_err!(tcx.sess, impl_item.span, E0201,\n+                                               \"duplicate definitions with name `{}`:\",\n+                                               impl_item.name);\n+                err.span_label(*entry.get(),\n+                               &format!(\"previous definition of `{}` here\",\n+                                        impl_item.name));\n+                err.span_label(impl_item.span, &format!(\"duplicate definition\"));\n+                err.emit();\n+            }\n+            Vacant(entry) => {\n+                entry.insert(impl_item.span);\n+            }\n+        }\n+    }\n+}"}, {"sha": "a1ee69791169e818c03abe7ab1d4ef7721d56e38", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -95,6 +95,7 @@ extern crate rustc_platform_intrinsics as intrinsics;\n extern crate rustc_back;\n extern crate rustc_const_math;\n extern crate rustc_const_eval;\n+extern crate rustc_data_structures;\n extern crate rustc_errors as errors;\n \n pub use rustc::dep_graph;\n@@ -130,6 +131,7 @@ mod rscope;\n mod astconv;\n pub mod collect;\n mod constrained_type_params;\n+mod impl_wf_check;\n pub mod coherence;\n pub mod variance;\n \n@@ -333,6 +335,11 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n     time(time_passes, \"variance inference\", ||\n          variance::infer_variance(tcx));\n \n+    tcx.sess.track_errors(|| {\n+        time(time_passes, \"impl wf inference\", ||\n+             impl_wf_check::impl_wf_check(&ccx));\n+    })?;\n+\n     tcx.sess.track_errors(|| {\n       time(time_passes, \"coherence checking\", ||\n           coherence::check_coherence(&ccx));"}, {"sha": "8a0c1c68322d078c9b135610d7898745c0a1756b", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -22,7 +22,7 @@ use rustc::ty::maps::ItemVariances;\n use rustc::hir::map as hir_map;\n use syntax::ast;\n use rustc::hir;\n-use rustc::hir::intravisit::Visitor;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n use super::terms::*;\n use super::terms::VarianceTerm::*;\n@@ -65,13 +65,13 @@ pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n     };\n \n     // See README.md for a discussion on dep-graph management.\n-    tcx.visit_all_items_in_krate(|def_id| ItemVariances::to_dep_node(&def_id),\n-                                 &mut constraint_cx);\n+    tcx.visit_all_item_likes_in_krate(|def_id| ItemVariances::to_dep_node(&def_id),\n+                                      &mut constraint_cx);\n \n     constraint_cx\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         let tcx = self.terms_cx.tcx;\n         let did = tcx.map.local_def_id(item.id);\n@@ -115,6 +115,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n             hir::ItemDefaultImpl(..) => {}\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }\n \n /// Is `param_id` a lifetime according to `map`?"}, {"sha": "0a3238480d9080efaf2821bf4623890f5140d448", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -27,7 +27,7 @@ use std::fmt;\n use std::rc::Rc;\n use syntax::ast;\n use rustc::hir;\n-use rustc::hir::intravisit::Visitor;\n+use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use util::nodemap::NodeMap;\n \n use self::VarianceTerm::*;\n@@ -109,7 +109,7 @@ pub fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n     };\n \n     // See README.md for a discussion on dep-graph management.\n-    tcx.visit_all_items_in_krate(|def_id| ItemVariances::to_dep_node(&def_id), &mut terms_cx);\n+    tcx.visit_all_item_likes_in_krate(|def_id| ItemVariances::to_dep_node(&def_id), &mut terms_cx);\n \n     terms_cx\n }\n@@ -227,7 +227,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         debug!(\"add_inferreds for item {}\",\n                self.tcx.map.node_to_string(item.id));\n@@ -257,4 +257,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n             hir::ItemTy(..) => {}\n         }\n     }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    }\n }"}, {"sha": "185f897c1baa1cfb82226cb4d59e3abe8204e382", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -364,7 +364,7 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n     let trait_items = tcx.associated_items(did).filter_map(|item| {\n         match item.kind {\n             ty::AssociatedKind::Const => {\n-                let default = if item.has_value {\n+                let default = if item.defaultness.has_value() {\n                     Some(pprust::expr_to_string(\n                         lookup_const_by_id(tcx, item.def_id, None).unwrap().0))\n                 } else {\n@@ -407,7 +407,7 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n                             abi: abi\n                         })\n                     }\n-                    _ => panic!(\"not a tymethod\"),\n+                    ref r => panic!(\"not a tymethod: {:?}\", r),\n                 };\n                 Some(cleaned)\n             }"}, {"sha": "a141d0e4788dd845509131780a6d83a9c268ff38", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -1373,9 +1373,10 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                         }\n                     }\n                 }\n+\n                 let provided = match self.container {\n                     ty::ImplContainer(_) => false,\n-                    ty::TraitContainer(_) => self.has_value\n+                    ty::TraitContainer(_) => self.defaultness.has_value()\n                 };\n                 if provided {\n                     MethodItem(Method {\n@@ -1440,7 +1441,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                     None => bounds.push(TyParamBound::maybe_sized(cx)),\n                 }\n \n-                let ty = if self.has_value {\n+                let ty = if self.defaultness.has_value() {\n                     Some(cx.tcx().item_type(self.def_id))\n                 } else {\n                     None"}, {"sha": "939fd6ccfc88e0e6f337d4fe04a4cc03d867f31e", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -502,17 +502,20 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 om.traits.push(t);\n             },\n \n-            hir::ItemImpl(unsafety, polarity, ref gen, ref tr, ref ty, ref items) => {\n+            hir::ItemImpl(unsafety, polarity, ref gen, ref tr, ref ty, ref item_ids) => {\n                 // Don't duplicate impls when inlining, we'll pick them up\n                 // regardless of where they're located.\n                 if !self.inlining {\n+                    let items = item_ids.iter()\n+                                        .map(|ii| self.cx.map.impl_item(ii.id).clone())\n+                                        .collect();\n                     let i = Impl {\n                         unsafety: unsafety,\n                         polarity: polarity,\n                         generics: gen.clone(),\n                         trait_: tr.clone(),\n                         for_: ty.clone(),\n-                        items: items.clone(),\n+                        items: items,\n                         attrs: item.attrs.clone(),\n                         id: item.id,\n                         whence: item.span,"}, {"sha": "2e33f11c04b4595ba708d46944facab51093a6a6", "filename": "src/test/compile-fail/dep-graph-type-alias.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Ftest%2Fcompile-fail%2Fdep-graph-type-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Ftest%2Fcompile-fail%2Fdep-graph-type-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-type-alias.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -42,8 +42,9 @@ trait Trait {\n \n struct SomeType;\n \n-#[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+#[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path\n impl SomeType {\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n     fn method(&self, _: TypeAlias) {}\n }\n "}, {"sha": "010cfb54c1ae91c3f160969400e4ebf7410cf608", "filename": "src/test/compile-fail/issue-3214.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Ftest%2Fcompile-fail%2Fissue-3214.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Ftest%2Fcompile-fail%2Fissue-3214.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3214.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -15,7 +15,6 @@ fn foo<T>() {\n \n     impl<T> Drop for foo<T> {\n         //~^ ERROR wrong number of type arguments\n-        //~^^ ERROR the type parameter `T` is not constrained\n         fn drop(&mut self) {}\n     }\n }"}, {"sha": "46e5a88eef9402fc9f1c9a4428bf3999f2e639f1", "filename": "src/test/incremental/change_private_impl_method/struct_point.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Ftest%2Fincremental%2Fchange_private_impl_method%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Ftest%2Fincremental%2Fchange_private_impl_method%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_impl_method%2Fstruct_point.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -20,9 +20,8 @@\n \n #![rustc_partition_translated(module=\"struct_point-point\", cfg=\"rpass2\")]\n \n-// FIXME(#37121) -- the following two modules *should* be reused but are not\n-#![rustc_partition_translated(module=\"struct_point-fn_calls_methods_in_same_impl\", cfg=\"rpass2\")]\n-#![rustc_partition_translated(module=\"struct_point-fn_calls_methods_in_another_impl\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_calls_methods_in_same_impl\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_calls_methods_in_another_impl\", cfg=\"rpass2\")]\n #![rustc_partition_reused(module=\"struct_point-fn_make_struct\", cfg=\"rpass2\")]\n #![rustc_partition_reused(module=\"struct_point-fn_read_field\", cfg=\"rpass2\")]\n #![rustc_partition_reused(module=\"struct_point-fn_write_field\", cfg=\"rpass2\")]\n@@ -60,8 +59,7 @@ mod point {\n mod fn_calls_methods_in_same_impl {\n     use point::Point;\n \n-    // FIXME(#37121) -- we should not need to typeck this again\n-    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n     pub fn check() {\n         let x = Point { x: 2.0, y: 2.0 };\n         x.distance_from_origin();\n@@ -72,8 +70,7 @@ mod fn_calls_methods_in_same_impl {\n mod fn_calls_methods_in_another_impl {\n     use point::Point;\n \n-    // FIXME(#37121) -- we should not need to typeck this again\n-    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n     pub fn check() {\n         let mut x = Point { x: 2.0, y: 2.0 };\n         x.translate(3.0, 3.0);"}, {"sha": "bb7f7025c59052d14bdffb5f8e80791834fbfcec", "filename": "src/test/incremental/change_private_impl_method_cc/struct_point.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -19,20 +19,21 @@\n #![feature(stmt_expr_attributes)]\n #![allow(dead_code)]\n \n-// FIXME(#37333) -- the following modules *should* be reused but are not\n+#![rustc_partition_reused(module=\"struct_point-fn_read_field\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_write_field\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"struct_point-fn_make_struct\", cfg=\"rpass2\")]\n+\n+// FIXME(#37720) these two should be reused, but data gets entangled across crates\n #![rustc_partition_translated(module=\"struct_point-fn_calls_methods_in_same_impl\", cfg=\"rpass2\")]\n #![rustc_partition_translated(module=\"struct_point-fn_calls_methods_in_another_impl\", cfg=\"rpass2\")]\n-#![rustc_partition_translated(module=\"struct_point-fn_make_struct\", cfg=\"rpass2\")]\n-#![rustc_partition_translated(module=\"struct_point-fn_read_field\", cfg=\"rpass2\")]\n-#![rustc_partition_translated(module=\"struct_point-fn_write_field\", cfg=\"rpass2\")]\n \n extern crate point;\n \n /// A fn item that calls (public) methods on `Point` from the same impl which changed\n mod fn_calls_methods_in_same_impl {\n     use point::Point;\n \n-    // FIXME(#37333) -- we should not need to typeck this again\n+    // FIXME(#37720) data gets entangled across crates\n     #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n     pub fn check() {\n         let x = Point { x: 2.0, y: 2.0 };\n@@ -44,9 +45,9 @@ mod fn_calls_methods_in_same_impl {\n mod fn_calls_methods_in_another_impl {\n     use point::Point;\n \n-    // FIXME(#37333) -- we should not need to typeck this again\n+    // FIXME(#37720) data gets entangled across crates\n     #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n-    pub fn check() {\n+    pub fn dirty() {\n         let mut x = Point { x: 2.0, y: 2.0 };\n         x.translate(3.0, 3.0);\n     }\n@@ -56,8 +57,7 @@ mod fn_calls_methods_in_another_impl {\n mod fn_make_struct {\n     use point::Point;\n \n-    // FIXME(#37333) -- we should not need to typeck this again\n-    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n     pub fn make_origin() -> Point {\n         Point { x: 2.0, y: 2.0 }\n     }\n@@ -67,8 +67,7 @@ mod fn_make_struct {\n mod fn_read_field {\n     use point::Point;\n \n-    // FIXME(#37333) -- we should not need to typeck this again\n-    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n     pub fn get_x(p: Point) -> f32 {\n         p.x\n     }\n@@ -78,8 +77,7 @@ mod fn_read_field {\n mod fn_write_field {\n     use point::Point;\n \n-    // FIXME(#37333) -- we should not need to typeck this again\n-    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n     pub fn inc_x(p: &mut Point) {\n         p.x += 1.0;\n     }"}, {"sha": "f7a390e874509312e6c01c0c5817e32f2651270b", "filename": "src/test/incremental/hashes/inherent_impls.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -0,0 +1,128 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for let expressions.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+struct Foo;\n+\n+// Change Method Name -----------------------------------------------------------\n+#[cfg(cfail1)]\n+impl Foo {\n+    pub fn method_name() { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl Foo {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    pub fn method_name2() { }\n+}\n+\n+// Change Method Body -----------------------------------------------------------\n+//\n+// This should affect the method itself, but not the impl.\n+#[cfg(cfail1)]\n+impl Foo {\n+    pub fn method_body() { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl Foo {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    pub fn method_body() {\n+        println!(\"Hello, world!\");\n+    }\n+}\n+\n+// Change Method Privacy -----------------------------------------------------------\n+#[cfg(cfail1)]\n+impl Foo {\n+    pub fn method_privacy() { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl Foo {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn method_privacy() { }\n+}\n+\n+// Change Method Selfness -----------------------------------------------------------\n+#[cfg(cfail1)]\n+impl Foo {\n+    pub fn method_selfness() { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl Foo {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    pub fn method_selfness(&self) { }\n+}\n+\n+// Change Method Selfmutness -----------------------------------------------------------\n+#[cfg(cfail1)]\n+impl Foo {\n+    pub fn method_selfmutness(&self) { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl Foo {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    pub fn method_selfmutness(&mut self) { }\n+}\n+"}, {"sha": "500aaf52324b028c5447b9e32ac77f947df92477", "filename": "src/test/incremental/hashes/trait_impls.rs", "status": "added", "additions": 404, "deletions": 0, "changes": 404, "blob_url": "https://github.com/rust-lang/rust/blob/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e8924dc5d5cc248f33767ff35f7aeb797a71ec/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_impls.rs?ref=35e8924dc5d5cc248f33767ff35f7aeb797a71ec", "patch": "@@ -0,0 +1,404 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for let expressions.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![feature(specialization)]\n+#![crate_type=\"rlib\"]\n+\n+struct Foo;\n+\n+// Change Method Name -----------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+pub trait ChangeMethodNameTrait {\n+    fn method_name();\n+}\n+\n+#[cfg(cfail1)]\n+impl ChangeMethodNameTrait for Foo {\n+    fn method_name() { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub trait ChangeMethodNameTrait {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn method_name2();\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl ChangeMethodNameTrait for Foo {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn method_name2() { }\n+}\n+\n+// Change Method Body -----------------------------------------------------------\n+//\n+// This should affect the method itself, but not the trait.\n+\n+pub trait ChangeMethodBodyTrait {\n+    fn method_name();\n+}\n+\n+#[cfg(cfail1)]\n+impl ChangeMethodBodyTrait for Foo {\n+    fn method_name() { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl ChangeMethodBodyTrait for Foo {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn method_name() {\n+        ()\n+    }\n+}\n+\n+// Change Method Selfness -----------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+pub trait ChangeMethodSelfnessTrait {\n+    fn method_name();\n+}\n+\n+#[cfg(cfail1)]\n+impl ChangeMethodSelfnessTrait for Foo {\n+    fn method_name() { }\n+}\n+\n+#[cfg(not(cfail1))]\n+pub trait ChangeMethodSelfnessTrait {\n+    fn method_name(&self);\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl ChangeMethodSelfnessTrait for Foo {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn method_name(&self) {\n+        ()\n+    }\n+}\n+\n+// Change Method Selfness -----------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+pub trait RemoveMethodSelfnessTrait {\n+    fn method_name(&self);\n+}\n+\n+#[cfg(cfail1)]\n+impl RemoveMethodSelfnessTrait for Foo {\n+    fn method_name(&self) { }\n+}\n+\n+#[cfg(not(cfail1))]\n+pub trait RemoveMethodSelfnessTrait {\n+    fn method_name();\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl RemoveMethodSelfnessTrait for Foo {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn method_name() {\n+        ()\n+    }\n+}\n+\n+// Change Method Selfmutness -----------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+pub trait ChangeMethodSelfmutnessTrait {\n+    fn method_name(&self);\n+}\n+\n+#[cfg(cfail1)]\n+impl ChangeMethodSelfmutnessTrait for Foo {\n+    fn method_name(&self) { }\n+}\n+\n+#[cfg(not(cfail1))]\n+pub trait ChangeMethodSelfmutnessTrait {\n+    fn method_name(&mut self);\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl ChangeMethodSelfmutnessTrait for Foo {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn method_name(&mut self) {\n+        ()\n+    }\n+}\n+\n+// Change item kind -----------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+pub trait ChangeItemKindTrait {\n+    fn name();\n+}\n+\n+#[cfg(cfail1)]\n+impl ChangeItemKindTrait for Foo {\n+    fn name() { }\n+}\n+\n+#[cfg(not(cfail1))]\n+pub trait ChangeItemKindTrait {\n+    type name;\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl ChangeItemKindTrait for Foo {\n+    type name = ();\n+}\n+\n+// Remove item -----------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+pub trait RemoveItemTrait {\n+    type TypeName;\n+    fn method_name();\n+}\n+\n+#[cfg(cfail1)]\n+impl RemoveItemTrait for Foo {\n+    type TypeName = ();\n+    fn method_name() { }\n+}\n+\n+#[cfg(not(cfail1))]\n+pub trait RemoveItemTrait {\n+    type TypeName;\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl RemoveItemTrait for Foo {\n+    type TypeName = ();\n+}\n+\n+// Add item -----------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+pub trait AddItemTrait {\n+    type TypeName;\n+}\n+\n+#[cfg(cfail1)]\n+impl AddItemTrait for Foo {\n+    type TypeName = ();\n+}\n+\n+#[cfg(not(cfail1))]\n+pub trait AddItemTrait {\n+    type TypeName;\n+    fn method_name();\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl AddItemTrait for Foo {\n+    type TypeName = ();\n+    fn method_name() { }\n+}\n+\n+// Change has-value -----------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+pub trait ChangeHasValueTrait {\n+    fn method_name();\n+}\n+\n+#[cfg(cfail1)]\n+impl ChangeHasValueTrait for Foo {\n+    fn method_name() { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub trait ChangeHasValueTrait {\n+    fn method_name() { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl ChangeHasValueTrait for Foo {\n+    fn method_name() { }\n+}\n+\n+// Add default\n+\n+pub trait AddDefaultTrait {\n+    fn method_name();\n+}\n+\n+#[cfg(cfail1)]\n+impl AddDefaultTrait for Foo {\n+    fn method_name() { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl AddDefaultTrait for Foo {\n+    default fn method_name() { }\n+}\n+\n+// Remove default\n+\n+pub trait RemoveDefaultTrait {\n+    fn method_name();\n+}\n+\n+#[cfg(cfail1)]\n+impl RemoveDefaultTrait for Foo {\n+    default fn method_name() { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl RemoveDefaultTrait for Foo {\n+    fn method_name() { }\n+}\n+\n+// Add arguments\n+\n+#[cfg(cfail1)]\n+pub trait AddArgumentTrait {\n+    fn method_name(&self);\n+}\n+\n+#[cfg(cfail1)]\n+impl AddArgumentTrait for Foo {\n+    fn method_name(&self) { }\n+}\n+\n+#[cfg(not(cfail1))]\n+pub trait AddArgumentTrait {\n+    fn method_name(&self, x: u32);\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl AddArgumentTrait for Foo {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn method_name(&self, _x: u32) { }\n+}\n+\n+// Change argument type\n+\n+#[cfg(cfail1)]\n+pub trait ChangeArgumentTypeTrait {\n+    fn method_name(&self, x: u32);\n+}\n+\n+#[cfg(cfail1)]\n+impl ChangeArgumentTypeTrait for Foo {\n+    fn method_name(&self, _x: u32) { }\n+}\n+\n+#[cfg(not(cfail1))]\n+pub trait ChangeArgumentTypeTrait {\n+    fn method_name(&self, x: char);\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl ChangeArgumentTypeTrait for Foo {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn method_name(&self, _x: char) { }\n+}\n+"}]}