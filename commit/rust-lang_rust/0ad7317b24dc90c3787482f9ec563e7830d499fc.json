{"sha": "0ad7317b24dc90c3787482f9ec563e7830d499fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhZDczMTdiMjRkYzkwYzM3ODc0ODJmOWVjNTYzZTc4MzBkNDk5ZmM=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-05-01T15:57:56Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-05-04T16:18:30Z"}, "message": "Canonicalize before doing method resolution", "tree": {"sha": "b065393029bb8d886c3562af2e0fbcf1bc62a0e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b065393029bb8d886c3562af2e0fbcf1bc62a0e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ad7317b24dc90c3787482f9ec563e7830d499fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ad7317b24dc90c3787482f9ec563e7830d499fc", "html_url": "https://github.com/rust-lang/rust/commit/0ad7317b24dc90c3787482f9ec563e7830d499fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ad7317b24dc90c3787482f9ec563e7830d499fc/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef77d8375130d12678d4b2316cc1708c90349dad", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef77d8375130d12678d4b2316cc1708c90349dad", "html_url": "https://github.com/rust-lang/rust/commit/ef77d8375130d12678d4b2316cc1708c90349dad"}], "stats": {"total": 298, "additions": 165, "deletions": 133}, "files": [{"sha": "24350bda7e6d580a770b1815f9a154bd1ba4765c", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0ad7317b24dc90c3787482f9ec563e7830d499fc/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad7317b24dc90c3787482f9ec563e7830d499fc/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=0ad7317b24dc90c3787482f9ec563e7830d499fc", "patch": "@@ -350,7 +350,16 @@ impl SourceAnalyzer {\n         name: Option<&Name>,\n         callback: impl FnMut(&Ty, Function) -> Option<T>,\n     ) -> Option<T> {\n-        ty.iterate_method_candidates(db, &self.resolver, name, callback)\n+        // There should be no inference vars in types passed here\n+        // TODO check that?\n+        let canonical = crate::ty::Canonical { value: ty, num_vars: 0 };\n+        crate::ty::method_resolution::iterate_method_candidates(\n+            &canonical,\n+            db,\n+            &self.resolver,\n+            name,\n+            callback,\n+        )\n     }\n \n     #[cfg(test)]"}, {"sha": "6a79af35b912e5a73979268d3affe6577bc9622e", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0ad7317b24dc90c3787482f9ec563e7830d499fc/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad7317b24dc90c3787482f9ec563e7830d499fc/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=0ad7317b24dc90c3787482f9ec563e7830d499fc", "patch": "@@ -234,6 +234,17 @@ impl TraitRef {\n     }\n }\n \n+/// Basically a claim (currently not validated / checked) that the contained\n+/// type / trait ref contains no inference variables; any inference variables it\n+/// contained have been replaced by bound variables, and `num_vars` tells us how\n+/// many there are. This is used to erase irrelevant differences between types\n+/// before using them in queries.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub(crate) struct Canonical<T> {\n+    pub value: T,\n+    pub num_vars: usize,\n+}\n+\n /// A function signature as seen by type inference: Several parameter types and\n /// one return type.\n #[derive(Clone, PartialEq, Eq, Debug)]"}, {"sha": "41ae569f7b6a20e850e6953189196e7172ac68e7", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0ad7317b24dc90c3787482f9ec563e7830d499fc/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad7317b24dc90c3787482f9ec563e7830d499fc/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=0ad7317b24dc90c3787482f9ec563e7830d499fc", "patch": "@@ -45,12 +45,11 @@ use crate::{\n use super::{\n     Ty, TypableDef, Substs, primitive, op, ApplicationTy, TypeCtor, CallableDef, TraitRef,\n     traits::{Solution, Obligation, Guidance},\n+    method_resolution,\n };\n \n mod unify;\n \n-pub(super) use unify::Canonical;\n-\n /// The entry point of type inference.\n pub fn infer(db: &impl HirDatabase, def: DefWithBody) -> Arc<InferenceResult> {\n     db.check_canceled();\n@@ -878,9 +877,17 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         generic_args: Option<&GenericArgs>,\n     ) -> Ty {\n         let receiver_ty = self.infer_expr(receiver, &Expectation::none());\n-        let resolved = receiver_ty.clone().lookup_method(self.db, method_name, &self.resolver);\n+        let mut canonicalizer = self.canonicalizer();\n+        let canonical_receiver = canonicalizer.canonicalize_ty(receiver_ty.clone());\n+        let resolved = method_resolution::lookup_method(\n+            &canonical_receiver,\n+            canonicalizer.ctx.db,\n+            method_name,\n+            &canonicalizer.ctx.resolver,\n+        );\n         let (derefed_receiver_ty, method_ty, def_generics) = match resolved {\n             Some((ty, func)) => {\n+                let ty = canonicalizer.decanonicalize_ty(ty);\n                 self.write_method_resolution(tgt_expr, func);\n                 (\n                     ty,"}, {"sha": "820a6478952b151d8544f101af44848660f21f37", "filename": "crates/ra_hir/src/ty/infer/unify.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0ad7317b24dc90c3787482f9ec563e7830d499fc/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad7317b24dc90c3787482f9ec563e7830d499fc/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs?ref=0ad7317b24dc90c3787482f9ec563e7830d499fc", "patch": "@@ -1,6 +1,8 @@\n //! Unification and canonicalization logic.\n \n-use super::{InferenceContext, Ty, TraitRef, InferTy, HirDatabase};\n+use crate::db::HirDatabase;\n+use crate::ty::{Ty, Canonical, TraitRef, InferTy};\n+use super::InferenceContext;\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     pub(super) fn canonicalizer<'b>(&'b mut self) -> Canonicalizer<'a, 'b, D>\n@@ -13,13 +15,6 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n // TODO improve the interface of this\n \n-// TODO move further up?\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub(crate) struct Canonical<T> {\n-    pub value: T,\n-    pub num_vars: usize,\n-}\n-\n pub(super) struct Canonicalizer<'a, 'b, D: HirDatabase>\n where\n     'a: 'b,\n@@ -68,6 +63,19 @@ where\n         Canonical { value, num_vars: self.free_vars.len() }\n     }\n \n+    pub fn decanonicalize_ty(&self, ty: Ty) -> Ty {\n+        ty.fold(&mut |ty| match ty {\n+            Ty::Bound(idx) => {\n+                if (idx as usize) < self.free_vars.len() {\n+                    Ty::Infer(self.free_vars[idx as usize].clone())\n+                } else {\n+                    Ty::Bound(idx)\n+                }\n+            }\n+            ty => ty,\n+        })\n+    }\n+\n     pub fn apply_solution(&mut self, solution: Canonical<Vec<Ty>>) {\n         // the solution may contain new variables, which we need to convert to new inference vars\n         let new_vars ="}, {"sha": "bc5033be6cc290f6b7807cc982d71b58a06bb48e", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 109, "deletions": 110, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/0ad7317b24dc90c3787482f9ec563e7830d499fc/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad7317b24dc90c3787482f9ec563e7830d499fc/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=0ad7317b24dc90c3787482f9ec563e7830d499fc", "patch": "@@ -16,7 +16,7 @@ use crate::{\n     generics::HasGenericParams,\n     ty::primitive::{UncertainIntTy, UncertainFloatTy}\n };\n-use super::{TraitRef, infer::Canonical, Substs};\n+use super::{TraitRef, Canonical};\n \n /// This is used as a key for indexing impls.\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -130,132 +130,123 @@ fn def_crate(db: &impl HirDatabase, cur_crate: Crate, ty: &Ty) -> Option<Crate>\n     }\n }\n \n-impl Ty {\n-    /// Look up the method with the given name, returning the actual autoderefed\n-    /// receiver type (but without autoref applied yet).\n-    pub(crate) fn lookup_method(\n-        self,\n-        db: &impl HirDatabase,\n-        name: &Name,\n-        resolver: &Resolver,\n-    ) -> Option<(Ty, Function)> {\n-        self.iterate_method_candidates(db, resolver, Some(name), |ty, f| Some((ty.clone(), f)))\n-    }\n+/// Look up the method with the given name, returning the actual autoderefed\n+/// receiver type (but without autoref applied yet).\n+pub(crate) fn lookup_method(\n+    ty: &Canonical<Ty>,\n+    db: &impl HirDatabase,\n+    name: &Name,\n+    resolver: &Resolver,\n+) -> Option<(Ty, Function)> {\n+    iterate_method_candidates(ty, db, resolver, Some(name), |ty, f| Some((ty.clone(), f)))\n+}\n \n-    // This would be nicer if it just returned an iterator, but that runs into\n-    // lifetime problems, because we need to borrow temp `CrateImplBlocks`.\n-    pub(crate) fn iterate_method_candidates<T>(\n-        self,\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n-        name: Option<&Name>,\n-        mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n-    ) -> Option<T> {\n-        // For method calls, rust first does any number of autoderef, and then one\n-        // autoref (i.e. when the method takes &self or &mut self). We just ignore\n-        // the autoref currently -- when we find a method matching the given name,\n-        // we assume it fits.\n+// This would be nicer if it just returned an iterator, but that runs into\n+// lifetime problems, because we need to borrow temp `CrateImplBlocks`.\n+pub(crate) fn iterate_method_candidates<T>(\n+    ty: &Canonical<Ty>,\n+    db: &impl HirDatabase,\n+    resolver: &Resolver,\n+    name: Option<&Name>,\n+    mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n+) -> Option<T> {\n+    // For method calls, rust first does any number of autoderef, and then one\n+    // autoref (i.e. when the method takes &self or &mut self). We just ignore\n+    // the autoref currently -- when we find a method matching the given name,\n+    // we assume it fits.\n \n-        // Also note that when we've got a receiver like &S, even if the method we\n-        // find in the end takes &self, we still do the autoderef step (just as\n-        // rustc does an autoderef and then autoref again).\n+    // Also note that when we've got a receiver like &S, even if the method we\n+    // find in the end takes &self, we still do the autoderef step (just as\n+    // rustc does an autoderef and then autoref again).\n \n-        let krate = resolver.krate()?;\n-        for derefed_ty in self.autoderef(db) {\n-            if let Some(result) =\n-                derefed_ty.iterate_inherent_methods(db, name, krate, &mut callback)\n-            {\n-                return Some(result);\n-            }\n-            if let Some(result) =\n-                derefed_ty.iterate_trait_method_candidates(db, resolver, name, &mut callback)\n-            {\n-                return Some(result);\n-            }\n+    let krate = resolver.krate()?;\n+    for derefed_ty in ty.value.clone().autoderef(db) {\n+        let derefed_ty = Canonical { value: derefed_ty, num_vars: ty.num_vars };\n+        if let Some(result) = iterate_inherent_methods(&derefed_ty, db, name, krate, &mut callback)\n+        {\n+            return Some(result);\n+        }\n+        if let Some(result) =\n+            iterate_trait_method_candidates(&derefed_ty, db, resolver, name, &mut callback)\n+        {\n+            return Some(result);\n         }\n-        None\n     }\n+    None\n+}\n \n-    fn iterate_trait_method_candidates<T>(\n-        &self,\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n-        name: Option<&Name>,\n-        mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n-    ) -> Option<T> {\n-        let krate = resolver.krate()?;\n-        'traits: for t in resolver.traits_in_scope() {\n-            let data = t.trait_data(db);\n-            // we'll be lazy about checking whether the type implements the\n-            // trait, but if we find out it doesn't, we'll skip the rest of the\n-            // iteration\n-            let mut known_implemented = false;\n-            for item in data.items() {\n-                match item {\n-                    &TraitItem::Function(m) => {\n-                        let sig = m.signature(db);\n-                        if name.map_or(true, |name| sig.name() == name) && sig.has_self_param() {\n-                            if !known_implemented {\n-                                // TODO the self type may contain type\n-                                // variables, so we need to do proper\n-                                // canonicalization here\n-                                let trait_ref = TraitRef {\n-                                    trait_: t,\n-                                    substs: fresh_substs_for_trait(db, t, self.clone()),\n-                                };\n-                                let canonical = Canonical {\n-                                    num_vars: trait_ref.substs.len(),\n-                                    value: trait_ref,\n-                                };\n-                                // FIXME cache this implements check (without solution) in a query?\n-                                if super::traits::implements(db, krate, canonical).is_none() {\n-                                    continue 'traits;\n-                                }\n-                            }\n-                            known_implemented = true;\n-                            if let Some(result) = callback(self, m) {\n-                                return Some(result);\n+fn iterate_trait_method_candidates<T>(\n+    ty: &Canonical<Ty>,\n+    db: &impl HirDatabase,\n+    resolver: &Resolver,\n+    name: Option<&Name>,\n+    mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n+) -> Option<T> {\n+    let krate = resolver.krate()?;\n+    'traits: for t in resolver.traits_in_scope() {\n+        let data = t.trait_data(db);\n+        // we'll be lazy about checking whether the type implements the\n+        // trait, but if we find out it doesn't, we'll skip the rest of the\n+        // iteration\n+        let mut known_implemented = false;\n+        for item in data.items() {\n+            match item {\n+                &TraitItem::Function(m) => {\n+                    let sig = m.signature(db);\n+                    if name.map_or(true, |name| sig.name() == name) && sig.has_self_param() {\n+                        if !known_implemented {\n+                            let trait_ref = canonical_trait_ref(db, t, ty.clone());\n+                            // FIXME cache this implements check (without solution) in a query?\n+                            if super::traits::implements(db, krate, trait_ref).is_none() {\n+                                continue 'traits;\n                             }\n                         }\n+                        known_implemented = true;\n+                        // TODO the self type is now canonicalized...\n+                        if let Some(result) = callback(&ty.value, m) {\n+                            return Some(result);\n+                        }\n                     }\n-                    _ => {}\n                 }\n+                _ => {}\n             }\n         }\n-        None\n     }\n+    None\n+}\n \n-    fn iterate_inherent_methods<T>(\n-        &self,\n-        db: &impl HirDatabase,\n-        name: Option<&Name>,\n-        krate: Crate,\n-        mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n-    ) -> Option<T> {\n-        let krate = match def_crate(db, krate, self) {\n-            Some(krate) => krate,\n-            None => return None,\n-        };\n-        let impls = db.impls_in_crate(krate);\n+fn iterate_inherent_methods<T>(\n+    ty: &Canonical<Ty>,\n+    db: &impl HirDatabase,\n+    name: Option<&Name>,\n+    krate: Crate,\n+    mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n+) -> Option<T> {\n+    let krate = match def_crate(db, krate, &ty.value) {\n+        Some(krate) => krate,\n+        None => return None,\n+    };\n+    let impls = db.impls_in_crate(krate);\n \n-        for impl_block in impls.lookup_impl_blocks(self) {\n-            for item in impl_block.items(db) {\n-                match item {\n-                    ImplItem::Method(f) => {\n-                        let sig = f.signature(db);\n-                        if name.map_or(true, |name| sig.name() == name) && sig.has_self_param() {\n-                            if let Some(result) = callback(self, f) {\n-                                return Some(result);\n-                            }\n+    for impl_block in impls.lookup_impl_blocks(&ty.value) {\n+        for item in impl_block.items(db) {\n+            match item {\n+                ImplItem::Method(f) => {\n+                    let sig = f.signature(db);\n+                    if name.map_or(true, |name| sig.name() == name) && sig.has_self_param() {\n+                        if let Some(result) = callback(&ty.value, f) {\n+                            return Some(result);\n                         }\n                     }\n-                    _ => {}\n                 }\n+                _ => {}\n             }\n         }\n-        None\n     }\n+    None\n+}\n \n+impl Ty {\n     // This would be nicer if it just returned an iterator, but that runs into\n     // lifetime problems, because we need to borrow temp `CrateImplBlocks`.\n     pub fn iterate_impl_items<T>(\n@@ -280,17 +271,25 @@ impl Ty {\n \n /// This creates Substs for a trait with the given Self type and type variables\n /// for all other parameters, to query Chalk with it.\n-fn fresh_substs_for_trait(db: &impl HirDatabase, tr: Trait, self_ty: Ty) -> Substs {\n+fn canonical_trait_ref(\n+    db: &impl HirDatabase,\n+    trait_: Trait,\n+    self_ty: Canonical<Ty>,\n+) -> Canonical<TraitRef> {\n     let mut substs = Vec::new();\n-    let generics = tr.generic_params(db);\n-    substs.push(self_ty);\n+    let generics = trait_.generic_params(db);\n+    let num_vars = self_ty.num_vars;\n+    substs.push(self_ty.value);\n     substs.extend(\n         generics\n             .params_including_parent()\n             .into_iter()\n             .skip(1)\n             .enumerate()\n-            .map(|(i, _p)| Ty::Bound(i as u32)),\n+            .map(|(i, _p)| Ty::Bound((i + num_vars) as u32)),\n     );\n-    substs.into()\n+    Canonical {\n+        num_vars: substs.len() - 1 + self_ty.num_vars,\n+        value: TraitRef { trait_, substs: substs.into() },\n+    }\n }"}, {"sha": "c707110ad9864ce06c7a5f0e5b7142951500e2fb", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0ad7317b24dc90c3787482f9ec563e7830d499fc/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad7317b24dc90c3787482f9ec563e7830d499fc/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=0ad7317b24dc90c3787482f9ec563e7830d499fc", "patch": "@@ -4,7 +4,7 @@ use std::sync::{Arc, Mutex};\n use chalk_ir::cast::Cast;\n \n use crate::{Crate, Trait, db::HirDatabase, ImplBlock};\n-use super::{TraitRef, Ty, infer::Canonical};\n+use super::{TraitRef, Ty, Canonical};\n \n use self::chalk::{ToChalk, from_chalk};\n \n@@ -86,10 +86,7 @@ pub(crate) fn implements(\n     solution.map(|solution| solution_from_chalk(db, solution))\n }\n \n-fn solution_from_chalk(\n-    db: &impl HirDatabase,\n-    solution: chalk_solve::Solution,\n-) -> Solution {\n+fn solution_from_chalk(db: &impl HirDatabase, solution: chalk_solve::Solution) -> Solution {\n     let convert_subst = |subst: chalk_ir::Canonical<chalk_ir::Substitution>| {\n         let value = subst\n             .value"}, {"sha": "18f3017899aa7f7af5726d68a5877f97584d2a40", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0ad7317b24dc90c3787482f9ec563e7830d499fc/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad7317b24dc90c3787482f9ec563e7830d499fc/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=0ad7317b24dc90c3787482f9ec563e7830d499fc", "patch": "@@ -32,8 +32,7 @@ impl ToChalk for Ty {\n         match self {\n             Ty::Apply(apply_ty) => chalk_ir::Ty::Apply(apply_ty.to_chalk(db)),\n             Ty::Param { idx, .. } => {\n-                PlaceholderIndex { ui: UniverseIndex::ROOT, idx: idx as usize }\n-                    .to_ty()\n+                PlaceholderIndex { ui: UniverseIndex::ROOT, idx: idx as usize }.to_ty()\n             }\n             Ty::Bound(idx) => chalk_ir::Ty::BoundVar(idx as usize),\n             Ty::Infer(_infer_ty) => panic!(\"uncanonicalized infer ty\"),\n@@ -74,9 +73,7 @@ impl ToChalk for ApplicationTy {\n \n     fn from_chalk(db: &impl HirDatabase, apply_ty: chalk_ir::ApplicationTy) -> ApplicationTy {\n         let ctor = match apply_ty.name {\n-            TypeName::TypeKindId(TypeKindId::StructId(struct_id)) => {\n-                from_chalk(db, struct_id)\n-            }\n+            TypeName::TypeKindId(TypeKindId::StructId(struct_id)) => from_chalk(db, struct_id),\n             TypeName::TypeKindId(_) => unimplemented!(),\n             TypeName::Placeholder(_) => unimplemented!(),\n             TypeName::AssociatedType(_) => unimplemented!(),\n@@ -267,7 +264,11 @@ where\n             .map(|impl_block| impl_block.to_chalk(self.db))\n             .collect()\n     }\n-    fn impl_provided_for(&self, auto_trait_id: chalk_ir::TraitId, struct_id: chalk_ir::StructId) -> bool {\n+    fn impl_provided_for(\n+        &self,\n+        auto_trait_id: chalk_ir::TraitId,\n+        struct_id: chalk_ir::StructId,\n+    ) -> bool {\n         eprintln!(\"impl_provided_for {:?}, {:?}\", auto_trait_id, struct_id);\n         false // FIXME\n     }"}]}