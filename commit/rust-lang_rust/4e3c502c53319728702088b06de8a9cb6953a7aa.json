{"sha": "4e3c502c53319728702088b06de8a9cb6953a7aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlM2M1MDJjNTMzMTk3Mjg3MDIwODhiMDZkZThhOWNiNjk1M2E3YWE=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-08-24T21:50:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-08-24T21:50:47Z"}, "message": "Merge pull request #309 from oli-obk/libstd\n\nRefactoring: Couple values and types into an object when passed around together", "tree": {"sha": "4f095d2ab9d888a6b616c9be187f57b892ba29b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f095d2ab9d888a6b616c9be187f57b892ba29b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e3c502c53319728702088b06de8a9cb6953a7aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e3c502c53319728702088b06de8a9cb6953a7aa", "html_url": "https://github.com/rust-lang/rust/commit/4e3c502c53319728702088b06de8a9cb6953a7aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e3c502c53319728702088b06de8a9cb6953a7aa/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f860ad8d2eaa2cc022d4d4a8427a2a908f39a6b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/f860ad8d2eaa2cc022d4d4a8427a2a908f39a6b3", "html_url": "https://github.com/rust-lang/rust/commit/f860ad8d2eaa2cc022d4d4a8427a2a908f39a6b3"}, {"sha": "110d50e7f95173c0bede64e588f832988d30c7a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/110d50e7f95173c0bede64e588f832988d30c7a2", "html_url": "https://github.com/rust-lang/rust/commit/110d50e7f95173c0bede64e588f832988d30c7a2"}], "stats": {"total": 584, "additions": 313, "deletions": 271}, "files": [{"sha": "cb7ee73e9961852d353014621fea4fbf7c2cbecd", "filename": "miri/fn_call.rs", "status": "modified", "additions": 33, "deletions": 50, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/4e3c502c53319728702088b06de8a9cb6953a7aa/miri%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3c502c53319728702088b06de8a9cb6953a7aa/miri%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Ffn_call.rs?ref=4e3c502c53319728702088b06de8a9cb6953a7aa", "patch": "@@ -19,7 +19,7 @@ pub trait EvalContextExt<'tcx> {\n     fn call_c_abi(\n         &mut self,\n         def_id: DefId,\n-        arg_operands: &[mir::Operand<'tcx>],\n+        args: &[ValTy<'tcx>],\n         dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n         dest_block: mir::BasicBlock,\n@@ -31,7 +31,7 @@ pub trait EvalContextExt<'tcx> {\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         destination: Option<(Lvalue, mir::BasicBlock)>,\n-        arg_operands: &[mir::Operand<'tcx>],\n+        args: &[ValTy<'tcx>],\n         sig: ty::FnSig<'tcx>,\n         path: String,\n     ) -> EvalResult<'tcx>;\n@@ -40,7 +40,7 @@ pub trait EvalContextExt<'tcx> {\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         destination: Option<(Lvalue, mir::BasicBlock)>,\n-        arg_operands: &[mir::Operand<'tcx>],\n+        args: &[ValTy<'tcx>],\n         span: Span,\n         sig: ty::FnSig<'tcx>,\n     ) -> EvalResult<'tcx, bool>;\n@@ -51,7 +51,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         destination: Option<(Lvalue, mir::BasicBlock)>,\n-        arg_operands: &[mir::Operand<'tcx>],\n+        args: &[ValTy<'tcx>],\n         span: Span,\n         sig: ty::FnSig<'tcx>,\n     ) -> EvalResult<'tcx, bool> {\n@@ -63,7 +63,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 self.call_missing_fn(\n                     instance,\n                     destination,\n-                    arg_operands,\n+                    args,\n                     sig,\n                     path,\n                 )?;\n@@ -91,7 +91,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n     fn call_c_abi(\n         &mut self,\n         def_id: DefId,\n-        arg_operands: &[mir::Operand<'tcx>],\n+        args: &[ValTy<'tcx>],\n         dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n         dest_block: mir::BasicBlock,\n@@ -102,17 +102,9 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             .unwrap_or(name)\n             .as_str();\n \n-        let args_res: EvalResult<Vec<Value>> = arg_operands\n-            .iter()\n-            .map(|arg| self.eval_operand(arg))\n-            .collect();\n-        let args = args_res?;\n-\n-        let usize = self.tcx.types.usize;\n-\n         match &link_name[..] {\n             \"malloc\" => {\n-                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                let size = self.value_to_primval(args[0])?.to_u64()?;\n                 if size == 0 {\n                     self.write_null(dest, dest_ty)?;\n                 } else {\n@@ -139,7 +131,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 //\n                 // libc::syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), GRND_NONBLOCK)\n                 // is called if a `HashMap` is created the regular way.\n-                match self.value_to_primval(args[0], usize)?.to_u64()? {\n+                match self.value_to_primval(args[0])?.to_u64()? {\n                     318 | 511 => {\n                         return err!(Unimplemented(\n                             \"miri does not support random number generators\".to_owned(),\n@@ -208,7 +200,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             \"memcmp\" => {\n                 let left = args[0].into_ptr(&mut self.memory)?;\n                 let right = args[1].into_ptr(&mut self.memory)?;\n-                let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                let n = self.value_to_primval(args[2])?.to_u64()?;\n \n                 let result = {\n                     let left_bytes = self.memory.read_bytes(left, n)?;\n@@ -231,8 +223,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n \n             \"memrchr\" => {\n                 let ptr = args[0].into_ptr(&mut self.memory)?;\n-                let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n-                let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                let val = self.value_to_primval(args[1])?.to_u64()? as u8;\n+                let num = self.value_to_primval(args[2])?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().rev().position(\n                     |&c| c == val,\n                 )\n@@ -246,8 +238,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n \n             \"memchr\" => {\n                 let ptr = args[0].into_ptr(&mut self.memory)?;\n-                let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n-                let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                let val = self.value_to_primval(args[1])?.to_u64()? as u8;\n+                let num = self.value_to_primval(args[2])?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(\n                     |&c| c == val,\n                 )\n@@ -329,9 +321,9 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             }\n \n             \"write\" => {\n-                let fd = self.value_to_primval(args[0], usize)?.to_u64()?;\n+                let fd = self.value_to_primval(args[0])?.to_u64()?;\n                 let buf = args[1].into_ptr(&mut self.memory)?;\n-                let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                let n = self.value_to_primval(args[2])?.to_u64()?;\n                 trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, n);\n                 let result = if fd == 1 || fd == 2 {\n                     // stdout/stderr\n@@ -370,8 +362,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             }\n \n             \"sysconf\" => {\n-                let c_int = self.operand_ty(&arg_operands[0]);\n-                let name = self.value_to_primval(args[0], c_int)?.to_u64()?;\n+                let name = self.value_to_primval(args[0])?.to_u64()?;\n                 trace!(\"sysconf() called with name {}\", name);\n                 // cache the sysconf integers via miri's global cache\n                 let paths = &[\n@@ -387,7 +378,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                         };\n                         // compute global if not cached\n                         let val = match self.globals.get(&cid).cloned() {\n-                            Some(ptr) => self.value_to_primval(Value::ByRef(ptr), c_int)?.to_u64()?,\n+                            Some(ptr) => self.value_to_primval(ValTy { value: Value::ByRef(ptr), ty: args[0].ty })?.to_u64()?,\n                             None => eval_body_as_primval(self.tcx, instance)?.0.to_u64()?,\n                         };\n                         if val == name {\n@@ -418,7 +409,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 };\n \n                 // Figure out how large a pthread TLS key actually is. This is libc::pthread_key_t.\n-                let key_type = self.operand_ty(&arg_operands[0]).builtin_deref(true, ty::LvaluePreference::NoPreference)\n+                let key_type = args[0].ty.builtin_deref(true, ty::LvaluePreference::NoPreference)\n                                    .ok_or(EvalErrorKind::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))?.ty;\n                 let key_size = {\n                     let layout = self.type_layout(key_type)?;\n@@ -442,20 +433,20 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             }\n             \"pthread_key_delete\" => {\n                 // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n-                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n+                let key = self.value_to_primval(args[0])?.to_u64()? as TlsKey;\n                 self.memory.delete_tls_key(key)?;\n                 // Return success (0)\n                 self.write_null(dest, dest_ty)?;\n             }\n             \"pthread_getspecific\" => {\n                 // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n-                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n+                let key = self.value_to_primval(args[0])?.to_u64()? as TlsKey;\n                 let ptr = self.memory.load_tls(key)?;\n                 self.write_ptr(dest, ptr, dest_ty)?;\n             }\n             \"pthread_setspecific\" => {\n                 // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n-                let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n+                let key = self.value_to_primval(args[0])?.to_u64()? as TlsKey;\n                 let new_ptr = args[1].into_ptr(&mut self.memory)?;\n                 self.memory.store_tls(key, new_ptr)?;\n \n@@ -524,7 +515,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         destination: Option<(Lvalue, mir::BasicBlock)>,\n-        arg_operands: &[mir::Operand<'tcx>],\n+        args: &[ValTy<'tcx>],\n         sig: ty::FnSig<'tcx>,\n         path: String,\n     ) -> EvalResult<'tcx> {\n@@ -546,27 +537,19 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             // unify these two mechanisms for \"hooking into missing functions\".\n             self.call_c_abi(\n                 instance.def_id(),\n-                arg_operands,\n+                args,\n                 dest,\n                 dest_ty,\n                 dest_block,\n             )?;\n             return Ok(());\n         }\n \n-        let args_res: EvalResult<Vec<Value>> = arg_operands\n-            .iter()\n-            .map(|arg| self.eval_operand(arg))\n-            .collect();\n-        let args = args_res?;\n-\n-        let usize = self.tcx.types.usize;\n-\n         match &path[..] {\n             // Allocators are magic.  They have no MIR, even when the rest of libstd does.\n             \"alloc::heap::::__rust_alloc\" => {\n-                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n-                let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                let size = self.value_to_primval(args[0])?.to_u64()?;\n+                let align = self.value_to_primval(args[1])?.to_u64()?;\n                 if size == 0 {\n                     return err!(HeapAllocZeroBytes);\n                 }\n@@ -577,8 +560,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n             }\n             \"alloc::heap::::__rust_alloc_zeroed\" => {\n-                let size = self.value_to_primval(args[0], usize)?.to_u64()?;\n-                let align = self.value_to_primval(args[1], usize)?.to_u64()?;\n+                let size = self.value_to_primval(args[0])?.to_u64()?;\n+                let align = self.value_to_primval(args[1])?.to_u64()?;\n                 if size == 0 {\n                     return err!(HeapAllocZeroBytes);\n                 }\n@@ -591,8 +574,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             }\n             \"alloc::heap::::__rust_dealloc\" => {\n                 let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n-                let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n-                let align = self.value_to_primval(args[2], usize)?.to_u64()?;\n+                let old_size = self.value_to_primval(args[1])?.to_u64()?;\n+                let align = self.value_to_primval(args[2])?.to_u64()?;\n                 if old_size == 0 {\n                     return err!(HeapAllocZeroBytes);\n                 }\n@@ -607,10 +590,10 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             }\n             \"alloc::heap::::__rust_realloc\" => {\n                 let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n-                let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n-                let old_align = self.value_to_primval(args[2], usize)?.to_u64()?;\n-                let new_size = self.value_to_primval(args[3], usize)?.to_u64()?;\n-                let new_align = self.value_to_primval(args[4], usize)?.to_u64()?;\n+                let old_size = self.value_to_primval(args[1])?.to_u64()?;\n+                let old_align = self.value_to_primval(args[2])?.to_u64()?;\n+                let new_size = self.value_to_primval(args[3])?.to_u64()?;\n+                let new_align = self.value_to_primval(args[4])?.to_u64()?;\n                 if old_size == 0 || new_size == 0 {\n                     return err!(HeapAllocZeroBytes);\n                 }"}, {"sha": "3e04f8598716414ffd4778cf0bc64f23f0789137", "filename": "miri/intrinsic.rs", "status": "modified", "additions": 80, "deletions": 87, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/4e3c502c53319728702088b06de8a9cb6953a7aa/miri%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3c502c53319728702088b06de8a9cb6953a7aa/miri%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fintrinsic.rs?ref=4e3c502c53319728702088b06de8a9cb6953a7aa", "patch": "@@ -4,15 +4,15 @@ use rustc::ty::layout::Layout;\n use rustc::ty::{self, Ty};\n \n use rustc_miri::interpret::{EvalResult, Lvalue, LvalueExtra, PrimVal, PrimValKind, Value, Pointer,\n-                            HasMemory, EvalContext, PtrAndAlign};\n+                            HasMemory, EvalContext, PtrAndAlign, ValTy};\n \n use helpers::EvalContextExt as HelperEvalContextExt;\n \n pub trait EvalContextExt<'tcx> {\n     fn call_intrinsic(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        args: &[mir::Operand<'tcx>],\n+        args: &[ValTy<'tcx>],\n         dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n         dest_layout: &'tcx Layout,\n@@ -24,29 +24,21 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n     fn call_intrinsic(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        args: &[mir::Operand<'tcx>],\n+        args: &[ValTy<'tcx>],\n         dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n         dest_layout: &'tcx Layout,\n         target: mir::BasicBlock,\n     ) -> EvalResult<'tcx> {\n-        let arg_vals: EvalResult<Vec<Value>> =\n-            args.iter().map(|arg| self.eval_operand(arg)).collect();\n-        let arg_vals = arg_vals?;\n-        let i32 = self.tcx.types.i32;\n-        let isize = self.tcx.types.isize;\n-        let usize = self.tcx.types.usize;\n-        let f32 = self.tcx.types.f32;\n-        let f64 = self.tcx.types.f64;\n         let substs = instance.substs;\n \n         let intrinsic_name = &self.tcx.item_name(instance.def_id()).as_str()[..];\n         match intrinsic_name {\n             \"add_with_overflow\" => {\n                 self.intrinsic_with_overflow(\n                     mir::BinOp::Add,\n-                    &args[0],\n-                    &args[1],\n+                    args[0],\n+                    args[1],\n                     dest,\n                     dest_ty,\n                 )?\n@@ -55,8 +47,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             \"sub_with_overflow\" => {\n                 self.intrinsic_with_overflow(\n                     mir::BinOp::Sub,\n-                    &args[0],\n-                    &args[1],\n+                    args[0],\n+                    args[1],\n                     dest,\n                     dest_ty,\n                 )?\n@@ -65,23 +57,22 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             \"mul_with_overflow\" => {\n                 self.intrinsic_with_overflow(\n                     mir::BinOp::Mul,\n-                    &args[0],\n-                    &args[1],\n+                    args[0],\n+                    args[1],\n                     dest,\n                     dest_ty,\n                 )?\n             }\n \n             \"arith_offset\" => {\n-                let offset = self.value_to_primval(arg_vals[1], isize)?.to_i128()? as i64;\n-                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n+                let offset = self.value_to_primval(args[1])?.to_i128()? as i64;\n+                let ptr = args[0].into_ptr(&self.memory)?;\n                 let result_ptr = self.wrapping_pointer_offset(ptr, substs.type_at(0), offset)?;\n                 self.write_ptr(dest, result_ptr, dest_ty)?;\n             }\n \n             \"assume\" => {\n-                let bool = self.tcx.types.bool;\n-                let cond = self.value_to_primval(arg_vals[0], bool)?.to_bool()?;\n+                let cond = self.value_to_primval(args[0])?.to_bool()?;\n                 if !cond {\n                     return err!(AssumptionNotHeld);\n                 }\n@@ -91,18 +82,21 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             \"atomic_load_relaxed\" |\n             \"atomic_load_acq\" |\n             \"volatile_load\" => {\n-                let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n-                self.write_value(Value::by_ref(ptr), dest, ty)?;\n+                let ptr = args[0].into_ptr(&self.memory)?;\n+                let valty = ValTy {\n+                    value: Value::by_ref(ptr),\n+                    ty: substs.type_at(0),\n+                };\n+                self.write_value(valty, dest)?;\n             }\n \n             \"atomic_store\" |\n             \"atomic_store_relaxed\" |\n             \"atomic_store_rel\" |\n             \"volatile_store\" => {\n                 let ty = substs.type_at(0);\n-                let dest = arg_vals[0].into_ptr(&self.memory)?;\n-                self.write_value_to_ptr(arg_vals[1], dest, ty)?;\n+                let dest = args[0].into_ptr(&self.memory)?;\n+                self.write_value_to_ptr(args[1].value, dest, ty)?;\n             }\n \n             \"atomic_fence_acq\" => {\n@@ -111,8 +105,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n \n             _ if intrinsic_name.starts_with(\"atomic_xchg\") => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n-                let change = self.value_to_primval(arg_vals[1], ty)?;\n+                let ptr = args[0].into_ptr(&self.memory)?;\n+                let change = self.value_to_primval(args[1])?;\n                 let old = self.read_value(ptr, ty)?;\n                 let old = match old {\n                     Value::ByVal(val) => val,\n@@ -129,9 +123,9 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n \n             _ if intrinsic_name.starts_with(\"atomic_cxchg\") => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n-                let expect_old = self.value_to_primval(arg_vals[1], ty)?;\n-                let change = self.value_to_primval(arg_vals[2], ty)?;\n+                let ptr = args[0].into_ptr(&self.memory)?;\n+                let expect_old = self.value_to_primval(args[1])?;\n+                let change = self.value_to_primval(args[2])?;\n                 let old = self.read_value(ptr, ty)?;\n                 let old = match old {\n                     Value::ByVal(val) => val,\n@@ -174,8 +168,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             \"atomic_xsub_acqrel\" |\n             \"atomic_xsub_relaxed\" => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n-                let change = self.value_to_primval(arg_vals[1], ty)?;\n+                let ptr = args[0].into_ptr(&self.memory)?;\n+                let change = self.value_to_primval(args[1])?;\n                 let old = self.read_value(ptr, ty)?;\n                 let old = match old {\n                     Value::ByVal(val) => val,\n@@ -204,13 +198,13 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             \"copy_nonoverlapping\" => {\n                 let elem_ty = substs.type_at(0);\n                 let elem_size = self.type_size(elem_ty)?.expect(\"cannot copy unsized value\");\n-                let count = self.value_to_primval(arg_vals[2], usize)?.to_u64()?;\n+                let count = self.value_to_primval(args[2])?.to_u64()?;\n                 if count * elem_size != 0 {\n                     // TODO: We do not even validate alignment for the 0-bytes case.  libstd relies on this in vec::IntoIter::next.\n                     // Also see the write_bytes intrinsic.\n                     let elem_align = self.type_align(elem_ty)?;\n-                    let src = arg_vals[0].into_ptr(&self.memory)?;\n-                    let dest = arg_vals[1].into_ptr(&self.memory)?;\n+                    let src = args[0].into_ptr(&self.memory)?;\n+                    let dest = args[1].into_ptr(&self.memory)?;\n                     self.memory.copy(\n                         src,\n                         dest,\n@@ -223,7 +217,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n \n             \"ctpop\" | \"cttz\" | \"cttz_nonzero\" | \"ctlz\" | \"ctlz_nonzero\" | \"bswap\" => {\n                 let ty = substs.type_at(0);\n-                let num = self.value_to_primval(arg_vals[0], ty)?.to_bytes()?;\n+                let num = self.value_to_primval(args[0])?.to_bytes()?;\n                 let kind = self.ty_to_primval_kind(ty)?;\n                 let num = if intrinsic_name.ends_with(\"_nonzero\") {\n                     if num == 0 {\n@@ -238,14 +232,14 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n \n             \"discriminant_value\" => {\n                 let ty = substs.type_at(0);\n-                let adt_ptr = arg_vals[0].into_ptr(&self.memory)?.to_ptr()?;\n+                let adt_ptr = args[0].into_ptr(&self.memory)?.to_ptr()?;\n                 let discr_val = self.read_discriminant_value(adt_ptr, ty)?;\n                 self.write_primval(dest, PrimVal::Bytes(discr_val), dest_ty)?;\n             }\n \n             \"sinf32\" | \"fabsf32\" | \"cosf32\" | \"sqrtf32\" | \"expf32\" | \"exp2f32\" | \"logf32\" |\n             \"log10f32\" | \"log2f32\" | \"floorf32\" | \"ceilf32\" | \"truncf32\" => {\n-                let f = self.value_to_primval(arg_vals[0], f32)?.to_f32()?;\n+                let f = self.value_to_primval(args[0])?.to_f32()?;\n                 let f = match intrinsic_name {\n                     \"sinf32\" => f.sin(),\n                     \"fabsf32\" => f.abs(),\n@@ -266,7 +260,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n \n             \"sinf64\" | \"fabsf64\" | \"cosf64\" | \"sqrtf64\" | \"expf64\" | \"exp2f64\" | \"logf64\" |\n             \"log10f64\" | \"log2f64\" | \"floorf64\" | \"ceilf64\" | \"truncf64\" => {\n-                let f = self.value_to_primval(arg_vals[0], f64)?.to_f64()?;\n+                let f = self.value_to_primval(args[0])?.to_f64()?;\n                 let f = match intrinsic_name {\n                     \"sinf64\" => f.sin(),\n                     \"fabsf64\" => f.abs(),\n@@ -287,8 +281,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n \n             \"fadd_fast\" | \"fsub_fast\" | \"fmul_fast\" | \"fdiv_fast\" | \"frem_fast\" => {\n                 let ty = substs.type_at(0);\n-                let a = self.value_to_primval(arg_vals[0], ty)?;\n-                let b = self.value_to_primval(arg_vals[1], ty)?;\n+                let a = self.value_to_primval(args[0])?;\n+                let b = self.value_to_primval(args[1])?;\n                 let op = match intrinsic_name {\n                     \"fadd_fast\" => mir::BinOp::Add,\n                     \"fsub_fast\" => mir::BinOp::Sub,\n@@ -360,8 +354,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n \n             \"move_val_init\" => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n-                self.write_value_to_ptr(arg_vals[1], ptr, ty)?;\n+                let ptr = args[0].into_ptr(&self.memory)?;\n+                self.write_value_to_ptr(args[1].value, ptr, ty)?;\n             }\n \n             \"needs_drop\" => {\n@@ -376,17 +370,17 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             }\n \n             \"offset\" => {\n-                let offset = self.value_to_primval(arg_vals[1], isize)?.to_i128()? as i64;\n-                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n+                let offset = self.value_to_primval(args[1])?.to_i128()? as i64;\n+                let ptr = args[0].into_ptr(&self.memory)?;\n                 let result_ptr = self.pointer_offset(ptr, substs.type_at(0), offset)?;\n                 self.write_ptr(dest, result_ptr, dest_ty)?;\n             }\n \n             \"overflowing_sub\" => {\n                 self.intrinsic_overflowing(\n                     mir::BinOp::Sub,\n-                    &args[0],\n-                    &args[1],\n+                    args[0],\n+                    args[1],\n                     dest,\n                     dest_ty,\n                 )?;\n@@ -395,8 +389,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             \"overflowing_mul\" => {\n                 self.intrinsic_overflowing(\n                     mir::BinOp::Mul,\n-                    &args[0],\n-                    &args[1],\n+                    args[0],\n+                    args[1],\n                     dest,\n                     dest_ty,\n                 )?;\n@@ -405,16 +399,16 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             \"overflowing_add\" => {\n                 self.intrinsic_overflowing(\n                     mir::BinOp::Add,\n-                    &args[0],\n-                    &args[1],\n+                    args[0],\n+                    args[1],\n                     dest,\n                     dest_ty,\n                 )?;\n             }\n \n             \"powf32\" => {\n-                let f = self.value_to_primval(arg_vals[0], f32)?.to_f32()?;\n-                let f2 = self.value_to_primval(arg_vals[1], f32)?.to_f32()?;\n+                let f = self.value_to_primval(args[0])?.to_f32()?;\n+                let f2 = self.value_to_primval(args[1])?.to_f32()?;\n                 self.write_primval(\n                     dest,\n                     PrimVal::from_f32(f.powf(f2)),\n@@ -423,8 +417,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             }\n \n             \"powf64\" => {\n-                let f = self.value_to_primval(arg_vals[0], f64)?.to_f64()?;\n-                let f2 = self.value_to_primval(arg_vals[1], f64)?.to_f64()?;\n+                let f = self.value_to_primval(args[0])?.to_f64()?;\n+                let f2 = self.value_to_primval(args[1])?.to_f64()?;\n                 self.write_primval(\n                     dest,\n                     PrimVal::from_f64(f.powf(f2)),\n@@ -433,9 +427,9 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             }\n \n             \"fmaf32\" => {\n-                let a = self.value_to_primval(arg_vals[0], f32)?.to_f32()?;\n-                let b = self.value_to_primval(arg_vals[1], f32)?.to_f32()?;\n-                let c = self.value_to_primval(arg_vals[2], f32)?.to_f32()?;\n+                let a = self.value_to_primval(args[0])?.to_f32()?;\n+                let b = self.value_to_primval(args[1])?.to_f32()?;\n+                let c = self.value_to_primval(args[2])?.to_f32()?;\n                 self.write_primval(\n                     dest,\n                     PrimVal::from_f32(a * b + c),\n@@ -444,9 +438,9 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             }\n \n             \"fmaf64\" => {\n-                let a = self.value_to_primval(arg_vals[0], f64)?.to_f64()?;\n-                let b = self.value_to_primval(arg_vals[1], f64)?.to_f64()?;\n-                let c = self.value_to_primval(arg_vals[2], f64)?.to_f64()?;\n+                let a = self.value_to_primval(args[0])?.to_f64()?;\n+                let b = self.value_to_primval(args[1])?.to_f64()?;\n+                let c = self.value_to_primval(args[2])?.to_f64()?;\n                 self.write_primval(\n                     dest,\n                     PrimVal::from_f64(a * b + c),\n@@ -455,8 +449,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             }\n \n             \"powif32\" => {\n-                let f = self.value_to_primval(arg_vals[0], f32)?.to_f32()?;\n-                let i = self.value_to_primval(arg_vals[1], i32)?.to_i128()?;\n+                let f = self.value_to_primval(args[0])?.to_f32()?;\n+                let i = self.value_to_primval(args[1])?.to_i128()?;\n                 self.write_primval(\n                     dest,\n                     PrimVal::from_f32(f.powi(i as i32)),\n@@ -465,8 +459,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             }\n \n             \"powif64\" => {\n-                let f = self.value_to_primval(arg_vals[0], f64)?.to_f64()?;\n-                let i = self.value_to_primval(arg_vals[1], i32)?.to_i128()?;\n+                let f = self.value_to_primval(args[0])?.to_f64()?;\n+                let i = self.value_to_primval(args[1])?.to_i128()?;\n                 self.write_primval(\n                     dest,\n                     PrimVal::from_f64(f.powi(i as i32)),\n@@ -484,7 +478,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n \n             \"size_of_val\" => {\n                 let ty = substs.type_at(0);\n-                let (size, _) = self.size_and_align_of_dst(ty, arg_vals[0])?;\n+                let (size, _) = self.size_and_align_of_dst(ty, args[0].value)?;\n                 self.write_primval(\n                     dest,\n                     PrimVal::from_u128(size as u128),\n@@ -495,7 +489,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             \"min_align_of_val\" |\n             \"align_of_val\" => {\n                 let ty = substs.type_at(0);\n-                let (_, align) = self.size_and_align_of_dst(ty, arg_vals[0])?;\n+                let (_, align) = self.size_and_align_of_dst(ty, args[0].value)?;\n                 self.write_primval(\n                     dest,\n                     PrimVal::from_u128(align as u128),\n@@ -506,8 +500,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             \"type_name\" => {\n                 let ty = substs.type_at(0);\n                 let ty_name = ty.to_string();\n-                let s = self.str_to_value(&ty_name)?;\n-                self.write_value(s, dest, dest_ty)?;\n+                let value = self.str_to_value(&ty_name)?;\n+                self.write_value(ValTy { value, ty: dest_ty }, dest)?;\n             }\n             \"type_id\" => {\n                 let ty = substs.type_at(0);\n@@ -522,7 +516,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                     /*aligned*/\n                     false,\n                     |ectx| {\n-                        ectx.write_value_to_ptr(arg_vals[0], ptr.into(), src_ty)\n+                        ectx.write_value_to_ptr(args[0].value, ptr.into(), src_ty)\n                     },\n                 )?;\n             }\n@@ -531,7 +525,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let bits = self.type_size(dest_ty)?.expect(\n                     \"intrinsic can't be called on unsized type\",\n                 ) as u128 * 8;\n-                let rhs = self.value_to_primval(arg_vals[1], substs.type_at(0))?\n+                let rhs = self.value_to_primval(args[1])?\n                     .to_bytes()?;\n                 if rhs >= bits {\n                     return err!(Intrinsic(\n@@ -540,8 +534,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 }\n                 self.intrinsic_overflowing(\n                     mir::BinOp::Shl,\n-                    &args[0],\n-                    &args[1],\n+                    args[0],\n+                    args[1],\n                     dest,\n                     dest_ty,\n                 )?;\n@@ -551,7 +545,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 let bits = self.type_size(dest_ty)?.expect(\n                     \"intrinsic can't be called on unsized type\",\n                 ) as u128 * 8;\n-                let rhs = self.value_to_primval(arg_vals[1], substs.type_at(0))?\n+                let rhs = self.value_to_primval(args[1])?\n                     .to_bytes()?;\n                 if rhs >= bits {\n                     return err!(Intrinsic(\n@@ -560,38 +554,38 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 }\n                 self.intrinsic_overflowing(\n                     mir::BinOp::Shr,\n-                    &args[0],\n-                    &args[1],\n+                    args[0],\n+                    args[1],\n                     dest,\n                     dest_ty,\n                 )?;\n             }\n \n             \"unchecked_div\" => {\n-                let rhs = self.value_to_primval(arg_vals[1], substs.type_at(0))?\n+                let rhs = self.value_to_primval(args[1])?\n                     .to_bytes()?;\n                 if rhs == 0 {\n                     return err!(Intrinsic(format!(\"Division by 0 in unchecked_div\")));\n                 }\n                 self.intrinsic_overflowing(\n                     mir::BinOp::Div,\n-                    &args[0],\n-                    &args[1],\n+                    args[0],\n+                    args[1],\n                     dest,\n                     dest_ty,\n                 )?;\n             }\n \n             \"unchecked_rem\" => {\n-                let rhs = self.value_to_primval(arg_vals[1], substs.type_at(0))?\n+                let rhs = self.value_to_primval(args[1])?\n                     .to_bytes()?;\n                 if rhs == 0 {\n                     return err!(Intrinsic(format!(\"Division by 0 in unchecked_rem\")));\n                 }\n                 self.intrinsic_overflowing(\n                     mir::BinOp::Rem,\n-                    &args[0],\n-                    &args[1],\n+                    args[0],\n+                    args[1],\n                     dest,\n                     dest_ty,\n                 )?;\n@@ -619,15 +613,14 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n             }\n \n             \"write_bytes\" => {\n-                let u8 = self.tcx.types.u8;\n                 let ty = substs.type_at(0);\n                 let ty_align = self.type_align(ty)?;\n-                let val_byte = self.value_to_primval(arg_vals[1], u8)?.to_u128()? as u8;\n+                let val_byte = self.value_to_primval(args[1])?.to_u128()? as u8;\n                 let size = self.type_size(ty)?.expect(\n                     \"write_bytes() type must be sized\",\n                 );\n-                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n-                let count = self.value_to_primval(arg_vals[2], usize)?.to_u64()?;\n+                let ptr = args[0].into_ptr(&self.memory)?;\n+                let count = self.value_to_primval(args[2])?.to_u64()?;\n                 if count > 0 {\n                     // HashMap relies on write_bytes on a NULL ptr with count == 0 to work\n                     // TODO: Should we, at least, validate the alignment? (Also see the copy intrinsic)"}, {"sha": "204746244c888a869497d33111e25ea91127a161", "filename": "miri/lib.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4e3c502c53319728702088b06de8a9cb6953a7aa/miri%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3c502c53319728702088b06de8a9cb6953a7aa/miri%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Flib.rs?ref=4e3c502c53319728702088b06de8a9cb6953a7aa", "patch": "@@ -94,9 +94,11 @@ pub fn eval_main<'a, 'tcx: 'a>(\n             let main_ty = main_instance.def.def_ty(ecx.tcx);\n             let main_ptr_ty = ecx.tcx.mk_fn_ptr(main_ty.fn_sig(ecx.tcx));\n             ecx.write_value(\n-                Value::ByVal(PrimVal::Ptr(main_ptr)),\n+                ValTy {\n+                    value: Value::ByVal(PrimVal::Ptr(main_ptr)),\n+                    ty: main_ptr_ty,\n+                },\n                 dest,\n-                main_ptr_ty,\n             )?;\n \n             // Second argument (argc): 0\n@@ -179,17 +181,17 @@ impl<'tcx> Machine<'tcx> for Evaluator {\n         ecx: &mut EvalContext<'a, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         destination: Option<(Lvalue, mir::BasicBlock)>,\n-        arg_operands: &[mir::Operand<'tcx>],\n+        args: &[ValTy<'tcx>],\n         span: Span,\n         sig: ty::FnSig<'tcx>,\n     ) -> EvalResult<'tcx, bool> {\n-        ecx.eval_fn_call(instance, destination, arg_operands, span, sig)\n+        ecx.eval_fn_call(instance, destination, args, span, sig)\n     }\n \n     fn call_intrinsic<'a>(\n         ecx: &mut rustc_miri::interpret::EvalContext<'a, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        args: &[mir::Operand<'tcx>],\n+        args: &[ValTy<'tcx>],\n         dest: Lvalue,\n         dest_ty: ty::Ty<'tcx>,\n         dest_layout: &'tcx Layout,"}, {"sha": "82795340ddaf4519c289fc1988fd4277b448cea8", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4e3c502c53319728702088b06de8a9cb6953a7aa/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3c502c53319728702088b06de8a9cb6953a7aa/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=4e3c502c53319728702088b06de8a9cb6953a7aa", "patch": "@@ -6,7 +6,7 @@ use syntax::ast::Mutability;\n use syntax::codemap::Span;\n \n use super::{EvalResult, EvalError, EvalErrorKind, GlobalId, Lvalue, Value, PrimVal, EvalContext,\n-            StackPopCleanup, PtrAndAlign, MemoryKind};\n+            StackPopCleanup, PtrAndAlign, MemoryKind, ValTy};\n \n use rustc_const_math::ConstInt;\n \n@@ -69,7 +69,11 @@ pub fn eval_body_as_primval<'a, 'tcx>(\n         while ecx.step()? {}\n     }\n     let value = Value::ByRef(*ecx.globals.get(&cid).expect(\"global not cached\"));\n-    Ok((ecx.value_to_primval(value, mir.return_ty)?, mir.return_ty))\n+    let valty = ValTy {\n+        value,\n+        ty: mir.return_ty,\n+    };\n+    Ok((ecx.value_to_primval(valty)?, mir.return_ty))\n }\n \n pub fn eval_body_as_integer<'a, 'tcx>(\n@@ -162,7 +166,7 @@ impl<'tcx> super::Machine<'tcx> for CompileTimeFunctionEvaluator {\n         ecx: &mut EvalContext<'a, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         destination: Option<(Lvalue, mir::BasicBlock)>,\n-        _arg_operands: &[mir::Operand<'tcx>],\n+        _args: &[ValTy<'tcx>],\n         span: Span,\n         _sig: ty::FnSig<'tcx>,\n     ) -> EvalResult<'tcx, bool> {\n@@ -201,7 +205,7 @@ impl<'tcx> super::Machine<'tcx> for CompileTimeFunctionEvaluator {\n     fn call_intrinsic<'a>(\n         _ecx: &mut EvalContext<'a, 'tcx, Self>,\n         _instance: ty::Instance<'tcx>,\n-        _args: &[mir::Operand<'tcx>],\n+        _args: &[ValTy<'tcx>],\n         _dest: Lvalue,\n         _dest_ty: Ty<'tcx>,\n         _dest_layout: &'tcx layout::Layout,"}, {"sha": "9fbc32c4f005c2dbaca374aec61e5f6b8ce291dd", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 119, "deletions": 49, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/4e3c502c53319728702088b06de8a9cb6953a7aa/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3c502c53319728702088b06de8a9cb6953a7aa/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=4e3c502c53319728702088b06de8a9cb6953a7aa", "patch": "@@ -133,6 +133,19 @@ pub struct TyAndPacked<'tcx> {\n     pub packed: bool,\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub struct ValTy<'tcx> {\n+    pub value: Value,\n+    pub ty: Ty<'tcx>,\n+}\n+\n+impl<'tcx> ::std::ops::Deref for ValTy<'tcx> {\n+    type Target = Value;\n+    fn deref(&self) -> &Value {\n+        &self.value\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub struct PtrAndAlign {\n     pub ptr: Pointer,\n@@ -597,14 +610,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         if self.ty_to_primval_kind(dest_ty).is_ok() {\n             assert_eq!(operands.len(), 1);\n             let value = self.eval_operand(&operands[0])?;\n-            let value_ty = self.operand_ty(&operands[0]);\n-            return self.write_value(value, dest, value_ty);\n+            return self.write_value(value, dest);\n         }\n         for (field_index, operand) in operands.iter().enumerate() {\n             let value = self.eval_operand(operand)?;\n-            let value_ty = self.operand_ty(operand);\n-            let field_dest = self.lvalue_field(dest, field_index, dest_ty, value_ty)?;\n-            self.write_value(value, field_dest, value_ty)?;\n+            let field_dest = self.lvalue_field(dest, field_index, dest_ty, value.ty)?;\n+            self.write_value(value, field_dest)?;\n         }\n         Ok(())\n     }\n@@ -625,11 +636,17 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         use rustc::mir::Rvalue::*;\n         match *rvalue {\n             Use(ref operand) => {\n-                let value = self.eval_operand(operand)?;\n-                self.write_value(value, dest, dest_ty)?;\n+                let value = self.eval_operand(operand)?.value;\n+                let valty = ValTy {\n+                    value,\n+                    ty: dest_ty,\n+                };\n+                self.write_value(valty, dest)?;\n             }\n \n             BinaryOp(bin_op, ref left, ref right) => {\n+                let left = self.eval_operand(left)?;\n+                let right = self.eval_operand(right)?;\n                 if self.intrinsic_overflowing(\n                     bin_op,\n                     left,\n@@ -648,6 +665,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n \n             CheckedBinaryOp(bin_op, ref left, ref right) => {\n+                let left = self.eval_operand(left)?;\n+                let right = self.eval_operand(right)?;\n                 self.intrinsic_with_overflow(\n                     bin_op,\n                     left,\n@@ -717,8 +736,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                                 assert_eq!(operands.len(), 1);\n                                 let operand = &operands[0];\n                                 let value = self.eval_operand(operand)?;\n-                                let value_ty = self.operand_ty(operand);\n-                                self.write_value(value, dest, value_ty)?;\n+                                self.write_value(value, dest)?;\n                             } else {\n                                 if let Some(operand) = operands.get(0) {\n                                     assert_eq!(operands.len(), 1);\n@@ -796,9 +814,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         assert_eq!(operands.len(), 1);\n                         let operand = &operands[0];\n                         let value = self.eval_operand(operand)?;\n-                        let value_ty = self.operand_ty(operand);\n                         self.write_maybe_aligned_mut(!variants.packed, |ecx| {\n-                            ecx.write_value(value, dest, value_ty)\n+                            ecx.write_value(value, dest)\n                         })?;\n                     }\n \n@@ -826,7 +843,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let elem_size = self.type_size(elem_ty)?.expect(\n                     \"repeat element type must be sized\",\n                 );\n-                let value = self.eval_operand(operand)?;\n+                let value = self.eval_operand(operand)?.value;\n \n                 // FIXME(solson)\n                 let dest = Pointer::from(self.force_allocation(dest)?.to_ptr()?);\n@@ -863,7 +880,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         bug!(\"attempted to take a reference to an enum downcast lvalue\")\n                     }\n                 };\n-                self.write_value(val, dest, dest_ty)?;\n+                let valty = ValTy {\n+                    value: val,\n+                    ty: dest_ty,\n+                };\n+                self.write_value(valty, dest)?;\n             }\n \n             NullaryOp(mir::NullOp::Box, ty) => {\n@@ -888,28 +909,38 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 match kind {\n                     Unsize => {\n                         let src = self.eval_operand(operand)?;\n-                        let src_ty = self.operand_ty(operand);\n-                        self.unsize_into(src, src_ty, dest, dest_ty)?;\n+                        self.unsize_into(src.value, src.ty, dest, dest_ty)?;\n                     }\n \n                     Misc => {\n                         let src = self.eval_operand(operand)?;\n-                        let src_ty = self.operand_ty(operand);\n-                        if self.type_is_fat_ptr(src_ty) {\n-                            match (src, self.type_is_fat_ptr(dest_ty)) {\n+                        if self.type_is_fat_ptr(src.ty) {\n+                            match (src.value, self.type_is_fat_ptr(dest_ty)) {\n                                 (Value::ByRef { .. }, _) |\n                                 (Value::ByValPair(..), true) => {\n-                                    self.write_value(src, dest, dest_ty)?;\n+                                    let valty = ValTy {\n+                                        value: src.value,\n+                                        ty: dest_ty,\n+                                    };\n+                                    self.write_value(valty, dest)?;\n                                 }\n                                 (Value::ByValPair(data, _), false) => {\n-                                    self.write_value(Value::ByVal(data), dest, dest_ty)?;\n+                                    let valty = ValTy {\n+                                        value: Value::ByVal(data),\n+                                        ty: dest_ty,\n+                                    };\n+                                    self.write_value(valty, dest)?;\n                                 }\n                                 (Value::ByVal(_), _) => bug!(\"expected fat ptr\"),\n                             }\n                         } else {\n-                            let src_val = self.value_to_primval(src, src_ty)?;\n-                            let dest_val = self.cast_primval(src_val, src_ty, dest_ty)?;\n-                            self.write_value(Value::ByVal(dest_val), dest, dest_ty)?;\n+                            let src_val = self.value_to_primval(src)?;\n+                            let dest_val = self.cast_primval(src_val, src.ty, dest_ty)?;\n+                            let valty = ValTy {\n+                                value: Value::ByVal(dest_val),\n+                                ty: dest_ty,\n+                            };\n+                            self.write_value(valty, dest)?;\n                         }\n                     }\n \n@@ -918,11 +949,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                             ty::TyFnDef(def_id, substs) => {\n                                 let instance = resolve(self.tcx, def_id, substs);\n                                 let fn_ptr = self.memory.create_fn_alloc(instance);\n-                                self.write_value(\n-                                    Value::ByVal(PrimVal::Ptr(fn_ptr)),\n-                                    dest,\n-                                    dest_ty,\n-                                )?;\n+                                let valty = ValTy {\n+                                    value: Value::ByVal(PrimVal::Ptr(fn_ptr)),\n+                                    ty: dest_ty,\n+                                };\n+                                self.write_value(valty, dest)?;\n                             }\n                             ref other => bug!(\"reify fn pointer on {:?}\", other),\n                         }\n@@ -931,8 +962,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     UnsafeFnPointer => {\n                         match dest_ty.sty {\n                             ty::TyFnPtr(_) => {\n-                                let src = self.eval_operand(operand)?;\n-                                self.write_value(src, dest, dest_ty)?;\n+                                let mut src = self.eval_operand(operand)?;\n+                                src.ty = dest_ty;\n+                                self.write_value(src, dest)?;\n                             }\n                             ref other => bug!(\"fn to unsafe fn cast on {:?}\", other),\n                         }\n@@ -948,11 +980,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                                     ty::ClosureKind::FnOnce,\n                                 );\n                                 let fn_ptr = self.memory.create_fn_alloc(instance);\n-                                self.write_value(\n-                                    Value::ByVal(PrimVal::Ptr(fn_ptr)),\n-                                    dest,\n-                                    dest_ty,\n-                                )?;\n+                                let valty = ValTy {\n+                                    value: Value::ByVal(PrimVal::Ptr(fn_ptr)),\n+                                    ty: dest_ty,\n+                                };\n+                                self.write_value(valty, dest)?;\n                             }\n                             ref other => bug!(\"closure fn pointer on {:?}\", other),\n                         }\n@@ -1208,15 +1240,28 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         &mut self,\n         op: &mir::Operand<'tcx>,\n     ) -> EvalResult<'tcx, PrimVal> {\n-        let value = self.eval_operand(op)?;\n-        let ty = self.operand_ty(op);\n-        self.value_to_primval(value, ty)\n+        let valty = self.eval_operand(op)?;\n+        self.value_to_primval(valty)\n+    }\n+\n+    pub(crate) fn operands_to_args(\n+        &mut self,\n+        ops: &[mir::Operand<'tcx>],\n+    ) -> EvalResult<'tcx, Vec<ValTy<'tcx>>> {\n+        ops.into_iter()\n+            .map(|op| self.eval_operand(op))\n+            .collect()\n     }\n \n-    pub fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, ValTy<'tcx>> {\n         use rustc::mir::Operand::*;\n         match *op {\n-            Consume(ref lvalue) => self.eval_and_read_lvalue(lvalue),\n+            Consume(ref lvalue) => {\n+                Ok(ValTy {\n+                    value: self.eval_and_read_lvalue(lvalue)?,\n+                    ty: self.operand_ty(op),\n+                })\n+            },\n \n             Constant(ref constant) => {\n                 use rustc::mir::Literal;\n@@ -1242,7 +1287,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     }\n                 };\n \n-                Ok(value)\n+                Ok(ValTy {\n+                    value,\n+                    ty: self.operand_ty(op),\n+                })\n             }\n         }\n     }\n@@ -1322,7 +1370,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n     }\n \n-    pub fn value_to_primval(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+    pub fn value_to_primval(\n+        &mut self,\n+        ValTy { value, ty } : ValTy<'tcx>,\n+    ) -> EvalResult<'tcx, PrimVal> {\n         match self.follow_by_ref_value(value, ty)? {\n             Value::ByRef { .. } => bug!(\"follow_by_ref_value can't result in `ByRef`\"),\n \n@@ -1340,7 +1391,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     pub fn write_ptr(&mut self, dest: Lvalue, val: Pointer, dest_ty: Ty<'tcx>) -> EvalResult<'tcx> {\n-        self.write_value(val.to_value(), dest, dest_ty)\n+        let valty = ValTy {\n+            value: val.to_value(),\n+            ty: dest_ty,\n+        };\n+        self.write_value(valty, dest)\n     }\n \n     pub fn write_primval(\n@@ -1349,14 +1404,17 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         val: PrimVal,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        self.write_value(Value::ByVal(val), dest, dest_ty)\n+        let valty = ValTy {\n+            value: Value::ByVal(val),\n+            ty: dest_ty,\n+        };\n+        self.write_value(valty, dest)\n     }\n \n     pub fn write_value(\n         &mut self,\n-        src_val: Value,\n+        ValTy { value: src_val, ty: dest_ty } : ValTy<'tcx>,\n         dest: Lvalue,\n-        dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         //trace!(\"Writing {:?} to {:?} at type {:?}\", src_val, dest, dest_ty);\n         // Note that it is really important that the type here is the right one, and matches the type things are read at.\n@@ -1753,13 +1811,21 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n                 let ptr = src.into_ptr(&self.memory)?;\n                 // u64 cast is from usize to u64, which is always good\n-                self.write_value(ptr.to_value_with_len(length as u64), dest, dest_ty)\n+                let valty = ValTy {\n+                    value: ptr.to_value_with_len(length as u64),\n+                    ty: dest_ty,\n+                };\n+                self.write_value(valty, dest)\n             }\n             (&ty::TyDynamic(..), &ty::TyDynamic(..)) => {\n                 // For now, upcasts are limited to changes in marker\n                 // traits, and hence never actually require an actual\n                 // change to the vtable.\n-                self.write_value(src, dest, dest_ty)\n+                let valty = ValTy {\n+                    value: src,\n+                    ty: dest_ty,\n+                };\n+                self.write_value(valty, dest)\n             }\n             (_, &ty::TyDynamic(ref data, _)) => {\n                 let trait_ref = data.principal().unwrap().with_self_ty(\n@@ -1769,7 +1835,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let trait_ref = self.tcx.erase_regions(&trait_ref);\n                 let vtable = self.get_vtable(src_pointee_ty, trait_ref)?;\n                 let ptr = src.into_ptr(&self.memory)?;\n-                self.write_value(ptr.to_value_with_vtable(vtable), dest, dest_ty)\n+                let valty = ValTy {\n+                    value: ptr.to_value_with_vtable(vtable),\n+                    ty: dest_ty,\n+                };\n+                self.write_value(valty, dest)\n             }\n \n             _ => bug!(\"invalid unsizing {:?} -> {:?}\", src_ty, dest_ty),"}, {"sha": "2bb0b88a356f6ca5a7a12ef68218f468cdeb5697", "filename": "src/librustc_mir/interpret/lvalue.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e3c502c53319728702088b06de8a9cb6953a7aa/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3c502c53319728702088b06de8a9cb6953a7aa/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs?ref=4e3c502c53319728702088b06de8a9cb6953a7aa", "patch": "@@ -435,10 +435,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n \n             Index(ref operand) => {\n-                // FIXME(solson)\n                 let n_ptr = self.eval_operand(operand)?;\n-                let usize = self.tcx.types.usize;\n-                let n = self.value_to_primval(n_ptr, usize)?.to_u64()?;\n+                let n = self.value_to_primval(n_ptr)?.to_u64()?;\n                 return self.lvalue_index(base, base_ty, n);\n             }\n "}, {"sha": "2d607005fe7d7091f8c31790fd6d146d7aa3afb1", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e3c502c53319728702088b06de8a9cb6953a7aa/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3c502c53319728702088b06de8a9cb6953a7aa/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=4e3c502c53319728702088b06de8a9cb6953a7aa", "patch": "@@ -2,7 +2,7 @@\n //! This separation exists to ensure that no fancy miri features like\n //! interpreting common C functions leak into CTFE.\n \n-use super::{EvalResult, EvalContext, Lvalue, PrimVal};\n+use super::{EvalResult, EvalContext, Lvalue, PrimVal, ValTy};\n \n use rustc::{mir, ty};\n use syntax::codemap::Span;\n@@ -29,7 +29,7 @@ pub trait Machine<'tcx>: Sized {\n         ecx: &mut EvalContext<'a, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         destination: Option<(Lvalue, mir::BasicBlock)>,\n-        arg_operands: &[mir::Operand<'tcx>],\n+        args: &[ValTy<'tcx>],\n         span: Span,\n         sig: ty::FnSig<'tcx>,\n     ) -> EvalResult<'tcx, bool>;\n@@ -38,7 +38,7 @@ pub trait Machine<'tcx>: Sized {\n     fn call_intrinsic<'a>(\n         ecx: &mut EvalContext<'a, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        args: &[mir::Operand<'tcx>],\n+        args: &[ValTy<'tcx>],\n         dest: Lvalue,\n         dest_ty: ty::Ty<'tcx>,\n         dest_layout: &'tcx ty::layout::Layout,"}, {"sha": "3a5fdf273a4841eb6f066c7e9a1f8e6ecd113f6f", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e3c502c53319728702088b06de8a9cb6953a7aa/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3c502c53319728702088b06de8a9cb6953a7aa/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=4e3c502c53319728702088b06de8a9cb6953a7aa", "patch": "@@ -23,7 +23,7 @@ mod value;\n pub use self::error::{EvalError, EvalResult, EvalErrorKind};\n \n pub use self::eval_context::{EvalContext, Frame, ResourceLimits, StackPopCleanup, DynamicLifetime,\n-                             TyAndPacked, PtrAndAlign};\n+                             TyAndPacked, PtrAndAlign, ValTy};\n \n pub use self::lvalue::{Lvalue, LvalueExtra, GlobalId};\n "}, {"sha": "69a8882631a517d37a80ee3f43e1484aa9003097", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4e3c502c53319728702088b06de8a9cb6953a7aa/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3c502c53319728702088b06de8a9cb6953a7aa/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=4e3c502c53319728702088b06de8a9cb6953a7aa", "patch": "@@ -1,7 +1,7 @@\n use rustc::mir;\n use rustc::ty::Ty;\n \n-use super::{EvalResult, EvalContext, Lvalue, Machine};\n+use super::{EvalResult, EvalContext, Lvalue, Machine, ValTy};\n \n use super::value::{PrimVal, PrimValKind, Value, bytes_to_f32, bytes_to_f64, f32_to_bytes,\n                    f64_to_bytes};\n@@ -10,38 +10,40 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     fn binop_with_overflow(\n         &mut self,\n         op: mir::BinOp,\n-        left: &mir::Operand<'tcx>,\n-        right: &mir::Operand<'tcx>,\n+        left: ValTy<'tcx>,\n+        right: ValTy<'tcx>,\n     ) -> EvalResult<'tcx, (PrimVal, bool)> {\n-        let left_ty = self.operand_ty(left);\n-        let right_ty = self.operand_ty(right);\n-        let left_val = self.eval_operand_to_primval(left)?;\n-        let right_val = self.eval_operand_to_primval(right)?;\n-        self.binary_op(op, left_val, left_ty, right_val, right_ty)\n+        let left_val = self.value_to_primval(left)?;\n+        let right_val = self.value_to_primval(right)?;\n+        self.binary_op(op, left_val, left.ty, right_val, right.ty)\n     }\n \n     /// Applies the binary operation `op` to the two operands and writes a tuple of the result\n     /// and a boolean signifying the potential overflow to the destination.\n     pub fn intrinsic_with_overflow(\n         &mut self,\n         op: mir::BinOp,\n-        left: &mir::Operand<'tcx>,\n-        right: &mir::Operand<'tcx>,\n+        left: ValTy<'tcx>,\n+        right: ValTy<'tcx>,\n         dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n         let (val, overflowed) = self.binop_with_overflow(op, left, right)?;\n         let val = Value::ByValPair(val, PrimVal::from_bool(overflowed));\n-        self.write_value(val, dest, dest_ty)\n+        let valty = ValTy {\n+            value: val,\n+            ty: dest_ty,\n+        };\n+        self.write_value(valty, dest)\n     }\n \n     /// Applies the binary operation `op` to the arguments and writes the result to the\n     /// destination. Returns `true` if the operation overflowed.\n     pub fn intrinsic_overflowing(\n         &mut self,\n         op: mir::BinOp,\n-        left: &mir::Operand<'tcx>,\n-        right: &mir::Operand<'tcx>,\n+        left: ValTy<'tcx>,\n+        right: ValTy<'tcx>,\n         dest: Lvalue,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, bool> {"}, {"sha": "32a4c66df2a807a290db0fd7cba52941c594eabb", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4e3c502c53319728702088b06de8a9cb6953a7aa/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3c502c53319728702088b06de8a9cb6953a7aa/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=4e3c502c53319728702088b06de8a9cb6953a7aa", "patch": "@@ -3,7 +3,7 @@ use rustc::ty::{self, Ty};\n use syntax::codemap::Span;\n \n use interpret::{EvalResult, EvalContext, StackPopCleanup, Lvalue, LvalueExtra, PrimVal, Value,\n-                Machine};\n+                Machine, ValTy};\n \n impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub(crate) fn drop_lvalue(\n@@ -79,6 +79,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         let arg_local = arg_locals.next().unwrap();\n         let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n         let arg_ty = self.tcx.mk_mut_ptr(ty);\n-        self.write_value(arg, dest, arg_ty)\n+        let valty = ValTy {\n+            value: arg,\n+            ty: arg_ty,\n+        };\n+        self.write_value(valty, dest)\n     }\n }"}, {"sha": "b2f19fe8bcdb11cf4aca871a8741d6453fcf5da6", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 40, "deletions": 54, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/4e3c502c53319728702088b06de8a9cb6953a7aa/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3c502c53319728702088b06de8a9cb6953a7aa/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=4e3c502c53319728702088b06de8a9cb6953a7aa", "patch": "@@ -5,7 +5,7 @@ use syntax::codemap::Span;\n use syntax::abi::Abi;\n \n use super::{EvalError, EvalResult, EvalErrorKind, EvalContext, eval_context, TyAndPacked,\n-            PtrAndAlign, Lvalue, MemoryPointer, PrimVal, Value, Machine, HasMemory};\n+            PtrAndAlign, Lvalue, MemoryPointer, PrimVal, Value, Machine, HasMemory, ValTy};\n use super::eval_context::IntegerExt;\n \n use rustc_data_structures::indexed_vec::Idx;\n@@ -39,8 +39,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             } => {\n                 // FIXME(CTFE): forbid branching\n                 let discr_val = self.eval_operand(discr)?;\n-                let discr_ty = self.operand_ty(discr);\n-                let discr_prim = self.value_to_primval(discr_val, discr_ty)?;\n+                let discr_prim = self.value_to_primval(discr_val)?;\n \n                 // Branch to the `otherwise` case by default, if no match is found.\n                 let mut target_block = targets[targets.len() - 1];\n@@ -97,11 +96,12 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         return err!(Unimplemented(msg));\n                     }\n                 };\n+                let args = self.operands_to_args(args)?;\n                 let sig = self.erase_lifetimes(&sig);\n                 self.eval_fn_call(\n                     fn_def,\n                     destination,\n-                    args,\n+                    &args,\n                     terminator.source_info.span,\n                     sig,\n                 )?;\n@@ -236,7 +236,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         destination: Option<(Lvalue, mir::BasicBlock)>,\n-        arg_operands: &[mir::Operand<'tcx>],\n+        args: &[ValTy<'tcx>],\n         span: Span,\n         sig: ty::FnSig<'tcx>,\n     ) -> EvalResult<'tcx> {\n@@ -252,28 +252,22 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     return err!(Unreachable);\n                 }\n                 let layout = self.type_layout(ty)?;\n-                M::call_intrinsic(self, instance, arg_operands, ret, ty, layout, target)?;\n+                M::call_intrinsic(self, instance, args, ret, ty, layout, target)?;\n                 self.dump_local(ret);\n                 Ok(())\n             }\n             // FIXME: figure out why we can't just go through the shim\n             ty::InstanceDef::ClosureOnceShim { .. } => {\n-                let mut args = Vec::new();\n-                for arg in arg_operands {\n-                    let arg_val = self.eval_operand(arg)?;\n-                    let arg_ty = self.operand_ty(arg);\n-                    args.push((arg_val, arg_ty));\n-                }\n-                if M::eval_fn_call(self, instance, destination, arg_operands, span, sig)? {\n+                if M::eval_fn_call(self, instance, destination, args, span, sig)? {\n                     return Ok(());\n                 }\n                 let mut arg_locals = self.frame().mir.args_iter();\n                 match sig.abi {\n                     // closure as closure once\n                     Abi::RustCall => {\n-                        for (arg_local, (arg_val, arg_ty)) in arg_locals.zip(args) {\n+                        for (arg_local, &valty) in arg_locals.zip(args) {\n                             let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n-                            self.write_value(arg_val, dest, arg_ty)?;\n+                            self.write_value(valty, dest)?;\n                         }\n                     }\n                     // non capture closure as fn ptr\n@@ -284,14 +278,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                             \"arg_locals: {:?}\",\n                             self.frame().mir.args_iter().collect::<Vec<_>>()\n                         );\n-                        trace!(\"arg_operands: {:?}\", arg_operands);\n+                        trace!(\"args: {:?}\", args);\n                         let local = arg_locals.nth(1).unwrap();\n-                        for (i, (arg_val, arg_ty)) in args.into_iter().enumerate() {\n+                        for (i, &valty) in args.into_iter().enumerate() {\n                             let dest = self.eval_lvalue(&mir::Lvalue::Local(local).field(\n                                 mir::Field::new(i),\n-                                arg_ty,\n+                                valty.ty,\n                             ))?;\n-                            self.write_value(arg_val, dest, arg_ty)?;\n+                            self.write_value(valty, dest)?;\n                         }\n                     }\n                     _ => bug!(\"bad ABI for ClosureOnceShim: {:?}\", sig.abi),\n@@ -302,15 +296,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             ty::InstanceDef::DropGlue(..) |\n             ty::InstanceDef::CloneShim(..) |\n             ty::InstanceDef::Item(_) => {\n-                let mut args = Vec::new();\n-                for arg in arg_operands {\n-                    let arg_val = self.eval_operand(arg)?;\n-                    let arg_ty = self.operand_ty(arg);\n-                    args.push((arg_val, arg_ty));\n-                }\n-\n                 // Push the stack frame, and potentially be entirely done if the call got hooked\n-                if M::eval_fn_call(self, instance, destination, arg_operands, span, sig)? {\n+                if M::eval_fn_call(self, instance, destination, args, span, sig)? {\n                     return Ok(());\n                 }\n \n@@ -321,7 +308,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     \"arg_locals: {:?}\",\n                     self.frame().mir.args_iter().collect::<Vec<_>>()\n                 );\n-                trace!(\"arg_operands: {:?}\", arg_operands);\n+                trace!(\"args: {:?}\", args);\n                 match sig.abi {\n                     Abi::RustCall => {\n                         assert_eq!(args.len(), 2);\n@@ -330,20 +317,18 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                             // write first argument\n                             let first_local = arg_locals.next().unwrap();\n                             let dest = self.eval_lvalue(&mir::Lvalue::Local(first_local))?;\n-                            let (arg_val, arg_ty) = args.remove(0);\n-                            self.write_value(arg_val, dest, arg_ty)?;\n+                            self.write_value(args[0], dest)?;\n                         }\n \n                         // unpack and write all other args\n-                        let (arg_val, arg_ty) = args.remove(0);\n-                        let layout = self.type_layout(arg_ty)?;\n+                        let layout = self.type_layout(args[1].ty)?;\n                         if let (&ty::TyTuple(fields, _),\n-                                &Layout::Univariant { ref variant, .. }) = (&arg_ty.sty, layout)\n+                                &Layout::Univariant { ref variant, .. }) = (&args[1].ty.sty, layout)\n                         {\n                             trace!(\"fields: {:?}\", fields);\n                             if self.frame().mir.args_iter().count() == fields.len() + 1 {\n                                 let offsets = variant.offsets.iter().map(|s| s.bytes());\n-                                match arg_val {\n+                                match args[1].value {\n                                     Value::ByRef(PtrAndAlign { ptr, aligned }) => {\n                                         assert!(\n                                             aligned,\n@@ -361,7 +346,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                                                 dest,\n                                                 ty\n                                             );\n-                                            self.write_value(arg, dest, ty)?;\n+                                            let valty = ValTy {\n+                                                value: arg,\n+                                                ty,\n+                                            };\n+                                            self.write_value(valty, dest)?;\n                                         }\n                                     }\n                                     Value::ByVal(PrimVal::Undef) => {}\n@@ -370,7 +359,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                                         let dest = self.eval_lvalue(&mir::Lvalue::Local(\n                                             arg_locals.next().unwrap(),\n                                         ))?;\n-                                        self.write_value(other, dest, fields[0])?;\n+                                        let valty = ValTy {\n+                                            value: other,\n+                                            ty: fields[0],\n+                                        };\n+                                        self.write_value(valty, dest)?;\n                                     }\n                                 }\n                             } else {\n@@ -379,20 +372,20 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                                 let dest = self.eval_lvalue(\n                                     &mir::Lvalue::Local(arg_locals.next().unwrap()),\n                                 )?;\n-                                self.write_value(arg_val, dest, arg_ty)?;\n+                                self.write_value(args[1], dest)?;\n                             }\n                         } else {\n                             bug!(\n-                                \"rust-call ABI tuple argument was {:?}, {:?}\",\n-                                arg_ty,\n+                                \"rust-call ABI tuple argument was {:#?}, {:#?}\",\n+                                args[1].ty,\n                                 layout\n                             );\n                         }\n                     }\n                     _ => {\n-                        for (arg_local, (arg_val, arg_ty)) in arg_locals.zip(args) {\n+                        for (arg_local, &valty) in arg_locals.zip(args) {\n                             let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n-                            self.write_value(arg_val, dest, arg_ty)?;\n+                            self.write_value(valty, dest)?;\n                         }\n                     }\n                 }\n@@ -401,24 +394,17 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             // cannot use the shim here, because that will only result in infinite recursion\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let ptr_size = self.memory.pointer_size();\n-                let (_, vtable) = self.eval_operand(&arg_operands[0])?.into_ptr_vtable_pair(\n-                    &self.memory,\n-                )?;\n+                let (ptr, vtable) = args[0].into_ptr_vtable_pair(&self.memory)?;\n                 let fn_ptr = self.memory.read_ptr(\n                     vtable.offset(ptr_size * (idx as u64 + 3), &self)?,\n                 )?;\n                 let instance = self.memory.get_fn(fn_ptr.to_ptr()?)?;\n-                let mut arg_operands = arg_operands.to_vec();\n-                let ty = self.operand_ty(&arg_operands[0]);\n-                let ty = self.get_field_ty(ty, 0)?.ty; // TODO: packed flag is ignored\n-                match arg_operands[0] {\n-                    mir::Operand::Consume(ref mut lval) => {\n-                        *lval = lval.clone().field(mir::Field::new(0), ty)\n-                    }\n-                    _ => bug!(\"virtual call first arg cannot be a constant\"),\n-                }\n+                let mut args = args.to_vec();\n+                let ty = self.get_field_ty(args[0].ty, 0)?.ty; // TODO: packed flag is ignored\n+                args[0].ty = ty;\n+                args[0].value = ptr.to_value();\n                 // recurse with concrete function\n-                self.eval_fn_call(instance, destination, &arg_operands, span, sig)\n+                self.eval_fn_call(instance, destination, &args, span, sig)\n             }\n         }\n     }"}]}