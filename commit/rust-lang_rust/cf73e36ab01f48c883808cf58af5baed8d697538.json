{"sha": "cf73e36ab01f48c883808cf58af5baed8d697538", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmNzNlMzZhYjAxZjQ4Yzg4MzgwOGNmNThhZjViYWVkOGQ2OTc1Mzg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-18T15:39:39Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-24T21:27:23Z"}, "message": "Rework trait-bound-conversion so be based on the AST and rework collect\nto pass in the appropriate ast::generics etc", "tree": {"sha": "df572dae3d1746c585295696c7af076ad1945e3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df572dae3d1746c585295696c7af076ad1945e3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf73e36ab01f48c883808cf58af5baed8d697538", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf73e36ab01f48c883808cf58af5baed8d697538", "html_url": "https://github.com/rust-lang/rust/commit/cf73e36ab01f48c883808cf58af5baed8d697538", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf73e36ab01f48c883808cf58af5baed8d697538/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36d04711b774dd97d8341881d26786733a5a6561", "url": "https://api.github.com/repos/rust-lang/rust/commits/36d04711b774dd97d8341881d26786733a5a6561", "html_url": "https://github.com/rust-lang/rust/commit/36d04711b774dd97d8341881d26786733a5a6561"}], "stats": {"total": 818, "additions": 552, "deletions": 266}, "files": [{"sha": "baecfb7eb22c5ec6cb95898ee8ca45f60e93f003", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cf73e36ab01f48c883808cf58af5baed8d697538/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf73e36ab01f48c883808cf58af5baed8d697538/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=cf73e36ab01f48c883808cf58af5baed8d697538", "patch": "@@ -835,6 +835,22 @@ fn parse_type_param_def_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F)\n     }\n }\n \n+fn parse_object_lifetime_default<'a,'tcx, F>(st: &mut PState<'a,'tcx>,\n+                                             conv: &mut F)\n+                                             -> Option<ty::ObjectLifetimeDefault>\n+    where F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n+    match next(st) {\n+        'n' => None,\n+        'a' => Some(ty::ObjectLifetimeDefault::Ambiguous),\n+        's' => {\n+            let region = parse_region_(st, conv);\n+            Some(ty::ObjectLifetimeDefault::Specific(region))\n+        }\n+        _ => panic!(\"parse_object_lifetime_default: bad input\")\n+    }\n+}\n+\n fn parse_existential_bounds<'a,'tcx, F>(st: &mut PState<'a,'tcx>,\n                                         mut conv: F)\n                                         -> ty::ExistentialBounds<'tcx> where"}, {"sha": "2899d8868cca002209f82b551f1137e1bfc122b0", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 334, "deletions": 256, "changes": 590, "blob_url": "https://github.com/rust-lang/rust/blob/cf73e36ab01f48c883808cf58af5baed8d697538/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf73e36ab01f48c883808cf58af5baed8d697538/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=cf73e36ab01f48c883808cf58af5baed8d697538", "patch": "@@ -91,10 +91,9 @@ use constrained_type_params::identify_constrained_type_params;\n use middle::lang_items::SizedTraitLangItem;\n use middle::region;\n use middle::resolve_lifetime;\n-use middle::subst;\n-use middle::subst::{Substs, SelfSpace, TypeSpace, VecPerParamSpace};\n+use middle::subst::{Substs, FnSpace, ParamSpace, SelfSpace, TypeSpace, VecPerParamSpace};\n use middle::ty::{AsPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n-use middle::ty::{self, RegionEscape, Ty, TypeScheme};\n+use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty, TypeScheme};\n use middle::ty_fold::{self, TypeFolder, TypeFoldable};\n use middle::infer;\n use rscope::*;\n@@ -155,8 +154,12 @@ struct CrateCtxt<'a,'tcx:'a> {\n /// on the trait. Unfortunately, this predicate information is\n /// available in various different forms at various points in the\n /// process. So we can't just store a pointer to e.g. the AST or the\n-/// parsed ty form, we have to wind up keeping both (and making both\n-/// optional) and extracting what we need from what's available.\n+/// parsed ty form, we have to be more flexible. To this end, the\n+/// `ItemCtxt` is parameterized by a `GetTypeParameterBounds` object\n+/// that it uses to satisfy `get_type_parameter_bounds` requests.\n+/// This object might draw the information from the AST\n+/// (`ast::Generics`) or it might draw from a `ty::GenericPredicates`\n+/// or both (a tuple).\n struct ItemCtxt<'a,'tcx:'a> {\n     ccx: &'a CrateCtxt<'a,'tcx>,\n     param_bounds: &'a (GetTypeParameterBounds<'tcx>+'a),\n@@ -377,15 +380,48 @@ impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n     }\n }\n \n-\n+/// Interface used to find the bounds on a type parameter from within\n+/// an `ItemCtxt`. This allows us to use multiple kinds of sources.\n trait GetTypeParameterBounds<'tcx> {\n     fn get_type_parameter_bounds(&self,\n                                  astconv: &AstConv<'tcx>,\n                                  span: Span,\n                                  node_id: ast::NodeId)\n                                  -> Vec<ty::PolyTraitRef<'tcx>>;\n }\n-impl<'tcx> GetTypeParameterBounds<'tcx> for ty::Generics<'tcx> {\n+\n+/// Find bounds from both elements of the tuple.\n+impl<'a,'b,'tcx,A,B> GetTypeParameterBounds<'tcx> for (&'a A,&'b B)\n+    where A : GetTypeParameterBounds<'tcx>, B : GetTypeParameterBounds<'tcx>\n+{\n+    fn get_type_parameter_bounds(&self,\n+                                 astconv: &AstConv<'tcx>,\n+                                 span: Span,\n+                                 node_id: ast::NodeId)\n+                                 -> Vec<ty::PolyTraitRef<'tcx>>\n+    {\n+        let mut v = self.0.get_type_parameter_bounds(astconv, span, node_id);\n+        v.extend(self.1.get_type_parameter_bounds(astconv, span, node_id).into_iter());\n+        v\n+    }\n+}\n+\n+/// Empty set of bounds.\n+impl<'tcx> GetTypeParameterBounds<'tcx> for () {\n+    fn get_type_parameter_bounds(&self,\n+                                 _astconv: &AstConv<'tcx>,\n+                                 _span: Span,\n+                                 _node_id: ast::NodeId)\n+                                 -> Vec<ty::PolyTraitRef<'tcx>>\n+    {\n+        Vec::new()\n+    }\n+}\n+\n+/// Find bounds from the parsed and converted predicates.  This is\n+/// used when converting methods, because by that time the predicates\n+/// from the trait/impl have been fully converted.\n+impl<'tcx> GetTypeParameterBounds<'tcx> for ty::GenericPredicates<'tcx> {\n     fn get_type_parameter_bounds(&self,\n                                  astconv: &AstConv<'tcx>,\n                                  _span: Span,\n@@ -394,12 +430,88 @@ impl<'tcx> GetTypeParameterBounds<'tcx> for ty::Generics<'tcx> {\n     {\n         let def = astconv.tcx().type_parameter_def(node_id);\n \n-        // TODO out of range indices can occur when you have something\n-        // like fn foo<T:U::X,U>() { }\n-        match self.types.opt_get(def.space, def.index as usize) {\n-            Some(def) => def.bounds.trait_bounds.clone(),\n-            None => Vec::new(),\n+        self.predicates\n+            .iter()\n+            .filter_map(|predicate| {\n+                match *predicate {\n+                    ty::Predicate::Trait(ref data) => {\n+                        if data.0.self_ty().is_param(def.space, def.index) {\n+                            Some(data.to_poly_trait_ref())\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    ty::Predicate::Equate(..) |\n+                    ty::Predicate::RegionOutlives(..) |\n+                    ty::Predicate::TypeOutlives(..) |\n+                    ty::Predicate::Projection(..) => {\n+                        None\n+                    }\n+                }\n+            })\n+            .collect()\n+    }\n+}\n+\n+/// Find bounds from ast::Generics. This requires scanning through the\n+/// AST. We do this to avoid having to convert *all* the bounds, which\n+/// would create artificial cycles. Instead we can only convert the\n+/// bounds for those a type parameter `X` if `X::Foo` is used.\n+impl<'tcx> GetTypeParameterBounds<'tcx> for ast::Generics {\n+    fn get_type_parameter_bounds(&self,\n+                                 astconv: &AstConv<'tcx>,\n+                                 _: Span,\n+                                 node_id: ast::NodeId)\n+                                 -> Vec<ty::PolyTraitRef<'tcx>>\n+    {\n+        // In the AST, bounds can derive from two places. Either\n+        // written inline like `<T:Foo>` or in a where clause like\n+        // `where T:Foo`.\n+\n+        let def = astconv.tcx().type_parameter_def(node_id);\n+        let ty = ty::mk_param_from_def(astconv.tcx(), &def);\n+\n+        let from_ty_params =\n+            self.ty_params\n+                .iter()\n+                .filter(|p| p.id == node_id)\n+                .flat_map(|p| p.bounds.iter())\n+                .filter_map(|b| poly_trait_ref_from_bound(astconv, ty, b, &mut Vec::new()));\n+\n+        let from_where_clauses =\n+            self.where_clause\n+                .predicates\n+                .iter()\n+                .filter_map(|wp| match *wp {\n+                    ast::WherePredicate::BoundPredicate(ref bp) => Some(bp),\n+                    _ => None\n+                })\n+                .filter(|bp| is_param(astconv.tcx(), &bp.bounded_ty, node_id))\n+                .flat_map(|bp| bp.bounds.iter())\n+                .filter_map(|b| poly_trait_ref_from_bound(astconv, ty, b, &mut Vec::new()));\n+\n+        from_ty_params.chain(from_where_clauses).collect()\n+    }\n+}\n+\n+/// Tests whether this is the AST for a reference to the type\n+/// parameter with id `param_id`. We use this so as to avoid running\n+/// `ast_ty_to_ty`, because we want to avoid triggering an all-out\n+/// conversion of the type to avoid inducing unnecessary cycles.\n+fn is_param<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                  ast_ty: &ast::Ty,\n+                  param_id: ast::NodeId)\n+                  -> bool\n+{\n+    if let ast::TyPath(None, _) = ast_ty.node {\n+        let path_res = ccx.tcx.def_map.borrow()[ast_ty.id];\n+        if let def::DefTyParam(_, _, def_id, _) = path_res.base_def {\n+            path_res.depth == 0 && def_id == local_def(param_id)\n+        } else {\n+            false\n         }\n+    } else {\n+        false\n     }\n }\n \n@@ -408,7 +520,7 @@ fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     enum_predicates: ty::GenericPredicates<'tcx>,\n                                     variants: &[P<ast::Variant>]) {\n     let tcx = ccx.tcx;\n-    let icx = ccx.icx(&enum_scheme.generics);\n+    let icx = ccx.icx(&enum_predicates);\n \n     // Create a set of parameter types shared among all the variants.\n     for variant in variants {\n@@ -571,19 +683,14 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                            -> ty::Method<'tcx>\n     {\n         let ty_generics =\n-            ty_generics_for_fn_or_method(ccx,\n-                                         m_generics,\n-                                         trait_generics.clone());\n+            ty_generics_for_fn(ccx, m_generics, trait_generics);\n \n-        let ty_bounds =\n-            ty_generic_bounds_for_fn_or_method(ccx,\n-                                               m_generics,\n-                                               &ty_generics,\n-                                               trait_bounds.clone());\n+        let ty_generic_predicates =\n+            ty_generic_predicates_for_fn(ccx, m_generics, trait_bounds);\n \n         let (fty, explicit_self_category) = {\n             let trait_self_ty = ty::mk_self_type(ccx.tcx);\n-            astconv::ty_of_method(&ccx.icx(&ty_generics),\n+            astconv::ty_of_method(&ccx.icx(&(trait_bounds, m_generics)),\n                                   *m_unsafety,\n                                   trait_self_ty,\n                                   m_explicit_self,\n@@ -594,7 +701,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         ty::Method::new(\n             *m_name,\n             ty_generics,\n-            ty_bounds,\n+            ty_generic_predicates,\n             fty,\n             explicit_self_category,\n             // assume public, because this is only invoked on trait methods\n@@ -613,7 +720,7 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            origin: ast::DefId)\n                            -> ty::field_ty\n {\n-    let tt = ccx.icx(struct_generics).to_ty(&ExplicitRscope, &*v.node.ty);\n+    let tt = ccx.icx(struct_predicates).to_ty(&ExplicitRscope, &*v.node.ty);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n \n     /* add the field to the tcache */\n@@ -668,7 +775,8 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n                                  rcvr_ty_generics: &ty::Generics<'tcx>,\n                                  rcvr_ty_predicates: &ty::GenericPredicates<'tcx>,\n                                  rcvr_visibility: ast::Visibility)\n-                                 where I: Iterator<Item=&'i ast::Method> {\n+                                 where I: Iterator<Item=&'i ast::Method>\n+{\n     debug!(\"convert_methods(untransformed_rcvr_ty={}, rcvr_ty_generics={})\",\n            untransformed_rcvr_ty.repr(ccx.tcx),\n            rcvr_ty_generics.repr(ccx.tcx));\n@@ -719,24 +827,21 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n                               rcvr_ty_generics: &ty::Generics<'tcx>,\n                               rcvr_ty_predicates: &ty::GenericPredicates<'tcx>,\n                               rcvr_visibility: ast::Visibility)\n-                              -> ty::Method<'tcx> {\n+                              -> ty::Method<'tcx>\n+    {\n         let m_ty_generics =\n-            ty_generics_for_fn_or_method(ccx,\n-                                         m.pe_generics(),\n-                                         rcvr_ty_generics.clone());\n-\n-        let m_ty_bounds =\n-            ty_generic_bounds_for_fn_or_method(ccx,\n-                                               m.pe_generics(),\n-                                               &m_ty_generics,\n-                                               rcvr_ty_predicates.clone());\n-\n-        let (fty, explicit_self_category) = astconv::ty_of_method(&ccx.icx(&m_ty_generics),\n-                                                                  m.pe_unsafety(),\n-                                                                  untransformed_rcvr_ty,\n-                                                                  m.pe_explicit_self(),\n-                                                                  &*m.pe_fn_decl(),\n-                                                                  m.pe_abi());\n+            ty_generics_for_fn(ccx, m.pe_generics(), rcvr_ty_generics);\n+\n+        let m_ty_generic_predicates =\n+            ty_generic_predicates_for_fn(ccx, m.pe_generics(), rcvr_ty_predicates);\n+\n+        let (fty, explicit_self_category) =\n+            astconv::ty_of_method(&ccx.icx(&(rcvr_ty_predicates, m.pe_generics())),\n+                                  m.pe_unsafety(),\n+                                  untransformed_rcvr_ty,\n+                                  m.pe_explicit_self(),\n+                                  &*m.pe_fn_decl(),\n+                                  m.pe_abi());\n \n         // if the method specifies a visibility, use that, otherwise\n         // inherit the visibility from the impl (so `foo` in `pub impl\n@@ -746,7 +851,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n \n         ty::Method::new(m.pe_ident().name,\n                         m_ty_generics,\n-                        m_ty_bounds,\n+                        m_ty_generic_predicates,\n                         fty,\n                         explicit_self_category,\n                         method_vis,\n@@ -820,11 +925,11 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n \n             debug!(\"convert: ast_generics={:?}\", generics);\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n-            let ty_predicates = ty_generic_bounds_for_type_or_impl(ccx, &ty_generics, generics);\n+            let ty_predicates = ty_generic_predicates_for_type_or_impl(ccx, generics);\n \n             debug!(\"convert: impl_bounds={:?}\", ty_predicates);\n \n-            let selfty = ccx.icx(&ty_generics).to_ty(&ExplicitRscope, &**selfty);\n+            let selfty = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, &**selfty);\n             write_ty_to_tcx(tcx, it.id, selfty);\n \n             tcx.tcache.borrow_mut().insert(local_def(it.id),\n@@ -856,7 +961,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                                               \"associated items are not allowed in inherent impls\");\n                         }\n \n-                        let typ = ccx.icx(&ty_generics).to_ty(&ExplicitRscope, &*typedef.typ);\n+                        let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, &*typedef.typ);\n                         tcx.tcache.borrow_mut().insert(local_def(typedef.id),\n                                                        TypeScheme {\n                                                            generics: ty::Generics::empty(),\n@@ -904,7 +1009,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n             }\n \n             if let Some(ref trait_ref) = *opt_trait_ref {\n-                astconv::instantiate_trait_ref(&ccx.icx(&ty_generics),\n+                astconv::instantiate_trait_ref(&ccx.icx(&ty_predicates),\n                                                &ExplicitRscope,\n                                                trait_ref,\n                                                Some(it.id),\n@@ -1124,8 +1229,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let self_param_ty = ty::ParamTy::for_self().to_ty(ccx.tcx);\n \n     // supertraits:\n-    let bounds = compute_bounds(ccx,\n-                                &ty_generics,\n+    let bounds = compute_bounds(&ccx.icx(generics),\n                                 self_param_ty,\n                                 bounds,\n                                 SizedByDefault::No,\n@@ -1161,7 +1265,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     fn mk_trait_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                  generics: &ast::Generics)\n-                                 -> subst::Substs<'tcx>\n+                                 -> Substs<'tcx>\n     {\n         let tcx = ccx.tcx;\n \n@@ -1171,7 +1275,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     .iter()\n                     .enumerate()\n                     .map(|(i, def)| ty::ReEarlyBound(def.lifetime.id,\n-                                                     subst::TypeSpace,\n+                                                     TypeSpace,\n                                                      i as u32,\n                                                      def.lifetime.name))\n                     .collect();\n@@ -1181,14 +1285,14 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             generics.ty_params\n                     .iter()\n                     .enumerate()\n-                    .map(|(i, def)| ty::mk_param(tcx, subst::TypeSpace,\n+                    .map(|(i, def)| ty::mk_param(tcx, TypeSpace,\n                                                  i as u32, def.ident.name))\n                     .collect();\n \n         // ...and also create the `Self` parameter.\n         let self_ty = ty::mk_self_type(tcx);\n \n-        subst::Substs::new_trait(types, regions, self_ty)\n+        Substs::new_trait(types, regions, self_ty)\n     }\n }\n \n@@ -1211,10 +1315,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n \n     let super_predicates = ty::predicates(ccx.tcx, self_param_ty, &trait_def.bounds);\n \n-    let assoc_predicates = predicates_for_associated_types(ccx, &trait_def.generics,\n-                                                           &trait_def.trait_ref, items);\n-\n-    // `ty_generic_bounds` below will consider the bounds on the type\n+    // `ty_generic_predicates` below will consider the bounds on the type\n     // parameters (including `Self`) and the explicit where-clauses,\n     // but to get the full set of predicates on a trait we need to add\n     // in the supertrait bounds and anything declared on the\n@@ -1223,28 +1324,31 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n         ty::GenericPredicates {\n             predicates: VecPerParamSpace::new(super_predicates, vec![], vec![])\n         };\n-    base_predicates.predicates.extend(subst::TypeSpace, assoc_predicates.into_iter());\n \n     // Add in a predicate that `Self:Trait` (where `Trait` is the\n     // current trait).  This is needed for builtin bounds.\n     let self_predicate = trait_def.trait_ref.to_poly_trait_ref().as_predicate();\n     base_predicates.predicates.push(SelfSpace, self_predicate);\n \n     // add in the explicit where-clauses\n-    let trait_predicates =\n-        ty_generic_bounds(ccx,\n-                          subst::TypeSpace,\n-                          &trait_def.generics,\n-                          base_predicates,\n-                          &generics.where_clause);\n+    let mut trait_predicates =\n+        ty_generic_predicates(ccx, TypeSpace, generics, &base_predicates);\n+\n+    let assoc_predicates = predicates_for_associated_types(ccx,\n+                                                           generics,\n+                                                           &trait_predicates,\n+                                                           &trait_def.trait_ref,\n+                                                           items);\n+    trait_predicates.predicates.extend(TypeSpace, assoc_predicates.into_iter());\n \n     let prev_predicates = tcx.predicates.borrow_mut().insert(def_id, trait_predicates);\n     assert!(prev_predicates.is_none());\n \n     return;\n \n     fn predicates_for_associated_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                                 generics: &ty::Generics<'tcx>,\n+                                                 ast_generics: &ast::Generics,\n+                                                 trait_predicates: &ty::GenericPredicates<'tcx>,\n                                                  self_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n                                                  trait_items: &[ast::TraitItem])\n                                                  -> Vec<ty::Predicate<'tcx>>\n@@ -1263,8 +1367,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n                                                  self_trait_ref.clone(),\n                                                  assoc_type_def.ident.name);\n \n-                let bounds = compute_bounds(ccx,\n-                                            generics,\n+                let bounds = compute_bounds(&ccx.icx(&(ast_generics, trait_predicates)),\n                                             assoc_ty,\n                                             &*assoc_type_def.bounds,\n                                             SizedByDefault::Yes,\n@@ -1309,28 +1412,25 @@ fn type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n              |_| compute_type_scheme_of_item(ccx, it))\n }\n \n-\n fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                         it: &ast::Item)\n                                         -> ty::TypeScheme<'tcx>\n {\n     let tcx = ccx.tcx;\n     match it.node {\n         ast::ItemStatic(ref t, _, _) | ast::ItemConst(ref t, _) => {\n-            let ty = ccx.icx(&ty::Generics::empty()).to_ty(&ExplicitRscope, &**t);\n+            let ty = ccx.icx(&()).to_ty(&ExplicitRscope, &**t);\n             ty::TypeScheme { ty: ty, generics: ty::Generics::empty() }\n         }\n         ast::ItemFn(ref decl, unsafety, abi, ref generics, _) => {\n-            let ty_generics = ty_generics_for_fn_or_method(ccx,\n-                                                           generics,\n-                                                           ty::Generics::empty());\n-            let tofd = astconv::ty_of_bare_fn(&ccx.icx(&ty_generics), unsafety, abi, &**decl);\n+            let ty_generics = ty_generics_for_fn(ccx, generics, &ty::Generics::empty());\n+            let tofd = astconv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &**decl);\n             let ty = ty::mk_bare_fn(tcx, Some(local_def(it.id)), tcx.mk_bare_fn(tofd));\n             ty::TypeScheme { ty: ty, generics: ty_generics }\n         }\n         ast::ItemTy(ref t, ref generics) => {\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n-            let ty = ccx.icx(&ty_generics).to_ty(&ExplicitRscope, &**t);\n+            let ty = ccx.icx(generics).to_ty(&ExplicitRscope, &**t);\n             ty::TypeScheme { ty: ty, generics: ty_generics }\n         }\n         ast::ItemEnum(_, ref generics) => {\n@@ -1375,19 +1475,16 @@ fn convert_typed_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             ty::GenericPredicates::empty()\n         }\n         ast::ItemFn(_, _, _, ref ast_generics, _) => {\n-            ty_generic_bounds_for_fn_or_method(ccx,\n-                                               ast_generics,\n-                                               &scheme.generics,\n-                                               ty::GenericPredicates::empty())\n+            ty_generic_predicates_for_fn(ccx, ast_generics, &ty::GenericPredicates::empty())\n         }\n         ast::ItemTy(_, ref generics) => {\n-            ty_generic_bounds_for_type_or_impl(ccx, &scheme.generics, generics)\n+            ty_generic_predicates_for_type_or_impl(ccx, generics)\n         }\n         ast::ItemEnum(_, ref generics) => {\n-            ty_generic_bounds_for_type_or_impl(ccx, &scheme.generics, generics)\n+            ty_generic_predicates_for_type_or_impl(ccx, generics)\n         }\n         ast::ItemStruct(_, ref generics) => {\n-            ty_generic_bounds_for_type_or_impl(ccx, &scheme.generics, generics)\n+            ty_generic_predicates_for_type_or_impl(ccx, generics)\n         }\n         ast::ItemDefaultImpl(..) |\n         ast::ItemTrait(..) |\n@@ -1399,8 +1496,8 @@ fn convert_typed_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         ast::ItemMac(..) => {\n             tcx.sess.span_bug(\n                 it.span,\n-                format!(\"compute_type_scheme_of_item: unexpected item type: {:?}\",\n-                        it.node).as_slice());\n+                &format!(\"compute_type_scheme_of_item: unexpected item type: {:?}\",\n+                         it.node));\n         }\n     };\n \n@@ -1416,7 +1513,7 @@ fn convert_typed_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                      Some(ty::ObjectLifetimeDefault::Specific(r)) =>\n                                          r.user_string(tcx),\n                                      d =>\n-                                         d.repr(ccx.tcx()),\n+                                         d.repr(ccx.tcx),\n                                  })\n                                  .collect::<Vec<String>>()\n                                  .connect(\",\");\n@@ -1451,7 +1548,7 @@ fn compute_type_scheme_of_foreign_item<'a, 'tcx>(\n         ast::ForeignItemStatic(ref t, _) => {\n             ty::TypeScheme {\n                 generics: ty::Generics::empty(),\n-                ty: ast_ty_to_ty(&ccx.icx(&ty::Generics::empty()), &ExplicitRscope, t)\n+                ty: ast_ty_to_ty(&ccx.icx(&()), &ExplicitRscope, t)\n             }\n         }\n     }\n@@ -1472,10 +1569,7 @@ fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let predicates = match it.node {\n         ast::ForeignItemFn(_, ref generics) => {\n-            ty_generic_bounds_for_fn_or_method(ccx,\n-                                               generics,\n-                                               &scheme.generics,\n-                                               ty::GenericPredicates::empty())\n+            ty_generic_predicates_for_fn(ccx, generics, &ty::GenericPredicates::empty())\n         }\n         ast::ForeignItemStatic(..) => {\n             ty::GenericPredicates::empty()\n@@ -1489,42 +1583,26 @@ fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n fn ty_generics_for_type_or_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                           generics: &ast::Generics)\n                                           -> ty::Generics<'tcx> {\n-    ty_generics(ccx,\n-                subst::TypeSpace,\n-                &generics.lifetimes,\n-                &generics.ty_params,\n-                &generics.where_clause,\n-                ty::Generics::empty())\n+    ty_generics(ccx, TypeSpace, generics, &ty::Generics::empty())\n }\n \n-fn ty_generic_bounds_for_type_or_impl<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                               ty_generics: &ty::Generics<'tcx>,\n-                                               generics: &ast::Generics)\n-                                               -> ty::GenericPredicates<'tcx>\n+fn ty_generic_predicates_for_type_or_impl<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                                                   generics: &ast::Generics)\n+                                                   -> ty::GenericPredicates<'tcx>\n {\n-    ty_generic_bounds(ccx,\n-                      subst::TypeSpace,\n-                      ty_generics,\n-                      ty::GenericPredicates::empty(),\n-                      &generics.where_clause)\n+    ty_generic_predicates(ccx, TypeSpace, generics, &ty::GenericPredicates::empty())\n }\n \n fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    trait_id: ast::NodeId,\n-                                   substs: &'tcx subst::Substs<'tcx>,\n+                                   substs: &'tcx Substs<'tcx>,\n                                    ast_generics: &ast::Generics)\n                                    -> ty::Generics<'tcx>\n {\n     debug!(\"ty_generics_for_trait(trait_id={}, substs={})\",\n            local_def(trait_id).repr(ccx.tcx), substs.repr(ccx.tcx));\n \n-    let mut generics =\n-        ty_generics(ccx,\n-                    subst::TypeSpace,\n-                    &ast_generics.lifetimes,\n-                    &ast_generics.ty_params,\n-                    &ast_generics.where_clause,\n-                    ty::Generics::empty());\n+    let mut generics = ty_generics_for_type_or_impl(ccx, ast_generics);\n \n     // Add in the self type parameter.\n     //\n@@ -1533,7 +1611,7 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let param_id = trait_id;\n \n     let def = ty::TypeParameterDef {\n-        space: subst::SelfSpace,\n+        space: SelfSpace,\n         index: 0,\n         name: special_idents::type_self.name,\n         def_id: local_def(param_id),\n@@ -1543,44 +1621,35 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     ccx.tcx.ty_param_defs.borrow_mut().insert(param_id, def.clone());\n \n-    generics.types.push(subst::SelfSpace, def);\n+    generics.types.push(SelfSpace, def);\n \n     return generics;\n }\n \n-fn ty_generics_for_fn_or_method<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                         generics: &ast::Generics,\n-                                         base_generics: ty::Generics<'tcx>)\n-                                         -> ty::Generics<'tcx>\n+fn ty_generics_for_fn<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                               generics: &ast::Generics,\n+                               base_generics: &ty::Generics<'tcx>)\n+                               -> ty::Generics<'tcx>\n {\n-    let early_lifetimes = resolve_lifetime::early_bound_lifetimes(generics);\n-    ty_generics(ccx,\n-                subst::FnSpace,\n-                &early_lifetimes[..],\n-                &generics.ty_params,\n-                &generics.where_clause,\n-                base_generics)\n+    ty_generics(ccx, FnSpace, generics, base_generics)\n }\n \n-fn ty_generic_bounds_for_fn_or_method<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                               generics: &ast::Generics,\n-                                               ty_generics: &ty::Generics<'tcx>,\n-                                               base: ty::GenericPredicates<'tcx>)\n-                                               -> ty::GenericPredicates<'tcx>\n+fn ty_generic_predicates_for_fn<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                                         generics: &ast::Generics,\n+                                         base_predicates: &ty::GenericPredicates<'tcx>)\n+                                         -> ty::GenericPredicates<'tcx>\n {\n-    ty_generic_bounds(ccx,\n-                      subst::FnSpace,\n-                      ty_generics,\n-                      base,\n-                      &generics.where_clause)\n+    ty_generic_predicates(ccx, FnSpace, generics, base_predicates)\n }\n \n // Add the Sized bound, unless the type parameter is marked as `?Sized`.\n-fn add_unsized_bound<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                              bounds: &mut ty::BuiltinBounds,\n-                              ast_bounds: &[ast::TyParamBound],\n-                              span: Span)\n+fn add_unsized_bound<'tcx>(astconv: &AstConv<'tcx>,\n+                           bounds: &mut ty::BuiltinBounds,\n+                           ast_bounds: &[ast::TyParamBound],\n+                           span: Span)\n {\n+    let tcx = astconv.tcx();\n+\n     // Try to find an unbound in bounds.\n     let mut unbound = None;\n     for ab in ast_bounds {\n@@ -1589,67 +1658,95 @@ fn add_unsized_bound<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                 assert!(ptr.bound_lifetimes.is_empty());\n                 unbound = Some(ptr.trait_ref.clone());\n             } else {\n-                span_err!(ccx.tcx.sess, span, E0203,\n+                span_err!(tcx.sess, span, E0203,\n                           \"type parameter has more than one relaxed default \\\n                                                 bound, only one is supported\");\n             }\n         }\n     }\n \n-    let kind_id = ccx.tcx.lang_items.require(SizedTraitLangItem);\n+    let kind_id = tcx.lang_items.require(SizedTraitLangItem);\n     match unbound {\n         Some(ref tpb) => {\n             // FIXME(#8559) currently requires the unbound to be built-in.\n-            let trait_def_id = ty::trait_ref_to_def_id(ccx.tcx, tpb);\n+            let trait_def_id = ty::trait_ref_to_def_id(tcx, tpb);\n             match kind_id {\n                 Ok(kind_id) if trait_def_id != kind_id => {\n-                    ccx.tcx.sess.span_warn(span,\n-                                              \"default bound relaxed for a type parameter, but \\\n-                                               this does nothing because the given bound is not \\\n-                                               a default. Only `?Sized` is supported\");\n-                    ty::try_add_builtin_trait(ccx.tcx,\n-                                              kind_id,\n-                                              bounds);\n+                    tcx.sess.span_warn(span,\n+                                       \"default bound relaxed for a type parameter, but \\\n+                                       this does nothing because the given bound is not \\\n+                                       a default. Only `?Sized` is supported\");\n+                    ty::try_add_builtin_trait(tcx, kind_id, bounds);\n                 }\n                 _ => {}\n             }\n         }\n         _ if kind_id.is_ok() => {\n-            ty::try_add_builtin_trait(ccx.tcx, kind_id.unwrap(), bounds);\n+            ty::try_add_builtin_trait(tcx, kind_id.unwrap(), bounds);\n         }\n         // No lang item for Sized, so we can't add it as a bound.\n         None => {}\n     }\n }\n \n-fn ty_generic_bounds<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                              space: subst::ParamSpace,\n-                              generics: &ty::Generics<'tcx>,\n-                              base: ty::GenericPredicates<'tcx>,\n-                              where_clause: &ast::WhereClause)\n-                              -> ty::GenericPredicates<'tcx>\n+/// Returns the early-bound lifetimes declared in this generics\n+/// listing.  For anything other than fns/methods, this is just all\n+/// the lifetimes that are declared. For fns or methods, we have to\n+/// screen out those that do not appear in any where-clauses etc using\n+/// `resolve_lifetime::early_bound_lifetimes`.\n+fn early_bound_lifetimes_from_generics(space: ParamSpace,\n+                                       ast_generics: &ast::Generics)\n+                                       -> Vec<ast::LifetimeDef>\n+{\n+    match space {\n+        SelfSpace | TypeSpace => ast_generics.lifetimes.to_vec(),\n+        FnSpace => resolve_lifetime::early_bound_lifetimes(ast_generics),\n+    }\n+}\n+\n+fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                                  space: ParamSpace,\n+                                  ast_generics: &ast::Generics,\n+                                  base_predicates: &ty::GenericPredicates<'tcx>)\n+                                  -> ty::GenericPredicates<'tcx>\n {\n     let tcx = ccx.tcx;\n-    let mut result = base;\n-\n-    // For now, scrape the bounds out of parameters from Generics. This is not great.\n-    for def in generics.regions.get_slice(space) {\n-        let r_a = def.to_early_bound_region();\n-        for &r_b in &def.bounds {\n-            let outlives = ty::Binder(ty::OutlivesPredicate(r_a, r_b));\n-            result.predicates.push(def.space, ty::Predicate::RegionOutlives(outlives));\n-        }\n+    let mut result = base_predicates.clone();\n+\n+    // Collect the predicates that were written inline by the user on each\n+    // type parameter (e.g., `<T:Foo>`).\n+    for (index, param) in ast_generics.ty_params.iter().enumerate() {\n+        let index = index as u32;\n+        let param_ty = ty::ParamTy::new(space, index, param.ident.name).to_ty(ccx.tcx);\n+        let bounds = compute_bounds(&ccx.icx(&(base_predicates, ast_generics)),\n+                                    param_ty,\n+                                    &param.bounds[],\n+                                    SizedByDefault::Yes,\n+                                    param.span);\n+        let predicates = ty::predicates(ccx.tcx, param_ty, &bounds);\n+        result.predicates.extend(space, predicates.into_iter());\n     }\n-    for def in generics.types.get_slice(space) {\n-        let t = ty::mk_param_from_def(ccx.tcx, def);\n-        result.predicates.extend(def.space, ty::predicates(ccx.tcx, t, &def.bounds).into_iter());\n+\n+    // Collect the region predicates that were declared inline as\n+    // well. In the case of parameters declared on a fn or method, we\n+    // have to be careful to only iterate over early-bound regions.\n+    let early_lifetimes = early_bound_lifetimes_from_generics(space, ast_generics);\n+    for (index, param) in early_lifetimes.iter().enumerate() {\n+        let index = index as u32;\n+        let region = ty::ReEarlyBound(param.lifetime.id, space, index, param.lifetime.name);\n+        for bound in &param.bounds {\n+            let bound_region = ast_region_to_region(ccx.tcx, bound);\n+            let outlives = ty::Binder(ty::OutlivesPredicate(region, bound_region));\n+            result.predicates.push(space, outlives.as_predicate());\n+        }\n     }\n \n-    // Add the bounds not associated with a type parameter\n+    // Add in the bounds that appear in the where-clause\n+    let where_clause = &ast_generics.where_clause;\n     for predicate in &where_clause.predicates {\n         match predicate {\n             &ast::WherePredicate::BoundPredicate(ref bound_pred) => {\n-                let ty = ast_ty_to_ty(&ccx.icx(generics),\n+                let ty = ast_ty_to_ty(&ccx.icx(&(base_predicates, ast_generics)),\n                                       &ExplicitRscope,\n                                       &*bound_pred.bounded_ty);\n \n@@ -1658,10 +1755,11 @@ fn ty_generic_bounds<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                         &ast::TyParamBound::TraitTyParamBound(ref poly_trait_ref, _) => {\n                             let mut projections = Vec::new();\n \n-                            let trait_ref = conv_poly_trait_ref(&ccx.icx(generics),\n-                                                                ty,\n-                                                                poly_trait_ref,\n-                                                                &mut projections);\n+                            let trait_ref =\n+                                conv_poly_trait_ref(&ccx.icx(&(base_predicates, ast_generics)),\n+                                                    ty,\n+                                                    poly_trait_ref,\n+                                                    &mut projections);\n \n                             result.predicates.push(space, trait_ref.as_predicate());\n \n@@ -1701,17 +1799,16 @@ fn ty_generic_bounds<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n }\n \n fn ty_generics<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                        space: subst::ParamSpace,\n-                        lifetime_defs: &[ast::LifetimeDef],\n-                        types: &[ast::TyParam],\n-                        where_clause: &ast::WhereClause,\n-                        base_generics: ty::Generics<'tcx>)\n+                        space: ParamSpace,\n+                        ast_generics: &ast::Generics,\n+                        base_generics: &ty::Generics<'tcx>)\n                         -> ty::Generics<'tcx>\n {\n     let tcx = ccx.tcx;\n-    let mut result = base_generics;\n+    let mut result = base_generics.clone();\n \n-    for (i, l) in lifetime_defs.iter().enumerate() {\n+    let early_lifetimes = early_bound_lifetimes_from_generics(space, ast_generics);\n+    for (i, l) in early_lifetimes.iter().enumerate() {\n         let bounds = l.bounds.iter()\n                              .map(|l| ast_region_to_region(tcx, l))\n                              .collect();\n@@ -1720,16 +1817,14 @@ fn ty_generics<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                            index: i as u32,\n                                            def_id: local_def(l.lifetime.id),\n                                            bounds: bounds };\n-        // debug!(\"ty_generics: def for region param: {:?}\",\n-        //        def.repr(tcx));\n         result.regions.push(space, def);\n     }\n \n     assert!(result.types.is_empty_in(space));\n \n     // Now create the real type parameters.\n-    for (i, param) in types.iter().enumerate() {\n-        let def = get_or_create_type_parameter_def(ccx, &result, space, param, i as u32);\n+    for i in 0..ast_generics.ty_params.len() {\n+        let def = get_or_create_type_parameter_def(ccx, ast_generics, space, i as u32);\n         debug!(\"ty_generics: def for type param: {:?}, {:?}\", def, space);\n         result.types.push(space, def);\n     }\n@@ -1738,13 +1833,13 @@ fn ty_generics<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n }\n \n fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                             generics_so_far: &ty::Generics<'tcx>,\n-                                             space: subst::ParamSpace,\n-                                             param: &ast::TyParam,\n-                                             index: u32,\n-                                             where_clause: &ast::WhereClause)\n+                                             ast_generics: &ast::Generics,\n+                                             space: ParamSpace,\n+                                             index: u32)\n                                              -> ty::TypeParameterDef<'tcx>\n {\n+    let param = &ast_generics.ty_params[index as usize];\n+\n     let tcx = ccx.tcx;\n     match tcx.ty_param_defs.borrow().get(&param.id) {\n         Some(d) => { return d.clone(); }\n@@ -1754,7 +1849,7 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     let default = match param.default {\n         None => None,\n         Some(ref path) => {\n-            let ty = ast_ty_to_ty(&ccx.icx(&ty::Generics::empty()), &ExplicitRscope, &**path);\n+            let ty = ast_ty_to_ty(&ccx.icx(&()), &ExplicitRscope, &**path);\n             let cur_idx = index;\n \n             ty::walk_ty(ty, |t| {\n@@ -1773,7 +1868,8 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     };\n \n     let object_lifetime_default =\n-        compute_object_lifetime_default(ccx, space, index, &param.bounds, where_clause);\n+        compute_object_lifetime_default(ccx, param.id,\n+                                        &param.bounds, &ast_generics.where_clause);\n \n     let def = ty::TypeParameterDef {\n         space: space,\n@@ -1795,15 +1891,14 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n /// intentionally avoid just asking astconv to convert all the where\n /// clauses into a `ty::Predicate`. This is because that could induce\n /// artificial cycles.\n-fn compute_object_lifetime_default<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n-                                            space: subst::ParamSpace,\n-                                            index: u32,\n+fn compute_object_lifetime_default<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                                            param_id: ast::NodeId,\n                                             param_bounds: &[ast::TyParamBound],\n                                             where_clause: &ast::WhereClause)\n                                             -> Option<ty::ObjectLifetimeDefault>\n {\n     let inline_bounds = from_bounds(ccx, param_bounds);\n-    let where_bounds = from_predicates(ccx, space, index, &where_clause.predicates);\n+    let where_bounds = from_predicates(ccx, param_id, &where_clause.predicates);\n     let all_bounds: HashSet<_> = inline_bounds.into_iter()\n                                               .chain(where_bounds.into_iter())\n                                               .collect();\n@@ -1815,7 +1910,7 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                   .map(ty::ObjectLifetimeDefault::Specific)\n     };\n \n-    fn from_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+    fn from_bounds<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                             bounds: &[ast::TyParamBound])\n                             -> Vec<ty::Region>\n     {\n@@ -1825,15 +1920,14 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                       ast::TraitTyParamBound(..) =>\n                           None,\n                       ast::RegionTyParamBound(ref lifetime) =>\n-                          Some(astconv::ast_region_to_region(ccx.tcx(), lifetime)),\n+                          Some(astconv::ast_region_to_region(ccx.tcx, lifetime)),\n                   }\n               })\n               .collect()\n     }\n \n-    fn from_predicates<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n-                                space: subst::ParamSpace,\n-                                index: u32,\n+    fn from_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                                param_id: ast::NodeId,\n                                 predicates: &[ast::WherePredicate])\n                                 -> Vec<ty::Region>\n     {\n@@ -1842,7 +1936,7 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                       match *predicate {\n                           ast::WherePredicate::BoundPredicate(ref data) => {\n                               if data.bound_lifetimes.len() == 0 &&\n-                                  is_param(ccx, &data.bounded_ty, space, index)\n+                                  is_param(ccx.tcx, &data.bounded_ty, param_id)\n                               {\n                                   from_bounds(ccx, &data.bounds).into_iter()\n                               } else {\n@@ -1857,52 +1951,32 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                   })\n                   .collect()\n     }\n-\n-    fn is_param(ccx: &CollectCtxt,\n-                ast_ty: &ast::Ty,\n-                space: subst::ParamSpace,\n-                index: u32)\n-                -> bool\n-    {\n-        if let ast::TyPath(None, _) = ast_ty.node {\n-            let path_res = ccx.tcx.def_map.borrow()[ast_ty.id];\n-            if let def::DefTyParam(s, i, _, _) = path_res.base_def {\n-                path_res.depth == 0 && space == s && index == i\n-            } else {\n-                false\n-            }\n-        } else {\n-            false\n-        }\n-    }\n }\n \n enum SizedByDefault { Yes, No }\n \n /// Translate the AST's notion of ty param bounds (which are an enum consisting of a newtyped Ty or\n /// a region) to ty's notion of ty param bounds, which can either be user-defined traits, or the\n /// built-in trait (formerly known as kind): Send.\n-fn compute_bounds<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                           generics: &ty::Generics<'tcx>,\n-                           param_ty: ty::Ty<'tcx>,\n-                           ast_bounds: &[ast::TyParamBound],\n-                           sized_by_default: SizedByDefault,\n-                           span: Span)\n-                           -> ty::ParamBounds<'tcx>\n+fn compute_bounds<'tcx>(astconv: &AstConv<'tcx>,\n+                        param_ty: ty::Ty<'tcx>,\n+                        ast_bounds: &[ast::TyParamBound],\n+                        sized_by_default: SizedByDefault,\n+                        span: Span)\n+                        -> ty::ParamBounds<'tcx>\n {\n-    let mut param_bounds = conv_param_bounds(ccx,\n-                                             generics,\n+    let mut param_bounds = conv_param_bounds(astconv,\n                                              span,\n                                              param_ty,\n                                              ast_bounds);\n \n     if let SizedByDefault::Yes = sized_by_default {\n-        add_unsized_bound(ccx,\n+        add_unsized_bound(astconv,\n                           &mut param_bounds.builtin_bounds,\n                           ast_bounds,\n                           span);\n \n-        check_bounds_compatible(ccx,\n+        check_bounds_compatible(astconv,\n                                 param_ty,\n                                 &param_bounds,\n                                 span);\n@@ -1913,22 +1987,27 @@ fn compute_bounds<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     param_bounds\n }\n \n-fn check_bounds_compatible<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                    param_ty: Ty<'tcx>,\n-                                    param_bounds: &ty::ParamBounds<'tcx>,\n-                                    span: Span) {\n+fn check_bounds_compatible<'tcx>(astconv: &AstConv<'tcx>,\n+                                 param_ty: Ty<'tcx>,\n+                                 param_bounds: &ty::ParamBounds<'tcx>,\n+                                 span: Span) {\n+    let tcx = astconv.tcx();\n     if !param_bounds.builtin_bounds.contains(&ty::BoundSized) {\n         ty::each_bound_trait_and_supertraits(\n-            ccx.tcx,\n+            tcx,\n             &param_bounds.trait_bounds,\n             |trait_ref| {\n-                let trait_def = get_trait_def(ccx, trait_ref.def_id());\n-                if trait_def.bounds.builtin_bounds.contains(&ty::BoundSized) {\n-                    span_err!(ccx.tcx.sess, span, E0129,\n-                              \"incompatible bounds on `{}`, \\\n-                               bound `{}` does not allow unsized type\",\n-                              param_ty.user_string(ccx.tcx),\n-                              trait_ref.user_string(ccx.tcx));\n+                match astconv.get_trait_def(span, trait_ref.def_id()) {\n+                    Ok(trait_def) => {\n+                        if trait_def.bounds.builtin_bounds.contains(&ty::BoundSized) {\n+                            span_err!(tcx.sess, span, E0129,\n+                                      \"incompatible bounds on `{}`, \\\n+                                        bound `{}` does not allow unsized type\",\n+                                      param_ty.user_string(tcx),\n+                                      trait_ref.user_string(tcx));\n+                        }\n+                    }\n+                    Err(ErrorReported) => { }\n                 }\n                 true\n             });\n@@ -1967,14 +2046,13 @@ fn conv_poly_trait_ref<'tcx>(astconv: &AstConv<'tcx>,\n                                         projections)\n }\n \n-fn conv_param_bounds<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                              generics: &ty::Generics<'tcx>,\n+fn conv_param_bounds<'a,'tcx>(astconv: &AstConv<'tcx>,\n                               span: Span,\n                               param_ty: ty::Ty<'tcx>,\n                               ast_bounds: &[ast::TyParamBound])\n                               -> ty::ParamBounds<'tcx>\n {\n-    let tcx = ccx.tcx;\n+    let tcx = astconv.tcx();\n     let astconv::PartitionedBounds {\n         builtin_bounds,\n         trait_bounds,\n@@ -1984,16 +2062,16 @@ fn conv_param_bounds<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     let mut projection_bounds = Vec::new();\n \n     let trait_bounds: Vec<ty::PolyTraitRef> =\n-        trait_bounds.into_iter()\n-                    .map(|bound| conv_poly_trait_ref(&ccx.icx(generics),\n+        trait_bounds.iter()\n+                    .map(|bound| conv_poly_trait_ref(astconv,\n                                                      param_ty,\n-                                                     bound,\n+                                                     *bound,\n                                                      &mut projection_bounds))\n                     .collect();\n \n     let region_bounds: Vec<ty::Region> =\n         region_bounds.into_iter()\n-                     .map(|r| ast_region_to_region(ccx.tcx, r))\n+                     .map(|r| ast_region_to_region(tcx, r))\n                      .collect();\n \n     ty::ParamBounds {\n@@ -2022,17 +2100,17 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n         }\n     }\n \n-    let ty_generics = ty_generics_for_fn_or_method(ccx, ast_generics, ty::Generics::empty());\n+    let ty_generics = ty_generics_for_fn(ccx, ast_generics, &ty::Generics::empty());\n \n     let rb = BindingRscope::new();\n     let input_tys = decl.inputs\n                         .iter()\n-                        .map(|a| ty_of_arg(&ccx.icx(&ty_generics), &rb, a, None))\n+                        .map(|a| ty_of_arg(&ccx.icx(ast_generics), &rb, a, None))\n                         .collect();\n \n     let output = match decl.output {\n         ast::Return(ref ty) =>\n-            ty::FnConverging(ast_ty_to_ty(&ccx.icx(&ty_generics), &rb, &**ty)),\n+            ty::FnConverging(ast_ty_to_ty(&ccx.icx(ast_generics), &rb, &**ty)),\n         ast::DefaultReturn(..) =>\n             ty::FnConverging(ty::mk_nil(ccx.tcx)),\n         ast::NoReturn(..) =>\n@@ -2058,7 +2136,7 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n \n fn mk_item_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             ty_generics: &ty::Generics<'tcx>)\n-                            -> subst::Substs<'tcx>\n+                            -> Substs<'tcx>\n {\n     let types =\n         ty_generics.types.map(\n@@ -2068,7 +2146,7 @@ fn mk_item_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         ty_generics.regions.map(\n             |def| def.to_early_bound_region());\n \n-    subst::Substs::new(types, regions)\n+    Substs::new(types, regions)\n }\n \n /// Verifies that the explicit self type of a method matches the impl\n@@ -2087,7 +2165,7 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n {\n     let tcx = ccx.tcx;\n     if let ast::SelfExplicit(ref ast_type, _) = explicit_self.node {\n-        let typ = ccx.icx(&method_type.generics).to_ty(rs, &**ast_type);\n+        let typ = ccx.icx(&method_type.predicates).to_ty(rs, &**ast_type);\n         let base_type = match typ.sty {\n             ty::ty_ptr(tm) | ty::ty_rptr(_, tm) => tm.ty,\n             ty::ty_uniq(typ) => typ,"}, {"sha": "ce97019a2b266d5558f39b78fe89965b90d6ad2a", "filename": "src/test/compile-fail/associated-type-projection-ambig-between-bound-and-where-clause.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cf73e36ab01f48c883808cf58af5baed8d697538/src%2Ftest%2Fcompile-fail%2Fassociated-type-projection-ambig-between-bound-and-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf73e36ab01f48c883808cf58af5baed8d697538/src%2Ftest%2Fcompile-fail%2Fassociated-type-projection-ambig-between-bound-and-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-type-projection-ambig-between-bound-and-where-clause.rs?ref=cf73e36ab01f48c883808cf58af5baed8d697538", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test equality constraints in a where clause where the type being\n+// equated appears in a supertrait.\n+\n+pub trait Vehicle {\n+    type Color;\n+\n+    fn go(&self) {  }\n+}\n+\n+pub trait Box {\n+    type Color;\n+\n+    fn mail(&self) {  }\n+}\n+\n+fn a<C:Vehicle+Box>(_: C::Color) {\n+    //~^ ERROR ambiguous associated type `Color` in bounds of `C`\n+}\n+\n+fn b<C>(_: C::Color) where C : Vehicle+Box {\n+    //~^ ERROR ambiguous associated type `Color` in bounds of `C`\n+}\n+\n+fn c<C>(_: C::Color) where C : Vehicle, C : Box {\n+    //~^ ERROR ambiguous associated type `Color` in bounds of `C`\n+}\n+\n+struct D<X>;\n+impl<X> D<X> where X : Vehicle {\n+    fn d(&self, _: X::Color) where X : Box { }\n+    //~^ ERROR ambiguous associated type `Color` in bounds of `X`\n+}\n+\n+trait E<X:Vehicle> {\n+    fn e(&self, _: X::Color) where X : Box;\n+    //~^ ERROR ambiguous associated type `Color` in bounds of `X`\n+\n+    fn f(&self, _: X::Color) where X : Box { }\n+    //~^ ERROR ambiguous associated type `Color` in bounds of `X`\n+}\n+\n+pub fn main() { }"}, {"sha": "abcbf567d44360f6584efcbfb0da509295d86501", "filename": "src/test/compile-fail/cycle-projection-based-on-where-clause.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cf73e36ab01f48c883808cf58af5baed8d697538/src%2Ftest%2Fcompile-fail%2Fcycle-projection-based-on-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf73e36ab01f48c883808cf58af5baed8d697538/src%2Ftest%2Fcompile-fail%2Fcycle-projection-based-on-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcycle-projection-based-on-where-clause.rs?ref=cf73e36ab01f48c883808cf58af5baed8d697538", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Example cycle where a bound on `T` uses a shorthand for `T`. This\n+// creates a cycle because we have to know the bounds on `T` to figure\n+// out what trait defines `Item`, but we can't know the bounds on `T`\n+// without knowing how to handle `T::Item`.\n+//\n+// Note that in the future cases like this could perhaps become legal,\n+// if we got more fine-grained about our cycle detection or changed\n+// how we handle `T::Item` resolution.\n+\n+use std::ops::Add;\n+\n+// Preamble.\n+trait Trait { type Item; }\n+\n+struct A<T>\n+    where T : Trait,\n+          T : Add<T::Item>\n+    //~^ ERROR illegal recursive type\n+{\n+    data: T\n+}\n+\n+fn main() {\n+}"}, {"sha": "ef3fead18f6aa1d34f99450012f30764b77ad116", "filename": "src/test/compile-fail/cycle-trait-supertrait-direct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf73e36ab01f48c883808cf58af5baed8d697538/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf73e36ab01f48c883808cf58af5baed8d697538/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-direct.rs?ref=cf73e36ab01f48c883808cf58af5baed8d697538", "patch": "@@ -11,7 +11,7 @@\n // Test a supertrait cycle where a trait extends itself.\n \n trait Chromosome: Chromosome {\n-    //~^ ERROR cyclic reference detected\n+    //~^ ERROR unsupported cyclic reference\n }\n \n fn main() { }"}, {"sha": "6ebd9a1bcb6e2548cb89a11d173d923911cfc98c", "filename": "src/test/compile-fail/cycle-trait-supertrait-indirect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf73e36ab01f48c883808cf58af5baed8d697538/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf73e36ab01f48c883808cf58af5baed8d697538/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-indirect.rs?ref=cf73e36ab01f48c883808cf58af5baed8d697538", "patch": "@@ -15,8 +15,8 @@ trait A: B {\n }\n \n trait B: C { }\n-    //~^ ERROR cyclic reference detected\n \n trait C: B { }\n+    //~^ ERROR unsupported cyclic reference\n \n fn main() { }"}, {"sha": "2243e00ffa1604be0dbbc724ed0c1fbbe7e60f98", "filename": "src/test/run-pass/associated-types-project-from-type-param-via-bound-in-where-clause.rs", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/cf73e36ab01f48c883808cf58af5baed8d697538/src%2Ftest%2Frun-pass%2Fassociated-types-project-from-type-param-via-bound-in-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf73e36ab01f48c883808cf58af5baed8d697538/src%2Ftest%2Frun-pass%2Fassociated-types-project-from-type-param-via-bound-in-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-project-from-type-param-via-bound-in-where-clause.rs?ref=cf73e36ab01f48c883808cf58af5baed8d697538", "patch": "@@ -0,0 +1,107 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Various uses of `T::Item` syntax where the bound that supplies\n+// `Item` originates in a where-clause, not the declaration of\n+// `T`. Issue #20300.\n+\n+use std::marker::{MarkerTrait, PhantomData};\n+use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT};\n+use std::sync::atomic::Ordering::SeqCst;\n+\n+static COUNTER: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+// Preamble.\n+trait Trait : MarkerTrait { type Item; }\n+struct Struct;\n+impl Trait for Struct {\n+    type Item = u32;\n+}\n+\n+// Where-clause attached on the method which declares `T`.\n+struct A;\n+impl A {\n+    fn foo<T>(_x: T::Item) where T: Trait {\n+        COUNTER.fetch_add(1, SeqCst);\n+    }\n+}\n+\n+// Where-clause attached on the method to a parameter from the struct.\n+struct B<T>(PhantomData<T>);\n+impl<T> B<T> {\n+    fn foo(_x: T::Item) where T: Trait {\n+        COUNTER.fetch_add(10, SeqCst);\n+    }\n+}\n+\n+// Where-clause attached to free fn.\n+fn c<T>(_: T::Item) where T : Trait {\n+    COUNTER.fetch_add(100, SeqCst);\n+}\n+\n+// Where-clause attached to defaulted and non-defaulted trait method.\n+trait AnotherTrait {\n+    fn method<T>(&self, _: T::Item) where T: Trait;\n+    fn default_method<T>(&self, _: T::Item) where T: Trait {\n+        COUNTER.fetch_add(1000, SeqCst);\n+    }\n+}\n+struct D;\n+impl AnotherTrait for D {\n+    fn method<T>(&self, _: T::Item) where T: Trait {\n+        COUNTER.fetch_add(10000, SeqCst);\n+    }\n+}\n+\n+// Where-clause attached to trait and impl containing the method.\n+trait YetAnotherTrait<T>\n+    where T : Trait\n+{\n+    fn method(&self, _: T::Item);\n+    fn default_method(&self, _: T::Item) {\n+        COUNTER.fetch_add(100000, SeqCst);\n+    }\n+}\n+struct E<T>(PhantomData<T>);\n+impl<T> YetAnotherTrait<T> for E<T>\n+    where T : Trait\n+{\n+    fn method(&self, _: T::Item) {\n+        COUNTER.fetch_add(1000000, SeqCst);\n+    }\n+}\n+\n+// Where-clause attached to inherent impl containing the method.\n+struct F<T>(PhantomData<T>);\n+impl<T> F<T> where T : Trait {\n+    fn method(&self, _: T::Item) {\n+        COUNTER.fetch_add(10000000, SeqCst);\n+    }\n+}\n+\n+// Where-clause attached to struct.\n+#[allow(dead_code)]\n+struct G<T> where T : Trait {\n+    data: T::Item,\n+    phantom: PhantomData<T>,\n+}\n+\n+fn main() {\n+    A::foo::<Struct>(22);\n+    B::<Struct>::foo(22);\n+    c::<Struct>(22);\n+    D.method::<Struct>(22);\n+    D.default_method::<Struct>(22);\n+    E(PhantomData::<Struct>).method(22);\n+    E(PhantomData::<Struct>).default_method(22);\n+    F(PhantomData::<Struct>).method(22);\n+    G::<Struct> { data: 22, phantom: PhantomData };\n+    assert_eq!(COUNTER.load(SeqCst), 11111111);\n+}"}, {"sha": "2388a567f3043e2b10c1a8ffb439b7de3397544b", "filename": "src/test/run-pass/cycle-generic-bound.rs", "status": "renamed", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cf73e36ab01f48c883808cf58af5baed8d697538/src%2Ftest%2Frun-pass%2Fcycle-generic-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf73e36ab01f48c883808cf58af5baed8d697538/src%2Ftest%2Frun-pass%2Fcycle-generic-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcycle-generic-bound.rs?ref=cf73e36ab01f48c883808cf58af5baed8d697538", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Regression test for #15477. This test should pass, vs reporting an\n-// error as it does now, but at least this test shows it doesn't\n-// segfault.\n+// Regression test for #15477. This test just needs to compile.\n \n-trait Chromosome<X: Chromosome> {\n-    //~^ ERROR cyclic reference detected\n+use std::marker::PhantomFn;\n+\n+trait Chromosome<X: Chromosome<i32>> : PhantomFn<(Self,X)> {\n }\n \n fn main() { }", "previous_filename": "src/test/compile-fail/cycle-generic-bound.rs"}, {"sha": "6e16e68610603f1f9e7123a5697ef0f515f56729", "filename": "src/test/run-pass/cycle-trait-type-trait.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf73e36ab01f48c883808cf58af5baed8d697538/src%2Ftest%2Frun-pass%2Fcycle-trait-type-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf73e36ab01f48c883808cf58af5baed8d697538/src%2Ftest%2Frun-pass%2Fcycle-trait-type-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcycle-trait-type-trait.rs?ref=cf73e36ab01f48c883808cf58af5baed8d697538", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test a supertrait cycle where a trait extends itself.\n+// Test a case where a supertrait references a type that references\n+// the original trait. This poses no problem at the moment.\n \n-trait Chromosome: Get<Struct> {\n-    //~^ ERROR cyclic reference detected\n+trait Chromosome: Get<Struct<i32>> {\n }\n \n trait Get<A> {", "previous_filename": "src/test/compile-fail/cycle-trait-type-trait.rs"}]}