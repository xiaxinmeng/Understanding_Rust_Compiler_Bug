{"sha": "73b4fea01502ea7d4381f711cde5210cefcb4e00", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczYjRmZWEwMTUwMmVhN2Q0MzgxZjcxMWNkZTUyMTBjZWZjYjRlMDA=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-09-10T19:23:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-10T19:23:39Z"}, "message": "Merge #1810\n\n1810: cleanup dollar handling in expressions r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "8b4a9d1ef764d82ccfdafdb2231a7813be09b01d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b4a9d1ef764d82ccfdafdb2231a7813be09b01d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73b4fea01502ea7d4381f711cde5210cefcb4e00", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdd/g7CRBK7hj4Ov3rIwAAdHIIACDTgCM0XyMAB3N2zrsJ8UYj\nJCeHf2FwfURFRGzUagNQEHD8zbWL5KFNI0/LyajLp7rVZ6HR19LmIY6nP3YKE3l/\njHiQz1CuKVfx1GDCApY7MRx2/qEku87zqq9UV5s6JgksItJTpGmgmQsx6c2VrAmS\nNuxqz/zTBeBQmm7g7blCr1i/bmjwqDKD+Iz2WpQ1VZ400/37sg35TtkojUHQiMe5\ndfFbYNWdjb9CiShdxPNGckmJMZmUXQwq5SFJ8x8SskXMsleN7plTRa8uYIlrWyvk\neNopqGMFQgAzg1r/7zeANTBGF9OU20j9zK7AXZPqXCb3bI55UyIQCFZRh4SMatE=\n=UPbh\n-----END PGP SIGNATURE-----\n", "payload": "tree 8b4a9d1ef764d82ccfdafdb2231a7813be09b01d\nparent 1140a83c1b393cdcd18e42d5d816fd8be348b059\nparent 9eb14e11706ebf9a60b0afbe9bc82a99a816bc02\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1568143419 +0000\ncommitter GitHub <noreply@github.com> 1568143419 +0000\n\nMerge #1810\n\n1810: cleanup dollar handling in expressions r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73b4fea01502ea7d4381f711cde5210cefcb4e00", "html_url": "https://github.com/rust-lang/rust/commit/73b4fea01502ea7d4381f711cde5210cefcb4e00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73b4fea01502ea7d4381f711cde5210cefcb4e00/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1140a83c1b393cdcd18e42d5d816fd8be348b059", "url": "https://api.github.com/repos/rust-lang/rust/commits/1140a83c1b393cdcd18e42d5d816fd8be348b059", "html_url": "https://github.com/rust-lang/rust/commit/1140a83c1b393cdcd18e42d5d816fd8be348b059"}, {"sha": "9eb14e11706ebf9a60b0afbe9bc82a99a816bc02", "url": "https://api.github.com/repos/rust-lang/rust/commits/9eb14e11706ebf9a60b0afbe9bc82a99a816bc02", "html_url": "https://github.com/rust-lang/rust/commit/9eb14e11706ebf9a60b0afbe9bc82a99a816bc02"}], "stats": {"total": 192, "additions": 62, "deletions": 130}, "files": [{"sha": "9ea4e695d9696d16c4bddc32b78b34b148dc918e", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73b4fea01502ea7d4381f711cde5210cefcb4e00/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73b4fea01502ea7d4381f711cde5210cefcb4e00/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=73b4fea01502ea7d4381f711cde5210cefcb4e00", "patch": "@@ -90,7 +90,7 @@ impl HirFileId {\n             })\n             .ok()?;\n         match macro_file.macro_file_kind {\n-            MacroFileKind::Items => Some(Parse::to_syntax(mbe::token_tree_to_ast_item_list(&tt))),\n+            MacroFileKind::Items => mbe::token_tree_to_items(&tt).ok().map(Parse::to_syntax),\n             MacroFileKind::Expr => mbe::token_tree_to_expr(&tt).ok().map(Parse::to_syntax),\n         }\n     }"}, {"sha": "04b97cb90691024803d7acf83c1de39229d32784", "filename": "crates/ra_hir/src/nameres/raw.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73b4fea01502ea7d4381f711cde5210cefcb4e00/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73b4fea01502ea7d4381f711cde5210cefcb4e00/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs?ref=73b4fea01502ea7d4381f711cde5210cefcb4e00", "patch": "@@ -76,8 +76,10 @@ impl RawItems {\n             source_map: ImportSourceMap::default(),\n         };\n         if let Some(node) = db.parse_or_expand(file_id) {\n-            if let Some(source_file) = ast::SourceFile::cast(node) {\n+            if let Some(source_file) = ast::SourceFile::cast(node.clone()) {\n                 collector.process_module(None, source_file);\n+            } else if let Some(item_list) = ast::MacroItems::cast(node) {\n+                collector.process_module(None, item_list);\n             }\n         }\n         (Arc::new(collector.raw_items), Arc::new(collector.source_map))"}, {"sha": "f07f000ffe336543ea304d19434bb2a6186cd1a9", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73b4fea01502ea7d4381f711cde5210cefcb4e00/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73b4fea01502ea7d4381f711cde5210cefcb4e00/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=73b4fea01502ea7d4381f711cde5210cefcb4e00", "patch": "@@ -41,8 +41,8 @@ pub enum ExpandError {\n }\n \n pub use crate::syntax_bridge::{\n-    ast_to_token_tree, syntax_node_to_token_tree, token_tree_to_ast_item_list, token_tree_to_expr,\n-    token_tree_to_macro_items, token_tree_to_macro_stmts, token_tree_to_pat, token_tree_to_ty,\n+    ast_to_token_tree, syntax_node_to_token_tree, token_tree_to_expr, token_tree_to_items,\n+    token_tree_to_macro_stmts, token_tree_to_pat, token_tree_to_ty,\n };\n \n /// This struct contains AST for a single `macro_rules` definition. What might"}, {"sha": "2d035307b1785bd328f92547b0ab4fcc5bba735f", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/73b4fea01502ea7d4381f711cde5210cefcb4e00/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73b4fea01502ea7d4381f711cde5210cefcb4e00/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=73b4fea01502ea7d4381f711cde5210cefcb4e00", "patch": "@@ -46,25 +46,6 @@ pub fn syntax_node_to_token_tree(node: &SyntaxNode) -> Option<(tt::Subtree, Toke\n // * TraitItems(SmallVec<[ast::TraitItem; 1]>)\n // * ImplItems(SmallVec<[ast::ImplItem; 1]>)\n // * ForeignItems(SmallVec<[ast::ForeignItem; 1]>\n-//\n-//\n-\n-fn token_tree_to_syntax_node<F>(tt: &tt::Subtree, f: F) -> Result<Parse<SyntaxNode>, ExpandError>\n-where\n-    F: Fn(&mut dyn ra_parser::TokenSource, &mut dyn ra_parser::TreeSink),\n-{\n-    let tokens = [tt.clone().into()];\n-    let buffer = TokenBuffer::new(&tokens);\n-    let mut token_source = SubtreeTokenSource::new(&buffer);\n-    let mut tree_sink = TtTreeSink::new(buffer.begin());\n-    f(&mut token_source, &mut tree_sink);\n-    if tree_sink.roots.len() != 1 {\n-        return Err(ExpandError::ConversionError);\n-    }\n-    //FIXME: would be cool to report errors\n-    let parse = tree_sink.inner.finish();\n-    Ok(parse)\n-}\n \n fn fragment_to_syntax_node(\n     tt: &tt::Subtree,\n@@ -115,17 +96,11 @@ pub fn token_tree_to_macro_stmts(tt: &tt::Subtree) -> Result<Parse<ast::MacroStm\n }\n \n /// Parses the token tree (result of macro expansion) as a sequence of items\n-pub fn token_tree_to_macro_items(tt: &tt::Subtree) -> Result<Parse<ast::MacroItems>, ExpandError> {\n+pub fn token_tree_to_items(tt: &tt::Subtree) -> Result<Parse<ast::MacroItems>, ExpandError> {\n     let parse = fragment_to_syntax_node(tt, Items)?;\n     parse.cast().ok_or_else(|| crate::ExpandError::ConversionError)\n }\n \n-/// Parses the token tree (result of macro expansion) as a sequence of items\n-pub fn token_tree_to_ast_item_list(tt: &tt::Subtree) -> Parse<ast::SourceFile> {\n-    let parse = token_tree_to_syntax_node(tt, ra_parser::parse).unwrap();\n-    parse.cast().unwrap()\n-}\n-\n impl TokenMap {\n     pub fn relative_range_of(&self, tt: tt::TokenId) -> Option<TextRange> {\n         let idx = tt.0 as usize;"}, {"sha": "312fa4626c6f5a7bca103d0bfef13c4e558d1a6e", "filename": "crates/ra_mbe/src/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/73b4fea01502ea7d4381f711cde5210cefcb4e00/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73b4fea01502ea7d4381f711cde5210cefcb4e00/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftests.rs?ref=73b4fea01502ea7d4381f711cde5210cefcb4e00", "patch": "@@ -70,7 +70,7 @@ pub(crate) fn expand(rules: &MacroRules, invocation: &str) -> tt::Subtree {\n \n pub(crate) fn expand_to_items(rules: &MacroRules, invocation: &str) -> ast::MacroItems {\n     let expanded = expand(rules, invocation);\n-    token_tree_to_macro_items(&expanded).unwrap().tree()\n+    token_tree_to_items(&expanded).unwrap().tree()\n }\n \n #[allow(unused)]\n@@ -155,8 +155,8 @@ pub(crate) fn assert_expansion(\n     let expected = text_to_tokentree(&expected);\n     let (expanded_tree, expected_tree) = match kind {\n         MacroKind::Items => {\n-            let expanded_tree = token_tree_to_macro_items(&expanded).unwrap().tree();\n-            let expected_tree = token_tree_to_macro_items(&expected).unwrap().tree();\n+            let expanded_tree = token_tree_to_items(&expanded).unwrap().tree();\n+            let expected_tree = token_tree_to_items(&expected).unwrap().tree();\n \n             (\n                 debug_dump_ignore_spaces(expanded_tree.syntax()).trim().to_string(),\n@@ -410,7 +410,7 @@ fn test_expand_to_item_list() {\n             \",\n     );\n     let expansion = expand(&rules, \"structs!(Foo, Bar);\");\n-    let tree = token_tree_to_macro_items(&expansion).unwrap().tree();\n+    let tree = token_tree_to_items(&expansion).unwrap().tree();\n     assert_eq!(\n         format!(\"{:#?}\", tree.syntax()).trim(),\n         r#\""}, {"sha": "1dd9a586c7fbc64a4c62f7ea6d978472c1107f46", "filename": "crates/ra_parser/src/grammar/expressions.rs", "status": "modified", "additions": 9, "deletions": 40, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/73b4fea01502ea7d4381f711cde5210cefcb4e00/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73b4fea01502ea7d4381f711cde5210cefcb4e00/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=73b4fea01502ea7d4381f711cde5210cefcb4e00", "patch": "@@ -14,20 +14,17 @@ const EXPR_FIRST: TokenSet = LHS_FIRST;\n \n pub(super) fn expr(p: &mut Parser) -> BlockLike {\n     let r = Restrictions { forbid_structs: false, prefer_stmt: false };\n-    let mut dollar_lvl = 0;\n-    expr_bp(p, r, 1, &mut dollar_lvl).1\n+    expr_bp(p, r, 1).1\n }\n \n pub(super) fn expr_stmt(p: &mut Parser) -> (Option<CompletedMarker>, BlockLike) {\n     let r = Restrictions { forbid_structs: false, prefer_stmt: true };\n-    let mut dollar_lvl = 0;\n-    expr_bp(p, r, 1, &mut dollar_lvl)\n+    expr_bp(p, r, 1)\n }\n \n fn expr_no_struct(p: &mut Parser) {\n     let r = Restrictions { forbid_structs: true, prefer_stmt: false };\n-    let mut dollar_lvl = 0;\n-    expr_bp(p, r, 1, &mut dollar_lvl);\n+    expr_bp(p, r, 1);\n }\n \n // test block\n@@ -257,23 +254,8 @@ fn current_op(p: &Parser) -> (u8, SyntaxKind) {\n }\n \n // Parses expression with binding power of at least bp.\n-fn expr_bp(\n-    p: &mut Parser,\n-    r: Restrictions,\n-    mut bp: u8,\n-    dollar_lvl: &mut usize,\n-) -> (Option<CompletedMarker>, BlockLike) {\n-    // `newly_dollar_open` is a flag indicated that dollar is just closed after lhs, e.g.\n-    // `$1$ + a`\n-    // We use this flag to skip handling it.\n-    let mut newly_dollar_open = if p.at_l_dollar() {\n-        *dollar_lvl += p.eat_l_dollars();\n-        true\n-    } else {\n-        false\n-    };\n-\n-    let mut lhs = match lhs(p, r, dollar_lvl) {\n+fn expr_bp(p: &mut Parser, r: Restrictions, bp: u8) -> (Option<CompletedMarker>, BlockLike) {\n+    let mut lhs = match lhs(p, r) {\n         Some((lhs, blocklike)) => {\n             // test stmt_bin_expr_ambiguity\n             // fn foo() {\n@@ -289,15 +271,6 @@ fn expr_bp(\n     };\n \n     loop {\n-        if *dollar_lvl > 0 && p.at_r_dollar() {\n-            *dollar_lvl -= p.eat_r_dollars(*dollar_lvl);\n-            if !newly_dollar_open {\n-                // We \"pump\" bp for make it highest priority\n-                bp = 255;\n-            }\n-            newly_dollar_open = false;\n-        }\n-\n         let is_range = p.at(T![..]) || p.at(T![..=]);\n         let (op_bp, op) = current_op(p);\n         if op_bp < bp {\n@@ -306,19 +279,15 @@ fn expr_bp(\n         let m = lhs.precede(p);\n         p.bump(op);\n \n-        expr_bp(p, r, op_bp + 1, dollar_lvl);\n+        expr_bp(p, r, op_bp + 1);\n         lhs = m.complete(p, if is_range { RANGE_EXPR } else { BIN_EXPR });\n     }\n     (Some(lhs), BlockLike::NotBlock)\n }\n \n const LHS_FIRST: TokenSet = atom::ATOM_EXPR_FIRST.union(token_set![AMP, STAR, EXCL, DOT, MINUS]);\n \n-fn lhs(\n-    p: &mut Parser,\n-    r: Restrictions,\n-    dollar_lvl: &mut usize,\n-) -> Option<(CompletedMarker, BlockLike)> {\n+fn lhs(p: &mut Parser, r: Restrictions) -> Option<(CompletedMarker, BlockLike)> {\n     let m;\n     let kind = match p.current() {\n         // test ref_expr\n@@ -351,7 +320,7 @@ fn lhs(\n                     m = p.start();\n                     p.bump(op);\n                     if p.at_ts(EXPR_FIRST) {\n-                        expr_bp(p, r, 2, dollar_lvl);\n+                        expr_bp(p, r, 2);\n                     }\n                     return Some((m.complete(p, RANGE_EXPR), BlockLike::NotBlock));\n                 }\n@@ -367,7 +336,7 @@ fn lhs(\n             return Some(postfix_expr(p, lhs, blocklike, !(r.prefer_stmt && blocklike.is_block())));\n         }\n     };\n-    expr_bp(p, r, 255, dollar_lvl);\n+    expr_bp(p, r, 255);\n     Some((m.complete(p, kind), BlockLike::NotBlock))\n }\n "}, {"sha": "6e295fbf9303298c49374710213b600a659bafbb", "filename": "crates/ra_parser/src/grammar/expressions/atom.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/73b4fea01502ea7d4381f711cde5210cefcb4e00/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73b4fea01502ea7d4381f711cde5210cefcb4e00/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=73b4fea01502ea7d4381f711cde5210cefcb4e00", "patch": "@@ -69,6 +69,7 @@ pub(super) fn atom_expr(p: &mut Parser, r: Restrictions) -> Option<(CompletedMar\n     let done = match p.current() {\n         T!['('] => tuple_expr(p),\n         T!['['] => array_expr(p),\n+        L_DOLLAR => meta_var_expr(p),\n         T![|] => lambda_expr(p),\n         T![move] if la == T![|] => lambda_expr(p),\n         T![async] if la == T![|] || (la == T![move] && p.nth(2) == T![|]) => lambda_expr(p),\n@@ -554,3 +555,27 @@ fn box_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n     }\n     m.complete(p, BOX_EXPR)\n }\n+\n+/// Expression from `$var` macro expansion, wrapped in dollars\n+fn meta_var_expr(p: &mut Parser) -> CompletedMarker {\n+    assert!(p.at(L_DOLLAR));\n+    let m = p.start();\n+    p.bump(L_DOLLAR);\n+    let (completed, _is_block) =\n+        expr_bp(p, Restrictions { forbid_structs: false, prefer_stmt: false }, 1);\n+\n+    match (completed, p.current()) {\n+        (Some(it), R_DOLLAR) => {\n+            p.bump(R_DOLLAR);\n+            m.abandon(p);\n+            it\n+        }\n+        _ => {\n+            while !p.at(R_DOLLAR) {\n+                p.bump_any()\n+            }\n+            p.bump(R_DOLLAR);\n+            m.complete(p, ERROR)\n+        }\n+    }\n+}"}, {"sha": "a2ac363fb854aa71b6efa1405810bf8e4ed164bb", "filename": "crates/ra_parser/src/parser.rs", "status": "modified", "additions": 17, "deletions": 56, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/73b4fea01502ea7d4381f711cde5210cefcb4e00/crates%2Fra_parser%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73b4fea01502ea7d4381f711cde5210cefcb4e00/crates%2Fra_parser%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fparser.rs?ref=73b4fea01502ea7d4381f711cde5210cefcb4e00", "patch": "@@ -5,7 +5,7 @@ use drop_bomb::DropBomb;\n use crate::{\n     event::Event,\n     ParseError,\n-    SyntaxKind::{self, EOF, ERROR, TOMBSTONE},\n+    SyntaxKind::{self, EOF, ERROR, L_DOLLAR, R_DOLLAR, TOMBSTONE},\n     TokenSet, TokenSource, T,\n };\n \n@@ -211,19 +211,26 @@ impl<'t> Parser<'t> {\n \n     /// Create an error node and consume the next token.\n     pub(crate) fn err_recover(&mut self, message: &str, recovery: TokenSet) {\n-        if self.at(T!['{']) || self.at(T!['}']) || self.at_ts(recovery) {\n-            self.error(message);\n-        } else {\n-            let m = self.start();\n+        match self.current() {\n+            T!['{'] | T!['}'] | L_DOLLAR | R_DOLLAR => {\n+                self.error(message);\n+                return;\n+            }\n+            _ => (),\n+        }\n+\n+        if self.at_ts(recovery) {\n             self.error(message);\n-            self.bump_any();\n-            m.complete(self, ERROR);\n-        };\n+            return;\n+        }\n+\n+        let m = self.start();\n+        self.error(message);\n+        self.bump_any();\n+        m.complete(self, ERROR);\n     }\n \n     fn do_bump(&mut self, kind: SyntaxKind, n_raw_tokens: u8) {\n-        // self.eat_dollars();\n-\n         for _ in 0..n_raw_tokens {\n             self.token_source.bump();\n         }\n@@ -234,52 +241,6 @@ impl<'t> Parser<'t> {\n     fn push_event(&mut self, event: Event) {\n         self.events.push(event)\n     }\n-\n-    pub(crate) fn eat_l_dollars(&mut self) -> usize {\n-        let mut ate_count = 0;\n-        loop {\n-            match self.token_source.current().kind {\n-                k @ SyntaxKind::L_DOLLAR => {\n-                    self.token_source.bump();\n-                    self.push_event(Event::Token { kind: k, n_raw_tokens: 1 });\n-                    ate_count += 1;\n-                }\n-                _ => {\n-                    return ate_count;\n-                }\n-            }\n-        }\n-    }\n-\n-    pub(crate) fn eat_r_dollars(&mut self, max_count: usize) -> usize {\n-        let mut ate_count = 0;\n-        loop {\n-            match self.token_source.current().kind {\n-                k @ SyntaxKind::R_DOLLAR => {\n-                    self.token_source.bump();\n-                    self.push_event(Event::Token { kind: k, n_raw_tokens: 1 });\n-                    ate_count += 1;\n-\n-                    if max_count >= ate_count {\n-                        return ate_count;\n-                    }\n-                }\n-                _ => {\n-                    return ate_count;\n-                }\n-            }\n-        }\n-    }\n-\n-    pub(crate) fn at_l_dollar(&self) -> bool {\n-        let kind = self.token_source.current().kind;\n-        (kind == SyntaxKind::L_DOLLAR)\n-    }\n-\n-    pub(crate) fn at_r_dollar(&self) -> bool {\n-        let kind = self.token_source.current().kind;\n-        (kind == SyntaxKind::R_DOLLAR)\n-    }\n }\n \n /// See `Parser::start`."}]}