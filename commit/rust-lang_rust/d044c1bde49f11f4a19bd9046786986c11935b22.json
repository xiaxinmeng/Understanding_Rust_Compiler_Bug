{"sha": "d044c1bde49f11f4a19bd9046786986c11935b22", "node_id": "C_kwDOAAsO6NoAKGQwNDRjMWJkZTQ5ZjExZjRhMTliZDkwNDY3ODY5ODZjMTE5MzViMjI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-02-07T16:57:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-07T16:57:18Z"}, "message": "Rollup merge of #107756 - RalfJung:miri-out-of-addresses, r=oli-obk\n\nmiri: fix ICE when running out of address space\n\nFixes https://github.com/rust-lang/miri/issues/2769\nr? `@oli-obk`\n\nI didn't add a test since that requires https://github.com/oli-obk/ui_test/issues/38 (host must be 64bit and target 32bit). Also the test takes ~30s, so I am not sure if we want to have it in the test suite?", "tree": {"sha": "1b1a065ae6cd37b806a3077b7696d71ffba5c39c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b1a065ae6cd37b806a3077b7696d71ffba5c39c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d044c1bde49f11f4a19bd9046786986c11935b22", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj4oLuCRBK7hj4Ov3rIwAAXAwIACx8ik9A5lyITi+mNx85xhJZ\n1EmvJi2kazV3sEBPkLo7vpWwZdVuXLTWWu+s6Cgkb9qgMzowGsRXTyUcMxDmPWzy\nGKD93yfXvfHBEGym8QZamRsbfMiMUGHvd+G0r1EkzbZQh1HMZMETi9sBjIoTDD+Y\nIqHOfh+Ki5h57ige9UKLO5AguflxmaYdq9khOgFL61WjawPsVB3ObXA3tC2F09qx\nVlyLG9Fjguxt2r9SAJu/DY3NLP2+3M4moyVYreaZR6wD7V1II6Wzb3Pzw7IAfS4O\nWwn+5GheIiPJUS+1KZwPgRAk4jEXVLRMLxeX4Aw8s39QFD+1lfN3aHf7TQMQMYs=\n=LMmg\n-----END PGP SIGNATURE-----\n", "payload": "tree 1b1a065ae6cd37b806a3077b7696d71ffba5c39c\nparent 505d05d3f753dc16720fb4bc94d68c64e892954b\nparent 2900ba15b3f2b17808b32af050c85f86ca98c136\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1675789038 +0100\ncommitter GitHub <noreply@github.com> 1675789038 +0100\n\nRollup merge of #107756 - RalfJung:miri-out-of-addresses, r=oli-obk\n\nmiri: fix ICE when running out of address space\n\nFixes https://github.com/rust-lang/miri/issues/2769\nr? `@oli-obk`\n\nI didn't add a test since that requires https://github.com/oli-obk/ui_test/issues/38 (host must be 64bit and target 32bit). Also the test takes ~30s, so I am not sure if we want to have it in the test suite?\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d044c1bde49f11f4a19bd9046786986c11935b22", "html_url": "https://github.com/rust-lang/rust/commit/d044c1bde49f11f4a19bd9046786986c11935b22", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d044c1bde49f11f4a19bd9046786986c11935b22/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "505d05d3f753dc16720fb4bc94d68c64e892954b", "url": "https://api.github.com/repos/rust-lang/rust/commits/505d05d3f753dc16720fb4bc94d68c64e892954b", "html_url": "https://github.com/rust-lang/rust/commit/505d05d3f753dc16720fb4bc94d68c64e892954b"}, {"sha": "2900ba15b3f2b17808b32af050c85f86ca98c136", "url": "https://api.github.com/repos/rust-lang/rust/commits/2900ba15b3f2b17808b32af050c85f86ca98c136", "html_url": "https://github.com/rust-lang/rust/commit/2900ba15b3f2b17808b32af050c85f86ca98c136"}], "stats": {"total": 87, "additions": 54, "deletions": 33}, "files": [{"sha": "5042c6bac9932dcfd4821aa3e273c14fab373b7d", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d044c1bde49f11f4a19bd9046786986c11935b22/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d044c1bde49f11f4a19bd9046786986c11935b22/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=d044c1bde49f11f4a19bd9046786986c11935b22", "patch": "@@ -78,13 +78,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         col: u32,\n     ) -> MPlaceTy<'tcx, M::Provenance> {\n         let loc_details = &self.tcx.sess.opts.unstable_opts.location_detail;\n+        // This can fail if rustc runs out of memory right here. Trying to emit an error would be\n+        // pointless, since that would require allocating more memory than these short strings.\n         let file = if loc_details.file {\n             self.allocate_str(filename.as_str(), MemoryKind::CallerLocation, Mutability::Not)\n+                .unwrap()\n         } else {\n             // FIXME: This creates a new allocation each time. It might be preferable to\n             // perform this allocation only once, and re-use the `MPlaceTy`.\n             // See https://github.com/rust-lang/rust/pull/89920#discussion_r730012398\n-            self.allocate_str(\"<redacted>\", MemoryKind::CallerLocation, Mutability::Not)\n+            self.allocate_str(\"<redacted>\", MemoryKind::CallerLocation, Mutability::Not).unwrap()\n         };\n         let line = if loc_details.line { Scalar::from_u32(line) } else { Scalar::from_u32(0) };\n         let col = if loc_details.column { Scalar::from_u32(col) } else { Scalar::from_u32(0) };\n@@ -95,8 +98,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .bound_type_of(self.tcx.require_lang_item(LangItem::PanicLocation, None))\n             .subst(*self.tcx, self.tcx.mk_substs([self.tcx.lifetimes.re_erased.into()].iter()));\n         let loc_layout = self.layout_of(loc_ty).unwrap();\n-        // This can fail if rustc runs out of memory right here. Trying to emit an error would be\n-        // pointless, since that would require allocating more memory than a Location.\n         let location = self.allocate(loc_layout, MemoryKind::CallerLocation).unwrap();\n \n         // Initialize fields."}, {"sha": "d8087a36a7c6abfb48240319148c8e68e2bf3917", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d044c1bde49f11f4a19bd9046786986c11935b22/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d044c1bde49f11f4a19bd9046786986c11935b22/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=d044c1bde49f11f4a19bd9046786986c11935b22", "patch": "@@ -291,7 +291,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     fn adjust_alloc_base_pointer(\n         ecx: &InterpCx<'mir, 'tcx, Self>,\n         ptr: Pointer,\n-    ) -> Pointer<Self::Provenance>;\n+    ) -> InterpResult<'tcx, Pointer<Self::Provenance>>;\n \n     /// \"Int-to-pointer cast\"\n     fn ptr_from_addr_cast(\n@@ -505,8 +505,8 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     fn adjust_alloc_base_pointer(\n         _ecx: &InterpCx<$mir, $tcx, Self>,\n         ptr: Pointer<AllocId>,\n-    ) -> Pointer<AllocId> {\n-        ptr\n+    ) -> InterpResult<$tcx, Pointer<AllocId>> {\n+        Ok(ptr)\n     }\n \n     #[inline(always)]"}, {"sha": "cfad930b1e52ec6ca1174e7700b5e3135fbcdf80", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d044c1bde49f11f4a19bd9046786986c11935b22/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d044c1bde49f11f4a19bd9046786986c11935b22/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=d044c1bde49f11f4a19bd9046786986c11935b22", "patch": "@@ -171,7 +171,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             _ => {}\n         }\n         // And we need to get the provenance.\n-        Ok(M::adjust_alloc_base_pointer(self, ptr))\n+        M::adjust_alloc_base_pointer(self, ptr)\n     }\n \n     pub fn create_fn_alloc_ptr(\n@@ -200,8 +200,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx, Pointer<M::Provenance>> {\n         let alloc = Allocation::uninit(size, align, M::PANIC_ON_ALLOC_FAIL)?;\n-        // We can `unwrap` since `alloc` contains no pointers.\n-        Ok(self.allocate_raw_ptr(alloc, kind).unwrap())\n+        self.allocate_raw_ptr(alloc, kind)\n     }\n \n     pub fn allocate_bytes_ptr(\n@@ -210,10 +209,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         align: Align,\n         kind: MemoryKind<M::MemoryKind>,\n         mutability: Mutability,\n-    ) -> Pointer<M::Provenance> {\n+    ) -> InterpResult<'tcx, Pointer<M::Provenance>> {\n         let alloc = Allocation::from_bytes(bytes, align, mutability);\n-        // We can `unwrap` since `alloc` contains no pointers.\n-        self.allocate_raw_ptr(alloc, kind).unwrap()\n+        self.allocate_raw_ptr(alloc, kind)\n     }\n \n     /// This can fail only of `alloc` contains provenance.\n@@ -230,7 +228,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         );\n         let alloc = M::adjust_allocation(self, id, Cow::Owned(alloc), Some(kind))?;\n         self.memory.alloc_map.insert(id, (kind, alloc.into_owned()));\n-        Ok(M::adjust_alloc_base_pointer(self, Pointer::from(id)))\n+        M::adjust_alloc_base_pointer(self, Pointer::from(id))\n     }\n \n     pub fn reallocate_ptr("}, {"sha": "038282e2161e6637891d2cde59fe2e766e40b189", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d044c1bde49f11f4a19bd9046786986c11935b22/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d044c1bde49f11f4a19bd9046786986c11935b22/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=d044c1bde49f11f4a19bd9046786986c11935b22", "patch": "@@ -754,8 +754,8 @@ where\n         str: &str,\n         kind: MemoryKind<M::MemoryKind>,\n         mutbl: Mutability,\n-    ) -> MPlaceTy<'tcx, M::Provenance> {\n-        let ptr = self.allocate_bytes_ptr(str.as_bytes(), Align::ONE, kind, mutbl);\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::Provenance>> {\n+        let ptr = self.allocate_bytes_ptr(str.as_bytes(), Align::ONE, kind, mutbl)?;\n         let meta = Scalar::from_machine_usize(u64::try_from(str.len()).unwrap(), self);\n         let mplace = MemPlace { ptr: ptr.into(), meta: MemPlaceMeta::Meta(meta) };\n \n@@ -764,7 +764,7 @@ where\n             ty::TypeAndMut { ty: self.tcx.types.str_, mutbl },\n         );\n         let layout = self.layout_of(ty).unwrap();\n-        MPlaceTy { mplace, layout, align: layout.align.abi }\n+        Ok(MPlaceTy { mplace, layout, align: layout.align.abi })\n     }\n \n     /// Writes the aggregate to the destination."}, {"sha": "f22c0dbc60d9d0f6a7114f0db7f87b550737eaca", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d044c1bde49f11f4a19bd9046786986c11935b22/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d044c1bde49f11f4a19bd9046786986c11935b22/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=d044c1bde49f11f4a19bd9046786986c11935b22", "patch": "@@ -430,8 +430,10 @@ pub enum ResourceExhaustionInfo {\n     ///\n     /// The exact limit is set by the `const_eval_limit` attribute.\n     StepLimitReached,\n-    /// There is not enough memory to perform an allocation.\n+    /// There is not enough memory (on the host) to perform an allocation.\n     MemoryExhausted,\n+    /// The address space (of the target) is full.\n+    AddressSpaceFull,\n }\n \n impl fmt::Display for ResourceExhaustionInfo {\n@@ -447,6 +449,9 @@ impl fmt::Display for ResourceExhaustionInfo {\n             MemoryExhausted => {\n                 write!(f, \"tried to allocate more memory than available to compiler\")\n             }\n+            AddressSpaceFull => {\n+                write!(f, \"there are no more free addresses in the address space\")\n+            }\n         }\n     }\n }"}, {"sha": "dcb1879042041daa9e9a0d520c4ef7d7265db366", "filename": "src/tools/miri/src/intptrcast.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d044c1bde49f11f4a19bd9046786986c11935b22/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d044c1bde49f11f4a19bd9046786986c11935b22/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs?ref=d044c1bde49f11f4a19bd9046786986c11935b22", "patch": "@@ -162,11 +162,14 @@ impl<'mir, 'tcx> GlobalStateInner {\n         Ok(Pointer::new(Some(Provenance::Wildcard), Size::from_bytes(addr)))\n     }\n \n-    fn alloc_base_addr(ecx: &MiriInterpCx<'mir, 'tcx>, alloc_id: AllocId) -> u64 {\n+    fn alloc_base_addr(\n+        ecx: &MiriInterpCx<'mir, 'tcx>,\n+        alloc_id: AllocId,\n+    ) -> InterpResult<'tcx, u64> {\n         let mut global_state = ecx.machine.intptrcast.borrow_mut();\n         let global_state = &mut *global_state;\n \n-        match global_state.base_addr.entry(alloc_id) {\n+        Ok(match global_state.base_addr.entry(alloc_id) {\n             Entry::Occupied(entry) => *entry.get(),\n             Entry::Vacant(entry) => {\n                 // There is nothing wrong with a raw pointer being cast to an integer only after\n@@ -181,7 +184,10 @@ impl<'mir, 'tcx> GlobalStateInner {\n                     rng.gen_range(0..16)\n                 };\n                 // From next_base_addr + slack, round up to adjust for alignment.\n-                let base_addr = global_state.next_base_addr.checked_add(slack).unwrap();\n+                let base_addr = global_state\n+                    .next_base_addr\n+                    .checked_add(slack)\n+                    .ok_or_else(|| err_exhaust!(AddressSpaceFull))?;\n                 let base_addr = Self::align_addr(base_addr, align.bytes());\n                 entry.insert(base_addr);\n                 trace!(\n@@ -197,24 +203,33 @@ impl<'mir, 'tcx> GlobalStateInner {\n                 // of at least 1 to avoid two allocations having the same base address.\n                 // (The logic in `alloc_id_from_addr` assumes unique addresses, and different\n                 // function/vtable pointers need to be distinguishable!)\n-                global_state.next_base_addr = base_addr.checked_add(max(size.bytes(), 1)).unwrap();\n+                global_state.next_base_addr = base_addr\n+                    .checked_add(max(size.bytes(), 1))\n+                    .ok_or_else(|| err_exhaust!(AddressSpaceFull))?;\n+                // Even if `Size` didn't overflow, we might still have filled up the address space.\n+                if global_state.next_base_addr > ecx.machine_usize_max() {\n+                    throw_exhaust!(AddressSpaceFull);\n+                }\n                 // Given that `next_base_addr` increases in each allocation, pushing the\n                 // corresponding tuple keeps `int_to_ptr_map` sorted\n                 global_state.int_to_ptr_map.push((base_addr, alloc_id));\n \n                 base_addr\n             }\n-        }\n+        })\n     }\n \n     /// Convert a relative (tcx) pointer to an absolute address.\n-    pub fn rel_ptr_to_addr(ecx: &MiriInterpCx<'mir, 'tcx>, ptr: Pointer<AllocId>) -> u64 {\n+    pub fn rel_ptr_to_addr(\n+        ecx: &MiriInterpCx<'mir, 'tcx>,\n+        ptr: Pointer<AllocId>,\n+    ) -> InterpResult<'tcx, u64> {\n         let (alloc_id, offset) = ptr.into_parts(); // offset is relative (AllocId provenance)\n-        let base_addr = GlobalStateInner::alloc_base_addr(ecx, alloc_id);\n+        let base_addr = GlobalStateInner::alloc_base_addr(ecx, alloc_id)?;\n \n         // Add offset with the right kind of pointer-overflowing arithmetic.\n         let dl = ecx.data_layout();\n-        dl.overflowing_offset(base_addr, offset.bytes()).0\n+        Ok(dl.overflowing_offset(base_addr, offset.bytes()).0)\n     }\n \n     /// When a pointer is used for a memory access, this computes where in which allocation the\n@@ -232,7 +247,9 @@ impl<'mir, 'tcx> GlobalStateInner {\n             GlobalStateInner::alloc_id_from_addr(ecx, addr.bytes())?\n         };\n \n-        let base_addr = GlobalStateInner::alloc_base_addr(ecx, alloc_id);\n+        // This cannot fail: since we already have a pointer with that provenance, rel_ptr_to_addr\n+        // must have been called in the past.\n+        let base_addr = GlobalStateInner::alloc_base_addr(ecx, alloc_id).unwrap();\n \n         // Wrapping \"addr - base_addr\"\n         let dl = ecx.data_layout();"}, {"sha": "8e44d4d7adec8465607827b6ba9f06529a623ce3", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d044c1bde49f11f4a19bd9046786986c11935b22/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d044c1bde49f11f4a19bd9046786986c11935b22/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=d044c1bde49f11f4a19bd9046786986c11935b22", "patch": "@@ -971,7 +971,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     fn adjust_alloc_base_pointer(\n         ecx: &MiriInterpCx<'mir, 'tcx>,\n         ptr: Pointer<AllocId>,\n-    ) -> Pointer<Provenance> {\n+    ) -> InterpResult<'tcx, Pointer<Provenance>> {\n         if cfg!(debug_assertions) {\n             // The machine promises to never call us on thread-local or extern statics.\n             let alloc_id = ptr.provenance;\n@@ -985,17 +985,17 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n                 _ => {}\n             }\n         }\n-        let absolute_addr = intptrcast::GlobalStateInner::rel_ptr_to_addr(ecx, ptr);\n+        let absolute_addr = intptrcast::GlobalStateInner::rel_ptr_to_addr(ecx, ptr)?;\n         let tag = if let Some(borrow_tracker) = &ecx.machine.borrow_tracker {\n             borrow_tracker.borrow_mut().base_ptr_tag(ptr.provenance, &ecx.machine)\n         } else {\n             // Value does not matter, SB is disabled\n             BorTag::default()\n         };\n-        Pointer::new(\n+        Ok(Pointer::new(\n             Provenance::Concrete { alloc_id: ptr.provenance, tag },\n             Size::from_bytes(absolute_addr),\n-        )\n+        ))\n     }\n \n     #[inline(always)]"}, {"sha": "ed1c6ebfece76ceed96988a2385a21c6d0145065", "filename": "src/tools/miri/src/shims/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d044c1bde49f11f4a19bd9046786986c11935b22/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d044c1bde49f11f4a19bd9046786986c11935b22/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fbacktrace.rs?ref=d044c1bde49f11f4a19bd9046786986c11935b22", "patch": "@@ -190,9 +190,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             0 => {\n                 // These are \"mutable\" allocations as we consider them to be owned by the callee.\n                 let name_alloc =\n-                    this.allocate_str(&name, MiriMemoryKind::Rust.into(), Mutability::Mut);\n+                    this.allocate_str(&name, MiriMemoryKind::Rust.into(), Mutability::Mut)?;\n                 let filename_alloc =\n-                    this.allocate_str(&filename, MiriMemoryKind::Rust.into(), Mutability::Mut);\n+                    this.allocate_str(&filename, MiriMemoryKind::Rust.into(), Mutability::Mut)?;\n \n                 this.write_immediate(\n                     name_alloc.to_ref(this),"}, {"sha": "0ea1137200b9d98177de5a0770fa040a7fd19471", "filename": "src/tools/miri/src/shims/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d044c1bde49f11f4a19bd9046786986c11935b22/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d044c1bde49f11f4a19bd9046786986c11935b22/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs?ref=d044c1bde49f11f4a19bd9046786986c11935b22", "patch": "@@ -172,7 +172,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         // First arg: message.\n-        let msg = this.allocate_str(msg, MiriMemoryKind::Machine.into(), Mutability::Not);\n+        let msg = this.allocate_str(msg, MiriMemoryKind::Machine.into(), Mutability::Not)?;\n \n         // Call the lang item.\n         let panic = this.tcx.lang_items().panic_fn().unwrap();"}]}