{"sha": "fe3ba31860f2eb93f1f1cb1fe45658a8dd4d7610", "node_id": "C_kwDOAAsO6NoAKGZlM2JhMzE4NjBmMmViOTNmMWYxY2IxZmU0NTY1OGE4ZGQ0ZDc2MTA", "commit": {"author": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2021-11-22T02:50:09Z"}, "committer": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2021-11-22T13:45:18Z"}, "message": "Overlap input and output stack slots", "tree": {"sha": "e45f8c9f76f54606a958ef36c7cd4285a337716a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e45f8c9f76f54606a958ef36c7cd4285a337716a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe3ba31860f2eb93f1f1cb1fe45658a8dd4d7610", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe3ba31860f2eb93f1f1cb1fe45658a8dd4d7610", "html_url": "https://github.com/rust-lang/rust/commit/fe3ba31860f2eb93f1f1cb1fe45658a8dd4d7610", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe3ba31860f2eb93f1f1cb1fe45658a8dd4d7610/comments", "author": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14aa039d3087b76152018e3ca8c5df34fe1540b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/14aa039d3087b76152018e3ca8c5df34fe1540b3", "html_url": "https://github.com/rust-lang/rust/commit/14aa039d3087b76152018e3ca8c5df34fe1540b3"}], "stats": {"total": 61, "additions": 40, "deletions": 21}, "files": [{"sha": "9c4de3932d10e7043a8dcc811db68b686a9e13ed", "filename": "src/inline_asm.rs", "status": "modified", "additions": 40, "deletions": 21, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/fe3ba31860f2eb93f1f1cb1fe45658a8dd4d7610/src%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe3ba31860f2eb93f1f1cb1fe45658a8dd4d7610/src%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finline_asm.rs?ref=fe3ba31860f2eb93f1f1cb1fe45658a8dd4d7610", "patch": "@@ -128,7 +128,6 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n     let generated_asm = asm_gen.generate_asm_wrapper(&asm_name);\n     fx.cx.global_asm.push_str(&generated_asm);\n \n-    // FIXME overlap input and output slots to save stack space\n     for (i, operand) in operands.iter().enumerate() {\n         match *operand {\n             InlineAsmOperand::In { reg: _, ref value } => {\n@@ -306,19 +305,19 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         let mut slots_input = vec![None; self.operands.len()];\n         let mut slots_output = vec![None; self.operands.len()];\n \n-        let mut new_slot = |reg_class: InlineAsmRegClass| {\n+        let new_slot_fn = |slot_size: &mut Size, reg_class: InlineAsmRegClass| {\n             let reg_size = reg_class\n                 .supported_types(InlineAsmArch::X86_64)\n                 .iter()\n                 .map(|(ty, _)| ty.size())\n                 .max()\n                 .unwrap();\n             let align = rustc_target::abi::Align::from_bytes(reg_size.bytes()).unwrap();\n-            slot_size = slot_size.align_to(align);\n-            let offset = slot_size;\n-            slot_size += reg_size;\n+            let offset = slot_size.align_to(align);\n+            *slot_size = offset + reg_size;\n             offset\n         };\n+        let mut new_slot = |x| new_slot_fn(&mut slot_size, x);\n \n         // Allocate stack slots for saving clobbered registers\n         let abi_clobber =\n@@ -346,30 +345,50 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n             }\n         }\n \n-        // FIXME overlap input and output slots to save stack space\n+        // Allocate stack slots for inout\n         for (i, operand) in self.operands.iter().enumerate() {\n             match *operand {\n-                InlineAsmOperand::In { reg, .. } => {\n-                    slots_input[i] = Some(new_slot(reg.reg_class()));\n-                }\n-                InlineAsmOperand::Out { reg, place, .. } => {\n-                    if place.is_some() {\n-                        slots_output[i] = Some(new_slot(reg.reg_class()));\n-                    }\n-                }\n-                InlineAsmOperand::InOut { reg, out_place, .. } => {\n+                InlineAsmOperand::InOut { reg, out_place: Some(_), .. } => {\n                     let slot = new_slot(reg.reg_class());\n                     slots_input[i] = Some(slot);\n-                    if out_place.is_some() {\n-                        slots_output[i] = Some(slot);\n-                    }\n+                    slots_output[i] = Some(slot);\n+                }\n+                _ => (),\n+            }\n+        }\n+\n+        let slot_size_before_input = slot_size;\n+        let mut new_slot = |x| new_slot_fn(&mut slot_size, x);\n+\n+        // Allocate stack slots for input\n+        for (i, operand) in self.operands.iter().enumerate() {\n+            match *operand {\n+                InlineAsmOperand::In { reg, .. }\n+                | InlineAsmOperand::InOut { reg, out_place: None, .. } => {\n+                    slots_input[i] = Some(new_slot(reg.reg_class()));\n+                }\n+                _ => (),\n+            }\n+        }\n+\n+        // Reset slot size to before input so that input and output operands can overlap\n+        // and save some memory.\n+        let slot_size_after_input = slot_size;\n+        slot_size = slot_size_before_input;\n+        let mut new_slot = |x| new_slot_fn(&mut slot_size, x);\n+\n+        // Allocate stack slots for output\n+        for (i, operand) in self.operands.iter().enumerate() {\n+            match *operand {\n+                InlineAsmOperand::Out { reg, place: Some(_), .. } => {\n+                    slots_output[i] = Some(new_slot(reg.reg_class()));\n                 }\n-                InlineAsmOperand::Const { value: _ } => (),\n-                InlineAsmOperand::SymFn { value: _ } => (),\n-                InlineAsmOperand::SymStatic { def_id: _ } => (),\n+                _ => (),\n             }\n         }\n \n+        slot_size = slot_size.max(slot_size_after_input);\n+\n         self.stack_slots_clobber = slots_clobber;\n         self.stack_slots_input = slots_input;\n         self.stack_slots_output = slots_output;"}]}