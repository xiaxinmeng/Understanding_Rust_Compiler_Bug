{"sha": "a302155344af987a6ae4aab6cf820e279bbdcf63", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzMDIxNTUzNDRhZjk4N2E2YWU0YWFiNmNmODIwZTI3OWJiZGNmNjM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-25T04:18:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-25T04:18:01Z"}, "message": "Rollup merge of #62959 - LukasKalbertodt:array-value-iter, r=scottmcm\n\nAdd by-value iterator for arrays\n\nThis adds an iterator that can iterate over arrays by value, yielding all elements by value. However, **this PR does _not_ add a corresponding `IntoIterator` impl for arrays**. The `IntoIterator` impl needs some discussion about backwards-compatibility that should take place in a separate PR. With this patch, this code should work (but there is currently still a bug):\n\n```rust\n#![feature(array_value_iter)]\nuse std::array::IntoIter;\n\nlet arr = [1, 2, 3];\nfor x in IntoIter::new(arr) {\n    println!(\"{}\", x);\n}\n```\n\n**TODO**:\n- [x] Get initial feedback\n- [x] Add tests\n- [x] Figure out why stage1 produces weird bugs ([comment](https://github.com/rust-lang/rust/pull/62959#issuecomment-516016524))\n- [x] Add UI tests as mentioned [here](https://github.com/rust-lang/rust/pull/62959#discussion_r307061894) (will do that soon-ish)\n- [x] Fix [this new bug](https://github.com/rust-lang/rust/pull/62959#issuecomment-544732159)\n\n**Notes for reviewers**\n- Is the use of `MaybeUninit` correct here? I think it has to be used due to the `Clone` impl which has to fill the dead array elements with something, but cannot fill it with a correct instance.\n- Are the unit tests sufficient?\n\nCC #25725", "tree": {"sha": "5d0d9f9038a5bdeaa7a1b74190d9ddbf9784cb46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d0d9f9038a5bdeaa7a1b74190d9ddbf9784cb46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a302155344af987a6ae4aab6cf820e279bbdcf63", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdsnd5CRBK7hj4Ov3rIwAAdHIIAId6sQkTX7tZcNCMabF73AmB\naxcTWlN1u/PEsYyLi+g44i7YcKzN+LMu0IQDCDOTeCeAt4brlbL/4uzREgomzWUd\nhvPjqEJ/z1qsGSB9YiwvqLmogTr8n92pWBlhM+kKpJAf+wN2A3/geGl21qA0ACyF\nH5zgNXh3Ia9mSd+UCEfM6kCeMx7HKyh4Bahgn6SuGvW1anpIOPU+BhKol+sdNXSD\nHGuWKNBIlJHcA4rSzv99nuxtHAuLg+QWJJtWN3QmpLam63iQn5POg9ZLB8Y43EVe\nq72M90rEY7XfEsV46KbvKnxzlPhWty57Ey0yuz9XYS1RJ4mA6ZGEpK5MZ5Pgbm4=\n=z2JP\n-----END PGP SIGNATURE-----\n", "payload": "tree 5d0d9f9038a5bdeaa7a1b74190d9ddbf9784cb46\nparent d54111afc061ef398cd8ce28984f9e8d70001b24\nparent c36b9ddcb40b81642cef2d1dd17bcd45f54c70da\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1571977081 +0200\ncommitter GitHub <noreply@github.com> 1571977081 +0200\n\nRollup merge of #62959 - LukasKalbertodt:array-value-iter, r=scottmcm\n\nAdd by-value iterator for arrays\n\nThis adds an iterator that can iterate over arrays by value, yielding all elements by value. However, **this PR does _not_ add a corresponding `IntoIterator` impl for arrays**. The `IntoIterator` impl needs some discussion about backwards-compatibility that should take place in a separate PR. With this patch, this code should work (but there is currently still a bug):\n\n```rust\n#![feature(array_value_iter)]\nuse std::array::IntoIter;\n\nlet arr = [1, 2, 3];\nfor x in IntoIter::new(arr) {\n    println!(\"{}\", x);\n}\n```\n\n**TODO**:\n- [x] Get initial feedback\n- [x] Add tests\n- [x] Figure out why stage1 produces weird bugs ([comment](https://github.com/rust-lang/rust/pull/62959#issuecomment-516016524))\n- [x] Add UI tests as mentioned [here](https://github.com/rust-lang/rust/pull/62959#discussion_r307061894) (will do that soon-ish)\n- [x] Fix [this new bug](https://github.com/rust-lang/rust/pull/62959#issuecomment-544732159)\n\n**Notes for reviewers**\n- Is the use of `MaybeUninit` correct here? I think it has to be used due to the `Clone` impl which has to fill the dead array elements with something, but cannot fill it with a correct instance.\n- Are the unit tests sufficient?\n\nCC #25725\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a302155344af987a6ae4aab6cf820e279bbdcf63", "html_url": "https://github.com/rust-lang/rust/commit/a302155344af987a6ae4aab6cf820e279bbdcf63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a302155344af987a6ae4aab6cf820e279bbdcf63/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d54111afc061ef398cd8ce28984f9e8d70001b24", "url": "https://api.github.com/repos/rust-lang/rust/commits/d54111afc061ef398cd8ce28984f9e8d70001b24", "html_url": "https://github.com/rust-lang/rust/commit/d54111afc061ef398cd8ce28984f9e8d70001b24"}, {"sha": "c36b9ddcb40b81642cef2d1dd17bcd45f54c70da", "url": "https://api.github.com/repos/rust-lang/rust/commits/c36b9ddcb40b81642cef2d1dd17bcd45f54c70da", "html_url": "https://github.com/rust-lang/rust/commit/c36b9ddcb40b81642cef2d1dd17bcd45f54c70da"}], "stats": {"total": 697, "additions": 696, "deletions": 1}, "files": [{"sha": "850a599c6599f46de6858786e3335d87ce30f04e", "filename": "src/libcore/array/iter.rs", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/a302155344af987a6ae4aab6cf820e279bbdcf63/src%2Flibcore%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a302155344af987a6ae4aab6cf820e279bbdcf63/src%2Flibcore%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray%2Fiter.rs?ref=a302155344af987a6ae4aab6cf820e279bbdcf63", "patch": "@@ -0,0 +1,266 @@\n+//! Defines the `IntoIter` owned iterator for arrays.\n+\n+use crate::{\n+    fmt,\n+    iter::{ExactSizeIterator, FusedIterator, TrustedLen},\n+    mem::{self, MaybeUninit},\n+    ops::Range,\n+    ptr,\n+};\n+use super::LengthAtMost32;\n+\n+\n+/// A by-value [array] iterator.\n+///\n+/// [array]: ../../std/primitive.array.html\n+#[unstable(feature = \"array_value_iter\", issue = \"0\")]\n+pub struct IntoIter<T, const N: usize>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    /// This is the array we are iterating over.\n+    ///\n+    /// Elements with index `i` where `alive.start <= i < alive.end` have not\n+    /// been yielded yet and are valid array entries. Elements with indices `i\n+    /// < alive.start` or `i >= alive.end` have been yielded already and must\n+    /// not be accessed anymore! Those dead elements might even be in a\n+    /// completely uninitialized state!\n+    ///\n+    /// So the invariants are:\n+    /// - `data[alive]` is alive (i.e. contains valid elements)\n+    /// - `data[..alive.start]` and `data[alive.end..]` are dead (i.e. the\n+    ///   elements were already read and must not be touched anymore!)\n+    data: [MaybeUninit<T>; N],\n+\n+    /// The elements in `data` that have not been yielded yet.\n+    ///\n+    /// Invariants:\n+    /// - `alive.start <= alive.end`\n+    /// - `alive.end <= N`\n+    alive: Range<usize>,\n+}\n+\n+impl<T, const N: usize> IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    /// Creates a new iterator over the given `array`.\n+    ///\n+    /// *Note*: this method might never get stabilized and/or removed in the\n+    /// future as there will likely be another, preferred way of obtaining this\n+    /// iterator (either via `IntoIterator` for arrays or via another way).\n+    #[unstable(feature = \"array_value_iter\", issue = \"0\")]\n+    pub fn new(array: [T; N]) -> Self {\n+        // The transmute here is actually safe. The docs of `MaybeUninit`\n+        // promise:\n+        //\n+        // > `MaybeUninit<T>` is guaranteed to have the same size and alignment\n+        // > as `T`.\n+        //\n+        // The docs even show a transmute from an array of `MaybeUninit<T>` to\n+        // an array of `T`.\n+        //\n+        // With that, this initialization satisfies the invariants.\n+\n+        // FIXME(LukasKalbertodt): actually use `mem::transmute` here, once it\n+        // works with const generics:\n+        //     `mem::transmute::<[T; {N}], [MaybeUninit<T>; {N}]>(array)`\n+        //\n+        // Until then, we do it manually here. We first create a bitwise copy\n+        // but cast the pointer so that it is treated as a different type. Then\n+        // we forget `array` so that it is not dropped.\n+        let data = unsafe {\n+            let data = ptr::read(&array as *const [T; N] as *const [MaybeUninit<T>; N]);\n+            mem::forget(array);\n+            data\n+        };\n+\n+        Self {\n+            data,\n+            alive: 0..N,\n+        }\n+    }\n+\n+    /// Returns an immutable slice of all elements that have not been yielded\n+    /// yet.\n+    fn as_slice(&self) -> &[T] {\n+        // This transmute is safe. As mentioned in `new`, `MaybeUninit` retains\n+        // the size and alignment of `T`. Furthermore, we know that all\n+        // elements within `alive` are properly initialized.\n+        let slice = &self.data[self.alive.clone()];\n+        unsafe {\n+            mem::transmute::<&[MaybeUninit<T>], &[T]>(slice)\n+        }\n+    }\n+}\n+\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+impl<T, const N: usize> Iterator for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    type Item = T;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.alive.start == self.alive.end {\n+            return None;\n+        }\n+\n+        // Bump start index.\n+        //\n+        // From the check above we know that `alive.start != alive.end`.\n+        // Combine this with the invariant `alive.start <= alive.end`, we know\n+        // that `alive.start < alive.end`. Increasing `alive.start` by 1\n+        // maintains the invariant regarding `alive`. However, due to this\n+        // change, for a short time, the alive zone is not `data[alive]`\n+        // anymore, but `data[idx..alive.end]`.\n+        let idx = self.alive.start;\n+        self.alive.start += 1;\n+\n+        // Read the element from the array. This is safe: `idx` is an index\n+        // into the \"alive\" region of the array. Reading this element means\n+        // that `data[idx]` is regarded as dead now (i.e. do not touch). As\n+        // `idx` was the start of the alive-zone, the alive zone is now\n+        // `data[alive]` again, restoring all invariants.\n+        let out = unsafe { self.data.get_unchecked(idx).read() };\n+\n+        Some(out)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let len = self.len();\n+        (len, Some(len))\n+    }\n+\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+impl<T, const N: usize> DoubleEndedIterator for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        if self.alive.start == self.alive.end {\n+            return None;\n+        }\n+\n+        // Decrease end index.\n+        //\n+        // From the check above we know that `alive.start != alive.end`.\n+        // Combine this with the invariant `alive.start <= alive.end`, we know\n+        // that `alive.start < alive.end`. As `alive.start` cannot be negative,\n+        // `alive.end` is at least 1, meaning that we can safely decrement it\n+        // by one. This also maintains the invariant `alive.start <=\n+        // alive.end`. However, due to this change, for a short time, the alive\n+        // zone is not `data[alive]` anymore, but `data[alive.start..alive.end\n+        // + 1]`.\n+        self.alive.end -= 1;\n+\n+        // Read the element from the array. This is safe: `alive.end` is an\n+        // index into the \"alive\" region of the array. Compare the previous\n+        // comment that states that the alive region is\n+        // `data[alive.start..alive.end + 1]`. Reading this element means that\n+        // `data[alive.end]` is regarded as dead now (i.e. do not touch). As\n+        // `alive.end` was the end of the alive-zone, the alive zone is now\n+        // `data[alive]` again, restoring all invariants.\n+        let out = unsafe { self.data.get_unchecked(self.alive.end).read() };\n+\n+        Some(out)\n+    }\n+}\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+impl<T, const N: usize> Drop for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn drop(&mut self) {\n+        // We simply drop each element via `for_each`. This should not incur\n+        // any significant runtime overhead and avoids adding another `unsafe`\n+        // block.\n+        self.by_ref().for_each(drop);\n+    }\n+}\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+impl<T, const N: usize> ExactSizeIterator for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn len(&self) -> usize {\n+        // Will never underflow due to the invariant `alive.start <=\n+        // alive.end`.\n+        self.alive.end - self.alive.start\n+    }\n+    fn is_empty(&self) -> bool {\n+        self.alive.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+impl<T, const N: usize> FusedIterator for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{}\n+\n+// The iterator indeed reports the correct length. The number of \"alive\"\n+// elements (that will still be yielded) is the length of the range `alive`.\n+// This range is decremented in length in either `next` or `next_back`. It is\n+// always decremented by 1 in those methods, but only if `Some(_)` is returned.\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+unsafe impl<T, const N: usize> TrustedLen for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{}\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+impl<T: Clone, const N: usize> Clone for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn clone(&self) -> Self {\n+        unsafe {\n+            // This creates a new uninitialized array. Note that the `assume_init`\n+            // refers to the array, not the individual elements. And it is Ok if\n+            // the array is in an uninitialized state as all elements may be\n+            // uninitialized (all bit patterns are valid). Compare the\n+            // `MaybeUninit` docs for more information.\n+            let mut new_data: [MaybeUninit<T>; N] = MaybeUninit::uninit().assume_init();\n+\n+            // Clone all alive elements.\n+            for idx in self.alive.clone() {\n+                // The element at `idx` in the old array is alive, so we can\n+                // safely call `get_ref()`. We then clone it, and write the\n+                // clone into the new array.\n+                let clone = self.data.get_unchecked(idx).get_ref().clone();\n+                new_data.get_unchecked_mut(idx).write(clone);\n+            }\n+\n+            Self {\n+                data: new_data,\n+                alive: self.alive.clone(),\n+            }\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"array_value_iter_impls\", since = \"1.38.0\")]\n+impl<T: fmt::Debug, const N: usize> fmt::Debug for IntoIter<T, {N}>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // Only print the elements that were not yielded yet: we cannot\n+        // access the yielded elements anymore.\n+        f.debug_tuple(\"IntoIter\")\n+            .field(&self.as_slice())\n+            .finish()\n+    }\n+}"}, {"sha": "120658e9a4343caee366b45152b44c52c8663986", "filename": "src/libcore/array/mod.rs", "status": "renamed", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a302155344af987a6ae4aab6cf820e279bbdcf63/src%2Flibcore%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a302155344af987a6ae4aab6cf820e279bbdcf63/src%2Flibcore%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray%2Fmod.rs?ref=a302155344af987a6ae4aab6cf820e279bbdcf63", "patch": "@@ -14,6 +14,13 @@ use crate::hash::{Hash, self};\n use crate::marker::Unsize;\n use crate::slice::{Iter, IterMut};\n \n+#[cfg(not(bootstrap))]\n+mod iter;\n+\n+#[cfg(not(bootstrap))]\n+#[unstable(feature = \"array_value_iter\", issue = \"0\")]\n+pub use iter::IntoIter;\n+\n /// Utility trait implemented only on arrays of fixed size\n ///\n /// This trait can be used to implement other traits on fixed-size arrays", "previous_filename": "src/libcore/array.rs"}, {"sha": "4f3b79c78b66c58d6d604800134a9173af9b1df5", "filename": "src/libcore/tests/array.rs", "status": "modified", "additions": 206, "deletions": 1, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/a302155344af987a6ae4aab6cf820e279bbdcf63/src%2Flibcore%2Ftests%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a302155344af987a6ae4aab6cf820e279bbdcf63/src%2Flibcore%2Ftests%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Farray.rs?ref=a302155344af987a6ae4aab6cf820e279bbdcf63", "patch": "@@ -1,4 +1,4 @@\n-use core::array::FixedSizeArray;\n+use core::array::{FixedSizeArray, IntoIter};\n use core::convert::TryFrom;\n \n #[test]\n@@ -40,3 +40,208 @@ fn array_try_from() {\n         30 31 32\n     }\n }\n+\n+\n+#[test]\n+fn iterator_collect() {\n+    let arr = [0, 1, 2, 5, 9];\n+    let v: Vec<_> = IntoIter::new(arr.clone()).collect();\n+    assert_eq!(&arr[..], &v[..]);\n+}\n+\n+#[test]\n+fn iterator_rev_collect() {\n+    let arr = [0, 1, 2, 5, 9];\n+    let v: Vec<_> = IntoIter::new(arr.clone()).rev().collect();\n+    assert_eq!(&v[..], &[9, 5, 2, 1, 0]);\n+}\n+\n+#[test]\n+fn iterator_nth() {\n+    let v = [0, 1, 2, 3, 4];\n+    for i in 0..v.len() {\n+        assert_eq!(IntoIter::new(v.clone()).nth(i).unwrap(), v[i]);\n+    }\n+    assert_eq!(IntoIter::new(v.clone()).nth(v.len()), None);\n+\n+    let mut iter = IntoIter::new(v);\n+    assert_eq!(iter.nth(2).unwrap(), v[2]);\n+    assert_eq!(iter.nth(1).unwrap(), v[4]);\n+}\n+\n+#[test]\n+fn iterator_last() {\n+    let v = [0, 1, 2, 3, 4];\n+    assert_eq!(IntoIter::new(v).last().unwrap(), 4);\n+    assert_eq!(IntoIter::new([0]).last().unwrap(), 0);\n+\n+    let mut it = IntoIter::new([0, 9, 2, 4]);\n+    assert_eq!(it.next_back(), Some(4));\n+    assert_eq!(it.last(), Some(2));\n+}\n+\n+#[test]\n+fn iterator_clone() {\n+    let mut it = IntoIter::new([0, 2, 4, 6, 8]);\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next_back(), Some(8));\n+    let mut clone = it.clone();\n+    assert_eq!(it.next_back(), Some(6));\n+    assert_eq!(clone.next_back(), Some(6));\n+    assert_eq!(it.next_back(), Some(4));\n+    assert_eq!(clone.next_back(), Some(4));\n+    assert_eq!(it.next(), Some(2));\n+    assert_eq!(clone.next(), Some(2));\n+}\n+\n+#[test]\n+fn iterator_fused() {\n+    let mut it = IntoIter::new([0, 9, 2]);\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next(), Some(9));\n+    assert_eq!(it.next(), Some(2));\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn iterator_len() {\n+    let mut it = IntoIter::new([0, 1, 2, 5, 9]);\n+    assert_eq!(it.size_hint(), (5, Some(5)));\n+    assert_eq!(it.len(), 5);\n+    assert_eq!(it.is_empty(), false);\n+\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.size_hint(), (4, Some(4)));\n+    assert_eq!(it.len(), 4);\n+    assert_eq!(it.is_empty(), false);\n+\n+    assert_eq!(it.next_back(), Some(9));\n+    assert_eq!(it.size_hint(), (3, Some(3)));\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.is_empty(), false);\n+\n+    // Empty\n+    let it = IntoIter::new([] as [String; 0]);\n+    assert_eq!(it.size_hint(), (0, Some(0)));\n+    assert_eq!(it.len(), 0);\n+    assert_eq!(it.is_empty(), true);\n+}\n+\n+#[test]\n+fn iterator_count() {\n+    let v = [0, 1, 2, 3, 4];\n+    assert_eq!(IntoIter::new(v.clone()).count(), 5);\n+\n+    let mut iter2 = IntoIter::new(v);\n+    iter2.next();\n+    iter2.next();\n+    assert_eq!(iter2.count(), 3);\n+}\n+\n+#[test]\n+fn iterator_flat_map() {\n+    assert!((0..5).flat_map(|i| IntoIter::new([2 * i, 2 * i + 1])).eq(0..10));\n+}\n+\n+#[test]\n+fn iterator_debug() {\n+    let arr = [0, 1, 2, 5, 9];\n+    assert_eq!(\n+        format!(\"{:?}\", IntoIter::new(arr)),\n+        \"IntoIter([0, 1, 2, 5, 9])\",\n+    );\n+}\n+\n+#[test]\n+fn iterator_drops() {\n+    use core::cell::Cell;\n+\n+    // This test makes sure the correct number of elements are dropped. The `R`\n+    // type is just a reference to a `Cell` that is incremented when an `R` is\n+    // dropped.\n+\n+    #[derive(Clone)]\n+    struct Foo<'a>(&'a Cell<usize>);\n+\n+    impl Drop for Foo<'_> {\n+       fn drop(&mut self) {\n+            self.0.set(self.0.get() + 1);\n+        }\n+    }\n+\n+    fn five(i: &Cell<usize>) -> [Foo<'_>; 5] {\n+        // This is somewhat verbose because `Foo` does not implement `Copy`\n+        // since it implements `Drop`. Consequently, we cannot write\n+        // `[Foo(i); 5]`.\n+        [Foo(i), Foo(i), Foo(i), Foo(i), Foo(i)]\n+    }\n+\n+    // Simple: drop new iterator.\n+    let i = Cell::new(0);\n+    {\n+        IntoIter::new(five(&i));\n+    }\n+    assert_eq!(i.get(), 5);\n+\n+    // Call `next()` once.\n+    let i = Cell::new(0);\n+    {\n+        let mut iter = IntoIter::new(five(&i));\n+        let _x = iter.next();\n+        assert_eq!(i.get(), 0);\n+        assert_eq!(iter.count(), 4);\n+        assert_eq!(i.get(), 4);\n+    }\n+    assert_eq!(i.get(), 5);\n+\n+    // Check `clone` and calling `next`/`next_back`.\n+    let i = Cell::new(0);\n+    {\n+        let mut iter = IntoIter::new(five(&i));\n+        iter.next();\n+        assert_eq!(i.get(), 1);\n+        iter.next_back();\n+        assert_eq!(i.get(), 2);\n+\n+        let mut clone = iter.clone();\n+        assert_eq!(i.get(), 2);\n+\n+        iter.next();\n+        assert_eq!(i.get(), 3);\n+\n+        clone.next();\n+        assert_eq!(i.get(), 4);\n+\n+        assert_eq!(clone.count(), 2);\n+        assert_eq!(i.get(), 6);\n+    }\n+    assert_eq!(i.get(), 8);\n+\n+    // Check via `nth`.\n+    let i = Cell::new(0);\n+    {\n+        let mut iter = IntoIter::new(five(&i));\n+        let _x = iter.nth(2);\n+        assert_eq!(i.get(), 2);\n+        let _y = iter.last();\n+        assert_eq!(i.get(), 3);\n+    }\n+    assert_eq!(i.get(), 5);\n+\n+    // Check every element.\n+    let i = Cell::new(0);\n+    for (index, _x) in IntoIter::new(five(&i)).enumerate() {\n+        assert_eq!(i.get(), index);\n+    }\n+    assert_eq!(i.get(), 5);\n+\n+    let i = Cell::new(0);\n+    for (index, _x) in IntoIter::new(five(&i)).rev().enumerate() {\n+        assert_eq!(i.get(), index);\n+    }\n+    assert_eq!(i.get(), 5);\n+}"}, {"sha": "b28ed2eaa0876ad6af9fb264eed6cc736b2cadb6", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a302155344af987a6ae4aab6cf820e279bbdcf63/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a302155344af987a6ae4aab6cf820e279bbdcf63/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=a302155344af987a6ae4aab6cf820e279bbdcf63", "patch": "@@ -31,6 +31,7 @@\n #![feature(slice_partition_dedup)]\n #![feature(int_error_matching)]\n #![feature(const_fn)]\n+#![feature(array_value_iter)]\n #![feature(iter_partition_in_place)]\n #![feature(iter_is_partitioned)]\n #![feature(iter_order_by)]"}, {"sha": "0aeba8607e818b774b82c596ffbc57f084f1ac0f", "filename": "src/test/ui/const-generics/array-impls/into-iter-impls-length-32.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a302155344af987a6ae4aab6cf820e279bbdcf63/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Finto-iter-impls-length-32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a302155344af987a6ae4aab6cf820e279bbdcf63/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Finto-iter-impls-length-32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Finto-iter-impls-length-32.rs?ref=a302155344af987a6ae4aab6cf820e279bbdcf63", "patch": "@@ -0,0 +1,41 @@\n+// check-pass\n+\n+#![feature(array_value_iter)]\n+#![feature(trusted_len)]\n+\n+use std::{\n+    array::IntoIter,\n+    fmt::Debug,\n+    iter::{ExactSizeIterator, FusedIterator, TrustedLen},\n+};\n+\n+pub fn yes_iterator() -> impl Iterator<Item = i32> {\n+    IntoIter::new([0i32; 32])\n+}\n+\n+pub fn yes_double_ended_iterator() -> impl DoubleEndedIterator {\n+    IntoIter::new([0i32; 32])\n+}\n+\n+pub fn yes_exact_size_iterator() -> impl ExactSizeIterator {\n+    IntoIter::new([0i32; 32])\n+}\n+\n+pub fn yes_fused_iterator() -> impl FusedIterator {\n+    IntoIter::new([0i32; 32])\n+}\n+\n+pub fn yes_trusted_len() -> impl TrustedLen {\n+    IntoIter::new([0i32; 32])\n+}\n+\n+pub fn yes_clone() -> impl Clone {\n+    IntoIter::new([0i32; 32])\n+}\n+\n+pub fn yes_debug() -> impl Debug {\n+    IntoIter::new([0i32; 32])\n+}\n+\n+\n+fn main() {}"}, {"sha": "a0bbd2ce64add0adfe8ba440d30b47fade1407c8", "filename": "src/test/ui/const-generics/array-impls/into-iter-no-impls-length-33.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a302155344af987a6ae4aab6cf820e279bbdcf63/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Finto-iter-no-impls-length-33.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a302155344af987a6ae4aab6cf820e279bbdcf63/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Finto-iter-no-impls-length-33.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Finto-iter-no-impls-length-33.rs?ref=a302155344af987a6ae4aab6cf820e279bbdcf63", "patch": "@@ -0,0 +1,53 @@\n+#![feature(array_value_iter)]\n+#![feature(trusted_len)]\n+\n+use std::{\n+    array::IntoIter,\n+    fmt::Debug,\n+    iter::{ExactSizeIterator, FusedIterator, TrustedLen},\n+};\n+\n+pub fn no_iterator() -> impl Iterator<Item = i32> {\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+    IntoIter::new([0i32; 33])\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+}\n+\n+pub fn no_double_ended_iterator() -> impl DoubleEndedIterator {\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+    IntoIter::new([0i32; 33])\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+}\n+\n+pub fn no_exact_size_iterator() -> impl ExactSizeIterator {\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+    IntoIter::new([0i32; 33])\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+}\n+\n+pub fn no_fused_iterator() -> impl FusedIterator {\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+    IntoIter::new([0i32; 33])\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+}\n+\n+pub fn no_trusted_len() -> impl TrustedLen {\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+    IntoIter::new([0i32; 33])\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+}\n+\n+pub fn no_clone() -> impl Clone {\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+    IntoIter::new([0i32; 33])\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+}\n+\n+pub fn no_debug() -> impl Debug {\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+    IntoIter::new([0i32; 33])\n+    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n+}\n+\n+\n+fn main() {}"}, {"sha": "bfdff8e3bbe61599026772b8321c1bff56deab25", "filename": "src/test/ui/const-generics/array-impls/into-iter-no-impls-length-33.stderr", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/a302155344af987a6ae4aab6cf820e279bbdcf63/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Finto-iter-no-impls-length-33.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a302155344af987a6ae4aab6cf820e279bbdcf63/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Finto-iter-no-impls-length-33.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Finto-iter-no-impls-length-33.stderr?ref=a302155344af987a6ae4aab6cf820e279bbdcf63", "patch": "@@ -0,0 +1,122 @@\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:12:5\n+   |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required by `std::array::IntoIter::<T, N>::new`\n+\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:10:25\n+   |\n+LL | pub fn no_iterator() -> impl Iterator<Item = i32> {\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required because of the requirements on the impl of `std::iter::Iterator` for `std::array::IntoIter<i32, 33usize>`\n+   = note: the return type of a function must have a statically known size\n+\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:18:5\n+   |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required by `std::array::IntoIter::<T, N>::new`\n+\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:16:38\n+   |\n+LL | pub fn no_double_ended_iterator() -> impl DoubleEndedIterator {\n+   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required because of the requirements on the impl of `std::iter::DoubleEndedIterator` for `std::array::IntoIter<i32, 33usize>`\n+   = note: the return type of a function must have a statically known size\n+\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:24:5\n+   |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required by `std::array::IntoIter::<T, N>::new`\n+\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:22:36\n+   |\n+LL | pub fn no_exact_size_iterator() -> impl ExactSizeIterator {\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required because of the requirements on the impl of `std::iter::ExactSizeIterator` for `std::array::IntoIter<i32, 33usize>`\n+   = note: the return type of a function must have a statically known size\n+\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:30:5\n+   |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required by `std::array::IntoIter::<T, N>::new`\n+\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:28:31\n+   |\n+LL | pub fn no_fused_iterator() -> impl FusedIterator {\n+   |                               ^^^^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required because of the requirements on the impl of `std::iter::FusedIterator` for `std::array::IntoIter<i32, 33usize>`\n+   = note: the return type of a function must have a statically known size\n+\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:36:5\n+   |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required by `std::array::IntoIter::<T, N>::new`\n+\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:34:28\n+   |\n+LL | pub fn no_trusted_len() -> impl TrustedLen {\n+   |                            ^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required because of the requirements on the impl of `std::iter::TrustedLen` for `std::array::IntoIter<i32, 33usize>`\n+   = note: the return type of a function must have a statically known size\n+\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:42:5\n+   |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required by `std::array::IntoIter::<T, N>::new`\n+\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:40:22\n+   |\n+LL | pub fn no_clone() -> impl Clone {\n+   |                      ^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required because of the requirements on the impl of `std::clone::Clone` for `std::array::IntoIter<i32, 33usize>`\n+   = note: the return type of a function must have a statically known size\n+\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:48:5\n+   |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required by `std::array::IntoIter::<T, N>::new`\n+\n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/into-iter-no-impls-length-33.rs:46:22\n+   |\n+LL | pub fn no_debug() -> impl Debug {\n+   |                      ^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+   |\n+   = note: required because of the requirements on the impl of `std::fmt::Debug` for `std::array::IntoIter<i32, 33usize>`\n+   = note: the return type of a function must have a statically known size\n+\n+error: aborting due to 14 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}]}