{"sha": "7bf54f90d619fc87af4c8b660a80166c40048cb5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiZjU0ZjkwZDYxOWZjODdhZjRjOGI2NjBhODAxNjZjNDAwNDhjYjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-05T21:42:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-05T21:42:42Z"}, "message": "Auto merge of #35116 - jseyfried:groundwork_for_new_import_semantics, r=nrc\n\nresolve: diagnostics improvement and groundwork for RFC 1560\n\nFixes #35115, fixes #35135, and lays groundwork for #32213 (cc #35120).\nr? @nrc", "tree": {"sha": "464e7696a161be9b18da8ae57f2a5954e44bbf80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/464e7696a161be9b18da8ae57f2a5954e44bbf80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bf54f90d619fc87af4c8b660a80166c40048cb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bf54f90d619fc87af4c8b660a80166c40048cb5", "html_url": "https://github.com/rust-lang/rust/commit/7bf54f90d619fc87af4c8b660a80166c40048cb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bf54f90d619fc87af4c8b660a80166c40048cb5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b30eff7ba72a78e31acd61a2b6931919a0ad62e8", "html_url": "https://github.com/rust-lang/rust/commit/b30eff7ba72a78e31acd61a2b6931919a0ad62e8"}, {"sha": "de5eaab87c03c60cf7785b5d1abeec9f56619b66", "url": "https://api.github.com/repos/rust-lang/rust/commits/de5eaab87c03c60cf7785b5d1abeec9f56619b66", "html_url": "https://github.com/rust-lang/rust/commit/de5eaab87c03c60cf7785b5d1abeec9f56619b66"}], "stats": {"total": 441, "additions": 223, "deletions": 218}, "files": [{"sha": "93c6dd09e07b83d2c450f2b97f223b6d8c828b29", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7bf54f90d619fc87af4c8b660a80166c40048cb5/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bf54f90d619fc87af4c8b660a80166c40048cb5/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=7bf54f90d619fc87af4c8b660a80166c40048cb5", "patch": "@@ -17,7 +17,6 @@\n //!   - not reference the erased type `Self` except for in this receiver;\n //!   - not have generic type parameters\n \n-use super::supertraits;\n use super::elaborate_predicates;\n \n use hir::def_id::DefId;"}, {"sha": "116c1b7a6d06f811eb29829e316cfedfe093d1e6", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7bf54f90d619fc87af4c8b660a80166c40048cb5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bf54f90d619fc87af4c8b660a80166c40048cb5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=7bf54f90d619fc87af4c8b660a80166c40048cb5", "patch": "@@ -16,7 +16,7 @@\n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport};\n use Module;\n use Namespace::{self, TypeNS, ValueNS};\n-use {NameBinding, NameBindingKind};\n+use {NameBinding, NameBindingKind, ToNameBinding};\n use ParentLink::{ModuleParentLink, BlockParentLink};\n use Resolver;\n use {resolve_error, resolve_struct_error, ResolutionError};\n@@ -39,10 +39,6 @@ use syntax::visit::{self, Visitor};\n \n use syntax_pos::{Span, DUMMY_SP};\n \n-trait ToNameBinding<'a> {\n-    fn to_name_binding(self) -> NameBinding<'a>;\n-}\n-\n impl<'a> ToNameBinding<'a> for (Module<'a>, Span, ty::Visibility) {\n     fn to_name_binding(self) -> NameBinding<'a> {\n         NameBinding { kind: NameBindingKind::Module(self.0), span: self.1, vis: self.2 }\n@@ -68,18 +64,13 @@ impl<'b> Resolver<'b> {\n         visit::walk_crate(&mut visitor, krate);\n     }\n \n-    /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined.\n-    fn try_define<T>(&self, parent: Module<'b>, name: Name, ns: Namespace, def: T)\n-        where T: ToNameBinding<'b>\n-    {\n-        let _ = parent.try_define_child(name, ns, def.to_name_binding());\n-    }\n-\n     /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;\n     /// otherwise, reports an error.\n-    fn define<T: ToNameBinding<'b>>(&self, parent: Module<'b>, name: Name, ns: Namespace, def: T) {\n+    fn define<T>(&mut self, parent: Module<'b>, name: Name, ns: Namespace, def: T)\n+        where T: ToNameBinding<'b>,\n+    {\n         let binding = def.to_name_binding();\n-        if let Err(old_binding) = parent.try_define_child(name, ns, binding.clone()) {\n+        if let Err(old_binding) = self.try_define(parent, name, ns, binding.clone()) {\n             self.report_conflict(parent, name, ns, old_binding, &binding);\n         }\n     }\n@@ -399,14 +390,14 @@ impl<'b> Resolver<'b> {\n                        name, vis);\n                 let parent_link = ModuleParentLink(parent, name);\n                 let module = self.new_module(parent_link, Some(def), true);\n-                self.try_define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n+                let _ = self.try_define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n             }\n             Def::Variant(_, variant_id) => {\n                 debug!(\"(building reduced graph for external crate) building variant {}\", name);\n                 // Variants are always treated as importable to allow them to be glob used.\n                 // All variants are defined in both type and value namespaces as future-proofing.\n-                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n-                self.try_define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n+                let _ = self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n+                let _ = self.try_define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n                 if self.session.cstore.variant_kind(variant_id) == Some(VariantKind::Struct) {\n                     // Not adding fields for variants as they are not accessed with a self receiver\n                     self.structs.insert(variant_id, Vec::new());\n@@ -419,7 +410,7 @@ impl<'b> Resolver<'b> {\n             Def::Method(..) => {\n                 debug!(\"(building reduced graph for external crate) building value (fn/static) {}\",\n                        name);\n-                self.try_define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n+                let _ = self.try_define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n             }\n             Def::Trait(def_id) => {\n                 debug!(\"(building reduced graph for external crate) building type {}\", name);\n@@ -441,20 +432,20 @@ impl<'b> Resolver<'b> {\n \n                 let parent_link = ModuleParentLink(parent, name);\n                 let module = self.new_module(parent_link, Some(def), true);\n-                self.try_define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n+                let _ = self.try_define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n             }\n             Def::TyAlias(..) | Def::AssociatedTy(..) => {\n                 debug!(\"(building reduced graph for external crate) building type {}\", name);\n-                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n+                let _ = self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n             }\n             Def::Struct(def_id)\n                 if self.session.cstore.tuple_struct_definition_if_ctor(def_id).is_none() => {\n                 debug!(\"(building reduced graph for external crate) building type and value for {}\",\n                        name);\n-                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n+                let _ = self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n                 if let Some(ctor_def_id) = self.session.cstore.struct_ctor_def_id(def_id) {\n                     let def = Def::Struct(ctor_def_id);\n-                    self.try_define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n+                    let _ = self.try_define(parent, name, ValueNS, (def, DUMMY_SP, vis));\n                 }\n \n                 // Record the def ID and fields of this struct."}, {"sha": "befe328591121e2bb45b82c28b998c3448e6ea04", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 52, "deletions": 50, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/7bf54f90d619fc87af4c8b660a80166c40048cb5/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bf54f90d619fc87af4c8b660a80166c40048cb5/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7bf54f90d619fc87af4c8b660a80166c40048cb5", "patch": "@@ -158,7 +158,7 @@ enum ResolutionError<'a> {\n     /// error E0435: attempt to use a non-constant value in a constant\n     AttemptToUseNonConstantValueInConstant,\n     /// error E0530: X bindings cannot shadow Ys\n-    BindingShadowsSomethingUnacceptable(&'a str, &'a str, Name),\n+    BindingShadowsSomethingUnacceptable(&'a str, Name, &'a NameBinding<'a>),\n     /// error E0531: unresolved pattern path kind `name`\n     PatPathUnresolved(&'a str, &'a Path),\n     /// error E0532: expected pattern path kind, found another pattern path kind\n@@ -428,17 +428,16 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n                              E0435,\n                              \"attempt to use a non-constant value in a constant\")\n         }\n-        ResolutionError::BindingShadowsSomethingUnacceptable(what_binding, shadows_what, name) => {\n+        ResolutionError::BindingShadowsSomethingUnacceptable(what_binding, name, binding) => {\n+            let shadows_what = PathResolution::new(binding.def().unwrap()).kind_name();\n             let mut err = struct_span_err!(resolver.session,\n                                            span,\n                                            E0530,\n                                            \"{}s cannot shadow {}s\", what_binding, shadows_what);\n             err.span_label(span, &format!(\"cannot be named the same as a {}\", shadows_what));\n-            if let Success(binding) = resolver.current_module.resolve_name(name, ValueNS, true) {\n-                let participle = if binding.is_import() { \"imported\" } else { \"defined\" };\n-                err.span_label(binding.span, &format!(\"a {} `{}` is {} here\",\n-                                                      shadows_what, name, participle));\n-            }\n+            let participle = if binding.is_import() { \"imported\" } else { \"defined\" };\n+            let msg = &format!(\"a {} `{}` is {} here\", shadows_what, name, participle);\n+            err.span_label(binding.span, msg);\n             err\n         }\n         ResolutionError::PatPathUnresolved(expected_what, path) => {\n@@ -718,12 +717,16 @@ impl<'a> LexicalScopeBinding<'a> {\n         }\n     }\n \n-    fn module(self) -> Option<Module<'a>> {\n+    fn item(self) -> Option<&'a NameBinding<'a>> {\n         match self {\n-            LexicalScopeBinding::Item(binding) => binding.module(),\n+            LexicalScopeBinding::Item(binding) => Some(binding),\n             _ => None,\n         }\n     }\n+\n+    fn module(self) -> Option<Module<'a>> {\n+        self.item().and_then(NameBinding::module)\n+    }\n }\n \n /// The link from a module up to its nearest parent node.\n@@ -824,6 +827,16 @@ pub struct NameBinding<'a> {\n     vis: ty::Visibility,\n }\n \n+pub trait ToNameBinding<'a> {\n+    fn to_name_binding(self) -> NameBinding<'a>;\n+}\n+\n+impl<'a> ToNameBinding<'a> for NameBinding<'a> {\n+    fn to_name_binding(self) -> NameBinding<'a> {\n+        self\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n enum NameBindingKind<'a> {\n     Def(Def),\n@@ -1203,34 +1216,27 @@ impl<'a> Resolver<'a> {\n         match ns { ValueNS => &mut self.value_ribs, TypeNS => &mut self.type_ribs }\n     }\n \n-    #[inline]\n-    fn record_use(&mut self, name: Name, binding: &'a NameBinding<'a>) {\n+    fn record_use(&mut self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>) {\n         // track extern crates for unused_extern_crate lint\n         if let Some(DefId { krate, .. }) = binding.module().and_then(ModuleS::def_id) {\n             self.used_crates.insert(krate);\n         }\n \n-        let directive = match binding.kind {\n-            NameBindingKind::Import { directive, .. } => directive,\n-            _ => return,\n-        };\n-\n-        if !self.make_glob_map {\n-            return;\n-        }\n-        if self.glob_map.contains_key(&directive.id) {\n-            self.glob_map.get_mut(&directive.id).unwrap().insert(name);\n-            return;\n+        if let NameBindingKind::Import { directive, .. } = binding.kind {\n+            self.used_imports.insert((directive.id, ns));\n+            self.add_to_glob_map(directive.id, name);\n         }\n+    }\n \n-        let mut new_set = FnvHashSet();\n-        new_set.insert(name);\n-        self.glob_map.insert(directive.id, new_set);\n+    fn add_to_glob_map(&mut self, id: NodeId, name: Name) {\n+        if self.make_glob_map {\n+            self.glob_map.entry(id).or_insert_with(FnvHashSet).insert(name);\n+        }\n     }\n \n-    /// Resolves the given module path from the given root `module_`.\n+    /// Resolves the given module path from the given root `search_module`.\n     fn resolve_module_path_from_root(&mut self,\n-                                     module_: Module<'a>,\n+                                     mut search_module: Module<'a>,\n                                      module_path: &[Name],\n                                      index: usize,\n                                      span: Span)\n@@ -1247,7 +1253,6 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let mut search_module = module_;\n         let mut index = index;\n         let module_path_len = module_path.len();\n \n@@ -1444,31 +1449,30 @@ impl<'a> Resolver<'a> {\n     }\n \n     /// Returns the nearest normal module parent of the given module.\n-    fn get_nearest_normal_module_parent(&self, module_: Module<'a>) -> Option<Module<'a>> {\n-        let mut module_ = module_;\n+    fn get_nearest_normal_module_parent(&self, mut module: Module<'a>) -> Option<Module<'a>> {\n         loop {\n-            match module_.parent_link {\n+            match module.parent_link {\n                 NoParentLink => return None,\n                 ModuleParentLink(new_module, _) |\n                 BlockParentLink(new_module, _) => {\n                     let new_module = new_module;\n                     if new_module.is_normal() {\n                         return Some(new_module);\n                     }\n-                    module_ = new_module;\n+                    module = new_module;\n                 }\n             }\n         }\n     }\n \n     /// Returns the nearest normal module parent of the given module, or the\n     /// module itself if it is a normal module.\n-    fn get_nearest_normal_module_parent_or_self(&self, module_: Module<'a>) -> Module<'a> {\n-        if module_.is_normal() {\n-            return module_;\n+    fn get_nearest_normal_module_parent_or_self(&self, module: Module<'a>) -> Module<'a> {\n+        if module.is_normal() {\n+            return module;\n         }\n-        match self.get_nearest_normal_module_parent(module_) {\n-            None => module_,\n+        match self.get_nearest_normal_module_parent(module) {\n+            None => module,\n             Some(new_module) => new_module,\n         }\n     }\n@@ -1485,8 +1489,8 @@ impl<'a> Resolver<'a> {\n             \"super\" => 0,\n             _ => return Success(NoPrefixFound),\n         };\n-        let module_ = self.current_module;\n-        let mut containing_module = self.get_nearest_normal_module_parent_or_self(module_);\n+        let mut containing_module =\n+            self.get_nearest_normal_module_parent_or_self(self.current_module);\n \n         // Now loop through all the `super`s we find.\n         while i < module_path.len() && \"super\" == module_path[i].as_str() {\n@@ -1525,10 +1529,7 @@ impl<'a> Resolver<'a> {\n         self.populate_module_if_necessary(module);\n         module.resolve_name(name, namespace, use_lexical_scope).and_then(|binding| {\n             if record_used {\n-                if let NameBindingKind::Import { directive, .. } = binding.kind {\n-                    self.used_imports.insert((directive.id, namespace));\n-                }\n-                self.record_use(name, binding);\n+                self.record_use(name, namespace, binding);\n             }\n             Success(binding)\n         })\n@@ -2308,16 +2309,17 @@ impl<'a> Resolver<'a> {\n                 PatKind::Ident(bmode, ref ident, ref opt_pat) => {\n                     // First try to resolve the identifier as some existing\n                     // entity, then fall back to a fresh binding.\n-                    let resolution = self.resolve_identifier(ident.node, ValueNS, true)\n-                                         .map(|local_def| PathResolution::new(local_def.def))\n-                                         .and_then(|resolution| {\n+                    let binding = self.resolve_ident_in_lexical_scope(ident.node, ValueNS, false)\n+                                      .and_then(LexicalScopeBinding::item);\n+                    let resolution = binding.and_then(NameBinding::def).and_then(|def| {\n                         let always_binding = !pat_src.is_refutable() || opt_pat.is_some() ||\n                                              bmode != BindingMode::ByValue(Mutability::Immutable);\n-                        match resolution.base_def {\n+                        match def {\n                             Def::Struct(..) | Def::Variant(..) |\n                             Def::Const(..) | Def::AssociatedConst(..) if !always_binding => {\n                                 // A constant, unit variant, etc pattern.\n-                                Some(resolution)\n+                                self.record_use(ident.node.name, ValueNS, binding.unwrap());\n+                                Some(PathResolution::new(def))\n                             }\n                             Def::Struct(..) | Def::Variant(..) |\n                             Def::Const(..) | Def::AssociatedConst(..) | Def::Static(..) => {\n@@ -2326,7 +2328,7 @@ impl<'a> Resolver<'a> {\n                                     self,\n                                     ident.span,\n                                     ResolutionError::BindingShadowsSomethingUnacceptable(\n-                                        pat_src.descr(), resolution.kind_name(), ident.node.name)\n+                                        pat_src.descr(), ident.node.name, binding.unwrap())\n                                 );\n                                 None\n                             }\n@@ -3136,10 +3138,10 @@ impl<'a> Resolver<'a> {\n                         if let NameBindingKind::Import { directive, .. } = binding.kind {\n                             let id = directive.id;\n                             this.maybe_unused_trait_imports.insert(id);\n+                            this.add_to_glob_map(id, trait_name);\n                             import_id = Some(id);\n                         }\n                         add_trait_info(&mut found_traits, trait_def_id, import_id, name);\n-                        this.record_use(trait_name, binding);\n                     }\n                 }\n             };"}, {"sha": "6986f99926e1e43d9dd07874d5d25b29a9d4d6df", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 148, "deletions": 143, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/7bf54f90d619fc87af4c8b660a80166c40048cb5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bf54f90d619fc87af4c8b660a80166c40048cb5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=7bf54f90d619fc87af4c8b660a80166c40048cb5", "patch": "@@ -12,7 +12,7 @@ use self::ImportDirectiveSubclass::*;\n \n use Module;\n use Namespace::{self, TypeNS, ValueNS};\n-use {NameBinding, NameBindingKind, PrivacyError};\n+use {NameBinding, NameBindingKind, PrivacyError, ToNameBinding};\n use ResolveResult;\n use ResolveResult::*;\n use Resolver;\n@@ -21,7 +21,7 @@ use {names_to_string, module_to_string};\n use {resolve_error, ResolutionError};\n \n use rustc::ty;\n-use rustc::lint;\n+use rustc::lint::builtin::PRIVATE_IN_PUBLIC;\n use rustc::hir::def::*;\n \n use syntax::ast::{NodeId, Name};\n@@ -71,19 +71,6 @@ pub struct ImportDirective<'a> {\n }\n \n impl<'a> ImportDirective<'a> {\n-    // Given the binding to which this directive resolves in a particular namespace,\n-    // this returns the binding for the name this directive defines in that namespace.\n-    fn import(&'a self, binding: &'a NameBinding<'a>) -> NameBinding<'a> {\n-        NameBinding {\n-            kind: NameBindingKind::Import {\n-                binding: binding,\n-                directive: self,\n-            },\n-            span: self.span,\n-            vis: self.vis,\n-        }\n-    }\n-\n     pub fn is_glob(&self) -> bool {\n         match self.subclass { ImportDirectiveSubclass::GlobImport { .. } => true, _ => false }\n     }\n@@ -137,23 +124,6 @@ impl<'a> SingleImports<'a> {\n }\n \n impl<'a> NameResolution<'a> {\n-    fn try_define(&mut self, binding: &'a NameBinding<'a>) -> Result<(), &'a NameBinding<'a>> {\n-        if let Some(old_binding) = self.binding {\n-            if binding.is_glob_import() {\n-                self.duplicate_globs.push(binding);\n-            } else if old_binding.is_glob_import() {\n-                self.duplicate_globs.push(old_binding);\n-                self.binding = Some(binding);\n-            } else {\n-                return Err(old_binding);\n-            }\n-        } else {\n-            self.binding = Some(binding);\n-        }\n-\n-        Ok(())\n-    }\n-\n     // Returns the binding for the name if it is known or None if it not known.\n     fn binding(&self) -> Option<&'a NameBinding<'a>> {\n         self.binding.and_then(|binding| match self.single_imports {\n@@ -203,24 +173,6 @@ impl<'a> NameResolution<'a> {\n \n         self.binding.map(Success)\n     }\n-\n-    fn report_conflicts<F: FnMut(&NameBinding, &NameBinding)>(&self, mut report: F) {\n-        let binding = match self.binding {\n-            Some(binding) => binding,\n-            None => return,\n-        };\n-\n-        for duplicate_glob in self.duplicate_globs.iter() {\n-            // FIXME #31337: We currently allow items to shadow glob-imported re-exports.\n-            if !binding.is_import() {\n-                if let NameBindingKind::Import { binding, .. } = duplicate_glob.kind {\n-                    if binding.is_import() { continue }\n-                }\n-            }\n-\n-            report(duplicate_glob, binding);\n-        }\n-    }\n }\n \n impl<'a> ::ModuleS<'a> {\n@@ -261,14 +213,6 @@ impl<'a> ::ModuleS<'a> {\n         Failed(None)\n     }\n \n-    // Define the name or return the existing binding if there is a collision.\n-    pub fn try_define_child(&self, name: Name, ns: Namespace, binding: NameBinding<'a>)\n-                            -> Result<(), &'a NameBinding<'a>> {\n-        self.update_resolution(name, ns, |resolution| {\n-            resolution.try_define(self.arenas.alloc_name_binding(binding))\n-        })\n-    }\n-\n     pub fn add_import_directive(&self,\n                                 module_path: Vec<Name>,\n                                 subclass: ImportDirectiveSubclass,\n@@ -298,19 +242,59 @@ impl<'a> ::ModuleS<'a> {\n             GlobImport { .. } => self.globs.borrow_mut().push(directive),\n         }\n     }\n+}\n+\n+impl<'a> Resolver<'a> {\n+    // Given a binding and an import directive that resolves to it,\n+    // return the corresponding binding defined by the import directive.\n+    fn import(&mut self, binding: &'a NameBinding<'a>, directive: &'a ImportDirective<'a>)\n+              -> NameBinding<'a> {\n+        NameBinding {\n+            kind: NameBindingKind::Import {\n+                binding: binding,\n+                directive: directive,\n+            },\n+            span: directive.span,\n+            vis: directive.vis,\n+        }\n+    }\n \n-    // Use `update` to mutate the resolution for the name.\n+    // Define the name or return the existing binding if there is a collision.\n+    pub fn try_define<T>(&mut self, module: Module<'a>, name: Name, ns: Namespace, binding: T)\n+                         -> Result<(), &'a NameBinding<'a>>\n+        where T: ToNameBinding<'a>\n+    {\n+        let binding = self.arenas.alloc_name_binding(binding.to_name_binding());\n+        self.update_resolution(module, name, ns, |_, resolution| {\n+            if let Some(old_binding) = resolution.binding {\n+                if binding.is_glob_import() {\n+                    resolution.duplicate_globs.push(binding);\n+                } else if old_binding.is_glob_import() {\n+                    resolution.duplicate_globs.push(old_binding);\n+                    resolution.binding = Some(binding);\n+                } else {\n+                    return Err(old_binding);\n+                }\n+            } else {\n+                resolution.binding = Some(binding);\n+            }\n+\n+            Ok(())\n+        })\n+    }\n+\n+    // Use `f` to mutate the resolution of the name in the module.\n     // If the resolution becomes a success, define it in the module's glob importers.\n-    fn update_resolution<T, F>(&self, name: Name, ns: Namespace, update: F) -> T\n-        where F: FnOnce(&mut NameResolution<'a>) -> T\n+    fn update_resolution<T, F>(&mut self, module: Module<'a>, name: Name, ns: Namespace, f: F) -> T\n+        where F: FnOnce(&mut Resolver<'a>, &mut NameResolution<'a>) -> T\n     {\n-        // Ensure that `resolution` isn't borrowed during `define_in_glob_importers`,\n-        // where it might end up getting re-defined via a glob cycle.\n+        // Ensure that `resolution` isn't borrowed when defining in the module's glob importers,\n+        // during which the resolution might end up getting re-defined via a glob cycle.\n         let (new_binding, t) = {\n-            let mut resolution = &mut *self.resolution(name, ns).borrow_mut();\n+            let mut resolution = &mut *module.resolution(name, ns).borrow_mut();\n             let was_known = resolution.binding().is_some();\n \n-            let t = update(resolution);\n+            let t = f(self, resolution);\n \n             if was_known { return t; }\n             match resolution.binding() {\n@@ -319,15 +303,15 @@ impl<'a> ::ModuleS<'a> {\n             }\n         };\n \n-        self.define_in_glob_importers(name, ns, new_binding);\n-        t\n-    }\n-\n-    fn define_in_glob_importers(&self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>) {\n-        if !binding.is_importable() || !binding.is_pseudo_public() { return }\n-        for &(importer, directive) in self.glob_importers.borrow_mut().iter() {\n-            let _ = importer.try_define_child(name, ns, directive.import(binding));\n+        // Define `new_binding` in `module`s glob importers.\n+        if new_binding.is_importable() && new_binding.is_pseudo_public() {\n+            for &(importer, directive) in module.glob_importers.borrow_mut().iter() {\n+                let imported_binding = self.import(new_binding, directive);\n+                let _ = self.try_define(importer, name, ns, imported_binding);\n+            }\n         }\n+\n+        t\n     }\n }\n \n@@ -343,6 +327,25 @@ struct ImportResolver<'a, 'b: 'a> {\n     resolver: &'a mut Resolver<'b>,\n }\n \n+impl<'a, 'b: 'a> ::std::ops::Deref for ImportResolver<'a, 'b> {\n+    type Target = Resolver<'b>;\n+    fn deref(&self) -> &Resolver<'b> {\n+        self.resolver\n+    }\n+}\n+\n+impl<'a, 'b: 'a> ::std::ops::DerefMut for ImportResolver<'a, 'b> {\n+    fn deref_mut(&mut self) -> &mut Resolver<'b> {\n+        self.resolver\n+    }\n+}\n+\n+impl<'a, 'b: 'a> ty::NodeIdTree for ImportResolver<'a, 'b> {\n+    fn is_descendant_of(&self, node: NodeId, ancestor: NodeId) -> bool {\n+        self.resolver.is_descendant_of(node, ancestor)\n+    }\n+}\n+\n impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     // Import resolution\n     //\n@@ -360,31 +363,29 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         let mut errors = Vec::new();\n \n         loop {\n-            debug!(\"(resolving imports) iteration {}, {} imports left\",\n-                   i,\n-                   self.resolver.unresolved_imports);\n+            debug!(\"(resolving imports) iteration {}, {} imports left\", i, self.unresolved_imports);\n \n             // Attempt to resolve imports in all local modules.\n-            for module in self.resolver.arenas.local_modules().iter() {\n-                self.resolver.current_module = module;\n+            for module in self.arenas.local_modules().iter() {\n+                self.current_module = module;\n                 self.resolve_imports_in_current_module(&mut errors);\n             }\n \n-            if self.resolver.unresolved_imports == 0 {\n+            if self.unresolved_imports == 0 {\n                 debug!(\"(resolving imports) success\");\n-                for module in self.resolver.arenas.local_modules().iter() {\n+                for module in self.arenas.local_modules().iter() {\n                     self.finalize_resolutions_in(module, false);\n                 }\n                 break;\n             }\n \n-            if self.resolver.unresolved_imports == prev_unresolved_imports {\n+            if self.unresolved_imports == prev_unresolved_imports {\n                 // resolving failed\n                 // Report unresolved imports only if no hard error was already reported\n                 // to avoid generating multiple errors on the same import.\n                 // Imports that are still indeterminate at this point are actually blocked\n                 // by errored imports, so there is no point reporting them.\n-                for module in self.resolver.arenas.local_modules().iter() {\n+                for module in self.arenas.local_modules().iter() {\n                     self.finalize_resolutions_in(module, errors.len() == 0);\n                 }\n                 for e in errors {\n@@ -394,29 +395,31 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             }\n \n             i += 1;\n-            prev_unresolved_imports = self.resolver.unresolved_imports;\n+            prev_unresolved_imports = self.unresolved_imports;\n         }\n     }\n \n     // Define a \"dummy\" resolution containing a Def::Err as a placeholder for a\n     // failed resolution\n-    fn import_dummy_binding(&self, source_module: Module<'b>, directive: &'b ImportDirective<'b>) {\n+    fn import_dummy_binding(&mut self,\n+                            source_module: Module<'b>,\n+                            directive: &'b ImportDirective<'b>) {\n         if let SingleImport { target, .. } = directive.subclass {\n-            let dummy_binding = self.resolver.arenas.alloc_name_binding(NameBinding {\n+            let dummy_binding = self.arenas.alloc_name_binding(NameBinding {\n                 kind: NameBindingKind::Def(Def::Err),\n                 span: DUMMY_SP,\n                 vis: ty::Visibility::Public,\n             });\n-            let dummy_binding = directive.import(dummy_binding);\n+            let dummy_binding = self.import(dummy_binding, directive);\n \n-            let _ = source_module.try_define_child(target, ValueNS, dummy_binding.clone());\n-            let _ = source_module.try_define_child(target, TypeNS, dummy_binding);\n+            let _ = self.try_define(source_module, target, ValueNS, dummy_binding.clone());\n+            let _ = self.try_define(source_module, target, TypeNS, dummy_binding);\n         }\n     }\n \n     /// Resolves an `ImportResolvingError` into the correct enum discriminant\n     /// and passes that on to `resolve_error`.\n-    fn import_resolving_error(&self, e: ImportResolvingError<'b>) {\n+    fn import_resolving_error(&mut self, e: ImportResolvingError<'b>) {\n         // If the error is a single failed import then create a \"fake\" import\n         // resolution for it so that later resolve stages won't complain.\n         self.import_dummy_binding(e.source_module, e.import_directive);\n@@ -430,7 +433,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     /// Attempts to resolve imports for the given module only.\n     fn resolve_imports_in_current_module(&mut self, errors: &mut Vec<ImportResolvingError<'b>>) {\n         let mut imports = Vec::new();\n-        let mut unresolved_imports = self.resolver.current_module.unresolved_imports.borrow_mut();\n+        let mut unresolved_imports = self.current_module.unresolved_imports.borrow_mut();\n         ::std::mem::swap(&mut imports, &mut unresolved_imports);\n \n         for import_directive in imports {\n@@ -441,7 +444,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                         None => (import_directive.span, String::new()),\n                     };\n                     errors.push(ImportResolvingError {\n-                        source_module: self.resolver.current_module,\n+                        source_module: self.current_module,\n                         import_directive: import_directive,\n                         span: span,\n                         help: help,\n@@ -450,8 +453,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 Indeterminate => unresolved_imports.push(import_directive),\n                 Success(()) => {\n                     // Decrement the count of unresolved imports.\n-                    assert!(self.resolver.unresolved_imports >= 1);\n-                    self.resolver.unresolved_imports -= 1;\n+                    assert!(self.unresolved_imports >= 1);\n+                    self.unresolved_imports -= 1;\n                 }\n             }\n         }\n@@ -465,13 +468,13 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     fn resolve_import(&mut self, directive: &'b ImportDirective<'b>) -> ResolveResult<()> {\n         debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n                names_to_string(&directive.module_path),\n-               module_to_string(self.resolver.current_module));\n+               module_to_string(self.current_module));\n \n         let target_module = match directive.target_module.get() {\n             Some(module) => module,\n-            _ => match self.resolver.resolve_module_path(&directive.module_path,\n-                                                         DontUseLexicalScope,\n-                                                         directive.span) {\n+            _ => match self.resolve_module_path(&directive.module_path,\n+                                                DontUseLexicalScope,\n+                                                directive.span) {\n                 Success(module) => module,\n                 Indeterminate => return Indeterminate,\n                 Failed(err) => return Failed(err),\n@@ -486,38 +489,36 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         };\n \n         // We need to resolve both namespaces for this to succeed.\n-        let value_result =\n-            self.resolver.resolve_name_in_module(target_module, source, ValueNS, false, true);\n-        let type_result =\n-            self.resolver.resolve_name_in_module(target_module, source, TypeNS, false, true);\n+        let value_result = self.resolve_name_in_module(target_module, source, ValueNS, false, true);\n+        let type_result = self.resolve_name_in_module(target_module, source, TypeNS, false, true);\n \n-        let module_ = self.resolver.current_module;\n+        let module = self.current_module;\n         let mut privacy_error = true;\n         for &(ns, result, determined) in &[(ValueNS, &value_result, value_determined),\n                                            (TypeNS, &type_result, type_determined)] {\n             match *result {\n                 Failed(..) if !determined.get() => {\n                     determined.set(true);\n-                    module_.update_resolution(target, ns, |resolution| {\n+                    self.update_resolution(module, target, ns, |_, resolution| {\n                         resolution.single_imports.directive_failed()\n                     });\n                 }\n                 Success(binding) if !binding.is_importable() => {\n                     let msg = format!(\"`{}` is not directly importable\", target);\n-                    span_err!(self.resolver.session, directive.span, E0253, \"{}\", &msg);\n+                    span_err!(self.session, directive.span, E0253, \"{}\", &msg);\n                     // Do not import this illegal binding. Import a dummy binding and pretend\n                     // everything is fine\n-                    self.import_dummy_binding(module_, directive);\n+                    self.import_dummy_binding(module, directive);\n                     return Success(());\n                 }\n-                Success(binding) if !self.resolver.is_accessible(binding.vis) => {}\n+                Success(binding) if !self.is_accessible(binding.vis) => {}\n                 Success(binding) if !determined.get() => {\n                     determined.set(true);\n-                    let imported_binding = directive.import(binding);\n-                    let conflict = module_.try_define_child(target, ns, imported_binding);\n+                    let imported_binding = self.import(binding, directive);\n+                    let conflict = self.try_define(module, target, ns, imported_binding);\n                     if let Err(old_binding) = conflict {\n-                        let binding = &directive.import(binding);\n-                        self.resolver.report_conflict(module_, target, ns, binding, old_binding);\n+                        let binding = &self.import(binding, directive);\n+                        self.report_conflict(module, target, ns, binding, old_binding);\n                     }\n                     privacy_error = false;\n                 }\n@@ -556,39 +557,35 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         if privacy_error {\n             for &(ns, result) in &[(ValueNS, &value_result), (TypeNS, &type_result)] {\n                 let binding = match *result { Success(binding) => binding, _ => continue };\n-                self.resolver.privacy_errors.push(PrivacyError(directive.span, source, binding));\n-                let _ = module_.try_define_child(target, ns, directive.import(binding));\n+                self.privacy_errors.push(PrivacyError(directive.span, source, binding));\n+                let imported_binding = self.import(binding, directive);\n+                let _ = self.try_define(module, target, ns, imported_binding);\n             }\n         }\n \n         match (&value_result, &type_result) {\n-            (&Success(binding), _) if !binding.pseudo_vis()\n-                                              .is_at_least(directive.vis, self.resolver) &&\n-                                      self.resolver.is_accessible(binding.vis) => {\n+            (&Success(binding), _) if !binding.pseudo_vis().is_at_least(directive.vis, self) &&\n+                                      self.is_accessible(binding.vis) => {\n                 let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n                 let note_msg = format!(\"consider marking `{}` as `pub` in the imported module\",\n                                         source);\n-                struct_span_err!(self.resolver.session, directive.span, E0364, \"{}\", &msg)\n+                struct_span_err!(self.session, directive.span, E0364, \"{}\", &msg)\n                     .span_note(directive.span, &note_msg)\n                     .emit();\n             }\n \n-            (_, &Success(binding)) if !binding.pseudo_vis()\n-                                              .is_at_least(directive.vis, self.resolver) &&\n-                                      self.resolver.is_accessible(binding.vis) => {\n+            (_, &Success(binding)) if !binding.pseudo_vis().is_at_least(directive.vis, self) &&\n+                                      self.is_accessible(binding.vis) => {\n                 if binding.is_extern_crate() {\n                     let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n                                        (error E0364), consider declaring with `pub`\",\n                                        source);\n-                    self.resolver.session.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n-                                                   directive.id,\n-                                                   directive.span,\n-                                                   msg);\n+                    self.session.add_lint(PRIVATE_IN_PUBLIC, directive.id, directive.span, msg);\n                 } else {\n                     let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n                     let note_msg =\n                         format!(\"consider declaring type or module `{}` with `pub`\", source);\n-                    struct_span_err!(self.resolver.session, directive.span, E0365, \"{}\", &msg)\n+                    struct_span_err!(self.session, directive.span, E0365, \"{}\", &msg)\n                         .span_note(directive.span, &note_msg)\n                         .emit();\n                 }\n@@ -605,7 +602,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             None => value_result.success().and_then(NameBinding::def).unwrap(),\n         };\n         let path_resolution = PathResolution::new(def);\n-        self.resolver.def_map.insert(directive.id, path_resolution);\n+        self.def_map.insert(directive.id, path_resolution);\n \n         debug!(\"(resolving single import) successfully resolved import\");\n         return Success(());\n@@ -618,40 +615,41 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     fn resolve_glob_import(&mut self, target_module: Module<'b>, directive: &'b ImportDirective<'b>)\n                            -> ResolveResult<()> {\n         if let Some(Def::Trait(_)) = target_module.def {\n-            self.resolver.session.span_err(directive.span, \"items in traits are not importable.\");\n+            self.session.span_err(directive.span, \"items in traits are not importable.\");\n         }\n \n-        let module_ = self.resolver.current_module;\n-        if module_.def_id() == target_module.def_id() {\n+        let module = self.current_module;\n+        if module.def_id() == target_module.def_id() {\n             // This means we are trying to glob import a module into itself, and it is a no-go\n             let msg = \"Cannot glob-import a module into itself.\".into();\n             return Failed(Some((directive.span, msg)));\n         }\n-        self.resolver.populate_module_if_necessary(target_module);\n+        self.populate_module_if_necessary(target_module);\n \n         if let GlobImport { is_prelude: true } = directive.subclass {\n-            self.resolver.prelude = Some(target_module);\n+            self.prelude = Some(target_module);\n             return Success(());\n         }\n \n         // Add to target_module's glob_importers\n-        target_module.glob_importers.borrow_mut().push((module_, directive));\n+        target_module.glob_importers.borrow_mut().push((module, directive));\n \n-        // Ensure that `resolutions` isn't borrowed during `try_define_child`,\n+        // Ensure that `resolutions` isn't borrowed during `try_define`,\n         // since it might get updated via a glob cycle.\n         let bindings = target_module.resolutions.borrow().iter().filter_map(|(name, resolution)| {\n             resolution.borrow().binding().map(|binding| (*name, binding))\n         }).collect::<Vec<_>>();\n         for ((name, ns), binding) in bindings {\n             if binding.is_importable() && binding.is_pseudo_public() {\n-                let _ = module_.try_define_child(name, ns, directive.import(binding));\n+                let imported_binding = self.import(binding, directive);\n+                let _ = self.try_define(module, name, ns, imported_binding);\n             }\n         }\n \n         // Record the destination of this import\n         if let Some(did) = target_module.def_id() {\n             let resolution = PathResolution::new(Def::Mod(did));\n-            self.resolver.def_map.insert(directive.id, resolution);\n+            self.def_map.insert(directive.id, resolution);\n         }\n \n         debug!(\"(resolving glob import) successfully resolved import\");\n@@ -667,15 +665,23 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         let mut reexports = Vec::new();\n         for (&(name, ns), resolution) in module.resolutions.borrow().iter() {\n             let resolution = resolution.borrow();\n-            resolution.report_conflicts(|b1, b2| {\n-                self.resolver.report_conflict(module, name, ns, b1, b2)\n-            });\n-\n             let binding = match resolution.binding {\n                 Some(binding) => binding,\n                 None => continue,\n             };\n \n+            // Report conflicts\n+            for duplicate_glob in resolution.duplicate_globs.iter() {\n+                // FIXME #31337: We currently allow items to shadow glob-imported re-exports.\n+                if !binding.is_import() {\n+                    if let NameBindingKind::Import { binding, .. } = duplicate_glob.kind {\n+                        if binding.is_import() { continue }\n+                    }\n+                }\n+\n+                self.report_conflict(module, name, ns, duplicate_glob, binding);\n+            }\n+\n             if binding.vis == ty::Visibility::Public &&\n                (binding.is_import() || binding.is_extern_crate()) {\n                 if let Some(def) = binding.def() {\n@@ -685,20 +691,19 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n             if let NameBindingKind::Import { binding: orig_binding, directive, .. } = binding.kind {\n                 if ns == TypeNS && orig_binding.is_variant() &&\n-                   !orig_binding.vis.is_at_least(binding.vis, self.resolver) {\n+                   !orig_binding.vis.is_at_least(binding.vis, self) {\n                     let msg = format!(\"variant `{}` is private, and cannot be reexported \\\n                                        (error E0364), consider declaring its enum as `pub`\",\n                                       name);\n-                    let lint = lint::builtin::PRIVATE_IN_PUBLIC;\n-                    self.resolver.session.add_lint(lint, directive.id, binding.span, msg);\n+                    self.session.add_lint(PRIVATE_IN_PUBLIC, directive.id, binding.span, msg);\n                 }\n             }\n         }\n \n         if reexports.len() > 0 {\n             if let Some(def_id) = module.def_id() {\n-                let node_id = self.resolver.definitions.as_local_node_id(def_id).unwrap();\n-                self.resolver.export_map.insert(node_id, reexports);\n+                let node_id = self.definitions.as_local_node_id(def_id).unwrap();\n+                self.export_map.insert(node_id, reexports);\n             }\n         }\n "}, {"sha": "f2c7068565ee90d482bfb7471f6f5b0e7f879cbf", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bf54f90d619fc87af4c8b660a80166c40048cb5/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bf54f90d619fc87af4c8b660a80166c40048cb5/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=7bf54f90d619fc87af4c8b660a80166c40048cb5", "patch": "@@ -18,7 +18,7 @@ use self::utils::{DIB, span_start, create_DIArray, is_node_local_to_unit};\n use self::namespace::mangled_name_of_item;\n use self::type_names::compute_debuginfo_type_name;\n use self::metadata::{type_metadata, diverging_type_metadata};\n-use self::metadata::{file_metadata, scope_metadata, TypeMap};\n+use self::metadata::{file_metadata, TypeMap};\n use self::source_loc::InternalDebugLocation::{self, UnknownLocation};\n \n use llvm;"}, {"sha": "11003067070f4e99b01f9cdfd1a55cd4253b4c75", "filename": "src/test/compile-fail/const-pattern-irrefutable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7bf54f90d619fc87af4c8b660a80166c40048cb5/src%2Ftest%2Fcompile-fail%2Fconst-pattern-irrefutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bf54f90d619fc87af4c8b660a80166c40048cb5/src%2Ftest%2Fcompile-fail%2Fconst-pattern-irrefutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-pattern-irrefutable.rs?ref=7bf54f90d619fc87af4c8b660a80166c40048cb5", "patch": "@@ -25,4 +25,5 @@ fn main() {\n                //~^ NOTE cannot be named the same as a constant\n     let d = 4; //~ ERROR let bindings cannot shadow constants\n                //~^ NOTE cannot be named the same as a constant\n+    fn f() {} // Check that the `NOTE`s still work with an item here (c.f. issue #35115).\n }"}, {"sha": "239f380e6c4abb6e0d673f26a153980e48eaea72", "filename": "src/test/compile-fail/lint-unused-imports.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7bf54f90d619fc87af4c8b660a80166c40048cb5/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bf54f90d619fc87af4c8b660a80166c40048cb5/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs?ref=7bf54f90d619fc87af4c8b660a80166c40048cb5", "patch": "@@ -79,6 +79,13 @@ fn g() {\n     }\n }\n \n+// c.f. issue #35135\n+#[allow(unused_variables)]\n+fn h() {\n+    use test2::foo; //~ ERROR unused import\n+    let foo = 0;\n+}\n+\n fn main() {\n     cal(foo::Point{x:3, y:9});\n     let mut a = 3;"}, {"sha": "72df09b7669f686ed4303f3fab6f0d93bc564fa9", "filename": "src/tools/cargotest/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bf54f90d619fc87af4c8b660a80166c40048cb5/src%2Ftools%2Fcargotest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bf54f90d619fc87af4c8b660a80166c40048cb5/src%2Ftools%2Fcargotest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargotest%2Fmain.rs?ref=7bf54f90d619fc87af4c8b660a80166c40048cb5", "patch": "@@ -24,7 +24,7 @@ struct Test {\n const TEST_REPOS: &'static [Test] = &[Test {\n                                           name: \"cargo\",\n                                           repo: \"https://github.com/rust-lang/cargo\",\n-                                          sha: \"7d79da08238e3d47e0bc4406155bdcc45ccb8c82\",\n+                                          sha: \"fd90fd642d404d8c66505ca8db742c664ea352f2\",\n                                           lock: None,\n                                       },\n                                       Test {"}]}