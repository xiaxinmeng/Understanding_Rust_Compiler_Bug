{"sha": "5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkMGJlYjdkODVlOGU3MTEzMzRjN2ZiNmYyYzVkYTI3MGU1MjAwY2I=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-31T17:15:26Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-31T17:15:26Z"}, "message": "rollup merge of #23549: aturon/stab-num\n\nThis commit stabilizes the `std::num` module:\n\n* The `Int` and `Float` traits are deprecated in favor of (1) the\n  newly-added inherent methods and (2) the generic traits available in\n  rust-lang/num.\n\n* The `Zero` and `One` traits are reintroduced in `std::num`, which\n  together with various other traits allow you to recover the most\n  common forms of generic programming.\n\n* The `FromStrRadix` trait, and associated free function, is deprecated\n  in favor of inherent implementations.\n\n* A wide range of methods and constants for both integers and floating\n  point numbers are now `#[stable]`, having been adjusted for integer\n  guidelines.\n\n* `is_positive` and `is_negative` are renamed to `is_sign_positive` and\n  `is_sign_negative`, in order to address #22985\n\n* The `Wrapping` type is moved to `std::num` and stabilized;\n  `WrappingOps` is deprecated in favor of inherent methods on the\n  integer types, and direct implementation of operations on\n  `Wrapping<X>` for each concrete integer type `X`.\n\nCloses #22985\nCloses #21069\n\n[breaking-change]\n\nr? @alexcrichton", "tree": {"sha": "cd6181ba8612c9233c3a47aaf5e956a5610c348e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd6181ba8612c9233c3a47aaf5e956a5610c348e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "html_url": "https://github.com/rust-lang/rust/commit/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3317d68910900f135f9f38e43a7a699bc736b4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3317d68910900f135f9f38e43a7a699bc736b4a", "html_url": "https://github.com/rust-lang/rust/commit/b3317d68910900f135f9f38e43a7a699bc736b4a"}, {"sha": "232424d9952700682373ccf2d578109f401ff023", "url": "https://api.github.com/repos/rust-lang/rust/commits/232424d9952700682373ccf2d578109f401ff023", "html_url": "https://github.com/rust-lang/rust/commit/232424d9952700682373ccf2d578109f401ff023"}], "stats": {"total": 2236, "additions": 985, "deletions": 1251}, "files": [{"sha": "57baa811b9d4740f82be7a272ae0fe2d44eaaad0", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -189,7 +189,6 @@ mod imp {\n     use core::option::Option;\n     use core::option::Option::None;\n     use core::ptr::{null_mut, null};\n-    use core::num::Int;\n     use libc::{c_char, c_int, c_void, size_t};\n     use super::MIN_ALIGN;\n "}, {"sha": "3ed8ca2bea98b1adb197c1654262df769ad138cb", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -91,7 +91,6 @@ use core::hash;\n use core::iter::RandomAccessIterator;\n use core::iter::{Chain, Enumerate, Repeat, Skip, Take, repeat, Cloned};\n use core::iter::{self, FromIterator, IntoIterator};\n-use core::num::Int;\n use core::ops::Index;\n use core::slice;\n use core::{u8, u32, usize};"}, {"sha": "474b4de8123e1ce271c59e9a3166cf771b54081e", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -16,7 +16,6 @@\n use core::prelude::*;\n use core::marker;\n use core::fmt;\n-use core::num::Int;\n use core::iter::{FromIterator, IntoIterator};\n use core::ops::{Sub, BitOr, BitAnd, BitXor};\n "}, {"sha": "050997f2dd3f085459575ea13b65c79725e5c636", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -89,6 +89,7 @@ use core::iter::MultiplicativeIterator;\n use core::marker::Sized;\n use core::mem::size_of;\n use core::mem;\n+#[cfg(stage0)]\n use core::num::wrapping::WrappingOps;\n use core::ops::FnMut;\n use core::option::Option::{self, Some, None};"}, {"sha": "9ddf8988f1ee7ee643e03b65dcde77b9effa0f53", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -18,9 +18,6 @@\n //! (see below). It is not possible to move out of borrowed strings because they\n //! are owned elsewhere.\n //!\n-//! Basic operations are implemented directly by the compiler, but more advanced\n-//! operations are defined as methods on the `str` type.\n-//!\n //! # Examples\n //!\n //! Here's some code that uses a `&str`:"}, {"sha": "392e5092e3b6a9845b0929e83da10f23ff959c77", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -25,6 +25,7 @@ use core::default::Default;\n use core::fmt;\n use core::iter::{self, repeat, FromIterator, IntoIterator, RandomAccessIterator};\n use core::mem;\n+#[cfg(stage0)]\n use core::num::wrapping::WrappingOps;\n use core::ops::{Index, IndexMut};\n use core::ptr::{self, Unique};"}, {"sha": "9b8b59ec8ce6e0ffe3758e99ee3150fcf2fb9839", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -20,8 +20,6 @@\n //!\n //! ```\n //! # #![feature(core)]\n-//! use std::num::SignedInt;\n-//!\n //! struct FuzzyNum {\n //!     num: i32,\n //! }"}, {"sha": "f3f5a0b70cb742117bd9cb3db937d653e16b5aba", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -33,6 +33,7 @@ trait GenericRadix {\n     fn digit(&self, x: u8) -> u8;\n \n     /// Format an integer using the radix using a formatter.\n+    #[allow(deprecated)] // Int\n     fn fmt_int<T: Int>(&self, mut x: T, f: &mut fmt::Formatter) -> fmt::Result {\n         // The radix can be as low as 2, so we need a buffer of at least 64\n         // characters for a base 2 number."}, {"sha": "e65fbac926bd91e854a12023b093f90412215896", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -12,9 +12,10 @@\n \n //! An implementation of SipHash 2-4.\n \n+#![allow(deprecated)] // until the next snapshot for inherent wrapping ops\n+\n use prelude::*;\n use default::Default;\n-use num::wrapping::WrappingOps;\n use super::Hasher;\n \n /// An implementation of SipHash 2-4.\n@@ -71,7 +72,7 @@ macro_rules! u8to64_le {\n \n macro_rules! rotl {\n     ($x:expr, $b:expr) =>\n-    (($x << $b) | ($x >> (64.wrapping_sub($b))))\n+    (($x << $b) | ($x >> (64_i32.wrapping_sub($b))))\n }\n \n macro_rules! compress {"}, {"sha": "44d48f9f4bf9d18d3ff023c3f9840b5a98dc99e5", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 122, "deletions": 36, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -64,8 +64,8 @@ use cmp::Ord;\n use default::Default;\n use marker;\n use mem;\n-use num::{ToPrimitive, Int};\n-use ops::{Add, FnMut, RangeFrom};\n+use num::{Int, Zero, One, ToPrimitive};\n+use ops::{Add, Sub, FnMut, RangeFrom};\n use option::Option;\n use option::Option::{Some, None};\n use marker::Sized;\n@@ -843,9 +843,8 @@ pub trait Iterator {\n     ///\n     /// ```\n     /// # #![feature(core)]\n-    /// use std::num::SignedInt;\n     ///\n-    /// let a = [-3, 0, 1, 5, -10];\n+    /// let a = [-3_i32, 0, 1, 5, -10];\n     /// assert_eq!(*a.iter().max_by(|x| x.abs()).unwrap(), -10);\n     /// ```\n     #[inline]\n@@ -875,9 +874,8 @@ pub trait Iterator {\n     ///\n     /// ```\n     /// # #![feature(core)]\n-    /// use std::num::SignedInt;\n     ///\n-    /// let a = [-3, 0, 1, 5, -10];\n+    /// let a = [-3_i32, 0, 1, 5, -10];\n     /// assert_eq!(*a.iter().min_by(|x| x.abs()).unwrap(), 0);\n     /// ```\n     #[inline]\n@@ -2417,6 +2415,67 @@ impl<A, St, F> Iterator for Unfold<St, F> where F: FnMut(&mut St) -> Option<A> {\n     }\n }\n \n+/// Objects that can be stepped over in both directions.\n+///\n+/// The `steps_between` function provides a way to efficiently compare\n+/// two `Step` objects.\n+#[unstable(feature = \"step_trait\",\n+           reason = \"likely to be replaced by finer-grained traits\")]\n+pub trait Step: Ord {\n+    /// Steps `self` if possible.\n+    fn step(&self, by: &Self) -> Option<Self>;\n+\n+    /// The number of steps between two step objects.\n+    ///\n+    /// `start` should always be less than `end`, so the result should never\n+    /// be negative.\n+    ///\n+    /// Return `None` if it is not possible to calculate steps_between\n+    /// without overflow.\n+    fn steps_between(start: &Self, end: &Self, by: &Self) -> Option<usize>;\n+}\n+\n+macro_rules! step_impl {\n+    ($($t:ty)*) => ($(\n+        impl Step for $t {\n+            #[inline]\n+            fn step(&self, by: &$t) -> Option<$t> {\n+                (*self).checked_add(*by)\n+            }\n+            #[inline]\n+            #[allow(trivial_numeric_casts)]\n+            fn steps_between(start: &$t, end: &$t, by: &$t) -> Option<usize> {\n+                if *start <= *end {\n+                    Some(((*end - *start) / *by) as usize)\n+                } else {\n+                    Some(0)\n+                }\n+            }\n+        }\n+    )*)\n+}\n+\n+macro_rules! step_impl_no_between {\n+    ($($t:ty)*) => ($(\n+        impl Step for $t {\n+            #[inline]\n+            fn step(&self, by: &$t) -> Option<$t> {\n+                (*self).checked_add(*by)\n+            }\n+            #[inline]\n+            fn steps_between(_a: &$t, _b: &$t, _by: &$t) -> Option<usize> {\n+                None\n+            }\n+        }\n+    )*)\n+}\n+\n+step_impl!(usize u8 u16 u32 isize i8 i16 i32);\n+#[cfg(target_pointer_width = \"64\")]\n+step_impl!(u64 i64);\n+#[cfg(target_pointer_width = \"32\")]\n+step_impl_no_between!(u64 i64);\n+\n /// An adapter for stepping range iterators by a custom amount.\n ///\n /// The resulting iterator handles overflow by stopping. The `A`\n@@ -2429,7 +2488,7 @@ pub struct StepBy<A, R> {\n     range: R,\n }\n \n-impl<A: Add> RangeFrom<A> {\n+impl<A: Step> RangeFrom<A> {\n     /// Creates an iterator starting at the same point, but stepping by\n     /// the given amount at each iteration.\n     ///\n@@ -2451,7 +2510,8 @@ impl<A: Add> RangeFrom<A> {\n     }\n }\n \n-impl<A: Int> ::ops::Range<A> {\n+#[allow(deprecated)]\n+impl<A: Step> ::ops::Range<A> {\n     /// Creates an iterator with the same range, but stepping by the\n     /// given amount at each iteration.\n     ///\n@@ -2505,14 +2565,17 @@ pub fn count<A>(start: A, step: A) -> Counter<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Add<Output=A> + Clone> Iterator for StepBy<A, RangeFrom<A>> {\n+impl<A> Iterator for StepBy<A, RangeFrom<A>> where\n+    A: Clone,\n+    for<'a> &'a A: Add<&'a A, Output = A>\n+{\n     type Item = A;\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        let result = self.range.start.clone();\n-        self.range.start = result.clone() + self.step_by.clone();\n-        Some(result)\n+        let mut n = &self.range.start + &self.step_by;\n+        mem::swap(&mut n, &mut self.range.start);\n+        Some(n)\n     }\n \n     #[inline]\n@@ -2715,19 +2778,27 @@ pub fn range_step<A: Int>(start: A, stop: A, step: A) -> RangeStep<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Int> Iterator for StepBy<A, ::ops::Range<A>> {\n+#[allow(deprecated)]\n+impl<A: Step + Zero + Clone> Iterator for StepBy<A, ::ops::Range<A>> {\n     type Item = A;\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        let rev = self.step_by < Int::zero();\n-        let start = self.range.start;\n-        if (rev && start > self.range.end) || (!rev && start < self.range.end) {\n-            match start.checked_add(self.step_by) {\n-                Some(x) => self.range.start = x,\n-                None => self.range.start = self.range.end.clone()\n+        let rev = self.step_by < A::zero();\n+        if (rev && self.range.start > self.range.end) ||\n+           (!rev && self.range.start < self.range.end)\n+        {\n+            match self.range.start.step(&self.step_by) {\n+                Some(mut n) => {\n+                    mem::swap(&mut self.range.start, &mut n);\n+                    Some(n)\n+                },\n+                None => {\n+                    let mut n = self.range.end.clone();\n+                    mem::swap(&mut self.range.start, &mut n);\n+                    Some(n)\n+                }\n             }\n-            Some(start)\n         } else {\n             None\n         }\n@@ -2774,6 +2845,7 @@ pub struct RangeStepInclusive<A> {\n #[inline]\n #[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n+#[allow(deprecated)]\n pub fn range_step_inclusive<A: Int>(start: A, stop: A, step: A) -> RangeStepInclusive<A> {\n     let rev = step < Int::zero();\n     RangeStepInclusive {\n@@ -2787,6 +2859,7 @@ pub fn range_step_inclusive<A: Int>(start: A, stop: A, step: A) -> RangeStepIncl\n \n #[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n+#[allow(deprecated)]\n impl<A: Int> Iterator for RangeStepInclusive<A> {\n     type Item = A;\n \n@@ -2814,27 +2887,36 @@ macro_rules! range_exact_iter_impl {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Int> Iterator for ::ops::Range<A> {\n+#[allow(deprecated)]\n+impl<A: Step + One + Clone> Iterator for ::ops::Range<A> {\n     type Item = A;\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if self.start < self.end {\n-            let result = self.start;\n-            self.start = self.start + Int::one();\n-            Some(result)\n+            match self.start.step(&A::one()) {\n+                Some(mut n) => {\n+                    mem::swap(&mut n, &mut self.start);\n+                    Some(n)\n+                },\n+                None => {\n+                    let mut n = self.end.clone();\n+                    mem::swap(&mut n, &mut self.start);\n+                    Some(n)\n+\n+                }\n+            }\n         } else {\n             None\n         }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.start >= self.end {\n-            (0, Some(0))\n+        if let Some(hint) = Step::steps_between(&self.start, &self.end, &A::one()) {\n+            (hint, Some(hint))\n         } else {\n-            let length = (self.end - self.start).to_usize();\n-            (length.unwrap_or(0), length)\n+            (0, None)\n         }\n     }\n }\n@@ -2844,28 +2926,32 @@ impl<A: Int> Iterator for ::ops::Range<A> {\n range_exact_iter_impl!(usize u8 u16 u32 isize i8 i16 i32);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Int> DoubleEndedIterator for ::ops::Range<A> {\n+#[allow(deprecated)]\n+impl<A: Step + One + Clone> DoubleEndedIterator for ::ops::Range<A> where\n+    for<'a> &'a A: Sub<&'a A, Output = A>\n+{\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         if self.start < self.end {\n-            self.end = self.end - Int::one();\n-            Some(self.end)\n+            self.end = &self.end - &A::one();\n+            Some(self.end.clone())\n         } else {\n             None\n         }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Int> Iterator for ::ops::RangeFrom<A> {\n+#[allow(deprecated)]\n+impl<A: Step + One> Iterator for ::ops::RangeFrom<A> {\n     type Item = A;\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        let result = self.start;\n-        self.start = self.start + Int::one();\n-        debug_assert!(result < self.start);\n-        Some(result)\n+        self.start.step(&A::one()).map(|mut n| {\n+            mem::swap(&mut n, &mut self.start);\n+            n\n+        })\n     }\n }\n "}, {"sha": "12b45a766b63929da94dc01ff5d7d6761451407c", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 38, "deletions": 10, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -22,12 +22,12 @@ use num::Float;\n use num::FpCategory as Fp;\n use option::Option;\n \n-#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const RADIX: u32 = 2;\n \n-#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MANTISSA_DIGITS: u32 = 24;\n-#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const DIGITS: u32 = 6;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -56,14 +56,14 @@ pub const MIN_POSITIVE: f32 = 1.17549435e-38_f32;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAX: f32 = 3.40282347e+38_f32;\n \n-#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN_EXP: i32 = -125;\n-#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAX_EXP: i32 = 128;\n \n-#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN_10_EXP: i32 = -37;\n-#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAX_10_EXP: i32 = 38;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -73,61 +73,89 @@ pub const INFINITY: f32 = 1.0_f32/0.0_f32;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const NEG_INFINITY: f32 = -1.0_f32/0.0_f32;\n \n-/// Various useful constants.\n-#[unstable(feature = \"core\",\n-           reason = \"naming scheme needs to be revisited\")]\n+/// Basic mathematial constants.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod consts {\n     // FIXME: replace with mathematical constants from cmath.\n \n     /// Archimedes' constant\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const PI: f32 = 3.14159265358979323846264338327950288_f32;\n \n     /// pi * 2.0\n+    #[unstable(feature = \"core\", reason = \"unclear naming convention/usefulness\")]\n     pub const PI_2: f32 = 6.28318530717958647692528676655900576_f32;\n \n     /// pi/2.0\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_PI_2: f32 = 1.57079632679489661923132169163975144_f32;\n \n     /// pi/3.0\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_PI_3: f32 = 1.04719755119659774615421446109316763_f32;\n \n     /// pi/4.0\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_PI_4: f32 = 0.785398163397448309615660845819875721_f32;\n \n     /// pi/6.0\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_PI_6: f32 = 0.52359877559829887307710723054658381_f32;\n \n     /// pi/8.0\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_PI_8: f32 = 0.39269908169872415480783042290993786_f32;\n \n     /// 1.0/pi\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_1_PI: f32 = 0.318309886183790671537767526745028724_f32;\n \n     /// 2.0/pi\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_2_PI: f32 = 0.636619772367581343075535053490057448_f32;\n \n     /// 2.0/sqrt(pi)\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub const FRAC_2_SQRT_PI: f32 = 1.12837916709551257389615890312154517_f32;\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to FRAC_2_SQRT_PI\")]\n     pub const FRAC_2_SQRTPI: f32 = 1.12837916709551257389615890312154517_f32;\n \n     /// sqrt(2.0)\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub const SQRT_2: f32 = 1.41421356237309504880168872420969808_f32;\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to SQRT_2\")]\n     pub const SQRT2: f32 = 1.41421356237309504880168872420969808_f32;\n \n     /// 1.0/sqrt(2.0)\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub const FRAC_1_SQRT_2: f32 = 0.707106781186547524400844362104849039_f32;\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to FRAC_1_SQRT_2\")]\n     pub const FRAC_1_SQRT2: f32 = 0.707106781186547524400844362104849039_f32;\n \n     /// Euler's number\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const E: f32 = 2.71828182845904523536028747135266250_f32;\n \n     /// log2(e)\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const LOG2_E: f32 = 1.44269504088896340735992468100189214_f32;\n \n     /// log10(e)\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const LOG10_E: f32 = 0.434294481903251827651128918916605082_f32;\n \n     /// ln(2.0)\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const LN_2: f32 = 0.693147180559945309417232121458176568_f32;\n \n     /// ln(10.0)\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const LN_10: f32 = 2.30258509299404568401799145468436421_f32;\n }\n "}, {"sha": "058acedd9c98889096926ecc1d1873e611ec6cde", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 38, "deletions": 17, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -22,15 +22,12 @@ use num::Float;\n use num::FpCategory as Fp;\n use option::Option;\n \n-// FIXME(#5527): These constants should be deprecated once associated\n-// constants are implemented in favour of referencing the respective\n-// members of `Bounded` and `Float`.\n-\n-#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const RADIX: u32 = 2;\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MANTISSA_DIGITS: u32 = 53;\n-#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const DIGITS: u32 = 15;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -59,14 +56,14 @@ pub const MIN_POSITIVE: f64 = 2.2250738585072014e-308_f64;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAX: f64 = 1.7976931348623157e+308_f64;\n \n-#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN_EXP: i32 = -1021;\n-#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAX_EXP: i32 = 1024;\n \n-#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MIN_10_EXP: i32 = -307;\n-#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAX_10_EXP: i32 = 308;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -76,65 +73,89 @@ pub const INFINITY: f64 = 1.0_f64/0.0_f64;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const NEG_INFINITY: f64 = -1.0_f64/0.0_f64;\n \n-/// Various useful constants.\n-#[unstable(feature = \"core\",\n-           reason = \"naming scheme needs to be revisited\")]\n+/// Basic mathematial constants.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub mod consts {\n     // FIXME: replace with mathematical constants from cmath.\n \n-    // FIXME(#5527): These constants should be deprecated once associated\n-    // constants are implemented in favour of referencing the respective members\n-    // of `Float`.\n-\n     /// Archimedes' constant\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const PI: f64 = 3.14159265358979323846264338327950288_f64;\n \n     /// pi * 2.0\n+    #[unstable(feature = \"core\", reason = \"unclear naming convention/usefulness\")]\n     pub const PI_2: f64 = 6.28318530717958647692528676655900576_f64;\n \n     /// pi/2.0\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_PI_2: f64 = 1.57079632679489661923132169163975144_f64;\n \n     /// pi/3.0\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_PI_3: f64 = 1.04719755119659774615421446109316763_f64;\n \n     /// pi/4.0\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_PI_4: f64 = 0.785398163397448309615660845819875721_f64;\n \n     /// pi/6.0\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_PI_6: f64 = 0.52359877559829887307710723054658381_f64;\n \n     /// pi/8.0\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_PI_8: f64 = 0.39269908169872415480783042290993786_f64;\n \n     /// 1.0/pi\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_1_PI: f64 = 0.318309886183790671537767526745028724_f64;\n \n     /// 2.0/pi\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const FRAC_2_PI: f64 = 0.636619772367581343075535053490057448_f64;\n \n     /// 2.0/sqrt(pi)\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub const FRAC_2_SQRT_PI: f64 = 1.12837916709551257389615890312154517_f64;\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to FRAC_2_SQRT_PI\")]\n     pub const FRAC_2_SQRTPI: f64 = 1.12837916709551257389615890312154517_f64;\n \n     /// sqrt(2.0)\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub const SQRT_2: f64 = 1.41421356237309504880168872420969808_f64;\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to SQRT_2\")]\n     pub const SQRT2: f64 = 1.41421356237309504880168872420969808_f64;\n \n     /// 1.0/sqrt(2.0)\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub const FRAC_1_SQRT_2: f64 = 0.707106781186547524400844362104849039_f64;\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to FRAC_1_SQRT_2\")]\n     pub const FRAC_1_SQRT2: f64 = 0.707106781186547524400844362104849039_f64;\n \n     /// Euler's number\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const E: f64 = 2.71828182845904523536028747135266250_f64;\n \n     /// log2(e)\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const LOG2_E: f64 = 1.44269504088896340735992468100189214_f64;\n \n     /// log10(e)\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const LOG10_E: f64 = 0.434294481903251827651128918916605082_f64;\n \n     /// ln(2.0)\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const LN_2: f64 = 0.693147180559945309417232121458176568_f64;\n \n     /// ln(10.0)\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const LN_10: f64 = 2.30258509299404568401799145468436421_f64;\n }\n "}, {"sha": "64f8e7055a57ae57b0ab0cbe93812b6fcf1859e4", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 212, "deletions": 101, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -32,11 +32,66 @@ use option::Option::{self, Some, None};\n use result::Result::{self, Ok, Err};\n use str::{FromStr, StrExt};\n \n+/// Provides intentionally-wrapped arithmetic on `T`.\n+///\n+/// Operations like `+` on `u32` values is intended to never overflow,\n+/// and in some debug configurations overflow is detected and results\n+/// in a panic. While most arithmetic falls into this category, some\n+/// code explicitly expects and relies upon modular arithmetic (e.g.,\n+/// hashing).\n+///\n+/// Wrapping arithmetic can be achieved either through methods like\n+/// `wrapping_add`, or through the `Wrapping<T>` type, which says that\n+/// all standard arithmetic operations on the underlying value are\n+/// intended to have wrapping semantics.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Debug)]\n+pub struct Wrapping<T>(pub T);\n+\n #[unstable(feature = \"core\", reason = \"may be removed or relocated\")]\n pub mod wrapping;\n \n+/// Types that have a \"zero\" value.\n+///\n+/// This trait is intended for use in conjunction with `Add`, as an identity:\n+/// `x + T::zero() == x`.\n+#[unstable(feature = \"zero_one\",\n+           reason = \"unsure of placement, wants to use associated constants\")]\n+pub trait Zero {\n+    /// The \"zero\" (usually, additive identity) for this type.\n+    fn zero() -> Self;\n+}\n+\n+/// Types that have a \"one\" value.\n+///\n+/// This trait is intended for use in conjunction with `Mul`, as an identity:\n+/// `x * T::one() == x`.\n+#[unstable(feature = \"zero_one\",\n+           reason = \"unsure of placement, wants to use associated constants\")]\n+pub trait One {\n+    /// The \"one\" (usually, multiplicative identity) for this type.\n+    fn one() -> Self;\n+}\n+\n+macro_rules! zero_one_impl {\n+    ($($t:ty)*) => ($(\n+        impl Zero for $t {\n+            #[inline]\n+            fn zero() -> $t { 0 }\n+        }\n+        impl One for $t {\n+            #[inline]\n+            fn one() -> $t { 1 }\n+        }\n+    )*)\n+}\n+zero_one_impl! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n+\n /// A built-in signed or unsigned integer.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"replaced by inherent methods; for generics, use rust-lang/num\")]\n+#[allow(deprecated)]\n pub trait Int\n     : Copy + Clone\n     + NumCast\n@@ -450,6 +505,7 @@ macro_rules! uint_impl {\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[allow(deprecated)]\n         impl Int for $T {\n             #[inline]\n             fn zero() -> $T { 0 }\n@@ -589,6 +645,7 @@ macro_rules! int_impl {\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[allow(deprecated)]\n         impl Int for $T {\n             #[inline]\n             fn zero() -> $T { 0 }\n@@ -692,6 +749,9 @@ int_impl! { isize = i64, u64, 64,\n \n /// A built-in two's complement integer.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"replaced by inherent methods; for generics, use rust-lang/num\")]\n+#[allow(deprecated)]\n pub trait SignedInt\n     : Int\n     + Neg<Output=Self>\n@@ -723,6 +783,7 @@ pub trait SignedInt\n macro_rules! signed_int_impl {\n     ($T:ty) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[allow(deprecated)]\n         impl SignedInt for $T {\n             #[inline]\n             fn abs(self) -> $T {\n@@ -759,35 +820,25 @@ macro_rules! int_impl {\n      $add_with_overflow:path,\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n-        /// Returns the `0` value of this integer type.\n-        // FIXME (#5527): Should be an associated constant\n-        #[unstable(feature = \"core\",\n-                   reason = \"unsure about its place in the world\")]\n-        #[inline]\n-        pub fn zero() -> $T { 0 }\n-\n-        /// Returns the `1` value of this integer type.\n-        // FIXME (#5527): Should be an associated constant\n-        #[unstable(feature = \"core\",\n-                   reason = \"unsure about its place in the world\")]\n-        #[inline]\n-        pub fn one() -> $T { 1 }\n-\n-        /// Returns the smallest value that can be represented by this integer\n-        /// type.\n-        // FIXME (#5527): Should be and associated constant\n-        #[unstable(feature = \"core\",\n-                   reason = \"unsure about its place in the world\")]\n-        #[inline]\n-        pub fn min_value() -> $T { (-1 as $T) << ($BITS - 1) }\n-\n-        /// Returns the largest value that can be represented by this integer\n-        /// type.\n-        // FIXME (#5527): Should be and associated constant\n-        #[unstable(feature = \"core\",\n-                   reason = \"unsure about its place in the world\")]\n-        #[inline]\n-        pub fn max_value() -> $T { let min: $T = <$T>::min_value(); !min }\n+        /// Convert a string slice in a given base to an integer.\n+        ///\n+        /// Leading and trailing whitespace represent an error.\n+        ///\n+        /// # Arguments\n+        ///\n+        /// * src - A string slice\n+        /// * radix - The base to use. Must lie in the range [2 .. 36]\n+        ///\n+        /// # Return value\n+        ///\n+        /// `None` if the string did not represent a valid number.\n+        /// Otherwise, `Some(n)` where `n` is the integer represented\n+        /// by `src`.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[allow(deprecated)]\n+        pub fn from_str_radix(src: &str, radix: u32) -> Result<$T, ParseIntError> {\n+            <Self as FromStrRadix>::from_str_radix(src, radix)\n+        }\n \n         /// Returns the number of ones in the binary representation of `self`.\n         ///\n@@ -801,8 +852,7 @@ macro_rules! int_impl {\n         ///\n         /// assert_eq!(n.count_ones(), 3);\n         /// ```\n-        #[unstable(feature = \"core\",\n-                   reason = \"pending integer conventions\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n \n@@ -818,8 +868,7 @@ macro_rules! int_impl {\n         ///\n         /// assert_eq!(n.count_zeros(), 5);\n         /// ```\n-        #[unstable(feature = \"core\",\n-                   reason = \"pending integer conventions\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn count_zeros(self) -> u32 {\n             (!self).count_ones()\n@@ -838,8 +887,7 @@ macro_rules! int_impl {\n         ///\n         /// assert_eq!(n.leading_zeros(), 10);\n         /// ```\n-        #[unstable(feature = \"core\",\n-                   reason = \"pending integer conventions\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn leading_zeros(self) -> u32 {\n             (self as $UnsignedT).leading_zeros()\n@@ -858,8 +906,7 @@ macro_rules! int_impl {\n         ///\n         /// assert_eq!(n.trailing_zeros(), 3);\n         /// ```\n-        #[unstable(feature = \"core\",\n-                   reason = \"pending integer conventions\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn trailing_zeros(self) -> u32 {\n             (self as $UnsignedT).trailing_zeros()\n@@ -879,8 +926,7 @@ macro_rules! int_impl {\n         ///\n         /// assert_eq!(n.rotate_left(12), m);\n         /// ```\n-        #[unstable(feature = \"core\",\n-                   reason = \"pending integer conventions\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn rotate_left(self, n: u32) -> $T {\n             (self as $UnsignedT).rotate_left(n) as $T\n@@ -901,8 +947,7 @@ macro_rules! int_impl {\n         ///\n         /// assert_eq!(n.rotate_right(12), m);\n         /// ```\n-        #[unstable(feature = \"core\",\n-                   reason = \"pending integer conventions\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn rotate_right(self, n: u32) -> $T {\n             (self as $UnsignedT).rotate_right(n) as $T\n@@ -1103,8 +1148,8 @@ macro_rules! int_impl {\n         pub fn saturating_add(self, other: $T) -> $T {\n             match self.checked_add(other) {\n                 Some(x)                       => x,\n-                None if other >= <$T>::zero() => <$T>::max_value(),\n-                None                          => <$T>::min_value(),\n+                None if other >= <$T as Zero>::zero() => <$T>::max_value(),\n+                None => <$T>::min_value(),\n             }\n         }\n \n@@ -1115,8 +1160,38 @@ macro_rules! int_impl {\n         pub fn saturating_sub(self, other: $T) -> $T {\n             match self.checked_sub(other) {\n                 Some(x)                      => x,\n-                None if other >= <$T>::zero() => <$T>::min_value(),\n-                None                          => <$T>::max_value(),\n+                None if other >= <$T as Zero>::zero() => <$T>::min_value(),\n+                None => <$T>::max_value(),\n+            }\n+        }\n+\n+        /// Wrapping (modular) addition. Computes `self + other`,\n+        /// wrapping around at the boundary of the type.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn wrapping_add(self, rhs: $T) -> $T {\n+            unsafe {\n+                intrinsics::overflowing_add(self, rhs)\n+            }\n+        }\n+\n+        /// Wrapping (modular) subtraction. Computes `self - other`,\n+        /// wrapping around at the boundary of the type.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn wrapping_sub(self, rhs: $T) -> $T {\n+            unsafe {\n+                intrinsics::overflowing_sub(self, rhs)\n+            }\n+        }\n+\n+        /// Wrapping (modular) multiplication. Computes `self *\n+        /// other`, wrapping around at the boundary of the type.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn wrapping_mul(self, rhs: $T) -> $T {\n+            unsafe {\n+                intrinsics::overflowing_mul(self, rhs)\n             }\n         }\n \n@@ -1130,12 +1205,11 @@ macro_rules! int_impl {\n         ///\n         /// assert_eq!(2.pow(4), 16);\n         /// ```\n-        #[unstable(feature = \"core\",\n-                   reason = \"pending integer conventions\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn pow(self, mut exp: u32) -> $T {\n             let mut base = self;\n-            let mut acc = <$T>::one();\n+            let mut acc = <$T as One>::one();\n \n             let mut prev_base = self;\n             let mut base_oflo = false;\n@@ -1161,7 +1235,7 @@ macro_rules! int_impl {\n \n         /// Computes the absolute value of `self`. `Int::min_value()` will be\n         /// returned if the number is `Int::min_value()`.\n-        #[unstable(feature = \"core\", reason = \"overflow in debug builds?\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn abs(self) -> $T {\n             if self.is_negative() { -self } else { self }\n@@ -1256,35 +1330,25 @@ macro_rules! uint_impl {\n      $add_with_overflow:path,\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n-        /// Returns the `0` value of this integer type.\n-        // FIXME (#5527): Should be an associated constant\n-        #[unstable(feature = \"core\",\n-                   reason = \"unsure about its place in the world\")]\n-        #[inline]\n-        pub fn zero() -> $T { 0 }\n-\n-        /// Returns the `1` value of this integer type.\n-        // FIXME (#5527): Should be an associated constant\n-        #[unstable(feature = \"core\",\n-                   reason = \"unsure about its place in the world\")]\n-        #[inline]\n-        pub fn one() -> $T { 1 }\n-\n-        /// Returns the smallest value that can be represented by this integer\n-        /// type.\n-        // FIXME (#5527): Should be and associated constant\n-        #[unstable(feature = \"core\",\n-                   reason = \"unsure about its place in the world\")]\n-        #[inline]\n-        pub fn min_value() -> $T { 0 }\n-\n-        /// Returns the largest value that can be represented by this integer\n-        /// type.\n-        // FIXME (#5527): Should be and associated constant\n-        #[unstable(feature = \"core\",\n-                   reason = \"unsure about its place in the world\")]\n-        #[inline]\n-        pub fn max_value() -> $T { -1 }\n+        /// Convert a string slice in a given base to an integer.\n+        ///\n+        /// Leading and trailing whitespace represent an error.\n+        ///\n+        /// # Arguments\n+        ///\n+        /// * src - A string slice\n+        /// * radix - The base to use. Must lie in the range [2 .. 36]\n+        ///\n+        /// # Return value\n+        ///\n+        /// `None` if the string did not represent a valid number.\n+        /// Otherwise, `Some(n)` where `n` is the integer represented\n+        /// by `src`.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[allow(deprecated)]\n+        pub fn from_str_radix(src: &str, radix: u32) -> Result<$T, ParseIntError> {\n+            <Self as FromStrRadix>::from_str_radix(src, radix)\n+        }\n \n         /// Returns the number of ones in the binary representation of `self`.\n         ///\n@@ -1298,8 +1362,7 @@ macro_rules! uint_impl {\n         ///\n         /// assert_eq!(n.count_ones(), 3);\n         /// ```\n-        #[unstable(feature = \"core\",\n-                   reason = \"pending integer conventions\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn count_ones(self) -> u32 {\n             unsafe { $ctpop(self as $ActualT) as u32 }\n@@ -1317,8 +1380,7 @@ macro_rules! uint_impl {\n         ///\n         /// assert_eq!(n.count_zeros(), 5);\n         /// ```\n-        #[unstable(feature = \"core\",\n-                   reason = \"pending integer conventions\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn count_zeros(self) -> u32 {\n             (!self).count_ones()\n@@ -1337,8 +1399,7 @@ macro_rules! uint_impl {\n         ///\n         /// assert_eq!(n.leading_zeros(), 10);\n         /// ```\n-        #[unstable(feature = \"core\",\n-                   reason = \"pending integer conventions\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn leading_zeros(self) -> u32 {\n             unsafe { $ctlz(self as $ActualT) as u32 }\n@@ -1357,8 +1418,7 @@ macro_rules! uint_impl {\n         ///\n         /// assert_eq!(n.trailing_zeros(), 3);\n         /// ```\n-        #[unstable(feature = \"core\",\n-                   reason = \"pending integer conventions\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn trailing_zeros(self) -> u32 {\n             unsafe { $cttz(self as $ActualT) as u32 }\n@@ -1378,8 +1438,7 @@ macro_rules! uint_impl {\n         ///\n         /// assert_eq!(n.rotate_left(12), m);\n         /// ```\n-        #[unstable(feature = \"core\",\n-                   reason = \"pending integer conventions\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn rotate_left(self, n: u32) -> $T {\n             // Protect against undefined behaviour for over-long bit shifts\n@@ -1402,8 +1461,7 @@ macro_rules! uint_impl {\n         ///\n         /// assert_eq!(n.rotate_right(12), m);\n         /// ```\n-        #[unstable(feature = \"core\",\n-                   reason = \"pending integer conventions\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn rotate_right(self, n: u32) -> $T {\n             // Protect against undefined behaviour for over-long bit shifts\n@@ -1604,8 +1662,8 @@ macro_rules! uint_impl {\n         pub fn saturating_add(self, other: $T) -> $T {\n             match self.checked_add(other) {\n                 Some(x)                       => x,\n-                None if other >= <$T>::zero() => <$T>::max_value(),\n-                None                          => <$T>::min_value(),\n+                None if other >= <$T as Zero>::zero() => <$T>::max_value(),\n+                None => <$T>::min_value(),\n             }\n         }\n \n@@ -1616,8 +1674,38 @@ macro_rules! uint_impl {\n         pub fn saturating_sub(self, other: $T) -> $T {\n             match self.checked_sub(other) {\n                 Some(x)                       => x,\n-                None if other >= <$T>::zero() => <$T>::min_value(),\n-                None                          => <$T>::max_value(),\n+                None if other >= <$T as Zero>::zero() => <$T>::min_value(),\n+                None => <$T>::max_value(),\n+            }\n+        }\n+\n+        /// Wrapping (modular) addition. Computes `self + other`,\n+        /// wrapping around at the boundary of the type.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn wrapping_add(self, rhs: $T) -> $T {\n+            unsafe {\n+                intrinsics::overflowing_add(self, rhs)\n+            }\n+        }\n+\n+        /// Wrapping (modular) subtraction. Computes `self - other`,\n+        /// wrapping around at the boundary of the type.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn wrapping_sub(self, rhs: $T) -> $T {\n+            unsafe {\n+                intrinsics::overflowing_sub(self, rhs)\n+            }\n+        }\n+\n+        /// Wrapping (modular) multiplication. Computes `self *\n+        /// other`, wrapping around at the boundary of the type.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        pub fn wrapping_mul(self, rhs: $T) -> $T {\n+            unsafe {\n+                intrinsics::overflowing_mul(self, rhs)\n             }\n         }\n \n@@ -1631,12 +1719,11 @@ macro_rules! uint_impl {\n         ///\n         /// assert_eq!(2.pow(4), 16);\n         /// ```\n-        #[unstable(feature = \"core\",\n-                   reason = \"pending integer conventions\")]\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn pow(self, mut exp: u32) -> $T {\n             let mut base = self;\n-            let mut acc = <$T>::one();\n+            let mut acc = <$T as One>::one();\n \n             let mut prev_base = self;\n             let mut base_oflo = false;\n@@ -1664,8 +1751,8 @@ macro_rules! uint_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn is_power_of_two(self) -> bool {\n-            (self.wrapping_sub(<$T>::one())) & self == <$T>::zero() &&\n-                !(self == <$T>::zero())\n+            (self.wrapping_sub(<$T as One>::one())) & self == <$T as Zero>::zero() &&\n+                !(self == <$T as Zero>::zero())\n         }\n \n         /// Returns the smallest power of two greater than or equal to `self`.\n@@ -1674,7 +1761,7 @@ macro_rules! uint_impl {\n         #[inline]\n         pub fn next_power_of_two(self) -> $T {\n             let bits = size_of::<$T>() * 8;\n-            let one: $T = <$T>::one();\n+            let one: $T = <$T as One>::one();\n             one << ((bits - self.wrapping_sub(one).leading_zeros() as usize) % bits)\n         }\n \n@@ -2339,17 +2426,26 @@ impl_num_cast! { f64,   to_f64 }\n \n /// Used for representing the classification of floating point numbers\n #[derive(Copy, PartialEq, Debug)]\n-#[unstable(feature = \"core\", reason = \"may be renamed\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum FpCategory {\n     /// \"Not a Number\", often obtained by dividing by zero\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Nan,\n+\n     /// Positive or negative infinity\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Infinite ,\n+\n     /// Positive or negative zero\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Zero,\n+\n     /// De-normalized floating point representation (less precise than `Normal`)\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Subnormal,\n+\n     /// A regular floating point number\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Normal,\n }\n \n@@ -2526,13 +2622,24 @@ pub trait Float\n \n /// A generic trait for converting a string with a radix (base) to a value\n #[unstable(feature = \"core\", reason = \"needs reevaluation\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"moved to inherent methods; use e.g. i32::from_str_radix\")]\n pub trait FromStrRadix {\n+    #[unstable(feature = \"core\", reason = \"needs reevaluation\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"moved to inherent methods\")]\n     type Err;\n+\n+    #[unstable(feature = \"core\", reason = \"needs reevaluation\")]\n+    #[deprecated(since = \"1.0.0\",\n+                 reason = \"moved to inherent methods; use e.g. i32::from_str_radix\")]\n+    #[allow(deprecated)]\n     fn from_str_radix(str: &str, radix: u32) -> Result<Self, Self::Err>;\n }\n \n /// A utility function that just calls `FromStrRadix::from_str_radix`.\n #[unstable(feature = \"core\", reason = \"needs reevaluation\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use e.g. i32::from_str_radix\")]\n+#[allow(deprecated)]\n pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: u32)\n                                        -> Result<T, T::Err> {\n     FromStrRadix::from_str_radix(str, radix)\n@@ -2570,12 +2677,14 @@ macro_rules! from_str_radix_float_impl {\n             /// `None` if the string did not represent a valid number.  Otherwise,\n             /// `Some(n)` where `n` is the floating-point number represented by `src`.\n             #[inline]\n+            #[allow(deprecated)]\n             fn from_str(src: &str) -> Result<$T, ParseFloatError> {\n                 from_str_radix(src, 10)\n             }\n         }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[allow(deprecated)]\n         impl FromStrRadix for $T {\n             type Err = ParseFloatError;\n \n@@ -2746,6 +2855,7 @@ from_str_radix_float_impl! { f64 }\n macro_rules! from_str_radix_int_impl {\n     ($T:ty) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[allow(deprecated)]\n         impl FromStr for $T {\n             type Err = ParseIntError;\n             #[inline]\n@@ -2755,6 +2865,7 @@ macro_rules! from_str_radix_int_impl {\n         }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[allow(deprecated)]\n         impl FromStrRadix for $T {\n             type Err = ParseIntError;\n             fn from_str_radix(src: &str, radix: u32)"}, {"sha": "bda05a3d9e885aff66f7929816cbe13a360ac0d3", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 106, "deletions": 72, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -7,7 +7,11 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+\n #![allow(missing_docs)]\n+#![allow(deprecated)]\n+\n+use super::Wrapping;\n \n use ops::*;\n \n@@ -26,6 +30,8 @@ use intrinsics::{i16_mul_with_overflow, u16_mul_with_overflow};\n use intrinsics::{i32_mul_with_overflow, u32_mul_with_overflow};\n use intrinsics::{i64_mul_with_overflow, u64_mul_with_overflow};\n \n+#[unstable(feature = \"core\", reason = \"may be removed, renamed, or relocated\")]\n+#[deprecated(since = \"1.0.0\", reason = \"moved to inherent methods\")]\n pub trait WrappingOps {\n     fn wrapping_add(self, rhs: Self) -> Self;\n     fn wrapping_sub(self, rhs: Self) -> Self;\n@@ -39,6 +45,49 @@ pub trait OverflowingOps {\n     fn overflowing_mul(self, rhs: Self) -> (Self, bool);\n }\n \n+macro_rules! sh_impl {\n+    ($t:ty, $f:ty) => (\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Shl<$f> for Wrapping<$t> {\n+            type Output = Wrapping<$t>;\n+\n+            #[inline(always)]\n+            fn shl(self, other: $f) -> Wrapping<$t> {\n+                Wrapping(self.0 << other)\n+            }\n+        }\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Shr<$f> for Wrapping<$t> {\n+            type Output = Wrapping<$t>;\n+\n+            #[inline(always)]\n+            fn shr(self, other: $f) -> Wrapping<$t> {\n+                Wrapping(self.0 >> other)\n+            }\n+        }\n+    )\n+}\n+\n+// FIXME (#23545): uncomment the remaining impls\n+macro_rules! sh_impl_all {\n+    ($($t:ty)*) => ($(\n+        // sh_impl! { $t, u8 }\n+        // sh_impl! { $t, u16 }\n+        // sh_impl! { $t, u32 }\n+        // sh_impl! { $t, u64 }\n+        sh_impl! { $t, usize }\n+\n+        // sh_impl! { $t, i8 }\n+        // sh_impl! { $t, i16 }\n+        // sh_impl! { $t, i32 }\n+        // sh_impl! { $t, i64 }\n+        // sh_impl! { $t, isize }\n+    )*)\n+}\n+\n+sh_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n+\n macro_rules! wrapping_impl {\n     ($($t:ty)*) => ($(\n         impl WrappingOps for $t {\n@@ -61,94 +110,79 @@ macro_rules! wrapping_impl {\n                 }\n             }\n         }\n-    )*)\n-}\n-\n-wrapping_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n-\n-#[unstable(feature = \"core\", reason = \"may be removed, renamed, or relocated\")]\n-#[derive(PartialEq, Eq, PartialOrd, Ord, Debug, Clone, Copy)]\n-pub struct Wrapping<T>(pub T);\n-\n-impl<T:WrappingOps> Add for Wrapping<T> {\n-    type Output = Wrapping<T>;\n \n-    #[inline(always)]\n-    fn add(self, other: Wrapping<T>) -> Wrapping<T> {\n-        Wrapping(self.0.wrapping_add(other.0))\n-    }\n-}\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Add for Wrapping<$t> {\n+            type Output = Wrapping<$t>;\n \n-impl<T:WrappingOps> Sub for Wrapping<T> {\n-    type Output = Wrapping<T>;\n-\n-    #[inline(always)]\n-    fn sub(self, other: Wrapping<T>) -> Wrapping<T> {\n-        Wrapping(self.0.wrapping_sub(other.0))\n-    }\n-}\n+            #[inline(always)]\n+            fn add(self, other: Wrapping<$t>) -> Wrapping<$t> {\n+                Wrapping(self.0.wrapping_add(other.0))\n+            }\n+        }\n \n-impl<T:WrappingOps> Mul for Wrapping<T> {\n-    type Output = Wrapping<T>;\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Sub for Wrapping<$t> {\n+            type Output = Wrapping<$t>;\n \n-    #[inline(always)]\n-    fn mul(self, other: Wrapping<T>) -> Wrapping<T> {\n-        Wrapping(self.0.wrapping_mul(other.0))\n-    }\n-}\n+            #[inline(always)]\n+            fn sub(self, other: Wrapping<$t>) -> Wrapping<$t> {\n+                Wrapping(self.0.wrapping_sub(other.0))\n+            }\n+        }\n \n-impl<T:WrappingOps+Not<Output=T>> Not for Wrapping<T> {\n-    type Output = Wrapping<T>;\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Mul for Wrapping<$t> {\n+            type Output = Wrapping<$t>;\n \n-    fn not(self) -> Wrapping<T> {\n-        Wrapping(!self.0)\n-    }\n-}\n+            #[inline(always)]\n+            fn mul(self, other: Wrapping<$t>) -> Wrapping<$t> {\n+                Wrapping(self.0.wrapping_mul(other.0))\n+            }\n+        }\n \n-impl<T:WrappingOps+BitXor<Output=T>> BitXor for Wrapping<T> {\n-    type Output = Wrapping<T>;\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Not for Wrapping<$t> {\n+            type Output = Wrapping<$t>;\n \n-    #[inline(always)]\n-    fn bitxor(self, other: Wrapping<T>) -> Wrapping<T> {\n-        Wrapping(self.0 ^ other.0)\n-    }\n-}\n+            fn not(self) -> Wrapping<$t> {\n+                Wrapping(!self.0)\n+            }\n+        }\n \n-impl<T:WrappingOps+BitOr<Output=T>> BitOr for Wrapping<T> {\n-    type Output = Wrapping<T>;\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl BitXor for Wrapping<$t> {\n+            type Output = Wrapping<$t>;\n \n-    #[inline(always)]\n-    fn bitor(self, other: Wrapping<T>) -> Wrapping<T> {\n-        Wrapping(self.0 | other.0)\n-    }\n-}\n+            #[inline(always)]\n+            fn bitxor(self, other: Wrapping<$t>) -> Wrapping<$t> {\n+                Wrapping(self.0 ^ other.0)\n+            }\n+        }\n \n-impl<T:WrappingOps+BitAnd<Output=T>> BitAnd for Wrapping<T> {\n-    type Output = Wrapping<T>;\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl BitOr for Wrapping<$t> {\n+            type Output = Wrapping<$t>;\n \n-    #[inline(always)]\n-    fn bitand(self, other: Wrapping<T>) -> Wrapping<T> {\n-        Wrapping(self.0 & other.0)\n-    }\n-}\n+            #[inline(always)]\n+            fn bitor(self, other: Wrapping<$t>) -> Wrapping<$t> {\n+                Wrapping(self.0 | other.0)\n+            }\n+        }\n \n-impl<T:WrappingOps+Shl<usize,Output=T>> Shl<usize> for Wrapping<T> {\n-    type Output = Wrapping<T>;\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl BitAnd for Wrapping<$t> {\n+            type Output = Wrapping<$t>;\n \n-    #[inline(always)]\n-    fn shl(self, other: usize) -> Wrapping<T> {\n-        Wrapping(self.0 << other)\n-    }\n+            #[inline(always)]\n+            fn bitand(self, other: Wrapping<$t>) -> Wrapping<$t> {\n+                Wrapping(self.0 & other.0)\n+            }\n+        }\n+    )*)\n }\n \n-impl<T:WrappingOps+Shr<usize,Output=T>> Shr<usize> for Wrapping<T> {\n-    type Output = Wrapping<T>;\n-\n-    #[inline(always)]\n-    fn shr(self, other: usize) -> Wrapping<T> {\n-        Wrapping(self.0 >> other)\n-    }\n-}\n+wrapping_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n \n macro_rules! overflowing_impl {\n     ($($t:ident)*) => ($("}, {"sha": "f9e2b47d9b63428ab8bb4c87a610ebb548ebc31d", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -945,9 +945,9 @@ impl TwoWaySearcher {\n     // critical factorization (u, v) and p = period(v)\n     #[inline]\n     #[allow(dead_code)]\n+    #[allow(deprecated)]\n     fn maximal_suffix(arr: &[u8], reversed: bool) -> (usize, usize) {\n-        use num::wrapping::WrappingOps;\n-        let mut left = -1; // Corresponds to i in the paper\n+        let mut left: usize = -1; // Corresponds to i in the paper\n         let mut right = 0; // Corresponds to j in the paper\n         let mut offset = 1; // Corresponds to k in the paper\n         let mut period = 1; // Corresponds to p in the paper"}, {"sha": "a7f7889783f70b775d40791d669efb547023a4bb", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -14,8 +14,8 @@\n \n use core::prelude::*;\n use core::slice;\n-use core::iter::{range_step, repeat};\n-use core::num::wrapping::Wrapping as w;\n+use core::iter::repeat;\n+use core::num::Wrapping as w;\n \n use {Rng, SeedableRng, Rand};\n \n@@ -95,7 +95,7 @@ impl IsaacRng {\n         if use_rsl {\n             macro_rules! memloop {\n                 ($arr:expr) => {{\n-                    for i in range_step(0, RAND_SIZE_USIZE, 8) {\n+                    for i in (0..RAND_SIZE_USIZE).step_by(8) {\n                         a=a+$arr[i  ]; b=b+$arr[i+1];\n                         c=c+$arr[i+2]; d=d+$arr[i+3];\n                         e=e+$arr[i+4]; f=f+$arr[i+5];\n@@ -112,7 +112,7 @@ impl IsaacRng {\n             memloop!(self.rsl);\n             memloop!(self.mem);\n         } else {\n-            for i in range_step(0, RAND_SIZE_USIZE, 8) {\n+            for i in (0..RAND_SIZE_USIZE).step_by(8) {\n                 mix!();\n                 self.mem[i  ]=a; self.mem[i+1]=b;\n                 self.mem[i+2]=c; self.mem[i+3]=d;\n@@ -136,7 +136,7 @@ impl IsaacRng {\n         const MIDPOINT: usize = RAND_SIZE_USIZE / 2;\n \n         macro_rules! ind {\n-            ($x:expr) => ( self.mem[($x >> 2).0 as usize & (RAND_SIZE_USIZE - 1)] )\n+            ($x:expr) => (self.mem[($x >> 2).0 as usize & (RAND_SIZE_USIZE - 1)] )\n         }\n \n         let r = [(0, MIDPOINT), (MIDPOINT, 0)];\n@@ -172,7 +172,7 @@ impl IsaacRng {\n                 }}\n             }\n \n-            for i in range_step(0, MIDPOINT, 4) {\n+            for i in (0..MIDPOINT).step_by(4) {\n                 rngstepp!(i + 0, 13);\n                 rngstepn!(i + 1, 6);\n                 rngstepp!(i + 2, 2);"}, {"sha": "85f3c621c7e88b9412c95600b1c6f379c0b381fd", "filename": "src/librand/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -30,6 +30,7 @@\n #![feature(staged_api)]\n #![staged_api]\n #![feature(core)]\n+#![feature(step_by)]\n #![deprecated(reason = \"use the crates.io `rand` library instead\",\n               since = \"1.0.0-alpha\")]\n "}, {"sha": "092cd780ec7c7cfb02efc8e16e996c3f8d5ae1d7", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -241,7 +241,6 @@ pub mod reader {\n \n     use std::isize;\n     use std::mem::transmute;\n-    use std::num::Int;\n     use std::slice::bytes;\n \n     use serialize;\n@@ -346,7 +345,7 @@ pub mod reader {\n \n         unsafe {\n             let ptr = data.as_ptr().offset(start as isize) as *const u32;\n-            let val = Int::from_be(*ptr);\n+            let val = u32::from_be(*ptr);\n \n             let i = (val >> 28) as usize;\n             let (shift, mask) = SHIFT_MASK_TABLE[i];\n@@ -835,7 +834,6 @@ pub mod reader {\n \n pub mod writer {\n     use std::mem;\n-    use std::num::Int;\n     use std::io::prelude::*;\n     use std::io::{self, SeekFrom, Cursor};\n     use std::slice::bytes;"}, {"sha": "92810b407f039dde41f2dc16ee97e6878585ed43", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -35,7 +35,7 @@ use std::collections::HashMap;\n use std::hash::{self, Hash, SipHasher};\n use std::io::prelude::*;\n use std::io;\n-use std::num::{FromPrimitive, Int};\n+use std::num::FromPrimitive;\n use std::rc::Rc;\n use std::slice::bytes;\n use std::str;"}, {"sha": "161fae11ea6d42c1f254f80f5db9e700c447e72e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -5491,7 +5491,6 @@ pub fn type_is_empty(cx: &ctxt, ty: Ty) -> bool {\n \n pub fn enum_variants<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                            -> Rc<Vec<Rc<VariantInfo<'tcx>>>> {\n-    use std::num::Int; // For checked_add\n     memoized(&cx.enum_var_cache, id, |id: ast::DefId| {\n         if ast::LOCAL_CRATE != id.krate {\n             Rc::new(csearch::get_enum_variants(cx, id))"}, {"sha": "8f0387059e4a9d2418026461782f3d9c585f4008", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -64,7 +64,7 @@ impl ToBits for u64 {\n fn add_bytes_to_bits<T: Int + ToBits>(bits: T, bytes: T) -> T {\n     let (new_high_bits, new_low_bits) = bytes.to_bits();\n \n-    if new_high_bits > Int::zero() {\n+    if new_high_bits > T::zero() {\n         panic!(\"numeric overflow occurred.\")\n     }\n \n@@ -537,7 +537,7 @@ mod tests {\n     use self::rand::isaac::IsaacRng;\n     use serialize::hex::FromHex;\n     use std::iter::repeat;\n-    use std::num::Int;\n+    use std::u64;\n     use super::{Digest, Sha256, FixedBuffer};\n \n     // A normal addition - no overflow occurs\n@@ -550,7 +550,7 @@ mod tests {\n     #[test]\n     #[should_panic]\n     fn test_add_bytes_to_bits_overflow() {\n-        super::add_bytes_to_bits::<u64>(Int::max_value(), 1);\n+        super::add_bytes_to_bits::<u64>(u64::MAX, 1);\n     }\n \n     struct Test {"}, {"sha": "e7443af3013aeff4519b5eae2585187b7257782f", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -41,7 +41,6 @@ use lint::{Level, Context, LintPass, LintArray, Lint};\n \n use std::collections::{HashSet, BitSet};\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n-use std::num::SignedInt;\n use std::{cmp, slice};\n use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n "}, {"sha": "4e099a4ca875e1b6873ad1aa59006b9ea1e58fb2", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -22,6 +22,7 @@ use flate;\n \n use std::ffi::CString;\n use std::mem;\n+#[allow(deprecated)]\n use std::num::Int;\n \n pub fn run(sess: &session::Session, llmod: ModuleRef,\n@@ -204,6 +205,7 @@ fn extract_compressed_bytecode_size_v1(bc: &[u8]) -> u64 {\n     return read_from_le_bytes::<u64>(bc, link::RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET);\n }\n \n+#[allow(deprecated)]\n fn read_from_le_bytes<T: Int>(bytes: &[u8], position_in_bytes: usize) -> T {\n     let byte_data = &bytes[position_in_bytes..position_in_bytes + mem::size_of::<T>()];\n     let data = unsafe {"}, {"sha": "e32d8e2b9cfdf8a7924442365489a2fb75598cd5", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -45,6 +45,7 @@\n \n pub use self::Repr::*;\n \n+#[allow(deprecated)]\n use std::num::Int;\n use std::rc::Rc;\n "}, {"sha": "2e577a0bd19b0a0e232dd0a01de4e1a86fd2723d", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -21,6 +21,7 @@ use util::ppaux::Repr;\n \n use trans::type_::Type;\n \n+#[allow(deprecated)]\n use std::num::Int;\n use syntax::abi;\n use syntax::ast;"}, {"sha": "16501ec280791d2886daffee7a0d39d9e71d4645", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -4285,7 +4285,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                           id: ast::NodeId,\n                           hint: attr::ReprAttr)\n                           -> Vec<Rc<ty::VariantInfo<'tcx>>> {\n-        use std::num::Int;\n+        #![allow(trivial_numeric_casts)]\n \n         let rty = ty::node_id_to_type(ccx.tcx, id);\n         let mut variants: Vec<Rc<ty::VariantInfo>> = Vec::new();"}, {"sha": "2d5d8cd501a46100e1fc493b03d382b6139ca784", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -204,6 +204,8 @@ use std::io::prelude::*;\n use std::io;\n use std::mem::swap;\n use std::num::FpCategory as Fp;\n+#[allow(deprecated)]\n+use std::num::wrapping::WrappingOps;\n use std::ops::Index;\n use std::str::FromStr;\n use std::string;\n@@ -1552,6 +1554,7 @@ impl<T: Iterator<Item=char>> Parser<T> {\n         }\n     }\n \n+    #[allow(deprecated)] // possible resolve bug is mapping these to traits\n     fn parse_u64(&mut self) -> Result<u64, ParserError> {\n         let mut accum = 0;\n         let last_accum = 0; // necessary to detect overflow."}, {"sha": "d8e403376bdc734a6d7a4db7988cf785c675d6ea", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -14,7 +14,6 @@ use io::prelude::*;\n use cmp;\n use io::{self, SeekFrom, Error, ErrorKind};\n use iter::repeat;\n-use num::Int;\n use slice;\n \n /// A `Cursor` is a type which wraps a non-I/O object to provide a `Seek`"}, {"sha": "ee57300765e8ef3fb19a8ceeef83642cd5743f00", "filename": "src/libstd/net/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -18,6 +18,7 @@\n use prelude::v1::*;\n \n use io::{self, Error, ErrorKind};\n+#[allow(deprecated)] // Int\n use num::Int;\n use sys_common::net2 as net_imp;\n \n@@ -54,7 +55,9 @@ pub enum Shutdown {\n     Both,\n }\n \n+#[allow(deprecated)] // Int\n fn hton<I: Int>(i: I) -> I { i.to_be() }\n+#[allow(deprecated)] // Int\n fn ntoh<I: Int>(i: I) -> I { Int::from_be(i) }\n \n fn each_addr<A: ToSocketAddrs, F, T>(addr: A, mut f: F) -> io::Result<T>"}, {"sha": "0ae4d3c5bd66b13f269729986f6d510911187bed", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 249, "deletions": 507, "changes": 756, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -75,6 +75,7 @@ mod cmath {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n impl Float for f32 {\n     #[inline]\n     fn nan() -> f32 { num::Float::nan() }\n@@ -361,272 +362,59 @@ impl Float for f32 {\n #[lang = \"f32\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl f32 {\n-    // inlined methods from `num::Float`\n-    /// Returns the `NaN` value.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let nan: f32 = Float::nan();\n-    ///\n-    /// assert!(nan.is_nan());\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    #[inline]\n-    pub fn nan() -> f32 { num::Float::nan() }\n-\n-    /// Returns the infinite value.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f32;\n-    ///\n-    /// let infinity: f32 = Float::infinity();\n-    ///\n-    /// assert!(infinity.is_infinite());\n-    /// assert!(!infinity.is_finite());\n-    /// assert!(infinity > f32::MAX);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    #[inline]\n-    pub fn infinity() -> f32 { num::Float::infinity() }\n-\n-    /// Returns the negative infinite value.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f32;\n-    ///\n-    /// let neg_infinity: f32 = Float::neg_infinity();\n-    ///\n-    /// assert!(neg_infinity.is_infinite());\n-    /// assert!(!neg_infinity.is_finite());\n-    /// assert!(neg_infinity < f32::MIN);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    #[inline]\n-    pub fn neg_infinity() -> f32 { num::Float::neg_infinity() }\n-\n-    /// Returns `0.0`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let inf: f32 = Float::infinity();\n-    /// let zero: f32 = Float::zero();\n-    /// let neg_zero: f32 = Float::neg_zero();\n-    ///\n-    /// assert_eq!(zero, neg_zero);\n-    /// assert_eq!(7.0f32/inf, zero);\n-    /// assert_eq!(zero * 10.0, zero);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    #[inline]\n-    pub fn zero() -> f32 { num::Float::zero() }\n-\n-    /// Returns `-0.0`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let inf: f32 = Float::infinity();\n-    /// let zero: f32 = Float::zero();\n-    /// let neg_zero: f32 = Float::neg_zero();\n-    ///\n-    /// assert_eq!(zero, neg_zero);\n-    /// assert_eq!(7.0f32/inf, zero);\n-    /// assert_eq!(zero * 10.0, zero);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    #[inline]\n-    pub fn neg_zero() -> f32 { num::Float::neg_zero() }\n-\n-    /// Returns `1.0`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let one: f32 = Float::one();\n-    ///\n-    /// assert_eq!(one, 1.0f32);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    #[inline]\n-    pub fn one() -> f32 { num::Float::one() }\n-\n-    // FIXME (#5527): These should be associated constants\n-\n-    /// Deprecated: use `std::f32::MANTISSA_DIGITS` or `std::f64::MANTISSA_DIGITS`\n-    /// instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MANTISSA_DIGITS` or \\\n-                           `std::f64::MANTISSA_DIGITS` as appropriate\")]\n-    #[allow(deprecated)]\n-    #[inline]\n-    pub fn mantissa_digits(unused_self: Option<f32>) -> usize {\n-        num::Float::mantissa_digits(unused_self)\n-    }\n-\n-    /// Deprecated: use `std::f32::DIGITS` or `std::f64::DIGITS` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\")]\n-    #[allow(deprecated)]\n-    #[inline]\n-    pub fn digits(unused_self: Option<f32>) -> usize { num::Float::digits(unused_self) }\n-\n-    /// Deprecated: use `std::f32::EPSILON` or `std::f64::EPSILON` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::EPSILON` or `std::f64::EPSILON` as appropriate\")]\n-    #[allow(deprecated)]\n-    #[inline]\n-    pub fn epsilon() -> f32 { num::Float::epsilon() }\n-\n-    /// Deprecated: use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\")]\n-    #[allow(deprecated)]\n-    #[inline]\n-    pub fn min_exp(unused_self: Option<f32>) -> isize { num::Float::min_exp(unused_self) }\n-\n-    /// Deprecated: use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\")]\n-    #[allow(deprecated)]\n-    #[inline]\n-    pub fn max_exp(unused_self: Option<f32>) -> isize { num::Float::max_exp(unused_self) }\n-\n-    /// Deprecated: use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\")]\n-    #[allow(deprecated)]\n-    #[inline]\n-    pub fn min_10_exp(unused_self: Option<f32>) -> isize { num::Float::min_10_exp(unused_self) }\n-\n-    /// Deprecated: use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\")]\n-    #[allow(deprecated)]\n-    #[inline]\n-    pub fn max_10_exp(unused_self: Option<f32>) -> isize { num::Float::max_10_exp(unused_self) }\n-\n-    /// Returns the smallest finite value that this type can represent.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x: f64 = Float::min_value();\n-    ///\n-    /// assert_eq!(x, f64::MIN);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    #[inline]\n-    #[allow(deprecated)]\n-    pub fn min_value() -> f32 { num::Float::min_value() }\n-\n-    /// Returns the smallest normalized positive number that this type can represent.\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    #[inline]\n-    #[allow(deprecated)]\n-    pub fn min_pos_value(unused_self: Option<f32>) -> f32 { num::Float::min_pos_value(unused_self) }\n-\n-    /// Returns the largest finite value that this type can represent.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x: f64 = Float::max_value();\n-    /// assert_eq!(x, f64::MAX);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    #[inline]\n-    #[allow(deprecated)]\n-    pub fn max_value() -> f32 { num::Float::max_value() }\n-\n     /// Returns `true` if this value is `NaN` and false otherwise.\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f64;\n+    /// use std::f32;\n     ///\n-    /// let nan = f64::NAN;\n-    /// let f = 7.0;\n+    /// let nan = f32::NAN;\n+    /// let f = 7.0_f32;\n     ///\n     /// assert!(nan.is_nan());\n     /// assert!(!f.is_nan());\n     /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_nan(self) -> bool { num::Float::is_nan(self) }\n \n     /// Returns `true` if this value is positive infinity or negative infinity and\n     /// false otherwise.\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n     /// use std::f32;\n     ///\n     /// let f = 7.0f32;\n-    /// let inf: f32 = Float::infinity();\n-    /// let neg_inf: f32 = Float::neg_infinity();\n-    /// let nan: f32 = f32::NAN;\n+    /// let inf = f32::INFINITY;\n+    /// let neg_inf = f32::NEG_INFINITY;\n+    /// let nan = f32::NAN;\n     ///\n     /// assert!(!f.is_infinite());\n     /// assert!(!nan.is_infinite());\n     ///\n     /// assert!(inf.is_infinite());\n     /// assert!(neg_inf.is_infinite());\n     /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_infinite(self) -> bool { num::Float::is_infinite(self) }\n \n     /// Returns `true` if this number is neither infinite nor `NaN`.\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n     /// use std::f32;\n     ///\n     /// let f = 7.0f32;\n-    /// let inf: f32 = Float::infinity();\n-    /// let neg_inf: f32 = Float::neg_infinity();\n-    /// let nan: f32 = f32::NAN;\n+    /// let inf = f32::INFINITY;\n+    /// let neg_inf = f32::NEG_INFINITY;\n+    /// let nan = f32::NAN;\n     ///\n     /// assert!(f.is_finite());\n     ///\n     /// assert!(!nan.is_finite());\n     /// assert!(!inf.is_finite());\n     /// assert!(!neg_inf.is_finite());\n     /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_finite(self) -> bool { num::Float::is_finite(self) }\n \n@@ -635,13 +423,12 @@ impl f32 {\n     ///\n     /// ```\n     /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n     /// use std::f32;\n     ///\n     /// let min = f32::MIN_POSITIVE; // 1.17549435e-38f32\n     /// let max = f32::MAX;\n     /// let lower_than_min = 1.0e-40_f32;\n-    /// let zero = 0.0f32;\n+    /// let zero = 0.0_f32;\n     ///\n     /// assert!(min.is_normal());\n     /// assert!(max.is_normal());\n@@ -653,7 +440,7 @@ impl f32 {\n     /// assert!(!lower_than_min.is_normal());\n     /// ```\n     /// [subnormal]: http://en.wikipedia.org/wiki/Denormal_number\n-    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_normal(self) -> bool { num::Float::is_normal(self) }\n \n@@ -662,11 +449,10 @@ impl f32 {\n     /// predicate instead.\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::{Float, FpCategory};\n+    /// use std::num::FpCategory;\n     /// use std::f32;\n     ///\n-    /// let num = 12.4f32;\n+    /// let num = 12.4_f32;\n     /// let inf = f32::INFINITY;\n     ///\n     /// assert_eq!(num.classify(), FpCategory::Normal);\n@@ -682,7 +468,7 @@ impl f32 {\n     ///\n     /// ```\n     /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n+    /// use std::f32;\n     ///\n     /// let num = 2.0f32;\n     ///\n@@ -695,7 +481,7 @@ impl f32 {\n     /// // 1 * 8388608 * 2^(-22) == 2\n     /// let abs_difference = (sign_f * mantissa_f * exponent_f - num).abs();\n     ///\n-    /// assert!(abs_difference < 1e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n     /// [floating-point]: ../../../../../reference.html#machine-types\n     #[unstable(feature = \"std_misc\", reason = \"signature is undecided\")]\n@@ -705,10 +491,8 @@ impl f32 {\n     /// Returns the largest integer less than or equal to a number.\n     ///\n     /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 3.99;\n-    /// let g = 3.0;\n+    /// let f = 3.99_f32;\n+    /// let g = 3.0_f32;\n     ///\n     /// assert_eq!(f.floor(), 3.0);\n     /// assert_eq!(g.floor(), 3.0);\n@@ -720,10 +504,8 @@ impl f32 {\n     /// Returns the smallest integer greater than or equal to a number.\n     ///\n     /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 3.01;\n-    /// let g = 4.0;\n+    /// let f = 3.01_f32;\n+    /// let g = 4.0_f32;\n     ///\n     /// assert_eq!(f.ceil(), 4.0);\n     /// assert_eq!(g.ceil(), 4.0);\n@@ -736,10 +518,8 @@ impl f32 {\n     /// `0.0`.\n     ///\n     /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 3.3;\n-    /// let g = -3.3;\n+    /// let f = 3.3_f32;\n+    /// let g = -3.3_f32;\n     ///\n     /// assert_eq!(f.round(), 3.0);\n     /// assert_eq!(g.round(), -3.0);\n@@ -751,10 +531,8 @@ impl f32 {\n     /// Return the integer part of a number.\n     ///\n     /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 3.3;\n-    /// let g = -3.7;\n+    /// let f = 3.3_f32;\n+    /// let g = -3.7_f32;\n     ///\n     /// assert_eq!(f.trunc(), 3.0);\n     /// assert_eq!(g.trunc(), -3.0);\n@@ -766,142 +544,140 @@ impl f32 {\n     /// Returns the fractional part of a number.\n     ///\n     /// ```\n-    /// use std::num::Float;\n+    /// use std::f32;\n     ///\n-    /// let x = 3.5;\n-    /// let y = -3.5;\n+    /// let x = 3.5_f32;\n+    /// let y = -3.5_f32;\n     /// let abs_difference_x = (x.fract() - 0.5).abs();\n     /// let abs_difference_y = (y.fract() - (-0.5)).abs();\n     ///\n-    /// assert!(abs_difference_x < 1e-10);\n-    /// assert!(abs_difference_y < 1e-10);\n+    /// assert!(abs_difference_x <= f32::EPSILON);\n+    /// assert!(abs_difference_y <= f32::EPSILON);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn fract(self) -> f32 { num::Float::fract(self) }\n \n-    /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n-    /// number is `Float::nan()`.\n+    /// Computes the absolute value of `self`. Returns `NAN` if the\n+    /// number is `NAN`.\n     ///\n     /// ```\n-    /// # #![feature(core, std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f64;\n+    /// use std::f32;\n     ///\n-    /// let x = 3.5;\n-    /// let y = -3.5;\n+    /// let x = 3.5_f32;\n+    /// let y = -3.5_f32;\n     ///\n     /// let abs_difference_x = (x.abs() - x).abs();\n     /// let abs_difference_y = (y.abs() - (-y)).abs();\n     ///\n-    /// assert!(abs_difference_x < 1e-10);\n-    /// assert!(abs_difference_y < 1e-10);\n+    /// assert!(abs_difference_x <= f32::EPSILON);\n+    /// assert!(abs_difference_y <= f32::EPSILON);\n     ///\n-    /// assert!(f64::NAN.abs().is_nan());\n+    /// assert!(f32::NAN.abs().is_nan());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn abs(self) -> f32 { num::Float::abs(self) }\n \n     /// Returns a number that represents the sign of `self`.\n     ///\n-    /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`\n-    /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`\n-    /// - `Float::nan()` if the number is `Float::nan()`\n+    /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n+    /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n+    /// - `NAN` if the number is `NAN`\n     ///\n     /// ```\n-    /// # #![feature(core, std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f64;\n+    /// use std::f32;\n     ///\n-    /// let f = 3.5;\n+    /// let f = 3.5_f32;\n     ///\n     /// assert_eq!(f.signum(), 1.0);\n-    /// assert_eq!(f64::NEG_INFINITY.signum(), -1.0);\n+    /// assert_eq!(f32::NEG_INFINITY.signum(), -1.0);\n     ///\n-    /// assert!(f64::NAN.signum().is_nan());\n+    /// assert!(f32::NAN.signum().is_nan());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn signum(self) -> f32 { num::Float::signum(self) }\n \n-    /// Returns `true` if `self` is positive, including `+0.0` and\n-    /// `Float::infinity()`.\n+    /// Returns `true` if `self`'s sign bit is positive, including\n+    /// `+0.0` and `INFINITY`.\n     ///\n     /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let nan: f64 = f64::NAN;\n+    /// use std::f32;\n     ///\n-    /// let f = 7.0;\n-    /// let g = -7.0;\n+    /// let nan = f32::NAN;\n+    /// let f = 7.0_f32;\n+    /// let g = -7.0_f32;\n     ///\n-    /// assert!(f.is_positive());\n-    /// assert!(!g.is_positive());\n+    /// assert!(f.is_sign_positive());\n+    /// assert!(!g.is_sign_positive());\n     /// // Requires both tests to determine if is `NaN`\n-    /// assert!(!nan.is_positive() && !nan.is_negative());\n+    /// assert!(!nan.is_sign_positive() && !nan.is_sign_negative());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n+    pub fn is_sign_positive(self) -> bool { num::Float::is_positive(self) }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_positive\")]\n+    #[inline]\n     pub fn is_positive(self) -> bool { num::Float::is_positive(self) }\n \n-    /// Returns `true` if `self` is negative, including `-0.0` and\n-    /// `Float::neg_infinity()`.\n+    /// Returns `true` if `self`'s sign is negative, including `-0.0`\n+    /// and `NEG_INFINITY`.\n     ///\n     /// ```\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let nan = f64::NAN;\n+    /// use std::f32;\n     ///\n-    /// let f = 7.0;\n-    /// let g = -7.0;\n+    /// let nan = f32::NAN;\n+    /// let f = 7.0f32;\n+    /// let g = -7.0f32;\n     ///\n-    /// assert!(!f.is_negative());\n-    /// assert!(g.is_negative());\n+    /// assert!(!f.is_sign_negative());\n+    /// assert!(g.is_sign_negative());\n     /// // Requires both tests to determine if is `NaN`.\n-    /// assert!(!nan.is_positive() && !nan.is_negative());\n+    /// assert!(!nan.is_sign_positive() && !nan.is_sign_negative());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n+    pub fn is_sign_negative(self) -> bool { num::Float::is_negative(self) }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_negative\")]\n+    #[inline]\n     pub fn is_negative(self) -> bool { num::Float::is_negative(self) }\n \n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n     /// error. This produces a more accurate result with better performance than\n     /// a separate multiplication operation followed by an add.\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n+    /// use std::f32;\n     ///\n-    /// let m = 10.0;\n-    /// let x = 4.0;\n-    /// let b = 60.0;\n+    /// let m = 10.0_f32;\n+    /// let x = 4.0_f32;\n+    /// let b = 60.0_f32;\n     ///\n     /// // 100.0\n     /// let abs_difference = (m.mul_add(x, b) - (m*x + b)).abs();\n     ///\n-    /// assert!(abs_difference < 1e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn mul_add(self, a: f32, b: f32) -> f32 { num::Float::mul_add(self, a, b) }\n \n     /// Take the reciprocal (inverse) of a number, `1/x`.\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n+    /// use std::f32;\n     ///\n-    /// let x = 2.0;\n+    /// let x = 2.0_f32;\n     /// let abs_difference = (x.recip() - (1.0/x)).abs();\n     ///\n-    /// assert!(abs_difference < 1e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn recip(self) -> f32 { num::Float::recip(self) }\n \n@@ -910,12 +686,12 @@ impl f32 {\n     /// Using this function is generally faster than using `powf`\n     ///\n     /// ```\n-    /// use std::num::Float;\n+    /// use std::f32;\n     ///\n-    /// let x = 2.0;\n+    /// let x = 2.0_f32;\n     /// let abs_difference = (x.powi(2) - x*x).abs();\n     ///\n-    /// assert!(abs_difference < 1e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -924,12 +700,12 @@ impl f32 {\n     /// Raise a number to a floating point power.\n     ///\n     /// ```\n-    /// use std::num::Float;\n+    /// use std::f32;\n     ///\n-    /// let x = 2.0;\n+    /// let x = 2.0_f32;\n     /// let abs_difference = (x.powf(2.0) - x*x).abs();\n     ///\n-    /// assert!(abs_difference < 1e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -940,52 +716,51 @@ impl f32 {\n     /// Returns NaN if `self` is a negative number.\n     ///\n     /// ```\n-    /// # #![feature(core, std_misc)]\n-    /// use std::num::Float;\n+    /// use std::f32;\n     ///\n-    /// let positive = 4.0;\n-    /// let negative = -4.0;\n+    /// let positive = 4.0_f32;\n+    /// let negative = -4.0_f32;\n     ///\n     /// let abs_difference = (positive.sqrt() - 2.0).abs();\n     ///\n-    /// assert!(abs_difference < 1e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// assert!(negative.sqrt().is_nan());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn sqrt(self) -> f32 { num::Float::sqrt(self) }\n \n-\n     /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n     ///\n     /// ```\n     /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n+    /// use std::f32;\n     ///\n-    /// let f = 4.0;\n+    /// let f = 4.0f32;\n     ///\n     /// let abs_difference = (f.rsqrt() - 0.5).abs();\n     ///\n-    /// assert!(abs_difference < 1e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n     #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use self.sqrt().recip() instead\")]\n     #[inline]\n     pub fn rsqrt(self) -> f32 { num::Float::rsqrt(self) }\n \n     /// Returns `e^(self)`, (the exponential function).\n     ///\n     /// ```\n-    /// use std::num::Float;\n+    /// use std::f32;\n     ///\n-    /// let one = 1.0;\n+    /// let one = 1.0f32;\n     /// // e^1\n     /// let e = one.exp();\n     ///\n     /// // ln(e) - 1 == 0\n     /// let abs_difference = (e.ln() - 1.0).abs();\n     ///\n-    /// assert!(abs_difference < 1e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -994,14 +769,14 @@ impl f32 {\n     /// Returns `2^(self)`.\n     ///\n     /// ```\n-    /// use std::num::Float;\n+    /// use std::f32;\n     ///\n-    /// let f = 2.0;\n+    /// let f = 2.0f32;\n     ///\n     /// // 2^2 - 4 == 0\n     /// let abs_difference = (f.exp2() - 4.0).abs();\n     ///\n-    /// assert!(abs_difference < 1e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1010,16 +785,16 @@ impl f32 {\n     /// Returns the natural logarithm of the number.\n     ///\n     /// ```\n-    /// use std::num::Float;\n+    /// use std::f32;\n     ///\n-    /// let one = 1.0;\n+    /// let one = 1.0f32;\n     /// // e^1\n     /// let e = one.exp();\n     ///\n     /// // ln(e) - 1 == 0\n     /// let abs_difference = (e.ln() - 1.0).abs();\n     ///\n-    /// assert!(abs_difference < 1e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1028,19 +803,19 @@ impl f32 {\n     /// Returns the logarithm of the number with respect to an arbitrary base.\n     ///\n     /// ```\n-    /// use std::num::Float;\n+    /// use std::f32;\n     ///\n-    /// let ten = 10.0;\n-    /// let two = 2.0;\n+    /// let ten = 10.0f32;\n+    /// let two = 2.0f32;\n     ///\n     /// // log10(10) - 1 == 0\n     /// let abs_difference_10 = (ten.log(10.0) - 1.0).abs();\n     ///\n     /// // log2(2) - 1 == 0\n     /// let abs_difference_2 = (two.log(2.0) - 1.0).abs();\n     ///\n-    /// assert!(abs_difference_10 < 1e-10);\n-    /// assert!(abs_difference_2 < 1e-10);\n+    /// assert!(abs_difference_10 <= f32::EPSILON);\n+    /// assert!(abs_difference_2 <= f32::EPSILON);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1049,14 +824,14 @@ impl f32 {\n     /// Returns the base 2 logarithm of the number.\n     ///\n     /// ```\n-    /// use std::num::Float;\n+    /// use std::f32;\n     ///\n-    /// let two = 2.0;\n+    /// let two = 2.0f32;\n     ///\n     /// // log2(2) - 1 == 0\n     /// let abs_difference = (two.log2() - 1.0).abs();\n     ///\n-    /// assert!(abs_difference < 1e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1065,14 +840,14 @@ impl f32 {\n     /// Returns the base 10 logarithm of the number.\n     ///\n     /// ```\n-    /// use std::num::Float;\n+    /// use std::f32;\n     ///\n-    /// let ten = 10.0;\n+    /// let ten = 10.0f32;\n     ///\n     /// // log10(10) - 1 == 0\n     /// let abs_difference = (ten.log10() - 1.0).abs();\n     ///\n-    /// assert!(abs_difference < 1e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1082,14 +857,13 @@ impl f32 {\n     ///\n     /// ```\n     /// # #![feature(std_misc, core)]\n-    /// use std::num::Float;\n-    /// use std::f64::consts;\n+    /// use std::f32::{self, consts};\n     ///\n     /// let angle = consts::PI;\n     ///\n     /// let abs_difference = (angle.to_degrees() - 180.0).abs();\n     ///\n-    /// assert!(abs_difference < 1e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n     #[unstable(feature = \"std_misc\", reason = \"desirability is unclear\")]\n     #[inline]\n@@ -1098,15 +872,14 @@ impl f32 {\n     /// Convert degrees to radians.\n     ///\n     /// ```\n-    /// # #![feature(std_misc, core)]\n-    /// use std::num::Float;\n-    /// use std::f64::consts;\n+    /// # #![feature(std_misc)]\n+    /// use std::f32::{self, consts};\n     ///\n-    /// let angle = 180.0;\n+    /// let angle = 180.0f32;\n     ///\n     /// let abs_difference = (angle.to_radians() - consts::PI).abs();\n     ///\n-    /// assert!(abs_difference < 1e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n     #[unstable(feature = \"std_misc\", reason = \"desirability is unclear\")]\n     #[inline]\n@@ -1116,12 +889,11 @@ impl f32 {\n     ///\n     /// ```\n     /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n+    /// use std::f32;\n     /// // 3*2^2 - 12 == 0\n-    /// let abs_difference = (Float::ldexp(3.0, 2) - 12.0).abs();\n+    /// let abs_difference = (f32::ldexp(3.0, 2) - 12.0).abs();\n     ///\n-    /// assert!(abs_difference < 1e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n     #[unstable(feature = \"std_misc\",\n                reason = \"pending integer conventions\")]\n@@ -1138,17 +910,17 @@ impl f32 {\n     ///\n     /// ```\n     /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n+    /// use std::f32;\n     ///\n-    /// let x = 4.0;\n+    /// let x = 4.0f32;\n     ///\n     /// // (1/2)*2^3 -> 1 * 8/2 -> 4.0\n     /// let f = x.frexp();\n     /// let abs_difference_0 = (f.0 - 0.5).abs();\n-    /// let abs_difference_1 = (f.1 as f64 - 3.0).abs();\n+    /// let abs_difference_1 = (f.1 as f32 - 3.0).abs();\n     ///\n-    /// assert!(abs_difference_0 < 1e-10);\n-    /// assert!(abs_difference_1 < 1e-10);\n+    /// assert!(abs_difference_0 <= f32::EPSILON);\n+    /// assert!(abs_difference_1 <= f32::EPSILON);\n     /// ```\n     #[unstable(feature = \"std_misc\",\n                reason = \"pending integer conventions\")]\n@@ -1166,13 +938,13 @@ impl f32 {\n     ///\n     /// ```\n     /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n+    /// use std::f32;\n     ///\n     /// let x = 1.0f32;\n     ///\n     /// let abs_diff = (x.next_after(2.0) - 1.00000011920928955078125_f32).abs();\n     ///\n-    /// assert!(abs_diff < 1e-10);\n+    /// assert!(abs_diff <= f32::EPSILON);\n     /// ```\n     #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n@@ -1184,10 +956,8 @@ impl f32 {\n     /// Returns the maximum of the two numbers.\n     ///\n     /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 1.0;\n-    /// let y = 2.0;\n+    /// let x = 1.0f32;\n+    /// let y = 2.0f32;\n     ///\n     /// assert_eq!(x.max(y), y);\n     /// ```\n@@ -1200,10 +970,8 @@ impl f32 {\n     /// Returns the minimum of the two numbers.\n     ///\n     /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 1.0;\n-    /// let y = 2.0;\n+    /// let x = 1.0f32;\n+    /// let y = 2.0f32;\n     ///\n     /// assert_eq!(x.min(y), x);\n     /// ```\n@@ -1220,18 +988,18 @@ impl f32 {\n     ///\n     /// ```\n     /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n+    /// use std::f32;\n     ///\n-    /// let x = 3.0;\n-    /// let y = -3.0;\n+    /// let x = 3.0f32;\n+    /// let y = -3.0f32;\n     ///\n     /// let abs_difference_x = (x.abs_sub(1.0) - 2.0).abs();\n     /// let abs_difference_y = (y.abs_sub(1.0) - 0.0).abs();\n     ///\n-    /// assert!(abs_difference_x < 1e-10);\n-    /// assert!(abs_difference_y < 1e-10);\n+    /// assert!(abs_difference_x <= f32::EPSILON);\n+    /// assert!(abs_difference_y <= f32::EPSILON);\n     /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn abs_sub(self, other: f32) -> f32 {\n         unsafe { cmath::fdimf(self, other) }\n@@ -1241,16 +1009,16 @@ impl f32 {\n     ///\n     /// ```\n     /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n+    /// use std::f32;\n     ///\n-    /// let x = 8.0;\n+    /// let x = 8.0f32;\n     ///\n     /// // x^(1/3) - 2 == 0\n     /// let abs_difference = (x.cbrt() - 2.0).abs();\n     ///\n-    /// assert!(abs_difference < 1e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn cbrt(self) -> f32 {\n         unsafe { cmath::cbrtf(self) }\n@@ -1260,19 +1028,17 @@ impl f32 {\n     /// legs of length `x` and `y`.\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n+    /// use std::f32;\n     ///\n-    /// let x = 2.0;\n-    /// let y = 3.0;\n+    /// let x = 2.0f32;\n+    /// let y = 3.0f32;\n     ///\n     /// // sqrt(x^2 + y^2)\n     /// let abs_difference = (x.hypot(y) - (x.powi(2) + y.powi(2)).sqrt()).abs();\n     ///\n-    /// assert!(abs_difference < 1e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn hypot(self, other: f32) -> f32 {\n         unsafe { cmath::hypotf(self, other) }\n@@ -1281,15 +1047,13 @@ impl f32 {\n     /// Computes the sine of a number (in radians).\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n-    /// use std::f64;\n+    /// use std::f32;\n     ///\n-    /// let x = f64::consts::PI/2.0;\n+    /// let x = f32::consts::PI/2.0;\n     ///\n     /// let abs_difference = (x.sin() - 1.0).abs();\n     ///\n-    /// assert!(abs_difference < 1e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1300,15 +1064,13 @@ impl f32 {\n     /// Computes the cosine of a number (in radians).\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n-    /// use std::f64;\n+    /// use std::f32;\n     ///\n-    /// let x = 2.0*f64::consts::PI;\n+    /// let x = 2.0*f32::consts::PI;\n     ///\n     /// let abs_difference = (x.cos() - 1.0).abs();\n     ///\n-    /// assert!(abs_difference < 1e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1319,14 +1081,12 @@ impl f32 {\n     /// Computes the tangent of a number (in radians).\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n     /// use std::f64;\n     ///\n     /// let x = f64::consts::PI/4.0;\n     /// let abs_difference = (x.tan() - 1.0).abs();\n     ///\n-    /// assert!(abs_difference < 1e-14);\n+    /// assert!(abs_difference < 1e-10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1339,16 +1099,14 @@ impl f32 {\n     /// [-1, 1].\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n-    /// use std::f64;\n+    /// use std::f32;\n     ///\n-    /// let f = f64::consts::PI / 2.0;\n+    /// let f = f32::consts::PI / 2.0;\n     ///\n     /// // asin(sin(pi/2))\n-    /// let abs_difference = (f.sin().asin() - f64::consts::PI / 2.0).abs();\n+    /// let abs_difference = f.sin().asin().abs_sub(f32::consts::PI / 2.0);\n     ///\n-    /// assert!(abs_difference < 1e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1361,16 +1119,14 @@ impl f32 {\n     /// [-1, 1].\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n-    /// use std::f64;\n+    /// use std::f32;\n     ///\n-    /// let f = f64::consts::PI / 4.0;\n+    /// let f = f32::consts::PI / 4.0;\n     ///\n     /// // acos(cos(pi/4))\n-    /// let abs_difference = (f.cos().acos() - f64::consts::PI / 4.0).abs();\n+    /// let abs_difference = f.cos().acos().abs_sub(f32::consts::PI / 4.0);\n     ///\n-    /// assert!(abs_difference < 1e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1382,14 +1138,14 @@ impl f32 {\n     /// range [-pi/2, pi/2];\n     ///\n     /// ```\n-    /// use std::num::Float;\n+    /// use std::f32;\n     ///\n-    /// let f = 1.0;\n+    /// let f = 1.0f32;\n     ///\n     /// // atan(tan(1))\n-    /// let abs_difference = (f.tan().atan() - 1.0).abs();\n+    /// let abs_difference = f.tan().atan().abs_sub(1.0);\n     ///\n-    /// assert!(abs_difference < 1e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1405,25 +1161,23 @@ impl f32 {\n     /// * `y < 0`: `arctan(y/x) - pi` -> `(-pi, -pi/2)`\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n-    /// use std::f64;\n+    /// use std::f32;\n     ///\n-    /// let pi = f64::consts::PI;\n+    /// let pi = f32::consts::PI;\n     /// // All angles from horizontal right (+x)\n     /// // 45 deg counter-clockwise\n-    /// let x1 = 3.0;\n-    /// let y1 = -3.0;\n+    /// let x1 = 3.0f32;\n+    /// let y1 = -3.0f32;\n     ///\n     /// // 135 deg clockwise\n-    /// let x2 = -3.0;\n-    /// let y2 = 3.0;\n+    /// let x2 = -3.0f32;\n+    /// let y2 = 3.0f32;\n     ///\n     /// let abs_difference_1 = (y1.atan2(x1) - (-pi/4.0)).abs();\n     /// let abs_difference_2 = (y2.atan2(x2) - 3.0*pi/4.0).abs();\n     ///\n-    /// assert!(abs_difference_1 < 1e-10);\n-    /// assert!(abs_difference_2 < 1e-10);\n+    /// assert!(abs_difference_1 <= f32::EPSILON);\n+    /// assert!(abs_difference_2 <= f32::EPSILON);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1435,18 +1189,16 @@ impl f32 {\n     /// `(sin(x), cos(x))`.\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n-    /// use std::f64;\n+    /// use std::f32;\n     ///\n-    /// let x = f64::consts::PI/4.0;\n+    /// let x = f32::consts::PI/4.0;\n     /// let f = x.sin_cos();\n     ///\n     /// let abs_difference_0 = (f.0 - x.sin()).abs();\n     /// let abs_difference_1 = (f.1 - x.cos()).abs();\n     ///\n-    /// assert!(abs_difference_0 < 1e-10);\n-    /// assert!(abs_difference_0 < 1e-10);\n+    /// assert!(abs_difference_0 <= f32::EPSILON);\n+    /// assert!(abs_difference_0 <= f32::EPSILON);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1458,17 +1210,16 @@ impl f32 {\n     /// number is close to zero.\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n+    /// use std::f64;\n     ///\n-    /// let x = 7.0;\n+    /// let x = 7.0f64;\n     ///\n     /// // e^(ln(7)) - 1\n-    /// let abs_difference = (x.ln().exp_m1() - 6.0).abs();\n+    /// let abs_difference = x.ln().exp_m1().abs_sub(6.0);\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn exp_m1(self) -> f32 {\n         unsafe { cmath::expm1f(self) }\n@@ -1478,18 +1229,16 @@ impl f32 {\n     /// the operations were performed separately.\n     ///\n     /// ```\n-    /// # #![feature(std_misc, core)]\n-    /// use std::num::Float;\n-    /// use std::f64;\n+    /// use std::f32;\n     ///\n-    /// let x = f64::consts::E - 1.0;\n+    /// let x = f32::consts::E - 1.0;\n     ///\n     /// // ln(1 + (e - 1)) == ln(e) == 1\n     /// let abs_difference = (x.ln_1p() - 1.0).abs();\n     ///\n-    /// assert!(abs_difference < 1e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn ln_1p(self) -> f32 {\n         unsafe { cmath::log1pf(self) }\n@@ -1498,19 +1247,17 @@ impl f32 {\n     /// Hyperbolic sine function.\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n-    /// use std::f64;\n+    /// use std::f32;\n     ///\n-    /// let e = f64::consts::E;\n-    /// let x = 1.0;\n+    /// let e = f32::consts::E;\n+    /// let x = 1.0f32;\n     ///\n     /// let f = x.sinh();\n     /// // Solving sinh() at 1 gives `(e^2-1)/(2e)`\n     /// let g = (e*e - 1.0)/(2.0*e);\n     /// let abs_difference = (f - g).abs();\n     ///\n-    /// assert!(abs_difference < 1e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1521,19 +1268,17 @@ impl f32 {\n     /// Hyperbolic cosine function.\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n-    /// use std::f64;\n+    /// use std::f32;\n     ///\n-    /// let e = f64::consts::E;\n-    /// let x = 1.0;\n+    /// let e = f32::consts::E;\n+    /// let x = 1.0f32;\n     /// let f = x.cosh();\n     /// // Solving cosh() at 1 gives this result\n     /// let g = (e*e + 1.0)/(2.0*e);\n-    /// let abs_difference = (f - g).abs();\n+    /// let abs_difference = f.abs_sub(g);\n     ///\n     /// // Same result\n-    /// assert!(abs_difference < 1.0e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1544,19 +1289,17 @@ impl f32 {\n     /// Hyperbolic tangent function.\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n-    /// use std::f64;\n+    /// use std::f32;\n     ///\n-    /// let e = f64::consts::E;\n-    /// let x = 1.0;\n+    /// let e = f32::consts::E;\n+    /// let x = 1.0f32;\n     ///\n     /// let f = x.tanh();\n     /// // Solving tanh() at 1 gives `(1 - e^(-2))/(1 + e^(-2))`\n     /// let g = (1.0 - e.powi(-2))/(1.0 + e.powi(-2));\n     /// let abs_difference = (f - g).abs();\n     ///\n-    /// assert!(abs_difference < 1.0e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1567,15 +1310,14 @@ impl f32 {\n     /// Inverse hyperbolic sine function.\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n+    /// use std::f32;\n     ///\n-    /// let x = 1.0;\n+    /// let x = 1.0f32;\n     /// let f = x.sinh().asinh();\n     ///\n     /// let abs_difference = (f - x).abs();\n     ///\n-    /// assert!(abs_difference < 1.0e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1589,15 +1331,14 @@ impl f32 {\n     /// Inverse hyperbolic cosine function.\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n+    /// use std::f32;\n     ///\n-    /// let x = 1.0;\n+    /// let x = 1.0f32;\n     /// let f = x.cosh().acosh();\n     ///\n     /// let abs_difference = (f - x).abs();\n     ///\n-    /// assert!(abs_difference < 1.0e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1611,16 +1352,14 @@ impl f32 {\n     /// Inverse hyperbolic tangent function.\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n-    /// use std::f64;\n+    /// use std::f32;\n     ///\n-    /// let e = f64::consts::E;\n+    /// let e = f32::consts::E;\n     /// let f = e.tanh().atanh();\n     ///\n-    /// let abs_difference = (f - e).abs();\n+    /// let abs_difference = f.abs_sub(e);\n     ///\n-    /// assert!(abs_difference < 1.0e-10);\n+    /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -1640,6 +1379,7 @@ impl f32 {\n /// * num - The float value\n #[inline]\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use the ToString trait instead\")]\n pub fn to_string(num: f32) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10, true, SignNeg, DigAll, ExpNone, false);\n@@ -1653,6 +1393,7 @@ pub fn to_string(num: f32) -> String {\n /// * num - The float value\n #[inline]\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use format! instead\")]\n pub fn to_str_hex(num: f32) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 16, true, SignNeg, DigAll, ExpNone, false);\n@@ -1668,6 +1409,7 @@ pub fn to_str_hex(num: f32) -> String {\n /// * radix - The base to use\n #[inline]\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use format! instead\")]\n pub fn to_str_radix_special(num: f32, rdx: u32) -> (String, bool) {\n     strconv::float_to_str_common(num, rdx, true, SignNeg, DigAll, ExpNone, false)\n }\n@@ -1764,8 +1506,8 @@ mod tests {\n         assert!(!nan.is_infinite());\n         assert!(!nan.is_finite());\n         assert!(!nan.is_normal());\n-        assert!(!nan.is_positive());\n-        assert!(!nan.is_negative());\n+        assert!(!nan.is_sign_positive());\n+        assert!(!nan.is_sign_negative());\n         assert_eq!(Fp::Nan, nan.classify());\n     }\n \n@@ -1774,8 +1516,8 @@ mod tests {\n         let inf: f32 = Float::infinity();\n         assert!(inf.is_infinite());\n         assert!(!inf.is_finite());\n-        assert!(inf.is_positive());\n-        assert!(!inf.is_negative());\n+        assert!(inf.is_sign_positive());\n+        assert!(!inf.is_sign_negative());\n         assert!(!inf.is_nan());\n         assert!(!inf.is_normal());\n         assert_eq!(Fp::Infinite, inf.classify());\n@@ -1786,8 +1528,8 @@ mod tests {\n         let neg_inf: f32 = Float::neg_infinity();\n         assert!(neg_inf.is_infinite());\n         assert!(!neg_inf.is_finite());\n-        assert!(!neg_inf.is_positive());\n-        assert!(neg_inf.is_negative());\n+        assert!(!neg_inf.is_sign_positive());\n+        assert!(neg_inf.is_sign_negative());\n         assert!(!neg_inf.is_nan());\n         assert!(!neg_inf.is_normal());\n         assert_eq!(Fp::Infinite, neg_inf.classify());\n@@ -1799,8 +1541,8 @@ mod tests {\n         assert_eq!(0.0, zero);\n         assert!(!zero.is_infinite());\n         assert!(zero.is_finite());\n-        assert!(zero.is_positive());\n-        assert!(!zero.is_negative());\n+        assert!(zero.is_sign_positive());\n+        assert!(!zero.is_sign_negative());\n         assert!(!zero.is_nan());\n         assert!(!zero.is_normal());\n         assert_eq!(Fp::Zero, zero.classify());\n@@ -1812,8 +1554,8 @@ mod tests {\n         assert_eq!(0.0, neg_zero);\n         assert!(!neg_zero.is_infinite());\n         assert!(neg_zero.is_finite());\n-        assert!(!neg_zero.is_positive());\n-        assert!(neg_zero.is_negative());\n+        assert!(!neg_zero.is_sign_positive());\n+        assert!(neg_zero.is_sign_negative());\n         assert!(!neg_zero.is_nan());\n         assert!(!neg_zero.is_normal());\n         assert_eq!(Fp::Zero, neg_zero.classify());\n@@ -1825,8 +1567,8 @@ mod tests {\n         assert_eq!(1.0, one);\n         assert!(!one.is_infinite());\n         assert!(one.is_finite());\n-        assert!(one.is_positive());\n-        assert!(!one.is_negative());\n+        assert!(one.is_sign_positive());\n+        assert!(!one.is_sign_negative());\n         assert!(!one.is_nan());\n         assert!(one.is_normal());\n         assert_eq!(Fp::Normal, one.classify());\n@@ -2012,27 +1754,27 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_is_positive() {\n-        assert!(INFINITY.is_positive());\n-        assert!(1f32.is_positive());\n-        assert!(0f32.is_positive());\n-        assert!(!(-0f32).is_positive());\n-        assert!(!(-1f32).is_positive());\n-        assert!(!NEG_INFINITY.is_positive());\n-        assert!(!(1f32/NEG_INFINITY).is_positive());\n-        assert!(!NAN.is_positive());\n+    fn test_is_sign_positive() {\n+        assert!(INFINITY.is_sign_positive());\n+        assert!(1f32.is_sign_positive());\n+        assert!(0f32.is_sign_positive());\n+        assert!(!(-0f32).is_sign_positive());\n+        assert!(!(-1f32).is_sign_positive());\n+        assert!(!NEG_INFINITY.is_sign_positive());\n+        assert!(!(1f32/NEG_INFINITY).is_sign_positive());\n+        assert!(!NAN.is_sign_positive());\n     }\n \n     #[test]\n-    fn test_is_negative() {\n-        assert!(!INFINITY.is_negative());\n-        assert!(!1f32.is_negative());\n-        assert!(!0f32.is_negative());\n-        assert!((-0f32).is_negative());\n-        assert!((-1f32).is_negative());\n-        assert!(NEG_INFINITY.is_negative());\n-        assert!((1f32/NEG_INFINITY).is_negative());\n-        assert!(!NAN.is_negative());\n+    fn test_is_sign_negative() {\n+        assert!(!INFINITY.is_sign_negative());\n+        assert!(!1f32.is_sign_negative());\n+        assert!(!0f32.is_sign_negative());\n+        assert!((-0f32).is_sign_negative());\n+        assert!((-1f32).is_sign_negative());\n+        assert!(NEG_INFINITY.is_sign_negative());\n+        assert!((1f32/NEG_INFINITY).is_sign_negative());\n+        assert!(!NAN.is_sign_negative());\n     }\n \n     #[test]"}, {"sha": "794853f6f709863f4237391e0bd6f22211ec2212", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 149, "deletions": 453, "changes": 602, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -83,6 +83,7 @@ mod cmath {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n impl Float for f64 {\n     // inlined methods from `num::Float`\n     #[inline]\n@@ -370,284 +371,69 @@ impl Float for f64 {\n #[lang = \"f64\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl f64 {\n-    // inlined methods from `num::Float`\n-    /// Returns the `NaN` value.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let nan: f32 = Float::nan();\n-    ///\n-    /// assert!(nan.is_nan());\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    #[inline]\n-    pub fn nan() -> f64 { num::Float::nan() }\n-\n-    /// Returns the infinite value.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f32;\n-    ///\n-    /// let infinity: f32 = Float::infinity();\n-    ///\n-    /// assert!(infinity.is_infinite());\n-    /// assert!(!infinity.is_finite());\n-    /// assert!(infinity > f32::MAX);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    #[inline]\n-    pub fn infinity() -> f64 { num::Float::infinity() }\n-\n-    /// Returns the negative infinite value.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f32;\n-    ///\n-    /// let neg_infinity: f32 = Float::neg_infinity();\n-    ///\n-    /// assert!(neg_infinity.is_infinite());\n-    /// assert!(!neg_infinity.is_finite());\n-    /// assert!(neg_infinity < f32::MIN);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    #[inline]\n-    pub fn neg_infinity() -> f64 { num::Float::neg_infinity() }\n-\n-    /// Returns `0.0`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let inf: f32 = Float::infinity();\n-    /// let zero: f32 = Float::zero();\n-    /// let neg_zero: f32 = Float::neg_zero();\n-    ///\n-    /// assert_eq!(zero, neg_zero);\n-    /// assert_eq!(7.0f32/inf, zero);\n-    /// assert_eq!(zero * 10.0, zero);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    #[inline]\n-    pub fn zero() -> f64 { num::Float::zero() }\n-\n-    /// Returns `-0.0`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let inf: f32 = Float::infinity();\n-    /// let zero: f32 = Float::zero();\n-    /// let neg_zero: f32 = Float::neg_zero();\n-    ///\n-    /// assert_eq!(zero, neg_zero);\n-    /// assert_eq!(7.0f32/inf, zero);\n-    /// assert_eq!(zero * 10.0, zero);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    #[inline]\n-    pub fn neg_zero() -> f64 { num::Float::neg_zero() }\n-\n-    /// Returns `1.0`.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let one: f32 = Float::one();\n-    ///\n-    /// assert_eq!(one, 1.0f32);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    #[inline]\n-    pub fn one() -> f64 { num::Float::one() }\n-\n-    // FIXME (#5527): These should be associated constants\n-\n-    /// Deprecated: use `std::f32::MANTISSA_DIGITS` or `std::f64::MANTISSA_DIGITS`\n-    /// instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MANTISSA_DIGITS` or \\\n-                           `std::f64::MANTISSA_DIGITS` as appropriate\")]\n-    #[allow(deprecated)]\n-    #[inline]\n-    pub fn mantissa_digits(unused_self: Option<f64>) -> usize {\n-        num::Float::mantissa_digits(unused_self)\n-    }\n-\n-    /// Deprecated: use `std::f32::DIGITS` or `std::f64::DIGITS` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\")]\n-    #[allow(deprecated)]\n-    #[inline]\n-    pub fn digits(unused_self: Option<f64>) -> usize { num::Float::digits(unused_self) }\n-\n-    /// Deprecated: use `std::f32::EPSILON` or `std::f64::EPSILON` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::EPSILON` or `std::f64::EPSILON` as appropriate\")]\n-    #[allow(deprecated)]\n-    #[inline]\n-    pub fn epsilon() -> f64 { num::Float::epsilon() }\n-\n-    /// Deprecated: use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\")]\n-    #[allow(deprecated)]\n-    #[inline]\n-    pub fn min_exp(unused_self: Option<f64>) -> isize { num::Float::min_exp(unused_self) }\n-\n-    /// Deprecated: use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\")]\n-    #[allow(deprecated)]\n-    #[inline]\n-    pub fn max_exp(unused_self: Option<f64>) -> isize { num::Float::max_exp(unused_self) }\n-\n-    /// Deprecated: use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\")]\n-    #[allow(deprecated)]\n-    #[inline]\n-    pub fn min_10_exp(unused_self: Option<f64>) -> isize { num::Float::min_10_exp(unused_self) }\n-\n-    /// Deprecated: use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` instead.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\")]\n-    #[allow(deprecated)]\n-    #[inline]\n-    pub fn max_10_exp(unused_self: Option<f64>) -> isize { num::Float::max_10_exp(unused_self) }\n-\n-    /// Returns the smallest finite value that this type can represent.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x: f64 = Float::min_value();\n-    ///\n-    /// assert_eq!(x, f64::MIN);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    #[inline]\n-    #[allow(deprecated)]\n-    pub fn min_value() -> f64 { num::Float::min_value() }\n-\n-    /// Returns the smallest normalized positive number that this type can represent.\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    #[inline]\n-    #[allow(deprecated)]\n-    pub fn min_pos_value(unused_self: Option<f64>) -> f64 { num::Float::min_pos_value(unused_self) }\n-\n-    /// Returns the largest finite value that this type can represent.\n-    ///\n-    /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f64;\n-    ///\n-    /// let x: f64 = Float::max_value();\n-    /// assert_eq!(x, f64::MAX);\n-    /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n-    #[inline]\n-    #[allow(deprecated)]\n-    pub fn max_value() -> f64 { num::Float::max_value() }\n-\n     /// Returns `true` if this value is `NaN` and false otherwise.\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n     /// use std::f64;\n     ///\n     /// let nan = f64::NAN;\n-    /// let f = 7.0;\n+    /// let f = 7.0_f64;\n     ///\n     /// assert!(nan.is_nan());\n     /// assert!(!f.is_nan());\n     /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_nan(self) -> bool { num::Float::is_nan(self) }\n \n     /// Returns `true` if this value is positive infinity or negative infinity and\n     /// false otherwise.\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f32;\n+    /// use std::f64;\n     ///\n-    /// let f = 7.0f32;\n-    /// let inf: f32 = Float::infinity();\n-    /// let neg_inf: f32 = Float::neg_infinity();\n-    /// let nan: f32 = f32::NAN;\n+    /// let f = 7.0f64;\n+    /// let inf = f64::INFINITY;\n+    /// let neg_inf = f64::NEG_INFINITY;\n+    /// let nan = f64::NAN;\n     ///\n     /// assert!(!f.is_infinite());\n     /// assert!(!nan.is_infinite());\n     ///\n     /// assert!(inf.is_infinite());\n     /// assert!(neg_inf.is_infinite());\n     /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_infinite(self) -> bool { num::Float::is_infinite(self) }\n \n     /// Returns `true` if this number is neither infinite nor `NaN`.\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    /// use std::f32;\n+    /// use std::f64;\n     ///\n-    /// let f = 7.0f32;\n-    /// let inf: f32 = Float::infinity();\n-    /// let neg_inf: f32 = Float::neg_infinity();\n-    /// let nan: f32 = f32::NAN;\n+    /// let f = 7.0f64;\n+    /// let inf: f64 = f64::INFINITY;\n+    /// let neg_inf: f64 = f64::NEG_INFINITY;\n+    /// let nan: f64 = f64::NAN;\n     ///\n     /// assert!(f.is_finite());\n     ///\n     /// assert!(!nan.is_finite());\n     /// assert!(!inf.is_finite());\n     /// assert!(!neg_inf.is_finite());\n     /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_finite(self) -> bool { num::Float::is_finite(self) }\n \n     /// Returns `true` if the number is neither zero, infinite,\n     /// [subnormal][subnormal], or `NaN`.\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n     /// use std::f32;\n     ///\n-    /// let min = f32::MIN_POSITIVE; // 1.17549435e-38f32\n+    /// let min = f32::MIN_POSITIVE; // 1.17549435e-38f64\n     /// let max = f32::MAX;\n     /// let lower_than_min = 1.0e-40_f32;\n     /// let zero = 0.0f32;\n@@ -662,7 +448,7 @@ impl f64 {\n     /// assert!(!lower_than_min.is_normal());\n     /// ```\n     /// [subnormal]: http://en.wikipedia.org/wiki/Denormal_number\n-    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_normal(self) -> bool { num::Float::is_normal(self) }\n \n@@ -671,12 +457,11 @@ impl f64 {\n     /// predicate instead.\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::{Float, FpCategory};\n-    /// use std::f32;\n+    /// use std::num::FpCategory;\n+    /// use std::f64;\n     ///\n-    /// let num = 12.4f32;\n-    /// let inf = f32::INFINITY;\n+    /// let num = 12.4_f64;\n+    /// let inf = f64::INFINITY;\n     ///\n     /// assert_eq!(num.classify(), FpCategory::Normal);\n     /// assert_eq!(inf.classify(), FpCategory::Infinite);\n@@ -691,15 +476,13 @@ impl f64 {\n     ///\n     /// ```\n     /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let num = 2.0f32;\n+    /// let num = 2.0f64;\n     ///\n     /// // (8388608, -22, 1)\n     /// let (mantissa, exponent, sign) = num.integer_decode();\n-    /// let sign_f = sign as f32;\n-    /// let mantissa_f = mantissa as f32;\n-    /// let exponent_f = num.powf(exponent as f32);\n+    /// let sign_f = sign as f64;\n+    /// let mantissa_f = mantissa as f64;\n+    /// let exponent_f = num.powf(exponent as f64);\n     ///\n     /// // 1 * 8388608 * 2^(-22) == 2\n     /// let abs_difference = (sign_f * mantissa_f * exponent_f - num).abs();\n@@ -714,10 +497,8 @@ impl f64 {\n     /// Returns the largest integer less than or equal to a number.\n     ///\n     /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 3.99;\n-    /// let g = 3.0;\n+    /// let f = 3.99_f64;\n+    /// let g = 3.0_f64;\n     ///\n     /// assert_eq!(f.floor(), 3.0);\n     /// assert_eq!(g.floor(), 3.0);\n@@ -729,10 +510,8 @@ impl f64 {\n     /// Returns the smallest integer greater than or equal to a number.\n     ///\n     /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 3.01;\n-    /// let g = 4.0;\n+    /// let f = 3.01_f64;\n+    /// let g = 4.0_f64;\n     ///\n     /// assert_eq!(f.ceil(), 4.0);\n     /// assert_eq!(g.ceil(), 4.0);\n@@ -745,10 +524,8 @@ impl f64 {\n     /// `0.0`.\n     ///\n     /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 3.3;\n-    /// let g = -3.3;\n+    /// let f = 3.3_f64;\n+    /// let g = -3.3_f64;\n     ///\n     /// assert_eq!(f.round(), 3.0);\n     /// assert_eq!(g.round(), -3.0);\n@@ -760,10 +537,8 @@ impl f64 {\n     /// Return the integer part of a number.\n     ///\n     /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 3.3;\n-    /// let g = -3.7;\n+    /// let f = 3.3_f64;\n+    /// let g = -3.7_f64;\n     ///\n     /// assert_eq!(f.trunc(), 3.0);\n     /// assert_eq!(g.trunc(), -3.0);\n@@ -775,10 +550,8 @@ impl f64 {\n     /// Returns the fractional part of a number.\n     ///\n     /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 3.5;\n-    /// let y = -3.5;\n+    /// let x = 3.5_f64;\n+    /// let y = -3.5_f64;\n     /// let abs_difference_x = (x.fract() - 0.5).abs();\n     /// let abs_difference_y = (y.fract() - (-0.5)).abs();\n     ///\n@@ -789,16 +562,14 @@ impl f64 {\n     #[inline]\n     pub fn fract(self) -> f64 { num::Float::fract(self) }\n \n-    /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n-    /// number is `Float::nan()`.\n+    /// Computes the absolute value of `self`. Returns `NAN` if the\n+    /// number is `NAN`.\n     ///\n     /// ```\n-    /// # #![feature(core, std_misc)]\n-    /// use std::num::Float;\n     /// use std::f64;\n     ///\n-    /// let x = 3.5;\n-    /// let y = -3.5;\n+    /// let x = 3.5_f64;\n+    /// let y = -3.5_f64;\n     ///\n     /// let abs_difference_x = (x.abs() - x).abs();\n     /// let abs_difference_y = (y.abs() - (-y)).abs();\n@@ -814,16 +585,14 @@ impl f64 {\n \n     /// Returns a number that represents the sign of `self`.\n     ///\n-    /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`\n-    /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`\n-    /// - `Float::nan()` if the number is `Float::nan()`\n+    /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n+    /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n+    /// - `NAN` if the number is `NAN`\n     ///\n     /// ```\n-    /// # #![feature(core, std_misc)]\n-    /// use std::num::Float;\n     /// use std::f64;\n     ///\n-    /// let f = 3.5;\n+    /// let f = 3.5_f64;\n     ///\n     /// assert_eq!(f.signum(), 1.0);\n     /// assert_eq!(f64::NEG_INFINITY.signum(), -1.0);\n@@ -834,83 +603,83 @@ impl f64 {\n     #[inline]\n     pub fn signum(self) -> f64 { num::Float::signum(self) }\n \n-    /// Returns `true` if `self` is positive, including `+0.0` and\n-    /// `Float::infinity()`.\n+    /// Returns `true` if `self`'s sign bit is positive, including\n+    /// `+0.0` and `INFINITY`.\n     ///\n     /// ```\n-    /// use std::num::Float;\n     /// use std::f64;\n     ///\n     /// let nan: f64 = f64::NAN;\n     ///\n-    /// let f = 7.0;\n-    /// let g = -7.0;\n+    /// let f = 7.0_f64;\n+    /// let g = -7.0_f64;\n     ///\n-    /// assert!(f.is_positive());\n-    /// assert!(!g.is_positive());\n+    /// assert!(f.is_sign_positive());\n+    /// assert!(!g.is_sign_positive());\n     /// // Requires both tests to determine if is `NaN`\n-    /// assert!(!nan.is_positive() && !nan.is_negative());\n+    /// assert!(!nan.is_sign_positive() && !nan.is_sign_negative());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n+    pub fn is_sign_positive(self) -> bool { num::Float::is_positive(self) }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_positive\")]\n+    #[inline]\n     pub fn is_positive(self) -> bool { num::Float::is_positive(self) }\n \n-    /// Returns `true` if `self` is negative, including `-0.0` and\n-    /// `Float::neg_infinity()`.\n+    /// Returns `true` if `self`'s sign is negative, including `-0.0`\n+    /// and `NEG_INFINITY`.\n     ///\n     /// ```\n-    /// use std::num::Float;\n     /// use std::f64;\n     ///\n     /// let nan = f64::NAN;\n     ///\n-    /// let f = 7.0;\n-    /// let g = -7.0;\n+    /// let f = 7.0_f64;\n+    /// let g = -7.0_f64;\n     ///\n-    /// assert!(!f.is_negative());\n-    /// assert!(g.is_negative());\n+    /// assert!(!f.is_sign_negative());\n+    /// assert!(g.is_sign_negative());\n     /// // Requires both tests to determine if is `NaN`.\n-    /// assert!(!nan.is_positive() && !nan.is_negative());\n+    /// assert!(!nan.is_sign_positive() && !nan.is_sign_negative());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n+    pub fn is_sign_negative(self) -> bool { num::Float::is_negative(self) }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to is_sign_negative\")]\n+    #[inline]\n     pub fn is_negative(self) -> bool { num::Float::is_negative(self) }\n \n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n     /// error. This produces a more accurate result with better performance than\n     /// a separate multiplication operation followed by an add.\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let m = 10.0;\n-    /// let x = 4.0;\n-    /// let b = 60.0;\n+    /// let m = 10.0_f64;\n+    /// let x = 4.0_f64;\n+    /// let b = 60.0_f64;\n     ///\n     /// // 100.0\n     /// let abs_difference = (m.mul_add(x, b) - (m*x + b)).abs();\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn mul_add(self, a: f64, b: f64) -> f64 { num::Float::mul_add(self, a, b) }\n \n     /// Take the reciprocal (inverse) of a number, `1/x`.\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 2.0;\n+    /// let x = 2.0_f64;\n     /// let abs_difference = (x.recip() - (1.0/x)).abs();\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn recip(self) -> f64 { num::Float::recip(self) }\n \n@@ -919,9 +688,7 @@ impl f64 {\n     /// Using this function is generally faster than using `powf`\n     ///\n     /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 2.0;\n+    /// let x = 2.0_f64;\n     /// let abs_difference = (x.powi(2) - x*x).abs();\n     ///\n     /// assert!(abs_difference < 1e-10);\n@@ -933,9 +700,7 @@ impl f64 {\n     /// Raise a number to a floating point power.\n     ///\n     /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 2.0;\n+    /// let x = 2.0_f64;\n     /// let abs_difference = (x.powf(2.0) - x*x).abs();\n     ///\n     /// assert!(abs_difference < 1e-10);\n@@ -949,11 +714,8 @@ impl f64 {\n     /// Returns NaN if `self` is a negative number.\n     ///\n     /// ```\n-    /// # #![feature(core, std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let positive = 4.0;\n-    /// let negative = -4.0;\n+    /// let positive = 4.0_f64;\n+    /// let negative = -4.0_f64;\n     ///\n     /// let abs_difference = (positive.sqrt() - 2.0).abs();\n     ///\n@@ -968,25 +730,22 @@ impl f64 {\n     ///\n     /// ```\n     /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 4.0;\n+    /// let f = 4.0_f64;\n     ///\n     /// let abs_difference = (f.rsqrt() - 0.5).abs();\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n     #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use self.sqrt().recip() instead\")]\n     #[inline]\n     pub fn rsqrt(self) -> f64 { num::Float::rsqrt(self) }\n \n     /// Returns `e^(self)`, (the exponential function).\n     ///\n     /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let one = 1.0;\n+    /// let one = 1.0_f64;\n     /// // e^1\n     /// let e = one.exp();\n     ///\n@@ -1002,9 +761,7 @@ impl f64 {\n     /// Returns `2^(self)`.\n     ///\n     /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 2.0;\n+    /// let f = 2.0_f64;\n     ///\n     /// // 2^2 - 4 == 0\n     /// let abs_difference = (f.exp2() - 4.0).abs();\n@@ -1018,9 +775,7 @@ impl f64 {\n     /// Returns the natural logarithm of the number.\n     ///\n     /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let one = 1.0;\n+    /// let one = 1.0_f64;\n     /// // e^1\n     /// let e = one.exp();\n     ///\n@@ -1036,10 +791,8 @@ impl f64 {\n     /// Returns the logarithm of the number with respect to an arbitrary base.\n     ///\n     /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let ten = 10.0;\n-    /// let two = 2.0;\n+    /// let ten = 10.0_f64;\n+    /// let two = 2.0_f64;\n     ///\n     /// // log10(10) - 1 == 0\n     /// let abs_difference_10 = (ten.log(10.0) - 1.0).abs();\n@@ -1057,9 +810,7 @@ impl f64 {\n     /// Returns the base 2 logarithm of the number.\n     ///\n     /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let two = 2.0;\n+    /// let two = 2.0_f64;\n     ///\n     /// // log2(2) - 1 == 0\n     /// let abs_difference = (two.log2() - 1.0).abs();\n@@ -1073,9 +824,7 @@ impl f64 {\n     /// Returns the base 10 logarithm of the number.\n     ///\n     /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let ten = 10.0;\n+    /// let ten = 10.0_f64;\n     ///\n     /// // log10(10) - 1 == 0\n     /// let abs_difference = (ten.log10() - 1.0).abs();\n@@ -1089,8 +838,6 @@ impl f64 {\n     /// Convert radians to degrees.\n     ///\n     /// ```\n-    /// # #![feature(std_misc, core)]\n-    /// use std::num::Float;\n     /// use std::f64::consts;\n     ///\n     /// let angle = consts::PI;\n@@ -1099,35 +846,31 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"desirability is unclear\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn to_degrees(self) -> f64 { num::Float::to_degrees(self) }\n \n     /// Convert degrees to radians.\n     ///\n     /// ```\n-    /// # #![feature(std_misc, core)]\n-    /// use std::num::Float;\n     /// use std::f64::consts;\n     ///\n-    /// let angle = 180.0;\n+    /// let angle = 180.0_f64;\n     ///\n     /// let abs_difference = (angle.to_radians() - consts::PI).abs();\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"desirability is unclear\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn to_radians(self) -> f64 { num::Float::to_radians(self) }\n \n     /// Constructs a floating point number of `x*2^exp`.\n     ///\n     /// ```\n     /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n     /// // 3*2^2 - 12 == 0\n-    /// let abs_difference = (Float::ldexp(3.0, 2) - 12.0).abs();\n+    /// let abs_difference = (f64::ldexp(3.0, 2) - 12.0).abs();\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n@@ -1146,9 +889,7 @@ impl f64 {\n     ///\n     /// ```\n     /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 4.0;\n+    /// let x = 4.0_f64;\n     ///\n     /// // (1/2)*2^3 -> 1 * 8/2 -> 4.0\n     /// let f = x.frexp();\n@@ -1174,7 +915,6 @@ impl f64 {\n     ///\n     /// ```\n     /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n     ///\n     /// let x = 1.0f32;\n     ///\n@@ -1192,10 +932,8 @@ impl f64 {\n     /// Returns the maximum of the two numbers.\n     ///\n     /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 1.0;\n-    /// let y = 2.0;\n+    /// let x = 1.0_f64;\n+    /// let y = 2.0_f64;\n     ///\n     /// assert_eq!(x.max(y), y);\n     /// ```\n@@ -1208,10 +946,8 @@ impl f64 {\n     /// Returns the minimum of the two numbers.\n     ///\n     /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 1.0;\n-    /// let y = 2.0;\n+    /// let x = 1.0_f64;\n+    /// let y = 2.0_f64;\n     ///\n     /// assert_eq!(x.min(y), x);\n     /// ```\n@@ -1227,19 +963,16 @@ impl f64 {\n     /// * Else: `self - other`\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 3.0;\n-    /// let y = -3.0;\n+    /// let x = 3.0_f64;\n+    /// let y = -3.0_f64;\n     ///\n     /// let abs_difference_x = (x.abs_sub(1.0) - 2.0).abs();\n     /// let abs_difference_y = (y.abs_sub(1.0) - 0.0).abs();\n     ///\n     /// assert!(abs_difference_x < 1e-10);\n     /// assert!(abs_difference_y < 1e-10);\n     /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn abs_sub(self, other: f64) -> f64 {\n         unsafe { cmath::fdim(self, other) }\n@@ -1248,17 +981,14 @@ impl f64 {\n     /// Take the cubic root of a number.\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 8.0;\n+    /// let x = 8.0_f64;\n     ///\n     /// // x^(1/3) - 2 == 0\n     /// let abs_difference = (x.cbrt() - 2.0).abs();\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn cbrt(self) -> f64 {\n         unsafe { cmath::cbrt(self) }\n@@ -1268,19 +998,15 @@ impl f64 {\n     /// legs of length `x` and `y`.\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 2.0;\n-    /// let y = 3.0;\n+    /// let x = 2.0_f64;\n+    /// let y = 3.0_f64;\n     ///\n     /// // sqrt(x^2 + y^2)\n     /// let abs_difference = (x.hypot(y) - (x.powi(2) + y.powi(2)).sqrt()).abs();\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure about its place in the world\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn hypot(self, other: f64) -> f64 {\n         unsafe { cmath::hypot(self, other) }\n@@ -1289,8 +1015,6 @@ impl f64 {\n     /// Computes the sine of a number (in radians).\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n     /// use std::f64;\n     ///\n     /// let x = f64::consts::PI/2.0;\n@@ -1308,8 +1032,6 @@ impl f64 {\n     /// Computes the cosine of a number (in radians).\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n     /// use std::f64;\n     ///\n     /// let x = 2.0*f64::consts::PI;\n@@ -1327,8 +1049,6 @@ impl f64 {\n     /// Computes the tangent of a number (in radians).\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n     /// use std::f64;\n     ///\n     /// let x = f64::consts::PI/4.0;\n@@ -1347,8 +1067,6 @@ impl f64 {\n     /// [-1, 1].\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n     /// use std::f64;\n     ///\n     /// let f = f64::consts::PI / 2.0;\n@@ -1369,8 +1087,6 @@ impl f64 {\n     /// [-1, 1].\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n     /// use std::f64;\n     ///\n     /// let f = f64::consts::PI / 4.0;\n@@ -1390,9 +1106,7 @@ impl f64 {\n     /// range [-pi/2, pi/2];\n     ///\n     /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let f = 1.0;\n+    /// let f = 1.0_f64;\n     ///\n     /// // atan(tan(1))\n     /// let abs_difference = (f.tan().atan() - 1.0).abs();\n@@ -1413,19 +1127,17 @@ impl f64 {\n     /// * `y < 0`: `arctan(y/x) - pi` -> `(-pi, -pi/2)`\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n     /// use std::f64;\n     ///\n     /// let pi = f64::consts::PI;\n     /// // All angles from horizontal right (+x)\n     /// // 45 deg counter-clockwise\n-    /// let x1 = 3.0;\n-    /// let y1 = -3.0;\n+    /// let x1 = 3.0_f64;\n+    /// let y1 = -3.0_f64;\n     ///\n     /// // 135 deg clockwise\n-    /// let x2 = -3.0;\n-    /// let y2 = 3.0;\n+    /// let x2 = -3.0_f64;\n+    /// let y2 = 3.0_f64;\n     ///\n     /// let abs_difference_1 = (y1.atan2(x1) - (-pi/4.0)).abs();\n     /// let abs_difference_2 = (y2.atan2(x2) - 3.0*pi/4.0).abs();\n@@ -1443,8 +1155,6 @@ impl f64 {\n     /// `(sin(x), cos(x))`.\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n     /// use std::f64;\n     ///\n     /// let x = f64::consts::PI/4.0;\n@@ -1466,17 +1176,14 @@ impl f64 {\n     /// number is close to zero.\n     ///\n     /// ```\n-    /// # #![feature(std_misc)]\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 7.0;\n+    /// let x = 7.0_f64;\n     ///\n     /// // e^(ln(7)) - 1\n     /// let abs_difference = (x.ln().exp_m1() - 6.0).abs();\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn exp_m1(self) -> f64 {\n         unsafe { cmath::expm1(self) }\n@@ -1486,8 +1193,6 @@ impl f64 {\n     /// the operations were performed separately.\n     ///\n     /// ```\n-    /// # #![feature(std_misc, core)]\n-    /// use std::num::Float;\n     /// use std::f64;\n     ///\n     /// let x = f64::consts::E - 1.0;\n@@ -1497,7 +1202,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n-    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn ln_1p(self) -> f64 {\n         unsafe { cmath::log1p(self) }\n@@ -1506,12 +1211,10 @@ impl f64 {\n     /// Hyperbolic sine function.\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n     /// use std::f64;\n     ///\n     /// let e = f64::consts::E;\n-    /// let x = 1.0;\n+    /// let x = 1.0_f64;\n     ///\n     /// let f = x.sinh();\n     /// // Solving sinh() at 1 gives `(e^2-1)/(2e)`\n@@ -1529,12 +1232,10 @@ impl f64 {\n     /// Hyperbolic cosine function.\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n     /// use std::f64;\n     ///\n     /// let e = f64::consts::E;\n-    /// let x = 1.0;\n+    /// let x = 1.0_f64;\n     /// let f = x.cosh();\n     /// // Solving cosh() at 1 gives this result\n     /// let g = (e*e + 1.0)/(2.0*e);\n@@ -1552,12 +1253,10 @@ impl f64 {\n     /// Hyperbolic tangent function.\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n     /// use std::f64;\n     ///\n     /// let e = f64::consts::E;\n-    /// let x = 1.0;\n+    /// let x = 1.0_f64;\n     ///\n     /// let f = x.tanh();\n     /// // Solving tanh() at 1 gives `(1 - e^(-2))/(1 + e^(-2))`\n@@ -1575,9 +1274,7 @@ impl f64 {\n     /// Inverse hyperbolic sine function.\n     ///\n     /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 1.0;\n+    /// let x = 1.0_f64;\n     /// let f = x.sinh().asinh();\n     ///\n     /// let abs_difference = (f - x).abs();\n@@ -1596,9 +1293,7 @@ impl f64 {\n     /// Inverse hyperbolic cosine function.\n     ///\n     /// ```\n-    /// use std::num::Float;\n-    ///\n-    /// let x = 1.0;\n+    /// let x = 1.0_f64;\n     /// let f = x.cosh().acosh();\n     ///\n     /// let abs_difference = (f - x).abs();\n@@ -1617,8 +1312,6 @@ impl f64 {\n     /// Inverse hyperbolic tangent function.\n     ///\n     /// ```\n-    /// # #![feature(core)]\n-    /// use std::num::Float;\n     /// use std::f64;\n     ///\n     /// let e = f64::consts::E;\n@@ -1646,6 +1339,7 @@ impl f64 {\n /// * num - The float value\n #[inline]\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use the ToString trait instead\")]\n pub fn to_string(num: f64) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10, true, SignNeg, DigAll, ExpNone, false);\n@@ -1659,6 +1353,7 @@ pub fn to_string(num: f64) -> String {\n /// * num - The float value\n #[inline]\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use format! instead\")]\n pub fn to_str_hex(num: f64) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 16, true, SignNeg, DigAll, ExpNone, false);\n@@ -1674,6 +1369,7 @@ pub fn to_str_hex(num: f64) -> String {\n /// * radix - The base to use\n #[inline]\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use format! instead\")]\n pub fn to_str_radix_special(num: f64, rdx: u32) -> (String, bool) {\n     strconv::float_to_str_common(num, rdx, true, SignNeg, DigAll, ExpNone, false)\n }\n@@ -1770,8 +1466,8 @@ mod tests {\n         assert!(!nan.is_infinite());\n         assert!(!nan.is_finite());\n         assert!(!nan.is_normal());\n-        assert!(!nan.is_positive());\n-        assert!(!nan.is_negative());\n+        assert!(!nan.is_sign_positive());\n+        assert!(!nan.is_sign_negative());\n         assert_eq!(Fp::Nan, nan.classify());\n     }\n \n@@ -1780,8 +1476,8 @@ mod tests {\n         let inf: f64 = Float::infinity();\n         assert!(inf.is_infinite());\n         assert!(!inf.is_finite());\n-        assert!(inf.is_positive());\n-        assert!(!inf.is_negative());\n+        assert!(inf.is_sign_positive());\n+        assert!(!inf.is_sign_negative());\n         assert!(!inf.is_nan());\n         assert!(!inf.is_normal());\n         assert_eq!(Fp::Infinite, inf.classify());\n@@ -1792,8 +1488,8 @@ mod tests {\n         let neg_inf: f64 = Float::neg_infinity();\n         assert!(neg_inf.is_infinite());\n         assert!(!neg_inf.is_finite());\n-        assert!(!neg_inf.is_positive());\n-        assert!(neg_inf.is_negative());\n+        assert!(!neg_inf.is_sign_positive());\n+        assert!(neg_inf.is_sign_negative());\n         assert!(!neg_inf.is_nan());\n         assert!(!neg_inf.is_normal());\n         assert_eq!(Fp::Infinite, neg_inf.classify());\n@@ -1805,8 +1501,8 @@ mod tests {\n         assert_eq!(0.0, zero);\n         assert!(!zero.is_infinite());\n         assert!(zero.is_finite());\n-        assert!(zero.is_positive());\n-        assert!(!zero.is_negative());\n+        assert!(zero.is_sign_positive());\n+        assert!(!zero.is_sign_negative());\n         assert!(!zero.is_nan());\n         assert!(!zero.is_normal());\n         assert_eq!(Fp::Zero, zero.classify());\n@@ -1818,8 +1514,8 @@ mod tests {\n         assert_eq!(0.0, neg_zero);\n         assert!(!neg_zero.is_infinite());\n         assert!(neg_zero.is_finite());\n-        assert!(!neg_zero.is_positive());\n-        assert!(neg_zero.is_negative());\n+        assert!(!neg_zero.is_sign_positive());\n+        assert!(neg_zero.is_sign_negative());\n         assert!(!neg_zero.is_nan());\n         assert!(!neg_zero.is_normal());\n         assert_eq!(Fp::Zero, neg_zero.classify());\n@@ -1831,8 +1527,8 @@ mod tests {\n         assert_eq!(1.0, one);\n         assert!(!one.is_infinite());\n         assert!(one.is_finite());\n-        assert!(one.is_positive());\n-        assert!(!one.is_negative());\n+        assert!(one.is_sign_positive());\n+        assert!(!one.is_sign_negative());\n         assert!(!one.is_nan());\n         assert!(one.is_normal());\n         assert_eq!(Fp::Normal, one.classify());\n@@ -2017,27 +1713,27 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_is_positive() {\n-        assert!(INFINITY.is_positive());\n-        assert!(1f64.is_positive());\n-        assert!(0f64.is_positive());\n-        assert!(!(-0f64).is_positive());\n-        assert!(!(-1f64).is_positive());\n-        assert!(!NEG_INFINITY.is_positive());\n-        assert!(!(1f64/NEG_INFINITY).is_positive());\n-        assert!(!NAN.is_positive());\n+    fn test_is_sign_positive() {\n+        assert!(INFINITY.is_sign_positive());\n+        assert!(1f64.is_sign_positive());\n+        assert!(0f64.is_sign_positive());\n+        assert!(!(-0f64).is_sign_positive());\n+        assert!(!(-1f64).is_sign_positive());\n+        assert!(!NEG_INFINITY.is_sign_positive());\n+        assert!(!(1f64/NEG_INFINITY).is_sign_positive());\n+        assert!(!NAN.is_sign_positive());\n     }\n \n     #[test]\n-    fn test_is_negative() {\n-        assert!(!INFINITY.is_negative());\n-        assert!(!1f64.is_negative());\n-        assert!(!0f64.is_negative());\n-        assert!((-0f64).is_negative());\n-        assert!((-1f64).is_negative());\n-        assert!(NEG_INFINITY.is_negative());\n-        assert!((1f64/NEG_INFINITY).is_negative());\n-        assert!(!NAN.is_negative());\n+    fn test_is_sign_negative() {\n+        assert!(!INFINITY.is_sign_negative());\n+        assert!(!1f64.is_sign_negative());\n+        assert!(!0f64.is_sign_negative());\n+        assert!((-0f64).is_sign_negative());\n+        assert!((-1f64).is_sign_negative());\n+        assert!(NEG_INFINITY.is_sign_negative());\n+        assert!((1f64/NEG_INFINITY).is_sign_negative());\n+        assert!(!NAN.is_sign_negative());\n     }\n \n     #[test]"}, {"sha": "2de03e2e72d664c41b3bde2324c33f9659a7b00e", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -15,6 +15,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n+#![allow(deprecated)]\n \n #[cfg(test)] use fmt::Debug;\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n@@ -23,22 +24,24 @@ use marker::Copy;\n use clone::Clone;\n use cmp::{PartialOrd, PartialEq};\n \n-pub use core::num::{Int, SignedInt};\n+pub use core::num::{Int, SignedInt, Zero, One};\n pub use core::num::{cast, FromPrimitive, NumCast, ToPrimitive};\n pub use core::num::{from_int, from_i8, from_i16, from_i32, from_i64};\n pub use core::num::{from_uint, from_u8, from_u16, from_u32, from_u64};\n pub use core::num::{from_f32, from_f64};\n pub use core::num::{FromStrRadix, from_str_radix};\n pub use core::num::{FpCategory, ParseIntError, ParseFloatError};\n-pub use core::num::wrapping;\n+pub use core::num::{wrapping, Wrapping};\n \n use option::Option;\n \n-#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n+#[unstable(feature = \"std_misc\", reason = \"likely to be removed\")]\n pub mod strconv;\n \n /// Mathematical operations on primitive floating point numbers.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"replaced by inherent methods; use rust-lang/num for generics\")]\n pub trait Float\n     : Copy + Clone\n     + NumCast\n@@ -272,6 +275,7 @@ pub trait Float\n     /// ```\n     #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n     fn is_finite(self) -> bool;\n+\n     /// Returns `true` if the number is neither zero, infinite,\n     /// [subnormal][subnormal], or `NaN`.\n     ///\n@@ -1148,7 +1152,7 @@ pub fn test_num<T>(ten: T, two: T) where\n \n #[cfg(test)]\n mod tests {\n-    use prelude::v1::*;\n+    use core::prelude::*;\n     use super::*;\n     use i8;\n     use i16;\n@@ -1160,6 +1164,7 @@ mod tests {\n     use u32;\n     use u64;\n     use usize;\n+    use string::ToString;\n \n     macro_rules! test_cast_20 {\n         ($_20:expr) => ({"}, {"sha": "fe55f40390e1754a07a2b3da1bfffbc985527e28", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -11,6 +11,7 @@\n // ignore-lexer-test FIXME #15679\n \n #![allow(missing_docs)]\n+#![allow(deprecated)]\n \n use self::ExponentFormat::*;\n use self::SignificantDigits::*;"}, {"sha": "297eccb9f769831da5a804e564c328b932f63cec", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -51,6 +51,3 @@\n #[doc(no_inline)] pub use string::{String, ToString};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use vec::Vec;\n-\n-// FIXME(#23454) should these be here?\n-#[doc(no_inline)] pub use num::wrapping::{Wrapping, WrappingOps};"}, {"sha": "d2e2f1044d612aef23ce8d7c5a7d0a78ee952680", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -14,6 +14,7 @@ use old_io::{self, IoError, IoResult};\n use prelude::v1::*;\n use sys::{last_error, retry};\n use ffi::CString;\n+#[allow(deprecated)] // Int\n use num::Int;\n \n #[allow(deprecated)]"}, {"sha": "987a12293da50c0a465cb43c9d3037b76117301f", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -37,6 +37,7 @@ use fmt;\n use hash::{Hash, Hasher};\n use iter::{FromIterator, IntoIterator};\n use mem;\n+#[allow(deprecated)] // Int\n use num::Int;\n use ops;\n use slice;"}, {"sha": "e8409bb4fd42c3ae61d322ed070b19257b547d19", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -171,6 +171,7 @@ pub fn retry<T, F> (mut f: F) -> T where\n     }\n }\n \n+#[allow(deprecated)]\n pub fn cvt<T: SignedInt>(t: T) -> io::Result<T> {\n     let one: T = Int::one();\n     if t == -one {\n@@ -180,6 +181,7 @@ pub fn cvt<T: SignedInt>(t: T) -> io::Result<T> {\n     }\n }\n \n+#[allow(deprecated)]\n pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>\n     where T: SignedInt, F: FnMut() -> T\n {"}, {"sha": "e9d5fca531fdb8b7ecd5fd3f8360b2d5059879c4", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -18,6 +18,7 @@ use ffi::{OsStr, OsString};\n use io::{self, ErrorKind};\n use libc;\n use mem;\n+#[allow(deprecated)]\n use num::Int;\n use old_io::{self, IoResult, IoError};\n use os::windows::ffi::{OsStrExt, OsStringExt};\n@@ -315,6 +316,7 @@ pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n     }\n }\n \n+#[allow(deprecated)]\n fn cvt<I: Int>(i: I) -> io::Result<I> {\n     if i == Int::zero() {\n         Err(io::Error::last_os_error())"}, {"sha": "88d043de479bbe68ce50b27e4ff02ff3d6c6f821", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -15,6 +15,7 @@ use libc::consts::os::extra::INVALID_SOCKET;\n use libc::{self, c_int, c_void};\n use mem;\n use net::SocketAddr;\n+#[allow(deprecated)]\n use num::{SignedInt, Int};\n use rt;\n use sync::{Once, ONCE_INIT};\n@@ -50,6 +51,7 @@ fn last_error() -> io::Error {\n /// function must be called before another call to the socket API is made.\n ///\n /// FIXME: generics needed?\n+#[allow(deprecated)]\n pub fn cvt<T: SignedInt>(t: T) -> io::Result<T> {\n     let one: T = Int::one();\n     if t == -one {\n@@ -67,6 +69,7 @@ pub fn cvt_gai(err: c_int) -> io::Result<()> {\n }\n \n /// Provides the functionality of `cvt` for a closure.\n+#[allow(deprecated)]\n pub fn cvt_r<T: SignedInt, F>(mut f: F) -> io::Result<T> where F: FnMut() -> T {\n     cvt(f())\n }"}, {"sha": "9b79b483b28cfbc77b27c21ee4ac2f9395ca1ebf", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -16,6 +16,7 @@ use {fmt, i64};\n use ops::{Add, Sub, Mul, Div, Neg, FnOnce};\n use option::Option;\n use option::Option::{Some, None};\n+#[allow(deprecated)] // Int\n use num::Int;\n use result::Result::Ok;\n "}, {"sha": "ce1539c62f80bc673edba482ca1fa2c35ee3f435", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -66,6 +66,7 @@ use parse::lexer;\n use ptr::P;\n \n use std::fmt;\n+#[allow(deprecated)]\n use std::num::Int;\n use std::rc::Rc;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n@@ -1141,6 +1142,7 @@ pub enum Sign {\n }\n \n impl Sign {\n+    #[allow(deprecated)] // Int\n     pub fn new<T:Int>(n: T) -> Sign {\n         if n < Int::zero() {\n             Minus"}, {"sha": "bcb265af9265527d85a78e209683456d1d156601", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -20,7 +20,6 @@ use std::borrow::{IntoCow, Cow};\n use std::char;\n use std::fmt;\n use std::mem::replace;\n-use std::num;\n use std::rc::Rc;\n \n pub use ext::tt::transcribe::{TtReader, new_tt_reader, new_tt_reader_with_doc_flag};\n@@ -622,8 +621,8 @@ impl<'a> StringReader<'a> {\n \n         // find the integer representing the name\n         self.scan_digits(base);\n-        let encoded_name : u32 = self.with_str_from(start_bpos, |s| {\n-            num::from_str_radix(s, 10).unwrap_or_else(|_| {\n+        let encoded_name: u32 = self.with_str_from(start_bpos, |s| {\n+            u32::from_str_radix(s, 10).unwrap_or_else(|_| {\n                 panic!(\"expected digits representing a name, got {:?}, {}, range [{:?},{:?}]\",\n                       s, whence, start_bpos, self.last_pos);\n             })\n@@ -641,7 +640,7 @@ impl<'a> StringReader<'a> {\n         let start_bpos = self.last_pos;\n         self.scan_digits(base);\n         let encoded_ctxt : ast::SyntaxContext = self.with_str_from(start_bpos, |s| {\n-            num::from_str_radix(s, 10).unwrap_or_else(|_| {\n+            u32::from_str_radix(s, 10).unwrap_or_else(|_| {\n                 panic!(\"expected digits representing a ctxt, got {:?}, {}\", s, whence);\n             })\n         });"}, {"sha": "544862a374a4e9e9ff52e6d59711f141f2278477", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -21,6 +21,7 @@ use std::cell::{Cell, RefCell};\n use std::fs::File;\n use std::io::Read;\n use std::iter;\n+#[allow(deprecated)] // Int\n use std::num::Int;\n use std::path::{Path, PathBuf};\n use std::rc::Rc;\n@@ -372,7 +373,7 @@ pub fn maybe_aborted<T>(result: T, p: Parser) -> T {\n /// well. Can take any slice prefixed by a character escape. Returns the\n /// character and the number of characters consumed.\n pub fn char_lit(lit: &str) -> (char, isize) {\n-    use std::{num, char};\n+    use std::char;\n \n     let mut chars = lit.chars();\n     let c = match (chars.next(), chars.next()) {\n@@ -399,7 +400,7 @@ pub fn char_lit(lit: &str) -> (char, isize) {\n     let msg2 = &msg[..];\n \n     fn esc(len: usize, lit: &str) -> Option<(char, isize)> {\n-        num::from_str_radix(&lit[2..len], 16).ok()\n+        u32::from_str_radix(&lit[2..len], 16).ok()\n         .and_then(char::from_u32)\n         .map(|x| (x, len as isize))\n     }\n@@ -408,7 +409,7 @@ pub fn char_lit(lit: &str) -> (char, isize) {\n         if lit.as_bytes()[2] == b'{' {\n             let idx = lit.find('}').expect(msg2);\n             let subslice = &lit[3..idx];\n-            num::from_str_radix(subslice, 16).ok()\n+            u32::from_str_radix(subslice, 16).ok()\n                 .and_then(char::from_u32)\n                 .map(|x| (x, subslice.chars().count() as isize + 4))\n         } else {\n@@ -582,7 +583,7 @@ pub fn byte_lit(lit: &str) -> (u8, usize) {\n             b'\\'' => b'\\'',\n             b'0' => b'\\0',\n             _ => {\n-                match ::std::num::from_str_radix::<u64>(&lit[2..4], 16).ok() {\n+                match u64::from_str_radix(&lit[2..4], 16).ok() {\n                     Some(c) =>\n                         if c > 0xFF {\n                             panic!(err(2))\n@@ -733,7 +734,7 @@ pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) ->\n     debug!(\"integer_lit: the type is {:?}, base {:?}, the new string is {:?}, the original \\\n            string was {:?}, the original suffix was {:?}\", ty, base, s, orig, suffix);\n \n-    let res: u64 = match ::std::num::from_str_radix(s, base).ok() {\n+    let res = match u64::from_str_radix(s, base).ok() {\n         Some(r) => r,\n         None => { sd.span_err(sp, \"int literal is too large\"); 0 }\n     };"}, {"sha": "94dee5ccc36b7a65dc39bf4e7e7463d839f3650d", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![allow(missing_docs)]\n+#![allow(deprecated)] // Float\n \n use std::cmp::Ordering::{self, Less, Greater, Equal};\n use std::mem;"}, {"sha": "3f9dd8ab635c3bd64bf973f06354e0cd4eb59a3e", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -22,7 +22,6 @@ use core::char;\n use core::cmp;\n use core::iter::{Filter, AdditiveIterator};\n use core::mem;\n-use core::num::Int;\n use core::slice;\n use core::str::Split;\n "}, {"sha": "3a9baecb9c60e7b595702c82debaf74a76475466", "filename": "src/test/compile-fail/lint-dead-code-4.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -16,8 +16,6 @@\n \n extern crate libc;\n \n-use std::num::Int;\n-\n struct Foo {\n     x: usize,\n     b: bool, //~ ERROR: struct field is never used"}, {"sha": "3ae61722bcff3e9c7206b875f3d403b0361add99", "filename": "src/test/compile-fail/range-1.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange-1.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -15,9 +15,10 @@ pub fn main() {\n     let _ = 0u32..10i32;\n     //~^ ERROR start and end of range have incompatible types\n \n-    // Float => does not implement iterator.\n-    for i in 0f32..42f32 {}\n-    //~^ ERROR the trait `core::num::Int` is not implemented for the type `f32`\n+    // Bool => does not implement iterator.\n+    for i in false..true {}\n+    //~^ ERROR the trait\n+    //~^^ ERROR the trait\n \n     // Unsized type.\n     let arr: &[_] = &[1, 2, 3];"}, {"sha": "7a765703e23a0cedae5dba942f14c287d0e988fa", "filename": "src/test/run-pass/generic-extern-mangle.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Ftest%2Frun-pass%2Fgeneric-extern-mangle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d0beb7d85e8e711334c7fb6f2c5da270e5200cb/src%2Ftest%2Frun-pass%2Fgeneric-extern-mangle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-extern-mangle.rs?ref=5d0beb7d85e8e711334c7fb6f2c5da270e5200cb", "patch": "@@ -12,11 +12,11 @@\n \n #![feature(core)]\n \n-use std::num::Int;\n+use std::ops::Add;\n \n-extern \"C\" fn foo<T: WrappingOps>(a: T, b: T) -> T { a.wrapping_add(b) }\n+extern \"C\" fn foo<T: Add>(a: T, b: T) -> T::Output { a + b }\n \n fn main() {\n-    assert_eq!(99u8, foo(255u8, 100u8));\n-    assert_eq!(99u16, foo(65535u16, 100u16));\n+    assert_eq!(100u8, foo(0u8, 100u8));\n+    assert_eq!(100u16, foo(0u16, 100u16));\n }"}]}