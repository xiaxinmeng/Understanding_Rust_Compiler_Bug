{"sha": "da08198bc94b9c51338cd94aeadc73324b373011", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhMDgxOThiYzk0YjljNTEzMzhjZDk0YWVhZGM3MzMyNGIzNzMwMTE=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-05-10T19:50:42Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-05-10T19:50:42Z"}, "message": "Rewrite `attr.rs` to allow using syntax-based indices", "tree": {"sha": "6ff2b27cabbcd20448b986c60d7418da64832f7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ff2b27cabbcd20448b986c60d7418da64832f7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da08198bc94b9c51338cd94aeadc73324b373011", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da08198bc94b9c51338cd94aeadc73324b373011", "html_url": "https://github.com/rust-lang/rust/commit/da08198bc94b9c51338cd94aeadc73324b373011", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da08198bc94b9c51338cd94aeadc73324b373011/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a87bec51485feb491f7b1b80c06a29d86ebaf681", "url": "https://api.github.com/repos/rust-lang/rust/commits/a87bec51485feb491f7b1b80c06a29d86ebaf681", "html_url": "https://github.com/rust-lang/rust/commit/a87bec51485feb491f7b1b80c06a29d86ebaf681"}], "stats": {"total": 143, "additions": 84, "deletions": 59}, "files": [{"sha": "aadd4e44ae7c60442a8d2c218ecd3b980e7f1422", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 83, "deletions": 58, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/da08198bc94b9c51338cd94aeadc73324b373011/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da08198bc94b9c51338cd94aeadc73324b373011/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=da08198bc94b9c51338cd94aeadc73324b373011", "patch": "@@ -101,17 +101,13 @@ impl RawAttrs {\n         hygiene: &Hygiene,\n     ) -> Self {\n         let entries = collect_attrs(owner)\n-            .enumerate()\n-            .flat_map(|(i, attr)| {\n-                let index = AttrId(i as u32);\n-                match attr {\n-                    Either::Left(attr) => Attr::from_src(db, attr, hygiene, index),\n-                    Either::Right(comment) => comment.doc_comment().map(|doc| Attr {\n-                        id: index,\n-                        input: Some(AttrInput::Literal(SmolStr::new(doc))),\n-                        path: Interned::new(ModPath::from(hir_expand::name!(doc))),\n-                    }),\n-                }\n+            .flat_map(|(id, attr)| match attr {\n+                Either::Left(attr) => Attr::from_src(db, attr, hygiene, id),\n+                Either::Right(comment) => comment.doc_comment().map(|doc| Attr {\n+                    id,\n+                    input: Some(AttrInput::Literal(SmolStr::new(doc))),\n+                    path: Interned::new(ModPath::from(hir_expand::name!(doc))),\n+                }),\n             })\n             .collect::<Arc<_>>();\n \n@@ -124,6 +120,7 @@ impl RawAttrs {\n     }\n \n     pub(crate) fn merge(&self, other: Self) -> Self {\n+        // FIXME: This needs to fixup `AttrId`s\n         match (&self.entries, &other.entries) {\n             (None, None) => Self::EMPTY,\n             (Some(entries), None) | (None, Some(entries)) => {\n@@ -375,39 +372,26 @@ impl AttrsWithOwner {\n \n                 let def_map = module.def_map(db);\n                 let mod_data = &def_map[module.local_id];\n-                let attrs = match mod_data.declaration_source(db) {\n+                match mod_data.declaration_source(db) {\n                     Some(it) => {\n-                        let mut attrs: Vec<_> = collect_attrs(&it.value as &dyn ast::AttrsOwner)\n-                            .map(|attr| InFile::new(it.file_id, attr))\n-                            .collect();\n+                        let mut map = AttrSourceMap::new(InFile::new(it.file_id, &it.value));\n                         if let InFile { file_id, value: ModuleSource::SourceFile(file) } =\n                             mod_data.definition_source(db)\n                         {\n-                            attrs.extend(\n-                                collect_attrs(&file as &dyn ast::AttrsOwner)\n-                                    .map(|attr| InFile::new(file_id, attr)),\n-                            )\n+                            map.merge(AttrSourceMap::new(InFile::new(file_id, &file)));\n                         }\n-                        attrs\n+                        return map;\n                     }\n                     None => {\n                         let InFile { file_id, value } = mod_data.definition_source(db);\n-                        match &value {\n-                            ModuleSource::SourceFile(file) => {\n-                                collect_attrs(file as &dyn ast::AttrsOwner)\n-                            }\n-                            ModuleSource::Module(module) => {\n-                                collect_attrs(module as &dyn ast::AttrsOwner)\n-                            }\n-                            ModuleSource::BlockExpr(block) => {\n-                                collect_attrs(block as &dyn ast::AttrsOwner)\n-                            }\n-                        }\n-                        .map(|attr| InFile::new(file_id, attr))\n-                        .collect()\n+                        let attrs_owner = match &value {\n+                            ModuleSource::SourceFile(file) => file as &dyn ast::AttrsOwner,\n+                            ModuleSource::Module(module) => module as &dyn ast::AttrsOwner,\n+                            ModuleSource::BlockExpr(block) => block as &dyn ast::AttrsOwner,\n+                        };\n+                        return AttrSourceMap::new(InFile::new(file_id, attrs_owner));\n                     }\n-                };\n-                return AttrSourceMap { attrs };\n+                }\n             }\n             AttrDefId::FieldId(id) => {\n                 let map = db.fields_attrs_source_map(id.parent);\n@@ -462,11 +446,7 @@ impl AttrsWithOwner {\n             },\n         };\n \n-        AttrSourceMap {\n-            attrs: collect_attrs(&owner.value)\n-                .map(|attr| InFile::new(owner.file_id, attr))\n-                .collect(),\n-        }\n+        AttrSourceMap::new(owner.as_ref().map(|node| node as &dyn AttrsOwner))\n     }\n \n     pub fn docs_with_rangemap(\n@@ -518,7 +498,7 @@ impl AttrsWithOwner {\n         if buf.is_empty() {\n             None\n         } else {\n-            Some((Documentation(buf), DocsRangeMap { mapping, source: self.source_map(db).attrs }))\n+            Some((Documentation(buf), DocsRangeMap { mapping, source_map: self.source_map(db) }))\n         }\n     }\n }\n@@ -559,27 +539,59 @@ fn inner_attributes(\n }\n \n pub struct AttrSourceMap {\n-    attrs: Vec<InFile<Either<ast::Attr, ast::Comment>>>,\n+    attrs: Vec<InFile<ast::Attr>>,\n+    doc_comments: Vec<InFile<ast::Comment>>,\n }\n \n impl AttrSourceMap {\n+    fn new(owner: InFile<&dyn ast::AttrsOwner>) -> Self {\n+        let mut attrs = Vec::new();\n+        let mut doc_comments = Vec::new();\n+        for (_, attr) in collect_attrs(owner.value) {\n+            match attr {\n+                Either::Left(attr) => attrs.push(owner.with_value(attr)),\n+                Either::Right(comment) => doc_comments.push(owner.with_value(comment)),\n+            }\n+        }\n+\n+        Self { attrs, doc_comments }\n+    }\n+\n+    fn merge(&mut self, other: Self) {\n+        self.attrs.extend(other.attrs);\n+        self.doc_comments.extend(other.doc_comments);\n+    }\n+\n     /// Maps the lowered `Attr` back to its original syntax node.\n     ///\n     /// `attr` must come from the `owner` used for AttrSourceMap\n     ///\n     /// Note that the returned syntax node might be a `#[cfg_attr]`, or a doc comment, instead of\n     /// the attribute represented by `Attr`.\n-    pub fn source_of(&self, attr: &Attr) -> InFile<&Either<ast::Attr, ast::Comment>> {\n-        self.attrs\n-            .get(attr.id.0 as usize)\n-            .unwrap_or_else(|| panic!(\"cannot find `Attr` at index {:?}\", attr.id))\n-            .as_ref()\n+    pub fn source_of(&self, attr: &Attr) -> InFile<Either<ast::Attr, ast::Comment>> {\n+        self.source_of_id(attr.id)\n+    }\n+\n+    fn source_of_id(&self, id: AttrId) -> InFile<Either<ast::Attr, ast::Comment>> {\n+        if id.is_doc_comment {\n+            self.doc_comments\n+                .get(id.ast_index as usize)\n+                .unwrap_or_else(|| panic!(\"cannot find doc comment at index {:?}\", id))\n+                .clone()\n+                .map(|attr| Either::Right(attr))\n+        } else {\n+            self.attrs\n+                .get(id.ast_index as usize)\n+                .unwrap_or_else(|| panic!(\"cannot find `Attr` at index {:?}\", id))\n+                .clone()\n+                .map(|attr| Either::Left(attr))\n+        }\n     }\n }\n \n /// A struct to map text ranges from [`Documentation`] back to TextRanges in the syntax tree.\n pub struct DocsRangeMap {\n-    source: Vec<InFile<Either<ast::Attr, ast::Comment>>>,\n+    source_map: AttrSourceMap,\n     // (docstring-line-range, attr_index, attr-string-range)\n     // a mapping from the text range of a line of the [`Documentation`] to the attribute index and\n     // the original (untrimmed) syntax doc line\n@@ -596,7 +608,7 @@ impl DocsRangeMap {\n \n         let relative_range = range - line_docs_range.start();\n \n-        let &InFile { file_id, value: ref source } = &self.source[idx.0 as usize];\n+        let &InFile { file_id, value: ref source } = &self.source_map.source_of_id(idx);\n         match source {\n             Either::Left(_) => None, // FIXME, figure out a nice way to handle doc attributes here\n             // as well as for whats done in syntax highlight doc injection\n@@ -616,7 +628,10 @@ impl DocsRangeMap {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct AttrId(pub u32);\n+pub(crate) struct AttrId {\n+    is_doc_comment: bool,\n+    pub(crate) ast_index: u32,\n+}\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Attr {\n@@ -752,22 +767,32 @@ fn attrs_from_item_tree<N: ItemTreeNode>(id: ItemTreeId<N>, db: &dyn DefDatabase\n \n fn collect_attrs(\n     owner: &dyn ast::AttrsOwner,\n-) -> impl Iterator<Item = Either<ast::Attr, ast::Comment>> {\n+) -> impl Iterator<Item = (AttrId, Either<ast::Attr, ast::Comment>)> {\n     let (inner_attrs, inner_docs) = inner_attributes(owner.syntax())\n         .map_or((None, None), |(attrs, docs)| (Some(attrs), Some(docs)));\n \n     let outer_attrs = owner.attrs().filter(|attr| attr.kind().is_outer());\n-    let attrs = outer_attrs\n-        .chain(inner_attrs.into_iter().flatten())\n-        .map(|attr| (attr.syntax().text_range().start(), Either::Left(attr)));\n+    let attrs =\n+        outer_attrs.chain(inner_attrs.into_iter().flatten()).enumerate().map(|(idx, attr)| {\n+            (\n+                AttrId { ast_index: idx as u32, is_doc_comment: false },\n+                attr.syntax().text_range().start(),\n+                Either::Left(attr),\n+            )\n+        });\n \n     let outer_docs =\n         ast::CommentIter::from_syntax_node(owner.syntax()).filter(ast::Comment::is_outer);\n-    let docs = outer_docs\n-        .chain(inner_docs.into_iter().flatten())\n-        .map(|docs_text| (docs_text.syntax().text_range().start(), Either::Right(docs_text)));\n+    let docs =\n+        outer_docs.chain(inner_docs.into_iter().flatten()).enumerate().map(|(idx, docs_text)| {\n+            (\n+                AttrId { ast_index: idx as u32, is_doc_comment: true },\n+                docs_text.syntax().text_range().start(),\n+                Either::Right(docs_text),\n+            )\n+        });\n     // sort here by syntax node offset because the source can have doc attributes and doc strings be interleaved\n-    docs.chain(attrs).sorted_by_key(|&(offset, _)| offset).map(|(_, attr)| attr)\n+    docs.chain(attrs).sorted_by_key(|&(_, offset, _)| offset).map(|(id, _, attr)| (id, attr))\n }\n \n pub(crate) fn variants_attrs_source_map("}, {"sha": "a82ea5957e9943e12d6ae4388b43f8b796784984", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da08198bc94b9c51338cd94aeadc73324b373011/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da08198bc94b9c51338cd94aeadc73324b373011/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=da08198bc94b9c51338cd94aeadc73324b373011", "patch": "@@ -753,7 +753,7 @@ fn derive_macro_as_call_id(\n             MacroCallKind::Derive {\n                 ast_id: item_attr.ast_id,\n                 derive_name: last_segment.to_string(),\n-                derive_attr_index: derive_attr.0,\n+                derive_attr_index: derive_attr.ast_index,\n             },\n         )\n         .into();"}]}