{"sha": "bcf5cf8ac64e8c63b4e083c7f2f88e2fe915cdb5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjZjVjZjhhYzY0ZThjNjNiNGUwODNjN2YyZjg4ZTJmZTkxNWNkYjU=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-04-21T20:09:44Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-04-21T21:04:37Z"}, "message": "fix mbe_parser rhs colon parsing", "tree": {"sha": "9ef2a9784672e35f9612e3febc820bd09983458d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ef2a9784672e35f9612e3febc820bd09983458d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcf5cf8ac64e8c63b4e083c7f2f88e2fe915cdb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcf5cf8ac64e8c63b4e083c7f2f88e2fe915cdb5", "html_url": "https://github.com/rust-lang/rust/commit/bcf5cf8ac64e8c63b4e083c7f2f88e2fe915cdb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcf5cf8ac64e8c63b4e083c7f2f88e2fe915cdb5/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a5b9638c1faf8fb4bbe4fbb0ea80c4386f65a21", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a5b9638c1faf8fb4bbe4fbb0ea80c4386f65a21", "html_url": "https://github.com/rust-lang/rust/commit/9a5b9638c1faf8fb4bbe4fbb0ea80c4386f65a21"}], "stats": {"total": 21, "additions": 11, "deletions": 10}, "files": [{"sha": "0710062d9fd9ef8066fe24f23011d8b23582e4e4", "filename": "crates/ra_mbe/src/mbe_parser.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bcf5cf8ac64e8c63b4e083c7f2f88e2fe915cdb5/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf5cf8ac64e8c63b4e083c7f2f88e2fe915cdb5/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs?ref=bcf5cf8ac64e8c63b4e083c7f2f88e2fe915cdb5", "patch": "@@ -20,25 +20,25 @@ pub(crate) fn parse(tt: &tt::Subtree) -> Result<crate::MacroRules, ParseError> {\n }\n \n fn parse_rule(p: &mut TtCursor) -> Result<crate::Rule, ParseError> {\n-    let lhs = parse_subtree(p.eat_subtree()?)?;\n+    let lhs = parse_subtree(p.eat_subtree()?, false)?;\n     p.expect_char('=')?;\n     p.expect_char('>')?;\n-    let mut rhs = parse_subtree(p.eat_subtree()?)?;\n+    let mut rhs = parse_subtree(p.eat_subtree()?, true)?;\n     rhs.delimiter = crate::Delimiter::None;\n     Ok(crate::Rule { lhs, rhs })\n }\n \n-fn parse_subtree(tt: &tt::Subtree) -> Result<crate::Subtree, ParseError> {\n+fn parse_subtree(tt: &tt::Subtree, transcriber: bool) -> Result<crate::Subtree, ParseError> {\n     let mut token_trees = Vec::new();\n     let mut p = TtCursor::new(tt);\n     while let Some(tt) = p.eat() {\n         let child: crate::TokenTree = match tt {\n             tt::TokenTree::Leaf(leaf) => match leaf {\n                 tt::Leaf::Punct(tt::Punct { char: '$', .. }) => {\n                     if p.at_ident().is_some() {\n-                        crate::Leaf::from(parse_var(&mut p)?).into()\n+                        crate::Leaf::from(parse_var(&mut p, transcriber)?).into()\n                     } else {\n-                        parse_repeat(&mut p)?.into()\n+                        parse_repeat(&mut p, transcriber)?.into()\n                     }\n                 }\n                 tt::Leaf::Punct(punct) => crate::Leaf::from(*punct).into(),\n@@ -49,17 +49,17 @@ fn parse_subtree(tt: &tt::Subtree) -> Result<crate::Subtree, ParseError> {\n                     crate::Leaf::from(crate::Literal { text: text.clone() }).into()\n                 }\n             },\n-            tt::TokenTree::Subtree(subtree) => parse_subtree(&subtree)?.into(),\n+            tt::TokenTree::Subtree(subtree) => parse_subtree(&subtree, transcriber)?.into(),\n         };\n         token_trees.push(child);\n     }\n     Ok(crate::Subtree { token_trees, delimiter: tt.delimiter })\n }\n \n-fn parse_var(p: &mut TtCursor) -> Result<crate::Var, ParseError> {\n+fn parse_var(p: &mut TtCursor, transcriber: bool) -> Result<crate::Var, ParseError> {\n     let ident = p.eat_ident().unwrap();\n     let text = ident.text.clone();\n-    let kind = if p.at_char(':') {\n+    let kind = if !transcriber && p.at_char(':') {\n         p.bump();\n         if let Some(ident) = p.eat_ident() {\n             Some(ident.text.clone())\n@@ -70,12 +70,13 @@ fn parse_var(p: &mut TtCursor) -> Result<crate::Var, ParseError> {\n     } else {\n         None\n     };\n+\n     Ok(crate::Var { text, kind })\n }\n \n-fn parse_repeat(p: &mut TtCursor) -> Result<crate::Repeat, ParseError> {\n+fn parse_repeat(p: &mut TtCursor, transcriber: bool) -> Result<crate::Repeat, ParseError> {\n     let subtree = p.eat_subtree().unwrap();\n-    let mut subtree = parse_subtree(subtree)?;\n+    let mut subtree = parse_subtree(subtree, transcriber)?;\n     subtree.delimiter = crate::Delimiter::None;\n     let sep = p.eat_punct().ok_or(ParseError::Expected(String::from(\"separator\")))?;\n     let (separator, rep) = match sep.char {"}]}