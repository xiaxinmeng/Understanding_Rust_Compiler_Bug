{"sha": "829d97bde289ad3dbc6d3417c657e942f9b404fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyOWQ5N2JkZTI4OWFkM2RiYzZkMzQxN2M2NTdlOTQyZjliNDA0ZmU=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-12-08T06:01:11Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-12-08T06:01:11Z"}, "message": "Move lvalue-related methods to lvalue mod.", "tree": {"sha": "01fc2ab599b3b7f3db59e0729b5359bb571708ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01fc2ab599b3b7f3db59e0729b5359bb571708ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/829d97bde289ad3dbc6d3417c657e942f9b404fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/829d97bde289ad3dbc6d3417c657e942f9b404fe", "html_url": "https://github.com/rust-lang/rust/commit/829d97bde289ad3dbc6d3417c657e942f9b404fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/829d97bde289ad3dbc6d3417c657e942f9b404fe/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ce6514f236794ce13af807194e811099b7794cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ce6514f236794ce13af807194e811099b7794cc", "html_url": "https://github.com/rust-lang/rust/commit/5ce6514f236794ce13af807194e811099b7794cc"}], "stats": {"total": 513, "additions": 258, "deletions": 255}, "files": [{"sha": "85c829ede12b2acf5b8adc725e18d43020f35023", "filename": "src/eval_context.rs", "status": "modified", "additions": 0, "deletions": 253, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/829d97bde289ad3dbc6d3417c657e942f9b404fe/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/829d97bde289ad3dbc6d3417c657e942f9b404fe/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=829d97bde289ad3dbc6d3417c657e942f9b404fe", "patch": "@@ -819,224 +819,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn eval_and_read_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Value> {\n-        if let mir::Lvalue::Projection(ref proj) = *lvalue {\n-            if let mir::Lvalue::Local(index) = proj.base {\n-                if let Some(Value::ByValPair(a, b)) = self.frame().get_local(index) {\n-                    if let mir::ProjectionElem::Field(ref field, _) = proj.elem {\n-                        let val = [a, b][field.index()];\n-                        return Ok(Value::ByVal(val));\n-                    }\n-                }\n-            }\n-        }\n-        let lvalue = self.eval_lvalue(lvalue)?;\n-        self.read_lvalue(lvalue)\n-    }\n-\n-    pub fn read_lvalue(&self, lvalue: Lvalue<'tcx>) -> EvalResult<'tcx, Value> {\n-        match lvalue {\n-            Lvalue::Ptr { ptr, extra } => {\n-                assert_eq!(extra, LvalueExtra::None);\n-                Ok(Value::ByRef(ptr))\n-            }\n-            Lvalue::Local { frame, local } => {\n-                self.stack[frame].get_local(local).ok_or(EvalError::ReadUndefBytes)\n-            }\n-            Lvalue::Global(cid) => self.globals\n-                                       .get(&cid)\n-                                       .expect(\"global not cached\")\n-                                       .data\n-                                       .ok_or(EvalError::ReadUndefBytes),\n-        }\n-    }\n-\n-    pub(super) fn eval_lvalue(&mut self, mir_lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue<'tcx>> {\n-        use rustc::mir::Lvalue::*;\n-        let lvalue = match *mir_lvalue {\n-            Local(mir::RETURN_POINTER) => self.frame().return_lvalue,\n-\n-            Local(local) => {\n-                Lvalue::Local {\n-                    frame: self.stack.len() - 1,\n-                    local: local,\n-                }\n-            }\n-\n-            Static(def_id) => {\n-                let substs = self.tcx.intern_substs(&[]);\n-                let cid = GlobalId {\n-                    def_id: def_id,\n-                    substs: substs,\n-                    promoted: None,\n-                };\n-                Lvalue::Global(cid)\n-            }\n-\n-            Projection(ref proj) => return self.eval_lvalue_projection(proj),\n-        };\n-\n-        if log_enabled!(::log::LogLevel::Trace) {\n-            self.dump_local(lvalue);\n-        }\n-\n-        Ok(lvalue)\n-    }\n-\n-    fn eval_lvalue_projection(\n-        &mut self,\n-        proj: &mir::LvalueProjection<'tcx>,\n-    ) -> EvalResult<'tcx, Lvalue<'tcx>> {\n-        let base = self.eval_lvalue(&proj.base)?;\n-        let base_ty = self.lvalue_ty(&proj.base);\n-        let base_layout = self.type_layout(base_ty)?;\n-\n-        use rustc::mir::ProjectionElem::*;\n-        let (ptr, extra) = match proj.elem {\n-            Field(field, field_ty) => {\n-                // FIXME(solson)\n-                let base = self.force_allocation(base)?;\n-                let (base_ptr, base_extra) = base.to_ptr_and_extra();\n-\n-                let field_ty = self.monomorphize(field_ty, self.substs());\n-                let field = field.index();\n-\n-                use rustc::ty::layout::Layout::*;\n-                let offset = match *base_layout {\n-                    Univariant { ref variant, .. } => variant.offsets[field],\n-\n-                    General { ref variants, .. } => {\n-                        if let LvalueExtra::DowncastVariant(variant_idx) = base_extra {\n-                            // +1 for the discriminant, which is field 0\n-                            variants[variant_idx].offsets[field + 1]\n-                        } else {\n-                            bug!(\"field access on enum had no variant index\");\n-                        }\n-                    }\n-\n-                    RawNullablePointer { .. } => {\n-                        assert_eq!(field.index(), 0);\n-                        return Ok(base);\n-                    }\n-\n-                    StructWrappedNullablePointer { ref nonnull, .. } => {\n-                        nonnull.offsets[field]\n-                    }\n-\n-                    _ => bug!(\"field access on non-product type: {:?}\", base_layout),\n-                };\n-\n-                let ptr = base_ptr.offset(offset.bytes());\n-                let extra = if self.type_is_sized(field_ty) {\n-                    LvalueExtra::None\n-                } else {\n-                    match base_extra {\n-                        LvalueExtra::None => bug!(\"expected fat pointer\"),\n-                        LvalueExtra::DowncastVariant(..) =>\n-                            bug!(\"Rust doesn't support unsized fields in enum variants\"),\n-                        LvalueExtra::Vtable(_) |\n-                        LvalueExtra::Length(_) => {},\n-                    }\n-                    base_extra\n-                };\n-\n-                (ptr, extra)\n-            }\n-\n-            Downcast(_, variant) => {\n-                // FIXME(solson)\n-                let base = self.force_allocation(base)?;\n-                let (base_ptr, base_extra) = base.to_ptr_and_extra();\n-\n-                use rustc::ty::layout::Layout::*;\n-                let extra = match *base_layout {\n-                    General { .. } => LvalueExtra::DowncastVariant(variant),\n-                    RawNullablePointer { .. } | StructWrappedNullablePointer { .. } => base_extra,\n-                    _ => bug!(\"variant downcast on non-aggregate: {:?}\", base_layout),\n-                };\n-                (base_ptr, extra)\n-            }\n-\n-            Deref => {\n-                let val = self.eval_and_read_lvalue(&proj.base)?;\n-\n-                let pointee_type = match base_ty.sty {\n-                    ty::TyRawPtr(ty::TypeAndMut{ty, ..}) |\n-                    ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n-                    ty::TyBox(ty) => ty,\n-                    _ => bug!(\"can only deref pointer types\"),\n-                };\n-\n-                trace!(\"deref to {} on {:?}\", pointee_type, val);\n-\n-                match self.tcx.struct_tail(pointee_type).sty {\n-                    ty::TyDynamic(..) => {\n-                        let (ptr, vtable) = val.expect_ptr_vtable_pair(&self.memory)?;\n-                        (ptr, LvalueExtra::Vtable(vtable))\n-                    },\n-                    ty::TyStr | ty::TySlice(_) => {\n-                        let (ptr, len) = val.expect_slice(&self.memory)?;\n-                        (ptr, LvalueExtra::Length(len))\n-                    },\n-                    _ => (val.read_ptr(&self.memory)?, LvalueExtra::None),\n-                }\n-            }\n-\n-            Index(ref operand) => {\n-                // FIXME(solson)\n-                let base = self.force_allocation(base)?;\n-                let (base_ptr, _) = base.to_ptr_and_extra();\n-\n-                let (elem_ty, len) = base.elem_ty_and_len(base_ty);\n-                let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n-                let n_ptr = self.eval_operand(operand)?;\n-                let usize = self.tcx.types.usize;\n-                let n = self.value_to_primval(n_ptr, usize)?.to_u64();\n-                assert!(n < len);\n-                let ptr = base_ptr.offset(n * elem_size);\n-                (ptr, LvalueExtra::None)\n-            }\n-\n-            ConstantIndex { offset, min_length, from_end } => {\n-                // FIXME(solson)\n-                let base = self.force_allocation(base)?;\n-                let (base_ptr, _) = base.to_ptr_and_extra();\n-\n-                let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n-                let elem_size = self.type_size(elem_ty)?.expect(\"sequence element must be sized\");\n-                assert!(n >= min_length as u64);\n-\n-                let index = if from_end {\n-                    n - u64::from(offset)\n-                } else {\n-                    u64::from(offset)\n-                };\n-\n-                let ptr = base_ptr.offset(index * elem_size);\n-                (ptr, LvalueExtra::None)\n-            }\n-\n-            Subslice { from, to } => {\n-                // FIXME(solson)\n-                let base = self.force_allocation(base)?;\n-                let (base_ptr, _) = base.to_ptr_and_extra();\n-\n-                let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n-                let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n-                assert!(u64::from(from) <= n - u64::from(to));\n-                let ptr = base_ptr.offset(u64::from(from) * elem_size);\n-                let extra = LvalueExtra::Length(n - u64::from(to) - u64::from(from));\n-                (ptr, extra)\n-            }\n-        };\n-\n-        Ok(Lvalue::Ptr { ptr: ptr, extra: extra })\n-    }\n-\n-    pub(super) fn lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> Ty<'tcx> {\n-        self.monomorphize(lvalue.ty(&self.mir(), self.tcx).to_ty(self.tcx), self.substs())\n-    }\n-\n     pub(super) fn operand_ty(&self, operand: &mir::Operand<'tcx>) -> Ty<'tcx> {\n         self.monomorphize(operand.ty(&self.mir(), self.tcx), self.substs())\n     }\n@@ -1617,41 +1399,6 @@ impl<'tcx> Frame<'tcx> {\n     }\n }\n \n-impl<'tcx> Lvalue<'tcx> {\n-    pub fn from_ptr(ptr: Pointer) -> Self {\n-        Lvalue::Ptr { ptr: ptr, extra: LvalueExtra::None }\n-    }\n-\n-    pub(super) fn to_ptr_and_extra(self) -> (Pointer, LvalueExtra) {\n-        match self {\n-            Lvalue::Ptr { ptr, extra } => (ptr, extra),\n-            _ => bug!(\"to_ptr_and_extra: expected Lvalue::Ptr, got {:?}\", self),\n-\n-        }\n-    }\n-\n-    pub(super) fn to_ptr(self) -> Pointer {\n-        let (ptr, extra) = self.to_ptr_and_extra();\n-        assert_eq!(extra, LvalueExtra::None);\n-        ptr\n-    }\n-\n-    fn elem_ty_and_len(self, ty: Ty<'tcx>) -> (Ty<'tcx>, u64) {\n-        match ty.sty {\n-            ty::TyArray(elem, n) => (elem, n as u64),\n-\n-            ty::TySlice(elem) => {\n-                match self {\n-                    Lvalue::Ptr { extra: LvalueExtra::Length(len), .. } => (elem, len),\n-                    _ => bug!(\"elem_ty_and_len of a TySlice given non-slice lvalue: {:?}\", self),\n-                }\n-            }\n-\n-            _ => bug!(\"elem_ty_and_len expected array or slice, got {:?}\", ty),\n-        }\n-    }\n-}\n-\n pub fn eval_main<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,"}, {"sha": "4f3c47800fe4fca183c3a2eb6bb01f955273fe72", "filename": "src/lvalue.rs", "status": "modified", "additions": 258, "deletions": 2, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/829d97bde289ad3dbc6d3417c657e942f9b404fe/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/829d97bde289ad3dbc6d3417c657e942f9b404fe/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=829d97bde289ad3dbc6d3417c657e942f9b404fe", "patch": "@@ -1,10 +1,12 @@\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n-use rustc::ty::Ty;\n+use rustc::ty::{self, Ty};\n use rustc::ty::subst::Substs;\n+use rustc_data_structures::indexed_vec::Idx;\n \n+use error::{EvalError, EvalResult};\n use memory::Pointer;\n-use eval_context::Value;\n+use eval_context::{EvalContext, Value};\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum Lvalue<'tcx> {\n@@ -57,6 +59,41 @@ pub struct Global<'tcx> {\n     pub(super) ty: Ty<'tcx>,\n }\n \n+impl<'tcx> Lvalue<'tcx> {\n+    pub fn from_ptr(ptr: Pointer) -> Self {\n+        Lvalue::Ptr { ptr: ptr, extra: LvalueExtra::None }\n+    }\n+\n+    pub(super) fn to_ptr_and_extra(self) -> (Pointer, LvalueExtra) {\n+        match self {\n+            Lvalue::Ptr { ptr, extra } => (ptr, extra),\n+            _ => bug!(\"to_ptr_and_extra: expected Lvalue::Ptr, got {:?}\", self),\n+\n+        }\n+    }\n+\n+    pub(super) fn to_ptr(self) -> Pointer {\n+        let (ptr, extra) = self.to_ptr_and_extra();\n+        assert_eq!(extra, LvalueExtra::None);\n+        ptr\n+    }\n+\n+    pub(super) fn elem_ty_and_len(self, ty: Ty<'tcx>) -> (Ty<'tcx>, u64) {\n+        match ty.sty {\n+            ty::TyArray(elem, n) => (elem, n as u64),\n+\n+            ty::TySlice(elem) => {\n+                match self {\n+                    Lvalue::Ptr { extra: LvalueExtra::Length(len), .. } => (elem, len),\n+                    _ => bug!(\"elem_ty_and_len of a TySlice given non-slice lvalue: {:?}\", self),\n+                }\n+            }\n+\n+            _ => bug!(\"elem_ty_and_len expected array or slice, got {:?}\", ty),\n+        }\n+    }\n+}\n+\n impl<'tcx> Global<'tcx> {\n     pub(super) fn uninitialized(ty: Ty<'tcx>) -> Self {\n         Global {\n@@ -67,3 +104,222 @@ impl<'tcx> Global<'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+    pub(super) fn eval_and_read_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Value> {\n+        if let mir::Lvalue::Projection(ref proj) = *lvalue {\n+            if let mir::Lvalue::Local(index) = proj.base {\n+                if let Some(Value::ByValPair(a, b)) = self.frame().get_local(index) {\n+                    if let mir::ProjectionElem::Field(ref field, _) = proj.elem {\n+                        let val = [a, b][field.index()];\n+                        return Ok(Value::ByVal(val));\n+                    }\n+                }\n+            }\n+        }\n+        let lvalue = self.eval_lvalue(lvalue)?;\n+        self.read_lvalue(lvalue)\n+    }\n+\n+    pub fn read_lvalue(&self, lvalue: Lvalue<'tcx>) -> EvalResult<'tcx, Value> {\n+        match lvalue {\n+            Lvalue::Ptr { ptr, extra } => {\n+                assert_eq!(extra, LvalueExtra::None);\n+                Ok(Value::ByRef(ptr))\n+            }\n+            Lvalue::Local { frame, local } => {\n+                self.stack[frame].get_local(local).ok_or(EvalError::ReadUndefBytes)\n+            }\n+            Lvalue::Global(cid) => self.globals\n+                                       .get(&cid)\n+                                       .expect(\"global not cached\")\n+                                       .data\n+                                       .ok_or(EvalError::ReadUndefBytes),\n+        }\n+    }\n+\n+    pub(super) fn eval_lvalue(&mut self, mir_lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+        use rustc::mir::Lvalue::*;\n+        let lvalue = match *mir_lvalue {\n+            Local(mir::RETURN_POINTER) => self.frame().return_lvalue,\n+\n+            Local(local) => {\n+                Lvalue::Local {\n+                    frame: self.stack.len() - 1,\n+                    local: local,\n+                }\n+            }\n+\n+            Static(def_id) => {\n+                let substs = self.tcx.intern_substs(&[]);\n+                let cid = GlobalId {\n+                    def_id: def_id,\n+                    substs: substs,\n+                    promoted: None,\n+                };\n+                Lvalue::Global(cid)\n+            }\n+\n+            Projection(ref proj) => return self.eval_lvalue_projection(proj),\n+        };\n+\n+        if log_enabled!(::log::LogLevel::Trace) {\n+            self.dump_local(lvalue);\n+        }\n+\n+        Ok(lvalue)\n+    }\n+\n+    fn eval_lvalue_projection(\n+        &mut self,\n+        proj: &mir::LvalueProjection<'tcx>,\n+    ) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+        let base = self.eval_lvalue(&proj.base)?;\n+        let base_ty = self.lvalue_ty(&proj.base);\n+        let base_layout = self.type_layout(base_ty)?;\n+\n+        use rustc::mir::ProjectionElem::*;\n+        let (ptr, extra) = match proj.elem {\n+            Field(field, field_ty) => {\n+                // FIXME(solson)\n+                let base = self.force_allocation(base)?;\n+                let (base_ptr, base_extra) = base.to_ptr_and_extra();\n+\n+                let field_ty = self.monomorphize(field_ty, self.substs());\n+                let field = field.index();\n+\n+                use rustc::ty::layout::Layout::*;\n+                let offset = match *base_layout {\n+                    Univariant { ref variant, .. } => variant.offsets[field],\n+\n+                    General { ref variants, .. } => {\n+                        if let LvalueExtra::DowncastVariant(variant_idx) = base_extra {\n+                            // +1 for the discriminant, which is field 0\n+                            variants[variant_idx].offsets[field + 1]\n+                        } else {\n+                            bug!(\"field access on enum had no variant index\");\n+                        }\n+                    }\n+\n+                    RawNullablePointer { .. } => {\n+                        assert_eq!(field.index(), 0);\n+                        return Ok(base);\n+                    }\n+\n+                    StructWrappedNullablePointer { ref nonnull, .. } => {\n+                        nonnull.offsets[field]\n+                    }\n+\n+                    _ => bug!(\"field access on non-product type: {:?}\", base_layout),\n+                };\n+\n+                let ptr = base_ptr.offset(offset.bytes());\n+                let extra = if self.type_is_sized(field_ty) {\n+                    LvalueExtra::None\n+                } else {\n+                    match base_extra {\n+                        LvalueExtra::None => bug!(\"expected fat pointer\"),\n+                        LvalueExtra::DowncastVariant(..) =>\n+                            bug!(\"Rust doesn't support unsized fields in enum variants\"),\n+                        LvalueExtra::Vtable(_) |\n+                        LvalueExtra::Length(_) => {},\n+                    }\n+                    base_extra\n+                };\n+\n+                (ptr, extra)\n+            }\n+\n+            Downcast(_, variant) => {\n+                // FIXME(solson)\n+                let base = self.force_allocation(base)?;\n+                let (base_ptr, base_extra) = base.to_ptr_and_extra();\n+\n+                use rustc::ty::layout::Layout::*;\n+                let extra = match *base_layout {\n+                    General { .. } => LvalueExtra::DowncastVariant(variant),\n+                    RawNullablePointer { .. } | StructWrappedNullablePointer { .. } => base_extra,\n+                    _ => bug!(\"variant downcast on non-aggregate: {:?}\", base_layout),\n+                };\n+                (base_ptr, extra)\n+            }\n+\n+            Deref => {\n+                let val = self.eval_and_read_lvalue(&proj.base)?;\n+\n+                let pointee_type = match base_ty.sty {\n+                    ty::TyRawPtr(ty::TypeAndMut{ty, ..}) |\n+                    ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n+                    ty::TyBox(ty) => ty,\n+                    _ => bug!(\"can only deref pointer types\"),\n+                };\n+\n+                trace!(\"deref to {} on {:?}\", pointee_type, val);\n+\n+                match self.tcx.struct_tail(pointee_type).sty {\n+                    ty::TyDynamic(..) => {\n+                        let (ptr, vtable) = val.expect_ptr_vtable_pair(&self.memory)?;\n+                        (ptr, LvalueExtra::Vtable(vtable))\n+                    },\n+                    ty::TyStr | ty::TySlice(_) => {\n+                        let (ptr, len) = val.expect_slice(&self.memory)?;\n+                        (ptr, LvalueExtra::Length(len))\n+                    },\n+                    _ => (val.read_ptr(&self.memory)?, LvalueExtra::None),\n+                }\n+            }\n+\n+            Index(ref operand) => {\n+                // FIXME(solson)\n+                let base = self.force_allocation(base)?;\n+                let (base_ptr, _) = base.to_ptr_and_extra();\n+\n+                let (elem_ty, len) = base.elem_ty_and_len(base_ty);\n+                let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n+                let n_ptr = self.eval_operand(operand)?;\n+                let usize = self.tcx.types.usize;\n+                let n = self.value_to_primval(n_ptr, usize)?.to_u64();\n+                assert!(n < len);\n+                let ptr = base_ptr.offset(n * elem_size);\n+                (ptr, LvalueExtra::None)\n+            }\n+\n+            ConstantIndex { offset, min_length, from_end } => {\n+                // FIXME(solson)\n+                let base = self.force_allocation(base)?;\n+                let (base_ptr, _) = base.to_ptr_and_extra();\n+\n+                let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n+                let elem_size = self.type_size(elem_ty)?.expect(\"sequence element must be sized\");\n+                assert!(n >= min_length as u64);\n+\n+                let index = if from_end {\n+                    n - u64::from(offset)\n+                } else {\n+                    u64::from(offset)\n+                };\n+\n+                let ptr = base_ptr.offset(index * elem_size);\n+                (ptr, LvalueExtra::None)\n+            }\n+\n+            Subslice { from, to } => {\n+                // FIXME(solson)\n+                let base = self.force_allocation(base)?;\n+                let (base_ptr, _) = base.to_ptr_and_extra();\n+\n+                let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n+                let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n+                assert!(u64::from(from) <= n - u64::from(to));\n+                let ptr = base_ptr.offset(u64::from(from) * elem_size);\n+                let extra = LvalueExtra::Length(n - u64::from(to) - u64::from(from));\n+                (ptr, extra)\n+            }\n+        };\n+\n+        Ok(Lvalue::Ptr { ptr: ptr, extra: extra })\n+    }\n+\n+    pub(super) fn lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> Ty<'tcx> {\n+        self.monomorphize(lvalue.ty(&self.mir(), self.tcx).to_ty(self.tcx), self.substs())\n+    }\n+}"}]}