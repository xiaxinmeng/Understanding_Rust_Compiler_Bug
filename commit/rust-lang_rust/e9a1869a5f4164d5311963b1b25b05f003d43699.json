{"sha": "e9a1869a5f4164d5311963b1b25b05f003d43699", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5YTE4NjlhNWY0MTY0ZDUzMTE5NjNiMWIyNWIwNWYwMDNkNDM2OTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-26T20:13:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-26T20:13:03Z"}, "message": "auto merge of #10581 : pcwalton/rust/dedo, r=pcwalton\n\nr? @alexcrichton", "tree": {"sha": "1c47dcc76668490e9b0228e2a10c27cfebbb80cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c47dcc76668490e9b0228e2a10c27cfebbb80cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9a1869a5f4164d5311963b1b25b05f003d43699", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9a1869a5f4164d5311963b1b25b05f003d43699", "html_url": "https://github.com/rust-lang/rust/commit/e9a1869a5f4164d5311963b1b25b05f003d43699", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9a1869a5f4164d5311963b1b25b05f003d43699/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f9efae790bba41f08befc2af47ef235b03dd8a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f9efae790bba41f08befc2af47ef235b03dd8a9", "html_url": "https://github.com/rust-lang/rust/commit/9f9efae790bba41f08befc2af47ef235b03dd8a9"}, {"sha": "9521551b4710805674ad6c1755bef4e76784db02", "url": "https://api.github.com/repos/rust-lang/rust/commits/9521551b4710805674ad6c1755bef4e76784db02", "html_url": "https://github.com/rust-lang/rust/commit/9521551b4710805674ad6c1755bef4e76784db02"}], "stats": {"total": 8696, "additions": 4211, "deletions": 4485}, "files": [{"sha": "99392964e7aadde9d6d6cf6adec5ce5c98db3068", "filename": "doc/po/ja/rust.md.po", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/doc%2Fpo%2Fja%2Frust.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/doc%2Fpo%2Fja%2Frust.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Frust.md.po?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -5383,7 +5383,7 @@ msgstr \"\"\n #. type: Plain text\n #: doc/rust.md:2849\n msgid \"\"\n-\"type Binop<'self> = &'self fn(int,int) -> int; let bo: Binop = add; x = \"\n+\"type Binop<'self> = 'self |int,int| -> int; let bo: Binop = add; x = \"\n \"bo(5,7); ~~~~~~~~\"\n msgstr \"\"\n "}, {"sha": "1914526cb921f6fcccf297d64bf4f66262ef5be5", "filename": "doc/po/rust.md.pot", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/doc%2Fpo%2Frust.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/doc%2Fpo%2Frust.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Frust.md.pot?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -5370,7 +5370,7 @@ msgstr \"\"\n #. type: Plain text\n #: doc/rust.md:2849\n msgid \"\"\n-\"type Binop<'self> = &'self fn(int,int) -> int; let bo: Binop = add; x = \"\n+\"type Binop<'self> = 'self |int,int| -> int; let bo: Binop = add; x = \"\n \"bo(5,7); ~~~~~~~~\"\n msgstr \"\"\n "}, {"sha": "4fca2b33696eb0dea770a09a2da36db9c93c3d9c", "filename": "doc/rust.md", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -2703,33 +2703,27 @@ A `loop` expression is only permitted in the body of a loop.\n do_expr : \"do\" expr [ '|' ident_list '|' ] ? '{' block '}' ;\n ~~~~\n \n-A _do expression_ provides a more-familiar block-syntax for a [lambda expression](#lambda-expressions),\n-including a special translation of [return expressions](#return-expressions) inside the supplied block.\n-\n-Any occurrence of a [return expression](#return-expressions)\n-inside this `block` expression is rewritten\n-as a reference to an (anonymous) flag set in the caller's environment,\n-which is checked on return from the `expr` and, if set,\n-causes a corresponding return from the caller.\n-In this way, the meaning of `return` statements in language built-in control blocks is preserved,\n-if they are rewritten using lambda functions and `do` expressions as abstractions.\n-\n-The optional `ident_list` and `block` provided in a `do` expression are parsed as though they constitute a lambda expression;\n+A _do expression_ provides a more-familiar block syntax\n+for invoking a function and passing it a newly-created a procedure.\n+\n+The optional `ident_list` and `block` provided in a `do` expression are parsed\n+as though they constitute a procedure expression;\n if the `ident_list` is missing, an empty `ident_list` is implied.\n \n-The lambda expression is then provided as a _trailing argument_\n-to the outermost [call](#call-expressions) or [method call](#method-call-expressions) expression\n+The procedure expression is then provided as a _trailing argument_\n+to the outermost [call](#call-expressions) or\n+[method call](#method-call-expressions) expression\n in the `expr` following `do`.\n If the `expr` is a [path expression](#path-expressions), it is parsed as though it is a call expression.\n If the `expr` is a [field expression](#field-expressions), it is parsed as though it is a method call expression.\n \n In this example, both calls to `f` are equivalent:\n \n ~~~~\n-# fn f(f: |int|) { }\n+# fn f(f: proc(int)) { }\n # fn g(i: int) { }\n \n-f(|j| g(j));\n+f(proc(j) { g(j) });\n \n do f |j| {\n     g(j);\n@@ -2739,10 +2733,10 @@ do f |j| {\n In this example, both calls to the (binary) function `k` are equivalent:\n \n ~~~~\n-# fn k(x:int, f: |int|) { }\n+# fn k(x:int, f: proc(int)) { }\n # fn l(i: int) { }\n \n-k(3, |j| l(j));\n+k(3, proc(j) { l(j) });\n \n do k(3) |j| {\n    l(j);\n@@ -3194,7 +3188,7 @@ fn add(x: int, y: int) -> int {\n \n let mut x = add(5,7);\n \n-type Binop<'self> = &'self fn(int,int) -> int;\n+type Binop<'self> = 'self |int,int| -> int;\n let bo: Binop = add;\n x = bo(5,7);\n ~~~~"}, {"sha": "2fb35fce9c46a4363008546a29d8c3d71ca4e2ce", "filename": "doc/tutorial-conditions.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/doc%2Ftutorial-conditions.md", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/doc%2Ftutorial-conditions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-conditions.md?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -457,15 +457,15 @@ condition! {\n \n fn main() {\n     // Trap the condition:\n-    do malformed_line::cond.trap(|_| (-1,-1)).inside {\n+    malformed_line::cond.trap(|_| (-1,-1)).inside(|| {\n \n         // The protected logic.\n         let pairs = read_int_pairs();\n         for &(a,b) in pairs.iter() {\n                 println!(\"{:4.4d}, {:4.4d}\", a, b);\n         }\n \n-    }\n+    })\n }\n \n fn read_int_pairs() -> ~[(int,int)] {\n@@ -535,15 +535,15 @@ condition! {\n \n fn main() {\n     // Trap the condition and return `None`\n-    do malformed_line::cond.trap(|_| None).inside {\n+    malformed_line::cond.trap(|_| None).inside(|| {\n \n         // The protected logic.\n         let pairs = read_int_pairs();\n         for &(a,b) in pairs.iter() {\n             println!(\"{:4.4d}, {:4.4d}\", a, b);\n         }\n \n-    }\n+    })\n }\n \n fn read_int_pairs() -> ~[(int,int)] {\n@@ -631,15 +631,15 @@ condition! {\n \n fn main() {\n     // Trap the condition and return `UsePreviousLine`\n-    do malformed_line::cond.trap(|_| UsePreviousLine).inside {\n+    malformed_line::cond.trap(|_| UsePreviousLine).inside(|| {\n \n         // The protected logic.\n         let pairs = read_int_pairs();\n         for &(a,b) in pairs.iter() {\n             println!(\"{:4.4d}, {:4.4d}\", a, b);\n         }\n \n-    }\n+    })\n }\n \n fn read_int_pairs() -> ~[(int,int)] {\n@@ -758,19 +758,19 @@ condition! {\n \n fn main() {\n     // Trap the `malformed_int` condition and return -1\n-    do malformed_int::cond.trap(|_| -1).inside {\n+    malformed_int::cond.trap(|_| -1).inside(|| {\n \n         // Trap the `malformed_line` condition and return `UsePreviousLine`\n-        do malformed_line::cond.trap(|_| UsePreviousLine).inside {\n+        malformed_line::cond.trap(|_| UsePreviousLine).inside(|| {\n \n             // The protected logic.\n             let pairs = read_int_pairs();\n             for &(a,b) in pairs.iter() {\n                 println!(\"{:4.4d}, {:4.4d}\", a, b);\n             }\n \n-        }\n-    }\n+        })\n+    })\n }\n \n // Parse an int; if parsing fails, call the condition handler and"}, {"sha": "41cd796325c32b71d375a3f3027524d424553537", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -76,7 +76,7 @@ fn print_message() { println(\"I am running in a different task!\"); }\n spawn(print_message);\n \n // Print something more profound in a different task using a lambda expression\n-spawn( || println(\"I am also running in a different task!\") );\n+spawn(proc() println(\"I am also running in a different task!\") );\n \n // The canonical way to spawn is using `do` notation\n do spawn {\n@@ -253,13 +253,13 @@ might look like the example below.\n # use std::vec;\n \n // Create a vector of ports, one for each child task\n-let ports = do vec::from_fn(3) |init_val| {\n+let ports = vec::from_fn(3, |init_val| {\n     let (port, chan) = stream();\n     do spawn {\n         chan.send(some_expensive_computation(init_val));\n     }\n     port\n-};\n+});\n \n // Wait on each port, accumulating the results\n let result = ports.iter().fold(0, |accum, port| accum + port.recv() );\n@@ -278,7 +278,7 @@ fn fib(n: u64) -> u64 {\n     12586269025\n }\n \n-let mut delayed_fib = extra::future::Future::spawn (|| fib(50) );\n+let mut delayed_fib = extra::future::Future::spawn(proc() fib(50));\n make_a_sandwich();\n println!(\"fib(50) = {:?}\", delayed_fib.get())\n ~~~"}, {"sha": "1559033a582aaba3127a70c2e1707624c4d19fc2", "filename": "doc/tutorial.md", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -1439,19 +1439,14 @@ call_twice(function);\n \n ## Do syntax\n \n-The `do` expression provides a way to treat higher-order functions\n-(functions that take closures as arguments) as control structures.\n+The `do` expression makes it easier to call functions that take procedures\n+as arguments.\n \n-Consider this function that iterates over a vector of\n-integers, passing in a pointer to each integer in the vector:\n+Consider this function that takes a procedure:\n \n ~~~~\n-fn each(v: &[int], op: |v: &int|) {\n-   let mut n = 0;\n-   while n < v.len() {\n-       op(&v[n]);\n-       n += 1;\n-   }\n+fn call_it(op: proc(v: int)) {\n+    op(10)\n }\n ~~~~\n \n@@ -1460,26 +1455,24 @@ argument, we can write it in a way that has a pleasant, block-like\n structure.\n \n ~~~~\n-# fn each(v: &[int], op: |v: &int|) { }\n-# fn do_some_work(i: &int) { }\n-each([1, 2, 3], |n| {\n-    do_some_work(n);\n+# fn call_it(op: proc(v: int)) { }\n+call_it(proc(n) {\n+    println(n.to_str());\n });\n ~~~~\n \n This is such a useful pattern that Rust has a special form of function\n-call that can be written more like a built-in control structure:\n+call for these functions.\n \n ~~~~\n-# fn each(v: &[int], op: |v: &int|) { }\n-# fn do_some_work(i: &int) { }\n-do each([1, 2, 3]) |n| {\n-    do_some_work(n);\n+# fn call_it(op: proc(v: int)) { }\n+do call_it() |n| {\n+    println(n.to_str());\n }\n ~~~~\n \n The call is prefixed with the keyword `do` and, instead of writing the\n-final closure inside the argument list, it appears outside of the\n+final procedure inside the argument list, it appears outside of the\n parentheses, where it looks more like a typical block of\n code.\n "}, {"sha": "0f39b29c60a9e80d96b45e767a81ef3289b3c84e", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -266,12 +266,12 @@ pub fn make_tests(config: &config) -> ~[test::TestDescAndFn] {\n         let file = file.clone();\n         debug!(\"inspecting file {}\", file.display());\n         if is_test(config, &file) {\n-            let t = do make_test(config, &file) {\n+            let t = make_test(config, &file, || {\n                 match config.mode {\n                     mode_codegen => make_metrics_test_closure(config, &file),\n                     _ => make_test_closure(config, &file)\n                 }\n-            };\n+            });\n             tests.push(t)\n         }\n     }\n@@ -301,8 +301,8 @@ pub fn is_test(config: &config, testfile: &Path) -> bool {\n     return valid;\n }\n \n-pub fn make_test(config: &config, testfile: &Path,\n-                 f: &fn()->test::TestFn) -> test::TestDescAndFn {\n+pub fn make_test(config: &config, testfile: &Path, f: || -> test::TestFn)\n+                 -> test::TestDescAndFn {\n     test::TestDescAndFn {\n         desc: test::TestDesc {\n             name: make_test_name(config, testfile),\n@@ -333,13 +333,15 @@ pub fn make_test_closure(config: &config, testfile: &Path) -> test::TestFn {\n     let config = Cell::new((*config).clone());\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let testfile = Cell::new(testfile.as_str().unwrap().to_owned());\n-    test::DynTestFn(|| { runtest::run(config.take(), testfile.take()) })\n+    test::DynTestFn(proc() { runtest::run(config.take(), testfile.take()) })\n }\n \n pub fn make_metrics_test_closure(config: &config, testfile: &Path) -> test::TestFn {\n     use std::cell::Cell;\n     let config = Cell::new((*config).clone());\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let testfile = Cell::new(testfile.as_str().unwrap().to_owned());\n-    test::DynMetricFn(|mm| { runtest::run_metrics(config.take(), testfile.take(), mm) })\n+    test::DynMetricFn(proc(mm) {\n+        runtest::run_metrics(config.take(), testfile.take(), mm)\n+    })\n }"}, {"sha": "1966701dbdedda584910ab7d685458c09f122650", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -39,7 +39,7 @@ pub fn load_props(testfile: &Path) -> TestProps {\n     let mut pp_exact = None;\n     let mut debugger_cmds = ~[];\n     let mut check_lines = ~[];\n-    do iter_header(testfile) |ln| {\n+    iter_header(testfile, |ln| {\n         match parse_error_pattern(ln) {\n           Some(ep) => error_patterns.push(ep),\n           None => ()\n@@ -74,7 +74,7 @@ pub fn load_props(testfile: &Path) -> TestProps {\n         };\n \n         true\n-    };\n+    });\n     return TestProps {\n         error_patterns: error_patterns,\n         compile_flags: compile_flags,\n@@ -91,18 +91,18 @@ pub fn is_test_ignored(config: &config, testfile: &Path) -> bool {\n         ~\"xfail-\" + util::get_os(config.target)\n     }\n \n-    let val = do iter_header(testfile) |ln| {\n+    let val = iter_header(testfile, |ln| {\n         if parse_name_directive(ln, \"xfail-test\") { false }\n         else if parse_name_directive(ln, xfail_target(config)) { false }\n         else if config.mode == common::mode_pretty &&\n             parse_name_directive(ln, \"xfail-pretty\") { false }\n         else { true }\n-    };\n+    });\n \n     !val\n }\n \n-fn iter_header(testfile: &Path, it: &fn(&str) -> bool) -> bool {\n+fn iter_header(testfile: &Path, it: |&str| -> bool) -> bool {\n     use std::io::buffered::BufferedReader;\n     use std::io::File;\n \n@@ -143,7 +143,7 @@ fn parse_check_line(line: &str) -> Option<~str> {\n }\n \n fn parse_exec_env(line: &str) -> Option<(~str, ~str)> {\n-    do parse_name_value_directive(line, ~\"exec-env\").map |nv| {\n+    parse_name_value_directive(line, ~\"exec-env\").map(|nv| {\n         // nv is either FOO or FOO=BAR\n         let mut strs: ~[~str] = nv.splitn('=', 1).map(|s| s.to_owned()).collect();\n \n@@ -155,7 +155,7 @@ fn parse_exec_env(line: &str) -> Option<(~str, ~str)> {\n           }\n           n => fail!(\"Expected 1 or 2 strings, not {}\", n)\n         }\n-    }\n+    })\n }\n \n fn parse_pp_exact(line: &str, testfile: &Path) -> Option<Path> {"}, {"sha": "012d57da123cfe16acbc9fbb00fdb147bf1effe4", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -22,11 +22,11 @@ fn target_env(lib_path: &str, prog: &str) -> ~[(~str,~str)] {\n     assert!(prog.ends_with(\".exe\"));\n     let aux_path = prog.slice(0u, prog.len() - 4u).to_owned() + \".libaux\";\n \n-    env = do env.map() |pair| {\n+    env = env.map(|pair| {\n         let (k,v) = (*pair).clone();\n         if k == ~\"PATH\" { (~\"PATH\", v + \";\" + lib_path + \";\" + aux_path) }\n         else { (k,v) }\n-    };\n+    });\n     if prog.ends_with(\"rustc.exe\") {\n         env.push((~\"RUST_THREADS\", ~\"1\"));\n     }"}, {"sha": "4c7b212304cebe1cc3c72a773cca458d6e634ada", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -427,9 +427,9 @@ fn check_error_patterns(props: &TestProps,\n                         testfile: &Path,\n                         ProcRes: &ProcRes) {\n     if props.error_patterns.is_empty() {\n-        do testfile.display().with_str |s| {\n+        testfile.display().with_str(|s| {\n             fatal(~\"no error pattern specified in \" + s);\n-        }\n+        })\n     }\n \n     if ProcRes.status.success() {\n@@ -730,9 +730,12 @@ fn compose_and_run(config: &config, testfile: &Path,\n                           prog, args, procenv, input);\n }\n \n-fn make_compile_args(config: &config, props: &TestProps, extras: ~[~str],\n-                     xform: &fn(&config, (&Path)) -> Path,\n-                     testfile: &Path) -> ProcArgs {\n+fn make_compile_args(config: &config,\n+                     props: &TestProps,\n+                     extras: ~[~str],\n+                     xform: |&config, &Path| -> Path,\n+                     testfile: &Path)\n+                     -> ProcArgs {\n     let xform_file = xform(config, testfile);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let mut args = ~[testfile.as_str().unwrap().to_owned(),"}, {"sha": "b9b1e324e5a964f3657112677c45c73227d5c07d", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 97, "deletions": 99, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -224,11 +224,11 @@ impl<T:Send> MutexArc<T> {\n         let state = self.x.get();\n         // Borrowck would complain about this if the function were\n         // not already unsafe. See borrow_rwlock, far below.\n-        do (&(*state).lock).lock {\n+        (&(*state).lock).lock(|| {\n             check_poison(true, (*state).failed);\n             let _z = PoisonOnFail(&mut (*state).failed);\n             blk(&mut (*state).data)\n-        }\n+        })\n     }\n \n     /// As unsafe_access(), but with a condvar, as sync::mutex.lock_cond().\n@@ -237,14 +237,14 @@ impl<T:Send> MutexArc<T> {\n                                         blk: |x: &mut T, c: &Condvar| -> U)\n                                         -> U {\n         let state = self.x.get();\n-        do (&(*state).lock).lock_cond |cond| {\n+        (&(*state).lock).lock_cond(|cond| {\n             check_poison(true, (*state).failed);\n             let _z = PoisonOnFail(&mut (*state).failed);\n             blk(&mut (*state).data,\n                 &Condvar {is_mutex: true,\n                           failed: &mut (*state).failed,\n                           cond: cond })\n-        }\n+        })\n     }\n \n     /**\n@@ -390,11 +390,11 @@ impl<T:Freeze + Send> RWArc<T> {\n     pub fn write<U>(&self, blk: |x: &mut T| -> U) -> U {\n         unsafe {\n             let state = self.x.get();\n-            do (*borrow_rwlock(state)).write {\n+            (*borrow_rwlock(state)).write(|| {\n                 check_poison(false, (*state).failed);\n                 let _z = PoisonOnFail(&mut (*state).failed);\n                 blk(&mut (*state).data)\n-            }\n+            })\n         }\n     }\n \n@@ -405,14 +405,14 @@ impl<T:Freeze + Send> RWArc<T> {\n                          -> U {\n         unsafe {\n             let state = self.x.get();\n-            do (*borrow_rwlock(state)).write_cond |cond| {\n+            (*borrow_rwlock(state)).write_cond(|cond| {\n                 check_poison(false, (*state).failed);\n                 let _z = PoisonOnFail(&mut (*state).failed);\n                 blk(&mut (*state).data,\n                     &Condvar {is_mutex: false,\n                               failed: &mut (*state).failed,\n                               cond: cond})\n-            }\n+            })\n         }\n     }\n \n@@ -428,10 +428,10 @@ impl<T:Freeze + Send> RWArc<T> {\n     pub fn read<U>(&self, blk: |x: &T| -> U) -> U {\n         unsafe {\n             let state = self.x.get();\n-            do (*state).lock.read {\n+            (*state).lock.read(|| {\n                 check_poison(false, (*state).failed);\n                 blk(&(*state).data)\n-            }\n+            })\n         }\n     }\n \n@@ -458,14 +458,14 @@ impl<T:Freeze + Send> RWArc<T> {\n     pub fn write_downgrade<U>(&self, blk: |v: RWWriteMode<T>| -> U) -> U {\n         unsafe {\n             let state = self.x.get();\n-            do (*borrow_rwlock(state)).write_downgrade |write_mode| {\n+            (*borrow_rwlock(state)).write_downgrade(|write_mode| {\n                 check_poison(false, (*state).failed);\n                 blk(RWWriteMode {\n                     data: &mut (*state).data,\n                     token: write_mode,\n                     poison: PoisonOnFail(&mut (*state).failed)\n                 })\n-            }\n+            })\n         }\n     }\n \n@@ -544,9 +544,7 @@ impl<'self, T:Freeze + Send> RWWriteMode<'self, T> {\n                 token: ref token,\n                 poison: _\n             } => {\n-                do token.write {\n-                    blk(data)\n-                }\n+                token.write(|| blk(data))\n             }\n         }\n     }\n@@ -561,7 +559,7 @@ impl<'self, T:Freeze + Send> RWWriteMode<'self, T> {\n                 token: ref token,\n                 poison: ref poison\n             } => {\n-                do token.write_cond |cond| {\n+                token.write_cond(|cond| {\n                     unsafe {\n                         let cvar = Condvar {\n                             is_mutex: false,\n@@ -570,7 +568,7 @@ impl<'self, T:Freeze + Send> RWWriteMode<'self, T> {\n                         };\n                         blk(data, &cvar)\n                     }\n-                }\n+                })\n             }\n         }\n     }\n@@ -584,7 +582,7 @@ impl<'self, T:Freeze + Send> RWReadMode<'self, T> {\n                 data: data,\n                 token: ref token\n             } => {\n-                do token.read { blk(data) }\n+                token.read(|| blk(data))\n             }\n         }\n     }\n@@ -634,19 +632,19 @@ mod tests {\n         do task::spawn || {\n             // wait until parent gets in\n             p.take().recv();\n-            do arc2.access_cond |state, cond| {\n+            arc2.access_cond(|state, cond| {\n                 *state = true;\n                 cond.signal();\n-            }\n+            })\n         }\n \n-        do arc.access_cond |state, cond| {\n+        arc.access_cond(|state, cond| {\n             c.take().send(());\n             assert!(!*state);\n             while !*state {\n                 cond.wait();\n             }\n-        }\n+        })\n     }\n \n     #[test] #[should_fail]\n@@ -657,33 +655,33 @@ mod tests {\n \n         do spawn {\n             let _ = p.recv();\n-            do arc2.access_cond |one, cond| {\n+            arc2.access_cond(|one, cond| {\n                 cond.signal();\n                 // Parent should fail when it wakes up.\n                 assert_eq!(*one, 0);\n-            }\n+            })\n         }\n \n-        do arc.access_cond |one, cond| {\n+        arc.access_cond(|one, cond| {\n             c.send(());\n             while *one == 1 {\n                 cond.wait();\n             }\n-        }\n+        })\n     }\n \n     #[test] #[should_fail]\n     fn test_mutex_arc_poison() {\n         let arc = ~MutexArc::new(1);\n         let arc2 = ~arc.clone();\n         do task::try || {\n-            do arc2.access |one| {\n+            arc2.access(|one| {\n                 assert_eq!(*one, 2);\n-            }\n+            })\n         };\n-        do arc.access |one| {\n+        arc.access(|one| {\n             assert_eq!(*one, 1);\n-        }\n+        })\n     }\n \n     #[test] #[should_fail]\n@@ -692,10 +690,10 @@ mod tests {\n         let arc2 = ~(&arc).clone();\n         let (p, c) = comm::stream();\n         do task::spawn {\n-            do arc2.access |one| {\n+            arc2.access(|one| {\n                 c.send(());\n                 assert!(*one == 2);\n-            }\n+            })\n         }\n         let _ = p.recv();\n         let one = arc.unwrap();\n@@ -710,11 +708,11 @@ mod tests {\n             let arc = ~MutexArc::new(1);\n             let arc2 = ~MutexArc::new(*arc);\n             do task::spawn || {\n-                do (*arc2).unsafe_access |mutex| {\n-                    do (*mutex).access |one| {\n+                (*arc2).unsafe_access(|mutex| {\n+                    (*mutex).access(|one| {\n                         assert!(*one == 1);\n-                    }\n-                }\n+                    })\n+                })\n             };\n         }\n     }\n@@ -724,84 +722,84 @@ mod tests {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n         do task::try {\n-            do arc2.write |one| {\n+            arc2.write(|one| {\n                 assert_eq!(*one, 2);\n-            }\n+            })\n         };\n-        do arc.read |one| {\n+        arc.read(|one| {\n             assert_eq!(*one, 1);\n-        }\n+        })\n     }\n \n     #[test] #[should_fail]\n     fn test_rw_arc_poison_ww() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n         do task::try {\n-            do arc2.write |one| {\n+            arc2.write(|one| {\n                 assert_eq!(*one, 2);\n-            }\n+            })\n         };\n-        do arc.write |one| {\n+        arc.write(|one| {\n             assert_eq!(*one, 1);\n-        }\n+        })\n     }\n     #[test] #[should_fail]\n     fn test_rw_arc_poison_dw() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n         do task::try {\n-            do arc2.write_downgrade |mut write_mode| {\n-                do write_mode.write |one| {\n+            arc2.write_downgrade(|mut write_mode| {\n+                write_mode.write(|one| {\n                     assert_eq!(*one, 2);\n-                }\n-            }\n+                })\n+            })\n         };\n-        do arc.write |one| {\n+        arc.write(|one| {\n             assert_eq!(*one, 1);\n-        }\n+        })\n     }\n     #[test]\n     fn test_rw_arc_no_poison_rr() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n         do task::try {\n-            do arc2.read |one| {\n+            arc2.read(|one| {\n                 assert_eq!(*one, 2);\n-            }\n+            })\n         };\n-        do arc.read |one| {\n+        arc.read(|one| {\n             assert_eq!(*one, 1);\n-        }\n+        })\n     }\n     #[test]\n     fn test_rw_arc_no_poison_rw() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n         do task::try {\n-            do arc2.read |one| {\n+            arc2.read(|one| {\n                 assert_eq!(*one, 2);\n-            }\n+            })\n         };\n-        do arc.write |one| {\n+        arc.write(|one| {\n             assert_eq!(*one, 1);\n-        }\n+        })\n     }\n     #[test]\n     fn test_rw_arc_no_poison_dr() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n         do task::try {\n-            do arc2.write_downgrade |write_mode| {\n+            arc2.write_downgrade(|write_mode| {\n                 let read_mode = arc2.downgrade(write_mode);\n-                do read_mode.read |one| {\n+                read_mode.read(|one| {\n                     assert_eq!(*one, 2);\n-                }\n-            }\n+                })\n+            })\n         };\n-        do arc.write |one| {\n+        arc.write(|one| {\n             assert_eq!(*one, 1);\n-        }\n+        })\n     }\n     #[test]\n     fn test_rw_arc() {\n@@ -810,29 +808,29 @@ mod tests {\n         let (p, c) = comm::stream();\n \n         do task::spawn {\n-            do arc2.write |num| {\n-                do 10.times {\n+            arc2.write(|num| {\n+                10.times(|| {\n                     let tmp = *num;\n                     *num = -1;\n                     task::deschedule();\n                     *num = tmp + 1;\n-                }\n+                });\n                 c.send(());\n-            }\n+            })\n         }\n \n         // Readers try to catch the writer in the act\n         let mut children = ~[];\n-        do 5.times {\n+        5.times(|| {\n             let arc3 = arc.clone();\n             let mut builder = task::task();\n             children.push(builder.future_result());\n             do builder.spawn {\n-                do arc3.read |num| {\n+                arc3.read(|num| {\n                     assert!(*num >= 0);\n-                }\n+                })\n             }\n-        }\n+        });\n \n         // Wait for children to pass their asserts\n         for r in children.iter() {\n@@ -841,9 +839,9 @@ mod tests {\n \n         // Wait for writer to finish\n         p.recv();\n-        do arc.read |num| {\n+        arc.read(|num| {\n             assert_eq!(*num, 10);\n-        }\n+        })\n     }\n     #[test]\n     fn test_rw_downgrade() {\n@@ -857,42 +855,42 @@ mod tests {\n \n         // Reader tasks\n         let mut reader_convos = ~[];\n-        do 10.times {\n+        10.times(|| {\n             let ((rp1, rc1), (rp2, rc2)) = (comm::stream(), comm::stream());\n             reader_convos.push((rc1, rp2));\n             let arcn = arc.clone();\n             do task::spawn {\n                 rp1.recv(); // wait for downgrader to give go-ahead\n-                do arcn.read |state| {\n+                arcn.read(|state| {\n                     assert_eq!(*state, 31337);\n                     rc2.send(());\n-                }\n+                })\n             }\n-        }\n+        });\n \n         // Writer task\n         let arc2 = arc.clone();\n         let ((wp1, wc1), (wp2, wc2)) = (comm::stream(), comm::stream());\n         do task::spawn || {\n             wp1.recv();\n-            do arc2.write_cond |state, cond| {\n+            arc2.write_cond(|state, cond| {\n                 assert_eq!(*state, 0);\n                 *state = 42;\n                 cond.signal();\n-            }\n+            });\n             wp1.recv();\n-            do arc2.write |state| {\n+            arc2.write(|state| {\n                 // This shouldn't happen until after the downgrade read\n                 // section, and all other readers, finish.\n                 assert_eq!(*state, 31337);\n                 *state = 42;\n-            }\n+            });\n             wc2.send(());\n         }\n \n         // Downgrader (us)\n-        do arc.write_downgrade |mut write_mode| {\n-            do write_mode.write_cond |state, cond| {\n+        arc.write_downgrade(|mut write_mode| {\n+            write_mode.write_cond(|state, cond| {\n                 wc1.send(()); // send to another writer who will wake us up\n                 while *state == 0 {\n                     cond.wait();\n@@ -903,17 +901,17 @@ mod tests {\n                 for &(ref rc, _) in reader_convos.iter() {\n                     rc.send(())\n                 }\n-            }\n+            });\n             let read_mode = arc.downgrade(write_mode);\n-            do read_mode.read |state| {\n+            read_mode.read(|state| {\n                 // complete handshake with other readers\n                 for &(_, ref rp) in reader_convos.iter() {\n                     rp.recv()\n                 }\n                 wc1.send(()); // tell writer to try again\n                 assert_eq!(*state, 31337);\n-            }\n-        }\n+            });\n+        });\n \n         wp2.recv(); // complete handshake with writer\n     }\n@@ -934,49 +932,49 @@ mod tests {\n         // writer task\n         let xw = x.clone();\n         do task::spawn {\n-            do xw.write_cond |state, c| {\n+            xw.write_cond(|state, c| {\n                 wc.send(()); // tell downgrader it's ok to go\n                 c.wait();\n                 // The core of the test is here: the condvar reacquire path\n                 // must involve order_lock, so that it cannot race with a reader\n                 // trying to receive the \"reader cloud lock hand-off\".\n                 *state = false;\n-            }\n+            })\n         }\n \n         wp.recv(); // wait for writer to get in\n \n-        do x.write_downgrade |mut write_mode| {\n-            do write_mode.write_cond |state, c| {\n+        x.write_downgrade(|mut write_mode| {\n+            write_mode.write_cond(|state, c| {\n                 assert!(*state);\n                 // make writer contend in the cond-reacquire path\n                 c.signal();\n-            }\n+            });\n             // make a reader task to trigger the \"reader cloud lock\" handoff\n             let xr = x.clone();\n             let (rp, rc) = comm::stream();\n             do task::spawn {\n                 rc.send(());\n-                do xr.read |_state| { }\n+                xr.read(|_state| { })\n             }\n             rp.recv(); // wait for reader task to exist\n \n             let read_mode = x.downgrade(write_mode);\n-            do read_mode.read |state| {\n+            read_mode.read(|state| {\n                 // if writer mistakenly got in, make sure it mutates state\n                 // before we assert on it\n-                do 5.times { task::deschedule(); }\n+                5.times(|| task::deschedule());\n                 // make sure writer didn't get in.\n                 assert!(*state);\n-            }\n-        }\n+            })\n+        });\n     }\n     #[test]\n     fn test_rw_write_cond_downgrade_read_race() {\n         // Ideally the above test case would have deschedule statements in it that\n         // helped to expose the race nearly 100% of the time... but adding\n         // deschedules in the intuitively-right locations made it even less likely,\n         // and I wasn't sure why :( . This is a mediocre \"next best\" option.\n-        do 8.times { test_rw_write_cond_downgrade_read_race_helper() }\n+        8.times(|| test_rw_write_cond_downgrade_read_race_helper());\n     }\n }"}, {"sha": "8aa89f86642a5fbe92489c44d0933300945d97ff", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -96,12 +96,12 @@ impl Drop for Arena {\n     fn drop(&mut self) {\n         unsafe {\n             destroy_chunk(&self.head);\n-            do self.chunks.each |chunk| {\n+            self.chunks.each(|chunk| {\n                 if !chunk.is_pod {\n                     destroy_chunk(chunk);\n                 }\n                 true\n-            };\n+            });\n         }\n     }\n }\n@@ -282,10 +282,10 @@ fn test_arena_destructors() {\n     for i in range(0u, 10) {\n         // Arena allocate something with drop glue to make sure it\n         // doesn't leak.\n-        do arena.alloc { @i };\n+        arena.alloc(|| @i);\n         // Allocate something with funny size and alignment, to keep\n         // things interesting.\n-        do arena.alloc { [0u8, 1u8, 2u8] };\n+        arena.alloc(|| [0u8, 1u8, 2u8]);\n     }\n }\n \n@@ -297,14 +297,14 @@ fn test_arena_destructors_fail() {\n     for i in range(0u, 10) {\n         // Arena allocate something with drop glue to make sure it\n         // doesn't leak.\n-        do arena.alloc { @i };\n+        arena.alloc(|| { @i });\n         // Allocate something with funny size and alignment, to keep\n         // things interesting.\n-        do arena.alloc { [0u8, 1u8, 2u8] };\n+        arena.alloc(|| { [0u8, 1u8, 2u8] });\n     }\n     // Now, fail while allocating\n-    do arena.alloc::<@int> {\n+    arena.alloc::<@int>(|| {\n         // Now fail.\n         fail!();\n-    };\n+    });\n }"}, {"sha": "94e3917a7ecdf76055011e7e3008a84ac33e83de", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -317,20 +317,20 @@ mod test {\n         use std::rand::{task_rng, random, Rng};\n         use std::vec;\n \n-        do 1000.times {\n+        1000.times(|| {\n             let times = task_rng().gen_range(1u, 100);\n             let v = vec::from_fn(times, |_| random::<u8>());\n             assert_eq!(v.to_base64(STANDARD).from_base64().unwrap(), v);\n-        }\n+        })\n     }\n \n     #[bench]\n     pub fn bench_to_base64(bh: & mut BenchHarness) {\n         let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n                  \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n-        do bh.iter {\n+        bh.iter(|| {\n             s.as_bytes().to_base64(STANDARD);\n-        }\n+        });\n         bh.bytes = s.len() as u64;\n     }\n \n@@ -339,9 +339,9 @@ mod test {\n         let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n                  \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n         let b = s.as_bytes().to_base64(STANDARD);\n-        do bh.iter {\n+        bh.iter(|| {\n             b.from_base64();\n-        }\n+        });\n         bh.bytes = b.len() as u64;\n     }\n "}, {"sha": "09137d6bb74519fbd92fe786c40da7d1868f9d69", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 58, "deletions": 52, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -166,7 +166,9 @@ impl BigBitv {\n     }\n \n     #[inline]\n-    pub fn negate(&mut self) { do self.each_storage |w| { *w = !*w; true }; }\n+    pub fn negate(&mut self) {\n+        self.each_storage(|w| { *w = !*w; true });\n+    }\n \n     #[inline]\n     pub fn union(&mut self, b: &BigBitv, nbits: uint) -> bool {\n@@ -358,26 +360,32 @@ impl Bitv {\n     #[inline]\n     pub fn clear(&mut self) {\n         match self.rep {\n-          Small(ref mut b) => b.clear(),\n-          Big(ref mut s) => { do s.each_storage() |w| { *w = 0u; true }; }\n+            Small(ref mut b) => b.clear(),\n+            Big(ref mut s) => {\n+                s.each_storage(|w| { *w = 0u; true });\n+            }\n         }\n     }\n \n     /// Set all bits to 1\n     #[inline]\n     pub fn set_all(&mut self) {\n-      match self.rep {\n-        Small(ref mut b) => b.set_all(),\n-        Big(ref mut s) => { do s.each_storage() |w| { *w = !0u; true }; }\n-      }\n+        match self.rep {\n+            Small(ref mut b) => b.set_all(),\n+            Big(ref mut s) => {\n+                s.each_storage(|w| { *w = !0u; true });\n+            }\n+        }\n     }\n \n     /// Invert all bits\n     #[inline]\n     pub fn negate(&mut self) {\n-      match self.rep {\n-        Small(ref mut b) => b.negate(),\n-        Big(ref mut s) => { do s.each_storage() |w| { *w = !*w; true }; }\n+        match self.rep {\n+            Small(ref mut b) => b.negate(),\n+            Big(ref mut s) => {\n+                s.each_storage(|w| { *w = !*w; true });\n+            }\n       }\n     }\n \n@@ -651,10 +659,10 @@ impl BitvSet {\n     /// Creates a new bit vector set from the given bit vector\n     pub fn from_bitv(bitv: Bitv) -> BitvSet {\n         let mut size = 0;\n-        do bitv.ones |_| {\n+        bitv.ones(|_| {\n             size += 1;\n             true\n-        };\n+        });\n         let Bitv{rep, _} = bitv;\n         match rep {\n             Big(b) => BitvSet{ size: size, bitv: b },\n@@ -786,7 +794,7 @@ impl Container for BitvSet {\n \n impl Mutable for BitvSet {\n     fn clear(&mut self) {\n-        do self.bitv.each_storage |w| { *w = 0; true };\n+        self.bitv.each_storage(|w| { *w = 0; true });\n         self.size = 0;\n     }\n }\n@@ -797,9 +805,7 @@ impl Set<uint> for BitvSet {\n     }\n \n     fn is_disjoint(&self, other: &BitvSet) -> bool {\n-        do self.intersection(other) |_| {\n-            false\n-        }\n+        self.intersection(other, |_| false)\n     }\n \n     fn is_subset(&self, other: &BitvSet) -> bool {\n@@ -1356,18 +1362,18 @@ mod tests {\n     fn test_small_clear() {\n         let mut b = Bitv::new(14, true);\n         b.clear();\n-        do b.ones |i| {\n+        b.ones(|i| {\n             fail!(\"found 1 at {:?}\", i)\n-        };\n+        });\n     }\n \n     #[test]\n     fn test_big_clear() {\n         let mut b = Bitv::new(140, true);\n         b.clear();\n-        do b.ones |i| {\n+        b.ones(|i| {\n             fail!(\"found 1 at {:?}\", i)\n-        };\n+        });\n     }\n \n     #[test]\n@@ -1402,11 +1408,11 @@ mod tests {\n \n         let mut i = 0;\n         let expected = [3, 5, 11, 77];\n-        do a.intersection(&b) |x| {\n+        a.intersection(&b, |x| {\n             assert_eq!(*x, expected[i]);\n             i += 1;\n             true\n-        };\n+        });\n         assert_eq!(i, expected.len());\n     }\n \n@@ -1426,11 +1432,11 @@ mod tests {\n \n         let mut i = 0;\n         let expected = [1, 5, 500];\n-        do a.difference(&b) |x| {\n+        a.difference(&b, |x| {\n             assert_eq!(*x, expected[i]);\n             i += 1;\n             true\n-        };\n+        });\n         assert_eq!(i, expected.len());\n     }\n \n@@ -1452,11 +1458,11 @@ mod tests {\n \n         let mut i = 0;\n         let expected = [1, 5, 11, 14, 220];\n-        do a.symmetric_difference(&b) |x| {\n+        a.symmetric_difference(&b, |x| {\n             assert_eq!(*x, expected[i]);\n             i += 1;\n             true\n-        };\n+        });\n         assert_eq!(i, expected.len());\n     }\n \n@@ -1481,11 +1487,11 @@ mod tests {\n \n         let mut i = 0;\n         let expected = [1, 3, 5, 9, 11, 13, 19, 24, 160];\n-        do a.union(&b) |x| {\n+        a.union(&b, |x| {\n             assert_eq!(*x, expected[i]);\n             i += 1;\n             true\n-        };\n+        });\n         assert_eq!(i, expected.len());\n     }\n \n@@ -1532,27 +1538,27 @@ mod tests {\n     fn bench_uint_small(b: &mut BenchHarness) {\n         let mut r = rng();\n         let mut bitv = 0 as uint;\n-        do b.iter {\n+        b.iter(|| {\n             bitv |= (1 << ((r.next_u32() as uint) % uint::bits));\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_small_bitv_small(b: &mut BenchHarness) {\n         let mut r = rng();\n         let mut bitv = SmallBitv::new(uint::bits);\n-        do b.iter {\n+        b.iter(|| {\n             bitv.set((r.next_u32() as uint) % uint::bits, true);\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_big_bitv_small(b: &mut BenchHarness) {\n         let mut r = rng();\n         let mut bitv = BigBitv::new(~[0]);\n-        do b.iter {\n+        b.iter(|| {\n             bitv.set((r.next_u32() as uint) % uint::bits, true);\n-        }\n+        })\n     }\n \n     #[bench]\n@@ -1561,87 +1567,87 @@ mod tests {\n         let mut storage = ~[];\n         storage.grow(BENCH_BITS / uint::bits, &0u);\n         let mut bitv = BigBitv::new(storage);\n-        do b.iter {\n+        b.iter(|| {\n             bitv.set((r.next_u32() as uint) % BENCH_BITS, true);\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_bitv_big(b: &mut BenchHarness) {\n         let mut r = rng();\n         let mut bitv = Bitv::new(BENCH_BITS, false);\n-        do b.iter {\n+        b.iter(|| {\n             bitv.set((r.next_u32() as uint) % BENCH_BITS, true);\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_bitv_small(b: &mut BenchHarness) {\n         let mut r = rng();\n         let mut bitv = Bitv::new(uint::bits, false);\n-        do b.iter {\n+        b.iter(|| {\n             bitv.set((r.next_u32() as uint) % uint::bits, true);\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_bitv_set_small(b: &mut BenchHarness) {\n         let mut r = rng();\n         let mut bitv = BitvSet::new();\n-        do b.iter {\n+        b.iter(|| {\n             bitv.insert((r.next_u32() as uint) % uint::bits);\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_bitv_set_big(b: &mut BenchHarness) {\n         let mut r = rng();\n         let mut bitv = BitvSet::new();\n-        do b.iter {\n+        b.iter(|| {\n             bitv.insert((r.next_u32() as uint) % BENCH_BITS);\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_bitv_big_union(b: &mut BenchHarness) {\n         let mut b1 = Bitv::new(BENCH_BITS, false);\n         let b2 = Bitv::new(BENCH_BITS, false);\n-        do b.iter {\n+        b.iter(|| {\n             b1.union(&b2);\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_btv_small_iter(b: &mut BenchHarness) {\n         let bitv = Bitv::new(uint::bits, false);\n-        do b.iter {\n+        b.iter(|| {\n             let mut _sum = 0;\n             for pres in bitv.iter() {\n                 _sum += pres as uint;\n             }\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_bitv_big_iter(b: &mut BenchHarness) {\n         let bitv = Bitv::new(BENCH_BITS, false);\n-        do b.iter {\n+        b.iter(|| {\n             let mut _sum = 0;\n             for pres in bitv.iter() {\n                 _sum += pres as uint;\n             }\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_bitvset_iter(b: &mut BenchHarness) {\n         let bitv = BitvSet::from_bitv(from_fn(BENCH_BITS,\n                                               |idx| {idx % 3 == 0}));\n-        do b.iter {\n+        b.iter(|| {\n             let mut _sum = 0;\n             for idx in bitv.iter() {\n                 _sum += idx;\n             }\n-        }\n+        })\n     }\n }"}, {"sha": "42287736ffa5f2a46ad172dd96fa34c62967a6f3", "filename": "src/libextra/comm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcomm.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -114,10 +114,10 @@ impl<T: Send> GenericPort<T> for SyncPort<T> {\n     }\n \n     fn try_recv(&self) -> Option<T> {\n-        do self.duplex_stream.try_recv().map |val| {\n+        self.duplex_stream.try_recv().map(|val| {\n             self.duplex_stream.try_send(());\n             val\n-        }\n+        })\n     }\n }\n \n@@ -167,9 +167,9 @@ mod test {\n         do run_in_uv_task {\n             let (port, chan) = rendezvous();\n             do spawn {\n-                do 1000000.times { chan.send(()) }\n+                1000000.times(|| { chan.send(()) })\n             }\n-            do 1000000.times { port.recv() }\n+            1000000.times(|| { port.recv() })\n         }\n     }\n "}, {"sha": "0ba00510ed8b575ef431fd8e2c7f6818e14ea4e7", "filename": "src/libextra/container.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcontainer.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -58,11 +58,11 @@ pub mod bench {\n         }\n \n         // measure\n-        do bh.iter {\n+        bh.iter(|| {\n             let k = rng.gen::<uint>() % n;\n             map.insert(k, 1);\n             map.remove(&k);\n-        }\n+        })\n     }\n \n     pub fn insert_seq_n<M:MutableMap<uint,uint>>(n: uint,\n@@ -76,11 +76,11 @@ pub mod bench {\n \n         // measure\n         let mut i = 1;\n-        do bh.iter {\n+        bh.iter(|| {\n             map.insert(i, 1);\n             map.remove(&i);\n             i = (i + 2) % n;\n-        }\n+        })\n     }\n \n     pub fn find_rand_n<M:MutableMap<uint,uint>>(n: uint,\n@@ -98,10 +98,10 @@ pub mod bench {\n \n         // measure\n         let mut i = 0;\n-        do bh.iter {\n+        bh.iter(|| {\n             map.find(&(keys[i]));\n             i = (i + 1) % n;\n-        }\n+        })\n     }\n \n     pub fn find_seq_n<M:MutableMap<uint,uint>>(n: uint,\n@@ -114,9 +114,9 @@ pub mod bench {\n \n         // measure\n         let mut i = 0;\n-        do bh.iter {\n+        bh.iter(|| {\n             map.find(&i);\n             i = (i + 1) % n;\n-        }\n+        })\n      }\n }"}, {"sha": "22109c98dc863518144aaed1d99a0d9e79f9d5df", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -165,14 +165,14 @@ impl<T> DList<T> {\n     /// Remove the first Node and return it, or None if the list is empty\n     #[inline]\n     fn pop_front_node(&mut self) -> Option<~Node<T>> {\n-        do self.list_head.take().map |mut front_node| {\n+        self.list_head.take().map(|mut front_node| {\n             self.length -= 1;\n             match front_node.next.take() {\n                 Some(node) => self.list_head = link_with_prev(node, Rawlink::none()),\n                 None => self.list_tail = Rawlink::none()\n             }\n             front_node\n-        }\n+        })\n     }\n \n     /// Add a Node last in the list\n@@ -191,14 +191,14 @@ impl<T> DList<T> {\n     /// Remove the last Node and return it, or None if the list is empty\n     #[inline]\n     fn pop_back_node(&mut self) -> Option<~Node<T>> {\n-        do self.list_tail.resolve().map_default(None) |tail| {\n+        self.list_tail.resolve().map_default(None, |tail| {\n             self.length -= 1;\n             self.list_tail = tail.prev;\n             match tail.prev.resolve() {\n                 None => self.list_head.take(),\n                 Some(tail_prev) => tail_prev.next.take()\n             }\n-        }\n+        })\n     }\n }\n \n@@ -270,19 +270,19 @@ impl<T> DList<T> {\n     /// If the list is empty, do nothing.\n     #[inline]\n     pub fn rotate_forward(&mut self) {\n-        do self.pop_back_node().map |tail| {\n+        self.pop_back_node().map(|tail| {\n             self.push_front_node(tail)\n-        };\n+        });\n     }\n \n     /// Move the first element to the back of the list.\n     ///\n     /// If the list is empty, do nothing.\n     #[inline]\n     pub fn rotate_backward(&mut self) {\n-        do self.pop_front_node().map |head| {\n+        self.pop_front_node().map(|head| {\n             self.push_back_node(head)\n-        };\n+        });\n     }\n \n     /// Add all elements from `other` to the end of the list\n@@ -444,11 +444,11 @@ impl<'self, A> Iterator<&'self A> for DListIterator<'self, A> {\n         if self.nelem == 0 {\n             return None;\n         }\n-        do self.head.as_ref().map |head| {\n+        self.head.as_ref().map(|head| {\n             self.nelem -= 1;\n             self.head = &head.next;\n             &head.value\n-        }\n+        })\n     }\n \n     #[inline]\n@@ -464,11 +464,11 @@ impl<'self, A> DoubleEndedIterator<&'self A> for DListIterator<'self, A> {\n             return None;\n         }\n         let tmp = self.tail.resolve_immut(); // FIXME: #3511: shouldn't need variable\n-        do tmp.as_ref().map |prev| {\n+        tmp.as_ref().map(|prev| {\n             self.nelem -= 1;\n             self.tail = prev.prev;\n             &prev.value\n-        }\n+        })\n     }\n }\n \n@@ -480,14 +480,14 @@ impl<'self, A> Iterator<&'self mut A> for MutDListIterator<'self, A> {\n         if self.nelem == 0 {\n             return None;\n         }\n-        do self.head.resolve().map |next| {\n+        self.head.resolve().map(|next| {\n             self.nelem -= 1;\n             self.head = match next.next {\n                 Some(ref mut node) => Rawlink::some(&mut **node),\n                 None => Rawlink::none(),\n             };\n             &mut next.value\n-        }\n+        })\n     }\n \n     #[inline]\n@@ -502,11 +502,11 @@ impl<'self, A> DoubleEndedIterator<&'self mut A> for MutDListIterator<'self, A>\n         if self.nelem == 0 {\n             return None;\n         }\n-        do self.tail.resolve().map |prev| {\n+        self.tail.resolve().map(|prev| {\n             self.nelem -= 1;\n             self.tail = prev.prev;\n             &mut prev.value\n-        }\n+        })\n     }\n }\n \n@@ -1031,11 +1031,11 @@ mod tests {\n \n     #[test]\n     fn test_fuzz() {\n-        do 25.times {\n+        25.times(|| {\n             fuzz_test(3);\n             fuzz_test(16);\n             fuzz_test(189);\n-        }\n+        })\n     }\n \n     #[cfg(test)]\n@@ -1078,95 +1078,95 @@ mod tests {\n     #[bench]\n     fn bench_collect_into(b: &mut test::BenchHarness) {\n         let v = &[0, ..64];\n-        do b.iter {\n+        b.iter(|| {\n             let _: DList<int> = v.iter().map(|x| *x).collect();\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_push_front(b: &mut test::BenchHarness) {\n         let mut m: DList<int> = DList::new();\n-        do b.iter {\n+        b.iter(|| {\n             m.push_front(0);\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_push_back(b: &mut test::BenchHarness) {\n         let mut m: DList<int> = DList::new();\n-        do b.iter {\n+        b.iter(|| {\n             m.push_back(0);\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_push_back_pop_back(b: &mut test::BenchHarness) {\n         let mut m: DList<int> = DList::new();\n-        do b.iter {\n+        b.iter(|| {\n             m.push_back(0);\n             m.pop_back();\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_push_front_pop_front(b: &mut test::BenchHarness) {\n         let mut m: DList<int> = DList::new();\n-        do b.iter {\n+        b.iter(|| {\n             m.push_front(0);\n             m.pop_front();\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_rotate_forward(b: &mut test::BenchHarness) {\n         let mut m: DList<int> = DList::new();\n         m.push_front(0);\n         m.push_front(1);\n-        do b.iter {\n+        b.iter(|| {\n             m.rotate_forward();\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_rotate_backward(b: &mut test::BenchHarness) {\n         let mut m: DList<int> = DList::new();\n         m.push_front(0);\n         m.push_front(1);\n-        do b.iter {\n+        b.iter(|| {\n             m.rotate_backward();\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_iter(b: &mut test::BenchHarness) {\n         let v = &[0, ..128];\n         let m: DList<int> = v.iter().map(|&x|x).collect();\n-        do b.iter {\n+        b.iter(|| {\n             assert!(m.iter().len() == 128);\n-        }\n+        })\n     }\n     #[bench]\n     fn bench_iter_mut(b: &mut test::BenchHarness) {\n         let v = &[0, ..128];\n         let mut m: DList<int> = v.iter().map(|&x|x).collect();\n-        do b.iter {\n+        b.iter(|| {\n             assert!(m.mut_iter().len() == 128);\n-        }\n+        })\n     }\n     #[bench]\n     fn bench_iter_rev(b: &mut test::BenchHarness) {\n         let v = &[0, ..128];\n         let m: DList<int> = v.iter().map(|&x|x).collect();\n-        do b.iter {\n+        b.iter(|| {\n             assert!(m.rev_iter().len() == 128);\n-        }\n+        })\n     }\n     #[bench]\n     fn bench_iter_mut_rev(b: &mut test::BenchHarness) {\n         let v = &[0, ..128];\n         let mut m: DList<int> = v.iter().map(|&x|x).collect();\n-        do b.iter {\n+        b.iter(|| {\n             assert!(m.mut_rev_iter().len() == 128);\n-        }\n+        })\n     }\n }"}, {"sha": "19959dd2705fc939f2fad26c04d96affedf5010c", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -546,24 +546,24 @@ pub mod reader {\n \n         fn read_option<T>(&mut self, f: |&mut Decoder, bool| -> T) -> T {\n             debug!(\"read_option()\");\n-            do self.read_enum(\"Option\") |this| {\n-                do this.read_enum_variant([\"None\", \"Some\"]) |this, idx| {\n+            self.read_enum(\"Option\", |this| {\n+                this.read_enum_variant([\"None\", \"Some\"], |this, idx| {\n                     match idx {\n                         0 => f(this, false),\n                         1 => f(this, true),\n                         _ => fail!(),\n                     }\n-                }\n-            }\n+                })\n+            })\n         }\n \n         fn read_seq<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n             debug!(\"read_seq()\");\n-            do self.push_doc(EsVec) |d| {\n+            self.push_doc(EsVec, |d| {\n                 let len = d._next_uint(EsVecLen);\n                 debug!(\"  len={}\", len);\n                 f(d, len)\n-            }\n+            })\n         }\n \n         fn read_seq_elt<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n@@ -574,11 +574,11 @@ pub mod reader {\n \n         fn read_map<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n             debug!(\"read_map()\");\n-            do self.push_doc(EsMap) |d| {\n+            self.push_doc(EsMap, |d| {\n                 let len = d._next_uint(EsMapLen);\n                 debug!(\"  len={}\", len);\n                 f(d, len)\n-            }\n+            })\n         }\n \n         fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n@@ -687,43 +687,43 @@ pub mod writer {\n         }\n \n         pub fn wr_tagged_u64(&mut self, tag_id: uint, v: u64) {\n-            do u64_to_be_bytes(v, 8u) |v| {\n+            u64_to_be_bytes(v, 8u, |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n-            }\n+            })\n         }\n \n         pub fn wr_tagged_u32(&mut self, tag_id: uint, v: u32) {\n-            do u64_to_be_bytes(v as u64, 4u) |v| {\n+            u64_to_be_bytes(v as u64, 4u, |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n-            }\n+            })\n         }\n \n         pub fn wr_tagged_u16(&mut self, tag_id: uint, v: u16) {\n-            do u64_to_be_bytes(v as u64, 2u) |v| {\n+            u64_to_be_bytes(v as u64, 2u, |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n-            }\n+            })\n         }\n \n         pub fn wr_tagged_u8(&mut self, tag_id: uint, v: u8) {\n             self.wr_tagged_bytes(tag_id, &[v]);\n         }\n \n         pub fn wr_tagged_i64(&mut self, tag_id: uint, v: i64) {\n-            do u64_to_be_bytes(v as u64, 8u) |v| {\n+            u64_to_be_bytes(v as u64, 8u, |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n-            }\n+            })\n         }\n \n         pub fn wr_tagged_i32(&mut self, tag_id: uint, v: i32) {\n-            do u64_to_be_bytes(v as u64, 4u) |v| {\n+            u64_to_be_bytes(v as u64, 4u, |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n-            }\n+            })\n         }\n \n         pub fn wr_tagged_i16(&mut self, tag_id: uint, v: i16) {\n-            do u64_to_be_bytes(v as u64, 2u) |v| {\n+            u64_to_be_bytes(v as u64, 2u, |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n-            }\n+            })\n         }\n \n         pub fn wr_tagged_i8(&mut self, tag_id: uint, v: i8) {"}, {"sha": "3d1d0c91e317d1c57b52d4f4cc09bea35f5ba098", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -47,7 +47,7 @@ static TINFL_FLAG_PARSE_ZLIB_HEADER : c_int = 0x1; // parse zlib header and adle\n static TDEFL_WRITE_ZLIB_HEADER : c_int = 0x01000; // write zlib header and adler32 checksum\n \n fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> ~[u8] {\n-    do bytes.as_imm_buf |b, len| {\n+    bytes.as_imm_buf(|b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;\n             let res =\n@@ -61,7 +61,7 @@ fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> ~[u8] {\n             libc::free(res);\n             out\n         }\n-    }\n+    })\n }\n \n pub fn deflate_bytes(bytes: &[u8]) -> ~[u8] {\n@@ -73,7 +73,7 @@ pub fn deflate_bytes_zlib(bytes: &[u8]) -> ~[u8] {\n }\n \n fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> ~[u8] {\n-    do bytes.as_imm_buf |b, len| {\n+    bytes.as_imm_buf(|b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;\n             let res =\n@@ -87,7 +87,7 @@ fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> ~[u8] {\n             libc::free(res);\n             out\n         }\n-    }\n+    })\n }\n \n pub fn inflate_bytes(bytes: &[u8]) -> ~[u8] {\n@@ -108,15 +108,15 @@ mod tests {\n     fn test_flate_round_trip() {\n         let mut r = rand::rng();\n         let mut words = ~[];\n-        do 20.times {\n+        20.times(|| {\n             let range = r.gen_range(1u, 10);\n             words.push(r.gen_vec::<u8>(range));\n-        }\n-        do 20.times {\n+        });\n+        20.times(|| {\n             let mut input = ~[];\n-            do 2000.times {\n+            2000.times(|| {\n                 input.push_all(r.choose(words));\n-            }\n+            });\n             debug!(\"de/inflate of {} bytes of random word-sequences\",\n                    input.len());\n             let cmp = deflate_bytes(input);\n@@ -125,7 +125,7 @@ mod tests {\n                    input.len(), cmp.len(),\n                    100.0 * ((cmp.len() as f64) / (input.len() as f64)));\n             assert_eq!(input, out);\n-        }\n+        });\n     }\n \n     #[test]"}, {"sha": "5fd720c501801ed1b27ed8f9c0b3f018cf7bb2c9", "filename": "src/libextra/future.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -161,7 +161,7 @@ mod test {\n \n     #[test]\n     fn test_from_fn() {\n-        let mut f = Future::from_fn(|| ~\"brail\");\n+        let mut f = Future::from_fn(proc() ~\"brail\");\n         assert_eq!(f.get(), ~\"brail\");\n     }\n \n@@ -185,14 +185,14 @@ mod test {\n \n     #[test]\n     fn test_spawn() {\n-        let mut f = Future::spawn(|| ~\"bale\");\n+        let mut f = Future::spawn(proc() ~\"bale\");\n         assert_eq!(f.get(), ~\"bale\");\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_futurefail() {\n-        let mut f = Future::spawn(|| fail!());\n+        let mut f = Future::spawn(proc() fail!());\n         let _x: ~str = f.get();\n     }\n "}, {"sha": "8cdadca1cc2968f6e4732285f584c798e028425e", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -726,9 +726,9 @@ pub mod groups {\n             // here we just need to indent the start of the description\n             let rowlen = row.char_len();\n             if rowlen < 24 {\n-                do (24 - rowlen).times {\n+                (24 - rowlen).times(|| {\n                     row.push_char(' ')\n-                }\n+                })\n             } else {\n                 row.push_str(desc_sep)\n             }\n@@ -742,10 +742,10 @@ pub mod groups {\n \n             // FIXME: #5516 should be graphemes not codepoints\n             let mut desc_rows = ~[];\n-            do each_split_within(desc_normalized_whitespace, 54) |substr| {\n+            each_split_within(desc_normalized_whitespace, 54, |substr| {\n                 desc_rows.push(substr.to_owned());\n                 true\n-            };\n+            });\n \n             // FIXME: #5516 should be graphemes not codepoints\n             // wrapped description\n@@ -840,7 +840,7 @@ pub mod groups {\n     fn test_split_within() {\n         fn t(s: &str, i: uint, u: &[~str]) {\n             let mut v = ~[];\n-            do each_split_within(s, i) |s| { v.push(s.to_owned()); true };\n+            each_split_within(s, i, |s| { v.push(s.to_owned()); true });\n             assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n         t(\"\", 0, []);"}, {"sha": "3ee43ca4a5852fea5054dcae7a09551b624973fb", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -310,9 +310,9 @@ impl Pattern {\n      */\n     pub fn matches_path(&self, path: &Path) -> bool {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        do path.as_str().map_default(false) |s| {\n+        path.as_str().map_default(false, |s| {\n             self.matches(s)\n-        }\n+        })\n     }\n \n     /**\n@@ -328,9 +328,9 @@ impl Pattern {\n      */\n     pub fn matches_path_with(&self, path: &Path, options: MatchOptions) -> bool {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        do path.as_str().map_default(false) |s| {\n+        path.as_str().map_default(false, |s| {\n             self.matches_with(s, options)\n-        }\n+        })\n     }\n \n     fn matches_from(&self,"}, {"sha": "5a1d1308f8cdae04925fe70c69dbe95a73ac7feb", "filename": "src/libextra/hex.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fhex.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -174,9 +174,9 @@ mod tests {\n     pub fn bench_to_hex(bh: & mut BenchHarness) {\n         let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n                  \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n-        do bh.iter {\n+        bh.iter(|| {\n             s.as_bytes().to_hex();\n-        }\n+        });\n         bh.bytes = s.len() as u64;\n     }\n \n@@ -185,9 +185,9 @@ mod tests {\n         let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n                  \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n         let b = s.as_bytes().to_hex();\n-        do bh.iter {\n+        bh.iter(|| {\n             b.from_hex();\n-        }\n+        });\n         bh.bytes = b.len() as u64;\n     }\n }"}, {"sha": "8dcf0a919d37fc87d780a7b881de8d3a7e895810", "filename": "src/libextra/json.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -79,9 +79,7 @@ fn escape_str(s: &str) -> ~str {\n \n fn spaces(n: uint) -> ~str {\n     let mut ss = ~\"\";\n-    do n.times {\n-        ss.push_str(\" \");\n-    }\n+    n.times(|| ss.push_str(\" \"));\n     return ss;\n }\n \n@@ -1523,33 +1521,33 @@ mod tests {\n     fn test_write_enum() {\n         let animal = Dog;\n         assert_eq!(\n-            do with_str_writer |wr| {\n+            with_str_writer(|wr| {\n                 let mut encoder = Encoder(wr);\n                 animal.encode(&mut encoder);\n-            },\n+            }),\n             ~\"\\\"Dog\\\"\"\n         );\n         assert_eq!(\n-            do with_str_writer |wr| {\n+            with_str_writer(|wr| {\n                 let mut encoder = PrettyEncoder(wr);\n                 animal.encode(&mut encoder);\n-            },\n+            }),\n             ~\"\\\"Dog\\\"\"\n         );\n \n         let animal = Frog(~\"Henry\", 349);\n         assert_eq!(\n-            do with_str_writer |wr| {\n+            with_str_writer(|wr| {\n                 let mut encoder = Encoder(wr);\n                 animal.encode(&mut encoder);\n-            },\n+            }),\n             ~\"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\"\n         );\n         assert_eq!(\n-            do with_str_writer |wr| {\n+            with_str_writer(|wr| {\n                 let mut encoder = PrettyEncoder(wr);\n                 animal.encode(&mut encoder);\n-            },\n+            }),\n             ~\"\\\n             [\\n  \\\n                 \\\"Frog\\\",\\n  \\\n@@ -1562,33 +1560,33 @@ mod tests {\n     #[test]\n     fn test_write_some() {\n         let value = Some(~\"jodhpurs\");\n-        let s = do with_str_writer |wr| {\n+        let s = with_str_writer(|wr| {\n             let mut encoder = Encoder(wr);\n             value.encode(&mut encoder);\n-        };\n+        });\n         assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n \n         let value = Some(~\"jodhpurs\");\n-        let s = do with_str_writer |wr| {\n+        let s = with_str_writer(|wr| {\n             let mut encoder = PrettyEncoder(wr);\n             value.encode(&mut encoder);\n-        };\n+        });\n         assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n     }\n \n     #[test]\n     fn test_write_none() {\n         let value: Option<~str> = None;\n-        let s = do with_str_writer |wr| {\n+        let s = with_str_writer(|wr| {\n             let mut encoder = Encoder(wr);\n             value.encode(&mut encoder);\n-        };\n+        });\n         assert_eq!(s, ~\"null\");\n \n-        let s = do with_str_writer |wr| {\n+        let s = with_str_writer(|wr| {\n             let mut encoder = Encoder(wr);\n             value.encode(&mut encoder);\n-        };\n+        });\n         assert_eq!(s, ~\"null\");\n     }\n \n@@ -1985,7 +1983,7 @@ mod tests {\n     }\n     fn check_err<T: Decodable<Decoder>>(to_parse: &'static str, expected_error: &str) {\n         use std::task;\n-        let res = task::try(|| {\n+        let res = do task::try {\n             // either fails in `decode` (which is what we want), or\n             // returns Some(error_message)/None if the string was\n             // invalid or valid JSON.\n@@ -1996,7 +1994,7 @@ mod tests {\n                     None\n                 }\n             }\n-        });\n+        };\n         match res {\n             Ok(Some(parse_error)) => fail!(\"`{}` is not valid json: {}\",\n                                            to_parse, parse_error),"}, {"sha": "a2540d3948e8920cf3f54ff07e14ebecc5a805b2", "filename": "src/libextra/list.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flist.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -46,7 +46,7 @@ pub fn from_vec<T:Clone + 'static>(v: &[T]) -> @List<T> {\n  */\n pub fn foldl<T:Clone,U>(z: T, ls: @List<U>, f: |&T, &U| -> T) -> T {\n     let mut accum: T = z;\n-    do iter(ls) |elt| { accum = f(&accum, elt);}\n+    iter(ls, |elt| accum = f(&accum, elt));\n     accum\n }\n \n@@ -73,9 +73,9 @@ pub fn find<T:Clone>(ls: @List<T>, f: |&T| -> bool) -> Option<T> {\n /// Returns true if a list contains an element with the given value\n pub fn has<T:Eq>(ls: @List<T>, elt: T) -> bool {\n     let mut found = false;\n-    do each(ls) |e| {\n+    each(ls, |e| {\n         if *e == elt { found = true; false } else { true }\n-    };\n+    });\n     return found;\n }\n "}, {"sha": "a37a0c39e304dee7dbb216330c20eb9dc81e1dfe", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 46, "deletions": 37, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -158,36 +158,36 @@ impl Orderable for BigUint {\n impl BitAnd<BigUint, BigUint> for BigUint {\n     fn bitand(&self, other: &BigUint) -> BigUint {\n         let new_len = num::min(self.data.len(), other.data.len());\n-        let anded = do vec::from_fn(new_len) |i| {\n+        let anded = vec::from_fn(new_len, |i| {\n             // i will never be less than the size of either data vector\n             let ai = self.data[i];\n             let bi = other.data[i];\n             ai & bi\n-        };\n+        });\n         return BigUint::new(anded);\n     }\n }\n \n impl BitOr<BigUint, BigUint> for BigUint {\n     fn bitor(&self, other: &BigUint) -> BigUint {\n         let new_len = num::max(self.data.len(), other.data.len());\n-        let ored = do vec::from_fn(new_len) |i| {\n+        let ored = vec::from_fn(new_len, |i| {\n             let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n             let bi = if i < other.data.len() { other.data[i] } else { 0 };\n             ai | bi\n-        };\n+        });\n         return BigUint::new(ored);\n     }\n }\n \n impl BitXor<BigUint, BigUint> for BigUint {\n     fn bitxor(&self, other: &BigUint) -> BigUint {\n         let new_len = num::max(self.data.len(), other.data.len());\n-        let xored = do vec::from_fn(new_len) |i| {\n+        let xored = vec::from_fn(new_len, |i| {\n             let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n             let bi = if i < other.data.len() { other.data[i] } else { 0 };\n             ai ^ bi\n-        };\n+        });\n         return BigUint::new(xored);\n     }\n }\n@@ -230,15 +230,15 @@ impl Add<BigUint, BigUint> for BigUint {\n         let new_len = num::max(self.data.len(), other.data.len());\n \n         let mut carry = 0;\n-        let mut sum = do vec::from_fn(new_len) |i| {\n+        let mut sum = vec::from_fn(new_len, |i| {\n             let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n             let bi = if i < other.data.len() { other.data[i] } else { 0 };\n             let (hi, lo) = BigDigit::from_uint(\n                 (ai as uint) + (bi as uint) + (carry as uint)\n             );\n             carry = hi;\n             lo\n-        };\n+        });\n         if carry != 0 { sum.push(carry); }\n         return BigUint::new(sum);\n     }\n@@ -249,7 +249,7 @@ impl Sub<BigUint, BigUint> for BigUint {\n         let new_len = num::max(self.data.len(), other.data.len());\n \n         let mut borrow = 0;\n-        let diff = do vec::from_fn(new_len) |i| {\n+        let diff = vec::from_fn(new_len, |i| {\n             let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n             let bi = if i < other.data.len() { other.data[i] } else { 0 };\n             let (hi, lo) = BigDigit::from_uint(\n@@ -262,7 +262,7 @@ impl Sub<BigUint, BigUint> for BigUint {\n             */\n             borrow = if hi == 0 { 1 } else { 0 };\n             lo\n-        };\n+        });\n \n         assert_eq!(borrow, 0);     // <=> assert!((self >= other));\n         return BigUint::new(diff);\n@@ -306,13 +306,13 @@ impl Mul<BigUint, BigUint> for BigUint {\n             if n == 1 { return (*a).clone(); }\n \n             let mut carry = 0;\n-            let mut prod = do a.data.iter().map |ai| {\n+            let mut prod = a.data.iter().map(|ai| {\n                 let (hi, lo) = BigDigit::from_uint(\n                     (*ai as uint) * (n as uint) + (carry as uint)\n                 );\n                 carry = hi;\n                 lo\n-            }.collect::<~[BigDigit]>();\n+            }).collect::<~[BigDigit]>();\n             if carry != 0 { prod.push(carry); }\n             return BigUint::new(prod);\n         }\n@@ -504,14 +504,14 @@ impl Integer for BigUint {\n impl ToPrimitive for BigUint {\n     #[inline]\n     fn to_i64(&self) -> Option<i64> {\n-        do self.to_u64().and_then |n| {\n+        self.to_u64().and_then(|n| {\n             // If top bit of u64 is set, it's too large to convert to i64.\n             if n >> 63 == 0 {\n                 Some(n as i64)\n             } else {\n                 None\n             }\n-        }\n+        })\n     }\n \n     #[cfg(target_word_size = \"32\")]\n@@ -763,13 +763,13 @@ impl BigUint {\n         if n_bits == 0 || self.is_zero() { return (*self).clone(); }\n \n         let mut carry = 0;\n-        let mut shifted = do self.data.iter().map |elem| {\n+        let mut shifted = self.data.iter().map(|elem| {\n             let (hi, lo) = BigDigit::from_uint(\n                 (*elem as uint) << n_bits | (carry as uint)\n             );\n             carry = hi;\n             lo\n-        }.collect::<~[BigDigit]>();\n+        }).collect::<~[BigDigit]>();\n         if carry != 0 { shifted.push(carry); }\n         return BigUint::new(shifted);\n     }\n@@ -1182,7 +1182,7 @@ impl ToPrimitive for BigInt {\n             Plus  => self.data.to_i64(),\n             Zero  => Some(0),\n             Minus => {\n-                do self.data.to_u64().and_then |n| {\n+                self.data.to_u64().and_then(|n| {\n                     let m: u64 = 1 << 63;\n                     if n < m {\n                         Some(-(n as i64))\n@@ -1191,7 +1191,7 @@ impl ToPrimitive for BigInt {\n                     } else {\n                         None\n                     }\n-                }\n+                })\n             }\n         }\n     }\n@@ -1210,13 +1210,14 @@ impl FromPrimitive for BigInt {\n     #[inline]\n     fn from_i64(n: i64) -> Option<BigInt> {\n         if n > 0 {\n-            do FromPrimitive::from_u64(n as u64).and_then |n| {\n+            FromPrimitive::from_u64(n as u64).and_then(|n| {\n                 Some(BigInt::from_biguint(Plus, n))\n-            }\n+            })\n         } else if n < 0 {\n-            do FromPrimitive::from_u64(u64::max_value - (n as u64) + 1).and_then |n| {\n-                Some(BigInt::from_biguint(Minus, n))\n-            }\n+            FromPrimitive::from_u64(u64::max_value - (n as u64) + 1).and_then(\n+                |n| {\n+                    Some(BigInt::from_biguint(Minus, n))\n+                })\n         } else {\n             Some(Zero::zero())\n         }\n@@ -1227,9 +1228,9 @@ impl FromPrimitive for BigInt {\n         if n == 0 {\n             Some(Zero::zero())\n         } else {\n-            do FromPrimitive::from_u64(n).and_then |n| {\n+            FromPrimitive::from_u64(n).and_then(|n| {\n                 Some(BigInt::from_biguint(Plus, n))\n-            }\n+            })\n         }\n     }\n }\n@@ -2051,22 +2052,22 @@ mod biguint_tests {\n     fn test_rand_range() {\n         let mut rng = task_rng();\n \n-        do 10.times {\n+        10.times(|| {\n             assert_eq!(rng.gen_bigint_range(&FromPrimitive::from_uint(236).unwrap(),\n                                             &FromPrimitive::from_uint(237).unwrap()),\n                        FromPrimitive::from_uint(236).unwrap());\n-        }\n+        });\n \n         let l = FromPrimitive::from_uint(403469000 + 2352).unwrap();\n         let u = FromPrimitive::from_uint(403469000 + 3513).unwrap();\n-        do 1000.times {\n+        1000.times(|| {\n             let n: BigUint = rng.gen_biguint_below(&u);\n             assert!(n < u);\n \n             let n: BigUint = rng.gen_biguint_range(&l, &u);\n             assert!(n >= l);\n             assert!(n < u);\n-        }\n+        })\n     }\n \n     #[test]\n@@ -2548,19 +2549,19 @@ mod bigint_tests {\n     fn test_rand_range() {\n         let mut rng = task_rng();\n \n-        do 10.times {\n+        10.times(|| {\n             assert_eq!(rng.gen_bigint_range(&FromPrimitive::from_uint(236).unwrap(),\n                                             &FromPrimitive::from_uint(237).unwrap()),\n                        FromPrimitive::from_uint(236).unwrap());\n-        }\n+        });\n \n         fn check(l: BigInt, u: BigInt) {\n             let mut rng = task_rng();\n-            do 1000.times {\n+            1000.times(|| {\n                 let n: BigInt = rng.gen_bigint_range(&l, &u);\n                 assert!(n >= l);\n                 assert!(n < u);\n-            }\n+            });\n         }\n         let l: BigInt = FromPrimitive::from_uint(403469000 + 2352).unwrap();\n         let u: BigInt = FromPrimitive::from_uint(403469000 + 3513).unwrap();\n@@ -2614,19 +2615,27 @@ mod bench {\n \n     #[bench]\n     fn factorial_100(bh: &mut BenchHarness) {\n-        do bh.iter { factorial(100);  }\n+        bh.iter(|| {\n+            factorial(100);\n+        });\n     }\n \n     #[bench]\n     fn fib_100(bh: &mut BenchHarness) {\n-        do bh.iter { fib(100); }\n+        bh.iter(|| {\n+            fib(100);\n+        });\n     }\n \n     #[bench]\n     fn to_str(bh: &mut BenchHarness) {\n         let fac = factorial(100);\n         let fib = fib(100);\n-        do bh.iter { fac.to_str(); }\n-        do bh.iter { fib.to_str(); }\n+        bh.iter(|| {\n+            fac.to_str();\n+        });\n+        bh.iter(|| {\n+            fib.to_str();\n+        });\n     }\n }"}, {"sha": "1aa03350305fcdcb65671ec4a34d0ac67a546ef5", "filename": "src/libextra/num/rational.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Frational.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -297,12 +297,12 @@ impl<T: FromStr + Clone + Integer + Ord>\n             return None\n         }\n         let a_option: Option<T> = FromStr::from_str(split[0]);\n-        do a_option.and_then |a| {\n+        a_option.and_then(|a| {\n             let b_option: Option<T> = FromStr::from_str(split[1]);\n-            do b_option.and_then |b| {\n+            b_option.and_then(|b| {\n                 Some(Ratio::new(a.clone(), b.clone()))\n-            }\n-        }\n+            })\n+        })\n     }\n }\n impl<T: FromStrRadix + Clone + Integer + Ord>\n@@ -315,13 +315,13 @@ impl<T: FromStrRadix + Clone + Integer + Ord>\n         } else {\n             let a_option: Option<T> = FromStrRadix::from_str_radix(split[0],\n                                                                    radix);\n-            do a_option.and_then |a| {\n+            a_option.and_then(|a| {\n                 let b_option: Option<T> =\n                     FromStrRadix::from_str_radix(split[1], radix);\n-                do b_option.and_then |b| {\n+                b_option.and_then(|b| {\n                     Some(Ratio::new(a.clone(), b.clone()))\n-                }\n-            }\n+                })\n+            })\n         }\n     }\n }"}, {"sha": "f6bf6c21335f8d72d69cec55a5e98b09ad13a74e", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -499,35 +499,35 @@ mod tests {\n \n     #[bench]\n     fn bench_new(b: &mut test::BenchHarness) {\n-        do b.iter {\n+        b.iter(|| {\n             let _: RingBuf<u64> = RingBuf::new();\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_push_back(b: &mut test::BenchHarness) {\n         let mut deq = RingBuf::new();\n-        do b.iter {\n+        b.iter(|| {\n             deq.push_back(0);\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_push_front(b: &mut test::BenchHarness) {\n         let mut deq = RingBuf::new();\n-        do b.iter {\n+        b.iter(|| {\n             deq.push_front(0);\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_grow(b: &mut test::BenchHarness) {\n         let mut deq = RingBuf::new();\n-        do b.iter {\n-            do 65.times {\n+        b.iter(|| {\n+            65.times(|| {\n                 deq.push_front(1);\n-            }\n-        }\n+            })\n+        })\n     }\n \n     #[deriving(Clone, Eq)]"}, {"sha": "cdaac93c1fcd38b1da961569985f9dbd741b4b96", "filename": "src/libextra/semver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsemver.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -238,14 +238,14 @@ pub fn parse(s: &str) -> Option<Version> {\n     }\n     let s = s.trim();\n     let mut bad = false;\n-    do bad_parse::cond.trap(|_| { debug!(\"bad\"); bad = true }).inside {\n+    bad_parse::cond.trap(|_| { debug!(\"bad\"); bad = true }).inside(|| {\n         let v = parse_iter(&mut s.chars());\n         if bad || v.to_str() != s.to_owned() {\n             None\n         } else {\n             Some(v)\n         }\n-    }\n+    })\n }\n \n #[test]"}, {"sha": "aa63ac102e4929c7248c4240113710b21414eb99", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -440,99 +440,99 @@ impl<D:Decoder,T:Decodable<D> + 'static> Decodable<D> for @mut T {\n \n impl<'self, S:Encoder,T:Encodable<S>> Encodable<S> for &'self [T] {\n     fn encode(&self, s: &mut S) {\n-        do s.emit_seq(self.len()) |s| {\n+        s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))\n             }\n-        }\n+        })\n     }\n }\n \n impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~[T] {\n     fn encode(&self, s: &mut S) {\n-        do s.emit_seq(self.len()) |s| {\n+        s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))\n             }\n-        }\n+        })\n     }\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~[T] {\n     fn decode(d: &mut D) -> ~[T] {\n-        do d.read_seq |d, len| {\n-            do vec::from_fn(len) |i| {\n+        d.read_seq(|d, len| {\n+            vec::from_fn(len, |i| {\n                 d.read_seq_elt(i, |d| Decodable::decode(d))\n-            }\n-        }\n+            })\n+        })\n     }\n }\n \n impl<S:Encoder,T:Encodable<S>> Encodable<S> for @[T] {\n     fn encode(&self, s: &mut S) {\n-        do s.emit_seq(self.len()) |s| {\n+        s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))\n             }\n-        }\n+        })\n     }\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for @[T] {\n     fn decode(d: &mut D) -> @[T] {\n-        do d.read_seq |d, len| {\n-            do at_vec::from_fn(len) |i| {\n+        d.read_seq(|d, len| {\n+            at_vec::from_fn(len, |i| {\n                 d.read_seq_elt(i, |d| Decodable::decode(d))\n-            }\n-        }\n+            })\n+        })\n     }\n }\n \n impl<S:Encoder,T:Encodable<S>> Encodable<S> for Option<T> {\n     fn encode(&self, s: &mut S) {\n-        do s.emit_option |s| {\n+        s.emit_option(|s| {\n             match *self {\n                 None => s.emit_option_none(),\n                 Some(ref v) => s.emit_option_some(|s| v.encode(s)),\n             }\n-        }\n+        })\n     }\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for Option<T> {\n     fn decode(d: &mut D) -> Option<T> {\n-        do d.read_option |d, b| {\n+        d.read_option(|d, b| {\n             if b {\n                 Some(Decodable::decode(d))\n             } else {\n                 None\n             }\n-        }\n+        })\n     }\n }\n \n impl<S:Encoder,T0:Encodable<S>,T1:Encodable<S>> Encodable<S> for (T0, T1) {\n     fn encode(&self, s: &mut S) {\n         match *self {\n             (ref t0, ref t1) => {\n-                do s.emit_seq(2) |s| {\n+                s.emit_seq(2, |s| {\n                     s.emit_seq_elt(0, |s| t0.encode(s));\n                     s.emit_seq_elt(1, |s| t1.encode(s));\n-                }\n+                })\n             }\n         }\n     }\n }\n \n impl<D:Decoder,T0:Decodable<D>,T1:Decodable<D>> Decodable<D> for (T0, T1) {\n     fn decode(d: &mut D) -> (T0, T1) {\n-        do d.read_seq |d, len| {\n+        d.read_seq(|d, len| {\n             assert_eq!(len, 2);\n             (\n                 d.read_seq_elt(0, |d| Decodable::decode(d)),\n                 d.read_seq_elt(1, |d| Decodable::decode(d))\n             )\n-        }\n+        })\n     }\n }\n \n@@ -545,11 +545,11 @@ impl<\n     fn encode(&self, s: &mut S) {\n         match *self {\n             (ref t0, ref t1, ref t2) => {\n-                do s.emit_seq(3) |s| {\n+                s.emit_seq(3, |s| {\n                     s.emit_seq_elt(0, |s| t0.encode(s));\n                     s.emit_seq_elt(1, |s| t1.encode(s));\n                     s.emit_seq_elt(2, |s| t2.encode(s));\n-                }\n+                })\n             }\n         }\n     }\n@@ -562,14 +562,14 @@ impl<\n     T2: Decodable<D>\n > Decodable<D> for (T0, T1, T2) {\n     fn decode(d: &mut D) -> (T0, T1, T2) {\n-        do d.read_seq |d, len| {\n+        d.read_seq(|d, len| {\n             assert_eq!(len, 3);\n             (\n                 d.read_seq_elt(0, |d| Decodable::decode(d)),\n                 d.read_seq_elt(1, |d| Decodable::decode(d)),\n                 d.read_seq_elt(2, |d| Decodable::decode(d))\n             )\n-        }\n+        })\n     }\n }\n \n@@ -583,12 +583,12 @@ impl<\n     fn encode(&self, s: &mut S) {\n         match *self {\n             (ref t0, ref t1, ref t2, ref t3) => {\n-                do s.emit_seq(4) |s| {\n+                s.emit_seq(4, |s| {\n                     s.emit_seq_elt(0, |s| t0.encode(s));\n                     s.emit_seq_elt(1, |s| t1.encode(s));\n                     s.emit_seq_elt(2, |s| t2.encode(s));\n                     s.emit_seq_elt(3, |s| t3.encode(s));\n-                }\n+                })\n             }\n         }\n     }\n@@ -602,15 +602,15 @@ impl<\n     T3: Decodable<D>\n > Decodable<D> for (T0, T1, T2, T3) {\n     fn decode(d: &mut D) -> (T0, T1, T2, T3) {\n-        do d.read_seq |d, len| {\n+        d.read_seq(|d, len| {\n             assert_eq!(len, 4);\n             (\n                 d.read_seq_elt(0, |d| Decodable::decode(d)),\n                 d.read_seq_elt(1, |d| Decodable::decode(d)),\n                 d.read_seq_elt(2, |d| Decodable::decode(d)),\n                 d.read_seq_elt(3, |d| Decodable::decode(d))\n             )\n-        }\n+        })\n     }\n }\n \n@@ -625,13 +625,13 @@ impl<\n     fn encode(&self, s: &mut S) {\n         match *self {\n             (ref t0, ref t1, ref t2, ref t3, ref t4) => {\n-                do s.emit_seq(5) |s| {\n+                s.emit_seq(5, |s| {\n                     s.emit_seq_elt(0, |s| t0.encode(s));\n                     s.emit_seq_elt(1, |s| t1.encode(s));\n                     s.emit_seq_elt(2, |s| t2.encode(s));\n                     s.emit_seq_elt(3, |s| t3.encode(s));\n                     s.emit_seq_elt(4, |s| t4.encode(s));\n-                }\n+                })\n             }\n         }\n     }\n@@ -646,7 +646,7 @@ impl<\n     T4: Decodable<D>\n > Decodable<D> for (T0, T1, T2, T3, T4) {\n     fn decode(d: &mut D) -> (T0, T1, T2, T3, T4) {\n-        do d.read_seq |d, len| {\n+        d.read_seq(|d, len| {\n             assert_eq!(len, 5);\n             (\n                 d.read_seq_elt(0, |d| Decodable::decode(d)),\n@@ -655,7 +655,7 @@ impl<\n                 d.read_seq_elt(3, |d| Decodable::decode(d)),\n                 d.read_seq_elt(4, |d| Decodable::decode(d))\n             )\n-        }\n+        })\n     }\n }\n \n@@ -664,22 +664,22 @@ impl<\n     T: Encodable<S>\n > Encodable<S> for DList<T> {\n     fn encode(&self, s: &mut S) {\n-        do s.emit_seq(self.len()) |s| {\n+        s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n             }\n-        }\n+        })\n     }\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for DList<T> {\n     fn decode(d: &mut D) -> DList<T> {\n         let mut list = DList::new();\n-        do d.read_seq |d, len| {\n+        d.read_seq(|d, len| {\n             for i in range(0u, len) {\n                 list.push_back(d.read_seq_elt(i, |d| Decodable::decode(d)));\n             }\n-        }\n+        });\n         list\n     }\n }\n@@ -689,22 +689,22 @@ impl<\n     T: Encodable<S>\n > Encodable<S> for RingBuf<T> {\n     fn encode(&self, s: &mut S) {\n-        do s.emit_seq(self.len()) |s| {\n+        s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n             }\n-        }\n+        })\n     }\n }\n \n impl<D:Decoder,T:Decodable<D>> Decodable<D> for RingBuf<T> {\n     fn decode(d: &mut D) -> RingBuf<T> {\n         let mut deque = RingBuf::new();\n-        do d.read_seq |d, len| {\n+        d.read_seq(|d, len| {\n             for i in range(0u, len) {\n                 deque.push_back(d.read_seq_elt(i, |d| Decodable::decode(d)));\n             }\n-        }\n+        });\n         deque\n     }\n }\n@@ -715,14 +715,14 @@ impl<\n     V: Encodable<E>\n > Encodable<E> for HashMap<K, V> {\n     fn encode(&self, e: &mut E) {\n-        do e.emit_map(self.len()) |e| {\n+        e.emit_map(self.len(), |e| {\n             let mut i = 0;\n             for (key, val) in self.iter() {\n                 e.emit_map_elt_key(i, |e| key.encode(e));\n                 e.emit_map_elt_val(i, |e| val.encode(e));\n                 i += 1;\n             }\n-        }\n+        })\n     }\n }\n \n@@ -732,15 +732,15 @@ impl<\n     V: Decodable<D>\n > Decodable<D> for HashMap<K, V> {\n     fn decode(d: &mut D) -> HashMap<K, V> {\n-        do d.read_map |d, len| {\n+        d.read_map(|d, len| {\n             let mut map = HashMap::with_capacity(len);\n             for i in range(0u, len) {\n                 let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n                 let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n                 map.insert(key, val);\n             }\n             map\n-        }\n+        })\n     }\n }\n \n@@ -749,13 +749,13 @@ impl<\n     T: Encodable<S> + Hash + IterBytes + Eq\n > Encodable<S> for HashSet<T> {\n     fn encode(&self, s: &mut S) {\n-        do s.emit_seq(self.len()) |s| {\n+        s.emit_seq(self.len(), |s| {\n             let mut i = 0;\n             for e in self.iter() {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n                 i += 1;\n             }\n-        }\n+        })\n     }\n }\n \n@@ -764,13 +764,13 @@ impl<\n     T: Decodable<D> + Hash + IterBytes + Eq\n > Decodable<D> for HashSet<T> {\n     fn decode(d: &mut D) -> HashSet<T> {\n-        do d.read_seq |d, len| {\n+        d.read_seq(|d, len| {\n             let mut set = HashSet::with_capacity(len);\n             for i in range(0u, len) {\n                 set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n             }\n             set\n-        }\n+        })\n     }\n }\n \n@@ -779,15 +779,15 @@ impl<\n     V: Encodable<E>\n > Encodable<E> for TrieMap<V> {\n     fn encode(&self, e: &mut E) {\n-        do e.emit_map(self.len()) |e| {\n+        e.emit_map(self.len(), |e| {\n             let mut i = 0;\n-            do self.each |key, val| {\n+            self.each(|key, val| {\n                 e.emit_map_elt_key(i, |e| key.encode(e));\n                 e.emit_map_elt_val(i, |e| val.encode(e));\n                 i += 1;\n                 true\n-            };\n-        }\n+            });\n+        })\n     }\n }\n \n@@ -796,40 +796,40 @@ impl<\n     V: Decodable<D>\n > Decodable<D> for TrieMap<V> {\n     fn decode(d: &mut D) -> TrieMap<V> {\n-        do d.read_map |d, len| {\n+        d.read_map(|d, len| {\n             let mut map = TrieMap::new();\n             for i in range(0u, len) {\n                 let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n                 let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n                 map.insert(key, val);\n             }\n             map\n-        }\n+        })\n     }\n }\n \n impl<S: Encoder> Encodable<S> for TrieSet {\n     fn encode(&self, s: &mut S) {\n-        do s.emit_seq(self.len()) |s| {\n+        s.emit_seq(self.len(), |s| {\n             let mut i = 0;\n-            do self.each |e| {\n+            self.each(|e| {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n                 i += 1;\n                 true\n-            };\n-        }\n+            });\n+        })\n     }\n }\n \n impl<D: Decoder> Decodable<D> for TrieSet {\n     fn decode(d: &mut D) -> TrieSet {\n-        do d.read_seq |d, len| {\n+        d.read_seq(|d, len| {\n             let mut set = TrieSet::new();\n             for i in range(0u, len) {\n                 set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n             }\n             set\n-        }\n+        })\n     }\n }\n \n@@ -839,14 +839,14 @@ impl<\n     V: Encodable<E> + Eq\n > Encodable<E> for TreeMap<K, V> {\n     fn encode(&self, e: &mut E) {\n-        do e.emit_map(self.len()) |e| {\n+        e.emit_map(self.len(), |e| {\n             let mut i = 0;\n             for (key, val) in self.iter() {\n                 e.emit_map_elt_key(i, |e| key.encode(e));\n                 e.emit_map_elt_val(i, |e| val.encode(e));\n                 i += 1;\n             }\n-        }\n+        })\n     }\n }\n \n@@ -856,15 +856,15 @@ impl<\n     V: Decodable<D> + Eq\n > Decodable<D> for TreeMap<K, V> {\n     fn decode(d: &mut D) -> TreeMap<K, V> {\n-        do d.read_map |d, len| {\n+        d.read_map(|d, len| {\n             let mut map = TreeMap::new();\n             for i in range(0u, len) {\n                 let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n                 let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n                 map.insert(key, val);\n             }\n             map\n-        }\n+        })\n     }\n }\n \n@@ -873,13 +873,13 @@ impl<\n     T: Encodable<S> + Eq + TotalOrd\n > Encodable<S> for TreeSet<T> {\n     fn encode(&self, s: &mut S) {\n-        do s.emit_seq(self.len()) |s| {\n+        s.emit_seq(self.len(), |s| {\n             let mut i = 0;\n             for e in self.iter() {\n                 s.emit_seq_elt(i, |s| e.encode(s));\n                 i += 1;\n             }\n-        }\n+        })\n     }\n }\n \n@@ -888,13 +888,13 @@ impl<\n     T: Decodable<D> + Eq + TotalOrd\n > Decodable<D> for TreeSet<T> {\n     fn decode(d: &mut D) -> TreeSet<T> {\n-        do d.read_seq |d, len| {\n+        d.read_seq(|d, len| {\n             let mut set = TreeSet::new();\n             for i in range(0u, len) {\n                 set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n             }\n             set\n-        }\n+        })\n     }\n }\n \n@@ -909,13 +909,13 @@ pub trait EncoderHelpers {\n \n impl<S:Encoder> EncoderHelpers for S {\n     fn emit_from_vec<T>(&mut self, v: &[T], f: |&mut S, &T|) {\n-        do self.emit_seq(v.len()) |this| {\n+        self.emit_seq(v.len(), |this| {\n             for (i, e) in v.iter().enumerate() {\n-                do this.emit_seq_elt(i) |this| {\n+                this.emit_seq_elt(i, |this| {\n                     f(this, e)\n-                }\n+                })\n             }\n-        }\n+        })\n     }\n }\n \n@@ -925,10 +925,10 @@ pub trait DecoderHelpers {\n \n impl<D:Decoder> DecoderHelpers for D {\n     fn read_to_vec<T>(&mut self, f: |&mut D| -> T) -> ~[T] {\n-        do self.read_seq |this, len| {\n-            do vec::from_fn(len) |i| {\n+        self.read_seq(|this, len| {\n+            vec::from_fn(len, |i| {\n                 this.read_seq_elt(i, |this| f(this))\n-            }\n-        }\n+            })\n+        })\n     }\n }"}, {"sha": "5d5696d778ffca207e6800457fbb33036afef902", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -15,7 +15,7 @@ use std::cmp::{Eq, Ord};\n use std::util::swap;\n use std::vec;\n \n-type Le<'self, T> = &'self fn(v1: &T, v2: &T) -> bool;\n+type Le<'self, T> = 'self |v1: &T, v2: &T| -> bool;\n \n /**\n  * Merge sort. Returns a new vector containing the sorted list.\n@@ -828,7 +828,7 @@ mod test_qsort {\n \n         let expected = ~[1, 2, 3];\n \n-        do quick_sort(names) |x, y| { *x < *y };\n+        quick_sort(names, |x, y| *x < *y);\n \n         let immut_names = names;\n \n@@ -968,9 +968,9 @@ mod test_tim_sort {\n     #[cfg(unix)]\n     fn crash_test() {\n         let mut rng = rand::rng();\n-        let mut arr = do vec::from_fn(1000) |_i| {\n+        let mut arr = vec::from_fn(1000, |_i| {\n             CVal { val: rng.gen() }\n-        };\n+        });\n \n         tim_sort(arr);\n         fail!(\"Guarantee the fail\");\n@@ -991,9 +991,9 @@ mod test_tim_sort {\n     #[test]\n     fn test_bad_Ord_impl() {\n         let mut rng = rand::rng();\n-        let mut arr = do vec::from_fn(500) |_i| {\n+        let mut arr = vec::from_fn(500, |_i| {\n             DVal { val: rng.gen() }\n-        };\n+        });\n \n         tim_sort(arr);\n     }\n@@ -1024,14 +1024,14 @@ mod big_tests {\n \n     fn multiplyVec<T:Clone>(arr: &[T], num: uint) -> ~[T] {\n         let size = arr.len();\n-        let res = do vec::from_fn(num) |i| {\n+        let res = vec::from_fn(num, |i| {\n             arr[i % size].clone()\n-        };\n+        });\n         res\n     }\n \n     fn makeRange(n: uint) -> ~[uint] {\n-        let one = do vec::from_fn(n) |i| { i };\n+        let one = vec::from_fn(n, |i| i);\n         let mut two = one.clone();\n         two.reverse();\n         vec::append(two, one)\n@@ -1050,9 +1050,9 @@ mod big_tests {\n \n         for i in range(lo, hi) {\n             let n = 1 << i;\n-            let mut arr: ~[f64] = do vec::from_fn(n) |_i| {\n+            let mut arr: ~[f64] = vec::from_fn(n, |_i| {\n                 rng.gen()\n-            };\n+            });\n \n             tim_sort(arr); // *sort\n             isSorted(arr);\n@@ -1064,11 +1064,11 @@ mod big_tests {\n             tim_sort(arr); // /sort\n             isSorted(arr);\n \n-            do 3.times {\n+            3.times(|| {\n                 let i1 = rng.gen_range(0u, n);\n                 let i2 = rng.gen_range(0u, n);\n                 arr.swap(i1, i2);\n-            }\n+            });\n             tim_sort(arr); // 3sort\n             isSorted(arr);\n \n@@ -1083,10 +1083,10 @@ mod big_tests {\n             tim_sort(arr); // +sort\n             isSorted(arr);\n \n-            do (n/100).times {\n+            (n/100).times(|| {\n                 let idx = rng.gen_range(0u, n);\n                 arr[idx] = rng.gen();\n-            }\n+            });\n             tim_sort(arr);\n             isSorted(arr);\n \n@@ -1121,9 +1121,9 @@ mod big_tests {\n \n         for i in range(lo, hi) {\n             let n = 1 << i;\n-            let arr: ~[@f64] = do vec::from_fn(n) |_i| {\n+            let arr: ~[@f64] = vec::from_fn(n, |_i| {\n                 @rng.gen()\n-            };\n+            });\n             let mut arr = arr;\n \n             tim_sort(arr); // *sort\n@@ -1136,11 +1136,11 @@ mod big_tests {\n             tim_sort(arr); // /sort\n             isSorted(arr);\n \n-            do 3.times {\n+            3.times(|| {\n                 let i1 = rng.gen_range(0u, n);\n                 let i2 = rng.gen_range(0u, n);\n                 arr.swap(i1, i2);\n-            }\n+            });\n             tim_sort(arr); // 3sort\n             isSorted(arr);\n \n@@ -1155,10 +1155,10 @@ mod big_tests {\n             tim_sort(arr); // +sort\n             isSorted(arr);\n \n-            do (n/100).times {\n+            (n/100).times(|| {\n                 let idx = rng.gen_range(0u, n);\n                 arr[idx] = @rng.gen();\n-            }\n+            });\n             tim_sort(arr);\n             isSorted(arr);\n "}, {"sha": "6167a4293806f8c8fa3ec94c8162fd47d61386e8", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 166, "deletions": 164, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -104,16 +104,16 @@ impl<Q:Send> Sem<Q> {\n     pub fn acquire(&self) {\n         unsafe {\n             let mut waiter_nobe = None;\n-            do (**self).with |state| {\n+            (**self).with(|state| {\n                 state.count -= 1;\n                 if state.count < 0 {\n                     // Create waiter nobe, enqueue ourself, and tell\n                     // outer scope we need to block.\n                     waiter_nobe = Some(state.waiters.wait_end());\n                 }\n-            }\n+            });\n             // Uncomment if you wish to test for sem races. Not valgrind-friendly.\n-            /* do 1000.times { task::deschedule(); } */\n+            /* 1000.times(|| task::deschedule()); */\n             // Need to wait outside the exclusive.\n             if waiter_nobe.is_some() {\n                 let _ = waiter_nobe.unwrap().recv();\n@@ -123,22 +123,22 @@ impl<Q:Send> Sem<Q> {\n \n     pub fn release(&self) {\n         unsafe {\n-            do (**self).with |state| {\n+            (**self).with(|state| {\n                 state.count += 1;\n                 if state.count <= 0 {\n                     state.waiters.signal();\n                 }\n-            }\n+            })\n         }\n     }\n \n     pub fn access<U>(&self, blk: || -> U) -> U {\n-        do (|| {\n+        (|| {\n             self.acquire();\n             blk()\n-        }).finally {\n+        }).finally(|| {\n             self.release();\n-        }\n+        })\n     }\n }\n \n@@ -147,9 +147,7 @@ impl Sem<~[WaitQueue]> {\n     fn new_and_signal(count: int, num_condvars: uint)\n         -> Sem<~[WaitQueue]> {\n         let mut queues = ~[];\n-        do num_condvars.times {\n-            queues.push(WaitQueue::new());\n-        }\n+        num_condvars.times(|| queues.push(WaitQueue::new()));\n         Sem::new(count, queues)\n     }\n }\n@@ -205,7 +203,7 @@ impl<'self> Condvar<'self> {\n         let mut out_of_bounds = None;\n         // Release lock, 'atomically' enqueuing ourselves in so doing.\n         unsafe {\n-            do (**self.sem).with |state| {\n+            (**self.sem).with(|state| {\n                 if condvar_id < state.blocked.len() {\n                     // Drop the lock.\n                     state.count += 1;\n@@ -218,29 +216,25 @@ impl<'self> Condvar<'self> {\n                 } else {\n                     out_of_bounds = Some(state.blocked.len());\n                 }\n-            }\n+            })\n         }\n \n         // If deschedule checks start getting inserted anywhere, we can be\n         // killed before or after enqueueing.\n-        do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.wait_on()\") {\n+        check_cvar_bounds(out_of_bounds, condvar_id, \"cond.wait_on()\", || {\n             // Unconditionally \"block\". (Might not actually block if a\n             // signaller already sent -- I mean 'unconditionally' in contrast\n             // with acquire().)\n-            do (|| {\n+            (|| {\n                 let _ = WaitEnd.take_unwrap().recv();\n-            }).finally {\n+            }).finally(|| {\n                 // Reacquire the condvar.\n                 match self.order {\n-                    Just(lock) => do lock.access {\n-                        self.sem.acquire();\n-                    },\n-                    Nothing => {\n-                        self.sem.acquire();\n-                    },\n+                    Just(lock) => lock.access(|| self.sem.acquire()),\n+                    Nothing => self.sem.acquire(),\n                 }\n-            }\n-        }\n+            })\n+        })\n     }\n \n     /// Wake up a blocked task. Returns false if there was no blocked task.\n@@ -251,16 +245,17 @@ impl<'self> Condvar<'self> {\n         unsafe {\n             let mut out_of_bounds = None;\n             let mut result = false;\n-            do (**self.sem).with |state| {\n+            (**self.sem).with(|state| {\n                 if condvar_id < state.blocked.len() {\n                     result = state.blocked[condvar_id].signal();\n                 } else {\n                     out_of_bounds = Some(state.blocked.len());\n                 }\n-            }\n-            do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.signal_on()\") {\n-                result\n-            }\n+            });\n+            check_cvar_bounds(out_of_bounds,\n+                              condvar_id,\n+                              \"cond.signal_on()\",\n+                              || result)\n         }\n     }\n \n@@ -272,7 +267,7 @@ impl<'self> Condvar<'self> {\n         let mut out_of_bounds = None;\n         let mut queue = None;\n         unsafe {\n-            do (**self.sem).with |state| {\n+            (**self.sem).with(|state| {\n                 if condvar_id < state.blocked.len() {\n                     // To avoid :broadcast_heavy, we make a new waitqueue,\n                     // swap it out with the old one, and broadcast on the\n@@ -282,11 +277,14 @@ impl<'self> Condvar<'self> {\n                 } else {\n                     out_of_bounds = Some(state.blocked.len());\n                 }\n-            }\n-            do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.signal_on()\") {\n+            });\n+            check_cvar_bounds(out_of_bounds,\n+                              condvar_id,\n+                              \"cond.signal_on()\",\n+                              || {\n                 let queue = queue.take_unwrap();\n                 queue.broadcast()\n-            }\n+            })\n         }\n     }\n }\n@@ -315,9 +313,13 @@ impl Sem<~[WaitQueue]> {\n     // The only other places that condvars get built are rwlock.write_cond()\n     // and rwlock_write_mode.\n     pub fn access_cond<U>(&self, blk: |c: &Condvar| -> U) -> U {\n-        do self.access {\n-            blk(&Condvar { sem: self, order: Nothing, token: NonCopyable })\n-        }\n+        self.access(|| {\n+            blk(&Condvar {\n+                sem: self,\n+                order: Nothing,\n+                token: NonCopyable\n+            })\n+        })\n     }\n }\n \n@@ -474,17 +476,17 @@ impl RWLock {\n      */\n     pub fn read<U>(&self, blk: || -> U) -> U {\n         unsafe {\n-            do (&self.order_lock).access {\n+            (&self.order_lock).access(|| {\n                 let state = &mut *self.state.get();\n                 let old_count = state.read_count.fetch_add(1, atomics::Acquire);\n                 if old_count == 0 {\n                     (&self.access_lock).acquire();\n                     state.read_mode = true;\n                 }\n-            }\n-            do (|| {\n+            });\n+            (|| {\n                 blk()\n-            }).finally {\n+            }).finally(|| {\n                 let state = &mut *self.state.get();\n                 assert!(state.read_mode);\n                 let old_count = state.read_count.fetch_sub(1, atomics::Release);\n@@ -497,7 +499,7 @@ impl RWLock {\n                     // this access MUST NOT go inside the exclusive access.\n                     (&self.access_lock).release();\n                 }\n-            }\n+            })\n         }\n     }\n \n@@ -507,10 +509,10 @@ impl RWLock {\n      */\n     pub fn write<U>(&self, blk: || -> U) -> U {\n         (&self.order_lock).acquire();\n-        do (&self.access_lock).access {\n+        (&self.access_lock).access(|| {\n             (&self.order_lock).release();\n             blk()\n-        }\n+        })\n     }\n \n     /**\n@@ -547,12 +549,12 @@ impl RWLock {\n         // The astute reader will also note that making waking writers use the\n         // order_lock is better for not starving readers.\n         (&self.order_lock).acquire();\n-        do (&self.access_lock).access_cond |cond| {\n+        (&self.access_lock).access_cond(|cond| {\n             (&self.order_lock).release();\n             let opt_lock = Just(&self.order_lock);\n             blk(&Condvar { sem: cond.sem, order: opt_lock,\n                            token: NonCopyable })\n-        }\n+        })\n     }\n \n     /**\n@@ -565,15 +567,15 @@ impl RWLock {\n      * # Example\n      *\n      * ```rust\n-     * do lock.write_downgrade |mut write_token| {\n-     *     do write_token.write_cond |condvar| {\n+     * lock.write_downgrade(|mut write_token| {\n+     *     write_token.write_cond(|condvar| {\n      *         ... exclusive access ...\n-     *     }\n+     *     });\n      *     let read_token = lock.downgrade(write_token);\n-     *     do read_token.read {\n+     *     read_token.read(|| {\n      *         ... shared access ...\n-     *     }\n-     * }\n+     *     })\n+     * })\n      * ```\n      */\n     pub fn write_downgrade<U>(&self, blk: |v: RWLockWriteMode| -> U) -> U {\n@@ -582,9 +584,9 @@ impl RWLock {\n         (&self.order_lock).acquire();\n         (&self.access_lock).acquire();\n         (&self.order_lock).release();\n-        do (|| {\n+        (|| {\n             blk(RWLockWriteMode { lock: self, token: NonCopyable })\n-        }).finally {\n+        }).finally(|| {\n             let writer_or_last_reader;\n             // Check if we're releasing from read mode or from write mode.\n             let state = unsafe { &mut *self.state.get() };\n@@ -609,7 +611,7 @@ impl RWLock {\n                 // Nobody left inside; release the \"reader cloud\" lock.\n                 (&self.access_lock).release();\n             }\n-        }\n+        })\n     }\n \n     /// To be called inside of the write_downgrade block.\n@@ -692,20 +694,20 @@ mod tests {\n     #[test]\n     fn test_sem_basic() {\n         let s = Semaphore::new(1);\n-        do s.access { }\n+        s.access(|| { })\n     }\n     #[test]\n     fn test_sem_as_mutex() {\n         let s = Semaphore::new(1);\n         let s2 = s.clone();\n         do task::spawn {\n-            do s2.access {\n-                do 5.times { task::deschedule(); }\n-            }\n-        }\n-        do s.access {\n-            do 5.times { task::deschedule(); }\n+            s2.access(|| {\n+                5.times(|| { task::deschedule(); })\n+            })\n         }\n+        s.access(|| {\n+            5.times(|| { task::deschedule(); })\n+        })\n     }\n     #[test]\n     fn test_sem_as_cvar() {\n@@ -717,7 +719,7 @@ mod tests {\n             s2.acquire();\n             c.send(());\n         }\n-        do 5.times { task::deschedule(); }\n+        5.times(|| { task::deschedule(); });\n         s.release();\n         let _ = p.recv();\n \n@@ -726,7 +728,7 @@ mod tests {\n         let s = Semaphore::new(0);\n         let s2 = s.clone();\n         do task::spawn {\n-            do 5.times { task::deschedule(); }\n+            5.times(|| { task::deschedule(); });\n             s2.release();\n             let _ = p.recv();\n         }\n@@ -742,15 +744,15 @@ mod tests {\n         let (p1,c1) = comm::stream();\n         let (p2,c2) = comm::stream();\n         do task::spawn {\n-            do s2.access {\n+            s2.access(|| {\n                 let _ = p2.recv();\n                 c1.send(());\n-            }\n+            })\n         }\n-        do s.access {\n+        s.access(|| {\n             c2.send(());\n             let _ = p1.recv();\n-        }\n+        })\n     }\n     #[test]\n     fn test_sem_runtime_friendly_blocking() {\n@@ -761,16 +763,16 @@ mod tests {\n             let s2 = s.clone();\n             let (p, c) = comm::stream();\n             let child_data = Cell::new((s2, c));\n-            do s.access {\n+            s.access(|| {\n                 let (s2, c) = child_data.take();\n                 do task::spawn {\n                     c.send(());\n-                    do s2.access { }\n+                    s2.access(|| { });\n                     c.send(());\n                 }\n                 let _ = p.recv(); // wait for child to come alive\n-                do 5.times { task::deschedule(); } // let the child contend\n-            }\n+                5.times(|| { task::deschedule(); }); // let the child contend\n+            });\n             let _ = p.recv(); // wait for child to be done\n         }\n     }\n@@ -803,71 +805,71 @@ mod tests {\n         }\n \n         fn access_shared(sharedstate: &mut int, m: &Mutex, n: uint) {\n-            do n.times {\n-                do m.lock {\n+            n.times(|| {\n+                m.lock(|| {\n                     let oldval = *sharedstate;\n                     task::deschedule();\n                     *sharedstate = oldval + 1;\n-                }\n-            }\n+                })\n+            })\n         }\n     }\n     #[test]\n     fn test_mutex_cond_wait() {\n         let m = Mutex::new();\n \n         // Child wakes up parent\n-        do m.lock_cond |cond| {\n+        m.lock_cond(|cond| {\n             let m2 = m.clone();\n             do task::spawn {\n-                do m2.lock_cond |cond| {\n+                m2.lock_cond(|cond| {\n                     let woken = cond.signal();\n                     assert!(woken);\n-                }\n+                })\n             }\n             cond.wait();\n-        }\n+        });\n         // Parent wakes up child\n         let (port,chan) = comm::stream();\n         let m3 = m.clone();\n         do task::spawn {\n-            do m3.lock_cond |cond| {\n+            m3.lock_cond(|cond| {\n                 chan.send(());\n                 cond.wait();\n                 chan.send(());\n-            }\n+            })\n         }\n         let _ = port.recv(); // Wait until child gets in the mutex\n-        do m.lock_cond |cond| {\n+        m.lock_cond(|cond| {\n             let woken = cond.signal();\n             assert!(woken);\n-        }\n+        });\n         let _ = port.recv(); // Wait until child wakes up\n     }\n     #[cfg(test)]\n     fn test_mutex_cond_broadcast_helper(num_waiters: uint) {\n         let m = Mutex::new();\n         let mut ports = ~[];\n \n-        do num_waiters.times {\n+        num_waiters.times(|| {\n             let mi = m.clone();\n             let (port, chan) = comm::stream();\n             ports.push(port);\n             do task::spawn {\n-                do mi.lock_cond |cond| {\n+                mi.lock_cond(|cond| {\n                     chan.send(());\n                     cond.wait();\n                     chan.send(());\n-                }\n+                })\n             }\n-        }\n+        });\n \n         // wait until all children get in the mutex\n         for port in ports.iter() { let _ = port.recv(); }\n-        do m.lock_cond |cond| {\n+        m.lock_cond(|cond| {\n             let num_woken = cond.broadcast();\n             assert_eq!(num_woken, num_waiters);\n-        }\n+        });\n         // wait until all children wake up\n         for port in ports.iter() { let _ = port.recv(); }\n     }\n@@ -884,11 +886,11 @@ mod tests {\n         let m = Mutex::new();\n         let m2 = m.clone();\n         do task::try {\n-            do m.lock_cond |_x| { }\n+            m.lock_cond(|_x| { })\n         };\n-        do m2.lock_cond |cond| {\n+        m2.lock_cond(|cond| {\n             assert!(!cond.signal());\n-        }\n+        })\n     }\n     #[test]\n     fn test_mutex_killed_simple() {\n@@ -897,13 +899,13 @@ mod tests {\n         let m2 = m.clone();\n \n         let result: result::Result<(), ~Any> = do task::try {\n-            do m2.lock {\n+            m2.lock(|| {\n                 fail!();\n-            }\n+            })\n         };\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n-        do m.lock { }\n+        m.lock(|| { })\n     }\n     #[ignore(reason = \"linked failure\")]\n     #[test]\n@@ -920,17 +922,17 @@ mod tests {\n                 task::deschedule();\n                 fail!();\n             }\n-            do m2.lock_cond |cond| {\n+            m2.lock_cond(|cond| {\n                 c.send(()); // tell sibling go ahead\n                 cond.wait(); // block forever\n-            }\n+            })\n         };\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n-        do m.lock_cond |cond| {\n+        m.lock_cond(|cond| {\n             let woken = cond.signal();\n             assert!(!woken);\n-        }\n+        })\n     }\n     #[ignore(reason = \"linked failure\")]\n     #[test]\n@@ -943,55 +945,55 @@ mod tests {\n \n         let result: result::Result<(), ~Any> = do task::try {\n             let mut sibling_convos = ~[];\n-            do 2.times {\n+            2.times(|| {\n                 let (p, c) = comm::stream();\n                 let c = Cell::new(c);\n                 sibling_convos.push(p);\n                 let mi = m2.clone();\n                 // spawn sibling task\n                 do task::spawn { // linked\n-                    do mi.lock_cond |cond| {\n+                    mi.lock_cond(|cond| {\n                         let c = c.take();\n                         c.send(()); // tell sibling to go ahead\n-                        do (|| {\n+                        (|| {\n                             cond.wait(); // block forever\n-                        }).finally {\n+                        }).finally(|| {\n                             error!(\"task unwinding and sending\");\n                             c.send(());\n                             error!(\"task unwinding and done sending\");\n-                        }\n-                    }\n+                        })\n+                    })\n                 }\n-            }\n+            });\n             for p in sibling_convos.iter() {\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n             }\n-            do m2.lock { }\n+            m2.lock(|| { });\n             c.send(sibling_convos); // let parent wait on all children\n             fail!();\n         };\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n         let r = p.recv();\n         for p in r.iter() { p.recv(); } // wait on all its siblings\n-        do m.lock_cond |cond| {\n+        m.lock_cond(|cond| {\n             let woken = cond.broadcast();\n             assert_eq!(woken, 0);\n-        }\n+        })\n     }\n     #[test]\n     fn test_mutex_cond_signal_on_0() {\n         // Tests that signal_on(0) is equivalent to signal().\n         let m = Mutex::new();\n-        do m.lock_cond |cond| {\n+        m.lock_cond(|cond| {\n             let m2 = m.clone();\n             do task::spawn {\n-                do m2.lock_cond |cond| {\n+                m2.lock_cond(|cond| {\n                     cond.signal_on(0);\n-                }\n+                })\n             }\n             cond.wait();\n-        }\n+        })\n     }\n     #[test]\n     fn test_mutex_different_conds() {\n@@ -1000,35 +1002,35 @@ mod tests {\n             let m2 = m.clone();\n             let (p, c) = comm::stream();\n             do task::spawn {\n-                do m2.lock_cond |cond| {\n+                m2.lock_cond(|cond| {\n                     c.send(());\n                     cond.wait_on(1);\n-                }\n+                })\n             }\n             let _ = p.recv();\n-            do m.lock_cond |cond| {\n+            m.lock_cond(|cond| {\n                 if !cond.signal_on(0) {\n                     fail!(); // success; punt sibling awake.\n                 }\n-            }\n+            })\n         };\n         assert!(result.is_err());\n     }\n     #[test]\n     fn test_mutex_no_condvars() {\n         let result = do task::try {\n             let m = Mutex::new_with_condvars(0);\n-            do m.lock_cond |cond| { cond.wait(); }\n+            m.lock_cond(|cond| { cond.wait(); })\n         };\n         assert!(result.is_err());\n         let result = do task::try {\n             let m = Mutex::new_with_condvars(0);\n-            do m.lock_cond |cond| { cond.signal(); }\n+            m.lock_cond(|cond| { cond.signal(); })\n         };\n         assert!(result.is_err());\n         let result = do task::try {\n             let m = Mutex::new_with_condvars(0);\n-            do m.lock_cond |cond| { cond.broadcast(); }\n+            m.lock_cond(|cond| { cond.broadcast(); })\n         };\n         assert!(result.is_err());\n     }\n@@ -1043,14 +1045,14 @@ mod tests {\n             Read => x.read(blk),\n             Write => x.write(blk),\n             Downgrade =>\n-                do x.write_downgrade |mode| {\n-                    do mode.write { blk() };\n-                },\n+                x.write_downgrade(|mode| {\n+                    mode.write(|| { blk() });\n+                }),\n             DowngradeRead =>\n-                do x.write_downgrade |mode| {\n+                x.write_downgrade(|mode| {\n                     let mode = x.downgrade(mode);\n-                    do mode.read { blk() };\n-                },\n+                    mode.read(|| { blk() });\n+                }),\n         }\n     }\n     #[cfg(test)]\n@@ -1080,13 +1082,13 @@ mod tests {\n \n         fn access_shared(sharedstate: &mut int, x: &RWLock, mode: RWLockMode,\n                          n: uint) {\n-            do n.times {\n-                do lock_rwlock_in_mode(x, mode) {\n+            n.times(|| {\n+                lock_rwlock_in_mode(x, mode, || {\n                     let oldval = *sharedstate;\n                     task::deschedule();\n                     *sharedstate = oldval + 1;\n-                }\n-            }\n+                })\n+            })\n         }\n     }\n     #[test]\n@@ -1116,24 +1118,24 @@ mod tests {\n             if !make_mode2_go_first {\n                 let _ = p2.recv(); // parent sends to us once it locks, or ...\n             }\n-            do lock_rwlock_in_mode(&x2, mode2) {\n+            lock_rwlock_in_mode(&x2, mode2, || {\n                 if make_mode2_go_first {\n                     c1.send(()); // ... we send to it once we lock\n                 }\n                 let _ = p2.recv();\n                 c1.send(());\n-            }\n+            })\n         }\n         if make_mode2_go_first {\n             let _ = p1.recv(); // child sends to us once it locks, or ...\n         }\n-        do lock_rwlock_in_mode(x, mode1) {\n+        lock_rwlock_in_mode(x, mode1, || {\n             if !make_mode2_go_first {\n                 c2.send(()); // ... we send to it once we lock\n             }\n             c2.send(());\n             let _ = p1.recv();\n-        }\n+        })\n     }\n     #[test]\n     fn test_rwlock_readers_and_readers() {\n@@ -1148,51 +1150,51 @@ mod tests {\n     fn test_rwlock_downgrade_unlock() {\n         // Tests that downgrade can unlock the lock in both modes\n         let x = RWLock::new();\n-        do lock_rwlock_in_mode(&x, Downgrade) { }\n+        lock_rwlock_in_mode(&x, Downgrade, || { });\n         test_rwlock_handshake(&x, Read, Read, false);\n         let y = RWLock::new();\n-        do lock_rwlock_in_mode(&y, DowngradeRead) { }\n+        lock_rwlock_in_mode(&y, DowngradeRead, || { });\n         test_rwlock_exclusion(&y, Write, Write);\n     }\n     #[test]\n     fn test_rwlock_read_recursive() {\n         let x = RWLock::new();\n-        do x.read { do x.read { } }\n+        x.read(|| { x.read(|| { }) })\n     }\n     #[test]\n     fn test_rwlock_cond_wait() {\n         // As test_mutex_cond_wait above.\n         let x = RWLock::new();\n \n         // Child wakes up parent\n-        do x.write_cond |cond| {\n+        x.write_cond(|cond| {\n             let x2 = x.clone();\n             do task::spawn {\n-                do x2.write_cond |cond| {\n+                x2.write_cond(|cond| {\n                     let woken = cond.signal();\n                     assert!(woken);\n-                }\n+                })\n             }\n             cond.wait();\n-        }\n+        });\n         // Parent wakes up child\n         let (port, chan) = comm::stream();\n         let x3 = x.clone();\n         do task::spawn {\n-            do x3.write_cond |cond| {\n+            x3.write_cond(|cond| {\n                 chan.send(());\n                 cond.wait();\n                 chan.send(());\n-            }\n+            })\n         }\n         let _ = port.recv(); // Wait until child gets in the rwlock\n-        do x.read { } // Must be able to get in as a reader in the meantime\n-        do x.write_cond |cond| { // Or as another writer\n+        x.read(|| { }); // Must be able to get in as a reader in the meantime\n+        x.write_cond(|cond| { // Or as another writer\n             let woken = cond.signal();\n             assert!(woken);\n-        }\n+        });\n         let _ = port.recv(); // Wait until child wakes up\n-        do x.read { } // Just for good measure\n+        x.read(|| { }); // Just for good measure\n     }\n     #[cfg(test)]\n     fn test_rwlock_cond_broadcast_helper(num_waiters: uint,\n@@ -1201,35 +1203,35 @@ mod tests {\n         // Much like the mutex broadcast test. Downgrade-enabled.\n         fn lock_cond(x: &RWLock, downgrade: bool, blk: |c: &Condvar|) {\n             if downgrade {\n-                do x.write_downgrade |mode| {\n-                    do mode.write_cond |c| { blk(c) }\n-                }\n+                x.write_downgrade(|mode| {\n+                    mode.write_cond(|c| { blk(c) });\n+                });\n             } else {\n-                do x.write_cond |c| { blk(c) }\n+                x.write_cond(|c| { blk(c) });\n             }\n         }\n         let x = RWLock::new();\n         let mut ports = ~[];\n \n-        do num_waiters.times {\n+        num_waiters.times(|| {\n             let xi = x.clone();\n             let (port, chan) = comm::stream();\n             ports.push(port);\n             do task::spawn {\n-                do lock_cond(&xi, dg1) |cond| {\n+                lock_cond(&xi, dg1, |cond| {\n                     chan.send(());\n                     cond.wait();\n                     chan.send(());\n-                }\n+                })\n             }\n-        }\n+        });\n \n         // wait until all children get in the mutex\n         for port in ports.iter() { let _ = port.recv(); }\n-        do lock_cond(&x, dg2) |cond| {\n+        lock_cond(&x, dg2, |cond| {\n             let num_woken = cond.broadcast();\n             assert_eq!(num_woken, num_waiters);\n-        }\n+        });\n         // wait until all children wake up\n         for port in ports.iter() { let _ = port.recv(); }\n     }\n@@ -1251,13 +1253,13 @@ mod tests {\n         let x2 = x.clone();\n \n         let result: result::Result<(), ~Any> = do task::try || {\n-            do lock_rwlock_in_mode(&x2, mode1) {\n+            lock_rwlock_in_mode(&x2, mode1, || {\n                 fail!();\n-            }\n+            })\n         };\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n-        do lock_rwlock_in_mode(&x, mode2) { }\n+        lock_rwlock_in_mode(&x, mode2, || { })\n     }\n     #[test]\n     fn test_rwlock_reader_killed_writer() {\n@@ -1295,12 +1297,12 @@ mod tests {\n         // Tests that you can't downgrade with a different rwlock's token.\n         let x = RWLock::new();\n         let y = RWLock::new();\n-        do x.write_downgrade |xwrite| {\n+        x.write_downgrade(|xwrite| {\n             let mut xopt = Some(xwrite);\n-            do y.write_downgrade |_ywrite| {\n+            y.write_downgrade(|_ywrite| {\n                 y.downgrade(xopt.take_unwrap());\n                 error!(\"oops, y.downgrade(x) should have failed!\");\n-            }\n-        }\n+            })\n+        })\n     }\n }"}, {"sha": "bda6935643f04ad514f111d4d437dde64ed559c8", "filename": "src/libextra/task_pool.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftask_pool.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -53,11 +53,11 @@ impl<T> TaskPool<T> {\n                -> TaskPool<T> {\n         assert!(n_tasks >= 1);\n \n-        let channels = do vec::from_fn(n_tasks) |i| {\n+        let channels = vec::from_fn(n_tasks, |i| {\n             let (port, chan) = comm::stream::<Msg<T>>();\n             let init_fn = init_fn_factory();\n \n-            let task_body: proc() = || {\n+            let task_body: proc() = proc() {\n                 let local_data = init_fn(i);\n                 loop {\n                     match port.recv() {\n@@ -81,7 +81,7 @@ impl<T> TaskPool<T> {\n             }\n \n             chan\n-        };\n+        });\n \n         return TaskPool { channels: channels, next_index: 0 };\n     }\n@@ -98,11 +98,11 @@ impl<T> TaskPool<T> {\n #[test]\n fn test_task_pool() {\n     let f: || -> proc(uint) -> uint = || {\n-        let g: proc(uint) -> uint = |i| i;\n+        let g: proc(uint) -> uint = proc(i) i;\n         g\n     };\n     let mut pool = TaskPool::new(4, Some(SingleThreaded), f);\n-    do 8.times {\n-        pool.execute(|i| println!(\"Hello from thread {}!\", *i));\n-    }\n+    8.times(|| {\n+        pool.execute(proc(i) println!(\"Hello from thread {}!\", *i));\n+    })\n }"}, {"sha": "aace15ee7a6714cdc18e5b8f43f7af85a0315647", "filename": "src/libextra/term.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterm.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -220,9 +220,9 @@ impl<T: Writer> Terminal<T> {\n                 cap = self.ti.strings.find_equiv(&(\"op\"));\n             }\n         }\n-        let s = do cap.map_default(Err(~\"can't find terminfo capability `sgr0`\")) |op| {\n+        let s = cap.map_default(Err(~\"can't find terminfo capability `sgr0`\"), |op| {\n             expand(*op, [], &mut Variables::new())\n-        };\n+        });\n         if s.is_ok() {\n             self.out.write(s.unwrap());\n         } else if self.num_colors > 0 {"}, {"sha": "eac450d9562f2c34fb8f267569911268f69ea962", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -494,14 +494,14 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n                     match op {\n                         FormatDigit => {\n                             let sign = if flags.sign { SignAll } else { SignNeg };\n-                            do int_to_str_bytes_common(d, radix, sign) |c| {\n+                            int_to_str_bytes_common(d, radix, sign, |c| {\n                                 s.push(c);\n-                            }\n+                            })\n                         }\n                         _ => {\n-                            do int_to_str_bytes_common(d as uint, radix, SignNone) |c| {\n+                            int_to_str_bytes_common(d as uint, radix, SignNone, |c| {\n                                 s.push(c);\n-                            }\n+                            })\n                         }\n                     };\n                     if flags.precision > s.len() {"}, {"sha": "16e9ea8ece48cdcb31233369e9e3e709fec46b88", "filename": "src/libextra/test.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -176,7 +176,7 @@ pub fn test_main(args: &[~str], tests: ~[TestDescAndFn]) {\n // semantics into parallel test runners, which in turn requires a ~[]\n // rather than a &[].\n pub fn test_main_static(args: &[~str], tests: &[TestDescAndFn]) {\n-    let owned_tests = do tests.map |t| {\n+    let owned_tests = tests.map(|t| {\n         match t.testfn {\n             StaticTestFn(f) =>\n             TestDescAndFn { testfn: StaticTestFn(f), desc: t.desc.clone() },\n@@ -188,7 +188,7 @@ pub fn test_main_static(args: &[~str], tests: &[TestDescAndFn]) {\n                 fail!(\"non-static tests passed to test::test_main_static\");\n             }\n         }\n-    };\n+    });\n     test_main(args, owned_tests)\n }\n \n@@ -730,12 +730,12 @@ fn run_tests(opts: &TestOpts,\n     callback(TeFiltered(filtered_descs));\n \n     let (filtered_tests, filtered_benchs_and_metrics) =\n-        do filtered_tests.partition |e| {\n-        match e.testfn {\n-            StaticTestFn(_) | DynTestFn(_) => true,\n-            _ => false\n-        }\n-    };\n+        filtered_tests.partition(|e| {\n+            match e.testfn {\n+                StaticTestFn(_) | DynTestFn(_) => true,\n+                _ => false\n+            }\n+        });\n \n     // It's tempting to just spawn all the tests at once, but since we have\n     // many tests that run in other processes we would be making a big mess.\n@@ -912,7 +912,7 @@ pub fn run_test(force_ignore: bool,\n             return;\n         }\n         DynTestFn(f) => run_test_inner(desc, monitor_ch, f),\n-        StaticTestFn(f) => run_test_inner(desc, monitor_ch, || f())\n+        StaticTestFn(f) => run_test_inner(desc, monitor_ch, proc() f())\n     }\n }\n \n@@ -1044,12 +1044,12 @@ impl MetricMap {\n         };\n \n         let diff : MetricDiff = self.compare_to_old(&old, pct);\n-        let ok = do diff.iter().all() |(_, v)| {\n+        let ok = diff.iter().all(|(_, v)| {\n             match *v {\n                 Regression(_) => false,\n                 _ => true\n             }\n-        };\n+        });\n \n         if ok {\n             debug!(\"rewriting file '{:?}' with updated metrics\", p);\n@@ -1209,7 +1209,7 @@ mod tests {\n                 ignore: true,\n                 should_fail: false\n             },\n-            testfn: DynTestFn(|| f()),\n+            testfn: DynTestFn(proc() f()),\n         };\n         let (p, ch) = stream();\n         let ch = SharedChan::new(ch);\n@@ -1227,7 +1227,7 @@ mod tests {\n                 ignore: true,\n                 should_fail: false\n             },\n-            testfn: DynTestFn(|| f()),\n+            testfn: DynTestFn(proc() f()),\n         };\n         let (p, ch) = stream();\n         let ch = SharedChan::new(ch);\n@@ -1245,7 +1245,7 @@ mod tests {\n                 ignore: false,\n                 should_fail: true\n             },\n-            testfn: DynTestFn(|| f()),\n+            testfn: DynTestFn(proc() f()),\n         };\n         let (p, ch) = stream();\n         let ch = SharedChan::new(ch);\n@@ -1263,7 +1263,7 @@ mod tests {\n                 ignore: false,\n                 should_fail: true\n             },\n-            testfn: DynTestFn(|| f()),\n+            testfn: DynTestFn(proc() f()),\n         };\n         let (p, ch) = stream();\n         let ch = SharedChan::new(ch);\n@@ -1318,15 +1318,15 @@ mod tests {\n                     ignore: true,\n                     should_fail: false,\n                 },\n-                testfn: DynTestFn(|| {}),\n+                testfn: DynTestFn(proc() {}),\n             },\n             TestDescAndFn {\n                 desc: TestDesc {\n                     name: StaticTestName(\"2\"),\n                     ignore: false,\n                     should_fail: false\n                 },\n-                testfn: DynTestFn(|| {}),\n+                testfn: DynTestFn(proc() {}),\n             },\n         ];\n         let filtered = filter_tests(&opts, tests);"}, {"sha": "1352bfd424f680e3c79277c947324e6bbbc28cb9", "filename": "src/libextra/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -969,9 +969,9 @@ mod tests {\n             // Windows does not understand \"America/Los_Angeles\".\n             // PST+08 may look wrong, but not! \"PST\" indicates\n             // the name of timezone. \"+08\" means UTC = local + 08.\n-            do \"TZ=PST+08\".with_c_str |env| {\n+            \"TZ=PST+08\".with_c_str(|env| {\n                 _putenv(env);\n-            }\n+            })\n         }\n         tzset();\n     }"}, {"sha": "cf63c63c942a1365ee861b6595fb62f8ed62ffde", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -394,15 +394,15 @@ impl<'self, T> Iterator<&'self T> for TreeSetIterator<'self, T> {\n     /// Advance the iterator to the next node (in order). If there are no more nodes, return `None`.\n     #[inline]\n     fn next(&mut self) -> Option<&'self T> {\n-        do self.iter.next().map |(value, _)| { value }\n+        self.iter.next().map(|(value, _)| value)\n     }\n }\n \n impl<'self, T> Iterator<&'self T> for TreeSetRevIterator<'self, T> {\n     /// Advance the iterator to the next node (in order). If there are no more nodes, return `None`.\n     #[inline]\n     fn next(&mut self) -> Option<&'self T> {\n-        do self.iter.next().map |(value, _)| { value }\n+        self.iter.next().map(|(value, _)| value)\n     }\n }\n \n@@ -1027,8 +1027,8 @@ mod test_treemap {\n \n         let mut rng: rand::IsaacRng = rand::SeedableRng::from_seed(&[42]);\n \n-        do 3.times {\n-            do 90.times {\n+        3.times(|| {\n+            90.times(|| {\n                 let k = rng.gen();\n                 let v = rng.gen();\n                 if !ctrl.iter().any(|x| x == &(k, v)) {\n@@ -1037,16 +1037,16 @@ mod test_treemap {\n                     check_structure(&map);\n                     check_equal(ctrl, &map);\n                 }\n-            }\n+            });\n \n-            do 30.times {\n+            30.times(|| {\n                 let r = rng.gen_range(0, ctrl.len());\n                 let (key, _) = ctrl.remove(r);\n                 assert!(map.remove(&key));\n                 check_structure(&map);\n                 check_equal(ctrl, &map);\n-            }\n-        }\n+            });\n+        })\n     }\n \n     #[test]\n@@ -1414,11 +1414,11 @@ mod test_set {\n         for y in b.iter() { assert!(set_b.insert(*y)) }\n \n         let mut i = 0;\n-        do f(&set_a, &set_b) |x| {\n+        f(&set_a, &set_b, |x| {\n             assert_eq!(*x, expected[i]);\n             i += 1;\n             true\n-        };\n+        });\n         assert_eq!(i, expected.len());\n     }\n "}, {"sha": "d40eef732f112086d69e9349372e0867b9f5304f", "filename": "src/libextra/uuid.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fuuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fuuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuuid.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -811,24 +811,24 @@ mod bench {\n \n     #[bench]\n     pub fn create_uuids(bh: &mut BenchHarness) {\n-        do bh.iter {\n+        bh.iter(|| {\n             Uuid::new_v4();\n-        }\n+        })\n     }\n \n     #[bench]\n     pub fn uuid_to_str(bh: &mut BenchHarness) {\n         let u = Uuid::new_v4();\n-        do bh.iter {\n+        bh.iter(|| {\n             u.to_str();\n-        }\n+        })\n     }\n \n     #[bench]\n     pub fn parse_str(bh: &mut BenchHarness) {\n         let s = \"urn:uuid:F9168C5E-CEB2-4faa-B6BF-329BF39FA1E4\";\n-        do bh.iter {\n+        bh.iter(|| {\n             Uuid::parse_string(s);\n-        }\n+        })\n     }\n }"}, {"sha": "beb211339083dcce2bd8560a334b06f2f6ef36be", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -373,15 +373,15 @@ impl<'self> Prep<'self> {\n             None => fail!(\"missing freshness-function for '{}'\", kind),\n             Some(f) => (*f)(name, val)\n         };\n-        do self.ctxt.logger.write |lg| {\n+        self.ctxt.logger.write(|lg| {\n             if fresh {\n                 lg.info(format!(\"{} {}:{} is fresh\",\n                              cat, kind, name));\n             } else {\n                 lg.info(format!(\"{} {}:{} is not fresh\",\n                              cat, kind, name))\n             }\n-        };\n+        });\n         fresh\n     }\n \n@@ -411,9 +411,9 @@ impl<'self> Prep<'self> {\n \n         debug!(\"exec_work: looking up {} and {:?}\", self.fn_name,\n                self.declared_inputs);\n-        let cached = do self.ctxt.db.read |db| {\n+        let cached = self.ctxt.db.read(|db| {\n             db.prepare(self.fn_name, &self.declared_inputs)\n-        };\n+        });\n \n         match cached {\n             Some((ref disc_in, ref disc_out, ref res))\n@@ -432,7 +432,7 @@ impl<'self> Prep<'self> {\n                 let blk = bo.take_unwrap();\n                 let chan = Cell::new(chan);\n \n-// What happens if the task fails?\n+                // XXX: What happens if the task fails?\n                 do task::spawn {\n                     let mut exe = Exec {\n                         discovered_inputs: WorkMap::new(),\n@@ -467,13 +467,13 @@ impl<'self, T:Send +\n             WorkFromTask(prep, port) => {\n                 let (exe, v) = port.recv();\n                 let s = json_encode(&v);\n-                do prep.ctxt.db.write |db| {\n+                prep.ctxt.db.write(|db| {\n                     db.cache(prep.fn_name,\n                              &prep.declared_inputs,\n                              &exe.discovered_inputs,\n                              &exe.discovered_outputs,\n-                             s);\n-                }\n+                             s)\n+                });\n                 v\n             }\n         }\n@@ -507,7 +507,7 @@ fn test() {\n                           RWArc::new(Logger::new()),\n                           Arc::new(TreeMap::new()));\n \n-    let s = do cx.with_prep(\"test1\") |prep| {\n+    let s = cx.with_prep(\"test1\", |prep| {\n \n         let subcx = cx.clone();\n         let pth = pth.clone();\n@@ -529,7 +529,7 @@ fn test() {\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             out.as_str().unwrap().to_owned()\n         }\n-    };\n+    });\n \n     println(s);\n }"}, {"sha": "adc3712bf0f97b157e8c22aaf0c06b9f93355fc8", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -72,13 +72,13 @@ pub fn WriteOutputFile(\n         Output: &Path,\n         FileType: lib::llvm::FileType) {\n     unsafe {\n-        do Output.with_c_str |Output| {\n+        Output.with_c_str(|Output| {\n             let result = llvm::LLVMRustWriteOutputFile(\n                     Target, PM, M, Output, FileType);\n             if !result {\n                 llvm_err(sess, ~\"Could not write output\");\n             }\n-        }\n+        })\n     }\n }\n \n@@ -130,12 +130,12 @@ pub mod jit {\n             for cratepath in r.iter() {\n                 debug!(\"linking: {}\", cratepath.display());\n \n-                do cratepath.with_c_str |buf_t| {\n+                cratepath.with_c_str(|buf_t| {\n                     if !llvm::LLVMRustLoadCrate(manager, buf_t) {\n                         llvm_err(sess, ~\"Could not link\");\n                     }\n                     debug!(\"linked: {}\", cratepath.display());\n-                }\n+                })\n             }\n \n             // We custom-build a JIT execution engine via some rust wrappers\n@@ -149,9 +149,9 @@ pub mod jit {\n             // Next, we need to get a handle on the _rust_main function by\n             // looking up it's corresponding ValueRef and then requesting that\n             // the execution engine compiles the function.\n-            let fun = do \"_rust_main\".with_c_str |entry| {\n+            let fun = \"_rust_main\".with_c_str(|entry| {\n                 llvm::LLVMGetNamedFunction(m, entry)\n-            };\n+            });\n             if fun.is_null() {\n                 llvm::LLVMDisposeExecutionEngine(ee);\n                 llvm::LLVMContextDispose(c);\n@@ -248,9 +248,9 @@ pub mod write {\n             llvm::LLVMInitializeMipsAsmParser();\n \n             if sess.opts.save_temps {\n-                do output.with_extension(\"no-opt.bc\").with_c_str |buf| {\n+                output.with_extension(\"no-opt.bc\").with_c_str(|buf| {\n                     llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-                }\n+                })\n             }\n \n             configure_llvm(sess);\n@@ -263,9 +263,9 @@ pub mod write {\n             };\n             let use_softfp = sess.opts.debugging_opts & session::use_softfp != 0;\n \n-            let tm = do sess.targ_cfg.target_strs.target_triple.with_c_str |T| {\n-                do sess.opts.target_cpu.with_c_str |CPU| {\n-                    do sess.opts.target_feature.with_c_str |Features| {\n+            let tm = sess.targ_cfg.target_strs.target_triple.with_c_str(|T| {\n+                sess.opts.target_cpu.with_c_str(|CPU| {\n+                    sess.opts.target_feature.with_c_str(|Features| {\n                         llvm::LLVMRustCreateTargetMachine(\n                             T, CPU, Features,\n                             lib::llvm::CodeModelDefault,\n@@ -274,9 +274,9 @@ pub mod write {\n                             true,\n                             use_softfp\n                         )\n-                    }\n-                }\n-            };\n+                    })\n+                })\n+            });\n \n             // Create the two optimizing pass managers. These mirror what clang\n             // does, and are by populated by LLVM's default PassManagerBuilder.\n@@ -288,7 +288,7 @@ pub mod write {\n             // If we're verifying or linting, add them to the function pass\n             // manager.\n             let addpass = |pass: &str| {\n-                do pass.with_c_str |s| { llvm::LLVMRustAddPass(fpm, s) }\n+                pass.with_c_str(|s| llvm::LLVMRustAddPass(fpm, s))\n             };\n             if !sess.no_verify() { assert!(addpass(\"verify\")); }\n             if sess.lint_llvm()  { assert!(addpass(\"lint\"));   }\n@@ -300,11 +300,11 @@ pub mod write {\n             }\n \n             for pass in sess.opts.custom_passes.iter() {\n-                do pass.with_c_str |s| {\n+                pass.with_c_str(|s| {\n                     if !llvm::LLVMRustAddPass(mpm, s) {\n                         sess.warn(format!(\"Unknown pass {}, ignoring\", *pass));\n                     }\n-                }\n+                })\n             }\n \n             // Finally, run the actual optimization passes\n@@ -316,9 +316,9 @@ pub mod write {\n             llvm::LLVMDisposePassManager(mpm);\n \n             if sess.opts.save_temps {\n-                do output.with_extension(\"bc\").with_c_str |buf| {\n+                output.with_extension(\"bc\").with_c_str(|buf| {\n                     llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-                }\n+                })\n             }\n \n             if sess.opts.jit {\n@@ -337,14 +337,14 @@ pub mod write {\n                 match output_type {\n                     output_type_none => {}\n                     output_type_bitcode => {\n-                        do output.with_c_str |buf| {\n+                        output.with_c_str(|buf| {\n                             llvm::LLVMWriteBitcodeToFile(llmod, buf);\n-                        }\n+                        })\n                     }\n                     output_type_llvm_assembly => {\n-                        do output.with_c_str |output| {\n+                        output.with_c_str(|output| {\n                             llvm::LLVMRustPrintModule(cpm, llmod, output)\n-                        }\n+                        })\n                     }\n                     output_type_assembly => {\n                         WriteOutputFile(sess, tm, cpm, llmod, output, lib::llvm::AssemblyFile);\n@@ -415,9 +415,9 @@ pub mod write {\n             add(*arg);\n         }\n \n-        do llvm_args.as_imm_buf |p, len| {\n+        llvm_args.as_imm_buf(|p, len| {\n             llvm::LLVMRustSetLLVMOptions(len as c_int, p);\n-        }\n+        })\n     }\n \n     unsafe fn populate_llvm_passes(fpm: lib::llvm::PassManagerRef,\n@@ -736,7 +736,7 @@ pub fn sanitize(s: &str) -> ~str {\n \n             _ => {\n                 let mut tstr = ~\"\";\n-                do char::escape_unicode(c) |c| { tstr.push_char(c); }\n+                char::escape_unicode(c, |c| tstr.push_char(c));\n                 result.push_char('$');\n                 result.push_str(tstr.slice_from(1));\n             }"}, {"sha": "d8d868d847325aa4bc83bb0ae8e20c64c95e213c", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -123,10 +123,10 @@ pub fn build_configuration(sess: Session) ->\n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n fn parse_cfgspecs(cfgspecs: ~[~str], demitter: @diagnostic::Emitter)\n                   -> ast::CrateConfig {\n-    do cfgspecs.move_iter().map |s| {\n+    cfgspecs.move_iter().map(|s| {\n         let sess = parse::new_parse_sess(Some(demitter));\n         parse::parse_meta_from_source_str(@\"cfgspec\", s.to_managed(), ~[], sess)\n-    }.collect::<ast::CrateConfig>()\n+    }).collect::<ast::CrateConfig>()\n }\n \n pub enum input {"}, {"sha": "1602cbb6a9bafb2f7e466e6f94eaff56073b997c", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -13,16 +13,14 @@ use syntax::fold::ast_fold;\n use syntax::{ast, fold, attr};\n \n struct Context<'self> {\n-    in_cfg: &'self fn(attrs: &[ast::Attribute]) -> bool,\n+    in_cfg: 'self |attrs: &[ast::Attribute]| -> bool,\n }\n \n // Support conditional compilation by transforming the AST, stripping out\n // any items that do not belong in the current configuration\n pub fn strip_unconfigured_items(crate: ast::Crate) -> ast::Crate {\n     let config = crate.config.clone();\n-    do strip_items(crate) |attrs| {\n-        in_cfg(config, attrs)\n-    }\n+    strip_items(crate, |attrs| in_cfg(config, attrs))\n }\n \n impl<'self> fold::ast_fold for Context<'self> {\n@@ -68,14 +66,12 @@ fn filter_view_item<'r>(cx: &Context, view_item: &'r ast::view_item)\n }\n \n fn fold_mod(cx: &Context, m: &ast::_mod) -> ast::_mod {\n-    let filtered_items = do m.items.iter().filter_map |a| {\n+    let filtered_items = m.items.iter().filter_map(|a| {\n         filter_item(cx, *a).and_then(|x| cx.fold_item(x))\n-    }.collect();\n-    let filtered_view_items = do m.view_items.iter().filter_map |a| {\n-        do filter_view_item(cx, a).map |x| {\n-            cx.fold_view_item(x)\n-        }\n-    }.collect();\n+    }).collect();\n+    let filtered_view_items = m.view_items.iter().filter_map(|a| {\n+        filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n+    }).collect();\n     ast::_mod {\n         view_items: filtered_view_items,\n         items: filtered_items\n@@ -96,11 +92,9 @@ fn fold_foreign_mod(cx: &Context, nm: &ast::foreign_mod) -> ast::foreign_mod {\n                            .iter()\n                            .filter_map(|a| filter_foreign_item(cx, *a))\n                            .collect();\n-    let filtered_view_items = do nm.view_items.iter().filter_map |a| {\n-        do filter_view_item(cx, a).map |x| {\n-            cx.fold_view_item(x)\n-        }\n-    }.collect();\n+    let filtered_view_items = nm.view_items.iter().filter_map(|a| {\n+        filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n+    }).collect();\n     ast::foreign_mod {\n         abis: nm.abis,\n         view_items: filtered_view_items,\n@@ -147,12 +141,12 @@ fn filter_stmt(cx: &Context, stmt: @ast::Stmt) -> Option<@ast::Stmt> {\n }\n \n fn fold_block(cx: &Context, b: &ast::Block) -> ast::Block {\n-    let resulting_stmts = do b.stmts.iter().filter_map |a| {\n+    let resulting_stmts = b.stmts.iter().filter_map(|a| {\n         filter_stmt(cx, *a).and_then(|stmt| cx.fold_stmt(stmt))\n-    }.collect();\n-    let filtered_view_items = do b.view_items.iter().filter_map |a| {\n+    }).collect();\n+    let filtered_view_items = b.view_items.iter().filter_map(|a| {\n         filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n-    }.collect();\n+    }).collect();\n     ast::Block {\n         view_items: filtered_view_items,\n         stmts: resulting_stmts,"}, {"sha": "4d1998c8fd722f4f9e3c778b2d1a1a571777fea1", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -118,13 +118,13 @@ impl fold::ast_fold for TestHarnessGenerator {\n         fn nomain(cx: @mut TestCtxt, item: @ast::item) -> @ast::item {\n             if !*cx.sess.building_library {\n                 @ast::item {\n-                    attrs: do item.attrs.iter().filter_map |attr| {\n+                    attrs: item.attrs.iter().filter_map(|attr| {\n                         if \"main\" != attr.name() {\n                             Some(*attr)\n                         } else {\n                             None\n                         }\n-                    }.collect(),\n+                    }).collect(),\n                     .. (*item).clone()\n                 }\n             } else {\n@@ -172,10 +172,10 @@ fn generate_test_harness(sess: session::Session, crate: ast::Crate)\n fn strip_test_functions(crate: ast::Crate) -> ast::Crate {\n     // When not compiling with --test we should not compile the\n     // #[test] functions\n-    do config::strip_items(crate) |attrs| {\n+    config::strip_items(crate, |attrs| {\n         !attr::contains_name(attrs, \"test\") &&\n         !attr::contains_name(attrs, \"bench\")\n-    }\n+    })\n }\n \n fn is_test_fn(cx: @mut TestCtxt, i: @ast::item) -> bool {\n@@ -232,13 +232,13 @@ fn is_bench_fn(i: @ast::item) -> bool {\n }\n \n fn is_ignored(cx: @mut TestCtxt, i: @ast::item) -> bool {\n-    do i.attrs.iter().any |attr| {\n+    i.attrs.iter().any(|attr| {\n         // check ignore(cfg(foo, bar))\n         \"ignore\" == attr.name() && match attr.meta_item_list() {\n             Some(ref cfgs) => attr::test_cfg(cx.config, cfgs.iter().map(|x| *x)),\n             None => true\n         }\n-    }\n+    })\n }\n \n fn should_fail(i: @ast::item) -> bool {"}, {"sha": "dc1aa1f41cbfb4708a2b238fa804ed8aad14a861", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -261,9 +261,9 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n     let odir = matches.opt_str(\"out-dir\").map(|o| Path::new(o));\n     let ofile = matches.opt_str(\"o\").map(|o| Path::new(o));\n     let cfg = build_configuration(sess);\n-    let pretty = do matches.opt_default(\"pretty\", \"normal\").map |a| {\n+    let pretty = matches.opt_default(\"pretty\", \"normal\").map(|a| {\n         parse_pretty(sess, a)\n-    };\n+    });\n     match pretty {\n       Some::<PpMode>(ppm) => {\n         pretty_print_input(sess, cfg, &input, ppm);\n@@ -345,7 +345,7 @@ pub fn monitor(f: proc(@diagnostic::Emitter)) {\n         task_builder.opts.stack_size = Some(STACK_SIZE);\n     }\n \n-    match do task_builder.try {\n+    match task_builder.try(proc() {\n         let ch = ch_capture.clone();\n         // The 'diagnostics emitter'. Every error, warning, etc. should\n         // go through this function.\n@@ -368,7 +368,7 @@ pub fn monitor(f: proc(@diagnostic::Emitter)) {\n         // Due reasons explain in #7732, if there was a jit execution context it\n         // must be consumed and passed along to our parent task.\n         back::link::jit::consume_engine()\n-    } {\n+    }) {\n         result::Ok(_) => { /* fallthrough */ }\n         result::Err(_) => {\n             // Task failed without emitting a fatal diagnostic\n@@ -403,9 +403,6 @@ pub fn main() {\n \n pub fn main_args(args: &[~str]) -> int {\n     let owned_args = args.to_owned();\n-    do monitor |demitter| {\n-        run_compiler(owned_args, demitter);\n-    }\n-\n-    return 0;\n+    monitor(proc(demitter) run_compiler(owned_args, demitter));\n+    0\n }"}, {"sha": "5de9a3894215c836ec9f5551ce7ed214cd41cacb", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -1844,9 +1844,9 @@ pub struct TargetData {\n }\n \n pub fn mk_target_data(string_rep: &str) -> TargetData {\n-    let lltd = do string_rep.with_c_str |buf| {\n+    let lltd = string_rep.with_c_str(|buf| {\n         unsafe { llvm::LLVMCreateTargetData(buf) }\n-    };\n+    });\n \n     TargetData {\n         lltd: lltd,"}, {"sha": "bc15312d98e18cdfbe076ed568580fdcaca02981", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -159,9 +159,9 @@ pub fn get_dep_hashes(cstore: &CStore) -> ~[@str] {\n         });\n     }\n \n-    let sorted = do extra::sort::merge_sort(result) |a, b| {\n+    let sorted = extra::sort::merge_sort(result, |a, b| {\n         (a.name, a.vers, a.hash) <= (b.name, b.vers, b.hash)\n-    };\n+    });\n \n     debug!(\"sorted:\");\n     for x in sorted.iter() {"}, {"sha": "cd4afdff91ef55bf8ee32cce13b98e28733e890e", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 102, "deletions": 103, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -62,19 +62,19 @@ fn lookup_hash(d: ebml::Doc, eq_fn: |&[u8]| -> bool, hash: u64) ->\n     let belt = tag_index_buckets_bucket_elt;\n \n     let mut ret = None;\n-    do reader::tagged_docs(tagged_doc.doc, belt) |elt| {\n+    reader::tagged_docs(tagged_doc.doc, belt, |elt| {\n         let pos = u64_from_be_bytes(*elt.data, elt.start, 4) as uint;\n         if eq_fn(elt.data.slice(elt.start + 4, elt.end)) {\n             ret = Some(reader::doc_at(d.data, pos).doc);\n             false\n         } else {\n             true\n         }\n-    };\n+    });\n     ret\n }\n \n-pub type GetCrateDataCb<'self> = &'self fn(ast::CrateNum) -> Cmd;\n+pub type GetCrateDataCb<'self> = 'self |ast::CrateNum| -> Cmd;\n \n pub fn maybe_find_item(item_id: int, items: ebml::Doc) -> Option<ebml::Doc> {\n     fn eq_item(bytes: &[u8], item_id: int) -> bool {\n@@ -168,10 +168,10 @@ fn item_visibility(item: ebml::Doc) -> ast::visibility {\n \n fn item_method_sort(item: ebml::Doc) -> char {\n     let mut ret = 'r';\n-    do reader::tagged_docs(item, tag_item_trait_method_sort) |doc| {\n+    reader::tagged_docs(item, tag_item_trait_method_sort, |doc| {\n         ret = doc.as_str_slice()[0] as char;\n         false\n-    };\n+    });\n     ret\n }\n \n@@ -181,10 +181,10 @@ fn item_symbol(item: ebml::Doc) -> ~str {\n \n fn item_parent_item(d: ebml::Doc) -> Option<ast::DefId> {\n     let mut ret = None;\n-    do reader::tagged_docs(d, tag_items_data_parent_item) |did| {\n+    reader::tagged_docs(d, tag_items_data_parent_item, |did| {\n         ret = Some(reader::with_doc_data(did, parse_def_id));\n         false\n-    };\n+    });\n     ret\n }\n \n@@ -200,19 +200,19 @@ fn item_def_id(d: ebml::Doc, cdata: Cmd) -> ast::DefId {\n }\n \n fn get_provided_source(d: ebml::Doc, cdata: Cmd) -> Option<ast::DefId> {\n-    do reader::maybe_get_doc(d, tag_item_method_provided_source).map |doc| {\n+    reader::maybe_get_doc(d, tag_item_method_provided_source).map(|doc| {\n         translate_def_id(cdata, reader::with_doc_data(doc, parse_def_id))\n-    }\n+    })\n }\n \n fn each_reexport(d: ebml::Doc, f: |ebml::Doc| -> bool) -> bool {\n     reader::tagged_docs(d, tag_items_data_item_reexport, f)\n }\n \n fn variant_disr_val(d: ebml::Doc) -> Option<ty::Disr> {\n-    do reader::maybe_get_doc(d, tag_disr_val).and_then |val_doc| {\n-        do reader::with_doc_data(val_doc) |data| { u64::parse_bytes(data, 10u) }\n-    }\n+    reader::maybe_get_doc(d, tag_disr_val).and_then(|val_doc| {\n+        reader::with_doc_data(val_doc, |data| u64::parse_bytes(data, 10u))\n+    })\n }\n \n fn doc_type(doc: ebml::Doc, tcx: ty::ctxt, cdata: Cmd) -> ty::t {\n@@ -231,10 +231,10 @@ fn doc_transformed_self_ty(doc: ebml::Doc,\n                            tcx: ty::ctxt,\n                            cdata: Cmd) -> Option<ty::t>\n {\n-    do reader::maybe_get_doc(doc, tag_item_method_transformed_self_ty).map |tp| {\n+    reader::maybe_get_doc(doc, tag_item_method_transformed_self_ty).map(|tp| {\n         parse_ty_data(*tp.data, cdata.cnum, tp.start, tcx,\n                       |_, did| translate_def_id(cdata, did))\n-    }\n+    })\n }\n \n pub fn item_type(_item_id: ast::DefId, item: ebml::Doc,\n@@ -258,22 +258,22 @@ fn item_ty_param_defs(item: ebml::Doc,\n                       tag: uint)\n                       -> @~[ty::TypeParameterDef] {\n     let mut bounds = ~[];\n-    do reader::tagged_docs(item, tag) |p| {\n+    reader::tagged_docs(item, tag, |p| {\n         let bd = parse_type_param_def_data(\n             *p.data, p.start, cdata.cnum, tcx,\n             |_, did| translate_def_id(cdata, did));\n         bounds.push(bd);\n         true\n-    };\n+    });\n     @bounds\n }\n \n fn item_region_param_defs(item_doc: ebml::Doc,\n                           tcx: ty::ctxt,\n                           cdata: Cmd)\n                           -> @[ty::RegionParameterDef] {\n-    do at_vec::build(None) |push| {\n-        do reader::tagged_docs(item_doc, tag_region_param_def) |rp_doc| {\n+    at_vec::build(None, |push| {\n+        reader::tagged_docs(item_doc, tag_region_param_def, |rp_doc| {\n             let ident_str_doc = reader::get_doc(rp_doc,\n                                                 tag_region_param_def_ident);\n             let ident = item_name(tcx.sess.intr(), ident_str_doc);\n@@ -284,8 +284,8 @@ fn item_region_param_defs(item_doc: ebml::Doc,\n             push(ty::RegionParameterDef { ident: ident,\n                                           def_id: def_id });\n             true\n-        };\n-    }\n+        });\n+    })\n }\n \n fn item_ty_param_count(item: ebml::Doc) -> uint {\n@@ -298,11 +298,11 @@ fn item_ty_param_count(item: ebml::Doc) -> uint {\n fn enum_variant_ids(item: ebml::Doc, cdata: Cmd) -> ~[ast::DefId] {\n     let mut ids: ~[ast::DefId] = ~[];\n     let v = tag_items_data_item_variant;\n-    do reader::tagged_docs(item, v) |p| {\n+    reader::tagged_docs(item, v, |p| {\n         let ext = reader::with_doc_data(p, parse_def_id);\n         ids.push(ast::DefId { crate: cdata.cnum, node: ext.node });\n         true\n-    };\n+    });\n     return ids;\n }\n \n@@ -313,7 +313,7 @@ pub fn item_path(item_doc: ebml::Doc) -> ast_map::path {\n     let len = reader::doc_as_u32(len_doc) as uint;\n \n     let mut result = vec::with_capacity(len);\n-    do reader::docs(path_doc) |tag, elt_doc| {\n+    reader::docs(path_doc, |tag, elt_doc| {\n         if tag == tag_path_elt_mod {\n             let str = elt_doc.as_str_slice();\n             result.push(ast_map::path_mod(token::str_to_ident(str)));\n@@ -333,7 +333,7 @@ pub fn item_path(item_doc: ebml::Doc) -> ast_map::path {\n             // ignore tag_path_len element\n         }\n         true\n-    };\n+    });\n \n     return result;\n }\n@@ -412,14 +412,14 @@ pub fn get_trait_def(cdata: Cmd,\n     let mut bounds = ty::EmptyBuiltinBounds();\n     // Collect the builtin bounds from the encoded supertraits.\n     // FIXME(#8559): They should be encoded directly.\n-    do reader::tagged_docs(item_doc, tag_item_super_trait_ref) |trait_doc| {\n+    reader::tagged_docs(item_doc, tag_item_super_trait_ref, |trait_doc| {\n         // NB. Bypasses real supertraits. See get_supertraits() if you wanted them.\n         let trait_ref = doc_trait_ref(trait_doc, tcx, cdata);\n-        do tcx.lang_items.to_builtin_kind(trait_ref.def_id).map |bound| {\n+        tcx.lang_items.to_builtin_kind(trait_ref.def_id).map(|bound| {\n             bounds.add(bound);\n-        };\n+        });\n         true\n-    };\n+    });\n     ty::TraitDef {\n         generics: ty::Generics {type_param_defs: tp_defs,\n                                 region_param_defs: rp_defs},\n@@ -455,9 +455,9 @@ pub fn get_impl_trait(cdata: Cmd,\n                       tcx: ty::ctxt) -> Option<@ty::TraitRef>\n {\n     let item_doc = lookup_item(id, cdata.data);\n-    do reader::maybe_get_doc(item_doc, tag_item_trait_ref).map |tp| {\n+    reader::maybe_get_doc(item_doc, tag_item_trait_ref).map(|tp| {\n         @doc_trait_ref(tp, tcx, cdata)\n-    }\n+    })\n }\n \n pub fn get_impl_vtables(cdata: Cmd,\n@@ -479,13 +479,13 @@ pub fn get_impl_method(intr: @ident_interner, cdata: Cmd, id: ast::NodeId,\n                        name: ast::Ident) -> Option<ast::DefId> {\n     let items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n     let mut found = None;\n-    do reader::tagged_docs(find_item(id, items), tag_item_impl_method) |mid| {\n+    reader::tagged_docs(find_item(id, items), tag_item_impl_method, |mid| {\n         let m_did = reader::with_doc_data(mid, parse_def_id);\n         if item_name(intr, find_item(m_did.node, items)) == name {\n             found = Some(translate_def_id(cdata, m_did));\n         }\n         true\n-    };\n+    });\n     found\n }\n \n@@ -512,23 +512,23 @@ pub fn def_like_to_def(def_like: DefLike) -> ast::Def {\n pub fn each_lang_item(cdata: Cmd, f: |ast::NodeId, uint| -> bool) -> bool {\n     let root = reader::Doc(cdata.data);\n     let lang_items = reader::get_doc(root, tag_lang_items);\n-    do reader::tagged_docs(lang_items, tag_lang_items_item) |item_doc| {\n+    reader::tagged_docs(lang_items, tag_lang_items_item, |item_doc| {\n         let id_doc = reader::get_doc(item_doc, tag_lang_items_item_id);\n         let id = reader::doc_as_u32(id_doc) as uint;\n         let node_id_doc = reader::get_doc(item_doc,\n                                           tag_lang_items_item_node_id);\n         let node_id = reader::doc_as_u32(node_id_doc) as ast::NodeId;\n \n         f(node_id, id)\n-    }\n+    })\n }\n \n struct EachItemContext<'self> {\n     intr: @ident_interner,\n     cdata: Cmd,\n     get_crate_data: GetCrateDataCb<'self>,\n     path_builder: &'self mut ~str,\n-    callback: &'self fn(&str, DefLike, ast::visibility) -> bool,\n+    callback: 'self |&str, DefLike, ast::visibility| -> bool,\n }\n \n impl<'self> EachItemContext<'self> {\n@@ -624,7 +624,7 @@ impl<'self> EachItemContext<'self> {\n         let mut continue_ = true;\n \n         // Iterate over all children.\n-        do reader::tagged_docs(item_doc, tag_mod_child) |child_info_doc| {\n+        reader::tagged_docs(item_doc, tag_mod_child, |child_info_doc| {\n             let child_def_id = reader::with_doc_data(child_info_doc,\n                                                      parse_def_id);\n             let child_def_id = translate_def_id(self.cdata, child_def_id);\n@@ -670,14 +670,14 @@ impl<'self> EachItemContext<'self> {\n                 }\n             }\n             continue_\n-        };\n+        });\n \n         if !continue_ {\n             return false\n         }\n \n         // Iterate over reexports.\n-        do each_reexport(item_doc) |reexport_doc| {\n+        each_reexport(item_doc, |reexport_doc| {\n             let def_id_doc = reader::get_doc(\n                 reexport_doc,\n                 tag_items_data_item_reexport_def_id);\n@@ -723,7 +723,7 @@ impl<'self> EachItemContext<'self> {\n             }\n \n             continue_\n-        };\n+        });\n \n         continue_\n     }\n@@ -737,7 +737,7 @@ fn each_child_of_item_or_crate(intr: @ident_interner,\n                                           ast::Ident,\n                                           ast::visibility|) {\n     // Iterate over all children.\n-    let _ = do reader::tagged_docs(item_doc, tag_mod_child) |child_info_doc| {\n+    let _ = reader::tagged_docs(item_doc, tag_mod_child, |child_info_doc| {\n         let child_def_id = reader::with_doc_data(child_info_doc,\n                                                  parse_def_id);\n         let child_def_id = translate_def_id(cdata, child_def_id);\n@@ -767,23 +767,23 @@ fn each_child_of_item_or_crate(intr: @ident_interner,\n         }\n \n         true\n-    };\n+    });\n \n     // As a special case, iterate over all static methods of\n     // associated implementations too. This is a bit of a botch.\n     // --pcwalton\n-    let _ = do reader::tagged_docs(item_doc,\n-                                   tag_items_data_item_inherent_impl)\n-            |inherent_impl_def_id_doc| {\n+    let _ = reader::tagged_docs(item_doc,\n+                                tag_items_data_item_inherent_impl,\n+                                |inherent_impl_def_id_doc| {\n         let inherent_impl_def_id = item_def_id(inherent_impl_def_id_doc,\n                                                cdata);\n         let items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n         match maybe_find_item(inherent_impl_def_id.node, items) {\n             None => {}\n             Some(inherent_impl_doc) => {\n-                let _ = do reader::tagged_docs(inherent_impl_doc,\n-                                               tag_item_impl_method)\n-                        |impl_method_def_id_doc| {\n+                let _ = reader::tagged_docs(inherent_impl_doc,\n+                                            tag_item_impl_method,\n+                                            |impl_method_def_id_doc| {\n                     let impl_method_def_id =\n                         reader::with_doc_data(impl_method_def_id_doc,\n                                               parse_def_id);\n@@ -812,15 +812,15 @@ fn each_child_of_item_or_crate(intr: @ident_interner,\n                     }\n \n                     true\n-                };\n+                });\n             }\n         }\n \n         true\n-    };\n+    });\n \n     // Iterate over all reexports.\n-    let _ = do each_reexport(item_doc) |reexport_doc| {\n+    let _ = each_reexport(item_doc, |reexport_doc| {\n         let def_id_doc = reader::get_doc(reexport_doc,\n                                          tag_items_data_item_reexport_def_id);\n         let child_def_id = reader::with_doc_data(def_id_doc,\n@@ -854,7 +854,7 @@ fn each_child_of_item_or_crate(intr: @ident_interner,\n         }\n \n         true\n-    };\n+    });\n }\n \n /// Iterates over each child of the given item.\n@@ -901,11 +901,11 @@ pub fn get_item_path(cdata: Cmd, id: ast::NodeId) -> ast_map::path {\n     item_path(lookup_item(id, cdata.data))\n }\n \n-pub type decode_inlined_item<'self> = &'self fn(\n-    cdata: @cstore::crate_metadata,\n-    tcx: ty::ctxt,\n-    path: ast_map::path,\n-    par_doc: ebml::Doc) -> Option<ast::inlined_item>;\n+pub type decode_inlined_item<'self> = 'self |cdata: @cstore::crate_metadata,\n+                                             tcx: ty::ctxt,\n+                                             path: ast_map::path,\n+                                             par_doc: ebml::Doc|\n+                                             -> Option<ast::inlined_item>;\n \n pub fn maybe_get_item_ast(cdata: Cmd, tcx: ty::ctxt,\n                           id: ast::NodeId,\n@@ -1002,11 +1002,11 @@ fn get_explicit_self(item: ebml::Doc) -> ast::explicit_self_ {\n fn item_impl_methods(intr: @ident_interner, cdata: Cmd, item: ebml::Doc,\n                      tcx: ty::ctxt) -> ~[@ty::Method] {\n     let mut rslt = ~[];\n-    do reader::tagged_docs(item, tag_item_impl_method) |doc| {\n+    reader::tagged_docs(item, tag_item_impl_method, |doc| {\n         let m_did = reader::with_doc_data(doc, parse_def_id);\n         rslt.push(@get_method(intr, cdata, m_did.node, tcx));\n         true\n-    };\n+    });\n \n     rslt\n }\n@@ -1083,10 +1083,10 @@ pub fn get_trait_method_def_ids(cdata: Cmd,\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n-    do reader::tagged_docs(item, tag_item_trait_method) |mth| {\n+    reader::tagged_docs(item, tag_item_trait_method, |mth| {\n         result.push(item_def_id(mth, cdata));\n         true\n-    };\n+    });\n     result\n }\n \n@@ -1105,15 +1105,15 @@ pub fn get_provided_trait_methods(intr: @ident_interner, cdata: Cmd,\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n \n-    do reader::tagged_docs(item, tag_item_trait_method) |mth_id| {\n+    reader::tagged_docs(item, tag_item_trait_method, |mth_id| {\n         let did = item_def_id(mth_id, cdata);\n         let mth = lookup_item(did.node, data);\n \n         if item_method_sort(mth) == 'p' {\n             result.push(@get_method(intr, cdata, did.node, tcx));\n         }\n         true\n-    };\n+    });\n \n     return result;\n }\n@@ -1123,7 +1123,7 @@ pub fn get_supertraits(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n                     -> ~[@ty::TraitRef] {\n     let mut results = ~[];\n     let item_doc = lookup_item(id, cdata.data);\n-    do reader::tagged_docs(item_doc, tag_item_super_trait_ref) |trait_doc| {\n+    reader::tagged_docs(item_doc, tag_item_super_trait_ref, |trait_doc| {\n         // NB. Only reads the ones that *aren't* builtin-bounds. See also\n         // get_trait_def() for collecting the builtin bounds.\n         // FIXME(#8559): The builtin bounds shouldn't be encoded in the first place.\n@@ -1132,7 +1132,7 @@ pub fn get_supertraits(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n             results.push(@trait_ref);\n         }\n         true\n-    };\n+    });\n     return results;\n }\n \n@@ -1144,10 +1144,10 @@ pub fn get_type_name_if_impl(cdata: Cmd,\n     }\n \n     let mut ret = None;\n-    do reader::tagged_docs(item, tag_item_impl_type_basename) |doc| {\n+    reader::tagged_docs(item, tag_item_impl_type_basename, |doc| {\n         ret = Some(token::str_to_ident(doc.as_str_slice()));\n         false\n-    };\n+    });\n \n     ret\n }\n@@ -1162,17 +1162,17 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n     }\n \n     // If this impl implements a trait, don't consider it.\n-    let ret = do reader::tagged_docs(item, tag_item_trait_ref) |_doc| {\n+    let ret = reader::tagged_docs(item, tag_item_trait_ref, |_doc| {\n         false\n-    };\n+    });\n \n     if !ret { return None }\n \n     let mut impl_method_ids = ~[];\n-    do reader::tagged_docs(item, tag_item_impl_method) |impl_method_doc| {\n+    reader::tagged_docs(item, tag_item_impl_method, |impl_method_doc| {\n         impl_method_ids.push(reader::with_doc_data(impl_method_doc, parse_def_id));\n         true\n-    };\n+    });\n \n     let mut static_impl_methods = ~[];\n     for impl_method_id in impl_method_ids.iter() {\n@@ -1205,13 +1205,13 @@ pub fn get_item_attrs(cdata: Cmd,\n                       node_id: ast::NodeId,\n                       f: |~[@ast::MetaItem]|) {\n     let item = lookup_item(node_id, cdata.data);\n-    do reader::tagged_docs(item, tag_attributes) |attributes| {\n-        do reader::tagged_docs(attributes, tag_attribute) |attribute| {\n+    reader::tagged_docs(item, tag_attributes, |attributes| {\n+        reader::tagged_docs(attributes, tag_attribute, |attribute| {\n             f(get_meta_items(attribute));\n             true\n-        };\n+        });\n         true\n-    };\n+    });\n }\n \n fn struct_field_family_to_visibility(family: Family) -> ast::visibility {\n@@ -1228,7 +1228,7 @@ pub fn get_struct_fields(intr: @ident_interner, cdata: Cmd, id: ast::NodeId)\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n-    do reader::tagged_docs(item, tag_item_field) |an_item| {\n+    reader::tagged_docs(item, tag_item_field, |an_item| {\n         let f = item_family(an_item);\n         if f == PublicField || f == PrivateField || f == InheritedField {\n             // FIXME #6993: name should be of type Name, not Ident\n@@ -1241,16 +1241,16 @@ pub fn get_struct_fields(intr: @ident_interner, cdata: Cmd, id: ast::NodeId)\n             });\n         }\n         true\n-    };\n-    do reader::tagged_docs(item, tag_item_unnamed_field) |an_item| {\n+    });\n+    reader::tagged_docs(item, tag_item_unnamed_field, |an_item| {\n         let did = item_def_id(an_item, cdata);\n         result.push(ty::field_ty {\n             name: special_idents::unnamed_field.name,\n             id: did,\n             vis: ast::inherited,\n         });\n         true\n-    };\n+    });\n     result\n }\n \n@@ -1272,13 +1272,13 @@ fn family_names_type(fam: Family) -> bool {\n }\n \n fn read_path(d: ebml::Doc) -> (~str, uint) {\n-    do reader::with_doc_data(d) |desc| {\n+    reader::with_doc_data(d, |desc| {\n         let pos = u64_from_be_bytes(desc, 0u, 4u) as uint;\n         let pathbytes = desc.slice(4u, desc.len());\n         let path = str::from_utf8(pathbytes);\n \n         (path, pos)\n-    }\n+    })\n }\n \n fn describe_def(items: ebml::Doc, id: ast::DefId) -> ~str {\n@@ -1317,13 +1317,13 @@ fn item_family_to_str(fam: Family) -> ~str {\n \n fn get_meta_items(md: ebml::Doc) -> ~[@ast::MetaItem] {\n     let mut items: ~[@ast::MetaItem] = ~[];\n-    do reader::tagged_docs(md, tag_meta_item_word) |meta_item_doc| {\n+    reader::tagged_docs(md, tag_meta_item_word, |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = nd.as_str_slice().to_managed();\n         items.push(attr::mk_word_item(n));\n         true\n-    };\n-    do reader::tagged_docs(md, tag_meta_item_name_value) |meta_item_doc| {\n+    });\n+    reader::tagged_docs(md, tag_meta_item_name_value, |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let vd = reader::get_doc(meta_item_doc, tag_meta_item_value);\n         let n = nd.as_str_slice().to_managed();\n@@ -1332,22 +1332,22 @@ fn get_meta_items(md: ebml::Doc) -> ~[@ast::MetaItem] {\n         // but currently the encoder just drops them\n         items.push(attr::mk_name_value_item_str(n, v));\n         true\n-    };\n-    do reader::tagged_docs(md, tag_meta_item_list) |meta_item_doc| {\n+    });\n+    reader::tagged_docs(md, tag_meta_item_list, |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = nd.as_str_slice().to_managed();\n         let subitems = get_meta_items(meta_item_doc);\n         items.push(attr::mk_list_item(n, subitems));\n         true\n-    };\n+    });\n     return items;\n }\n \n fn get_attributes(md: ebml::Doc) -> ~[ast::Attribute] {\n     let mut attrs: ~[ast::Attribute] = ~[];\n     match reader::maybe_get_doc(md, tag_attributes) {\n       option::Some(attrs_d) => {\n-        do reader::tagged_docs(attrs_d, tag_attribute) |attr_doc| {\n+        reader::tagged_docs(attrs_d, tag_attribute, |attr_doc| {\n             let meta_items = get_meta_items(attr_doc);\n             // Currently it's only possible to have a single meta item on\n             // an attribute\n@@ -1363,7 +1363,7 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::Attribute] {\n                     span: codemap::dummy_sp()\n                 });\n             true\n-        };\n+        });\n       }\n       option::None => ()\n     }\n@@ -1412,14 +1412,14 @@ pub fn get_crate_deps(data: @~[u8]) -> ~[CrateDep] {\n         let d = reader::get_doc(doc, tag_);\n         d.as_str_slice().to_managed()\n     }\n-    do reader::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {\n+    reader::tagged_docs(depsdoc, tag_crate_dep, |depdoc| {\n         deps.push(CrateDep {cnum: crate_num,\n                   name: token::str_to_ident(docstr(depdoc, tag_crate_dep_name)),\n                   vers: docstr(depdoc, tag_crate_dep_vers),\n                   hash: docstr(depdoc, tag_crate_dep_hash)});\n         crate_num += 1;\n         true\n-    };\n+    });\n     return deps;\n }\n \n@@ -1477,36 +1477,37 @@ pub fn translate_def_id(cdata: Cmd, did: ast::DefId) -> ast::DefId {\n \n pub fn each_impl(cdata: Cmd, callback: |ast::DefId|) {\n     let impls_doc = reader::get_doc(reader::Doc(cdata.data), tag_impls);\n-    let _ = do reader::tagged_docs(impls_doc, tag_impls_impl) |impl_doc| {\n+    let _ = reader::tagged_docs(impls_doc, tag_impls_impl, |impl_doc| {\n         callback(item_def_id(impl_doc, cdata));\n         true\n-    };\n+    });\n }\n \n pub fn each_implementation_for_type(cdata: Cmd,\n                                     id: ast::NodeId,\n                                     callback: |ast::DefId|) {\n     let item_doc = lookup_item(id, cdata.data);\n-    do reader::tagged_docs(item_doc, tag_items_data_item_inherent_impl)\n-            |impl_doc| {\n+    reader::tagged_docs(item_doc,\n+                        tag_items_data_item_inherent_impl,\n+                        |impl_doc| {\n         let implementation_def_id = item_def_id(impl_doc, cdata);\n         callback(implementation_def_id);\n         true\n-    };\n+    });\n }\n \n pub fn each_implementation_for_trait(cdata: Cmd,\n                                      id: ast::NodeId,\n                                      callback: |ast::DefId|) {\n     let item_doc = lookup_item(id, cdata.data);\n \n-    let _ = do reader::tagged_docs(item_doc,\n-                                   tag_items_data_item_extension_impl)\n-            |impl_doc| {\n+    let _ = reader::tagged_docs(item_doc,\n+                                tag_items_data_item_extension_impl,\n+                                |impl_doc| {\n         let implementation_def_id = item_def_id(impl_doc, cdata);\n         callback(implementation_def_id);\n         true\n-    };\n+    });\n }\n \n pub fn get_trait_of_method(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n@@ -1521,10 +1522,8 @@ pub fn get_trait_of_method(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n     match item_family(parent_item_doc) {\n         Trait => Some(item_def_id(parent_item_doc, cdata)),\n         Impl => {\n-            do reader::maybe_get_doc(parent_item_doc, tag_item_trait_ref).map\n-                    |_| {\n-                item_trait_ref(parent_item_doc, tcx, cdata).def_id\n-            }\n+            reader::maybe_get_doc(parent_item_doc, tag_item_trait_ref)\n+                .map(|_| item_trait_ref(parent_item_doc, tcx, cdata).def_id)\n         }\n         _ => None\n     }"}, {"sha": "8f09353796b7e121b9ab6d6680be8d98d7d40c41", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -52,10 +52,10 @@ use std::cast;\n // used by astencode:\n type abbrev_map = @mut HashMap<ty::t, tyencode::ty_abbrev>;\n \n-pub type encode_inlined_item<'self> = &'self fn(ecx: &EncodeContext,\n-                                   ebml_w: &mut writer::Encoder,\n-                                   path: &[ast_map::path_elt],\n-                                   ii: ast::inlined_item);\n+pub type encode_inlined_item<'self> = 'self |ecx: &EncodeContext,\n+                                             ebml_w: &mut writer::Encoder,\n+                                             path: &[ast_map::path_elt],\n+                                             ii: ast::inlined_item|;\n \n pub struct EncodeParams<'self> {\n     diag: @mut span_handler,\n@@ -615,12 +615,12 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n         ebml_w.wr_str(def_to_str(local_def(item.id)));\n         ebml_w.end_tag();\n \n-        do each_auxiliary_node_id(*item) |auxiliary_node_id| {\n+        each_auxiliary_node_id(*item, |auxiliary_node_id| {\n             ebml_w.start_tag(tag_mod_child);\n             ebml_w.wr_str(def_to_str(local_def(auxiliary_node_id)));\n             ebml_w.end_tag();\n             true\n-        };\n+        });\n \n         match item.node {\n             item_impl(*) => {\n@@ -1570,13 +1570,13 @@ fn encode_crate_deps(ecx: &EncodeContext,\n \n         // Pull the cnums and name,vers,hash out of cstore\n         let mut deps = ~[];\n-        do cstore::iter_crate_data(cstore) |key, val| {\n+        cstore::iter_crate_data(cstore, |key, val| {\n             let dep = decoder::CrateDep {cnum: key,\n                        name: ecx.tcx.sess.ident_of(val.name),\n                        vers: decoder::get_crate_vers(val.data),\n                        hash: decoder::get_crate_hash(val.data)};\n             deps.push(dep);\n-        };\n+        });\n \n         // Sort by cnum\n         extra::sort::quick_sort(deps, |kv1, kv2| kv1.cnum <= kv2.cnum);\n@@ -1697,12 +1697,12 @@ fn encode_misc_info(ecx: &EncodeContext,\n         ebml_w.wr_str(def_to_str(local_def(item.id)));\n         ebml_w.end_tag();\n \n-        do each_auxiliary_node_id(item) |auxiliary_node_id| {\n+        each_auxiliary_node_id(item, |auxiliary_node_id| {\n             ebml_w.start_tag(tag_mod_child);\n             ebml_w.wr_str(def_to_str(local_def(auxiliary_node_id)));\n             ebml_w.end_tag();\n             true\n-        };\n+        });\n     }\n \n     // Encode reexports for the root module."}, {"sha": "b2e5888eee1a50d70076b3a02bb9978e4618beb2", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -23,7 +23,7 @@ pub enum FileMatch { FileMatches, FileDoesntMatch }\n \n /// Functions with type `pick` take a parent directory as well as\n /// a file found in that directory.\n-pub type pick<'self> = &'self fn(path: &Path) -> FileMatch;\n+pub type pick<'self> = 'self |path: &Path| -> FileMatch;\n \n pub fn pick_file(file: Path, path: &Path) -> Option<Path> {\n     if path.filename() == Some(file.as_vec()) {\n@@ -118,7 +118,7 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n }\n \n pub fn search(filesearch: @FileSearch, pick: pick) {\n-    do filesearch.for_each_lib_search_path() |lib_search_path| {\n+    filesearch.for_each_lib_search_path(|lib_search_path| {\n         debug!(\"searching {}\", lib_search_path.display());\n         match io::result(|| fs::readdir(lib_search_path)) {\n             Ok(files) => {\n@@ -140,7 +140,7 @@ pub fn search(filesearch: @FileSearch, pick: pick) {\n             }\n             Err(*) => FileDoesntMatch,\n         }\n-    };\n+    });\n }\n \n pub fn relative_target_lib_path(target_triple: &str) -> Path {"}, {"sha": "ecd1c8985bd00dc52404f3aa9e4eb71bfd67737f", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -193,17 +193,15 @@ pub fn metadata_matches(extern_metas: &[@ast::MetaItem],\n     debug!(\"matching {} metadata requirements against {} items\",\n            local_metas.len(), extern_metas.len());\n \n-    do local_metas.iter().all |needed| {\n-        attr::contains(extern_metas, *needed)\n-    }\n+    local_metas.iter().all(|needed| attr::contains(extern_metas, *needed))\n }\n \n fn get_metadata_section(os: Os,\n                         filename: &Path) -> Option<@~[u8]> {\n     unsafe {\n-        let mb = do filename.with_c_str |buf| {\n+        let mb = filename.with_c_str(|buf| {\n             llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n-        };\n+        });\n         if mb as int == 0 { return option::None::<@~[u8]>; }\n         let of = match mk_object_file(mb) {\n             option::Some(of) => of,\n@@ -224,19 +222,19 @@ fn get_metadata_section(os: Os,\n                        vlen);\n                 let minsz = num::min(vlen, csz);\n                 let mut version_ok = false;\n-                do vec::raw::buf_as_slice(cvbuf, minsz) |buf0| {\n+                vec::raw::buf_as_slice(cvbuf, minsz, |buf0| {\n                     version_ok = (buf0 ==\n                                   encoder::metadata_encoding_version);\n-                }\n+                });\n                 if !version_ok { return None; }\n \n                 let cvbuf1 = ptr::offset(cvbuf, vlen as int);\n                 debug!(\"inflating {} bytes of compressed metadata\",\n                        csz - vlen);\n-                do vec::raw::buf_as_slice(cvbuf1, csz-vlen) |bytes| {\n+                vec::raw::buf_as_slice(cvbuf1, csz-vlen, |bytes| {\n                     let inflated = flate::inflate_bytes(bytes);\n                     found = Some(@(inflated));\n-                }\n+                });\n                 if found != None {\n                     return found;\n                 }"}, {"sha": "27bca78b7b7255ae0ce4119d2c7460e44e2e4c09", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -54,7 +54,7 @@ pub enum DefIdSource {\n     RegionParameter,\n }\n type conv_did<'self> =\n-    &'self fn(source: DefIdSource, ast::DefId) -> ast::DefId;\n+    'self |source: DefIdSource, ast::DefId| -> ast::DefId;\n \n pub struct PState<'self> {\n     data: &'self [u8],"}, {"sha": "19a9a7efc578ae609038a6f8be044e93d72b5140", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -132,7 +132,7 @@ fn enc_opt<T>(w: @mut MemWriter, t: Option<T>, enc_f: |T|) {\n \n fn enc_substs(w: @mut MemWriter, cx: @ctxt, substs: &ty::substs) {\n     enc_region_substs(w, cx, &substs.regions);\n-    do enc_opt(w, substs.self_ty) |t| { enc_ty(w, cx, t) }\n+    enc_opt(w, substs.self_ty, |t| enc_ty(w, cx, t));\n     mywrite!(w, \"[\");\n     for t in substs.tps.iter() { enc_ty(w, cx, *t); }\n     mywrite!(w, \"]\");\n@@ -350,10 +350,10 @@ fn enc_purity(w: @mut MemWriter, p: purity) {\n \n fn enc_abi_set(w: @mut MemWriter, abis: AbiSet) {\n     mywrite!(w, \"[\");\n-    do abis.each |abi| {\n+    abis.each(|abi| {\n         mywrite!(w, \"{},\", abi.name());\n         true\n-    };\n+    });\n     mywrite!(w, \"]\")\n }\n "}, {"sha": "c0dc904b9a376e10f246cbdaccd870cbe78bf224", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 128, "deletions": 136, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -303,7 +303,7 @@ struct NestedItemsDropper {\n \n impl fold::ast_fold for NestedItemsDropper {\n     fn fold_block(&self, blk: &ast::Block) -> ast::Block {\n-        let stmts_sans_items = do blk.stmts.iter().filter_map |stmt| {\n+        let stmts_sans_items = blk.stmts.iter().filter_map(|stmt| {\n             match stmt.node {\n                 ast::StmtExpr(_, _) | ast::StmtSemi(_, _) |\n                 ast::StmtDecl(@codemap::Spanned {\n@@ -316,7 +316,7 @@ impl fold::ast_fold for NestedItemsDropper {\n                 }, _) => None,\n                 ast::StmtMac(*) => fail!(\"unexpanded macro in astencode\")\n             }\n-        }.collect();\n+        }).collect();\n         let blk_sans_items = ast::Block {\n             view_items: ~[], // I don't know if we need the view_items here,\n                              // but it doesn't break tests!\n@@ -568,26 +568,26 @@ trait read_method_map_entry_helper {\n fn encode_method_map_entry(ecx: &e::EncodeContext,\n                            ebml_w: &mut writer::Encoder,\n                            mme: method_map_entry) {\n-    do ebml_w.emit_struct(\"method_map_entry\", 3) |ebml_w| {\n-        do ebml_w.emit_struct_field(\"self_ty\", 0u) |ebml_w| {\n+    ebml_w.emit_struct(\"method_map_entry\", 3, |ebml_w| {\n+        ebml_w.emit_struct_field(\"self_ty\", 0u, |ebml_w| {\n             ebml_w.emit_ty(ecx, mme.self_ty);\n-        }\n-        do ebml_w.emit_struct_field(\"explicit_self\", 2u) |ebml_w| {\n+        });\n+        ebml_w.emit_struct_field(\"explicit_self\", 2u, |ebml_w| {\n             mme.explicit_self.encode(ebml_w);\n-        }\n-        do ebml_w.emit_struct_field(\"origin\", 1u) |ebml_w| {\n+        });\n+        ebml_w.emit_struct_field(\"origin\", 1u, |ebml_w| {\n             mme.origin.encode(ebml_w);\n-        }\n-        do ebml_w.emit_struct_field(\"self_mode\", 3) |ebml_w| {\n+        });\n+        ebml_w.emit_struct_field(\"self_mode\", 3, |ebml_w| {\n             mme.self_mode.encode(ebml_w);\n-        }\n-    }\n+        });\n+    })\n }\n \n impl read_method_map_entry_helper for reader::Decoder {\n     fn read_method_map_entry(&mut self, xcx: @ExtendedDecodeContext)\n                              -> method_map_entry {\n-        do self.read_struct(\"method_map_entry\", 3) |this| {\n+        self.read_struct(\"method_map_entry\", 3, |this| {\n             method_map_entry {\n                 self_ty: this.read_struct_field(\"self_ty\", 0u, |this| {\n                     this.read_ty(xcx)\n@@ -608,7 +608,7 @@ impl read_method_map_entry_helper for reader::Decoder {\n                     self_mode\n                 }),\n             }\n-        }\n+        })\n     }\n }\n \n@@ -648,50 +648,50 @@ pub fn encode_vtable_res(ecx: &e::EncodeContext,\n     // ty::t doesn't work, and there is no way (atm) to have\n     // hand-written encoding routines combine with auto-generated\n     // ones.  perhaps we should fix this.\n-    do ebml_w.emit_from_vec(*dr) |ebml_w, param_tables| {\n+    ebml_w.emit_from_vec(*dr, |ebml_w, param_tables| {\n         encode_vtable_param_res(ecx, ebml_w, *param_tables);\n-    }\n+    })\n }\n \n pub fn encode_vtable_param_res(ecx: &e::EncodeContext,\n                      ebml_w: &mut writer::Encoder,\n                      param_tables: typeck::vtable_param_res) {\n-    do ebml_w.emit_from_vec(*param_tables) |ebml_w, vtable_origin| {\n+    ebml_w.emit_from_vec(*param_tables, |ebml_w, vtable_origin| {\n         encode_vtable_origin(ecx, ebml_w, vtable_origin)\n-    }\n+    })\n }\n \n \n pub fn encode_vtable_origin(ecx: &e::EncodeContext,\n                         ebml_w: &mut writer::Encoder,\n                         vtable_origin: &typeck::vtable_origin) {\n-    do ebml_w.emit_enum(\"vtable_origin\") |ebml_w| {\n+    ebml_w.emit_enum(\"vtable_origin\", |ebml_w| {\n         match *vtable_origin {\n           typeck::vtable_static(def_id, ref tys, vtable_res) => {\n-            do ebml_w.emit_enum_variant(\"vtable_static\", 0u, 3u) |ebml_w| {\n-                do ebml_w.emit_enum_variant_arg(0u) |ebml_w| {\n+            ebml_w.emit_enum_variant(\"vtable_static\", 0u, 3u, |ebml_w| {\n+                ebml_w.emit_enum_variant_arg(0u, |ebml_w| {\n                     ebml_w.emit_def_id(def_id)\n-                }\n-                do ebml_w.emit_enum_variant_arg(1u) |ebml_w| {\n+                });\n+                ebml_w.emit_enum_variant_arg(1u, |ebml_w| {\n                     ebml_w.emit_tys(ecx, *tys);\n-                }\n-                do ebml_w.emit_enum_variant_arg(2u) |ebml_w| {\n+                });\n+                ebml_w.emit_enum_variant_arg(2u, |ebml_w| {\n                     encode_vtable_res(ecx, ebml_w, vtable_res);\n-                }\n-            }\n+                })\n+            })\n           }\n           typeck::vtable_param(pn, bn) => {\n-            do ebml_w.emit_enum_variant(\"vtable_param\", 1u, 2u) |ebml_w| {\n-                do ebml_w.emit_enum_variant_arg(0u) |ebml_w| {\n+            ebml_w.emit_enum_variant(\"vtable_param\", 1u, 2u, |ebml_w| {\n+                ebml_w.emit_enum_variant_arg(0u, |ebml_w| {\n                     pn.encode(ebml_w);\n-                }\n-                do ebml_w.emit_enum_variant_arg(1u) |ebml_w| {\n+                });\n+                ebml_w.emit_enum_variant_arg(1u, |ebml_w| {\n                     ebml_w.emit_uint(bn);\n-                }\n-            }\n+                })\n+            })\n           }\n         }\n-    }\n+    })\n }\n \n pub trait vtable_decoder_helpers {\n@@ -724,40 +724,40 @@ impl vtable_decoder_helpers for reader::Decoder {\n     fn read_vtable_origin(&mut self,\n                           tcx: ty::ctxt, cdata: @cstore::crate_metadata)\n         -> typeck::vtable_origin {\n-        do self.read_enum(\"vtable_origin\") |this| {\n-            do this.read_enum_variant([\"vtable_static\",\n-                                       \"vtable_param\",\n-                                       \"vtable_self\"])\n-                    |this, i| {\n+        self.read_enum(\"vtable_origin\", |this| {\n+            this.read_enum_variant([\"vtable_static\",\n+                                    \"vtable_param\",\n+                                    \"vtable_self\"],\n+                                   |this, i| {\n                 match i {\n                   0 => {\n                     typeck::vtable_static(\n-                        do this.read_enum_variant_arg(0u) |this| {\n+                        this.read_enum_variant_arg(0u, |this| {\n                             this.read_def_id_noxcx(cdata)\n-                        },\n-                        do this.read_enum_variant_arg(1u) |this| {\n+                        }),\n+                        this.read_enum_variant_arg(1u, |this| {\n                             this.read_tys_noxcx(tcx, cdata)\n-                        },\n-                        do this.read_enum_variant_arg(2u) |this| {\n+                        }),\n+                        this.read_enum_variant_arg(2u, |this| {\n                             this.read_vtable_res(tcx, cdata)\n-                        }\n+                        })\n                     )\n                   }\n                   1 => {\n                     typeck::vtable_param(\n-                        do this.read_enum_variant_arg(0u) |this| {\n+                        this.read_enum_variant_arg(0u, |this| {\n                             Decodable::decode(this)\n-                        },\n-                        do this.read_enum_variant_arg(1u) |this| {\n+                        }),\n+                        this.read_enum_variant_arg(1u, |this| {\n                             this.read_uint()\n-                        }\n+                        })\n                     )\n                   }\n                   // hard to avoid - user input\n                   _ => fail!(\"bad enum variant\")\n                 }\n-            }\n-        }\n+            })\n+        })\n     }\n }\n \n@@ -793,54 +793,48 @@ trait ebml_writer_helpers {\n \n impl ebml_writer_helpers for writer::Encoder {\n     fn emit_ty(&mut self, ecx: &e::EncodeContext, ty: ty::t) {\n-        do self.emit_opaque |this| {\n-            e::write_type(ecx, this, ty)\n-        }\n+        self.emit_opaque(|this| e::write_type(ecx, this, ty))\n     }\n \n     fn emit_vstore(&mut self, ecx: &e::EncodeContext, vstore: ty::vstore) {\n-        do self.emit_opaque |this| {\n-            e::write_vstore(ecx, this, vstore)\n-        }\n+        self.emit_opaque(|this| e::write_vstore(ecx, this, vstore))\n     }\n \n     fn emit_tys(&mut self, ecx: &e::EncodeContext, tys: &[ty::t]) {\n-        do self.emit_from_vec(tys) |this, ty| {\n-            this.emit_ty(ecx, *ty)\n-        }\n+        self.emit_from_vec(tys, |this, ty| this.emit_ty(ecx, *ty))\n     }\n \n     fn emit_type_param_def(&mut self,\n                            ecx: &e::EncodeContext,\n                            type_param_def: &ty::TypeParameterDef) {\n-        do self.emit_opaque |this| {\n+        self.emit_opaque(|this| {\n             tyencode::enc_type_param_def(this.writer,\n                                          ecx.ty_str_ctxt(),\n                                          type_param_def)\n-        }\n+        })\n     }\n \n     fn emit_tpbt(&mut self,\n                  ecx: &e::EncodeContext,\n                  tpbt: ty::ty_param_bounds_and_ty) {\n-        do self.emit_struct(\"ty_param_bounds_and_ty\", 2) |this| {\n-            do this.emit_struct_field(\"generics\", 0) |this| {\n-                do this.emit_struct(\"Generics\", 2) |this| {\n-                    do this.emit_struct_field(\"type_param_defs\", 0) |this| {\n-                        do this.emit_from_vec(*tpbt.generics.type_param_defs)\n-                                |this, type_param_def| {\n+        self.emit_struct(\"ty_param_bounds_and_ty\", 2, |this| {\n+            this.emit_struct_field(\"generics\", 0, |this| {\n+                this.emit_struct(\"Generics\", 2, |this| {\n+                    this.emit_struct_field(\"type_param_defs\", 0, |this| {\n+                        this.emit_from_vec(*tpbt.generics.type_param_defs,\n+                                           |this, type_param_def| {\n                             this.emit_type_param_def(ecx, type_param_def);\n-                        }\n-                    }\n-                    do this.emit_struct_field(\"region_param_defs\", 1) |this| {\n+                        })\n+                    });\n+                    this.emit_struct_field(\"region_param_defs\", 1, |this| {\n                         tpbt.generics.region_param_defs.encode(this);\n-                    }\n-                }\n-            }\n-            do this.emit_struct_field(\"ty\", 1) |this| {\n+                    })\n+                })\n+            });\n+            this.emit_struct_field(\"ty\", 1, |this| {\n                 this.emit_ty(ecx, tpbt.ty);\n-            }\n-        }\n+            })\n+        })\n     }\n }\n \n@@ -912,125 +906,123 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     {\n         let r = tcx.def_map.find(&id);\n         for def in r.iter() {\n-            do ebml_w.tag(c::tag_table_def) |ebml_w| {\n+            ebml_w.tag(c::tag_table_def, |ebml_w| {\n                 ebml_w.id(id);\n-                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                    (*def).encode(ebml_w)\n-                }\n-            }\n+                ebml_w.tag(c::tag_table_val, |ebml_w| (*def).encode(ebml_w));\n+            })\n         }\n     }\n \n     {\n         let r = tcx.node_types.find(&(id as uint));\n         for &ty in r.iter() {\n-            do ebml_w.tag(c::tag_table_node_type) |ebml_w| {\n+            ebml_w.tag(c::tag_table_node_type, |ebml_w| {\n                 ebml_w.id(id);\n-                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                ebml_w.tag(c::tag_table_val, |ebml_w| {\n                     ebml_w.emit_ty(ecx, *ty);\n-                }\n-            }\n+                })\n+            })\n         }\n     }\n \n     {\n         let r = tcx.node_type_substs.find(&id);\n         for tys in r.iter() {\n-            do ebml_w.tag(c::tag_table_node_type_subst) |ebml_w| {\n+            ebml_w.tag(c::tag_table_node_type_subst, |ebml_w| {\n                 ebml_w.id(id);\n-                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                ebml_w.tag(c::tag_table_val, |ebml_w| {\n                     ebml_w.emit_tys(ecx, **tys)\n-                }\n-            }\n+                })\n+            })\n         }\n     }\n \n     {\n         let r = tcx.freevars.find(&id);\n         for &fv in r.iter() {\n-            do ebml_w.tag(c::tag_table_freevars) |ebml_w| {\n+            ebml_w.tag(c::tag_table_freevars, |ebml_w| {\n                 ebml_w.id(id);\n-                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                    do ebml_w.emit_from_vec(**fv) |ebml_w, fv_entry| {\n+                ebml_w.tag(c::tag_table_val, |ebml_w| {\n+                    ebml_w.emit_from_vec(**fv, |ebml_w, fv_entry| {\n                         encode_freevar_entry(ebml_w, *fv_entry)\n-                    }\n-                }\n-            }\n+                    })\n+                })\n+            })\n         }\n     }\n \n     let lid = ast::DefId { crate: ast::LOCAL_CRATE, node: id };\n     {\n         let r = tcx.tcache.find(&lid);\n         for &tpbt in r.iter() {\n-            do ebml_w.tag(c::tag_table_tcache) |ebml_w| {\n+            ebml_w.tag(c::tag_table_tcache, |ebml_w| {\n                 ebml_w.id(id);\n-                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                ebml_w.tag(c::tag_table_val, |ebml_w| {\n                     ebml_w.emit_tpbt(ecx, *tpbt);\n-                }\n-            }\n+                })\n+            })\n         }\n     }\n \n     {\n         let r = tcx.ty_param_defs.find(&id);\n         for &type_param_def in r.iter() {\n-            do ebml_w.tag(c::tag_table_param_defs) |ebml_w| {\n+            ebml_w.tag(c::tag_table_param_defs, |ebml_w| {\n                 ebml_w.id(id);\n-                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                ebml_w.tag(c::tag_table_val, |ebml_w| {\n                     ebml_w.emit_type_param_def(ecx, type_param_def)\n-                }\n-            }\n+                })\n+            })\n         }\n     }\n \n     {\n         let r = maps.method_map.find(&id);\n         for &mme in r.iter() {\n-            do ebml_w.tag(c::tag_table_method_map) |ebml_w| {\n+            ebml_w.tag(c::tag_table_method_map, |ebml_w| {\n                 ebml_w.id(id);\n-                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                ebml_w.tag(c::tag_table_val, |ebml_w| {\n                     encode_method_map_entry(ecx, ebml_w, *mme)\n-                }\n-            }\n+                })\n+            })\n         }\n     }\n \n     {\n         let r = maps.vtable_map.find(&id);\n         for &dr in r.iter() {\n-            do ebml_w.tag(c::tag_table_vtable_map) |ebml_w| {\n+            ebml_w.tag(c::tag_table_vtable_map, |ebml_w| {\n                 ebml_w.id(id);\n-                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                ebml_w.tag(c::tag_table_val, |ebml_w| {\n                     encode_vtable_res(ecx, ebml_w, *dr);\n-                }\n-            }\n+                })\n+            })\n         }\n     }\n \n     {\n         let r = tcx.adjustments.find(&id);\n         for adj in r.iter() {\n-            do ebml_w.tag(c::tag_table_adjustments) |ebml_w| {\n+            ebml_w.tag(c::tag_table_adjustments, |ebml_w| {\n                 ebml_w.id(id);\n-                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n+                ebml_w.tag(c::tag_table_val, |ebml_w| {\n                     (**adj).encode(ebml_w)\n-                }\n-            }\n+                })\n+            })\n         }\n     }\n \n     {\n         let r = maps.capture_map.find(&id);\n         for &cap_vars in r.iter() {\n-            do ebml_w.tag(c::tag_table_capture_map) |ebml_w| {\n+            ebml_w.tag(c::tag_table_capture_map, |ebml_w| {\n                 ebml_w.id(id);\n-                do ebml_w.tag(c::tag_table_val) |ebml_w| {\n-                    do ebml_w.emit_from_vec(*cap_vars) |ebml_w, cap_var| {\n+                ebml_w.tag(c::tag_table_val, |ebml_w| {\n+                    ebml_w.emit_from_vec(*cap_vars, |ebml_w, cap_var| {\n                         cap_var.encode(ebml_w);\n-                    }\n-                }\n-            }\n+                    })\n+                })\n+            })\n         }\n     }\n }\n@@ -1072,14 +1064,14 @@ trait ebml_decoder_decoder_helpers {\n impl ebml_decoder_decoder_helpers for reader::Decoder {\n     fn read_ty_noxcx(&mut self,\n                      tcx: ty::ctxt, cdata: @cstore::crate_metadata) -> ty::t {\n-        do self.read_opaque |_, doc| {\n+        self.read_opaque(|_, doc| {\n             tydecode::parse_ty_data(\n                 *doc.data,\n                 cdata.cnum,\n                 doc.start,\n                 tcx,\n                 |_, id| decoder::translate_def_id(cdata, id))\n-        }\n+        })\n     }\n \n     fn read_tys_noxcx(&mut self,\n@@ -1094,7 +1086,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         // context.  However, we do not bother, because region types\n         // are not used during trans.\n \n-        return do self.read_opaque |this, doc| {\n+        return self.read_opaque(|this, doc| {\n             debug!(\"read_ty({})\", type_string(doc));\n \n             let ty = tydecode::parse_ty_data(\n@@ -1105,7 +1097,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n                 |s, a| this.convert_def_id(xcx, s, a));\n \n             ty\n-        };\n+        });\n \n         fn type_string(doc: ebml::Doc) -> ~str {\n             let mut str = ~\"\";\n@@ -1122,22 +1114,22 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n \n     fn read_type_param_def(&mut self, xcx: @ExtendedDecodeContext)\n                            -> ty::TypeParameterDef {\n-        do self.read_opaque |this, doc| {\n+        self.read_opaque(|this, doc| {\n             tydecode::parse_type_param_def_data(\n                 *doc.data,\n                 doc.start,\n                 xcx.dcx.cdata.cnum,\n                 xcx.dcx.tcx,\n                 |s, a| this.convert_def_id(xcx, s, a))\n-        }\n+        })\n     }\n \n     fn read_ty_param_bounds_and_ty(&mut self, xcx: @ExtendedDecodeContext)\n                                    -> ty::ty_param_bounds_and_ty {\n-        do self.read_struct(\"ty_param_bounds_and_ty\", 2) |this| {\n+        self.read_struct(\"ty_param_bounds_and_ty\", 2, |this| {\n             ty::ty_param_bounds_and_ty {\n-                generics: do this.read_struct_field(\"generics\", 0) |this| {\n-                    do this.read_struct(\"Generics\", 2) |this| {\n+                generics: this.read_struct_field(\"generics\", 0, |this| {\n+                    this.read_struct(\"Generics\", 2, |this| {\n                         ty::Generics {\n                             type_param_defs:\n                                 this.read_struct_field(\"type_param_defs\",\n@@ -1153,13 +1145,13 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n                                     Decodable::decode(this)\n                                 })\n                         }\n-                    }\n-                },\n+                    })\n+                }),\n                 ty: this.read_struct_field(\"ty\", 1, |this| {\n                     this.read_ty(xcx)\n                 })\n             }\n-        }\n+        })\n     }\n \n     fn convert_def_id(&mut self,\n@@ -1208,7 +1200,7 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                       ast_doc: ebml::Doc) {\n     let dcx = xcx.dcx;\n     let tbl_doc = ast_doc.get(c::tag_table as uint);\n-    do reader::docs(tbl_doc) |tag, entry_doc| {\n+    reader::docs(tbl_doc, |tag, entry_doc| {\n         let id0 = entry_doc.get(c::tag_table_id as uint).as_int();\n         let id = xcx.tr_id(id0);\n \n@@ -1288,7 +1280,7 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n \n         debug!(\">< Side table doc loaded\");\n         true\n-    };\n+    });\n }\n \n // ______________________________________________________________________"}, {"sha": "774509ab0da58e705e86ac50b2980170bacffb02", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -132,10 +132,10 @@ impl<'self> CheckLoanCtxt<'self> {\n         //! are issued for future scopes and thus they may have been\n         //! *issued* but not yet be in effect.\n \n-        do self.dfcx_loans.each_bit_on_entry_frozen(scope_id) |loan_index| {\n+        self.dfcx_loans.each_bit_on_entry_frozen(scope_id, |loan_index| {\n             let loan = &self.all_loans[loan_index];\n             op(loan)\n-        }\n+        })\n     }\n \n     pub fn each_in_scope_loan(&self,\n@@ -146,13 +146,13 @@ impl<'self> CheckLoanCtxt<'self> {\n         //! currently in scope.\n \n         let region_maps = self.tcx().region_maps;\n-        do self.each_issued_loan(scope_id) |loan| {\n+        self.each_issued_loan(scope_id, |loan| {\n             if region_maps.is_subscope_of(scope_id, loan.kill_scope) {\n                 op(loan)\n             } else {\n                 true\n             }\n-        }\n+        })\n     }\n \n     pub fn each_in_scope_restriction(&self,\n@@ -163,7 +163,7 @@ impl<'self> CheckLoanCtxt<'self> {\n         //! Iterates through all the in-scope restrictions for the\n         //! given `loan_path`\n \n-        do self.each_in_scope_loan(scope_id) |loan| {\n+        self.each_in_scope_loan(scope_id, |loan| {\n             let mut ret = true;\n             for restr in loan.restrictions.iter() {\n                 if restr.loan_path == loan_path {\n@@ -174,18 +174,18 @@ impl<'self> CheckLoanCtxt<'self> {\n                 }\n             }\n             ret\n-        }\n+        })\n     }\n \n     pub fn loans_generated_by(&self, scope_id: ast::NodeId) -> ~[uint] {\n         //! Returns a vector of the loans that are generated as\n         //! we encounter `scope_id`.\n \n         let mut result = ~[];\n-        do self.dfcx_loans.each_gen_bit_frozen(scope_id) |loan_index| {\n+        self.dfcx_loans.each_gen_bit_frozen(scope_id, |loan_index| {\n             result.push(loan_index);\n             true\n-        };\n+        });\n         return result;\n     }\n \n@@ -200,13 +200,13 @@ impl<'self> CheckLoanCtxt<'self> {\n         let new_loan_indices = self.loans_generated_by(scope_id);\n         debug!(\"new_loan_indices = {:?}\", new_loan_indices);\n \n-        do self.each_issued_loan(scope_id) |issued_loan| {\n+        self.each_issued_loan(scope_id, |issued_loan| {\n             for &new_loan_index in new_loan_indices.iter() {\n                 let new_loan = &self.all_loans[new_loan_index];\n                 self.report_error_if_loans_conflict(issued_loan, new_loan);\n             }\n             true\n-        };\n+        });\n \n         for (i, &x) in new_loan_indices.iter().enumerate() {\n             let old_loan = &self.all_loans[x];\n@@ -317,15 +317,15 @@ impl<'self> CheckLoanCtxt<'self> {\n \n         debug!(\"check_if_path_is_moved(id={:?}, use_kind={:?}, lp={})\",\n                id, use_kind, lp.repr(self.bccx.tcx));\n-        do self.move_data.each_move_of(id, lp) |move, moved_lp| {\n+        self.move_data.each_move_of(id, lp, |move, moved_lp| {\n             self.bccx.report_use_of_moved_value(\n                 span,\n                 use_kind,\n                 lp,\n                 move,\n                 moved_lp);\n             false\n-        };\n+        });\n     }\n \n     pub fn check_assignment(&self, expr: @ast::Expr) {\n@@ -357,13 +357,13 @@ impl<'self> CheckLoanCtxt<'self> {\n         if self.is_local_variable(cmt) {\n             assert!(cmt.mutbl.is_immutable()); // no \"const\" locals\n             let lp = opt_loan_path(cmt).unwrap();\n-            do self.move_data.each_assignment_of(expr.id, lp) |assign| {\n+            self.move_data.each_assignment_of(expr.id, lp, |assign| {\n                 self.bccx.report_reassigned_immutable_variable(\n                     expr.span,\n                     lp,\n                     assign);\n                 false\n-            };\n+            });\n             return;\n         }\n \n@@ -546,16 +546,16 @@ impl<'self> CheckLoanCtxt<'self> {\n             // `RESTR_MUTATE` restriction whenever the contents of an\n             // owned pointer are borrowed, and hence while `v[*]` is not\n             // restricted from being written, `v` is.\n-            let cont = do this.each_in_scope_restriction(expr.id, loan_path)\n-                |loan, restr|\n-            {\n+            let cont = this.each_in_scope_restriction(expr.id,\n+                                                      loan_path,\n+                                                      |loan, restr| {\n                 if restr.set.intersects(RESTR_MUTATE) {\n                     this.report_illegal_mutation(expr, loan_path, loan);\n                     false\n                 } else {\n                     true\n                 }\n-            };\n+            });\n \n             if !cont { return false }\n \n@@ -621,7 +621,7 @@ impl<'self> CheckLoanCtxt<'self> {\n                 }\n \n                 // Check for a non-const loan of `loan_path`\n-                let cont = do this.each_in_scope_loan(expr.id) |loan| {\n+                let cont = this.each_in_scope_loan(expr.id, |loan| {\n                     if loan.loan_path == loan_path &&\n                             loan.mutbl != ConstMutability {\n                         this.report_illegal_mutation(expr,\n@@ -631,7 +631,7 @@ impl<'self> CheckLoanCtxt<'self> {\n                     } else {\n                         true\n                     }\n-                };\n+                });\n \n                 if !cont { return false }\n             }\n@@ -666,7 +666,7 @@ impl<'self> CheckLoanCtxt<'self> {\n     }\n \n     fn check_move_out_from_id(&self, id: ast::NodeId, span: Span) {\n-        do self.move_data.each_path_moved_by(id) |_, move_path| {\n+        self.move_data.each_path_moved_by(id, |_, move_path| {\n             match self.analyze_move_out_from(id, move_path) {\n                 MoveOk => {}\n                 MoveWhileBorrowed(loan_path, loan_span) => {\n@@ -682,7 +682,7 @@ impl<'self> CheckLoanCtxt<'self> {\n                 }\n             }\n             true\n-        };\n+        });\n     }\n \n     pub fn analyze_move_out_from(&self,\n@@ -696,11 +696,11 @@ impl<'self> CheckLoanCtxt<'self> {\n         let mut ret = MoveOk;\n \n         // check for a conflicting loan:\n-        do self.each_in_scope_restriction(expr_id, move_path) |loan, _| {\n+        self.each_in_scope_restriction(expr_id, move_path, |loan, _| {\n             // Any restriction prevents moves.\n             ret = MoveWhileBorrowed(loan.loan_path, loan.span);\n             false\n-        };\n+        });\n \n         ret\n     }"}, {"sha": "410cf658a985148b2487bf9ed6b67b2cf1b759df", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -161,27 +161,25 @@ fn gather_loans_in_local(this: &mut GatherLoanCtxt,\n         None => {\n             // Variable declarations without initializers are considered \"moves\":\n             let tcx = this.bccx.tcx;\n-            do pat_util::pat_bindings(tcx.def_map, local.pat)\n-                |_, id, span, _| {\n+            pat_util::pat_bindings(tcx.def_map, local.pat, |_, id, span, _| {\n                 gather_moves::gather_decl(this.bccx,\n                                           this.move_data,\n                                           id,\n                                           span,\n                                           id);\n-            }\n+            })\n         }\n         Some(init) => {\n             // Variable declarations with initializers are considered \"assigns\":\n             let tcx = this.bccx.tcx;\n-            do pat_util::pat_bindings(tcx.def_map, local.pat)\n-                |_, id, span, _| {\n+            pat_util::pat_bindings(tcx.def_map, local.pat, |_, id, span, _| {\n                 gather_moves::gather_assignment(this.bccx,\n                                                 this.move_data,\n                                                 id,\n                                                 span,\n                                                 @LpVar(id),\n                                                 id);\n-            }\n+            });\n             let init_cmt = this.bccx.cat_expr(init);\n             this.gather_pat(init_cmt, local.pat, None);\n         }\n@@ -692,7 +690,7 @@ impl<'self> GatherLoanCtxt<'self> {\n          * moves (non-`ref` bindings with linear type).\n          */\n \n-        do self.bccx.cat_pattern(discr_cmt, root_pat) |cmt, pat| {\n+        self.bccx.cat_pattern(discr_cmt, root_pat, |cmt, pat| {\n             match pat.node {\n               ast::PatIdent(bm, _, _) if self.pat_is_binding(pat) => {\n                 match bm {\n@@ -781,7 +779,7 @@ impl<'self> GatherLoanCtxt<'self> {\n \n               _ => {}\n             }\n-        }\n+        })\n     }\n \n     pub fn vec_slice_info(&self, pat: @ast::Pat, slice_ty: ty::t)"}, {"sha": "abeaef054314121d654095dc2cad9aa7d072cae9", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -318,15 +318,15 @@ pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n         }\n \n         mc::cat_deref(cmt_base, _, pk) => {\n-            do opt_loan_path(cmt_base).map |lp| {\n+            opt_loan_path(cmt_base).map(|lp| {\n                 @LpExtend(lp, cmt.mutbl, LpDeref(pk))\n-            }\n+            })\n         }\n \n         mc::cat_interior(cmt_base, ik) => {\n-            do opt_loan_path(cmt_base).map |lp| {\n+            opt_loan_path(cmt_base).map(|lp| {\n                 @LpExtend(lp, cmt.mutbl, LpInterior(ik))\n-            }\n+            })\n         }\n \n         mc::cat_downcast(cmt_base) |"}, {"sha": "7b060e6ac7db8237c38e77428f15ce0309843d7a", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -277,10 +277,10 @@ impl MoveData {\n \n         match self.path_map.find_copy(&lp) {\n             Some(index) => {\n-                do self.each_base_path(index) |p| {\n+                self.each_base_path(index, |p| {\n                     result.push(p);\n                     true\n-                };\n+                });\n             }\n             None => {\n                 match *lp {\n@@ -448,7 +448,7 @@ impl MoveData {\n                             f: |MoveIndex| -> bool)\n                             -> bool {\n         let mut ret = true;\n-        do self.each_extending_path(index0) |index| {\n+        self.each_extending_path(index0, |index| {\n             let mut p = self.path(index).first_move;\n             while p != InvalidMoveIndex {\n                 if !f(p) {\n@@ -458,18 +458,18 @@ impl MoveData {\n                 p = self.move(p).next_move;\n             }\n             ret\n-        };\n+        });\n         ret\n     }\n \n     fn kill_moves(&self,\n                   path: MovePathIndex,\n                   kill_id: ast::NodeId,\n                   dfcx_moves: &mut MoveDataFlow) {\n-        do self.each_applicable_move(path) |move_index| {\n+        self.each_applicable_move(path, |move_index| {\n             dfcx_moves.add_kill(kill_id, *move_index);\n             true\n-        };\n+        });\n     }\n }\n \n@@ -511,11 +511,11 @@ impl FlowedMoveData {\n          * Iterates through each path moved by `id`\n          */\n \n-        do self.dfcx_moves.each_gen_bit_frozen(id) |index| {\n+        self.dfcx_moves.each_gen_bit_frozen(id, |index| {\n             let move = &self.move_data.moves[index];\n             let moved_path = move.path;\n             f(move, self.move_data.path(moved_path).loan_path)\n-        }\n+        })\n     }\n \n     pub fn each_move_of(&self,\n@@ -549,7 +549,7 @@ impl FlowedMoveData {\n \n         let mut ret = true;\n \n-        do self.dfcx_moves.each_bit_on_entry_frozen(id) |index| {\n+        self.dfcx_moves.each_bit_on_entry_frozen(id, |index| {\n             let move = &self.move_data.moves[index];\n             let moved_path = move.path;\n             if base_indices.iter().any(|x| x == &moved_path) {\n@@ -560,20 +560,20 @@ impl FlowedMoveData {\n                 }\n             } else {\n                 for &loan_path_index in opt_loan_path_index.iter() {\n-                    let cont = do self.move_data.each_base_path(moved_path) |p| {\n+                    let cont = self.move_data.each_base_path(moved_path, |p| {\n                         if p == loan_path_index {\n                             // Scenario 3: some extension of `loan_path`\n                             // was moved\n                             f(move, self.move_data.path(moved_path).loan_path)\n                         } else {\n                             true\n                         }\n-                    };\n+                    });\n                     if !cont { ret = false; break }\n                 }\n             }\n             ret\n-        }\n+        })\n     }\n \n     pub fn is_assignee(&self,\n@@ -605,14 +605,14 @@ impl FlowedMoveData {\n             }\n         };\n \n-        do self.dfcx_assign.each_bit_on_entry_frozen(id) |index| {\n+        self.dfcx_assign.each_bit_on_entry_frozen(id, |index| {\n             let assignment = &self.move_data.var_assignments[index];\n             if assignment.path == loan_path_index && !f(assignment) {\n                 false\n             } else {\n                 true\n             }\n-        }\n+        })\n     }\n }\n "}, {"sha": "a65dc88ce9984a290b1d4d8e3d2540372b581931", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -134,13 +134,13 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n                 }\n             };\n \n-            do walk_pat(*pat) |p| {\n+            walk_pat(*pat, |p| {\n                 if pat_matches_nan(p) {\n                     cx.tcx.sess.span_warn(p.span, \"unmatchable NaN in pattern, \\\n                                                    use the is_nan method in a guard instead\");\n                 }\n                 true\n-            };\n+            });\n \n             let v = ~[*pat];\n             match is_useful(cx, &seen, v) {\n@@ -275,14 +275,14 @@ fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n                 is_useful_specialized(cx, m, v, vec(n), n, left_ty)\n               }\n               ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n-                let max_len = do m.rev_iter().fold(0) |max_len, r| {\n+                let max_len = m.rev_iter().fold(0, |max_len, r| {\n                   match r[0].node {\n                     PatVec(ref before, _, ref after) => {\n                       num::max(before.len() + after.len(), max_len)\n                     }\n                     _ => max_len\n                   }\n-                };\n+                });\n                 for n in iter::range(0u, max_len + 1) {\n                   match is_useful_specialized(cx, m, v, vec(n), n, left_ty) {\n                     not_useful => (),\n@@ -454,14 +454,14 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n       ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n \n         // Find the lengths and slices of all vector patterns.\n-        let vec_pat_lens = do m.iter().filter_map |r| {\n+        let vec_pat_lens = m.iter().filter_map(|r| {\n             match r[0].node {\n                 PatVec(ref before, ref slice, ref after) => {\n                     Some((before.len() + after.len(), slice.is_some()))\n                 }\n                 _ => None\n             }\n-        }.collect::<~[(uint, bool)]>();\n+        }).collect::<~[(uint, bool)]>();\n \n         // Sort them by length such that for patterns of the same length,\n         // those with a destructured slice come first.\n@@ -886,7 +886,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n     let mut by_ref_span = None;\n     let mut any_by_move = false;\n     for pat in pats.iter() {\n-        do pat_bindings(def_map, *pat) |bm, id, span, _path| {\n+        pat_bindings(def_map, *pat, |bm, id, span, _path| {\n             match bm {\n                 BindByRef(_) => {\n                     by_ref_span = Some(span);\n@@ -897,7 +897,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                     }\n                 }\n             }\n-        }\n+        })\n     }\n \n     let check_move: |&Pat, Option<@Pat>| = |p, sub| {\n@@ -925,7 +925,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n \n     if !any_by_move { return; } // pointless micro-optimization\n     for pat in pats.iter() {\n-        do walk_pat(*pat) |p| {\n+        walk_pat(*pat, |p| {\n             if pat_is_binding(def_map, p) {\n                 match p.node {\n                     PatIdent(_, _, sub) => {\n@@ -943,6 +943,6 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                 }\n             }\n             true\n-        };\n+        });\n     }\n }"}, {"sha": "28d6f9515a83609fdffe479c71160fc0e7830ced", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -219,9 +219,7 @@ impl ConstEvalVisitor {\n             }\n \n             ast::ExprStruct(_, ref fs, None) => {\n-                let cs = do fs.iter().map |f| {\n-                    self.classify(f.expr)\n-                };\n+                let cs = fs.iter().map(|f| self.classify(f.expr));\n                 join_all(cs)\n             }\n "}, {"sha": "e10e53d257598a8f28b170226a618ceb1384f792", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -208,17 +208,17 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n     fn compute_id_range(&mut self, id: ast::NodeId) -> (uint, uint) {\n         let mut expanded = false;\n         let len = self.nodeid_to_bitset.len();\n-        let n = do self.nodeid_to_bitset.find_or_insert_with(id) |_| {\n+        let n = self.nodeid_to_bitset.find_or_insert_with(id, |_| {\n             expanded = true;\n             len\n-        };\n+        });\n         if expanded {\n             let entry = if self.oper.initial_value() { uint::max_value } else {0};\n-            do self.words_per_id.times {\n+            self.words_per_id.times(|| {\n                 self.gens.push(0);\n                 self.kills.push(0);\n                 self.on_entry.push(entry);\n-            }\n+            })\n         }\n         let start = *n * self.words_per_id;\n         let end = start + self.words_per_id;\n@@ -835,12 +835,12 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n         debug!(\"DataFlowContext::walk_pat(pat={}, in_out={})\",\n                pat.repr(self.dfcx.tcx), bits_to_str(reslice(in_out)));\n \n-        do ast_util::walk_pat(pat) |p| {\n+        ast_util::walk_pat(pat, |p| {\n             debug!(\"  p.id={:?} in_out={}\", p.id, bits_to_str(reslice(in_out)));\n             self.merge_with_entry_set(p.id, in_out);\n             self.dfcx.apply_gen_kill(p.id, in_out);\n             true\n-        };\n+        });\n     }\n \n     fn walk_pat_alternatives(&mut self,"}, {"sha": "ce2aae3e36bcfcdd2c3ce3f59f0decff4f5ca79e", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -318,22 +318,22 @@ mod test {\n     fn each_node() {\n         let graph = create_graph();\n         let expected = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"];\n-        do graph.each_node |idx, node| {\n+        graph.each_node(|idx, node| {\n             assert_eq!(&expected[*idx], graph.node_data(idx));\n             assert_eq!(expected[*idx], node.data);\n             true\n-        };\n+        });\n     }\n \n     #[test]\n     fn each_edge() {\n         let graph = create_graph();\n         let expected = [\"AB\", \"BC\", \"BD\", \"DE\", \"EC\", \"FB\"];\n-        do graph.each_edge |idx, edge| {\n+        graph.each_edge(|idx, edge| {\n             assert_eq!(&expected[*idx], graph.edge_data(idx));\n             assert_eq!(expected[*idx], edge.data);\n             true\n-        };\n+        });\n     }\n \n     fn test_adjacent_edges<N:Eq,E:Eq>(graph: &Graph<N,E>,\n@@ -344,7 +344,7 @@ mod test {\n         assert_eq!(graph.node_data(start_index), &start_data);\n \n         let mut counter = 0;\n-        do graph.each_incoming_edge(start_index) |edge_index, edge| {\n+        graph.each_incoming_edge(start_index, |edge_index, edge| {\n             assert_eq!(graph.edge_data(edge_index), &edge.data);\n             assert!(counter < expected_incoming.len());\n             debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n@@ -358,11 +358,11 @@ mod test {\n             }\n             counter += 1;\n             true\n-        };\n+        });\n         assert_eq!(counter, expected_incoming.len());\n \n         let mut counter = 0;\n-        do graph.each_outgoing_edge(start_index) |edge_index, edge| {\n+        graph.each_outgoing_edge(start_index, |edge_index, edge| {\n             assert_eq!(graph.edge_data(edge_index), &edge.data);\n             assert!(counter < expected_outgoing.len());\n             debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n@@ -376,7 +376,7 @@ mod test {\n             }\n             counter += 1;\n             true\n-        };\n+        });\n         assert_eq!(counter, expected_outgoing.len());\n     }\n "}, {"sha": "3bc103519dac9707211877ea848072c209285c2b", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -125,14 +125,14 @@ fn check_impl_of_trait(cx: &mut Context, it: @item, trait_ref: &trait_ref, self_\n     // If this trait has builtin-kind supertraits, meet them.\n     let self_ty: ty::t = ty::node_id_to_type(cx.tcx, it.id);\n     debug!(\"checking impl with self type {:?}\", ty::get(self_ty).sty);\n-    do check_builtin_bounds(cx, self_ty, trait_def.bounds) |missing| {\n+    check_builtin_bounds(cx, self_ty, trait_def.bounds, |missing| {\n         cx.tcx.sess.span_err(self_type.span,\n             format!(\"the type `{}', which does not fulfill `{}`, cannot implement this \\\n                   trait\", ty_to_str(cx.tcx, self_ty), missing.user_string(cx.tcx)));\n         cx.tcx.sess.span_note(self_type.span,\n             format!(\"types implementing this trait must fulfill `{}`\",\n                  trait_def.bounds.user_string(cx.tcx)));\n-    }\n+    });\n \n     // If this is a destructor, check kinds.\n     if cx.tcx.lang_items.drop_trait() == Some(trait_def_id) {\n@@ -255,12 +255,12 @@ fn check_fn(\n     fn_id: NodeId) {\n \n     // Check kinds on free variables:\n-    do with_appropriate_checker(cx, fn_id) |chk| {\n+    with_appropriate_checker(cx, fn_id, |chk| {\n         let r = freevars::get_freevars(cx.tcx, fn_id);\n         for fv in r.iter() {\n             chk(cx, *fv);\n         }\n-    }\n+    });\n \n     visit::walk_fn(cx, fk, decl, body, sp, fn_id, ());\n }\n@@ -374,20 +374,23 @@ pub fn check_typaram_bounds(cx: &Context,\n                     ty: ty::t,\n                     type_param_def: &ty::TypeParameterDef)\n {\n-    do check_builtin_bounds(cx, ty, type_param_def.bounds.builtin_bounds) |missing| {\n+    check_builtin_bounds(cx,\n+                         ty,\n+                         type_param_def.bounds.builtin_bounds,\n+                         |missing| {\n         cx.tcx.sess.span_err(\n             sp,\n             format!(\"instantiating a type parameter with an incompatible type \\\n                   `{}`, which does not fulfill `{}`\",\n                  ty_to_str(cx.tcx, ty),\n                  missing.user_string(cx.tcx)));\n-    }\n+    });\n }\n \n pub fn check_freevar_bounds(cx: &Context, sp: Span, ty: ty::t,\n                             bounds: ty::BuiltinBounds, referenced_ty: Option<ty::t>)\n {\n-    do check_builtin_bounds(cx, ty, bounds) |missing| {\n+    check_builtin_bounds(cx, ty, bounds, |missing| {\n         // Will be Some if the freevar is implicitly borrowed (stack closure).\n         // Emit a less mysterious error message in this case.\n         match referenced_ty {\n@@ -404,18 +407,18 @@ pub fn check_freevar_bounds(cx: &Context, sp: Span, ty: ty::t,\n             sp,\n             format!(\"this closure's environment must satisfy `{}`\",\n                  bounds.user_string(cx.tcx)));\n-    }\n+    });\n }\n \n pub fn check_trait_cast_bounds(cx: &Context, sp: Span, ty: ty::t,\n                                bounds: ty::BuiltinBounds) {\n-    do check_builtin_bounds(cx, ty, bounds) |missing| {\n+    check_builtin_bounds(cx, ty, bounds, |missing| {\n         cx.tcx.sess.span_err(sp,\n             format!(\"cannot pack type `{}`, which does not fulfill \\\n                   `{}`, as a trait bounded by {}\",\n                  ty_to_str(cx.tcx, ty), missing.user_string(cx.tcx),\n                  bounds.user_string(cx.tcx)));\n-    }\n+    });\n }\n \n fn is_nullary_variant(cx: &Context, ex: @Expr) -> bool {"}, {"sha": "5babebef2f662780297f0cd6d47ae5aa6c65d8ea", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -413,14 +413,13 @@ impl LanguageItemCollector {\n \n     pub fn collect_external_language_items(&mut self) {\n         let crate_store = self.session.cstore;\n-        do iter_crate_data(crate_store) |crate_number, _crate_metadata| {\n-            do each_lang_item(crate_store, crate_number)\n-                    |node_id, item_index| {\n+        iter_crate_data(crate_store, |crate_number, _crate_metadata| {\n+            each_lang_item(crate_store, crate_number, |node_id, item_index| {\n                 let def_id = ast::DefId { crate: crate_number, node: node_id };\n                 self.collect_item(item_index, def_id);\n                 true\n-            };\n-        }\n+            });\n+        })\n     }\n \n     pub fn collect(&mut self, crate: &ast::Crate) {"}, {"sha": "38b7bc0875bfc82653abd4c35c752fd6540fee37", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -441,7 +441,7 @@ impl<'self> Context<'self> {\n         // of what we changed so we can roll everything back after invoking the\n         // specified closure\n         let mut pushed = 0u;\n-        do each_lint(self.tcx.sess, attrs) |meta, level, lintname| {\n+        each_lint(self.tcx.sess, attrs, |meta, level, lintname| {\n             match self.dict.find_equiv(&lintname) {\n                 None => {\n                     self.span_lint(\n@@ -467,7 +467,7 @@ impl<'self> Context<'self> {\n                 }\n             }\n             true\n-        };\n+        });\n \n         let old_is_doc_hidden = self.is_doc_hidden;\n         self.is_doc_hidden = self.is_doc_hidden ||\n@@ -479,10 +479,10 @@ impl<'self> Context<'self> {\n \n         // rollback\n         self.is_doc_hidden = old_is_doc_hidden;\n-        do pushed.times {\n+        pushed.times(|| {\n             let (lint, lvl, src) = self.lint_stack.pop();\n             self.set_level(lint, lvl, src);\n-        }\n+        })\n     }\n \n     fn visit_ids(&self, f: |&mut ast_util::IdVisitor<Context>|) {\n@@ -1135,11 +1135,11 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n         // this crate\n         match cx.tcx.items.find(&id.node) {\n             Some(ast_node) => {\n-                let s = do ast_node.with_attrs |attrs| {\n-                    do attrs.map |a| {\n+                let s = ast_node.with_attrs(|attrs| {\n+                    attrs.map(|a| {\n                         attr::find_stability(a.iter().map(|a| a.meta()))\n-                    }\n-                };\n+                    })\n+                });\n                 match s {\n                     Some(s) => s,\n \n@@ -1157,11 +1157,11 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n         let mut s = None;\n         // run through all the attributes and take the first\n         // stability one.\n-        do csearch::get_item_attrs(cx.tcx.cstore, id) |meta_items| {\n+        csearch::get_item_attrs(cx.tcx.cstore, id, |meta_items| {\n             if s.is_none() {\n                 s = attr::find_stability(meta_items.move_iter())\n             }\n-        }\n+        });\n         s\n     };\n \n@@ -1189,34 +1189,32 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n \n impl<'self> Visitor<()> for Context<'self> {\n     fn visit_item(&mut self, it: @ast::item, _: ()) {\n-        do self.with_lint_attrs(it.attrs) |cx| {\n+        self.with_lint_attrs(it.attrs, |cx| {\n             check_item_ctypes(cx, it);\n             check_item_non_camel_case_types(cx, it);\n             check_item_non_uppercase_statics(cx, it);\n             check_heap_item(cx, it);\n             check_missing_doc_item(cx, it);\n             check_attrs_usage(cx, it.attrs);\n \n-            do cx.visit_ids |v| {\n-                v.visit_item(it, ());\n-            }\n+            cx.visit_ids(|v| v.visit_item(it, ()));\n \n             visit::walk_item(cx, it, ());\n-        }\n+        })\n     }\n \n     fn visit_foreign_item(&mut self, it: @ast::foreign_item, _: ()) {\n-        do self.with_lint_attrs(it.attrs) |cx| {\n+        self.with_lint_attrs(it.attrs, |cx| {\n             check_attrs_usage(cx, it.attrs);\n             visit::walk_foreign_item(cx, it, ());\n-        }\n+        })\n     }\n \n     fn visit_view_item(&mut self, i: &ast::view_item, _: ()) {\n-        do self.with_lint_attrs(i.attrs) |cx| {\n+        self.with_lint_attrs(i.attrs, |cx| {\n             check_attrs_usage(cx, i.attrs);\n             visit::walk_view_item(cx, i, ());\n-        }\n+        })\n     }\n \n     fn visit_pat(&mut self, p: &ast::Pat, _: ()) {\n@@ -1266,28 +1264,28 @@ impl<'self> Visitor<()> for Context<'self> {\n \n         match *fk {\n             visit::fk_method(_, _, m) => {\n-                do self.with_lint_attrs(m.attrs) |cx| {\n+                self.with_lint_attrs(m.attrs, |cx| {\n                     check_missing_doc_method(cx, m);\n                     check_attrs_usage(cx, m.attrs);\n \n-                    do cx.visit_ids |v| {\n+                    cx.visit_ids(|v| {\n                         v.visit_fn(fk, decl, body, span, id, ());\n-                    }\n+                    });\n                     recurse(cx);\n-                }\n+                })\n             }\n             _ => recurse(self),\n         }\n     }\n \n \n     fn visit_ty_method(&mut self, t: &ast::TypeMethod, _: ()) {\n-        do self.with_lint_attrs(t.attrs) |cx| {\n+        self.with_lint_attrs(t.attrs, |cx| {\n             check_missing_doc_ty_method(cx, t);\n             check_attrs_usage(cx, t.attrs);\n \n             visit::walk_ty_method(cx, t, ());\n-        }\n+        })\n     }\n \n     fn visit_struct_def(&mut self,\n@@ -1303,21 +1301,21 @@ impl<'self> Visitor<()> for Context<'self> {\n     }\n \n     fn visit_struct_field(&mut self, s: @ast::struct_field, _: ()) {\n-        do self.with_lint_attrs(s.node.attrs) |cx| {\n+        self.with_lint_attrs(s.node.attrs, |cx| {\n             check_missing_doc_struct_field(cx, s);\n             check_attrs_usage(cx, s.node.attrs);\n \n             visit::walk_struct_field(cx, s, ());\n-        }\n+        })\n     }\n \n     fn visit_variant(&mut self, v: &ast::variant, g: &ast::Generics, _: ()) {\n-        do self.with_lint_attrs(v.node.attrs) |cx| {\n+        self.with_lint_attrs(v.node.attrs, |cx| {\n             check_missing_doc_variant(cx, v);\n             check_attrs_usage(cx, v.node.attrs);\n \n             visit::walk_variant(cx, v, g, ());\n-        }\n+        })\n     }\n }\n \n@@ -1356,16 +1354,16 @@ pub fn check_crate(tcx: ty::ctxt,\n     for &(lint, level) in tcx.sess.opts.lint_opts.iter() {\n         cx.set_level(lint, level, CommandLine);\n     }\n-    do cx.with_lint_attrs(crate.attrs) |cx| {\n-        do cx.visit_ids |v| {\n+    cx.with_lint_attrs(crate.attrs, |cx| {\n+        cx.visit_ids(|v| {\n             v.visited_outermost = true;\n             visit::walk_crate(v, crate, ());\n-        }\n+        });\n \n         check_crate_attrs_usage(cx, crate.attrs);\n \n         visit::walk_crate(cx, crate, ());\n-    }\n+    });\n \n     // If we missed any lints added to the session, then there's a bug somewhere\n     // in the iteration code."}, {"sha": "4f137f1f5c45d717c97ff1f307df4c790e6d0047", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 44, "deletions": 42, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -381,12 +381,13 @@ fn visit_fn(v: &mut LivenessVisitor,\n     }\n \n     for arg in decl.inputs.iter() {\n-        do pat_util::pat_bindings(this.tcx.def_map, arg.pat)\n-                |_bm, arg_id, _x, path| {\n+        pat_util::pat_bindings(this.tcx.def_map,\n+                               arg.pat,\n+                               |_bm, arg_id, _x, path| {\n             debug!(\"adding argument {}\", arg_id);\n             let ident = ast_util::path_to_ident(path);\n             fn_maps.add_variable(Arg(arg_id, ident));\n-        }\n+        })\n     };\n \n     // Add `this`, whether explicit or implicit.\n@@ -429,7 +430,7 @@ fn visit_fn(v: &mut LivenessVisitor,\n \n fn visit_local(v: &mut LivenessVisitor, local: @Local, this: @mut IrMaps) {\n     let def_map = this.tcx.def_map;\n-    do pat_util::pat_bindings(def_map, local.pat) |bm, p_id, sp, path| {\n+    pat_util::pat_bindings(def_map, local.pat, |bm, p_id, sp, path| {\n         debug!(\"adding local variable {}\", p_id);\n         let name = ast_util::path_to_ident(path);\n         this.add_live_node_for_node(p_id, VarDefNode(sp));\n@@ -447,14 +448,14 @@ fn visit_local(v: &mut LivenessVisitor, local: @Local, this: @mut IrMaps) {\n           is_mutbl: mutbl,\n           kind: kind\n         }));\n-    }\n+    });\n     visit::walk_local(v, local, this);\n }\n \n fn visit_arm(v: &mut LivenessVisitor, arm: &Arm, this: @mut IrMaps) {\n     let def_map = this.tcx.def_map;\n     for pat in arm.pats.iter() {\n-        do pat_util::pat_bindings(def_map, *pat) |bm, p_id, sp, path| {\n+        pat_util::pat_bindings(def_map, *pat, |bm, p_id, sp, path| {\n             debug!(\"adding local variable {} from match with bm {:?}\",\n                    p_id, bm);\n             let name = ast_util::path_to_ident(path);\n@@ -469,7 +470,7 @@ fn visit_arm(v: &mut LivenessVisitor, arm: &Arm, this: @mut IrMaps) {\n                 is_mutbl: mutbl,\n                 kind: FromMatch(bm)\n             }));\n-        }\n+        })\n     }\n     visit::walk_arm(v, arm, this);\n }\n@@ -628,9 +629,9 @@ impl Liveness {\n         match expr.node {\n           ExprPath(_) => {\n             let def = self.tcx.def_map.get_copy(&expr.id);\n-            do moves::moved_variable_node_id_from_def(def).map |rdef| {\n+            moves::moved_variable_node_id_from_def(def).map(|rdef| {\n                 self.variable(rdef, expr.span)\n-            }\n+            })\n           }\n           _ => None\n         }\n@@ -644,9 +645,9 @@ impl Liveness {\n                                  -> Option<Variable> {\n         match self.tcx.def_map.find(&node_id) {\n           Some(&def) => {\n-            do moves::moved_variable_node_id_from_def(def).map |rdef| {\n+            moves::moved_variable_node_id_from_def(def).map(|rdef| {\n                 self.variable(rdef, span)\n-            }\n+            })\n           }\n           None => {\n             self.tcx.sess.span_bug(\n@@ -659,11 +660,11 @@ impl Liveness {\n                         pat: @Pat,\n                         f: |LiveNode, Variable, Span, NodeId|) {\n         let def_map = self.tcx.def_map;\n-        do pat_util::pat_bindings(def_map, pat) |_bm, p_id, sp, _n| {\n+        pat_util::pat_bindings(def_map, pat, |_bm, p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n             let var = self.variable(p_id, sp);\n             f(ln, var, sp, p_id);\n-        }\n+        })\n     }\n \n     pub fn arm_pats_bindings(&self,\n@@ -685,11 +686,11 @@ impl Liveness {\n     pub fn define_bindings_in_arm_pats(&self, pats: &[@Pat], succ: LiveNode)\n                                        -> LiveNode {\n         let mut succ = succ;\n-        do self.arm_pats_bindings(pats) |ln, var, _sp, _id| {\n+        self.arm_pats_bindings(pats, |ln, var, _sp, _id| {\n             self.init_from_succ(ln, succ);\n             self.define(ln, var);\n             succ = ln;\n-        }\n+        });\n         succ\n     }\n \n@@ -792,14 +793,14 @@ impl Liveness {\n     }\n \n     pub fn ln_str(&self, ln: LiveNode) -> ~str {\n-        str::from_utf8_owned(do io::mem::with_mem_writer |wr| {\n+        str::from_utf8_owned(io::mem::with_mem_writer(|wr| {\n             let wr = wr as &mut io::Writer;\n             write!(wr, \"[ln({}) of kind {:?} reads\", *ln, self.ir.lnks[*ln]);\n             self.write_vars(wr, ln, |idx| self.users[idx].reader );\n             write!(wr, \"  writes\");\n             self.write_vars(wr, ln, |idx| self.users[idx].writer );\n             write!(wr, \"  precedes {}]\", self.successors[*ln].to_str());\n-        })\n+        }))\n     }\n \n     pub fn init_empty(&self, ln: LiveNode, succ_ln: LiveNode) {\n@@ -833,7 +834,7 @@ impl Liveness {\n         if ln == succ_ln { return false; }\n \n         let mut changed = false;\n-        do self.indices2(ln, succ_ln) |idx, succ_idx| {\n+        self.indices2(ln, succ_ln, |idx, succ_idx| {\n             let users = &mut *self.users;\n             changed |= copy_if_invalid(users[succ_idx].reader,\n                                        &mut users[idx].reader);\n@@ -843,7 +844,7 @@ impl Liveness {\n                 users[idx].used = true;\n                 changed = true;\n             }\n-        }\n+        });\n \n         debug!(\"merge_from_succ(ln={}, succ={}, first_merge={}, changed={})\",\n                ln.to_str(), self.ln_str(succ_ln), first_merge, changed);\n@@ -939,9 +940,9 @@ impl Liveness {\n     pub fn propagate_through_block(&self, blk: &Block, succ: LiveNode)\n                                    -> LiveNode {\n         let succ = self.propagate_through_opt_expr(blk.expr, succ);\n-        do blk.stmts.rev_iter().fold(succ) |succ, stmt| {\n+        blk.stmts.rev_iter().fold(succ, |succ, stmt| {\n             self.propagate_through_stmt(*stmt, succ)\n-        }\n+        })\n     }\n \n     pub fn propagate_through_stmt(&self, stmt: &Stmt, succ: LiveNode)\n@@ -993,18 +994,18 @@ impl Liveness {\n \n     pub fn propagate_through_exprs(&self, exprs: &[@Expr], succ: LiveNode)\n                                    -> LiveNode {\n-        do exprs.rev_iter().fold(succ) |succ, expr| {\n+        exprs.rev_iter().fold(succ, |succ, expr| {\n             self.propagate_through_expr(*expr, succ)\n-        }\n+        })\n     }\n \n     pub fn propagate_through_opt_expr(&self,\n                                       opt_expr: Option<@Expr>,\n                                       succ: LiveNode)\n                                       -> LiveNode {\n-        do opt_expr.iter().fold(succ) |succ, expr| {\n+        opt_expr.iter().fold(succ, |succ, expr| {\n             self.propagate_through_expr(*expr, succ)\n-        }\n+        })\n     }\n \n     pub fn propagate_through_expr(&self, expr: @Expr, succ: LiveNode)\n@@ -1037,12 +1038,12 @@ impl Liveness {\n                  // the construction of a closure itself is not important,\n                  // but we have to consider the closed over variables.\n                  let caps = self.ir.captures(expr);\n-                 do caps.rev_iter().fold(succ) |succ, cap| {\n+                 caps.rev_iter().fold(succ, |succ, cap| {\n                      self.init_from_succ(cap.ln, succ);\n                      let var = self.variable(cap.var_nid, expr.span);\n                      self.acc(cap.ln, var, ACC_READ | ACC_USE);\n                      cap.ln\n-                 }\n+                 })\n               })\n           }\n \n@@ -1177,9 +1178,9 @@ impl Liveness {\n \n           ExprStruct(_, ref fields, with_expr) => {\n             let succ = self.propagate_through_opt_expr(with_expr, succ);\n-            do fields.rev_iter().fold(succ) |succ, field| {\n+            fields.rev_iter().fold(succ, |succ, field| {\n                 self.propagate_through_expr(field.expr, succ)\n-            }\n+            })\n           }\n \n           ExprCall(f, ref args, _) => {\n@@ -1230,15 +1231,15 @@ impl Liveness {\n           }\n \n           ExprInlineAsm(ref ia) => {\n-            let succ = do ia.inputs.rev_iter().fold(succ) |succ, &(_, expr)| {\n+            let succ = ia.inputs.rev_iter().fold(succ, |succ, &(_, expr)| {\n                 self.propagate_through_expr(expr, succ)\n-            };\n-            do ia.outputs.rev_iter().fold(succ) |succ, &(_, expr)| {\n+            });\n+            ia.outputs.rev_iter().fold(succ, |succ, &(_, expr)| {\n                 // see comment on lvalues in\n                 // propagate_through_lvalue_components()\n                 let succ = self.write_lvalue(expr, succ, ACC_WRITE);\n                 self.propagate_through_lvalue_components(expr, succ)\n-            }\n+            })\n           }\n \n           ExprLogLevel |\n@@ -1437,7 +1438,7 @@ fn check_local(this: &mut Liveness, local: @Local) {\n         // should not be live at this point.\n \n         debug!(\"check_local() with no initializer\");\n-        do this.pat_bindings(local.pat) |ln, var, sp, id| {\n+        this.pat_bindings(local.pat, |ln, var, sp, id| {\n             if !this.warn_about_unused(sp, id, ln, var) {\n                 match this.live_on_exit(ln, var) {\n                   None => { /* not live: good */ }\n@@ -1448,17 +1449,17 @@ fn check_local(this: &mut Liveness, local: @Local) {\n                   }\n                 }\n             }\n-        }\n+        })\n       }\n     }\n \n     visit::walk_local(this, local, ());\n }\n \n fn check_arm(this: &mut Liveness, arm: &Arm) {\n-    do this.arm_pats_bindings(arm.pats) |ln, var, sp, id| {\n+    this.arm_pats_bindings(arm.pats, |ln, var, sp, id| {\n         this.warn_about_unused(sp, id, ln, var);\n-    }\n+    });\n     visit::walk_arm(this, arm, ());\n }\n \n@@ -1620,20 +1621,21 @@ impl Liveness {\n \n     pub fn warn_about_unused_args(&self, decl: &fn_decl, entry_ln: LiveNode) {\n         for arg in decl.inputs.iter() {\n-            do pat_util::pat_bindings(self.tcx.def_map, arg.pat)\n-                    |_bm, p_id, sp, _n| {\n+            pat_util::pat_bindings(self.tcx.def_map,\n+                                   arg.pat,\n+                                   |_bm, p_id, sp, _n| {\n                 let var = self.variable(p_id, sp);\n                 self.warn_about_unused(sp, p_id, entry_ln, var);\n-            }\n+            })\n         }\n     }\n \n     pub fn warn_about_unused_or_dead_vars_in_pat(&self, pat: @Pat) {\n-        do self.pat_bindings(pat) |ln, var, sp, id| {\n+        self.pat_bindings(pat, |ln, var, sp, id| {\n             if !self.warn_about_unused(sp, id, ln, var) {\n                 self.warn_about_dead_assign(sp, id, ln, var);\n             }\n-        }\n+        })\n     }\n \n     pub fn warn_about_unused(&self,"}, {"sha": "93465dc9bac9144832372b6e9da33ae805e6ddb4", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -614,7 +614,7 @@ impl VisitContext {\n          * into itself or not based on its type and annotation.\n          */\n \n-        do pat_bindings(self.tcx.def_map, pat) |bm, id, _span, path| {\n+        pat_bindings(self.tcx.def_map, pat, |bm, id, _span, path| {\n             let binding_moves = match bm {\n                 BindByRef(_) => false,\n                 BindByValue(_) => {\n@@ -633,7 +633,7 @@ impl VisitContext {\n             if binding_moves {\n                 self.move_maps.moves_map.insert(id);\n             }\n-        }\n+        })\n     }\n \n     pub fn use_receiver(&mut self,"}, {"sha": "69e9e4d880df05352f6b26f37df4dc478251c1d6", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -22,9 +22,9 @@ pub type PatIdMap = HashMap<Ident, NodeId>;\n // use the NodeId of their namesake in the first pattern.\n pub fn pat_id_map(dm: resolve::DefMap, pat: &Pat) -> PatIdMap {\n     let mut map = HashMap::new();\n-    do pat_bindings(dm, pat) |_bm, p_id, _s, n| {\n+    pat_bindings(dm, pat, |_bm, p_id, _s, n| {\n       map.insert(path_to_ident(n), p_id);\n-    };\n+    });\n     map\n }\n \n@@ -75,15 +75,15 @@ pub fn pat_is_binding_or_wild(dm: resolve::DefMap, pat: &Pat) -> bool {\n pub fn pat_bindings(dm: resolve::DefMap,\n                     pat: &Pat,\n                     it: |BindingMode, NodeId, Span, &Path|) {\n-    do walk_pat(pat) |p| {\n+    walk_pat(pat, |p| {\n         match p.node {\n           PatIdent(binding_mode, ref pth, _) if pat_is_binding(dm, p) => {\n             it(binding_mode, p.id, p.span, pth);\n           }\n           _ => {}\n         }\n         true\n-    };\n+    });\n }\n \n pub fn pat_binding_ids(dm: resolve::DefMap, pat: &Pat) -> ~[NodeId] {\n@@ -96,13 +96,13 @@ pub fn pat_binding_ids(dm: resolve::DefMap, pat: &Pat) -> ~[NodeId] {\n /// an ident, e.g. `foo`, or `Foo(foo)` or `foo @ Bar(*)`.\n pub fn pat_contains_bindings(dm: resolve::DefMap, pat: &Pat) -> bool {\n     let mut contains_bindings = false;\n-    do walk_pat(pat) |p| {\n+    walk_pat(pat, |p| {\n         if pat_is_binding(dm, p) {\n             contains_bindings = true;\n             false // there's at least one binding, can short circuit now.\n         } else {\n             true\n         }\n-    };\n+    });\n     contains_bindings\n }"}, {"sha": "c2a21905be6d54c0a82c0fea2e6f9c93b040ac3b", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -232,10 +232,10 @@ impl<'self> Visitor<()> for EmbargoVisitor<'self> {\n                     _ => true,\n                 };\n                 let tr = ty::impl_trait_ref(self.tcx, local_def(item.id));\n-                let public_trait = do tr.map_default(false) |tr| {\n+                let public_trait = tr.map_default(false, |tr| {\n                     !is_local(tr.def_id) ||\n                      self.exported_items.contains(&tr.def_id.node)\n-                };\n+                });\n \n                 if public_ty || public_trait {\n                     for method in methods.iter() {"}, {"sha": "49f26568d3726babaa7345d08f945966409afad0", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 78, "deletions": 66, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -909,11 +909,12 @@ impl<'self> Visitor<ReducedGraphParent> for BuildReducedGraphVisitor<'self> {\n \n     fn visit_foreign_item(&mut self, foreign_item: @foreign_item,\n                           context:ReducedGraphParent) {\n-        do self.resolver.build_reduced_graph_for_foreign_item(foreign_item,\n-                                                              context) |r, c| {\n+        self.resolver.build_reduced_graph_for_foreign_item(foreign_item,\n+                                                           context,\n+                                                           |r, c| {\n             let mut v = BuildReducedGraphVisitor{ resolver: r };\n             visit::walk_foreign_item(&mut v, foreign_item, c);\n-        }\n+        })\n     }\n \n     fn visit_view_item(&mut self, view_item:&view_item, context:ReducedGraphParent) {\n@@ -1227,11 +1228,11 @@ impl Resolver {\n \n                 // If this is a newtype or unit-like struct, define a name\n                 // in the value namespace as well\n-                do ctor_id.while_some |cid| {\n+                ctor_id.while_some(|cid| {\n                     name_bindings.define_value(DefStruct(local_def(cid)), sp,\n                                                is_public);\n                     None\n-                }\n+                });\n \n                 // Record the def ID of this struct.\n                 self.structs.insert(local_def(item.id));\n@@ -1553,12 +1554,12 @@ impl Resolver {\n                 let def = DefFn(local_def(foreign_item.id), unsafe_fn);\n                 name_bindings.define_value(def, foreign_item.span, is_public);\n \n-                do self.with_type_parameter_rib(\n-                    HasTypeParameters(\n-                        generics, foreign_item.id, 0, NormalRibKind)) |this|\n-                {\n-                    f(this, new_parent)\n-                }\n+                self.with_type_parameter_rib(\n+                    HasTypeParameters(generics,\n+                                      foreign_item.id,\n+                                      0,\n+                                      NormalRibKind),\n+                    |this| f(this, new_parent));\n             }\n             foreign_item_static(_, m) => {\n                 let def = DefStatic(local_def(foreign_item.id), m);\n@@ -1758,15 +1759,17 @@ impl Resolver {\n                     DefForeignMod(def_id) => {\n                         // Foreign modules have no names. Recur and populate\n                         // eagerly.\n-                        do csearch::each_child_of_item(self.session.cstore,\n-                                                       def_id)\n-                                |def_like, child_ident, vis| {\n+                        csearch::each_child_of_item(self.session.cstore,\n+                                                    def_id,\n+                                                    |def_like,\n+                                                     child_ident,\n+                                                     vis| {\n                             self.build_reduced_graph_for_external_crate_def(\n                                 root,\n                                 def_like,\n                                 child_ident,\n                                 vis)\n-                        }\n+                        });\n                     }\n                     _ => {\n                         let (child_name_bindings, new_parent) =\n@@ -1893,15 +1896,16 @@ impl Resolver {\n             Some(def_id) => def_id,\n         };\n \n-        do csearch::each_child_of_item(self.session.cstore, def_id)\n-                |def_like, child_ident, visibility| {\n+        csearch::each_child_of_item(self.session.cstore,\n+                                    def_id,\n+                                    |def_like, child_ident, visibility| {\n             debug!(\"(populating external module) ... found ident: {}\",\n                    token::ident_to_str(&child_ident));\n             self.build_reduced_graph_for_external_crate_def(module,\n                                                             def_like,\n                                                             child_ident,\n                                                             visibility)\n-        }\n+        });\n         module.populated = true\n     }\n \n@@ -1918,14 +1922,14 @@ impl Resolver {\n     /// crate.\n     fn build_reduced_graph_for_external_crate(&mut self,\n                                               root: @mut Module) {\n-        do csearch::each_top_level_item_of_crate(self.session.cstore,\n-                                                 root.def_id.unwrap().crate)\n-                |def_like, ident, visibility| {\n+        csearch::each_top_level_item_of_crate(self.session.cstore,\n+                                              root.def_id.unwrap().crate,\n+                                              |def_like, ident, visibility| {\n             self.build_reduced_graph_for_external_crate_def(root,\n                                                             def_like,\n                                                             ident,\n                                                             visibility)\n-        }\n+        });\n     }\n \n     /// Creates and adds an import directive to the given module.\n@@ -3544,20 +3548,23 @@ impl Resolver {\n                 // n.b. the discr expr gets visted twice.\n                 // but maybe it's okay since the first time will signal an\n                 // error if there is one? -- tjc\n-                do self.with_type_parameter_rib(\n-                    HasTypeParameters(\n-                        generics, item.id, 0, NormalRibKind)) |this| {\n+                self.with_type_parameter_rib(HasTypeParameters(generics,\n+                                                               item.id,\n+                                                               0,\n+                                                               NormalRibKind),\n+                                             |this| {\n                     visit::walk_item(this, item, ());\n-                }\n+                });\n             }\n \n             item_ty(_, ref generics) => {\n-                do self.with_type_parameter_rib\n-                        (HasTypeParameters(generics, item.id, 0,\n-                                           NormalRibKind))\n-                        |this| {\n+                self.with_type_parameter_rib(HasTypeParameters(generics,\n+                                                               item.id,\n+                                                               0,\n+                                                               NormalRibKind),\n+                                             |this| {\n                     visit::walk_item(this, item, ());\n-                }\n+                });\n             }\n \n             item_impl(ref generics,\n@@ -3581,10 +3588,11 @@ impl Resolver {\n                                               DlDef(DefSelfTy(item.id)));\n \n                 // Create a new rib for the trait-wide type parameters.\n-                do self.with_type_parameter_rib\n-                        (HasTypeParameters(generics, item.id, 0,\n-                                           NormalRibKind)) |this| {\n-\n+                self.with_type_parameter_rib(HasTypeParameters(generics,\n+                                                               item.id,\n+                                                               0,\n+                                                               NormalRibKind),\n+                                             |this| {\n                     this.resolve_type_parameters(&generics.ty_params);\n \n                     // Resolve derived traits.\n@@ -3600,11 +3608,12 @@ impl Resolver {\n \n                         match *method {\n                           required(ref ty_m) => {\n-                            do this.with_type_parameter_rib\n+                            this.with_type_parameter_rib\n                                 (HasTypeParameters(&ty_m.generics,\n                                                    item.id,\n                                                    generics.ty_params.len(),\n-                                        MethodRibKind(item.id, Required))) |this| {\n+                                        MethodRibKind(item.id, Required)),\n+                                 |this| {\n \n                                 // Resolve the method-specific type\n                                 // parameters.\n@@ -3616,7 +3625,7 @@ impl Resolver {\n                                 }\n \n                                 this.resolve_type(&ty_m.decl.output);\n-                            }\n+                            });\n                           }\n                           provided(m) => {\n                               this.resolve_method(MethodRibKind(item.id,\n@@ -3626,7 +3635,7 @@ impl Resolver {\n                           }\n                         }\n                     }\n-                }\n+                });\n \n                 self.type_ribs.pop();\n             }\n@@ -3638,14 +3647,14 @@ impl Resolver {\n             }\n \n             item_mod(ref module_) => {\n-                do self.with_scope(Some(item.ident)) |this| {\n+                self.with_scope(Some(item.ident), |this| {\n                     this.resolve_module(module_, item.span, item.ident,\n                                         item.id);\n-                }\n+                });\n             }\n \n             item_foreign_mod(ref foreign_module) => {\n-                do self.with_scope(Some(item.ident)) |this| {\n+                self.with_scope(Some(item.ident), |this| {\n                     for foreign_item in foreign_module.items.iter() {\n                         match foreign_item.node {\n                             foreign_item_fn(_, ref generics) => {\n@@ -3664,7 +3673,7 @@ impl Resolver {\n                             }\n                         }\n                     }\n-                }\n+                });\n             }\n \n             item_fn(ref fn_decl, _, _, ref generics, ref block) => {\n@@ -3764,7 +3773,7 @@ impl Resolver {\n         self.label_ribs.push(function_label_rib);\n \n         // If this function has type parameters, add them now.\n-        do self.with_type_parameter_rib(type_parameters) |this| {\n+        self.with_type_parameter_rib(type_parameters, |this| {\n             // Resolve the type parameters.\n             match type_parameters {\n                 NoTypeParameters => {\n@@ -3815,7 +3824,7 @@ impl Resolver {\n             this.resolve_block(block);\n \n             debug!(\"(resolving function) leaving function\");\n-        }\n+        });\n \n         self.label_ribs.pop();\n         self.value_ribs.pop();\n@@ -3890,18 +3899,19 @@ impl Resolver {\n         }\n \n         // If applicable, create a rib for the type parameters.\n-        do self.with_type_parameter_rib(HasTypeParameters\n-                                        (generics, id, 0,\n-                                         OpaqueFunctionRibKind)) |this| {\n-\n+        self.with_type_parameter_rib(HasTypeParameters(generics,\n+                                                       id,\n+                                                       0,\n+                                                       OpaqueFunctionRibKind),\n+                                     |this| {\n             // Resolve the type parameters.\n             this.resolve_type_parameters(&generics.ty_params);\n \n             // Resolve fields.\n             for field in fields.iter() {\n                 this.resolve_type(&field.node.ty);\n             }\n-        }\n+        });\n     }\n \n     // Does this really need to take a RibKind or is it always going\n@@ -3937,9 +3947,11 @@ impl Resolver {\n                                   methods: &[@method]) {\n         // If applicable, create a rib for the type parameters.\n         let outer_type_parameter_count = generics.ty_params.len();\n-        do self.with_type_parameter_rib(HasTypeParameters\n-                                        (generics, id, 0,\n-                                         NormalRibKind)) |this| {\n+        self.with_type_parameter_rib(HasTypeParameters(generics,\n+                                                       id,\n+                                                       0,\n+                                                       NormalRibKind),\n+                                     |this| {\n             // Resolve the type parameters.\n             this.resolve_type_parameters(&generics.ty_params);\n \n@@ -4000,7 +4012,7 @@ impl Resolver {\n                 Some(r) => { this.current_trait_refs = r; }\n                 None => ()\n             }\n-        }\n+        });\n     }\n \n     fn resolve_module(&mut self,\n@@ -4037,12 +4049,12 @@ impl Resolver {\n     // user and one 'x' came from the macro.\n     fn binding_mode_map(&mut self, pat: @Pat) -> BindingMap {\n         let mut result = HashMap::new();\n-        do pat_bindings(self.def_map, pat) |binding_mode, _id, sp, path| {\n+        pat_bindings(self.def_map, pat, |binding_mode, _id, sp, path| {\n             let name = mtwt_resolve(path_to_ident(path));\n             result.insert(name,\n                           binding_info {span: sp,\n                                         binding_mode: binding_mode});\n-        }\n+        });\n         return result;\n     }\n \n@@ -4210,19 +4222,19 @@ impl Resolver {\n                     }\n                 }\n \n-                do bounds.as_ref().map |bound_vec| {\n+                bounds.as_ref().map(|bound_vec| {\n                     for bound in bound_vec.iter() {\n                         self.resolve_type_parameter_bound(ty.id, bound);\n                     }\n-                };\n+                });\n             }\n \n             ty_closure(c) => {\n-                do c.bounds.as_ref().map |bounds| {\n+                c.bounds.as_ref().map(|bounds| {\n                     for bound in bounds.iter() {\n                         self.resolve_type_parameter_bound(ty.id, bound);\n                     }\n-                };\n+                });\n                 visit::walk_ty(self, ty, ());\n             }\n \n@@ -4240,7 +4252,7 @@ impl Resolver {\n                        // pattern that binds them\n                        bindings_list: Option<@mut HashMap<Name,NodeId>>) {\n         let pat_id = pattern.id;\n-        do walk_pat(pattern) |pattern| {\n+        walk_pat(pattern, |pattern| {\n             match pattern.node {\n                 PatIdent(binding_mode, ref path, _)\n                         if !path.global && path.segments.len() == 1 => {\n@@ -4480,7 +4492,7 @@ impl Resolver {\n                 }\n             }\n             true\n-        };\n+        });\n     }\n \n     fn resolve_bare_identifier_pattern(&mut self, name: Ident)\n@@ -5056,14 +5068,14 @@ impl Resolver {\n             }\n \n             ExprLoop(_, Some(label)) => {\n-                do self.with_label_rib |this| {\n+                self.with_label_rib(|this| {\n                     let def_like = DlDef(DefLabel(expr.id));\n                     let rib = this.label_ribs[this.label_ribs.len() - 1];\n                     // plain insert (no renaming)\n                     rib.bindings.insert(label.name, def_like);\n \n                     visit::walk_expr(this, expr, ());\n-                }\n+                })\n             }\n \n             ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n@@ -5316,15 +5328,15 @@ impl Resolver {\n         debug!(\"(recording def) recording {:?} for {:?}, last private {:?}\",\n                 def, node_id, lp);\n         self.last_private.insert(node_id, lp);\n-        do self.def_map.insert_or_update_with(node_id, def) |_, old_value| {\n+        self.def_map.insert_or_update_with(node_id, def, |_, old_value| {\n             // Resolve appears to \"resolve\" the same ID multiple\n             // times, so here is a sanity check it at least comes to\n             // the same conclusion! - nmatsakis\n             if def != *old_value {\n                 self.session.bug(format!(\"node_id {:?} resolved first to {:?} \\\n                                       and then {:?}\", node_id, *old_value, def));\n             }\n-        };\n+        });\n     }\n \n     fn enforce_default_binding_mode(&mut self,"}, {"sha": "1162f845ed07ac7f40d6df167b8bb0a2233dd17d", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -446,7 +446,7 @@ fn expand_nested_bindings<'r>(bcx: @mut Block,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    do m.map |br| {\n+    m.map(|br| {\n         match br.pats[col].node {\n             ast::PatIdent(_, ref path, Some(inner)) => {\n                 let pats = vec::append(\n@@ -465,7 +465,7 @@ fn expand_nested_bindings<'r>(bcx: @mut Block,\n             }\n             _ => (*br).clone(),\n         }\n-    }\n+    })\n }\n \n fn assert_is_binding_or_wild(bcx: @mut Block, p: @ast::Pat) {\n@@ -477,7 +477,7 @@ fn assert_is_binding_or_wild(bcx: @mut Block, p: @ast::Pat) {\n     }\n }\n \n-type enter_pat<'self> = &'self fn(@ast::Pat) -> Option<~[@ast::Pat]>;\n+type enter_pat<'self> = 'self |@ast::Pat| -> Option<~[@ast::Pat]>;\n \n fn enter_match<'r>(bcx: @mut Block,\n                        dm: DefMap,\n@@ -543,13 +543,13 @@ fn enter_default<'r>(bcx: @mut Block,\n     let _indenter = indenter();\n \n     // Collect all of the matches that can match against anything.\n-    let matches = do enter_match(bcx, dm, m, col, val) |p| {\n+    let matches = enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n           ast::PatWild | ast::PatWildMulti | ast::PatTup(_) => Some(~[]),\n           ast::PatIdent(_, _, None) if pat_is_binding(dm, p) => Some(~[]),\n           _ => None\n         }\n-    };\n+    });\n \n     // Ok, now, this is pretty subtle. A \"default\" match is a match\n     // that needs to be considered if none of the actual checks on the\n@@ -616,7 +616,7 @@ fn enter_opt<'r>(bcx: @mut Block,\n     let tcx = bcx.tcx();\n     let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: dummy_sp()};\n     let mut i = 0;\n-    do enter_match(bcx, tcx.def_map, m, col, val) |p| {\n+    enter_match(bcx, tcx.def_map, m, col, val, |p| {\n         let answer = match p.node {\n             ast::PatEnum(*) |\n             ast::PatIdent(_, _, None) if pat_is_const(tcx.def_map, p) => {\n@@ -731,7 +731,7 @@ fn enter_opt<'r>(bcx: @mut Block,\n         };\n         i += 1;\n         answer\n-    }\n+    })\n }\n \n fn enter_rec_or_struct<'r>(bcx: @mut Block,\n@@ -749,7 +749,7 @@ fn enter_rec_or_struct<'r>(bcx: @mut Block,\n     let _indenter = indenter();\n \n     let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: dummy_sp()};\n-    do enter_match(bcx, dm, m, col, val) |p| {\n+    enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatStruct(_, ref fpats, _) => {\n                 let mut pats = ~[];\n@@ -766,7 +766,7 @@ fn enter_rec_or_struct<'r>(bcx: @mut Block,\n                 Some(vec::from_elem(fields.len(), dummy))\n             }\n         }\n-    }\n+    })\n }\n \n fn enter_tup<'r>(bcx: @mut Block,\n@@ -784,15 +784,15 @@ fn enter_tup<'r>(bcx: @mut Block,\n     let _indenter = indenter();\n \n     let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: dummy_sp()};\n-    do enter_match(bcx, dm, m, col, val) |p| {\n+    enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatTup(ref elts) => Some((*elts).clone()),\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n                 Some(vec::from_elem(n_elts, dummy))\n             }\n         }\n-    }\n+    })\n }\n \n fn enter_tuple_struct<'r>(bcx: @mut Block,\n@@ -810,15 +810,15 @@ fn enter_tuple_struct<'r>(bcx: @mut Block,\n     let _indenter = indenter();\n \n     let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: dummy_sp()};\n-    do enter_match(bcx, dm, m, col, val) |p| {\n+    enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatEnum(_, Some(ref elts)) => Some((*elts).clone()),\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n                 Some(vec::from_elem(n_elts, dummy))\n             }\n         }\n-    }\n+    })\n }\n \n fn enter_box<'r>(bcx: @mut Block,\n@@ -835,7 +835,7 @@ fn enter_box<'r>(bcx: @mut Block,\n     let _indenter = indenter();\n \n     let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: dummy_sp()};\n-    do enter_match(bcx, dm, m, col, val) |p| {\n+    enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatBox(sub) => {\n                 Some(~[sub])\n@@ -845,7 +845,7 @@ fn enter_box<'r>(bcx: @mut Block,\n                 Some(~[dummy])\n             }\n         }\n-    }\n+    })\n }\n \n fn enter_uniq<'r>(bcx: @mut Block,\n@@ -862,7 +862,7 @@ fn enter_uniq<'r>(bcx: @mut Block,\n     let _indenter = indenter();\n \n     let dummy = @ast::Pat {id: 0, node: ast::PatWild, span: dummy_sp()};\n-    do enter_match(bcx, dm, m, col, val) |p| {\n+    enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatUniq(sub) => {\n                 Some(~[sub])\n@@ -872,7 +872,7 @@ fn enter_uniq<'r>(bcx: @mut Block,\n                 Some(~[dummy])\n             }\n         }\n-    }\n+    })\n }\n \n fn enter_region<'r>(bcx: @mut Block,\n@@ -889,7 +889,7 @@ fn enter_region<'r>(bcx: @mut Block,\n     let _indenter = indenter();\n \n     let dummy = @ast::Pat { id: 0, node: ast::PatWild, span: dummy_sp() };\n-    do enter_match(bcx, dm, m, col, val) |p| {\n+    enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n             ast::PatRegion(sub) => {\n                 Some(~[sub])\n@@ -899,7 +899,7 @@ fn enter_region<'r>(bcx: @mut Block,\n                 Some(~[dummy])\n             }\n         }\n-    }\n+    })\n }\n \n // Returns the options in one column of matches. An option is something that\n@@ -998,9 +998,9 @@ fn extract_variant_args(bcx: @mut Block,\n                             val: ValueRef)\n     -> ExtractedBlock {\n     let _icx = push_ctxt(\"match::extract_variant_args\");\n-    let args = do vec::from_fn(adt::num_args(repr, disr_val)) |i| {\n+    let args = vec::from_fn(adt::num_args(repr, disr_val), |i| {\n         adt::trans_field_ptr(bcx, repr, val, disr_val, i)\n-    };\n+    });\n \n     ExtractedBlock { vals: args, bcx: bcx }\n }\n@@ -1028,7 +1028,7 @@ fn extract_vec_elems(bcx: @mut Block,\n     let (bcx, base, len) = vec_datum.get_vec_base_and_len(bcx, pat_span, pat_id, 0);\n     let vt = tvec::vec_types(bcx, node_id_type(bcx, pat_id));\n \n-    let mut elems = do vec::from_fn(elem_count) |i| {\n+    let mut elems = vec::from_fn(elem_count, |i| {\n         match slice {\n             None => GEPi(bcx, base, [i]),\n             Some(n) if i < n => GEPi(bcx, base, [i]),\n@@ -1039,7 +1039,7 @@ fn extract_vec_elems(bcx: @mut Block,\n             }\n             _ => unsafe { llvm::LLVMGetUndef(vt.llunit_ty.to_ref()) }\n         }\n-    };\n+    });\n     if slice.is_some() {\n         let n = slice.unwrap();\n         let slice_byte_offset = Mul(bcx, vt.llunit_size, C_uint(bcx.ccx(), n));\n@@ -1108,11 +1108,11 @@ fn pats_require_rooting(bcx: @mut Block,\n                             m: &[Match],\n                             col: uint)\n                          -> bool {\n-    do m.iter().any |br| {\n+    m.iter().any(|br| {\n         let pat_id = br.pats[col].id;\n         let key = root_map_key {id: pat_id, derefs: 0u };\n         bcx.ccx().maps.root_map.contains_key(&key)\n-    }\n+    })\n }\n \n fn root_pats_as_necessary(mut bcx: @mut Block,\n@@ -1137,12 +1137,12 @@ fn root_pats_as_necessary(mut bcx: @mut Block,\n // matches may be wildcards like _ or identifiers).\n macro_rules! any_pat (\n     ($m:expr, $pattern:pat) => (\n-        do ($m).iter().any |br| {\n+        ($m).iter().any(|br| {\n             match br.pats[col].node {\n                 $pattern => true,\n                 _ => false\n             }\n-        }\n+        })\n     )\n )\n \n@@ -1163,7 +1163,7 @@ fn any_tup_pat(m: &[Match], col: uint) -> bool {\n }\n \n fn any_tuple_struct_pat(bcx: @mut Block, m: &[Match], col: uint) -> bool {\n-    do m.iter().any |br| {\n+    m.iter().any(|br| {\n         let pat = br.pats[col];\n         match pat.node {\n             ast::PatEnum(_, Some(_)) => {\n@@ -1175,7 +1175,7 @@ fn any_tuple_struct_pat(bcx: @mut Block, m: &[Match], col: uint) -> bool {\n             }\n             _ => false\n         }\n-    }\n+    })\n }\n \n trait CustomFailureHandler {\n@@ -1335,11 +1335,11 @@ fn store_non_ref_bindings(bcx: @mut Block,\n                 let datum = Datum {val: llval, ty: binding_info.ty,\n                                    mode: ByRef(ZeroMem)};\n                 bcx = datum.store_to(bcx, INIT, lldest);\n-                do opt_temp_cleanups.mutate |temp_cleanups| {\n+                opt_temp_cleanups.mutate(|temp_cleanups| {\n                     add_clean_temp_mem(bcx, lldest, binding_info.ty);\n                     temp_cleanups.push(lldest);\n                     temp_cleanups\n-                };\n+                });\n             }\n             TrByRef => {}\n         }\n@@ -1412,10 +1412,9 @@ fn compile_guard(bcx: @mut Block,\n     bcx = insert_lllocals(bcx, data.bindings_map, false);\n \n     let val = unpack_result!(bcx, {\n-        do with_scope_result(bcx, guard_expr.info(),\n-                             \"guard\") |bcx| {\n+        with_scope_result(bcx, guard_expr.info(), \"guard\", |bcx| {\n             expr::trans_to_datum(bcx, guard_expr).to_result()\n-        }\n+        })\n     });\n     let val = bool_to_i1(bcx, val);\n \n@@ -1424,13 +1423,13 @@ fn compile_guard(bcx: @mut Block,\n         revoke_clean(bcx, *llval);\n     }\n \n-    return do with_cond(bcx, Not(bcx, val)) |bcx| {\n+    return with_cond(bcx, Not(bcx, val), |bcx| {\n         // Guard does not match: free the values we copied,\n         // and remove all bindings from the lllocals table\n         let bcx = drop_bindings(bcx, data);\n         compile_submatch(bcx, m, vals, chk);\n         bcx\n-    };\n+    });\n \n     fn drop_bindings(bcx: @mut Block, data: &ArmData) -> @mut Block {\n         let mut bcx = bcx;\n@@ -1530,7 +1529,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n         Some(ref rec_fields) => {\n             let pat_ty = node_id_type(bcx, pat_id);\n             let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n-            do expr::with_field_tys(tcx, pat_ty, None) |discr, field_tys| {\n+            expr::with_field_tys(tcx, pat_ty, None, |discr, field_tys| {\n                 let rec_vals = rec_fields.map(|field_name| {\n                         let ix = ty::field_idx_strict(tcx, field_name.name, field_tys);\n                         adt::trans_field_ptr(bcx, pat_repr, val, discr, ix)\n@@ -1540,7 +1539,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n                         enter_rec_or_struct(bcx, dm, m, col, *rec_fields, val),\n                         vec::append(rec_vals, vals_left),\n                         chk);\n-            }\n+            });\n             return;\n         }\n         None => {}\n@@ -1553,9 +1552,9 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n           ty::ty_tup(ref elts) => elts.len(),\n           _ => ccx.sess.bug(\"non-tuple type in tuple pattern\")\n         };\n-        let tup_vals = do vec::from_fn(n_tup_elts) |i| {\n+        let tup_vals = vec::from_fn(n_tup_elts, |i| {\n             adt::trans_field_ptr(bcx, tup_repr, val, 0, i)\n-        };\n+        });\n         compile_submatch(bcx, enter_tup(bcx, dm, m, col, val, n_tup_elts),\n                          vec::append(tup_vals, vals_left), chk);\n         return;\n@@ -1575,9 +1574,9 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n         }\n \n         let struct_repr = adt::represent_type(bcx.ccx(), struct_ty);\n-        let llstructvals = do vec::from_fn(struct_element_count) |i| {\n+        let llstructvals = vec::from_fn(struct_element_count, |i| {\n             adt::trans_field_ptr(bcx, struct_repr, val, 0, i)\n-        };\n+        });\n         compile_submatch(bcx,\n                          enter_tuple_struct(bcx, dm, m, col, val,\n                                             struct_element_count),\n@@ -1696,8 +1695,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n               compare => {\n                   let t = node_id_type(bcx, pat_id);\n                   let Result {bcx: after_cx, val: matches} = {\n-                      do with_scope_result(bcx, None,\n-                                           \"compaReScope\") |bcx| {\n+                      with_scope_result(bcx, None, \"compaReScope\", |bcx| {\n                           match trans_opt(bcx, opt) {\n                               single_result(\n                                   Result {bcx, val}) => {\n@@ -1723,15 +1721,17 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n                                   rslt(bcx, And(bcx, llge, llle))\n                               }\n                           }\n-                      }\n+                      })\n                   };\n                   bcx = sub_block(after_cx, \"compare_next\");\n                   CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n               }\n               compare_vec_len => {\n                   let Result {bcx: after_cx, val: matches} = {\n-                      do with_scope_result(bcx, None,\n-                                           \"compare_vec_len_scope\") |bcx| {\n+                      with_scope_result(bcx,\n+                                        None,\n+                                        \"compare_vec_len_scope\",\n+                                        |bcx| {\n                           match trans_opt(bcx, opt) {\n                               single_result(\n                                   Result {bcx, val}) => {\n@@ -1761,7 +1761,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n                                   rslt(bcx, And(bcx, llge, llle))\n                               }\n                           }\n-                      }\n+                      })\n                   };\n                   bcx = sub_block(after_cx, \"compare_vec_len_next\");\n \n@@ -1821,9 +1821,9 @@ pub fn trans_match(bcx: @mut Block,\n                    arms: &[ast::Arm],\n                    dest: Dest) -> @mut Block {\n     let _icx = push_ctxt(\"match::trans_match\");\n-    do with_scope(bcx, match_expr.info(), \"match\") |bcx| {\n+    with_scope(bcx, match_expr.info(), \"match\", |bcx| {\n         trans_match_inner(bcx, discr_expr, arms, dest)\n-    }\n+    })\n }\n \n fn create_bindings_map(bcx: @mut Block, pat: @ast::Pat) -> BindingsMap {\n@@ -1834,7 +1834,7 @@ fn create_bindings_map(bcx: @mut Block, pat: @ast::Pat) -> BindingsMap {\n     let ccx = bcx.ccx();\n     let tcx = bcx.tcx();\n     let mut bindings_map = HashMap::new();\n-    do pat_bindings(tcx.def_map, pat) |bm, p_id, span, path| {\n+    pat_bindings(tcx.def_map, pat, |bm, p_id, span, path| {\n         let ident = path_to_ident(path);\n         let variable_ty = node_id_type(bcx, p_id);\n         let llvariable_ty = type_of::type_of(ccx, variable_ty);\n@@ -1862,7 +1862,7 @@ fn create_bindings_map(bcx: @mut Block, pat: @ast::Pat) -> BindingsMap {\n             span: span,\n             ty: variable_ty\n         });\n-    }\n+    });\n     return bindings_map;\n }\n \n@@ -2009,11 +2009,11 @@ pub fn store_local(bcx: @mut Block,\n         // create dummy memory for the variables if we have no\n         // value to store into them immediately\n         let tcx = bcx.tcx();\n-        do pat_bindings(tcx.def_map, pat) |_, p_id, _, path| {\n+        pat_bindings(tcx.def_map, pat, |_, p_id, _, path| {\n             bcx = mk_binding_alloca(\n                 bcx, p_id, path, BindLocal,\n                 |bcx, var_ty, llval| { zero_mem(bcx, llval, var_ty); bcx });\n-        }\n+        });\n         bcx\n     }\n }\n@@ -2201,14 +2201,14 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n             let tcx = bcx.tcx();\n             let pat_ty = node_id_type(bcx, pat.id);\n             let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n-            do expr::with_field_tys(tcx, pat_ty, None) |discr, field_tys| {\n+            expr::with_field_tys(tcx, pat_ty, None, |discr, field_tys| {\n                 for f in fields.iter() {\n                     let ix = ty::field_idx_strict(tcx, f.ident.name, field_tys);\n                     let fldptr = adt::trans_field_ptr(bcx, pat_repr, val,\n                                                       discr, ix);\n                     bcx = bind_irrefutable_pat(bcx, f.pat, fldptr, binding_mode);\n                 }\n-            }\n+            })\n         }\n         ast::PatTup(ref elems) => {\n             let repr = adt::represent_node(bcx, pat.id);"}, {"sha": "d6631f6d833cd4fa2205ebe1088efd25a48baf7c", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -135,9 +135,9 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n         }\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx, def_id);\n-            let mut ftys = do fields.map |field| {\n+            let mut ftys = fields.map(|field| {\n                 ty::lookup_field_type(cx.tcx, def_id, field.id, substs)\n-            };\n+            });\n             let packed = ty::lookup_packed(cx.tcx, def_id);\n             let dtor = ty::ty_dtor(cx.tcx, def_id).has_drop_flag();\n             if dtor { ftys.push(ty::mk_bool()); }\n@@ -259,12 +259,12 @@ impl Case {\n }\n \n fn get_cases(tcx: ty::ctxt, def_id: ast::DefId, substs: &ty::substs) -> ~[Case] {\n-    do ty::enum_variants(tcx, def_id).map |vi| {\n-        let arg_tys = do vi.args.map |&raw_ty| {\n+    ty::enum_variants(tcx, def_id).map(|vi| {\n+        let arg_tys = vi.args.map(|&raw_ty| {\n             ty::subst(tcx, substs, raw_ty)\n-        };\n+        });\n         Case { discr: vi.disr_val, tys: arg_tys }\n-    }\n+    })\n }\n \n \n@@ -659,9 +659,7 @@ fn struct_field_ptr(bcx: @mut Block, st: &Struct, val: ValueRef, ix: uint,\n     let ccx = bcx.ccx();\n \n     let val = if needs_cast {\n-        let fields = do st.fields.map |&ty| {\n-            type_of::type_of(ccx, ty)\n-        };\n+        let fields = st.fields.map(|&ty| type_of::type_of(ccx, ty));\n         let real_ty = Type::struct_(fields, st.packed);\n         PointerCast(bcx, val, real_ty.ptr_to())\n     } else {\n@@ -725,10 +723,10 @@ pub fn trans_const(ccx: &mut CrateContext, r: &Repr, discr: Disr,\n                 C_struct(build_const_struct(ccx, nonnull, vals), false)\n             } else {\n                 assert_eq!(vals.len(), 0);\n-                let vals = do nonnull.fields.iter().enumerate().map |(i, &ty)| {\n+                let vals = nonnull.fields.iter().enumerate().map(|(i, &ty)| {\n                     let llty = type_of::sizing_type_of(ccx, ty);\n                     if i == ptrfield { C_null(llty) } else { C_undef(llty) }\n-                }.collect::<~[ValueRef]>();\n+                }).collect::<~[ValueRef]>();\n                 C_struct(build_const_struct(ccx, nonnull, vals), false)\n             }\n         }"}, {"sha": "7b936b61976bcdb1dec651da636428ae2494c15a", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -35,22 +35,22 @@ pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n     let mut output_types = ~[];\n \n     // Prepare the output operands\n-    let outputs = do ia.outputs.map |&(c, out)| {\n+    let outputs = ia.outputs.map(|&(c, out)| {\n         constraints.push(c);\n \n         let out_datum = unpack_datum!(bcx, trans_to_datum(bcx, out));\n         output_types.push(type_of(bcx.ccx(), out_datum.ty));\n         out_datum.val\n \n-    };\n+    });\n \n     for c in cleanups.iter() {\n         revoke_clean(bcx, *c);\n     }\n     cleanups.clear();\n \n     // Now the input operands\n-    let inputs = do ia.inputs.map |&(c, input)| {\n+    let inputs = ia.inputs.map(|&(c, input)| {\n         constraints.push(c);\n \n         unpack_result!(bcx, {\n@@ -61,8 +61,7 @@ pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n                                    &mut cleanups,\n                                    callee::DontAutorefArg)\n         })\n-\n-    };\n+    });\n \n     for c in cleanups.iter() {\n         revoke_clean(bcx, *c);\n@@ -103,11 +102,11 @@ pub fn trans_inline_asm(bcx: @mut Block, ia: &ast::inline_asm) -> @mut Block {\n         ast::asm_intel => lib::llvm::AD_Intel\n     };\n \n-    let r = do ia.asm.with_c_str |a| {\n-        do constraints.with_c_str |c| {\n+    let r = ia.asm.with_c_str(|a| {\n+        constraints.with_c_str(|c| {\n             InlineAsmCall(bcx, a, c, inputs, output_type, ia.volatile, ia.alignstack, dialect)\n-        }\n-    };\n+        })\n+    });\n \n     // Again, based on how many outputs we have\n     if numOutputs == 1 {"}, {"sha": "de93b08f0859c579f5ae92135de0973a31bbf925", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 85, "deletions": 80, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -94,12 +94,12 @@ pub use middle::trans::context::task_llcx;\n local_data_key!(task_local_insn_key: ~[&'static str])\n \n pub fn with_insn_ctxt(blk: |&[&'static str]|) {\n-    do local_data::get(task_local_insn_key) |c| {\n+    local_data::get(task_local_insn_key, |c| {\n         match c {\n             Some(ctx) => blk(*ctx),\n             None => ()\n         }\n-    }\n+    })\n }\n \n pub fn init_insn_ctxt() {\n@@ -111,23 +111,23 @@ pub struct _InsnCtxt { _x: () }\n #[unsafe_destructor]\n impl Drop for _InsnCtxt {\n     fn drop(&mut self) {\n-        do local_data::modify(task_local_insn_key) |c| {\n-            do c.map |mut ctx| {\n+        local_data::modify(task_local_insn_key, |c| {\n+            c.map(|mut ctx| {\n                 ctx.pop();\n                 ctx\n-            }\n-        }\n+            })\n+        })\n     }\n }\n \n pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n     debug!(\"new InsnCtxt: {}\", s);\n-    do local_data::modify(task_local_insn_key) |c| {\n-        do c.map |mut ctx| {\n+    local_data::modify(task_local_insn_key, |c| {\n+        c.map(|mut ctx| {\n             ctx.push(s);\n             ctx\n-        }\n-    }\n+        })\n+    });\n     _InsnCtxt { _x: () }\n }\n \n@@ -175,11 +175,11 @@ impl<'self> Drop for StatRecorder<'self> {\n \n // only use this for foreign function ABIs and glue, use `decl_rust_fn` for Rust functions\n pub fn decl_fn(llmod: ModuleRef, name: &str, cc: lib::llvm::CallConv, ty: Type) -> ValueRef {\n-    let llfn: ValueRef = do name.with_c_str |buf| {\n+    let llfn: ValueRef = name.with_c_str(|buf| {\n         unsafe {\n             llvm::LLVMGetOrInsertFunction(llmod, buf, ty.to_ref())\n         }\n-    };\n+    });\n \n     lib::llvm::SetFunctionCallConv(llfn, cc);\n     // Function addresses in Rust are never significant, allowing functions to be merged.\n@@ -211,9 +211,9 @@ fn get_extern_rust_fn(ccx: &mut CrateContext, inputs: &[ty::t], output: ty::t,\n         None => ()\n     }\n     let f = decl_rust_fn(ccx, inputs, output, name);\n-    do csearch::get_item_attrs(ccx.tcx.cstore, did) |meta_items| {\n+    csearch::get_item_attrs(ccx.tcx.cstore, did, |meta_items| {\n         set_llvm_fn_attrs(meta_items.iter().map(|&x| attr::mk_attr(x)).to_owned_vec(), f)\n-    }\n+    });\n     ccx.externs.insert(name.to_owned(), f);\n     f\n }\n@@ -285,9 +285,9 @@ pub fn get_extern_const(externs: &mut ExternMap, llmod: ModuleRef,\n         None => ()\n     }\n     unsafe {\n-        let c = do name.with_c_str |buf| {\n+        let c = name.with_c_str(|buf| {\n             llvm::LLVMAddGlobal(llmod, ty.to_ref(), buf)\n-        };\n+        });\n         externs.insert(name.to_owned(), c);\n         return c;\n     }\n@@ -496,9 +496,9 @@ pub fn set_always_inline(f: ValueRef) {\n }\n \n pub fn set_no_split_stack(f: ValueRef) {\n-    do \"no-split-stack\".with_c_str |buf| {\n+    \"no-split-stack\".with_c_str(|buf| {\n         unsafe { llvm::LLVMAddFunctionAttrString(f, buf); }\n-    }\n+    })\n }\n \n // Double-check that we never ask LLVM to declare the same symbol twice. It\n@@ -563,11 +563,11 @@ pub fn get_res_dtor(ccx: @mut CrateContext,\n // Structural comparison: a rather involved form of glue.\n pub fn maybe_name_value(cx: &CrateContext, v: ValueRef, s: &str) {\n     if cx.sess.opts.save_temps {\n-        do s.with_c_str |buf| {\n+        s.with_c_str(|buf| {\n             unsafe {\n                 llvm::LLVMSetValueName(v, buf)\n             }\n-        }\n+        })\n     }\n }\n \n@@ -669,7 +669,8 @@ pub fn compare_scalar_values(cx: @mut Block,\n     }\n }\n \n-pub type val_and_ty_fn<'self> = &'self fn(@mut Block, ValueRef, ty::t) -> @mut Block;\n+pub type val_and_ty_fn<'self> = 'self |@mut Block, ValueRef, ty::t|\n+                                       -> @mut Block;\n \n pub fn load_inbounds(cx: @mut Block, p: ValueRef, idxs: &[uint]) -> ValueRef {\n     return Load(cx, GEPi(cx, p, idxs));\n@@ -703,12 +704,12 @@ pub fn iter_structural_ty(cx: @mut Block, av: ValueRef, t: ty::t,\n     match ty::get(t).sty {\n       ty::ty_struct(*) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n-          do expr::with_field_tys(cx.tcx(), t, None) |discr, field_tys| {\n+          expr::with_field_tys(cx.tcx(), t, None, |discr, field_tys| {\n               for (i, field_ty) in field_tys.iter().enumerate() {\n                   let llfld_a = adt::trans_field_ptr(cx, repr, av, discr, i);\n                   cx = f(cx, llfld_a, field_ty.mt.ty);\n               }\n-          }\n+          })\n       }\n       ty::ty_estr(ty::vstore_fixed(_)) |\n       ty::ty_evec(_, ty::vstore_fixed(_)) => {\n@@ -835,9 +836,9 @@ pub fn fail_if_zero(cx: @mut Block, span: Span, divrem: ast::BinOp,\n                           ty_to_str(cx.ccx().tcx, rhs_t));\n       }\n     };\n-    do with_cond(cx, is_zero) |bcx| {\n+    with_cond(cx, is_zero, |bcx| {\n         controlflow::trans_fail(bcx, Some(span), text)\n-    }\n+    })\n }\n \n pub fn null_env_ptr(ccx: &CrateContext) -> ValueRef {\n@@ -958,12 +959,12 @@ pub fn need_invoke(bcx: @mut Block) -> bool {\n \n pub fn have_cached_lpad(bcx: @mut Block) -> bool {\n     let mut res = false;\n-    do in_lpad_scope_cx(bcx) |inf| {\n+    in_lpad_scope_cx(bcx, |inf| {\n         match inf.landing_pad {\n           Some(_) => res = true,\n           None => res = false\n         }\n-    }\n+    });\n     return res;\n }\n \n@@ -992,7 +993,7 @@ pub fn get_landing_pad(bcx: @mut Block) -> BasicBlockRef {\n \n     let mut cached = None;\n     let mut pad_bcx = bcx; // Guaranteed to be set below\n-    do in_lpad_scope_cx(bcx) |inf| {\n+    in_lpad_scope_cx(bcx, |inf| {\n         // If there is a valid landing pad still around, use it\n         match inf.landing_pad {\n           Some(target) => cached = Some(target),\n@@ -1001,7 +1002,7 @@ pub fn get_landing_pad(bcx: @mut Block) -> BasicBlockRef {\n             inf.landing_pad = Some(pad_bcx.llbb);\n           }\n         }\n-    }\n+    });\n     // Can't return from block above\n     match cached { Some(b) => return b, None => () }\n     // The landing pad return type (the type being propagated). Not sure what\n@@ -1186,9 +1187,9 @@ pub fn new_block(cx: @mut FunctionContext,\n                  opt_node_info: Option<NodeInfo>)\n               -> @mut Block {\n     unsafe {\n-        let llbb = do name.with_c_str |buf| {\n+        let llbb = name.with_c_str(|buf| {\n             llvm::LLVMAppendBasicBlockInContext(cx.ccx.llcx, cx.llfn, buf)\n-        };\n+        });\n         let bcx = @mut Block::new(llbb,\n                                   parent,\n                                   is_lpad,\n@@ -1613,18 +1614,18 @@ pub struct BasicBlocks {\n pub fn mk_staticallocas_basic_block(llfn: ValueRef) -> BasicBlockRef {\n     unsafe {\n         let cx = task_llcx();\n-        do \"static_allocas\".with_c_str | buf| {\n+        \"static_allocas\".with_c_str(|buf| {\n             llvm::LLVMAppendBasicBlockInContext(cx, llfn, buf)\n-        }\n+        })\n     }\n }\n \n pub fn mk_return_basic_block(llfn: ValueRef) -> BasicBlockRef {\n     unsafe {\n         let cx = task_llcx();\n-        do \"return\".with_c_str |buf| {\n+        \"return\".with_c_str(|buf| {\n             llvm::LLVMAppendBasicBlockInContext(cx, llfn, buf)\n-        }\n+        })\n     }\n }\n \n@@ -1764,9 +1765,9 @@ pub fn create_llargs_for_fn_args(cx: @mut FunctionContext,\n \n     // Return an array containing the ValueRefs that we get from\n     // llvm::LLVMGetParam for each argument.\n-    do vec::from_fn(args.len()) |i| {\n+    vec::from_fn(args.len(), |i| {\n         unsafe { llvm::LLVMGetParam(cx.llfn, cx.arg_pos(i) as c_uint) }\n-    }\n+    })\n }\n \n pub fn copy_args_to_allocas(fcx: @mut FunctionContext,\n@@ -2075,7 +2076,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n     llfndecl: ValueRef)\n {\n     // Translate variant arguments to function arguments.\n-    let fn_args = do args.map |varg| {\n+    let fn_args = args.map(|varg| {\n         ast::arg {\n             ty: (*varg.ty()).clone(),\n             pat: ast_util::ident_to_pat(\n@@ -2084,7 +2085,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n                 special_idents::arg),\n             id: varg.id(),\n         }\n-    };\n+    });\n \n     let no_substs: &[ty::t] = [];\n     let ty_param_substs = match param_substs {\n@@ -2385,11 +2386,11 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n             \"main\"\n         };\n         let llfn = decl_cdecl_fn(ccx.llmod, main_name, llfty);\n-        let llbb = do \"top\".with_c_str |buf| {\n+        let llbb = \"top\".with_c_str(|buf| {\n             unsafe {\n                 llvm::LLVMAppendBasicBlockInContext(ccx.llcx, llfn, buf)\n             }\n-        };\n+        });\n         let bld = ccx.builder.B;\n         unsafe {\n             llvm::LLVMPositionBuilderAtEnd(bld, llbb);\n@@ -2408,9 +2409,9 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n                 };\n \n                 let args = {\n-                    let opaque_rust_main = do \"rust_main\".with_c_str |buf| {\n+                    let opaque_rust_main = \"rust_main\".with_c_str(|buf| {\n                         llvm::LLVMBuildPointerCast(bld, rust_main, Type::i8p().to_ref(), buf)\n-                    };\n+                    });\n \n                     ~[\n                         C_null(Type::opaque_box(ccx).ptr_to()),\n@@ -2431,9 +2432,9 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n                 (rust_main, args)\n             };\n \n-            let result = do args.as_imm_buf |buf, len| {\n+            let result = args.as_imm_buf(|buf, len| {\n                 llvm::LLVMBuildCall(bld, start_fn, buf, len as c_uint, noname())\n-            };\n+            });\n \n             llvm::LLVMBuildRet(bld, result);\n         }\n@@ -2508,9 +2509,9 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n \n                             unsafe {\n                                 let llty = llvm::LLVMTypeOf(v);\n-                                let g = do sym.with_c_str |buf| {\n+                                let g = sym.with_c_str(|buf| {\n                                     llvm::LLVMAddGlobal(ccx.llmod, llty, buf)\n-                                };\n+                                });\n \n                                 if !ccx.reachable.contains(&id) {\n                                     lib::llvm::SetLinkage(g, lib::llvm::InternalLinkage);\n@@ -2570,9 +2571,9 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n \n                     match (attr::first_attr_value_str_by_name(i.attrs, \"link_section\")) {\n                         Some(sect) => unsafe {\n-                            do sect.with_c_str |buf| {\n+                            sect.with_c_str(|buf| {\n                                 llvm::LLVMSetSection(v, buf);\n-                            }\n+                            })\n                         },\n                         None => ()\n                     }\n@@ -2617,11 +2618,14 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                             if attr::contains_name(ni.attrs, \"crate_map\") {\n                                 if *ccx.sess.building_library {\n                                     let s = \"_rust_crate_map_toplevel\";\n-                                    let g = unsafe { do s.with_c_str |buf| {\n-                                        let ty = type_of(ccx, ty);\n-                                        llvm::LLVMAddGlobal(ccx.llmod,\n-                                                            ty.to_ref(), buf)\n-                                    } };\n+                                    let g = unsafe {\n+                                        s.with_c_str(|buf| {\n+                                            let ty = type_of(ccx, ty);\n+                                            llvm::LLVMAddGlobal(ccx.llmod,\n+                                                                ty.to_ref(),\n+                                                                buf)\n+                                        })\n+                                    };\n                                     lib::llvm::SetLinkage(g,\n                                         lib::llvm::ExternalWeakLinkage);\n                                     g\n@@ -2631,11 +2635,11 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                             } else {\n                                 let ident = foreign::link_name(ccx, ni);\n                                 unsafe {\n-                                    do ident.with_c_str |buf| {\n+                                    ident.with_c_str(|buf| {\n                                         let ty = type_of(ccx, ty);\n                                         llvm::LLVMAddGlobal(ccx.llmod,\n                                                             ty.to_ref(), buf)\n-                                    }\n+                                    })\n                                 }\n                             }\n                         }\n@@ -2903,11 +2907,11 @@ pub fn decl_gc_metadata(ccx: &mut CrateContext, llmod_id: &str) {\n     }\n \n     let gc_metadata_name = ~\"_gc_module_metadata_\" + llmod_id;\n-    let gc_metadata = do gc_metadata_name.with_c_str |buf| {\n+    let gc_metadata = gc_metadata_name.with_c_str(|buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod, Type::i32().to_ref(), buf)\n         }\n-    };\n+    });\n     unsafe {\n         llvm::LLVMSetGlobalConstant(gc_metadata, True);\n         lib::llvm::SetLinkage(gc_metadata, lib::llvm::ExternalLinkage);\n@@ -2919,11 +2923,11 @@ pub fn create_module_map(ccx: &mut CrateContext) -> (ValueRef, uint) {\n     let str_slice_type = Type::struct_([Type::i8p(), ccx.int_type], false);\n     let elttype = Type::struct_([str_slice_type, ccx.int_type], false);\n     let maptype = Type::array(&elttype, ccx.module_data.len() as u64);\n-    let map = do \"_rust_mod_map\".with_c_str |buf| {\n+    let map = \"_rust_mod_map\".with_c_str(|buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod, maptype.to_ref(), buf)\n         }\n-    };\n+    });\n     lib::llvm::SetLinkage(map, lib::llvm::InternalLinkage);\n     let mut elts: ~[ValueRef] = ~[];\n \n@@ -2972,11 +2976,11 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n         slicetype,          // sub crate-maps\n         int_type.ptr_to(),  // event loop factory\n     ], false);\n-    let map = do sym_name.with_c_str |buf| {\n+    let map = sym_name.with_c_str(|buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(llmod, maptype.to_ref(), buf)\n         }\n-    };\n+    });\n     // On windows we'd like to export the toplevel cratemap\n     // such that we can find it from libstd.\n     if targ_cfg.os == OsWin32 && \"toplevel\" == mapname {\n@@ -2998,21 +3002,21 @@ pub fn fill_crate_map(ccx: &mut CrateContext, map: ValueRef) {\n                       cdata.name,\n                       cstore::get_crate_vers(cstore, i),\n                       cstore::get_crate_hash(cstore, i));\n-        let cr = do nm.with_c_str |buf| {\n+        let cr = nm.with_c_str(|buf| {\n             unsafe {\n                 llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type.to_ref(), buf)\n             }\n-        };\n+        });\n         subcrates.push(p2i(ccx, cr));\n         i += 1;\n     }\n     let event_loop_factory = if !*ccx.sess.building_library {\n         match ccx.tcx.lang_items.event_loop_factory() {\n             Some(did) => unsafe {\n                 let name = csearch::get_symbol(ccx.sess.cstore, did);\n-                let global = do name.with_c_str |buf| {\n+                let global = name.with_c_str(|buf| {\n                     llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type.to_ref(), buf)\n-                };\n+                });\n                 global\n             },\n             None => C_null(ccx.int_type.ptr_to())\n@@ -3022,9 +3026,9 @@ pub fn fill_crate_map(ccx: &mut CrateContext, map: ValueRef) {\n     };\n     unsafe {\n         let maptype = Type::array(&ccx.int_type, subcrates.len() as u64);\n-        let vec_elements = do \"_crate_map_child_vectors\".with_c_str |buf| {\n+        let vec_elements = \"_crate_map_child_vectors\".with_c_str(|buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, maptype.to_ref(), buf)\n-        };\n+        });\n         lib::llvm::SetLinkage(vec_elements, lib::llvm::InternalLinkage);\n \n         llvm::LLVMSetInitializer(vec_elements, C_array(ccx.int_type, subcrates));\n@@ -3076,23 +3080,23 @@ pub fn write_metadata(cx: &CrateContext, crate: &ast::Crate) {\n     let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item);\n     let llmeta = C_bytes(encoder::encode_metadata(encode_parms, crate));\n     let llconst = C_struct([llmeta], false);\n-    let mut llglobal = do \"rust_metadata\".with_c_str |buf| {\n+    let mut llglobal = \"rust_metadata\".with_c_str(|buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst).to_ref(), buf)\n         }\n-    };\n+    });\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n-        do cx.sess.targ_cfg.target_strs.meta_sect_name.with_c_str |buf| {\n+        cx.sess.targ_cfg.target_strs.meta_sect_name.with_c_str(|buf| {\n             llvm::LLVMSetSection(llglobal, buf)\n-        };\n+        });\n         lib::llvm::SetLinkage(llglobal, lib::llvm::InternalLinkage);\n \n         let t_ptr_i8 = Type::i8p();\n         llglobal = llvm::LLVMConstBitCast(llglobal, t_ptr_i8.to_ref());\n-        let llvm_used = do \"llvm.used\".with_c_str |buf| {\n+        let llvm_used = \"llvm.used\".with_c_str(|buf| {\n             llvm::LLVMAddGlobal(cx.llmod, Type::array(&t_ptr_i8, 1).to_ref(), buf)\n-        };\n+        });\n         lib::llvm::SetLinkage(llvm_used, lib::llvm::AppendingLinkage);\n         llvm::LLVMSetInitializer(llvm_used, C_array(t_ptr_i8, [llglobal]));\n     }\n@@ -3102,9 +3106,9 @@ pub fn write_metadata(cx: &CrateContext, crate: &ast::Crate) {\n pub fn write_abi_version(ccx: &mut CrateContext) {\n     unsafe {\n         let llval = C_uint(ccx, abi::abi_version);\n-        let llglobal = do \"rust_abi_version\".with_c_str |buf| {\n+        let llglobal = \"rust_abi_version\".with_c_str(|buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, val_ty(llval).to_ref(), buf)\n-        };\n+        });\n         llvm::LLVMSetInitializer(llglobal, llval);\n         llvm::LLVMSetGlobalConstant(llglobal, True);\n     }\n@@ -3160,12 +3164,12 @@ pub fn trans_crate(sess: session::Session,\n \n         let maptype = val_ty(ccx.crate_map).to_ref();\n \n-        do \"__rust_crate_map_toplevel\".with_c_str |buf| {\n+        \"__rust_crate_map_toplevel\".with_c_str(|buf| {\n             unsafe {\n                 llvm::LLVMAddAlias(ccx.llmod, maptype,\n                                    ccx.crate_map, buf);\n             }\n-        }\n+        })\n     }\n \n     glue::emit_tydescs(ccx);\n@@ -3188,9 +3192,10 @@ pub fn trans_crate(sess: session::Session,\n         println!(\"n_inlines: {}\", ccx.stats.n_inlines);\n         println!(\"n_closures: {}\", ccx.stats.n_closures);\n         println(\"fn stats:\");\n-        do sort::quick_sort(ccx.stats.fn_stats) |&(_, _, insns_a), &(_, _, insns_b)| {\n+        sort::quick_sort(ccx.stats.fn_stats,\n+                         |&(_, _, insns_a), &(_, _, insns_b)| {\n             insns_a > insns_b\n-        }\n+        });\n         for tuple in ccx.stats.fn_stats.iter() {\n             match *tuple {\n                 (ref name, ms, insns) => {"}, {"sha": "7541a14fc720cf0696b81494ac89976f0c94cbf5", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -51,7 +51,7 @@ impl Builder {\n             self.ccx.stats.n_llvm_insns += 1;\n         }\n         if self.ccx.sess.count_llvm_insns() {\n-            do base::with_insn_ctxt |v| {\n+            base::with_insn_ctxt(|v| {\n                 let h = &mut self.ccx.stats.llvm_insns;\n \n                 // Build version of path with cycles removed.\n@@ -85,7 +85,7 @@ impl Builder {\n                     _ => 0u\n                 };\n                 h.insert(s, n+1u);\n-            }\n+            })\n         }\n     }\n \n@@ -419,9 +419,9 @@ impl Builder {\n             if name.is_empty() {\n                 llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(), noname())\n             } else {\n-                do name.with_c_str |c| {\n+                name.with_c_str(|c| {\n                     llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(), c)\n-                }\n+                })\n             }\n         }\n     }\n@@ -465,11 +465,11 @@ impl Builder {\n             let min = llvm::LLVMConstInt(t, lo, signed);\n             let max = llvm::LLVMConstInt(t, hi, signed);\n \n-            do [min, max].as_imm_buf |ptr, len| {\n+            [min, max].as_imm_buf(|ptr, len| {\n                 llvm::LLVMSetMetadata(value, lib::llvm::MD_range as c_uint,\n                                       llvm::LLVMMDNodeInContext(self.ccx.llcx,\n                                                                 ptr, len as c_uint));\n-            }\n+            })\n         }\n \n         value\n@@ -518,7 +518,7 @@ impl Builder {\n             }\n             self.inbounds_gep(base, small_vec.slice(0, ixs.len()))\n         } else {\n-            let v = do ixs.iter().map |i| { C_i32(*i as i32) }.collect::<~[ValueRef]>();\n+            let v = ixs.iter().map(|i| C_i32(*i as i32)).collect::<~[ValueRef]>();\n             self.count_insn(\"gepi\");\n             self.inbounds_gep(base, v)\n         }\n@@ -736,12 +736,12 @@ impl Builder {\n             let sanitized = text.replace(\"$\", \"\");\n             let comment_text = format!(\"\\\\# {}\", sanitized.replace(\"\\n\", \"\\n\\t# \"));\n             self.count_insn(\"inlineasm\");\n-            let asm = do comment_text.with_c_str |c| {\n+            let asm = comment_text.with_c_str(|c| {\n                 unsafe {\n                     llvm::LLVMConstInlineAsm(Type::func([], &Type::void()).to_ref(),\n                                              c, noname(), False, False)\n                 }\n-            };\n+            });\n             self.call(asm, [], []);\n         }\n     }\n@@ -757,10 +757,10 @@ impl Builder {\n         let alignstack = if alignstack { lib::llvm::True }\n                          else          { lib::llvm::False };\n \n-        let argtys = do inputs.map |v| {\n+        let argtys = inputs.map(|v| {\n             debug!(\"Asm Input Type: {:?}\", self.ccx.tn.val_to_str(*v));\n             val_ty(*v)\n-        };\n+        });\n \n         debug!(\"Asm Output Type: {:?}\", self.ccx.tn.type_to_str(output));\n         let fty = Type::func(argtys, &output);\n@@ -878,9 +878,9 @@ impl Builder {\n             let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(self.llbuilder);\n             let FN: ValueRef = llvm::LLVMGetBasicBlockParent(BB);\n             let M: ModuleRef = llvm::LLVMGetGlobalParent(FN);\n-            let T: ValueRef = do \"llvm.trap\".with_c_str |buf| {\n+            let T: ValueRef = \"llvm.trap\".with_c_str(|buf| {\n                 llvm::LLVMGetNamedFunction(M, buf)\n-            };\n+            });\n             assert!((T as int != 0));\n             let args: &[ValueRef] = [];\n             self.count_insn(\"trap\");"}, {"sha": "10c34b0b928886fe765cae6291737462660a3a9d", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -616,7 +616,7 @@ pub fn trans_call_inner(in_cx: @mut Block,\n      */\n \n \n-    do base::with_scope_result(in_cx, call_info, \"call\") |cx| {\n+    base::with_scope_result(in_cx, call_info, \"call\", |cx| {\n         let callee = get_callee(cx);\n         let mut bcx = callee.bcx;\n         let ccx = cx.ccx();\n@@ -776,7 +776,7 @@ pub fn trans_call_inner(in_cx: @mut Block,\n         }\n \n         rslt(bcx, llresult)\n-    }\n+    })\n }\n \n pub enum CallArgs<'self> {"}, {"sha": "768d3cbd4b2c8fb034dbe2323061f673180b4803", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -438,10 +438,10 @@ pub fn make_closure_glue(cx: @mut Block,\n         ast::OwnedSigil | ast::ManagedSigil => {\n             let box_cell_v = GEPi(cx, v, [0u, abi::fn_field_box]);\n             let box_ptr_v = Load(cx, box_cell_v);\n-            do with_cond(cx, IsNotNull(cx, box_ptr_v)) |bcx| {\n+            with_cond(cx, IsNotNull(cx, box_ptr_v), |bcx| {\n                 let closure_ty = ty::mk_opaque_closure_ptr(tcx, sigil);\n                 glue_fn(bcx, box_cell_v, closure_ty)\n-            }\n+            })\n         }\n     }\n }\n@@ -481,7 +481,7 @@ pub fn make_opaque_cbox_free_glue(\n     }\n \n     let ccx = bcx.ccx();\n-    do with_cond(bcx, IsNotNull(bcx, cbox)) |bcx| {\n+    with_cond(bcx, IsNotNull(bcx, cbox), |bcx| {\n         // Load the type descr found in the cbox\n         let lltydescty = ccx.tydesc_type.ptr_to();\n         let cbox = Load(bcx, cbox);\n@@ -498,5 +498,5 @@ pub fn make_opaque_cbox_free_glue(\n         glue::trans_exchange_free(bcx, cbox);\n \n         bcx\n-    }\n+    })\n }"}, {"sha": "7b2e439f2d253b486f759aaaf6f218638c94d7f4", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -453,14 +453,14 @@ pub fn add_clean(bcx: @mut Block, val: ValueRef, t: ty::t) {\n     debug!(\"add_clean({}, {}, {})\", bcx.to_str(), bcx.val_to_str(val), t.repr(bcx.tcx()));\n \n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n-    do in_scope_cx(bcx, None) |scope_info| {\n+    in_scope_cx(bcx, None, |scope_info| {\n         scope_info.cleanups.push(clean(@TypeDroppingCleanupFunction {\n             val: val,\n             t: t,\n         } as @CleanupFunction,\n         cleanup_type));\n         grow_scope_clean(scope_info);\n-    }\n+    })\n }\n \n pub fn add_clean_temp_immediate(cx: @mut Block, val: ValueRef, ty: ty::t) {\n@@ -469,15 +469,15 @@ pub fn add_clean_temp_immediate(cx: @mut Block, val: ValueRef, ty: ty::t) {\n            cx.to_str(), cx.val_to_str(val),\n            ty.repr(cx.tcx()));\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n-    do in_scope_cx(cx, None) |scope_info| {\n+    in_scope_cx(cx, None, |scope_info| {\n         scope_info.cleanups.push(clean_temp(val,\n             @ImmediateTypeDroppingCleanupFunction {\n                 val: val,\n                 t: ty,\n             } as @CleanupFunction,\n             cleanup_type));\n         grow_scope_clean(scope_info);\n-    }\n+    })\n }\n \n pub fn add_clean_temp_mem(bcx: @mut Block, val: ValueRef, t: ty::t) {\n@@ -498,15 +498,15 @@ pub fn add_clean_temp_mem_in_scope_(bcx: @mut Block, scope_id: Option<ast::NodeI\n            bcx.to_str(), bcx.val_to_str(val),\n            t.repr(bcx.tcx()));\n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n-    do in_scope_cx(bcx, scope_id) |scope_info| {\n+    in_scope_cx(bcx, scope_id, |scope_info| {\n         scope_info.cleanups.push(clean_temp(val,\n             @TypeDroppingCleanupFunction {\n                 val: val,\n                 t: t,\n             } as @CleanupFunction,\n             cleanup_type));\n         grow_scope_clean(scope_info);\n-    }\n+    })\n }\n pub fn add_clean_return_to_mut(bcx: @mut Block,\n                                scope_id: ast::NodeId,\n@@ -527,7 +527,7 @@ pub fn add_clean_return_to_mut(bcx: @mut Block,\n            bcx.to_str(),\n            bcx.val_to_str(frozen_val_ref),\n            bcx.val_to_str(bits_val_ref));\n-    do in_scope_cx(bcx, Some(scope_id)) |scope_info| {\n+    in_scope_cx(bcx, Some(scope_id), |scope_info| {\n         scope_info.cleanups.push(clean_temp(\n                 frozen_val_ref,\n                 @WriteGuardReleasingCleanupFunction {\n@@ -539,7 +539,7 @@ pub fn add_clean_return_to_mut(bcx: @mut Block,\n                 } as @CleanupFunction,\n                 normal_exit_only));\n         grow_scope_clean(scope_info);\n-    }\n+    })\n }\n pub fn add_clean_free(cx: @mut Block, ptr: ValueRef, heap: heap) {\n     let free_fn = match heap {\n@@ -554,20 +554,20 @@ pub fn add_clean_free(cx: @mut Block, ptr: ValueRef, heap: heap) {\n             } as @CleanupFunction\n         }\n     };\n-    do in_scope_cx(cx, None) |scope_info| {\n+    in_scope_cx(cx, None, |scope_info| {\n         scope_info.cleanups.push(clean_temp(ptr,\n                                             free_fn,\n                                             normal_exit_and_unwind));\n         grow_scope_clean(scope_info);\n-    }\n+    })\n }\n \n // Note that this only works for temporaries. We should, at some point, move\n // to a system where we can also cancel the cleanup on local variables, but\n // this will be more involved. For now, we simply zero out the local, and the\n // drop glue checks whether it is zero.\n pub fn revoke_clean(cx: @mut Block, val: ValueRef) {\n-    do in_scope_cx(cx, None) |scope_info| {\n+    in_scope_cx(cx, None, |scope_info| {\n         let cleanup_pos = scope_info.cleanups.iter().position(\n             |cu| match *cu {\n                 clean_temp(v, _, _) if v == val => true,\n@@ -580,7 +580,7 @@ pub fn revoke_clean(cx: @mut Block, val: ValueRef) {\n                                                       scope_info.cleanups.len()));\n             shrink_scope_clean(scope_info, *i);\n         }\n-    }\n+    })\n }\n \n pub fn block_cleanups(bcx: &mut Block) -> ~[cleanup] {\n@@ -844,9 +844,7 @@ pub fn C_integral(t: Type, u: u64, sign_extend: bool) -> ValueRef {\n \n pub fn C_floating(s: &str, t: Type) -> ValueRef {\n     unsafe {\n-        do s.with_c_str |buf| {\n-            llvm::LLVMConstRealOfString(t.to_ref(), buf)\n-        }\n+        s.with_c_str(|buf| llvm::LLVMConstRealOfString(t.to_ref(), buf))\n     }\n }\n \n@@ -896,14 +894,14 @@ pub fn C_cstr(cx: &mut CrateContext, s: @str) -> ValueRef {\n             None => ()\n         }\n \n-        let sc = do s.as_imm_buf |buf, buflen| {\n+        let sc = s.as_imm_buf(|buf, buflen| {\n             llvm::LLVMConstStringInContext(cx.llcx, buf as *c_char, buflen as c_uint, False)\n-        };\n+        });\n \n         let gsym = token::gensym(\"str\");\n-        let g = do format!(\"str{}\", gsym).with_c_str |buf| {\n+        let g = format!(\"str{}\", gsym).with_c_str(|buf| {\n             llvm::LLVMAddGlobal(cx.llmod, val_ty(sc).to_ref(), buf)\n-        };\n+        });\n         llvm::LLVMSetInitializer(g, sc);\n         llvm::LLVMSetGlobalConstant(g, True);\n         lib::llvm::SetLinkage(g, lib::llvm::InternalLinkage);\n@@ -930,9 +928,9 @@ pub fn C_binary_slice(cx: &mut CrateContext, data: &[u8]) -> ValueRef {\n         let lldata = C_bytes(data);\n \n         let gsym = token::gensym(\"binary\");\n-        let g = do format!(\"binary{}\", gsym).with_c_str |buf| {\n+        let g = format!(\"binary{}\", gsym).with_c_str(|buf| {\n             llvm::LLVMAddGlobal(cx.llmod, val_ty(lldata).to_ref(), buf)\n-        };\n+        });\n         llvm::LLVMSetInitializer(g, lldata);\n         llvm::LLVMSetGlobalConstant(g, True);\n         lib::llvm::SetLinkage(g, lib::llvm::InternalLinkage);\n@@ -954,17 +952,17 @@ pub fn C_zero_byte_arr(size: uint) -> ValueRef {\n \n pub fn C_struct(elts: &[ValueRef], packed: bool) -> ValueRef {\n     unsafe {\n-        do elts.as_imm_buf |ptr, len| {\n+        elts.as_imm_buf(|ptr, len| {\n             llvm::LLVMConstStructInContext(base::task_llcx(), ptr, len as c_uint, packed as Bool)\n-        }\n+        })\n     }\n }\n \n pub fn C_named_struct(T: Type, elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        do elts.as_imm_buf |ptr, len| {\n+        elts.as_imm_buf(|ptr, len| {\n             llvm::LLVMConstNamedStruct(T.to_ref(), ptr, len as c_uint)\n-        }\n+        })\n     }\n }\n \n@@ -990,9 +988,9 @@ pub fn get_param(fndecl: ValueRef, param: uint) -> ValueRef {\n pub fn const_get_elt(cx: &CrateContext, v: ValueRef, us: &[c_uint])\n                   -> ValueRef {\n     unsafe {\n-        let r = do us.as_imm_buf |p, len| {\n+        let r = us.as_imm_buf(|p, len| {\n             llvm::LLVMConstExtractValue(v, p, len as c_uint)\n-        };\n+        });\n \n         debug!(\"const_get_elt(v={}, us={:?}, r={})\",\n                cx.tn.val_to_str(v), us, cx.tn.val_to_str(r));\n@@ -1151,9 +1149,9 @@ pub fn node_id_type_params(bcx: &mut Block, id: ast::NodeId) -> ~[ty::t] {\n \n     match bcx.fcx.param_substs {\n       Some(substs) => {\n-        do params.iter().map |t| {\n+        params.iter().map(|t| {\n             ty::subst_tps(tcx, substs.tys, substs.self_ty, *t)\n-        }.collect()\n+        }).collect()\n       }\n       _ => params\n     }\n@@ -1207,9 +1205,9 @@ pub fn resolve_vtable_under_param_substs(tcx: ty::ctxt,\n         typeck::vtable_static(trait_id, ref tys, sub) => {\n             let tys = match param_substs {\n                 Some(substs) => {\n-                    do tys.iter().map |t| {\n+                    tys.iter().map(|t| {\n                         ty::subst_tps(tcx, substs.tys, substs.self_ty, *t)\n-                    }.collect()\n+                    }).collect()\n                 }\n                 _ => tys.to_owned()\n             };"}, {"sha": "04da76cec9e5ac0c336b4eb7b8a18142e3cd9efe", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -100,9 +100,9 @@ fn const_vec(cx: @mut CrateContext, e: &ast::Expr, es: &[@ast::Expr]) -> (ValueR\n \n fn const_addr_of(cx: &mut CrateContext, cv: ValueRef) -> ValueRef {\n     unsafe {\n-        let gv = do \"const\".with_c_str |name| {\n+        let gv = \"const\".with_c_str(|name| {\n             llvm::LLVMAddGlobal(cx.llmod, val_ty(cv).to_ref(), name)\n-        };\n+        });\n         llvm::LLVMSetInitializer(gv, cv);\n         llvm::LLVMSetGlobalConstant(gv, True);\n         SetLinkage(gv, PrivateLinkage);\n@@ -191,12 +191,12 @@ pub fn const_expr(cx: @mut CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n         Some(@ty::AutoDerefRef(ref adj)) => {\n             let mut ty = ety;\n             let mut maybe_ptr = None;\n-            do adj.autoderefs.times {\n+            adj.autoderefs.times(|| {\n                 let (dv, dt) = const_deref(cx, llconst, ty, false);\n                 maybe_ptr = Some(llconst);\n                 llconst = dv;\n                 ty = dt;\n-            }\n+            });\n \n             match adj.autoref {\n                 None => { }\n@@ -385,10 +385,10 @@ fn const_expr_unadjusted(cx: @mut CrateContext,\n               let bt = ty::expr_ty_adjusted(cx.tcx, base);\n               let brepr = adt::represent_type(cx, bt);\n               let (bv, inlineable) = const_expr(cx, base);\n-              do expr::with_field_tys(cx.tcx, bt, None) |discr, field_tys| {\n+              expr::with_field_tys(cx.tcx, bt, None, |discr, field_tys| {\n                   let ix = ty::field_idx_strict(cx.tcx, field.name, field_tys);\n                   (adt::const_get_field(cx, brepr, bv, discr, ix), inlineable)\n-              }\n+              })\n           }\n \n           ast::ExprIndex(_, base, index) => {\n@@ -504,8 +504,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext,\n                 None => None\n               };\n \n-              do expr::with_field_tys(tcx, ety, Some(e.id))\n-                  |discr, field_tys| {\n+              expr::with_field_tys(tcx, ety, Some(e.id), |discr, field_tys| {\n                   let cs = field_tys.iter().enumerate()\n                       .map(|(ix, &field_ty)| {\n                       match fs.iter().find(|f| field_ty.ident.name == f.ident.node.name) {\n@@ -524,7 +523,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext,\n                   let (cs, inlineable) = vec::unzip(cs.move_iter());\n                   (adt::trans_const(cx, repr, discr, cs),\n                    inlineable.iter().fold(true, |a, &b| a && b))\n-              }\n+              })\n           }\n           ast::ExprVec(ref es, ast::MutImmutable) => {\n             let (v, _, inlineable) = const_vec(cx, e, *es);\n@@ -541,9 +540,9 @@ fn const_expr_unadjusted(cx: @mut CrateContext,\n               ast::ExprVec(ref es, ast::MutImmutable) => {\n                 let (cv, llunitty, _) = const_vec(cx, e, *es);\n                 let llty = val_ty(cv);\n-                let gv = do \"const\".with_c_str |name| {\n+                let gv = \"const\".with_c_str(|name| {\n                     llvm::LLVMAddGlobal(cx.llmod, llty.to_ref(), name)\n-                };\n+                });\n                 llvm::LLVMSetInitializer(gv, cv);\n                 llvm::LLVMSetGlobalConstant(gv, True);\n                 SetLinkage(gv, PrivateLinkage);"}, {"sha": "851a1233dcca76c62c0f0d6c996721189d765f23", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -131,17 +131,15 @@ impl CrateContext {\n         unsafe {\n             let llcx = llvm::LLVMContextCreate();\n             set_task_llcx(llcx);\n-            let llmod = do name.with_c_str |buf| {\n+            let llmod = name.with_c_str(|buf| {\n                 llvm::LLVMModuleCreateWithNameInContext(buf, llcx)\n-            };\n+            });\n             let data_layout: &str = sess.targ_cfg.target_strs.data_layout;\n             let targ_triple: &str = sess.targ_cfg.target_strs.target_triple;\n-            do data_layout.with_c_str |buf| {\n-                llvm::LLVMSetDataLayout(llmod, buf)\n-            };\n-            do targ_triple.with_c_str |buf| {\n+            data_layout.with_c_str(|buf| llvm::LLVMSetDataLayout(llmod, buf));\n+            targ_triple.with_c_str(|buf| {\n                 llvm::LLVMRustSetNormalizedTarget(llmod, buf)\n-            };\n+            });\n             let targ_cfg = sess.targ_cfg;\n \n             let td = mk_target_data(sess.targ_cfg.target_strs.data_layout);"}, {"sha": "1360c9c7c9ba9dc040b765ce009c2031cb95438d", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -74,23 +74,26 @@ pub fn trans_if(bcx: @mut Block,\n                 None => {}\n             }\n             // if true { .. } [else { .. }]\n-            return do with_scope(bcx, thn.info(), \"if_true_then\") |bcx| {\n+            return with_scope(bcx, thn.info(), \"if_true_then\", |bcx| {\n                 let bcx_out = trans_block(bcx, thn, dest);\n                 debuginfo::clear_source_location(bcx.fcx);\n                 trans_block_cleanups(bcx_out, block_cleanups(bcx))\n-            }\n+            })\n         } else {\n             let mut trans = TransItemVisitor { ccx: bcx.fcx.ccx } ;\n             trans.visit_block(thn, ());\n \n             match els {\n                 // if false { .. } else { .. }\n                 Some(elexpr) => {\n-                    return do with_scope(bcx, elexpr.info(), \"if_false_then\") |bcx| {\n+                    return with_scope(bcx,\n+                                      elexpr.info(),\n+                                      \"if_false_then\",\n+                                      |bcx| {\n                         let bcx_out = trans_if_else(bcx, elexpr, dest);\n                         debuginfo::clear_source_location(bcx.fcx);\n                         trans_block_cleanups(bcx_out, block_cleanups(bcx))\n-                    }\n+                    })\n                 }\n                 // if false { .. }\n                 None => return bcx,"}, {"sha": "4fd6e08c8b5847510b9107fb0e75901bba704a7e", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -290,9 +290,9 @@ impl Datum {\n                 ByRef(_) => {\n                     let cast = PointerCast(bcx, dst, val_ty(self.val));\n                     let cmp = ICmp(bcx, lib::llvm::IntNE, cast, self.val);\n-                    do with_cond(bcx, cmp) |bcx| {\n+                    with_cond(bcx, cmp, |bcx| {\n                         self.copy_to_no_check(bcx, action, dst)\n-                    }\n+                    })\n                 }\n                 ByValue => {\n                     self.copy_to_no_check(bcx, action, dst)"}, {"sha": "caed9fb8e9c745e1cfeaa3cbe4281b375b0ff666", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 144, "deletions": 127, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -254,8 +254,7 @@ pub fn create_local_var_metadata(bcx: @mut Block,\n     let cx = bcx.ccx();\n     let def_map = cx.tcx.def_map;\n \n-    do pat_util::pat_bindings(def_map, local.pat) |_, node_id, span, path_ref| {\n-\n+    pat_util::pat_bindings(def_map, local.pat, |_, node_id, span, path_ref| {\n         let var_ident = ast_util::path_to_ident(path_ref);\n         let var_type = node_id_type(bcx, node_id);\n \n@@ -276,7 +275,7 @@ pub fn create_local_var_metadata(bcx: @mut Block,\n                       DirectVariable { alloca: llptr },\n                       LocalVariable,\n                       span);\n-    }\n+    })\n }\n \n /// Creates debug information for a variable captured in a closure.\n@@ -449,8 +448,7 @@ pub fn create_argument_metadata(bcx: @mut Block,\n     let def_map = cx.tcx.def_map;\n     let scope_metadata = bcx.fcx.debug_context.get_ref(cx, arg.pat.span).fn_metadata;\n \n-    do pat_util::pat_bindings(def_map, arg.pat) |_, node_id, span, path_ref| {\n-\n+    pat_util::pat_bindings(def_map, arg.pat, |_, node_id, span, path_ref| {\n         let llptr = match bcx.fcx.llargs.find_copy(&node_id) {\n             Some(v) => v,\n             None => {\n@@ -481,7 +479,7 @@ pub fn create_argument_metadata(bcx: @mut Block,\n                       DirectVariable { alloca: llptr },\n                       ArgumentVariable(argument_index),\n                       span);\n-    }\n+    })\n }\n \n /// Sets the current debug location at the beginning of the span.\n@@ -655,27 +653,28 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n \n     let scope_line = get_scope_line(cx, top_level_block, loc.line);\n \n-    let fn_metadata = do function_name.with_c_str |function_name| {\n-                      do linkage_name.with_c_str |linkage_name| {\n-        unsafe {\n-            llvm::LLVMDIBuilderCreateFunction(\n-                DIB(cx),\n-                containing_scope,\n-                function_name,\n-                linkage_name,\n-                file_metadata,\n-                loc.line as c_uint,\n-                function_type_metadata,\n-                false,\n-                true,\n-                scope_line as c_uint,\n-                FlagPrototyped as c_uint,\n-                cx.sess.opts.optimize != session::No,\n-                llfn,\n-                template_parameters,\n-                ptr::null())\n-        }\n-    }};\n+    let fn_metadata = function_name.with_c_str(|function_name| {\n+                          linkage_name.with_c_str(|linkage_name| {\n+            unsafe {\n+                llvm::LLVMDIBuilderCreateFunction(\n+                    DIB(cx),\n+                    containing_scope,\n+                    function_name,\n+                    linkage_name,\n+                    file_metadata,\n+                    loc.line as c_uint,\n+                    function_type_metadata,\n+                    false,\n+                    true,\n+                    scope_line as c_uint,\n+                    FlagPrototyped as c_uint,\n+                    cx.sess.opts.optimize != session::No,\n+                    llfn,\n+                    template_parameters,\n+                    ptr::null())\n+            }\n+        })\n+    });\n \n     // Initialize fn debug context (including scope map and namespace map)\n     let mut fn_debug_context = ~FunctionDebugContextData {\n@@ -685,7 +684,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n         source_locations_enabled: false,\n     };\n \n-    let arg_pats = do fn_decl.inputs.map |arg_ref| { arg_ref.pat };\n+    let arg_pats = fn_decl.inputs.map(|arg_ref| arg_ref.pat);\n     populate_scope_map(cx, arg_pats, top_level_block, fn_metadata, &mut fn_debug_context.scope_map);\n \n     return FunctionDebugContext(fn_debug_context);\n@@ -780,7 +779,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n \n                 let ident = special_idents::type_self;\n \n-                let param_metadata = do token::ident_to_str(&ident).with_c_str |name| {\n+                let param_metadata = token::ident_to_str(&ident).with_c_str(|name| {\n                     unsafe {\n                         llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n                             DIB(cx),\n@@ -791,7 +790,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n                             0,\n                             0)\n                     }\n-                };\n+                });\n \n                 template_params.push(param_metadata);\n             }\n@@ -818,7 +817,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n             // Again, only create type information if extra_debuginfo is enabled\n             if cx.sess.opts.extra_debuginfo {\n                 let actual_type_metadata = type_metadata(cx, actual_type, codemap::dummy_sp());\n-                let param_metadata = do token::ident_to_str(&ident).with_c_str |name| {\n+                let param_metadata = token::ident_to_str(&ident).with_c_str(|name| {\n                     unsafe {\n                         llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n                             DIB(cx),\n@@ -829,7 +828,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n                             0,\n                             0)\n                     }\n-                };\n+                });\n                 template_params.push(param_metadata);\n             }\n         }\n@@ -875,24 +874,28 @@ fn compile_unit_metadata(cx: @mut CrateContext) {\n     let work_dir = cx.sess.working_dir.as_str().unwrap();\n     let producer = format!(\"rustc version {}\", env!(\"CFG_VERSION\"));\n \n-    do crate_name.with_c_str |crate_name| {\n-    do work_dir.with_c_str |work_dir| {\n-    do producer.with_c_str |producer| {\n-    do \"\".with_c_str |flags| {\n-    do \"\".with_c_str |split_name| {\n-        unsafe {\n-            llvm::LLVMDIBuilderCreateCompileUnit(\n-                dcx.builder,\n-                DW_LANG_RUST,\n-                crate_name,\n-                work_dir,\n-                producer,\n-                cx.sess.opts.optimize != session::No,\n-                flags,\n-                0,\n-                split_name);\n-        }\n-    }}}}};\n+    crate_name.with_c_str(|crate_name| {\n+        work_dir.with_c_str(|work_dir| {\n+            producer.with_c_str(|producer| {\n+                \"\".with_c_str(|flags| {\n+                    \"\".with_c_str(|split_name| {\n+                        unsafe {\n+                            llvm::LLVMDIBuilderCreateCompileUnit(\n+                                dcx.builder,\n+                                DW_LANG_RUST,\n+                                crate_name,\n+                                work_dir,\n+                                producer,\n+                                cx.sess.opts.optimize != session::No,\n+                                flags,\n+                                0,\n+                                split_name);\n+                        }\n+                    })\n+                })\n+            })\n+        })\n+    });\n }\n \n fn declare_local(bcx: @mut Block,\n@@ -917,7 +920,7 @@ fn declare_local(bcx: @mut Block,\n         CapturedVariable => 0\n     } as c_uint;\n \n-    let (var_alloca, var_metadata) = do name.with_c_str |name| {\n+    let (var_alloca, var_metadata) = name.with_c_str(|name| {\n         match variable_access {\n             DirectVariable { alloca } => (\n                 alloca,\n@@ -952,7 +955,7 @@ fn declare_local(bcx: @mut Block,\n                 }\n             )\n         }\n-    };\n+    });\n \n     set_debug_location(cx, DebugLocation::new(scope_metadata, loc.line, *loc.col));\n     unsafe {\n@@ -992,12 +995,13 @@ fn file_metadata(cx: &mut CrateContext, full_path: &str) -> DIFile {\n         };\n \n     let file_metadata =\n-        do file_name.with_c_str |file_name| {\n-        do work_dir.with_c_str |work_dir| {\n-            unsafe {\n-                llvm::LLVMDIBuilderCreateFile(DIB(cx), file_name, work_dir)\n-            }\n-        }};\n+        file_name.with_c_str(|file_name| {\n+            work_dir.with_c_str(|work_dir| {\n+                unsafe {\n+                    llvm::LLVMDIBuilderCreateFile(DIB(cx), file_name, work_dir)\n+                }\n+            })\n+        });\n \n     debug_context(cx).created_files.insert(full_path.to_owned(), file_metadata);\n     return file_metadata;\n@@ -1053,7 +1057,7 @@ fn basic_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n \n     let llvm_type = type_of::type_of(cx, t);\n     let (size, align) = size_and_align_of(cx, llvm_type);\n-    let ty_metadata = do name.with_c_str |name| {\n+    let ty_metadata = name.with_c_str(|name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreateBasicType(\n                 DIB(cx),\n@@ -1062,7 +1066,7 @@ fn basic_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n                 bytes_to_bits(align),\n                 encoding)\n         }\n-    };\n+    });\n \n     return ty_metadata;\n }\n@@ -1074,7 +1078,7 @@ fn pointer_type_metadata(cx: &mut CrateContext,\n     let pointer_llvm_type = type_of::type_of(cx, pointer_type);\n     let (pointer_size, pointer_align) = size_and_align_of(cx, pointer_llvm_type);\n     let name = ppaux::ty_to_str(cx.tcx, pointer_type);\n-    let ptr_metadata = do name.with_c_str |name| {\n+    let ptr_metadata = name.with_c_str(|name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreatePointerType(\n                 DIB(cx),\n@@ -1083,7 +1087,7 @@ fn pointer_type_metadata(cx: &mut CrateContext,\n                 bytes_to_bits(pointer_align),\n                 name)\n         }\n-    };\n+    });\n     return ptr_metadata;\n }\n \n@@ -1100,7 +1104,7 @@ struct StructMemberDescriptionFactory {\n impl MemberDescriptionFactory for StructMemberDescriptionFactory {\n     fn create_member_descriptions(&self, cx: &mut CrateContext)\n                                   -> ~[MemberDescription] {\n-        do self.fields.map |field| {\n+        self.fields.map(|field| {\n             let name = if field.ident.name == special_idents::unnamed_field.name {\n                 @\"\"\n             } else {\n@@ -1113,7 +1117,7 @@ impl MemberDescriptionFactory for StructMemberDescriptionFactory {\n                 type_metadata: type_metadata(cx, field.mt.ty, self.span),\n                 offset: ComputedMemberOffset,\n             }\n-        }\n+        })\n     }\n }\n \n@@ -1210,14 +1214,14 @@ struct TupleMemberDescriptionFactory {\n impl MemberDescriptionFactory for TupleMemberDescriptionFactory {\n     fn create_member_descriptions(&self, cx: &mut CrateContext)\n                                   -> ~[MemberDescription] {\n-        do self.component_types.map |&component_type| {\n+        self.component_types.map(|&component_type| {\n             MemberDescription {\n                 name: @\"\",\n                 llvm_type: type_of::type_of(cx, component_type),\n                 type_metadata: type_metadata(cx, component_type, self.span),\n                 offset: ComputedMemberOffset,\n             }\n-        }\n+        })\n     }\n }\n \n@@ -1267,10 +1271,10 @@ impl MemberDescriptionFactory for GeneralMemberDescriptionFactory {\n             _ => cx.sess.bug(\"unreachable\")\n         };\n \n-        do struct_defs\n+        struct_defs\n             .iter()\n             .enumerate()\n-            .map |(i, struct_def)| {\n+            .map(|(i, struct_def)| {\n                 let (variant_type_metadata, variant_llvm_type, member_desc_factory) =\n                     describe_variant(cx,\n                                      struct_def,\n@@ -1295,7 +1299,7 @@ impl MemberDescriptionFactory for GeneralMemberDescriptionFactory {\n                     type_metadata: variant_type_metadata,\n                     offset: FixedMemberOffset { bytes: 0 },\n                 }\n-        }.collect()\n+        }).collect()\n     }\n }\n \n@@ -1308,7 +1312,7 @@ struct EnumVariantMemberDescriptionFactory {\n impl MemberDescriptionFactory for EnumVariantMemberDescriptionFactory {\n     fn create_member_descriptions(&self, cx: &mut CrateContext)\n                                   -> ~[MemberDescription] {\n-        do self.args.iter().enumerate().map |(i, &(name, ty))| {\n+        self.args.iter().enumerate().map(|(i, &(name, ty))| {\n             MemberDescription {\n                 name: name,\n                 llvm_type: type_of::type_of(cx, ty),\n@@ -1318,7 +1322,7 @@ impl MemberDescriptionFactory for EnumVariantMemberDescriptionFactory {\n                 },\n                 offset: ComputedMemberOffset,\n             }\n-        }.collect()\n+        }).collect()\n     }\n }\n \n@@ -1360,8 +1364,8 @@ fn describe_variant(cx: &mut CrateContext,\n \n     // Get the argument names from the enum variant info\n     let mut arg_names = match variant_info.arg_names {\n-        Some(ref names) => do names.map |ident| { token::ident_to_str(ident) },\n-        None => do variant_info.args.map |_| { @\"\" }\n+        Some(ref names) => names.map(|ident| token::ident_to_str(ident)),\n+        None => variant_info.args.map(|_| @\"\")\n     };\n \n     // If this is not a univariant enum, there is also the (unnamed) discriminant field\n@@ -1420,14 +1424,14 @@ fn prepare_enum_metadata(cx: &mut CrateContext,\n             let name: &str = token::ident_to_str(&v.name);\n             let discriminant_value = v.disr_val as c_ulonglong;\n \n-            do name.with_c_str |name| {\n+            name.with_c_str(|name| {\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateEnumerator(\n                         DIB(cx),\n                         name,\n                         discriminant_value)\n                 }\n-            }\n+            })\n         })\n         .collect();\n \n@@ -1436,7 +1440,7 @@ fn prepare_enum_metadata(cx: &mut CrateContext,\n         let (discriminant_size, discriminant_align) = size_and_align_of(cx, discriminant_llvm_type);\n         let discriminant_base_type_metadata = type_metadata(cx, adt::ty_of_inttype(inttype),\n                                                             codemap::dummy_sp());\n-        do enum_name.with_c_str |enum_name| {\n+        enum_name.with_c_str(|enum_name| {\n             unsafe {\n                 llvm::LLVMDIBuilderCreateEnumerationType(\n                     DIB(cx),\n@@ -1449,7 +1453,7 @@ fn prepare_enum_metadata(cx: &mut CrateContext,\n                     create_DIArray(DIB(cx), enumerators_metadata),\n                     discriminant_base_type_metadata)\n             }\n-        }\n+        })\n     };\n \n     let type_rep = adt::represent_type(cx, enum_type);\n@@ -1482,7 +1486,7 @@ fn prepare_enum_metadata(cx: &mut CrateContext,\n             let enum_llvm_type = type_of::type_of(cx, enum_type);\n             let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n \n-            let enum_metadata = do enum_name.with_c_str |enum_name| {\n+            let enum_metadata = enum_name.with_c_str(|enum_name| {\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateUnionType(\n                     DIB(cx),\n@@ -1495,7 +1499,8 @@ fn prepare_enum_metadata(cx: &mut CrateContext,\n                     0, // Flags\n                     ptr::null(),\n                     0) // RuntimeLang\n-            }};\n+                }\n+            });\n \n             UnfinishedMetadata {\n                 cache_id: cache_id_for_type(enum_type),\n@@ -1605,7 +1610,7 @@ fn set_members_of_composite_type(cx: &mut CrateContext,\n                 ComputedMemberOffset => machine::llelement_offset(cx, composite_llvm_type, i)\n             };\n \n-            do member_description.name.with_c_str |member_name| {\n+            member_description.name.with_c_str(|member_name| {\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateMemberType(\n                         DIB(cx),\n@@ -1619,7 +1624,7 @@ fn set_members_of_composite_type(cx: &mut CrateContext,\n                         0,\n                         member_description.type_metadata)\n                 }\n-            }\n+            })\n         })\n         .collect();\n \n@@ -1649,27 +1654,29 @@ fn create_struct_stub(cx: &mut CrateContext,\n     };\n \n     return unsafe {\n-        do struct_type_name.with_c_str |name| {\n-        do unique_id.with_c_str |unique_id| {\n-            // LLVMDIBuilderCreateStructType() wants an empty array. A null pointer will lead to\n-            // hard to trace and debug LLVM assertions later on in llvm/lib/IR/Value.cpp\n-            let empty_array = create_DIArray(DIB(cx), []);\n+        struct_type_name.with_c_str(|name| {\n+            unique_id.with_c_str(|unique_id| {\n+                // LLVMDIBuilderCreateStructType() wants an empty array. A null pointer will lead to\n+                // hard to trace and debug LLVM assertions later on in llvm/lib/IR/Value.cpp\n+                let empty_array = create_DIArray(DIB(cx), []);\n \n-            llvm::LLVMDIBuilderCreateStructType(\n-                DIB(cx),\n-                containing_scope,\n-                name,\n-                file_metadata,\n-                loc.line as c_uint,\n-                bytes_to_bits(struct_size),\n-                bytes_to_bits(struct_align),\n-                0,\n-                ptr::null(),\n-                empty_array,\n-                0,\n-                ptr::null(),\n-                unique_id)\n-    }}};\n+                llvm::LLVMDIBuilderCreateStructType(\n+                    DIB(cx),\n+                    containing_scope,\n+                    name,\n+                    file_metadata,\n+                    loc.line as c_uint,\n+                    bytes_to_bits(struct_size),\n+                    bytes_to_bits(struct_align),\n+                    0,\n+                    ptr::null(),\n+                    empty_array,\n+                    0,\n+                    ptr::null(),\n+                    unique_id)\n+            })\n+        })\n+    };\n }\n \n fn boxed_type_metadata(cx: &mut CrateContext,\n@@ -1979,7 +1986,7 @@ fn unimplemented_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n     debug!(\"unimplemented_type_metadata: {:?}\", ty::get(t));\n \n     let name = ppaux::ty_to_str(cx.tcx, t);\n-    let metadata = do format!(\"NYI<{}>\", name).with_c_str |name| {\n+    let metadata = format!(\"NYI<{}>\", name).with_c_str(|name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreateBasicType(\n                 DIB(cx),\n@@ -1988,7 +1995,7 @@ fn unimplemented_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n                 8_u64,\n                 DW_ATE_unsigned as c_uint)\n             }\n-        };\n+        });\n \n     return metadata;\n }\n@@ -2261,10 +2268,10 @@ fn populate_scope_map(cx: &mut CrateContext,\n     // Push argument identifiers onto the stack so arguments integrate nicely with variable\n     // shadowing.\n     for &arg_pat in arg_pats.iter() {\n-        do pat_util::pat_bindings(def_map, arg_pat) |_, _, _, path_ref| {\n+        pat_util::pat_bindings(def_map, arg_pat, |_, _, _, path_ref| {\n             let ident = ast_util::path_to_ident(path_ref);\n             scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata, ident: Some(ident) });\n-        }\n+        })\n     }\n \n     walk_block(cx, fn_entry_block, &mut scope_stack, scope_map);\n@@ -2550,11 +2557,13 @@ fn populate_scope_map(cx: &mut CrateContext,\n             ast::ExprIf(@ref cond_exp, ref then_block, ref opt_else_exp) => {\n                 walk_expr(cx, cond_exp, scope_stack, scope_map);\n \n-                do with_new_scope(cx, then_block.span, scope_stack, scope_map) |cx,\n-                                                                                scope_stack,\n-                                                                                scope_map| {\n+                with_new_scope(cx,\n+                               then_block.span,\n+                               scope_stack,\n+                               scope_map,\n+                               |cx, scope_stack, scope_map| {\n                     walk_block(cx, then_block, scope_stack, scope_map);\n-                }\n+                });\n \n                 match *opt_else_exp {\n                     Some(@ref else_exp) => walk_expr(cx, else_exp, scope_stack, scope_map),\n@@ -2565,11 +2574,13 @@ fn populate_scope_map(cx: &mut CrateContext,\n             ast::ExprWhile(@ref cond_exp, ref loop_body) => {\n                 walk_expr(cx, cond_exp, scope_stack, scope_map);\n \n-                do with_new_scope(cx, loop_body.span, scope_stack, scope_map) |cx,\n-                                                                               scope_stack,\n-                                                                               scope_map| {\n+                with_new_scope(cx,\n+                               loop_body.span,\n+                               scope_stack,\n+                               scope_map,\n+                               |cx, scope_stack, scope_map| {\n                     walk_block(cx, loop_body, scope_stack, scope_map);\n-                }\n+                })\n             }\n \n             ast::ExprForLoop(_, _, _, _) => {\n@@ -2584,24 +2595,28 @@ fn populate_scope_map(cx: &mut CrateContext,\n \n             ast::ExprLoop(ref block, _) |\n             ast::ExprBlock(ref block)   => {\n-                do with_new_scope(cx, block.span, scope_stack, scope_map) |cx,\n-                                                                           scope_stack,\n-                                                                           scope_map| {\n+                with_new_scope(cx,\n+                               block.span,\n+                               scope_stack,\n+                               scope_map,\n+                               |cx, scope_stack, scope_map| {\n                     walk_block(cx, block, scope_stack, scope_map);\n-                }\n+                })\n             }\n \n             ast::ExprFnBlock(ast::fn_decl { inputs: ref inputs, _ }, ref block) |\n             ast::ExprProc(ast::fn_decl { inputs: ref inputs, _ }, ref block) => {\n-                do with_new_scope(cx, block.span, scope_stack, scope_map) |cx,\n-                                                                           scope_stack,\n-                                                                           scope_map| {\n+                with_new_scope(cx,\n+                               block.span,\n+                               scope_stack,\n+                               scope_map,\n+                               |cx, scope_stack, scope_map| {\n                     for &ast::arg { pat: pattern, _ } in inputs.iter() {\n                         walk_pattern(cx, pattern, scope_stack, scope_map);\n                     }\n \n                     walk_block(cx, block, scope_stack, scope_map);\n-                }\n+                })\n             }\n \n             // ast::expr_loop_body(@ref inner_exp) |\n@@ -2646,9 +2661,11 @@ fn populate_scope_map(cx: &mut CrateContext,\n                 for arm_ref in arms.iter() {\n                     let arm_span = arm_ref.pats[0].span;\n \n-                    do with_new_scope(cx, arm_span, scope_stack, scope_map) |cx,\n-                                                                             scope_stack,\n-                                                                             scope_map| {\n+                    with_new_scope(cx,\n+                                   arm_span,\n+                                   scope_stack,\n+                                   scope_map,\n+                                   |cx, scope_stack, scope_map| {\n                         for &pat in arm_ref.pats.iter() {\n                             walk_pattern(cx, pat, scope_stack, scope_map);\n                         }\n@@ -2658,7 +2675,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n                         }\n \n                         walk_block(cx, &arm_ref.body, scope_stack, scope_map);\n-                    }\n+                    })\n                 }\n             }\n \n@@ -2769,14 +2786,14 @@ fn namespace_for_item(cx: &mut CrateContext,\n                 let namespace_name = token::ident_to_str(&ident);\n \n                 let namespace_metadata = unsafe {\n-                    do namespace_name.with_c_str |namespace_name| {\n+                    namespace_name.with_c_str(|namespace_name| {\n                         llvm::LLVMDIBuilderCreateNameSpace(\n                             DIB(cx),\n                             parent_scope,\n                             namespace_name,\n                             ptr::null(), // cannot reconstruct file ...\n                             0)           // ... or line information, but that's not so important.\n-                    }\n+                    })\n                 };\n \n                 let node = @NamespaceTreeNode {"}, {"sha": "4d69c95d281b235e14aee829a91aefcfd724ca6d", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -693,10 +693,12 @@ fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: &ast::Expr,\n             return _match::trans_match(bcx, expr, discr, *arms, dest);\n         }\n         ast::ExprBlock(ref blk) => {\n-            return do base::with_scope(bcx, blk.info(),\n-                                       \"block-expr body\") |bcx| {\n+            return base::with_scope(bcx,\n+                                    blk.info(),\n+                                    \"block-expr body\",\n+                                    |bcx| {\n                 controlflow::trans_block(bcx, blk, dest)\n-            };\n+            });\n         }\n         ast::ExprStruct(_, ref fields, base) => {\n             return trans_rec_or_struct(bcx, (*fields), base, expr.span, expr.id, dest);\n@@ -930,17 +932,18 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n \n         let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n         let repr = adt::represent_type(bcx.ccx(), base_datum.ty);\n-        do with_field_tys(bcx.tcx(), base_datum.ty, None) |discr, field_tys| {\n+        with_field_tys(bcx.tcx(), base_datum.ty, None, |discr, field_tys| {\n             let ix = ty::field_idx_strict(bcx.tcx(), field.name, field_tys);\n             DatumBlock {\n-                datum: do base_datum.get_element(bcx,\n-                                                 field_tys[ix].mt.ty,\n-                                                 ZeroMem) |srcval| {\n+                datum: base_datum.get_element(bcx,\n+                                              field_tys[ix].mt.ty,\n+                                              ZeroMem,\n+                                              |srcval| {\n                     adt::trans_field_ptr(bcx, repr, srcval, discr, ix)\n-                },\n+                }),\n                 bcx: bcx\n             }\n-        }\n+        })\n     }\n \n     fn trans_index(bcx: @mut Block,\n@@ -984,9 +987,9 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n         let bounds_check = ICmp(bcx, lib::llvm::IntUGE, ix_val, len);\n         let expect = ccx.intrinsics.get_copy(&(\"llvm.expect.i1\"));\n         let expected = Call(bcx, expect, [bounds_check, C_i1(false)], []);\n-        let bcx = do with_cond(bcx, expected) |bcx| {\n+        let bcx = with_cond(bcx, expected, |bcx| {\n             controlflow::trans_fail_bounds_check(bcx, index_expr.span, ix_val, len)\n-        };\n+        });\n         let elt = InBoundsGEP(bcx, base, [ix_val]);\n         let elt = PointerCast(bcx, elt, vt.llunit_ty.ptr_to());\n         return DatumBlock {\n@@ -1044,11 +1047,11 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n                             let symbol = csearch::get_symbol(\n                                 bcx.ccx().sess.cstore,\n                                 did);\n-                            let llval = do symbol.with_c_str |buf| {\n+                            let llval = symbol.with_c_str(|buf| {\n                                 llvm::LLVMAddGlobal(bcx.ccx().llmod,\n                                                     llty.to_ref(),\n                                                     buf)\n-                            };\n+                            });\n                             let extern_const_values = &mut bcx.ccx().extern_const_values;\n                             extern_const_values.insert(did, llval);\n                             llval\n@@ -1208,10 +1211,10 @@ fn trans_rec_or_struct(bcx: @mut Block,\n \n     let ty = node_id_type(bcx, id);\n     let tcx = bcx.tcx();\n-    do with_field_tys(tcx, ty, Some(id)) |discr, field_tys| {\n+    with_field_tys(tcx, ty, Some(id), |discr, field_tys| {\n         let mut need_base = vec::from_elem(field_tys.len(), true);\n \n-        let numbered_fields = do fields.map |field| {\n+        let numbered_fields = fields.map(|field| {\n             let opt_pos =\n                 field_tys.iter().position(|field_ty|\n                                           field_ty.ident.name == field.ident.node.name);\n@@ -1225,7 +1228,7 @@ fn trans_rec_or_struct(bcx: @mut Block,\n                                       \"Couldn't find field in struct type\")\n                 }\n             }\n-        };\n+        });\n         let optbase = match base {\n             Some(base_expr) => {\n                 let mut leftovers = ~[];\n@@ -1247,7 +1250,7 @@ fn trans_rec_or_struct(bcx: @mut Block,\n \n         let repr = adt::represent_type(bcx.ccx(), ty);\n         trans_adt(bcx, repr, discr, numbered_fields, optbase, dest)\n-    }\n+    })\n }\n \n /**\n@@ -1308,9 +1311,9 @@ fn trans_adt(bcx: @mut Block, repr: &adt::Repr, discr: ty::Disr,\n         // And, would it ever be reasonable to be here with discr != 0?\n         let base_datum = unpack_datum!(bcx, trans_to_datum(bcx, base.expr));\n         for &(i, t) in base.fields.iter() {\n-            let datum = do base_datum.get_element(bcx, t, ZeroMem) |srcval| {\n+            let datum = base_datum.get_element(bcx, t, ZeroMem, |srcval| {\n                 adt::trans_field_ptr(bcx, repr, srcval, discr, i)\n-            };\n+            });\n             let dest = adt::trans_field_ptr(bcx, repr, addr, discr, i);\n             bcx = datum.store_to(bcx, INIT, dest);\n         }\n@@ -1541,9 +1544,9 @@ fn trans_lazy_binop(bcx: @mut Block,\n     let bcx = bcx;\n \n     let Result {bcx: past_lhs, val: lhs} = {\n-        do base::with_scope_result(bcx, a.info(), \"lhs\") |bcx| {\n+        base::with_scope_result(bcx, a.info(), \"lhs\", |bcx| {\n             trans_to_datum(bcx, a).to_result()\n-        }\n+        })\n     };\n \n     if past_lhs.unreachable {\n@@ -1560,9 +1563,9 @@ fn trans_lazy_binop(bcx: @mut Block,\n     }\n \n     let Result {bcx: past_rhs, val: rhs} = {\n-        do base::with_scope_result(before_rhs, b.info(), \"rhs\") |bcx| {\n+        base::with_scope_result(before_rhs, b.info(), \"rhs\", |bcx| {\n             trans_to_datum(bcx, b).to_result()\n-        }\n+        })\n     };\n \n     if past_rhs.unreachable {\n@@ -1830,9 +1833,9 @@ pub fn trans_log_level(bcx: @mut Block) -> DatumBlock {\n             ccx, modpath, \"loglevel\");\n         let global;\n         unsafe {\n-            global = do s.with_c_str |buf| {\n+            global = s.with_c_str(|buf| {\n                 llvm::LLVMAddGlobal(ccx.llmod, Type::i32().to_ref(), buf)\n-            };\n+            });\n             llvm::LLVMSetGlobalConstant(global, False);\n             llvm::LLVMSetInitializer(global, C_null(Type::i32()));\n             lib::llvm::SetLinkage(global, lib::llvm::InternalLinkage);"}, {"sha": "742683307020086f0feeb436bd6c8d1777e20a71", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -647,11 +647,11 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n         }\n \n         // Perform the call itself\n-        let llrust_ret_val = do llrust_args.as_imm_buf |ptr, len| {\n+        let llrust_ret_val = llrust_args.as_imm_buf(|ptr, len| {\n             debug!(\"calling llrustfn = {}\", ccx.tn.val_to_str(llrustfn));\n             llvm::LLVMBuildCall(builder, llrustfn, ptr,\n                                 len as c_uint, noname())\n-        };\n+        });\n \n         // Get the return value where the foreign fn expects it.\n         let llforeign_ret_ty = match tys.fn_ty.ret_ty.cast {"}, {"sha": "70d983a01fa4f1e39cadfe68d2179ebd558ec4d6", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -336,7 +336,7 @@ pub fn call_tydesc_glue(cx: @mut Block, v: ValueRef, t: ty::t, field: uint)\n \n pub fn make_visit_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n     let _icx = push_ctxt(\"make_visit_glue\");\n-    do with_scope(bcx, None, \"visitor cleanup\") |bcx| {\n+    with_scope(bcx, None, \"visitor cleanup\", |bcx| {\n         let mut bcx = bcx;\n         let (visitor_trait, object_ty) = match ty::visitor_object_ty(bcx.tcx(),\n                                                                      ty::ReStatic) {\n@@ -350,7 +350,7 @@ pub fn make_visit_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n         // The visitor is a boxed object and needs to be dropped\n         add_clean(bcx, v, object_ty);\n         bcx\n-    }\n+    })\n }\n \n pub fn make_free_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n@@ -394,9 +394,9 @@ pub fn trans_struct_drop_flag(bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did:\n                               class_did: ast::DefId, substs: &ty::substs) -> @mut Block {\n     let repr = adt::represent_type(bcx.ccx(), t);\n     let drop_flag = adt::trans_drop_flag_ptr(bcx, repr, v0);\n-    do with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag))) |cx| {\n+    with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag)), |cx| {\n         trans_struct_drop(cx, t, v0, dtor_did, class_did, substs)\n-    }\n+    })\n }\n \n pub fn trans_struct_drop(bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did: ast::DefId,\n@@ -420,7 +420,7 @@ pub fn trans_struct_drop(bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did: ast:\n     // Be sure to put all of the fields into a scope so we can use an invoke\n     // instruction to call the user destructor but still call the field\n     // destructors if the user destructor fails.\n-    do with_scope(bcx, None, \"field drops\") |bcx| {\n+    with_scope(bcx, None, \"field drops\", |bcx| {\n         let self_arg = PointerCast(bcx, v0, params[0]);\n         let args = ~[self_arg];\n \n@@ -434,7 +434,7 @@ pub fn trans_struct_drop(bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did: ast:\n \n         let (_, bcx) = invoke(bcx, dtor_addr, args, []);\n         bcx\n-    }\n+    })\n }\n \n pub fn make_drop_glue(bcx: @mut Block, v0: ValueRef, t: ty::t) -> @mut Block {\n@@ -480,7 +480,7 @@ pub fn make_drop_glue(bcx: @mut Block, v0: ValueRef, t: ty::t) -> @mut Block {\n       ty::ty_trait(_, _, ty::UniqTraitStore, _, _) => {\n           let lluniquevalue = GEPi(bcx, v0, [0, abi::trt_field_box]);\n           // Only drop the value when it is non-null\n-          do with_cond(bcx, IsNotNull(bcx, Load(bcx, lluniquevalue))) |bcx| {\n+          with_cond(bcx, IsNotNull(bcx, Load(bcx, lluniquevalue)), |bcx| {\n               let llvtable = Load(bcx, GEPi(bcx, v0, [0, abi::trt_field_vtable]));\n \n               // Cast the vtable to a pointer to a pointer to a tydesc.\n@@ -493,7 +493,7 @@ pub fn make_drop_glue(bcx: @mut Block, v0: ValueRef, t: ty::t) -> @mut Block {\n                                     abi::tydesc_field_free_glue,\n                                     None);\n               bcx\n-          }\n+          })\n       }\n       ty::ty_opaque_closure_ptr(ck) => {\n         closure::make_opaque_cbox_drop_glue(bcx, ck, v0)\n@@ -618,11 +618,11 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n     let name = mangle_internal_name_by_type_and_seq(ccx, t, \"tydesc\").to_managed();\n     note_unique_llvm_symbol(ccx, name);\n     debug!(\"+++ declare_tydesc {} {}\", ppaux::ty_to_str(ccx.tcx, t), name);\n-    let gvar = do name.with_c_str |buf| {\n+    let gvar = name.with_c_str(|buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type.to_ref(), buf)\n         }\n-    };\n+    });\n \n     let ty_name = C_estr_slice(ccx, ppaux::ty_to_str(ccx.tcx, t).to_managed());\n \n@@ -642,7 +642,8 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n     return inf;\n }\n \n-pub type glue_helper<'self> = &'self fn(@mut Block, ValueRef, ty::t) -> @mut Block;\n+pub type glue_helper<'self> = 'self |@mut Block, ValueRef, ty::t|\n+                                     -> @mut Block;\n \n pub fn declare_generic_glue(ccx: &mut CrateContext, t: ty::t, llfnty: Type,\n                             name: &str) -> ValueRef {"}, {"sha": "71d2204b94f35d63aba7f755a5dda8ff3a81ee44", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -545,14 +545,14 @@ pub fn get_vtable(bcx: @mut Block,\n     }\n \n     // Not in the cache. Actually build it.\n-    let methods = do origins.flat_map |origin| {\n+    let methods = origins.flat_map(|origin| {\n         match *origin {\n             typeck::vtable_static(id, ref substs, sub_vtables) => {\n                 emit_vtable_methods(bcx, id, *substs, sub_vtables)\n             }\n             _ => ccx.sess.bug(\"get_vtable: expected a static origin\"),\n         }\n-    };\n+    });\n \n     // Generate a type descriptor for the vtable.\n     let tydesc = get_tydesc(ccx, self_ty);\n@@ -578,9 +578,9 @@ pub fn make_vtable(ccx: &mut CrateContext,\n \n         let tbl = C_struct(components, false);\n         let sym = token::gensym(\"vtable\");\n-        let vt_gvar = do format!(\"vtable{}\", sym).with_c_str |buf| {\n+        let vt_gvar = format!(\"vtable{}\", sym).with_c_str(|buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl).to_ref(), buf)\n-        };\n+        });\n         llvm::LLVMSetInitializer(vt_gvar, tbl);\n         llvm::LLVMSetGlobalConstant(vt_gvar, lib::llvm::True);\n         lib::llvm::SetLinkage(vt_gvar, lib::llvm::InternalLinkage);\n@@ -605,7 +605,7 @@ fn emit_vtable_methods(bcx: @mut Block,\n     ty::populate_implementations_for_trait_if_necessary(bcx.tcx(), trt_id);\n \n     let trait_method_def_ids = ty::trait_method_def_ids(tcx, trt_id);\n-    do trait_method_def_ids.map |method_def_id| {\n+    trait_method_def_ids.map(|method_def_id| {\n         let ident = ty::method(tcx, *method_def_id).ident;\n         // The substitutions we have are on the impl, so we grab\n         // the method type from the impl to substitute into.\n@@ -626,7 +626,7 @@ fn emit_vtable_methods(bcx: @mut Block,\n             trans_fn_ref_with_vtables(bcx, m_id, 0,\n                                       substs, Some(vtables)).llfn\n         }\n-    }\n+    })\n }\n \n pub fn trans_trait_cast(bcx: @mut Block,"}, {"sha": "ccfe0d6e9794982ff7953c50864963c592048421", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -213,12 +213,12 @@ impl Reflector {\n           ty::ty_tup(ref tys) => {\n               let extra = ~[self.c_uint(tys.len())]\n                   + self.c_size_and_align(t);\n-              do self.bracketed(\"tup\", extra) |this| {\n+              self.bracketed(\"tup\", extra, |this| {\n                   for (i, t) in tys.iter().enumerate() {\n                       let extra = ~[this.c_uint(i), this.c_tydesc(*t)];\n                       this.visit(\"tup_field\", extra);\n                   }\n-              }\n+              })\n           }\n \n           // FIXME (#2594): fetch constants out of intrinsic\n@@ -262,15 +262,15 @@ impl Reflector {\n               let extra = ~[self.c_slice(ty_to_str(tcx, t).to_managed()),\n                             self.c_bool(named_fields),\n                             self.c_uint(fields.len())] + self.c_size_and_align(t);\n-              do self.bracketed(\"class\", extra) |this| {\n+              self.bracketed(\"class\", extra, |this| {\n                   for (i, field) in fields.iter().enumerate() {\n                       let extra = ~[this.c_uint(i),\n                                     this.c_slice(bcx.ccx().sess.str_of(field.ident)),\n                                     this.c_bool(named_fields)]\n                           + this.c_mt(&field.mt);\n                       this.visit(\"class_field\", extra);\n                   }\n-              }\n+              })\n           }\n \n           // FIXME (#2595): visiting all the variants in turn is probably\n@@ -320,14 +320,14 @@ impl Reflector {\n \n             let enum_args = ~[self.c_uint(variants.len()), make_get_disr()]\n                 + self.c_size_and_align(t);\n-            do self.bracketed(\"enum\", enum_args) |this| {\n+            self.bracketed(\"enum\", enum_args, |this| {\n                 for (i, v) in variants.iter().enumerate() {\n                     let name = ccx.sess.str_of(v.name);\n                     let variant_args = ~[this.c_uint(i),\n                                          C_u64(v.disr_val),\n                                          this.c_uint(v.args.len()),\n                                          this.c_slice(name)];\n-                    do this.bracketed(\"enum_variant\", variant_args) |this| {\n+                    this.bracketed(\"enum_variant\", variant_args, |this| {\n                         for (j, a) in v.args.iter().enumerate() {\n                             let bcx = this.bcx;\n                             let null = C_null(llptrty);\n@@ -338,9 +338,9 @@ impl Reflector {\n                                                this.c_tydesc(*a)];\n                             this.visit(\"enum_variant_field\", field_args);\n                         }\n-                    }\n+                    })\n                 }\n-            }\n+            })\n           }\n \n           ty::ty_trait(_, _, _, _, _) => {"}, {"sha": "82615b1e119a08bb46fe25942023973f3e474074", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -539,7 +539,8 @@ pub fn get_base_and_len(bcx: @mut Block, llval: ValueRef, vec_ty: ty::t) -> (Val\n     }\n }\n \n-pub type iter_vec_block<'self> = &'self fn(@mut Block, ValueRef, ty::t) -> @mut Block;\n+pub type iter_vec_block<'self> = 'self |@mut Block, ValueRef, ty::t|\n+                                        -> @mut Block;\n \n pub fn iter_vec_loop(bcx: @mut Block,\n                      data_ptr: ValueRef,"}, {"sha": "18b45fb461381617bfa23b17928c37fb2720270f", "filename": "src/librustc/middle/trans/uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -23,7 +23,7 @@ pub fn make_free_glue(bcx: @mut Block, vptrptr: ValueRef, box_ty: ty::t)\n     let box_datum = immediate_rvalue(Load(bcx, vptrptr), box_ty);\n \n     let not_null = IsNotNull(bcx, box_datum.val);\n-    do with_cond(bcx, not_null) |bcx| {\n+    with_cond(bcx, not_null, |bcx| {\n         let body_datum = box_datum.box_body(bcx);\n         let bcx = glue::drop_ty(bcx, body_datum.to_ref_llval(bcx),\n                                 body_datum.ty);\n@@ -32,5 +32,5 @@ pub fn make_free_glue(bcx: @mut Block, vptrptr: ValueRef, box_ty: ty::t)\n         } else {\n             glue::trans_exchange_free(bcx, box_datum.val)\n         }\n-    }\n+    })\n }"}, {"sha": "59bc397a55884f96e9a105642f4938634ff4075b", "filename": "src/librustc/middle/trans/value.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -52,7 +52,7 @@ impl Value {\n     pub fn get_dominating_store(self, bcx: &mut Block) -> Option<Value> {\n         match self.get_single_user().and_then(|user| user.as_store_inst()) {\n             Some(store) => {\n-                do store.get_parent().and_then |store_bb| {\n+                store.get_parent().and_then(|store_bb| {\n                     let mut bb = BasicBlock(bcx.llbb);\n                     let mut ret = Some(store);\n                     while *bb != *store_bb {\n@@ -62,7 +62,7 @@ impl Value {\n                         }\n                     }\n                     ret\n-                }\n+                })\n             }\n             _ => None\n         }\n@@ -150,8 +150,8 @@ impl Iterator<Value> for UserIterator {\n     fn next(&mut self) -> Option<Value> {\n         let current = self.next;\n \n-        self.next = do current.and_then |u| { u.get_next_use() };\n+        self.next = current.and_then(|u| u.get_next_use());\n \n-        do current.map |u| { u.get_user() }\n+        current.map(|u| u.get_user())\n     }\n }"}, {"sha": "00487830490e74b3c54a6de3a9f8d9ead02c0028", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -1684,7 +1684,7 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n \n     let mut encountered_box = encountered_box;\n     let mut needs_unwind_cleanup = false;\n-    do maybe_walk_ty(ty) |ty| {\n+    maybe_walk_ty(ty, |ty| {\n         let old_encountered_box = encountered_box;\n         let result = match get(ty).sty {\n           ty_box(_) | ty_opaque_box => {\n@@ -1729,7 +1729,7 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n \n         encountered_box = old_encountered_box;\n         result\n-    }\n+    });\n \n     return needs_unwind_cleanup;\n }\n@@ -2207,14 +2207,14 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                                -> TypeContents {\n         let _i = indenter();\n         let mut tc = TC::All;\n-        do each_inherited_builtin_bound(cx, bounds, traits) |bound| {\n+        each_inherited_builtin_bound(cx, bounds, traits, |bound| {\n             tc = tc - match bound {\n                 BoundStatic => TC::Nonstatic,\n                 BoundSend => TC::Nonsendable,\n                 BoundFreeze => TC::Nonfreezable,\n                 BoundSized => TC::Nonsized,\n             };\n-        }\n+        });\n         return tc;\n \n         // Iterates over all builtin bounds on the type parameter def, including\n@@ -2227,13 +2227,13 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 f(bound);\n             }\n \n-            do each_bound_trait_and_supertraits(cx, traits) |trait_ref| {\n+            each_bound_trait_and_supertraits(cx, traits, |trait_ref| {\n                 let trait_def = lookup_trait_def(cx, trait_ref.def_id);\n                 for bound in trait_def.bounds.iter() {\n                     f(bound);\n                 }\n                 true\n-            };\n+            });\n         }\n     }\n }\n@@ -2327,12 +2327,12 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             ty_enum(did, ref substs) => {\n                 seen.push(did);\n                 let vs = enum_variants(cx, did);\n-                let r = !vs.is_empty() && do vs.iter().all |variant| {\n-                    do variant.args.iter().any |aty| {\n+                let r = !vs.is_empty() && vs.iter().all(|variant| {\n+                    variant.args.iter().any(|aty| {\n                         let sty = subst(cx, substs, *aty);\n                         type_requires(cx, seen, r_ty, sty)\n-                    }\n-                };\n+                    })\n+                });\n                 seen.pop();\n                 r\n             }\n@@ -2490,11 +2490,11 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_opaque_closure_ptr(_) => result = true,\n       ty_struct(did, ref substs) => {\n         let fields = lookup_struct_fields(cx, did);\n-        result = do fields.iter().all |f| {\n+        result = fields.iter().all(|f| {\n             let fty = ty::lookup_item_type(cx, f.id);\n             let sty = subst(cx, substs, fty.ty);\n             type_is_pod(cx, sty)\n-        };\n+        });\n       }\n \n       ty_estr(vstore_slice(*)) | ty_evec(_, vstore_slice(*)) => {\n@@ -3000,7 +3000,7 @@ pub fn method_call_type_param_defs(tcx: ctxt,\n                                    method_map: typeck::method_map,\n                                    id: ast::NodeId)\n                                    -> Option<@~[TypeParameterDef]> {\n-    do method_map.find(&id).map |method| {\n+    method_map.find(&id).map(|method| {\n         match method.origin {\n           typeck::method_static(did) => {\n             // n.b.: When we encode impl methods, the bounds\n@@ -3026,7 +3026,7 @@ pub fn method_call_type_param_defs(tcx: ctxt,\n                                   n_mth).generics.type_param_defs)\n           }\n         }\n-    }\n+    })\n }\n \n pub fn resolve_expr(tcx: ctxt, expr: &ast::Expr) -> ast::Def {\n@@ -3217,14 +3217,14 @@ pub fn method_idx(id: ast::Ident, meths: &[@Method]) -> Option<uint> {\n /// to a bitset or some other representation.\n pub fn param_tys_in_type(ty: t) -> ~[param_ty] {\n     let mut rslt = ~[];\n-    do walk_ty(ty) |ty| {\n+    walk_ty(ty, |ty| {\n         match get(ty).sty {\n           ty_param(p) => {\n             rslt.push(p);\n           }\n           _ => ()\n         }\n-    }\n+    });\n     rslt\n }\n \n@@ -3233,12 +3233,12 @@ pub fn occurs_check(tcx: ctxt, sp: Span, vid: TyVid, rt: t) {\n     // contain duplicates.  (Integral type vars aren't counted.)\n     fn vars_in_type(ty: t) -> ~[TyVid] {\n         let mut rslt = ~[];\n-        do walk_ty(ty) |ty| {\n+        walk_ty(ty, |ty| {\n             match get(ty).sty {\n               ty_infer(TyVar(v)) => rslt.push(v),\n               _ => ()\n             }\n-        }\n+        });\n         rslt\n     }\n \n@@ -3644,9 +3644,9 @@ fn struct_ctor_id(cx: ctxt, struct_did: ast::DefId) -> Option<ast::DefId> {\n         Some(&ast_map::node_item(item, _)) => {\n             match item.node {\n                 ast::item_struct(struct_def, _) => {\n-                    do struct_def.ctor_id.map |ctor_id| {\n+                    struct_def.ctor_id.map(|ctor_id| {\n                         ast_util::local_def(ctor_id)\n-                    }\n+                    })\n                 }\n                 _ => cx.sess.bug(\"called struct_ctor_id on non-struct\")\n             }\n@@ -3698,13 +3698,13 @@ impl VariantInfo {\n                 assert!(fields.len() > 0);\n \n                 let arg_tys = ty_fn_args(ctor_ty).map(|a| *a);\n-                let arg_names = do fields.map |field| {\n+                let arg_names = fields.map(|field| {\n                     match field.node.kind {\n                         named_field(ident, _) => ident,\n                         unnamed_field => cx.sess.bug(\n                             \"enum_variants: all fields in struct must have a name\")\n                     }\n-                };\n+                });\n \n                 return VariantInfo {\n                     args: arg_tys,\n@@ -3724,7 +3724,7 @@ pub fn substd_enum_variants(cx: ctxt,\n                             id: ast::DefId,\n                             substs: &substs)\n                          -> ~[@VariantInfo] {\n-    do enum_variants(cx, id).iter().map |variant_info| {\n+    enum_variants(cx, id).iter().map(|variant_info| {\n         let substd_args = variant_info.args.iter()\n             .map(|aty| subst(cx, substs, *aty)).collect();\n \n@@ -3735,7 +3735,7 @@ pub fn substd_enum_variants(cx: ctxt,\n             ctor_ty: substd_ctor_ty,\n             ..(**variant_info).clone()\n         }\n-    }.collect()\n+    }).collect()\n }\n \n pub fn item_path_str(cx: ctxt, id: ast::DefId) -> ~str {\n@@ -3967,11 +3967,11 @@ pub fn each_attr(tcx: ctxt, did: DefId, f: |@MetaItem| -> bool) -> bool {\n         }\n     } else {\n         let mut cont = true;\n-        do csearch::get_item_attrs(tcx.cstore, did) |meta_items| {\n+        csearch::get_item_attrs(tcx.cstore, did, |meta_items| {\n             if cont {\n                 cont = meta_items.iter().advance(|ptrptr| f(*ptrptr));\n             }\n-        }\n+        });\n         return cont;\n     }\n }\n@@ -4083,7 +4083,7 @@ pub fn lookup_struct_field(cx: ctxt,\n }\n \n fn struct_field_tys(fields: &[@struct_field]) -> ~[field_ty] {\n-    do fields.map |field| {\n+    fields.map(|field| {\n         match field.node.kind {\n             named_field(ident, visibility) => {\n                 field_ty {\n@@ -4101,14 +4101,14 @@ fn struct_field_tys(fields: &[@struct_field]) -> ~[field_ty] {\n                 }\n             }\n         }\n-    }\n+    })\n }\n \n // Returns a list of fields corresponding to the struct's items. trans uses\n // this. Takes a list of substs with which to instantiate field types.\n pub fn struct_fields(cx: ctxt, did: ast::DefId, substs: &substs)\n                      -> ~[field] {\n-    do lookup_struct_fields(cx, did).map |f| {\n+    lookup_struct_fields(cx, did).map(|f| {\n        field {\n             // FIXME #6993: change type of field to Name and get rid of new()\n             ident: ast::Ident::new(f.name),\n@@ -4117,7 +4117,7 @@ pub fn struct_fields(cx: ctxt, did: ast::DefId, substs: &substs)\n                 mutbl: MutImmutable\n             }\n         }\n-    }\n+    })\n }\n \n pub fn is_binopable(cx: ctxt, ty: t, op: ast::BinOp) -> bool {\n@@ -4381,27 +4381,27 @@ pub fn count_traits_and_supertraits(tcx: ctxt,\n                                     type_param_defs: &[TypeParameterDef]) -> uint {\n     let mut total = 0;\n     for type_param_def in type_param_defs.iter() {\n-        do each_bound_trait_and_supertraits(\n-            tcx, type_param_def.bounds.trait_bounds) |_| {\n+        each_bound_trait_and_supertraits(\n+            tcx, type_param_def.bounds.trait_bounds, |_| {\n             total += 1;\n             true\n-        };\n+        });\n     }\n     return total;\n }\n \n pub fn get_tydesc_ty(tcx: ctxt) -> Result<t, ~str> {\n-    do tcx.lang_items.require(TyDescStructLangItem).map |tydesc_lang_item| {\n+    tcx.lang_items.require(TyDescStructLangItem).map(|tydesc_lang_item| {\n         tcx.intrinsic_defs.find_copy(&tydesc_lang_item)\n             .expect(\"Failed to resolve TyDesc\")\n-    }\n+    })\n }\n \n pub fn get_opaque_ty(tcx: ctxt) -> Result<t, ~str> {\n-    do tcx.lang_items.require(OpaqueStructLangItem).map |opaque_lang_item| {\n+    tcx.lang_items.require(OpaqueStructLangItem).map(|opaque_lang_item| {\n         tcx.intrinsic_defs.find_copy(&opaque_lang_item)\n             .expect(\"Failed to resolve Opaque\")\n-    }\n+    })\n }\n \n pub fn visitor_object_ty(tcx: ctxt,\n@@ -4460,7 +4460,7 @@ pub fn populate_implementations_for_type_if_necessary(tcx: ctxt,\n         return\n     }\n \n-    do csearch::each_implementation_for_type(tcx.sess.cstore, type_id)\n+    csearch::each_implementation_for_type(tcx.sess.cstore, type_id,\n             |implementation_def_id| {\n         let implementation = @csearch::get_impl(tcx, implementation_def_id);\n \n@@ -4498,7 +4498,7 @@ pub fn populate_implementations_for_type_if_necessary(tcx: ctxt,\n \n         // Store the implementation info.\n         tcx.impls.insert(implementation_def_id, implementation);\n-    }\n+    });\n \n     tcx.populated_external_types.insert(type_id);\n }\n@@ -4515,7 +4515,7 @@ pub fn populate_implementations_for_trait_if_necessary(\n         return\n     }\n \n-    do csearch::each_implementation_for_trait(tcx.sess.cstore, trait_id)\n+    csearch::each_implementation_for_trait(tcx.sess.cstore, trait_id,\n             |implementation_def_id| {\n         let implementation = @csearch::get_impl(tcx, implementation_def_id);\n \n@@ -4532,7 +4532,7 @@ pub fn populate_implementations_for_trait_if_necessary(\n \n         // Store the implementation info.\n         tcx.impls.insert(implementation_def_id, implementation);\n-    }\n+    });\n \n     tcx.populated_external_traits.insert(trait_id);\n }\n@@ -4607,9 +4607,9 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n         iter(hash, &mt.mutbl);\n     };\n     fn iter<T: IterBytes>(hash: &mut SipState, t: &T) {\n-        do t.iter_bytes(true) |bytes| { hash.input(bytes); true };\n+        t.iter_bytes(true, |bytes| { hash.input(bytes); true });\n     }\n-    do ty::walk_ty(t) |t| {\n+    ty::walk_ty(t, |t| {\n         match ty::get(t).sty {\n             ty_nil => hash.input([0]),\n             ty_bot => hash.input([1]),\n@@ -4714,7 +4714,7 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n                 mt(&mut hash, m);\n             }\n         }\n-    }\n+    });\n \n     hash.result_u64()\n }"}, {"sha": "2f35121dc02aea1be251d5568920e145df6d4f13", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -224,7 +224,7 @@ pub fn super_fold_trait_store<T:TypeFolder>(this: &mut T,\n \n pub struct BottomUpFolder<'self> {\n     tcx: ty::ctxt,\n-    fldop: &'self fn(ty::t) -> ty::t,\n+    fldop: 'self |ty::t| -> ty::t,\n }\n \n impl<'self> TypeFolder for BottomUpFolder<'self> {\n@@ -241,14 +241,14 @@ impl<'self> TypeFolder for BottomUpFolder<'self> {\n \n pub struct RegionFolder<'self> {\n     tcx: ty::ctxt,\n-    fld_t: &'self fn(ty::t) -> ty::t,\n-    fld_r: &'self fn(ty::Region) -> ty::Region,\n+    fld_t: 'self |ty::t| -> ty::t,\n+    fld_r: 'self |ty::Region| -> ty::Region,\n }\n \n impl<'self> RegionFolder<'self> {\n     pub fn general(tcx: ty::ctxt,\n-                   fld_r: &'self fn(ty::Region) -> ty::Region,\n-                   fld_t: &'self fn(ty::t) -> ty::t)\n+                   fld_r: 'self |ty::Region| -> ty::Region,\n+                   fld_t: 'self |ty::t| -> ty::t)\n                    -> RegionFolder<'self> {\n         RegionFolder {\n             tcx: tcx,\n@@ -257,8 +257,7 @@ impl<'self> RegionFolder<'self> {\n         }\n     }\n \n-    pub fn regions(tcx: ty::ctxt,\n-                   fld_r: &'self fn(ty::Region) -> ty::Region)\n+    pub fn regions(tcx: ty::ctxt, fld_r: 'self |ty::Region| -> ty::Region)\n                    -> RegionFolder<'self> {\n         fn noop(t: ty::t) -> ty::t { t }\n "}, {"sha": "77dbb66fd7f5860fb987276272de37b61c5a3d06", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -635,9 +635,9 @@ fn ty_of_method_or_bare_fn<AC:AstConv>(\n     // that function type\n     let rb = rscope::BindingRscope::new(id);\n \n-    let opt_transformed_self_ty = do opt_self_info.map |self_info| {\n+    let opt_transformed_self_ty = opt_self_info.map(|self_info| {\n         transform_self_ty(this, &rb, self_info)\n-    };\n+    });\n \n     let input_tys = decl.inputs.map(|a| ty_of_arg(this, &rb, a, None));\n \n@@ -730,14 +730,14 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope>(\n     // that function type\n     let rb = rscope::BindingRscope::new(id);\n \n-    let input_tys = do decl.inputs.iter().enumerate().map |(i, a)| {\n-        let expected_arg_ty = do expected_sig.as_ref().and_then |e| {\n+    let input_tys = decl.inputs.iter().enumerate().map(|(i, a)| {\n+        let expected_arg_ty = expected_sig.as_ref().and_then(|e| {\n             // no guarantee that the correct number of expected args\n             // were supplied\n             if i < e.inputs.len() {Some(e.inputs[i])} else {None}\n-        };\n+        });\n         ty_of_arg(this, &rb, a, expected_arg_ty)\n-    }.collect();\n+    }).collect();\n \n     let expected_ret_ty = expected_sig.map(|e| e.output);\n     let output_ty = match decl.output.node {"}, {"sha": "c7503e25684a12ca01bd39a5130d4c5b726fc5f2", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -378,14 +378,13 @@ impl<'self> LookupContext<'self> {\n         // we find the trait the method came from, counting up the\n         // methods from them.\n         let mut method_count = 0;\n-        do ty::each_bound_trait_and_supertraits(tcx, &[subtrait])\n-            |bound_ref| {\n+        ty::each_bound_trait_and_supertraits(tcx, &[subtrait], |bound_ref| {\n             if bound_ref.def_id == trait_ref.def_id { false }\n                 else {\n                 method_count += ty::trait_methods(tcx, bound_ref.def_id).len();\n                 true\n             }\n-        };\n+        });\n         return method_count + n_method;\n     }\n \n@@ -412,7 +411,7 @@ impl<'self> LookupContext<'self> {\n         };\n         let trait_ref = @TraitRef { def_id: did, substs: rcvr_substs.clone() };\n \n-        do self.push_inherent_candidates_from_bounds_inner(&[trait_ref])\n+        self.push_inherent_candidates_from_bounds_inner(&[trait_ref],\n             |new_trait_ref, m, method_num, _bound_num| {\n             let vtable_index =\n                 self.get_method_index(new_trait_ref, trait_ref, method_num);\n@@ -436,7 +435,7 @@ impl<'self> LookupContext<'self> {\n                         real_index: vtable_index\n                     })\n             }\n-        };\n+        });\n     }\n \n     fn push_inherent_candidates_from_param(&self,\n@@ -464,7 +463,7 @@ impl<'self> LookupContext<'self> {\n                                             self_ty: ty::t,\n                                             bounds: &[@TraitRef],\n                                             param: param_index) {\n-        do self.push_inherent_candidates_from_bounds_inner(bounds)\n+        self.push_inherent_candidates_from_bounds_inner(bounds,\n             |trait_ref, m, method_num, bound_num| {\n             Candidate {\n                 rcvr_match_condition: RcvrMatchesIfSubtype(self_ty),\n@@ -478,7 +477,7 @@ impl<'self> LookupContext<'self> {\n                         bound_num: bound_num,\n                     })\n             }\n-        }\n+        })\n     }\n \n     // Do a search through a list of bounds, using a callback to actually\n@@ -493,7 +492,7 @@ impl<'self> LookupContext<'self> {\n         let tcx = self.tcx();\n         let mut next_bound_idx = 0; // count only trait bounds\n \n-        do ty::each_bound_trait_and_supertraits(tcx, bounds) |bound_trait_ref| {\n+        ty::each_bound_trait_and_supertraits(tcx, bounds, |bound_trait_ref| {\n             let this_bound_idx = next_bound_idx;\n             next_bound_idx += 1;\n \n@@ -518,7 +517,7 @@ impl<'self> LookupContext<'self> {\n                 }\n             }\n             true\n-        };\n+        });\n     }\n \n "}, {"sha": "6bd8226258bd68e377e9e91ea620fcca1e92e3f9", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -392,12 +392,10 @@ impl Visitor<()> for GatherLocalsVisitor {\n     }\n \n     fn visit_block(&mut self, b:&ast::Block, _:()) {\n-            // non-obvious: the `blk` variable maps to region lb, so\n-            // we have to keep this up-to-date.  This\n-            // is... unfortunate.  It'd be nice to not need this.\n-            do self.fcx.with_region_lb(b.id) {\n-                visit::walk_block(self, b, ());\n-            }\n+        // non-obvious: the `blk` variable maps to region lb, so\n+        // we have to keep this up-to-date.  This\n+        // is... unfortunate.  It'd be nice to not need this.\n+        self.fcx.with_region_lb(b.id, || visit::walk_block(self, b, ()));\n     }\n \n         // Don't descend into fns and items\n@@ -517,10 +515,11 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         // Add formal parameters.\n         for (arg_ty, input) in arg_tys.iter().zip(decl.inputs.iter()) {\n             // Create type variables for each argument.\n-            do pat_util::pat_bindings(tcx.def_map, input.pat)\n-                    |_bm, pat_id, _sp, _path| {\n+            pat_util::pat_bindings(tcx.def_map,\n+                                   input.pat,\n+                                   |_bm, pat_id, _sp, _path| {\n                 visit.assign(pat_id, None);\n-            }\n+            });\n \n             // Check the pattern.\n             let pcx = pat_ctxt {\n@@ -1392,17 +1391,17 @@ pub fn valid_range_bounds(ccx: @mut CrateCtxt,\n pub fn check_expr_has_type(\n     fcx: @mut FnCtxt, expr: @ast::Expr,\n     expected: ty::t) {\n-    do check_expr_with_unifier(fcx, expr, Some(expected)) {\n+    check_expr_with_unifier(fcx, expr, Some(expected), || {\n         demand::suptype(fcx, expr.span, expected, fcx.expr_ty(expr));\n-    }\n+    });\n }\n \n pub fn check_expr_coercable_to_type(\n     fcx: @mut FnCtxt, expr: @ast::Expr,\n     expected: ty::t) {\n-    do check_expr_with_unifier(fcx, expr, Some(expected)) {\n+    check_expr_with_unifier(fcx, expr, Some(expected), || {\n         demand::coerce(fcx, expr.span, expected, expr)\n-    }\n+    });\n }\n \n pub fn check_expr_with_hint(\n@@ -1462,9 +1461,7 @@ pub fn lookup_field_ty(tcx: ty::ctxt,\n                        substs: &ty::substs) -> Option<ty::t> {\n \n     let o_field = items.iter().find(|f| f.name == fieldname);\n-    do o_field.map() |f| {\n-        ty::lookup_field_type(tcx, class_id, f.id, substs)\n-    }\n+    o_field.map(|f| ty::lookup_field_type(tcx, class_id, f.id, substs))\n }\n \n // Controls whether the arguments are automatically referenced. This is useful\n@@ -2693,7 +2690,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n       }\n       ast::ExprUnary(callee_id, unop, oprnd) => {\n-        let exp_inner = do unpack_expected(fcx, expected) |sty| {\n+        let exp_inner = unpack_expected(fcx, expected, |sty| {\n             match unop {\n               ast::UnBox(_) | ast::UnUniq => match *sty {\n                 ty::ty_box(ref mt) | ty::ty_uniq(ref mt) => Some(mt.ty),\n@@ -2702,7 +2699,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n               ast::UnNot | ast::UnNeg => expected,\n               ast::UnDeref => None\n             }\n-        };\n+        });\n         check_expr_with_opt_hint(fcx, oprnd, exp_inner);\n         let mut oprnd_t = fcx.expr_ty(oprnd);\n         if !ty::type_is_error(oprnd_t) &&\n@@ -2908,8 +2905,13 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         _match::check_match(fcx, expr, discrim, *arms);\n       }\n       ast::ExprFnBlock(ref decl, ref body) => {\n-        check_expr_fn(fcx, expr, None,\n-                      decl, body, Vanilla, expected);\n+        check_expr_fn(fcx,\n+                      expr,\n+                      Some(ast::BorrowedSigil),\n+                      decl,\n+                      body,\n+                      Vanilla,\n+                      expected);\n       }\n       ast::ExprProc(ref decl, ref body) => {\n         check_expr_fn(fcx,\n@@ -2925,12 +2927,15 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                            expected,\n                                            |x| Some((*x).clone()));\n         let inner_ty = match expected_sty {\n-            Some(ty::ty_closure(_)) => expected.unwrap(),\n+            Some(ty::ty_closure(ref closure_ty))\n+                    if closure_ty.sigil == ast::OwnedSigil => {\n+                expected.unwrap()\n+            }\n             _ => match expected {\n                 Some(expected_t) => {\n                     fcx.type_error_message(expr.span, |actual| {\n                         format!(\"last argument in `do` call \\\n-                              has non-closure type: {}\",\n+                              has non-procedure type: {}\",\n                              actual)\n                     }, expected_t, None);\n                     let err_ty = ty::mk_err();\n@@ -3137,7 +3142,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let mut bot_field = false;\n         let mut err_field = false;\n \n-        let elt_ts = do elts.iter().enumerate().map |(i, e)| {\n+        let elt_ts = elts.iter().enumerate().map(|(i, e)| {\n             let opt_hint = match flds {\n                 Some(ref fs) if i < fs.len() => Some(fs[i]),\n                 _ => None\n@@ -3147,7 +3152,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             err_field = err_field || ty::type_is_error(t);\n             bot_field = bot_field || ty::type_is_bot(t);\n             t\n-        }.collect();\n+        }).collect();\n         if bot_field {\n             fcx.write_bot(id);\n         } else if err_field {\n@@ -3355,7 +3360,7 @@ pub fn check_block_with_expected(fcx: @mut FnCtxt,\n     let purity_state = fcx.ps.recurse(blk);\n     let prev = replace(&mut fcx.ps, purity_state);\n \n-    do fcx.with_region_lb(blk.id) {\n+    fcx.with_region_lb(blk.id, || {\n         let mut warned = false;\n         let mut last_was_bot = false;\n         let mut any_bot = false;\n@@ -3408,7 +3413,7 @@ pub fn check_block_with_expected(fcx: @mut FnCtxt,\n               }\n           }\n         };\n-    }\n+    });\n \n     fcx.ps = prev;\n }"}, {"sha": "98ef129dd208f54ecfb99643ec6ae4a28039bbfc", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -212,7 +212,7 @@ fn visit_local(rcx: &mut Rcx, l: @ast::Local) {\n fn constrain_bindings_in_pat(pat: @ast::Pat, rcx: &mut Rcx) {\n     let tcx = rcx.fcx.tcx();\n     debug!(\"regionck::visit_pat(pat={})\", pat.repr(tcx));\n-    do pat_util::pat_bindings(tcx.def_map, pat) |_, id, span, _| {\n+    pat_util::pat_bindings(tcx.def_map, pat, |_, id, span, _| {\n         // If we have a variable that contains region'd data, that\n         // data will be accessible from anywhere that the variable is\n         // accessed. We must be wary of loops like this:\n@@ -240,7 +240,7 @@ fn constrain_bindings_in_pat(pat: @ast::Pat, rcx: &mut Rcx) {\n         constrain_regions_in_type_of_node(\n             rcx, id, encl_region,\n             infer::BindingTypeIsNotValidAtDecl(span));\n-    }\n+    })\n }\n \n fn visit_expr(rcx: &mut Rcx, expr: @ast::Expr) {\n@@ -735,7 +735,7 @@ fn constrain_regions_in_type(\n            region_to_str(tcx, \"\", false, minimum_lifetime),\n            ty_to_str(tcx, ty));\n \n-    do relate_nested_regions(tcx, Some(minimum_lifetime), ty) |r_sub, r_sup| {\n+    relate_nested_regions(tcx, Some(minimum_lifetime), ty, |r_sub, r_sup| {\n         debug!(\"relate_nested_regions(r_sub={}, r_sup={})\",\n                 r_sub.repr(tcx),\n                 r_sup.repr(tcx));\n@@ -754,7 +754,7 @@ fn constrain_regions_in_type(\n                 true, infer::ReferenceOutlivesReferent(ty, origin.span()),\n                 r_sub, r_sup);\n         }\n-    }\n+    });\n \n     return (e == rcx.errors_reported);\n }"}, {"sha": "7bf5eacb3d5c47184fec53a9c3c3fc0764a16c50", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -88,7 +88,7 @@ pub fn relate_nested_regions(tcx: ty::ctxt,\n     struct RegionRelator<'self> {\n         tcx: ty::ctxt,\n         stack: ~[ty::Region],\n-        relate_op: &'self fn(ty::Region, ty::Region),\n+        relate_op: 'self |ty::Region, ty::Region|,\n     }\n \n     // FIXME(#10151) -- Define more precisely when a region is"}, {"sha": "782a5276b7470e7157cfe6abadecd9fcf74f8221", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -132,7 +132,7 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n     // ty is the value supplied for the type parameter A...\n     let mut param_result = ~[];\n \n-    do ty::each_bound_trait_and_supertraits(tcx, type_param_bounds.trait_bounds) |trait_ref| {\n+    ty::each_bound_trait_and_supertraits(tcx, type_param_bounds.trait_bounds, |trait_ref| {\n         // ...and here trait_ref is each bound that was declared on A,\n         // expressed in terms of the type parameters.\n \n@@ -161,7 +161,7 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n             }\n         }\n         true\n-    };\n+    });\n \n     debug!(\"lookup_vtables_for_param result(\\\n             location_info={:?}, \\\n@@ -291,7 +291,7 @@ fn lookup_vtable_from_bounds(vcx: &VtableContext,\n \n     let mut n_bound = 0;\n     let mut ret = None;\n-    do ty::each_bound_trait_and_supertraits(tcx, bounds) |bound_trait_ref| {\n+    ty::each_bound_trait_and_supertraits(tcx, bounds, |bound_trait_ref| {\n         debug!(\"checking bounds trait {}\",\n                bound_trait_ref.repr(vcx.tcx()));\n \n@@ -309,7 +309,7 @@ fn lookup_vtable_from_bounds(vcx: &VtableContext,\n             n_bound += 1;\n             true\n         }\n-    };\n+    });\n     ret\n }\n \n@@ -483,12 +483,12 @@ fn fixup_substs(vcx: &VtableContext,\n                          ty::RegionTraitStore(ty::ReStatic),\n                          ast::MutImmutable,\n                          ty::EmptyBuiltinBounds());\n-    do fixup_ty(vcx, location_info, t, is_early).map |t_f| {\n+    fixup_ty(vcx, location_info, t, is_early).map(|t_f| {\n         match ty::get(t_f).sty {\n           ty::ty_trait(_, ref substs_f, _, _, _) => (*substs_f).clone(),\n           _ => fail!(\"t_f should be a trait\")\n         }\n-    }\n+    })\n }\n \n fn fixup_ty(vcx: &VtableContext,\n@@ -560,7 +560,7 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n     let cx = fcx.ccx;\n     match ex.node {\n       ast::ExprPath(*) => {\n-        do fcx.opt_node_ty_substs(ex.id) |substs| {\n+        fcx.opt_node_ty_substs(ex.id, |substs| {\n             debug!(\"vtable resolution on parameter bounds for expr {}\",\n                    ex.repr(fcx.tcx()));\n             let def = cx.tcx.def_map.get_copy(&ex.id);\n@@ -580,7 +580,7 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n                 }\n             }\n             true\n-        };\n+        });\n       }\n \n       ast::ExprParen(e) => {"}, {"sha": "e2da054527c66835adbe0519eb6af0966caa7e57", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -180,7 +180,7 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                id, ppaux::ty_to_str(tcx, n_ty), ppaux::ty_to_str(tcx, t));\n         write_ty_to_tcx(tcx, id, t);\n         let mut ret = Some(t);\n-        do fcx.opt_node_ty_substs(id) |substs| {\n+        fcx.opt_node_ty_substs(id, |substs| {\n           let mut new_tps = ~[];\n           for subst in substs.tps.iter() {\n               match resolve_type_vars_in_type(fcx, sp, *subst) {\n@@ -190,7 +190,7 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n           }\n           write_substs_to_tcx(tcx, id, new_tps);\n           ret.is_some()\n-        };\n+        });\n         ret\n       }\n     }"}, {"sha": "115058824c6ff8e3d32374c93507f33db0321393", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -102,7 +102,7 @@ pub fn type_is_defined_in_local_crate(original_type: t) -> bool {\n      */\n \n     let mut found_nominal = false;\n-    do ty::walk_ty(original_type) |t| {\n+    ty::walk_ty(original_type, |t| {\n         match get(t).sty {\n             ty_enum(def_id, _) |\n             ty_trait(def_id, _, _, _, _) |\n@@ -114,7 +114,7 @@ pub fn type_is_defined_in_local_crate(original_type: t) -> bool {\n \n             _ => { }\n         }\n-    }\n+    });\n     return found_nominal;\n }\n \n@@ -413,22 +413,22 @@ impl CoherenceChecker {\n     }\n \n     pub fn check_implementation_coherence(&self) {\n-        do self.crate_context.tcx.trait_impls.each_key |&trait_id| {\n+        self.crate_context.tcx.trait_impls.each_key(|&trait_id| {\n             self.check_implementation_coherence_of(trait_id);\n             true\n-        };\n+        });\n     }\n \n     pub fn check_implementation_coherence_of(&self, trait_def_id: DefId) {\n         // Unify pairs of polytypes.\n-        do self.iter_impls_of_trait(trait_def_id) |a| {\n+        self.iter_impls_of_trait(trait_def_id, |a| {\n             let implementation_a = a;\n             let polytype_a =\n                 self.get_self_type_for_implementation(implementation_a);\n \n             // \"We have an impl of trait <trait_def_id> for type <polytype_a>,\n             // and that impl is <implementation_a>\"\n-            do self.iter_impls_of_trait(trait_def_id) |b| {\n+            self.iter_impls_of_trait(trait_def_id, |b| {\n                 let implementation_b = b;\n \n                 // An impl is coherent with itself\n@@ -447,8 +447,8 @@ impl CoherenceChecker {\n                                           \"note conflicting implementation here\");\n                     }\n                 }\n-            }\n-        }\n+            })\n+        })\n     }\n \n     pub fn iter_impls_of_trait(&self, trait_def_id: DefId, f: |@Impl|) {\n@@ -665,12 +665,12 @@ impl CoherenceChecker {\n         let mut impls_seen = HashSet::new();\n \n         let crate_store = self.crate_context.tcx.sess.cstore;\n-        do iter_crate_data(crate_store) |crate_number, _crate_metadata| {\n-            do each_impl(crate_store, crate_number) |def_id| {\n+        iter_crate_data(crate_store, |crate_number, _crate_metadata| {\n+            each_impl(crate_store, crate_number, |def_id| {\n                 assert_eq!(crate_number, def_id.crate);\n                 self.add_external_impl(&mut impls_seen, def_id)\n-            }\n-        }\n+            })\n+        })\n     }\n \n     //"}, {"sha": "aa99c2b0f3751405406f95f41bd4bf8b20a19fe0", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -264,20 +264,20 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n \n         // Represents [A',B',C']\n         let num_trait_bounds = trait_ty_generics.type_param_defs.len();\n-        let non_shifted_trait_tps = do vec::from_fn(num_trait_bounds) |i| {\n+        let non_shifted_trait_tps = vec::from_fn(num_trait_bounds, |i| {\n             ty::mk_param(tcx, i, trait_ty_generics.type_param_defs[i].def_id)\n-        };\n+        });\n \n         // Represents [D']\n         let self_param = ty::mk_param(tcx, num_trait_bounds,\n                                       dummy_defid);\n \n         // Represents [E',F',G']\n         let num_method_bounds = m.generics.type_param_defs.len();\n-        let shifted_method_tps = do vec::from_fn(num_method_bounds) |i| {\n+        let shifted_method_tps = vec::from_fn(num_method_bounds, |i| {\n             ty::mk_param(tcx, i + num_trait_bounds + 1,\n                          m.generics.type_param_defs[i].def_id)\n-        };\n+        });\n \n         // Convert the regions 'a, 'b, 'c defined on the trait into\n         // bound regions on the fn."}, {"sha": "e825aca2eec65e60ee77c19e7bb5d95a91800fe0", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -98,45 +98,45 @@ impl Coerce {\n         // See above for details.\n         match ty::get(b).sty {\n             ty::ty_rptr(_, mt_b) => {\n-                return do self.unpack_actual_value(a) |sty_a| {\n+                return self.unpack_actual_value(a, |sty_a| {\n                     self.coerce_borrowed_pointer(a, sty_a, b, mt_b)\n-                };\n+                });\n             }\n \n             ty::ty_estr(vstore_slice(_)) => {\n-                return do self.unpack_actual_value(a) |sty_a| {\n+                return self.unpack_actual_value(a, |sty_a| {\n                     self.coerce_borrowed_string(a, sty_a, b)\n-                };\n+                });\n             }\n \n             ty::ty_evec(mt_b, vstore_slice(_)) => {\n-                return do self.unpack_actual_value(a) |sty_a| {\n+                return self.unpack_actual_value(a, |sty_a| {\n                     self.coerce_borrowed_vector(a, sty_a, b, mt_b)\n-                };\n+                });\n             }\n \n             ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil, _}) => {\n-                return do self.unpack_actual_value(a) |sty_a| {\n+                return self.unpack_actual_value(a, |sty_a| {\n                     self.coerce_borrowed_fn(a, sty_a, b)\n-                };\n+                });\n             }\n \n             ty::ty_trait(_, _, ty::RegionTraitStore(*), m, _) => {\n-                return do self.unpack_actual_value(a) |sty_a| {\n+                return self.unpack_actual_value(a, |sty_a| {\n                     self.coerce_borrowed_object(a, sty_a, b, m)\n-                };\n+                });\n             }\n \n             ty::ty_ptr(mt_b) => {\n-                return do self.unpack_actual_value(a) |sty_a| {\n+                return self.unpack_actual_value(a, |sty_a| {\n                     self.coerce_unsafe_ptr(a, sty_a, b, mt_b)\n-                };\n+                });\n             }\n \n             _ => {}\n         }\n \n-        do self.unpack_actual_value(a) |sty_a| {\n+        self.unpack_actual_value(a, |sty_a| {\n             match *sty_a {\n                 ty::ty_bare_fn(ref a_f) => {\n                     // Bare functions are coercable to any closure type.\n@@ -151,7 +151,7 @@ impl Coerce {\n                     self.subtype(a, b)\n                 }\n             }\n-        }\n+        })\n     }\n \n     pub fn subtype(&self, a: ty::t, b: ty::t) -> CoerceResult {\n@@ -342,9 +342,9 @@ impl Coerce {\n                                fn_ty_a: &ty::BareFnTy,\n                                b: ty::t)\n                                -> CoerceResult {\n-        do self.unpack_actual_value(b) |sty_b| {\n+        self.unpack_actual_value(b, |sty_b| {\n             self.coerce_from_bare_fn_post_unpack(a, fn_ty_a, b, sty_b)\n-        }\n+        })\n     }\n \n     pub fn coerce_from_bare_fn_post_unpack(&self,"}, {"sha": "cdbd70ce3a7296f657b2d16a90a119840f75a3a9", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 34, "deletions": 52, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -232,9 +232,7 @@ pub trait Combine {\n     }\n \n     fn args(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n-        do self.contratys(a, b).and_then |t| {\n-            Ok(t)\n-        }\n+        self.contratys(a, b).and_then(|t| Ok(t))\n     }\n \n     fn sigils(&self, p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil> {\n@@ -270,9 +268,9 @@ pub trait Combine {\n \n         match (a, b) {\n             (ty::vstore_slice(a_r), ty::vstore_slice(b_r)) => {\n-                do self.contraregions(a_r, b_r).and_then |r| {\n+                self.contraregions(a_r, b_r).and_then(|r| {\n                     Ok(ty::vstore_slice(r))\n-                }\n+                })\n             }\n \n             _ if a == b => {\n@@ -294,9 +292,9 @@ pub trait Combine {\n \n         match (a, b) {\n             (ty::RegionTraitStore(a_r), ty::RegionTraitStore(b_r)) => {\n-                do self.contraregions(a_r, b_r).and_then |r| {\n+                self.contraregions(a_r, b_r).and_then(|r| {\n                     Ok(ty::RegionTraitStore(r))\n-                }\n+                })\n             }\n \n             _ if a == b => {\n@@ -346,11 +344,9 @@ pub fn expected_found<C:Combine,T>(\n \n pub fn eq_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> ures {\n     let suber = this.sub();\n-    do this.infcx().try {\n-        do suber.tys(a, b).and_then |_ok| {\n-            suber.contratys(a, b)\n-        }.to_ures()\n-    }\n+    this.infcx().try(|| {\n+        suber.tys(a, b).and_then(|_ok| suber.contratys(a, b)).to_ures()\n+    })\n }\n \n pub fn eq_regions<C:Combine>(this: &C, a: ty::Region, b: ty::Region)\n@@ -359,11 +355,9 @@ pub fn eq_regions<C:Combine>(this: &C, a: ty::Region, b: ty::Region)\n             a.repr(this.infcx().tcx),\n             b.repr(this.infcx().tcx));\n     let sub = this.sub();\n-    do indent {\n+    indent(|| {\n         this.infcx().try(|| {\n-            do sub.regions(a, b).and_then |_r| {\n-                sub.contraregions(a, b)\n-            }\n+            sub.regions(a, b).and_then(|_r| sub.contraregions(a, b))\n         }).or_else(|e| {\n             // substitute a better error, but use the regions\n             // found in the original error\n@@ -373,7 +367,7 @@ pub fn eq_regions<C:Combine>(this: &C, a: ty::Region, b: ty::Region)\n               _ => Err(e)\n             }\n         }).to_ures()\n-    }\n+    })\n }\n \n pub fn eq_opt_regions<C:Combine>(\n@@ -382,25 +376,19 @@ pub fn eq_opt_regions<C:Combine>(\n     b: Option<ty::Region>) -> cres<Option<ty::Region>> {\n \n     match (a, b) {\n-      (None, None) => {\n-        Ok(None)\n-      }\n-      (Some(a), Some(b)) => {\n-        do eq_regions(this, a, b).then {\n-            Ok(Some(a))\n+        (None, None) => Ok(None),\n+        (Some(a), Some(b)) => eq_regions(this, a, b).then(|| Ok(Some(a))),\n+        (_, _) => {\n+            // If these two substitutions are for the same type (and\n+            // they should be), then the type should either\n+            // consistently have a region parameter or not have a\n+            // region parameter.\n+            this.infcx().tcx.sess.bug(\n+                format!(\"substitution a had opt_region {} and \\\n+                      b had opt_region {}\",\n+                     a.inf_str(this.infcx()),\n+                     b.inf_str(this.infcx())));\n         }\n-      }\n-      (_, _) => {\n-        // If these two substitutions are for the same type (and\n-        // they should be), then the type should either\n-        // consistently have a region parameter or not have a\n-        // region parameter.\n-        this.infcx().tcx.sess.bug(\n-            format!(\"substitution a had opt_region {} and \\\n-                  b had opt_region {}\",\n-                 a.inf_str(this.infcx()),\n-                 b.inf_str(this.infcx())));\n-      }\n     }\n }\n \n@@ -528,21 +516,15 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n       }\n \n       (&ty::ty_box(ref a_mt), &ty::ty_box(ref b_mt)) => {\n-        do this.mts(a_mt, b_mt).and_then |mt| {\n-            Ok(ty::mk_box(tcx, mt))\n-        }\n+        this.mts(a_mt, b_mt).and_then(|mt| Ok(ty::mk_box(tcx, mt)))\n       }\n \n       (&ty::ty_uniq(ref a_mt), &ty::ty_uniq(ref b_mt)) => {\n-        do this.mts(a_mt, b_mt).and_then |mt| {\n-            Ok(ty::mk_uniq(tcx, mt))\n-        }\n+        this.mts(a_mt, b_mt).and_then(|mt| Ok(ty::mk_uniq(tcx, mt)))\n       }\n \n       (&ty::ty_ptr(ref a_mt), &ty::ty_ptr(ref b_mt)) => {\n-        do this.mts(a_mt, b_mt).and_then |mt| {\n-            Ok(ty::mk_ptr(tcx, mt))\n-        }\n+        this.mts(a_mt, b_mt).and_then(|mt| Ok(ty::mk_ptr(tcx, mt)))\n       }\n \n       (&ty::ty_rptr(a_r, ref a_mt), &ty::ty_rptr(b_r, ref b_mt)) => {\n@@ -552,11 +534,11 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n       }\n \n       (&ty::ty_evec(ref a_mt, vs_a), &ty::ty_evec(ref b_mt, vs_b)) => {\n-        do this.mts(a_mt, b_mt).and_then |mt| {\n-            do this.vstores(ty::terr_vec, vs_a, vs_b).and_then |vs| {\n+        this.mts(a_mt, b_mt).and_then(|mt| {\n+            this.vstores(ty::terr_vec, vs_a, vs_b).and_then(|vs| {\n                 Ok(ty::mk_evec(tcx, mt, vs))\n-            }\n-        }\n+            })\n+        })\n       }\n \n       (&ty::ty_estr(vs_a), &ty::ty_estr(vs_b)) => {\n@@ -576,15 +558,15 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n       }\n \n       (&ty::ty_bare_fn(ref a_fty), &ty::ty_bare_fn(ref b_fty)) => {\n-        do this.bare_fn_tys(a_fty, b_fty).and_then |fty| {\n+        this.bare_fn_tys(a_fty, b_fty).and_then(|fty| {\n             Ok(ty::mk_bare_fn(tcx, fty))\n-        }\n+        })\n       }\n \n       (&ty::ty_closure(ref a_fty), &ty::ty_closure(ref b_fty)) => {\n-        do this.closure_tys(a_fty, b_fty).and_then |fty| {\n+        this.closure_tys(a_fty, b_fty).and_then(|fty| {\n             Ok(ty::mk_closure(tcx, fty))\n-        }\n+        })\n       }\n \n       _ => Err(ty::terr_sorts(expected_found(this, a, b)))"}, {"sha": "8f344095aea8c1b593085be794db7005649df2de", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -52,7 +52,7 @@ pub trait LatticeValue {\n }\n \n pub type LatticeOp<'self, T> =\n-    &'self fn(cf: &CombineFields, a: &T, b: &T) -> cres<T>;\n+    'self |cf: &CombineFields, a: &T, b: &T| -> cres<T>;\n \n impl LatticeValue for ty::t {\n     fn sub(cf: &CombineFields, a: &ty::t, b: &ty::t) -> ures {\n@@ -230,9 +230,7 @@ impl CombineFieldsLatticeMethods for CombineFields {\n             (&Some(_),       &None) => Ok((*a).clone()),\n             (&None,          &Some(_)) => Ok((*b).clone()),\n             (&Some(ref v_a), &Some(ref v_b)) => {\n-                do lattice_op(self, v_a, v_b).and_then |v| {\n-                    Ok(Some(v))\n-                }\n+                lattice_op(self, v_a, v_b).and_then(|v| Ok(Some(v)))\n             }\n         }\n     }\n@@ -407,7 +405,7 @@ pub fn super_lattice_tys<L:LatticeDir+TyLatticeDir+Combine>(this: &L,\n     }\n }\n \n-pub type LatticeDirOp<'self, T> = &'self fn(a: &T, b: &T) -> cres<T>;\n+pub type LatticeDirOp<'self, T> = 'self |a: &T, b: &T| -> cres<T>;\n \n #[deriving(Clone)]\n pub enum LatticeVarResult<V,T> {\n@@ -471,9 +469,9 @@ pub fn lattice_vars<L:LatticeDir + Combine,\n     // Otherwise, we need to merge A and B into one variable.  We can\n     // then use either variable as an upper bound:\n     let cf = this.combine_fields();\n-    do cf.var_sub_var(a_vid.clone(), b_vid.clone()).then {\n+    cf.var_sub_var(a_vid.clone(), b_vid.clone()).then(|| {\n         Ok(VarResult(a_vid.clone()))\n-    }\n+    })\n }\n \n pub fn lattice_var_and_t<L:LatticeDir + Combine,\n@@ -508,11 +506,11 @@ pub fn lattice_var_and_t<L:LatticeDir + Combine,\n             // and then return b.\n             debug!(\"bnd=None\");\n             let a_bounds = this.with_bnd(a_bounds, (*b).clone());\n-            do this.combine_fields().bnds(&a_bounds.lb, &a_bounds.ub).then {\n+            this.combine_fields().bnds(&a_bounds.lb, &a_bounds.ub).then(|| {\n                 this.infcx().set(a_id.clone(),\n                                  Root(a_bounds.clone(), nde_a.rank));\n                 Ok((*b).clone())\n-            }\n+            })\n         }\n     }\n }"}, {"sha": "edac978041b677e75e446375245f7af130131dce", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 35, "deletions": 38, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -290,10 +290,7 @@ pub fn common_supertype(cx: @mut InferCtxt,\n         values: Types(expected_found(a_is_expected, a, b))\n     };\n \n-    let result = do cx.commit {\n-        cx.lub(a_is_expected, trace).tys(a, b)\n-    };\n-\n+    let result = cx.commit(|| cx.lub(a_is_expected, trace).tys(a, b));\n     match result {\n         Ok(t) => t,\n         Err(ref err) => {\n@@ -310,28 +307,28 @@ pub fn mk_subty(cx: @mut InferCtxt,\n                 b: ty::t)\n              -> ures {\n     debug!(\"mk_subty({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n-    do indent {\n-        do cx.commit {\n+    indent(|| {\n+        cx.commit(|| {\n             let trace = TypeTrace {\n                 origin: origin,\n                 values: Types(expected_found(a_is_expected, a, b))\n             };\n             cx.sub(a_is_expected, trace).tys(a, b)\n-        }\n-    }.to_ures()\n+        })\n+    }).to_ures()\n }\n \n pub fn can_mk_subty(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n     debug!(\"can_mk_subty({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n-    do indent {\n-        do cx.probe {\n+    indent(|| {\n+        cx.probe(|| {\n             let trace = TypeTrace {\n                 origin: Misc(codemap::dummy_sp()),\n                 values: Types(expected_found(true, a, b))\n             };\n             cx.sub(true, trace).tys(a, b)\n-        }\n-    }.to_ures()\n+        })\n+    }).to_ures()\n }\n \n pub fn mk_subr(cx: @mut InferCtxt,\n@@ -352,16 +349,16 @@ pub fn mk_eqty(cx: @mut InferCtxt,\n                b: ty::t)\n             -> ures {\n     debug!(\"mk_eqty({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n-    do indent {\n-        do cx.commit {\n+    indent(|| {\n+        cx.commit(|| {\n             let trace = TypeTrace {\n                 origin: origin,\n                 values: Types(expected_found(a_is_expected, a, b))\n             };\n             let suber = cx.sub(a_is_expected, trace);\n             eq_tys(&suber, a, b)\n-        }\n-    }.to_ures()\n+        })\n+    }).to_ures()\n }\n \n pub fn mk_sub_trait_refs(cx: @mut InferCtxt,\n@@ -373,16 +370,16 @@ pub fn mk_sub_trait_refs(cx: @mut InferCtxt,\n {\n     debug!(\"mk_sub_trait_refs({} <: {})\",\n            a.inf_str(cx), b.inf_str(cx));\n-    do indent {\n-        do cx.commit {\n+    indent(|| {\n+        cx.commit(|| {\n             let trace = TypeTrace {\n                 origin: origin,\n                 values: TraitRefs(expected_found(a_is_expected, a, b))\n             };\n             let suber = cx.sub(a_is_expected, trace);\n             suber.trait_refs(a, b)\n-        }\n-    }.to_ures()\n+        })\n+    }).to_ures()\n }\n \n fn expected_found<T>(a_is_expected: bool,\n@@ -402,28 +399,28 @@ pub fn mk_coercety(cx: @mut InferCtxt,\n                    b: ty::t)\n                 -> CoerceResult {\n     debug!(\"mk_coercety({} -> {})\", a.inf_str(cx), b.inf_str(cx));\n-    do indent {\n-        do cx.commit {\n+    indent(|| {\n+        cx.commit(|| {\n             let trace = TypeTrace {\n                 origin: origin,\n                 values: Types(expected_found(a_is_expected, a, b))\n             };\n             Coerce(cx.combine_fields(a_is_expected, trace)).tys(a, b)\n-        }\n-    }\n+        })\n+    })\n }\n \n pub fn can_mk_coercety(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n     debug!(\"can_mk_coercety({} -> {})\", a.inf_str(cx), b.inf_str(cx));\n-    do indent {\n-        do cx.probe {\n+    indent(|| {\n+        cx.probe(|| {\n             let trace = TypeTrace {\n                 origin: Misc(codemap::dummy_sp()),\n                 values: Types(expected_found(true, a, b))\n             };\n             Coerce(cx.combine_fields(true, trace)).tys(a, b)\n-        }\n-    }.to_ures()\n+        })\n+    }).to_ures()\n }\n \n // See comment on the type `resolve_state` below\n@@ -472,13 +469,13 @@ trait CresCompare<T> {\n \n impl<T:Clone + Eq> CresCompare<T> for cres<T> {\n     fn compare(&self, t: T, f: || -> ty::type_err) -> cres<T> {\n-        do (*self).clone().and_then |s| {\n+        (*self).clone().and_then(|s| {\n             if s == t {\n                 (*self).clone()\n             } else {\n                 Err(f())\n             }\n-        }\n+        })\n     }\n }\n \n@@ -553,14 +550,14 @@ impl InferCtxt {\n         assert!(!self.in_snapshot());\n \n         debug!(\"commit()\");\n-        do indent {\n+        indent(|| {\n             let r = self.try(|| f());\n \n             self.ty_var_bindings.bindings.truncate(0);\n             self.int_var_bindings.bindings.truncate(0);\n             self.region_vars.commit();\n             r\n-        }\n+        })\n     }\n \n     /// Execute `f`, unroll bindings on failure\n@@ -581,12 +578,12 @@ impl InferCtxt {\n     /// Execute `f` then unroll any bindings it creates\n     pub fn probe<T,E>(@mut self, f: || -> Result<T,E>) -> Result<T,E> {\n         debug!(\"probe()\");\n-        do indent {\n+        indent(|| {\n             let snapshot = self.start_snapshot();\n             let r = f();\n             self.rollback_to(&snapshot);\n             r\n-        }\n+        })\n     }\n }\n \n@@ -737,12 +734,12 @@ impl InferCtxt {\n                                                 err: Option<&ty::type_err>) {\n         debug!(\"hi! expected_ty = {:?}, actual_ty = {}\", expected_ty, actual_ty);\n \n-        let error_str = do err.map_default(~\"\") |t_err| {\n+        let error_str = err.map_default(~\"\", |t_err| {\n             format!(\" ({})\", ty::type_err_to_str(self.tcx, t_err))\n-        };\n-        let resolved_expected = do expected_ty.map |e_ty| {\n+        });\n+        let resolved_expected = expected_ty.map(|e_ty| {\n             self.resolve_type_vars_if_possible(e_ty)\n-        };\n+        });\n         if !resolved_expected.map_default(false, |e| { ty::type_is_error(e) }) {\n             match resolved_expected {\n                 None => self.tcx.sess.span_err(sp,"}, {"sha": "f639139d265e4c835791c6e4059885f85974e3bb", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -764,7 +764,7 @@ impl RegionVarBindings {\n     }\n \n     fn expansion(&self, var_data: &mut [VarData]) {\n-        do self.iterate_until_fixed_point(\"Expansion\") |constraint| {\n+        self.iterate_until_fixed_point(\"Expansion\", |constraint| {\n             match *constraint {\n               ConstrainRegSubVar(a_region, b_vid) => {\n                 let b_data = &mut var_data[b_vid.to_uint()];\n@@ -788,7 +788,7 @@ impl RegionVarBindings {\n                 false\n               }\n             }\n-        }\n+        })\n     }\n \n     fn expand_node(&self,\n@@ -829,7 +829,7 @@ impl RegionVarBindings {\n \n     fn contraction(&self,\n                    var_data: &mut [VarData]) {\n-        do self.iterate_until_fixed_point(\"Contraction\") |constraint| {\n+        self.iterate_until_fixed_point(\"Contraction\", |constraint| {\n             match *constraint {\n               ConstrainRegSubVar(*) => {\n                 // This is an expansion constraint.  Ignore.\n@@ -853,7 +853,7 @@ impl RegionVarBindings {\n                 false\n               }\n             }\n-        }\n+        })\n     }\n \n     fn contract_node(&self,\n@@ -1225,7 +1225,7 @@ impl RegionVarBindings {\n             debug!(\"process_edges(source_vid={:?}, dir={:?})\", source_vid, dir);\n \n             let source_node_index = NodeIndex(source_vid.to_uint());\n-            do graph.each_adjacent_edge(source_node_index, dir) |_, edge| {\n+            graph.each_adjacent_edge(source_node_index, dir, |_, edge| {\n                 match edge.data {\n                     ConstrainVarSubVar(from_vid, to_vid) => {\n                         let opp_vid =\n@@ -1246,7 +1246,7 @@ impl RegionVarBindings {\n                     ConstrainRegSubReg(*) => {}\n                 }\n                 true\n-            };\n+            });\n         }\n     }\n "}, {"sha": "210d7fd7c80b144a28dac97d6c5df2b585d3e913", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -167,13 +167,13 @@ impl Combine for Sub {\n         // Second, we instantiate each bound region in the supertype with a\n         // fresh concrete region.\n         let (skol_map, _, b_sig) = {\n-            do replace_bound_regions_in_fn_sig(self.infcx.tcx, None, b) |br| {\n+            replace_bound_regions_in_fn_sig(self.infcx.tcx, None, b, |br| {\n                 let skol = self.infcx.region_vars.new_skolemized(br);\n                 debug!(\"Bound region {} skolemized to {:?}\",\n                        bound_region_to_str(self.infcx.tcx, \"\", false, br),\n                        skol);\n                 skol\n-            }\n+            })\n         };\n \n         debug!(\"a_sig={}\", a_sig.inf_str(self.infcx));"}, {"sha": "6afbcf053b8cdc122fa5db2829037e5a40f8970b", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -330,10 +330,10 @@ impl get_and_find_region for isr_alist {\n \n     fn find(&self, br: ty::BoundRegion) -> Option<ty::Region> {\n         let mut ret = None;\n-        do list::each(*self) |isr| {\n+        list::each(*self, |isr| {\n             let (isr_br, isr_r) = *isr;\n             if isr_br == br { ret = Some(isr_r); false } else { true }\n-        };\n+        });\n         ret\n     }\n }"}, {"sha": "28fe067293b8998fee22e81b26bea40473c9bc02", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -61,7 +61,7 @@ pub fn field_exprs(fields: ~[ast::Field]) -> ~[@ast::Expr] {\n }\n \n struct LoopQueryVisitor<'self> {\n-    p: &'self fn(&ast::Expr_) -> bool,\n+    p: 'self |&ast::Expr_| -> bool,\n     flag: bool,\n }\n \n@@ -89,7 +89,7 @@ pub fn loop_query(b: &ast::Block, p: |&ast::Expr_| -> bool) -> bool {\n }\n \n struct BlockQueryVisitor<'self> {\n-    p: &'self fn(@ast::Expr) -> bool,\n+    p: 'self |@ast::Expr| -> bool,\n     flag: bool,\n }\n "}, {"sha": "11c2aca6c343fc7d8503c3a71c144c31a39089f5", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -79,9 +79,9 @@ impl Clean<Crate> for visit_ast::RustdocVisitor {\n         let cx = local_data::get(super::ctxtkey, |x| *x.unwrap());\n \n         let mut externs = HashMap::new();\n-        do cstore::iter_crate_data(cx.sess.cstore) |n, meta| {\n+        cstore::iter_crate_data(cx.sess.cstore, |n, meta| {\n             externs.insert(n, meta.clean());\n-        }\n+        });\n \n         Crate {\n             name: match maybe_meta {"}, {"sha": "0f490fd960e37842aba4cd14532a7af39efb541c", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -148,8 +148,8 @@ fn external_path(w: &mut io::Writer, p: &clean::Path, print_all: bool,\n }\n \n fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n-        root: &fn(&render::Cache, &[~str]) -> Option<~str>,\n-        info: &fn(&render::Cache) -> Option<(~[~str], &'static str)>) {\n+        root: |&render::Cache, &[~str]| -> Option<~str>,\n+        info: |&render::Cache| -> Option<(~[~str], &'static str)>) {\n     // The generics will get written to both the title and link\n     let mut generics = ~\"\";\n     let last = path.segments.last();\n@@ -170,11 +170,11 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n     }\n \n     // Did someone say rightward-drift?\n-    do local_data::get(current_location_key) |loc| {\n+    local_data::get(current_location_key, |loc| {\n         let loc = loc.unwrap();\n \n-        do local_data::get(cache_key) |cache| {\n-            do cache.unwrap().read |cache| {\n+        local_data::get(cache_key, |cache| {\n+            cache.unwrap().read(|cache| {\n                 let abs_root = root(cache, loc.as_slice());\n                 let rel_root = match path.segments[0].name.as_slice() {\n                     \"self\" => Some(~\"./\"),\n@@ -238,9 +238,9 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n                     }\n                 }\n                 write!(w, \"{}\", generics);\n-            }\n-        }\n-    }\n+            })\n+        })\n+    })\n }\n \n /// Helper to render type parameters\n@@ -262,11 +262,11 @@ impl fmt::Default for clean::Type {\n     fn fmt(g: &clean::Type, f: &mut fmt::Formatter) {\n         match *g {\n             clean::TyParamBinder(id) | clean::Generic(id) => {\n-                do local_data::get(cache_key) |cache| {\n-                    do cache.unwrap().read |m| {\n+                local_data::get(cache_key, |cache| {\n+                    cache.unwrap().read(|m| {\n                         f.buf.write(m.typarams.get(&id).as_bytes());\n-                    }\n-                }\n+                    })\n+                })\n             }\n             clean::ResolvedPath{id, typarams: ref tp, path: ref path} => {\n                 resolved_path(f.buf, id, path, false);"}, {"sha": "ac7c50fdfd809673571474ea653919dbcec324a2", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -109,14 +109,14 @@ fn render(w: &mut io::Writer, s: &str) {\n         let markdown = sd_markdown_new(extensions, 16, &callbacks,\n                                        &options as *html_renderopt as *libc::c_void);\n \n-        do s.as_imm_buf |data, len| {\n+        s.as_imm_buf(|data, len| {\n             sd_markdown_render(ob, data, len as libc::size_t, markdown);\n-        }\n+        });\n         sd_markdown_free(markdown);\n \n-        do vec::raw::buf_as_slice((*ob).data, (*ob).size as uint) |buf| {\n+        vec::raw::buf_as_slice((*ob).data, (*ob).size as uint, |buf| {\n             w.write(buf);\n-        }\n+        });\n \n         bufrelease(ob);\n     }"}, {"sha": "819316313b6778b3d82f510ff183f77652e4cccf", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 38, "deletions": 40, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -320,22 +320,22 @@ fn write(dst: Path, contents: &str) {\n /// Makes a directory on the filesystem, failing the task if an error occurs and\n /// skipping if the directory already exists.\n fn mkdir(path: &Path) {\n-    do io::io_error::cond.trap(|err| {\n+    io::io_error::cond.trap(|err| {\n         error!(\"Couldn't create directory `{}`: {}\",\n                 path.display(), err.desc);\n         fail!()\n-    }).inside {\n+    }).inside(|| {\n         if !path.is_dir() {\n             fs::mkdir(path, io::UserRWX);\n         }\n-    }\n+    })\n }\n \n /// Takes a path to a source file and cleans the path to it. This canonicalizes\n /// things like \"..\" to components which preserve the \"top down\" hierarchy of a\n /// static HTML tree.\n // FIXME (#9639): The closure should deal with &[u8] instead of &str\n-fn clean_srcpath(src: &[u8], f: &fn(&str)) {\n+fn clean_srcpath(src: &[u8], f: |&str|) {\n     let p = Path::new(src);\n     if p.as_vec() != bytes!(\".\") {\n         for c in p.str_components().map(|x|x.unwrap()) {\n@@ -439,11 +439,11 @@ impl<'self> SourceCollector<'self> {\n         // Create the intermediate directories\n         let mut cur = self.dst.clone();\n         let mut root_path = ~\"../../\";\n-        do clean_srcpath(p.dirname()) |component| {\n+        clean_srcpath(p.dirname(), |component| {\n             cur.push(component);\n             mkdir(&cur);\n             root_path.push_str(\"../\");\n-        }\n+        });\n \n         cur.push(p.filename().expect(\"source has no filename\") + bytes!(\".html\"));\n         let mut w = BufferedWriter::new(File::create(&cur).unwrap());\n@@ -492,9 +492,9 @@ impl DocFolder for Cache {\n             clean::ImplItem(ref i) => {\n                 match i.trait_ {\n                     Some(clean::ResolvedPath{ id, _ }) => {\n-                        let v = do self.implementors.find_or_insert_with(id) |_|{\n+                        let v = self.implementors.find_or_insert_with(id, |_|{\n                             ~[]\n-                        };\n+                        });\n                         match i.for_ {\n                             clean::ResolvedPath{_} => {\n                                 v.unshift(PathType(i.for_.clone()));\n@@ -595,9 +595,9 @@ impl DocFolder for Cache {\n                     clean::Item{ attrs, inner: clean::ImplItem(i), _ } => {\n                         match i.for_ {\n                             clean::ResolvedPath { id, _ } => {\n-                                let v = do self.impls.find_or_insert_with(id) |_| {\n+                                let v = self.impls.find_or_insert_with(id, |_| {\n                                     ~[]\n-                                };\n+                                });\n                                 // extract relevant documentation for this impl\n                                 match attrs.move_iter().find(|a| {\n                                     match *a {\n@@ -645,7 +645,7 @@ impl<'self> Cache {\n impl Context {\n     /// Recurse in the directory structure and change the \"root path\" to make\n     /// sure it always points to the top (relatively)\n-    fn recurse<T>(&mut self, s: ~str, f: &fn(&mut Context) -> T) -> T {\n+    fn recurse<T>(&mut self, s: ~str, f: |&mut Context| -> T) -> T {\n         if s.len() == 0 {\n             fail!(\"what {:?}\", self);\n         }\n@@ -726,16 +726,16 @@ impl Context {\n                         Process(cx, item) => {\n                             let mut cx = cx;\n                             let item = Cell::new(item);\n-                            do (|| {\n-                                do cx.item(item.take()) |cx, item| {\n+                            (|| {\n+                                cx.item(item.take(), |cx, item| {\n                                     prog_chan.send(JobNew);\n                                     chan.send(Process(cx.clone(), item));\n-                                }\n-                            }).finally {\n+                                })\n+                            }).finally(|| {\n                                 // If we fail, everything else should still get\n                                 // completed\n                                 prog_chan.send(JobDone);\n-                            }\n+                            })\n                         }\n                         Die => break,\n                     }\n@@ -768,7 +768,7 @@ impl Context {\n     /// all sub-items which need to be rendered.\n     ///\n     /// The rendering driver uses this closure to queue up more work.\n-    fn item(&mut self, item: clean::Item, f: &fn(&mut Context, clean::Item)) {\n+    fn item(&mut self, item: clean::Item, f: |&mut Context, clean::Item|) {\n         fn render(w: io::File, cx: &mut Context, it: &clean::Item,\n                   pushname: bool) {\n             // A little unfortunate that this is done like this, but it sure\n@@ -803,7 +803,7 @@ impl Context {\n             clean::ModuleItem(*) => {\n                 let name = item.name.get_ref().to_owned();\n                 let item = Cell::new(item);\n-                do self.recurse(name) |this| {\n+                self.recurse(name, |this| {\n                     let item = item.take();\n                     let dst = this.dst.join(\"index.html\");\n                     render(File::create(&dst).unwrap(), this, &item, false);\n@@ -816,7 +816,7 @@ impl Context {\n                     for item in m.items.move_iter() {\n                         f(this, item);\n                     }\n-                }\n+                })\n             }\n \n             // Things which don't have names (like impls) don't get special\n@@ -875,9 +875,9 @@ impl<'self> fmt::Default for Item<'self> {\n \n         if it.cx.include_sources {\n             let mut path = ~[];\n-            do clean_srcpath(it.item.source.filename.as_bytes()) |component| {\n+            clean_srcpath(it.item.source.filename.as_bytes(), |component| {\n                 path.push(component.to_owned());\n-            }\n+            });\n             let href = if it.item.source.loline == it.item.source.hiline {\n                 format!(\"{}\", it.item.source.loline)\n             } else {\n@@ -1012,9 +1012,7 @@ fn item_module(w: &mut Writer, cx: &Context,\n     }\n \n     debug!(\"{:?}\", indices);\n-    do sort::quick_sort(indices) |&i1, &i2| {\n-        lt(&items[i1], &items[i2], i1, i2)\n-    }\n+    sort::quick_sort(indices, |&i1, &i2| lt(&items[i1], &items[i2], i1, i2));\n \n     debug!(\"{:?}\", indices);\n     let mut curty = \"\";\n@@ -1200,8 +1198,8 @@ fn item_trait(w: &mut Writer, it: &clean::Item, t: &clean::Trait) {\n         write!(w, \"</div>\");\n     }\n \n-    do local_data::get(cache_key) |cache| {\n-        do cache.unwrap().read |cache| {\n+    local_data::get(cache_key, |cache| {\n+        cache.unwrap().read(|cache| {\n             match cache.implementors.find(&it.id) {\n                 Some(implementors) => {\n                     write!(w, \"\n@@ -1223,8 +1221,8 @@ fn item_trait(w: &mut Writer, it: &clean::Item, t: &clean::Trait) {\n                 }\n                 None => {}\n             }\n-        }\n-    }\n+        })\n+    })\n }\n \n fn render_method(w: &mut Writer, meth: &clean::Item, withlink: bool) {\n@@ -1412,9 +1410,9 @@ fn render_struct(w: &mut Writer, it: &clean::Item,\n }\n \n fn render_methods(w: &mut Writer, it: &clean::Item) {\n-    do local_data::get(cache_key) |cache| {\n+    local_data::get(cache_key, |cache| {\n         let cache = cache.unwrap();\n-        do cache.read |c| {\n+        cache.read(|c| {\n             match c.impls.find(&it.id) {\n                 Some(v) => {\n                     let mut non_trait = v.iter().filter(|p| {\n@@ -1442,8 +1440,8 @@ fn render_methods(w: &mut Writer, it: &clean::Item) {\n                 }\n                 None => {}\n             }\n-        }\n-    }\n+        })\n+    })\n }\n \n fn render_impl(w: &mut Writer, i: &clean::Impl, dox: &Option<~str>) {\n@@ -1492,8 +1490,8 @@ fn render_impl(w: &mut Writer, i: &clean::Impl, dox: &Option<~str>) {\n             None => continue,\n             Some(id) => id,\n         };\n-        do local_data::get(cache_key) |cache| {\n-            do cache.unwrap().read |cache| {\n+        local_data::get(cache_key, |cache| {\n+            cache.unwrap().read(|cache| {\n                 match cache.traits.find(&trait_id) {\n                     Some(t) => {\n                         let name = meth.name.clone();\n@@ -1513,17 +1511,17 @@ fn render_impl(w: &mut Writer, i: &clean::Impl, dox: &Option<~str>) {\n                     }\n                     None => {}\n                 }\n-            }\n-        }\n+            })\n+        })\n     }\n \n     // If we've implemented a trait, then also emit documentation for all\n     // default methods which weren't overridden in the implementation block.\n     match trait_id {\n         None => {}\n         Some(id) => {\n-            do local_data::get(cache_key) |cache| {\n-                do cache.unwrap().read |cache| {\n+            local_data::get(cache_key, |cache| {\n+                cache.unwrap().read(|cache| {\n                     match cache.traits.find(&id) {\n                         Some(t) => {\n                             for method in t.methods.iter() {\n@@ -1538,8 +1536,8 @@ fn render_impl(w: &mut Writer, i: &clean::Impl, dox: &Option<~str>) {\n                         }\n                         None => {}\n                     }\n-                }\n-            }\n+                })\n+            })\n         }\n     }\n     write!(w, \"</div>\");"}, {"sha": "f7705f93a79eeb598bc9f6ba9574f403af46e66c", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -57,9 +57,9 @@ pub fn strip_private(crate: clean::Crate) -> plugins::PluginResult {\n     // This stripper collects all *retained* nodes.\n     let mut retained = HashSet::new();\n     let crate = Cell::new(crate);\n-    let exported_items = do local_data::get(super::analysiskey) |analysis| {\n+    let exported_items = local_data::get(super::analysiskey, |analysis| {\n         analysis.unwrap().exported_items.clone()\n-    };\n+    });\n     let mut crate = crate.take();\n \n     // strip all private items\n@@ -231,7 +231,7 @@ pub fn unindent(s: &str) -> ~str {\n     let lines = s.lines_any().collect::<~[&str]>();\n     let mut saw_first_line = false;\n     let mut saw_second_line = false;\n-    let min_indent = do lines.iter().fold(uint::max_value) |min_indent, line| {\n+    let min_indent = lines.iter().fold(uint::max_value, |min_indent, line| {\n \n         // After we see the first non-whitespace line, look at\n         // the line we have. If it is not whitespace, and therefore\n@@ -257,7 +257,7 @@ pub fn unindent(s: &str) -> ~str {\n         } else {\n             saw_first_line = true;\n             let mut spaces = 0;\n-            do line.chars().all |char| {\n+            line.chars().all(|char| {\n                 // Only comparing against space because I wouldn't\n                 // know what to do with mixed whitespace chars\n                 if char == ' ' {\n@@ -266,22 +266,22 @@ pub fn unindent(s: &str) -> ~str {\n                 } else {\n                     false\n                 }\n-            };\n+            });\n             num::min(min_indent, spaces)\n         }\n-    };\n+    });\n \n     match lines {\n         [head, .. tail] => {\n             let mut unindented = ~[ head.trim() ];\n-            unindented.push_all(do tail.map |&line| {\n+            unindented.push_all(tail.map(|&line| {\n                 if line.is_whitespace() {\n                     line\n                 } else {\n                     assert!(line.len() >= min_indent);\n                     line.slice_from(min_indent)\n                 }\n-            });\n+            }));\n             unindented.connect(\"\\n\")\n         }\n         [] => s.to_owned()"}, {"sha": "b1e3d1bd879ec02661d1d21050409274b0d5c362", "filename": "src/librustpkg/installed_packages.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustpkg%2Finstalled_packages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustpkg%2Finstalled_packages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Finstalled_packages.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -16,10 +16,10 @@ use std::os;\n use std::io;\n use std::io::fs;\n \n-pub fn list_installed_packages(f: &fn(&PkgId) -> bool) -> bool  {\n+pub fn list_installed_packages(f: |&PkgId| -> bool) -> bool  {\n     let workspaces = rust_path();\n     for p in workspaces.iter() {\n-        let binfiles = do io::ignore_io_error { fs::readdir(&p.join(\"bin\")) };\n+        let binfiles = io::ignore_io_error(|| fs::readdir(&p.join(\"bin\")));\n         for exec in binfiles.iter() {\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             match exec.filestem_str() {\n@@ -31,7 +31,7 @@ pub fn list_installed_packages(f: &fn(&PkgId) -> bool) -> bool  {\n                 }\n             }\n         }\n-        let libfiles = do io::ignore_io_error { fs::readdir(&p.join(\"lib\")) };\n+        let libfiles = io::ignore_io_error(|| fs::readdir(&p.join(\"lib\")));\n         for lib in libfiles.iter() {\n             debug!(\"Full name: {}\", lib.display());\n             match has_library(lib) {\n@@ -42,10 +42,10 @@ pub fn list_installed_packages(f: &fn(&PkgId) -> bool) -> bool  {\n                     let rel_p = lib.path_relative_from(&parent).unwrap();\n                     debug!(\"Rel: {}\", rel_p.display());\n                     let rel_path = rel_p.join(basename);\n-                    do rel_path.display().with_str |s| {\n+                    rel_path.display().with_str(|s| {\n                         debug!(\"Rel name: {}\", s);\n                         f(&PkgId::new(s));\n-                    }\n+                    });\n                 }\n                 None => ()\n             }\n@@ -55,7 +55,7 @@ pub fn list_installed_packages(f: &fn(&PkgId) -> bool) -> bool  {\n }\n \n pub fn has_library(p: &Path) -> Option<~str> {\n-    let files = do io::ignore_io_error { fs::readdir(p) };\n+    let files = io::ignore_io_error(|| fs::readdir(p));\n     for path in files.iter() {\n         if path.extension_str() == Some(os::consts::DLL_EXTENSION) {\n             let stuff : &str = path.filestem_str().expect(\"has_library: weird path\");\n@@ -71,13 +71,13 @@ pub fn has_library(p: &Path) -> Option<~str> {\n \n pub fn package_is_installed(p: &PkgId) -> bool {\n     let mut is_installed = false;\n-    do list_installed_packages() |installed| {\n+    list_installed_packages(|installed| {\n         if installed == p {\n             is_installed = true;\n             false\n         } else {\n             true\n         }\n-    };\n+    });\n     is_installed\n }"}, {"sha": "2308f314b14a120c23eaa4a2d6beb691ad1493e9", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -255,7 +255,7 @@ impl CtxMethods for BuildContext {\n             // argument\n             let pkgid = PkgId::new(args[0].clone());\n             let mut dest_ws = default_workspace();\n-            do each_pkg_parent_workspace(&self.context, &pkgid) |workspace| {\n+            each_pkg_parent_workspace(&self.context, &pkgid, |workspace| {\n                 debug!(\"found pkg {} in workspace {}, trying to build\",\n                        pkgid.to_str(), workspace.display());\n                 dest_ws = determine_destination(os::getcwd(),\n@@ -265,7 +265,7 @@ impl CtxMethods for BuildContext {\n                                               false, pkgid.clone());\n                 self.build(&mut pkg_src, what);\n                 true\n-            };\n+            });\n             // n.b. If this builds multiple packages, it only returns the workspace for\n             // the last one. The whole building-multiple-packages-with-the-same-ID is weird\n             // anyway and there are no tests for it, so maybe take it out\n@@ -353,12 +353,10 @@ impl CtxMethods for BuildContext {\n             }\n             \"list\" => {\n                 println(\"Installed packages:\");\n-                do installed_packages::list_installed_packages |pkg_id| {\n-                    do pkg_id.path.display().with_str |s| {\n-                        println(s);\n-                    }\n+                installed_packages::list_installed_packages(|pkg_id| {\n+                    pkg_id.path.display().with_str(|s| println(s));\n                     true\n-                };\n+                });\n             }\n             \"prefer\" => {\n                 if args.len() < 1 {\n@@ -402,12 +400,12 @@ impl CtxMethods for BuildContext {\n                 else {\n                     let rp = rust_path();\n                     assert!(!rp.is_empty());\n-                    do each_pkg_parent_workspace(&self.context, &pkgid) |workspace| {\n+                    each_pkg_parent_workspace(&self.context, &pkgid, |workspace| {\n                         path_util::uninstall_package_from(workspace, &pkgid);\n                         note(format!(\"Uninstalled package {} (was installed in {})\",\n                                   pkgid.to_str(), workspace.display()));\n                         true\n-                    };\n+                    });\n                 }\n             }\n             \"unprefer\" => {\n@@ -471,19 +469,19 @@ impl CtxMethods for BuildContext {\n                 // Build the package script if needed\n                 let script_build = format!(\"build_package_script({})\",\n                                            package_script_path.display());\n-                let pkg_exe = do self.workcache_context.with_prep(script_build) |prep| {\n+                let pkg_exe = self.workcache_context.with_prep(script_build, |prep| {\n                     let subsysroot = sysroot.clone();\n                     let psp = package_script_path.clone();\n                     let ws = workspace.clone();\n                     let pid = pkgid.clone();\n-                    do prep.exec |exec| {\n+                    prep.exec(proc(exec) {\n                         let mut pscript = PkgScript::parse(subsysroot.clone(),\n                                                            psp.clone(),\n                                                            &ws,\n                                                            &pid);\n                         pscript.build_custom(exec)\n-                    }\n-                };\n+                    })\n+                });\n                 // We always *run* the package script\n                 let (cfgs, hook_result) = PkgScript::run_custom(&Path::new(pkg_exe), &sysroot);\n                 debug!(\"Command return code = {:?}\", hook_result);\n@@ -620,7 +618,7 @@ impl CtxMethods for BuildContext {\n                target_exec.display(), target_lib,\n                maybe_executable, maybe_library);\n \n-        do self.workcache_context.with_prep(id.install_tag()) |prep| {\n+        self.workcache_context.with_prep(id.install_tag(), |prep| {\n             for ee in maybe_executable.iter() {\n                 // FIXME (#9639): This needs to handle non-utf8 paths\n                 prep.declare_input(\"binary\",\n@@ -638,7 +636,7 @@ impl CtxMethods for BuildContext {\n             let sub_target_ex = target_exec.clone();\n             let sub_target_lib = target_lib.clone();\n             let sub_build_inputs = build_inputs.to_owned();\n-            do prep.exec |exe_thing| {\n+            prep.exec(proc(exe_thing) {\n                 let mut outputs = ~[];\n                 // Declare all the *inputs* to the declared input too, as inputs\n                 for executable in subex.iter() {\n@@ -684,8 +682,8 @@ impl CtxMethods for BuildContext {\n                     outputs.push(target_lib.as_str().unwrap().to_owned());\n                 }\n                 outputs\n-            }\n-        }\n+            })\n+        })\n     }\n \n     fn prefer(&self, _id: &str, _vers: Option<~str>)  {"}, {"sha": "04ac30e3732876930c05bf9f855dcc03081babd8", "filename": "src/librustpkg/package_id.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustpkg%2Fpackage_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustpkg%2Fpackage_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_id.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -87,10 +87,10 @@ impl PkgId {\n \n     pub fn hash(&self) -> ~str {\n         // FIXME (#9639): hash should take a &[u8] so we can hash the real path\n-        do self.path.display().with_str |s| {\n+        self.path.display().with_str(|s| {\n             let vers = self.version.to_str();\n             format!(\"{}-{}-{}\", s, hash(s + vers), vers)\n-        }\n+        })\n     }\n \n     pub fn short_name_with_version(&self) -> ~str {"}, {"sha": "b93199e2c61793343910cc44f46effe0d69ea034", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -291,11 +291,9 @@ impl PkgSrc {\n \n                 let mut failed = false;\n \n-                do cond.trap(|_| {\n+                cond.trap(|_| {\n                     failed = true;\n-                }).inside {\n-                    git_clone_url(url, &clone_target, &pkgid.version);\n-                };\n+                }).inside(|| git_clone_url(url, &clone_target, &pkgid.version));\n \n                 if failed {\n                     return None;\n@@ -348,7 +346,7 @@ impl PkgSrc {\n         self.find_crates_with_filter(|_| true);\n     }\n \n-    pub fn find_crates_with_filter(&mut self, filter: &fn(&str) -> bool) {\n+    pub fn find_crates_with_filter(&mut self, filter: |&str| -> bool) {\n         use conditions::missing_pkg_files::cond;\n \n         let prefix = self.start_dir.components().len();\n@@ -400,7 +398,7 @@ impl PkgSrc {\n             debug!(\"build_crates: compiling {}\", path.display());\n             let cfgs = crate.cfgs + cfgs;\n \n-            do ctx.workcache_context.with_prep(crate_tag(&path)) |prep| {\n+            ctx.workcache_context.with_prep(crate_tag(&path), |prep| {\n                 debug!(\"Building crate {}, declaring it as an input\", path.display());\n                 // FIXME (#9639): This needs to handle non-utf8 paths\n                 prep.declare_input(\"file\", path.as_str().unwrap(),\n@@ -414,7 +412,7 @@ impl PkgSrc {\n                 let sub_deps = deps.clone();\n                 let inputs = inputs_to_discover.map(|&(ref k, ref p)|\n                                                     (k.clone(), p.as_str().unwrap().to_owned()));\n-                do prep.exec |exec| {\n+                prep.exec(proc(exec) {\n                     for &(ref kind, ref p) in inputs.iter() {\n                         let pth = Path::new(p.clone());\n                         exec.discover_input(*kind, *p, if *kind == ~\"file\" {\n@@ -445,8 +443,8 @@ impl PkgSrc {\n                     let result = result.as_ref().map(|p|p.as_str().unwrap());\n                     debug!(\"Result of compiling {} was {}\", subpath.display(), result.to_str());\n                     result.to_str()\n-                }\n-            };\n+                })\n+            });\n         }\n     }\n "}, {"sha": "9d5b5e91fe27cf96db876c23cc9f5eda8e2e1ae8", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -63,7 +63,7 @@ pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n \n pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n // Returns the directory it was actually found in\n-             workspace_to_src_dir: &fn(&Path) -> Path) -> Option<Path> {\n+             workspace_to_src_dir: |&Path| -> Path) -> Option<Path> {\n     if !workspace.is_dir() {\n         return None;\n     }\n@@ -76,15 +76,15 @@ pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n         if p.is_dir() {\n             if p == src_dir.join(&pkgid.path) || {\n                 let pf = p.filename_str();\n-                do pf.iter().any |&g| {\n+                pf.iter().any(|&g| {\n                     match split_version_general(g, '-') {\n                         None => false,\n                         Some((ref might_match, ref vers)) => {\n                             *might_match == pkgid.short_name\n                                 && (pkgid.version == *vers || pkgid.version == NoVersion)\n                         }\n                     }\n-                }\n+                })\n             } {\n                 found = Some(p.clone());\n             }\n@@ -215,7 +215,7 @@ pub fn system_library(sysroot: &Path, lib_name: &str) -> Option<Path> {\n \n fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Option<Path> {\n     debug!(\"Listing directory {}\", dir_to_search.display());\n-    let dir_contents = do io::ignore_io_error { fs::readdir(dir_to_search) };\n+    let dir_contents = io::ignore_io_error(|| fs::readdir(dir_to_search));\n     debug!(\"dir has {:?} entries\", dir_contents.len());\n \n     let lib_prefix = format!(\"{}{}\", os::consts::DLL_PREFIX, short_name);\n@@ -225,14 +225,14 @@ fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Opti\n \n     // Find a filename that matches the pattern:\n     // (lib_prefix)-hash-(version)(lib_suffix)\n-    let mut libraries = do dir_contents.iter().filter |p| {\n+    let mut libraries = dir_contents.iter().filter(|p| {\n         let extension = p.extension_str();\n         debug!(\"p = {}, p's extension is {:?}\", p.display(), extension);\n         match extension {\n             None => false,\n             Some(ref s) => lib_filetype == *s\n         }\n-    };\n+    });\n \n     let mut result_filename = None;\n     for p_path in libraries {\n@@ -277,11 +277,11 @@ fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Opti\n \n     // Return the filename that matches, which we now know exists\n     // (if result_filename != None)\n-    let abs_path = do result_filename.map |result_filename| {\n+    let abs_path = result_filename.map(|result_filename| {\n         let absolute_path = dir_to_search.join(&result_filename);\n         debug!(\"result_filename = {}\", absolute_path.display());\n         absolute_path\n-    };\n+    });\n \n     abs_path\n }\n@@ -463,19 +463,14 @@ pub fn versionize(p: &Path, v: &Version) -> Path {\n #[cfg(target_os = \"win32\")]\n pub fn chmod_read_only(p: &Path) -> bool {\n     unsafe {\n-        do p.with_c_str |src_buf| {\n-            libc::chmod(src_buf, S_IRUSR as libc::c_int) == 0 as libc::c_int\n-        }\n+        p.with_c_str(|src_buf| libc::chmod(src_buf, S_IRUSR as libc::c_int) == 0 as libc::c_int)\n     }\n }\n \n #[cfg(not(target_os = \"win32\"))]\n pub fn chmod_read_only(p: &Path) -> bool {\n     unsafe {\n-        do p.with_c_str |src_buf| {\n-            libc::chmod(src_buf, S_IRUSR as libc::mode_t) == 0\n-                as libc::c_int\n-        }\n+        p.with_c_str(|src_buf| libc::chmod(src_buf, S_IRUSR as libc::mode_t) == 0 as libc::c_int)\n     }\n }\n "}, {"sha": "396ef756c7610836ea99ddb388fb526cc7be1531", "filename": "src/librustpkg/sha1.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustpkg%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustpkg%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsha1.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -51,11 +51,11 @@ fn read_u32v_be(dst: &mut[u32], input: &[u8]) {\n     unsafe {\n         let mut x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n         let mut y: *i32 = transmute(input.unsafe_ref(0));\n-        do dst.len().times() {\n+        dst.len().times(|| {\n             *x = to_be32(*y);\n             x = x.offset(1);\n             y = y.offset(1);\n-        }\n+        })\n     }\n }\n \n@@ -94,7 +94,7 @@ fn add_bytes_to_bits<T: Int + CheckedAdd + ToBits>(bits: T, bytes: T) -> T {\n trait FixedBuffer {\n     /// Input a vector of bytes. If the buffer becomes full, process it with the provided\n     /// function and then clear the buffer.\n-    fn input(&mut self, input: &[u8], func: &fn(&[u8]));\n+    fn input(&mut self, input: &[u8], func: |&[u8]|);\n \n     /// Reset the buffer.\n     fn reset(&mut self);\n@@ -137,7 +137,7 @@ impl FixedBuffer64 {\n }\n \n impl FixedBuffer for FixedBuffer64 {\n-    fn input(&mut self, input: &[u8], func: &fn(&[u8])) {\n+    fn input(&mut self, input: &[u8], func: |&[u8]|) {\n         let mut i = 0;\n \n         let size = 64;\n@@ -217,11 +217,11 @@ trait StandardPadding {\n     /// and is guaranteed to have exactly rem remaining bytes when it returns. If there are not at\n     /// least rem bytes available, the buffer will be zero padded, processed, cleared, and then\n     /// filled with zeros again until only rem bytes are remaining.\n-    fn standard_padding(&mut self, rem: uint, func: &fn(&[u8]));\n+    fn standard_padding(&mut self, rem: uint, func: |&[u8]|);\n }\n \n impl <T: FixedBuffer> StandardPadding for T {\n-    fn standard_padding(&mut self, rem: uint, func: &fn(&[u8])) {\n+    fn standard_padding(&mut self, rem: uint, func: |&[u8]|) {\n         let size = self.size();\n \n         self.next(1)[0] = 128;\n@@ -613,29 +613,23 @@ mod bench {\n     pub fn sha1_10(bh: & mut BenchHarness) {\n         let mut sh = Sha1::new();\n         let bytes = [1u8, ..10];\n-        do bh.iter {\n-            sh.input(bytes);\n-        }\n+        bh.iter(|| sh.input(bytes));\n         bh.bytes = bytes.len() as u64;\n     }\n \n     #[bench]\n     pub fn sha1_1k(bh: & mut BenchHarness) {\n         let mut sh = Sha1::new();\n         let bytes = [1u8, ..1024];\n-        do bh.iter {\n-            sh.input(bytes);\n-        }\n+        bh.iter(|| sh.input(bytes));\n         bh.bytes = bytes.len() as u64;\n     }\n \n     #[bench]\n     pub fn sha1_64k(bh: & mut BenchHarness) {\n         let mut sh = Sha1::new();\n         let bytes = [1u8, ..65536];\n-        do bh.iter {\n-            sh.input(bytes);\n-        }\n+        bh.iter(|| sh.input(bytes));\n         bh.bytes = bytes.len() as u64;\n     }\n }"}, {"sha": "86c0fb276801631e0071fea9ed02f21824fbe28d", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -384,9 +384,7 @@ fn executable_exists(repo: &Path, short_name: &str) -> bool {\n fn test_executable_exists(repo: &Path, short_name: &str) -> bool {\n     debug!(\"test_executable_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n     let exec = built_test_in_workspace(&PkgId::new(short_name), repo);\n-    do exec.map_default(false) |exec| {\n-        exec.exists() && is_rwx(&exec)\n-    }\n+    exec.map_default(false, |exec| exec.exists() && is_rwx(&exec))\n }\n \n fn remove_executable_file(p: &PkgId, workspace: &Path) {\n@@ -544,12 +542,12 @@ fn frob_source_file(workspace: &Path, pkgid: &PkgId, filename: &str) {\n     debug!(\"Frobbed? {:?}\", maybe_p);\n     match maybe_p {\n         Some(ref p) => {\n-            do io::io_error::cond.trap(|e| {\n+            io::io_error::cond.trap(|e| {\n                 cond.raise((p.clone(), format!(\"Bad path: {}\", e.desc)));\n-            }).inside {\n+            }).inside(|| {\n                 let mut w = File::open_mode(p, io::Append, io::Write);\n                 w.write(bytes!(\"/* hi */\\n\"));\n-            }\n+            })\n         }\n         None => fail!(\"frob_source_file failed to find a source file in {}\",\n                            pkg_src_dir.display())\n@@ -744,26 +742,26 @@ fn test_package_ids_must_be_relative_path_like() {\n     assert!(\"github.com/catamorphism/test-pkg-0.1\" ==\n             PkgId::new(\"github.com/catamorphism/test-pkg\").to_str());\n \n-    do cond.trap(|(p, e)| {\n+    cond.trap(|(p, e)| {\n         assert!(p.filename().is_none())\n         assert!(\"0-length pkgid\" == e);\n         whatever.clone()\n-    }).inside {\n+    }).inside(|| {\n         let x = PkgId::new(\"\");\n         assert_eq!(~\"foo-0.1\", x.to_str());\n-    }\n+    });\n \n-    do cond.trap(|(p, e)| {\n+    cond.trap(|(p, e)| {\n         let abs = os::make_absolute(&Path::new(\"foo/bar/quux\"));\n         assert_eq!(p, abs);\n         assert!(\"absolute pkgid\" == e);\n         whatever.clone()\n-    }).inside {\n+    }).inside(|| {\n         let zp = os::make_absolute(&Path::new(\"foo/bar/quux\"));\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let z = PkgId::new(zp.as_str().unwrap());\n         assert_eq!(~\"foo-0.1\", z.to_str());\n-    }\n+    })\n \n }\n "}, {"sha": "122f80a52f1cad06af724b56b178e709859d7853", "filename": "src/librustpkg/testsuite/pass/src/c-dependencies/pkg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -44,7 +44,7 @@ pub fn main() {\n     let my_workspace = api::my_workspace(&context.context, \"cdep\");\n     let foo_c_name = my_workspace.join_many([\"src\", \"cdep-0.1\", \"foo.c\"]);\n \n-    let out_lib_path = do context.workcache_context.with_prep(\"foo.c\") |prep| {\n+    let out_lib_path = context.workcache_context.with_prep(\"foo.c\", |prep| {\n         let sub_cx = context.context.clone();\n         debug!(\"foo_c_name = {}\", foo_c_name.display());\n         prep.declare_input(\"file\",\n@@ -62,7 +62,7 @@ pub fn main() {\n             out_p.as_str().unwrap().to_owned()\n         };\n         out_path\n-    };\n+    });\n     let out_lib_path = Path::new(out_lib_path);\n     debug!(\"out_lib_path = {}\", out_lib_path.display());\n     context.add_library_path(out_lib_path.dir_path());"}, {"sha": "9842508a5c3203bab9cd0976d934d513b8c1492e", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -81,21 +81,19 @@ fn fold_mod(_ctx: @mut ReadyCtx, m: &ast::_mod, fold: &CrateSetup)\n             -> ast::_mod {\n     fn strip_main(item: @ast::item) -> @ast::item {\n         @ast::item {\n-            attrs: do item.attrs.iter().filter_map |attr| {\n+            attrs: item.attrs.iter().filter_map(|attr| {\n                 if \"main\" != attr.name() {\n                     Some(*attr)\n                 } else {\n                     None\n                 }\n-            }.collect(),\n+            }).collect(),\n             .. (*item).clone()\n         }\n     }\n \n     fold::noop_fold_mod(&ast::_mod {\n-        items: do m.items.map |item| {\n-            strip_main(*item)\n-        },\n+        items: m.items.map(|item| strip_main(*item)),\n         .. (*m).clone()\n     }, fold)\n }\n@@ -425,7 +423,7 @@ struct ViewItemVisitor<'self> {\n     sess: session::Session,\n     exec: &'self mut workcache::Exec,\n     c: &'self ast::Crate,\n-    save: &'self fn(Path),\n+    save: 'self |Path|,\n     deps: &'self mut DepMap\n }\n \n@@ -493,21 +491,21 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                         // and the `PkgSrc` constructor will detect that;\n                         // or else it's already in a workspace and we'll build into that\n                         // workspace\n-                        let pkg_src = do cond.trap(|_| {\n+                        let pkg_src = cond.trap(|_| {\n                                  // Nonexistent package? Then print a better error\n                                  error(format!(\"Package {} depends on {}, but I don't know \\\n                                                how to find it\",\n                                                self.parent.path.display(),\n                                                pkg_id.path.display()));\n                                  fail!()\n-                        }).inside {\n+                        }).inside(|| {\n                             PkgSrc::new(source_workspace.clone(),\n                                         dest_workspace.clone(),\n                                         // Use the rust_path_hack to search for dependencies iff\n                                         // we were already using it\n                                         self.context.context.use_rust_path_hack,\n                                         pkg_id.clone())\n-                        };\n+                        });\n                         let (outputs_disc, inputs_disc) =\n                             self.context.install(\n                                 pkg_src,\n@@ -587,7 +585,7 @@ pub fn find_and_install_dependencies(context: &BuildContext,\n                                      exec: &mut workcache::Exec,\n                                      c: &ast::Crate,\n                                      deps: &mut DepMap,\n-                                     save: &fn(Path)) {\n+                                     save: |Path|) {\n     debug!(\"In find_and_install_dependencies...\");\n     let mut visitor = ViewItemVisitor {\n         context: context,"}, {"sha": "22d673333e9542ee01eef7906a22d175ff07c6a6", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -18,7 +18,10 @@ use path_util::rust_path;\n use util::option_to_vec;\n use package_id::PkgId;\n \n-pub fn each_pkg_parent_workspace(cx: &Context, pkgid: &PkgId, action: &fn(&Path) -> bool) -> bool {\n+pub fn each_pkg_parent_workspace(cx: &Context,\n+                                 pkgid: &PkgId,\n+                                 action: |&Path| -> bool)\n+                                 -> bool {\n     // Using the RUST_PATH, find workspaces that contain\n     // this package ID\n     let workspaces = pkg_parent_workspaces(cx, pkgid);"}, {"sha": "04c1c5a9fb8c97c4cdc77025eee854e51bd22c9a", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -55,11 +55,11 @@ impl GetAddrInfoRequest {\n \n         let hint = hints.map(|hint| {\n             let mut flags = 0;\n-            do each_ai_flag |cval, aival| {\n+            each_ai_flag(|cval, aival| {\n                 if hint.flags & (aival as uint) != 0 {\n                     flags |= cval as i32;\n                 }\n-            }\n+            });\n             let socktype = 0;\n             let protocol = 0;\n \n@@ -86,9 +86,9 @@ impl GetAddrInfoRequest {\n                 req.defuse(); // uv callback now owns this request\n                 let mut cx = Ctx { slot: None, status: 0, addrinfo: None };\n \n-                do wait_until_woken_after(&mut cx.slot) {\n+                wait_until_woken_after(&mut cx.slot, || {\n                     req.set_data(&cx);\n-                }\n+                });\n \n                 match cx.status {\n                     0 => Ok(accum_addrinfo(cx.addrinfo.get_ref())),\n@@ -120,7 +120,7 @@ impl Drop for Addrinfo {\n     }\n }\n \n-fn each_ai_flag(_f: &fn(c_int, ai::Flag)) {\n+fn each_ai_flag(_f: |c_int, ai::Flag|) {\n     /* XXX: do we really want to support these?\n     unsafe {\n         f(uvll::rust_AI_ADDRCONFIG(), ai::AddrConfig);\n@@ -144,11 +144,11 @@ pub fn accum_addrinfo(addr: &Addrinfo) -> ~[ai::Info] {\n             let rustaddr = net::sockaddr_to_socket_addr((*addr).ai_addr);\n \n             let mut flags = 0;\n-            do each_ai_flag |cval, aival| {\n+            each_ai_flag(|cval, aival| {\n                 if (*addr).ai_flags & cval != 0 {\n                     flags |= aival as uint;\n                 }\n-            }\n+            });\n \n             /* XXX: do we really want to support these\n             let protocol = match (*addr).ai_protocol {"}, {"sha": "0f1e967f9bc46badc83e01bbb2707e25728c3552", "filename": "src/librustuv/async.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -111,14 +111,14 @@ impl RemoteCallback for AsyncWatcher {\n impl Drop for AsyncWatcher {\n     fn drop(&mut self) {\n         unsafe {\n-            do self.exit_flag.with |should_exit| {\n+            self.exit_flag.with(|should_exit| {\n                 // NB: These two things need to happen atomically. Otherwise\n                 // the event handler could wake up due to a *previous*\n                 // signal and see the exit flag, destroying the handle\n                 // before the final send.\n                 *should_exit = true;\n                 uvll::uv_async_send(self.handle)\n-            }\n+            })\n         }\n     }\n }"}, {"sha": "7aef62af8eef429700416489dc328557459d5a28", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -86,13 +86,13 @@ impl FsRequest {\n     pub fn read(loop_: &Loop, fd: c_int, buf: &mut [u8], offset: i64)\n         -> Result<int, UvError>\n     {\n-        do execute(|req, cb| unsafe {\n+        execute(|req, cb| unsafe {\n             uvll::uv_fs_read(loop_.handle, req,\n                              fd, vec::raw::to_ptr(buf) as *c_void,\n                              buf.len() as size_t, offset, cb)\n-        }).map |req| {\n+        }).map(|req| {\n             req.get_result() as int\n-        }\n+        })\n     }\n \n     pub fn mkdir(loop_: &Loop, path: &CString, mode: c_int)\n@@ -142,24 +142,25 @@ impl FsRequest {\n             let mut paths = ~[];\n             let path = CString::new(path.with_ref(|p| p), false);\n             let parent = Path::new(path);\n-            do c_str::from_c_multistring(req.get_ptr() as *libc::c_char,\n-                                         Some(req.get_result() as uint)) |rel| {\n+            c_str::from_c_multistring(req.get_ptr() as *libc::c_char,\n+                                      Some(req.get_result() as uint),\n+                                      |rel| {\n                 let p = rel.as_bytes();\n                 paths.push(parent.join(p.slice_to(rel.len())));\n-            };\n+            });\n             paths\n         })\n     }\n \n     pub fn readlink(loop_: &Loop, path: &CString) -> Result<Path, UvError> {\n-        do execute(|req, cb| unsafe {\n+        execute(|req, cb| unsafe {\n             uvll::uv_fs_readlink(loop_.handle, req,\n                                  path.with_ref(|p| p), cb)\n-        }).map |req| {\n+        }).map(|req| {\n             Path::new(unsafe {\n                 CString::new(req.get_ptr() as *libc::c_char, false)\n             })\n-        }\n+        })\n     }\n \n     pub fn chown(loop_: &Loop, path: &CString, uid: int, gid: int)\n@@ -294,7 +295,7 @@ impl Drop for FsRequest {\n     }\n }\n \n-fn execute(f: &fn(*uvll::uv_fs_t, uvll::uv_fs_cb) -> c_int)\n+fn execute(f: |*uvll::uv_fs_t, uvll::uv_fs_cb| -> c_int)\n     -> Result<FsRequest, UvError>\n {\n     let mut req = FsRequest {\n@@ -305,16 +306,15 @@ fn execute(f: &fn(*uvll::uv_fs_t, uvll::uv_fs_cb) -> c_int)\n         0 => {\n             req.fired = true;\n             let mut slot = None;\n-            do wait_until_woken_after(&mut slot) {\n+            wait_until_woken_after(&mut slot, || {\n                 unsafe { uvll::set_data_for_req(req.req, &slot) }\n-            }\n+            });\n             match req.get_result() {\n                 n if n < 0 => Err(UvError(n)),\n                 _ => Ok(req),\n             }\n         }\n         n => Err(UvError(n))\n-\n     };\n \n     extern fn fs_cb(req: *uvll::uv_fs_t) {\n@@ -326,9 +326,8 @@ fn execute(f: &fn(*uvll::uv_fs_t, uvll::uv_fs_cb) -> c_int)\n     }\n }\n \n-fn execute_nop(f: &fn(*uvll::uv_fs_t, uvll::uv_fs_cb) -> c_int)\n-    -> Result<(), UvError>\n-{\n+fn execute_nop(f: |*uvll::uv_fs_t, uvll::uv_fs_cb| -> c_int)\n+    -> Result<(), UvError> {\n     execute(f).map(|_| {})\n }\n "}, {"sha": "1f06f87c9de6e80f32ac72c1568ba4318038130c", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -138,9 +138,9 @@ pub trait UvHandle<T> {\n             uvll::uv_close(self.uv_handle() as *uvll::uv_handle_t, close_cb);\n             uvll::set_data_for_uv_handle(self.uv_handle(), ptr::null::<()>());\n \n-            do wait_until_woken_after(&mut slot) {\n+            wait_until_woken_after(&mut slot, || {\n                 uvll::set_data_for_uv_handle(self.uv_handle(), &slot);\n-            }\n+            })\n         }\n \n         extern fn close_cb(handle: *uvll::uv_handle_t) {\n@@ -196,15 +196,15 @@ impl Drop for ForbidUnwind {\n     }\n }\n \n-fn wait_until_woken_after(slot: *mut Option<BlockedTask>, f: &fn()) {\n+fn wait_until_woken_after(slot: *mut Option<BlockedTask>, f: ||) {\n     let _f = ForbidUnwind::new(\"wait_until_woken_after\");\n     unsafe {\n         assert!((*slot).is_none());\n         let sched: ~Scheduler = Local::take();\n-        do sched.deschedule_running_task_and_then |_, task| {\n+        sched.deschedule_running_task_and_then(|_, task| {\n             f();\n             *slot = Some(task);\n-        }\n+        })\n     }\n }\n \n@@ -390,15 +390,15 @@ pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n #[cfg(test)]\n fn local_loop() -> &'static mut Loop {\n     unsafe {\n-        cast::transmute(do Local::borrow |sched: &mut Scheduler| {\n+        cast::transmute(Local::borrow(|sched: &mut Scheduler| {\n             let mut io = None;\n-            do sched.event_loop.io |i| {\n+            sched.event_loop.io(|i| {\n                 let (_vtable, uvio): (uint, &'static mut uvio::UvIoFactory) =\n                     cast::transmute(i);\n                 io = Some(uvio);\n-            }\n+            });\n             io.unwrap()\n-        }.uv_loop())\n+        }).uv_loop())\n     }\n }\n "}, {"sha": "eb679553e7642eead29e45ec84ff089bcbab83b7", "filename": "src/librustuv/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustuv%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustuv%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fmacros.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -29,7 +29,7 @@ macro_rules! uvdebug (\n \n // get a handle for the current scheduler\n macro_rules! get_handle_to_current_scheduler(\n-    () => (do Local::borrow |sched: &mut Scheduler| { sched.make_handle() })\n+    () => (Local::borrow(|sched: &mut Scheduler| sched.make_handle()))\n )\n \n pub fn dumb_println(args: &fmt::Arguments) {"}, {"sha": "2c0528e87426975d870b7004664cff6cd137ada0", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -34,19 +34,19 @@ use uvll::sockaddr;\n /// Generic functions related to dealing with sockaddr things\n ////////////////////////////////////////////////////////////////////////////////\n \n-fn socket_addr_as_sockaddr<T>(addr: SocketAddr, f: &fn(*sockaddr) -> T) -> T {\n+fn socket_addr_as_sockaddr<T>(addr: SocketAddr, f: |*sockaddr| -> T) -> T {\n     let malloc = match addr.ip {\n         Ipv4Addr(*) => uvll::rust_malloc_ip4_addr,\n         Ipv6Addr(*) => uvll::rust_malloc_ip6_addr,\n     };\n \n     let ip = addr.ip.to_str();\n     let addr = ip.with_c_str(|p| unsafe { malloc(p, addr.port as c_int) });\n-    do (|| {\n+    (|| {\n         f(addr)\n-    }).finally {\n+    }).finally(|| {\n         unsafe { libc::free(addr) };\n-    }\n+    })\n }\n \n pub fn sockaddr_to_socket_addr(addr: *sockaddr) -> SocketAddr {\n@@ -93,19 +93,19 @@ pub fn sockaddr_to_socket_addr(addr: *sockaddr) -> SocketAddr {\n fn test_ip4_conversion() {\n     use std::rt;\n     let ip4 = rt::test::next_test_ip4();\n-    do socket_addr_as_sockaddr(ip4) |addr| {\n+    socket_addr_as_sockaddr(ip4, |addr| {\n         assert_eq!(ip4, sockaddr_to_socket_addr(addr));\n-    }\n+    })\n }\n \n #[cfg(test)]\n #[test]\n fn test_ip6_conversion() {\n     use std::rt;\n     let ip6 = rt::test::next_test_ip6();\n-    do socket_addr_as_sockaddr(ip6) |addr| {\n+    socket_addr_as_sockaddr(ip6, |addr| {\n         assert_eq!(ip6, sockaddr_to_socket_addr(addr));\n-    }\n+    })\n }\n \n enum SocketNameKind {\n@@ -181,7 +181,7 @@ impl TcpWatcher {\n         struct Ctx { status: c_int, task: Option<BlockedTask> }\n \n         let tcp = TcpWatcher::new(loop_);\n-        let ret = do socket_addr_as_sockaddr(address) |addr| {\n+        let ret = socket_addr_as_sockaddr(address, |addr| {\n             let mut req = Request::new(uvll::UV_CONNECT);\n             let result = unsafe {\n                 uvll::uv_tcp_connect(req.handle, tcp.handle, addr,\n@@ -191,17 +191,17 @@ impl TcpWatcher {\n                 0 => {\n                     req.defuse(); // uv callback now owns this request\n                     let mut cx = Ctx { status: 0, task: None };\n-                    do wait_until_woken_after(&mut cx.task) {\n+                    wait_until_woken_after(&mut cx.task, || {\n                         req.set_data(&cx);\n-                    }\n+                    });\n                     match cx.status {\n                         0 => Ok(()),\n                         n => Err(UvError(n)),\n                     }\n                 }\n                 n => Err(UvError(n))\n             }\n-        };\n+        });\n \n         return match ret {\n             Ok(()) => Ok(tcp),\n@@ -291,8 +291,7 @@ impl Drop for TcpWatcher {\n \n impl TcpListener {\n     pub fn bind(loop_: &mut Loop, address: SocketAddr)\n-        -> Result<~TcpListener, UvError>\n-    {\n+                -> Result<~TcpListener, UvError> {\n         let handle = unsafe { uvll::malloc_handle(uvll::UV_TCP) };\n         assert_eq!(unsafe {\n             uvll::uv_tcp_init(loop_.handle, handle)\n@@ -424,8 +423,7 @@ pub struct UdpWatcher {\n \n impl UdpWatcher {\n     pub fn bind(loop_: &Loop, address: SocketAddr)\n-        -> Result<UdpWatcher, UvError>\n-    {\n+                -> Result<UdpWatcher, UvError> {\n         let udp = UdpWatcher {\n             handle: unsafe { uvll::malloc_handle(uvll::UV_UDP) },\n             home: get_handle_to_current_scheduler!(),\n@@ -478,9 +476,9 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n                     buf: Some(slice_to_uv_buf(buf)),\n                     result: None,\n                 };\n-                do wait_until_woken_after(&mut cx.task) {\n+                wait_until_woken_after(&mut cx.task, || {\n                     unsafe { uvll::set_data_for_uv_handle(self.handle, &cx) }\n-                }\n+                });\n                 match cx.result.take_unwrap() {\n                     (n, _) if n < 0 =>\n                         Err(uv_error_to_io_error(UvError(n as c_int))),\n@@ -550,9 +548,9 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n             0 => {\n                 req.defuse(); // uv callback now owns this request\n                 let mut cx = Ctx { task: None, result: 0 };\n-                do wait_until_woken_after(&mut cx.task) {\n+                wait_until_woken_after(&mut cx.task, || {\n                     req.set_data(&cx);\n-                }\n+                });\n                 match cx.result {\n                     0 => Ok(()),\n                     n => Err(uv_error_to_io_error(UvError(n)))\n@@ -575,22 +573,22 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n     fn join_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n         let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n-            do multi.to_str().with_c_str |m_addr| {\n+            multi.to_str().with_c_str(|m_addr| {\n                 uvll::uv_udp_set_membership(self.handle,\n                                             m_addr, ptr::null(),\n                                             uvll::UV_JOIN_GROUP)\n-            }\n+            })\n         })\n     }\n \n     fn leave_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n         let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n-            do multi.to_str().with_c_str |m_addr| {\n+            multi.to_str().with_c_str(|m_addr| {\n                 uvll::uv_udp_set_membership(self.handle,\n                                             m_addr, ptr::null(),\n                                             uvll::UV_LEAVE_GROUP)\n-            }\n+            })\n         })\n     }\n \n@@ -1099,21 +1097,21 @@ mod test {\n             let handle2 = Cell::new(sched2.make_handle());\n             let tasksFriendHandle = Cell::new(sched2.make_handle());\n \n-            let on_exit: proc(UnwindResult) = |exit_status| {\n+            let on_exit: proc(UnwindResult) = proc(exit_status) {\n                 handle1.take().send(Shutdown);\n                 handle2.take().send(Shutdown);\n                 assert!(exit_status.is_success());\n             };\n \n             unsafe fn local_io() -> &'static mut IoFactory {\n-                do Local::borrow |sched: &mut Scheduler| {\n+                Local::borrow(|sched: &mut Scheduler| {\n                     let mut io = None;\n                     sched.event_loop.io(|i| io = Some(i));\n                     cast::transmute(io.unwrap())\n-                }\n+                })\n             }\n \n-            let test_function: proc() = || {\n+            let test_function: proc() = proc() {\n                 let io = unsafe { local_io() };\n                 let addr = next_test_ip4();\n                 let maybe_socket = io.udp_bind(addr);\n@@ -1122,14 +1120,14 @@ mod test {\n \n                 // block self on sched1\n                 let scheduler: ~Scheduler = Local::take();\n-                do scheduler.deschedule_running_task_and_then |_, task| {\n+                scheduler.deschedule_running_task_and_then(|_, task| {\n                     // unblock task\n-                    do task.wake().map |task| {\n+                    task.wake().map(|task| {\n                         // send self to sched2\n                         tasksFriendHandle.take().send(TaskFromFriend(task));\n-                    };\n+                    });\n                     // sched1 should now sleep since it has nothing else to do\n-                }\n+                })\n                 // sched2 will wake up and get the task as we do nothing else,\n                 // the function ends and the socket goes out of scope sched2\n                 // will start to run the destructor the destructor will first"}, {"sha": "6b48e823e4286645323cf86108d751ec76f13be0", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -77,7 +77,7 @@ impl PipeWatcher {\n         let mut req = Request::new(uvll::UV_CONNECT);\n         let pipe = PipeWatcher::new(loop_, false);\n \n-        do wait_until_woken_after(&mut cx.task) {\n+        wait_until_woken_after(&mut cx.task, || {\n             unsafe {\n                 uvll::uv_pipe_connect(req.handle,\n                                       pipe.handle(),\n@@ -86,7 +86,7 @@ impl PipeWatcher {\n             }\n             req.set_data(&cx);\n             req.defuse(); // uv callback now owns this request\n-        }\n+        });\n         return match cx.result {\n             0 => Ok(pipe),\n             n => Err(UvError(n))"}, {"sha": "0577d19ec4603c98fa0d936d00384bd2d98958de", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -57,8 +57,8 @@ impl Process {\n             }\n         }\n \n-        let ret = do with_argv(config.program, config.args) |argv| {\n-            do with_env(config.env) |envp| {\n+        let ret = with_argv(config.program, config.args, |argv| {\n+            with_env(config.env, |envp| {\n                 let options = uvll::uv_process_options_t {\n                     exit_cb: on_exit,\n                     file: unsafe { *argv },\n@@ -88,8 +88,8 @@ impl Process {\n                     0 => Ok(process.install()),\n                     err => Err(UvError(err)),\n                 }\n-            }\n-        };\n+            })\n+        });\n \n         match ret {\n             Ok(p) => Ok((p, ret_io)),\n@@ -148,7 +148,7 @@ unsafe fn set_stdio(dst: *uvll::uv_stdio_container_t,\n }\n \n /// Converts the program and arguments to the argv array expected by libuv\n-fn with_argv<T>(prog: &str, args: &[~str], f: &fn(**libc::c_char) -> T) -> T {\n+fn with_argv<T>(prog: &str, args: &[~str], f: |**libc::c_char| -> T) -> T {\n     // First, allocation space to put all the C-strings (we need to have\n     // ownership of them somewhere\n     let mut c_strs = vec::with_capacity(args.len() + 1);\n@@ -167,7 +167,7 @@ fn with_argv<T>(prog: &str, args: &[~str], f: &fn(**libc::c_char) -> T) -> T {\n }\n \n /// Converts the environment to the env array expected by libuv\n-fn with_env<T>(env: Option<&[(~str, ~str)]>, f: &fn(**libc::c_char) -> T) -> T {\n+fn with_env<T>(env: Option<&[(~str, ~str)]>, f: |**libc::c_char| -> T) -> T {\n     let env = match env {\n         Some(s) => s,\n         None => { return f(ptr::null()); }"}, {"sha": "0304b89dd6fdeae36e4206dec97a614452ebae25", "filename": "src/librustuv/stream.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustuv%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustuv%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fstream.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -123,9 +123,9 @@ impl StreamWatcher {\n                 let mut wcx = WriteContext { result: 0, task: None, };\n                 req.defuse(); // uv callback now owns this request\n \n-                do wait_until_woken_after(&mut wcx.task) {\n+                wait_until_woken_after(&mut wcx.task, || {\n                     req.set_data(&wcx);\n-                }\n+                });\n                 self.last_write_req = Some(Request::wrap(req.handle));\n                 match wcx.result {\n                     0 => Ok(()),"}, {"sha": "b7babed05024ba2dee30b1a2dc75ce43130e07df", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -88,10 +88,10 @@ impl RtioTimer for TimerWatcher {\n         let _f = ForbidUnwind::new(\"timer\");\n \n         let sched: ~Scheduler = Local::take();\n-        do sched.deschedule_running_task_and_then |_sched, task| {\n+        sched.deschedule_running_task_and_then(|_sched, task| {\n             self.action = Some(WakeTask(task));\n             self.start(msecs, 0);\n-        }\n+        });\n         self.stop();\n     }\n "}, {"sha": "976c0fbf9bc57efa9d96991294abe3348e12992c", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -46,23 +46,23 @@ pub trait HomingIO {\n \n         let _f = ForbidUnwind::new(\"going home\");\n \n-        let current_sched_id = do Local::borrow |sched: &mut Scheduler| {\n+        let current_sched_id = Local::borrow(|sched: &mut Scheduler| {\n             sched.sched_id()\n-        };\n+        });\n \n         // Only need to invoke a context switch if we're not on the right\n         // scheduler.\n         if current_sched_id != self.home().sched_id {\n             let scheduler: ~Scheduler = Local::take();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                do task.wake().map |task| {\n+            scheduler.deschedule_running_task_and_then(|_, task| {\n+                task.wake().map(|task| {\n                     self.home().send(RunOnce(task));\n-                };\n-            }\n+                });\n+            })\n         }\n-        let current_sched_id = do Local::borrow |sched: &mut Scheduler| {\n+        let current_sched_id = Local::borrow(|sched: &mut Scheduler| {\n             sched.sched_id()\n-        };\n+        });\n         assert!(current_sched_id == self.home().sched_id);\n \n         self.home().sched_id\n@@ -114,11 +114,11 @@ impl Drop for HomingMissile {\n         // original scheduler. Otherwise, we can just return and keep running\n         if !Task::on_appropriate_sched() {\n             let scheduler: ~Scheduler = Local::take();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                do task.wake().map |task| {\n+            scheduler.deschedule_running_task_and_then(|_, task| {\n+                task.wake().map(|task| {\n                     Scheduler::run_task(task);\n-                };\n-            }\n+                });\n+            })\n         }\n \n         util::ignore(f);\n@@ -161,7 +161,7 @@ impl EventLoop for UvEventLoop {\n         ~AsyncWatcher::new(self.uvio.uv_loop(), f) as ~RemoteCallback\n     }\n \n-    fn io<'a>(&'a mut self, f: &fn(&'a mut IoFactory)) {\n+    fn io<'a>(&'a mut self, f: |&'a mut IoFactory|) {\n         f(&mut self.uvio as &mut IoFactory)\n     }\n }"}, {"sha": "18b6a1ef52a00da0bc94438095a2a9d2e378ad9e", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -290,7 +290,7 @@ impl<'self> AsciiStr for &'self [Ascii] {\n \n     #[inline]\n     fn eq_ignore_case(self, other: &[Ascii]) -> bool {\n-        do self.iter().zip(other.iter()).all |(&a, &b)| { a.eq_ignore_case(b) }\n+        self.iter().zip(other.iter()).all(|(&a, &b)| a.eq_ignore_case(b))\n     }\n }\n "}, {"sha": "2b105a3fa7d2375bf593740beeedecd7f2ba0f6d", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -56,24 +56,24 @@ pub fn build<A>(size: Option<uint>, builder: |push: |v: A||) -> @[A] {\n /// `lhs`. Afterwards, the `lhs` is then returned for use again.\n #[inline]\n pub fn append<T:Clone>(lhs: @[T], rhs: &[T]) -> @[T] {\n-    do build(Some(lhs.len() + rhs.len())) |push| {\n+    build(Some(lhs.len() + rhs.len()), |push| {\n         for x in lhs.iter() {\n             push((*x).clone());\n         }\n         for elt in rhs.iter() {\n             push(elt.clone());\n         }\n-    }\n+    })\n }\n \n \n /// Apply a function to each element of a vector and return the results\n pub fn map<T, U>(v: &[T], f: |x: &T| -> U) -> @[U] {\n-    do build(Some(v.len())) |push| {\n+    build(Some(v.len()), |push| {\n         for elem in v.iter() {\n             push(f(elem));\n         }\n-    }\n+    })\n }\n \n /**\n@@ -83,10 +83,10 @@ pub fn map<T, U>(v: &[T], f: |x: &T| -> U) -> @[U] {\n  * to the value returned by the function `op`.\n  */\n pub fn from_fn<T>(n_elts: uint, op: |uint| -> T) -> @[T] {\n-    do build(Some(n_elts)) |push| {\n+    build(Some(n_elts), |push| {\n         let mut i: uint = 0u;\n         while i < n_elts { push(op(i)); i += 1u; }\n-    }\n+    })\n }\n \n /**\n@@ -96,13 +96,13 @@ pub fn from_fn<T>(n_elts: uint, op: |uint| -> T) -> @[T] {\n  * to the value `t`.\n  */\n pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> @[T] {\n-    do build(Some(n_elts)) |push| {\n+    build(Some(n_elts), |push| {\n         let mut i: uint = 0u;\n         while i < n_elts {\n             push(t.clone());\n             i += 1u;\n         }\n-    }\n+    })\n }\n \n /**\n@@ -137,11 +137,11 @@ impl<T> Clone for @[T] {\n impl<A> FromIterator<A> for @[A] {\n     fn from_iterator<T: Iterator<A>>(iterator: &mut T) -> @[A] {\n         let (lower, _) = iterator.size_hint();\n-        do build(Some(lower)) |push| {\n+        build(Some(lower), |push| {\n             for x in *iterator {\n                 push(x);\n             }\n-        }\n+        })\n     }\n }\n \n@@ -259,9 +259,9 @@ pub mod raw {\n             use rt::local::Local;\n             use rt::task::Task;\n \n-            do Local::borrow |task: &mut Task| {\n+            Local::borrow(|task: &mut Task| {\n                 task.heap.realloc(ptr as *mut Box<()>, size) as *()\n-            }\n+            })\n         }\n     }\n \n@@ -295,11 +295,11 @@ mod test {\n     fn test() {\n         // Some code that could use that, then:\n         fn seq_range(lo: uint, hi: uint) -> @[uint] {\n-            do build(None) |push| {\n+            build(None, |push| {\n                 for i in range(lo, hi) {\n                     push(i);\n                 }\n-            }\n+            })\n         }\n \n         assert_eq!(seq_range(10, 15), @[10, 11, 12, 13, 14]);\n@@ -333,80 +333,80 @@ mod test {\n     #[bench]\n     fn bench_capacity(b: &mut bh) {\n         let x = @[1, 2, 3];\n-        do b.iter {\n-            capacity(x);\n-        }\n+        b.iter(|| {\n+            let _ = capacity(x);\n+        });\n     }\n \n     #[bench]\n     fn bench_build_sized(b: &mut bh) {\n         let len = 64;\n-        do b.iter {\n+        b.iter(|| {\n             build(Some(len), |push| for i in range(0, 1024) { push(i) });\n-        }\n+        });\n     }\n \n     #[bench]\n     fn bench_build(b: &mut bh) {\n-        do b.iter {\n+        b.iter(|| {\n             for i in range(0, 95) {\n                 build(None, |push| push(i));\n             }\n-        }\n+        });\n     }\n \n     #[bench]\n     fn bench_append(b: &mut bh) {\n         let lhs = @[7, ..128];\n         let rhs = range(0, 256).to_owned_vec();\n-        do b.iter {\n-            append(lhs, rhs);\n-        }\n+        b.iter(|| {\n+            let _ = append(lhs, rhs);\n+        })\n     }\n \n     #[bench]\n     fn bench_map(b: &mut bh) {\n         let elts = range(0, 256).to_owned_vec();\n-        do b.iter {\n-            map(elts, |x| x*2);\n-        }\n+        b.iter(|| {\n+            let _ = map(elts, |x| x*2);\n+        })\n     }\n \n     #[bench]\n     fn bench_from_fn(b: &mut bh) {\n-        do b.iter {\n-            from_fn(1024, |x| x);\n-        }\n+        b.iter(|| {\n+            let _ = from_fn(1024, |x| x);\n+        });\n     }\n \n     #[bench]\n     fn bench_from_elem(b: &mut bh) {\n-        do b.iter {\n-            from_elem(1024, 0u64);\n-        }\n+        b.iter(|| {\n+            let _ = from_elem(1024, 0u64);\n+        });\n     }\n \n     #[bench]\n     fn bench_to_managed_move(b: &mut bh) {\n-        do b.iter {\n+        b.iter(|| {\n             let elts = range(0, 1024).to_owned_vec(); // yikes! can't move out of capture, though\n             to_managed_move(elts);\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_to_managed(b: &mut bh) {\n         let elts = range(0, 1024).to_owned_vec();\n-        do b.iter {\n-            to_managed(elts);\n-        }\n+        b.iter(|| {\n+            let _ = to_managed(elts);\n+        });\n     }\n \n     #[bench]\n     fn bench_clone(b: &mut bh) {\n         let elts = to_managed(range(0, 1024).to_owned_vec());\n-        do b.iter {\n-            elts.clone();\n-        }\n+        b.iter(|| {\n+            let _ = elts.clone();\n+        });\n     }\n }"}, {"sha": "29c304f9ac539a3d12bb63c93bba8764d0028c60", "filename": "src/libstd/bool.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbool.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -53,9 +53,9 @@ use num::FromPrimitive;\n /// # Examples\n ///\n /// ```\n-/// do std::bool::all_values |x: bool| {\n+/// std::bool::all_values(|x: bool| {\n ///     println(x.to_str());\n-/// }\n+/// })\n /// ```\n #[inline]\n pub fn all_values(blk: |v: bool|) {\n@@ -396,9 +396,9 @@ mod tests {\n \n     #[test]\n     fn test_bool_from_str() {\n-        do all_values |v| {\n+        all_values(|v| {\n             assert!(Some(v) == FromStr::from_str(v.to_str()))\n-        }\n+        });\n     }\n \n     #[test]\n@@ -409,11 +409,11 @@ mod tests {\n \n     #[test]\n     fn test_bool_to_bit() {\n-        do all_values |v| {\n+        all_values(|v| {\n             assert_eq!(v.to_bit::<u8>(), if v { 1u8 } else { 0u8 });\n             assert_eq!(v.to_bit::<uint>(), if v { 1u } else { 0u });\n             assert_eq!(v.to_bit::<int>(), if v { 1i } else { 0i });\n-        }\n+        });\n     }\n \n     #[test]"}, {"sha": "306ee331929bb70bc95eb1e47b40ab8a8b552938", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 42, "deletions": 54, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -49,15 +49,15 @@ let my_string = \"Hello, world!\";\n // Allocate the C string with an explicit local that owns the string. The\n // `c_buffer` pointer will be deallocated when `my_c_string` goes out of scope.\n let my_c_string = my_string.to_c_str();\n-do my_c_string.with_ref |c_buffer| {\n+my_c_string.with_ref(|c_buffer| {\n     unsafe { puts(c_buffer); }\n-}\n+})\n \n // Don't save off the allocation of the C string, the `c_buffer` will be\n // deallocated when this block returns!\n-do my_string.with_c_str |c_buffer| {\n+my_string.with_c_str(|c_buffer| {\n     unsafe { puts(c_buffer); }\n-}\n+})\n  ```\n \n */\n@@ -262,14 +262,12 @@ static BUF_LEN: uint = 128;\n impl<'self> ToCStr for &'self [u8] {\n     fn to_c_str(&self) -> CString {\n         let mut cs = unsafe { self.to_c_str_unchecked() };\n-        do cs.with_mut_ref |buf| {\n-            check_for_null(*self, buf);\n-        }\n+        cs.with_mut_ref(|buf| check_for_null(*self, buf));\n         cs\n     }\n \n     unsafe fn to_c_str_unchecked(&self) -> CString {\n-        do self.as_imm_buf |self_buf, self_len| {\n+        self.as_imm_buf(|self_buf, self_len| {\n             let buf = libc::malloc(self_len as libc::size_t + 1) as *mut u8;\n             if buf.is_null() {\n                 fail!(\"failed to allocate memory!\");\n@@ -279,7 +277,7 @@ impl<'self> ToCStr for &'self [u8] {\n             *ptr::mut_offset(buf, self_len as int) = 0;\n \n             CString::new(buf as *libc::c_char, true)\n-        }\n+        })\n     }\n \n     fn with_c_str<T>(&self, f: |*libc::c_char| -> T) -> T {\n@@ -298,13 +296,13 @@ unsafe fn with_c_str<T>(v: &[u8], checked: bool, f: |*libc::c_char| -> T) -> T {\n         vec::bytes::copy_memory(buf, v, v.len());\n         buf[v.len()] = 0;\n \n-        do buf.as_mut_buf |buf, _| {\n+        buf.as_mut_buf(|buf, _| {\n             if checked {\n                 check_for_null(v, buf as *mut libc::c_char);\n             }\n \n             f(buf as *libc::c_char)\n-        }\n+        })\n     } else if checked {\n         v.to_c_str().with_ref(f)\n     } else {\n@@ -390,24 +388,24 @@ mod tests {\n             let ptr = vec::raw::to_ptr(input);\n             let expected = [\"zero\", \"one\"];\n             let mut it = expected.iter();\n-            let result = do from_c_multistring(ptr as *libc::c_char, None) |c| {\n+            let result = from_c_multistring(ptr as *libc::c_char, None, |c| {\n                 let cbytes = c.as_bytes().slice_to(c.len());\n                 assert_eq!(cbytes, it.next().unwrap().as_bytes());\n-            };\n+            });\n             assert_eq!(result, 2);\n             assert!(it.next().is_none());\n         }\n     }\n \n     #[test]\n     fn test_str_to_c_str() {\n-        do \"\".to_c_str().with_ref |buf| {\n+        \"\".to_c_str().with_ref(|buf| {\n             unsafe {\n                 assert_eq!(*ptr::offset(buf, 0), 0);\n             }\n-        }\n+        });\n \n-        do \"hello\".to_c_str().with_ref |buf| {\n+        \"hello\".to_c_str().with_ref(|buf| {\n             unsafe {\n                 assert_eq!(*ptr::offset(buf, 0), 'h' as libc::c_char);\n                 assert_eq!(*ptr::offset(buf, 1), 'e' as libc::c_char);\n@@ -416,19 +414,19 @@ mod tests {\n                 assert_eq!(*ptr::offset(buf, 4), 'o' as libc::c_char);\n                 assert_eq!(*ptr::offset(buf, 5), 0);\n             }\n-        }\n+        })\n     }\n \n     #[test]\n     fn test_vec_to_c_str() {\n         let b: &[u8] = [];\n-        do b.to_c_str().with_ref |buf| {\n+        b.to_c_str().with_ref(|buf| {\n             unsafe {\n                 assert_eq!(*ptr::offset(buf, 0), 0);\n             }\n-        }\n+        });\n \n-        do bytes!(\"hello\").to_c_str().with_ref |buf| {\n+        let _ = bytes!(\"hello\").to_c_str().with_ref(|buf| {\n             unsafe {\n                 assert_eq!(*ptr::offset(buf, 0), 'h' as libc::c_char);\n                 assert_eq!(*ptr::offset(buf, 1), 'e' as libc::c_char);\n@@ -437,17 +435,17 @@ mod tests {\n                 assert_eq!(*ptr::offset(buf, 4), 'o' as libc::c_char);\n                 assert_eq!(*ptr::offset(buf, 5), 0);\n             }\n-        }\n+        });\n \n-        do bytes!(\"foo\", 0xff).to_c_str().with_ref |buf| {\n+        let _ = bytes!(\"foo\", 0xff).to_c_str().with_ref(|buf| {\n             unsafe {\n                 assert_eq!(*ptr::offset(buf, 0), 'f' as libc::c_char);\n                 assert_eq!(*ptr::offset(buf, 1), 'o' as libc::c_char);\n                 assert_eq!(*ptr::offset(buf, 2), 'o' as libc::c_char);\n                 assert_eq!(*ptr::offset(buf, 3), 0xff);\n                 assert_eq!(*ptr::offset(buf, 4), 0);\n             }\n-        }\n+        });\n     }\n \n     #[test]\n@@ -500,18 +498,16 @@ mod tests {\n         use c_str::null_byte::cond;\n \n         let mut error_happened = false;\n-        do cond.trap(|err| {\n+        cond.trap(|err| {\n             assert_eq!(err, bytes!(\"he\", 0, \"llo\").to_owned())\n             error_happened = true;\n             Truncate\n-        }).inside {\n-            \"he\\x00llo\".to_c_str()\n-        };\n+        }).inside(|| \"he\\x00llo\".to_c_str());\n         assert!(error_happened);\n \n-        do cond.trap(|_| {\n+        cond.trap(|_| {\n             ReplaceWith('?' as libc::c_char)\n-        }).inside(|| \"he\\x00llo\".to_c_str()).with_ref |buf| {\n+        }).inside(|| \"he\\x00llo\".to_c_str()).with_ref(|buf| {\n             unsafe {\n                 assert_eq!(*buf.offset(0), 'h' as libc::c_char);\n                 assert_eq!(*buf.offset(1), 'e' as libc::c_char);\n@@ -521,21 +517,21 @@ mod tests {\n                 assert_eq!(*buf.offset(5), 'o' as libc::c_char);\n                 assert_eq!(*buf.offset(6), 0);\n             }\n-        }\n+        })\n     }\n \n     #[test]\n     fn test_to_c_str_unchecked() {\n         unsafe {\n-            do \"he\\x00llo\".to_c_str_unchecked().with_ref |buf| {\n+            \"he\\x00llo\".to_c_str_unchecked().with_ref(|buf| {\n                 assert_eq!(*buf.offset(0), 'h' as libc::c_char);\n                 assert_eq!(*buf.offset(1), 'e' as libc::c_char);\n                 assert_eq!(*buf.offset(2), 0);\n                 assert_eq!(*buf.offset(3), 'l' as libc::c_char);\n                 assert_eq!(*buf.offset(4), 'l' as libc::c_char);\n                 assert_eq!(*buf.offset(5), 'o' as libc::c_char);\n                 assert_eq!(*buf.offset(6), 0);\n-            }\n+            })\n         }\n     }\n \n@@ -579,15 +575,15 @@ mod bench {\n \n     #[inline]\n     fn check(s: &str, c_str: *libc::c_char) {\n-        do s.as_imm_buf |s_buf, s_len| {\n+        s.as_imm_buf(|s_buf, s_len| {\n             for i in range(0, s_len) {\n                 unsafe {\n                     assert_eq!(\n                         *ptr::offset(s_buf, i as int) as libc::c_char,\n                         *ptr::offset(c_str, i as int));\n                 }\n             }\n-        }\n+        })\n     }\n \n     static s_short: &'static str = \"Mary\";\n@@ -601,12 +597,10 @@ mod bench {\n         Mary had a little lamb, Little lamb\";\n \n     fn bench_to_str(bh: &mut BenchHarness, s: &str) {\n-        do bh.iter {\n+        bh.iter(|| {\n             let c_str = s.to_c_str();\n-            do c_str.with_ref |c_str_buf| {\n-                check(s, c_str_buf)\n-            }\n-        }\n+            c_str.with_ref(|c_str_buf| check(s, c_str_buf))\n+        })\n     }\n \n     #[bench]\n@@ -625,12 +619,10 @@ mod bench {\n     }\n \n     fn bench_to_c_str_unchecked(bh: &mut BenchHarness, s: &str) {\n-        do bh.iter {\n+        bh.iter(|| {\n             let c_str = unsafe { s.to_c_str_unchecked() };\n-            do c_str.with_ref |c_str_buf| {\n-                check(s, c_str_buf)\n-            }\n-        }\n+            c_str.with_ref(|c_str_buf| check(s, c_str_buf))\n+        })\n     }\n \n     #[bench]\n@@ -649,11 +641,9 @@ mod bench {\n     }\n \n     fn bench_with_c_str(bh: &mut BenchHarness, s: &str) {\n-        do bh.iter {\n-            do s.with_c_str |c_str_buf| {\n-                check(s, c_str_buf)\n-            }\n-        }\n+        bh.iter(|| {\n+            s.with_c_str(|c_str_buf| check(s, c_str_buf))\n+        })\n     }\n \n     #[bench]\n@@ -672,13 +662,11 @@ mod bench {\n     }\n \n     fn bench_with_c_str_unchecked(bh: &mut BenchHarness, s: &str) {\n-        do bh.iter {\n+        bh.iter(|| {\n             unsafe {\n-                do s.with_c_str_unchecked |c_str_buf| {\n-                    check(s, c_str_buf)\n-                }\n+                s.with_c_str_unchecked(|c_str_buf| check(s, c_str_buf))\n             }\n-        }\n+        })\n     }\n \n     #[bench]"}, {"sha": "b372993e3e50665d6040b63d66c964c2aae2e434", "filename": "src/libstd/char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -532,7 +532,7 @@ fn test_is_digit() {\n fn test_escape_default() {\n     fn string(c: char) -> ~str {\n         let mut result = ~\"\";\n-        do escape_default(c) |c| { result.push_char(c); }\n+        escape_default(c, |c| { result.push_char(c); });\n         return result;\n     }\n     assert_eq!(string('\\n'), ~\"\\\\n\");\n@@ -554,7 +554,7 @@ fn test_escape_default() {\n fn test_escape_unicode() {\n     fn string(c: char) -> ~str {\n         let mut result = ~\"\";\n-        do escape_unicode(c) |c| { result.push_char(c); }\n+        escape_unicode(c, |c| { result.push_char(c); });\n         return result;\n     }\n     assert_eq!(string('\\x00'), ~\"\\\\x00\");"}, {"sha": "7c972ed86b4ddbc37feb3ecefd18d006db142176", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -15,7 +15,7 @@ use ptr;\n use unstable::intrinsics::TyDesc;\n use unstable::raw;\n \n-type DropGlue<'self> = &'self fn(**TyDesc, *c_void);\n+type DropGlue<'self> = 'self |**TyDesc, *c_void|;\n \n /*\n  * Box annihilation\n@@ -82,45 +82,45 @@ pub unsafe fn annihilate() {\n     //\n     // In this pass, nothing gets freed, so it does not matter whether\n     // we read the next field before or after the callback.\n-    do each_live_alloc(true) |box, uniq| {\n+    each_live_alloc(true, |box, uniq| {\n         stats.n_total_boxes += 1;\n         if uniq {\n             stats.n_unique_boxes += 1;\n         } else {\n             (*box).ref_count = managed::RC_IMMORTAL;\n         }\n         true\n-    };\n+    });\n \n     // Pass 2: Drop all boxes.\n     //\n     // In this pass, unique-managed boxes may get freed, but not\n     // managed boxes, so we must read the `next` field *after* the\n     // callback, as the original value may have been freed.\n-    do each_live_alloc(false) |box, uniq| {\n+    each_live_alloc(false, |box, uniq| {\n         if !uniq {\n             let tydesc = (*box).type_desc;\n             let data = &(*box).data as *();\n             ((*tydesc).drop_glue)(data as *i8);\n         }\n         true\n-    };\n+    });\n \n     // Pass 3: Free all boxes.\n     //\n     // In this pass, managed boxes may get freed (but not\n     // unique-managed boxes, though I think that none of those are\n     // left), so we must read the `next` field before, since it will\n     // not be valid after.\n-    do each_live_alloc(true) |box, uniq| {\n+    each_live_alloc(true, |box, uniq| {\n         if !uniq {\n             stats.n_bytes_freed +=\n                 (*((*box).type_desc)).size\n                 + mem::size_of::<raw::Box<()>>();\n             local_free(box as *i8);\n         }\n         true\n-    };\n+    });\n \n     if debug_mem() {\n         // We do logging here w/o allocation."}, {"sha": "e34e94ac10cc5e651866567116e11560f00aab02", "filename": "src/libstd/condition.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcondition.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -30,14 +30,14 @@ This macro declares an inner module called `my_error` with one static variable,\n parameters are used for, an example usage of this condition would be:\n \n ```rust\n-do my_error::cond.trap(|raised_int| {\n+my_error::cond.trap(|raised_int| {\n \n     // the condition `my_error` was raised on, and the value it raised is stored\n     // in `raised_int`. This closure must return a `~str` type (as specified in\n     // the declaration of the condition\n     if raised_int == 3 { ~\"three\" } else { ~\"oh well\" }\n \n-}).inside {\n+}).inside(|| {\n \n     // The condition handler above is installed for the duration of this block.\n     // That handler will override any previous handler, but the previous handler\n@@ -50,7 +50,7 @@ do my_error::cond.trap(|raised_int| {\n     println(my_error::cond.raise(3)); // prints \"three\"\n     println(my_error::cond.raise(4)); // prints \"oh well\"\n \n-}\n+})\n  ```\n \n Condition handling is useful in cases where propagating errors is either to\n@@ -104,7 +104,7 @@ impl<T, U> Condition<T, U> {\n     /// // use `trap`'s inside method to register the handler and then run a\n     /// // block of code with the handler registered\n     /// ```\n-    pub fn trap<'a>(&'a self, h: &'a fn(T) -> U) -> Trap<'a, T, U> {\n+    pub fn trap<'a>(&'a self, h: 'a |T| -> U) -> Trap<'a, T, U> {\n         let h: Closure = unsafe { ::cast::transmute(h) };\n         let prev = local_data::get(self.key, |k| k.map(|x| *x));\n         let h = @Handler { handle: h, prev: prev };\n@@ -176,12 +176,12 @@ impl<'self, T, U> Trap<'self, T, U> {\n     /// ```rust\n     /// condition! { my_error: int -> int; }\n     ///\n-    /// let result = do my_error::cond.trap(|error| error + 3).inside {\n+    /// let result = my_error::cond.trap(|error| error + 3).inside(|| {\n     ///     my_error::cond.raise(4)\n-    /// };\n+    /// });\n     /// assert_eq!(result, 7);\n     /// ```\n-    pub fn inside<V>(&self, inner: &'self fn() -> V) -> V {\n+    pub fn inside<V>(&self, inner: 'self || -> V) -> V {\n         let _g = Guard { cond: self.cond };\n         debug!(\"Trap: pushing handler to TLS\");\n         local_data::set(self.cond.key, self.handler);\n@@ -224,14 +224,14 @@ mod test {\n     fn nested_trap_test_inner() {\n         let mut inner_trapped = false;\n \n-        do sadness::cond.trap(|_j| {\n+        sadness::cond.trap(|_j| {\n             debug!(\"nested_trap_test_inner: in handler\");\n             inner_trapped = true;\n             0\n-        }).inside {\n+        }).inside(|| {\n             debug!(\"nested_trap_test_inner: in protected block\");\n             trouble(1);\n-        }\n+        });\n \n         assert!(inner_trapped);\n     }\n@@ -240,31 +240,31 @@ mod test {\n     fn nested_trap_test_outer() {\n         let mut outer_trapped = false;\n \n-        do sadness::cond.trap(|_j| {\n+        sadness::cond.trap(|_j| {\n             debug!(\"nested_trap_test_outer: in handler\");\n             outer_trapped = true; 0\n-        }).inside {\n+        }).inside(|| {\n             debug!(\"nested_guard_test_outer: in protected block\");\n             nested_trap_test_inner();\n             trouble(1);\n-        }\n+        });\n \n         assert!(outer_trapped);\n     }\n \n     fn nested_reraise_trap_test_inner() {\n         let mut inner_trapped = false;\n \n-        do sadness::cond.trap(|_j| {\n+        sadness::cond.trap(|_j| {\n             debug!(\"nested_reraise_trap_test_inner: in handler\");\n             inner_trapped = true;\n             let i = 10;\n             debug!(\"nested_reraise_trap_test_inner: handler re-raising\");\n             sadness::cond.raise(i)\n-        }).inside {\n+        }).inside(|| {\n             debug!(\"nested_reraise_trap_test_inner: in protected block\");\n             trouble(1);\n-        }\n+        });\n \n         assert!(inner_trapped);\n     }\n@@ -273,13 +273,13 @@ mod test {\n     fn nested_reraise_trap_test_outer() {\n         let mut outer_trapped = false;\n \n-        do sadness::cond.trap(|_j| {\n+        sadness::cond.trap(|_j| {\n             debug!(\"nested_reraise_trap_test_outer: in handler\");\n             outer_trapped = true; 0\n-        }).inside {\n+        }).inside(|| {\n             debug!(\"nested_reraise_trap_test_outer: in protected block\");\n             nested_reraise_trap_test_inner();\n-        }\n+        });\n \n         assert!(outer_trapped);\n     }\n@@ -288,13 +288,13 @@ mod test {\n     fn test_default() {\n         let mut trapped = false;\n \n-        do sadness::cond.trap(|j| {\n+        sadness::cond.trap(|j| {\n             debug!(\"test_default: in handler\");\n             sadness::cond.raise_default(j, || { trapped=true; 5 })\n-        }).inside {\n+        }).inside(|| {\n             debug!(\"test_default: in protected block\");\n             trouble(1);\n-        }\n+        });\n \n         assert!(trapped);\n     }\n@@ -312,12 +312,12 @@ mod test {\n             #[test]\n             fn test_conditions_are_public() {\n                 let mut trapped = false;\n-                do sadness::cond.trap(|_| {\n+                sadness::cond.trap(|_| {\n                     trapped = true;\n                     0\n-                }).inside {\n+                }).inside(|| {\n                     sadness::cond.raise(0);\n-                }\n+                });\n                 assert!(trapped);\n             }\n         }"}, {"sha": "6d152d8c179a818fce9a97f9217d754c37790f56", "filename": "src/libstd/either.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -209,23 +209,23 @@ pub type Rights<L, R, Iter> = FilterMap<'static, Either<L, R>, R, Iter>;\n /// Extracts all the left values\n pub fn lefts<L, R, Iter: Iterator<Either<L, R>>>(eithers: Iter)\n     -> Lefts<L, R, Iter> {\n-    do eithers.filter_map |elt| {\n+    eithers.filter_map(|elt| {\n         match elt {\n             Left(x) => Some(x),\n             _ => None,\n         }\n-    }\n+    })\n }\n \n /// Extracts all the right values\n pub fn rights<L, R, Iter: Iterator<Either<L, R>>>(eithers: Iter)\n     -> Rights<L, R, Iter> {\n-    do eithers.filter_map |elt| {\n+    eithers.filter_map(|elt| {\n         match elt {\n             Right(x) => Some(x),\n             _ => None,\n         }\n-    }\n+    })\n }\n \n "}, {"sha": "33ef4731405fa7d76719c6b462c8aebaf5b0d8ba", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -801,12 +801,12 @@ impl<'self> Formatter<'self> {\n     }\n \n     fn runplural(&mut self, value: uint, pieces: &[rt::Piece]) {\n-        do ::uint::to_str_bytes(value, 10) |buf| {\n+        ::uint::to_str_bytes(value, 10, |buf| {\n             let valuestr = str::from_utf8_slice(buf);\n             for piece in pieces.iter() {\n                 self.run(piece, Some(valuestr));\n             }\n-        }\n+        })\n     }\n \n     // Helper methods used for padding and processing formatting arguments that\n@@ -868,9 +868,9 @@ impl<'self> Formatter<'self> {\n                     self.fill = '0';\n                     sign(self);\n                 }\n-                do self.with_padding(min - actual_len, parse::AlignRight) |me| {\n+                self.with_padding(min - actual_len, parse::AlignRight, |me| {\n                     emit(me);\n-                }\n+                })\n             }\n         }\n     }\n@@ -924,9 +924,9 @@ impl<'self> Formatter<'self> {\n             // If we're under both the maximum and the minimum width, then fill\n             // up the minimum width with the specified string + some alignment.\n             Some(width) => {\n-                do self.with_padding(width - s.len(), parse::AlignLeft) |me| {\n+                self.with_padding(width - s.len(), parse::AlignLeft, |me| {\n                     me.buf.write(s.as_bytes());\n-                }\n+                })\n             }\n         }\n     }\n@@ -1007,18 +1007,18 @@ macro_rules! int_base(($ty:ident, $into:ident, $base:expr,\n                        $name:ident, $prefix:expr) => {\n     impl $name for $ty {\n         fn fmt(c: &$ty, f: &mut Formatter) {\n-            do ::$into::to_str_bytes(*c as $into, $base) |buf| {\n+            ::$into::to_str_bytes(*c as $into, $base, |buf| {\n                 f.pad_integral(buf, $prefix, true);\n-            }\n+            })\n         }\n     }\n })\n macro_rules! upper_hex(($ty:ident, $into:ident) => {\n     impl UpperHex for $ty {\n         fn fmt(c: &$ty, f: &mut Formatter) {\n-            do ::$into::to_str_bytes(*c as $into, 16) |buf| {\n+            ::$into::to_str_bytes(*c as $into, 16, |buf| {\n                 upperhex(buf, f);\n-            }\n+            })\n         }\n     }\n })\n@@ -1045,9 +1045,9 @@ macro_rules! integer(($signed:ident, $unsigned:ident) => {\n         // nothing else should do that, however.\n         impl Signed for $signed {\n             fn fmt(c: &$signed, f: &mut Formatter) {\n-                do ::$unsigned::to_str_bytes(c.abs() as $unsigned, 10) |buf| {\n+                ::$unsigned::to_str_bytes(c.abs() as $unsigned, 10, |buf| {\n                     f.pad_integral(buf, \"\", *c >= 0);\n-                }\n+                })\n             }\n         }\n         int_base!($signed, $unsigned, 2, Binary, \"0b\")\n@@ -1104,9 +1104,9 @@ impl<T> Poly for T {\n impl<T> Pointer for *T {\n     fn fmt(t: &*T, f: &mut Formatter) {\n         f.flags |= 1 << (parse::FlagAlternate as uint);\n-        do ::uint::to_str_bytes(*t as uint, 16) |buf| {\n+        ::uint::to_str_bytes(*t as uint, 16, |buf| {\n             f.pad_integral(buf, \"0x\", true);\n-        }\n+        })\n     }\n }\n impl<T> Pointer for *mut T {"}, {"sha": "d3bec8ca6c907c18fc2d75a414e7dd35839c3d92", "filename": "src/libstd/gc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgc.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -61,19 +61,19 @@ mod tests {\n     fn test_clone() {\n         let x = Gc::new(RefCell::new(5));\n         let y = x.clone();\n-        do x.borrow().with_mut |inner| {\n+        x.borrow().with_mut(|inner| {\n             *inner = 20;\n-        }\n+        });\n         assert_eq!(y.borrow().with(|x| *x), 20);\n     }\n \n     #[test]\n     fn test_deep_clone() {\n         let x = Gc::new(RefCell::new(5));\n         let y = x.deep_clone();\n-        do x.borrow().with_mut |inner| {\n+        x.borrow().with_mut(|inner| {\n             *inner = 20;\n-        }\n+        });\n         assert_eq!(y.borrow().with(|x| *x), 5);\n     }\n "}, {"sha": "5a671eea7a34851f1dfd99047ee6d882af52513f", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -83,44 +83,44 @@ impl<A:IterBytes> Hash for A {\n     #[inline]\n     fn hash_keyed(&self, k0: u64, k1: u64) -> u64 {\n         let mut s = State::new(k0, k1);\n-        do self.iter_bytes(true) |bytes| {\n+        self.iter_bytes(true, |bytes| {\n             s.input(bytes);\n             true\n-        };\n+        });\n         s.result_u64()\n     }\n }\n \n fn hash_keyed_2<A: IterBytes,\n                 B: IterBytes>(a: &A, b: &B, k0: u64, k1: u64) -> u64 {\n     let mut s = State::new(k0, k1);\n-    do a.iter_bytes(true) |bytes| {\n+    a.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n-    do b.iter_bytes(true) |bytes| {\n+    });\n+    b.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n+    });\n     s.result_u64()\n }\n \n fn hash_keyed_3<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes>(a: &A, b: &B, c: &C, k0: u64, k1: u64) -> u64 {\n     let mut s = State::new(k0, k1);\n-    do a.iter_bytes(true) |bytes| {\n+    a.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n-    do b.iter_bytes(true) |bytes| {\n+    });\n+    b.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n-    do c.iter_bytes(true) |bytes| {\n+    });\n+    c.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n+    });\n     s.result_u64()\n }\n \n@@ -136,22 +136,22 @@ fn hash_keyed_4<A: IterBytes,\n                 k1: u64)\n                 -> u64 {\n     let mut s = State::new(k0, k1);\n-    do a.iter_bytes(true) |bytes| {\n+    a.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n-    do b.iter_bytes(true) |bytes| {\n+    });\n+    b.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n-    do c.iter_bytes(true) |bytes| {\n+    });\n+    c.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n-    do d.iter_bytes(true) |bytes| {\n+    });\n+    d.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n+    });\n     s.result_u64()\n }\n \n@@ -169,26 +169,26 @@ fn hash_keyed_5<A: IterBytes,\n                 k1: u64)\n                 -> u64 {\n     let mut s = State::new(k0, k1);\n-    do a.iter_bytes(true) |bytes| {\n+    a.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n-    do b.iter_bytes(true) |bytes| {\n+    });\n+    b.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n-    do c.iter_bytes(true) |bytes| {\n+    });\n+    c.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n-    do d.iter_bytes(true) |bytes| {\n+    });\n+    d.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n-    do e.iter_bytes(true) |bytes| {\n+    });\n+    e.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n+    });\n     s.result_u64()\n }\n "}, {"sha": "a61871cbb5e277efca3e4a10ff55ada72c1fb408", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -110,15 +110,15 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n                                 k: &K)\n                              -> SearchResult {\n         let mut ret = TableFull;\n-        do self.bucket_sequence(hash) |i| {\n+        self.bucket_sequence(hash, |i| {\n             match self.buckets[i] {\n                 Some(ref bkt) if bkt.hash == hash && *k == bkt.key => {\n                     ret = FoundEntry(i); false\n                 },\n                 None => { ret = FoundHole(i); false }\n                 _ => true,\n             }\n-        };\n+        });\n         ret\n     }\n \n@@ -128,15 +128,15 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n                                                   k: &Q)\n                                                -> SearchResult {\n         let mut ret = TableFull;\n-        do self.bucket_sequence(hash) |i| {\n+        self.bucket_sequence(hash, |i| {\n             match self.buckets[i] {\n                 Some(ref bkt) if bkt.hash == hash && k.equiv(&bkt.key) => {\n                     ret = FoundEntry(i); false\n                 },\n                 None => { ret = FoundHole(i); false }\n                 _ => true,\n             }\n-        };\n+        });\n         ret\n     }\n \n@@ -236,9 +236,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n         let len_buckets = self.buckets.len();\n         let bucket = self.buckets[idx].take();\n \n-        let value = do bucket.map |bucket| {\n-            bucket.value\n-        };\n+        let value = bucket.map(|bucket| bucket.value);\n \n         /* re-inserting buckets may cause changes in size, so remember\n         what our new size is ahead of time before we start insertions */\n@@ -500,12 +498,12 @@ impl<K:Hash + Eq,V:Eq> Eq for HashMap<K, V> {\n     fn eq(&self, other: &HashMap<K, V>) -> bool {\n         if self.len() != other.len() { return false; }\n \n-        do self.iter().all |(key, value)| {\n+        self.iter().all(|(key, value)| {\n             match other.find(key) {\n                 None => false,\n                 Some(v) => value == v\n             }\n-        }\n+        })\n     }\n \n     fn ne(&self, other: &HashMap<K, V>) -> bool { !self.eq(other) }"}, {"sha": "8c1897339cbef9d7e11d977407bd24e6907fc2a4", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -438,22 +438,22 @@ mod test {\n \n     #[bench]\n     fn bench_buffered_reader(bh: &mut Harness) {\n-        do bh.iter {\n+        bh.iter(|| {\n             BufferedReader::new(NullStream);\n-        }\n+        });\n     }\n \n     #[bench]\n     fn bench_buffered_writer(bh: &mut Harness) {\n-        do bh.iter {\n+        bh.iter(|| {\n             BufferedWriter::new(NullStream);\n-        }\n+        });\n     }\n \n     #[bench]\n     fn bench_buffered_stream(bh: &mut Harness) {\n-        do bh.iter {\n+        bh.iter(|| {\n             BufferedStream::new(NullStream);\n-        }\n+        });\n     }\n }"}, {"sha": "564e664027f73ec32f1e5a9ae6e3812273cdf5cb", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -276,11 +276,11 @@ mod test {\n     #[test]\n     fn read_byte_error() {\n         let mut reader = ErroringReader;\n-        do io_error::cond.trap(|_| {\n-        }).inside {\n+        io_error::cond.trap(|_| {\n+        }).inside(|| {\n             let byte = reader.read_byte();\n             assert!(byte == None);\n-        }\n+        });\n     }\n \n     #[test]\n@@ -303,10 +303,10 @@ mod test {\n     fn bytes_error() {\n         let reader = ErroringReader;\n         let mut it = reader.bytes();\n-        do io_error::cond.trap(|_| ()).inside {\n+        io_error::cond.trap(|_| ()).inside(|| {\n             let byte = it.next();\n             assert!(byte == None);\n-        }\n+        })\n     }\n \n     #[test]\n@@ -328,10 +328,10 @@ mod test {\n     #[test]\n     fn read_bytes_eof() {\n         let mut reader = MemReader::new(~[10, 11]);\n-        do io_error::cond.trap(|_| {\n-        }).inside {\n+        io_error::cond.trap(|_| {\n+        }).inside(|| {\n             assert!(reader.read_bytes(4) == ~[10, 11]);\n-        }\n+        })\n     }\n \n     #[test]\n@@ -356,11 +356,11 @@ mod test {\n     fn push_bytes_eof() {\n         let mut reader = MemReader::new(~[10, 11]);\n         let mut buf = ~[8, 9];\n-        do io_error::cond.trap(|_| {\n-        }).inside {\n+        io_error::cond.trap(|_| {\n+        }).inside(|| {\n             reader.push_bytes(&mut buf, 4);\n             assert!(buf == ~[8, 9, 10, 11]);\n-        }\n+        })\n     }\n \n     #[test]\n@@ -369,9 +369,9 @@ mod test {\n             count: 0,\n         };\n         let mut buf = ~[8, 9];\n-        do io_error::cond.trap(|_| { } ).inside {\n+        io_error::cond.trap(|_| { } ).inside(|| {\n             reader.push_bytes(&mut buf, 4);\n-        }\n+        });\n         assert!(buf == ~[8, 9, 10]);\n     }\n \n@@ -384,13 +384,13 @@ mod test {\n             count: 0,\n         };\n         let buf = @mut ~[8, 9];\n-        do (|| {\n+        (|| {\n             reader.push_bytes(&mut *buf, 4);\n-        }).finally {\n+        }).finally(|| {\n             // NB: Using rtassert here to trigger abort on failure since this is a should_fail test\n             // FIXME: #7049 This fails because buf is still borrowed\n             //rtassert!(*buf == ~[8, 9, 10]);\n-        }\n+        })\n     }\n \n     #[test]"}, {"sha": "d1502df047e704ffa23d677fe120ce76eff1f563", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 25, "deletions": 43, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -76,15 +76,15 @@ pub struct File {\n }\n \n fn io_raise<T>(f: |io: &mut IoFactory| -> Result<T, IoError>) -> Option<T> {\n-    do with_local_io |io| {\n+    with_local_io(|io| {\n         match f(io) {\n             Ok(t) => Some(t),\n             Err(ioerr) => {\n                 io_error::cond.raise(ioerr);\n                 None\n             }\n         }\n-    }\n+    })\n }\n \n impl File {\n@@ -97,17 +97,17 @@ impl File {\n     ///\n     ///     let p = Path::new(\"/some/file/path.txt\");\n     ///\n-    ///     do io_error::cond.trap(|_| {\n+    ///     io_error::cond.trap(|_| {\n     ///         // hoo-boy...\n-    ///     }).inside {\n+    ///     }).inside(|| {\n     ///         let file = match File::open_mode(&p, Open, ReadWrite) {\n     ///             Some(s) => s,\n     ///             None => fail!(\"whoops! I'm sure this raised, anyways..\")\n     ///         };\n     ///         // do some stuff with that file\n     ///\n     ///         // the file will be closed at the end of this block\n-    ///     }\n+    ///     })\n     ///     // ..\n     ///\n     /// `FileMode` and `FileAccess` provide information about the permissions\n@@ -132,7 +132,7 @@ impl File {\n     pub fn open_mode(path: &Path,\n                      mode: FileMode,\n                      access: FileAccess) -> Option<File> {\n-        do with_local_io |io| {\n+        with_local_io(|io| {\n             match io.fs_open(&path.to_c_str(), mode, access) {\n                 Ok(fd) => Some(File {\n                     path: path.clone(),\n@@ -144,7 +144,7 @@ impl File {\n                     None\n                 }\n             }\n-        }\n+        })\n     }\n \n     /// Attempts to open a file in read-only mode. This function is equivalent to\n@@ -244,7 +244,7 @@ impl File {\n /// directory, the user lacks permissions to remove the file, or if some\n /// other filesystem-level error occurs.\n pub fn unlink(path: &Path) {\n-    do io_raise |io| { io.fs_unlink(&path.to_c_str()) };\n+    io_raise(|io| io.fs_unlink(&path.to_c_str()));\n }\n \n /// Given a path, query the file system to get information about a file,\n@@ -272,9 +272,7 @@ pub fn unlink(path: &Path) {\n /// requisite permissions to perform a `stat` call on the given path or if\n /// there is no entry in the filesystem at the provided path.\n pub fn stat(path: &Path) -> FileStat {\n-    do io_raise |io| {\n-        io.fs_stat(&path.to_c_str())\n-    }.unwrap_or_else(dummystat)\n+    io_raise(|io| io.fs_stat(&path.to_c_str())).unwrap_or_else(dummystat)\n }\n \n fn dummystat() -> FileStat {\n@@ -310,9 +308,7 @@ fn dummystat() -> FileStat {\n ///\n /// See `stat`\n pub fn lstat(path: &Path) -> FileStat {\n-    do io_raise |io| {\n-        io.fs_lstat(&path.to_c_str())\n-    }.unwrap_or_else(dummystat)\n+    io_raise(|io| io.fs_lstat(&path.to_c_str())).unwrap_or_else(dummystat)\n }\n \n /// Rename a file or directory to a new name.\n@@ -330,9 +326,7 @@ pub fn lstat(path: &Path) -> FileStat {\n /// the process lacks permissions to view the contents, or if some other\n /// intermittent I/O error occurs.\n pub fn rename(from: &Path, to: &Path) {\n-    do io_raise |io| {\n-        io.fs_rename(&from.to_c_str(), &to.to_c_str())\n-    };\n+    io_raise(|io| io.fs_rename(&from.to_c_str(), &to.to_c_str()));\n }\n \n /// Copies the contents of one file to another. This function will also\n@@ -403,9 +397,7 @@ pub fn copy(from: &Path, to: &Path) {\n /// condition. Some possible error situations are not having the permission to\n /// change the attributes of a file or the file not existing.\n pub fn chmod(path: &Path, mode: io::FilePermission) {\n-    do io_raise |io| {\n-        io.fs_chmod(&path.to_c_str(), mode)\n-    };\n+    io_raise(|io| io.fs_chmod(&path.to_c_str(), mode));\n }\n \n /// Change the user and group owners of a file at the specified path.\n@@ -414,7 +406,7 @@ pub fn chmod(path: &Path, mode: io::FilePermission) {\n ///\n /// This funtion will raise on the `io_error` condition on failure.\n pub fn chown(path: &Path, uid: int, gid: int) {\n-    do io_raise |io| { io.fs_chown(&path.to_c_str(), uid, gid) };\n+    io_raise(|io| io.fs_chown(&path.to_c_str(), uid, gid));\n }\n \n /// Creates a new hard link on the filesystem. The `dst` path will be a\n@@ -425,7 +417,7 @@ pub fn chown(path: &Path, uid: int, gid: int) {\n ///\n /// This function will raise on the `io_error` condition on failure.\n pub fn link(src: &Path, dst: &Path) {\n-    do io_raise |io| { io.fs_link(&src.to_c_str(), &dst.to_c_str()) };\n+    io_raise(|io| io.fs_link(&src.to_c_str(), &dst.to_c_str()));\n }\n \n /// Creates a new symbolic link on the filesystem. The `dst` path will be a\n@@ -435,7 +427,7 @@ pub fn link(src: &Path, dst: &Path) {\n ///\n /// This function will raise on the `io_error` condition on failure.\n pub fn symlink(src: &Path, dst: &Path) {\n-    do io_raise |io| { io.fs_symlink(&src.to_c_str(), &dst.to_c_str()) };\n+    io_raise(|io| io.fs_symlink(&src.to_c_str(), &dst.to_c_str()));\n }\n \n /// Reads a symlink, returning the file that the symlink points to.\n@@ -446,7 +438,7 @@ pub fn symlink(src: &Path, dst: &Path) {\n /// conditions include reading a file that does not exist or reading a file\n /// which is not a symlink.\n pub fn readlink(path: &Path) -> Option<Path> {\n-    do io_raise |io| { io.fs_readlink(&path.to_c_str()) }\n+    io_raise(|io| io.fs_readlink(&path.to_c_str()))\n }\n \n /// Create a new, empty directory at the provided path\n@@ -466,9 +458,7 @@ pub fn readlink(path: &Path) -> Option<Path> {\n /// to make a new directory at the provided path, or if the directory already\n /// exists.\n pub fn mkdir(path: &Path, mode: FilePermission) {\n-    do io_raise |io| {\n-        io.fs_mkdir(&path.to_c_str(), mode)\n-    };\n+    io_raise(|io| io.fs_mkdir(&path.to_c_str(), mode));\n }\n \n /// Remove an existing, empty directory\n@@ -487,9 +477,7 @@ pub fn mkdir(path: &Path, mode: FilePermission) {\n /// to remove the directory at the provided path, or if the directory isn't\n /// empty.\n pub fn rmdir(path: &Path) {\n-    do io_raise |io| {\n-        io.fs_rmdir(&path.to_c_str())\n-    };\n+    io_raise(|io| io.fs_rmdir(&path.to_c_str()));\n }\n \n /// Retrieve a vector containing all entries within a provided directory\n@@ -516,9 +504,7 @@ pub fn rmdir(path: &Path) {\n /// the process lacks permissions to view the contents or if the `path` points\n /// at a non-directory file\n pub fn readdir(path: &Path) -> ~[Path] {\n-    do io_raise |io| {\n-        io.fs_readdir(&path.to_c_str(), 0)\n-    }.unwrap_or_else(|| ~[])\n+    io_raise(|io| io.fs_readdir(&path.to_c_str(), 0)).unwrap_or_else(|| ~[])\n }\n \n /// Returns an iterator which will recursively walk the directory structure\n@@ -599,9 +585,7 @@ pub fn rmdir_recursive(path: &Path) {\n /// happens.\n // FIXME(#10301) these arguments should not be u64\n pub fn change_file_times(path: &Path, atime: u64, mtime: u64) {\n-    do io_raise |io| {\n-        io.fs_utime(&path.to_c_str(), atime, mtime)\n-    };\n+    io_raise(|io| io.fs_utime(&path.to_c_str(), atime, mtime));\n }\n \n impl Reader for File {\n@@ -797,24 +781,22 @@ mod test {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_that_does_not_exist.txt\");\n         let mut called = false;\n-        do io_error::cond.trap(|_| {\n+        io_error::cond.trap(|_| {\n             called = true;\n-        }).inside {\n+        }).inside(|| {\n             let result = File::open_mode(filename, Open, Read);\n             assert!(result.is_none());\n-        }\n+        });\n         assert!(called);\n     })\n \n     test!(fn file_test_iounlinking_invalid_path_should_raise_condition() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_another_file_that_does_not_exist.txt\");\n         let mut called = false;\n-        do io_error::cond.trap(|_| {\n+        io_error::cond.trap(|_| {\n             called = true;\n-        }).inside {\n-            unlink(filename);\n-        }\n+        }).inside(|| unlink(filename));\n         assert!(called);\n     })\n "}, {"sha": "b08f4af9a54c6c3db981e1801ab8fecbb355429d", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -331,12 +331,12 @@ mod test {\n         writer.write([0]);\n \n         let mut called = false;\n-        do io_error::cond.trap(|err| {\n+        io_error::cond.trap(|err| {\n             assert_eq!(err.kind, OtherIoError);\n             called = true;\n-        }).inside {\n+        }).inside(|| {\n             writer.write([0, 0]);\n-        }\n+        });\n         assert!(called);\n     }\n "}, {"sha": "8cc4e7b389b46075fe4b4010dc9aef7e3fe3a9b4", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -40,9 +40,9 @@ Some examples of obvious things you might want to do\n \n * Iterate over the lines of a file\n \n-    do File::open(\"message.txt\").each_line |line| {\n+    File::open(\"message.txt\").each_line(|line| {\n         println(line)\n-    }\n+    })\n \n * Pull the lines of a file into a vector of strings\n \n@@ -395,13 +395,11 @@ condition! {\n /// Helper for wrapper calls where you want to\n /// ignore any io_errors that might be raised\n pub fn ignore_io_error<T>(cb: || -> T) -> T {\n-    do io_error::cond.trap(|_| {\n+    io_error::cond.trap(|_| {\n         // just swallow the error.. downstream users\n         // who can make a decision based on a None result\n         // won't care\n-    }).inside {\n-        cb()\n-    }\n+    }).inside(|| cb())\n }\n \n /// Helper for catching an I/O error and wrapping it in a Result object. The\n@@ -501,7 +499,7 @@ pub trait Reader {\n             buf.reserve_additional(len);\n             vec::raw::set_len(buf, start_len + len);\n \n-            do (|| {\n+            (|| {\n                 while total_read < len {\n                     let len = buf.len();\n                     let slice = buf.mut_slice(start_len + total_read, len);\n@@ -515,9 +513,7 @@ pub trait Reader {\n                         }\n                     }\n                 }\n-            }).finally {\n-                vec::raw::set_len(buf, start_len + total_read);\n-            }\n+            }).finally(|| vec::raw::set_len(buf, start_len + total_read))\n         }\n     }\n \n@@ -542,17 +538,17 @@ pub trait Reader {\n     fn read_to_end(&mut self) -> ~[u8] {\n         let mut buf = vec::with_capacity(DEFAULT_BUF_SIZE);\n         let mut keep_reading = true;\n-        do io_error::cond.trap(|e| {\n+        io_error::cond.trap(|e| {\n             if e.kind == EndOfFile {\n                 keep_reading = false;\n             } else {\n                 io_error::cond.raise(e)\n             }\n-        }).inside {\n+        }).inside(|| {\n             while keep_reading {\n                 self.push_bytes(&mut buf, DEFAULT_BUF_SIZE)\n             }\n-        }\n+        });\n         return buf;\n     }\n "}, {"sha": "9dd6daf66e9489056a3c8929066d45f13521c3cc", "filename": "src/libstd/io/native/file.rs", "status": "modified", "additions": 39, "deletions": 45, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnative%2Ffile.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -37,7 +37,7 @@ fn keep_going(data: &[u8], f: |*u8, uint| -> i64) -> i64 {\n     #[cfg(windows)] static eintr: int = 0; // doesn't matter\n     #[cfg(not(windows))] static eintr: int = libc::EINTR as int;\n \n-    let (data, origamt) = do data.as_imm_buf |data, amt| { (data, amt) };\n+    let (data, origamt) = data.as_imm_buf(|data, amt| (data, amt));\n     let mut data = data;\n     let mut amt = origamt;\n     while amt > 0 {\n@@ -83,11 +83,11 @@ impl FileDesc {\n     fn inner_read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n         #[cfg(windows)] type rlen = libc::c_uint;\n         #[cfg(not(windows))] type rlen = libc::size_t;\n-        let ret = do keep_going(buf) |buf, len| {\n+        let ret = keep_going(buf, |buf, len| {\n             unsafe {\n                 libc::read(self.fd, buf as *mut libc::c_void, len as rlen) as i64\n             }\n-        };\n+        });\n         if ret == 0 {\n             Err(io::standard_error(io::EndOfFile))\n         } else if ret < 0 {\n@@ -99,11 +99,11 @@ impl FileDesc {\n     fn inner_write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n         #[cfg(windows)] type wlen = libc::c_uint;\n         #[cfg(not(windows))] type wlen = libc::size_t;\n-        let ret = do keep_going(buf) |buf, len| {\n+        let ret = keep_going(buf, |buf, len| {\n             unsafe {\n                 libc::write(self.fd, buf as *libc::c_void, len as wlen) as i64\n             }\n-        };\n+        });\n         if ret < 0 {\n             Err(super::last_error())\n         } else {\n@@ -344,12 +344,12 @@ impl CFile {\n \n impl rtio::RtioFileStream for CFile {\n     fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n-        let ret = do keep_going(buf) |buf, len| {\n+        let ret = keep_going(buf, |buf, len| {\n             unsafe {\n                 libc::fread(buf as *mut libc::c_void, 1, len as libc::size_t,\n                             self.file) as i64\n             }\n-        };\n+        });\n         if ret == 0 {\n             Err(io::standard_error(io::EndOfFile))\n         } else if ret < 0 {\n@@ -360,12 +360,12 @@ impl rtio::RtioFileStream for CFile {\n     }\n \n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        let ret = do keep_going(buf) |buf, len| {\n+        let ret = keep_going(buf, |buf, len| {\n             unsafe {\n                 libc::fwrite(buf as *libc::c_void, 1, len as libc::size_t,\n                             self.file) as i64\n             }\n-        };\n+        });\n         if ret < 0 {\n             Err(super::last_error())\n         } else {\n@@ -445,9 +445,9 @@ pub fn open(path: &CString, fm: io::FileMode, fa: io::FileAccess)\n \n     #[cfg(windows)]\n     fn os_open(path: &CString, flags: c_int, mode: c_int) -> c_int {\n-        do as_utf16_p(path.as_str().unwrap()) |path| {\n+        as_utf16_p(path.as_str().unwrap(), |path| {\n             unsafe { libc::wopen(path, flags, mode) }\n-        }\n+        })\n     }\n \n     #[cfg(unix)]\n@@ -463,9 +463,9 @@ pub fn mkdir(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n     fn os_mkdir(p: &CString, _mode: c_int) -> IoResult<()> {\n         super::mkerr_winbool(unsafe {\n             // FIXME: turn mode into something useful? #2623\n-            do as_utf16_p(p.as_str().unwrap()) |buf| {\n+            as_utf16_p(p.as_str().unwrap(), |buf| {\n                 libc::CreateDirectoryW(buf, ptr::mut_null())\n-            }\n+            })\n         })\n     }\n \n@@ -497,9 +497,7 @@ pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n             }\n             debug!(\"os::list_dir -- BEFORE OPENDIR\");\n \n-            let dir_ptr = do p.with_ref |buf| {\n-                opendir(buf)\n-            };\n+            let dir_ptr = p.with_ref(|buf| opendir(buf));\n \n             if (dir_ptr as uint != 0) {\n                 let mut paths = ~[];\n@@ -540,7 +538,7 @@ pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n             let p = CString::new(p.with_ref(|p| p), false);\n             let p = Path::new(p);\n             let star = p.join(\"*\");\n-            do as_utf16_p(star.as_str().unwrap()) |path_ptr| {\n+            as_utf16_p(star.as_str().unwrap(), |path_ptr| {\n                 let wfd_ptr = malloc_raw(rust_list_dir_wfd_size() as uint);\n                 let find_handle = FindFirstFileW(path_ptr, wfd_ptr as HANDLE);\n                 if find_handle as libc::c_int != INVALID_HANDLE_VALUE {\n@@ -565,7 +563,7 @@ pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n                 } else {\n                     Err(super::last_error())\n                 }\n-            }\n+            })\n         }\n \n         get_list(p).map(|paths| prune(p, paths))\n@@ -578,9 +576,9 @@ pub fn unlink(p: &CString) -> IoResult<()> {\n     #[cfg(windows)]\n     fn os_unlink(p: &CString) -> IoResult<()> {\n         super::mkerr_winbool(unsafe {\n-            do as_utf16_p(p.as_str().unwrap()) |buf| {\n+            as_utf16_p(p.as_str().unwrap(), |buf| {\n                 libc::DeleteFileW(buf)\n-            }\n+            })\n         })\n     }\n \n@@ -596,11 +594,11 @@ pub fn rename(old: &CString, new: &CString) -> IoResult<()> {\n     #[cfg(windows)]\n     fn os_rename(old: &CString, new: &CString) -> IoResult<()> {\n         super::mkerr_winbool(unsafe {\n-            do as_utf16_p(old.as_str().unwrap()) |old| {\n-                do as_utf16_p(new.as_str().unwrap()) |new| {\n+            as_utf16_p(old.as_str().unwrap(), |old| {\n+                as_utf16_p(new.as_str().unwrap(), |new| {\n                     libc::MoveFileExW(old, new, libc::MOVEFILE_REPLACE_EXISTING)\n-                }\n-            }\n+                })\n+            })\n         })\n     }\n \n@@ -618,9 +616,7 @@ pub fn chmod(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n     #[cfg(windows)]\n     fn os_chmod(p: &CString, mode: c_int) -> c_int {\n         unsafe {\n-            do as_utf16_p(p.as_str().unwrap()) |p| {\n-                libc::wchmod(p, mode)\n-            }\n+            as_utf16_p(p.as_str().unwrap(), |p| libc::wchmod(p, mode))\n         }\n     }\n \n@@ -636,7 +632,7 @@ pub fn rmdir(p: &CString) -> IoResult<()> {\n     #[cfg(windows)]\n     fn os_rmdir(p: &CString) -> c_int {\n         unsafe {\n-            do as_utf16_p(p.as_str().unwrap()) |p| { libc::wrmdir(p) }\n+            as_utf16_p(p.as_str().unwrap(), |p| libc::wrmdir(p))\n         }\n     }\n \n@@ -669,23 +665,23 @@ pub fn readlink(p: &CString) -> IoResult<Path> {\n     #[cfg(windows)]\n     fn os_readlink(p: &CString) -> IoResult<Path> {\n         let handle = unsafe {\n-            do as_utf16_p(p.as_str().unwrap()) |p| {\n+            as_utf16_p(p.as_str().unwrap(), |p| {\n                 libc::CreateFileW(p,\n                                   libc::GENERIC_READ,\n                                   libc::FILE_SHARE_READ,\n                                   ptr::mut_null(),\n                                   libc::OPEN_EXISTING,\n                                   libc::FILE_ATTRIBUTE_NORMAL,\n                                   ptr::mut_null())\n-            }\n+            })\n         };\n         if handle == ptr::mut_null() { return Err(super::last_error()) }\n-        let ret = do fill_utf16_buf_and_decode |buf, sz| {\n+        let ret = fill_utf16_buf_and_decode(|buf, sz| {\n             unsafe {\n                 libc::GetFinalPathNameByHandleW(handle, buf as *u16, sz,\n                                                 libc::VOLUME_NAME_NT)\n             }\n-        };\n+        });\n         let ret = match ret {\n             Some(s) => Ok(Path::new(s)),\n             None => Err(super::last_error()),\n@@ -722,11 +718,11 @@ pub fn symlink(src: &CString, dst: &CString) -> IoResult<()> {\n \n     #[cfg(windows)]\n     fn os_symlink(src: &CString, dst: &CString) -> IoResult<()> {\n-        super::mkerr_winbool(do as_utf16_p(src.as_str().unwrap()) |src| {\n-            do as_utf16_p(dst.as_str().unwrap()) |dst| {\n+        super::mkerr_winbool(as_utf16_p(src.as_str().unwrap(), |src| {\n+            as_utf16_p(dst.as_str().unwrap(), |dst| {\n                 unsafe { libc::CreateSymbolicLinkW(dst, src, 0) }\n-            }\n-        })\n+            })\n+        }))\n     }\n \n     #[cfg(unix)]\n@@ -742,11 +738,11 @@ pub fn link(src: &CString, dst: &CString) -> IoResult<()> {\n \n     #[cfg(windows)]\n     fn os_link(src: &CString, dst: &CString) -> IoResult<()> {\n-        super::mkerr_winbool(do as_utf16_p(src.as_str().unwrap()) |src| {\n-            do as_utf16_p(dst.as_str().unwrap()) |dst| {\n+        super::mkerr_winbool(as_utf16_p(src.as_str().unwrap(), |src| {\n+            as_utf16_p(dst.as_str().unwrap(), |dst| {\n                 unsafe { libc::CreateHardLinkW(dst, src, ptr::mut_null()) }\n-            }\n-        })\n+            })\n+        }))\n     }\n \n     #[cfg(unix)]\n@@ -851,12 +847,12 @@ pub fn stat(p: &CString) -> IoResult<io::FileStat> {\n     #[cfg(windows)]\n     fn os_stat(p: &CString) -> IoResult<io::FileStat> {\n         let mut stat: libc::stat = unsafe { intrinsics::uninit() };\n-        do as_utf16_p(p.as_str().unwrap()) |up| {\n+        as_utf16_p(p.as_str().unwrap(), |up| {\n             match unsafe { libc::wstat(up, &mut stat) } {\n                 0 => Ok(mkstat(&stat, p)),\n                 _ => Err(super::last_error()),\n             }\n-        }\n+        })\n     }\n \n     #[cfg(unix)]\n@@ -898,9 +894,7 @@ pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n             modtime: (mtime / 1000) as libc::time64_t,\n         };\n         unsafe {\n-            do as_utf16_p(p.as_str().unwrap()) |p| {\n-                libc::wutime(p, &buf)\n-            }\n+            as_utf16_p(p.as_str().unwrap(), |p| libc::wutime(p, &buf))\n         }\n     }\n "}, {"sha": "038b6ec0ff20140f6ee01a57c1f0898c8c844d78", "filename": "src/libstd/io/native/process.rs", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fnative%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fnative%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnative%2Fprocess.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -234,18 +234,18 @@ fn spawn_process_os(prog: &str, args: &[~str],\n         let mut pi = zeroed_process_information();\n         let mut create_err = None;\n \n-        do with_envp(env) |envp| {\n-            do with_dirp(dir) |dirp| {\n-                do cmd.with_c_str |cmdp| {\n+        with_envp(env, |envp| {\n+            with_dirp(dir, |dirp| {\n+                cmd.with_c_str(|cmdp| {\n                     let created = CreateProcessA(ptr::null(), cast::transmute(cmdp),\n                                                  ptr::mut_null(), ptr::mut_null(), TRUE,\n                                                  0, envp, dirp, &mut si, &mut pi);\n                     if created == FALSE {\n                         create_err = Some(os::last_os_error());\n                     }\n-                }\n-            }\n-        }\n+                })\n+            })\n+        });\n \n         CloseHandle(si.hStdInput);\n         CloseHandle(si.hStdOutput);\n@@ -411,22 +411,22 @@ fn spawn_process_os(prog: &str, args: &[~str],\n             close(fd as c_int);\n         }\n \n-        do with_dirp(dir) |dirp| {\n+        with_dirp(dir, |dirp| {\n             if !dirp.is_null() && chdir(dirp) == -1 {\n                 fail!(\"failure in chdir: {}\", os::last_os_error());\n             }\n-        }\n+        });\n \n-        do with_envp(env) |envp| {\n+        with_envp(env, |envp| {\n             if !envp.is_null() {\n                 set_environ(envp);\n             }\n-            do with_argv(prog, args) |argv| {\n+            with_argv(prog, args, |argv| {\n                 execvp(*argv, argv);\n                 // execvp only returns if an error occurred\n                 fail!(\"failure in execvp: {}\", os::last_os_error());\n-            }\n-        }\n+            })\n+        })\n     }\n }\n \n@@ -448,9 +448,7 @@ fn with_argv<T>(prog: &str, args: &[~str], cb: |**libc::c_char| -> T) -> T {\n     // Next, convert each of the byte strings into a pointer. This is\n     // technically unsafe as the caller could leak these pointers out of our\n     // scope.\n-    let mut ptrs = do tmps.map |tmp| {\n-        tmp.with_ref(|buf| buf)\n-    };\n+    let mut ptrs = tmps.map(|tmp| tmp.with_ref(|buf| buf));\n \n     // Finally, make sure we add a null pointer.\n     ptrs.push(ptr::null());\n@@ -475,14 +473,10 @@ fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: |*c_void| -> T) -> T {\n             }\n \n             // Once again, this is unsafe.\n-            let mut ptrs = do tmps.map |tmp| {\n-                tmp.with_ref(|buf| buf)\n-            };\n+            let mut ptrs = tmps.map(|tmp| tmp.with_ref(|buf| buf));\n             ptrs.push(ptr::null());\n \n-            do ptrs.as_imm_buf |buf, _| {\n-                unsafe { cb(cast::transmute(buf)) }\n-            }\n+            ptrs.as_imm_buf(|buf, _| unsafe { cb(cast::transmute(buf)) })\n         }\n         _ => cb(ptr::null())\n     }\n@@ -505,9 +499,7 @@ fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: |*mut c_void| -> T) -> T {\n \n             blk.push(0);\n \n-            do blk.as_imm_buf |p, _len| {\n-                unsafe { cb(cast::transmute(p)) }\n-            }\n+            blk.as_imm_buf(|p, _len| unsafe { cb(cast::transmute(p)) })\n         }\n         _ => cb(ptr::mut_null())\n     }"}, {"sha": "03af64cc6dccfe2e6c42f6a9a5288f75d22dd892", "filename": "src/libstd/io/net/addrinfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -97,15 +97,15 @@ pub fn get_host_addresses(host: &str) -> Option<~[IpAddr]> {\n ///      consumption just yet.\n fn lookup(hostname: Option<&str>, servname: Option<&str>,\n           hint: Option<Hint>) -> Option<~[Info]> {\n-    do with_local_io |io| {\n+    with_local_io(|io| {\n         match io.get_host_addresses(hostname, servname, hint) {\n             Ok(i) => Some(i),\n             Err(ioerr) => {\n                 io_error::cond.raise(ioerr);\n                 None\n             }\n         }\n-    }\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "e089628b9c779d84dabd00a16c39e55ad35db4e1", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 16, "deletions": 28, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -94,9 +94,7 @@ impl<'self> Parser<'self> {\n     // Commit only if parser read till EOF\n     fn read_till_eof<T>(&mut self, cb: |&mut Parser| -> Option<T>)\n                      -> Option<T> {\n-        do self.read_atomically |p| {\n-            cb(p).filtered(|_| p.is_eof())\n-        }\n+        self.read_atomically(|p| cb(p).filtered(|_| p.is_eof()))\n     }\n \n     // Return result of first successful parser\n@@ -120,15 +118,15 @@ impl<'self> Parser<'self> {\n                   pb: |&mut Parser| -> Option<B>,\n                   pc: |&mut Parser| -> Option<C>)\n                   -> Option<(A, B, C)> {\n-        do self.read_atomically |p| {\n+        self.read_atomically(|p| {\n             let a = pa(p);\n             let b = if a.is_some() { pb(p) } else { None };\n             let c = if b.is_some() { pc(p) } else { None };\n             match (a, b, c) {\n                 (Some(a), Some(b), Some(c)) => Some((a, b, c)),\n                 _ => None\n             }\n-        }\n+        })\n     }\n \n     // Read next char\n@@ -144,9 +142,9 @@ impl<'self> Parser<'self> {\n \n     // Return char and advance iff next char is equal to requested\n     fn read_given_char(&mut self, c: char) -> Option<char> {\n-        do self.read_atomically |p| {\n+        self.read_atomically(|p| {\n             p.read_char().filtered(|&next| next == c)\n-        }\n+        })\n     }\n \n     // Read digit\n@@ -165,9 +163,9 @@ impl<'self> Parser<'self> {\n             }\n         }\n \n-        do self.read_atomically |p| {\n+        self.read_atomically(|p| {\n             p.read_char().and_then(|c| parse_digit(c, radix))\n-        }\n+        })\n     }\n \n     fn read_number_impl(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> {\n@@ -195,9 +193,7 @@ impl<'self> Parser<'self> {\n \n     // Read number, failing if max_digits of number value exceeded\n     fn read_number(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> {\n-        do self.read_atomically |p| {\n-            p.read_number_impl(radix, max_digits, upto)\n-        }\n+        self.read_atomically(|p| p.read_number_impl(radix, max_digits, upto))\n     }\n \n     fn read_ipv4_addr_impl(&mut self) -> Option<IpAddr> {\n@@ -220,9 +216,7 @@ impl<'self> Parser<'self> {\n \n     // Read IPv4 address\n     fn read_ipv4_addr(&mut self) -> Option<IpAddr> {\n-        do self.read_atomically |p| {\n-            p.read_ipv4_addr_impl()\n-        }\n+        self.read_atomically(|p| p.read_ipv4_addr_impl())\n     }\n \n     fn read_ipv6_addr_impl(&mut self) -> Option<IpAddr> {\n@@ -238,13 +232,13 @@ impl<'self> Parser<'self> {\n             let mut i = 0;\n             while i < limit {\n                 if i < limit - 1 {\n-                    let ipv4 = do p.read_atomically |p| {\n+                    let ipv4 = p.read_atomically(|p| {\n                         if i == 0 || p.read_given_char(':').is_some() {\n                             p.read_ipv4_addr()\n                         } else {\n                             None\n                         }\n-                    };\n+                    });\n                     match ipv4 {\n                         Some(Ipv4Addr(a, b, c, d)) => {\n                             groups[i + 0] = (a as u16 << 8) | (b as u16);\n@@ -255,13 +249,13 @@ impl<'self> Parser<'self> {\n                     }\n                 }\n \n-                let group = do p.read_atomically |p| {\n+                let group = p.read_atomically(|p| {\n                     if i == 0 || p.read_given_char(':').is_some() {\n                         p.read_number(16, 4, 0x10000).map(|n| n as u16)\n                     } else {\n                         None\n                     }\n-                };\n+                });\n                 match group {\n                     Some(g) => groups[i] = g,\n                     None => return (i, false)\n@@ -296,9 +290,7 @@ impl<'self> Parser<'self> {\n     }\n \n     fn read_ipv6_addr(&mut self) -> Option<IpAddr> {\n-        do self.read_atomically |p| {\n-            p.read_ipv6_addr_impl()\n-        }\n+        self.read_atomically(|p| p.read_ipv6_addr_impl())\n     }\n \n     fn read_ip_addr(&mut self) -> Option<IpAddr> {\n@@ -330,17 +322,13 @@ impl<'self> Parser<'self> {\n \n impl FromStr for IpAddr {\n     fn from_str(s: &str) -> Option<IpAddr> {\n-        do Parser::new(s).read_till_eof |p| {\n-            p.read_ip_addr()\n-        }\n+        Parser::new(s).read_till_eof(|p| p.read_ip_addr())\n     }\n }\n \n impl FromStr for SocketAddr {\n     fn from_str(s: &str) -> Option<SocketAddr> {\n-        do Parser::new(s).read_till_eof |p| {\n-            p.read_socket_addr()\n-        }\n+        Parser::new(s).read_till_eof(|p| p.read_socket_addr())\n     }\n }\n "}, {"sha": "aa7a64d2210748d65d66ac3181e4b914daee1a0d", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -26,15 +26,15 @@ impl TcpStream {\n     }\n \n     pub fn connect(addr: SocketAddr) -> Option<TcpStream> {\n-        do with_local_io |io| {\n+        with_local_io(|io| {\n             match io.tcp_connect(addr) {\n                 Ok(s) => Some(TcpStream::new(s)),\n                 Err(ioerr) => {\n                     io_error::cond.raise(ioerr);\n                     None\n                 }\n             }\n-        }\n+        })\n     }\n \n     pub fn peer_name(&mut self) -> Option<SocketAddr> {\n@@ -92,15 +92,15 @@ pub struct TcpListener {\n \n impl TcpListener {\n     pub fn bind(addr: SocketAddr) -> Option<TcpListener> {\n-        do with_local_io |io| {\n+        with_local_io(|io| {\n             match io.tcp_bind(addr) {\n                 Ok(l) => Some(TcpListener { obj: l }),\n                 Err(ioerr) => {\n                     io_error::cond.raise(ioerr);\n                     None\n                 }\n             }\n-        }\n+        })\n     }\n \n     pub fn socket_name(&mut self) -> Option<SocketAddr> {\n@@ -157,14 +157,14 @@ mod test {\n     fn bind_error() {\n         do run_in_mt_newsched_task {\n             let mut called = false;\n-            do io_error::cond.trap(|e| {\n+            io_error::cond.trap(|e| {\n                 assert!(e.kind == PermissionDenied);\n                 called = true;\n-            }).inside {\n+            }).inside(|| {\n                 let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n                 let listener = TcpListener::bind(addr);\n                 assert!(listener.is_none());\n-            }\n+            });\n             assert!(called);\n         }\n     }\n@@ -173,7 +173,7 @@ mod test {\n     fn connect_error() {\n         do run_in_mt_newsched_task {\n             let mut called = false;\n-            do io_error::cond.trap(|e| {\n+            io_error::cond.trap(|e| {\n                 let expected_error = if cfg!(unix) {\n                     ConnectionRefused\n                 } else {\n@@ -182,11 +182,11 @@ mod test {\n                 };\n                 assert_eq!(e.kind, expected_error);\n                 called = true;\n-            }).inside {\n+            }).inside(|| {\n                 let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n                 let stream = TcpStream::connect(addr);\n                 assert!(stream.is_none());\n-            }\n+            });\n             assert!(called);\n         }\n     }\n@@ -306,16 +306,16 @@ mod test {\n                 let mut buf = [0];\n                 let nread = stream.read(buf);\n                 assert!(nread.is_none());\n-                do io_error::cond.trap(|e| {\n+                io_error::cond.trap(|e| {\n                     if cfg!(windows) {\n                         assert_eq!(e.kind, NotConnected);\n                     } else {\n                         fail!();\n                     }\n-                }).inside {\n+                }).inside(|| {\n                     let nread = stream.read(buf);\n                     assert!(nread.is_none());\n-                }\n+                })\n             }\n \n             do spawntask {\n@@ -341,16 +341,16 @@ mod test {\n                 let mut buf = [0];\n                 let nread = stream.read(buf);\n                 assert!(nread.is_none());\n-                do io_error::cond.trap(|e| {\n+                io_error::cond.trap(|e| {\n                     if cfg!(windows) {\n                         assert_eq!(e.kind, NotConnected);\n                     } else {\n                         fail!();\n                     }\n-                }).inside {\n+                }).inside(|| {\n                     let nread = stream.read(buf);\n                     assert!(nread.is_none());\n-                }\n+                })\n             }\n \n             do spawntask {\n@@ -376,17 +376,17 @@ mod test {\n                 let buf = [0];\n                 loop {\n                     let mut stop = false;\n-                    do io_error::cond.trap(|e| {\n+                    io_error::cond.trap(|e| {\n                         // NB: ECONNRESET on linux, EPIPE on mac, ECONNABORTED\n                         //     on windows\n                         assert!(e.kind == ConnectionReset ||\n                                 e.kind == BrokenPipe ||\n                                 e.kind == ConnectionAborted,\n                                 \"unknown error: {:?}\", e);\n                         stop = true;\n-                    }).inside {\n+                    }).inside(|| {\n                         stream.write(buf);\n-                    }\n+                    });\n                     if stop { break }\n                 }\n             }\n@@ -414,17 +414,17 @@ mod test {\n                 let buf = [0];\n                 loop {\n                     let mut stop = false;\n-                    do io_error::cond.trap(|e| {\n+                    io_error::cond.trap(|e| {\n                         // NB: ECONNRESET on linux, EPIPE on mac, ECONNABORTED\n                         //     on windows\n                         assert!(e.kind == ConnectionReset ||\n                                 e.kind == BrokenPipe ||\n                                 e.kind == ConnectionAborted,\n                                 \"unknown error: {:?}\", e);\n                         stop = true;\n-                    }).inside {\n+                    }).inside(|| {\n                         stream.write(buf);\n-                    }\n+                    });\n                     if stop { break }\n                 }\n             }\n@@ -458,10 +458,10 @@ mod test {\n \n             do spawntask {\n                 port.take().recv();\n-                do max.times {\n+                max.times(|| {\n                     let mut stream = TcpStream::connect(addr);\n                     stream.write([99]);\n-                }\n+                });\n             }\n         }\n     }\n@@ -487,10 +487,10 @@ mod test {\n \n             do spawntask {\n                 port.take().recv();\n-                do max.times {\n+                max.times(|| {\n                     let mut stream = TcpStream::connect(addr);\n                     stream.write([99]);\n-                }\n+                });\n             }\n         }\n     }"}, {"sha": "f02fc1ae4471cc856da94218bc9c733c335e899b", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -21,15 +21,15 @@ pub struct UdpSocket {\n \n impl UdpSocket {\n     pub fn bind(addr: SocketAddr) -> Option<UdpSocket> {\n-        do with_local_io |io| {\n+        with_local_io(|io| {\n             match io.udp_bind(addr) {\n                 Ok(s) => Some(UdpSocket { obj: s }),\n                 Err(ioerr) => {\n                     io_error::cond.raise(ioerr);\n                     None\n                 }\n             }\n-        }\n+        })\n     }\n \n     pub fn recvfrom(&mut self, buf: &mut [u8]) -> Option<(uint, SocketAddr)> {\n@@ -84,23 +84,21 @@ impl UdpStream {\n impl Reader for UdpStream {\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n         let peer = self.connectedTo;\n-        do self.as_socket |sock| {\n+        self.as_socket(|sock| {\n             match sock.recvfrom(buf) {\n                 Some((_nread, src)) if src != peer => Some(0),\n                 Some((nread, _src)) => Some(nread),\n                 None => None,\n             }\n-        }\n+        })\n     }\n \n     fn eof(&mut self) -> bool { fail!() }\n }\n \n impl Writer for UdpStream {\n     fn write(&mut self, buf: &[u8]) {\n-        do self.as_socket |sock| {\n-            sock.sendto(buf, self.connectedTo);\n-        }\n+        self.as_socket(|sock| sock.sendto(buf, self.connectedTo));\n     }\n }\n \n@@ -118,14 +116,14 @@ mod test {\n     fn bind_error() {\n         do run_in_mt_newsched_task {\n             let mut called = false;\n-            do io_error::cond.trap(|e| {\n+            io_error::cond.trap(|e| {\n                 assert!(e.kind == PermissionDenied);\n                 called = true;\n-            }).inside {\n+            }).inside(|| {\n                 let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n                 let socket = UdpSocket::bind(addr);\n                 assert!(socket.is_none());\n-            }\n+            });\n             assert!(called);\n         }\n     }"}, {"sha": "6d2deccaa4cfe738bab906d8d5c17957f040f512", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -59,15 +59,15 @@ impl UnixStream {\n     ///     stream.write([1, 2, 3]);\n     ///\n     pub fn connect<P: ToCStr>(path: &P) -> Option<UnixStream> {\n-        do with_local_io |io| {\n+        with_local_io(|io| {\n             match io.unix_connect(&path.to_c_str()) {\n                 Ok(s) => Some(UnixStream::new(s)),\n                 Err(ioerr) => {\n                     io_error::cond.raise(ioerr);\n                     None\n                 }\n             }\n-        }\n+        })\n     }\n }\n \n@@ -108,15 +108,15 @@ impl UnixListener {\n     ///     }\n     ///\n     pub fn bind<P: ToCStr>(path: &P) -> Option<UnixListener> {\n-        do with_local_io |io| {\n+        with_local_io(|io| {\n             match io.unix_bind(&path.to_c_str()) {\n                 Ok(s) => Some(UnixListener{ obj: s }),\n                 Err(ioerr) => {\n                     io_error::cond.raise(ioerr);\n                     None\n                 }\n             }\n-        }\n+        })\n     }\n }\n \n@@ -186,13 +186,13 @@ mod tests {\n     fn bind_error() {\n         do run_in_mt_newsched_task {\n             let mut called = false;\n-            do io_error::cond.trap(|e| {\n+            io_error::cond.trap(|e| {\n                 assert!(e.kind == PermissionDenied);\n                 called = true;\n-            }).inside {\n+            }).inside(|| {\n                 let listener = UnixListener::bind(&(\"path/to/nowhere\"));\n                 assert!(listener.is_none());\n-            }\n+            });\n             assert!(called);\n         }\n     }\n@@ -201,54 +201,54 @@ mod tests {\n     fn connect_error() {\n         do run_in_mt_newsched_task {\n             let mut called = false;\n-            do io_error::cond.trap(|e| {\n+            io_error::cond.trap(|e| {\n                 assert_eq!(e.kind, OtherIoError);\n                 called = true;\n-            }).inside {\n+            }).inside(|| {\n                 let stream = UnixStream::connect(&(\"path/to/nowhere\"));\n                 assert!(stream.is_none());\n-            }\n+            });\n             assert!(called);\n         }\n     }\n \n     #[test]\n     fn smoke() {\n-        smalltest(|mut server| {\n+        smalltest(proc(mut server) {\n             let mut buf = [0];\n             server.read(buf);\n             assert!(buf[0] == 99);\n-        }, |mut client| {\n+        }, proc(mut client) {\n             client.write([99]);\n         })\n     }\n \n     #[test]\n     fn read_eof() {\n-        smalltest(|mut server| {\n+        smalltest(proc(mut server) {\n             let mut buf = [0];\n             assert!(server.read(buf).is_none());\n             assert!(server.read(buf).is_none());\n-        }, |_client| {\n+        }, proc(_client) {\n             // drop the client\n         })\n     }\n \n     #[test]\n     fn write_begone() {\n-        smalltest(|mut server| {\n+        smalltest(proc(mut server) {\n             let buf = [0];\n             let mut stop = false;\n             while !stop{\n-                do io_error::cond.trap(|e| {\n+                io_error::cond.trap(|e| {\n                     assert!(e.kind == BrokenPipe || e.kind == NotConnected,\n                             \"unknown error {:?}\", e);\n                     stop = true;\n-                }).inside {\n+                }).inside(|| {\n                     server.write(buf);\n-                }\n+                })\n             }\n-        }, |_client| {\n+        }, proc(_client) {\n             // drop the client\n         })\n     }\n@@ -266,20 +266,20 @@ mod tests {\n             do spawntask {\n                 let mut acceptor = UnixListener::bind(&path1).listen();\n                 chan.take().send(());\n-                do times.times {\n+                times.times(|| {\n                     let mut client = acceptor.accept();\n                     let mut buf = [0];\n                     client.read(buf);\n                     assert_eq!(buf[0], 100);\n-                }\n+                })\n             }\n \n             do spawntask {\n                 port.take().recv();\n-                do times.times {\n+                times.times(|| {\n                     let mut stream = UnixStream::connect(&path2);\n                     stream.write([100]);\n-                }\n+                })\n             }\n         }\n     }"}, {"sha": "61c5411f3602fa611759a702009c2632ba792951", "filename": "src/libstd/io/option.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Foption.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -125,21 +125,21 @@ mod test {\n             let mut writer: Option<MemWriter> = None;\n \n             let mut called = false;\n-            do io_error::cond.trap(|err| {\n+            io_error::cond.trap(|err| {\n                 assert_eq!(err.kind, PreviousIoError);\n                 called = true;\n-            }).inside {\n+            }).inside(|| {\n                 writer.write([0, 0, 0]);\n-            }\n+            });\n             assert!(called);\n \n             let mut called = false;\n-            do io_error::cond.trap(|err| {\n+            io_error::cond.trap(|err| {\n                 assert_eq!(err.kind, PreviousIoError);\n                 called = true;\n-            }).inside {\n+            }).inside(|| {\n                 writer.flush();\n-            }\n+            });\n             assert!(called);\n         }\n     }\n@@ -161,21 +161,21 @@ mod test {\n         let mut buf = [];\n \n         let mut called = false;\n-        do io_error::cond.trap(|err| {\n+        io_error::cond.trap(|err| {\n             assert_eq!(err.kind, PreviousIoError);\n             called = true;\n-        }).inside {\n+        }).inside(|| {\n             reader.read(buf);\n-        }\n+        });\n         assert!(called);\n \n         let mut called = false;\n-        do io_error::cond.trap(|err| {\n+        io_error::cond.trap(|err| {\n             assert_eq!(err.kind, PreviousIoError);\n             called = true;\n-        }).inside {\n+        }).inside(|| {\n             assert!(reader.eof());\n-        }\n+        });\n         assert!(called);\n     }\n }"}, {"sha": "373de1649edc4370a20237fc8a84460306aafea1", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -44,15 +44,15 @@ impl PipeStream {\n     /// If the pipe cannot be created, an error will be raised on the\n     /// `io_error` condition.\n     pub fn open(fd: file::fd_t) -> Option<PipeStream> {\n-        do with_local_io |io| {\n+        with_local_io(|io| {\n             match io.pipe_open(fd) {\n                 Ok(obj) => Some(PipeStream { obj: obj }),\n                 Err(e) => {\n                     io_error::cond.raise(e);\n                     None\n                 }\n             }\n-        }\n+        })\n     }\n \n     pub fn new(inner: ~RtioPipe) -> PipeStream {"}, {"sha": "308e969c43a1f57a3d465b1de73db52995ac2a42", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -121,7 +121,7 @@ impl Process {\n     /// source/destination\n     pub fn new(config: ProcessConfig) -> Option<Process> {\n         let config = Cell::new(config);\n-        do with_local_io |io| {\n+        with_local_io(|io| {\n             match io.spawn(config.take()) {\n                 Ok((p, io)) => Some(Process{\n                     handle: p,\n@@ -134,7 +134,7 @@ impl Process {\n                     None\n                 }\n             }\n-        }\n+        })\n     }\n \n     /// Returns the process id of this child process"}, {"sha": "f6e79a03323218766861c71a1f6b0a3f3b4ba879", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -123,7 +123,7 @@ impl Listener {\n         if self.handles.contains_key(&signum) {\n             return true; // self is already listening to signum, so succeed\n         }\n-        do with_local_io |io| {\n+        with_local_io(|io| {\n             match io.signal(signum, self.chan.clone()) {\n                 Ok(w) => {\n                     self.handles.insert(signum, w);\n@@ -134,7 +134,7 @@ impl Listener {\n                     None\n                 }\n             }\n-        }.is_some()\n+        }).is_some()\n     }\n \n     /// Unregisters a signal. If this listener currently had a handler\n@@ -212,13 +212,13 @@ mod test {\n         use super::User1;\n         let mut s = Listener::new();\n         let mut called = false;\n-        do io::io_error::cond.trap(|_| {\n+        io::io_error::cond.trap(|_| {\n             called = true;\n-        }).inside {\n+        }).inside(|| {\n             if s.register(User1) {\n                 fail!(\"Unexpected successful registry of signum {:?}\", User1);\n             }\n-        }\n+        });\n         assert!(called);\n     }\n }"}, {"sha": "2aa8b0c7ed6d54c77ae72529883f73228a4c9453", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -70,7 +70,7 @@ enum StdSource {\n }\n \n fn src<T>(fd: libc::c_int, readable: bool, f: |StdSource| -> T) -> T {\n-    do with_local_io |io| {\n+    with_local_io(|io| {\n         let fd = unsafe { libc::dup(fd) };\n         match io.tty_open(fd, readable) {\n             Ok(tty) => Some(f(TTY(tty))),\n@@ -84,14 +84,14 @@ fn src<T>(fd: libc::c_int, readable: bool, f: |StdSource| -> T) -> T {\n                 Some(f(File(io.fs_from_raw_fd(fd, CloseAsynchronously))))\n             }\n         }\n-    }.unwrap()\n+    }).unwrap()\n }\n \n /// Creates a new non-blocking handle to the stdin of the current process.\n ///\n /// See `stdout()` for notes about this function.\n pub fn stdin() -> StdReader {\n-    do src(libc::STDIN_FILENO, true) |src| { StdReader { inner: src } }\n+    src(libc::STDIN_FILENO, true, |src| StdReader { inner: src })\n }\n \n /// Creates a new non-blocking handle to the stdout of the current process.\n@@ -101,26 +101,26 @@ pub fn stdin() -> StdReader {\n /// task context because the stream returned will be a non-blocking object using\n /// the local scheduler to perform the I/O.\n pub fn stdout() -> StdWriter {\n-    do src(libc::STDOUT_FILENO, false) |src| { StdWriter { inner: src } }\n+    src(libc::STDOUT_FILENO, false, |src| StdWriter { inner: src })\n }\n \n /// Creates a new non-blocking handle to the stderr of the current process.\n ///\n /// See `stdout()` for notes about this function.\n pub fn stderr() -> StdWriter {\n-    do src(libc::STDERR_FILENO, false) |src| { StdWriter { inner: src } }\n+    src(libc::STDERR_FILENO, false, |src| StdWriter { inner: src })\n }\n \n // Helper to access the local task's stdout handle\n //\n // Note that this is not a safe function to expose because you can create an\n // aliased pointer very easily:\n //\n-//  do with_task_stdout |io1| {\n-//      do with_task_stdout |io2| {\n+//  with_task_stdout(|io1| {\n+//      with_task_stdout(|io2| {\n //          // io1 aliases io2\n-//      }\n-//  }\n+//      })\n+//  })\n fn with_task_stdout(f: |&mut Writer|) {\n     use rt::local::Local;\n     use rt::task::Task;\n@@ -158,42 +158,34 @@ fn with_task_stdout(f: |&mut Writer|) {\n /// will emit output to stderr, and while they are line buffered the log\n /// messages are always terminated in a newline (no need to flush).\n pub fn flush() {\n-    do with_task_stdout |io| {\n-        io.flush();\n-    }\n+    with_task_stdout(|io| io.flush())\n }\n \n /// Prints a string to the stdout of the current process. No newline is emitted\n /// after the string is printed.\n pub fn print(s: &str) {\n-    do with_task_stdout |io| {\n-        io.write(s.as_bytes());\n-    }\n+    with_task_stdout(|io| io.write(s.as_bytes()))\n }\n \n /// Prints a string as a line. to the stdout of the current process. A literal\n /// `\\n` character is printed to the console after the string.\n pub fn println(s: &str) {\n-    do with_task_stdout |io| {\n+    with_task_stdout(|io| {\n         io.write(s.as_bytes());\n         io.write(['\\n' as u8]);\n-    }\n+    })\n }\n \n /// Similar to `print`, but takes a `fmt::Arguments` structure to be compatible\n /// with the `format_args!` macro.\n pub fn print_args(fmt: &fmt::Arguments) {\n-    do with_task_stdout |io| {\n-        fmt::write(io, fmt);\n-    }\n+    with_task_stdout(|io| fmt::write(io, fmt))\n }\n \n /// Similar to `println`, but takes a `fmt::Arguments` structure to be\n /// compatible with the `format_args!` macro.\n pub fn println_args(fmt: &fmt::Arguments) {\n-    do with_task_stdout |io| {\n-        fmt::writeln(io, fmt);\n-    }\n+    with_task_stdout(|io| fmt::writeln(io, fmt))\n }\n \n /// Representation of a reader of a standard input stream"}, {"sha": "8dda79358887eac32eaadff4de407af3a4a31c3a", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -60,7 +60,7 @@ impl Timer {\n     /// for a number of milliseconds, or to possibly create channels which will\n     /// get notified after an amount of time has passed.\n     pub fn new() -> Option<Timer> {\n-        do with_local_io |io| {\n+        with_local_io(|io| {\n             match io.timer_init() {\n                 Ok(t) => Some(Timer { obj: t }),\n                 Err(ioerr) => {\n@@ -70,7 +70,7 @@ impl Timer {\n                 }\n             }\n \n-        }\n+        })\n     }\n \n     /// Blocks the current task for `msecs` milliseconds."}, {"sha": "75a7d5db1321e392845d7ef31643108bf539a7e7", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -156,7 +156,7 @@ pub trait Iterator<A> {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    fn map<'r, B>(self, f: &'r fn(A) -> B) -> Map<'r, A, B, Self> {\n+    fn map<'r, B>(self, f: 'r |A| -> B) -> Map<'r, A, B, Self> {\n         Map{iter: self, f: f}\n     }\n \n@@ -173,7 +173,7 @@ pub trait Iterator<A> {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    fn filter<'r>(self, predicate: &'r fn(&A) -> bool) -> Filter<'r, A, Self> {\n+    fn filter<'r>(self, predicate: 'r |&A| -> bool) -> Filter<'r, A, Self> {\n         Filter{iter: self, predicate: predicate}\n     }\n \n@@ -190,7 +190,7 @@ pub trait Iterator<A> {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    fn filter_map<'r, B>(self, f: &'r fn(A) -> Option<B>) -> FilterMap<'r, A, B, Self> {\n+    fn filter_map<'r, B>(self, f: 'r |A| -> Option<B>) -> FilterMap<'r, A, B, Self> {\n         FilterMap { iter: self, f: f }\n     }\n \n@@ -249,7 +249,7 @@ pub trait Iterator<A> {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    fn skip_while<'r>(self, predicate: &'r fn(&A) -> bool) -> SkipWhile<'r, A, Self> {\n+    fn skip_while<'r>(self, predicate: 'r |&A| -> bool) -> SkipWhile<'r, A, Self> {\n         SkipWhile{iter: self, flag: false, predicate: predicate}\n     }\n \n@@ -267,7 +267,7 @@ pub trait Iterator<A> {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    fn take_while<'r>(self, predicate: &'r fn(&A) -> bool) -> TakeWhile<'r, A, Self> {\n+    fn take_while<'r>(self, predicate: 'r |&A| -> bool) -> TakeWhile<'r, A, Self> {\n         TakeWhile{iter: self, flag: false, predicate: predicate}\n     }\n \n@@ -327,7 +327,7 @@ pub trait Iterator<A> {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    fn scan<'r, St, B>(self, initial_state: St, f: &'r fn(&mut St, A) -> Option<B>)\n+    fn scan<'r, St, B>(self, initial_state: St, f: 'r |&mut St, A| -> Option<B>)\n         -> Scan<'r, A, B, Self, St> {\n         Scan{iter: self, f: f, state: initial_state}\n     }\n@@ -349,7 +349,7 @@ pub trait Iterator<A> {\n     /// }\n     /// ```\n     #[inline]\n-    fn flat_map<'r, B, U: Iterator<B>>(self, f: &'r fn(A) -> U)\n+    fn flat_map<'r, B, U: Iterator<B>>(self, f: 'r |A| -> U)\n         -> FlatMap<'r, A, Self, U> {\n         FlatMap{iter: self, f: f, frontiter: None, backiter: None }\n     }\n@@ -401,7 +401,7 @@ pub trait Iterator<A> {\n     ///println(sum.to_str());\n     /// ```\n     #[inline]\n-    fn inspect<'r>(self, f: &'r fn(&A)) -> Inspect<'r, A, Self> {\n+    fn inspect<'r>(self, f: 'r |&A|) -> Inspect<'r, A, Self> {\n         Inspect{iter: self, f: f}\n     }\n \n@@ -1123,7 +1123,7 @@ RandomAccessIterator<(A, B)> for Zip<T, U> {\n /// An iterator which maps the values of `iter` with `f`\n pub struct Map<'self, A, B, T> {\n     priv iter: T,\n-    priv f: &'self fn(A) -> B\n+    priv f: 'self |A| -> B\n }\n \n impl<'self, A, B, T> Map<'self, A, B, T> {\n@@ -1172,7 +1172,7 @@ impl<'self, A, B, T: RandomAccessIterator<A>> RandomAccessIterator<B> for Map<'s\n /// An iterator which filters the elements of `iter` with `predicate`\n pub struct Filter<'self, A, T> {\n     priv iter: T,\n-    priv predicate: &'self fn(&A) -> bool\n+    priv predicate: 'self |&A| -> bool\n }\n \n impl<'self, A, T: Iterator<A>> Iterator<A> for Filter<'self, A, T> {\n@@ -1216,7 +1216,7 @@ impl<'self, A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Filter<'sel\n /// An iterator which uses `f` to both filter and map elements from `iter`\n pub struct FilterMap<'self, A, B, T> {\n     priv iter: T,\n-    priv f: &'self fn(A) -> Option<B>\n+    priv f: 'self |A| -> Option<B>\n }\n \n impl<'self, A, B, T: Iterator<A>> Iterator<B> for FilterMap<'self, A, B, T> {\n@@ -1359,7 +1359,7 @@ impl<'self, A, T: Iterator<A>> Peekable<A, T> {\n pub struct SkipWhile<'self, A, T> {\n     priv iter: T,\n     priv flag: bool,\n-    priv predicate: &'self fn(&A) -> bool\n+    priv predicate: 'self |&A| -> bool\n }\n \n impl<'self, A, T: Iterator<A>> Iterator<A> for SkipWhile<'self, A, T> {\n@@ -1397,7 +1397,7 @@ impl<'self, A, T: Iterator<A>> Iterator<A> for SkipWhile<'self, A, T> {\n pub struct TakeWhile<'self, A, T> {\n     priv iter: T,\n     priv flag: bool,\n-    priv predicate: &'self fn(&A) -> bool\n+    priv predicate: 'self |&A| -> bool\n }\n \n impl<'self, A, T: Iterator<A>> Iterator<A> for TakeWhile<'self, A, T> {\n@@ -1544,7 +1544,7 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Take<T> {\n /// An iterator to maintain state while iterating another iterator\n pub struct Scan<'self, A, B, T, St> {\n     priv iter: T,\n-    priv f: &'self fn(&mut St, A) -> Option<B>,\n+    priv f: 'self |&mut St, A| -> Option<B>,\n \n     /// The current internal state to be passed to the closure next.\n     state: St\n@@ -1568,7 +1568,7 @@ impl<'self, A, B, T: Iterator<A>, St> Iterator<B> for Scan<'self, A, B, T, St> {\n ///\n pub struct FlatMap<'self, A, T, U> {\n     priv iter: T,\n-    priv f: &'self fn(A) -> U,\n+    priv f: 'self |A| -> U,\n     priv frontiter: Option<U>,\n     priv backiter: Option<U>,\n }\n@@ -1699,7 +1699,7 @@ impl<T> Fuse<T> {\n /// element before yielding it.\n pub struct Inspect<'self, A, T> {\n     priv iter: T,\n-    priv f: &'self fn(&A)\n+    priv f: 'self |&A|\n }\n \n impl<'self, A, T> Inspect<'self, A, T> {\n@@ -1751,7 +1751,7 @@ for Inspect<'self, A, T> {\n \n /// An iterator which just modifies the contained state throughout iteration.\n pub struct Unfold<'self, A, St> {\n-    priv f: &'self fn(&mut St) -> Option<A>,\n+    priv f: 'self |&mut St| -> Option<A>,\n     /// Internal state that will be yielded on the next iteration\n     state: St\n }\n@@ -1760,8 +1760,8 @@ impl<'self, A, St> Unfold<'self, A, St> {\n     /// Creates a new iterator with the specified closure as the \"iterator\n     /// function\" and an initial state to eventually pass to the iterator\n     #[inline]\n-    pub fn new<'a>(initial_state: St, f: &'a fn(&mut St) -> Option<A>)\n-        -> Unfold<'a, A, St> {\n+    pub fn new<'a>(initial_state: St, f: 'a |&mut St| -> Option<A>)\n+               -> Unfold<'a, A, St> {\n         Unfold {\n             f: f,\n             state: initial_state\n@@ -2674,13 +2674,13 @@ mod tests {\n     fn test_rposition_fail() {\n         let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n-        do v.iter().rposition |_elt| {\n+        v.iter().rposition(|_elt| {\n             if i == 2 {\n                 fail!()\n             }\n             i += 1;\n             false\n-        };\n+        });\n     }\n \n "}, {"sha": "335bbc8b1da30d519b1a36d9e1238413c6113fe9", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -189,7 +189,7 @@ pub fn get<T: 'static, U>(key: Key<T>, f: |Option<&T>| -> U) -> U {\n /// on loan via this or the `get` methods. This is similar to how it's a runtime\n /// error to take two mutable loans on an `@mut` box.\n pub fn get_mut<T: 'static, U>(key: Key<T>, f: |Option<&mut T>| -> U) -> U {\n-    do get_with(key, MutLoan) |x| {\n+    get_with(key, MutLoan, |x| {\n         match x {\n             None => f(None),\n             // We're violating a lot of compiler guarantees with this\n@@ -199,7 +199,7 @@ pub fn get_mut<T: 'static, U>(key: Key<T>, f: |Option<&mut T>| -> U) -> U {\n             // there is no need to be upset!\n             Some(x) => { f(Some(unsafe { cast::transmute_mut(x) })) }\n         }\n-    }\n+    })\n }\n \n fn get_with<T:'static,\n@@ -479,33 +479,33 @@ mod tests {\n         static key: Key<~int> = &Key;\n         set(key, ~1);\n \n-        do get(key) |v| {\n-            do get(key) |v| {\n-                do get(key) |v| {\n+        get(key, |v| {\n+            get(key, |v| {\n+                get(key, |v| {\n                     assert_eq!(**v.unwrap(), 1);\n-                }\n+                });\n                 assert_eq!(**v.unwrap(), 1);\n-            }\n+            });\n             assert_eq!(**v.unwrap(), 1);\n-        }\n+        });\n         set(key, ~2);\n-        do get(key) |v| {\n+        get(key, |v| {\n             assert_eq!(**v.unwrap(), 2);\n-        }\n+        })\n     }\n \n     #[test]\n     fn test_get_mut() {\n         static key: Key<int> = &Key;\n         set(key, 1);\n \n-        do get_mut(key) |v| {\n+        get_mut(key, |v| {\n             *v.unwrap() = 2;\n-        }\n+        });\n \n-        do get(key) |v| {\n+        get(key, |v| {\n             assert_eq!(*v.unwrap(), 2);\n-        }\n+        })\n     }\n \n     #[test]\n@@ -533,38 +533,38 @@ mod tests {\n     fn test_nested_get_set1() {\n         static key: Key<int> = &Key;\n         set(key, 4);\n-        do get(key) |_| {\n+        get(key, |_| {\n             set(key, 4);\n-        }\n+        })\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_nested_get_mut2() {\n         static key: Key<int> = &Key;\n         set(key, 4);\n-        do get(key) |_| {\n+        get(key, |_| {\n             get_mut(key, |_| {})\n-        }\n+        })\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_nested_get_mut3() {\n         static key: Key<int> = &Key;\n         set(key, 4);\n-        do get_mut(key) |_| {\n+        get_mut(key, |_| {\n             get(key, |_| {})\n-        }\n+        })\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_nested_get_mut4() {\n         static key: Key<int> = &Key;\n         set(key, 4);\n-        do get_mut(key) |_| {\n+        get_mut(key, |_| {\n             get_mut(key, |_| {})\n-        }\n+        })\n     }\n }"}, {"sha": "fc56bf91c2a77da3be867d8b5ce627921ea67cae", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -420,10 +420,10 @@ pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n     // base 2 number, and then we need another for a possible '-' character.\n     let mut buf = [0u8, ..65];\n     let mut cur = 0;\n-    do strconv::int_to_str_bytes_common(n, radix, strconv::SignNeg) |i| {\n+    strconv::int_to_str_bytes_common(n, radix, strconv::SignNeg, |i| {\n         buf[cur] = i;\n         cur += 1;\n-    }\n+    });\n     f(buf.slice(0, cur))\n }\n \n@@ -440,9 +440,9 @@ impl ToStrRadix for $T {\n     #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         let mut buf: ~[u8] = ~[];\n-        do strconv::int_to_str_bytes_common(*self, radix, strconv::SignNeg) |i| {\n+        strconv::int_to_str_bytes_common(*self, radix, strconv::SignNeg, |i| {\n             buf.push(i);\n-        }\n+        });\n         // We know we generated valid utf-8, so we don't need to go through that\n         // check.\n         unsafe { str::raw::from_utf8_owned(buf) }"}, {"sha": "456011d51720e2654a0354243aa86401d828a0d5", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -104,7 +104,7 @@ pub trait Unsigned: Num {}\n /// use num::Times;\n /// let ten = 10 as uint;\n /// let mut accum = 0;\n-/// do ten.times { accum += 1; }\n+/// ten.times(|| { accum += 1; })\n /// ```\n ///\n pub trait Times {"}, {"sha": "1028cef9dc6475754703644e1ee8bd7a040bcc88", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -750,16 +750,16 @@ mod bench {\n     #[bench]\n     fn uint_to_str_rand(bh: &mut BenchHarness) {\n         let mut rng = XorShiftRng::new();\n-        do bh.iter {\n+        bh.iter(|| {\n             rng.gen::<uint>().to_str();\n-        }\n+        })\n     }\n \n     #[bench]\n     fn float_to_str_rand(bh: &mut BenchHarness) {\n         let mut rng = XorShiftRng::new();\n-        do bh.iter {\n+        bh.iter(|| {\n             f64::to_str(rng.gen());\n-        }\n+        })\n     }\n }"}, {"sha": "cf28083bb09b941d6106614d85e3f3cbd113d299", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -77,13 +77,13 @@ impl num::Times for uint {\n     #[inline]\n     ///\n     /// A convenience form for basic repetition. Given a uint `x`,\n-    /// `do x.times { ... }` executes the given block x times.\n+    /// `x.times(|| { ... })` executes the given block x times.\n     ///\n     /// Equivalent to `for uint::range(0, x) |_| { ... }`.\n     ///\n     /// Not defined on all integer types to permit unambiguous\n     /// use with integer literals of inferred integer-type as\n-    /// the self-value (eg. `do 100.times { ... }`).\n+    /// the self-value (eg. `100.times(|| { ... })`).\n     ///\n     fn times(&self, it: ||) {\n         let mut i = *self;\n@@ -244,6 +244,6 @@ pub fn test_times() {\n     use num::Times;\n     let ten = 10 as uint;\n     let mut accum = 0;\n-    do ten.times { accum += 1; }\n+    ten.times(|| { accum += 1; });\n     assert!((accum == 10));\n }"}, {"sha": "3c276378df86356577e183bc6967af28dd545e42", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -271,10 +271,10 @@ pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n     // base 2 number.\n     let mut buf = [0u8, ..64];\n     let mut cur = 0;\n-    do strconv::int_to_str_bytes_common(n, radix, strconv::SignNone) |i| {\n+    strconv::int_to_str_bytes_common(n, radix, strconv::SignNone, |i| {\n         buf[cur] = i;\n         cur += 1;\n-    }\n+    });\n     f(buf.slice(0, cur))\n }\n \n@@ -291,9 +291,9 @@ impl ToStrRadix for $T {\n     #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         let mut buf = ~[];\n-        do strconv::int_to_str_bytes_common(*self, radix, strconv::SignNone) |i| {\n+        strconv::int_to_str_bytes_common(*self, radix, strconv::SignNone, |i| {\n             buf.push(i);\n-        }\n+        });\n         // We know we generated valid utf-8, so we don't need to go through that\n         // check.\n         unsafe { str::raw::from_utf8_owned(buf) }"}, {"sha": "cdc63608122a8ef4d512e97a9b4ad2a193f668df", "filename": "src/libstd/ops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fops.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -481,8 +481,8 @@ mod bench {\n \n     #[bench]\n     fn alloc_obj_with_dtor(bh: &mut BenchHarness) {\n-        do bh.iter {\n+        bh.iter(|| {\n             HasDtor { x : 10 };\n-        }\n+        })\n     }\n }"}, {"sha": "715072653a7ab616fce00e4e6ad2afbbb235f915", "filename": "src/libstd/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -612,14 +612,14 @@ mod tests {\n     #[test]\n     fn test_option_while_some() {\n         let mut i = 0;\n-        do Some(10).while_some |j| {\n+        Some(10).while_some(|j| {\n             i += 1;\n             if (j > 0) {\n                 Some(j-1)\n             } else {\n                 None\n             }\n-        }\n+        });\n         assert_eq!(i, 11);\n     }\n "}, {"sha": "baa4423220c5dd392d4a2298807038278b9b6f86", "filename": "src/libstd/os.rs", "status": "modified", "additions": 61, "deletions": 67, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -58,29 +58,29 @@ static BUF_BYTES : uint = 2048u;\n #[cfg(unix)]\n pub fn getcwd() -> Path {\n     let mut buf = [0 as libc::c_char, ..BUF_BYTES];\n-    do buf.as_mut_buf |buf, len| {\n+    buf.as_mut_buf(|buf, len| {\n         unsafe {\n             if libc::getcwd(buf, len as size_t).is_null() {\n                 fail!()\n             }\n \n             Path::new(CString::new(buf as *c_char, false))\n         }\n-    }\n+    })\n }\n \n #[cfg(windows)]\n pub fn getcwd() -> Path {\n     use libc::DWORD;\n     use libc::GetCurrentDirectoryW;\n     let mut buf = [0 as u16, ..BUF_BYTES];\n-    do buf.as_mut_buf |buf, len| {\n+    buf.as_mut_buf(|buf, len| {\n         unsafe {\n             if libc::GetCurrentDirectoryW(len as DWORD, buf) == 0 as DWORD {\n                 fail!();\n             }\n         }\n-    }\n+    });\n     Path::new(str::from_utf16(buf))\n }\n \n@@ -104,7 +104,7 @@ pub mod win32 {\n             while !done {\n                 let mut k: DWORD = 0;\n                 let mut buf = vec::from_elem(n as uint, 0u16);\n-                do buf.as_mut_buf |b, _sz| {\n+                buf.as_mut_buf(|b, _sz| {\n                     k = f(b, TMPBUF_SZ as DWORD);\n                     if k == (0 as DWORD) {\n                         done = true;\n@@ -115,7 +115,7 @@ pub mod win32 {\n                     } else {\n                         done = true;\n                     }\n-                }\n+                });\n                 if k != 0 && done {\n                     let sub = buf.slice(0, k as uint);\n                     res = option::Some(str::from_utf16(sub));\n@@ -144,12 +144,10 @@ fn with_env_lock<T>(f: || -> T) -> T {\n     static mut lock: Mutex = MUTEX_INIT;\n \n     unsafe {\n-        return do (|| {\n+        return (|| {\n             lock.lock();\n             f()\n-        }).finally {\n-            lock.unlock();\n-        };\n+        }).finally(|| lock.unlock());\n     }\n }\n \n@@ -172,9 +170,9 @@ pub fn env() -> ~[(~str,~str)] {\n                        os::last_os_error());\n             }\n             let mut result = ~[];\n-            do c_str::from_c_multistring(ch as *libc::c_char, None) |cstr| {\n+            c_str::from_c_multistring(ch as *libc::c_char, None, |cstr| {\n                 result.push(cstr.as_str().unwrap().to_owned());\n-            };\n+            });\n             FreeEnvironmentStringsA(ch);\n             result\n         }\n@@ -207,10 +205,10 @@ pub fn env() -> ~[(~str,~str)] {\n             }\n             pairs\n         }\n-        do with_env_lock {\n+        with_env_lock(|| {\n             let unparsed_environ = get_env_pairs();\n             env_convert(unparsed_environ)\n-        }\n+        })\n     }\n }\n \n@@ -219,16 +217,14 @@ pub fn env() -> ~[(~str,~str)] {\n /// None if the variable isn't set.\n pub fn getenv(n: &str) -> Option<~str> {\n     unsafe {\n-        do with_env_lock {\n-            let s = do n.with_c_str |buf| {\n-                libc::getenv(buf)\n-            };\n+        with_env_lock(|| {\n+            let s = n.with_c_str(|buf| libc::getenv(buf));\n             if s.is_null() {\n                 None\n             } else {\n                 Some(str::raw::from_c_str(s))\n             }\n-        }\n+        })\n     }\n }\n \n@@ -237,14 +233,14 @@ pub fn getenv(n: &str) -> Option<~str> {\n /// None if the variable isn't set.\n pub fn getenv(n: &str) -> Option<~str> {\n     unsafe {\n-        do with_env_lock {\n+        with_env_lock(|| {\n             use os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n-            do as_utf16_p(n) |u| {\n-                do fill_utf16_buf_and_decode() |buf, sz| {\n+            as_utf16_p(n, |u| {\n+                fill_utf16_buf_and_decode(|buf, sz| {\n                     libc::GetEnvironmentVariableW(u, buf, sz)\n-                }\n-            }\n-        }\n+                })\n+            })\n+        })\n     }\n }\n \n@@ -254,13 +250,13 @@ pub fn getenv(n: &str) -> Option<~str> {\n /// process\n pub fn setenv(n: &str, v: &str) {\n     unsafe {\n-        do with_env_lock {\n-            do n.with_c_str |nbuf| {\n-                do v.with_c_str |vbuf| {\n+        with_env_lock(|| {\n+            n.with_c_str(|nbuf| {\n+                v.with_c_str(|vbuf| {\n                     libc::funcs::posix01::unistd::setenv(nbuf, vbuf, 1);\n-                }\n-            }\n-        }\n+                })\n+            })\n+        })\n     }\n }\n \n@@ -270,14 +266,14 @@ pub fn setenv(n: &str, v: &str) {\n /// process\n pub fn setenv(n: &str, v: &str) {\n     unsafe {\n-        do with_env_lock {\n+        with_env_lock(|| {\n             use os::win32::as_utf16_p;\n-            do as_utf16_p(n) |nbuf| {\n-                do as_utf16_p(v) |vbuf| {\n+            as_utf16_p(n, |nbuf| {\n+                as_utf16_p(v, |vbuf| {\n                     libc::SetEnvironmentVariableW(nbuf, vbuf);\n-                }\n-            }\n-        }\n+                })\n+            })\n+        })\n     }\n }\n \n@@ -286,22 +282,22 @@ pub fn unsetenv(n: &str) {\n     #[cfg(unix)]\n     fn _unsetenv(n: &str) {\n         unsafe {\n-            do with_env_lock {\n-                do n.with_c_str |nbuf| {\n+            with_env_lock(|| {\n+                n.with_c_str(|nbuf| {\n                     libc::funcs::posix01::unistd::unsetenv(nbuf);\n-                }\n-            }\n+                })\n+            })\n         }\n     }\n     #[cfg(windows)]\n     fn _unsetenv(n: &str) {\n         unsafe {\n-            do with_env_lock {\n+            with_env_lock(|| {\n                 use os::win32::as_utf16_p;\n-                do as_utf16_p(n) |nbuf| {\n+                as_utf16_p(n, |nbuf| {\n                     libc::SetEnvironmentVariableW(nbuf, ptr::null());\n-                }\n-            }\n+                })\n+            })\n         }\n     }\n \n@@ -372,10 +368,10 @@ pub fn self_exe_path() -> Option<Path> {\n             if err != 0 { return None; }\n             if sz == 0 { return None; }\n             let mut v: ~[u8] = vec::with_capacity(sz as uint);\n-            let err = do v.as_mut_buf |buf,_| {\n+            let err = v.as_mut_buf(|buf,_| {\n                 sysctl(vec::raw::to_ptr(mib), mib.len() as ::libc::c_uint,\n                        buf as *mut c_void, &mut sz, ptr::null(), 0u as size_t)\n-            };\n+            });\n             if err != 0 { return None; }\n             if sz == 0 { return None; }\n             vec::raw::set_len(&mut v, sz as uint - 1); // chop off trailing NUL\n@@ -403,9 +399,9 @@ pub fn self_exe_path() -> Option<Path> {\n             _NSGetExecutablePath(ptr::mut_null(), &mut sz);\n             if sz == 0 { return None; }\n             let mut v: ~[u8] = vec::with_capacity(sz as uint);\n-            let err = do v.as_mut_buf |buf,_| {\n+            let err = v.as_mut_buf(|buf, _| {\n                 _NSGetExecutablePath(buf as *mut i8, &mut sz)\n-            };\n+            });\n             if err != 0 { return None; }\n             vec::raw::set_len(&mut v, sz as uint - 1); // chop off trailing NUL\n             Some(v)\n@@ -416,9 +412,9 @@ pub fn self_exe_path() -> Option<Path> {\n     fn load_self() -> Option<~[u8]> {\n         unsafe {\n             use os::win32::fill_utf16_buf_and_decode;\n-            do fill_utf16_buf_and_decode() |buf, sz| {\n+            fill_utf16_buf_and_decode(|buf, sz| {\n                 libc::GetModuleFileNameW(0u as libc::DWORD, buf, sz)\n-            }.map(|s| s.into_bytes())\n+            }).map(|s| s.into_bytes())\n         }\n     }\n \n@@ -452,13 +448,13 @@ pub fn homedir() -> Option<Path> {\n \n     #[cfg(windows)]\n     fn secondary() -> Option<Path> {\n-        do getenv(\"USERPROFILE\").and_then |p| {\n+        getenv(\"USERPROFILE\").and_then(|p| {\n             if !p.is_empty() {\n                 Path::new_opt(p)\n             } else {\n                 None\n             }\n-        }\n+        })\n     }\n }\n \n@@ -536,19 +532,19 @@ pub fn change_dir(p: &Path) -> bool {\n     fn chdir(p: &Path) -> bool {\n         unsafe {\n             use os::win32::as_utf16_p;\n-            return do as_utf16_p(p.as_str().unwrap()) |buf| {\n+            return as_utf16_p(p.as_str().unwrap(), |buf| {\n                 libc::SetCurrentDirectoryW(buf) != (0 as libc::BOOL)\n-            };\n+            });\n         }\n     }\n \n     #[cfg(unix)]\n     fn chdir(p: &Path) -> bool {\n-        do p.with_c_str |buf| {\n+        p.with_c_str(|buf| {\n             unsafe {\n                 libc::chdir(buf) == (0 as c_int)\n             }\n-        }\n+        })\n     }\n }\n \n@@ -637,15 +633,15 @@ pub fn last_os_error() -> ~str {\n \n         let mut buf = [0 as c_char, ..TMPBUF_SZ];\n \n-        do buf.as_mut_buf |buf, len| {\n+        buf.as_mut_buf(|buf, len| {\n             unsafe {\n                 if strerror_r(errno() as c_int, buf, len as size_t) < 0 {\n                     fail!(\"strerror_r failure\");\n                 }\n \n                 str::raw::from_c_str(buf as *c_char)\n             }\n-        }\n+        })\n     }\n \n     #[cfg(windows)]\n@@ -678,7 +674,7 @@ pub fn last_os_error() -> ~str {\n         let mut buf = [0 as WCHAR, ..TMPBUF_SZ];\n \n         unsafe {\n-            do buf.as_mut_buf |buf, len| {\n+            buf.as_mut_buf(|buf, len| {\n                 let res = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |\n                                          FORMAT_MESSAGE_IGNORE_INSERTS,\n                                          ptr::mut_null(),\n@@ -690,7 +686,7 @@ pub fn last_os_error() -> ~str {\n                 if res == 0 {\n                     fail!(\"[{}] FormatMessage failure\", errno());\n                 }\n-            }\n+            });\n \n             str::from_utf16(buf)\n         }\n@@ -1466,13 +1462,11 @@ mod tests {\n         let size = MemoryMap::granularity() * 2;\n \n         let fd = unsafe {\n-            let fd = do path.with_c_str |path| {\n+            let fd = path.with_c_str(|path| {\n                 open(path, O_CREAT | O_RDWR | O_TRUNC, S_IRUSR | S_IWUSR)\n-            };\n+            });\n             lseek_(fd, size);\n-            do \"x\".with_c_str |x| {\n-                assert!(write(fd, x as *c_void, 1) == 1);\n-            }\n+            \"x\".with_c_str(|x| assert!(write(fd, x as *c_void, 1) == 1));\n             fd\n         };\n         let chunk = match MemoryMap::new(size / 2, [\n@@ -1491,7 +1485,7 @@ mod tests {\n             assert!(*chunk.data == 0xbe);\n             close(fd);\n         }\n-        do io::ignore_io_error { fs::unlink(&path); }\n+        io::ignore_io_error(|| fs::unlink(&path));\n     }\n \n     // More recursive_mkdir tests are in extra::tempfile"}, {"sha": "2b6009206acf7fc91ec0b9f1cfe5784847d635ab", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -530,9 +530,7 @@ pub struct Display<'self, P> {\n \n impl<'self, P: GenericPath> fmt::Default for Display<'self, P> {\n     fn fmt(d: &Display<P>, f: &mut fmt::Formatter) {\n-        do d.with_str |s| {\n-            f.pad(s)\n-        }\n+        d.with_str(|s| f.pad(s))\n     }\n }\n "}, {"sha": "ddfb43ed56f8707f252b28a03e5e73570d773e20", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -523,35 +523,35 @@ mod tests {\n         use path::null_byte::cond;\n \n         let mut handled = false;\n-        let mut p = do cond.trap(|v| {\n+        let mut p = cond.trap(|v| {\n             handled = true;\n             assert_eq!(v.as_slice(), b!(\"foo/bar\", 0));\n             (b!(\"/bar\").to_owned())\n-        }).inside {\n+        }).inside(|| {\n             Path::new(b!(\"foo/bar\", 0))\n-        };\n+        });\n         assert!(handled);\n         assert_eq!(p.as_vec(), b!(\"/bar\"));\n \n         handled = false;\n-        do cond.trap(|v| {\n+        cond.trap(|v| {\n             handled = true;\n             assert_eq!(v.as_slice(), b!(\"f\", 0, \"o\"));\n             (b!(\"foo\").to_owned())\n-        }).inside {\n+        }).inside(|| {\n             p.set_filename(b!(\"f\", 0, \"o\"))\n-        };\n+        });\n         assert!(handled);\n         assert_eq!(p.as_vec(), b!(\"/foo\"));\n \n         handled = false;\n-        do cond.trap(|v| {\n+        cond.trap(|v| {\n             handled = true;\n             assert_eq!(v.as_slice(), b!(\"f\", 0, \"o\"));\n             (b!(\"foo\").to_owned())\n-        }).inside {\n+        }).inside(|| {\n             p.push(b!(\"f\", 0, \"o\"));\n-        };\n+        });\n         assert!(handled);\n         assert_eq!(p.as_vec(), b!(\"/foo/foo\"));\n     }\n@@ -573,29 +573,29 @@ mod tests {\n         )\n \n         t!(~\"new() w/nul\" => {\n-            do cond.trap(|_| {\n+            cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n-            }).inside {\n+            }).inside(|| {\n                 Path::new(b!(\"foo/bar\", 0))\n-            };\n+            });\n         })\n \n         t!(~\"set_filename w/nul\" => {\n             let mut p = Path::new(b!(\"foo/bar\"));\n-            do cond.trap(|_| {\n+            cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n-            }).inside {\n+            }).inside(|| {\n                 p.set_filename(b!(\"foo\", 0))\n-            };\n+            });\n         })\n \n         t!(~\"push w/nul\" => {\n             let mut p = Path::new(b!(\"foo/bar\"));\n-            do cond.trap(|_| {\n+            cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n-            }).inside {\n+            }).inside(|| {\n                 p.push(b!(\"foo\", 0))\n-            };\n+            });\n         })\n     }\n \n@@ -621,22 +621,21 @@ mod tests {\n                 {\n                     let mut called = false;\n                     let path = Path::new($path);\n-                    do path.display().with_str |s| {\n+                    path.display().with_str(|s| {\n                         assert_eq!(s, $exp);\n                         called = true;\n-                    };\n+                    });\n                     assert!(called);\n                 }\n             );\n             ($path:expr, $exp:expr, filename) => (\n                 {\n                     let mut called = false;\n                     let path = Path::new($path);\n-                    do path.filename_display().with_str |s| {\n+                    path.filename_display().with_str(|s| {\n                         assert_eq!(s, $exp);\n                         called = true;\n-\n-                    };\n+                    });\n                     assert!(called);\n                 }\n             )"}, {"sha": "cc2af54fd105c62fe2db9cf35d30f1f1a3964767", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -1248,35 +1248,35 @@ mod tests {\n         use path::null_byte::cond;\n \n         let mut handled = false;\n-        let mut p = do cond.trap(|v| {\n+        let mut p = cond.trap(|v| {\n             handled = true;\n             assert_eq!(v.as_slice(), b!(\"foo\\\\bar\", 0));\n             (b!(\"\\\\bar\").to_owned())\n-        }).inside {\n+        }).inside(|| {\n             Path::new(b!(\"foo\\\\bar\", 0))\n-        };\n+        });\n         assert!(handled);\n         assert_eq!(p.as_vec(), b!(\"\\\\bar\"));\n \n         handled = false;\n-        do cond.trap(|v| {\n+        cond.trap(|v| {\n             handled = true;\n             assert_eq!(v.as_slice(), b!(\"f\", 0, \"o\"));\n             (b!(\"foo\").to_owned())\n-        }).inside {\n+        }).inside(|| {\n             p.set_filename(b!(\"f\", 0, \"o\"))\n-        };\n+        });\n         assert!(handled);\n         assert_eq!(p.as_vec(), b!(\"\\\\foo\"));\n \n         handled = false;\n-        do cond.trap(|v| {\n+        cond.trap(|v| {\n             handled = true;\n             assert_eq!(v.as_slice(), b!(\"f\", 0, \"o\"));\n             (b!(\"foo\").to_owned())\n-        }).inside {\n+        }).inside(|| {\n             p.push(b!(\"f\", 0, \"o\"));\n-        };\n+        });\n         assert!(handled);\n         assert_eq!(p.as_vec(), b!(\"\\\\foo\\\\foo\"));\n     }\n@@ -1298,29 +1298,29 @@ mod tests {\n         )\n \n         t!(~\"from_vec() w\\\\nul\" => {\n-            do cond.trap(|_| {\n+            cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n-            }).inside {\n+            }).inside(|| {\n                 Path::new(b!(\"foo\\\\bar\", 0))\n-            };\n+            });\n         })\n \n         t!(~\"set_filename w\\\\nul\" => {\n             let mut p = Path::new(b!(\"foo\\\\bar\"));\n-            do cond.trap(|_| {\n+            cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n-            }).inside {\n+            }).inside(|| {\n                 p.set_filename(b!(\"foo\", 0))\n-            };\n+            });\n         })\n \n         t!(~\"push w\\\\nul\" => {\n             let mut p = Path::new(b!(\"foo\\\\bar\"));\n-            do cond.trap(|_| {\n+            cond.trap(|_| {\n                 (b!(\"null\", 0).to_owned())\n-            }).inside {\n+            }).inside(|| {\n                 p.push(b!(\"foo\", 0))\n-            };\n+            });\n         })\n     }\n \n@@ -1339,17 +1339,17 @@ mod tests {\n \n         let mut called = false;\n         let path = Path::new(\"foo\");\n-        do path.display().with_str |s| {\n+        path.display().with_str(|s| {\n             assert_eq!(s, \"foo\");\n             called = true;\n-        };\n+        });\n         assert!(called);\n         called = false;\n         let path = Path::new(b!(\"\\\\\"));\n-        do path.filename_display().with_str |s| {\n+        path.filename_display().with_str(|s| {\n             assert_eq!(s, \"\");\n             called = true;\n-        }\n+        });\n         assert!(called);\n     }\n "}, {"sha": "9b9636af901f241c6b52662d55c7b68fb8ec3071", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -492,28 +492,28 @@ pub mod ptr_tests {\n     fn test_position() {\n         use libc::c_char;\n \n-        do \"hello\".with_c_str |p| {\n+        \"hello\".with_c_str(|p| {\n             unsafe {\n                 assert!(2u == position(p, |c| *c == 'l' as c_char));\n                 assert!(4u == position(p, |c| *c == 'o' as c_char));\n                 assert!(5u == position(p, |c| *c == 0 as c_char));\n             }\n-        }\n+        })\n     }\n \n     #[test]\n     fn test_buf_len() {\n-        do \"hello\".with_c_str |p0| {\n-            do \"there\".with_c_str |p1| {\n-                do \"thing\".with_c_str |p2| {\n+        \"hello\".with_c_str(|p0| {\n+            \"there\".with_c_str(|p1| {\n+                \"thing\".with_c_str(|p2| {\n                     let v = ~[p0, p1, p2, null()];\n-                    do v.as_imm_buf |vp, len| {\n+                    v.as_imm_buf(|vp, len| {\n                         assert_eq!(unsafe { buf_len(vp) }, 3u);\n                         assert_eq!(len, 4u);\n-                    }\n-                }\n-            }\n-        }\n+                    })\n+                })\n+            })\n+        })\n     }\n \n     #[test]\n@@ -621,23 +621,23 @@ pub mod ptr_tests {\n                 one, two, three\n             ];\n \n-            do arr.as_imm_buf |arr_ptr, arr_len| {\n+            arr.as_imm_buf(|arr_ptr, arr_len| {\n                 let mut ctr = 0;\n                 let mut iteration_count = 0;\n-                do array_each_with_len(arr_ptr, arr_len) |e| {\n+                array_each_with_len(arr_ptr, arr_len, |e| {\n                      let actual = str::raw::from_c_str(e);\n-                     let expected = do expected_arr[ctr].with_ref |buf| {\n+                     let expected = expected_arr[ctr].with_ref(|buf| {\n                          str::raw::from_c_str(buf)\n-                     };\n+                     });\n                      debug!(\n                          \"test_ptr_array_each_with_len e: {}, a: {}\",\n                          expected, actual);\n                      assert_eq!(actual, expected);\n                      ctr += 1;\n                      iteration_count += 1;\n-                 }\n+                });\n                 assert_eq!(iteration_count, 3u);\n-            }\n+            })\n         }\n     }\n \n@@ -658,23 +658,23 @@ pub mod ptr_tests {\n                 one, two, three\n             ];\n \n-            do arr.as_imm_buf |arr_ptr, _| {\n+            arr.as_imm_buf(|arr_ptr, _| {\n                 let mut ctr = 0;\n                 let mut iteration_count = 0;\n-                do array_each(arr_ptr) |e| {\n+                array_each(arr_ptr, |e| {\n                      let actual = str::raw::from_c_str(e);\n-                     let expected = do expected_arr[ctr].with_ref |buf| {\n+                     let expected = expected_arr[ctr].with_ref(|buf| {\n                          str::raw::from_c_str(buf)\n-                     };\n+                     });\n                      debug!(\n                          \"test_ptr_array_each e: {}, a: {}\",\n                          expected, actual);\n                      assert_eq!(actual, expected);\n                      ctr += 1;\n                      iteration_count += 1;\n-                 }\n+                });\n                 assert_eq!(iteration_count, 3);\n-            }\n+            })\n         }\n     }\n "}, {"sha": "e042874245967af31fed9e5fa2f944571db63b14", "filename": "src/libstd/rand/distributions/gamma.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions%2Fgamma.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -184,11 +184,11 @@ mod bench {\n         let gamma = Gamma::new(10., 1.0);\n         let mut rng = StdRng::new();\n \n-        do bh.iter {\n+        bh.iter(|| {\n             for _ in range(0, RAND_BENCH_N) {\n                 gamma.ind_sample(&mut rng);\n             }\n-        }\n+        });\n         bh.bytes = size_of::<f64>() as u64 * RAND_BENCH_N;\n     }\n \n@@ -197,11 +197,11 @@ mod bench {\n         let gamma = Gamma::new(0.1, 1.0);\n         let mut rng = StdRng::new();\n \n-        do bh.iter {\n+        bh.iter(|| {\n             for _ in range(0, RAND_BENCH_N) {\n                 gamma.ind_sample(&mut rng);\n             }\n-        }\n+        });\n         bh.bytes = size_of::<f64>() as u64 * RAND_BENCH_N;\n     }\n }"}, {"sha": "4778e81f95169510e2ff019e9935afe3815de16d", "filename": "src/libstd/rand/distributions/mod.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions%2Fmod.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -205,12 +205,14 @@ mod ziggurat_tables;\n // the perf improvement (25-50%) is definitely worth the extra code\n // size from force-inlining.\n #[inline(always)]\n-fn ziggurat<R:Rng>(rng: &mut R,\n-                   symmetric: bool,\n-                   X: ziggurat_tables::ZigTable,\n-                   F: ziggurat_tables::ZigTable,\n-                   pdf: &'static fn(f64) -> f64,\n-                   zero_case: &'static fn(&mut R, f64) -> f64) -> f64 {\n+fn ziggurat<R:Rng>(\n+            rng: &mut R,\n+            symmetric: bool,\n+            X: ziggurat_tables::ZigTable,\n+            F: ziggurat_tables::ZigTable,\n+            pdf: 'static |f64| -> f64,\n+            zero_case: 'static |&mut R, f64| -> f64)\n+            -> f64 {\n     static SCALE: f64 = (1u64 << 53) as f64;\n     loop {\n         // reimplement the f64 generation as an optimisation suggested\n@@ -569,23 +571,23 @@ mod bench {\n         let mut rng = XorShiftRng::new();\n         let mut normal = Normal::new(-2.71828, 3.14159);\n \n-        do bh.iter {\n+        bh.iter(|| {\n             for _ in range(0, RAND_BENCH_N) {\n                 normal.sample(&mut rng);\n             }\n-        }\n+        });\n         bh.bytes = size_of::<f64>() as u64 * RAND_BENCH_N;\n     }\n     #[bench]\n     fn rand_exp(bh: &mut BenchHarness) {\n         let mut rng = XorShiftRng::new();\n         let mut exp = Exp::new(2.71828 * 3.14159);\n \n-        do bh.iter {\n+        bh.iter(|| {\n             for _ in range(0, RAND_BENCH_N) {\n                 exp.sample(&mut rng);\n             }\n-        }\n+        });\n         bh.bytes = size_of::<f64>() as u64 * RAND_BENCH_N;\n     }\n }"}, {"sha": "877df1fb644f49c443c78eb67ca2c76841d67fd8", "filename": "src/libstd/rand/isaac.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fisaac.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -51,9 +51,9 @@ impl IsaacRng {\n         unsafe {\n             let ptr = raw::to_mut_ptr(rng.rsl);\n \n-            do raw::mut_buf_as_slice(ptr as *mut u8, mem::size_of_val(&rng.rsl)) |slice| {\n+            raw::mut_buf_as_slice(ptr as *mut u8, mem::size_of_val(&rng.rsl), |slice| {\n                 OSRng::new().fill_bytes(slice);\n-            }\n+            })\n         }\n \n         rng.init(true);\n@@ -94,7 +94,7 @@ impl IsaacRng {\n             }}\n         );\n \n-        do 4.times { mix!(); }\n+        4.times(|| mix!());\n \n         if use_rsl {\n             macro_rules! memloop (\n@@ -256,9 +256,9 @@ impl Isaac64Rng {\n         unsafe {\n             let ptr = raw::to_mut_ptr(rng.rsl);\n \n-            do raw::mut_buf_as_slice(ptr as *mut u8, mem::size_of_val(&rng.rsl)) |slice| {\n+            raw::mut_buf_as_slice(ptr as *mut u8, mem::size_of_val(&rng.rsl), |slice| {\n                 OSRng::new().fill_bytes(slice);\n-            }\n+            })\n         }\n \n         rng.init(true);"}, {"sha": "ae53ef8b7c0b15ace73bdf2f66c32bfbb2270dfa", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -899,53 +899,53 @@ mod bench {\n     #[bench]\n     fn rand_xorshift(bh: &mut BenchHarness) {\n         let mut rng = XorShiftRng::new();\n-        do bh.iter {\n+        bh.iter(|| {\n             for _ in range(0, RAND_BENCH_N) {\n                 rng.gen::<uint>();\n             }\n-        }\n+        });\n         bh.bytes = size_of::<uint>() as u64 * RAND_BENCH_N;\n     }\n \n     #[bench]\n     fn rand_isaac(bh: &mut BenchHarness) {\n         let mut rng = IsaacRng::new();\n-        do bh.iter {\n+        bh.iter(|| {\n             for _ in range(0, RAND_BENCH_N) {\n                 rng.gen::<uint>();\n             }\n-        }\n+        });\n         bh.bytes = size_of::<uint>() as u64 * RAND_BENCH_N;\n     }\n \n     #[bench]\n     fn rand_isaac64(bh: &mut BenchHarness) {\n         let mut rng = Isaac64Rng::new();\n-        do bh.iter {\n+        bh.iter(|| {\n             for _ in range(0, RAND_BENCH_N) {\n                 rng.gen::<uint>();\n             }\n-        }\n+        });\n         bh.bytes = size_of::<uint>() as u64 * RAND_BENCH_N;\n     }\n \n     #[bench]\n     fn rand_std(bh: &mut BenchHarness) {\n         let mut rng = StdRng::new();\n-        do bh.iter {\n+        bh.iter(|| {\n             for _ in range(0, RAND_BENCH_N) {\n                 rng.gen::<uint>();\n             }\n-        }\n+        });\n         bh.bytes = size_of::<uint>() as u64 * RAND_BENCH_N;\n     }\n \n     #[bench]\n     fn rand_shuffle_100(bh: &mut BenchHarness) {\n         let mut rng = XorShiftRng::new();\n         let x : &mut[uint] = [1,..100];\n-        do bh.iter {\n+        bh.iter(|| {\n             rng.shuffle_mut(x);\n-        }\n+        })\n     }\n }"}, {"sha": "5558b8b33487bd08bb6e78b8f42dd8eb8bafa90d", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -111,9 +111,9 @@ impl Rng for OSRng {\n                                    pbBuffer: *mut BYTE);\n         }\n \n-        do v.as_mut_buf |ptr, len| {\n+        v.as_mut_buf(|ptr, len| {\n             unsafe {rust_win32_rand_gen(self.hcryptprov, len as DWORD, ptr)}\n-        }\n+        })\n     }\n }\n "}, {"sha": "f2beea992c67a13d430c90ec41eaf3668ce00c26", "filename": "src/libstd/rc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -177,19 +177,19 @@ mod test_rc {\n     fn test_clone() {\n         let x = Rc::from_send(RefCell::new(5));\n         let y = x.clone();\n-        do x.borrow().with_mut |inner| {\n+        x.borrow().with_mut(|inner| {\n             *inner = 20;\n-        }\n+        });\n         assert_eq!(y.borrow().with(|v| *v), 20);\n     }\n \n     #[test]\n     fn test_deep_clone() {\n         let x = Rc::from_send(RefCell::new(5));\n         let y = x.deep_clone();\n-        do x.borrow().with_mut |inner| {\n+        x.borrow().with_mut(|inner| {\n             *inner = 20;\n-        }\n+        });\n         assert_eq!(y.borrow().with(|v| *v), 5);\n     }\n "}, {"sha": "8a3e60eb3e2d521dc9da6356a47d49c6f7a6439b", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -50,16 +50,12 @@ pub fn MovePtrAdaptor<V:TyVisitor + MovePtr>(v: V) -> MovePtrAdaptor<V> {\n impl<V:TyVisitor + MovePtr> MovePtrAdaptor<V> {\n     #[inline]\n     pub fn bump(&mut self, sz: uint) {\n-        do self.inner.move_ptr() |p| {\n-            ((p as uint) + sz) as *c_void\n-        };\n+        self.inner.move_ptr(|p| ((p as uint) + sz) as *c_void)\n     }\n \n     #[inline]\n     pub fn align(&mut self, a: uint) {\n-        do self.inner.move_ptr() |p| {\n-            align(p as uint, a) as *c_void\n-        };\n+        self.inner.move_ptr(|p| align(p as uint, a) as *c_void)\n     }\n \n     #[inline]"}, {"sha": "d26989c36e66a92142eb8e8ec86b0db78efca17a", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 39, "deletions": 41, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -53,18 +53,18 @@ impl Repr for bool {\n \n impl Repr for int {\n     fn write_repr(&self, writer: &mut io::Writer) {\n-        do ::int::to_str_bytes(*self, 10u) |bits| {\n+        ::int::to_str_bytes(*self, 10u, |bits| {\n             writer.write(bits);\n-        }\n+        })\n     }\n }\n \n macro_rules! int_repr(($ty:ident, $suffix:expr) => (impl Repr for $ty {\n     fn write_repr(&self, writer: &mut io::Writer) {\n-        do ::$ty::to_str_bytes(*self, 10u) |bits| {\n+        ::$ty::to_str_bytes(*self, 10u, |bits| {\n             writer.write(bits);\n             writer.write(bytes!($suffix));\n-        }\n+        })\n     }\n }))\n \n@@ -163,9 +163,9 @@ impl<'self> ReprVisitor<'self> {\n \n     #[inline]\n     pub fn write<T:Repr>(&mut self) -> bool {\n-        do self.get |this, v:&T| {\n+        self.get(|this, v:&T| {\n             v.write_repr(unsafe { ::cast::transmute_copy(&this.writer) });\n-        }\n+        })\n     }\n \n     pub fn write_escaped_slice(&mut self, slice: &str) {\n@@ -234,9 +234,9 @@ impl<'self> ReprVisitor<'self> {\n             }\n             '\\x20'..'\\x7e' => self.writer.write([ch as u8]),\n             _ => {\n-                do char::escape_unicode(ch) |c| {\n+                char::escape_unicode(ch, |c| {\n                     self.writer.write([c as u8]);\n-                }\n+                })\n             }\n         }\n     }\n@@ -265,31 +265,29 @@ impl<'self> TyVisitor for ReprVisitor<'self> {\n     fn visit_f64(&mut self) -> bool { self.write::<f64>() }\n \n     fn visit_char(&mut self) -> bool {\n-        do self.get::<char> |this, &ch| {\n+        self.get::<char>(|this, &ch| {\n             this.writer.write(['\\'' as u8]);\n             this.write_escaped_char(ch, false);\n             this.writer.write(['\\'' as u8]);\n-        }\n+        })\n     }\n \n     fn visit_estr_box(&mut self) -> bool {\n-        do self.get::<@str> |this, s| {\n+        self.get::<@str>(|this, s| {\n             this.writer.write(['@' as u8]);\n             this.write_escaped_slice(*s);\n-        }\n+        })\n     }\n \n     fn visit_estr_uniq(&mut self) -> bool {\n-        do self.get::<~str> |this, s| {\n+        self.get::<~str>(|this, s| {\n             this.writer.write(['~' as u8]);\n             this.write_escaped_slice(*s);\n-        }\n+        })\n     }\n \n     fn visit_estr_slice(&mut self) -> bool {\n-        do self.get::<&str> |this, s| {\n-            this.write_escaped_slice(*s);\n-        }\n+        self.get::<&str>(|this, s| this.write_escaped_slice(*s))\n     }\n \n     // Type no longer exists, vestigial function.\n@@ -299,91 +297,91 @@ impl<'self> TyVisitor for ReprVisitor<'self> {\n     fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.writer.write(['@' as u8]);\n         self.write_mut_qualifier(mtbl);\n-        do self.get::<&raw::Box<()>> |this, b| {\n+        self.get::<&raw::Box<()>>(|this, b| {\n             let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n             this.visit_ptr_inner(p, inner);\n-        }\n+        })\n     }\n \n     fn visit_uniq(&mut self, _mtbl: uint, inner: *TyDesc) -> bool {\n         self.writer.write(['~' as u8]);\n-        do self.get::<*c_void> |this, b| {\n+        self.get::<*c_void>(|this, b| {\n             this.visit_ptr_inner(*b, inner);\n-        }\n+        })\n     }\n \n     fn visit_uniq_managed(&mut self, _mtbl: uint, inner: *TyDesc) -> bool {\n         self.writer.write(['~' as u8]);\n-        do self.get::<&raw::Box<()>> |this, b| {\n+        self.get::<&raw::Box<()>>(|this, b| {\n             let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n             this.visit_ptr_inner(p, inner);\n-        }\n+        })\n     }\n \n     fn visit_ptr(&mut self, mtbl: uint, _inner: *TyDesc) -> bool {\n-        do self.get::<*c_void> |this, p| {\n+        self.get::<*c_void>(|this, p| {\n             write!(this.writer, \"({} as *\", *p);\n             this.write_mut_qualifier(mtbl);\n             this.writer.write(\"())\".as_bytes());\n-        }\n+        })\n     }\n \n     fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.writer.write(['&' as u8]);\n         self.write_mut_qualifier(mtbl);\n-        do self.get::<*c_void> |this, p| {\n+        self.get::<*c_void>(|this, p| {\n             this.visit_ptr_inner(*p, inner);\n-        }\n+        })\n     }\n \n     // Type no longer exists, vestigial function.\n     fn visit_vec(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { fail!(); }\n \n     fn visit_unboxed_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<raw::Vec<()>> |this, b| {\n+        self.get::<raw::Vec<()>>(|this, b| {\n             this.write_unboxed_vec_repr(mtbl, b, inner);\n-        }\n+        })\n     }\n \n     fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<&raw::Box<raw::Vec<()>>> |this, b| {\n+        self.get::<&raw::Box<raw::Vec<()>>>(|this, b| {\n             this.writer.write(['@' as u8]);\n             this.write_mut_qualifier(mtbl);\n             this.write_unboxed_vec_repr(mtbl, &b.data, inner);\n-        }\n+        })\n     }\n \n     fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<&raw::Vec<()>> |this, b| {\n+        self.get::<&raw::Vec<()>>(|this, b| {\n             this.writer.write(['~' as u8]);\n             this.write_unboxed_vec_repr(mtbl, *b, inner);\n-        }\n+        })\n     }\n \n     fn visit_evec_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<&raw::Box<raw::Vec<()>>> |this, b| {\n+        self.get::<&raw::Box<raw::Vec<()>>>(|this, b| {\n             this.writer.write(['~' as u8]);\n             this.write_unboxed_vec_repr(mtbl, &b.data, inner);\n-        }\n+        })\n     }\n \n     fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<raw::Slice<()>> |this, s| {\n+        self.get::<raw::Slice<()>>(|this, s| {\n             this.writer.write(['&' as u8]);\n             this.write_mut_qualifier(mtbl);\n             let size = unsafe {\n                 if (*inner).size == 0 { 1 } else { (*inner).size }\n             };\n             this.write_vec_range(s.data, s.len * size, inner);\n-        }\n+        })\n     }\n \n     fn visit_evec_fixed(&mut self, n: uint, sz: uint, _align: uint,\n                         _: uint, inner: *TyDesc) -> bool {\n         let assumed_size = if sz == 0 { n } else { sz };\n-        do self.get::<()> |this, b| {\n+        self.get::<()>(|this, b| {\n             this.write_vec_range(ptr::to_unsafe_ptr(b), assumed_size, inner);\n-        }\n+        })\n     }\n \n     fn visit_enter_rec(&mut self, _n_fields: uint,\n@@ -600,10 +598,10 @@ impl<'self> TyVisitor for ReprVisitor<'self> {\n \n     fn visit_opaque_box(&mut self) -> bool {\n         self.writer.write(['@' as u8]);\n-        do self.get::<&raw::Box<()>> |this, b| {\n+        self.get::<&raw::Box<()>>(|this, b| {\n             let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n             this.visit_ptr_inner(p, b.type_desc);\n-        }\n+        })\n     }\n \n     fn visit_closure_ptr(&mut self, _ck: uint) -> bool { true }"}, {"sha": "ff425a8a73b2598ba5cf1f86537b7a30cc7e5648", "filename": "src/libstd/result.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -139,9 +139,9 @@ impl<T, E: ToStr> Result<T, E> {\n     ///\n     /// Example:\n     ///\n-    ///     let res = do read_file(file).map |buf| {\n+    ///     let res = read_file(file).map(|buf| {\n     ///         parse_bytes(buf)\n-    ///     }\n+    ///     })\n     #[inline]\n     pub fn map<U>(self, op: |T| -> U) -> Result<U,E> {\n         match self {\n@@ -462,24 +462,24 @@ mod tests {\n     pub fn test_impl_iter() {\n         let mut valid = false;\n         let okval = Ok::<~str, ~str>(~\"a\");\n-        do okval.iter().next().map |_| { valid = true; };\n+        okval.iter().next().map(|_| { valid = true; });\n         assert!(valid);\n \n         let errval = Err::<~str, ~str>(~\"b\");\n-        do errval.iter().next().map |_| { valid = false; };\n+        errval.iter().next().map(|_| { valid = false; });\n         assert!(valid);\n     }\n \n     #[test]\n     pub fn test_impl_iter_err() {\n         let mut valid = true;\n         let okval = Ok::<~str, ~str>(~\"a\");\n-        do okval.iter_err().next().map |_| { valid = false };\n+        okval.iter_err().next().map(|_| { valid = false });\n         assert!(valid);\n \n         valid = false;\n         let errval = Err::<~str, ~str>(~\"b\");\n-        do errval.iter_err().next().map |_| { valid = true };\n+        errval.iter_err().next().map(|_| { valid = true });\n         assert!(valid);\n     }\n "}, {"sha": "43e8096a8b113a6aa34640e3591865178fc39f9f", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -109,16 +109,16 @@ mod imp {\n \n     fn with_lock<T>(f: || -> T) -> T {\n         static mut lock: Mutex = MUTEX_INIT;\n-        do (|| {\n+        (|| {\n             unsafe {\n                 lock.lock();\n                 f()\n             }\n-        }).finally {\n+        }).finally(|| {\n             unsafe {\n                 lock.unlock();\n             }\n-        }\n+        })\n     }\n \n     fn get_global_ptr() -> *mut Option<~~[~str]> {\n@@ -127,9 +127,9 @@ mod imp {\n \n     // Copied from `os`.\n     unsafe fn load_argc_and_argv(argc: int, argv: **u8) -> ~[~str] {\n-        do vec::from_fn(argc as uint) |i| {\n+        vec::from_fn(argc as uint, |i| {\n             str::raw::from_c_str(*(argv as **libc::c_char).offset(i as int))\n-        }\n+        })\n     }\n \n     #[cfg(test)]\n@@ -150,14 +150,14 @@ mod imp {\n             assert!(take() == Some(expected.clone()));\n             assert!(take() == None);\n \n-            do (|| {\n-            }).finally {\n+            (|| {\n+            }).finally(|| {\n                 // Restore the actual global state.\n                 match saved_value {\n                     Some(ref args) => put(args.clone()),\n                     None => ()\n                 }\n-            }\n+            })\n         }\n     }\n }"}, {"sha": "d857f39ceaf0aa9cd94f8a92248448906ae9d61e", "filename": "src/libstd/rt/basic.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbasic.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -71,13 +71,13 @@ impl BasicLoop {\n \n     fn remote_work(&mut self) {\n         let messages = unsafe {\n-            do self.messages.with |messages| {\n+            self.messages.with(|messages| {\n                 if messages.len() > 0 {\n                     Some(util::replace(messages, ~[]))\n                 } else {\n                     None\n                 }\n-            }\n+            })\n         };\n         let messages = match messages {\n             Some(m) => m, None => return\n@@ -139,11 +139,11 @@ impl EventLoop for BasicLoop {\n             unsafe {\n                 // We block here if we have no messages to process and we may\n                 // receive a message at a later date\n-                do self.messages.hold_and_wait |messages| {\n+                self.messages.hold_and_wait(|messages| {\n                     self.remotes.len() > 0 &&\n                         messages.len() == 0 &&\n                         self.work.len() == 0\n-                }\n+                })\n             }\n         }\n     }\n@@ -189,19 +189,19 @@ impl BasicRemote {\n impl RemoteCallback for BasicRemote {\n     fn fire(&mut self) {\n         unsafe {\n-            do self.queue.hold_and_signal |queue| {\n+            self.queue.hold_and_signal(|queue| {\n                 queue.push(RunRemote(self.id));\n-            }\n+            })\n         }\n     }\n }\n \n impl Drop for BasicRemote {\n     fn drop(&mut self) {\n         unsafe {\n-            do self.queue.hold_and_signal |queue| {\n+            self.queue.hold_and_signal(|queue| {\n                 queue.push(RemoveRemote(self.id));\n-            }\n+            })\n         }\n     }\n }"}, {"sha": "30c2264bd869790afa919e109ce568d1cdf4c9e2", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -35,9 +35,7 @@ pub struct BorrowRecord {\n }\n \n fn try_take_task_borrow_list() -> Option<~[BorrowRecord]> {\n-    do Local::borrow |task: &mut Task| {\n-        task.borrow_list.take()\n-    }\n+    Local::borrow(|task: &mut Task| task.borrow_list.take())\n }\n \n fn swap_task_borrow_list(f: |~[BorrowRecord]| -> ~[BorrowRecord]) {\n@@ -47,9 +45,7 @@ fn swap_task_borrow_list(f: |~[BorrowRecord]| -> ~[BorrowRecord]) {\n     };\n     let borrows = f(borrows);\n     let borrows = Cell::new(borrows);\n-    do Local::borrow |task: &mut Task| {\n-        task.borrow_list = Some(borrows.take());\n-    }\n+    Local::borrow(|task: &mut Task| task.borrow_list = Some(borrows.take()))\n }\n \n pub fn clear_task_borrow_list() {\n@@ -64,9 +60,7 @@ unsafe fn fail_borrowed(box: *mut raw::Box<()>, file: *c_char, line: size_t) ->\n     match try_take_task_borrow_list() {\n         None => { // not recording borrows\n             let msg = \"borrowed\";\n-            do msg.with_c_str |msg_p| {\n-                task::begin_unwind_raw(msg_p, file, line);\n-            }\n+            msg.with_c_str(|msg_p| task::begin_unwind_raw(msg_p, file, line))\n         }\n         Some(borrow_list) => { // recording borrows\n             let mut msg = ~\"borrowed\";\n@@ -80,9 +74,7 @@ unsafe fn fail_borrowed(box: *mut raw::Box<()>, file: *c_char, line: size_t) ->\n                     sep = \" and at \";\n                 }\n             }\n-            do msg.with_c_str |msg_p| {\n-                task::begin_unwind_raw(msg_p, file, line)\n-            }\n+            msg.with_c_str(|msg_p| task::begin_unwind_raw(msg_p, file, line))\n         }\n     }\n }\n@@ -158,33 +150,35 @@ pub unsafe fn record_borrow(a: *u8, old_ref_count: uint,\n         // was not borrowed before\n         let a = a as *mut raw::Box<()>;\n         debug_borrow(\"record_borrow:\", a, old_ref_count, 0, file, line);\n-        do swap_task_borrow_list |borrow_list| {\n+        swap_task_borrow_list(|borrow_list| {\n             let mut borrow_list = borrow_list;\n             borrow_list.push(BorrowRecord {box: a, file: file, line: line});\n             borrow_list\n-        }\n+        })\n     }\n }\n \n-pub unsafe fn unrecord_borrow(a: *u8, old_ref_count: uint,\n-                              file: *c_char, line: size_t) {\n+pub unsafe fn unrecord_borrow(a: *u8,\n+                              old_ref_count: uint,\n+                              file: *c_char,\n+                              line: size_t) {\n     if (old_ref_count & ALL_BITS) == 0 {\n         // was not borrowed before, so we should find the record at\n         // the end of the list\n         let a = a as *mut raw::Box<()>;\n         debug_borrow(\"unrecord_borrow:\", a, old_ref_count, 0, file, line);\n-        do swap_task_borrow_list |borrow_list| {\n+        swap_task_borrow_list(|borrow_list| {\n             let mut borrow_list = borrow_list;\n             assert!(!borrow_list.is_empty());\n             let br = borrow_list.pop();\n             if br.box != a || br.file != file || br.line != line {\n                 let err = format!(\"wrong borrow found, br={:?}\", br);\n-                do err.with_c_str |msg_p| {\n+                err.with_c_str(|msg_p| {\n                     task::begin_unwind_raw(msg_p, file, line)\n-                }\n+                })\n             }\n             borrow_list\n-        }\n+        })\n     }\n }\n "}, {"sha": "06743bce9bf49a3293ac5ac46876a9cf910dcb31", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -165,14 +165,14 @@ impl<T: Send> ChanOne<T> {\n                     // Port is blocked. Wake it up.\n                     let recvr = BlockedTask::cast_from_uint(task_as_state);\n                     if do_resched {\n-                        do recvr.wake().map |woken_task| {\n+                        recvr.wake().map(|woken_task| {\n                             Scheduler::run_task(woken_task);\n-                        };\n+                        });\n                     } else {\n                         let recvr = Cell::new(recvr);\n-                        do Local::borrow |sched: &mut Scheduler| {\n+                        Local::borrow(|sched: &mut Scheduler| {\n                             sched.enqueue_blocked_task(recvr.take());\n-                        }\n+                        })\n                     }\n                 }\n             }\n@@ -209,9 +209,9 @@ impl<T: Send> PortOne<T> {\n             // No data available yet.\n             // Switch to the scheduler to put the ~Task into the Packet state.\n             let sched: ~Scheduler = Local::take();\n-            do sched.deschedule_running_task_and_then |sched, task| {\n+            sched.deschedule_running_task_and_then(|sched, task| {\n                 self.block_on(sched, task);\n-            }\n+            })\n         }\n \n         // Task resumes.\n@@ -230,9 +230,9 @@ impl<T: Send> SelectInner for PortOne<T> {\n         // The optimistic check is never necessary for correctness. For testing\n         // purposes, making it randomly return false simulates a racing sender.\n         use rand::{Rand};\n-        let actually_check = do Local::borrow |sched: &mut Scheduler| {\n+        let actually_check = Local::borrow(|sched: &mut Scheduler| {\n             Rand::rand(&mut sched.rng)\n-        };\n+        });\n         if actually_check {\n             unsafe { (*self.packet()).state.load(Acquire) == STATE_ONE }\n         } else {\n@@ -387,9 +387,9 @@ impl<T: Send> Drop for ChanOne<T> {\n                     // The port is blocked waiting for a message we will never send. Wake it.\n                     rtassert!((*self.packet()).payload.is_none());\n                     let recvr = BlockedTask::cast_from_uint(task_as_state);\n-                    do recvr.wake().map |woken_task| {\n+                    recvr.wake().map(|woken_task| {\n                         Scheduler::run_task(woken_task);\n-                    };\n+                    });\n                 }\n             }\n         }\n@@ -491,15 +491,15 @@ impl<T: Send> GenericPort<T> for Port<T> {\n \n     fn try_recv(&self) -> Option<T> {\n         let mut b = self.next.borrow_mut();\n-        do b.get().take().map_default(None) |pone| {\n+        b.get().take().map_default(None, |pone| {\n             match pone.try_recv() {\n                 Some(StreamPayload { val, next }) => {\n                     *b.get() = Some(next);\n                     Some(val)\n                 }\n                 None => None\n             }\n-        }\n+        })\n     }\n }\n \n@@ -516,7 +516,7 @@ impl<T: Send> Peekable<T> for Port<T> {\n impl<'self, T: Send> SelectInner for &'self Port<T> {\n     #[inline]\n     fn optimistic_check(&mut self) -> bool {\n-        do self.next.with_mut |pone| { pone.get_mut_ref().optimistic_check() }\n+        self.next.with_mut(|pone| { pone.get_mut_ref().optimistic_check() })\n     }\n \n     #[inline]\n@@ -527,7 +527,7 @@ impl<'self, T: Send> SelectInner for &'self Port<T> {\n \n     #[inline]\n     fn unblock_from(&mut self) -> bool {\n-        do self.next.with_mut |pone| { pone.get_mut_ref().unblock_from() }\n+        self.next.with_mut(|pone| { pone.get_mut_ref().unblock_from() })\n     }\n }\n \n@@ -871,7 +871,7 @@ mod test {\n     #[test]\n     fn oneshot_multi_thread_close_stress() {\n         if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-        do stress_factor().times {\n+        stress_factor().times(|| {\n             do run_in_newsched_task {\n                 let (port, chan) = oneshot::<int>();\n                 let port_cell = Cell::new(port);\n@@ -881,13 +881,13 @@ mod test {\n                 let _chan = chan;\n                 thread.join();\n             }\n-        }\n+        })\n     }\n \n     #[test]\n     fn oneshot_multi_thread_send_close_stress() {\n         if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-        do stress_factor().times {\n+        stress_factor().times(|| {\n             do run_in_newsched_task {\n                 let (port, chan) = oneshot::<int>();\n                 let chan_cell = Cell::new(chan);\n@@ -902,13 +902,13 @@ mod test {\n                 thread1.join();\n                 thread2.join();\n             }\n-        }\n+        })\n     }\n \n     #[test]\n     fn oneshot_multi_thread_recv_close_stress() {\n         if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-        do stress_factor().times {\n+        stress_factor().times(|| {\n             do run_in_newsched_task {\n                 let (port, chan) = oneshot::<int>();\n                 let chan_cell = Cell::new(chan);\n@@ -929,13 +929,13 @@ mod test {\n                 thread1.join();\n                 thread2.join();\n             }\n-        }\n+        })\n     }\n \n     #[test]\n     fn oneshot_multi_thread_send_recv_stress() {\n         if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-        do stress_factor().times {\n+        stress_factor().times(|| {\n             do run_in_newsched_task {\n                 let (port, chan) = oneshot::<~int>();\n                 let chan_cell = Cell::new(chan);\n@@ -949,13 +949,13 @@ mod test {\n                 thread1.join();\n                 thread2.join();\n             }\n-        }\n+        })\n     }\n \n     #[test]\n     fn stream_send_recv_stress() {\n         if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-        do stress_factor().times {\n+        stress_factor().times(|| {\n             do run_in_mt_newsched_task {\n                 let (port, chan) = stream::<~int>();\n \n@@ -984,16 +984,16 @@ mod test {\n                     };\n                 }\n             }\n-        }\n+        })\n     }\n \n     #[test]\n     fn recv_a_lot() {\n         // Regression test that we don't run out of stack in scheduler context\n         do run_in_newsched_task {\n             let (port, chan) = stream();\n-            do 10000.times { chan.send(()) }\n-            do 10000.times { port.recv() }\n+            10000.times(|| { chan.send(()) });\n+            10000.times(|| { port.recv() });\n         }\n     }\n \n@@ -1004,16 +1004,16 @@ mod test {\n             let (port, chan) = stream();\n             let chan = SharedChan::new(chan);\n             let total = stress_factor() + 100;\n-            do total.times {\n+            total.times(|| {\n                 let chan_clone = chan.clone();\n                 do spawntask_random {\n                     chan_clone.send(());\n                 }\n-            }\n+            });\n \n-            do total.times {\n+            total.times(|| {\n                 port.recv();\n-            }\n+            });\n         }\n     }\n \n@@ -1026,22 +1026,22 @@ mod test {\n             let end_chan = SharedChan::new(end_chan);\n             let port = SharedPort::new(port);\n             let total = stress_factor() + 100;\n-            do total.times {\n+            total.times(|| {\n                 let end_chan_clone = end_chan.clone();\n                 let port_clone = port.clone();\n                 do spawntask_random {\n                     port_clone.recv();\n                     end_chan_clone.send(());\n                 }\n-            }\n+            });\n \n-            do total.times {\n+            total.times(|| {\n                 chan.send(());\n-            }\n+            });\n \n-            do total.times {\n+            total.times(|| {\n                 end_port.recv();\n-            }\n+            });\n         }\n     }\n \n@@ -1066,29 +1066,29 @@ mod test {\n             let send_total = 10;\n             let recv_total = 20;\n             do spawntask_random {\n-                do send_total.times {\n+                send_total.times(|| {\n                     let chan_clone = chan.clone();\n                     do spawntask_random {\n                         chan_clone.send(());\n                     }\n-                }\n+                });\n             }\n             let end_chan_clone = end_chan.clone();\n             do spawntask_random {\n-                do recv_total.times {\n+                recv_total.times(|| {\n                     let port_clone = port.clone();\n                     let end_chan_clone = end_chan_clone.clone();\n                     do spawntask_random {\n                         let recvd = port_clone.try_recv().is_some();\n                         end_chan_clone.send(recvd);\n                     }\n-                }\n+                });\n             }\n \n             let mut recvd = 0;\n-            do recv_total.times {\n+            recv_total.times(|| {\n                 recvd += if end_port.recv() { 1 } else { 0 };\n-            }\n+            });\n \n             assert!(recvd == send_total);\n         }\n@@ -1107,25 +1107,25 @@ mod test {\n             let pipe = megapipe();\n             let total = stress_factor() + 10;\n             let mut rng = rand::rng();\n-            do total.times {\n+            total.times(|| {\n                 let msgs = rng.gen_range(0u, 10);\n                 let pipe_clone = pipe.clone();\n                 let end_chan_clone = end_chan.clone();\n                 do spawntask_random {\n-                    do msgs.times {\n+                    msgs.times(|| {\n                         pipe_clone.send(());\n-                    }\n-                    do msgs.times {\n+                    });\n+                    msgs.times(|| {\n                         pipe_clone.recv();\n-                    }\n+                    });\n                 }\n \n                 end_chan_clone.send(());\n-            }\n+            });\n \n-            do total.times {\n+            total.times(|| {\n                 end_port.recv();\n-            }\n+            });\n         }\n     }\n \n@@ -1152,13 +1152,13 @@ mod test {\n \n             let cs = Cell::new((cone, cstream, cshared, mp));\n             unsafe {\n-                do atomically {\n+                atomically(|| {\n                     let (cone, cstream, cshared, mp) = cs.take();\n                     cone.send_deferred(());\n                     cstream.send_deferred(());\n                     cshared.send_deferred(());\n                     mp.send_deferred(());\n-                }\n+                })\n             }\n         }\n     }"}, {"sha": "6dcbd4a129e5c62ef7d227ca2e9c3f163fe7f366", "filename": "src/libstd/rt/crate_map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Fcrate_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Fcrate_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcrate_map.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -61,9 +61,9 @@ pub fn get_crate_map() -> Option<&'static CrateMap<'static>> {\n         } else {\n             \"_rust_crate_map_toplevel\"\n         };\n-        let sym = do rust_crate_map_toplevel.with_c_str |buf| {\n+        let sym = rust_crate_map_toplevel.with_c_str(|buf| {\n             dl::symbol(module, buf)\n-        };\n+        });\n         dl::close(module);\n         sym\n     };\n@@ -141,10 +141,10 @@ mod tests {\n \n         let mut cnt = 0;\n         unsafe {\n-            do iter_crate_map(&root_crate) |entry| {\n+            iter_crate_map(&root_crate, |entry| {\n                 assert!(*entry.log_level == 3);\n                 cnt += 1;\n-            }\n+            });\n             assert!(cnt == 1);\n         }\n     }\n@@ -183,10 +183,10 @@ mod tests {\n \n         let mut cnt = 0;\n         unsafe {\n-            do iter_crate_map(&root_crate) |entry| {\n+            iter_crate_map(&root_crate, |entry| {\n                 assert!(*entry.log_level == cnt);\n                 cnt += 1;\n-            }\n+            });\n             assert!(cnt == 4);\n         }\n     }"}, {"sha": "3147e3c8a078e18e6196a10043f10598908c7638", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -103,15 +103,15 @@ mod bench {\n \n     #[bench]\n     fn alloc_owned_small(bh: &mut BenchHarness) {\n-        do bh.iter {\n+        bh.iter(|| {\n             ~10;\n-        }\n+        })\n     }\n \n     #[bench]\n     fn alloc_owned_big(bh: &mut BenchHarness) {\n-        do bh.iter {\n+        bh.iter(|| {\n             ~[10, ..1000];\n-        }\n+        })\n     }\n }"}, {"sha": "56c77ffaa0d3772a18d7a4adc298f1410fa238fa", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -257,10 +257,7 @@ impl Death {\n     /// Collect failure exit codes from children and propagate them to a parent.\n     pub fn collect_failure(&mut self, result: UnwindResult) {\n         let result = Cell::new(result);\n-\n-        do self.on_exit.take().map |on_exit| {\n-            on_exit(result.take());\n-        };\n+        self.on_exit.take().map(|on_exit| on_exit(result.take()));\n     }\n \n     /// Enter a possibly-nested \"atomic\" section of code. Just for assertions."}, {"sha": "3e4072e617a4e1656ea31cb7052bf1e0a526d351", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -34,10 +34,10 @@ impl Local for Task {\n         let mut res: Option<T> = None;\n         let res_ptr: *mut Option<T> = &mut res;\n         unsafe {\n-            do local_ptr::borrow |task| {\n+            local_ptr::borrow(|task| {\n                 let result = f(task);\n                 *res_ptr = Some(result);\n-            }\n+            })\n         }\n         match res {\n             Some(r) => { r }\n@@ -57,10 +57,10 @@ impl Local for Task {\n impl Local for Scheduler {\n     fn put(value: ~Scheduler) {\n         let value = Cell::new(value);\n-        do Local::borrow |task: &mut Task| {\n+        Local::borrow(|task: &mut Task| {\n             let task = task;\n             task.sched = Some(value.take());\n-        };\n+        });\n     }\n     #[inline]\n     fn take() -> ~Scheduler {\n@@ -71,15 +71,15 @@ impl Local for Scheduler {\n         }\n     }\n     fn exists(_: Option<Scheduler>) -> bool {\n-        do Local::borrow |task: &mut Task| {\n+        Local::borrow(|task: &mut Task| {\n             match task.sched {\n                 Some(ref _task) => true,\n                 None => false\n             }\n-        }\n+        })\n     }\n     fn borrow<T>(f: |&mut Scheduler| -> T) -> T {\n-        do Local::borrow |task: &mut Task| {\n+        Local::borrow(|task: &mut Task| {\n             match task.sched {\n                 Some(~ref mut task) => {\n                     f(task)\n@@ -88,7 +88,7 @@ impl Local for Scheduler {\n                     rtabort!(\"no scheduler\")\n                 }\n             }\n-        }\n+        })\n     }\n     unsafe fn unsafe_take() -> ~Scheduler { rtabort!(\"unimpl\") }\n     unsafe fn unsafe_borrow() -> *mut Scheduler {\n@@ -134,7 +134,7 @@ mod test {\n         do run_in_bare_thread {\n             local_ptr::init_tls_key();\n             let mut sched = ~new_test_uv_sched();\n-            let task = ~Task::new_root(&mut sched.stack_pool, None, || {});\n+            let task = ~Task::new_root(&mut sched.stack_pool, None, proc(){});\n             Local::put(task);\n             let task: ~Task = Local::take();\n             cleanup_task(task);\n@@ -146,11 +146,11 @@ mod test {\n         do run_in_bare_thread {\n             local_ptr::init_tls_key();\n             let mut sched = ~new_test_uv_sched();\n-            let task = ~Task::new_root(&mut sched.stack_pool, None, || {});\n+            let task = ~Task::new_root(&mut sched.stack_pool, None, proc(){});\n             Local::put(task);\n             let task: ~Task = Local::take();\n             cleanup_task(task);\n-            let task = ~Task::new_root(&mut sched.stack_pool, None, || {});\n+            let task = ~Task::new_root(&mut sched.stack_pool, None, proc(){});\n             Local::put(task);\n             let task: ~Task = Local::take();\n             cleanup_task(task);\n@@ -163,7 +163,7 @@ mod test {\n         do run_in_bare_thread {\n             local_ptr::init_tls_key();\n             let mut sched = ~new_test_uv_sched();\n-            let task = ~Task::new_root(&mut sched.stack_pool, None, || {});\n+            let task = ~Task::new_root(&mut sched.stack_pool, None, proc(){});\n             Local::put(task);\n \n             unsafe {\n@@ -179,12 +179,12 @@ mod test {\n         do run_in_bare_thread {\n             local_ptr::init_tls_key();\n             let mut sched = ~new_test_uv_sched();\n-            let task = ~Task::new_root(&mut sched.stack_pool, None, || {});\n+            let task = ~Task::new_root(&mut sched.stack_pool, None, proc(){});\n             Local::put(task);\n \n-            let res = do Local::borrow |_task: &mut Task| {\n+            let res = Local::borrow(|_task: &mut Task| {\n                 true\n-            };\n+            });\n             assert!(res)\n                 let task: ~Task = Local::take();\n             cleanup_task(task);"}, {"sha": "c98a66453eb158bd0a74eb918e6a5ebd562b231d", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -302,9 +302,7 @@ pub unsafe fn local_free(ptr: *libc::c_char) {\n }\n \n pub fn live_allocs() -> *mut Box {\n-    do Local::borrow |task: &mut Task| {\n-        task.heap.live_allocs\n-    }\n+    Local::borrow(|task: &mut Task| task.heap.live_allocs)\n }\n \n #[cfg(test)]\n@@ -313,15 +311,11 @@ mod bench {\n \n     #[bench]\n     fn alloc_managed_small(bh: &mut BenchHarness) {\n-        do bh.iter {\n-            @10;\n-        }\n+        bh.iter(|| { @10; });\n     }\n \n     #[bench]\n     fn alloc_managed_big(bh: &mut BenchHarness) {\n-        do bh.iter {\n-            @[10, ..1000];\n-        }\n+        bh.iter(|| { @[10, ..1000]; });\n     }\n }"}, {"sha": "eb7d8ef2f5fe2b2dca3e23d840299512fd140685", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -110,11 +110,7 @@ pub unsafe fn borrow<T>(f: |&mut T|) {\n     let unsafe_ptr = cast::transmute_mut_region(&mut *value);\n     let value_cell = Cell::new(value);\n \n-    do (|| {\n-        f(unsafe_ptr);\n-    }).finally {\n-        put(value_cell.take());\n-    }\n+    (|| f(unsafe_ptr)).finally(|| put(value_cell.take()));\n }\n \n /// Borrow a mutable reference to the thread-local value"}, {"sha": "13e18f7d9b75ee83c5c8d82f41bc6fc3d6a23c11", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -142,19 +142,17 @@ fn update_log_settings(crate_map: &CrateMap, settings: ~str) {\n     if settings.len() > 0 {\n         if settings == ~\"::help\" || settings == ~\"?\" {\n             rterrln!(\"\\nCrate log map:\\n\");\n-            do iter_crate_map(crate_map) |entry| {\n-                rterrln!(\" {}\", entry.name);\n-            }\n+            iter_crate_map(crate_map, |entry| rterrln!(\" {}\", entry.name));\n             unsafe { exit(1); }\n         }\n         dirs = parse_logging_spec(settings);\n     }\n \n     let mut n_matches: u32 = 0;\n-    do iter_crate_map(crate_map) |entry| {\n+    iter_crate_map(crate_map, |entry| {\n         let m = update_entry(dirs, entry);\n         n_matches += m;\n-    }\n+    });\n \n     if n_matches < (dirs.len() as u32) {\n         rterrln!(\"warning: got {} RUST_LOG specs but only matched\\n\\"}, {"sha": "a8b510cbed7885fe67cd3379af131d3befed2333", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -340,14 +340,14 @@ fn run_(main: proc(), use_main_sched: bool) -> int {\n \n     // When the main task exits, after all the tasks in the main\n     // task tree, shut down the schedulers and set the exit code.\n-    let handles = Cell::new(handles);\n-    let on_exit: proc(UnwindResult) = |exit_success| {\n+    let handles = handles;\n+    let on_exit: proc(UnwindResult) = proc(exit_success) {\n         unsafe {\n             assert!(!(*exited_already.get()).swap(true, SeqCst),\n                     \"the runtime already exited\");\n         }\n \n-        let mut handles = handles.take();\n+        let mut handles = handles;\n         for handle in handles.mut_iter() {\n             handle.send(Shutdown);\n         }"}, {"sha": "7f607fcf12a63a70290add3a0b4cb3fe57191688", "filename": "src/libstd/rt/mpmc_bounded_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Fmpmc_bounded_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Fmpmc_bounded_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmpmc_bounded_queue.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -68,9 +68,9 @@ impl<T: Send> State<T> {\n         } else {\n             capacity\n         };\n-        let buffer = do vec::from_fn(capacity) |i:uint| {\n+        let buffer = vec::from_fn(capacity, |i:uint| {\n             Node{sequence:AtomicUint::new(i),value:None}\n-        };\n+        });\n         State{\n             pad0: [0, ..64],\n             buffer: buffer,"}, {"sha": "9a48fc51329994773d0a923bfe7c08a8398060ab", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -236,9 +236,9 @@ impl Scheduler {\n             // Our scheduler must be in the task before the event loop\n             // is started.\n             let self_sched = Cell::new(self);\n-            do Local::borrow |stask: &mut Task| {\n+            Local::borrow(|stask: &mut Task| {\n                 stask.sched = Some(self_sched.take());\n-            };\n+            });\n \n             (*event_loop).run();\n         }\n@@ -538,9 +538,7 @@ impl Scheduler {\n     /// As enqueue_task, but with the possibility for the blocked task to\n     /// already have been killed.\n     pub fn enqueue_blocked_task(&mut self, blocked_task: BlockedTask) {\n-        do blocked_task.wake().map |task| {\n-            self.enqueue_task(task);\n-        };\n+        blocked_task.wake().map(|task| self.enqueue_task(task));\n     }\n \n     // * Core Context Switching Functions\n@@ -643,9 +641,9 @@ impl Scheduler {\n     // * Context Swapping Helpers - Here be ugliness!\n \n     pub fn resume_task_immediately(~self, task: ~Task) {\n-        do self.change_task_context(task) |sched, stask| {\n+        self.change_task_context(task, |sched, stask| {\n             sched.sched_task = Some(stask);\n-        }\n+        })\n     }\n \n     fn resume_task_immediately_cl(sched: ~Scheduler,\n@@ -686,15 +684,15 @@ impl Scheduler {\n                                          f: |&mut Scheduler, BlockedTask|) {\n         // This is where we convert the BlockedTask-taking closure into one\n         // that takes just a Task\n-        do self.change_task_context(next_task) |sched, task| {\n+        self.change_task_context(next_task, |sched, task| {\n             f(sched, BlockedTask::block(task))\n-        }\n+        })\n     }\n \n     fn switch_task(sched: ~Scheduler, task: ~Task) {\n-        do sched.switch_running_tasks_and_then(task) |sched, last_task| {\n+        sched.switch_running_tasks_and_then(task, |sched, last_task| {\n             sched.enqueue_blocked_task(last_task);\n-        };\n+        });\n     }\n \n     // * Task Context Helpers\n@@ -705,10 +703,10 @@ impl Scheduler {\n         // Similar to deschedule running task and then, but cannot go through\n         // the task-blocking path. The task is already dying.\n         let stask = self.sched_task.take_unwrap();\n-        do self.change_task_context(stask) |sched, mut dead_task| {\n+        self.change_task_context(stask, |sched, mut dead_task| {\n             let coroutine = dead_task.coroutine.take_unwrap();\n             coroutine.recycle(&mut sched.stack_pool);\n-        }\n+        })\n     }\n \n     pub fn run_task(task: ~Task) {\n@@ -718,9 +716,9 @@ impl Scheduler {\n \n     pub fn run_task_later(next_task: ~Task) {\n         let next_task = Cell::new(next_task);\n-        do Local::borrow |sched: &mut Scheduler| {\n+        Local::borrow(|sched: &mut Scheduler| {\n             sched.enqueue_task(next_task.take());\n-        };\n+        });\n     }\n \n     /// Yield control to the scheduler, executing another task. This is guaranteed\n@@ -731,9 +729,9 @@ impl Scheduler {\n         self.yield_check_count = reset_yield_check(&mut self.rng);\n         // Tell the scheduler to start stealing on the next iteration\n         self.steal_for_yield = true;\n-        do self.deschedule_running_task_and_then |sched, task| {\n+        self.deschedule_running_task_and_then(|sched, task| {\n             sched.enqueue_blocked_task(task);\n-        }\n+        })\n     }\n \n     pub fn maybe_yield(mut ~self) {\n@@ -852,23 +850,23 @@ fn new_sched_rng() -> XorShiftRng {\n     use iter::Iterator;\n     use rand::SeedableRng;\n \n-    let fd = do \"/dev/urandom\".with_c_str |name| {\n+    let fd = \"/dev/urandom\".with_c_str(|name| {\n         unsafe { libc::open(name, libc::O_RDONLY, 0) }\n-    };\n+    });\n     if fd == -1 {\n         rtabort!(\"could not open /dev/urandom for reading.\")\n     }\n \n     let mut seeds = [0u32, .. 4];\n     let size = mem::size_of_val(&seeds);\n     loop {\n-        let nbytes = do seeds.as_mut_buf |buf, _| {\n+        let nbytes = seeds.as_mut_buf(|buf, _| {\n             unsafe {\n                 libc::read(fd,\n                            buf as *mut libc::c_void,\n                            size as libc::size_t)\n             }\n-        };\n+        });\n         rtassert!(nbytes as uint == size);\n \n         if !seeds.iter().all(|x| *x == 0) {\n@@ -981,7 +979,7 @@ mod test {\n                 assert!(Task::on_appropriate_sched());\n             };\n \n-            let on_exit: proc(UnwindResult) = |exit_status| {\n+            let on_exit: proc(UnwindResult) = proc(exit_status) {\n                 rtassert!(exit_status.is_success())\n             };\n             task.death.on_exit = Some(on_exit);\n@@ -1178,7 +1176,7 @@ mod test {\n         use util;\n \n         do run_in_bare_thread {\n-            do stress_factor().times {\n+            stress_factor().times(|| {\n                 let sleepers = SleeperList::new();\n                 let queue = WorkQueue::new();\n                 let queues = ~[queue.clone()];\n@@ -1195,19 +1193,22 @@ mod test {\n \n                 let thread = do Thread::start {\n                     let mut sched = sched.take();\n-                    let bootstrap_task = ~Task::new_root(&mut sched.stack_pool, None, ||());\n+                    let bootstrap_task =\n+                        ~Task::new_root(&mut sched.stack_pool,\n+                                        None,\n+                                        proc()());\n                     sched.bootstrap(bootstrap_task);\n                 };\n \n                 let mut stack_pool = StackPool::new();\n-                let task = ~Task::new_root(&mut stack_pool, None, ||());\n+                let task = ~Task::new_root(&mut stack_pool, None, proc()());\n                 handle.send(TaskFromFriend(task));\n \n                 handle.send(Shutdown);\n                 util::ignore(handle);\n \n                 thread.join();\n-            }\n+            })\n         }\n     }\n \n@@ -1220,14 +1221,14 @@ mod test {\n \n         do run_in_mt_newsched_task {\n             let mut ports = ~[];\n-            do 10.times {\n+            10.times(|| {\n                 let (port, chan) = oneshot();\n                 let chan_cell = Cell::new(chan);\n                 do spawntask_later {\n                     chan_cell.take().send(());\n                 }\n                 ports.push(port);\n-            }\n+            });\n \n             while !ports.is_empty() {\n                 ports.pop().recv();\n@@ -1317,7 +1318,7 @@ mod test {\n     fn dont_starve_1() {\n         use rt::comm::oneshot;\n \n-        do stress_factor().times {\n+        stress_factor().times(|| {\n             do run_in_mt_newsched_task {\n                 let (port, chan) = oneshot();\n \n@@ -1329,14 +1330,14 @@ mod test {\n \n                 chan.send(());\n             }\n-        }\n+        })\n     }\n \n     #[test]\n     fn dont_starve_2() {\n         use rt::comm::oneshot;\n \n-        do stress_factor().times {\n+        stress_factor().times(|| {\n             do run_in_newsched_task {\n                 let (port, chan) = oneshot();\n                 let (_port2, chan2) = stream();\n@@ -1351,7 +1352,7 @@ mod test {\n \n                 chan.send(());\n             }\n-        }\n+        })\n     }\n \n     // Regression test for a logic bug that would cause single-threaded schedulers\n@@ -1362,7 +1363,7 @@ mod test {\n         use num::Times;\n \n         do spawn_sched(SingleThreaded) {\n-            do 5.times { deschedule(); }\n+            5.times(|| { deschedule(); })\n         }\n         do spawn { }\n         do spawn { }"}, {"sha": "68164eb93459a321c6b21b74bf72c479db8786d0", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -142,15 +142,15 @@ impl Task {\n                              -> ~Task {\n         let f = Cell::new(f);\n         let home = Cell::new(home);\n-        do Local::borrow |running_task: &mut Task| {\n+        Local::borrow(|running_task: &mut Task| {\n             let mut sched = running_task.sched.take_unwrap();\n             let new_task = ~running_task.new_child_homed(&mut sched.stack_pool,\n                                                          stack_size,\n                                                          home.take(),\n                                                          f.take());\n             running_task.sched = Some(sched);\n             new_task\n-        }\n+        })\n     }\n \n     pub fn build_child(stack_size: Option<uint>, f: proc()) -> ~Task {\n@@ -163,15 +163,15 @@ impl Task {\n                             -> ~Task {\n         let f = Cell::new(f);\n         let home = Cell::new(home);\n-        do Local::borrow |running_task: &mut Task| {\n+        Local::borrow(|running_task: &mut Task| {\n             let mut sched = running_task.sched.take_unwrap();\n             let new_task = ~Task::new_root_homed(&mut sched.stack_pool,\n                                                  stack_size,\n                                                  home.take(),\n                                                  f.take());\n             running_task.sched = Some(sched);\n             new_task\n-        }\n+        })\n     }\n \n     pub fn build_root(stack_size: Option<uint>, f: proc()) -> ~Task {\n@@ -280,10 +280,10 @@ impl Task {\n \n         // The only try/catch block in the world. Attempt to run the task's\n         // client-specified code and catch any failures.\n-        do self.unwinder.try {\n+        self.unwinder.try(|| {\n \n             // Run the task main function, then do some cleanup.\n-            do f.finally {\n+            f.finally(|| {\n \n                 // First, destroy task-local storage. This may run user dtors.\n                 //\n@@ -320,8 +320,8 @@ impl Task {\n                     None => {}\n                 }\n                 self.logger.take();\n-            }\n-        }\n+            })\n+        });\n \n         // Cleanup the dynamic borrowck debugging info\n         borrowck::clear_task_borrow_list();\n@@ -364,7 +364,7 @@ impl Task {\n     // Grab both the scheduler and the task from TLS and check if the\n     // task is executing on an appropriate scheduler.\n     pub fn on_appropriate_sched() -> bool {\n-        do Local::borrow |task: &mut Task| {\n+        Local::borrow(|task: &mut Task| {\n             let sched_id = task.sched.get_ref().sched_id();\n             let sched_run_anything = task.sched.get_ref().run_anything;\n             match task.task_type {\n@@ -383,7 +383,7 @@ impl Task {\n                     rtabort!(\"type error: expected: GreenTask, found: SchedTask\");\n                 }\n             }\n-        }\n+        })\n     }\n }\n \n@@ -425,15 +425,15 @@ impl Coroutine {\n \n     fn build_start_wrapper(start: proc()) -> proc() {\n         let start_cell = Cell::new(start);\n-        let wrapper: proc() = || {\n+        let wrapper: proc() = proc() {\n             // First code after swap to this new context. Run our\n             // cleanup job.\n             unsafe {\n \n                 // Again - might work while safe, or it might not.\n-                do Local::borrow |sched: &mut Scheduler| {\n+                Local::borrow(|sched: &mut Scheduler| {\n                     sched.run_cleanup_job();\n-                }\n+                });\n \n                 // To call the run method on a task we need a direct\n                 // reference to it. The task is in TLS, so we can\n@@ -442,7 +442,7 @@ impl Coroutine {\n                 // need to unsafe_borrow.\n                 let task: *mut Task = Local::unsafe_borrow();\n \n-                do (*task).run {\n+                (*task).run(|| {\n                     // N.B. Removing `start` from the start wrapper\n                     // closure by emptying a cell is critical for\n                     // correctness. The ~Task pointer, and in turn the\n@@ -455,7 +455,7 @@ impl Coroutine {\n                     // scope while the task is still running.\n                     let start = start_cell.take();\n                     start();\n-                };\n+                });\n             }\n \n             // We remove the sched from the Task in TLS right now.\n@@ -584,7 +584,7 @@ pub extern \"C\" fn rust_stack_exhausted() {\n         //  #2361 - possible implementation of not using landing pads\n \n         if in_green_task_context() {\n-            do Local::borrow |task: &mut Task| {\n+            Local::borrow(|task: &mut Task| {\n                 let n = task.name.as_ref().map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n \n                 // See the message below for why this is not emitted to the\n@@ -593,7 +593,7 @@ pub extern \"C\" fn rust_stack_exhausted() {\n                 // call would happen to initialized it (calling out to libuv),\n                 // and the FFI call needs 2MB of stack when we just ran out.\n                 rterrln!(\"task '{}' has overflowed its stack\", n);\n-            }\n+            })\n         } else {\n             rterrln!(\"stack overflow in non-task context\");\n         }\n@@ -712,10 +712,10 @@ mod test {\n     #[test]\n     fn unwind() {\n         do run_in_newsched_task() {\n-            let result = spawntask_try(||());\n+            let result = spawntask_try(proc()());\n             rtdebug!(\"trying first assert\");\n             assert!(result.is_ok());\n-            let result = spawntask_try(|| fail!());\n+            let result = spawntask_try(proc() fail!());\n             rtdebug!(\"trying second assert\");\n             assert!(result.is_err());\n         }"}, {"sha": "867d997e98d15a357f31048ae8d59da9402321e5", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -83,10 +83,11 @@ pub fn run_in_uv_task_core(f: proc()) {\n     use rt::sched::Shutdown;\n \n     let mut sched = ~new_test_uv_sched();\n-    let exit_handle = Cell::new(sched.make_handle());\n+    let exit_handle = sched.make_handle();\n \n-    let on_exit: proc(UnwindResult) = |exit_status| {\n-        exit_handle.take().send(Shutdown);\n+    let on_exit: proc(UnwindResult) = proc(exit_status: UnwindResult) {\n+        let mut exit_handle = exit_handle;\n+        exit_handle.send(Shutdown);\n         rtassert!(exit_status.is_success());\n     };\n     let mut task = ~Task::new_root(&mut sched.stack_pool, None, f);\n@@ -99,10 +100,11 @@ pub fn run_in_newsched_task_core(f: proc()) {\n     use rt::sched::Shutdown;\n \n     let mut sched = ~new_test_sched();\n-    let exit_handle = Cell::new(sched.make_handle());\n+    let exit_handle = sched.make_handle();\n \n-    let on_exit: proc(UnwindResult) = |exit_status| {\n-        exit_handle.take().send(Shutdown);\n+    let on_exit: proc(UnwindResult) = proc(exit_status: UnwindResult) {\n+        let mut exit_handle = exit_handle;\n+        exit_handle.send(Shutdown);\n         rtassert!(exit_status.is_success());\n     };\n     let mut task = ~Task::new_root(&mut sched.stack_pool, None, f);\n@@ -244,10 +246,10 @@ pub fn run_in_mt_newsched_task(f: proc()) {\n             scheds.push(sched);\n         }\n \n-        let handles = Cell::new(handles);\n-        let on_exit: proc(UnwindResult) = |exit_status| {\n-            let mut handles = handles.take();\n+        let handles = handles;  // Work around not being able to capture mut\n+        let on_exit: proc(UnwindResult) = proc(exit_status: UnwindResult) {\n             // Tell schedulers to exit\n+            let mut handles = handles;\n             for handle in handles.mut_iter() {\n                 handle.send(Shutdown);\n             }\n@@ -319,8 +321,9 @@ pub fn spawntask_random(f: proc()) {\n pub fn spawntask_try(f: proc()) -> Result<(),()> {\n \n     let (port, chan) = oneshot();\n-    let chan = Cell::new(chan);\n-    let on_exit: proc(UnwindResult) = |exit_status| chan.take().send(exit_status);\n+    let on_exit: proc(UnwindResult) = proc(exit_status) {\n+        chan.send(exit_status)\n+    };\n \n     let mut new_task = Task::build_root(None, f);\n     new_task.death.on_exit = Some(on_exit);\n@@ -348,7 +351,9 @@ pub fn spawntask_thread(f: proc()) -> Thread {\n pub fn with_test_task(blk: proc(~Task) -> ~Task) {\n     do run_in_bare_thread {\n         let mut sched = ~new_test_sched();\n-        let task = blk(~Task::new_root(&mut sched.stack_pool, None, ||{}));\n+        let task = blk(~Task::new_root(&mut sched.stack_pool,\n+                                       None,\n+                                       proc() {}));\n         cleanup_task(task);\n     }\n }"}, {"sha": "0d4171d5a643ca1c70a44b25cfe68631ee201e8b", "filename": "src/libstd/rt/tube.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Ftube.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Ftube.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftube.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -68,9 +68,9 @@ impl<T> Tube<T> {\n                 assert!(self.p.refcount() > 1); // There better be somebody to wake us up\n                 assert!((*state).blocked_task.is_none());\n                 let sched: ~Scheduler = Local::take();\n-                do sched.deschedule_running_task_and_then |_, task| {\n+                sched.deschedule_running_task_and_then(|_, task| {\n                     (*state).blocked_task = Some(task);\n-                }\n+                });\n                 rtdebug!(\"waking after tube recv\");\n                 let buf = &mut (*state).buf;\n                 assert!(!buf.is_empty());\n@@ -103,11 +103,11 @@ mod test {\n             let tube_clone = tube.clone();\n             let tube_clone_cell = Cell::new(tube_clone);\n             let sched: ~Scheduler = Local::take();\n-            do sched.deschedule_running_task_and_then |sched, task| {\n+            sched.deschedule_running_task_and_then(|sched, task| {\n                 let mut tube_clone = tube_clone_cell.take();\n                 tube_clone.send(1);\n                 sched.enqueue_blocked_task(task);\n-            }\n+            });\n \n             assert!(tube.recv() == 1);\n         }\n@@ -120,7 +120,7 @@ mod test {\n             let tube_clone = tube.clone();\n             let tube_clone = Cell::new(tube_clone);\n             let sched: ~Scheduler = Local::take();\n-            do sched.deschedule_running_task_and_then |sched, task| {\n+            sched.deschedule_running_task_and_then(|sched, task| {\n                 let tube_clone = Cell::new(tube_clone.take());\n                 do sched.event_loop.callback {\n                     let mut tube_clone = tube_clone.take();\n@@ -129,7 +129,7 @@ mod test {\n                     tube_clone.send(1);\n                 }\n                 sched.enqueue_blocked_task(task);\n-            }\n+            });\n \n             assert!(tube.recv() == 1);\n         }\n@@ -144,14 +144,14 @@ mod test {\n             let tube_clone = tube.clone();\n             let tube_clone = Cell::new(tube_clone);\n             let sched: ~Scheduler = Local::take();\n-            do sched.deschedule_running_task_and_then |sched, task| {\n+            sched.deschedule_running_task_and_then(|sched, task| {\n                 callback_send(tube_clone.take(), 0);\n \n                 fn callback_send(tube: Tube<int>, i: int) {\n                     if i == 100 { return; }\n \n                     let tube = Cell::new(Cell::new(tube));\n-                    do Local::borrow |sched: &mut Scheduler| {\n+                    Local::borrow(|sched: &mut Scheduler| {\n                         let tube = tube.take();\n                         do sched.event_loop.callback {\n                             let mut tube = tube.take();\n@@ -160,11 +160,11 @@ mod test {\n                             tube.send(i);\n                             callback_send(tube, i + 1);\n                         }\n-                    }\n+                    })\n                 }\n \n                 sched.enqueue_blocked_task(task);\n-            }\n+            });\n \n             for i in range(0, MAX) {\n                 let j = tube.recv();"}, {"sha": "02ea8ab4f5037b65fc442cd770081280eae4e47b", "filename": "src/libstd/rt/work_queue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Fwork_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frt%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fwork_queue.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -37,25 +37,25 @@ impl<T: Send> WorkQueue<T> {\n \n     pub fn pop(&mut self) -> Option<T> {\n         unsafe {\n-            do self.queue.with |q| {\n+            self.queue.with(|q| {\n                 if !q.is_empty() {\n                     Some(q.shift())\n                 } else {\n                     None\n                 }\n-            }\n+            })\n         }\n     }\n \n     pub fn steal(&mut self) -> Option<T> {\n         unsafe {\n-            do self.queue.with |q| {\n+            self.queue.with(|q| {\n                 if !q.is_empty() {\n                     Some(q.pop())\n                 } else {\n                     None\n                 }\n-            }\n+            })\n         }\n     }\n "}, {"sha": "7f977fdd2a39f5a15b49fc093adbc033bae900b8", "filename": "src/libstd/run.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -221,20 +221,20 @@ impl Process {\n         let ch_clone = ch.clone();\n \n         do spawn {\n-            do io::ignore_io_error {\n+            io::ignore_io_error(|| {\n                 match error.take() {\n                     Some(ref mut e) => ch.send((2, e.read_to_end())),\n                     None => ch.send((2, ~[]))\n                 }\n-            }\n+            })\n         }\n         do spawn {\n-            do io::ignore_io_error {\n+            io::ignore_io_error(|| {\n                 match output.take() {\n                     Some(ref mut e) => ch_clone.send((1, e.read_to_end())),\n                     None => ch_clone.send((1, ~[]))\n                 }\n-            }\n+            })\n         }\n \n         let status = self.finish();"}, {"sha": "43f1c3c529671281f0c8bba088589365d024b935", "filename": "src/libstd/select.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fselect.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -59,10 +59,10 @@ pub fn select<A: Select>(ports: &mut [A]) -> uint {\n     let p = Cell::new(p);\n     let c = Cell::new(c);\n \n-    do (|| {\n+    (|| {\n         let c = Cell::new(c.take());\n         let sched: ~Scheduler = Local::take();\n-        do sched.deschedule_running_task_and_then |sched, task| {\n+        sched.deschedule_running_task_and_then(|sched, task| {\n             let task_handles = task.make_selectable(ports.len());\n \n             for (index, (port, task_handle)) in\n@@ -76,13 +76,13 @@ pub fn select<A: Select>(ports: &mut [A]) -> uint {\n \n             let c = Cell::new(c.take());\n             do sched.event_loop.callback { c.take().send_deferred(()) }\n-        }\n-    }).finally {\n+        })\n+    }).finally(|| {\n         // Unkillable is necessary not because getting killed is dangerous here,\n         // but to force the recv not to use the same kill-flag that we used for\n         // selecting. Otherwise a user-sender could spuriously wakeup us here.\n         p.take().recv();\n-    }\n+    });\n \n     // Task resumes. Now unblock ourselves from all the ports we blocked on.\n     // If the success index wasn't reset, 'take' will just take all of them.\n@@ -211,7 +211,7 @@ mod test {\n         do run_in_uv_task {\n             let (ports, _) = unzip(range(0u, 10).map(|_| stream::<int>()));\n             let (port, chan) = stream();\n-            do 10.times { chan.send(31337); }\n+            10.times(|| { chan.send(31337); });\n             let mut ports = ports;\n             let mut port = Some(port);\n             let order = [5u,0,4,3,2,6,9,8,7,1];\n@@ -276,7 +276,7 @@ mod test {\n \n             do run_in_uv_task {\n                 // A bit of stress, since ordinarily this is just smoke and mirrors.\n-                do 4.times {\n+                4.times(|| {\n                     let send_on_chans = send_on_chans.clone();\n                     do task::spawn {\n                         let mut ports = ~[];\n@@ -294,7 +294,7 @@ mod test {\n                         // nondeterministic result, but should succeed\n                         select(ports);\n                     }\n-                }\n+                })\n             }\n         }\n     }"}, {"sha": "f65ec6971aba7af47d466c835014c4dc2a58a72a", "filename": "src/libstd/str.rs", "status": "modified", "additions": 69, "deletions": 107, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -322,7 +322,7 @@ impl CharEq for char {\n     fn only_ascii(&self) -> bool { (*self as uint) < 128 }\n }\n \n-impl<'self> CharEq for &'self fn(char) -> bool {\n+impl<'self> CharEq for 'self |char| -> bool {\n     #[inline]\n     fn matches(&self, c: char) -> bool { (*self)(c) }\n \n@@ -410,11 +410,11 @@ impl<'self> Iterator<(uint, char)> for CharOffsetIterator<'self> {\n     fn next(&mut self) -> Option<(uint, char)> {\n         // Compute the byte offset by using the pointer offset between\n         // the original string slice and the iterator's remaining part\n-        let offset = do self.string.as_imm_buf |a, _| {\n-            do self.iter.string.as_imm_buf |b, _| {\n+        let offset = self.string.as_imm_buf(|a, _| {\n+            self.iter.string.as_imm_buf(|b, _| {\n                 b as uint - a as uint\n-            }\n-        };\n+            })\n+        });\n         self.iter.next().map(|ch| (offset, ch))\n     }\n \n@@ -428,11 +428,11 @@ impl<'self> DoubleEndedIterator<(uint, char)> for CharOffsetIterator<'self> {\n     #[inline]\n     fn next_back(&mut self) -> Option<(uint, char)> {\n         self.iter.next_back().map(|ch| {\n-            let offset = do self.string.as_imm_buf |a, _| {\n-                do self.iter.string.as_imm_buf |b, len| {\n+            let offset = self.string.as_imm_buf(|a, _| {\n+                self.iter.string.as_imm_buf(|b, len| {\n                     b as uint - a as uint + len\n-                }\n-            };\n+                })\n+            });\n             (offset, ch)\n         })\n     }\n@@ -716,14 +716,14 @@ impl<'self> Iterator<char> for NormalizationIterator<'self> {\n \n         if !self.sorted {\n             for ch in self.iter {\n-                do decomposer(ch) |d| {\n+                decomposer(ch, |d| {\n                     let class = canonical_combining_class(d);\n                     if class == 0 && !self.sorted {\n                         canonical_sort(self.buffer);\n                         self.sorted = true;\n                     }\n                     self.buffer.push((d, class));\n-                }\n+                });\n                 if self.sorted { break }\n             }\n         }\n@@ -781,8 +781,8 @@ Section: Comparing strings\n #[lang=\"str_eq\"]\n #[inline]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n-    do a.as_imm_buf |ap, alen| {\n-        do b.as_imm_buf |bp, blen| {\n+    a.as_imm_buf(|ap, alen| {\n+        b.as_imm_buf(|bp, blen| {\n             if (alen != blen) { false }\n             else {\n                 unsafe {\n@@ -791,16 +791,16 @@ pub fn eq_slice(a: &str, b: &str) -> bool {\n                                  alen as libc::size_t) == 0\n                 }\n             }\n-        }\n-    }\n+        })\n+    })\n }\n \n /// Bytewise slice equality\n #[cfg(test)]\n #[inline]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n-    do a.as_imm_buf |ap, alen| {\n-        do b.as_imm_buf |bp, blen| {\n+    a.as_imm_buf(|ap, alen| {\n+        b.as_imm_buf(|bp, blen| {\n             if (alen != blen) { false }\n             else {\n                 unsafe {\n@@ -809,8 +809,8 @@ pub fn eq_slice(a: &str, b: &str) -> bool {\n                                  alen as libc::size_t) == 0\n                 }\n             }\n-        }\n-    }\n+        })\n+    })\n }\n \n /// Bytewise string equality\n@@ -1029,9 +1029,7 @@ pub mod raw {\n     /// Create a Rust string from a *u8 buffer of the given length\n     pub unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str {\n         let mut v: ~[u8] = vec::with_capacity(len);\n-        do v.as_mut_buf |vbuf, _len| {\n-            ptr::copy_memory(vbuf, buf as *u8, len)\n-        };\n+        v.as_mut_buf(|vbuf, _len| ptr::copy_memory(vbuf, buf as *u8, len));\n         vec::raw::set_len(&mut v, len);\n \n         assert!(is_utf8(v));\n@@ -1059,9 +1057,7 @@ pub mod raw {\n \n     /// Converts a vector of bytes to a new owned string.\n     pub unsafe fn from_utf8(v: &[u8]) -> ~str {\n-        do v.as_imm_buf |buf, len| {\n-            from_buf_len(buf, len)\n-        }\n+        v.as_imm_buf(|buf, len| from_buf_len(buf, len))\n     }\n \n     /// Converts an owned vector of bytes to a new owned string. This assumes\n@@ -1112,12 +1108,12 @@ pub mod raw {\n     /// Caller must check slice boundaries!\n     #[inline]\n     pub unsafe fn slice_unchecked<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n-        do s.as_imm_buf |sbuf, _n| {\n+        s.as_imm_buf(|sbuf, _n| {\n              cast::transmute(Slice {\n                  data: sbuf.offset(begin as int),\n                  len: end - begin,\n              })\n-        }\n+        })\n     }\n \n     /// Appends a byte to a string.\n@@ -1351,7 +1347,7 @@ impl<'self> Str for @str {\n impl<'self> Container for &'self str {\n     #[inline]\n     fn len(&self) -> uint {\n-        do self.as_imm_buf |_p, n| { n }\n+        self.as_imm_buf(|_p, n| n)\n     }\n }\n \n@@ -1876,11 +1872,11 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n     fn lines_any(&self) -> AnyLineIterator<'self> {\n-        do self.lines().map |line| {\n+        self.lines().map(|line| {\n             let l = line.len();\n             if l > 0 && line[l - 1] == '\\r' as u8 { line.slice(0, l - 1) }\n             else { line }\n-        }\n+        })\n     }\n \n     #[inline]\n@@ -1973,9 +1969,7 @@ impl<'self> StrSlice<'self> for &'self str {\n         let mut out: ~str = ~\"\";\n         out.reserve_at_least(self.len());\n         for c in self.chars() {\n-            do c.escape_default |c| {\n-                out.push_char(c);\n-            }\n+            c.escape_default(|c| out.push_char(c));\n         }\n         out\n     }\n@@ -1984,9 +1978,7 @@ impl<'self> StrSlice<'self> for &'self str {\n         let mut out: ~str = ~\"\";\n         out.reserve_at_least(self.len());\n         for c in self.chars() {\n-            do c.escape_unicode |c| {\n-                out.push_char(c);\n-            }\n+            c.escape_unicode(|c| out.push_char(c));\n         }\n         out\n     }\n@@ -2044,17 +2036,15 @@ impl<'self> StrSlice<'self> for &'self str {\n \n     #[inline]\n     fn to_owned(&self) -> ~str {\n-        do self.as_imm_buf |src, len| {\n+        self.as_imm_buf(|src, len| {\n             unsafe {\n                 let mut v = vec::with_capacity(len);\n \n-                do v.as_mut_buf |dst, _| {\n-                    ptr::copy_memory(dst, src, len);\n-                }\n+                v.as_mut_buf(|dst, _| ptr::copy_memory(dst, src, len));\n                 vec::raw::set_len(&mut v, len);\n                 ::cast::transmute(v)\n             }\n-        }\n+        })\n     }\n \n     #[inline]\n@@ -2250,8 +2240,8 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n     fn subslice_offset(&self, inner: &str) -> uint {\n-        do self.as_imm_buf |a, a_len| {\n-            do inner.as_imm_buf |b, b_len| {\n+        self.as_imm_buf(|a, a_len| {\n+            inner.as_imm_buf(|b, b_len| {\n                 let a_start: uint;\n                 let a_end: uint;\n                 let b_start: uint;\n@@ -2263,8 +2253,8 @@ impl<'self> StrSlice<'self> for &'self str {\n                 assert!(a_start <= b_start);\n                 assert!(b_end <= a_end);\n                 b_start - a_start\n-            }\n-        }\n+            })\n+        })\n     }\n \n     #[inline]\n@@ -2382,11 +2372,11 @@ impl OwnedStr for ~str {\n \n             // Attempt to not use an intermediate buffer by just pushing bytes\n             // directly onto this string.\n-            let used = do self.as_mut_buf |buf, _| {\n-                do vec::raw::mut_buf_as_slice(buf.offset(cur_len as int), 4) |slc| {\n+            let used = self.as_mut_buf(|buf, _| {\n+                vec::raw::mut_buf_as_slice(buf.offset(cur_len as int), 4, |slc| {\n                     c.encode_utf8(slc)\n-                }\n-            };\n+                })\n+            });\n             raw::set_len(self, cur_len + used);\n         }\n     }\n@@ -3156,13 +3146,11 @@ mod tests {\n                   0x6d_u8];\n \n         let mut error_happened = false;\n-        let _x = do cond.trap(|err| {\n+        let _x = cond.trap(|err| {\n             assert_eq!(err, ~\"from_utf8: input is not UTF-8; first bad byte is 255\");\n             error_happened = true;\n             ~\"\"\n-        }).inside {\n-            from_utf8(bb)\n-        };\n+        }).inside(|| from_utf8(bb));\n         assert!(error_happened);\n     }\n \n@@ -3201,11 +3189,9 @@ mod tests {\n \n     #[test]\n     fn test_as_imm_buf() {\n-        do \"\".as_imm_buf |_, len| {\n-            assert_eq!(len, 0);\n-        }\n+        \"\".as_imm_buf(|_, len| assert_eq!(len, 0));\n \n-        do \"hello\".as_imm_buf |buf, len| {\n+        \"hello\".as_imm_buf(|buf, len| {\n             assert_eq!(len, 5);\n             unsafe {\n                 assert_eq!(*ptr::offset(buf, 0), 'h' as u8);\n@@ -3214,7 +3200,7 @@ mod tests {\n                 assert_eq!(*ptr::offset(buf, 3), 'l' as u8);\n                 assert_eq!(*ptr::offset(buf, 4), 'o' as u8);\n             }\n-        }\n+        })\n     }\n \n     #[test]\n@@ -3864,9 +3850,7 @@ mod bench {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n         let len = s.char_len();\n \n-        do bh.iter {\n-            assert_eq!(s.chars().len(), len);\n-        }\n+        bh.iter(|| assert_eq!(s.chars().len(), len));\n     }\n \n     #[bench]\n@@ -3879,48 +3863,38 @@ mod bench {\n         Mary had a little lamb, Little lamb\";\n         let len = s.char_len();\n \n-        do bh.iter {\n-            assert_eq!(s.chars().len(), len);\n-        }\n+        bh.iter(|| assert_eq!(s.chars().len(), len));\n     }\n \n     #[bench]\n     fn char_iterator_rev(bh: &mut BenchHarness) {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n         let len = s.char_len();\n \n-        do bh.iter {\n-            assert_eq!(s.chars_rev().len(), len);\n-        }\n+        bh.iter(|| assert_eq!(s.chars_rev().len(), len));\n     }\n \n     #[bench]\n     fn char_indicesator(bh: &mut BenchHarness) {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n         let len = s.char_len();\n \n-        do bh.iter {\n-            assert_eq!(s.char_indices().len(), len);\n-        }\n+        bh.iter(|| assert_eq!(s.char_indices().len(), len));\n     }\n \n     #[bench]\n     fn char_indicesator_rev(bh: &mut BenchHarness) {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n         let len = s.char_len();\n \n-        do bh.iter {\n-            assert_eq!(s.char_indices_rev().len(), len);\n-        }\n+        bh.iter(|| assert_eq!(s.char_indices_rev().len(), len));\n     }\n \n     #[bench]\n     fn split_unicode_ascii(bh: &mut BenchHarness) {\n         let s = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n \n-        do bh.iter {\n-            assert_eq!(s.split('V').len(), 3);\n-        }\n+        bh.iter(|| assert_eq!(s.split('V').len(), 3));\n     }\n \n     #[bench]\n@@ -3934,9 +3908,7 @@ mod bench {\n         }\n         let s = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n \n-        do bh.iter {\n-            assert_eq!(s.split(NotAscii('V')).len(), 3);\n-        }\n+        bh.iter(|| assert_eq!(s.split(NotAscii('V')).len(), 3));\n     }\n \n \n@@ -3945,9 +3917,7 @@ mod bench {\n         let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n         let len = s.split(' ').len();\n \n-        do bh.iter {\n-            assert_eq!(s.split(' ').len(), len);\n-        }\n+        bh.iter(|| assert_eq!(s.split(' ').len(), len));\n     }\n \n     #[bench]\n@@ -3961,9 +3931,7 @@ mod bench {\n         let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n         let len = s.split(' ').len();\n \n-        do bh.iter {\n-            assert_eq!(s.split(NotAscii(' ')).len(), len);\n-        }\n+        bh.iter(|| assert_eq!(s.split(NotAscii(' ')).len(), len));\n     }\n \n     #[bench]\n@@ -3972,29 +3940,23 @@ mod bench {\n         let len = s.split(' ').len();\n         fn pred(c: char) -> bool { c == ' ' }\n \n-        do bh.iter {\n-            assert_eq!(s.split(pred).len(), len);\n-        }\n+        bh.iter(|| assert_eq!(s.split(pred).len(), len));\n     }\n \n     #[bench]\n     fn split_closure(bh: &mut BenchHarness) {\n         let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n         let len = s.split(' ').len();\n \n-        do bh.iter {\n-            assert_eq!(s.split(|c: char| c == ' ').len(), len);\n-        }\n+        bh.iter(|| assert_eq!(s.split(|c: char| c == ' ').len(), len));\n     }\n \n     #[bench]\n     fn split_slice(bh: &mut BenchHarness) {\n         let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n         let len = s.split(' ').len();\n \n-        do bh.iter {\n-            assert_eq!(s.split(&[' ']).len(), len);\n-        }\n+        bh.iter(|| assert_eq!(s.split(&[' ']).len(), len));\n     }\n \n     #[bench]\n@@ -4004,43 +3966,43 @@ mod bench {\n                         Lorem ipsum dolor sit amet, consectetur. \");\n \n         assert_eq!(100, s.len());\n-        do bh.iter {\n-            is_utf8(s);\n-        }\n+        bh.iter(|| {\n+            let _ = is_utf8(s);\n+        });\n     }\n \n     #[bench]\n     fn is_utf8_100_multibyte(bh: &mut BenchHarness) {\n         let s = bytes!(\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\");\n         assert_eq!(100, s.len());\n-        do bh.iter {\n-            is_utf8(s);\n-        }\n+        bh.iter(|| {\n+            let _ = is_utf8(s);\n+        });\n     }\n \n     #[bench]\n     fn bench_with_capacity(bh: &mut BenchHarness) {\n-        do bh.iter {\n-            with_capacity(100);\n-        }\n+        bh.iter(|| {\n+            let _ = with_capacity(100);\n+        });\n     }\n \n     #[bench]\n     fn bench_push_str(bh: &mut BenchHarness) {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-        do bh.iter {\n+        bh.iter(|| {\n             let mut r = ~\"\";\n             r.push_str(s);\n-        }\n+        });\n     }\n \n     #[bench]\n     fn bench_connect(bh: &mut BenchHarness) {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n         let sep = \"\u2192\";\n         let v = [s, s, s, s, s, s, s, s, s, s];\n-        do bh.iter {\n+        bh.iter(|| {\n             assert_eq!(v.connect(sep).len(), s.len() * 10 + sep.len() * 9);\n-        }\n+        })\n     }\n }"}, {"sha": "a587515bb16269211906ea583ddbb89a5804b07b", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -280,13 +280,13 @@ impl TaskBuilder {\n         let prev_gen_body = match prev_gen_body {\n             Some(gen) => gen,\n             None => {\n-                let f: proc(proc()) -> proc() = |body| body;\n+                let f: proc(proc()) -> proc() = proc(body) body;\n                 f\n             }\n         };\n         let prev_gen_body = Cell::new(prev_gen_body);\n         let next_gen_body = {\n-            let f: proc(proc()) -> proc() = |body| {\n+            let f: proc(proc()) -> proc() = proc(body) {\n                 let prev_gen_body = prev_gen_body.take();\n                 wrapper(prev_gen_body(body))\n             };\n@@ -432,12 +432,12 @@ pub fn with_task_name<U>(blk: |Option<&str>| -> U) -> U {\n     use rt::task::Task;\n \n     if in_green_task_context() {\n-        do Local::borrow |task: &mut Task| {\n+        Local::borrow(|task: &mut Task| {\n             match task.name {\n                 Some(ref name) => blk(Some(name.as_slice())),\n                 None => blk(None)\n             }\n-        }\n+        })\n     } else {\n         fail!(\"no task name exists in non-green task context\")\n     }\n@@ -459,9 +459,7 @@ pub fn failing() -> bool {\n \n     use rt::task::Task;\n \n-    do Local::borrow |local: &mut Task| {\n-        local.unwinder.unwinding\n-    }\n+    Local::borrow(|local: &mut Task| local.unwinder.unwinding)\n }\n \n // The following 8 tests test the following 2^3 combinations:\n@@ -479,9 +477,9 @@ fn test_unnamed_task() {\n \n     do run_in_uv_task {\n         do spawn {\n-            do with_task_name |name| {\n+            with_task_name(|name| {\n                 assert!(name.is_none());\n-            }\n+            })\n         }\n     }\n }\n@@ -494,9 +492,9 @@ fn test_owned_named_task() {\n         let mut t = task();\n         t.name(~\"ada lovelace\");\n         do t.spawn {\n-            do with_task_name |name| {\n+            with_task_name(|name| {\n                 assert!(name.unwrap() == \"ada lovelace\");\n-            }\n+            })\n         }\n     }\n }\n@@ -509,9 +507,9 @@ fn test_static_named_task() {\n         let mut t = task();\n         t.name(\"ada lovelace\");\n         do t.spawn {\n-            do with_task_name |name| {\n+            with_task_name(|name| {\n                 assert!(name.unwrap() == \"ada lovelace\");\n-            }\n+            })\n         }\n     }\n }\n@@ -524,9 +522,9 @@ fn test_send_named_task() {\n         let mut t = task();\n         t.name(\"ada lovelace\".into_send_str());\n         do t.spawn {\n-            do with_task_name |name| {\n+            with_task_name(|name| {\n                 assert!(name.unwrap() == \"ada lovelace\");\n-            }\n+            })\n         }\n     }\n }\n@@ -553,7 +551,7 @@ fn test_add_wrapper() {\n     let ch = Cell::new(ch);\n     do b0.add_wrapper |body| {\n         let ch = Cell::new(ch.take());\n-        let result: proc() = || {\n+        let result: proc() = proc() {\n             let ch = ch.take();\n             body();\n             ch.send(());\n@@ -608,9 +606,9 @@ fn test_try_fail() {\n \n #[cfg(test)]\n fn get_sched_id() -> int {\n-    do Local::borrow |sched: &mut ::rt::sched::Scheduler| {\n+    Local::borrow(|sched: &mut ::rt::sched::Scheduler| {\n         sched.sched_id() as int\n-    }\n+    })\n }\n \n #[test]\n@@ -668,7 +666,7 @@ fn test_spawn_sched_blocking() {\n \n         // Testing that a task in one scheduler can block in foreign code\n         // without affecting other schedulers\n-        do 20u.times {\n+        20u.times(|| {\n             let (start_po, start_ch) = stream();\n             let (fin_po, fin_ch) = stream();\n \n@@ -715,7 +713,7 @@ fn test_spawn_sched_blocking() {\n             lock.unlock();\n             fin_po.recv();\n             lock.destroy();\n-        }\n+        })\n     }\n }\n \n@@ -742,21 +740,21 @@ fn test_avoid_copying_the_body_spawn() {\n \n #[test]\n fn test_avoid_copying_the_body_task_spawn() {\n-    do avoid_copying_the_body |f| {\n+    avoid_copying_the_body(|f| {\n         let builder = task();\n         do builder.spawn || {\n             f();\n         }\n-    }\n+    })\n }\n \n #[test]\n fn test_avoid_copying_the_body_try() {\n-    do avoid_copying_the_body |f| {\n+    avoid_copying_the_body(|f| {\n         do try || {\n             f()\n         };\n-    }\n+    })\n }\n \n #[test]\n@@ -767,7 +765,7 @@ fn test_child_doesnt_ref_parent() {\n     // valgrind-friendly. try this at home, instead..!)\n     static generations: uint = 16;\n     fn child_no(x: uint) -> proc() {\n-        return || {\n+        return proc() {\n             if x < generations {\n                 let mut t = task();\n                 t.unwatched();\n@@ -785,7 +783,7 @@ fn test_simple_newsched_spawn() {\n     use rt::test::run_in_uv_task;\n \n     do run_in_uv_task {\n-        spawn(||())\n+        spawn(proc()())\n     }\n }\n "}, {"sha": "6c1c28c980559dd8f725bd07e69d52dd32d9dc88", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -180,7 +180,7 @@ pub fn spawn_raw(mut opts: TaskOpts, f: proc()) {\n     if opts.notify_chan.is_some() {\n         let notify_chan = opts.notify_chan.take_unwrap();\n         let notify_chan = Cell::new(notify_chan);\n-        let on_exit: proc(UnwindResult) = |task_result| {\n+        let on_exit: proc(UnwindResult) = proc(task_result) {\n             notify_chan.take().send(task_result)\n         };\n         task.death.on_exit = Some(on_exit);"}, {"sha": "d81fe0c2fbd8a87460b988b17a428a350a0eb106", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -22,7 +22,7 @@ use rc::Rc;\n use str::{Str, StrSlice};\n use vec::{Vector, ImmutableVector};\n \n-pub type Cb<'self> = &'self fn(buf: &[u8]) -> bool;\n+pub type Cb<'self> = 'self |buf: &[u8]| -> bool;\n \n ///\n /// A trait to implement in order to make a type hashable;\n@@ -369,12 +369,12 @@ impl<A:IterBytes> ToBytes for A {\n         use io::mem;\n         use io::Writer;\n \n-        do mem::with_mem_writer |wr| {\n-            do self.iter_bytes(lsb0) |bytes| {\n+        mem::with_mem_writer(|wr| {\n+            self.iter_bytes(lsb0, |bytes| {\n                 wr.write(bytes);\n                 true\n-            };\n-        }\n+            });\n+        })\n     }\n }\n "}, {"sha": "8b534d7d3bebe43c957759e057b7baa2167bd545", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -489,7 +489,7 @@ pub struct TrieSetIterator<'self> {\n \n impl<'self> Iterator<uint> for TrieSetIterator<'self> {\n     fn next(&mut self) -> Option<uint> {\n-        do self.iter.next().map |(key, _)| { key }\n+        self.iter.next().map(|(key, _)| key)\n     }\n \n     fn size_hint(&self) -> (uint, Option<uint>) {\n@@ -594,12 +594,12 @@ mod test_map {\n         assert!(m.insert(1, 2));\n \n         let mut n = 0;\n-        do m.each |k, v| {\n+        m.each(|k, v| {\n             assert_eq!(*k, n);\n             assert_eq!(*v, n * 2);\n             n += 1;\n             true\n-        };\n+        });\n     }\n \n     #[test]\n@@ -611,7 +611,7 @@ mod test_map {\n         }\n \n         let mut n = uint::max_value - 10000;\n-        do m.each |k, v| {\n+        m.each(|k, v| {\n             if n == uint::max_value - 5000 { false } else {\n                 assert!(n < uint::max_value - 5000);\n \n@@ -620,7 +620,7 @@ mod test_map {\n                 n += 1;\n                 true\n             }\n-        };\n+        });\n     }\n \n     #[test]\n@@ -634,12 +634,12 @@ mod test_map {\n         assert!(m.insert(1, 2));\n \n         let mut n = 4;\n-        do m.each_reverse |k, v| {\n+        m.each_reverse(|k, v| {\n             assert_eq!(*k, n);\n             assert_eq!(*v, n * 2);\n             n -= 1;\n             true\n-        };\n+        });\n     }\n \n     #[test]\n@@ -651,7 +651,7 @@ mod test_map {\n         }\n \n         let mut n = uint::max_value - 1;\n-        do m.each_reverse |k, v| {\n+        m.each_reverse(|k, v| {\n             if n == uint::max_value - 5000 { false } else {\n                 assert!(n > uint::max_value - 5000);\n \n@@ -660,7 +660,7 @@ mod test_map {\n                 n -= 1;\n                 true\n             }\n-        };\n+        });\n     }\n \n     #[test]\n@@ -777,11 +777,11 @@ mod test_set {\n \n         let mut i = 0;\n \n-        do trie.each |x| {\n+        trie.each(|x| {\n             assert_eq!(expected[i], *x);\n             i += 1;\n             true\n-        };\n+        });\n     }\n \n     #[test]"}, {"sha": "ac4bc5754fb18ff271631a43cd2c4a88267caf2b", "filename": "src/libstd/unicode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funicode.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -19,11 +19,11 @@ pub mod general_category {\n         use cmp::{Equal, Less, Greater};\n         use vec::ImmutableVector;\n         use option::None;\n-        (do r.bsearch |&(lo,hi)| {\n+        (r.bsearch(|&(lo,hi)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n-        }) != None\n+        })) != None\n     }\n \n \n@@ -3663,11 +3663,11 @@ pub mod derived_property {\n         use cmp::{Equal, Less, Greater};\n         use vec::ImmutableVector;\n         use option::None;\n-        (do r.bsearch |&(lo,hi)| {\n+        (r.bsearch(|&(lo,hi)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n-        }) != None\n+        })) != None\n     }\n \n "}, {"sha": "2a6e40dc3a0df93870ca30f9c6929a9f794f9f7e", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -27,11 +27,11 @@ pub struct DynamicLibrary { priv handle: *libc::c_void }\n \n impl Drop for DynamicLibrary {\n     fn drop(&mut self) {\n-        match do dl::check_for_errors_in {\n+        match dl::check_for_errors_in(|| {\n             unsafe {\n                 dl::close(self.handle)\n             }\n-        } {\n+        }) {\n             Ok(()) => {},\n             Err(str) => fail!(\"{}\", str)\n         }\n@@ -43,12 +43,12 @@ impl DynamicLibrary {\n     /// handle to the calling process\n     pub fn open(filename: Option<&path::Path>) -> Result<DynamicLibrary, ~str> {\n         unsafe {\n-            let maybe_library = do dl::check_for_errors_in {\n+            let maybe_library = dl::check_for_errors_in(|| {\n                 match filename {\n                     Some(name) => dl::open_external(name),\n                     None => dl::open_internal()\n                 }\n-            };\n+            });\n \n             // The dynamic library must not be constructed if there is\n             // an error opening the library so the destructor does not\n@@ -65,11 +65,11 @@ impl DynamicLibrary {\n         // This function should have a lifetime constraint of 'self on\n         // T but that feature is still unimplemented\n \n-        let maybe_symbol_value = do dl::check_for_errors_in {\n-            do symbol.with_c_str |raw_string| {\n+        let maybe_symbol_value = dl::check_for_errors_in(|| {\n+            symbol.with_c_str(|raw_string| {\n                 dl::symbol(self.handle, raw_string)\n-            }\n-        };\n+            })\n+        });\n \n         // The value must not be constructed if there is an error so\n         // the destructor does not run.\n@@ -144,9 +144,9 @@ pub mod dl {\n     use result::*;\n \n     pub unsafe fn open_external(filename: &path::Path) -> *libc::c_void {\n-        do filename.with_c_str |raw_name| {\n+        filename.with_c_str(|raw_name| {\n             dlopen(raw_name, Lazy as libc::c_int)\n-        }\n+        })\n     }\n \n     pub unsafe fn open_internal() -> *libc::c_void {\n@@ -162,7 +162,7 @@ pub mod dl {\n             // would cause this task to be descheduled, which could deadlock\n             // the scheduler if it happens while the lock is held.\n             // FIXME #9105 use a Rust mutex instead of C++ mutexes.\n-            do atomically {\n+            atomically(|| {\n                 lock.lock();\n                 let _old_error = dlerror();\n \n@@ -176,7 +176,7 @@ pub mod dl {\n                 };\n                 lock.unlock();\n                 ret\n-            }\n+            })\n         }\n     }\n \n@@ -213,9 +213,9 @@ pub mod dl {\n     use result::*;\n \n     pub unsafe fn open_external(filename: &path::Path) -> *libc::c_void {\n-        do os::win32::as_utf16_p(filename.as_str().unwrap()) |raw_name| {\n+        os::win32::as_utf16_p(filename.as_str().unwrap(), |raw_name| {\n             LoadLibraryW(raw_name)\n-        }\n+        })\n     }\n \n     pub unsafe fn open_internal() -> *libc::c_void {\n@@ -226,7 +226,7 @@ pub mod dl {\n \n     pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, ~str> {\n         unsafe {\n-            do atomically {\n+            atomically(|| {\n                 SetLastError(0);\n \n                 let result = f();\n@@ -237,7 +237,7 @@ pub mod dl {\n                 } else {\n                     Err(format!(\"Error code {}\", error))\n                 }\n-            }\n+            })\n         }\n     }\n "}, {"sha": "57aff6031bafd7940e4c92344cbd76eb28a918c4", "filename": "src/libstd/unstable/finally.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Funstable%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Funstable%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Ffinally.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -15,11 +15,11 @@ stack closures that emulates Java-style try/finally blocks.\n # Example\n \n  ```\n-do || {\n+(|| {\n     ...\n-}.finally {\n+}).finally(|| {\n     always_run_this();\n-}\n+})\n  ```\n */\n \n@@ -44,7 +44,7 @@ macro_rules! finally_fn {\n     }\n }\n \n-impl<'self,T> Finally<T> for &'self fn() -> T {\n+impl<'self,T> Finally<T> for 'self || -> T {\n     fn finally(&self, dtor: ||) -> T {\n         let _d = Finallyalizer {\n             dtor: dtor\n@@ -57,7 +57,7 @@ impl<'self,T> Finally<T> for &'self fn() -> T {\n finally_fn!(extern \"Rust\" fn() -> T)\n \n struct Finallyalizer<'self> {\n-    dtor: &'self fn()\n+    dtor: 'self ||\n }\n \n #[unsafe_destructor]\n@@ -70,33 +70,33 @@ impl<'self> Drop for Finallyalizer<'self> {\n #[test]\n fn test_success() {\n     let mut i = 0;\n-    do (|| {\n+    (|| {\n         i = 10;\n-    }).finally {\n+    }).finally(|| {\n         assert!(!failing());\n         assert_eq!(i, 10);\n         i = 20;\n-    }\n+    });\n     assert_eq!(i, 20);\n }\n \n #[test]\n #[should_fail]\n fn test_fail() {\n     let mut i = 0;\n-    do (|| {\n+    (|| {\n         i = 10;\n         fail!();\n-    }).finally {\n+    }).finally(|| {\n         assert!(failing());\n         assert_eq!(i, 10);\n-    }\n+    })\n }\n \n #[test]\n fn test_retval() {\n     let closure: || -> int = || 10;\n-    let i = do closure.finally { };\n+    let i = closure.finally(|| { });\n     assert_eq!(i, 10);\n }\n "}, {"sha": "06f9ba65ae77331e014ffcf4e1c4bf3feb9abd5f", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -27,9 +27,7 @@ pub fn fail_(expr: *c_char, file: *c_char, line: size_t) -> ! {\n pub fn fail_bounds_check(file: *c_char, line: size_t, index: size_t, len: size_t) -> ! {\n     let msg = format!(\"index out of bounds: the len is {} but the index is {}\",\n                       len as uint, index as uint);\n-    do msg.with_c_str |buf| {\n-        fail_(buf, file, line);\n-    }\n+    msg.with_c_str(|buf| fail_(buf, file, line))\n }\n \n #[lang=\"malloc\"]"}, {"sha": "03745c2c3485bdf00bda9d100e1109dcb4542d42", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 18, "deletions": 37, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -134,9 +134,8 @@ impl<T: Send> UnsafeArc<T> {\n     /// If called when the task is already unkillable, unwrap will unkillably\n     /// block; otherwise, an unwrapping task can be killed by linked failure.\n     pub fn unwrap(self) -> T {\n-        let this = Cell::new(self); // argh\n         unsafe {\n-            let mut this = this.take();\n+            let mut this = self;\n             // The ~ dtor needs to run if this code succeeds.\n             let mut data: ~ArcData<T> = cast::transmute(this.data);\n             // Set up the unwrap protocol.\n@@ -164,7 +163,7 @@ impl<T: Send> UnsafeArc<T> {\n                     // Unlike the above one, this cell is necessary. It will get\n                     // taken either in the do block or in the finally block.\n                     let c2_and_data = Cell::new((c2,data));\n-                    do (|| {\n+                    (|| {\n                         p1.take().recv();\n                         // Got here. Back in the 'unkillable' without getting killed.\n                         let (c2, data) = c2_and_data.take();\n@@ -174,7 +173,7 @@ impl<T: Send> UnsafeArc<T> {\n                         // user_data\n                         let mut data = data;\n                         data.data.take_unwrap()\n-                    }).finally {\n+                    }).finally(|| {\n                         if task::failing() {\n                             // Killed during wait. Because this might happen while\n                             // someone else still holds a reference, we can't free\n@@ -185,7 +184,7 @@ impl<T: Send> UnsafeArc<T> {\n                         } else {\n                             assert!(c2_and_data.is_empty());\n                         }\n-                    }\n+                    })\n                 }\n             } else {\n                 // If 'put' returns the server end back to us, we were rejected;\n@@ -256,8 +255,6 @@ impl<T> Drop for UnsafeArc<T>{\n                 // *awake* task with the data.\n                 match data.unwrapper.take(Acquire) {\n                     Some(~(message,response)) => {\n-                        let cell = Cell::new((message, response, data));\n-                        let (message, response, data) = cell.take();\n                         // Send 'ready' and wait for a response.\n                         message.send(());\n                         // Unkillable wait. Message guaranteed to come.\n@@ -301,12 +298,10 @@ pub unsafe fn atomically<U>(f: || -> U) -> U {\n         Some(t) => {\n             match (*t).task_type {\n                 GreenTask(_) => {\n-                    do (|| {\n+                    (|| {\n                         (*t).death.inhibit_deschedule();\n                         f()\n-                    }).finally {\n-                        (*t).death.allow_deschedule();\n-                    }\n+                    }).finally(|| (*t).death.allow_deschedule())\n                 }\n                 SchedTask => f()\n             }\n@@ -425,9 +420,7 @@ impl<T:Send> Exclusive<T> {\n \n     #[inline]\n     pub unsafe fn with_imm<U>(&self, f: |x: &T| -> U) -> U {\n-        do self.with |x| {\n-            f(cast::transmute_immut(x))\n-        }\n+        self.with(|x| f(cast::transmute_immut(x)))\n     }\n \n     #[inline]\n@@ -469,7 +462,6 @@ impl<T:Send> Exclusive<T> {\n \n #[cfg(test)]\n mod tests {\n-    use cell::Cell;\n     use comm;\n     use option::*;\n     use prelude::*;\n@@ -489,7 +481,7 @@ mod tests {\n     fn test_atomically() {\n         // NB. The whole runtime will abort on an 'atomic-sleep' violation,\n         // so we can't really test for the converse behaviour.\n-        unsafe { do atomically { } } task::deschedule(); // oughtn't fail\n+        unsafe { atomically(|| ()) } task::deschedule(); // oughtn't fail\n     }\n \n     #[test]\n@@ -509,19 +501,15 @@ mod tests {\n \n                 do task::spawn || {\n                     for _ in range(0u, count) {\n-                        do total.with |count| {\n-                            **count += 1;\n-                        }\n+                        total.with(|count| **count += 1);\n                     }\n                     chan.send(());\n                 }\n             };\n \n             for f in futures.iter() { f.recv() }\n \n-            do total.with |total| {\n-                assert!(**total == num_tasks * count)\n-            };\n+            total.with(|total| assert!(**total == num_tasks * count));\n         }\n     }\n \n@@ -533,13 +521,9 @@ mod tests {\n             let x = Exclusive::new(1);\n             let x2 = x.clone();\n             do task::try || {\n-                do x2.with |one| {\n-                    assert_eq!(*one, 2);\n-                }\n+                x2.with(|one| assert_eq!(*one, 2))\n             };\n-            do x.with |one| {\n-                assert_eq!(*one, 1);\n-            }\n+            x.with(|one| assert_eq!(*one, 1));\n         }\n     }\n \n@@ -595,11 +579,11 @@ mod tests {\n     fn arclike_try_unwrap_unwrap_race() {\n         // When an unwrap and a try_unwrap race, the unwrapper should always win.\n         let x = UnsafeArc::new(~~\"hello\");\n-        let x2 = Cell::new(x.clone());\n+        let x2 = x.clone();\n         let (p,c) = comm::stream();\n         do task::spawn {\n             c.send(());\n-            assert!(x2.take().unwrap() == ~~\"hello\");\n+            assert!(x2.unwrap() == ~~\"hello\");\n             c.send(());\n         }\n         p.recv();\n@@ -620,21 +604,19 @@ mod tests {\n     #[test]\n     fn exclusive_new_unwrap_contended() {\n         let x = Exclusive::new(~~\"hello\");\n-        let x2 = Cell::new(x.clone());\n+        let x2 = x.clone();\n         do task::spawn {\n-            let x2 = x2.take();\n-            unsafe { do x2.with |_hello| { } }\n+            unsafe { x2.with(|_hello| ()); }\n             task::deschedule();\n         }\n         assert!(x.unwrap() == ~~\"hello\");\n \n         // Now try the same thing, but with the child task blocking.\n         let x = Exclusive::new(~~\"hello\");\n-        let x2 = Cell::new(x.clone());\n+        let x2 = x.clone();\n         let mut builder = task::task();\n         let res = builder.future_result();\n         do builder.spawn {\n-            let x2 = x2.take();\n             assert!(x2.unwrap() == ~~\"hello\");\n         }\n         // Have to get rid of our reference before blocking.\n@@ -645,11 +627,10 @@ mod tests {\n     #[test] #[should_fail]\n     fn exclusive_new_unwrap_conflict() {\n         let x = Exclusive::new(~~\"hello\");\n-        let x2 = Cell::new(x.clone());\n+        let x2 = x.clone();\n         let mut builder = task::task();\n         let res = builder.future_result();\n         do builder.spawn {\n-            let x2 = x2.take();\n             assert!(x2.unwrap() == ~~\"hello\");\n         }\n         assert!(x.unwrap() == ~~\"hello\");"}, {"sha": "ddcf408189ed261845b9177b1dadc514eedd80d1", "filename": "src/libstd/util.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Futil.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699", "patch": "@@ -178,40 +178,40 @@ mod bench {\n     fn trait_vtable_method_call(bh: &mut BenchHarness) {\n         let s = Struct { field: 10 };\n         let t = &s as &Trait;\n-        do bh.iter {\n+        bh.iter(|| {\n             t.method();\n-        }\n+        });\n     }\n \n     #[bench]\n     fn trait_static_method_call(bh: &mut BenchHarness) {\n         let s = Struct { field: 10 };\n-        do bh.iter {\n+        bh.iter(|| {\n             s.method();\n-        }\n+        });\n     }\n \n     // Overhead of various match forms\n \n     #[bench]\n     fn match_option_some(bh: &mut BenchHarness) {\n         let x = Some(10);\n-        do bh.iter {\n+        bh.iter(|| {\n             let _q = match x {\n                 Some(y) => y,\n                 None => 11\n             };\n-        }\n+        });\n     }\n \n     #[bench]\n     fn match_vec_pattern(bh: &mut BenchHarness) {\n         let x = [1,2,3,4,5,6];\n-        do bh.iter {\n+        bh.iter(|| {\n             let _q = match x {\n                 [1,2,3,.._] => 10,\n                 _ => 11\n             };\n-        }\n+        });\n     }\n }"}, {"sha": "1d562d648499c4e66da2adde15bdadcf1e2dc174", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "9f69379f3c58cbd42169b918959d2d9ff4803086", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "32b270643afd23069ee273db7730dd1cf4c90369", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "ef3c23f515380c1f3b2b230cd49e37b8ae8ebefc", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "ecde00aa3021141a9c973978146d284e76ab0133", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "36e6bf32451f9199b92c9fbbc952d46be2452646", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "2a7f6dfe2d20a112b23cd7ae2e542bf8b94ec397", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "6dd358144a474e37a0b5a935f65febc3e9cfeda9", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "4ab0cc3bc67f59e6dd977bd95e310ac5f0e83309", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "015083f11d35ba4128746547854390fe0b91a68c", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "96b77c4c16246f32a6d14ecdaac1be5242982275", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "614c719e0a2be2a33020c790b7b9c923f7d8bda9", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "7e3debd7967f60f48ce977ab25aa8dc23f67bdf4", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "9c611d7e7b2844fffd08b09ce289edc6434514d0", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "40fdee481edd98d90e942bc04c88a7e93308299a", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "eb957e80835ffedc96b34d18d876a2b9bbe95e84", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "a37cb586f59d457308283d69ae308a5e98949eab", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "f23e13b89311c25f644321f16dd5f25b2dc0ca3f", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "1c0930f984a71343ce80282d98c19accd04eeb9a", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "3e877d29300dab03766b903d6325e287d97cc6dd", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "0f7b92b5b064050a962692380c0895941040d892", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "b268988c3c567ec407dfea4d929f0fccbac6bece", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "d8f2d8a53807a6050900cb8c822249b65b5f70bd", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "e4b93c3b4d5b567035234955d8e3a5c7f96cdddd", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "8e291ca6705f3619a888bad331af527fe1287cb2", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "b9a7ec33ee4ffcd8af5358196c8a820b7a45d289", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 23, "deletions": 26, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "870c1bd74b1b0b13ea5ba4802479a9a7511803a4", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "a8f82221fa199abf30ff7cb245d9e63516db2dfe", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "2d13cdb9bbb7f3f863faffba73bfd1e06e2608da", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "f038acf67a82ed8eeee50beee03cd96517fac6ca", "filename": "src/test/auxiliary/cci_impl_lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "e08a2f7fcbbecc07f117c616980fc1648f4ee027", "filename": "src/test/auxiliary/cci_iter_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "99d13e91752ab6a11b6252ebf5800a83ade23061", "filename": "src/test/auxiliary/cci_no_inline_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "3855a348f60c0ee088563a17d354fc826be3bf0a", "filename": "src/test/auxiliary/iss.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fauxiliary%2Fiss.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fauxiliary%2Fiss.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fiss.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "afe9de7abb969f86d2cd9abaf47682ee3493e736", "filename": "src/test/auxiliary/xc_conditions_3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fauxiliary%2Fxc_conditions_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fauxiliary%2Fxc_conditions_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fxc_conditions_3.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "ca7dc238e2e819b33998f054a8e41eee533fbef6", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "57205ca2c583df7324fd77bc11cd7eff169f546c", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "c7036f8d9db312a11aa70eb012eafc7033809b2c", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "facd8a3bd74e6ee9afbb04f74128bbe8efa0c1b1", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "2ce3a373f8b33d606d094fbe611a8d3a79341e14", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "715043d5be686cf23c2ce2b1e3608fa8bbe9a65b", "filename": "src/test/bench/rt-messaging-ping-pong.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "e057d6862e6a91685d02bda9e64c291973b9fd99", "filename": "src/test/bench/rt-spawn-rate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Frt-spawn-rate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Frt-spawn-rate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-spawn-rate.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "d2241a0ddee525393c9bbda9e45e572be0e1e0da", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "5045e9c58d92527f94a5d4604aed907b611870a6", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "f8ac5154e7b0d7ed10b5d82f5bad0cd6639b68c9", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "5685b489072f1801826ed0bb81c2fd954411374e", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "da25f1e82eebb77c310afd6221cec7b7f8a2ee3e", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "497b6a392a539d5b539c59aa1c1cff5182f7ce5e", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "cdbec1784b98ebc2c7409894daaf15cebe3881d2", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "e322aceb5e6619d6163f650da1be5af334f7370c", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "ef853f57ef5e16b79e9bb65313c6044d9eb04061", "filename": "src/test/compile-fail/access-mode-in-closures.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Faccess-mode-in-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Faccess-mode-in-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Faccess-mode-in-closures.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "c31a7bb244c72d5305a0f9f53a05a93bbfdba3ca", "filename": "src/test/compile-fail/arc-rw-cond-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "2fe2095ca879efd22bad0529c5d3dfbf97c57267", "filename": "src/test/compile-fail/arc-rw-read-mode-shouldnt-escape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "7c129ae0dcaad33e0eeeeea78e3bc610563bb0ef", "filename": "src/test/compile-fail/arc-rw-state-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Farc-rw-state-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Farc-rw-state-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-state-shouldnt-escape.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "674cd5708889c4dfeeb54c81f6079b49f1189801", "filename": "src/test/compile-fail/arc-rw-write-mode-cond-shouldnt-escape.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "d9247ab4fc170d16c31a592be1e35132bb7ed5c6", "filename": "src/test/compile-fail/arc-rw-write-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "7637ebdc80dcc5422b5a2d7cded9b6c5f3ef6ff7", "filename": "src/test/compile-fail/block-arg-as-stmt-with-value.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9f9efae790bba41f08befc2af47ef235b03dd8a9/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f9efae790bba41f08befc2af47ef235b03dd8a9/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs?ref=9f9efae790bba41f08befc2af47ef235b03dd8a9"}, {"sha": "52359bed59c90438db721632d7da2cfbee3c0908", "filename": "src/test/compile-fail/block-coerce-no-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no-2.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "d07c3feb1942372dfe95db9cf08e4a29c4364bc4", "filename": "src/test/compile-fail/block-coerce-no.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "b50a657eae79a93e2dd3d86c32de888055599f9c", "filename": "src/test/compile-fail/borrowck-assign-comp-idx.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "5c7e328969bb5cbcd1dea2afe2253fb5cde3b31d", "filename": "src/test/compile-fail/borrowck-autoref-3261.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "94ed47b01e1ee65f7bd06256e2dd083cfd0fdfc1", "filename": "src/test/compile-fail/borrowck-insert-during-each.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "80b8770397fb2727bd5137bd58803c5c462e0e07", "filename": "src/test/compile-fail/borrowck-lend-flow-if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-if.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "c25f39a9d4329ec77f8c03f29627dfe6d5b4081a", "filename": "src/test/compile-fail/borrowck-lend-flow-loop.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "5e4e5bb1e73f1b51e9d273e0d283083b78e4959d", "filename": "src/test/compile-fail/borrowck-lend-flow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "c935c9deeac1ce3de65c51107473cf519dfbbcbb", "filename": "src/test/compile-fail/borrowck-loan-blocks-move-cc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "a54476abb26d691c55f5f533f0f878a9f786df6b", "filename": "src/test/compile-fail/borrowck-loan-blocks-mut-uniq.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "c2ed3378bf97ced26ea100144227e4b589871350", "filename": "src/test/compile-fail/borrowck-loan-rcvr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "6527ddfa2ecf67999fe385f3dc60dd8098a48622", "filename": "src/test/compile-fail/borrowck-loan-vec-content.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "ac565e9bfd694241ddf24ecb9278945177256b7c", "filename": "src/test/compile-fail/borrowck-move-by-capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "7615036300f6fefcf09b46f983e58cc9ea58f09f", "filename": "src/test/compile-fail/borrowck-move-in-irrefut-pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fborrowck-move-in-irrefut-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fborrowck-move-in-irrefut-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-in-irrefut-pat.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "6e6a779840e761dbe352bf1159a628bacbde8d04", "filename": "src/test/compile-fail/borrowck-move-moved-value-into-closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fborrowck-move-moved-value-into-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fborrowck-move-moved-value-into-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-moved-value-into-closure.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "4633ca662897f004c503927570b73a982eba8587", "filename": "src/test/compile-fail/break-outside-loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fbreak-outside-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fbreak-outside-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbreak-outside-loop.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "e5898b33e7785305cbe929256dd8a0f3884d14ea", "filename": "src/test/compile-fail/closure-bounds-cant-promote-superkind-in-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-cant-promote-superkind-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-cant-promote-superkind-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-cant-promote-superkind-in-struct.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "4afab8db5468b525cae2ed29fd6109ccfdbd189f", "filename": "src/test/compile-fail/closure-bounds-not-builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-not-builtin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-not-builtin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-not-builtin.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "1c6d65ba541671d1bcee8a969424f28dd15e7edd", "filename": "src/test/compile-fail/closure-bounds-static-cant-capture-borrowed.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-static-cant-capture-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-static-cant-capture-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-static-cant-capture-borrowed.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "77281b26554b1f502fb49db5774486a0abdb880f", "filename": "src/test/compile-fail/closure-bounds-subtype.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-subtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-subtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-subtype.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "fc8e2d4d853f1e4f5ce23d5e07524536092bb29e", "filename": "src/test/compile-fail/closure-that-fails.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fclosure-that-fails.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fclosure-that-fails.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-that-fails.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "309abe218f6f1bc55712130446824d7fcf6e7ef5", "filename": "src/test/compile-fail/do2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fdo2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fdo2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdo2.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "6b01b83db21fd31d0c097a459a52f00c9ba10411", "filename": "src/test/compile-fail/extern-wrong-value-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}, {"sha": "a4ebfef1774c63e13cda067a152263547693485e", "filename": "src/test/compile-fail/fn-variance-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Ffn-variance-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9a1869a5f4164d5311963b1b25b05f003d43699/src%2Ftest%2Fcompile-fail%2Ffn-variance-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-variance-1.rs?ref=e9a1869a5f4164d5311963b1b25b05f003d43699"}]}