{"sha": "94ac30c498399eec1c5239b472845d238b1926ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0YWMzMGM0OTgzOTllZWMxYzUyMzliNDcyODQ1ZDIzOGIxOTI2ZWM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-03T06:14:25Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-03T06:14:47Z"}, "message": "rt: Improve docs for main, kernel, scheduler, and task", "tree": {"sha": "a6da1c59d45e57954673a047faffd7d1af494a66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6da1c59d45e57954673a047faffd7d1af494a66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94ac30c498399eec1c5239b472845d238b1926ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94ac30c498399eec1c5239b472845d238b1926ec", "html_url": "https://github.com/rust-lang/rust/commit/94ac30c498399eec1c5239b472845d238b1926ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94ac30c498399eec1c5239b472845d238b1926ec/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b9ceea6bdcc51ffab258ed2d6ef23066c17838c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b9ceea6bdcc51ffab258ed2d6ef23066c17838c", "html_url": "https://github.com/rust-lang/rust/commit/9b9ceea6bdcc51ffab258ed2d6ef23066c17838c"}], "stats": {"total": 157, "additions": 120, "deletions": 37}, "files": [{"sha": "7efc3b8839c09c8756643bee2b2df7ed43a162d1", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/94ac30c498399eec1c5239b472845d238b1926ec/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/94ac30c498399eec1c5239b472845d238b1926ec/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=94ac30c498399eec1c5239b472845d238b1926ec", "patch": "@@ -1,9 +1,14 @@\n+/**\n+ * Main entry point into the Rust runtime. Here we initialize the kernel,\n+ * create the initial scheduler and run the main task.\n+ */\n \n #include \"rust_globals.h\"\n #include \"rust_kernel.h\"\n #include \"rust_util.h\"\n #include \"rust_scheduler.h\"\n \n+// Creates a rust argument vector from the platform argument vector\n struct\n command_line_args : public kernel_owned<command_line_args>\n {\n@@ -61,42 +66,60 @@ command_line_args : public kernel_owned<command_line_args>\n     }\n };\n \n-/**\n- * Main entry point into the Rust runtime. Here we create a Rust service,\n- * initialize the kernel, create the root domain and run it.\n- */\n-\n+// A global that indicates whether Rust typestate claim statements should be\n+// executed Generated code will read this variable directly (I think).\n+// FIXME: This belongs somewhere else\n int check_claims = 0;\n \n+/**\n+   The runtime entrypoint. The (C ABI) main function generated by rustc calls\n+   `rust_start`, providing the address of the Rust ABI main function, the\n+   platform argument vector, and a `crate_map` the provides some logging\n+   metadata.\n+*/\n extern \"C\" CDECL int\n rust_start(uintptr_t main_fn, int argc, char **argv, void* crate_map) {\n \n+    // Load runtime configuration options from the environment.\n+    // FIXME #1497: Should provide a way to get these from the command\n+    // line as well.\n     rust_env *env = load_env();\n \n     update_log_settings(crate_map, env->logspec);\n+\n+    // Maybe turn on typestate claim checking\n     check_claims = env->check_claims;\n \n     rust_kernel *kernel = new rust_kernel(env);\n+\n+    // Create the main scheduler and the main task\n     rust_sched_id sched_id = kernel->create_scheduler(env->num_sched_threads);\n     rust_scheduler *sched = kernel->get_scheduler_by_id(sched_id);\n     rust_task *root_task = sched->create_task(NULL, \"main\");\n+\n+    // Build the command line arguments to pass to the root task\n     command_line_args *args\n         = new (kernel, \"main command line args\")\n         command_line_args(root_task, argc, argv);\n \n     LOG(root_task, dom, \"startup: %d args in 0x%\" PRIxPTR,\n-             args->argc, (uintptr_t)args->args);\n+        args->argc, (uintptr_t)args->args);\n     for (int i = 0; i < args->argc; i++) {\n         LOG(root_task, dom, \"startup: arg[%d] = '%s'\", i, args->argv[i]);\n     }\n \n+    // Schedule the main Rust task\n     root_task->start((spawn_fn)main_fn, NULL, args->args);\n+\n+    // At this point the task lifecycle is responsible for it\n+    // and our pointer may not be valid\n     root_task = NULL;\n \n+    // Run the kernel until all schedulers exit\n     int ret = kernel->run();\n+\n     delete args;\n     delete kernel;\n-\n     free_env(env);\n \n     return ret;"}, {"sha": "8a963dbb25c15dcd063bb7aae4768af5740bd80d", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 35, "deletions": 9, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/94ac30c498399eec1c5239b472845d238b1926ec/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/94ac30c498399eec1c5239b472845d238b1926ec/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=94ac30c498399eec1c5239b472845d238b1926ec", "patch": "@@ -1,4 +1,34 @@\n // -*- c++ -*-\n+\n+/**\n+   A single runtime instance.\n+\n+   The kernel is primarily responsible for managing the lifetime of\n+   schedulers, which in turn run rust tasks. It provides a memory\n+   allocator and logging service for use by other runtime components,\n+   it creates unique task and port ids and provides global access\n+   to ports by id.\n+\n+   The kernel runs until there are no live schedulers.\n+\n+   The kernel internally runs an additional, special scheduler called\n+   the 'osmain' (or platform) scheduler, which schedules tasks on the\n+   thread that is running the kernel (normally the thread on which the\n+   C main function was called). This scheduler may be used by Rust\n+   code for interacting with platform APIs that insist on being called\n+   from the main thread.\n+\n+   The requirements of the osmain scheduler has resulted in a complex\n+   process for creating and running scheduler loops that involves\n+   a thing called a 'rust_sched_launcher_factory' whose function I've\n+   already forgotten. rust_scheduler is the main scheduler class,\n+   and tasks are scheduled on individual threads by rust_sched_loop.\n+\n+   Ideally all the in-memory Rust state is encapsulated by a kernel\n+   instance, but there is still some truly global data in the runtime\n+   (like the check claims flag).\n+ */\n+\n #ifndef RUST_KERNEL_H\n #define RUST_KERNEL_H\n \n@@ -12,24 +42,20 @@\n #include \"rust_sched_reaper.h\"\n #include \"util/hash_map.h\"\n \n-struct rust_task_thread;\n class rust_scheduler;\n+class rust_sched_driver;\n+class rust_sched_launcher_factory;\n+struct rust_task_thread;\n class rust_port;\n \n+// Scheduler, task, and port handles. These uniquely identify within a\n+// single kernel instance the objects they represent.\n typedef intptr_t rust_sched_id;\n typedef intptr_t rust_task_id;\n typedef intptr_t rust_port_id;\n \n typedef std::map<rust_sched_id, rust_scheduler*> sched_map;\n \n-class rust_sched_driver;\n-class rust_sched_launcher_factory;\n-\n-/**\n- * A global object shared by all thread domains. Most of the data structures\n- * in this class are synchronized since they are accessed from multiple\n- * threads.\n- */\n class rust_kernel {\n     memory_region _region;\n     rust_log _log;"}, {"sha": "199c5f4bf64b463bc888e96b0bc9385f861d860a", "filename": "src/rt/rust_scheduler.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/94ac30c498399eec1c5239b472845d238b1926ec/src%2Frt%2Frust_scheduler.h", "raw_url": "https://github.com/rust-lang/rust/raw/94ac30c498399eec1c5239b472845d238b1926ec/src%2Frt%2Frust_scheduler.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.h?ref=94ac30c498399eec1c5239b472845d238b1926ec", "patch": "@@ -1,3 +1,10 @@\n+/**\n+   The rust scheduler. Schedulers may be added to the kernel\n+   dynamically and they run until there are no more tasks to\n+   schedule. Most of the scheduler work is carried out in worker\n+   threads by rust_sched_loop.\n+ */\n+\n #ifndef RUST_SCHEDULER_H\n #define RUST_SCHEDULER_H\n "}, {"sha": "43f1abd190e2099ddbcd0e9cdb4c55a294788b54", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 48, "deletions": 21, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/94ac30c498399eec1c5239b472845d238b1926ec/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/94ac30c498399eec1c5239b472845d238b1926ec/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=94ac30c498399eec1c5239b472845d238b1926ec", "patch": "@@ -1,3 +1,28 @@\n+/**\n+   The rust task is a cooperatively-scheduled green thread that executes\n+   Rust code on a segmented stack.\n+\n+   This class has too many responsibilities:\n+\n+   * Working with the scheduler loop to signal and respond to state changes,\n+   and dealing with all the thread synchronization issues involved\n+\n+   * Managing the dynamically resizing list of Rust stack segments\n+\n+   * Switching between running Rust code on the Rust segmented stack and\n+   native C code on large stacks owned by the scheduler\n+\n+   The lifetime of a rust_task object closely mirrors that of a running Rust\n+   task object, but they are not identical. In particular, the rust_task is an\n+   atomically reference counted object that might be accessed from arbitrary\n+   threads at any time. This may keep the task from being destroyed even after\n+   the task is dead from a Rust task lifecycle perspective.\n+\n+   FIXME: The task and the scheduler have an over-complicated, undocumented\n+   protocol for shutting down the task, hopefully without races. It would be\n+   easier to reason about if other runtime objects could not access the task\n+   from arbitrary threads, and didn't need to be atomically refcounted.\n+ */\n \n #ifndef RUST_TASK_H\n #define RUST_TASK_H\n@@ -17,7 +42,8 @@\n \n // The amount of extra space at the end of each stack segment, available\n // to the rt, compiler and dynamic linker for running small functions\n-// FIXME: We want this to be 128 but need to slim the red zone calls down\n+// FIXME: We want this to be 128 but need to slim the red zone calls down,\n+// disable lazy symbol relocation, and other things we haven't discovered yet\n #define RZ_LINUX_32 (1024*2)\n #define RZ_LINUX_64 (1024*2)\n #define RZ_MAC_32   (1024*20)\n@@ -59,18 +85,6 @@\n #endif\n #endif\n \n-extern \"C\" CDECL void\n-record_sp_limit(void *limit);\n-extern \"C\" CDECL uintptr_t\n-get_sp_limit();\n-\n-// The function prolog compares the amount of stack needed to the end of\n-// the stack. As an optimization, when the frame size is less than 256\n-// bytes, it will simply compare %esp to to the stack limit instead of\n-// subtracting the frame size. As a result we need our stack limit to\n-// account for those 256 bytes.\n-const unsigned LIMIT_OFFSET = 256;\n-\n struct rust_box;\n \n struct frame_glue_fns {\n@@ -323,14 +337,19 @@ template <typename T> struct task_owned {\n \n // This stuff is on the stack-switching fast path\n \n-// Get a rough approximation of the current stack pointer\n-extern \"C\" uintptr_t get_sp();\n-\n-// This is the function that switches stacks by calling another function with\n-// a single void* argument while changing the stack pointer. It has a funny\n-// name because gdb doesn't normally like to backtrace through split stacks\n-// (thinks it indicates a bug), but has a special case to allow functions\n-// named __morestack to move the stack pointer around.\n+// Records the pointer to the end of the Rust stack in a platform-\n+// specific location in the thread control block\n+extern \"C\" CDECL void      record_sp_limit(void *limit);\n+extern \"C\" CDECL uintptr_t get_sp_limit();\n+// Gets a pointer to the vicinity of the current stack pointer\n+extern \"C\" uintptr_t       get_sp();\n+\n+// This is the function that switches between the C and the Rust stack by\n+// calling another function with a single void* argument while changing the\n+// stack pointer. It has a funny name because gdb doesn't normally like to\n+// backtrace through split stacks (thinks it indicates a bug), but has a\n+// special case to allow functions named __morestack to move the stack pointer\n+// around.\n extern \"C\" void __morestack(void *args, void *fn_ptr, uintptr_t stack_ptr);\n \n inline static uintptr_t\n@@ -490,6 +509,14 @@ rust_task::prev_stack() {\n extern \"C\" CDECL void\n record_sp_limit(void *limit);\n \n+// The LLVM-generated segmented-stack function prolog compares the amount of\n+// stack needed for each frame to the end-of-stack pointer stored in the\n+// TCB. As an optimization, when the frame size is less than 256 bytes, it\n+// will simply compare %esp to to the stack limit instead of subtracting the\n+// frame size. As a result we need our stack limit to account for those 256\n+// bytes.\n+const unsigned LIMIT_OFFSET = 256;\n+\n inline void\n rust_task::record_stack_limit() {\n     assert(stk);"}]}