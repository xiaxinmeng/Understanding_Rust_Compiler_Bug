{"sha": "5f49d4c8435a25d804b2f375e949cb25479f5be9", "node_id": "C_kwDOAAsO6NoAKDVmNDlkNGM4NDM1YTI1ZDgwNGIyZjM3NWU5NDljYjI1NDc5ZjViZTk", "commit": {"author": {"name": "Jubilee", "email": "46493976+workingjubilee@users.noreply.github.com", "date": "2022-02-26T20:56:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-26T20:56:23Z"}, "message": "rust-lang/portable-simd#239: Bitmask conversion trait\n\nAnother approach that fixes rust-lang/portable-simd#223, as an alternative to rust-lang/portable-simd#238.\r\n\r\nThis adds the `ToBitMask` trait, which is implemented on a vector for each bitmask type it supports.  This includes all unsigned integers with enough bits to contain it.  The byte array variant has been separated out for now into rust-lang/portable-simd#246 and still requires `generic_const_exprs`, but the integer variants no longer require it and can make it to nightly.", "tree": {"sha": "d969c418bbbda017059ad85debb33d6c55bca93c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d969c418bbbda017059ad85debb33d6c55bca93c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f49d4c8435a25d804b2f375e949cb25479f5be9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiGpP3CRBK7hj4Ov3rIwAA4dwIAH7D/A26Vdx1QYl/PHiGmb3o\n2h2mwaSaL498kuk3vtLxGbNuujPLcpXMe73eGqZf6fdqAVpjZ17Fx6zXDBKvaln2\nX8m0zRaFe1YmHloW22kLv3g35GuZqwl2/MJkYwBYzHsy4F3GLT14smcbbfty4bS3\n5xsDEe4wBiMEiVCFazvUlNDN/OXvYkEekF3nptnjRyxFkxzwow72Ht2/UdyeteNa\nBgOxczPrZ00YZNXC6iFAPP2krmDNW6vuEIw67O9mKj0KU7AglI+paS1TbdpRzAxB\nBMY4rcjgUyF8WRaWQRAimyowDOoXkMLezWpnrYCfHGJ/tlmVTe+qw4QaRcvKnSs=\n=zD1w\n-----END PGP SIGNATURE-----\n", "payload": "tree d969c418bbbda017059ad85debb33d6c55bca93c\nparent 78a18c3433c13bbd6259242185667c385eafe859\nparent 20fa4b76235afb6a2ad543781a10a14e8013b143\nauthor Jubilee <46493976+workingjubilee@users.noreply.github.com> 1645908983 -0800\ncommitter GitHub <noreply@github.com> 1645908983 -0800\n\nrust-lang/portable-simd#239: Bitmask conversion trait\n\nAnother approach that fixes rust-lang/portable-simd#223, as an alternative to rust-lang/portable-simd#238.\r\n\r\nThis adds the `ToBitMask` trait, which is implemented on a vector for each bitmask type it supports.  This includes all unsigned integers with enough bits to contain it.  The byte array variant has been separated out for now into rust-lang/portable-simd#246 and still requires `generic_const_exprs`, but the integer variants no longer require it and can make it to nightly."}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f49d4c8435a25d804b2f375e949cb25479f5be9", "html_url": "https://github.com/rust-lang/rust/commit/5f49d4c8435a25d804b2f375e949cb25479f5be9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f49d4c8435a25d804b2f375e949cb25479f5be9/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78a18c3433c13bbd6259242185667c385eafe859", "url": "https://api.github.com/repos/rust-lang/rust/commits/78a18c3433c13bbd6259242185667c385eafe859", "html_url": "https://github.com/rust-lang/rust/commit/78a18c3433c13bbd6259242185667c385eafe859"}, {"sha": "20fa4b76235afb6a2ad543781a10a14e8013b143", "url": "https://api.github.com/repos/rust-lang/rust/commits/20fa4b76235afb6a2ad543781a10a14e8013b143", "html_url": "https://github.com/rust-lang/rust/commit/20fa4b76235afb6a2ad543781a10a14e8013b143"}], "stats": {"total": 173, "additions": 115, "deletions": 58}, "files": [{"sha": "e1cd793045046b1963e3613802290cbd5f8ad1b8", "filename": "crates/core_simd/src/masks.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5f49d4c8435a25d804b2f375e949cb25479f5be9/crates%2Fcore_simd%2Fsrc%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f49d4c8435a25d804b2f375e949cb25479f5be9/crates%2Fcore_simd%2Fsrc%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks.rs?ref=5f49d4c8435a25d804b2f375e949cb25479f5be9", "patch": "@@ -12,8 +12,10 @@\n )]\n mod mask_impl;\n \n-use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n+mod to_bitmask;\n+pub use to_bitmask::ToBitMask;\n+\n+use crate::simd::{intrinsics, LaneCount, Simd, SimdElement, SupportedLaneCount};\n use core::cmp::Ordering;\n use core::{fmt, mem};\n \n@@ -225,22 +227,6 @@ where\n         }\n     }\n \n-    /// Convert this mask to a bitmask, with one bit set per lane.\n-    #[cfg(feature = \"generic_const_exprs\")]\n-    #[inline]\n-    #[must_use = \"method returns a new array and does not mutate the original value\"]\n-    pub fn to_bitmask(self) -> [u8; LaneCount::<LANES>::BITMASK_LEN] {\n-        self.0.to_bitmask()\n-    }\n-\n-    /// Convert a bitmask to a mask.\n-    #[cfg(feature = \"generic_const_exprs\")]\n-    #[inline]\n-    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-    pub fn from_bitmask(bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN]) -> Self {\n-        Self(mask_impl::Mask::from_bitmask(bitmask))\n-    }\n-\n     /// Returns true if any lane is set, or false otherwise.\n     #[inline]\n     #[must_use = \"method returns a new bool and does not mutate the original value\"]"}, {"sha": "ec4dd357ee98c5b4660e3173053679d30dceecce", "filename": "crates/core_simd/src/masks/bitmask.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5f49d4c8435a25d804b2f375e949cb25479f5be9/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f49d4c8435a25d804b2f375e949cb25479f5be9/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs?ref=5f49d4c8435a25d804b2f375e949cb25479f5be9", "patch": "@@ -1,7 +1,7 @@\n #![allow(unused_imports)]\n use super::MaskElement;\n use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n+use crate::simd::{LaneCount, Simd, SupportedLaneCount, ToBitMask};\n use core::marker::PhantomData;\n \n /// A mask where each lane is represented by a single bit.\n@@ -115,20 +115,22 @@ where\n         unsafe { Self(intrinsics::simd_bitmask(value), PhantomData) }\n     }\n \n-    #[cfg(feature = \"generic_const_exprs\")]\n     #[inline]\n-    #[must_use = \"method returns a new array and does not mutate the original value\"]\n-    pub fn to_bitmask(self) -> [u8; LaneCount::<LANES>::BITMASK_LEN] {\n-        // Safety: these are the same type and we are laundering the generic\n+    pub fn to_bitmask_integer<U>(self) -> U\n+    where\n+        super::Mask<T, LANES>: ToBitMask<BitMask = U>,\n+    {\n+        // Safety: these are the same types\n         unsafe { core::mem::transmute_copy(&self.0) }\n     }\n \n-    #[cfg(feature = \"generic_const_exprs\")]\n     #[inline]\n-    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-    pub fn from_bitmask(bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN]) -> Self {\n-        // Safety: these are the same type and we are laundering the generic\n-        Self(unsafe { core::mem::transmute_copy(&bitmask) }, PhantomData)\n+    pub fn from_bitmask_integer<U>(bitmask: U) -> Self\n+    where\n+        super::Mask<T, LANES>: ToBitMask<BitMask = U>,\n+    {\n+        // Safety: these are the same types\n+        unsafe { Self(core::mem::transmute_copy(&bitmask), PhantomData) }\n     }\n \n     #[inline]"}, {"sha": "8bbdf637de84defcc23f1e3a8afc07d0eb2538a7", "filename": "crates/core_simd/src/masks/full_masks.rs", "status": "modified", "additions": 40, "deletions": 28, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/5f49d4c8435a25d804b2f375e949cb25479f5be9/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f49d4c8435a25d804b2f375e949cb25479f5be9/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=5f49d4c8435a25d804b2f375e949cb25479f5be9", "patch": "@@ -2,7 +2,7 @@\n \n use super::MaskElement;\n use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n+use crate::simd::{LaneCount, Simd, SupportedLaneCount, ToBitMask};\n \n #[repr(transparent)]\n pub struct Mask<T, const LANES: usize>(Simd<T, LANES>)\n@@ -66,6 +66,23 @@ where\n     }\n }\n \n+// Used for bitmask bit order workaround\n+pub(crate) trait ReverseBits {\n+    fn reverse_bits(self) -> Self;\n+}\n+\n+macro_rules! impl_reverse_bits {\n+    { $($int:ty),* } => {\n+        $(\n+        impl ReverseBits for $int {\n+            fn reverse_bits(self) -> Self { <$int>::reverse_bits(self) }\n+        }\n+        )*\n+    }\n+}\n+\n+impl_reverse_bits! { u8, u16, u32, u64 }\n+\n impl<T, const LANES: usize> Mask<T, LANES>\n where\n     T: MaskElement,\n@@ -110,41 +127,36 @@ where\n         unsafe { Mask(intrinsics::simd_cast(self.0)) }\n     }\n \n-    #[cfg(feature = \"generic_const_exprs\")]\n     #[inline]\n-    #[must_use = \"method returns a new array and does not mutate the original value\"]\n-    pub fn to_bitmask(self) -> [u8; LaneCount::<LANES>::BITMASK_LEN] {\n-        unsafe {\n-            let mut bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN] =\n-                intrinsics::simd_bitmask(self.0);\n-\n-            // There is a bug where LLVM appears to implement this operation with the wrong\n-            // bit order.\n-            // TODO fix this in a better way\n-            if cfg!(target_endian = \"big\") {\n-                for x in bitmask.as_mut() {\n-                    *x = x.reverse_bits();\n-                }\n-            }\n+    pub(crate) fn to_bitmask_integer<U: ReverseBits>(self) -> U\n+    where\n+        super::Mask<T, LANES>: ToBitMask<BitMask = U>,\n+    {\n+        // Safety: U is required to be the appropriate bitmask type\n+        let bitmask: U = unsafe { intrinsics::simd_bitmask(self.0) };\n \n+        // LLVM assumes bit order should match endianness\n+        if cfg!(target_endian = \"big\") {\n+            bitmask.reverse_bits()\n+        } else {\n             bitmask\n         }\n     }\n \n-    #[cfg(feature = \"generic_const_exprs\")]\n     #[inline]\n-    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-    pub fn from_bitmask(mut bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN]) -> Self {\n-        unsafe {\n-            // There is a bug where LLVM appears to implement this operation with the wrong\n-            // bit order.\n-            // TODO fix this in a better way\n-            if cfg!(target_endian = \"big\") {\n-                for x in bitmask.as_mut() {\n-                    *x = x.reverse_bits();\n-                }\n-            }\n+    pub(crate) fn from_bitmask_integer<U: ReverseBits>(bitmask: U) -> Self\n+    where\n+        super::Mask<T, LANES>: ToBitMask<BitMask = U>,\n+    {\n+        // LLVM assumes bit order should match endianness\n+        let bitmask = if cfg!(target_endian = \"big\") {\n+            bitmask.reverse_bits()\n+        } else {\n+            bitmask\n+        };\n \n+        // Safety: U is required to be the appropriate bitmask type\n+        unsafe {\n             Self::from_int_unchecked(intrinsics::simd_select_bitmask(\n                 bitmask,\n                 Self::splat(true).to_int(),"}, {"sha": "1c2037764c1e45af1960550df93cc290af05eaee", "filename": "crates/core_simd/src/masks/to_bitmask.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/5f49d4c8435a25d804b2f375e949cb25479f5be9/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fto_bitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f49d4c8435a25d804b2f375e949cb25479f5be9/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fto_bitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fto_bitmask.rs?ref=5f49d4c8435a25d804b2f375e949cb25479f5be9", "patch": "@@ -0,0 +1,57 @@\n+use super::{mask_impl, Mask, MaskElement};\n+use crate::simd::{LaneCount, SupportedLaneCount};\n+\n+mod sealed {\n+    pub trait Sealed {}\n+}\n+pub use sealed::Sealed;\n+\n+impl<T, const LANES: usize> Sealed for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+}\n+\n+/// Converts masks to and from integer bitmasks.\n+///\n+/// Each bit of the bitmask corresponds to a mask lane, starting with the LSB.\n+///\n+/// # Safety\n+/// This trait is `unsafe` and sealed, since the `BitMask` type must match the number of lanes in\n+/// the mask.\n+pub unsafe trait ToBitMask: Sealed {\n+    /// The integer bitmask type.\n+    type BitMask;\n+\n+    /// Converts a mask to a bitmask.\n+    fn to_bitmask(self) -> Self::BitMask;\n+\n+    /// Converts a bitmask to a mask.\n+    fn from_bitmask(bitmask: Self::BitMask) -> Self;\n+}\n+\n+macro_rules! impl_integer_intrinsic {\n+    { $(unsafe impl ToBitMask<BitMask=$int:ty> for Mask<_, $lanes:literal>)* } => {\n+        $(\n+        unsafe impl<T: MaskElement> ToBitMask for Mask<T, $lanes> {\n+            type BitMask = $int;\n+\n+            fn to_bitmask(self) -> $int {\n+                self.0.to_bitmask_integer()\n+            }\n+\n+            fn from_bitmask(bitmask: $int) -> Self {\n+                Self(mask_impl::Mask::from_bitmask_integer(bitmask))\n+            }\n+        }\n+        )*\n+    }\n+}\n+\n+impl_integer_intrinsic! {\n+    unsafe impl ToBitMask<BitMask=u8> for Mask<_, 8>\n+    unsafe impl ToBitMask<BitMask=u16> for Mask<_, 16>\n+    unsafe impl ToBitMask<BitMask=u32> for Mask<_, 32>\n+    unsafe impl ToBitMask<BitMask=u64> for Mask<_, 64>\n+}"}, {"sha": "3aec36ca7b7468b89f9a23401c85bbfd7a7b6151", "filename": "crates/core_simd/tests/masks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f49d4c8435a25d804b2f375e949cb25479f5be9/crates%2Fcore_simd%2Ftests%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f49d4c8435a25d804b2f375e949cb25479f5be9/crates%2Fcore_simd%2Ftests%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fmasks.rs?ref=5f49d4c8435a25d804b2f375e949cb25479f5be9", "patch": "@@ -68,16 +68,16 @@ macro_rules! test_mask_api {\n                 assert_eq!(core_simd::Mask::<$type, 8>::from_int(int), mask);\n             }\n \n-            #[cfg(feature = \"generic_const_exprs\")]\n             #[test]\n             fn roundtrip_bitmask_conversion() {\n+                use core_simd::ToBitMask;\n                 let values = [\n                     true, false, false, true, false, false, true, false,\n                     true, true, false, false, false, false, false, true,\n                 ];\n                 let mask = core_simd::Mask::<$type, 16>::from_array(values);\n                 let bitmask = mask.to_bitmask();\n-                assert_eq!(bitmask, [0b01001001, 0b10000011]);\n+                assert_eq!(bitmask, 0b1000001101001001);\n                 assert_eq!(core_simd::Mask::<$type, 16>::from_bitmask(bitmask), mask);\n             }\n         }"}]}