{"sha": "6587dda39e9b49b322394592e45a477da68c7f1a", "node_id": "C_kwDOAAsO6NoAKDY1ODdkZGEzOWU5YjQ5YjMyMjM5NDU5MmU0NWE0NzdkYTY4YzdmMWE", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2022-06-22T15:56:26Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2022-06-22T22:44:39Z"}, "message": "Refactor iter adapters with less macros", "tree": {"sha": "5b7af876b60b15c16840e7107a31319e7cd50ef5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b7af876b60b15c16840e7107a31319e7cd50ef5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6587dda39e9b49b322394592e45a477da68c7f1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6587dda39e9b49b322394592e45a477da68c7f1a", "html_url": "https://github.com/rust-lang/rust/commit/6587dda39e9b49b322394592e45a477da68c7f1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6587dda39e9b49b322394592e45a477da68c7f1a/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10f4ce324baf7cfb7ce2b2096662b82b79204944", "url": "https://api.github.com/repos/rust-lang/rust/commits/10f4ce324baf7cfb7ce2b2096662b82b79204944", "html_url": "https://github.com/rust-lang/rust/commit/10f4ce324baf7cfb7ce2b2096662b82b79204944"}], "stats": {"total": 173, "additions": 56, "deletions": 117}, "files": [{"sha": "60eb3a6da3a4bf93147a7a5cd103ed380eef6954", "filename": "library/core/src/iter/adapters/chain.rs", "status": "modified", "additions": 19, "deletions": 53, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/6587dda39e9b49b322394592e45a477da68c7f1a/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6587dda39e9b49b322394592e45a477da68c7f1a/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fchain.rs?ref=6587dda39e9b49b322394592e45a477da68c7f1a", "patch": "@@ -37,33 +37,6 @@ impl<A, B> Chain<A, B> {\n     }\n }\n \n-/// Fuse the iterator if the expression is `None`.\n-macro_rules! fuse {\n-    ($self:ident . $iter:ident . $($call:tt)+) => {\n-        match $self.$iter {\n-            Some(ref mut iter) => match iter.$($call)+ {\n-                None => {\n-                    $self.$iter = None;\n-                    None\n-                }\n-                item => item,\n-            },\n-            None => None,\n-        }\n-    };\n-}\n-\n-/// Try an iterator method without fusing,\n-/// like an inline `.as_mut().and_then(...)`\n-macro_rules! maybe {\n-    ($self:ident . $iter:ident . $($call:tt)+) => {\n-        match $self.$iter {\n-            Some(ref mut iter) => iter.$($call)+,\n-            None => None,\n-        }\n-    };\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B> Iterator for Chain<A, B>\n where\n@@ -74,10 +47,7 @@ where\n \n     #[inline]\n     fn next(&mut self) -> Option<A::Item> {\n-        match fuse!(self.a.next()) {\n-            None => maybe!(self.b.next()),\n-            item => item,\n-        }\n+        and_then_or_clear(&mut self.a, Iterator::next).or_else(|| self.b.as_mut()?.next())\n     }\n \n     #[inline]\n@@ -161,31 +131,23 @@ where\n             self.a = None;\n         }\n \n-        maybe!(self.b.nth(n))\n+        self.b.as_mut()?.nth(n)\n     }\n \n     #[inline]\n     fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n     where\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        match fuse!(self.a.find(&mut predicate)) {\n-            None => maybe!(self.b.find(predicate)),\n-            item => item,\n-        }\n+        and_then_or_clear(&mut self.a, |a| a.find(&mut predicate))\n+            .or_else(|| self.b.as_mut()?.find(predicate))\n     }\n \n     #[inline]\n     fn last(self) -> Option<A::Item> {\n         // Must exhaust a before b.\n-        let a_last = match self.a {\n-            Some(a) => a.last(),\n-            None => None,\n-        };\n-        let b_last = match self.b {\n-            Some(b) => b.last(),\n-            None => None,\n-        };\n+        let a_last = self.a.and_then(Iterator::last);\n+        let b_last = self.b.and_then(Iterator::last);\n         b_last.or(a_last)\n     }\n \n@@ -220,10 +182,7 @@ where\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<A::Item> {\n-        match fuse!(self.b.next_back()) {\n-            None => maybe!(self.a.next_back()),\n-            item => item,\n-        }\n+        and_then_or_clear(&mut self.b, |b| b.next_back()).or_else(|| self.a.as_mut()?.next_back())\n     }\n \n     #[inline]\n@@ -263,18 +222,16 @@ where\n             self.b = None;\n         }\n \n-        maybe!(self.a.nth_back(n))\n+        self.a.as_mut()?.nth_back(n)\n     }\n \n     #[inline]\n     fn rfind<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n     where\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        match fuse!(self.b.rfind(&mut predicate)) {\n-            None => maybe!(self.a.rfind(predicate)),\n-            item => item,\n-        }\n+        and_then_or_clear(&mut self.b, |b| b.rfind(&mut predicate))\n+            .or_else(|| self.a.as_mut()?.rfind(predicate))\n     }\n \n     fn try_rfold<Acc, F, R>(&mut self, mut acc: Acc, mut f: F) -> R\n@@ -324,3 +281,12 @@ where\n     B: TrustedLen<Item = A::Item>,\n {\n }\n+\n+#[inline]\n+fn and_then_or_clear<T, U>(opt: &mut Option<T>, f: impl FnOnce(&mut T) -> Option<U>) -> Option<U> {\n+    let x = f(opt.as_mut()?);\n+    if x.is_none() {\n+        *opt = None;\n+    }\n+    x\n+}"}, {"sha": "15a120e35a2fa16c75562b84eaed6e60ed79045e", "filename": "library/core/src/iter/adapters/flatten.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6587dda39e9b49b322394592e45a477da68c7f1a/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6587dda39e9b49b322394592e45a477da68c7f1a/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs?ref=6587dda39e9b49b322394592e45a477da68c7f1a", "patch": "@@ -290,20 +290,11 @@ where\n     #[inline]\n     fn next(&mut self) -> Option<U::Item> {\n         loop {\n-            if let Some(ref mut inner) = self.frontiter {\n-                match inner.next() {\n-                    None => self.frontiter = None,\n-                    elt @ Some(_) => return elt,\n-                }\n+            if let elt @ Some(_) = and_then_or_clear(&mut self.frontiter, Iterator::next) {\n+                return elt;\n             }\n             match self.iter.next() {\n-                None => match self.backiter.as_mut()?.next() {\n-                    None => {\n-                        self.backiter = None;\n-                        return None;\n-                    }\n-                    elt @ Some(_) => return elt,\n-                },\n+                None => return and_then_or_clear(&mut self.backiter, Iterator::next),\n                 Some(inner) => self.frontiter = Some(inner.into_iter()),\n             }\n         }\n@@ -436,21 +427,12 @@ where\n     #[inline]\n     fn next_back(&mut self) -> Option<U::Item> {\n         loop {\n-            if let Some(ref mut inner) = self.backiter {\n-                match inner.next_back() {\n-                    None => self.backiter = None,\n-                    elt @ Some(_) => return elt,\n-                }\n+            if let elt @ Some(_) = and_then_or_clear(&mut self.backiter, |b| b.next_back()) {\n+                return elt;\n             }\n             match self.iter.next_back() {\n-                None => match self.frontiter.as_mut()?.next_back() {\n-                    None => {\n-                        self.frontiter = None;\n-                        return None;\n-                    }\n-                    elt @ Some(_) => return elt,\n-                },\n-                next => self.backiter = next.map(IntoIterator::into_iter),\n+                None => return and_then_or_clear(&mut self.frontiter, |f| f.next_back()),\n+                Some(inner) => self.backiter = Some(inner.into_iter()),\n             }\n         }\n     }\n@@ -606,3 +588,12 @@ unsafe impl<T, const N: usize> TrustedConstSize for [T; N] {}\n unsafe impl<T, const N: usize> TrustedConstSize for &'_ [T; N] {}\n #[unstable(feature = \"std_internals\", issue = \"none\")]\n unsafe impl<T, const N: usize> TrustedConstSize for &'_ mut [T; N] {}\n+\n+#[inline]\n+fn and_then_or_clear<T, U>(opt: &mut Option<T>, f: impl FnOnce(&mut T) -> Option<U>) -> Option<U> {\n+    let x = f(opt.as_mut()?);\n+    if x.is_none() {\n+        *opt = None;\n+    }\n+    x\n+}"}, {"sha": "c931445420342bf16c9585ab145d1ca73ab0c910", "filename": "library/core/src/iter/adapters/fuse.rs", "status": "modified", "additions": 21, "deletions": 39, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6587dda39e9b49b322394592e45a477da68c7f1a/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6587dda39e9b49b322394592e45a477da68c7f1a/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs?ref=6587dda39e9b49b322394592e45a477da68c7f1a", "patch": "@@ -29,33 +29,6 @@ impl<I> Fuse<I> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I> FusedIterator for Fuse<I> where I: Iterator {}\n \n-/// Fuse the iterator if the expression is `None`.\n-macro_rules! fuse {\n-    ($self:ident . iter . $($call:tt)+) => {\n-        match $self.iter {\n-            Some(ref mut iter) => match iter.$($call)+ {\n-                None => {\n-                    $self.iter = None;\n-                    None\n-                }\n-                item => item,\n-            },\n-            None => None,\n-        }\n-    };\n-}\n-\n-/// Specialized macro that doesn't check if the expression is `None`.\n-/// (We trust that a `FusedIterator` will fuse itself.)\n-macro_rules! spec {\n-    ($self:ident . iter . $($call:tt)+) => {\n-        match $self.iter {\n-            Some(ref mut iter) => iter.$($call)+,\n-            None => None,\n-        }\n-    };\n-}\n-\n // Any specialized implementation here is made internal\n // to avoid exposing default fns outside this trait.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -281,12 +254,12 @@ where\n \n     #[inline]\n     default fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        fuse!(self.iter.next())\n+        and_then_or_clear(&mut self.iter, Iterator::next)\n     }\n \n     #[inline]\n     default fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        fuse!(self.iter.nth(n))\n+        and_then_or_clear(&mut self.iter, |iter| iter.nth(n))\n     }\n \n     #[inline]\n@@ -308,23 +281,23 @@ where\n     where\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        fuse!(self.iter.find(predicate))\n+        and_then_or_clear(&mut self.iter, |iter| iter.find(predicate))\n     }\n \n     #[inline]\n     default fn next_back(&mut self) -> Option<<I as Iterator>::Item>\n     where\n         I: DoubleEndedIterator,\n     {\n-        fuse!(self.iter.next_back())\n+        and_then_or_clear(&mut self.iter, |iter| iter.next_back())\n     }\n \n     #[inline]\n     default fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item>\n     where\n         I: DoubleEndedIterator,\n     {\n-        fuse!(self.iter.nth_back(n))\n+        and_then_or_clear(&mut self.iter, |iter| iter.nth_back(n))\n     }\n \n     #[inline]\n@@ -348,7 +321,7 @@ where\n         P: FnMut(&Self::Item) -> bool,\n         I: DoubleEndedIterator,\n     {\n-        fuse!(self.iter.rfind(predicate))\n+        and_then_or_clear(&mut self.iter, |iter| iter.rfind(predicate))\n     }\n }\n \n@@ -361,12 +334,12 @@ where\n {\n     #[inline]\n     fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        spec!(self.iter.next())\n+        self.iter.as_mut()?.next()\n     }\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        spec!(self.iter.nth(n))\n+        self.iter.as_mut()?.nth(n)\n     }\n \n     #[inline]\n@@ -387,23 +360,23 @@ where\n     where\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        spec!(self.iter.find(predicate))\n+        self.iter.as_mut()?.find(predicate)\n     }\n \n     #[inline]\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item>\n     where\n         I: DoubleEndedIterator,\n     {\n-        spec!(self.iter.next_back())\n+        self.iter.as_mut()?.next_back()\n     }\n \n     #[inline]\n     fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item>\n     where\n         I: DoubleEndedIterator,\n     {\n-        spec!(self.iter.nth_back(n))\n+        self.iter.as_mut()?.nth_back(n)\n     }\n \n     #[inline]\n@@ -426,6 +399,15 @@ where\n         P: FnMut(&Self::Item) -> bool,\n         I: DoubleEndedIterator,\n     {\n-        spec!(self.iter.rfind(predicate))\n+        self.iter.as_mut()?.rfind(predicate)\n+    }\n+}\n+\n+#[inline]\n+fn and_then_or_clear<T, U>(opt: &mut Option<T>, f: impl FnOnce(&mut T) -> Option<U>) -> Option<U> {\n+    let x = f(opt.as_mut()?);\n+    if x.is_none() {\n+        *opt = None;\n     }\n+    x\n }"}]}