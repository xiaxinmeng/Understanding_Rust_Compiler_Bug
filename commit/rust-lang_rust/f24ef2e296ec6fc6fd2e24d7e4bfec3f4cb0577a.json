{"sha": "f24ef2e296ec6fc6fd2e24d7e4bfec3f4cb0577a", "node_id": "C_kwDOAAsO6NoAKGYyNGVmMmUyOTZlYzZmYzZmZDJlMjRkN2U0YmZlYzNmNGNiMDU3N2E", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-20T03:27:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-20T03:27:01Z"}, "message": "Auto merge of #97029 - eholk:drop-tracking-yielding-in-match-guard, r=nikomatsakis\n\ngenerator_interior: Count match pattern bindings as borrowed for the whole guard expression\n\nThe test case `yielding-in-match-guard.rs` was failing with `-Zdrop-tracking` enabled. The reason is that the copy of a local (`y`) was not counted as a borrow in typeck, while MIR did consider this as borrowed.\n\nThe correct thing to do here is to count pattern bindings are borrowed for the whole guard. Instead, what we were doing is to record the type at the use site of the variable and check if the variable comes from a borrowed pattern. Due to the fix for #57017, we were considering too small of a scope for this variable, which meant it was not counted as borrowed.\n\nBecause we now unconditionally record the borrow, rather than only for bindings that are used, this PR is also able to remove a lot of the logic around match bindings that was there before.\n\nr? `@nikomatsakis`", "tree": {"sha": "f7f4a65df4a7298fe7423d03501700165373f4f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7f4a65df4a7298fe7423d03501700165373f4f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f24ef2e296ec6fc6fd2e24d7e4bfec3f4cb0577a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f24ef2e296ec6fc6fd2e24d7e4bfec3f4cb0577a", "html_url": "https://github.com/rust-lang/rust/commit/f24ef2e296ec6fc6fd2e24d7e4bfec3f4cb0577a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f24ef2e296ec6fc6fd2e24d7e4bfec3f4cb0577a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d6992bc18e54522cced4f945f29f186992d5ea4", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d6992bc18e54522cced4f945f29f186992d5ea4", "html_url": "https://github.com/rust-lang/rust/commit/4d6992bc18e54522cced4f945f29f186992d5ea4"}, {"sha": "7d1dbdf3de3abcce9bbd571e5c88b890e9a37243", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d1dbdf3de3abcce9bbd571e5c88b890e9a37243", "html_url": "https://github.com/rust-lang/rust/commit/7d1dbdf3de3abcce9bbd571e5c88b890e9a37243"}], "stats": {"total": 181, "additions": 87, "deletions": 94}, "files": [{"sha": "57655365cca952b422d902f4c25abf33339cecbc", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f24ef2e296ec6fc6fd2e24d7e4bfec3f4cb0577a/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f24ef2e296ec6fc6fd2e24d7e4bfec3f4cb0577a/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=f24ef2e296ec6fc6fd2e24d7e4bfec3f4cb0577a", "patch": "@@ -1323,6 +1323,20 @@ pub enum Guard<'hir> {\n     IfLet(&'hir Let<'hir>),\n }\n \n+impl<'hir> Guard<'hir> {\n+    /// Returns the body of the guard\n+    ///\n+    /// In other words, returns the e in either of the following:\n+    ///\n+    /// - `if e`\n+    /// - `if let x = e`\n+    pub fn body(&self) -> &'hir Expr<'hir> {\n+        match self {\n+            Guard::If(e) | Guard::IfLet(Let { init: e, .. }) => e,\n+        }\n+    }\n+}\n+\n #[derive(Debug, HashStable_Generic)]\n pub struct ExprField<'hir> {\n     #[stable_hasher(ignore)]"}, {"sha": "60d19405bcfaf541919eb51b6a46bd46e071fda5", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 44, "deletions": 90, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/f24ef2e296ec6fc6fd2e24d7e4bfec3f4cb0577a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f24ef2e296ec6fc6fd2e24d7e4bfec3f4cb0577a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=f24ef2e296ec6fc6fd2e24d7e4bfec3f4cb0577a", "patch": "@@ -17,7 +17,6 @@ use rustc_middle::middle::region::{self, Scope, ScopeData, YieldData};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n-use smallvec::SmallVec;\n use tracing::debug;\n \n mod drop_ranges;\n@@ -29,13 +28,6 @@ struct InteriorVisitor<'a, 'tcx> {\n     expr_count: usize,\n     kind: hir::GeneratorKind,\n     prev_unresolved_span: Option<Span>,\n-    /// Match arm guards have temporary borrows from the pattern bindings.\n-    /// In case there is a yield point in a guard with a reference to such bindings,\n-    /// such borrows can span across this yield point.\n-    /// As such, we need to track these borrows and record them despite of the fact\n-    /// that they may succeed the said yield point in the post-order.\n-    guard_bindings: SmallVec<[SmallVec<[HirId; 4]>; 1]>,\n-    guard_bindings_set: HirIdSet,\n     linted_values: HirIdSet,\n     drop_ranges: DropRanges,\n }\n@@ -48,7 +40,6 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n         scope: Option<region::Scope>,\n         expr: Option<&'tcx Expr<'tcx>>,\n         source_span: Span,\n-        guard_borrowing_from_pattern: bool,\n     ) {\n         use rustc_span::DUMMY_SP;\n \n@@ -89,8 +80,7 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                             // If it is a borrowing happening in the guard,\n                             // it needs to be recorded regardless because they\n                             // do live across this yield point.\n-                            guard_borrowing_from_pattern\n-                                || yield_data.expr_and_pat_count >= self.expr_count\n+                            yield_data.expr_and_pat_count >= self.expr_count\n                         })\n                         .cloned()\n                 })\n@@ -196,8 +186,6 @@ pub fn resolve_interior<'a, 'tcx>(\n         expr_count: 0,\n         kind,\n         prev_unresolved_span: None,\n-        guard_bindings: <_>::default(),\n-        guard_bindings_set: <_>::default(),\n         linted_values: <_>::default(),\n         drop_ranges: drop_ranges::compute_drop_ranges(fcx, def_id, body),\n     };\n@@ -284,15 +272,47 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         let Arm { guard, pat, body, .. } = arm;\n         self.visit_pat(pat);\n         if let Some(ref g) = guard {\n-            self.guard_bindings.push(<_>::default());\n-            ArmPatCollector {\n-                guard_bindings_set: &mut self.guard_bindings_set,\n-                guard_bindings: self\n-                    .guard_bindings\n-                    .last_mut()\n-                    .expect(\"should have pushed at least one earlier\"),\n+            {\n+                // If there is a guard, we need to count all variables bound in the pattern as\n+                // borrowed for the entire guard body, regardless of whether they are accessed.\n+                // We do this by walking the pattern bindings and recording `&T` for any `x: T`\n+                // that is bound.\n+\n+                struct ArmPatCollector<'a, 'b, 'tcx> {\n+                    interior_visitor: &'a mut InteriorVisitor<'b, 'tcx>,\n+                    scope: Scope,\n+                }\n+\n+                impl<'a, 'b, 'tcx> Visitor<'tcx> for ArmPatCollector<'a, 'b, 'tcx> {\n+                    fn visit_pat(&mut self, pat: &'tcx Pat<'tcx>) {\n+                        intravisit::walk_pat(self, pat);\n+                        if let PatKind::Binding(_, id, ident, ..) = pat.kind {\n+                            let ty =\n+                                self.interior_visitor.fcx.typeck_results.borrow().node_type(id);\n+                            let tcx = self.interior_visitor.fcx.tcx;\n+                            let ty = tcx.mk_ref(\n+                                // Use `ReErased` as `resolve_interior` is going to replace all the\n+                                // regions anyway.\n+                                tcx.mk_region(ty::ReErased),\n+                                ty::TypeAndMut { ty, mutbl: hir::Mutability::Not },\n+                            );\n+                            self.interior_visitor.record(\n+                                ty,\n+                                id,\n+                                Some(self.scope),\n+                                None,\n+                                ident.span,\n+                            );\n+                        }\n+                    }\n+                }\n+\n+                ArmPatCollector {\n+                    interior_visitor: self,\n+                    scope: Scope { id: g.body().hir_id.local_id, data: ScopeData::Node },\n+                }\n+                .visit_pat(pat);\n             }\n-            .visit_pat(pat);\n \n             match g {\n                 Guard::If(ref e) => {\n@@ -302,12 +322,6 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n                     self.visit_let_expr(l);\n                 }\n             }\n-\n-            let mut scope_var_ids =\n-                self.guard_bindings.pop().expect(\"should have pushed at least one earlier\");\n-            for var_id in scope_var_ids.drain(..) {\n-                self.guard_bindings_set.remove(&var_id);\n-            }\n         }\n         self.visit_expr(body);\n     }\n@@ -320,13 +334,11 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         if let PatKind::Binding(..) = pat.kind {\n             let scope = self.region_scope_tree.var_scope(pat.hir_id.local_id).unwrap();\n             let ty = self.fcx.typeck_results.borrow().pat_ty(pat);\n-            self.record(ty, pat.hir_id, Some(scope), None, pat.span, false);\n+            self.record(ty, pat.hir_id, Some(scope), None, pat.span);\n         }\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        let mut guard_borrowing_from_pattern = false;\n-\n         match &expr.kind {\n             ExprKind::Call(callee, args) => match &callee.kind {\n                 ExprKind::Path(qpath) => {\n@@ -353,16 +365,6 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n                 }\n                 _ => intravisit::walk_expr(self, expr),\n             },\n-            ExprKind::Path(qpath) => {\n-                intravisit::walk_expr(self, expr);\n-                let res = self.fcx.typeck_results.borrow().qpath_res(qpath, expr.hir_id);\n-                match res {\n-                    Res::Local(id) if self.guard_bindings_set.contains(&id) => {\n-                        guard_borrowing_from_pattern = true;\n-                    }\n-                    _ => {}\n-                }\n-            }\n             _ => intravisit::walk_expr(self, expr),\n         }\n \n@@ -391,14 +393,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         // If there are adjustments, then record the final type --\n         // this is the actual value that is being produced.\n         if let Some(adjusted_ty) = self.fcx.typeck_results.borrow().expr_ty_adjusted_opt(expr) {\n-            self.record(\n-                adjusted_ty,\n-                expr.hir_id,\n-                scope,\n-                Some(expr),\n-                expr.span,\n-                guard_borrowing_from_pattern,\n-            );\n+            self.record(adjusted_ty, expr.hir_id, scope, Some(expr), expr.span);\n         }\n \n         // Also record the unadjusted type (which is the only type if\n@@ -426,54 +421,13 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         // The type table might not have information for this expression\n         // if it is in a malformed scope. (#66387)\n         if let Some(ty) = self.fcx.typeck_results.borrow().expr_ty_opt(expr) {\n-            if guard_borrowing_from_pattern {\n-                // Match guards create references to all the bindings in the pattern that are used\n-                // in the guard, e.g. `y if is_even(y) => ...` becomes `is_even(*r_y)` where `r_y`\n-                // is a reference to `y`, so we must record a reference to the type of the binding.\n-                let tcx = self.fcx.tcx;\n-                let ref_ty = tcx.mk_ref(\n-                    // Use `ReErased` as `resolve_interior` is going to replace all the regions anyway.\n-                    tcx.mk_region(ty::ReErased),\n-                    ty::TypeAndMut { ty, mutbl: hir::Mutability::Not },\n-                );\n-                self.record(\n-                    ref_ty,\n-                    expr.hir_id,\n-                    scope,\n-                    Some(expr),\n-                    expr.span,\n-                    guard_borrowing_from_pattern,\n-                );\n-            }\n-            self.record(\n-                ty,\n-                expr.hir_id,\n-                scope,\n-                Some(expr),\n-                expr.span,\n-                guard_borrowing_from_pattern,\n-            );\n+            self.record(ty, expr.hir_id, scope, Some(expr), expr.span);\n         } else {\n             self.fcx.tcx.sess.delay_span_bug(expr.span, \"no type for node\");\n         }\n     }\n }\n \n-struct ArmPatCollector<'a> {\n-    guard_bindings_set: &'a mut HirIdSet,\n-    guard_bindings: &'a mut SmallVec<[HirId; 4]>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for ArmPatCollector<'a> {\n-    fn visit_pat(&mut self, pat: &'tcx Pat<'tcx>) {\n-        intravisit::walk_pat(self, pat);\n-        if let PatKind::Binding(_, id, ..) = pat.kind {\n-            self.guard_bindings.push(id);\n-            self.guard_bindings_set.insert(id);\n-        }\n-    }\n-}\n-\n #[derive(Default)]\n pub struct SuspendCheckData<'a, 'tcx> {\n     expr: Option<&'tcx Expr<'tcx>>,"}, {"sha": "ad44adb68c69cb4cf55d1c4b0b5c5455016cf1ba", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f24ef2e296ec6fc6fd2e24d7e4bfec3f4cb0577a/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f24ef2e296ec6fc6fd2e24d7e4bfec3f4cb0577a/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=f24ef2e296ec6fc6fd2e24d7e4bfec3f4cb0577a", "patch": "@@ -17,6 +17,7 @@ use rustc_middle::hir::place::ProjectionKind;\n use rustc_middle::mir::FakeReadCause;\n use rustc_middle::ty::{self, adjustment, AdtKind, Ty, TyCtxt};\n use rustc_target::abi::VariantIdx;\n+use ty::BorrowKind::ImmBorrow;\n \n use crate::mem_categorization as mc;\n \n@@ -621,7 +622,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             FakeReadCause::ForMatchedPlace(closure_def_id),\n             discr_place.hir_id,\n         );\n-        self.walk_pat(discr_place, arm.pat);\n+        self.walk_pat(discr_place, arm.pat, arm.guard.is_some());\n \n         if let Some(hir::Guard::If(e)) = arm.guard {\n             self.consume_expr(e)\n@@ -645,12 +646,17 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             FakeReadCause::ForLet(closure_def_id),\n             discr_place.hir_id,\n         );\n-        self.walk_pat(discr_place, pat);\n+        self.walk_pat(discr_place, pat, false);\n     }\n \n     /// The core driver for walking a pattern\n-    fn walk_pat(&mut self, discr_place: &PlaceWithHirId<'tcx>, pat: &hir::Pat<'_>) {\n-        debug!(\"walk_pat(discr_place={:?}, pat={:?})\", discr_place, pat);\n+    fn walk_pat(\n+        &mut self,\n+        discr_place: &PlaceWithHirId<'tcx>,\n+        pat: &hir::Pat<'_>,\n+        has_guard: bool,\n+    ) {\n+        debug!(\"walk_pat(discr_place={:?}, pat={:?}, has_guard={:?})\", discr_place, pat, has_guard);\n \n         let tcx = self.tcx();\n         let ExprUseVisitor { ref mc, body_owner: _, ref mut delegate } = *self;\n@@ -671,6 +677,13 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                         delegate.bind(binding_place, binding_place.hir_id);\n                     }\n \n+                    // Subtle: MIR desugaring introduces immutable borrows for each pattern\n+                    // binding when lowering pattern guards to ensure that the guard does not\n+                    // modify the scrutinee.\n+                    if has_guard {\n+                        delegate.borrow(place, discr_place.hir_id, ImmBorrow);\n+                    }\n+\n                     // It is also a borrow or copy/move of the value being matched.\n                     // In a cases of pattern like `let pat = upvar`, don't use the span\n                     // of the pattern, as this just looks confusing, instead use the span"}, {"sha": "646365e4359016eb958bc796b92512318fadc07a", "filename": "src/test/ui/generator/drop-tracking-yielding-in-match-guards.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f24ef2e296ec6fc6fd2e24d7e4bfec3f4cb0577a/src%2Ftest%2Fui%2Fgenerator%2Fdrop-tracking-yielding-in-match-guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f24ef2e296ec6fc6fd2e24d7e4bfec3f4cb0577a/src%2Ftest%2Fui%2Fgenerator%2Fdrop-tracking-yielding-in-match-guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fdrop-tracking-yielding-in-match-guards.rs?ref=f24ef2e296ec6fc6fd2e24d7e4bfec3f4cb0577a", "patch": "@@ -0,0 +1,12 @@\n+// build-pass\n+// edition:2018\n+// compile-flags: -Zdrop-tracking\n+\n+#![feature(generators)]\n+\n+fn main() {\n+    let _ = static |x: u8| match x {\n+        y if { yield } == y + 1 => (),\n+        _ => (),\n+    };\n+}"}]}