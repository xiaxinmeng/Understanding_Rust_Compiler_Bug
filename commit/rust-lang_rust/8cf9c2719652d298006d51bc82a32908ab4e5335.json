{"sha": "8cf9c2719652d298006d51bc82a32908ab4e5335", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjZjljMjcxOTY1MmQyOTgwMDZkNTFiYzgyYTMyOTA4YWI0ZTUzMzU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-12T18:50:15Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-15T21:00:05Z"}, "message": "generic salsa algo", "tree": {"sha": "c74d3c63b2b2d0463e557ce25dca9d0230f8f00e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c74d3c63b2b2d0463e557ce25dca9d0230f8f00e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cf9c2719652d298006d51bc82a32908ab4e5335", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cf9c2719652d298006d51bc82a32908ab4e5335", "html_url": "https://github.com/rust-lang/rust/commit/8cf9c2719652d298006d51bc82a32908ab4e5335", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cf9c2719652d298006d51bc82a32908ab4e5335/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e493160c0cdbaa71f61af64fd7c439410e8c8b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e493160c0cdbaa71f61af64fd7c439410e8c8b1", "html_url": "https://github.com/rust-lang/rust/commit/0e493160c0cdbaa71f61af64fd7c439410e8c8b1"}], "stats": {"total": 399, "additions": 399, "deletions": 0}, "files": [{"sha": "9eb83234f0cbe92f802314002f4aaa198ccfd721", "filename": "crates/salsa/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8cf9c2719652d298006d51bc82a32908ab4e5335/crates%2Fsalsa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8cf9c2719652d298006d51bc82a32908ab4e5335/crates%2Fsalsa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsalsa%2FCargo.toml?ref=8cf9c2719652d298006d51bc82a32908ab4e5335", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"salsa\"\n+version = \"0.1.0\"\n+authors = [\"Aleksey Kladov <aleksey.kladov@gmail.com>\"]\n+\n+[dependencies]\n+parking_lot = \"0.6.3\"\n+im = \"12.0.0\""}, {"sha": "69c7b35fa1b055d02801b81989c6f372fd3081cf", "filename": "crates/salsa/src/lib.rs", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/8cf9c2719652d298006d51bc82a32908ab4e5335/crates%2Fsalsa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf9c2719652d298006d51bc82a32908ab4e5335/crates%2Fsalsa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsalsa%2Fsrc%2Flib.rs?ref=8cf9c2719652d298006d51bc82a32908ab4e5335", "patch": "@@ -0,0 +1,238 @@\n+extern crate im;\n+extern crate parking_lot;\n+\n+use std::{\n+    sync::Arc,\n+    any::Any,\n+    collections::HashMap,\n+    cell::RefCell,\n+};\n+use parking_lot::Mutex;\n+\n+type GroundQueryFn<T> = fn(&T, &(Any + Send + Sync + 'static)) -> (Box<Any + Send + Sync + 'static>, OutputFingerprint);\n+type QueryFn<T> = fn(&QueryCtx<T>, &(Any + Send + Sync + 'static)) -> (Box<Any + Send + Sync + 'static>, OutputFingerprint);\n+\n+#[derive(Debug)]\n+pub struct Db<T> {\n+    db: Arc<DbState<T>>,\n+    query_config: Arc<QueryConfig<T>>,\n+}\n+\n+pub struct QueryConfig<T> {\n+    ground_fn: HashMap<QueryTypeId, GroundQueryFn<T>>,\n+    query_fn: HashMap<QueryTypeId, QueryFn<T>>,\n+}\n+\n+impl<T> ::std::fmt::Debug for QueryConfig<T> {\n+    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n+        ::std::fmt::Display::fmt(\"QueryConfig { ... }\", f)\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct DbState<T> {\n+    ground_data: T,\n+    gen: Gen,\n+    graph: Mutex<im::HashMap<QueryId, (Gen, Arc<QueryRecord>)>>,\n+}\n+\n+#[derive(Debug)]\n+struct QueryRecord {\n+    params: Arc<Any + Send + Sync + 'static>,\n+    output: Arc<Any + Send + Sync + 'static>,\n+    output_fingerprint: OutputFingerprint,\n+    deps: Vec<(QueryId, OutputFingerprint)>,\n+}\n+\n+impl<T> DbState<T> {\n+    fn record(\n+        &self,\n+        query_id: QueryId,\n+        params: Arc<Any + Send + Sync + 'static>,\n+        output: Arc<Any + Send + Sync + 'static>,\n+        output_fingerprint: OutputFingerprint,\n+        deps: Vec<(QueryId, OutputFingerprint)>,\n+    ) {\n+        let gen = self.gen;\n+        let record = QueryRecord {\n+            params,\n+            output,\n+            output_fingerprint,\n+            deps,\n+        };\n+        self.graph.lock().insert(query_id, (gen, Arc::new(record)));\n+    }\n+}\n+\n+impl<T> QueryConfig<T> {\n+    pub fn new() -> Self {\n+        QueryConfig {\n+            ground_fn: HashMap::new(),\n+            query_fn: HashMap::new(),\n+        }\n+    }\n+    pub fn with_ground_query(\n+        mut self,\n+        query_type: QueryTypeId,\n+        query_fn: GroundQueryFn<T>\n+    ) -> Self {\n+        let prev = self.ground_fn.insert(query_type, query_fn);\n+        assert!(prev.is_none());\n+        self\n+    }\n+    pub fn with_query(\n+        mut self,\n+        query_type: QueryTypeId,\n+        query_fn: QueryFn<T>,\n+    ) -> Self {\n+        let prev = self.query_fn.insert(query_type, query_fn);\n+        assert!(prev.is_none());\n+        self\n+    }\n+}\n+\n+pub struct QueryCtx<T> {\n+    db: Arc<DbState<T>>,\n+    query_config: Arc<QueryConfig<T>>,\n+    stack: RefCell<Vec<Vec<(QueryId, OutputFingerprint)>>>,\n+    executed: RefCell<Vec<QueryTypeId>>,\n+}\n+\n+impl<T> QueryCtx<T> {\n+    fn new(db: &Db<T>) -> QueryCtx<T> {\n+        QueryCtx {\n+            db: Arc::clone(&db.db),\n+            query_config: Arc::clone(&db.query_config),\n+            stack: RefCell::new(vec![Vec::new()]),\n+            executed: RefCell::new(Vec::new()),\n+        }\n+    }\n+    pub fn get(\n+        &self,\n+        query_id: QueryId,\n+        params: Arc<Any + Send + Sync + 'static>,\n+    ) -> Arc<Any + Send + Sync + 'static> {\n+        let (res, output_fingerprint) = self.get_inner(query_id, params);\n+        self.record_dep(query_id, output_fingerprint);\n+        res\n+    }\n+\n+    pub fn get_inner(\n+        &self,\n+        query_id: QueryId,\n+        params: Arc<Any + Send + Sync + 'static>,\n+    ) -> (Arc<Any + Send + Sync + 'static>, OutputFingerprint) {\n+        let (gen, record) = {\n+            let guard = self.db.graph.lock();\n+            match guard.get(&query_id).map(|it| it.clone()){\n+                None => {\n+                    drop(guard);\n+                    return self.force(query_id, params);\n+                },\n+                Some(it) => it,\n+            }\n+        };\n+        if gen == self.db.gen {\n+            return (record.output.clone(), record.output_fingerprint)\n+        }\n+        if self.query_config.ground_fn.contains_key(&query_id.0) {\n+            return self.force(query_id, params);\n+        }\n+        for (dep_query_id, prev_fingerprint) in record.deps.iter().cloned() {\n+            let dep_params: Arc<Any + Send + Sync + 'static> = {\n+                let guard = self.db.graph.lock();\n+                guard[&dep_query_id]\n+                .1\n+                .params\n+                .clone()\n+            };\n+            if prev_fingerprint != self.get_inner(dep_query_id, dep_params).1 {\n+                return self.force(query_id, params)\n+            }\n+        }\n+        let gen = self.db.gen;\n+        {\n+            let mut guard = self.db.graph.lock();\n+            guard[&query_id].0 = gen;\n+        }\n+        (record.output.clone(), record.output_fingerprint)\n+    }\n+    fn force(\n+        &self,\n+        query_id: QueryId,\n+        params: Arc<Any + Send + Sync + 'static>,\n+    ) -> (Arc<Any + Send + Sync + 'static>, OutputFingerprint) {\n+        self.executed.borrow_mut().push(query_id.0);\n+        self.stack.borrow_mut().push(Vec::new());\n+\n+        let (res, output_fingerprint) = if let Some(f) = self.ground_query_fn_by_type(query_id.0) {\n+            f(&self.db.ground_data, &*params)\n+        } else if let Some(f) = self.query_fn_by_type(query_id.0) {\n+            f(self, &*params)\n+        } else {\n+            panic!(\"unknown query type: {:?}\", query_id.0);\n+        };\n+\n+        let res: Arc<Any + Send + Sync + 'static> = res.into();\n+\n+        let deps = self.stack.borrow_mut().pop().unwrap();\n+        self.db.record(query_id, params, res.clone(), output_fingerprint, deps);\n+        (res, output_fingerprint)\n+    }\n+    fn ground_query_fn_by_type(&self, query_type: QueryTypeId) -> Option<GroundQueryFn<T>> {\n+        self.query_config.ground_fn.get(&query_type).map(|&it| it)\n+    }\n+    fn query_fn_by_type(&self, query_type: QueryTypeId) -> Option<QueryFn<T>> {\n+        self.query_config.query_fn.get(&query_type).map(|&it| it)\n+    }\n+    fn record_dep(\n+        &self,\n+        query_id: QueryId,\n+        output_fingerprint: OutputFingerprint,\n+    ) -> () {\n+        let mut stack = self.stack.borrow_mut();\n+        let deps = stack.last_mut().unwrap();\n+        deps.push((query_id, output_fingerprint))\n+    }\n+}\n+\n+impl<T> Db<T> {\n+    pub fn new(query_config: QueryConfig<T>, ground_data: T) -> Db<T> {\n+        Db {\n+            db: Arc::new(DbState { ground_data, gen: Gen(0), graph: Default::default() }),\n+            query_config: Arc::new(query_config),\n+        }\n+    }\n+\n+    pub fn with_ground_data(&self, ground_data: T) -> Db<T> {\n+        let gen = Gen(self.db.gen.0 + 1);\n+        let graph = self.db.graph.lock().clone();\n+        let graph = Mutex::new(graph);\n+        Db {\n+            db: Arc::new(DbState { ground_data, gen, graph }),\n+            query_config: Arc::clone(&self.query_config)\n+        }\n+    }\n+    pub fn get(\n+        &self,\n+        query_id: QueryId,\n+        params: Box<Any + Send + Sync + 'static>,\n+    ) -> (Arc<Any + Send + Sync + 'static>, Vec<QueryTypeId>) {\n+        let ctx = QueryCtx::new(self);\n+        let res = ctx.get(query_id, params.into());\n+        let executed = ::std::mem::replace(&mut *ctx.executed.borrow_mut(), Vec::new());\n+        (res, executed)\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+struct Gen(u64);\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct InputFingerprint(pub u64);\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct OutputFingerprint(pub u64);\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct QueryTypeId(pub u16);\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct QueryId(pub QueryTypeId, pub InputFingerprint);\n+"}, {"sha": "7241eca3850ff8585997eae16bdcbadcbacc65b8", "filename": "crates/salsa/tests/integration.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/8cf9c2719652d298006d51bc82a32908ab4e5335/crates%2Fsalsa%2Ftests%2Fintegration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf9c2719652d298006d51bc82a32908ab4e5335/crates%2Fsalsa%2Ftests%2Fintegration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsalsa%2Ftests%2Fintegration.rs?ref=8cf9c2719652d298006d51bc82a32908ab4e5335", "patch": "@@ -0,0 +1,153 @@\n+extern crate salsa;\n+use std::{\n+    sync::Arc,\n+    collections::hash_map::{HashMap, DefaultHasher},\n+    any::Any,\n+    hash::{Hash, Hasher},\n+};\n+\n+type State = HashMap<u32, String>;\n+const GET_TEXT: salsa::QueryTypeId = salsa::QueryTypeId(1);\n+const GET_FILES: salsa::QueryTypeId = salsa::QueryTypeId(2);\n+const FILE_NEWLINES: salsa::QueryTypeId = salsa::QueryTypeId(3);\n+const TOTAL_NEWLINES: salsa::QueryTypeId = salsa::QueryTypeId(4);\n+\n+fn mk_ground_query<T, R>(\n+    state: &State,\n+    params: &(Any + Send + Sync + 'static),\n+    f: fn(&State, &T) -> R,\n+) -> (Box<Any + Send + Sync + 'static>, salsa::OutputFingerprint)\n+where\n+    T: 'static,\n+    R: Hash + Send + Sync + 'static,\n+{\n+    let params = params.downcast_ref().unwrap();\n+    let result = f(state, params);\n+    let fingerprint = o_print(&result);\n+    (Box::new(result), fingerprint)\n+}\n+\n+fn get<T, R>(db: &salsa::Db<State>, query_type: salsa::QueryTypeId, param: T) -> (Arc<R>, Vec<salsa::QueryTypeId>)\n+where\n+    T: Hash + Send + Sync + 'static,\n+    R: Send + Sync + 'static,\n+{\n+    let i_print = i_print(&param);\n+    let param = Box::new(param);\n+    let (res, trace) = db.get(salsa::QueryId(query_type, i_print), param);\n+    (res.downcast().unwrap(), trace)\n+}\n+\n+struct QueryCtx<'a>(&'a salsa::QueryCtx<State>);\n+\n+impl<'a> QueryCtx<'a> {\n+    fn get_text(&self, id: u32) -> Arc<String> {\n+        let i_print = i_print(&id);\n+        let text = self.0.get(salsa::QueryId(GET_TEXT, i_print), Arc::new(id));\n+        text.downcast().unwrap()\n+    }\n+    fn get_files(&self) -> Arc<Vec<u32>> {\n+        let i_print = i_print(&());\n+        let files = self.0.get(salsa::QueryId(GET_FILES, i_print), Arc::new(()));\n+        let res = files.downcast().unwrap();\n+        res\n+    }\n+    fn get_n_lines(&self, id: u32) -> usize {\n+        let i_print = i_print(&id);\n+        let n_lines = self.0.get(salsa::QueryId(FILE_NEWLINES, i_print), Arc::new(id));\n+        *n_lines.downcast().unwrap()\n+    }\n+}\n+\n+fn mk_query<T, R>(\n+    query_ctx: &salsa::QueryCtx<State>,\n+    params: &(Any + Send + Sync + 'static),\n+    f: fn(QueryCtx, &T) -> R,\n+) -> (Box<Any + Send + Sync + 'static>, salsa::OutputFingerprint)\n+where\n+    T: 'static,\n+    R: Hash + Send + Sync + 'static,\n+{\n+    let params: &T = params.downcast_ref().unwrap();\n+    let query_ctx = QueryCtx(query_ctx);\n+    let result = f(query_ctx, params);\n+    let fingerprint = o_print(&result);\n+    (Box::new(result), fingerprint)\n+}\n+\n+fn mk_queries() -> salsa::QueryConfig<State> {\n+    salsa::QueryConfig::<State>::new()\n+        .with_ground_query(GET_TEXT, |state, id| {\n+            mk_ground_query::<u32, String>(state, id, |state, id| state[id].clone())\n+        })\n+        .with_ground_query(GET_FILES, |state, id| {\n+            mk_ground_query::<(), Vec<u32>>(state, id, |state, &()| state.keys().cloned().collect())\n+        })\n+        .with_query(FILE_NEWLINES, |query_ctx, id| {\n+            mk_query(query_ctx, id, |query_ctx, &id| {\n+                let text = query_ctx.get_text(id);\n+                text.lines().count()\n+            })\n+        })\n+        .with_query(TOTAL_NEWLINES, |query_ctx, id| {\n+            mk_query(query_ctx, id, |query_ctx, &()| {\n+                let mut total = 0;\n+                for &id in query_ctx.get_files().iter() {\n+                    total += query_ctx.get_n_lines(id)\n+                }\n+                total\n+            })\n+        })\n+}\n+\n+#[test]\n+fn test_number_of_lines() {\n+    let mut state = State::new();\n+    let db = salsa::Db::new(mk_queries(), state.clone());\n+    let (newlines, trace) = get::<(), usize>(&db, TOTAL_NEWLINES, ());\n+    assert_eq!(*newlines, 0);\n+    assert_eq!(trace.len(), 2);\n+    let (newlines, trace) = get::<(), usize>(&db, TOTAL_NEWLINES, ());\n+    assert_eq!(*newlines, 0);\n+    assert_eq!(trace.len(), 0);\n+\n+    state.insert(1, \"hello\\nworld\".to_string());\n+    let db = db.with_ground_data(state.clone());\n+    let (newlines, trace) = get::<(), usize>(&db, TOTAL_NEWLINES, ());\n+    assert_eq!(*newlines, 2);\n+    assert_eq!(trace.len(), 4);\n+\n+    state.insert(2, \"spam\\neggs\".to_string());\n+    let db = db.with_ground_data(state.clone());\n+    let (newlines, trace) = get::<(), usize>(&db, TOTAL_NEWLINES, ());\n+    assert_eq!(*newlines, 4);\n+    assert_eq!(trace.len(), 5);\n+\n+    for i in 0..10 {\n+        state.insert(i + 10, \"spam\".to_string());\n+    }\n+    let db = db.with_ground_data(state.clone());\n+    let (newlines, trace) = get::<(), usize>(&db, TOTAL_NEWLINES, ());\n+    assert_eq!(*newlines, 14);\n+    assert_eq!(trace.len(), 24);\n+\n+    state.insert(15, String::new());\n+    let db = db.with_ground_data(state.clone());\n+    let (newlines, trace) = get::<(), usize>(&db, TOTAL_NEWLINES, ());\n+    assert_eq!(*newlines, 13);\n+    assert_eq!(trace.len(), 15);\n+}\n+\n+fn o_print<T: Hash>(x: &T) -> salsa::OutputFingerprint {\n+    let mut hasher = DefaultHasher::new();\n+    x.hash(&mut hasher);\n+    let hash = hasher.finish();\n+    salsa::OutputFingerprint(hash)\n+}\n+\n+fn i_print<T: Hash>(x: &T) -> salsa::InputFingerprint {\n+    let mut hasher = DefaultHasher::new();\n+    x.hash(&mut hasher);\n+    let hash = hasher.finish();\n+    salsa::InputFingerprint(hash)\n+}"}]}