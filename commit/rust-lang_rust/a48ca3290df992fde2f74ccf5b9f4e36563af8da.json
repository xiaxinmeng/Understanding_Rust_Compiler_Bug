{"sha": "a48ca3290df992fde2f74ccf5b9f4e36563af8da", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0OGNhMzI5MGRmOTkyZmRlMmY3NGNjZjViOWY0ZTM2NTYzYWY4ZGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-09T01:49:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-09T01:49:46Z"}, "message": "auto merge of #7262 : nikomatsakis/rust/ref-bindings-in-irrefut-patterns, r=catamorphism\n\nCorrect treatment of irrefutable patterns. The old code was wrong in many, many ways. `ref` bindings didn't work, it sometimes copied when it should have moved, the borrow checker didn't even look at such patterns at all, we weren't consistent about preventing values with destructors from being pulled apart, etc.\r\n\r\nFixes #3224.\r\nFixes #3225.\r\nFixes #3255.\r\nFixes #6225.\r\nFixes #6386.\r\n\r\nr? @catamorphism", "tree": {"sha": "816142177cf53d6185626aee592ef837b5e1d93a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/816142177cf53d6185626aee592ef837b5e1d93a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a48ca3290df992fde2f74ccf5b9f4e36563af8da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a48ca3290df992fde2f74ccf5b9f4e36563af8da", "html_url": "https://github.com/rust-lang/rust/commit/a48ca3290df992fde2f74ccf5b9f4e36563af8da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a48ca3290df992fde2f74ccf5b9f4e36563af8da/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30c8aac677a754e0d4ebc16f261618f15d15a6e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/30c8aac677a754e0d4ebc16f261618f15d15a6e2", "html_url": "https://github.com/rust-lang/rust/commit/30c8aac677a754e0d4ebc16f261618f15d15a6e2"}, {"sha": "0c6d02f391aa668b2ead91e8a4ed545475ac2c90", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c6d02f391aa668b2ead91e8a4ed545475ac2c90", "html_url": "https://github.com/rust-lang/rust/commit/0c6d02f391aa668b2ead91e8a4ed545475ac2c90"}], "stats": {"total": 1838, "additions": 1141, "deletions": 697}, "files": [{"sha": "27c8051afac36c284b49f1f2dde04ad1a91d7a05", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -418,8 +418,8 @@ mod test {\n     fn make_file(path : &Path, contents: &[~str]) {\n         let file = io::file_writer(path, [io::Create, io::Truncate]).get();\n \n-        for contents.iter().advance |&str| {\n-            file.write_str(str);\n+        for contents.iter().advance |str| {\n+            file.write_str(*str);\n             file.write_char('\\n');\n         }\n     }\n@@ -445,7 +445,7 @@ mod test {\n             |i| fmt!(\"tmp/lib-fileinput-test-fileinput-read-byte-%u.tmp\", i)), true);\n \n         // 3 files containing 0\\n, 1\\n, and 2\\n respectively\n-        for filenames.iter().enumerate().advance |(i, &filename)| {\n+        for filenames.iter().enumerate().advance |(i, filename)| {\n             make_file(filename.get_ref(), [fmt!(\"%u\", i)]);\n         }\n \n@@ -475,7 +475,7 @@ mod test {\n             |i| fmt!(\"tmp/lib-fileinput-test-fileinput-read-%u.tmp\", i)), true);\n \n         // 3 files containing 1\\n, 2\\n, and 3\\n respectively\n-        for filenames.iter().enumerate().advance |(i, &filename)| {\n+        for filenames.iter().enumerate().advance |(i, filename)| {\n             make_file(filename.get_ref(), [fmt!(\"%u\", i)]);\n         }\n \n@@ -495,10 +495,11 @@ mod test {\n             3,\n             |i| fmt!(\"tmp/lib-fileinput-test-input-vec-%u.tmp\", i)), true);\n \n-        for filenames.iter().enumerate().advance |(i, &filename)| {\n+        for filenames.iter().enumerate().advance |(i, filename)| {\n             let contents =\n                 vec::from_fn(3, |j| fmt!(\"%u %u\", i, j));\n             make_file(filename.get_ref(), contents);\n+            debug!(\"contents=%?\", contents);\n             all_lines.push_all(contents);\n         }\n \n@@ -515,7 +516,7 @@ mod test {\n             3,\n             |i| fmt!(\"tmp/lib-fileinput-test-input-vec-state-%u.tmp\", i)),true);\n \n-        for filenames.iter().enumerate().advance |(i, &filename)| {\n+        for filenames.iter().enumerate().advance |(i, filename)| {\n             let contents =\n                 vec::from_fn(3, |j| fmt!(\"%u %u\", i, j + 1));\n             make_file(filename.get_ref(), contents);\n@@ -579,10 +580,10 @@ mod test {\n             3,\n             |i| fmt!(\"tmp/lib-fileinput-test-next-file-%u.tmp\", i)),true);\n \n-        for filenames.iter().enumerate().advance |(i, &filename)| {\n+        for filenames.iter().enumerate().advance |(i, filename)| {\n             let contents =\n                 vec::from_fn(3, |j| fmt!(\"%u %u\", i, j + 1));\n-            make_file(&filename.get(), contents);\n+            make_file(filename.get_ref(), contents);\n         }\n \n         let in = FileInput::from_vec(filenames);"}, {"sha": "5867b13f55656c9e74e9b4827490736f126f925d", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -1571,10 +1571,10 @@ mod biguint_tests {\n     fn test_to_str_radix() {\n         let r = to_str_pairs();\n         for r.iter().advance |num_pair| {\n-            let &(n, rs) = num_pair;\n+            let &(ref n, ref rs) = num_pair;\n             for rs.iter().advance |str_pair| {\n-                let &(radix, str) = str_pair;\n-                assert_eq!(n.to_str_radix(radix), str);\n+                let &(ref radix, ref str) = str_pair;\n+                assert_eq!(&n.to_str_radix(*radix), str);\n             }\n         }\n     }\n@@ -1583,10 +1583,10 @@ mod biguint_tests {\n     fn test_from_str_radix() {\n         let r = to_str_pairs();\n         for r.iter().advance |num_pair| {\n-            let &(n, rs) = num_pair;\n+            let &(ref n, ref rs) = num_pair;\n             for rs.iter().advance |str_pair| {\n-                let &(radix, str) = str_pair;\n-                assert_eq!(&n, &FromStrRadix::from_str_radix(str, radix).get());\n+                let &(ref radix, ref str) = str_pair;\n+                assert_eq!(n, &FromStrRadix::from_str_radix(*str, *radix).get());\n             }\n         }\n "}, {"sha": "7cc8bca891077a08925be70420a1cad21c8cad33", "filename": "src/libextra/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibextra%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibextra%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frc.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -73,7 +73,7 @@ impl<T> Drop for Rc<T> {\n             if self.ptr.is_not_null() {\n                 (*self.ptr).count -= 1;\n                 if (*self.ptr).count == 0 {\n-                    ptr::replace_ptr(self.ptr, intrinsics::uninit());\n+                    ptr::read_ptr(self.ptr);\n                     free(self.ptr as *c_void)\n                 }\n             }"}, {"sha": "cd226e2ad3267ce4245638ee3d6c9efd09e99939", "filename": "src/libextra/term.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibextra%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibextra%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterm.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -119,8 +119,8 @@ impl Terminal {\n     pub fn reset(&self) {\n         let mut vars = Variables::new();\n         let s = do self.ti.strings.find_equiv(&(\"op\"))\n-                       .map_consume_default(Err(~\"can't find terminfo capability `op`\")) |&op| {\n-                           expand(op, [], &mut vars)\n+                       .map_consume_default(Err(~\"can't find terminfo capability `op`\")) |op| {\n+                           expand(copy *op, [], &mut vars)\n                        };\n         if s.is_ok() {\n             self.out.write(s.unwrap());"}, {"sha": "f25d192cc0a9fd8d57176751dc77221bcb49122c", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -81,8 +81,8 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n \n     // Copy parameters into a local vector for mutability\n     let mut mparams = [Number(0), ..9];\n-    for mparams.mut_iter().zip(params.iter()).advance |(dst, &src)| {\n-        *dst = src;\n+    for mparams.mut_iter().zip(params.iter()).advance |(dst, src)| {\n+        *dst = copy *src;\n     }\n \n     for cap.iter().transform(|&x| x).advance |c| {"}, {"sha": "f2dea8b9bbaf30ccfc1b8b9f89d9a1327276c682", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -773,15 +773,15 @@ mod test_treemap {\n                                             map: &TreeMap<K, V>) {\n         assert_eq!(ctrl.is_empty(), map.is_empty());\n         for ctrl.iter().advance |x| {\n-            let &(k, v) = x;\n-            assert!(map.find(&k).unwrap() == &v)\n+            let &(ref k, ref v) = x;\n+            assert!(map.find(k).unwrap() == v)\n         }\n         for map.iter().advance |(map_k, map_v)| {\n             let mut found = false;\n             for ctrl.iter().advance |x| {\n-                let &(ctrl_k, ctrl_v) = x;\n-                if *map_k == ctrl_k {\n-                    assert!(*map_v == ctrl_v);\n+                let &(ref ctrl_k, ref ctrl_v) = x;\n+                if *map_k == *ctrl_k {\n+                    assert!(*map_v == *ctrl_v);\n                     found = true;\n                     break;\n                 }"}, {"sha": "e7bec2fbd8d1cc2e60b44762f924fed1a102a8da", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -157,8 +157,8 @@ impl<D:Decoder> Decodable<D> for WorkMap {\n     fn decode(d: &mut D) -> WorkMap {\n         let v : ~[(WorkKey,~str)] = Decodable::decode(d);\n         let mut w = WorkMap::new();\n-        for v.iter().advance |&(k, v)| {\n-            w.insert(copy k, copy v);\n+        for v.iter().advance |pair| {\n+            w.insert(pair.first(), pair.second());\n         }\n         w\n     }"}, {"sha": "f9dc88074d3b15044ec670bd2a9c32c82faa592f", "filename": "src/librustc/back/passes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fback%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fback%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fpasses.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -165,10 +165,10 @@ pub fn create_standard_passes(level: OptLevel) -> ~[~str] {\n }\n \n pub fn populate_pass_manager(sess: Session, pm: &mut PassManager, pass_list:&[~str]) {\n-    for pass_list.iter().advance |&nm| {\n-        match create_pass(nm) {\n+    for pass_list.iter().advance |nm| {\n+        match create_pass(*nm) {\n             Some(p) => pm.add_pass(p),\n-            None    => sess.warn(fmt!(\"Unknown pass %s\", nm))\n+            None    => sess.warn(fmt!(\"Unknown pass %s\", *nm))\n         }\n     }\n }"}, {"sha": "e8ef95b811e87ffe35e663f08c1ea4fd82a782f7", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -314,7 +314,6 @@ pub fn compile_rest(sess: Session,\n             method_map: method_map,\n             vtable_map: vtable_map,\n             write_guard_map: write_guard_map,\n-            moves_map: moves_map,\n             capture_map: capture_map\n         };\n "}, {"sha": "9aefb8fdb55792fd47a8c6618138d30cd7f31240", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -127,7 +127,9 @@ fn find_library_crate_aux(\n             cx.diag.span_err(\n                     cx.span, fmt!(\"multiple matching crates for `%s`\", crate_name));\n                 cx.diag.handler().note(\"candidates:\");\n-                for matches.iter().advance |&(ident, data)| {\n+                for matches.iter().advance |pair| {\n+                    let ident = pair.first();\n+                    let data = pair.second();\n                     cx.diag.handler().note(fmt!(\"path: %s\", ident));\n                     let attrs = decoder::get_crate_attributes(data);\n                     note_linkage_attrs(cx.intr, cx.diag, attrs);"}, {"sha": "7412eba11563136d39a7ed99770287c6a81fc13a", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -53,7 +53,6 @@ pub struct Maps {\n     method_map: middle::typeck::method_map,\n     vtable_map: middle::typeck::vtable_map,\n     write_guard_map: middle::borrowck::write_guard_map,\n-    moves_map: middle::moves::MovesMap,\n     capture_map: middle::moves::CaptureMap,\n }\n \n@@ -952,12 +951,6 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         }\n     }\n \n-    if maps.moves_map.contains(&id) {\n-        do ebml_w.tag(c::tag_table_moves_map) |ebml_w| {\n-            ebml_w.id(id);\n-        }\n-    }\n-\n     {\n         let r = maps.capture_map.find(&id);\n         for r.iter().advance |&cap_vars| {\n@@ -1121,9 +1114,7 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                 xcx.dcx.tcx.sess.bug(\n                     fmt!(\"unknown tag found in side tables: %x\", tag));\n             }\n-            Some(value) => if value == c::tag_table_moves_map {\n-                dcx.maps.moves_map.insert(id);\n-            } else {\n+            Some(value) => {\n                 let val_doc = entry_doc.get(c::tag_table_val as uint);\n                 let mut val_dsr = reader::Decoder(val_doc);\n                 let val_dsr = &mut val_dsr;"}, {"sha": "a455bdc436cadb1c2be881b410dbd8aa1c1707ef", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 40, "deletions": 51, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -65,7 +65,7 @@ pub fn check_loans(bccx: @BorrowckCtxt,\n \n enum MoveError {\n     MoveOk,\n-    MoveWhileBorrowed(/*move*/@LoanPath, /*loan*/@LoanPath, /*loan*/span)\n+    MoveWhileBorrowed(/*loan*/@LoanPath, /*loan*/span)\n }\n \n impl<'self> CheckLoanCtxt<'self> {\n@@ -348,7 +348,7 @@ impl<'self> CheckLoanCtxt<'self> {\n                         cmt = b;\n                     }\n \n-                    mc::cat_rvalue |\n+                    mc::cat_rvalue(*) |\n                     mc::cat_static_item |\n                     mc::cat_implicit_self |\n                     mc::cat_copied_upvar(*) |\n@@ -547,45 +547,50 @@ impl<'self> CheckLoanCtxt<'self> {\n                  self.bccx.loan_path_to_str(loan_path)));\n     }\n \n-    pub fn check_move_out_from_expr(&self, ex: @ast::expr) {\n-        match ex.node {\n-            ast::expr_paren(*) => {\n-                /* In the case of an expr_paren(), the expression inside\n-                 * the parens will also be marked as being moved.  Ignore\n-                 * the parents then so as not to report duplicate errors. */\n+    fn check_move_out_from_expr(&self, expr: @ast::expr) {\n+        match expr.node {\n+            ast::expr_fn_block(*) => {\n+                // moves due to capture clauses are checked\n+                // in `check_loans_in_fn`, so that we can\n+                // give a better error message\n             }\n             _ => {\n-                let cmt = self.bccx.cat_expr(ex);\n-                match self.analyze_move_out_from_cmt(cmt) {\n-                    MoveOk => {}\n-                    MoveWhileBorrowed(move_path, loan_path, loan_span) => {\n-                        self.bccx.span_err(\n-                            cmt.span,\n-                            fmt!(\"cannot move out of `%s` \\\n-                                  because it is borrowed\",\n-                                 self.bccx.loan_path_to_str(move_path)));\n-                        self.bccx.span_note(\n-                            loan_span,\n-                            fmt!(\"borrow of `%s` occurs here\",\n-                                 self.bccx.loan_path_to_str(loan_path)));\n-                    }\n+                self.check_move_out_from_id(expr.id, expr.span)\n+            }\n+        }\n+    }\n+\n+    fn check_move_out_from_id(&self, id: ast::node_id, span: span) {\n+        for self.move_data.each_path_moved_by(id) |_, move_path| {\n+            match self.analyze_move_out_from(id, move_path) {\n+                MoveOk => {}\n+                MoveWhileBorrowed(loan_path, loan_span) => {\n+                    self.bccx.span_err(\n+                        span,\n+                        fmt!(\"cannot move out of `%s` \\\n+                              because it is borrowed\",\n+                             self.bccx.loan_path_to_str(move_path)));\n+                    self.bccx.span_note(\n+                        loan_span,\n+                        fmt!(\"borrow of `%s` occurs here\",\n+                             self.bccx.loan_path_to_str(loan_path)));\n                 }\n             }\n         }\n     }\n \n-    pub fn analyze_move_out_from_cmt(&self, cmt: mc::cmt) -> MoveError {\n-        debug!(\"analyze_move_out_from_cmt(cmt=%s)\", cmt.repr(self.tcx()));\n+    pub fn analyze_move_out_from(&self,\n+                                 expr_id: ast::node_id,\n+                                 move_path: @LoanPath) -> MoveError {\n+        debug!(\"analyze_move_out_from(expr_id=%?, move_path=%s)\",\n+               expr_id, move_path.repr(self.tcx()));\n \n         // FIXME(#4384) inadequare if/when we permit `move a.b`\n \n         // check for a conflicting loan:\n-        let r = opt_loan_path(cmt);\n-        for r.iter().advance |&lp| {\n-            for self.each_in_scope_restriction(cmt.id, lp) |loan, _| {\n-                // Any restriction prevents moves.\n-                return MoveWhileBorrowed(lp, loan.loan_path, loan.span);\n-            }\n+        for self.each_in_scope_restriction(expr_id, move_path) |loan, _| {\n+            // Any restriction prevents moves.\n+            return MoveWhileBorrowed(loan.loan_path, loan.span);\n         }\n \n         MoveOk\n@@ -652,13 +657,11 @@ fn check_loans_in_fn<'a>(fk: &visit::fn_kind,\n                                  closure_id: ast::node_id,\n                                  cap_var: &moves::CaptureVar) {\n             let var_id = ast_util::def_id_of_def(cap_var.def).node;\n-            let ty = ty::node_id_to_type(this.tcx(), var_id);\n-            let cmt = this.bccx.cat_def(closure_id, cap_var.span,\n-                                        ty, cap_var.def);\n-            let move_err = this.analyze_move_out_from_cmt(cmt);\n+            let move_path = @LpVar(var_id);\n+            let move_err = this.analyze_move_out_from(closure_id, move_path);\n             match move_err {\n                 MoveOk => {}\n-                MoveWhileBorrowed(move_path, loan_path, loan_span) => {\n+                MoveWhileBorrowed(loan_path, loan_span) => {\n                     this.bccx.span_err(\n                         cap_var.span,\n                         fmt!(\"cannot move `%s` into closure \\\n@@ -689,10 +692,7 @@ fn check_loans_in_expr<'a>(expr: @ast::expr,\n            expr.repr(this.tcx()));\n \n     this.check_for_conflicting_loans(expr.id);\n-\n-    if this.bccx.moves_map.contains(&expr.id) {\n-        this.check_move_out_from_expr(expr);\n-    }\n+    this.check_move_out_from_expr(expr);\n \n     match expr.node {\n       ast::expr_self |\n@@ -742,18 +742,7 @@ fn check_loans_in_pat<'a>(pat: @ast::pat,\n                                        visit::vt<@mut CheckLoanCtxt<'a>>))\n {\n     this.check_for_conflicting_loans(pat.id);\n-\n-    // Note: moves out of pattern bindings are not checked by\n-    // the borrow checker, at least not directly.  What happens\n-    // is that if there are any moved bindings, the discriminant\n-    // will be considered a move, and this will be checked as\n-    // normal.  Then, in `middle::check_match`, we will check\n-    // that no move occurs in a binding that is underneath an\n-    // `@` or `&`.  Together these give the same guarantees as\n-    // `check_move_out_from_expr()` without requiring us to\n-    // rewalk the patterns and rebuild the pattern\n-    // categorizations.\n-\n+    this.check_move_out_from_id(pat.id, pat.span);\n     visit::visit_pat(pat, (this, vt));\n }\n "}, {"sha": "5d91916d0044a07ac1f90ecd4e6d98ea8676e7bc", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -67,7 +67,7 @@ impl GuaranteeLifetimeContext {\n         //! Main routine. Walks down `cmt` until we find the \"guarantor\".\n \n         match cmt.cat {\n-            mc::cat_rvalue |\n+            mc::cat_rvalue(*) |\n             mc::cat_implicit_self |\n             mc::cat_copied_upvar(*) |                  // L-Local\n             mc::cat_local(*) |                         // L-Local\n@@ -179,7 +179,7 @@ impl GuaranteeLifetimeContext {\n         //! lvalue.\n \n         cmt.mutbl.is_immutable() || match cmt.guarantor().cat {\n-            mc::cat_rvalue => true,\n+            mc::cat_rvalue(*) => true,\n             _ => false\n         }\n     }\n@@ -299,7 +299,7 @@ impl GuaranteeLifetimeContext {\n             mc::cat_arg(id) => {\n                 self.bccx.moved_variables_set.contains(&id)\n             }\n-            mc::cat_rvalue |\n+            mc::cat_rvalue(*) |\n             mc::cat_static_item |\n             mc::cat_implicit_self |\n             mc::cat_copied_upvar(*) |\n@@ -325,8 +325,8 @@ impl GuaranteeLifetimeContext {\n         // See the SCOPE(LV) function in doc.rs\n \n         match cmt.cat {\n-            mc::cat_rvalue => {\n-                ty::re_scope(self.bccx.tcx.region_maps.cleanup_scope(cmt.id))\n+            mc::cat_rvalue(cleanup_scope_id) => {\n+                ty::re_scope(cleanup_scope_id)\n             }\n             mc::cat_implicit_self |\n             mc::cat_copied_upvar(_) => {"}, {"sha": "23451e0f36ea05de19793f8c8a18771c861f123f", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 95, "deletions": 34, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -73,6 +73,7 @@ struct GatherLoanCtxt {\n }\n \n pub fn gather_loans(bccx: @BorrowckCtxt,\n+                    decl: &ast::fn_decl,\n                     body: &ast::blk)\n                     -> (id_range, @mut ~[Loan], @mut move_data::MoveData) {\n     let glcx = @mut GatherLoanCtxt {\n@@ -83,6 +84,7 @@ pub fn gather_loans(bccx: @BorrowckCtxt,\n         repeating_ids: ~[body.node.id],\n         move_data: @mut MoveData::new()\n     };\n+    glcx.gather_fn_arg_patterns(decl, body);\n     let v = visit::mk_vt(@visit::Visitor {visit_expr: gather_loans_in_expr,\n                                           visit_block: gather_loans_in_block,\n                                           visit_fn: gather_loans_in_fn,\n@@ -124,6 +126,7 @@ fn gather_loans_in_fn(fk: &visit::fn_kind,\n             this.push_repeating_id(body.node.id);\n             visit::visit_fn(fk, decl, body, sp, id, (this, v));\n             this.pop_repeating_id(body.node.id);\n+            this.gather_fn_arg_patterns(decl, body);\n         }\n     }\n }\n@@ -138,26 +141,33 @@ fn gather_loans_in_block(blk: &ast::blk,\n fn gather_loans_in_local(local: @ast::local,\n                          (this, vt): (@mut GatherLoanCtxt,\n                                       visit::vt<@mut GatherLoanCtxt>)) {\n-    if local.node.init.is_none() {\n-        // Variable declarations without initializers are considered \"moves\":\n-        let tcx = this.bccx.tcx;\n-        do pat_util::pat_bindings(tcx.def_map, local.node.pat) |_, id, span, _| {\n-            gather_moves::gather_decl(this.bccx,\n-                                      this.move_data,\n-                                      id,\n-                                      span,\n-                                      id);\n+    match local.node.init {\n+        None => {\n+            // Variable declarations without initializers are considered \"moves\":\n+            let tcx = this.bccx.tcx;\n+            do pat_util::pat_bindings(tcx.def_map, local.node.pat)\n+                |_, id, span, _| {\n+                gather_moves::gather_decl(this.bccx,\n+                                          this.move_data,\n+                                          id,\n+                                          span,\n+                                          id);\n+            }\n         }\n-    } else {\n-        // Variable declarations with initializers are considered \"assigns\":\n-        let tcx = this.bccx.tcx;\n-        do pat_util::pat_bindings(tcx.def_map, local.node.pat) |_, id, span, _| {\n-            gather_moves::gather_assignment(this.bccx,\n-                                            this.move_data,\n-                                            id,\n-                                            span,\n-                                            @LpVar(id),\n-                                            id);\n+        Some(init) => {\n+            // Variable declarations with initializers are considered \"assigns\":\n+            let tcx = this.bccx.tcx;\n+            do pat_util::pat_bindings(tcx.def_map, local.node.pat)\n+                |_, id, span, _| {\n+                gather_moves::gather_assignment(this.bccx,\n+                                                this.move_data,\n+                                                id,\n+                                                span,\n+                                                @LpVar(id),\n+                                                id);\n+            }\n+            let init_cmt = this.bccx.cat_expr(init);\n+            this.gather_pat(init_cmt, local.node.pat, None);\n         }\n     }\n \n@@ -230,7 +240,7 @@ fn gather_loans_in_expr(ex: @ast::expr,\n         let cmt = this.bccx.cat_expr(ex_v);\n         for arms.iter().advance |arm| {\n             for arm.pats.iter().advance |pat| {\n-                this.gather_pat(cmt, *pat, arm.body.node.id, ex.id);\n+                this.gather_pat(cmt, *pat, Some((arm.body.node.id, ex.id)));\n             }\n         }\n         visit::visit_expr(ex, (this, vt));\n@@ -596,11 +606,40 @@ impl GatherLoanCtxt {\n         }\n     }\n \n-    pub fn gather_pat(&mut self,\n-                      discr_cmt: mc::cmt,\n-                      root_pat: @ast::pat,\n-                      arm_body_id: ast::node_id,\n-                      match_id: ast::node_id) {\n+    fn gather_fn_arg_patterns(&mut self,\n+                              decl: &ast::fn_decl,\n+                              body: &ast::blk) {\n+        /*!\n+         * Walks the patterns for fn arguments, checking that they\n+         * do not attempt illegal moves or create refs that outlive\n+         * the arguments themselves. Just a shallow wrapper around\n+         * `gather_pat()`.\n+         */\n+\n+        let mc_ctxt = self.bccx.mc_ctxt();\n+        for decl.inputs.iter().advance |arg| {\n+            let arg_ty = ty::node_id_to_type(self.tcx(), arg.pat.id);\n+\n+            let arg_cmt = mc_ctxt.cat_rvalue(\n+                arg.id,\n+                arg.pat.span,\n+                body.node.id, // Arguments live only as long as the fn body.\n+                arg_ty);\n+\n+            self.gather_pat(arg_cmt, arg.pat, None);\n+        }\n+    }\n+\n+    fn gather_pat(&mut self,\n+                  discr_cmt: mc::cmt,\n+                  root_pat: @ast::pat,\n+                  arm_match_ids: Option<(ast::node_id, ast::node_id)>) {\n+        /*!\n+         * Walks patterns, examining the bindings to determine if they\n+         * cause borrows (`ref` bindings, vector patterns) or\n+         * moves (non-`ref` bindings with linear type).\n+         */\n+\n         do self.bccx.cat_pattern(discr_cmt, root_pat) |cmt, pat| {\n             match pat.node {\n               ast::pat_ident(bm, _, _) if self.pat_is_binding(pat) => {\n@@ -621,15 +660,19 @@ impl GatherLoanCtxt {\n                     // with a cat_discr() node.  There is a detailed\n                     // discussion of the function of this node in\n                     // `lifetime.rs`:\n-                    let arm_scope = ty::re_scope(arm_body_id);\n-                    if self.bccx.is_subregion_of(scope_r, arm_scope) {\n-                        let cmt_discr = self.bccx.cat_discr(cmt, match_id);\n-                        self.guarantee_valid(pat.id, pat.span,\n-                                             cmt_discr, mutbl, scope_r);\n-                    } else {\n-                        self.guarantee_valid(pat.id, pat.span,\n-                                             cmt, mutbl, scope_r);\n-                    }\n+                    let cmt_discr = match arm_match_ids {\n+                        None => cmt,\n+                        Some((arm_id, match_id)) => {\n+                            let arm_scope = ty::re_scope(arm_id);\n+                            if self.bccx.is_subregion_of(scope_r, arm_scope) {\n+                                self.bccx.cat_discr(cmt, match_id)\n+                            } else {\n+                                cmt\n+                            }\n+                        }\n+                    };\n+                    self.guarantee_valid(pat.id, pat.span,\n+                                         cmt_discr, mutbl, scope_r);\n                   }\n                   ast::bind_infer => {\n                       // No borrows here, but there may be moves\n@@ -652,6 +695,24 @@ impl GatherLoanCtxt {\n                       self.vec_slice_info(slice_pat, slice_ty);\n                   let mcx = self.bccx.mc_ctxt();\n                   let cmt_index = mcx.cat_index(slice_pat, cmt, 0);\n+\n+                  // Note: We declare here that the borrow occurs upon\n+                  // entering the `[...]` pattern. This implies that\n+                  // something like `[a, ..b]` where `a` is a move is\n+                  // illegal, because the borrow is already in effect.\n+                  // In fact such a move would be safe-ish, but it\n+                  // effectively *requires* that we use the nulling\n+                  // out semantics to indicate when a value has been\n+                  // moved, which we are trying to move away from.\n+                  // Otherwise, how can we indicate that the first\n+                  // element in the vector has been moved?\n+                  // Eventually, we could perhaps modify this rule to\n+                  // permit `[..a, b]` where `b` is a move, because in\n+                  // that case we can adjust the length of the\n+                  // original vec accordingly, but we'd have to make\n+                  // trans do the right thing, and it would only work\n+                  // for `~` vectors. It seems simpler to just require\n+                  // that people call `vec.pop()` or `vec.unshift()`.\n                   self.guarantee_valid(pat.id, pat.span,\n                                        cmt_index, slice_mutbl, slice_r);\n               }"}, {"sha": "e568da5eedfae98a65ffa90c25c8e09745c1b94b", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -64,7 +64,7 @@ impl RestrictionsContext {\n         }\n \n         match cmt.cat {\n-            mc::cat_rvalue => {\n+            mc::cat_rvalue(*) => {\n                 // Effectively, rvalues are stored into a\n                 // non-aliasable temporary on the stack. Since they\n                 // are inherently non-aliasable, they can only be"}, {"sha": "47d35d73df09bbdd4a191cabf2e66e1021f3b7e6", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -124,7 +124,7 @@ fn borrowck_fn(fk: &visit::fn_kind,\n \n             // Check the body of fn items.\n             let (id_range, all_loans, move_data) =\n-                gather_loans::gather_loans(this, body);\n+                gather_loans::gather_loans(this, decl, body);\n             let mut loan_dfcx =\n                 DataFlowContext::new(this.tcx,\n                                      this.method_map,\n@@ -264,7 +264,7 @@ pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n     //! traverses the CMT.\n \n     match cmt.cat {\n-        mc::cat_rvalue |\n+        mc::cat_rvalue(*) |\n         mc::cat_static_item |\n         mc::cat_copied_upvar(_) |\n         mc::cat_implicit_self => {\n@@ -485,7 +485,7 @@ impl BorrowckCtxt {\n \n     pub fn mc_ctxt(&self) -> mc::mem_categorization_ctxt {\n         mc::mem_categorization_ctxt {tcx: self.tcx,\n-                                 method_map: self.method_map}\n+                                     method_map: self.method_map}\n     }\n \n     pub fn cat_pattern(&self,"}, {"sha": "7ec1ff3c628e4ad3ca018485b572fbb733aadde1", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -474,6 +474,24 @@ impl FlowedMoveData {\n         }\n     }\n \n+    pub fn each_path_moved_by(&self,\n+                              id: ast::node_id,\n+                              f: &fn(&Move, @LoanPath) -> bool)\n+                              -> bool {\n+        /*!\n+         * Iterates through each path moved by `id`\n+         */\n+\n+        for self.dfcx_moves.each_gen_bit_frozen(id) |index| {\n+            let move = &self.move_data.moves[index];\n+            let moved_path = move.path;\n+            if !f(move, self.move_data.path(moved_path).loan_path) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n     pub fn each_move_of(&self,\n                         id: ast::node_id,\n                         loan_path: @LoanPath,"}, {"sha": "02f7294ffcd3b604cce5d438deb26a42aa3ac28f", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -49,23 +49,13 @@ pub fn check_crate(tcx: ty::ctxt,\n     tcx.sess.abort_if_errors();\n }\n \n-pub fn expr_is_non_moving_lvalue(cx: &MatchCheckCtxt, expr: &expr) -> bool {\n-    if !ty::expr_is_lval(cx.tcx, cx.method_map, expr) {\n-        return false;\n-    }\n-\n-    !cx.moves_map.contains(&expr.id)\n-}\n-\n pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, (s, v): ((), visit::vt<()>)) {\n     visit::visit_expr(ex, (s, v));\n     match ex.node {\n       expr_match(scrut, ref arms) => {\n         // First, check legality of move bindings.\n-        let is_non_moving_lvalue = expr_is_non_moving_lvalue(cx, ex);\n         for arms.iter().advance |arm| {\n             check_legality_of_move_bindings(cx,\n-                                            is_non_moving_lvalue,\n                                             arm.guard.is_some(),\n                                             arm.pats);\n         }\n@@ -758,11 +748,7 @@ pub fn check_local(cx: &MatchCheckCtxt,\n     }\n \n     // Check legality of move bindings.\n-    let is_lvalue = match loc.node.init {\n-        Some(init) => expr_is_non_moving_lvalue(cx, init),\n-        None => true\n-    };\n-    check_legality_of_move_bindings(cx, is_lvalue, false, [ loc.node.pat ]);\n+    check_legality_of_move_bindings(cx, false, [ loc.node.pat ]);\n }\n \n pub fn check_fn(cx: &MatchCheckCtxt,\n@@ -821,7 +807,6 @@ pub fn is_refutable(cx: &MatchCheckCtxt, pat: &pat) -> bool {\n // Legality of move bindings checking\n \n pub fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n-                                       is_lvalue: bool,\n                                        has_guard: bool,\n                                        pats: &[@pat]) {\n     let tcx = cx.tcx;\n@@ -861,11 +846,6 @@ pub fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n             tcx.sess.span_note(\n                 by_ref_span.get(),\n                 \"by-ref binding occurs here\");\n-        } else if is_lvalue {\n-            tcx.sess.span_err(\n-                p.span,\n-                \"cannot bind by-move when \\\n-                 matching an lvalue\");\n         }\n     };\n "}, {"sha": "af39dea6d79e1f66122d651dd7228bcd5742d088", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -187,7 +187,6 @@ pub fn lookup_const_by_id(tcx: ty::ctxt,\n             method_map: @mut HashMap::new(),\n             vtable_map: @mut HashMap::new(),\n             write_guard_map: @mut HashSet::new(),\n-            moves_map: @mut HashSet::new(),\n             capture_map: @mut HashMap::new()\n         };\n         match csearch::maybe_get_item_ast(tcx, def_id,"}, {"sha": "ec375eaba0e86b93c81a796a973b0284abaf0a99", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -422,8 +422,8 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                  loop_scopes: &mut ~[LoopScope]) {\n         match decl.node {\n             ast::decl_local(local) => {\n-                self.walk_pat(local.node.pat, in_out, loop_scopes);\n                 self.walk_opt_expr(local.node.init, in_out, loop_scopes);\n+                self.walk_pat(local.node.pat, in_out, loop_scopes);\n             }\n \n             ast::decl_item(_) => {}"}, {"sha": "ac7805146e4864c04524afee30113f5dcfc74f99", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -60,7 +60,7 @@ use syntax::print::pprust;\n \n #[deriving(Eq)]\n pub enum categorization {\n-    cat_rvalue,                        // result of eval'ing some misc expr\n+    cat_rvalue(ast::node_id),          // temporary val, argument is its scope\n     cat_static_item,\n     cat_implicit_self,\n     cat_copied_upvar(CopiedUpvar),     // upvar copied into @fn or ~fn env\n@@ -350,7 +350,7 @@ impl mem_categorization_ctxt {\n                 // Convert a bare fn to a closure by adding NULL env.\n                 // Result is an rvalue.\n                 let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n-                self.cat_rvalue(expr, expr_ty)\n+                self.cat_rvalue_node(expr, expr_ty)\n             }\n \n             Some(\n@@ -360,7 +360,7 @@ impl mem_categorization_ctxt {\n                 // Equivalent to &*expr or something similar.\n                 // Result is an rvalue.\n                 let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n-                self.cat_rvalue(expr, expr_ty)\n+                self.cat_rvalue_node(expr, expr_ty)\n             }\n \n             Some(\n@@ -390,7 +390,7 @@ impl mem_categorization_ctxt {\n         match expr.node {\n           ast::expr_unary(_, ast::deref, e_base) => {\n             if self.method_map.contains_key(&expr.id) {\n-                return self.cat_rvalue(expr, expr_ty);\n+                return self.cat_rvalue_node(expr, expr_ty);\n             }\n \n             let base_cmt = self.cat_expr(e_base);\n@@ -408,7 +408,7 @@ impl mem_categorization_ctxt {\n \n           ast::expr_index(_, base, _) => {\n             if self.method_map.contains_key(&expr.id) {\n-                return self.cat_rvalue(expr, expr_ty);\n+                return self.cat_rvalue_node(expr, expr_ty);\n             }\n \n             let base_cmt = self.cat_expr(base);\n@@ -433,7 +433,7 @@ impl mem_categorization_ctxt {\n           ast::expr_match(*) | ast::expr_lit(*) | ast::expr_break(*) |\n           ast::expr_mac(*) | ast::expr_again(*) | ast::expr_struct(*) |\n           ast::expr_repeat(*) | ast::expr_inline_asm(*) => {\n-            return self.cat_rvalue(expr, expr_ty);\n+            return self.cat_rvalue_node(expr, expr_ty);\n           }\n         }\n     }\n@@ -577,11 +577,24 @@ impl mem_categorization_ctxt {\n         }\n     }\n \n-    pub fn cat_rvalue<N:ast_node>(&self, elt: N, expr_ty: ty::t) -> cmt {\n+    pub fn cat_rvalue_node<N:ast_node>(&self,\n+                                       node: N,\n+                                       expr_ty: ty::t) -> cmt {\n+        self.cat_rvalue(node.id(),\n+                        node.span(),\n+                        self.tcx.region_maps.cleanup_scope(node.id()),\n+                        expr_ty)\n+    }\n+\n+    pub fn cat_rvalue(&self,\n+                      cmt_id: ast::node_id,\n+                      span: span,\n+                      cleanup_scope_id: ast::node_id,\n+                      expr_ty: ty::t) -> cmt {\n         @cmt_ {\n-            id:elt.id(),\n-            span:elt.span(),\n-            cat:cat_rvalue,\n+            id:cmt_id,\n+            span:span,\n+            cat:cat_rvalue(cleanup_scope_id),\n             mutbl:McDeclared,\n             ty:expr_ty\n         }\n@@ -970,7 +983,7 @@ impl mem_categorization_ctxt {\n               }\n               for slice.iter().advance |&slice_pat| {\n                   let slice_ty = self.pat_ty(slice_pat);\n-                  let slice_cmt = self.cat_rvalue(pat, slice_ty);\n+                  let slice_cmt = self.cat_rvalue_node(pat, slice_ty);\n                   self.cat_pattern(slice_cmt, slice_pat, |x,y| op(x,y));\n               }\n               for after.iter().advance |&after_pat| {\n@@ -1003,7 +1016,7 @@ impl mem_categorization_ctxt {\n           cat_copied_upvar(_) => {\n               ~\"captured outer variable in a heap closure\"\n           }\n-          cat_rvalue => {\n+          cat_rvalue(*) => {\n               ~\"non-lvalue\"\n           }\n           cat_local(_) => {\n@@ -1100,7 +1113,7 @@ impl cmt_ {\n         //! determines how long the value in `self` remains live.\n \n         match self.cat {\n-            cat_rvalue |\n+            cat_rvalue(*) |\n             cat_static_item |\n             cat_implicit_self |\n             cat_copied_upvar(*) |\n@@ -1187,11 +1200,13 @@ impl Repr for categorization {\n         match *self {\n             cat_static_item |\n             cat_implicit_self |\n-            cat_rvalue |\n+            cat_rvalue(*) |\n             cat_copied_upvar(*) |\n             cat_local(*) |\n             cat_self(*) |\n-            cat_arg(*) => fmt!(\"%?\", *self),\n+            cat_arg(*) => {\n+                fmt!(\"%?\", *self)\n+            }\n             cat_deref(cmt, derefs, ptr) => {\n                 fmt!(\"%s->(%s, %u)\", cmt.cat.repr(tcx),\n                      ptr_sigil(ptr), derefs)\n@@ -1205,7 +1220,9 @@ impl Repr for categorization {\n                 fmt!(\"%s->(enum)\", cmt.cat.repr(tcx))\n             }\n             cat_stack_upvar(cmt) |\n-            cat_discr(cmt, _) => cmt.cat.repr(tcx)\n+            cat_discr(cmt, _) => {\n+                cmt.cat.repr(tcx)\n+            }\n         }\n     }\n }"}, {"sha": "07bdee07c0feb270ee9abef13f4c156cd19f6a32", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -193,7 +193,9 @@ pub fn compute_moves(tcx: ty::ctxt,\n                      crate: &crate) -> MoveMaps\n {\n     let visitor = visit::mk_vt(@visit::Visitor {\n+        visit_fn: compute_modes_for_fn,\n         visit_expr: compute_modes_for_expr,\n+        visit_local: compute_modes_for_local,\n         .. *visit::default_visitor()\n     });\n     let visit_cx = VisitContext {\n@@ -220,9 +222,31 @@ pub fn moved_variable_node_id_from_def(def: def) -> Option<node_id> {\n     }\n }\n \n-// ______________________________________________________________________\n+///////////////////////////////////////////////////////////////////////////\n // Expressions\n \n+fn compute_modes_for_local<'a>(local: @local,\n+                               (cx, v): (VisitContext,\n+                                         vt<VisitContext>)) {\n+    cx.use_pat(local.node.pat);\n+    for local.node.init.iter().advance |&init| {\n+        cx.use_expr(init, Read, v);\n+    }\n+}\n+\n+fn compute_modes_for_fn(fk: &visit::fn_kind,\n+                        decl: &fn_decl,\n+                        body: &blk,\n+                        span: span,\n+                        id: node_id,\n+                        (cx, v): (VisitContext,\n+                                  vt<VisitContext>)) {\n+    for decl.inputs.iter().advance |a| {\n+        cx.use_pat(a.pat);\n+    }\n+    visit::visit_fn(fk, decl, body, span, id, (cx, v));\n+}\n+\n fn compute_modes_for_expr(expr: @expr,\n                           (cx, v): (VisitContext,\n                                     vt<VisitContext>))\n@@ -522,7 +546,10 @@ impl VisitContext {\n                 self.use_expr(base, comp_mode, visitor);\n             }\n \n-            expr_fn_block(_, ref body) => {\n+            expr_fn_block(ref decl, ref body) => {\n+                for decl.inputs.iter().advance |a| {\n+                    self.use_pat(a.pat);\n+                }\n                 let cap_vars = self.compute_captures(expr.id);\n                 self.move_maps.capture_map.insert(expr.id, cap_vars);\n                 self.consume_block(body, visitor);\n@@ -580,13 +607,15 @@ impl VisitContext {\n          * into itself or not based on its type and annotation.\n          */\n \n-        do pat_bindings(self.tcx.def_map, pat) |bm, id, _span, _path| {\n+        do pat_bindings(self.tcx.def_map, pat) |bm, id, _span, path| {\n             let binding_moves = match bm {\n                 bind_by_ref(_) => false,\n                 bind_infer => {\n                     let pat_ty = ty::node_id_to_type(self.tcx, id);\n-                    debug!(\"pattern %? type is %s\",\n-                           id, pat_ty.repr(self.tcx));\n+                    debug!(\"pattern %? %s type is %s\",\n+                           id,\n+                           ast_util::path_to_ident(path).repr(self.tcx),\n+                           pat_ty.repr(self.tcx));\n                     ty::type_moves_by_default(self.tcx, pat_ty)\n                 }\n             };"}, {"sha": "d5d0cde1ee0a083b720829ede4eb194251eba227", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 233, "deletions": 96, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -268,7 +268,7 @@ pub fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n         }\n         lit(UnitLikeStructLit(pat_id)) => {\n             let struct_ty = ty::node_id_to_type(bcx.tcx(), pat_id);\n-            let datumblock = datum::scratch_datum(bcx, struct_ty, true);\n+            let datumblock = datum::scratch_datum(bcx, struct_ty, \"\", true);\n             return single_result(datumblock.to_result(bcx));\n         }\n         lit(ConstLit(lit_id)) => {\n@@ -316,7 +316,7 @@ pub fn variant_opt(bcx: block, pat_id: ast::node_id)\n }\n \n pub enum TransBindingMode {\n-    TrByValue(/*ismove:*/ bool, /*llbinding:*/ ValueRef),\n+    TrByValue(/*llbinding:*/ ValueRef),\n     TrByRef,\n }\n \n@@ -927,7 +927,7 @@ pub fn extract_vec_elems(bcx: block,\n             ty::mt {ty: vt.unit_ty, mutbl: ast::m_imm},\n             ty::vstore_slice(ty::re_static)\n         );\n-        let scratch = scratch_datum(bcx, slice_ty, false);\n+        let scratch = scratch_datum(bcx, slice_ty, \"\", false);\n         Store(bcx, slice_begin,\n             GEPi(bcx, scratch.val, [0u, abi::slice_elt_base])\n         );\n@@ -1095,9 +1095,9 @@ pub fn compare_values(cx: block,\n \n     match ty::get(rhs_t).sty {\n         ty::ty_estr(ty::vstore_uniq) => {\n-            let scratch_lhs = alloca(cx, val_ty(lhs));\n+            let scratch_lhs = alloca(cx, val_ty(lhs), \"__lhs\");\n             Store(cx, lhs, scratch_lhs);\n-            let scratch_rhs = alloca(cx, val_ty(rhs));\n+            let scratch_rhs = alloca(cx, val_ty(rhs), \"__rhs\");\n             Store(cx, rhs, scratch_rhs);\n             let did = cx.tcx().lang_items.uniq_str_eq_fn();\n             let result = callee::trans_lang_call(cx, did, [scratch_lhs, scratch_rhs], None);\n@@ -1138,18 +1138,11 @@ fn store_non_ref_bindings(bcx: block,\n     let mut bcx = bcx;\n     for bindings_map.each_value |&binding_info| {\n         match binding_info.trmode {\n-            TrByValue(is_move, lldest) => {\n+            TrByValue(lldest) => {\n                 let llval = Load(bcx, binding_info.llmatch); // get a T*\n                 let datum = Datum {val: llval, ty: binding_info.ty,\n                                    mode: ByRef(ZeroMem)};\n-                bcx = {\n-                    if is_move {\n-                        datum.move_to(bcx, INIT, lldest)\n-                    } else {\n-                        datum.copy_to(bcx, INIT, lldest)\n-                    }\n-                };\n-\n+                bcx = datum.store_to(bcx, INIT, lldest);\n                 do opt_temp_cleanups.mutate |temp_cleanups| {\n                     add_clean_temp_mem(bcx, lldest, binding_info.ty);\n                     temp_cleanups.push(lldest);\n@@ -1181,7 +1174,7 @@ fn insert_lllocals(bcx: block,\n         let llval = match binding_info.trmode {\n             // By value bindings: use the stack slot that we\n             // copied/moved the value into\n-            TrByValue(_, lldest) => {\n+            TrByValue(lldest) => {\n                 if add_cleans {\n                     add_clean(bcx, lldest, binding_info.ty);\n                 }\n@@ -1245,7 +1238,7 @@ pub fn compile_guard(bcx: block,\n         let mut bcx = bcx;\n         for data.bindings_map.each_value |&binding_info| {\n             match binding_info.trmode {\n-                TrByValue(_, llval) => {\n+                TrByValue(llval) => {\n                     bcx = glue::drop_ty(bcx, llval, binding_info.ty);\n                 }\n                 TrByRef => {}\n@@ -1636,12 +1629,12 @@ fn create_bindings_map(bcx: block, pat: @ast::pat) -> BindingsMap {\n                 // in this case, the final type of the variable will be T,\n                 // but during matching we need to store a *T as explained\n                 // above\n-                let is_move = ccx.maps.moves_map.contains(&p_id);\n-                llmatch = alloca(bcx, llvariable_ty.ptr_to());\n-                trmode = TrByValue(is_move, alloca(bcx, llvariable_ty));\n+                llmatch = alloca(bcx, llvariable_ty.ptr_to(), \"__llmatch\");\n+                trmode = TrByValue(alloca(bcx, llvariable_ty,\n+                                          bcx.ident(ident)));\n             }\n             ast::bind_by_ref(_) => {\n-                llmatch = alloca(bcx, llvariable_ty);\n+                llmatch = alloca(bcx, llvariable_ty, bcx.ident(ident));\n                 trmode = TrByRef;\n             }\n         };\n@@ -1737,53 +1730,205 @@ pub enum IrrefutablePatternBindingMode {\n     BindArgument\n }\n \n-// Not match-related, but similar to the pattern-munging code above\n-pub fn bind_irrefutable_pat(bcx: block,\n-                            pat: @ast::pat,\n-                            val: ValueRef,\n-                            make_copy: bool,\n-                            binding_mode: IrrefutablePatternBindingMode)\n-                         -> block {\n-    let _icx = push_ctxt(\"match::bind_irrefutable_pat\");\n-    let ccx = bcx.fcx.ccx;\n+pub fn store_local(bcx: block,\n+                   pat: @ast::pat,\n+                   opt_init_expr: Option<@ast::expr>)\n+                               -> block {\n+    /*!\n+     * Generates code for a local variable declaration like\n+     * `let <pat>;` or `let <pat> = <opt_init_expr>`.\n+     */\n+    let _icx = push_ctxt(\"match::store_local\");\n     let mut bcx = bcx;\n \n-    // Necessary since bind_irrefutable_pat is called outside trans_match\n-    match pat.node {\n-        ast::pat_ident(_, _, ref inner) => {\n-            if pat_is_variant_or_struct(bcx.tcx().def_map, pat) {\n-                return bcx;\n+    return match opt_init_expr {\n+        Some(init_expr) => {\n+            // Optimize the \"let x = expr\" case. This just writes\n+            // the result of evaluating `expr` directly into the alloca\n+            // for `x`. Often the general path results in similar or the\n+            // same code post-optimization, but not always. In particular,\n+            // in unsafe code, you can have expressions like\n+            //\n+            //    let x = intrinsics::uninit();\n+            //\n+            // In such cases, the more general path is unsafe, because\n+            // it assumes it is matching against a valid value.\n+            match simple_identifier(pat) {\n+                Some(path) => {\n+                    return mk_binding_alloca(\n+                        bcx, pat.id, path, BindLocal,\n+                        |bcx, _, llval| expr::trans_into(bcx, init_expr,\n+                                                         expr::SaveIn(llval)));\n+                }\n+\n+                None => {}\n             }\n \n-            if make_copy {\n-                let binding_ty = node_id_type(bcx, pat.id);\n-                let datum = Datum {val: val, ty: binding_ty,\n-                                   mode: ByRef(RevokeClean)};\n-                let scratch = scratch_datum(bcx, binding_ty, false);\n-                datum.copy_to_datum(bcx, INIT, scratch);\n-                match binding_mode {\n-                    BindLocal => {\n-                        bcx.fcx.lllocals.insert(pat.id, scratch.val);\n-                    }\n-                    BindArgument => {\n-                        bcx.fcx.llargs.insert(pat.id, scratch.val);\n-                    }\n-                }\n-                add_clean(bcx, scratch.val, binding_ty);\n+            // General path.\n+            let init_datum =\n+                unpack_datum!(\n+                    bcx,\n+                    expr::trans_to_datum(bcx, init_expr));\n+            if ty::type_is_bot(expr_ty(bcx, init_expr)) {\n+                create_dummy_locals(bcx, pat)\n             } else {\n-                match binding_mode {\n-                    BindLocal => {\n-                        bcx.fcx.lllocals.insert(pat.id, val);\n-                    }\n-                    BindArgument => {\n-                        bcx.fcx.llargs.insert(pat.id, val);\n-                    }\n+                if bcx.sess().asm_comments() {\n+                    add_comment(bcx, \"creating zeroable ref llval\");\n                 }\n+                let llptr = init_datum.to_zeroable_ref_llval(bcx);\n+                return bind_irrefutable_pat(bcx, pat, llptr, BindLocal);\n+            }\n+        }\n+        None => {\n+            create_dummy_locals(bcx, pat)\n+        }\n+    };\n+\n+    fn create_dummy_locals(mut bcx: block, pat: @ast::pat) -> block {\n+        // create dummy memory for the variables if we have no\n+        // value to store into them immediately\n+        let tcx = bcx.tcx();\n+        do pat_bindings(tcx.def_map, pat) |_, p_id, _, path| {\n+            bcx = mk_binding_alloca(\n+                bcx, p_id, path, BindLocal,\n+                |bcx, var_ty, llval| { zero_mem(bcx, llval, var_ty); bcx });\n+        }\n+        bcx\n+    }\n+}\n+\n+pub fn store_arg(mut bcx: block,\n+                 pat: @ast::pat,\n+                 llval: ValueRef)\n+                 -> block {\n+    /*!\n+     * Generates code for argument patterns like `fn foo(<pat>: T)`.\n+     * Creates entries in the `llargs` map for each of the bindings\n+     * in `pat`.\n+     *\n+     * # Arguments\n+     *\n+     * - `pat` is the argument pattern\n+     * - `llval` is a pointer to the argument value (in other words,\n+     *   if the argument type is `T`, then `llval` is a `T*`). In some\n+     *   cases, this code may zero out the memory `llval` points at.\n+     */\n+    let _icx = push_ctxt(\"match::store_arg\");\n+\n+    // We always need to cleanup the argument as we exit the fn scope.\n+    // Note that we cannot do it before for fear of a fn like\n+    //    fn getaddr(~ref x: ~uint) -> *uint {....}\n+    // (From test `run-pass/func-arg-ref-pattern.rs`)\n+    let arg_ty = node_id_type(bcx, pat.id);\n+    add_clean(bcx, llval, arg_ty);\n+\n+    match simple_identifier(pat) {\n+        Some(_) => {\n+            // Optimized path for `x: T` case. This just adopts\n+            // `llval` wholesale as the pointer for `x`, avoiding the\n+            // general logic which may copy out of `llval`.\n+            bcx.fcx.llargs.insert(pat.id, llval);\n+        }\n+\n+        None => {\n+            // General path. Copy out the values that are used in the\n+            // pattern.\n+            bcx = bind_irrefutable_pat(bcx, pat, llval, BindArgument);\n+        }\n+    }\n+\n+    return bcx;\n+}\n+\n+fn mk_binding_alloca(mut bcx: block,\n+                     p_id: ast::node_id,\n+                     path: &ast::Path,\n+                     binding_mode: IrrefutablePatternBindingMode,\n+                     populate: &fn(block, ty::t, ValueRef) -> block) -> block {\n+    let var_ty = node_id_type(bcx, p_id);\n+    let ident = ast_util::path_to_ident(path);\n+    let llval = alloc_ty(bcx, var_ty, bcx.ident(ident));\n+    bcx = populate(bcx, var_ty, llval);\n+    let llmap = match binding_mode {\n+        BindLocal => bcx.fcx.lllocals,\n+        BindArgument => bcx.fcx.llargs\n+    };\n+    llmap.insert(p_id, llval);\n+    add_clean(bcx, llval, var_ty);\n+    return bcx;\n+}\n+\n+fn bind_irrefutable_pat(bcx: block,\n+                        pat: @ast::pat,\n+                        val: ValueRef,\n+                        binding_mode: IrrefutablePatternBindingMode)\n+                        -> block {\n+    /*!\n+     * A simple version of the pattern matching code that only handles\n+     * irrefutable patterns. This is used in let/argument patterns,\n+     * not in match statements. Unifying this code with the code above\n+     * sounds nice, but in practice it produces very inefficient code,\n+     * since the match code is so much more general. In most cases,\n+     * LLVM is able to optimize the code, but it causes longer compile\n+     * times and makes the generated code nigh impossible to read.\n+     *\n+     * # Arguments\n+     * - bcx: starting basic block context\n+     * - pat: the irrefutable pattern being matched.\n+     * - val: a pointer to the value being matched. If pat matches a value\n+     *   of type T, then this is a T*. If the value is moved from `pat`,\n+     *   then `*pat` will be zeroed; otherwise, it's existing cleanup\n+     *   applies.\n+     * - binding_mode: is this for an argument or a local variable?\n+     */\n+\n+    debug!(\"bind_irrefutable_pat(bcx=%s, pat=%s, binding_mode=%?)\",\n+           bcx.to_str(),\n+           pat_to_str(pat, bcx.sess().intr()),\n+           binding_mode);\n+\n+    if bcx.sess().asm_comments() {\n+        add_comment(bcx, fmt!(\"bind_irrefutable_pat(pat=%s)\",\n+                              pat_to_str(pat, bcx.sess().intr())));\n+    }\n+\n+    let _indenter = indenter();\n+\n+    let _icx = push_ctxt(\"alt::bind_irrefutable_pat\");\n+    let mut bcx = bcx;\n+    let tcx = bcx.tcx();\n+    let ccx = bcx.ccx();\n+    match pat.node {\n+        ast::pat_ident(pat_binding_mode, ref path, inner) => {\n+            if pat_is_binding(tcx.def_map, pat) {\n+                // Allocate the stack slot where the value of this\n+                // binding will live and place it into the appropriate\n+                // map.\n+                bcx = mk_binding_alloca(\n+                    bcx, pat.id, path, binding_mode,\n+                    |bcx, variable_ty, llvariable_val| {\n+                        match pat_binding_mode {\n+                            ast::bind_infer => {\n+                                // By value binding: move the value that `val`\n+                                // points at into the binding's stack slot.\n+                                let datum = Datum {val: val,\n+                                                   ty: variable_ty,\n+                                                   mode: ByRef(ZeroMem)};\n+                                datum.store_to(bcx, INIT, llvariable_val)\n+                            }\n+\n+                            ast::bind_by_ref(_) => {\n+                                // By ref binding: the value of the variable\n+                                // is the pointer `val` itself.\n+                                Store(bcx, val, llvariable_val);\n+                                bcx\n+                            }\n+                        }\n+                    });\n             }\n \n-            for inner.iter().advance |inner_pat| {\n-                bcx = bind_irrefutable_pat(\n-                    bcx, *inner_pat, val, true, binding_mode);\n+            for inner.iter().advance |&inner_pat| {\n+                bcx = bind_irrefutable_pat(bcx, inner_pat, val, binding_mode);\n             }\n         }\n         ast::pat_enum(_, ref sub_pats) => {\n@@ -1799,11 +1944,8 @@ pub fn bind_irrefutable_pat(bcx: block,\n                                                     val);\n                     for sub_pats.iter().advance |sub_pat| {\n                         for args.vals.iter().enumerate().advance |(i, argval)| {\n-                            bcx = bind_irrefutable_pat(bcx,\n-                                                       sub_pat[i],\n-                                                       *argval,\n-                                                       make_copy,\n-                                                       binding_mode);\n+                            bcx = bind_irrefutable_pat(bcx, sub_pat[i],\n+                                                       *argval, binding_mode);\n                         }\n                     }\n                 }\n@@ -1818,19 +1960,14 @@ pub fn bind_irrefutable_pat(bcx: block,\n                             let repr = adt::represent_node(bcx, pat.id);\n                             for elems.iter().enumerate().advance |(i, elem)| {\n                                 let fldptr = adt::trans_field_ptr(bcx, repr,\n-                                                            val, 0, i);\n-                                bcx = bind_irrefutable_pat(bcx,\n-                                                           *elem,\n-                                                           fldptr,\n-                                                           make_copy,\n-                                                           binding_mode);\n+                                                                  val, 0, i);\n+                                bcx = bind_irrefutable_pat(bcx, *elem,\n+                                                           fldptr, binding_mode);\n                             }\n                         }\n                     }\n                 }\n                 Some(&ast::def_static(_, false)) => {\n-                    bcx = bind_irrefutable_pat(bcx, pat, val, make_copy,\n-                                               binding_mode);\n                 }\n                 _ => {\n                     // Nothing to do here.\n@@ -1845,24 +1982,16 @@ pub fn bind_irrefutable_pat(bcx: block,\n                 for fields.iter().advance |f| {\n                     let ix = ty::field_idx_strict(tcx, f.ident, field_tys);\n                     let fldptr = adt::trans_field_ptr(bcx, pat_repr, val,\n-                                                discr, ix);\n-                    bcx = bind_irrefutable_pat(bcx,\n-                                               f.pat,\n-                                               fldptr,\n-                                               make_copy,\n-                                               binding_mode);\n+                                                      discr, ix);\n+                    bcx = bind_irrefutable_pat(bcx, f.pat, fldptr, binding_mode);\n                 }\n             }\n         }\n         ast::pat_tup(ref elems) => {\n             let repr = adt::represent_node(bcx, pat.id);\n             for elems.iter().enumerate().advance |(i, elem)| {\n                 let fldptr = adt::trans_field_ptr(bcx, repr, val, 0, i);\n-                bcx = bind_irrefutable_pat(bcx,\n-                                           *elem,\n-                                           fldptr,\n-                                           make_copy,\n-                                           binding_mode);\n+                bcx = bind_irrefutable_pat(bcx, *elem, fldptr, binding_mode);\n             }\n         }\n         ast::pat_box(inner) | ast::pat_uniq(inner) => {\n@@ -1872,22 +2001,30 @@ pub fn bind_irrefutable_pat(bcx: block,\n                 ty::ty_uniq(*) if !ty::type_contents(bcx.tcx(), pat_ty).contains_managed() => llbox,\n                     _ => GEPi(bcx, llbox, [0u, abi::box_field_body])\n             };\n-            bcx = bind_irrefutable_pat(bcx,\n-                                       inner,\n-                                       unboxed,\n-                                       true,\n-                                       binding_mode);\n+            bcx = bind_irrefutable_pat(bcx, inner, unboxed, binding_mode);\n         }\n         ast::pat_region(inner) => {\n             let loaded_val = Load(bcx, val);\n-            bcx = bind_irrefutable_pat(bcx,\n-                                       inner,\n-                                       loaded_val,\n-                                       true,\n-                                       binding_mode);\n-        }\n-        ast::pat_wild | ast::pat_lit(_) | ast::pat_range(_, _) |\n-        ast::pat_vec(*) => ()\n+            bcx = bind_irrefutable_pat(bcx, inner, loaded_val, binding_mode);\n+        }\n+        ast::pat_vec(*) => {\n+            bcx.tcx().sess.span_bug(\n+                pat.span,\n+                fmt!(\"vector patterns are never irrefutable!\"));\n+        }\n+        ast::pat_wild | ast::pat_lit(_) | ast::pat_range(_, _) => ()\n     }\n     return bcx;\n }\n+\n+fn simple_identifier<'a>(pat: &'a ast::pat) -> Option<&'a ast::Path> {\n+    match pat.node {\n+        ast::pat_ident(ast::bind_infer, ref path, None) => {\n+            Some(path)\n+        }\n+        _ => {\n+            None\n+        }\n+    }\n+}\n+"}, {"sha": "80fc3803ae7320926e6f10d6b30dc4fae88855fc", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 121, "deletions": 173, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -59,6 +59,7 @@ use middle::trans::type_of::*;\n use middle::ty;\n use util::common::indenter;\n use util::ppaux::{Repr, ty_to_str};\n+use middle::pat_util;\n \n use middle::trans::type_::Type;\n \n@@ -75,7 +76,7 @@ use extra::time;\n use extra::sort;\n use syntax::ast::ident;\n use syntax::ast_map::{path, path_elt_to_str, path_name};\n-use syntax::ast_util::{local_def, path_to_ident};\n+use syntax::ast_util::{local_def};\n use syntax::attr;\n use syntax::codemap::span;\n use syntax::parse::token;\n@@ -111,8 +112,8 @@ impl Drop for _InsnCtxt {\n     fn drop(&self) {\n         unsafe {\n             do local_data::local_data_modify(task_local_insn_key) |c| {\n-                do c.map_consume |@ctx| {\n-                    let mut ctx = ctx;\n+                do c.map_consume |ctx| {\n+                    let mut ctx = copy *ctx;\n                     ctx.pop();\n                     @ctx\n                 }\n@@ -125,8 +126,8 @@ pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n     debug!(\"new InsnCtxt: %s\", s);\n     unsafe {\n         do local_data::local_data_modify(task_local_insn_key) |c| {\n-            do c.map_consume |@ctx| {\n-                let mut ctx = ctx;\n+            do c.map_consume |ctx| {\n+                let mut ctx = copy *ctx;\n                 ctx.push(s);\n                 @ctx\n             }\n@@ -1012,7 +1013,7 @@ pub fn get_landing_pad(bcx: block) -> BasicBlockRef {\n     match bcx.fcx.personality {\n       Some(addr) => Store(pad_bcx, llretval, addr),\n       None => {\n-        let addr = alloca(pad_bcx, val_ty(llretval));\n+        let addr = alloca(pad_bcx, val_ty(llretval), \"\");\n         bcx.fcx.personality = Some(addr);\n         Store(pad_bcx, llretval, addr);\n       }\n@@ -1056,15 +1057,15 @@ pub fn do_spill(bcx: block, v: ValueRef, t: ty::t) -> ValueRef {\n     if ty::type_is_bot(t) {\n         return C_null(Type::i8p());\n     }\n-    let llptr = alloc_ty(bcx, t);\n+    let llptr = alloc_ty(bcx, t, \"\");\n     Store(bcx, v, llptr);\n     return llptr;\n }\n \n // Since this function does *not* root, it is the caller's responsibility to\n // ensure that the referent is pointed to by a root.\n pub fn do_spill_noroot(cx: block, v: ValueRef) -> ValueRef {\n-    let llptr = alloca(cx, val_ty(v));\n+    let llptr = alloca(cx, val_ty(v), \"\");\n     Store(cx, v, llptr);\n     return llptr;\n }\n@@ -1121,9 +1122,6 @@ pub fn init_local(bcx: block, local: &ast::local) -> block {\n     let _indenter = indenter();\n \n     let _icx = push_ctxt(\"init_local\");\n-    let ty = node_id_type(bcx, local.node.id);\n-\n-    debug!(\"ty=%s\", bcx.ty_to_str(ty));\n \n     if ignore_lhs(bcx, local) {\n         // Handle let _ = e; just like e;\n@@ -1135,36 +1133,7 @@ pub fn init_local(bcx: block, local: &ast::local) -> block {\n         }\n     }\n \n-    let llptr = match bcx.fcx.lllocals.find_copy(&local.node.id) {\n-        Some(v) => v,\n-        _ => {\n-            bcx.tcx().sess.span_bug(local.span,\n-                                    \"init_local: Someone forgot to document why it's\\\n-                                     safe to assume local.node.init must be local_mem!\");\n-        }\n-    };\n-\n-    let mut bcx = bcx;\n-    match local.node.init {\n-        Some(init) => {\n-            bcx = expr::trans_into(bcx, init, expr::SaveIn(llptr));\n-        }\n-        _ => {\n-            zero_mem(bcx, llptr, ty);\n-        }\n-    }\n-\n-    // Make a note to drop this slot on the way out.\n-    debug!(\"adding clean for %?/%s to bcx=%s\",\n-           local.node.id, bcx.ty_to_str(ty),\n-           bcx.to_str());\n-    add_clean(bcx, llptr, ty);\n-\n-    return _match::bind_irrefutable_pat(bcx,\n-                                       local.node.pat,\n-                                       llptr,\n-                                       false,\n-                                       _match::BindLocal);\n+    _match::store_local(bcx, local.node.pat, local.node.init)\n }\n \n pub fn trans_stmt(cx: block, s: &ast::stmt) -> block {\n@@ -1469,28 +1438,6 @@ pub fn block_locals(b: &ast::blk, it: &fn(@ast::local)) {\n     }\n }\n \n-pub fn alloc_local(cx: block, local: &ast::local) -> block {\n-    let _icx = push_ctxt(\"alloc_local\");\n-    let t = node_id_type(cx, local.node.id);\n-    let simple_name = match local.node.pat.node {\n-      ast::pat_ident(_, ref pth, None) => Some(path_to_ident(pth)),\n-      _ => None\n-    };\n-    let val = alloc_ty(cx, t);\n-    if cx.sess().opts.debuginfo {\n-        for simple_name.iter().advance |name| {\n-            str::as_c_str(cx.ccx().sess.str_of(*name), |buf| {\n-                unsafe {\n-                    llvm::LLVMSetValueName(val, buf)\n-                }\n-            });\n-        }\n-    }\n-    cx.fcx.lllocals.insert(local.node.id, val);\n-    cx\n-}\n-\n-\n pub fn with_cond(bcx: block, val: ValueRef, f: &fn(block) -> block) -> block {\n     let _icx = push_ctxt(\"with_cond\");\n     let next_cx = base::sub_block(bcx, \"next\");\n@@ -1561,28 +1508,28 @@ pub fn memzero(cx: block, llptr: ValueRef, ty: Type) {\n     Call(cx, llintrinsicfn, [llptr, llzeroval, size, align, volatile]);\n }\n \n-pub fn alloc_ty(bcx: block, t: ty::t) -> ValueRef {\n+pub fn alloc_ty(bcx: block, t: ty::t, name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"alloc_ty\");\n     let ccx = bcx.ccx();\n     let ty = type_of::type_of(ccx, t);\n     assert!(!ty::type_has_params(t), \"Type has params: %s\", ty_to_str(ccx.tcx, t));\n-    let val = alloca(bcx, ty);\n+    let val = alloca(bcx, ty, name);\n     return val;\n }\n \n-pub fn alloca(cx: block, ty: Type) -> ValueRef {\n-    alloca_maybe_zeroed(cx, ty, false)\n+pub fn alloca(cx: block, ty: Type, name: &str) -> ValueRef {\n+    alloca_maybe_zeroed(cx, ty, name, false)\n }\n \n-pub fn alloca_maybe_zeroed(cx: block, ty: Type, zero: bool) -> ValueRef {\n+pub fn alloca_maybe_zeroed(cx: block, ty: Type, name: &str, zero: bool) -> ValueRef {\n     let _icx = push_ctxt(\"alloca\");\n     if cx.unreachable {\n         unsafe {\n             return llvm::LLVMGetUndef(ty.to_ref());\n         }\n     }\n     let initcx = base::raw_block(cx.fcx, false, cx.fcx.llstaticallocas);\n-    let p = Alloca(initcx, ty);\n+    let p = Alloca(initcx, ty, name);\n     if zero { memzero(initcx, p, ty); }\n     p\n }\n@@ -1623,7 +1570,8 @@ pub fn make_return_pointer(fcx: fn_ctxt, output_type: ty::t) -> ValueRef {\n             llvm::LLVMGetParam(fcx.llfn, 0)\n         } else {\n             let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n-            alloca(raw_block(fcx, false, fcx.llstaticallocas), lloutputtype)\n+            alloca(raw_block(fcx, false, fcx.llstaticallocas), lloutputtype,\n+                   \"__make_return_pointer\")\n         }\n     }\n }\n@@ -1738,6 +1686,7 @@ pub fn create_llargs_for_fn_args(cx: fn_ctxt,\n             let arg = &args[i];\n             let llarg = llvm::LLVMGetParam(cx.llfn, arg_n as c_uint);\n \n+            // FIXME #7260: aliasing should be determined by monomorphized ty::t\n             match arg.ty.node {\n                 // `~` pointers never alias other parameters, because ownership was transferred\n                 ast::ty_uniq(_) => {\n@@ -1766,7 +1715,7 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n             let self_val = if slf.is_copy\n                     && datum::appropriate_mode(bcx.tcx(), slf.t).is_by_value() {\n                 let tmp = BitCast(bcx, slf.v, type_of(bcx.ccx(), slf.t));\n-                let alloc = alloc_ty(bcx, slf.t);\n+                let alloc = alloc_ty(bcx, slf.t, \"__self\");\n                 Store(bcx, tmp, alloc);\n                 alloc\n             } else {\n@@ -1782,7 +1731,6 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n     for uint::range(0, arg_tys.len()) |arg_n| {\n         let arg_ty = arg_tys[arg_n];\n         let raw_llarg = raw_llargs[arg_n];\n-        let arg_id = args[arg_n].id;\n \n         // For certain mode/type combinations, the raw llarg values are passed\n         // by value.  However, within the fn body itself, we want to always\n@@ -1793,22 +1741,13 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n         // the event it's not truly needed.\n         // only by value if immediate:\n         let llarg = if datum::appropriate_mode(bcx.tcx(), arg_ty).is_by_value() {\n-            let alloc = alloc_ty(bcx, arg_ty);\n+            let alloc = alloc_ty(bcx, arg_ty, \"__arg\");\n             Store(bcx, raw_llarg, alloc);\n             alloc\n         } else {\n             raw_llarg\n         };\n-\n-        add_clean(bcx, llarg, arg_ty);\n-\n-        bcx = _match::bind_irrefutable_pat(bcx,\n-                                          args[arg_n].pat,\n-                                          llarg,\n-                                          false,\n-                                          _match::BindArgument);\n-\n-        fcx.llargs.insert(arg_id, llarg);\n+        bcx = _match::store_arg(bcx, args[arg_n].pat, llarg);\n \n         if fcx.ccx.sess.opts.extra_debuginfo && fcx_has_nonzero_span(fcx) {\n             debuginfo::create_arg(bcx, &args[arg_n], args[arg_n].ty.span);\n@@ -1967,143 +1906,148 @@ pub fn trans_fn(ccx: @mut CrateContext,\n                   |_bcx| { });\n }\n \n+fn insert_synthetic_type_entries(bcx: block,\n+                                 fn_args: &[ast::arg],\n+                                 arg_tys: &[ty::t])\n+{\n+    /*!\n+     * For tuple-like structs and enum-variants, we generate\n+     * synthetic AST nodes for the arguments.  These have no types\n+     * in the type table and no entries in the moves table,\n+     * so the code in `copy_args_to_allocas` and `bind_irrefutable_pat`\n+     * gets upset. This hack of a function bridges the gap by inserting types.\n+     *\n+     * This feels horrible. I think we should just have a special path\n+     * for these functions and not try to use the generic code, but\n+     * that's not the problem I'm trying to solve right now. - nmatsakis\n+     */\n+\n+    let tcx = bcx.tcx();\n+    for uint::range(0, fn_args.len()) |i| {\n+        debug!(\"setting type of argument %u (pat node %d) to %s\",\n+               i, fn_args[i].pat.id, bcx.ty_to_str(arg_tys[i]));\n+\n+        let pat_id = fn_args[i].pat.id;\n+        let arg_ty = arg_tys[i];\n+        tcx.node_types.insert(pat_id as uint, arg_ty);\n+    }\n+}\n+\n pub fn trans_enum_variant(ccx: @mut CrateContext,\n-                          enum_id: ast::node_id,\n+                          _enum_id: ast::node_id,\n                           variant: &ast::variant,\n                           args: &[ast::variant_arg],\n                           disr: int,\n                           param_substs: Option<@param_substs>,\n                           llfndecl: ValueRef) {\n     let _icx = push_ctxt(\"trans_enum_variant\");\n-    // Translate variant arguments to function arguments.\n-    let fn_args = do args.map |varg| {\n-        ast::arg {\n-            is_mutbl: false,\n-            ty: copy varg.ty,\n-            pat: ast_util::ident_to_pat(\n-                ccx.tcx.sess.next_node_id(),\n-                codemap::dummy_sp(),\n-                special_idents::arg),\n-            id: varg.id,\n-        }\n-    };\n-\n-    let ty_param_substs = match param_substs {\n-        Some(ref substs) => { copy substs.tys }\n-        None => ~[]\n-    };\n-    let enum_ty = ty::subst_tps(ccx.tcx,\n-                                ty_param_substs,\n-                                None,\n-                                ty::node_id_to_type(ccx.tcx, enum_id));\n-    let fcx = new_fn_ctxt_w_id(ccx,\n-                               ~[],\n-                               llfndecl,\n-                               variant.node.id,\n-                               enum_ty,\n-                               param_substs,\n-                               None);\n-\n-    let raw_llargs = create_llargs_for_fn_args(fcx, no_self, fn_args);\n-    let bcx = top_scope_block(fcx, None);\n-    let lltop = bcx.llbb;\n-    let arg_tys = ty::ty_fn_args(node_id_type(bcx, variant.node.id));\n-    let bcx = copy_args_to_allocas(fcx, bcx, fn_args, raw_llargs, arg_tys);\n-\n-    // XXX is there a better way to reconstruct the ty::t?\n-    let repr = adt::represent_type(ccx, enum_ty);\n-\n-    debug!(\"trans_enum_variant: name=%s tps=%s repr=%? enum_ty=%s\",\n-           unsafe { str::raw::from_c_str(llvm::LLVMGetValueName(llfndecl)) },\n-           ~\"[\" + ty_param_substs.map(|&t| ty_to_str(ccx.tcx, t)).connect(\", \") + \"]\",\n-           repr, ty_to_str(ccx.tcx, enum_ty));\n \n-    adt::trans_start_init(bcx, repr, fcx.llretptr.get(), disr);\n-    for args.iter().enumerate().advance |(i, va)| {\n-        let lldestptr = adt::trans_field_ptr(bcx,\n-                                             repr,\n-                                             fcx.llretptr.get(),\n-                                             disr,\n-                                             i);\n-\n-        // If this argument to this function is a enum, it'll have come in to\n-        // this function as an opaque blob due to the way that type_of()\n-        // works. So we have to cast to the destination's view of the type.\n-        let llarg = match fcx.llargs.find(&va.id) {\n-            Some(&x) => x,\n-            _ => fail!(\"trans_enum_variant: how do we know this works?\"),\n-        };\n-        let arg_ty = arg_tys[i];\n-        memcpy_ty(bcx, lldestptr, llarg, arg_ty);\n-    }\n-    build_return(bcx);\n-    finish_fn(fcx, lltop);\n+    trans_enum_variant_or_tuple_like_struct(\n+        ccx,\n+        variant.node.id,\n+        args,\n+        disr,\n+        param_substs,\n+        llfndecl);\n }\n \n-// NB: In theory this should be merged with the function above. But the AST\n-// structures are completely different, so very little code would be shared.\n pub fn trans_tuple_struct(ccx: @mut CrateContext,\n                           fields: &[@ast::struct_field],\n                           ctor_id: ast::node_id,\n                           param_substs: Option<@param_substs>,\n                           llfndecl: ValueRef) {\n     let _icx = push_ctxt(\"trans_tuple_struct\");\n \n-    // Translate struct fields to function arguments.\n-    let fn_args = do fields.map |field| {\n+    trans_enum_variant_or_tuple_like_struct(\n+        ccx,\n+        ctor_id,\n+        fields,\n+        0,\n+        param_substs,\n+        llfndecl);\n+}\n+\n+trait IdAndTy {\n+    fn id(&self) -> ast::node_id;\n+    fn ty<'a>(&'a self) -> &'a ast::Ty;\n+}\n+\n+impl IdAndTy for ast::variant_arg {\n+    fn id(&self) -> ast::node_id { self.id }\n+    fn ty<'a>(&'a self) -> &'a ast::Ty { &self.ty }\n+}\n+\n+impl IdAndTy for @ast::struct_field {\n+    fn id(&self) -> ast::node_id { self.node.id }\n+    fn ty<'a>(&'a self) -> &'a ast::Ty { &self.node.ty }\n+}\n+\n+pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n+    ccx: @mut CrateContext,\n+    ctor_id: ast::node_id,\n+    args: &[A],\n+    disr: int,\n+    param_substs: Option<@param_substs>,\n+    llfndecl: ValueRef)\n+{\n+    // Translate variant arguments to function arguments.\n+    let fn_args = do args.map |varg| {\n         ast::arg {\n             is_mutbl: false,\n-            ty: copy field.node.ty,\n-            pat: ast_util::ident_to_pat(ccx.tcx.sess.next_node_id(),\n-                                        codemap::dummy_sp(),\n-                                        special_idents::arg),\n-            id: field.node.id\n+            ty: copy *varg.ty(),\n+            pat: ast_util::ident_to_pat(\n+                ccx.tcx.sess.next_node_id(),\n+                codemap::dummy_sp(),\n+                special_idents::arg),\n+            id: varg.id(),\n         }\n     };\n \n-    // XXX is there a better way to reconstruct the ty::t?\n     let ty_param_substs = match param_substs {\n         Some(ref substs) => { copy substs.tys }\n         None => ~[]\n     };\n+\n     let ctor_ty = ty::subst_tps(ccx.tcx, ty_param_substs, None,\n                                 ty::node_id_to_type(ccx.tcx, ctor_id));\n-    let tup_ty = match ty::get(ctor_ty).sty {\n+\n+    let result_ty = match ty::get(ctor_ty).sty {\n         ty::ty_bare_fn(ref bft) => bft.sig.output,\n-        _ => ccx.sess.bug(fmt!(\"trans_tuple_struct: unexpected ctor \\\n-                                return type %s\",\n-                               ty_to_str(ccx.tcx, ctor_ty)))\n+        _ => ccx.sess.bug(\n+            fmt!(\"trans_enum_variant_or_tuple_like_struct: \\\n+                  unexpected ctor return type %s\",\n+                 ty_to_str(ccx.tcx, ctor_ty)))\n     };\n \n     let fcx = new_fn_ctxt_w_id(ccx,\n                                ~[],\n                                llfndecl,\n                                ctor_id,\n-                               tup_ty,\n+                               result_ty,\n                                param_substs,\n                                None);\n \n     let raw_llargs = create_llargs_for_fn_args(fcx, no_self, fn_args);\n \n     let bcx = top_scope_block(fcx, None);\n     let lltop = bcx.llbb;\n-    let arg_tys = ty::ty_fn_args(node_id_type(bcx, ctor_id));\n-    let bcx = copy_args_to_allocas(fcx, bcx, fn_args, raw_llargs, arg_tys);\n+    let arg_tys = ty::ty_fn_args(ctor_ty);\n \n-    let repr = adt::represent_type(ccx, tup_ty);\n-    adt::trans_start_init(bcx, repr, fcx.llretptr.get(), 0);\n+    insert_synthetic_type_entries(bcx, fn_args, arg_tys);\n+    let bcx = copy_args_to_allocas(fcx, bcx, fn_args, raw_llargs, arg_tys);\n \n-    for fields.iter().enumerate().advance |(i, field)| {\n+    let repr = adt::represent_type(ccx, result_ty);\n+    adt::trans_start_init(bcx, repr, fcx.llretptr.get(), disr);\n+    for fn_args.iter().enumerate().advance |(i, fn_arg)| {\n         let lldestptr = adt::trans_field_ptr(bcx,\n                                              repr,\n                                              fcx.llretptr.get(),\n-                                             0,\n+                                             disr,\n                                              i);\n-        let llarg = fcx.llargs.get_copy(&field.node.id);\n+        let llarg = fcx.llargs.get_copy(&fn_arg.pat.id);\n         let arg_ty = arg_tys[i];\n         memcpy_ty(bcx, lldestptr, llarg, arg_ty);\n     }\n-\n     build_return(bcx);\n     finish_fn(fcx, lltop);\n }\n@@ -3033,13 +2977,17 @@ pub fn trans_crate(sess: session::Session,\n         do sort::quick_sort(ccx.stats.fn_stats) |&(_, _, insns_a), &(_, _, insns_b)| {\n             insns_a > insns_b\n         }\n-        for ccx.stats.fn_stats.iter().advance |&(name, ms, insns)| {\n-            io::println(fmt!(\"%u insns, %u ms, %s\", insns, ms, name));\n+        for ccx.stats.fn_stats.iter().advance |tuple| {\n+            match *tuple {\n+                (ref name, ms, insns) => {\n+                    io::println(fmt!(\"%u insns, %u ms, %s\", insns, ms, *name));\n+                }\n+            }\n         }\n     }\n     if ccx.sess.count_llvm_insns() {\n-        for ccx.stats.llvm_insns.iter().advance |(&k, &v)| {\n-            io::println(fmt!(\"%-7u %s\", v, k));\n+        for ccx.stats.llvm_insns.iter().advance |(k, v)| {\n+            io::println(fmt!(\"%-7u %s\", *v, *k));\n         }\n     }\n "}, {"sha": "db5553ca939d79d67ed4e8d5f26c69eec9e63cb8", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -505,11 +505,17 @@ pub fn ArrayMalloc(cx: block, Ty: Type, Val: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn Alloca(cx: block, Ty: Type) -> ValueRef {\n+pub fn Alloca(cx: block, Ty: Type, name: &str) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n         count_insn(cx, \"alloca\");\n-        return llvm::LLVMBuildAlloca(B(cx), Ty.to_ref(), noname());\n+        if name.is_empty() {\n+            llvm::LLVMBuildAlloca(B(cx), Ty.to_ref(), noname())\n+        } else {\n+            str::as_c_str(\n+                name,\n+                |c| llvm::LLVMBuildAlloca(B(cx), Ty.to_ref(), c))\n+        }\n     }\n }\n "}, {"sha": "8d741369e1a25af5affae8f55cd323aeae60645a", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -130,10 +130,10 @@ impl FnType {\n             j = 1u;\n             get_param(llwrapfn, 0u)\n         } else if self.ret_ty.cast {\n-            let retptr = alloca(bcx, self.ret_ty.ty);\n+            let retptr = alloca(bcx, self.ret_ty.ty, \"\");\n             BitCast(bcx, retptr, ret_ty.ptr_to())\n         } else {\n-            alloca(bcx, ret_ty)\n+            alloca(bcx, ret_ty, \"\")\n         };\n \n         let mut i = 0u;"}, {"sha": "22adc4aa24b6561f248146bbe052d9d11e0ed680", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -600,7 +600,7 @@ pub fn trans_call_inner(in_cx: block,\n         let mut bcx = callee.bcx;\n         let ccx = cx.ccx();\n         let ret_flag = if ret_in_loop {\n-            let flag = alloca(bcx, Type::bool());\n+            let flag = alloca(bcx, Type::bool(), \"__ret_flag\");\n             Store(bcx, C_bool(false), flag);\n             Some(flag)\n         } else {\n@@ -675,7 +675,7 @@ pub fn trans_call_inner(in_cx: block,\n                 unsafe {\n                     if ty::type_needs_drop(bcx.tcx(), ret_ty) {\n                         if ty::type_is_immediate(bcx.tcx(), ret_ty) {\n-                            let llscratchptr = alloc_ty(bcx, ret_ty);\n+                            let llscratchptr = alloc_ty(bcx, ret_ty, \"__ret\");\n                             Store(bcx, llresult, llscratchptr);\n                             bcx = glue::drop_ty(bcx, llscratchptr, ret_ty);\n                         } else {\n@@ -733,7 +733,7 @@ pub fn trans_ret_slot(bcx: block, fn_ty: ty::t, dest: Option<expr::Dest>)\n                     llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref())\n                 }\n             } else {\n-                alloc_ty(bcx, retty)\n+                alloc_ty(bcx, retty, \"__trans_ret_slot\")\n             }\n         }\n     }\n@@ -823,7 +823,7 @@ pub fn trans_arg_expr(bcx: block,\n                         _\n                     }) => {\n                     let scratch_ty = expr_ty(bcx, arg_expr);\n-                    let scratch = alloc_ty(bcx, scratch_ty);\n+                    let scratch = alloc_ty(bcx, scratch_ty, \"__ret_flag\");\n                     let arg_ty = expr_ty(bcx, arg_expr);\n                     let sigil = ty::ty_closure_sigil(arg_ty);\n                     let bcx = closure::trans_expr_fn(\n@@ -860,8 +860,6 @@ pub fn trans_arg_expr(bcx: block,\n         // FIXME(#3548) use the adjustments table\n         match autoref_arg {\n             DoAutorefArg => {\n-                assert!(!\n-                    bcx.ccx().maps.moves_map.contains(&arg_expr.id));\n                 val = arg_datum.to_ref_llval(bcx);\n             }\n             DontAutorefArg => {\n@@ -875,10 +873,10 @@ pub fn trans_arg_expr(bcx: block,\n                         //    &arg_expr.id);\n                         debug!(\"by ref arg with type %s, storing to scratch\",\n                                bcx.ty_to_str(arg_datum.ty));\n-                        let scratch = scratch_datum(bcx, arg_datum.ty, false);\n+                        let scratch = scratch_datum(bcx, arg_datum.ty,\n+                                                    \"__self\", false);\n \n                         arg_datum.store_to_datum(bcx,\n-                                                 arg_expr.id,\n                                                  INIT,\n                                                  scratch);\n \n@@ -895,10 +893,10 @@ pub fn trans_arg_expr(bcx: block,\n                                 arg_datum.appropriate_mode(bcx.tcx()).is_by_ref() {\n                             debug!(\"by copy arg with type %s, storing to scratch\",\n                                    bcx.ty_to_str(arg_datum.ty));\n-                            let scratch = scratch_datum(bcx, arg_datum.ty, false);\n+                            let scratch = scratch_datum(bcx, arg_datum.ty,\n+                                                        \"__arg\", false);\n \n                             arg_datum.store_to_datum(bcx,\n-                                                     arg_expr.id,\n                                                      INIT,\n                                                      scratch);\n "}, {"sha": "5b0212cc05cc7ff2a722974bdf1dd5a6bea479e2", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -193,7 +193,7 @@ pub fn allocate_cbox(bcx: block, sigil: ast::Sigil, cdata_ty: ty::t)\n         }\n         ast::BorrowedSigil => {\n             let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n-            let llbox = alloc_ty(bcx, cbox_ty);\n+            let llbox = alloc_ty(bcx, cbox_ty, \"__closure\");\n             nuke_ref_count(bcx, llbox);\n             rslt(bcx, llbox)\n         }"}, {"sha": "24648ada8935eeaa9c82e7966f3f4b45b8e3aa13", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -608,6 +608,10 @@ impl block_ {\n     pub fn tcx(&self) -> ty::ctxt { self.fcx.ccx.tcx }\n     pub fn sess(&self) -> Session { self.fcx.ccx.sess }\n \n+    pub fn ident(&self, ident: ident) -> @str {\n+        token::ident_to_str(&ident)\n+    }\n+\n     pub fn node_id_to_str(&self, id: ast::node_id) -> ~str {\n         ast_map::node_id_to_str(self.tcx().items, id, self.sess().intr())\n     }"}, {"sha": "2880c68c1e036a22de1870dbf6b8117e22a27abd", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -96,7 +96,7 @@ pub struct CrateContext {\n      all_llvm_symbols: HashSet<@str>,\n      tcx: ty::ctxt,\n      maps: astencode::Maps,\n-     stats: Stats,\n+     stats: @mut Stats,\n      upcalls: @upcall::Upcalls,\n      tydesc_type: Type,\n      int_type: Type,\n@@ -201,7 +201,7 @@ impl CrateContext {\n                   all_llvm_symbols: HashSet::new(),\n                   tcx: tcx,\n                   maps: maps,\n-                  stats: Stats {\n+                  stats: @mut Stats {\n                     n_static_tydescs: 0u,\n                     n_glues_created: 0u,\n                     n_null_glues: 0u,"}, {"sha": "904e6e14e28db9b4f8a2506ffee08438cebaea40", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -35,9 +35,6 @@ use syntax::codemap::span;\n pub fn trans_block(bcx: block, b: &ast::blk, dest: expr::Dest) -> block {\n     let _icx = push_ctxt(\"trans_block\");\n     let mut bcx = bcx;\n-    do block_locals(b) |local| {\n-        bcx = alloc_local(bcx, local);\n-    };\n     for b.node.stmts.iter().advance |s| {\n         debuginfo::update_source_pos(bcx, b.span);\n         bcx = trans_stmt(bcx, *s);"}, {"sha": "1de619433afbd86f09f84d81ab1f3fe82f1de3fc", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -70,8 +70,8 @@\n  *   This is a \"shallow\" clone.  After `move_to()`, the current datum\n  *   is invalid and should no longer be used.\n  *\n- * - `store_to()` either performs a copy or a move by consulting the\n- *   moves_map computed by `middle::moves`.\n+ * - `store_to()` either performs a copy or a move depending on the\n+ *   Rust type of the datum.\n  *\n  * # Scratch datum\n  *\n@@ -173,19 +173,19 @@ pub fn immediate_rvalue_bcx(bcx: block,\n     return DatumBlock {bcx: bcx, datum: immediate_rvalue(val, ty)};\n }\n \n-pub fn scratch_datum(bcx: block, ty: ty::t, zero: bool) -> Datum {\n+pub fn scratch_datum(bcx: block, ty: ty::t, name: &str, zero: bool) -> Datum {\n     /*!\n-     *\n      * Allocates temporary space on the stack using alloca() and\n      * returns a by-ref Datum pointing to it.  If `zero` is true, the\n      * space will be zeroed when it is allocated; this is normally not\n      * necessary, but in the case of automatic rooting in match\n      * statements it is possible to have temporaries that may not get\n      * initialized if a certain arm is not taken, so we must zero\n-     * them. You must arrange any cleanups etc yourself! */\n+     * them. You must arrange any cleanups etc yourself!\n+     */\n \n     let llty = type_of::type_of(bcx.ccx(), ty);\n-    let scratch = alloca_maybe_zeroed(bcx, llty, zero);\n+    let scratch = alloca_maybe_zeroed(bcx, llty, name, zero);\n     Datum { val: scratch, ty: ty, mode: ByRef(RevokeClean) }\n }\n \n@@ -208,7 +208,6 @@ pub fn appropriate_mode(tcx: ty::ctxt, ty: ty::t) -> DatumMode {\n impl Datum {\n     pub fn store_to(&self,\n                     bcx: block,\n-                    id: ast::node_id,\n                     action: CopyAction,\n                     dst: ValueRef)\n                     -> block {\n@@ -218,7 +217,7 @@ impl Datum {\n          * `id` is located in the move table, but copies otherwise.\n          */\n \n-        if bcx.ccx().maps.moves_map.contains(&id) {\n+        if ty::type_moves_by_default(bcx.tcx(), self.ty) {\n             self.move_to(bcx, action, dst)\n         } else {\n             self.copy_to(bcx, action, dst)\n@@ -227,29 +226,27 @@ impl Datum {\n \n     pub fn store_to_dest(&self,\n                          bcx: block,\n-                         id: ast::node_id,\n                          dest: expr::Dest)\n                          -> block {\n         match dest {\n             expr::Ignore => {\n                 return bcx;\n             }\n             expr::SaveIn(addr) => {\n-                return self.store_to(bcx, id, INIT, addr);\n+                return self.store_to(bcx, INIT, addr);\n             }\n         }\n     }\n \n     pub fn store_to_datum(&self,\n                           bcx: block,\n-                          id: ast::node_id,\n                           action: CopyAction,\n                           datum: Datum)\n                           -> block {\n         debug!(\"store_to_datum(self=%s, action=%?, datum=%s)\",\n                self.to_str(bcx.ccx()), action, datum.to_str(bcx.ccx()));\n         assert!(datum.mode.is_by_ref());\n-        self.store_to(bcx, id, action, datum.val)\n+        self.store_to(bcx, action, datum.val)\n     }\n \n     pub fn move_to_datum(&self, bcx: block, action: CopyAction, datum: Datum)\n@@ -476,7 +473,7 @@ impl Datum {\n                 if ty::type_is_nil(self.ty) || ty::type_is_bot(self.ty) {\n                     C_null(type_of::type_of(bcx.ccx(), self.ty).ptr_to())\n                 } else {\n-                    let slot = alloc_ty(bcx, self.ty);\n+                    let slot = alloc_ty(bcx, self.ty, \"\");\n                     Store(bcx, self.val, slot);\n                     slot\n                 }\n@@ -828,11 +825,10 @@ impl DatumBlock {\n     }\n \n     pub fn store_to(&self,\n-                    id: ast::node_id,\n                     action: CopyAction,\n                     dst: ValueRef)\n                     -> block {\n-        self.datum.store_to(self.bcx, id, action, dst)\n+        self.datum.store_to(self.bcx, action, dst)\n     }\n \n     pub fn copy_to(&self, action: CopyAction, dst: ValueRef) -> block {"}, {"sha": "19a0f7262ff6e697c242bfa802dedf6fc0c735f5", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 35, "deletions": 31, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -23,7 +23,8 @@ This will generate code that evaluates `expr`, storing the result into\n `Dest`, which must either be the special flag ignore (throw the result\n away) or be a pointer to memory of the same type/size as the\n expression.  It returns the resulting basic block.  This form will\n-handle all automatic adjustments and moves for you.\n+handle all automatic adjustments for you. The value will be moved if\n+its type is linear and copied otherwise.\n \n ## Translation to a datum\n \n@@ -42,18 +43,18 @@ This function generates code to evaluate the expression and return a\n tries to return its result in the most efficient way possible, without\n introducing extra copies or sacrificing information.  Therefore, for\n lvalue expressions, you always get a by-ref `Datum` in return that\n-points at the memory for this lvalue (almost, see [1]).  For rvalue\n-expressions, we will return a by-value `Datum` whenever possible, but\n-it is often necessary to allocate a stack slot, store the result of\n-the rvalue in there, and then return a pointer to the slot (see the\n-discussion later on about the different kinds of rvalues).\n+points at the memory for this lvalue.  For rvalue expressions, we will\n+return a by-value `Datum` whenever possible, but it is often necessary\n+to allocate a stack slot, store the result of the rvalue in there, and\n+then return a pointer to the slot (see the discussion later on about\n+the different kinds of rvalues).\n \n NB: The `trans_to_datum()` function does perform adjustments, but\n since it returns a pointer to the value \"in place\" it does not handle\n-any moves that may be relevant.  If you are transing an expression\n-whose result should be moved, you should either use the Datum methods\n-`move_to()` (for unconditional moves) or `store_to()` (for moves\n-conditioned on the type of the expression) at some point.\n+moves.  If you wish to copy/move the value returned into a new\n+location, you should use the Datum method `store_to()` (move or copy\n+depending on type). You can also use `move_to()` (force move) or\n+`copy_to()` (force copy) for special situations.\n \n ## Translating local variables\n \n@@ -110,13 +111,6 @@ generate phi nodes).\n Finally, statement rvalues are rvalues that always produce a nil\n return type, such as `while` loops or assignments (`a = b`).\n \n-## Caveats\n-\n-[1] Actually, some lvalues are only stored by value and not by\n-reference.  An example (as of this writing) would be immutable\n-arguments or pattern bindings of immediate type.  However, mutable\n-lvalues are *never* stored by value.\n-\n */\n \n \n@@ -274,7 +268,7 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n                                    ty::mt { ty: unit_ty, mutbl: ast::m_imm },\n                                    ty::vstore_slice(ty::re_static));\n \n-        let scratch = scratch_datum(bcx, slice_ty, false);\n+        let scratch = scratch_datum(bcx, slice_ty, \"__adjust\", false);\n         Store(bcx, base, GEPi(bcx, scratch.val, [0u, abi::slice_elt_base]));\n         Store(bcx, len, GEPi(bcx, scratch.val, [0u, abi::slice_elt_len]));\n         DatumBlock {bcx: bcx, datum: scratch}\n@@ -290,7 +284,7 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n         let tcx = bcx.tcx();\n         let closure_ty = expr_ty_adjusted(bcx, expr);\n         debug!(\"add_env(closure_ty=%s)\", closure_ty.repr(tcx));\n-        let scratch = scratch_datum(bcx, closure_ty, false);\n+        let scratch = scratch_datum(bcx, closure_ty, \"__adjust\", false);\n         let llfn = GEPi(bcx, scratch.val, [0u, abi::fn_field_code]);\n         assert_eq!(datum.appropriate_mode(tcx), ByValue);\n         Store(bcx, datum.to_appropriate_llval(bcx), llfn);\n@@ -315,7 +309,7 @@ pub fn trans_into(bcx: block, expr: @ast::expr, dest: Dest) -> block {\n         let datumblock = trans_to_datum(bcx, expr);\n         return match dest {\n             Ignore => datumblock.bcx,\n-            SaveIn(lldest) => datumblock.store_to(expr.id, INIT, lldest)\n+            SaveIn(lldest) => datumblock.store_to(INIT, lldest)\n         };\n     }\n \n@@ -343,16 +337,17 @@ pub fn trans_into(bcx: block, expr: @ast::expr, dest: Dest) -> block {\n             let datumblock = trans_lvalue_unadjusted(bcx, expr);\n             match dest {\n                 Ignore => datumblock.bcx,\n-                SaveIn(lldest) => datumblock.store_to(expr.id, INIT, lldest)\n+                SaveIn(lldest) => datumblock.store_to(INIT, lldest)\n             }\n         }\n         ty::RvalueDatumExpr => {\n             let datumblock = trans_rvalue_datum_unadjusted(bcx, expr);\n             match dest {\n                 Ignore => datumblock.drop_val(),\n \n-                // NB: We always do `move_to()` regardless of the\n-                // moves_map because we're processing an rvalue\n+                // When processing an rvalue, the value will be newly\n+                // allocated, so we always `move_to` so as not to\n+                // unnecessarily inc ref counts and so forth:\n                 SaveIn(lldest) => datumblock.move_to(INIT, lldest)\n             }\n         }\n@@ -386,11 +381,11 @@ fn trans_lvalue(bcx: block, expr: @ast::expr) -> DatumBlock {\n \n fn trans_to_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     /*!\n-     *\n      * Translates an expression into a datum.  If this expression\n      * is an rvalue, this will result in a temporary value being\n-     * created.  If you already know where the result should be stored,\n-     * you should use `trans_into()` instead. */\n+     * created.  If you plan to store the value somewhere else,\n+     * you should prefer `trans_into()` instead.\n+     */\n \n     let mut bcx = bcx;\n \n@@ -423,7 +418,7 @@ fn trans_to_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n                 bcx = trans_rvalue_dps_unadjusted(bcx, expr, Ignore);\n                 return nil(bcx, ty);\n             } else {\n-                let scratch = scratch_datum(bcx, ty, false);\n+                let scratch = scratch_datum(bcx, ty, \"\", false);\n                 bcx = trans_rvalue_dps_unadjusted(\n                     bcx, expr, SaveIn(scratch.val));\n \n@@ -535,7 +530,7 @@ fn trans_rvalue_stmt_unadjusted(bcx: block, expr: @ast::expr) -> block {\n             let dst_datum = unpack_datum!(\n                 bcx, trans_lvalue(bcx, dst));\n             return src_datum.store_to_datum(\n-                bcx, src.id, DROP_EXISTING, dst_datum);\n+                bcx, DROP_EXISTING, dst_datum);\n         }\n         ast::expr_assign_op(callee_id, op, dst, src) => {\n             return trans_assign_op(bcx, expr, callee_id, op, dst, src);\n@@ -638,7 +633,15 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n             return trans_into(bcx, blk, dest);\n         }\n         ast::expr_copy(a) => {\n-            return trans_into(bcx, a, dest);\n+            // If we just called `trans_into(bcx, a, dest)`, then this\n+            // might *move* the value into `dest` if the value is\n+            // non-copyable. So first get a datum and then do an\n+            // explicit copy.\n+            let datumblk = trans_to_datum(bcx, a);\n+            return match dest {\n+                Ignore => datumblk.bcx,\n+                SaveIn(llval) => datumblk.copy_to(INIT, llval)\n+            };\n         }\n         ast::expr_call(f, ref args, _) => {\n             return callee::trans_call(\n@@ -1221,6 +1224,7 @@ fn trans_adt(bcx: block, repr: &adt::Repr, discr: int,\n                 bcx = trans_into(bcx, e, Ignore);\n             }\n             for optbase.iter().advance |sbi| {\n+                // FIXME #7261: this moves entire base, not just certain fields\n                 bcx = trans_into(bcx, sbi.expr, Ignore);\n             }\n             return bcx;\n@@ -1245,7 +1249,7 @@ fn trans_adt(bcx: block, repr: &adt::Repr, discr: int,\n                 adt::trans_field_ptr(bcx, repr, srcval, discr, i)\n             };\n             let dest = adt::trans_field_ptr(bcx, repr, addr, discr, i);\n-            bcx = datum.store_to(bcx, base.expr.id, INIT, dest);\n+            bcx = datum.store_to(bcx, INIT, dest);\n         }\n     }\n \n@@ -1687,7 +1691,7 @@ fn trans_assign_op(bcx: block,\n     // A user-defined operator method\n     if bcx.ccx().maps.method_map.find(&expr.id).is_some() {\n         // FIXME(#2528) evaluates the receiver twice!!\n-        let scratch = scratch_datum(bcx, dst_datum.ty, false);\n+        let scratch = scratch_datum(bcx, dst_datum.ty, \"__assign_op\", false);\n         let bcx = trans_overloaded_op(bcx,\n                                       expr,\n                                       callee_id,"}, {"sha": "bdae222059894694ce15ad9aa41889a2e70af7fa", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -195,14 +195,15 @@ fn build_wrap_fn_(ccx: @mut CrateContext,\n     if needs_c_return && !ty::type_is_immediate(ccx.tcx, tys.fn_sig.output) {\n         let lloutputtype = type_of::type_of(fcx.ccx, tys.fn_sig.output);\n         fcx.llretptr = Some(alloca(raw_block(fcx, false, fcx.llstaticallocas),\n-                                   lloutputtype));\n+                                   lloutputtype,\n+                                   \"\"));\n     }\n \n     let bcx = top_scope_block(fcx, None);\n     let lltop = bcx.llbb;\n \n     // Allocate the struct and write the arguments into it.\n-    let llargbundle = alloca(bcx, tys.bundle_ty);\n+    let llargbundle = alloca(bcx, tys.bundle_ty, \"__llargbundle\");\n     arg_builder(bcx, tys, llwrapfn, llargbundle);\n \n     // Create call itself.\n@@ -732,7 +733,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n \n                 let llsrcval = get_param(decl, first_real_arg);\n                 let llsrcptr = if ty::type_is_immediate(ccx.tcx, in_type) {\n-                    let llsrcptr = alloca(bcx, llintype);\n+                    let llsrcptr = alloca(bcx, llintype, \"__llsrcptr\");\n                     Store(bcx, llsrcval, llsrcptr);\n                     llsrcptr\n                 } else {"}, {"sha": "25e73fd640d43cb916c8ba4d90e6ef6bb185ebf9", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -132,7 +132,7 @@ pub fn free_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n       ty::ty_evec(_, ty::vstore_box) |\n       ty::ty_estr(ty::vstore_box) |\n       ty::ty_opaque_closure_ptr(_) => {\n-        let vp = alloca(bcx, type_of(bcx.ccx(), t));\n+        let vp = alloca(bcx, type_of(bcx.ccx(), t), \"\");\n         Store(bcx, v, vp);\n         free_ty(bcx, vp, t)\n       }"}, {"sha": "0914e61d58f33893142a15db6e0baefe681a7f5a", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -614,7 +614,8 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n     }\n \n     llself = PointerCast(bcx, llself, Type::opaque_box(ccx).ptr_to());\n-    let scratch = scratch_datum(bcx, ty::mk_opaque_box(bcx.tcx()), false);\n+    let scratch = scratch_datum(bcx, ty::mk_opaque_box(bcx.tcx()),\n+                                \"__trait_callee\", false);\n     Store(bcx, llself, scratch.val);\n     scratch.add_clean(bcx);\n "}, {"sha": "a3b544dbc6195b7c18dde6364f4a2c774bf09303", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -57,7 +57,7 @@ impl Reflector {\n         let bcx = self.bcx;\n         let str_vstore = ty::vstore_slice(ty::re_static);\n         let str_ty = ty::mk_estr(bcx.tcx(), str_vstore);\n-        let scratch = scratch_datum(bcx, str_ty, false);\n+        let scratch = scratch_datum(bcx, str_ty, \"\", false);\n         let len = C_uint(bcx.ccx(), s.len() + 1);\n         let c_str = PointerCast(bcx, C_cstr(bcx.ccx(), s), Type::i8p());\n         Store(bcx, c_str, GEPi(bcx, scratch.val, [ 0, 0 ]));"}, {"sha": "825320b9ff6369fcce554da3887db590da776108", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -332,7 +332,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: block, heap: heap, vstore_expr: @ast::e\n                     let llptrval = PointerCast(bcx, llptrval, Type::i8p());\n                     let llsizeval = C_uint(bcx.ccx(), s.len());\n                     let typ = ty::mk_estr(bcx.tcx(), ty::vstore_uniq);\n-                    let lldestval = scratch_datum(bcx, typ, false);\n+                    let lldestval = scratch_datum(bcx, typ, \"\", false);\n                     let bcx = callee::trans_lang_call(\n                         bcx,\n                         bcx.tcx().lang_items.strdup_uniq_fn(),\n@@ -454,7 +454,7 @@ pub fn write_content(bcx: block,\n \n                     let loop_counter = {\n                         // i = 0\n-                        let i = alloca(loop_bcx, bcx.ccx().int_type);\n+                        let i = alloca(loop_bcx, bcx.ccx().int_type, \"__i\");\n                         Store(loop_bcx, C_uint(bcx.ccx(), 0), i);\n \n                         Br(loop_bcx, cond_bcx.llbb);"}, {"sha": "1804a7334f23fb4d37475e763ce3be7c76395a9d", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -120,7 +120,7 @@ fn root(datum: &Datum,\n     // First, root the datum. Note that we must zero this value,\n     // because sometimes we root on one path but not another.\n     // See e.g. #4904.\n-    let scratch = scratch_datum(bcx, datum.ty, true);\n+    let scratch = scratch_datum(bcx, datum.ty, \"__write_guard\", true);\n     datum.copy_to_datum(bcx, INIT, scratch);\n     let cleanup_bcx = find_bcx_for_scope(bcx, root_info.scope);\n     add_clean_temp_mem_in_scope(cleanup_bcx, root_info.scope, scratch.val, scratch.ty);\n@@ -135,7 +135,8 @@ fn root(datum: &Datum,\n             // scratch.val will be NULL should the cleanup get\n             // called without the freezing actually occurring, and\n             // return_to_mut checks for this condition.\n-            let scratch_bits = scratch_datum(bcx, ty::mk_uint(), false);\n+            let scratch_bits = scratch_datum(bcx, ty::mk_uint(),\n+                                             \"__write_guard_bits\", false);\n \n             let freeze_did = match freeze_kind {\n                 DynaImm => bcx.tcx().lang_items.borrow_as_imm_fn(),"}, {"sha": "ac7a9db99e9ac55311b71ebb9c304add836d96a9", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -158,9 +158,9 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n                 None => {\n                     fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                        |expected, actual| {\n-                                                       expected.map_default(~\"\", |&e| {\n+                                                       expected.map_default(~\"\", |e| {\n                         fmt!(\"mismatched types: expected `%s` but found %s\",\n-                             e, actual)})},\n+                             *e, actual)})},\n                              Some(expected), ~\"a structure pattern\",\n                              None);\n                     fcx.write_error(pat.id);\n@@ -200,9 +200,9 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n         _ => {\n             fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                |expected, actual| {\n-                                               expected.map_default(~\"\", |&e| {\n+                                               expected.map_default(~\"\", |e| {\n                     fmt!(\"mismatched types: expected `%s` but found %s\",\n-                         e, actual)})},\n+                         *e, actual)})},\n                     Some(expected), ~\"an enum or structure pattern\",\n                     None);\n             fcx.write_error(pat.id);\n@@ -534,9 +534,9 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n                     _ => ty::terr_mismatch\n                 };\n                 fcx.infcx().type_error_message_str_with_expected(pat.span, |expected, actual| {\n-                expected.map_default(~\"\", |&e| {\n+                expected.map_default(~\"\", |e| {\n                     fmt!(\"mismatched types: expected `%s` but found %s\",\n-                                     e, actual)})}, Some(expected), ~\"tuple\", Some(&type_error));\n+                                     *e, actual)})}, Some(expected), ~\"tuple\", Some(&type_error));\n                 fcx.write_error(pat.id);\n             }\n         }\n@@ -583,9 +583,9 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n               fcx.infcx().type_error_message_str_with_expected(\n                   pat.span,\n                   |expected, actual| {\n-                      expected.map_default(~\"\", |&e| {\n+                      expected.map_default(~\"\", |e| {\n                           fmt!(\"mismatched types: expected `%s` but found %s\",\n-                               e, actual)})},\n+                               *e, actual)})},\n                   Some(expected),\n                   ~\"a vector pattern\",\n                   None);\n@@ -641,9 +641,9 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n             fcx.infcx().type_error_message_str_with_expected(\n                 span,\n                 |expected, actual| {\n-                    expected.map_default(~\"\", |&e| {\n+                    expected.map_default(~\"\", |e| {\n                         fmt!(\"mismatched types: expected `%s` but found %s\",\n-                             e, actual)})},\n+                             *e, actual)})},\n                 Some(expected),\n                 fmt!(\"%s pattern\", match pointer_kind {\n                     Managed => \"an @-box\","}, {"sha": "d59c8e5e894fbd0e1d2ca1985341d2e089e6e962", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -350,10 +350,7 @@ pub fn resolve_type_vars_in_fn(fcx: @mut FnCtxt,\n                                    self_info.self_id);\n     }\n     for decl.inputs.iter().advance |arg| {\n-        do pat_util::pat_bindings(fcx.tcx().def_map, arg.pat)\n-                |_bm, pat_id, span, _path| {\n-            resolve_type_vars_for_node(wbcx, span, pat_id);\n-        }\n+        (visit.visit_pat)(arg.pat, (wbcx, visit));\n         // Privacy needs the type for the whole pattern, not just each binding\n         if !pat_util::pat_is_binding(fcx.tcx().def_map, arg.pat) {\n             resolve_type_vars_for_node(wbcx, arg.pat.span, arg.pat.id);"}, {"sha": "7ee731d4f46b47daef8a5cb87ebf809b45f23a12", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -209,7 +209,7 @@ impl CoherenceChecker {\n                 match item.node {\n                     item_impl(_, ref opt_trait, _, _) => {\n                         let opt_trait : ~[trait_ref] = opt_trait.iter()\n-                                                                .transform(|&x| x)\n+                                                                .transform(|x| copy *x)\n                                                                 .collect();\n                         self.check_implementation(item, opt_trait);\n                     }\n@@ -270,7 +270,7 @@ impl CoherenceChecker {\n         // We only want to generate one Impl structure. When we generate one,\n         // we store it here so that we don't recreate it.\n         let mut implementation_opt = None;\n-        for associated_traits.iter().advance |&associated_trait| {\n+        for associated_traits.iter().advance |associated_trait| {\n             let trait_ref =\n                 ty::node_id_to_trait_ref(\n                     self.crate_context.tcx,"}, {"sha": "54ad888e2ae8ca2ee442540202a3dcc2b1774125", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -202,7 +202,7 @@ impl PkgSrc {\n                     crates: &[Crate],\n                     cfgs: &[~str],\n                     what: OutputType) {\n-        for crates.iter().advance |&crate| {\n+        for crates.iter().advance |crate| {\n             let path = &src_dir.push_rel(&crate.file).normalize();\n             note(fmt!(\"build_crates: compiling %s\", path.to_str()));\n             note(fmt!(\"build_crates: destination dir is %s\", dst_dir.to_str()));"}, {"sha": "c6f7735b204e47ac600817e0b7b2a3f8a6b31b5b", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -71,8 +71,8 @@ pub fn make_dir_rwx(p: &Path) -> bool { os::make_dir(p, U_RWX) }\n pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n     let src_dir = workspace.push(\"src\");\n     let dirs = os::list_dir(&src_dir);\n-    for dirs.iter().advance |&p| {\n-        let p = Path(p);\n+    for dirs.iter().advance |p| {\n+        let p = Path(copy *p);\n         debug!(\"=> p = %s\", p.to_str());\n         if !os::path_is_dir(&src_dir.push_rel(&p)) {\n             loop;\n@@ -84,8 +84,8 @@ pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n         }\n         else {\n             let pf = p.filename();\n-            for pf.iter().advance |&pf| {\n-                let f_ = copy pf;\n+            for pf.iter().advance |pf| {\n+                let f_ = copy *pf;\n                 let g = f_.to_str();\n                 match split_version_general(g, '-') {\n                     Some((ref might_match, ref vers)) => {\n@@ -217,10 +217,10 @@ pub fn library_in_workspace(path: &LocalPath, short_name: &str, where: Target,\n     debug!(\"lib_prefix = %s and lib_filetype = %s\", lib_prefix, lib_filetype);\n \n     let mut result_filename = None;\n-    for dir_contents.iter().advance |&p| {\n+    for dir_contents.iter().advance |p| {\n         let mut which = 0;\n         let mut hash = None;\n-        let p_path = Path(p);\n+        let p_path = Path(copy *p);\n         let extension = p_path.filetype();\n         debug!(\"p = %s, p's extension is %?\", p.to_str(), extension);\n         match extension {"}, {"sha": "da5c98680b9199745444b797081c2497b8fd696f", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -194,7 +194,7 @@ pub fn compile_input(ctxt: &Ctx,\n                               Main => ~[]\n                           }\n                           + flags\n-                          + cfgs.flat_map(|&c| { ~[~\"--cfg\", c] }),\n+                          + cfgs.flat_map(|c| { ~[~\"--cfg\", copy *c] }),\n                           driver::optgroups()).get();\n     let options = @session::options {\n         crate_type: crate_type,\n@@ -311,8 +311,8 @@ pub fn compile_crate(ctxt: &Ctx, pkg_id: &PkgId,\n                      what: OutputType) -> bool {\n     debug!(\"compile_crate: crate=%s, dir=%s\", crate.to_str(), dir.to_str());\n     debug!(\"compile_crate: short_name = %s, flags =...\", pkg_id.to_str());\n-    for flags.iter().advance |&fl| {\n-        debug!(\"+++ %s\", fl);\n+    for flags.iter().advance |fl| {\n+        debug!(\"+++ %s\", *fl);\n     }\n     compile_input(ctxt, pkg_id, crate, dir, flags, cfgs, opt, what)\n }"}, {"sha": "2b42c085009df5a5686959b65c47bc7af69252bc", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -142,6 +142,30 @@ pub unsafe fn set_memory<T>(dst: *mut T, c: u8, count: uint) {\n     memset64(dst, c, count as u64);\n }\n \n+/**\n+ * Zeroes out `count * size_of::<T>` bytes of memory at `dst`\n+ */\n+#[inline]\n+#[cfg(not(stage0))]\n+pub unsafe fn zero_memory<T>(dst: *mut T, count: uint) {\n+    set_memory(dst, 0, count);\n+}\n+\n+/**\n+ * Zeroes out `count * size_of::<T>` bytes of memory at `dst`\n+ */\n+#[inline]\n+#[cfg(stage0)]\n+pub unsafe fn zero_memory<T>(dst: *mut T, count: uint) {\n+    let mut count = count * sys::size_of::<T>();\n+    let mut dst = dst as *mut u8;\n+    while count > 0 {\n+        *dst = 0;\n+        dst = mut_offset(dst, 1);\n+        count -= 1;\n+    }\n+}\n+\n /**\n  * Swap the values at two mutable locations of the same type, without\n  * deinitialising or copying either one.\n@@ -172,6 +196,32 @@ pub unsafe fn replace_ptr<T>(dest: *mut T, mut src: T) -> T {\n     src\n }\n \n+/**\n+ * Reads the value from `*src` and returns it. Does not copy `*src`.\n+ */\n+#[inline(always)]\n+pub unsafe fn read_ptr<T>(src: *mut T) -> T {\n+    let mut tmp: T = intrinsics::uninit();\n+    let t: *mut T = &mut tmp;\n+    copy_memory(t, src, 1);\n+    tmp\n+}\n+\n+/**\n+ * Reads the value from `*src` and nulls it out.\n+ * This currently prevents destructors from executing.\n+ */\n+#[inline(always)]\n+pub unsafe fn read_and_zero_ptr<T>(dest: *mut T) -> T {\n+    // Copy the data out from `dest`:\n+    let tmp = read_ptr(dest);\n+\n+    // Now zero out `dest`:\n+    zero_memory(dest, 1);\n+\n+    tmp\n+}\n+\n /// Transform a region pointer - &T - to an unsafe pointer - *T.\n #[inline]\n pub fn to_unsafe_ptr<T>(thing: &T) -> *T {"}, {"sha": "17dc604a178584a49bcdfa04a6f3b8099da1a9a3", "filename": "src/libstd/run.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -715,10 +715,16 @@ fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*c_void) -> T) -> T {\n         let mut tmps = ~[];\n         let mut ptrs = ~[];\n \n-        for es.iter().advance |&(k, v)| {\n-            let kv = @fmt!(\"%s=%s\", k, v);\n-            tmps.push(kv);\n-            ptrs.push(str::as_c_str(*kv, |b| b));\n+        for es.iter().advance |pair| {\n+            // Use of match here is just to workaround limitations\n+            // in the stage0 irrefutable pattern impl.\n+            match pair {\n+                &(ref k, ref v) => {\n+                    let kv = @fmt!(\"%s=%s\", *k, *v);\n+                    tmps.push(kv);\n+                    ptrs.push(str::as_c_str(*kv, |b| b));\n+                }\n+            }\n         }\n \n         ptrs.push(ptr::null());\n@@ -738,8 +744,8 @@ fn with_envp<T>(env: Option<&[(~str, ~str)]>, cb: &fn(*mut c_void) -> T) -> T {\n     match env {\n       Some(es) => {\n         let mut blk = ~[];\n-        for es.iter().advance |&(k, v)| {\n-            let kv = fmt!(\"%s=%s\", k, v);\n+        for es.iter().advance |pair| {\n+            let kv = fmt!(\"%s=%s\", pair.first(), pair.second());\n             blk.push_all(kv.as_bytes_with_null_consume());\n         }\n         blk.push(0);\n@@ -1294,9 +1300,9 @@ mod tests {\n         let output = str::from_bytes(prog.finish_with_output().output);\n \n         let r = os::env();\n-        for r.iter().advance |&(k, v)| {\n+        for r.iter().advance |&(ref k, ref v)| {\n             // don't check windows magical empty-named variables\n-            assert!(k.is_empty() || output.contains(fmt!(\"%s=%s\", k, v)));\n+            assert!(k.is_empty() || output.contains(fmt!(\"%s=%s\", *k, *v)));\n         }\n     }\n     #[test]"}, {"sha": "a69ffca026b86d486c919c6eeac0de08fc623a6f", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 95, "deletions": 41, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -281,16 +281,16 @@ pub trait VectorVector<T> {\n impl<'self, T:Copy> VectorVector<T> for &'self [~[T]] {\n     /// Flattens a vector of slices of T into a single vector of T.\n     pub fn concat_vec(&self) -> ~[T] {\n-        self.flat_map(|&inner| inner)\n+        self.flat_map(|inner| copy *inner)\n     }\n \n     /// Concatenate a vector of vectors, placing a given separator between each.\n     pub fn connect_vec(&self, sep: &T) -> ~[T] {\n         let mut r = ~[];\n         let mut first = true;\n-        for self.iter().advance |&inner| {\n+        for self.iter().advance |inner| {\n             if first { first = false; } else { r.push(copy *sep); }\n-            r.push_all(inner);\n+            r.push_all(copy *inner);\n         }\n         r\n     }\n@@ -1256,16 +1256,15 @@ impl<T> OwnedVector<T> for ~[T] {\n     /// ~~~\n     #[inline]\n     fn push_all_move(&mut self, mut rhs: ~[T]) {\n-        let new_len = self.len() + rhs.len();\n+        let self_len = self.len();\n+        let rhs_len = rhs.len();\n+        let new_len = self_len + rhs_len;\n         self.reserve(new_len);\n-        unsafe {\n-            do rhs.as_mut_buf |p, len| {\n-                for uint::range(0, len) |i| {\n-                    let x = ptr::replace_ptr(ptr::mut_offset(p, i),\n-                                             intrinsics::uninit());\n-                    self.push(x);\n-                }\n-            }\n+        unsafe { // Note: infallible.\n+            let self_p = vec::raw::to_mut_ptr(*self);\n+            let rhs_p = vec::raw::to_ptr(rhs);\n+            ptr::copy_memory(ptr::mut_offset(self_p, self_len), rhs_p, rhs_len);\n+            raw::set_len(self, new_len);\n             raw::set_len(&mut rhs, 0);\n         }\n     }\n@@ -1277,9 +1276,8 @@ impl<T> OwnedVector<T> for ~[T] {\n             ln => {\n                 let valptr = ptr::to_mut_unsafe_ptr(&mut self[ln - 1u]);\n                 unsafe {\n-                    let val = ptr::replace_ptr(valptr, intrinsics::init());\n                     raw::set_len(self, ln - 1u);\n-                    Some(val)\n+                    Some(ptr::read_ptr(valptr))\n                 }\n             }\n         }\n@@ -1410,7 +1408,7 @@ impl<T> OwnedVector<T> for ~[T] {\n             unsafe {\n                 // This loop is optimized out for non-drop types.\n                 for uint::range(newlen, oldlen) |i| {\n-                    ptr::replace_ptr(ptr::mut_offset(p, i), intrinsics::uninit());\n+                    ptr::read_and_zero_ptr(ptr::mut_offset(p, i));\n                 }\n             }\n         }\n@@ -1555,37 +1553,93 @@ pub trait OwnedEqVector<T:Eq> {\n \n impl<T:Eq> OwnedEqVector<T> for ~[T] {\n     /**\n-     * Remove consecutive repeated elements from a vector; if the vector is\n-     * sorted, this removes all duplicates.\n-     */\n+    * Remove consecutive repeated elements from a vector; if the vector is\n+    * sorted, this removes all duplicates.\n+    */\n     pub fn dedup(&mut self) {\n         unsafe {\n-            if self.len() == 0 { return; }\n-            let mut last_written = 0;\n-            let mut next_to_read = 1;\n-            do self.as_mut_buf |p, ln| {\n-                // last_written < next_to_read <= ln\n-                while next_to_read < ln {\n-                    // last_written < next_to_read < ln\n-                    if *ptr::mut_offset(p, next_to_read) ==\n-                        *ptr::mut_offset(p, last_written) {\n-                        ptr::replace_ptr(ptr::mut_offset(p, next_to_read),\n-                                         intrinsics::uninit());\n-                    } else {\n-                        last_written += 1;\n-                        // last_written <= next_to_read < ln\n-                        if next_to_read != last_written {\n-                            ptr::swap_ptr(ptr::mut_offset(p, last_written),\n-                                          ptr::mut_offset(p, next_to_read));\n-                        }\n+            // Although we have a mutable reference to `self`, we cannot make\n+            // *arbitrary* changes. There exists the possibility that this\n+            // vector is contained with an `@mut` box and hence is still\n+            // readable by the outside world during the `Eq` comparisons.\n+            // Moreover, those comparisons could fail, so we must ensure\n+            // that the vector is in a valid state at all time.\n+            //\n+            // The way that we handle this is by using swaps; we iterate\n+            // over all the elements, swapping as we go so that at the end\n+            // the elements we wish to keep are in the front, and those we\n+            // wish to reject are at the back. We can then truncate the\n+            // vector. This operation is still O(n).\n+            //\n+            // Example: We start in this state, where `r` represents \"next\n+            // read\" and `w` represents \"next_write`.\n+            //\n+            //           r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //           w\n+            //\n+            // Comparing self[r] against self[w-1], tis is not a duplicate, so\n+            // we swap self[r] and self[w] (no effect as r==w) and then increment both\n+            // r and w, leaving us with:\n+            //\n+            //               r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //               w\n+            //\n+            // Comparing self[r] against self[w-1], this value is a duplicate,\n+            // so we increment `r` but leave everything else unchanged:\n+            //\n+            //                   r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //               w\n+            //\n+            // Comparing self[r] against self[w-1], this is not a duplicate,\n+            // so swap self[r] and self[w] and advance r and w:\n+            //\n+            //                       r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 2 | 1 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //                   w\n+            //\n+            // Not a duplicate, repeat:\n+            //\n+            //                           r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 2 | 3 | 1 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //                       w\n+            //\n+            // Duplicate, advance r. End of vec. Truncate to w.\n+\n+            let ln = self.len();\n+            if ln < 1 { return; }\n+\n+            // Avoid bounds checks by using unsafe pointers.\n+            let p = vec::raw::to_mut_ptr(*self);\n+            let mut r = 1;\n+            let mut w = 1;\n+\n+            while r < ln {\n+                let p_r = ptr::mut_offset(p, r);\n+                let p_wm1 = ptr::mut_offset(p, w - 1);\n+                if *p_r != *p_wm1 {\n+                    if r != w {\n+                        let p_w = ptr::mut_offset(p_wm1, 1);\n+                        util::swap(&mut *p_r, &mut *p_w);\n                     }\n-                    // last_written <= next_to_read < ln\n-                    next_to_read += 1;\n-                    // last_written < next_to_read <= ln\n+                    w += 1;\n                 }\n+                r += 1;\n             }\n-            // last_written < next_to_read == ln\n-            raw::set_len(self, last_written + 1);\n+\n+            self.truncate(w);\n         }\n     }\n }"}, {"sha": "3bc16477c808a389f26aed88b84d5a4c40eb7864", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -519,8 +519,8 @@ impl<'self> MethodDef<'self> {\n         // create the generics that aren't for Self\n         let fn_generics = self.generics.to_generics(cx, span, type_ident, generics);\n \n-        let args = do arg_types.map |&(id, ty)| {\n-            cx.arg(span, id, ty)\n+        let args = do arg_types.map |pair| {\n+            cx.arg(span, pair.first(), pair.second())\n         };\n \n         let ret_type = self.get_ret_ty(cx, span, generics, type_ident);\n@@ -589,7 +589,7 @@ impl<'self> MethodDef<'self> {\n \n         // transpose raw_fields\n         let fields = match raw_fields {\n-            [self_arg, .. rest] => {\n+            [ref self_arg, .. rest] => {\n                 do self_arg.iter().enumerate().transform |(i, &(opt_id, field))| {\n                     let other_fields = do rest.map |l| {\n                         match &l[i] {\n@@ -738,16 +738,20 @@ impl<'self> MethodDef<'self> {\n \n                     let mut enum_matching_fields = vec::from_elem(self_vec.len(), ~[]);\n \n-                    for matches_so_far.tail().iter().advance |&(_, _, other_fields)| {\n-                        for other_fields.iter().enumerate().advance |(i, &(_, other_field))| {\n-                            enum_matching_fields[i].push(other_field);\n+                    for matches_so_far.tail().iter().advance |triple| {\n+                        match triple {\n+                            &(_, _, ref other_fields) => {\n+                                for other_fields.iter().enumerate().advance |(i, pair)| {\n+                                    enum_matching_fields[i].push(pair.second());\n+                                }\n+                            }\n                         }\n                     }\n                     let field_tuples =\n                         do self_vec.iter()\n                            .zip(enum_matching_fields.iter())\n-                           .transform |(&(id, self_f), &other)| {\n-                        (id, self_f, other)\n+                           .transform |(&(id, self_f), other)| {\n+                        (id, self_f, copy *other)\n                     }.collect();\n                     substructure = EnumMatching(variant_index, variant, field_tuples);\n                 }\n@@ -892,8 +896,8 @@ pub fn create_subpatterns(cx: @ExtCtxt,\n                           field_paths: ~[ast::Path],\n                           mutbl: ast::mutability)\n                    -> ~[@ast::pat] {\n-    do field_paths.map |&path| {\n-        cx.pat(span, ast::pat_ident(ast::bind_by_ref(mutbl), path, None))\n+    do field_paths.map |path| {\n+        cx.pat(span, ast::pat_ident(ast::bind_by_ref(mutbl), copy *path, None))\n     }\n }\n \n@@ -1015,19 +1019,22 @@ left-to-right (`true`) or right-to-left (`false`).\n pub fn cs_fold(use_foldl: bool,\n                f: &fn(@ExtCtxt, span,\n                       old: @expr,\n-                      self_f: @expr, other_fs: &[@expr]) -> @expr,\n+                      self_f: @expr,\n+                      other_fs: &[@expr]) -> @expr,\n                base: @expr,\n                enum_nonmatch_f: EnumNonMatchFunc,\n                cx: @ExtCtxt, span: span,\n                substructure: &Substructure) -> @expr {\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             if use_foldl {\n-                do all_fields.iter().fold(base) |old, &(_, self_f, other_fs)| {\n+                do all_fields.iter().fold(base) |old, triple| {\n+                    let (_, self_f, other_fs) = copy *triple;\n                     f(cx, span, old, self_f, other_fs)\n                 }\n             } else {\n-                do all_fields.rev_iter().fold(base) |old, &(_, self_f, other_fs)| {\n+                do all_fields.rev_iter().fold(base) |old, triple| {\n+                    let (_, self_f, other_fs) = copy *triple;\n                     f(cx, span, old, self_f, other_fs)\n                 }\n             }\n@@ -1059,7 +1066,8 @@ pub fn cs_same_method(f: &fn(@ExtCtxt, span, ~[@expr]) -> @expr,\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             // call self_n.method(other_1_n, other_2_n, ...)\n-            let called = do all_fields.map |&(_, self_field, other_fields)| {\n+            let called = do all_fields.map |triple| {\n+                let (_, self_field, other_fields) = copy *triple;\n                 cx.expr_method_call(span,\n                                     self_field,\n                                     substructure.method_ident,"}, {"sha": "478c086199011424f5e10ae57a733d7d9bebff93", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -137,7 +137,7 @@ impl gen_send for message {\n                 let arg_names = vec::from_fn(tys.len(), |i| \"x_\" + i.to_str());\n \n                 let args_ast: ~[ast::arg] = arg_names.iter().zip(tys.iter())\n-                    .transform(|(&n, t)| cx.arg(span, cx.ident_of(n), copy *t)).collect();\n+                    .transform(|(n, t)| cx.arg(span, cx.ident_of(*n), copy *t)).collect();\n \n                 let args_ast = vec::append(\n                     ~[cx.arg(span,"}, {"sha": "75424b60390d733ea33f64799733ed76eaae81db", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -215,8 +215,8 @@ pub fn visit<Tproto, Tstate, Tmessage, V: visitor<Tproto, Tstate, Tmessage>>(\n \n     // the copy keywords prevent recursive use of dvec\n     let states: ~[Tstate] = do (copy proto.states).iter().transform |&s| {\n-        let messages: ~[Tmessage] = do (copy s.messages).iter().transform |&m| {\n-            let message(name, span, tys, this, next) = m;\n+        let messages: ~[Tmessage] = do (copy s.messages).iter().transform |m| {\n+            let message(name, span, tys, this, next) = copy *m;\n             visitor.visit_message(name, span, tys, this, next)\n         }.collect();\n         visitor.visit_state(s, messages)"}, {"sha": "8666c84bbefe13152da362ade3a2ac9633643e0b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -3914,7 +3914,7 @@ impl Parser {\n         };\n         let full_path = full_path.normalize();\n \n-        let maybe_i = do self.sess.included_mod_stack.iter().position |&p| { p == full_path };\n+        let maybe_i = do self.sess.included_mod_stack.iter().position |p| { *p == full_path };\n         match maybe_i {\n             Some(i) => {\n                 let stack = &self.sess.included_mod_stack;"}, {"sha": "c37108536154d87454ea80de13a67f0f2bc9d0d1", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 23, "deletions": 33, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -147,7 +147,7 @@ pub fn ty_to_str(ty: &ast::Ty, intr: @ident_interner) -> ~str {\n }\n \n pub fn pat_to_str(pat: &ast::pat, intr: @ident_interner) -> ~str {\n-    to_str(pat, print_irrefutable_pat, intr)\n+    to_str(pat, print_pat, intr)\n }\n \n pub fn expr_to_str(e: &ast::expr, intr: @ident_interner) -> ~str {\n@@ -1240,7 +1240,7 @@ pub fn print_expr(s: @ps, expr: &ast::expr) {\n                 if first {\n                     first = false;\n                 } else { space(s.s); word_space(s, \"|\"); }\n-                print_refutable_pat(s, *p);\n+                print_pat(s, *p);\n             }\n             space(s.s);\n             match arm.guard {\n@@ -1434,7 +1434,7 @@ pub fn print_expr(s: @ps, expr: &ast::expr) {\n }\n \n pub fn print_local_decl(s: @ps, loc: &ast::local) {\n-    print_irrefutable_pat(s, loc.node.pat);\n+    print_pat(s, loc.node.pat);\n     match loc.node.ty.node {\n       ast::ty_infer => (),\n       _ => { word_space(s, \":\"); print_type(s, &loc.node.ty); }\n@@ -1526,15 +1526,7 @@ pub fn print_bounded_path(s: @ps, path: &ast::Path,\n     print_path_(s, path, false, bounds)\n }\n \n-pub fn print_irrefutable_pat(s: @ps, pat: &ast::pat) {\n-    print_pat(s, pat, false)\n-}\n-\n-pub fn print_refutable_pat(s: @ps, pat: &ast::pat) {\n-    print_pat(s, pat, true)\n-}\n-\n-pub fn print_pat(s: @ps, pat: &ast::pat, refutable: bool) {\n+pub fn print_pat(s: @ps, pat: &ast::pat) {\n     maybe_print_comment(s, pat.span.lo);\n     let ann_node = node_pat(s, pat);\n     (s.ann.pre)(ann_node);\n@@ -1543,20 +1535,18 @@ pub fn print_pat(s: @ps, pat: &ast::pat, refutable: bool) {\n     match pat.node {\n       ast::pat_wild => word(s.s, \"_\"),\n       ast::pat_ident(binding_mode, ref path, sub) => {\n-          if refutable {\n-              match binding_mode {\n-                  ast::bind_by_ref(mutbl) => {\n-                      word_nbsp(s, \"ref\");\n-                      print_mutability(s, mutbl);\n-                  }\n-                  ast::bind_infer => {}\n+          match binding_mode {\n+              ast::bind_by_ref(mutbl) => {\n+                  word_nbsp(s, \"ref\");\n+                  print_mutability(s, mutbl);\n               }\n+              ast::bind_infer => {}\n           }\n           print_path(s, path, true);\n           match sub {\n               Some(p) => {\n                   word(s.s, \"@\");\n-                  print_pat(s, p, refutable);\n+                  print_pat(s, p);\n               }\n               None => ()\n           }\n@@ -1569,7 +1559,7 @@ pub fn print_pat(s: @ps, pat: &ast::pat, refutable: bool) {\n             if !args.is_empty() {\n               popen(s);\n               commasep(s, inconsistent, *args,\n-                       |s, &p| print_pat(s, p, refutable));\n+                       |s, &p| print_pat(s, p));\n               pclose(s);\n             } else { }\n           }\n@@ -1578,16 +1568,16 @@ pub fn print_pat(s: @ps, pat: &ast::pat, refutable: bool) {\n       ast::pat_struct(ref path, ref fields, etc) => {\n         print_path(s, path, true);\n         word(s.s, \"{\");\n-        fn print_field(s: @ps, f: &ast::field_pat, refutable: bool) {\n+        fn print_field(s: @ps, f: &ast::field_pat) {\n             cbox(s, indent_unit);\n             print_ident(s, f.ident);\n             word_space(s, \":\");\n-            print_pat(s, f.pat, refutable);\n+            print_pat(s, f.pat);\n             end(s);\n         }\n         fn get_span(f: &ast::field_pat) -> codemap::span { return f.pat.span; }\n         commasep_cmnt(s, consistent, *fields,\n-                      |s, f| print_field(s,f,refutable),\n+                      |s, f| print_field(s,f),\n                       get_span);\n         if etc {\n             if fields.len() != 0u { word_space(s, \",\"); }\n@@ -1597,23 +1587,23 @@ pub fn print_pat(s: @ps, pat: &ast::pat, refutable: bool) {\n       }\n       ast::pat_tup(ref elts) => {\n         popen(s);\n-        commasep(s, inconsistent, *elts, |s, &p| print_pat(s, p, refutable));\n+        commasep(s, inconsistent, *elts, |s, &p| print_pat(s, p));\n         if elts.len() == 1 {\n             word(s.s, \",\");\n         }\n         pclose(s);\n       }\n       ast::pat_box(inner) => {\n           word(s.s, \"@\");\n-          print_pat(s, inner, refutable);\n+          print_pat(s, inner);\n       }\n       ast::pat_uniq(inner) => {\n           word(s.s, \"~\");\n-          print_pat(s, inner, refutable);\n+          print_pat(s, inner);\n       }\n       ast::pat_region(inner) => {\n           word(s.s, \"&\");\n-          print_pat(s, inner, refutable);\n+          print_pat(s, inner);\n       }\n       ast::pat_lit(e) => print_expr(s, e),\n       ast::pat_range(begin, end) => {\n@@ -1625,16 +1615,16 @@ pub fn print_pat(s: @ps, pat: &ast::pat, refutable: bool) {\n       ast::pat_vec(ref before, slice, ref after) => {\n         word(s.s, \"[\");\n         do commasep(s, inconsistent, *before) |s, &p| {\n-            print_pat(s, p, refutable);\n+            print_pat(s, p);\n         }\n         for slice.iter().advance |&p| {\n             if !before.is_empty() { word_space(s, \",\"); }\n             word(s.s, \"..\");\n-            print_pat(s, p, refutable);\n+            print_pat(s, p);\n             if !after.is_empty() { word_space(s, \",\"); }\n         }\n         do commasep(s, inconsistent, *after) |s, &p| {\n-            print_pat(s, p, refutable);\n+            print_pat(s, p);\n         }\n         word(s.s, \"]\");\n       }\n@@ -1888,7 +1878,7 @@ pub fn print_arg(s: @ps, input: &ast::arg) {\n         word_space(s, \"mut\");\n     }\n     match input.ty.node {\n-      ast::ty_infer => print_irrefutable_pat(s, input.pat),\n+      ast::ty_infer => print_pat(s, input.pat),\n       _ => {\n         match input.pat.node {\n             ast::pat_ident(_, ref path, _) if\n@@ -1897,7 +1887,7 @@ pub fn print_arg(s: @ps, input: &ast::arg) {\n                 // Do nothing.\n             }\n             _ => {\n-                print_irrefutable_pat(s, input.pat);\n+                print_pat(s, input.pat);\n                 word(s.s, \":\");\n                 space(s.s);\n             }"}, {"sha": "012333b931ec7005a9c1efabc193be12df750fec", "filename": "src/rt/boxed_region.cpp", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Frt%2Fboxed_region.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Frt%2Fboxed_region.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fboxed_region.cpp?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -39,10 +39,6 @@ rust_opaque_box *boxed_region::malloc(type_desc *td, size_t body_size) {\n rust_opaque_box *boxed_region::realloc(rust_opaque_box *box,\n                                        size_t new_size) {\n \n-    // We also get called on the unique-vec-in-managed-heap path.\n-    assert(box->ref_count == 1 ||\n-           box->ref_count == (size_t)(-2));\n-\n     size_t total_size = new_size + sizeof(rust_opaque_box);\n     rust_opaque_box *new_box =\n         (rust_opaque_box*)backing_region->realloc(box, total_size);"}, {"sha": "919c4daeb253bbe1a8f67de3484b4f13357397d4", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -56,8 +56,8 @@ fn sort_and_fmt(mm: &HashMap<~[u8], uint>, total: uint) -> ~str {\n    let mut pairs = ~[];\n \n    // map -> [(k,%)]\n-   for mm.iter().advance |(&key, &val)| {\n-      pairs.push((key, pct(val, total)));\n+   for mm.iter().advance |(key, &val)| {\n+      pairs.push((copy *key, pct(val, total)));\n    }\n \n    let pairs_sorted = sortKV(pairs);"}, {"sha": "c99a1ee60d7fd39bc496866b6c90cb7e54c9df10", "filename": "src/test/compile-fail/borrowck-move-in-irrefut-pat.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Fcompile-fail%2Fborrowck-move-in-irrefut-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Fcompile-fail%2Fborrowck-move-in-irrefut-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-in-irrefut-pat.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -0,0 +1,16 @@\n+fn with(f: &fn(&~str)) {}\n+\n+fn arg_item(&_x: &~str) {}\n+    //~^ ERROR cannot move out of dereference of & pointer\n+\n+fn arg_closure() {\n+    with(|&_x| ())\n+    //~^ ERROR cannot move out of dereference of & pointer\n+}\n+\n+fn let_pat() {\n+    let &_x = &~\"hi\";\n+    //~^ ERROR cannot move out of dereference of & pointer\n+}\n+\n+pub fn main() {}\n\\ No newline at end of file"}, {"sha": "4407329f49775876f027132e63bfc287da426620", "filename": "src/test/compile-fail/borrowck-move-out-of-struct-with-dtor.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-struct-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-struct-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-struct-with-dtor.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -0,0 +1,22 @@\n+struct S {f:~str}\n+impl Drop for S {\n+    fn drop(&self) { println(self.f); }\n+}\n+\n+fn move_in_match() {\n+    match S {f:~\"foo\"} {\n+        S {f:_s} => {}\n+        //~^ ERROR cannot move out of type `S`, which defines the `Drop` trait\n+    }\n+}\n+\n+fn move_in_let() {\n+    let S {f:_s} = S {f:~\"foo\"};\n+    //~^ ERROR cannot move out of type `S`, which defines the `Drop` trait\n+}\n+\n+fn move_in_fn_arg(S {f:_s}: S) {\n+    //~^ ERROR cannot move out of type `S`, which defines the `Drop` trait\n+}\n+\n+fn main() {}"}, {"sha": "400a4f07951fc120480feb44822f252465edb123", "filename": "src/test/compile-fail/borrowck-move-out-of-tuple-struct-with-dtor.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-tuple-struct-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-tuple-struct-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-tuple-struct-with-dtor.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -0,0 +1,22 @@\n+struct S(~str);\n+impl Drop for S {\n+    fn drop(&self) { println(**self); }\n+}\n+\n+fn move_in_match() {\n+    match S(~\"foo\") {\n+        S(_s) => {}\n+        //~^ ERROR cannot move out of type `S`, which defines the `Drop` trait\n+    }\n+}\n+\n+fn move_in_let() {\n+    let S(_s) = S(~\"foo\");\n+    //~^ ERROR cannot move out of type `S`, which defines the `Drop` trait\n+}\n+\n+fn move_in_fn_arg(S(_s): S) {\n+    //~^ ERROR cannot move out of type `S`, which defines the `Drop` trait\n+}\n+\n+fn main() {}"}, {"sha": "91a3d843cd4ac2f57d1de1d68c629a5967737f5d", "filename": "src/test/compile-fail/borrowck-move-out-of-vec-tail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -11,7 +11,7 @@ pub fn main() {\n         Foo { string: ~\"baz\" }\n     ];\n     match x {\n-        [first, ..tail] => {\n+        [_, ..tail] => {\n             match tail {\n                 [Foo { string: a }, Foo { string: b }] => {\n                     //~^ ERROR cannot move out of dereference of & pointer"}, {"sha": "36ae5f88208929397a0c82a73c237f30e15c3186", "filename": "src/test/compile-fail/borrowck-vec-pattern-nesting.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -17,4 +17,41 @@ fn b() {\n     }\n }\n \n+fn c() {\n+    let mut vec = [~1, ~2, ~3];\n+    match vec {\n+        [_a, .._b] => {\n+            //~^ ERROR cannot move out\n+\n+            // Note: `_a` is *moved* here, but `b` is borrowing,\n+            // hence illegal.\n+            //\n+            // See comment in middle/borrowck/gather_loans/mod.rs\n+            // in the case covering these sorts of vectors.\n+        }\n+        _ => {}\n+    }\n+    let a = vec[0]; //~ ERROR use of partially moved value: `vec`\n+}\n+\n+fn d() {\n+    let mut vec = [~1, ~2, ~3];\n+    match vec {\n+        [.._a, _b] => {\n+            //~^ ERROR cannot move out\n+        }\n+        _ => {}\n+    }\n+    let a = vec[0]; //~ ERROR use of partially moved value: `vec`\n+}\n+\n+fn e() {\n+    let mut vec = [~1, ~2, ~3];\n+    match vec {\n+        [_a, _b, _c] => {}\n+        _ => {}\n+    }\n+    let a = vec[0]; //~ ERROR use of partially moved value: `vec`\n+}\n+\n fn main() {}"}, {"sha": "f90fe924587dfe3b519acc34f6e51b058610a37c", "filename": "src/test/compile-fail/regions-ref-in-fn-arg.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Fcompile-fail%2Fregions-ref-in-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Fcompile-fail%2Fregions-ref-in-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ref-in-fn-arg.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -0,0 +1,11 @@\n+fn arg_item(~ref x: ~int) -> &'static int {\n+    x //~^ ERROR borrowed value does not live long enough\n+}\n+\n+fn with<R>(f: &fn(~int) -> R) -> R { f(~3) }\n+\n+fn arg_closure() -> &'static int {\n+    with(|~ref x| x) //~ ERROR borrowed value does not live long enough\n+}\n+\n+fn main() {}\n\\ No newline at end of file"}, {"sha": "92344aae73e6da9fcdcefbf0556c750414609697", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -68,7 +68,7 @@ fn main() {\n     check_pp(ext_cx, *stmt, pprust::print_stmt, ~\"let x = 20;\");\n \n     let pat = quote_pat!(Some(_));\n-    check_pp(ext_cx, pat, pprust::print_refutable_pat, ~\"Some(_)\");\n+    check_pp(ext_cx, pat, pprust::print_pat, ~\"Some(_)\");\n \n }\n "}, {"sha": "5f0c7cad6191c532805ac9cde04c5f3dd9a53b13", "filename": "src/test/run-pass/borrowck-newtype-issue-2573.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/30c8aac677a754e0d4ebc16f261618f15d15a6e2/src%2Ftest%2Frun-pass%2Fborrowck-newtype-issue-2573.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c8aac677a754e0d4ebc16f261618f15d15a6e2/src%2Ftest%2Frun-pass%2Fborrowck-newtype-issue-2573.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-newtype-issue-2573.rs?ref=30c8aac677a754e0d4ebc16f261618f15d15a6e2", "patch": "@@ -1,32 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct foo {bar: baz}\n-\n-struct baz_ {baz: int}\n-\n-type baz = @mut baz_;\n-\n-trait frob {\n-    fn frob(&self);\n-}\n-\n-impl frob for foo {\n-    fn frob(&self) {\n-        really_impure(self.bar);\n-    }\n-}\n-\n-// Override default mode so that we are passing by value\n-fn really_impure(bar: baz) {\n-    bar.baz = 3;\n-}\n-\n-pub fn main() {}"}, {"sha": "5da7a6f2b56cc9f0796456ac746f2e9108f4df13", "filename": "src/test/run-pass/borrowck-wg-autoderef-and-autoborrowvec-combined-issue-6272.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Frun-pass%2Fborrowck-wg-autoderef-and-autoborrowvec-combined-issue-6272.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Frun-pass%2Fborrowck-wg-autoderef-and-autoborrowvec-combined-issue-6272.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-wg-autoderef-and-autoborrowvec-combined-issue-6272.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -28,12 +28,12 @@\n \n \n fn main() {\n-    let a = @mut [3i];\n+    let a = @mut 3i;\n     let b = @mut [a];\n-    let c = @mut b;\n+    let c = @mut [3];\n \n     // this should freeze `a` only\n-    let _x: &mut [int] = c[0];\n+    let _x: &mut int = a;\n \n     // hence these writes should not fail:\n     b[0] = b[0];"}, {"sha": "b08d3beae1bfa0d7103786c3a5cfe23c115a84ef", "filename": "src/test/run-pass/func-arg-incomplete-pattern.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Frun-pass%2Ffunc-arg-incomplete-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Frun-pass%2Ffunc-arg-incomplete-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffunc-arg-incomplete-pattern.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -0,0 +1,20 @@\n+// Test that we do not leak when the arg pattern must drop part of the\n+// argument (in this case, the `y` field).\n+\n+struct Foo {\n+    x: ~uint,\n+    y: ~uint,\n+}\n+\n+fn foo(Foo {x, _}: Foo) -> *uint {\n+    let addr: *uint = &*x;\n+    addr\n+}\n+\n+fn main() {\n+    let obj = ~1;\n+    let objptr: *uint = &*obj;\n+    let f = Foo {x: obj, y: ~2};\n+    let xptr = foo(f);\n+    assert_eq!(objptr, xptr);\n+}\n\\ No newline at end of file"}, {"sha": "84c2b3acf35800f9ea7759b7cb8250ac68a09ac9", "filename": "src/test/run-pass/func-arg-ref-pattern.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Frun-pass%2Ffunc-arg-ref-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Frun-pass%2Ffunc-arg-ref-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffunc-arg-ref-pattern.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -0,0 +1,24 @@\n+// exec-env:RUST_POISON_ON_FREE=1\n+\n+// Test argument patterns where we create refs to the inside of `~`\n+// boxes. Make sure that we don't free the box as we match the\n+// pattern.\n+\n+fn getaddr(~ref x: ~uint) -> *uint {\n+    let addr: *uint = &*x;\n+    addr\n+}\n+\n+fn checkval(~ref x: ~uint) -> uint {\n+    *x\n+}\n+\n+fn main() {\n+    let obj = ~1;\n+    let objptr: *uint = &*obj;\n+    let xptr = getaddr(obj);\n+    assert_eq!(objptr, xptr);\n+\n+    let obj = ~22;\n+    assert_eq!(checkval(obj), 22);\n+}"}, {"sha": "c2d60c8532993dc317da166a0010b66a27d1d883", "filename": "src/test/run-pass/func-arg-wild-pattern.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Frun-pass%2Ffunc-arg-wild-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Frun-pass%2Ffunc-arg-wild-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffunc-arg-wild-pattern.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -0,0 +1,10 @@\n+// Test that we can compile code that uses a `_` in function argument\n+// patterns.\n+\n+fn foo((x, _): (int, int)) -> int {\n+    x\n+}\n+\n+fn main() {\n+    assert_eq!(foo((22, 23)), 22);\n+}"}, {"sha": "7f3f9110b1c5cf3458f4d522cca339684a184ac6", "filename": "src/test/run-pass/let-destruct-ref.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Frun-pass%2Flet-destruct-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Frun-pass%2Flet-destruct-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flet-destruct-ref.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let x = ~\"hello\";\n+    let ref y = x;\n+    assert_eq!(x.slice(0, x.len()), y.slice(0, y.len()));\n+}"}, {"sha": "2a629b62534ecc736c4f744957488e68307f5545", "filename": "src/test/run-pass/match-drop-strs-issue-4541.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Frun-pass%2Fmatch-drop-strs-issue-4541.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Frun-pass%2Fmatch-drop-strs-issue-4541.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-drop-strs-issue-4541.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -0,0 +1,27 @@\n+// Tests a tricky scenario involving string matching,\n+// copying, and moving to ensure that we don't segfault\n+// or double-free, as we were wont to do in the past.\n+\n+use std::io;\n+use std::os;\n+\n+fn parse_args() -> ~str {\n+    let args = os::args();\n+    let mut n = 0;\n+\n+    while n < args.len() {\n+        match copy args[n] {\n+            ~\"-v\" => (),\n+            s => {\n+                return s;\n+            }\n+        }\n+        n += 1;\n+    }\n+\n+    return ~\"\"\n+}\n+\n+fn main() {\n+    io::println(parse_args());\n+}"}, {"sha": "3ce4ef8a94cd589c903976330d0893ae0ddafa40", "filename": "src/test/run-pass/match-pattern-drop.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Frun-pass%2Fmatch-pattern-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Frun-pass%2Fmatch-pattern-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-pattern-drop.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -14,8 +14,11 @@\n enum t { make_t(@int), clam, }\n \n fn foo(s: @int) {\n+    debug!(::std::sys::refcount(s));\n     let count = ::std::sys::refcount(s);\n     let x: t = make_t(s); // ref up\n+    assert_eq!(::std::sys::refcount(s), count + 1u);\n+    debug!(::std::sys::refcount(s));\n \n     match x {\n       make_t(y) => {\n@@ -38,6 +41,5 @@ pub fn main() {\n \n     debug!(\"%u\", ::std::sys::refcount(s));\n     let count2 = ::std::sys::refcount(s);\n-    let _ = ::std::sys::refcount(s); // don't get bitten by last-use.\n     assert_eq!(count, count2);\n }"}, {"sha": "f8c369c2e5f7ecfd1d99e491b07edeec6ec8678b", "filename": "src/test/run-pass/reflect-visit-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-type.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -163,8 +163,8 @@ pub fn main() {\n     visit_ty::<i16>(vv);\n     visit_ty::<~[int]>(vv);\n \n-    for v.types.iter().advance |&s| {\n-        println(fmt!(\"type: %s\", s));\n+    for v.types.iter().advance |s| {\n+        println(fmt!(\"type: %s\", copy *s));\n     }\n     assert_eq!((*v.types).clone(), ~[~\"bool\", ~\"int\", ~\"i8\", ~\"i16\", ~\"[\", ~\"int\", ~\"]\"]);\n }"}, {"sha": "27f4fc833511ae7cf49b00e19cec0131e6199782", "filename": "src/test/run-pass/vec-tail-matching.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48ca3290df992fde2f74ccf5b9f4e36563af8da/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs?ref=a48ca3290df992fde2f74ccf5b9f4e36563af8da", "patch": "@@ -9,7 +9,7 @@ pub fn main() {\n         Foo { string: ~\"baz\" }\n     ];\n     match x {\n-        [first, ..tail] => {\n+        [ref first, ..tail] => {\n             assert!(first.string == ~\"foo\");\n             assert_eq!(tail.len(), 2);\n             assert!(tail[0].string == ~\"bar\");"}]}