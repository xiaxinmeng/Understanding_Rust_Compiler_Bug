{"sha": "9cf35bfbe7b2610ff64c41668403fdb8f36c839c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljZjM1YmZiZTdiMjYxMGZmNjRjNDE2Njg0MDNmZGI4ZjM2YzgzOWM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-04-10T05:33:31Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-05-31T15:24:55Z"}, "message": "rustc_codegen_utils: remove symbol name dumping/checking harness, and mw impl.", "tree": {"sha": "fa37b001fc206031f5b7692097ba7f146625e4c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa37b001fc206031f5b7692097ba7f146625e4c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9cf35bfbe7b2610ff64c41668403fdb8f36c839c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9cf35bfbe7b2610ff64c41668403fdb8f36c839c", "html_url": "https://github.com/rust-lang/rust/commit/9cf35bfbe7b2610ff64c41668403fdb8f36c839c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9cf35bfbe7b2610ff64c41668403fdb8f36c839c/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6386a31c5b940bc5a5a4c49450247454bc002632", "url": "https://api.github.com/repos/rust-lang/rust/commits/6386a31c5b940bc5a5a4c49450247454bc002632", "html_url": "https://github.com/rust-lang/rust/commit/6386a31c5b940bc5a5a4c49450247454bc002632"}], "stats": {"total": 1049, "additions": 11, "deletions": 1038}, "files": [{"sha": "a13bc0e74760ad30eb4a111677b77c8a525e05fd", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9cf35bfbe7b2610ff64c41668403fdb8f36c839c/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9cf35bfbe7b2610ff64c41668403fdb8f36c839c/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=9cf35bfbe7b2610ff64c41668403fdb8f36c839c", "patch": "@@ -2699,7 +2699,6 @@ dependencies = [\n  \"rustc_metadata 0.0.0\",\n  \"rustc_mir 0.0.0\",\n  \"rustc_target 0.0.0\",\n- \"std-mangle-rs 0.1.0 (git+https://github.com/michaelwoerister/std-mangle-rs?rev=e884304cfcb2f636db4d59ca8ad8fa95b983281c)\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n@@ -3336,14 +3335,6 @@ dependencies = [\n  \"unwind 0.0.0\",\n ]\n \n-[[package]]\n-name = \"std-mangle-rs\"\n-version = \"0.1.0\"\n-source = \"git+https://github.com/michaelwoerister/std-mangle-rs?rev=e884304cfcb2f636db4d59ca8ad8fa95b983281c#e884304cfcb2f636db4d59ca8ad8fa95b983281c\"\n-dependencies = [\n- \"unic-idna-punycode 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"string_cache\"\n version = \"0.7.3\"\n@@ -3858,11 +3849,6 @@ name = \"ucd-util\"\n version = \"0.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"unic-idna-punycode\"\n-version = \"0.7.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"unicase\"\n version = \"2.4.0\"\n@@ -4368,7 +4354,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b73ea3738b47563803ef814925e69be00799a8c07420be8b996f8e98fb2336db\"\n \"checksum socket2 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c4d11a52082057d87cb5caa31ad812f4504b97ab44732cd8359df2e9ff9f48e7\"\n \"checksum stable_deref_trait 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ffbc596e092fe5f598b12ef46cc03754085ac2f4d8c739ad61c4ae266cc3b3fa\"\n-\"checksum std-mangle-rs 0.1.0 (git+https://github.com/michaelwoerister/std-mangle-rs?rev=e884304cfcb2f636db4d59ca8ad8fa95b983281c)\" = \"<none>\"\n \"checksum string_cache 0.7.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"25d70109977172b127fe834e5449e5ab1740b9ba49fa18a2020f509174f25423\"\n \"checksum string_cache_codegen 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1eea1eee654ef80933142157fdad9dd8bc43cf7c74e999e369263496f04ff4da\"\n \"checksum string_cache_shared 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b1884d1bc09741d466d9b14e6d37ac89d6909cbcac41dd9ae982d4d063bbedfc\"\n@@ -4412,7 +4397,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum typenum 1.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"612d636f949607bdf9b123b4a6f6d966dedf3ff669f7f045890d3a4a73948169\"\n \"checksum ucd-trie 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"71a9c5b1fe77426cf144cc30e49e955270f5086e31a6441dfa8b32efc09b9d77\"\n \"checksum ucd-util 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"535c204ee4d8434478593480b8f86ab45ec9aae0e83c568ca81abf0fd0e88f86\"\n-\"checksum unic-idna-punycode 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1b0366615c248bc56ea5ceafe6f71a682f6591e653b1ce61814999302617b8c0\"\n \"checksum unicase 2.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a84e5511b2a947f3ae965dcb29b13b7b1691b6e7332cf5dbc1744138d5acb7f6\"\n \"checksum unicode-bidi 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"49f2bd0c6468a8230e1db229cff8029217cf623c767ea5d60bfbd42729ea54d5\"\n \"checksum unicode-normalization 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6a0180bc61fc5a987082bfa111f4cc95c4caff7f9799f3e46df09163a937aa25\""}, {"sha": "268be2b109114d764fee9e60bb1b107ca8eb073e", "filename": "src/librustc_codegen_utils/Cargo.toml", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cf35bfbe7b2610ff64c41668403fdb8f36c839c/src%2Flibrustc_codegen_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9cf35bfbe7b2610ff64c41668403fdb8f36c839c/src%2Flibrustc_codegen_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2FCargo.toml?ref=9cf35bfbe7b2610ff64c41668403fdb8f36c839c", "patch": "@@ -23,7 +23,3 @@ rustc_target = { path = \"../librustc_target\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_mir = { path = \"../librustc_mir\" }\n-\n-[dependencies.std-mangle-rs]\n-git = \"https://github.com/michaelwoerister/std-mangle-rs\"\n-rev = \"e884304cfcb2f636db4d59ca8ad8fa95b983281c\""}, {"sha": "37847b1b0988f681dd16d77388deb0899500daef", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9cf35bfbe7b2610ff64c41668403fdb8f36c839c/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf35bfbe7b2610ff64c41668403fdb8f36c839c/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=9cf35bfbe7b2610ff64c41668403fdb8f36c839c", "patch": "@@ -100,9 +100,7 @@ use syntax_pos::symbol::InternedString;\n \n use log::debug;\n \n-mod dump;\n mod legacy;\n-mod mw;\n mod v0;\n \n pub fn provide(providers: &mut Providers<'_>) {\n@@ -221,19 +219,9 @@ fn symbol_name(tcx: TyCtxt<'_, 'tcx, 'tcx>, instance: Instance<'tcx>) -> Interne\n     };\n \n     let mangled = match mangling_version {\n-        SymbolManglingVersion::Legacy => legacy::mangle(tcx, instance, instantiating_crate, false),\n-        SymbolManglingVersion::V0 => v0::mangle(tcx, instance, instantiating_crate, true),\n+        SymbolManglingVersion::Legacy => legacy::mangle(tcx, instance, instantiating_crate),\n+        SymbolManglingVersion::V0 => v0::mangle(tcx, instance, instantiating_crate),\n     };\n \n-    let r = InternedString::intern(&mangled);\n-\n-    dump::record(\n-        tcx,\n-        instance,\n-        instantiating_crate,\n-        mangling_version,\n-        mangled,\n-    );\n-\n-    r\n+    InternedString::intern(&mangled)\n }"}, {"sha": "0a60d3895e90c02aebe9d2b3db701f6a3144904d", "filename": "src/librustc_codegen_utils/symbol_names/dump.rs", "status": "removed", "additions": 0, "deletions": 558, "changes": 558, "blob_url": "https://github.com/rust-lang/rust/blob/6386a31c5b940bc5a5a4c49450247454bc002632/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fdump.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6386a31c5b940bc5a5a4c49450247454bc002632/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fdump.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fdump.rs?ref=6386a31c5b940bc5a5a4c49450247454bc002632", "patch": "@@ -1,558 +0,0 @@\n-use rustc::hir::def_id::{CrateNum, DefId};\n-use rustc::hir::map::{DefPathData, DisambiguatedDefPathData};\n-use rustc::session::config::SymbolManglingVersion;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::ty::print::{PrettyPrinter, Printer, Print};\n-use rustc::ty::subst::{Kind, Subst, UnpackedKind};\n-use rustc_mir::monomorphize::Instance;\n-\n-use std::cell::RefCell;\n-use std::fmt::{self, Write as FmtWrite};\n-use std::fs::{self, File};\n-use std::io::Write;\n-use std::ops::Range;\n-use std::path::PathBuf;\n-use std::time::SystemTime;\n-\n-use crate::symbol_names::{legacy, mw, v0};\n-\n-thread_local!(static OUT_DIR: Option<PathBuf> = {\n-    std::env::var_os(\"RUST_SYMBOL_DUMP_DIR\").map(PathBuf::from)\n-});\n-thread_local!(static OUTPUT: RefCell<Option<File>> = RefCell::new(None));\n-\n-pub fn record(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-    instance: Instance<'tcx>,\n-    instantiating_crate: Option<CrateNum>,\n-    mangling_version: SymbolManglingVersion,\n-    mangled: String,\n-) {\n-    let header = \"legacy+generics,legacy,mw,mw+compression,v0,v0+compression\";\n-\n-    // Reuse the already-mangled symbol name that is used by codegen.\n-    let (legacy_mangling, v0_mangling_plus_compression) = match mangling_version {\n-        SymbolManglingVersion::Legacy =>\n-            (mangled, v0::mangle(tcx, instance, instantiating_crate, true)),\n-        SymbolManglingVersion::V0 =>\n-            (legacy::mangle(tcx, instance, instantiating_crate, false), mangled),\n-    };\n-\n-    // Always attempt all the choices of mangling.\n-    let legacy_mangling_plus_generics =\n-        legacy::mangle(tcx, instance, instantiating_crate, true);\n-\n-    let (mw_mangling, mw_mangling_plus_compression) =\n-        mw::mangle(tcx, instance, instantiating_crate)\n-        .unwrap_or((String::new(), String::new()));\n-\n-    let v0_mangling = v0::mangle(tcx, instance, instantiating_crate, false);\n-\n-    OUTPUT.with(|out| {\n-        let mut out = out.borrow_mut();\n-        if out.is_none() {\n-            OUT_DIR.with(|out_dir| {\n-                if let Some(out_dir) = out_dir {\n-                    let mut opts = fs::OpenOptions::new();\n-                    opts.write(true).create_new(true);\n-\n-                    let mut time = SystemTime::now()\n-                        .duration_since(SystemTime::UNIX_EPOCH)\n-                        .map(|d| d.as_secs())\n-                        .unwrap_or(0);\n-                    let mut file = loop {\n-                        let file_path = out_dir.join(format!(\"{}-{}.{}.csv\",\n-                            tcx.crate_name,\n-                            tcx.sess.local_crate_disambiguator(),\n-                            time,\n-                        ));\n-\n-                        match opts.open(&file_path) {\n-                            Ok(file) => break file,\n-                            Err(e) => {\n-                                if e.kind() == std::io::ErrorKind::AlreadyExists {\n-                                    time += 1;\n-                                    continue;\n-                                }\n-                                bug!(\"can't open symbol dump file `{}`: {:?}\",\n-                                    file_path.display(), e);\n-                            }\n-                        }\n-                    };\n-                    writeln!(file, \"{}\", header).unwrap();\n-                    *out = Some(file);\n-                }\n-            })\n-        }\n-\n-        if let Some(out) = out.as_mut() {\n-            writeln!(out, \"{},{},{},{},{},{}\",\n-                legacy_mangling_plus_generics,\n-                legacy_mangling,\n-                mw_mangling,\n-                mw_mangling_plus_compression,\n-                v0_mangling,\n-                v0_mangling_plus_compression,\n-            ).unwrap();\n-        }\n-    });\n-\n-    let def_id = instance.def_id();\n-    // FIXME(eddyb) this should ideally not be needed.\n-    let substs =\n-        tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), instance.substs);\n-\n-    // Build the expected output of demangling, via `ty::print`.\n-    let make_expected_demangling = |alternate| {\n-        let cx = DemanglingPrinter {\n-            tcx,\n-            out: String::new(),\n-            alternate,\n-            in_value: true,\n-            binders: vec![],\n-        };\n-        if instance.is_vtable_shim() {\n-            cx.path_append_ns(\n-                |cx| cx.print_def_path(def_id, substs),\n-                'S',\n-                0,\n-                \"\",\n-            ).unwrap().out\n-        } else {\n-            cx.print_def_path(def_id, substs).unwrap().out\n-        }\n-    };\n-\n-    let expected_demangling_alt = make_expected_demangling(true);\n-    let expected_demangling = make_expected_demangling(false);\n-\n-    for mangling in &[&v0_mangling, &v0_mangling_plus_compression] {\n-        match rustc_demangle::try_demangle(mangling) {\n-            Ok(demangling) => {\n-                let demangling_alt = format!(\"{:#}\", demangling);\n-                if demangling_alt.contains('?') {\n-                    bug!(\"demangle(alt) printing failed for {:?}\\n{:?}\", mangling, demangling_alt);\n-                }\n-                assert_eq!(demangling_alt, expected_demangling_alt);\n-\n-                let demangling = format!(\"{}\", demangling);\n-                if demangling.contains('?') {\n-                    bug!(\"demangle printing failed for {:?}\\n{:?}\", mangling, demangling);\n-                }\n-                assert_eq!(demangling, expected_demangling);\n-            }\n-            Err(_) => bug!(\"try_demangle failed for {:?}\", mangling),\n-        }\n-    }\n-}\n-\n-struct BinderLevel {\n-    lifetime_depths: Range<u32>,\n-}\n-\n-// Our expectation of the output of demangling,\n-// relying on `ty::print` / `PrettyPrinter`.\n-struct DemanglingPrinter<'a, 'tcx> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    out: String,\n-\n-    /// Equivalent to `rustc-demangle`'s `{:#}` printing.\n-    alternate: bool,\n-\n-    in_value: bool,\n-    binders: Vec<BinderLevel>,\n-}\n-\n-impl fmt::Write for DemanglingPrinter<'_, '_> {\n-    fn write_str(&mut self, s: &str) -> fmt::Result {\n-        self.out.write_str(s)\n-    }\n-}\n-\n-impl DemanglingPrinter<'_, '_> {\n-    fn path_append_ns(\n-        mut self,\n-        print_prefix: impl FnOnce(Self) -> Result<Self, fmt::Error>,\n-        ns: char,\n-        disambiguator: u64,\n-        name: &str,\n-    ) -> Result<Self, fmt::Error> {\n-        self = print_prefix(self)?;\n-\n-        if let 'A'..='Z' = ns {\n-            self.write_str(\"::{\")?;\n-            match ns {\n-                'C' => self.write_str(\"closure\")?,\n-                'S' => self.write_str(\"shim\")?,\n-                _ => write!(self, \"{}\", ns)?,\n-            }\n-            if !name.is_empty() {\n-                write!(self, \":{}\", name)?;\n-            }\n-            write!(self, \"#{}\", disambiguator)?;\n-            self.write_str(\"}\")?;\n-        } else {\n-            if !name.is_empty() {\n-                self.write_str(\"::\")?;\n-                self.write_str(&name)?;\n-            }\n-        }\n-\n-        Ok(self)\n-    }\n-\n-    fn print_lifetime_at_depth(&mut self, depth: u64) -> Result<(), fmt::Error> {\n-        if depth < 26 {\n-            write!(self, \"'{}\", (b'a' + depth as u8) as char)\n-        } else {\n-            write!(self, \"'_{}\", depth)\n-        }\n-    }\n-}\n-\n-impl Printer<'tcx, 'tcx> for DemanglingPrinter<'_, 'tcx> {\n-    type Error = fmt::Error;\n-\n-    type Path = Self;\n-    type Region = Self;\n-    type Type = Self;\n-    type DynExistential = Self;\n-    type Const = Self;\n-\n-    fn tcx(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-        self.tcx\n-    }\n-\n-    fn print_impl_path(\n-        self,\n-        impl_def_id: DefId,\n-        substs: &'tcx [Kind<'tcx>],\n-        mut self_ty: Ty<'tcx>,\n-        mut impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n-    ) -> Result<Self::Path, Self::Error> {\n-        let mut param_env = self.tcx.param_env(impl_def_id)\n-            .with_reveal_all();\n-        if !substs.is_empty() {\n-            param_env = param_env.subst(self.tcx, substs);\n-        }\n-\n-        match &mut impl_trait_ref {\n-            Some(impl_trait_ref) => {\n-                assert_eq!(impl_trait_ref.self_ty(), self_ty);\n-                *impl_trait_ref =\n-                    self.tcx.normalize_erasing_regions(param_env, *impl_trait_ref);\n-                self_ty = impl_trait_ref.self_ty();\n-            }\n-            None => {\n-                self_ty = self.tcx.normalize_erasing_regions(param_env, self_ty);\n-            }\n-        }\n-\n-        self.path_qualified(self_ty, impl_trait_ref)\n-    }\n-\n-    fn print_region(\n-        mut self,\n-        region: ty::Region<'_>,\n-    ) -> Result<Self::Region, Self::Error> {\n-        match *region {\n-            ty::ReErased => write!(self, \"'_\")?,\n-\n-            ty::ReLateBound(debruijn, ty::BrAnon(i)) => {\n-                let binder = &self.binders[self.binders.len() - 1 - debruijn.index()];\n-                let depth = binder.lifetime_depths.start + i;\n-                self.print_lifetime_at_depth(depth as u64)?;\n-            }\n-\n-            _ => bug!(\"symbol_names::dump: non-erased region `{:?}`\", region),\n-        }\n-\n-        Ok(self)\n-    }\n-\n-    fn print_type(\n-        mut self,\n-        ty: Ty<'tcx>,\n-    ) -> Result<Self::Type, Self::Error> {\n-        match ty.sty {\n-            // Mangled as paths (unlike `pretty_print_type`).\n-            ty::FnDef(def_id, substs) |\n-            ty::Opaque(def_id, substs) |\n-            ty::Projection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n-            ty::UnnormalizedProjection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n-            ty::Closure(def_id, ty::ClosureSubsts { substs }) |\n-            ty::Generator(def_id, ty::GeneratorSubsts { substs }, _) => {\n-                self.print_def_path(def_id, substs)\n-            }\n-\n-            // Mangled as placeholders.\n-            ty::Param(_) | ty::Bound(..) | ty::Placeholder(_) |\n-            ty::Infer(_) | ty::Error => {\n-                write!(self, \"_\")?;\n-                Ok(self)\n-            }\n-\n-            // Demangled with explicit type for constants (`len` here).\n-            ty::Array(ty, len) if !self.alternate => {\n-                write!(self, \"[\")?;\n-                self = ty.print(self)?;\n-                write!(self, \"; \")?;\n-                if let Some(n) = len.assert_usize(self.tcx()) {\n-                    write!(self, \"{}\", n)?;\n-                } else {\n-                    self = len.print(self)?;\n-                }\n-                write!(self, \": usize]\")?;\n-                Ok(self)\n-            }\n-\n-            // Demangled without anyparens.\n-            ty::Dynamic(data, r) => {\n-                let print_r = self.region_should_not_be_omitted(r);\n-                write!(self, \"dyn \")?;\n-                self = data.print(self)?;\n-                if print_r {\n-                    write!(self, \" + \")?;\n-                    self = r.print(self)?;\n-                }\n-                Ok(self)\n-            }\n-\n-            _ => self.pretty_print_type(ty),\n-        }\n-    }\n-\n-    fn print_dyn_existential(\n-        mut self,\n-        predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n-    ) -> Result<Self::DynExistential, Self::Error> {\n-        // Generate the main trait ref, including associated types.\n-        let mut first = true;\n-\n-        if let Some(principal) = predicates.principal() {\n-            self = self.print_def_path(principal.def_id, &[])?;\n-\n-            // Use a type that can't appear in defaults of type parameters.\n-            let dummy_self = self.tcx().mk_ty_infer(ty::FreshTy(0));\n-            let principal = principal.with_self_ty(self.tcx(), dummy_self);\n-\n-            let args = self.generic_args_to_print(\n-                self.tcx().generics_of(principal.def_id),\n-                principal.substs,\n-            );\n-\n-            // Don't print any regions if they're all erased.\n-            let print_regions = args.iter().any(|arg| {\n-                match arg.unpack() {\n-                    UnpackedKind::Lifetime(r) => *r != ty::ReErased,\n-                    _ => false,\n-                }\n-            });\n-            let mut args = args.iter().cloned().filter(|arg| {\n-                match arg.unpack() {\n-                    UnpackedKind::Lifetime(_) => print_regions,\n-                    _ => true,\n-                }\n-            });\n-            let mut projections = predicates.projection_bounds();\n-\n-            let arg0 = args.next();\n-            let projection0 = projections.next();\n-            if arg0.is_some() || projection0.is_some() {\n-                let args = arg0.into_iter().chain(args);\n-                let projections = projection0.into_iter().chain(projections);\n-\n-                self = self.generic_delimiters(|mut cx| {\n-                    cx = cx.comma_sep(args)?;\n-                    if arg0.is_some() && projection0.is_some() {\n-                        write!(cx, \", \")?;\n-                    }\n-                    cx.comma_sep(projections)\n-                })?;\n-            }\n-            first = false;\n-        }\n-\n-        for def_id in predicates.auto_traits() {\n-            if !first {\n-                write!(self, \" + \")?;\n-            }\n-            first = false;\n-\n-            self = self.print_def_path(def_id, &[])?;\n-        }\n-\n-        Ok(self)\n-    }\n-\n-    fn print_const(\n-        mut self,\n-        ct: &'tcx ty::Const<'tcx>,\n-    ) -> Result<Self::Const, Self::Error> {\n-        if let ty::Uint(_) = ct.ty.sty {\n-            if let Some(bits) = ct.assert_bits(self.tcx, ty::ParamEnv::empty().and(ct.ty)) {\n-                write!(self, \"{}\", bits)?;\n-            } else {\n-                write!(self, \"_\")?;\n-            }\n-        } else {\n-            write!(self, \"_\")?;\n-        }\n-\n-        if !self.alternate {\n-            write!(self, \": \")?;\n-            self = ct.ty.print(self)?;\n-        }\n-\n-        Ok(self)\n-    }\n-\n-    fn path_crate(\n-        mut self,\n-        cnum: CrateNum,\n-    ) -> Result<Self::Path, Self::Error> {\n-        self.write_str(&self.tcx.original_crate_name(cnum).as_str())?;\n-        let fingerprint = self.tcx.crate_disambiguator(cnum).to_fingerprint();\n-        if !self.alternate {\n-            write!(self, \"[{:x}]\", fingerprint.to_smaller_hash())?;\n-        }\n-        Ok(self)\n-    }\n-    fn path_qualified(\n-        self,\n-        self_ty: Ty<'tcx>,\n-        trait_ref: Option<ty::TraitRef<'tcx>>,\n-    ) -> Result<Self::Path, Self::Error> {\n-        self.generic_delimiters(|mut cx| {\n-            cx = self_ty.print(cx)?;\n-            if let Some(trait_ref) = trait_ref {\n-                write!(cx, \" as \")?;\n-                cx = trait_ref.print(cx)?;\n-            }\n-            Ok(cx)\n-        })\n-    }\n-\n-    fn path_append_impl(\n-        self,\n-        _print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-        _disambiguated_data: &DisambiguatedDefPathData,\n-        _self_ty: Ty<'tcx>,\n-        _trait_ref: Option<ty::TraitRef<'tcx>>,\n-    ) -> Result<Self::Path, Self::Error> {\n-        unreachable!()\n-    }\n-    fn path_append(\n-        self,\n-        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-        disambiguated_data: &DisambiguatedDefPathData,\n-    ) -> Result<Self::Path, Self::Error> {\n-        let ns = match disambiguated_data.data {\n-            DefPathData::ClosureExpr => 'C',\n-            _ => '_',\n-        };\n-\n-        let name = disambiguated_data.data.get_opt_name().map(|s| s.as_str());\n-        let name = name.as_ref().map_or(\"\", |s| &s[..]);\n-\n-        self.path_append_ns(\n-            print_prefix,\n-            ns,\n-            disambiguated_data.disambiguator as u64,\n-            name,\n-        )\n-    }\n-    fn path_generic_args(\n-        mut self,\n-        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-        args: &[Kind<'tcx>],\n-    )  -> Result<Self::Path, Self::Error> {\n-        self = print_prefix(self)?;\n-\n-        // Don't print any regions if they're all erased.\n-        let print_regions = args.iter().any(|arg| {\n-            match arg.unpack() {\n-                UnpackedKind::Lifetime(r) => *r != ty::ReErased,\n-                _ => false,\n-            }\n-        });\n-        let args = args.iter().cloned().filter(|arg| {\n-            match arg.unpack() {\n-                UnpackedKind::Lifetime(_) => print_regions,\n-                _ => true,\n-            }\n-        });\n-\n-        if args.clone().next().is_some() {\n-            if self.in_value {\n-                write!(self, \"::\")?;\n-            }\n-            self.generic_delimiters(|cx| cx.comma_sep(args))\n-        } else {\n-            Ok(self)\n-        }\n-    }\n-}\n-\n-impl PrettyPrinter<'tcx, 'tcx> for DemanglingPrinter<'_, 'tcx> {\n-    fn region_should_not_be_omitted(\n-        &self,\n-        region: ty::Region<'_>,\n-    ) -> bool {\n-        *region != ty::ReErased\n-    }\n-\n-    fn generic_delimiters(\n-        mut self,\n-        f: impl FnOnce(Self) -> Result<Self, Self::Error>,\n-    ) -> Result<Self, Self::Error> {\n-        write!(self, \"<\")?;\n-        let was_in_value = ::std::mem::replace(&mut self.in_value, false);\n-        self = f(self)?;\n-        self.in_value = was_in_value;\n-        write!(self, \">\")?;\n-        Ok(self)\n-    }\n-\n-    fn in_binder<T>(\n-        mut self,\n-        value: &ty::Binder<T>,\n-    ) -> Result<Self, Self::Error>\n-        where T: Print<'tcx, 'tcx, Self, Output = Self, Error = Self::Error> + TypeFoldable<'tcx>\n-    {\n-        let regions = if value.has_late_bound_regions() {\n-            self.tcx.collect_referenced_late_bound_regions(value)\n-        } else {\n-            Default::default()\n-        };\n-\n-        let mut lifetime_depths =\n-            self.binders.last().map(|b| b.lifetime_depths.end).map_or(0..0, |i| i..i);\n-\n-        let lifetimes = regions.into_iter().map(|br| {\n-            match br {\n-                ty::BrAnon(i) => i + 1,\n-                _ => bug!(\"symbol_names: non-anonymized region `{:?}` in `{:?}`\", br, value),\n-            }\n-        }).max().unwrap_or(0);\n-\n-        lifetime_depths.end += lifetimes;\n-\n-        if lifetimes > 0 {\n-            write!(self, \"for<\")?;\n-            for i in lifetime_depths.clone() {\n-                if i > lifetime_depths.start {\n-                    write!(self, \", \")?;\n-                }\n-                self.print_lifetime_at_depth(i as u64)?;\n-            }\n-            write!(self, \"> \")?;\n-        }\n-\n-        self.binders.push(BinderLevel { lifetime_depths });\n-        self = value.skip_binder().print(self)?;\n-        self.binders.pop();\n-\n-        Ok(self)\n-    }\n-}"}, {"sha": "53682b9bdc2c8ef47605270d39bfb8b1f754de00", "filename": "src/librustc_codegen_utils/symbol_names/legacy.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9cf35bfbe7b2610ff64c41668403fdb8f36c839c/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf35bfbe7b2610ff64c41668403fdb8f36c839c/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs?ref=9cf35bfbe7b2610ff64c41668403fdb8f36c839c", "patch": "@@ -18,7 +18,6 @@ pub(super) fn mangle(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     instance: Instance<'tcx>,\n     instantiating_crate: Option<CrateNum>,\n-    include_generic_args: bool,\n ) -> String {\n     let def_id = instance.def_id();\n \n@@ -57,17 +56,11 @@ pub(super) fn mangle(\n \n     let hash = get_symbol_hash(tcx, instance, instance_ty, instantiating_crate);\n \n-    let substs = if include_generic_args {\n-        // FIXME(eddyb) this should ideally not be needed.\n-        &tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), instance.substs)[..]\n-    } else {\n-        &[]\n-    };\n     let mut printer = SymbolPrinter {\n         tcx,\n         path: SymbolPath::new(),\n         keep_within_component: false,\n-    }.print_def_path(def_id, substs).unwrap();\n+    }.print_def_path(def_id, &[]).unwrap();\n \n     if instance.is_vtable_shim() {\n         let _ = printer.write_str(\"{{vtable-shim}}\");"}, {"sha": "c0d8fe5445bd9895499809cbfb8190137eb1e6f4", "filename": "src/librustc_codegen_utils/symbol_names/mw.rs", "status": "removed", "additions": 0, "deletions": 421, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/6386a31c5b940bc5a5a4c49450247454bc002632/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fmw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6386a31c5b940bc5a5a4c49450247454bc002632/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fmw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fmw.rs?ref=6386a31c5b940bc5a5a4c49450247454bc002632", "patch": "@@ -1,421 +0,0 @@\n-use std_mangle_rs::ast;\n-\n-use rustc::hir;\n-use rustc::hir::def_id::{CrateNum, DefId};\n-use rustc::hir::map::{DefPathData, DisambiguatedDefPathData};\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::print::{Printer, Print};\n-use rustc::ty::subst::{Kind, UnpackedKind};\n-use rustc_mir::monomorphize::Instance;\n-use rustc_target::spec::abi::Abi;\n-use syntax::ast::{IntTy, UintTy, FloatTy};\n-\n-use std::sync::Arc;\n-\n-pub(super) struct Unsupported;\n-\n-pub(super) fn mangle(\n-    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-    instance: Instance<'tcx>,\n-    instantiating_crate: Option<CrateNum>,\n-) -> Result<(String, String), Unsupported> {\n-    if instance.is_vtable_shim() {\n-        return Err(Unsupported);\n-    }\n-\n-    let symbol = ast::Symbol {\n-        version: None,\n-        path: SymbolPrinter { tcx }\n-            .print_def_path(instance.def_id(), instance.substs)?,\n-        instantiating_crate: match instantiating_crate {\n-            Some(instantiating_crate) => Some(\n-                SymbolPrinter { tcx }\n-                    .path_crate(instantiating_crate)?\n-            ),\n-            None => None,\n-        },\n-    };\n-\n-    let _ = symbol;\n-    unimplemented!(\"missing compressor/mangler for mw symbol mangling\");\n-\n-    /*let mut uncompressed = String::new();\n-    symbol.mangle(&mut uncompressed);\n-\n-    let (compressed_symbol, _) = std_mangle_rs::compress::compress_ext(&symbol);\n-    let mut compressed = String::new();\n-    compressed_symbol.mangle(&mut compressed);\n-\n-    Ok((uncompressed, compressed))*/\n-}\n-\n-#[derive(Copy, Clone)]\n-struct SymbolPrinter<'a, 'tcx> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-}\n-\n-impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n-    type Error = Unsupported;\n-\n-    type Path = ast::Path;\n-    type Region = ast::Lifetime;\n-    type Type = ast::Type;\n-    type DynExistential = ast::DynBounds;\n-    type Const = ast::Const;\n-\n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-        self.tcx\n-    }\n-\n-    fn print_impl_path(\n-        self,\n-        impl_def_id: DefId,\n-        _substs: &[Kind<'tcx>],\n-        self_ty: Ty<'tcx>,\n-        impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n-    ) -> Result<Self::Path, Self::Error> {\n-        let key = self.tcx.def_key(impl_def_id);\n-        let parent_def_id = DefId { index: key.parent.unwrap(), ..impl_def_id };\n-\n-        self.path_append_impl(\n-            |cx| cx.print_def_path(parent_def_id, &[]),\n-            &key.disambiguated_data,\n-            self_ty,\n-            impl_trait_ref,\n-        )\n-    }\n-\n-    fn print_region(\n-        self,\n-        region: ty::Region<'_>,\n-    ) -> Result<Self::Region, Self::Error> {\n-        let i = match *region {\n-            ty::ReErased => 0,\n-\n-            // FIXME(eddyb) copy the implementation over to here.\n-            ty::ReLateBound(_, ty::BrAnon(_)) => {\n-                return Err(Unsupported);\n-            }\n-\n-            _ => bug!(\"mw: non-erased region `{:?}`\", region),\n-        };\n-        Ok(ast::Lifetime {\n-            debruijn_index: ast::Base62Number(i),\n-        })\n-    }\n-\n-    fn print_type(\n-        self,\n-        ty: Ty<'tcx>,\n-    ) -> Result<Self::Type, Self::Error> {\n-        macro_rules! basic {\n-            ($name:ident) => (ast::Type::BasicType(ast::BasicType::$name))\n-        }\n-        Ok(match ty.sty {\n-            ty::Bool => basic!(Bool),\n-            ty::Char => basic!(Char),\n-            ty::Str => basic!(Str),\n-            ty::Tuple(_) if ty.is_unit() => basic!(Unit),\n-            ty::Int(IntTy::I8) => basic!(I8),\n-            ty::Int(IntTy::I16) => basic!(I16),\n-            ty::Int(IntTy::I32) => basic!(I32),\n-            ty::Int(IntTy::I64) => basic!(I64),\n-            ty::Int(IntTy::I128) => basic!(I128),\n-            ty::Int(IntTy::Isize) => basic!(Isize),\n-            ty::Uint(UintTy::U8) => basic!(U8),\n-            ty::Uint(UintTy::U16) => basic!(U16),\n-            ty::Uint(UintTy::U32) => basic!(U32),\n-            ty::Uint(UintTy::U64) => basic!(U64),\n-            ty::Uint(UintTy::U128) => basic!(U128),\n-            ty::Uint(UintTy::Usize) => basic!(Usize),\n-            ty::Float(FloatTy::F32) => basic!(F32),\n-            ty::Float(FloatTy::F64) => basic!(F64),\n-            ty::Never => basic!(Never),\n-\n-            // Placeholders (should be demangled as `_`).\n-            ty::Param(_) | ty::Bound(..) | ty::Placeholder(_) |\n-            ty::Infer(_) | ty::Error => basic!(Placeholder),\n-\n-            ty::Ref(r, ty, mutbl) => {\n-                let lt = if *r != ty::ReErased {\n-                    Some(r.print(self)?)\n-                } else {\n-                    None\n-                };\n-                let ty = Arc::new(ty.print(self)?);\n-                match mutbl {\n-                    hir::MutImmutable => ast::Type::Ref(lt, ty),\n-                    hir::MutMutable => ast::Type::RefMut(lt, ty),\n-                }\n-            }\n-\n-            ty::RawPtr(ty::TypeAndMut { ty, mutbl: hir::MutImmutable }) => {\n-                ast::Type::RawPtrConst(Arc::new(ty.print(self)?))\n-            }\n-            ty::RawPtr(ty::TypeAndMut { ty, mutbl: hir::MutMutable }) => {\n-                ast::Type::RawPtrMut(Arc::new(ty.print(self)?))\n-            }\n-\n-            ty::Array(ty, len) => {\n-                ast::Type::Array(Arc::new(ty.print(self)?), Arc::new(len.print(self)?))\n-            }\n-            ty::Slice(ty) => ast::Type::Slice(Arc::new(ty.print(self)?)),\n-\n-            ty::Tuple(tys) => {\n-                let tys = tys.iter()\n-                    .map(|k| k.expect_ty().print(self))\n-                    .collect::<Result<Vec<_>, _>>()?;\n-                ast::Type::Tuple(tys)\n-            }\n-\n-            // Mangle all nominal types as paths.\n-            ty::Adt(&ty::AdtDef { did: def_id, .. }, substs) |\n-            ty::FnDef(def_id, substs) |\n-            ty::Opaque(def_id, substs) |\n-            ty::Projection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n-            ty::UnnormalizedProjection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n-            ty::Closure(def_id, ty::ClosureSubsts { substs }) |\n-            ty::Generator(def_id, ty::GeneratorSubsts { substs }, _) => {\n-                ast::Type::Named(Arc::new(self.print_def_path(def_id, substs)?))\n-            }\n-            ty::Foreign(def_id) => {\n-                ast::Type::Named(Arc::new(self.print_def_path(def_id, &[])?))\n-            }\n-\n-            ty::FnPtr(sig) => {\n-                let mut param_types = sig.inputs().skip_binder().iter()\n-                    .map(|ty| ty.print(self))\n-                    .collect::<Result<Vec<_>, _>>()?;\n-                if sig.c_variadic() {\n-                    param_types.push(basic!(Ellipsis));\n-                }\n-                let return_type = sig.output().skip_binder().print(self)?;\n-                ast::Type::Fn(Arc::new(ast::FnSig {\n-                    binder: ast::Binder {\n-                        // FIXME(eddyb) needs to be implemented, see `print_region`.\n-                        count: ast::Base62Number(0),\n-                    },\n-                    is_unsafe: sig.unsafety() == hir::Unsafety::Unsafe,\n-                    abi: match sig.abi() {\n-                        Abi::Rust => None,\n-                        Abi::C => Some(ast::Abi::C),\n-                        abi => Some(ast::Abi::Named(ast::UIdent(abi.name().replace('-', \"_\")))),\n-                    },\n-                    param_types,\n-                    return_type,\n-                }))\n-            }\n-\n-            ty::Dynamic(predicates, r) => {\n-                let bounds = Arc::new(self.print_dyn_existential(predicates.skip_binder())?);\n-                let lt = r.print(self)?;\n-                ast::Type::DynTrait(bounds, lt)\n-            }\n-\n-            ty::GeneratorWitness(_) => {\n-                bug!(\"mw: unexpected `GeneratorWitness`\")\n-            }\n-        })\n-    }\n-\n-    fn print_dyn_existential(\n-        self,\n-        predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n-    ) -> Result<Self::DynExistential, Self::Error> {\n-        let mut traits = vec![];\n-        for predicate in predicates {\n-            match *predicate {\n-                ty::ExistentialPredicate::Trait(trait_ref) => {\n-                    // Use a type that can't appear in defaults of type parameters.\n-                    let dummy_self = self.tcx.mk_infer(ty::FreshTy(0));\n-                    let trait_ref = trait_ref.with_self_ty(self.tcx, dummy_self);\n-                    traits.push(ast::DynTrait {\n-                        path: self.print_def_path(trait_ref.def_id, trait_ref.substs)?,\n-                        assoc_type_bindings: vec![],\n-                    });\n-                }\n-                ty::ExistentialPredicate::Projection(projection) => {\n-                    let name = self.tcx.associated_item(projection.item_def_id).ident;\n-                    traits.last_mut().unwrap().assoc_type_bindings.push(ast::DynTraitAssocBinding {\n-                        ident: ast::UIdent(name.to_string()),\n-                        ty: projection.ty.print(self)?,\n-                    });\n-                }\n-                ty::ExistentialPredicate::AutoTrait(def_id) => {\n-                    traits.push(ast::DynTrait {\n-                        path: self.print_def_path(def_id, &[])?,\n-                        assoc_type_bindings: vec![],\n-                    });\n-                }\n-            }\n-        }\n-\n-        Ok(ast::DynBounds {\n-            binder: ast::Binder {\n-                // FIXME(eddyb) needs to be implemented, see `print_region`.\n-                count: ast::Base62Number(0),\n-            },\n-            traits,\n-        })\n-    }\n-\n-    fn print_const(\n-        self,\n-        ct: &'tcx ty::Const<'tcx>,\n-    ) -> Result<Self::Const, Self::Error> {\n-        match ct.ty.sty {\n-            ty::Uint(_) => {}\n-            _ => {\n-                bug!(\"mw: unsupported constant of type `{}` ({:?})\",\n-                    ct.ty, ct);\n-            }\n-        }\n-        let ty = ct.ty.print(self)?;\n-\n-        if let Some(bits) = ct.assert_bits(self.tcx, ty::ParamEnv::empty().and(ct.ty)) {\n-            if bits as u64 as u128 != bits {\n-                return Err(Unsupported);\n-            }\n-            Ok(ast::Const::Value(ty, bits as u64))\n-        } else {\n-            // NOTE(eddyb) despite having the path, we need to\n-            // encode a placeholder, as the path could refer\n-            // back to e.g. an `impl` using the constant.\n-            Ok(ast::Const::Placeholder(ty))\n-        }\n-    }\n-\n-    fn path_crate(\n-        self,\n-        cnum: CrateNum,\n-    ) -> Result<Self::Path, Self::Error> {\n-        let fingerprint = self.tcx.crate_disambiguator(cnum).to_fingerprint();\n-        Ok(ast::Path::CrateRoot {\n-            id: ast::Ident {\n-                dis: ast::Base62Number(fingerprint.to_smaller_hash()),\n-                u_ident: ast::UIdent(self.tcx.original_crate_name(cnum).to_string()),\n-            },\n-        })\n-    }\n-    fn path_qualified(\n-        self,\n-        self_ty: Ty<'tcx>,\n-        trait_ref: Option<ty::TraitRef<'tcx>>,\n-    ) -> Result<Self::Path, Self::Error> {\n-        assert!(trait_ref.is_some());\n-        let trait_ref = trait_ref.unwrap();\n-\n-        // This is a default method in the trait declaration.\n-        Ok(ast::Path::TraitDef {\n-            self_type: self_ty.print(self)?,\n-            trait_name: Arc::new(self.print_def_path(trait_ref.def_id, trait_ref.substs)?),\n-        })\n-    }\n-\n-    fn path_append_impl(\n-        self,\n-        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-        disambiguated_data: &DisambiguatedDefPathData,\n-        self_ty: Ty<'tcx>,\n-        trait_ref: Option<ty::TraitRef<'tcx>>,\n-    ) -> Result<Self::Path, Self::Error> {\n-        let impl_path = ast::ImplPath {\n-            dis: Some(ast::Base62Number(disambiguated_data.disambiguator as u64)),\n-            path: Arc::new(print_prefix(self)?),\n-        };\n-        let self_type = self_ty.print(self)?;\n-        match trait_ref {\n-            Some(trait_ref) => Ok(ast::Path::TraitImpl {\n-                impl_path,\n-                self_type,\n-                trait_name: Arc::new(self.print_def_path(trait_ref.def_id, trait_ref.substs)?),\n-            }),\n-            None => Ok(ast::Path::InherentImpl {\n-                impl_path,\n-                self_type,\n-            }),\n-        }\n-    }\n-    fn path_append(\n-        self,\n-        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-        disambiguated_data: &DisambiguatedDefPathData,\n-    ) -> Result<Self::Path, Self::Error> {\n-        let inner = Arc::new(print_prefix(self)?);\n-\n-        let name = disambiguated_data.data.get_opt_name().map(|s| s.as_str());\n-        let name = name.as_ref().map_or(\"\", |s| &s[..]);\n-        let ns = match disambiguated_data.data {\n-            DefPathData::ClosureExpr => ast::Namespace(b'C'),\n-\n-            // Lowercase a-z are unspecified disambiguation categories.\n-            _ => {\n-                let discriminant = unsafe {\n-                    ::std::intrinsics::discriminant_value(&disambiguated_data.data)\n-                };\n-                assert!(discriminant < 26);\n-\n-                // Mix in the name to avoid making it too predictable.\n-                let mut d = (discriminant ^ 0x55) % 26;\n-                for (i, b) in name.bytes().enumerate() {\n-                    d = (d + i as u64 + b as u64) % 26;\n-                }\n-\n-                ast::Namespace(b'a' + d as u8)\n-            }\n-        };\n-\n-        Ok(ast::Path::Nested {\n-            ns,\n-            inner,\n-            ident: ast::Ident {\n-                dis: ast::Base62Number(disambiguated_data.disambiguator as u64),\n-                u_ident: ast::UIdent(name.to_string()),\n-            }\n-        })\n-    }\n-    fn path_generic_args(\n-        self,\n-        print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-        args: &[Kind<'tcx>],\n-    ) -> Result<Self::Path, Self::Error> {\n-        let prefix = print_prefix(self)?;\n-\n-        // Don't print any regions if they're all erased.\n-        let print_regions = args.iter().any(|arg| {\n-            match arg.unpack() {\n-                UnpackedKind::Lifetime(r) => *r != ty::ReErased,\n-                _ => false,\n-            }\n-        });\n-        let args = args.iter().cloned().filter(|arg| {\n-            match arg.unpack() {\n-                UnpackedKind::Lifetime(_) => print_regions,\n-                _ => true,\n-            }\n-        });\n-\n-        if args.clone().next().is_none() {\n-            return Ok(prefix);\n-        }\n-\n-        let args = args.map(|arg| {\n-            Ok(match arg.unpack() {\n-                UnpackedKind::Lifetime(lt) => {\n-                    ast::GenericArg::Lifetime(lt.print(self)?)\n-                }\n-                UnpackedKind::Type(ty) => {\n-                    ast::GenericArg::Type(ty.print(self)?)\n-                }\n-                UnpackedKind::Const(ct) => {\n-                    ast::GenericArg::Const(ct.print(self)?)\n-                }\n-            })\n-        }).collect::<Result<Vec<_>, _>>()?;\n-\n-        Ok(ast::Path::Generic {\n-            inner: Arc::new(prefix),\n-            args,\n-        })\n-    }\n-}"}, {"sha": "1615a097b3bf9e0938f86af47ad9844d2ad80f88", "filename": "src/librustc_codegen_utils/symbol_names/v0.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9cf35bfbe7b2610ff64c41668403fdb8f36c839c/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf35bfbe7b2610ff64c41668403fdb8f36c839c/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs?ref=9cf35bfbe7b2610ff64c41668403fdb8f36c839c", "patch": "@@ -17,7 +17,6 @@ pub(super) fn mangle(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     instance: Instance<'tcx>,\n     instantiating_crate: Option<CrateNum>,\n-    compress: bool,\n ) -> String {\n     let def_id = instance.def_id();\n     // FIXME(eddyb) this should ideally not be needed.\n@@ -27,17 +26,13 @@ pub(super) fn mangle(\n     let prefix = \"_R\";\n     let mut cx = SymbolMangler {\n         tcx,\n-        compress: if compress {\n-            Some(Box::new(CompressionCaches {\n-                start_offset: prefix.len(),\n-\n-                paths: FxHashMap::default(),\n-                types: FxHashMap::default(),\n-                consts: FxHashMap::default(),\n-            }))\n-        } else {\n-            None\n-        },\n+        compress: Some(Box::new(CompressionCaches {\n+            start_offset: prefix.len(),\n+\n+            paths: FxHashMap::default(),\n+            types: FxHashMap::default(),\n+            consts: FxHashMap::default(),\n+        })),\n         binders: vec![],\n         out: String::from(prefix),\n     };"}, {"sha": "52e263df5e3d3be963e3cdf4a30481dbc836339e", "filename": "src/tools/tidy/src/extdeps.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cf35bfbe7b2610ff64c41668403fdb8f36c839c/src%2Ftools%2Ftidy%2Fsrc%2Fextdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf35bfbe7b2610ff64c41668403fdb8f36c839c/src%2Ftools%2Ftidy%2Fsrc%2Fextdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fextdeps.rs?ref=9cf35bfbe7b2610ff64c41668403fdb8f36c839c", "patch": "@@ -6,10 +6,6 @@ use std::path::Path;\n /// List of whitelisted sources for packages.\n const WHITELISTED_SOURCES: &[&str] = &[\n     \"\\\"registry+https://github.com/rust-lang/crates.io-index\\\"\",\n-\n-    \"\\\"git+https://github.com/michaelwoerister/std-mangle-rs?\\\n-        rev=e884304cfcb2f636db4d59ca8ad8fa95b983281c#\\\n-            e884304cfcb2f636db4d59ca8ad8fa95b983281c\\\"\",\n ];\n \n /// Checks for external package sources."}]}