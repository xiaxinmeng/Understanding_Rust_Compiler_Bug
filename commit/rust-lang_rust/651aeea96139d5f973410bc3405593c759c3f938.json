{"sha": "651aeea96139d5f973410bc3405593c759c3f938", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1MWFlZWE5NjEzOWQ1Zjk3MzQxMGJjMzQwNTU5M2M3NTljM2Y5Mzg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-20T21:42:44Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-20T21:54:40Z"}, "message": "rustdoc: Document impl reexports", "tree": {"sha": "aca2a2a3d430cf94e9a00a3129c0386a1231ffbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aca2a2a3d430cf94e9a00a3129c0386a1231ffbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/651aeea96139d5f973410bc3405593c759c3f938", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/651aeea96139d5f973410bc3405593c759c3f938", "html_url": "https://github.com/rust-lang/rust/commit/651aeea96139d5f973410bc3405593c759c3f938", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/651aeea96139d5f973410bc3405593c759c3f938/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3ed738399e0c3c6fba5f3c0e4aca1e3d36bdbf8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3ed738399e0c3c6fba5f3c0e4aca1e3d36bdbf8", "html_url": "https://github.com/rust-lang/rust/commit/f3ed738399e0c3c6fba5f3c0e4aca1e3d36bdbf8"}], "stats": {"total": 143, "additions": 143, "deletions": 0}, "files": [{"sha": "9f7af646fab85d7f5e73f618a909d44c0cf524d7", "filename": "src/rustdoc/reexport_pass.rs", "status": "modified", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/651aeea96139d5f973410bc3405593c759c3f938/src%2Frustdoc%2Freexport_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651aeea96139d5f973410bc3405593c759c3f938/src%2Frustdoc%2Freexport_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Freexport_pass.rs?ref=651aeea96139d5f973410bc3405593c759c3f938", "patch": "@@ -2,10 +2,13 @@\n \n import std::map;\n import std::map::hashmap;\n+import std::list;\n import rustc::syntax::ast;\n import rustc::syntax::ast_util;\n import rustc::util::common;\n import rustc::middle::ast_map;\n+import rustc::syntax::visit;\n+import rustc::syntax::codemap;\n \n export mk_pass;\n \n@@ -84,12 +87,63 @@ fn build_reexport_def_set(srv: astsrv::srv) -> def_set {\n                 }\n             }\n         }\n+        for def in find_reexport_impls(ctxt) {\n+            def_set.insert(def, ());\n+        }\n         to_assoc_list(def_set)\n     };\n \n     from_def_assoc_list(assoc_list)\n }\n \n+fn find_reexport_impls(ctxt: astsrv::ctxt) -> [ast::def_id] {\n+    let defs = @mut [];\n+    let visitor = @{\n+        visit_mod: bind visit_mod(ctxt, defs, _, _, _)\n+        with *visit::default_simple_visitor()\n+    };\n+    let visitor = visit::mk_simple_visitor(visitor);\n+    visit::visit_crate(*ctxt.ast, (), visitor);\n+    ret *defs;\n+\n+    fn visit_mod(\n+        ctxt: astsrv::ctxt,\n+        defs: @mut [ast::def_id],\n+        m: ast::_mod,\n+        _sp: codemap::span,\n+        mod_id: ast::node_id\n+    ) {\n+        let all_impls = all_impls(m);\n+        alt check ctxt.impl_map.get(mod_id) {\n+          list::cons(impls, @list::nil) {\n+            for i in *impls {\n+                // This impl is not an item in the current mod\n+                if !all_impls.contains_key(i.did) {\n+                    // Ignore external impls because I don't\n+                    // know what to do with them yet\n+                    if i.did.crate == ast::local_crate {\n+                        *defs += [i.did]\n+                    }\n+                }\n+            }\n+          }\n+        }\n+    }\n+}\n+\n+fn all_impls(m: ast::_mod) -> map::set<ast::def_id> {\n+    let all_impls = common::new_def_hash();\n+    for item in m.items {\n+        alt item.node {\n+          ast::item_impl(_, _, _, _) {\n+            all_impls.insert(ast_util::local_def(item.id), ());\n+          }\n+          _ { }\n+        }\n+    }\n+    ret all_impls;\n+}\n+\n fn build_reexport_def_map(\n     srv: astsrv::srv,\n     doc: doc::doc,\n@@ -191,12 +245,77 @@ fn build_reexport_path_map(srv: astsrv::srv, -def_map: def_map) -> path_map {\n             }\n         }\n \n+        for (path, doc) in find_reexport_impl_docs(ctxt, def_map) {\n+            let docs = alt path_map.find(path) {\n+              some(docs) { docs + [(doc)] }\n+              none { [doc] }\n+            };\n+            path_map.insert(path, docs);\n+        }\n+\n         to_assoc_list(path_map)\n     };\n \n     from_str_assoc_list(assoc_list)\n }\n \n+fn find_reexport_impl_docs(\n+    ctxt: astsrv::ctxt,\n+    def_map: def_map\n+) -> [(str, (str, doc::itemtag))] {\n+    let docs = @mut [];\n+    let visitor = @{\n+        visit_mod: bind visit_mod(ctxt, def_map, docs, _, _, _)\n+        with *visit::default_simple_visitor()\n+    };\n+    let visitor = visit::mk_simple_visitor(visitor);\n+    visit::visit_crate(*ctxt.ast, (), visitor);\n+    ret *docs;\n+\n+    fn visit_mod(\n+        ctxt: astsrv::ctxt,\n+        def_map: def_map,\n+        docs: @mut [(str, (str, doc::itemtag))],\n+        m: ast::_mod,\n+        _sp: codemap::span,\n+        mod_id: ast::node_id\n+    ) {\n+        let all_impls = all_impls(m);\n+        alt check ctxt.impl_map.get(mod_id) {\n+          list::cons(impls, @list::nil) {\n+            for i in *impls {\n+                // This impl is not an item in the current mod\n+                if !all_impls.contains_key(i.did) {\n+                    // Ignore external impls because I don't\n+                    // know what to do with them yet\n+                    if i.did.crate == ast::local_crate {\n+                        let path = alt ctxt.ast_map.find(mod_id) {\n+                          some(ast_map::node_item(item, path)) {\n+                            let path = ast_map::path_to_str(*path);\n+                            if str::is_empty(path) {\n+                                item.ident\n+                            } else {\n+                                path + \"::\" + item.ident\n+                            }\n+                          }\n+                          _ {\n+                            assert mod_id == ast::crate_node_id;\n+                            \"\"\n+                          }\n+                        };\n+                        let ident = i.ident;\n+                        let doc = alt check def_map.find(i.did) {\n+                          some(doc) { doc }\n+                        };\n+                        *docs += [(path, (ident, doc))];\n+                    }\n+                }\n+            }\n+          }\n+        }\n+    }\n+}\n+\n fn merge_reexports(\n     doc: doc::doc,\n     path_map: path_map\n@@ -323,6 +442,30 @@ fn should_mark_reepxorts_as_such() {\n     assert doc.cratemod().mods()[1].fns()[0].item.reexport == true;\n }\n \n+#[test]\n+fn should_duplicate_reexported_impls() {\n+    let source = \"mod a { impl b for int { fn c() { } } } \\\n+                  mod d { import a::b; export b; }\";\n+    let doc = test::mk_doc(source);\n+    assert doc.cratemod().mods()[1].impls()[0].name() == \"b\";\n+}\n+\n+#[test]\n+fn should_duplicate_reexported_impls_deep() {\n+    let source = \"mod a { impl b for int { fn c() { } } } \\\n+                  mod d { mod e { import a::b; export b; } }\";\n+    let doc = test::mk_doc(source);\n+    assert doc.cratemod().mods()[1].mods()[0].impls()[0].name() == \"b\";\n+}\n+\n+#[test]\n+fn should_duplicate_reexported_impls_crate() {\n+    let source = \"import a::b; export b; \\\n+                  mod a { impl b for int { fn c() { } } }\";\n+    let doc = test::mk_doc(source);\n+    assert doc.cratemod().impls()[0].name() == \"b\";\n+}\n+\n #[test]\n fn should_duplicate_reexported_native_fns() {\n     let source = \"native mod a { fn b(); } \\"}]}