{"sha": "ec56537c4325ce5b798fc3628cbdd48ba4949ae5", "node_id": "C_kwDOAAsO6NoAKGVjNTY1MzdjNDMyNWNlNWI3OThmYzM2MjhjYmRkNDhiYTQ5NDlhZTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-15T19:59:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-15T19:59:48Z"}, "message": "Auto merge of #105356 - JakobDegen:more-custom-mir, r=oli-obk\n\nCustom MIR: Many more improvements\n\nCommits are each atomic changes, best reviewed one at a time, with the exception that the last commit includes all the documentation.\n\n### First commit\n\nUnsafetyck was not correctly disabled before for `dialect = \"built\"` custom MIR. This is fixed and a regression test is added.\n\n### Second commit\n\nImplements `Discriminant`, `SetDiscriminant`, and `SwitchInt`.\n\n### Third commit\n\nImplements indexing, field, and variant projections.\n\n### Fourth commit\n\nDocuments the previous commits and everything else.\n\nThere is some amount of weirdness here due to having to beat Rust syntax into cooperating with MIR concepts, but it hopefully should not be too much. All of it is documented.\n\nr? `@oli-obk`", "tree": {"sha": "f3196df94cf2fa761085969f50ccf315aeb2a7e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3196df94cf2fa761085969f50ccf315aeb2a7e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec56537c4325ce5b798fc3628cbdd48ba4949ae5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec56537c4325ce5b798fc3628cbdd48ba4949ae5", "html_url": "https://github.com/rust-lang/rust/commit/ec56537c4325ce5b798fc3628cbdd48ba4949ae5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4954a7ef5c5bb45f1c0d021491702ad05d470821", "url": "https://api.github.com/repos/rust-lang/rust/commits/4954a7ef5c5bb45f1c0d021491702ad05d470821", "html_url": "https://github.com/rust-lang/rust/commit/4954a7ef5c5bb45f1c0d021491702ad05d470821"}, {"sha": "b580f29b744d845f75d959d63943ffeab55671fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/b580f29b744d845f75d959d63943ffeab55671fd", "html_url": "https://github.com/rust-lang/rust/commit/b580f29b744d845f75d959d63943ffeab55671fd"}], "stats": {"total": 763, "additions": 731, "deletions": 32}, "files": [{"sha": "bdaa586c69879ca53ddea0eb5d308436341f00d5", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=ec56537c4325ce5b798fc3628cbdd48ba4949ae5", "patch": "@@ -533,6 +533,11 @@ impl<'tcx> Body<'tcx> {\n         };\n         injection_phase > self.phase\n     }\n+\n+    #[inline]\n+    pub fn is_custom_mir(&self) -> bool {\n+        self.injection_phase.is_some()\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug, TyEncodable, TyDecodable, HashStable)]"}, {"sha": "34fefb99e09c25c1b034a2f431ce38dafbf3e39c", "filename": "compiler/rustc_mir_build/src/build/custom/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs?ref=ec56537c4325ce5b798fc3628cbdd48ba4949ae5", "patch": "@@ -25,7 +25,7 @@ use rustc_index::vec::IndexVec;\n use rustc_middle::{\n     mir::*,\n     thir::*,\n-    ty::{Ty, TyCtxt},\n+    ty::{ParamEnv, Ty, TyCtxt},\n };\n use rustc_span::Span;\n \n@@ -78,6 +78,7 @@ pub(super) fn build_custom_mir<'tcx>(\n \n     let mut pctxt = ParseCtxt {\n         tcx,\n+        param_env: tcx.param_env(did),\n         thir,\n         source_scope: OUTERMOST_SOURCE_SCOPE,\n         body: &mut body,\n@@ -132,6 +133,7 @@ fn parse_attribute(attr: &Attribute) -> MirPhase {\n \n struct ParseCtxt<'tcx, 'body> {\n     tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n     thir: &'body Thir<'tcx>,\n     source_scope: SourceScope,\n "}, {"sha": "2f26499a3b6e937c8acc0a1bfb2bdc48ba855b05", "filename": "compiler/rustc_mir_build/src/build/custom/parse/instruction.rs", "status": "modified", "additions": 106, "deletions": 8, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs?ref=ec56537c4325ce5b798fc3628cbdd48ba4949ae5", "patch": "@@ -1,5 +1,11 @@\n use rustc_middle::mir::interpret::{ConstValue, Scalar};\n+use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::{mir::*, thir::*, ty};\n+use rustc_span::Span;\n+use rustc_target::abi::VariantIdx;\n+\n+use crate::build::custom::ParseError;\n+use crate::build::expr::as_constant::as_constant_inner;\n \n use super::{parse_by_kind, PResult, ParseCtxt};\n \n@@ -12,6 +18,14 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n             @call(\"mir_retag_raw\", args) => {\n                 Ok(StatementKind::Retag(RetagKind::Raw, Box::new(self.parse_place(args[0])?)))\n             },\n+            @call(\"mir_set_discriminant\", args) => {\n+                let place = self.parse_place(args[0])?;\n+                let var = self.parse_integer_literal(args[1])? as u32;\n+                Ok(StatementKind::SetDiscriminant {\n+                    place: Box::new(place),\n+                    variant_index: VariantIdx::from_u32(var),\n+                })\n+            },\n             ExprKind::Assign { lhs, rhs } => {\n                 let lhs = self.parse_place(*lhs)?;\n                 let rhs = self.parse_rvalue(*rhs)?;\n@@ -21,18 +35,60 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n     }\n \n     pub fn parse_terminator(&self, expr_id: ExprId) -> PResult<TerminatorKind<'tcx>> {\n-        parse_by_kind!(self, expr_id, _, \"terminator\",\n+        parse_by_kind!(self, expr_id, expr, \"terminator\",\n             @call(\"mir_return\", _args) => {\n                 Ok(TerminatorKind::Return)\n             },\n             @call(\"mir_goto\", args) => {\n                 Ok(TerminatorKind::Goto { target: self.parse_block(args[0])? } )\n             },\n+            ExprKind::Match { scrutinee, arms } => {\n+                let discr = self.parse_operand(*scrutinee)?;\n+                self.parse_match(arms, expr.span).map(|t| TerminatorKind::SwitchInt { discr, targets: t })\n+            },\n         )\n     }\n \n+    fn parse_match(&self, arms: &[ArmId], span: Span) -> PResult<SwitchTargets> {\n+        let Some((otherwise, rest)) = arms.split_last() else {\n+            return Err(ParseError {\n+                span,\n+                item_description: format!(\"no arms\"),\n+                expected: \"at least one arm\".to_string(),\n+            })\n+        };\n+\n+        let otherwise = &self.thir[*otherwise];\n+        let PatKind::Wild = otherwise.pattern.kind else {\n+            return Err(ParseError {\n+                span: otherwise.span,\n+                item_description: format!(\"{:?}\", otherwise.pattern.kind),\n+                expected: \"wildcard pattern\".to_string(),\n+            })\n+        };\n+        let otherwise = self.parse_block(otherwise.body)?;\n+\n+        let mut values = Vec::new();\n+        let mut targets = Vec::new();\n+        for arm in rest {\n+            let arm = &self.thir[*arm];\n+            let PatKind::Constant { value } = arm.pattern.kind else {\n+                return Err(ParseError {\n+                    span: arm.pattern.span,\n+                    item_description: format!(\"{:?}\", arm.pattern.kind),\n+                    expected: \"constant pattern\".to_string(),\n+                })\n+            };\n+            values.push(value.eval_bits(self.tcx, self.param_env, arm.pattern.ty));\n+            targets.push(self.parse_block(arm.body)?);\n+        }\n+\n+        Ok(SwitchTargets::new(values.into_iter().zip(targets), otherwise))\n+    }\n+\n     fn parse_rvalue(&self, expr_id: ExprId) -> PResult<Rvalue<'tcx>> {\n         parse_by_kind!(self, expr_id, _, \"rvalue\",\n+            @call(\"mir_discriminant\", args) => self.parse_place(args[0]).map(Rvalue::Discriminant),\n             ExprKind::Borrow { borrow_kind, arg } => Ok(\n                 Rvalue::Ref(self.tcx.lifetimes.re_erased, *borrow_kind, self.parse_place(*arg)?)\n             ),\n@@ -55,20 +111,50 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n             | ExprKind::ConstParam { .. }\n             | ExprKind::ConstBlock { .. } => {\n                 Ok(Operand::Constant(Box::new(\n-                    crate::build::expr::as_constant::as_constant_inner(expr, |_| None, self.tcx)\n+                    as_constant_inner(expr, |_| None, self.tcx)\n                 )))\n             },\n             _ => self.parse_place(expr_id).map(Operand::Copy),\n         )\n     }\n \n     fn parse_place(&self, expr_id: ExprId) -> PResult<Place<'tcx>> {\n-        parse_by_kind!(self, expr_id, _, \"place\",\n-            ExprKind::Deref { arg } => Ok(\n-                self.parse_place(*arg)?.project_deeper(&[PlaceElem::Deref], self.tcx)\n-            ),\n-            _ => self.parse_local(expr_id).map(Place::from),\n-        )\n+        self.parse_place_inner(expr_id).map(|(x, _)| x)\n+    }\n+\n+    fn parse_place_inner(&self, expr_id: ExprId) -> PResult<(Place<'tcx>, PlaceTy<'tcx>)> {\n+        let (parent, proj) = parse_by_kind!(self, expr_id, expr, \"place\",\n+            @call(\"mir_field\", args) => {\n+                let (parent, ty) = self.parse_place_inner(args[0])?;\n+                let field = Field::from_u32(self.parse_integer_literal(args[1])? as u32);\n+                let field_ty = ty.field_ty(self.tcx, field);\n+                let proj = PlaceElem::Field(field, field_ty);\n+                let place = parent.project_deeper(&[proj], self.tcx);\n+                return Ok((place, PlaceTy::from_ty(field_ty)));\n+            },\n+            @call(\"mir_variant\", args) => {\n+                (args[0], PlaceElem::Downcast(\n+                    None,\n+                    VariantIdx::from_u32(self.parse_integer_literal(args[1])? as u32)\n+                ))\n+            },\n+            ExprKind::Deref { arg } => {\n+                parse_by_kind!(self, *arg, _, \"does not matter\",\n+                    @call(\"mir_make_place\", args) => return self.parse_place_inner(args[0]),\n+                    _ => (*arg, PlaceElem::Deref),\n+                )\n+            },\n+            ExprKind::Index { lhs, index } => (*lhs, PlaceElem::Index(self.parse_local(*index)?)),\n+            ExprKind::Field { lhs, name: field, .. } => (*lhs, PlaceElem::Field(*field, expr.ty)),\n+            _ => {\n+                let place = self.parse_local(expr_id).map(Place::from)?;\n+                return Ok((place, PlaceTy::from_ty(expr.ty)))\n+            },\n+        );\n+        let (parent, ty) = self.parse_place_inner(parent)?;\n+        let place = parent.project_deeper(&[proj], self.tcx);\n+        let ty = ty.projection_ty(self.tcx, proj);\n+        Ok((place, ty))\n     }\n \n     fn parse_local(&self, expr_id: ExprId) -> PResult<Local> {\n@@ -102,4 +188,16 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n             },\n         )\n     }\n+\n+    fn parse_integer_literal(&self, expr_id: ExprId) -> PResult<u128> {\n+        parse_by_kind!(self, expr_id, expr, \"constant\",\n+            ExprKind::Literal { .. }\n+            | ExprKind::NamedConst { .. }\n+            | ExprKind::NonHirLiteral { .. }\n+            | ExprKind::ConstBlock { .. } => Ok({\n+                let value = as_constant_inner(expr, |_| None, self.tcx);\n+                value.literal.eval_bits(self.tcx, self.param_env, value.ty())\n+            }),\n+        )\n+    }\n }"}, {"sha": "9c22b5df73ce85ea2423352c4c8d55ed0ea20abe", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=ec56537c4325ce5b798fc3628cbdd48ba4949ae5", "patch": "@@ -500,7 +500,7 @@ fn unsafety_check_result<'tcx>(\n     // `mir_built` force this.\n     let body = &tcx.mir_built(def).borrow();\n \n-    if body.should_skip() {\n+    if body.is_custom_mir() {\n         return tcx.arena.alloc(UnsafetyCheckResult {\n             violations: Vec::new(),\n             used_unsafe_blocks: FxHashSet::default(),"}, {"sha": "0910ce599b7c00fe41cf17a12b489c8b0609692c", "filename": "library/core/src/intrinsics/mir.rs", "status": "modified", "additions": 240, "deletions": 22, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs?ref=ec56537c4325ce5b798fc3628cbdd48ba4949ae5", "patch": "@@ -21,15 +21,14 @@\n //! #[custom_mir(dialect = \"built\")]\n //! pub fn simple(x: i32) -> i32 {\n //!     mir!(\n-//!         let temp1: i32;\n-//!         let temp2: _;\n+//!         let temp2: i32;\n //!\n //!         {\n-//!             temp1 = x;\n-//!             Goto(exit)\n+//!             let temp1 = x;\n+//!             Goto(my_second_block)\n //!         }\n //!\n-//!         exit = {\n+//!         my_second_block = {\n //!             temp2 = Move(temp1);\n //!             RET = temp2;\n //!             Return()\n@@ -38,22 +37,168 @@\n //! }\n //! ```\n //!\n-//! Hopefully most of this is fairly self-explanatory. Expanding on some notable details:\n+//! The `custom_mir` attribute tells the compiler to treat the function as being custom MIR. This\n+//! attribute only works on functions - there is no way to insert custom MIR into the middle of\n+//! another function. The `dialect` and `phase` parameters indicate which [version of MIR][dialect\n+//! docs] you are inserting here. Generally you'll want to use `#![custom_mir(dialect = \"built\")]`\n+//! if you want your MIR to be modified by the full MIR pipeline, or `#![custom_mir(dialect =\n+//! \"runtime\", phase = \"optimized\")] if you don't.\n //!\n-//!  - The `custom_mir` attribute tells the compiler to treat the function as being custom MIR. This\n-//!    attribute only works on functions - there is no way to insert custom MIR into the middle of\n-//!    another function.\n-//!  - The `dialect` and `phase` parameters indicate which version of MIR you are inserting here.\n-//!    This will normally be the phase that corresponds to the thing you are trying to test. The\n-//!    phase can be omitted for dialects that have just one.\n-//!  - You should define your function signature like you normally would. Externally, this function\n-//!    can be called like any other function.\n-//!  - Type inference works - you don't have to spell out the type of all of your locals.\n+//! [dialect docs]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.MirPhase.html\n //!\n-//! For now, all statements and terminators are parsed from nested invocations of the special\n-//! functions provided in this module. We additionally want to (but do not yet) support more\n-//! \"normal\" Rust syntax in places where it makes sense. Also, most kinds of instructions are not\n-//! supported yet.\n+//! The input to the [`mir!`] macro is:\n+//!\n+//!  - A possibly empty list of local declarations. Locals can also be declared inline on\n+//!    assignments via `let`. Type inference generally works. Shadowing does not.\n+//!  - A list of basic blocks. The first of these is the start block and is where execution begins.\n+//!    All blocks other than the start block need to be given a name, so that they can be referred\n+//!    to later.\n+//!     - Each block is a list of semicolon terminated statements, followed by a terminator. The\n+//!       syntax for the various statements and terminators is designed to be as similar as possible\n+//!       to the syntax for analogous concepts in native Rust. See below for a list.\n+//!\n+//! # Examples\n+//!\n+//! ```rust\n+//! #![feature(core_intrinsics, custom_mir)]\n+//!\n+//! extern crate core;\n+//! use core::intrinsics::mir::*;\n+//!\n+//! #[custom_mir(dialect = \"built\")]\n+//! pub fn choose_load(a: &i32, b: &i32, c: bool) -> i32 {\n+//!     mir!(\n+//!         {\n+//!             match c {\n+//!                 true => t,\n+//!                 _ => f,\n+//!             }\n+//!         }\n+//!\n+//!         t = {\n+//!             let temp = a;\n+//!             Goto(load_and_exit)\n+//!         }\n+//!\n+//!         f = {\n+//!             temp = b;\n+//!             Goto(load_and_exit)\n+//!         }\n+//!\n+//!         load_and_exit = {\n+//!             RET = *temp;\n+//!             Return()\n+//!         }\n+//!     )\n+//! }\n+//!\n+//! #[custom_mir(dialect = \"built\")]\n+//! fn unwrap_unchecked<T>(opt: Option<T>) -> T {\n+//!     mir!({\n+//!         RET = Move(Field(Variant(opt, 1), 0));\n+//!         Return()\n+//!     })\n+//! }\n+//! ```\n+//!\n+//! We can also set off compilation failures that happen in sufficiently late stages of the\n+//! compiler:\n+//!\n+//! ```rust,compile_fail\n+//! #![feature(core_intrinsics, custom_mir)]\n+//!\n+//! extern crate core;\n+//! use core::intrinsics::mir::*;\n+//!\n+//! #[custom_mir(dialect = \"built\")]\n+//! fn borrow_error(should_init: bool) -> i32 {\n+//!     mir!(\n+//!         let temp: i32;\n+//!\n+//!         {\n+//!             match should_init {\n+//!                 true => init,\n+//!                 _ => use_temp,\n+//!             }\n+//!         }\n+//!\n+//!         init = {\n+//!             temp = 0;\n+//!             Goto(use_temp)\n+//!         }\n+//!\n+//!         use_temp = {\n+//!             RET = temp;\n+//!             Return()\n+//!         }\n+//!     )\n+//! }\n+//! ```\n+//!\n+//! ```text\n+//! error[E0381]: used binding is possibly-uninitialized\n+//!   --> test.rs:24:13\n+//!    |\n+//! 8  | /     mir!(\n+//! 9  | |         let temp: i32;\n+//! 10 | |\n+//! 11 | |         {\n+//! ...  |\n+//! 19 | |             temp = 0;\n+//!    | |             -------- binding initialized here in some conditions\n+//! ...  |\n+//! 24 | |             RET = temp;\n+//!    | |             ^^^^^^^^^^ value used here but it is possibly-uninitialized\n+//! 25 | |             Return()\n+//! 26 | |         }\n+//! 27 | |     )\n+//!    | |_____- binding declared here but left uninitialized\n+//!\n+//! error: aborting due to previous error\n+//!\n+//! For more information about this error, try `rustc --explain E0381`.\n+//! ```\n+//!\n+//! # Syntax\n+//!\n+//! The lists below are an exhaustive description of how various MIR constructs can be created.\n+//! Anything missing from the list should be assumed to not be supported, PRs welcome.\n+//!\n+//! #### Locals\n+//!\n+//!  - The `_0` return local can always be accessed via `RET`.\n+//!  - Arguments can be accessed via their regular name.\n+//!  - All other locals need to be declared with `let` somewhere and then can be accessed by name.\n+//!\n+//! #### Places\n+//!  - Locals implicit convert to places.\n+//!  - Field accesses, derefs, and indexing work normally.\n+//!  - Fields in variants can be accessed via the [`Variant`] and [`Field`] associated functions,\n+//!    see their documentation for details.\n+//!\n+//! #### Operands\n+//!  - Places implicitly convert to `Copy` operands.\n+//!  - `Move` operands can be created via [`Move`].\n+//!  - Const blocks, literals, named constants, and const params all just work.\n+//!  - [`Static`] and [`StaticMut`] can be used to create `&T` and `*mut T`s to statics. These are\n+//!    constants in MIR and the only way to access statics.\n+//!\n+//! #### Statements\n+//!  - Assign statements work via normal Rust assignment.\n+//!  - [`Retag`] statements have an associated function.\n+//!\n+//! #### Rvalues\n+//!\n+//!  - Operands implicitly convert to `Use` rvalues.\n+//!  - `&`, `&mut`, `addr_of!`, and `addr_of_mut!` all work to create their associated rvalue.\n+//!  - [`Discriminant`] has an associated function.\n+//!\n+//! #### Terminators\n+//!\n+//!  - [`Goto`] and [`Return`] have associated functions.\n+//!  - `match some_int_operand` becomes a `SwitchInt`. Each arm should be `literal => basic_block`\n+//!     - The exception is the last arm, which must be `_ => basic_block` and corresponds to the\n+//!       otherwise branch.\n //!\n \n #![unstable(\n@@ -69,9 +214,10 @@\n pub struct BasicBlock;\n \n macro_rules! define {\n-    ($name:literal, $($sig:tt)*) => {\n+    ($name:literal, $( #[ $meta:meta ] )* fn $($sig:tt)*) => {\n         #[rustc_diagnostic_item = $name]\n-        pub $($sig)* { panic!() }\n+        $( #[ $meta ] )*\n+        pub fn $($sig)* { panic!() }\n     }\n }\n \n@@ -82,8 +228,73 @@ define!(\"mir_retag_raw\", fn RetagRaw<T>(place: T));\n define!(\"mir_move\", fn Move<T>(place: T) -> T);\n define!(\"mir_static\", fn Static<T>(s: T) -> &'static T);\n define!(\"mir_static_mut\", fn StaticMut<T>(s: T) -> *mut T);\n+define!(\n+    \"mir_discriminant\",\n+    /// Gets the discriminant of a place.\n+    fn Discriminant<T>(place: T) -> <T as ::core::marker::DiscriminantKind>::Discriminant\n+);\n+define!(\"mir_set_discriminant\", fn SetDiscriminant<T>(place: T, index: u32));\n+define!(\n+    \"mir_field\",\n+    /// Access the field with the given index of some place.\n+    ///\n+    /// This only makes sense to use in conjunction with [`Variant`]. If the type you are looking to\n+    /// access the field of does not have variants, you can use normal field projection syntax.\n+    ///\n+    /// There is no proper way to do a place projection to a variant in Rust, and so these two\n+    /// functions are a workaround. You can access a field of a variant via `Field(Variant(place,\n+    /// var_idx), field_idx)`, where `var_idx` and `field_idx` are appropriate literals. Some\n+    /// caveats:\n+    ///\n+    ///  - The return type of `Variant` is always `()`. Don't worry about that, the correct MIR will\n+    ///    still be generated.\n+    ///  - In some situations, the return type of `Field` cannot be inferred. You may need to\n+    ///    annotate it on the function in these cases.\n+    ///  - Since `Field` is a function call which is not a place expression, using this on the left\n+    ///    hand side of an expression is rejected by the compiler. [`place!`] is a macro provided to\n+    ///    work around that issue. Wrap the left hand side of an assignment in the macro to convince\n+    ///    the compiler that it's ok.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(custom_mir, core_intrinsics)]\n+    ///\n+    /// extern crate core;\n+    /// use core::intrinsics::mir::*;\n+    ///\n+    /// #[custom_mir(dialect = \"built\")]\n+    /// fn unwrap_deref(opt: Option<&i32>) -> i32 {\n+    ///     mir!({\n+    ///         RET = *Field::<&i32>(Variant(opt, 1), 0);\n+    ///         Return()\n+    ///     })\n+    /// }\n+    ///\n+    /// #[custom_mir(dialect = \"built\")]\n+    /// fn set(opt: &mut Option<i32>) {\n+    ///     mir!({\n+    ///         place!(Field(Variant(*opt, 1), 0)) = 5;\n+    ///         Return()\n+    ///     })\n+    /// }\n+    /// ```\n+    fn Field<F>(place: (), field: u32) -> F\n+);\n+define!(\n+    \"mir_variant\",\n+    /// Adds a variant projection with the given index to the place.\n+    ///\n+    /// See [`Field`] for documentation.\n+    fn Variant<T>(place: T, index: u32) -> ()\n+);\n+define!(\n+    \"mir_make_place\",\n+    #[doc(hidden)]\n+    fn __internal_make_place<T>(place: T) -> *mut T\n+);\n \n-/// Convenience macro for generating custom MIR.\n+/// Macro for generating custom MIR.\n ///\n /// See the module documentation for syntax details. This macro is not magic - it only transforms\n /// your MIR into something that is easier to parse in the compiler.\n@@ -139,6 +350,13 @@ pub macro mir {\n     }}\n }\n \n+/// Helper macro that allows you to treat a value expression like a place expression.\n+///\n+/// See the documentation on [`Variant`] for why this is necessary and how to use it.\n+pub macro place($e:expr) {\n+    (*::core::intrinsics::mir::__internal_make_place($e))\n+}\n+\n /// Helper macro that extracts the `let` declarations out of a bunch of statements.\n ///\n /// This macro is written using the \"statement muncher\" strategy. Each invocation parses the first"}, {"sha": "e5cd456377844e1d18ee1cde5a09ddf26fb828dc", "filename": "src/test/mir-opt/building/custom/enums.rs", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fenums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fenums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fenums.rs?ref=ec56537c4325ce5b798fc3628cbdd48ba4949ae5", "patch": "@@ -0,0 +1,120 @@\n+#![feature(custom_mir, core_intrinsics)]\n+\n+extern crate core;\n+use core::intrinsics::mir::*;\n+\n+// EMIT_MIR enums.switch_bool.built.after.mir\n+#[custom_mir(dialect = \"built\")]\n+pub fn switch_bool(b: bool) -> u32 {\n+    mir!(\n+        {\n+            match b {\n+                true => t,\n+                false => f,\n+                _ => f,\n+            }\n+        }\n+\n+        t = {\n+            RET = 5;\n+            Return()\n+        }\n+\n+        f = {\n+            RET = 10;\n+            Return()\n+        }\n+    )\n+}\n+\n+// EMIT_MIR enums.switch_option.built.after.mir\n+#[custom_mir(dialect = \"built\")]\n+pub fn switch_option(option: Option<()>) -> bool {\n+    mir!(\n+        {\n+            let discr = Discriminant(option);\n+            match discr {\n+                0 => n,\n+                1 => s,\n+                _ => s,\n+            }\n+        }\n+\n+        n = {\n+            RET = false;\n+            Return()\n+        }\n+\n+        s = {\n+            RET = true;\n+            Return()\n+        }\n+    )\n+}\n+\n+#[repr(u8)]\n+enum Bool {\n+    False = 0,\n+    True = 1,\n+}\n+\n+// EMIT_MIR enums.switch_option_repr.built.after.mir\n+#[custom_mir(dialect = \"built\")]\n+fn switch_option_repr(option: Bool) -> bool {\n+    mir!(\n+        {\n+            let discr = Discriminant(option);\n+            match discr {\n+                0 => f,\n+                _ => t,\n+            }\n+        }\n+\n+        t = {\n+            RET = true;\n+            Return()\n+        }\n+\n+        f = {\n+            RET = false;\n+            Return()\n+        }\n+    )\n+}\n+\n+// EMIT_MIR enums.set_discr.built.after.mir\n+#[custom_mir(dialect = \"runtime\", phase = \"initial\")]\n+fn set_discr(option: &mut Option<()>) {\n+    mir!({\n+        SetDiscriminant(*option, 0);\n+        Return()\n+    })\n+}\n+\n+// EMIT_MIR enums.set_discr_repr.built.after.mir\n+#[custom_mir(dialect = \"runtime\", phase = \"initial\")]\n+fn set_discr_repr(b: &mut Bool) {\n+    mir!({\n+        SetDiscriminant(*b, 0);\n+        Return()\n+    })\n+}\n+\n+fn main() {\n+    assert_eq!(switch_bool(true), 5);\n+    assert_eq!(switch_bool(false), 10);\n+\n+    assert_eq!(switch_option(Some(())), true);\n+    assert_eq!(switch_option(None), false);\n+\n+    assert_eq!(switch_option_repr(Bool::True), true);\n+    assert_eq!(switch_option_repr(Bool::False), false);\n+\n+    let mut opt = Some(());\n+    set_discr(&mut opt);\n+    assert_eq!(opt, None);\n+\n+    let mut b = Bool::True;\n+    set_discr_repr(&mut b);\n+    assert!(matches!(b, Bool::False));\n+}"}, {"sha": "7de9ed0983fe80a2787988eed3e541ae340a86c1", "filename": "src/test/mir-opt/building/custom/enums.set_discr.built.after.mir", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fenums.set_discr.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fenums.set_discr.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fenums.set_discr.built.after.mir?ref=ec56537c4325ce5b798fc3628cbdd48ba4949ae5", "patch": "@@ -0,0 +1,10 @@\n+// MIR for `set_discr` after built\n+\n+fn set_discr(_1: &mut Option<()>) -> () {\n+    let mut _0: ();                      // return place in scope 0 at $DIR/enums.rs:+0:39: +0:39\n+\n+    bb0: {\n+        discriminant((*_1)) = 0;         // scope 0 at $DIR/enums.rs:+2:9: +2:36\n+        return;                          // scope 0 at $DIR/enums.rs:+3:9: +3:17\n+    }\n+}"}, {"sha": "6fdc3d0f4d4e138c274868409efc5111c7b545d3", "filename": "src/test/mir-opt/building/custom/enums.set_discr_repr.built.after.mir", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fenums.set_discr_repr.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fenums.set_discr_repr.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fenums.set_discr_repr.built.after.mir?ref=ec56537c4325ce5b798fc3628cbdd48ba4949ae5", "patch": "@@ -0,0 +1,10 @@\n+// MIR for `set_discr_repr` after built\n+\n+fn set_discr_repr(_1: &mut Bool) -> () {\n+    let mut _0: ();                      // return place in scope 0 at $DIR/enums.rs:+0:33: +0:33\n+\n+    bb0: {\n+        discriminant((*_1)) = 0;         // scope 0 at $DIR/enums.rs:+2:9: +2:31\n+        return;                          // scope 0 at $DIR/enums.rs:+3:9: +3:17\n+    }\n+}"}, {"sha": "95c57d2dca33a3fd2996dc91fba4fc62231bc221", "filename": "src/test/mir-opt/building/custom/enums.switch_bool.built.after.mir", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fenums.switch_bool.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fenums.switch_bool.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fenums.switch_bool.built.after.mir?ref=ec56537c4325ce5b798fc3628cbdd48ba4949ae5", "patch": "@@ -0,0 +1,19 @@\n+// MIR for `switch_bool` after built\n+\n+fn switch_bool(_1: bool) -> u32 {\n+    let mut _0: u32;                     // return place in scope 0 at $DIR/enums.rs:+0:32: +0:35\n+\n+    bb0: {\n+        switchInt(_1) -> [1: bb1, 0: bb2, otherwise: bb2]; // scope 0 at $DIR/enums.rs:+3:13: +7:14\n+    }\n+\n+    bb1: {\n+        _0 = const 5_u32;                // scope 0 at $DIR/enums.rs:+11:13: +11:20\n+        return;                          // scope 0 at $DIR/enums.rs:+12:13: +12:21\n+    }\n+\n+    bb2: {\n+        _0 = const 10_u32;               // scope 0 at $DIR/enums.rs:+16:13: +16:21\n+        return;                          // scope 0 at $DIR/enums.rs:+17:13: +17:21\n+    }\n+}"}, {"sha": "a659ba7c114d046b08cbfe74d2ffe238f0e71f41", "filename": "src/test/mir-opt/building/custom/enums.switch_option.built.after.mir", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fenums.switch_option.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fenums.switch_option.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fenums.switch_option.built.after.mir?ref=ec56537c4325ce5b798fc3628cbdd48ba4949ae5", "patch": "@@ -0,0 +1,21 @@\n+// MIR for `switch_option` after built\n+\n+fn switch_option(_1: Option<()>) -> bool {\n+    let mut _0: bool;                    // return place in scope 0 at $DIR/enums.rs:+0:45: +0:49\n+    let mut _2: isize;                   // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+\n+    bb0: {\n+        _2 = discriminant(_1);           // scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+        switchInt(_2) -> [0: bb1, 1: bb2, otherwise: bb2]; // scope 0 at $DIR/enums.rs:+4:13: +8:14\n+    }\n+\n+    bb1: {\n+        _0 = const false;                // scope 0 at $DIR/enums.rs:+12:13: +12:24\n+        return;                          // scope 0 at $DIR/enums.rs:+13:13: +13:21\n+    }\n+\n+    bb2: {\n+        _0 = const true;                 // scope 0 at $DIR/enums.rs:+17:13: +17:23\n+        return;                          // scope 0 at $DIR/enums.rs:+18:13: +18:21\n+    }\n+}"}, {"sha": "d60e4b1b712fd207983884cb152e854ddc6c201b", "filename": "src/test/mir-opt/building/custom/enums.switch_option_repr.built.after.mir", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fenums.switch_option_repr.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fenums.switch_option_repr.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fenums.switch_option_repr.built.after.mir?ref=ec56537c4325ce5b798fc3628cbdd48ba4949ae5", "patch": "@@ -0,0 +1,21 @@\n+// MIR for `switch_option_repr` after built\n+\n+fn switch_option_repr(_1: Bool) -> bool {\n+    let mut _0: bool;                    // return place in scope 0 at $DIR/enums.rs:+0:40: +0:44\n+    let mut _2: u8;                      // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+\n+    bb0: {\n+        _2 = discriminant(_1);           // scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+        switchInt(_2) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/enums.rs:+4:13: +7:14\n+    }\n+\n+    bb1: {\n+        _0 = const true;                 // scope 0 at $DIR/enums.rs:+11:13: +11:23\n+        return;                          // scope 0 at $DIR/enums.rs:+12:13: +12:21\n+    }\n+\n+    bb2: {\n+        _0 = const false;                // scope 0 at $DIR/enums.rs:+16:13: +16:24\n+        return;                          // scope 0 at $DIR/enums.rs:+17:13: +17:21\n+    }\n+}"}, {"sha": "5e472e531c742d56869289e03865383f8dd817f5", "filename": "src/test/mir-opt/building/custom/projections.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fprojections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fprojections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fprojections.rs?ref=ec56537c4325ce5b798fc3628cbdd48ba4949ae5", "patch": "@@ -0,0 +1,85 @@\n+#![feature(custom_mir, core_intrinsics)]\n+\n+extern crate core;\n+use core::intrinsics::mir::*;\n+\n+union U {\n+    a: i32,\n+    b: u32,\n+}\n+\n+// EMIT_MIR projections.unions.built.after.mir\n+#[custom_mir(dialect = \"built\")]\n+fn unions(u: U) -> i32 {\n+    mir!({\n+        RET = u.a;\n+        Return()\n+    })\n+}\n+\n+// EMIT_MIR projections.tuples.built.after.mir\n+#[custom_mir(dialect = \"analysis\", phase = \"post-cleanup\")]\n+fn tuples(i: (u32, i32)) -> (u32, i32) {\n+    mir!(\n+        // FIXME(JakobDegen): This is necessary because we can't give type hints for `RET`\n+        let temp: (u32, i32);\n+        {\n+            temp.0 = i.0;\n+            temp.1 = i.1;\n+\n+            RET = temp;\n+            Return()\n+        }\n+    )\n+}\n+\n+// EMIT_MIR projections.unwrap.built.after.mir\n+#[custom_mir(dialect = \"built\")]\n+fn unwrap(opt: Option<i32>) -> i32 {\n+    mir!({\n+        RET = Field(Variant(opt, 1), 0);\n+        Return()\n+    })\n+}\n+\n+// EMIT_MIR projections.unwrap_deref.built.after.mir\n+#[custom_mir(dialect = \"built\")]\n+fn unwrap_deref(opt: Option<&i32>) -> i32 {\n+    mir!({\n+        RET = *Field::<&i32>(Variant(opt, 1), 0);\n+        Return()\n+    })\n+}\n+\n+// EMIT_MIR projections.set.built.after.mir\n+#[custom_mir(dialect = \"built\")]\n+fn set(opt: &mut Option<i32>) {\n+    mir!({\n+        place!(Field(Variant(*opt, 1), 0)) = 10;\n+        Return()\n+    })\n+}\n+\n+// EMIT_MIR projections.simple_index.built.after.mir\n+#[custom_mir(dialect = \"built\")]\n+fn simple_index(a: [i32; 10], b: &[i32]) -> i32 {\n+    mir!({\n+        let temp = 3;\n+        RET = a[temp];\n+        RET = (*b)[temp];\n+        Return()\n+    })\n+}\n+\n+fn main() {\n+    assert_eq!(unions(U { a: 5 }), 5);\n+    assert_eq!(tuples((5, 6)), (5, 6));\n+\n+    assert_eq!(unwrap(Some(5)), 5);\n+    assert_eq!(unwrap_deref(Some(&5)), 5);\n+    let mut o = Some(5);\n+    set(&mut o);\n+    assert_eq!(o, Some(10));\n+\n+    assert_eq!(simple_index([0; 10], &[0; 10]), 0);\n+}"}, {"sha": "2f15176a61f20d9ceefced59daa89519772a1c50", "filename": "src/test/mir-opt/building/custom/projections.set.built.after.mir", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fprojections.set.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fprojections.set.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fprojections.set.built.after.mir?ref=ec56537c4325ce5b798fc3628cbdd48ba4949ae5", "patch": "@@ -0,0 +1,10 @@\n+// MIR for `set` after built\n+\n+fn set(_1: &mut Option<i32>) -> () {\n+    let mut _0: ();                      // return place in scope 0 at $DIR/projections.rs:+0:31: +0:31\n+\n+    bb0: {\n+        (((*_1) as variant#1).0: i32) = const 10_i32; // scope 0 at $DIR/projections.rs:+2:9: +2:48\n+        return;                          // scope 0 at $DIR/projections.rs:+3:9: +3:17\n+    }\n+}"}, {"sha": "fc422e4b3f01f27d39397d09ebcb125338244503", "filename": "src/test/mir-opt/building/custom/projections.simple_index.built.after.mir", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fprojections.simple_index.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fprojections.simple_index.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fprojections.simple_index.built.after.mir?ref=ec56537c4325ce5b798fc3628cbdd48ba4949ae5", "patch": "@@ -0,0 +1,13 @@\n+// MIR for `simple_index` after built\n+\n+fn simple_index(_1: [i32; 10], _2: &[i32]) -> i32 {\n+    let mut _0: i32;                     // return place in scope 0 at $DIR/projections.rs:+0:45: +0:48\n+    let mut _3: usize;                   // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+\n+    bb0: {\n+        _3 = const 3_usize;              // scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+        _0 = _1[_3];                     // scope 0 at $DIR/projections.rs:+3:9: +3:22\n+        _0 = (*_2)[_3];                  // scope 0 at $DIR/projections.rs:+4:9: +4:25\n+        return;                          // scope 0 at $DIR/projections.rs:+5:9: +5:17\n+    }\n+}"}, {"sha": "65487d3c9ed4f03d5194eb9b72c82968949c791f", "filename": "src/test/mir-opt/building/custom/projections.tuples.built.after.mir", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fprojections.tuples.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fprojections.tuples.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fprojections.tuples.built.after.mir?ref=ec56537c4325ce5b798fc3628cbdd48ba4949ae5", "patch": "@@ -0,0 +1,13 @@\n+// MIR for `tuples` after built\n+\n+fn tuples(_1: (u32, i32)) -> (u32, i32) {\n+    let mut _0: (u32, i32);              // return place in scope 0 at $DIR/projections.rs:+0:29: +0:39\n+    let mut _2: (u32, i32);              // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+\n+    bb0: {\n+        (_2.0: u32) = (_1.0: u32);       // scope 0 at $DIR/projections.rs:+5:13: +5:25\n+        (_2.1: i32) = (_1.1: i32);       // scope 0 at $DIR/projections.rs:+6:13: +6:25\n+        _0 = _2;                         // scope 0 at $DIR/projections.rs:+8:13: +8:23\n+        return;                          // scope 0 at $DIR/projections.rs:+9:13: +9:21\n+    }\n+}"}, {"sha": "922538a5f17be93c0fc605b20e7efd2d7b18d044", "filename": "src/test/mir-opt/building/custom/projections.unions.built.after.mir", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fprojections.unions.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fprojections.unions.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fprojections.unions.built.after.mir?ref=ec56537c4325ce5b798fc3628cbdd48ba4949ae5", "patch": "@@ -0,0 +1,10 @@\n+// MIR for `unions` after built\n+\n+fn unions(_1: U) -> i32 {\n+    let mut _0: i32;                     // return place in scope 0 at $DIR/projections.rs:+0:20: +0:23\n+\n+    bb0: {\n+        _0 = (_1.0: i32);                // scope 0 at $DIR/projections.rs:+2:9: +2:18\n+        return;                          // scope 0 at $DIR/projections.rs:+3:9: +3:17\n+    }\n+}"}, {"sha": "75b03a3c3930b7651af4bad29e01dde183a108eb", "filename": "src/test/mir-opt/building/custom/projections.unwrap.built.after.mir", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fprojections.unwrap.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fprojections.unwrap.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fprojections.unwrap.built.after.mir?ref=ec56537c4325ce5b798fc3628cbdd48ba4949ae5", "patch": "@@ -0,0 +1,10 @@\n+// MIR for `unwrap` after built\n+\n+fn unwrap(_1: Option<i32>) -> i32 {\n+    let mut _0: i32;                     // return place in scope 0 at $DIR/projections.rs:+0:32: +0:35\n+\n+    bb0: {\n+        _0 = ((_1 as variant#1).0: i32); // scope 0 at $DIR/projections.rs:+2:9: +2:40\n+        return;                          // scope 0 at $DIR/projections.rs:+3:9: +3:17\n+    }\n+}"}, {"sha": "c6b0f7efa9ba0eb3edf939160552e088c4b4f924", "filename": "src/test/mir-opt/building/custom/projections.unwrap_deref.built.after.mir", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fprojections.unwrap_deref.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fprojections.unwrap_deref.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Fprojections.unwrap_deref.built.after.mir?ref=ec56537c4325ce5b798fc3628cbdd48ba4949ae5", "patch": "@@ -0,0 +1,10 @@\n+// MIR for `unwrap_deref` after built\n+\n+fn unwrap_deref(_1: Option<&i32>) -> i32 {\n+    let mut _0: i32;                     // return place in scope 0 at $DIR/projections.rs:+0:39: +0:42\n+\n+    bb0: {\n+        _0 = (*((_1 as variant#1).0: &i32)); // scope 0 at $DIR/projections.rs:+2:9: +2:49\n+        return;                          // scope 0 at $DIR/projections.rs:+3:9: +3:17\n+    }\n+}"}, {"sha": "775e5e3ad9b1278675d38dd8278ce3cb7881cf9a", "filename": "src/test/mir-opt/building/custom/references.raw_pointer.built.after.mir", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.raw_pointer.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.raw_pointer.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.raw_pointer.built.after.mir?ref=ec56537c4325ce5b798fc3628cbdd48ba4949ae5", "patch": "@@ -0,0 +1,10 @@\n+// MIR for `raw_pointer` after built\n+\n+fn raw_pointer(_1: *const i32) -> *const i32 {\n+    let mut _0: *const i32;              // return place in scope 0 at $DIR/references.rs:+0:38: +0:48\n+\n+    bb0: {\n+        _0 = &raw const (*_1);           // scope 0 at $DIR/references.rs:+4:9: +4:27\n+        return;                          // scope 0 at $DIR/references.rs:+5:9: +5:17\n+    }\n+}"}, {"sha": "c93f6ec624b3551784c67643d449ce3a4bce8c7c", "filename": "src/test/mir-opt/building/custom/references.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec56537c4325ce5b798fc3628cbdd48ba4949ae5/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fcustom%2Freferences.rs?ref=ec56537c4325ce5b798fc3628cbdd48ba4949ae5", "patch": "@@ -36,8 +36,22 @@ pub fn immut_ref(x: &i32) -> &i32 {\n     )\n }\n \n+// EMIT_MIR references.raw_pointer.built.after.mir\n+#[custom_mir(dialect = \"built\")]\n+pub fn raw_pointer(x: *const i32) -> *const i32 {\n+    // Regression test for a bug in which unsafetyck was not correctly turned off for\n+    // `dialect = \"built\"`\n+    mir!({\n+        RET = addr_of!(*x);\n+        Return()\n+    })\n+}\n+\n fn main() {\n     let mut x = 5;\n     assert_eq!(*mut_ref(&mut x), 5);\n     assert_eq!(*immut_ref(&x), 5);\n+    unsafe {\n+        assert_eq!(*raw_pointer(addr_of!(x)), 5);\n+    }\n }"}]}