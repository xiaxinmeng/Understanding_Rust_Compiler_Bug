{"sha": "fe4fdcc0f67272de0c9f40da8b699a48bffb719f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlNGZkY2MwZjY3MjcyZGUwYzlmNDBkYThiNjk5YTQ4YmZmYjcxOWY=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-12-03T20:56:39Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-12-08T07:14:21Z"}, "message": "core: make the public fmt API completely safe.", "tree": {"sha": "1761b4bc96998fb19a171fa0197b469df34a5d87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1761b4bc96998fb19a171fa0197b469df34a5d87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe4fdcc0f67272de0c9f40da8b699a48bffb719f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe4fdcc0f67272de0c9f40da8b699a48bffb719f", "html_url": "https://github.com/rust-lang/rust/commit/fe4fdcc0f67272de0c9f40da8b699a48bffb719f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe4fdcc0f67272de0c9f40da8b699a48bffb719f/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c75e8d46c2fc576661c01f9eadb0866b3367ca4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c75e8d46c2fc576661c01f9eadb0866b3367ca4b", "html_url": "https://github.com/rust-lang/rust/commit/c75e8d46c2fc576661c01f9eadb0866b3367ca4b"}], "stats": {"total": 114, "additions": 61, "deletions": 53}, "files": [{"sha": "8b2ffd90ef71529dd948d7033633f47a46fa4e67", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 53, "deletions": 28, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/fe4fdcc0f67272de0c9f40da8b699a48bffb719f/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe4fdcc0f67272de0c9f40da8b699a48bffb719f/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=fe4fdcc0f67272de0c9f40da8b699a48bffb719f", "patch": "@@ -92,6 +92,9 @@ pub struct Formatter<'a> {\n     args: &'a [Argument<'a>],\n }\n \n+// NB. Argument is essentially an optimized partially applied formatting function,\n+// equivalent to `exists T.(&T, fn(&T, &mut Formatter) -> Result`.\n+\n enum Void {}\n \n /// This struct represents the generic \"argument\" which is taken by the Xprintf\n@@ -100,37 +103,66 @@ enum Void {}\n /// types, and then this struct is used to canonicalize arguments to one type.\n #[experimental = \"implementation detail of the `format_args!` macro\"]\n pub struct Argument<'a> {\n-    formatter: extern \"Rust\" fn(&Void, &mut Formatter) -> Result,\n     value: &'a Void,\n+    formatter: fn(&Void, &mut Formatter) -> Result,\n+}\n+\n+impl<'a> Argument<'a> {\n+    #[inline(never)]\n+    fn show_uint(x: &uint, f: &mut Formatter) -> Result {\n+        Show::fmt(x, f)\n+    }\n+\n+    fn new<'a, T>(x: &'a T, f: fn(&T, &mut Formatter) -> Result) -> Argument<'a> {\n+        unsafe {\n+            Argument {\n+                formatter: mem::transmute(f),\n+                value: mem::transmute(x)\n+            }\n+        }\n+    }\n+\n+    fn from_uint<'a>(x: &'a uint) -> Argument<'a> {\n+        Argument::new(x, Argument::show_uint)\n+    }\n+\n+    fn as_uint(&self) -> Option<uint> {\n+        if self.formatter as uint == Argument::show_uint as uint {\n+            Some(unsafe { *(self.value as *const _ as *const uint) })\n+        } else {\n+            None\n+        }\n+    }\n }\n \n impl<'a> Arguments<'a> {\n     /// When using the format_args!() macro, this function is used to generate the\n-    /// Arguments structure. The compiler inserts an `unsafe` block to call this,\n-    /// which is valid because the compiler performs all necessary validation to\n-    /// ensure that the resulting call to format/write would be safe.\n+    /// Arguments structure.\n     #[doc(hidden)] #[inline]\n     #[experimental = \"implementation detail of the `format_args!` macro\"]\n-    pub unsafe fn new<'a>(pieces: &'static [&'static str],\n-                          args: &'a [Argument<'a>]) -> Arguments<'a> {\n+    pub fn new<'a>(pieces: &'a [&'a str],\n+                   args: &'a [Argument<'a>]) -> Arguments<'a> {\n         Arguments {\n-            pieces: mem::transmute(pieces),\n+            pieces: pieces,\n             fmt: None,\n             args: args\n         }\n     }\n \n     /// This function is used to specify nonstandard formatting parameters.\n     /// The `pieces` array must be at least as long as `fmt` to construct\n-    /// a valid Arguments structure.\n+    /// a valid Arguments structure. Also, any `Count` within `fmt` that is\n+    /// `CountIsParam` or `CountIsNextParam` has to point to an argument\n+    /// created with `argumentuint`. However, failing to do so doesn't cause\n+    /// unsafety, but will ignore invalid .\n     #[doc(hidden)] #[inline]\n     #[experimental = \"implementation detail of the `format_args!` macro\"]\n-    pub unsafe fn with_placeholders<'a>(pieces: &'static [&'static str],\n-                                        fmt: &'static [rt::Argument<'static>],\n-                                        args: &'a [Argument<'a>]) -> Arguments<'a> {\n+    pub fn with_placeholders<'a>(pieces: &'a [&'a str],\n+                                 fmt: &'a [rt::Argument<'a>],\n+                                 args: &'a [Argument<'a>]) -> Arguments<'a> {\n         Arguments {\n-            pieces: mem::transmute(pieces),\n-            fmt: Some(mem::transmute(fmt)),\n+            pieces: pieces,\n+            fmt: Some(fmt),\n             args: args\n         }\n     }\n@@ -312,15 +344,13 @@ impl<'a> Formatter<'a> {\n \n     fn getcount(&mut self, cnt: &rt::Count) -> Option<uint> {\n         match *cnt {\n-            rt::CountIs(n) => { Some(n) }\n-            rt::CountImplied => { None }\n+            rt::CountIs(n) => Some(n),\n+            rt::CountImplied => None,\n             rt::CountIsParam(i) => {\n-                let v = self.args[i].value;\n-                unsafe { Some(*(v as *const _ as *const uint)) }\n+                self.args[i].as_uint()\n             }\n             rt::CountIsNextParam => {\n-                let v = self.curarg.next().unwrap().value;\n-                unsafe { Some(*(v as *const _ as *const uint)) }\n+                self.curarg.next().and_then(|arg| arg.as_uint())\n             }\n         }\n     }\n@@ -533,22 +563,17 @@ impl Show for Error {\n /// create the Argument structures that are passed into the `format` function.\n #[doc(hidden)] #[inline]\n #[experimental = \"implementation detail of the `format_args!` macro\"]\n-pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter) -> Result,\n+pub fn argument<'a, T>(f: fn(&T, &mut Formatter) -> Result,\n                        t: &'a T) -> Argument<'a> {\n-    unsafe {\n-        Argument {\n-            formatter: mem::transmute(f),\n-            value: mem::transmute(t)\n-        }\n-    }\n+    Argument::new(t, f)\n }\n \n /// When the compiler determines that the type of an argument *must* be a uint\n-/// (such as for plural), then it invokes this method.\n+/// (such as for width and precision), then it invokes this method.\n #[doc(hidden)] #[inline]\n #[experimental = \"implementation detail of the `format_args!` macro\"]\n pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n-    argument(Show::fmt, s)\n+    Argument::from_uint(s)\n }\n \n // Implementations of the core formatting traits"}, {"sha": "c8fed3dcd16f6f092bdee2ef7cf1adad042e2669", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 8, "deletions": 25, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fe4fdcc0f67272de0c9f40da8b699a48bffb719f/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe4fdcc0f67272de0c9f40da8b699a48bffb719f/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=fe4fdcc0f67272de0c9f40da8b699a48bffb719f", "patch": "@@ -577,17 +577,11 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n \n         // Now create a vector containing all the arguments\n-        let slicename = self.ecx.ident_of(\"__args_vec\");\n-        {\n-            let args = names.into_iter().map(|a| a.unwrap());\n-            let args = locals.into_iter().chain(args);\n-            let args = self.ecx.expr_vec_slice(self.fmtsp, args.collect());\n-            lets.push(self.ecx.stmt_let(self.fmtsp, false, slicename, args));\n-        }\n+        let args = locals.into_iter().chain(names.into_iter().map(|a| a.unwrap()));\n \n         // Now create the fmt::Arguments struct with all our locals we created.\n         let pieces = self.ecx.expr_ident(self.fmtsp, static_str_name);\n-        let args_slice = self.ecx.expr_ident(self.fmtsp, slicename);\n+        let args_slice = self.ecx.expr_vec_slice(self.fmtsp, args.collect());\n \n         let (fn_name, fn_args) = if self.all_pieces_simple {\n             (\"new\", vec![pieces, args_slice])\n@@ -602,29 +596,18 @@ impl<'a, 'b> Context<'a, 'b> {\n                 self.ecx.ident_of(\"Arguments\"),\n                 self.ecx.ident_of(fn_name)), fn_args);\n \n-        // We did all the work of making sure that the arguments\n-        // structure is safe, so we can safely have an unsafe block.\n-        let result = self.ecx.expr_block(P(ast::Block {\n-           view_items: Vec::new(),\n-           stmts: Vec::new(),\n-           expr: Some(result),\n-           id: ast::DUMMY_NODE_ID,\n-           rules: ast::UnsafeBlock(ast::CompilerGenerated),\n-           span: self.fmtsp,\n-        }));\n-        let resname = self.ecx.ident_of(\"__args\");\n-        lets.push(self.ecx.stmt_let(self.fmtsp, false, resname, result));\n-        let res = self.ecx.expr_ident(self.fmtsp, resname);\n         let result = match invocation {\n             Call(e) => {\n                 let span = e.span;\n-                self.ecx.expr_call(span, e,\n-                                   vec!(self.ecx.expr_addr_of(span, res)))\n+                self.ecx.expr_call(span, e, vec![\n+                    self.ecx.expr_addr_of(span, result)\n+                ])\n             }\n             MethodCall(e, m) => {\n                 let span = e.span;\n-                self.ecx.expr_method_call(span, e, m,\n-                                          vec!(self.ecx.expr_addr_of(span, res)))\n+                self.ecx.expr_method_call(span, e, m, vec![\n+                    self.ecx.expr_addr_of(span, result)\n+                ])\n             }\n         };\n         let body = self.ecx.expr_block(self.ecx.block(self.fmtsp, lets,"}]}