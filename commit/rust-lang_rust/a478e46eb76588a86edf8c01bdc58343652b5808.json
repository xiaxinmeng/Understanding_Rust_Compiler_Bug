{"sha": "a478e46eb76588a86edf8c01bdc58343652b5808", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0NzhlNDZlYjc2NTg4YTg2ZWRmOGMwMWJkYzU4MzQzNjUyYjU4MDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-07T13:57:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-07T13:57:36Z"}, "message": "Auto merge of #40857 - estebank:recursive, r=arielb1\n\nPoint at fields that make the type recursive\n\nOn recursive types of infinite size, point at all the fields that make\nthe type recursive.\n\n```rust\nstruct Foo {\n    bar: Bar,\n}\n\nstruct Bar {\n    foo: Foo,\n}\n```\n\noutputs\n\n```\nerror[E0072]: recursive type `Foo` has infinite size\n --> file.rs:1:1\n1 | struct Foo {\n  | ^^^^^^^^^^ recursive type has infinite size\n2 |     bar: Bar,\n  |     -------- recursive here\n  |\n  = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Foo` representable\n\nerror[E0072]: recursive type `Bar` has infinite size\n --> file.rs:5:1\n  |\n5 | struct Bar {\n  | ^^^^^^^^^^ recursive type has infinite size\n6 |     foo: Foo,\n  |     -------- recursive here\n  |\n  = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Bar` representable\n```", "tree": {"sha": "4f9719d6eac89dcd095a4d6daeed333c09a2d4ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f9719d6eac89dcd095a4d6daeed333c09a2d4ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a478e46eb76588a86edf8c01bdc58343652b5808", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a478e46eb76588a86edf8c01bdc58343652b5808", "html_url": "https://github.com/rust-lang/rust/commit/a478e46eb76588a86edf8c01bdc58343652b5808", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a478e46eb76588a86edf8c01bdc58343652b5808/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ced823e267c132fab172b1890b24073995e79ffa", "url": "https://api.github.com/repos/rust-lang/rust/commits/ced823e267c132fab172b1890b24073995e79ffa", "html_url": "https://github.com/rust-lang/rust/commit/ced823e267c132fab172b1890b24073995e79ffa"}, {"sha": "a4fc9251920260e1b0b3dff71c8da8b3af2c5453", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4fc9251920260e1b0b3dff71c8da8b3af2c5453", "html_url": "https://github.com/rust-lang/rust/commit/a4fc9251920260e1b0b3dff71c8da8b3af2c5453"}], "stats": {"total": 145, "additions": 119, "deletions": 26}, "files": [{"sha": "06d09bd350a4c8eab5002311887379924ba4bdfd", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a478e46eb76588a86edf8c01bdc58343652b5808/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a478e46eb76588a86edf8c01bdc58343652b5808/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=a478e46eb76588a86edf8c01bdc58343652b5808", "patch": "@@ -145,11 +145,11 @@ pub enum CopyImplementationError<'tcx> {\n ///\n /// The ordering of the cases is significant. They are sorted so that cmp::max\n /// will keep the \"more erroneous\" of two values.\n-#[derive(Copy, Clone, PartialOrd, Ord, Eq, PartialEq, Debug)]\n+#[derive(Clone, PartialOrd, Ord, Eq, PartialEq, Debug)]\n pub enum Representability {\n     Representable,\n     ContainsRecursive,\n-    SelfRecursive,\n+    SelfRecursive(Vec<Span>),\n }\n \n impl<'tcx> ParameterEnvironment<'tcx> {\n@@ -1006,37 +1006,51 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n \n     /// Check whether a type is representable. This means it cannot contain unboxed\n     /// structural recursion. This check is needed for structs and enums.\n-    pub fn is_representable(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span)\n+    pub fn is_representable(&'tcx self,\n+                            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            sp: Span)\n                             -> Representability {\n \n         // Iterate until something non-representable is found\n-        fn find_nonrepresentable<'a, 'tcx, It>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                               sp: Span,\n-                                               seen: &mut Vec<Ty<'tcx>>,\n-                                               iter: It)\n-                                               -> Representability\n-        where It: Iterator<Item=Ty<'tcx>> {\n-            iter.fold(Representability::Representable,\n-                      |r, ty| cmp::max(r, is_type_structurally_recursive(tcx, sp, seen, ty)))\n+        fn fold_repr<It: Iterator<Item=Representability>>(iter: It) -> Representability {\n+            iter.fold(Representability::Representable, |r1, r2| {\n+                match (r1, r2) {\n+                    (Representability::SelfRecursive(v1),\n+                     Representability::SelfRecursive(v2)) => {\n+                        Representability::SelfRecursive(v1.iter().map(|s| *s).chain(v2).collect())\n+                    }\n+                    (r1, r2) => cmp::max(r1, r2)\n+                }\n+            })\n         }\n \n         fn are_inner_types_recursive<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span,\n                                                seen: &mut Vec<Ty<'tcx>>, ty: Ty<'tcx>)\n                                                -> Representability {\n             match ty.sty {\n                 TyTuple(ref ts, _) => {\n-                    find_nonrepresentable(tcx, sp, seen, ts.iter().cloned())\n+                    // Find non representable\n+                    fold_repr(ts.iter().map(|ty| {\n+                        is_type_structurally_recursive(tcx, sp, seen, ty)\n+                    }))\n                 }\n                 // Fixed-length vectors.\n                 // FIXME(#11924) Behavior undecided for zero-length vectors.\n                 TyArray(ty, _) => {\n                     is_type_structurally_recursive(tcx, sp, seen, ty)\n                 }\n                 TyAdt(def, substs) => {\n-                    find_nonrepresentable(tcx,\n-                                          sp,\n-                                          seen,\n-                                          def.all_fields().map(|f| f.ty(tcx, substs)))\n+                    // Find non representable fields with their spans\n+                    fold_repr(def.all_fields().map(|field| {\n+                        let ty = field.ty(tcx, substs);\n+                        let span = tcx.hir.span_if_local(field.did).unwrap_or(sp);\n+                        match is_type_structurally_recursive(tcx, span, seen, ty) {\n+                            Representability::SelfRecursive(_) => {\n+                                Representability::SelfRecursive(vec![span])\n+                            }\n+                            x => x,\n+                        }\n+                    }))\n                 }\n                 TyClosure(..) => {\n                     // this check is run on type definitions, so we don't expect\n@@ -1075,7 +1089,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                                                     sp: Span,\n                                                     seen: &mut Vec<Ty<'tcx>>,\n                                                     ty: Ty<'tcx>) -> Representability {\n-            debug!(\"is_type_structurally_recursive: {:?}\", ty);\n+            debug!(\"is_type_structurally_recursive: {:?} {:?}\", ty, sp);\n \n             match ty.sty {\n                 TyAdt(def, _) => {\n@@ -1096,7 +1110,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                                 debug!(\"SelfRecursive: {:?} contains {:?}\",\n                                        seen_type,\n                                        ty);\n-                                return Representability::SelfRecursive;\n+                                return Representability::SelfRecursive(vec![sp]);\n                             }\n                         }\n "}, {"sha": "2e29aeeb02214b89d65729919dbbed0e13c06339", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a478e46eb76588a86edf8c01bdc58343652b5808/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a478e46eb76588a86edf8c01bdc58343652b5808/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a478e46eb76588a86edf8c01bdc58343652b5808", "patch": "@@ -1374,8 +1374,12 @@ fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // contain themselves. For case 2, there must be an inner type that will be\n     // caught by case 1.\n     match rty.is_representable(tcx, sp) {\n-        Representability::SelfRecursive => {\n-            tcx.recursive_type_with_infinite_size_error(item_def_id).emit();\n+        Representability::SelfRecursive(spans) => {\n+            let mut err = tcx.recursive_type_with_infinite_size_error(item_def_id);\n+            for span in spans {\n+                err.span_label(span, &\"recursive without indirection\");\n+            }\n+            err.emit();\n             return false\n         }\n         Representability::Representable | Representability::ContainsRecursive => (),"}, {"sha": "7ca6d9301a689349dd12362f1cd55184b1385003", "filename": "src/test/compile-fail/issue-3008-1.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a478e46eb76588a86edf8c01bdc58343652b5808/src%2Ftest%2Fcompile-fail%2Fissue-3008-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a478e46eb76588a86edf8c01bdc58343652b5808/src%2Ftest%2Fcompile-fail%2Fissue-3008-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3008-1.rs?ref=a478e46eb76588a86edf8c01bdc58343652b5808", "patch": "@@ -8,9 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum foo { foo_(bar) }\n-enum bar { bar_none, bar_some(bar) }\n-//~^ ERROR recursive type `bar` has infinite size\n+enum Foo {\n+    Foo_(Bar)\n+}\n+\n+enum Bar {\n+    //~^ ERROR recursive type `Bar` has infinite size\n+    //~| NOTE recursive type has infinite size\n+    BarNone,\n+    BarSome(Bar)  //~ NOTE recursive without indirection\n+}\n \n fn main() {\n }"}, {"sha": "061d1facda0ca7cf13232e389b8e89b775a5824d", "filename": "src/test/compile-fail/issue-3008-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a478e46eb76588a86edf8c01bdc58343652b5808/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a478e46eb76588a86edf8c01bdc58343652b5808/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs?ref=a478e46eb76588a86edf8c01bdc58343652b5808", "patch": "@@ -12,6 +12,7 @@ enum foo { foo_(bar) }\n struct bar { x: bar }\n //~^ ERROR E0072\n //~| NOTE recursive type has infinite size\n+//~| NOTE recursive without indirection\n \n fn main() {\n }"}, {"sha": "70a7cd8b9702128acfaaf0e373c5c9fcbc0cb95e", "filename": "src/test/compile-fail/issue-32326.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a478e46eb76588a86edf8c01bdc58343652b5808/src%2Ftest%2Fcompile-fail%2Fissue-32326.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a478e46eb76588a86edf8c01bdc58343652b5808/src%2Ftest%2Fcompile-fail%2Fissue-32326.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32326.rs?ref=a478e46eb76588a86edf8c01bdc58343652b5808", "patch": "@@ -15,6 +15,8 @@\n enum Expr { //~ ERROR E0072\n             //~| NOTE recursive type has infinite size\n     Plus(Expr, Expr),\n+    //~^ NOTE recursive without indirection\n+    //~| NOTE recursive without indirection\n     Literal(i64),\n }\n "}, {"sha": "10f73dc086288aed40084f0bb3e441dc20a33f60", "filename": "src/test/compile-fail/issue-3779.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a478e46eb76588a86edf8c01bdc58343652b5808/src%2Ftest%2Fcompile-fail%2Fissue-3779.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a478e46eb76588a86edf8c01bdc58343652b5808/src%2Ftest%2Fcompile-fail%2Fissue-3779.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3779.rs?ref=a478e46eb76588a86edf8c01bdc58343652b5808", "patch": "@@ -8,9 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct S { //~ ERROR E0072\n-           //~| NOTE recursive type has infinite size\n+struct S {\n+    //~^ ERROR E0072\n+    //~| NOTE recursive type has infinite size\n     element: Option<S>\n+    //~^ NOTE recursive without indirection\n }\n \n fn main() {"}, {"sha": "5dd76ce32c7a401ab0d47f1d674cee2fe8386154", "filename": "src/test/compile-fail/type-recursive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a478e46eb76588a86edf8c01bdc58343652b5808/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a478e46eb76588a86edf8c01bdc58343652b5808/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs?ref=a478e46eb76588a86edf8c01bdc58343652b5808", "patch": "@@ -11,7 +11,7 @@\n struct t1 { //~ ERROR E0072\n             //~| NOTE recursive type has infinite size\n     foo: isize,\n-    foolish: t1\n+    foolish: t1  //~ NOTE recursive without indirection\n }\n \n fn main() { }"}, {"sha": "1f6dd6b1d165f52c9eb3f5e257ccce7dcafd4718", "filename": "src/test/ui/span/E0072.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a478e46eb76588a86edf8c01bdc58343652b5808/src%2Ftest%2Fui%2Fspan%2FE0072.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a478e46eb76588a86edf8c01bdc58343652b5808/src%2Ftest%2Fui%2Fspan%2FE0072.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2FE0072.stderr?ref=a478e46eb76588a86edf8c01bdc58343652b5808", "patch": "@@ -3,6 +3,9 @@ error[E0072]: recursive type `ListNode` has infinite size\n    |\n 11 | struct ListNode {\n    | ^^^^^^^^^^^^^^^ recursive type has infinite size\n+12 |     head: u8,\n+13 |     tail: Option<ListNode>,\n+   |     ---------------------- recursive without indirection\n    |\n    = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `ListNode` representable\n "}, {"sha": "a06cbd04deb4fb4a32bc030387426608e8a913fd", "filename": "src/test/ui/span/multiline-span-E0072.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a478e46eb76588a86edf8c01bdc58343652b5808/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a478e46eb76588a86edf8c01bdc58343652b5808/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.stderr?ref=a478e46eb76588a86edf8c01bdc58343652b5808", "patch": "@@ -6,6 +6,7 @@ error[E0072]: recursive type `ListNode` has infinite size\n 14 | | {\n 15 | |     head: u8,\n 16 | |     tail: Option<ListNode>,\n+   | |     ---------------------- recursive without indirection\n 17 | | }\n    | |_^ recursive type has infinite size\n    |"}, {"sha": "6fef4d30f7a77cc21070848c97d0cd44ffb4450f", "filename": "src/test/ui/span/recursive-type-field.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a478e46eb76588a86edf8c01bdc58343652b5808/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a478e46eb76588a86edf8c01bdc58343652b5808/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.rs?ref=a478e46eb76588a86edf8c01bdc58343652b5808", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::rc::Rc;\n+\n+struct Foo<'a> {\n+    bar: Bar<'a>,\n+    b: Rc<Bar<'a>>,\n+}\n+\n+struct Bar<'a> {\n+    y: (Foo<'a>, Foo<'a>),\n+    z: Option<Bar<'a>>,\n+    a: &'a Foo<'a>,\n+    c: &'a [Bar<'a>],\n+    d: [Bar<'a>; 1],\n+    e: Foo<'a>,\n+    x: Bar<'a>,\n+}\n+\n+fn main() {}"}, {"sha": "b4d0b5a6a25d03557028beec40e27409ccb2b19e", "filename": "src/test/ui/span/recursive-type-field.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a478e46eb76588a86edf8c01bdc58343652b5808/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a478e46eb76588a86edf8c01bdc58343652b5808/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Frecursive-type-field.stderr?ref=a478e46eb76588a86edf8c01bdc58343652b5808", "patch": "@@ -0,0 +1,31 @@\n+error[E0072]: recursive type `Foo` has infinite size\n+  --> $DIR/recursive-type-field.rs:13:1\n+   |\n+13 | struct Foo<'a> {\n+   | ^^^^^^^^^^^^^^ recursive type has infinite size\n+14 |     bar: Bar<'a>,\n+   |     ------------ recursive without indirection\n+   |\n+   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Foo` representable\n+\n+error[E0072]: recursive type `Bar` has infinite size\n+  --> $DIR/recursive-type-field.rs:18:1\n+   |\n+18 | struct Bar<'a> {\n+   | ^^^^^^^^^^^^^^ recursive type has infinite size\n+19 |     y: (Foo<'a>, Foo<'a>),\n+   |     --------------------- recursive without indirection\n+20 |     z: Option<Bar<'a>>,\n+   |     ------------------ recursive without indirection\n+...\n+23 |     d: [Bar<'a>; 1],\n+   |     --------------- recursive without indirection\n+24 |     e: Foo<'a>,\n+   |     ---------- recursive without indirection\n+25 |     x: Bar<'a>,\n+   |     ---------- recursive without indirection\n+   |\n+   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `Bar` representable\n+\n+error: aborting due to 2 previous errors\n+"}]}