{"sha": "904c2701496143e089e01b3a10ccbe7eaa1bf9e5", "node_id": "C_kwDOAAsO6NoAKDkwNGMyNzAxNDk2MTQzZTA4OWUwMWIzYTEwY2NiZTdlYWExYmY5ZTU", "commit": {"author": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2021-11-19T01:26:30Z"}, "committer": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2022-01-18T22:25:26Z"}, "message": "More comments and small cleanups", "tree": {"sha": "30e5c2d8035566e12e6df6ee4817d55606722f6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30e5c2d8035566e12e6df6ee4817d55606722f6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/904c2701496143e089e01b3a10ccbe7eaa1bf9e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/904c2701496143e089e01b3a10ccbe7eaa1bf9e5", "html_url": "https://github.com/rust-lang/rust/commit/904c2701496143e089e01b3a10ccbe7eaa1bf9e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/904c2701496143e089e01b3a10ccbe7eaa1bf9e5/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b39fb9bb7bfed503e85c44913e0fe57825f380fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/b39fb9bb7bfed503e85c44913e0fe57825f380fb", "html_url": "https://github.com/rust-lang/rust/commit/b39fb9bb7bfed503e85c44913e0fe57825f380fb"}], "stats": {"total": 220, "additions": 108, "deletions": 112}, "files": [{"sha": "fdf93e5893247aa94bc69cef4af37127b8dd80e4", "filename": "compiler/rustc_passes/src/region.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/904c2701496143e089e01b3a10ccbe7eaa1bf9e5/compiler%2Frustc_passes%2Fsrc%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/904c2701496143e089e01b3a10ccbe7eaa1bf9e5/compiler%2Frustc_passes%2Fsrc%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fregion.rs?ref=904c2701496143e089e01b3a10ccbe7eaa1bf9e5", "patch": "@@ -255,6 +255,7 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n             hir::ExprKind::AssignOp(..)\n             | hir::ExprKind::Index(..)\n             | hir::ExprKind::Unary(..)\n+            | hir::ExprKind::Call(..)\n             | hir::ExprKind::MethodCall(..) => {\n                 // FIXME(https://github.com/rust-lang/rfcs/issues/811) Nested method calls\n                 //"}, {"sha": "0df56dd2ee815ed9c8f08daa0c5d8319851de1aa", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 107, "deletions": 107, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/904c2701496143e089e01b3a10ccbe7eaa1bf9e5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/904c2701496143e089e01b3a10ccbe7eaa1bf9e5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=904c2701496143e089e01b3a10ccbe7eaa1bf9e5", "patch": "@@ -182,39 +182,6 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n             }\n         }\n     }\n-\n-    fn visit_call(\n-        &mut self,\n-        call_expr: &'tcx Expr<'tcx>,\n-        callee: &'tcx Expr<'tcx>,\n-        args: &'tcx [Expr<'tcx>],\n-    ) {\n-        match &callee.kind {\n-            ExprKind::Path(qpath) => {\n-                let res = self.fcx.typeck_results.borrow().qpath_res(qpath, callee.hir_id);\n-                match res {\n-                    // Direct calls never need to keep the callee `ty::FnDef`\n-                    // ZST in a temporary, so skip its type, just in case it\n-                    // can significantly complicate the generator type.\n-                    Res::Def(\n-                        DefKind::Fn | DefKind::AssocFn | DefKind::Ctor(_, CtorKind::Fn),\n-                        _,\n-                    ) => {\n-                        // NOTE(eddyb) this assumes a path expression has\n-                        // no nested expressions to keep track of.\n-                        self.expr_count += 1;\n-\n-                        // Record the rest of the call expression normally.\n-                        for arg in args {\n-                            self.visit_expr(arg);\n-                        }\n-                    }\n-                    _ => intravisit::walk_expr(self, call_expr),\n-                }\n-            }\n-            _ => intravisit::walk_expr(self, call_expr),\n-        }\n-    }\n }\n \n pub fn resolve_interior<'a, 'tcx>(\n@@ -252,7 +219,6 @@ pub fn resolve_interior<'a, 'tcx>(\n         intravisit::walk_body(&mut drop_range_visitor, body);\n \n         drop_range_visitor.drop_ranges.propagate_to_fixpoint();\n-        // drop_range_visitor.drop_ranges.save_graph(\"drop_ranges.dot\");\n \n         InteriorVisitor {\n             fcx,\n@@ -395,7 +361,31 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         let mut guard_borrowing_from_pattern = false;\n \n         match &expr.kind {\n-            ExprKind::Call(callee, args) => self.visit_call(expr, callee, args),\n+            ExprKind::Call(callee, args) => match &callee.kind {\n+                ExprKind::Path(qpath) => {\n+                    let res = self.fcx.typeck_results.borrow().qpath_res(qpath, callee.hir_id);\n+                    match res {\n+                        // Direct calls never need to keep the callee `ty::FnDef`\n+                        // ZST in a temporary, so skip its type, just in case it\n+                        // can significantly complicate the generator type.\n+                        Res::Def(\n+                            DefKind::Fn | DefKind::AssocFn | DefKind::Ctor(_, CtorKind::Fn),\n+                            _,\n+                        ) => {\n+                            // NOTE(eddyb) this assumes a path expression has\n+                            // no nested expressions to keep track of.\n+                            self.expr_count += 1;\n+\n+                            // Record the rest of the call expression normally.\n+                            for arg in args.iter() {\n+                                self.visit_expr(arg);\n+                            }\n+                        }\n+                        _ => intravisit::walk_expr(self, expr),\n+                    }\n+                }\n+                _ => intravisit::walk_expr(self, expr),\n+            },\n             ExprKind::Path(qpath) => {\n                 intravisit::walk_expr(self, expr);\n                 let res = self.fcx.typeck_results.borrow().qpath_res(qpath, expr.hir_id);\n@@ -675,6 +665,26 @@ fn check_must_not_suspend_def(\n     false\n }\n \n+// The following structs and impls are used for drop range analysis.\n+//\n+// Drop range analysis finds the portions of the tree where a value is guaranteed to be dropped\n+// (i.e. moved, uninitialized, etc.). This is used to exclude the types of those values from the\n+// generator type. See `InteriorVisitor::record` for where the results of this analysis are used.\n+//\n+// There are three phases to this analysis:\n+// 1. Use `ExprUseVisitor` to identify the interesting values that are consumed and borrowed.\n+// 2. Use `DropRangeVisitor` to find where the interesting values are dropped or reinitialized,\n+//    and also build a control flow graph.\n+// 3. Use `DropRanges::propagate_to_fixpoint` to flow the dropped/reinitialized information through\n+//    the CFG and find the exact points where we know a value is definitely dropped.\n+//\n+// The end result is a data structure that maps the post-order index of each node in the HIR tree\n+// to a set of values that are known to be dropped at that location.\n+\n+/// Works with ExprUseVisitor to find interesting values for the drop range analysis.\n+///\n+/// Interesting values are those that are either dropped or borrowed. For dropped values, we also\n+/// record the parent expression, which is the point where the drop actually takes place.\n struct ExprUseDelegate<'tcx> {\n     hir: Map<'tcx>,\n     /// Maps a HirId to a set of HirIds that are dropped by that node.\n@@ -691,7 +701,65 @@ impl<'tcx> ExprUseDelegate<'tcx> {\n     }\n }\n \n-/// This struct facilitates computing the ranges for which a place is uninitialized.\n+impl<'tcx> expr_use_visitor::Delegate<'tcx> for ExprUseDelegate<'tcx> {\n+    fn consume(\n+        &mut self,\n+        place_with_id: &expr_use_visitor::PlaceWithHirId<'tcx>,\n+        diag_expr_id: hir::HirId,\n+    ) {\n+        let parent = match self.hir.find_parent_node(place_with_id.hir_id) {\n+            Some(parent) => parent,\n+            None => place_with_id.hir_id,\n+        };\n+        debug!(\n+            \"consume {:?}; diag_expr_id={:?}, using parent {:?}\",\n+            place_with_id, diag_expr_id, parent\n+        );\n+        self.mark_consumed(parent, place_with_id.hir_id);\n+        place_hir_id(&place_with_id.place).map(|place| self.mark_consumed(parent, place));\n+    }\n+\n+    fn borrow(\n+        &mut self,\n+        place_with_id: &expr_use_visitor::PlaceWithHirId<'tcx>,\n+        _diag_expr_id: hir::HirId,\n+        _bk: rustc_middle::ty::BorrowKind,\n+    ) {\n+        place_hir_id(&place_with_id.place).map(|place| self.borrowed_places.insert(place));\n+    }\n+\n+    fn mutate(\n+        &mut self,\n+        _assignee_place: &expr_use_visitor::PlaceWithHirId<'tcx>,\n+        _diag_expr_id: hir::HirId,\n+    ) {\n+    }\n+\n+    fn fake_read(\n+        &mut self,\n+        _place: expr_use_visitor::Place<'tcx>,\n+        _cause: rustc_middle::mir::FakeReadCause,\n+        _diag_expr_id: hir::HirId,\n+    ) {\n+    }\n+}\n+\n+/// Gives the hir_id associated with a place if one exists. This is the hir_id that we want to\n+/// track for a value in the drop range analysis.\n+fn place_hir_id(place: &Place<'_>) -> Option<HirId> {\n+    match place.base {\n+        PlaceBase::Rvalue | PlaceBase::StaticItem => None,\n+        PlaceBase::Local(hir_id)\n+        | PlaceBase::Upvar(ty::UpvarId { var_path: ty::UpvarPath { hir_id }, .. }) => Some(hir_id),\n+    }\n+}\n+\n+/// This struct is used to gather the information for `DropRanges` to determine the regions of the\n+/// HIR tree for which a value is dropped.\n+///\n+/// We are interested in points where a variables is dropped or initialized, and the control flow\n+/// of the code. We identify locations in code by their post-order traversal index, so it is\n+/// important for this traversal to match that in `RegionResolutionVisitor` and `InteriorVisitor`.\n struct DropRangeVisitor<'tcx> {\n     hir: Map<'tcx>,\n     /// Maps a HirId to a set of HirIds that are dropped by that node.\n@@ -756,6 +824,9 @@ impl<'tcx> DropRangeVisitor<'tcx> {\n     }\n }\n \n+/// Applies `f` to consumable portion of a HIR node.\n+///\n+/// The `node` parameter should be the result of calling `Map::find(place)`.\n fn for_each_consumable(place: HirId, node: Option<Node<'_>>, mut f: impl FnMut(HirId)) {\n     f(place);\n     if let Some(Node::Expr(expr)) = node {\n@@ -771,57 +842,6 @@ fn for_each_consumable(place: HirId, node: Option<Node<'_>>, mut f: impl FnMut(H\n     }\n }\n \n-fn place_hir_id(place: &Place<'_>) -> Option<HirId> {\n-    match place.base {\n-        PlaceBase::Rvalue | PlaceBase::StaticItem => None,\n-        PlaceBase::Local(hir_id)\n-        | PlaceBase::Upvar(ty::UpvarId { var_path: ty::UpvarPath { hir_id }, .. }) => Some(hir_id),\n-    }\n-}\n-\n-impl<'tcx> expr_use_visitor::Delegate<'tcx> for ExprUseDelegate<'tcx> {\n-    fn consume(\n-        &mut self,\n-        place_with_id: &expr_use_visitor::PlaceWithHirId<'tcx>,\n-        diag_expr_id: hir::HirId,\n-    ) {\n-        let parent = match self.hir.find_parent_node(place_with_id.hir_id) {\n-            Some(parent) => parent,\n-            None => place_with_id.hir_id,\n-        };\n-        debug!(\n-            \"consume {:?}; diag_expr_id={:?}, using parent {:?}\",\n-            place_with_id, diag_expr_id, parent\n-        );\n-        self.mark_consumed(parent, place_with_id.hir_id);\n-        place_hir_id(&place_with_id.place).map(|place| self.mark_consumed(parent, place));\n-    }\n-\n-    fn borrow(\n-        &mut self,\n-        place_with_id: &expr_use_visitor::PlaceWithHirId<'tcx>,\n-        _diag_expr_id: hir::HirId,\n-        _bk: rustc_middle::ty::BorrowKind,\n-    ) {\n-        place_hir_id(&place_with_id.place).map(|place| self.borrowed_places.insert(place));\n-    }\n-\n-    fn mutate(\n-        &mut self,\n-        _assignee_place: &expr_use_visitor::PlaceWithHirId<'tcx>,\n-        _diag_expr_id: hir::HirId,\n-    ) {\n-    }\n-\n-    fn fake_read(\n-        &mut self,\n-        _place: expr_use_visitor::Place<'tcx>,\n-        _cause: rustc_middle::mir::FakeReadCause,\n-        _diag_expr_id: hir::HirId,\n-    ) {\n-    }\n-}\n-\n impl<'tcx> Visitor<'tcx> for DropRangeVisitor<'tcx> {\n     type Map = intravisit::ErasedMap<'tcx>;\n \n@@ -832,26 +852,6 @@ impl<'tcx> Visitor<'tcx> for DropRangeVisitor<'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         let mut reinit = None;\n         match expr.kind {\n-            // ExprKind::AssignOp(_op, lhs, rhs) => {\n-            //     // These operations are weird because their order of evaluation depends on whether\n-            //     // the operator is overloaded. In a perfect world, we'd just ask the type checker\n-            //     // whether this is a method call, but we also need to match the expression IDs\n-            //     // from RegionResolutionVisitor. RegionResolutionVisitor doesn't know the order,\n-            //     // so it runs both orders and picks the most conservative. We'll mirror that here.\n-            //     let mut old_count = self.expr_count;\n-            //     self.visit_expr(lhs);\n-            //     self.visit_expr(rhs);\n-\n-            //     let old_drops = self.swap_drop_ranges(<_>::default());\n-            //     std::mem::swap(&mut old_count, &mut self.expr_count);\n-            //     self.visit_expr(rhs);\n-            //     self.visit_expr(lhs);\n-\n-            //     // We should have visited the same number of expressions in either order.\n-            //     assert_eq!(old_count, self.expr_count);\n-\n-            //     self.intersect_drop_ranges(old_drops);\n-            // }\n             ExprKind::If(test, if_true, if_false) => {\n                 self.visit_expr(test);\n "}, {"sha": "d497210b434619216c5e6ed454f63991dd6eb1d4", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/904c2701496143e089e01b3a10ccbe7eaa1bf9e5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/904c2701496143e089e01b3a10ccbe7eaa1bf9e5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs?ref=904c2701496143e089e01b3a10ccbe7eaa1bf9e5", "patch": "@@ -203,11 +203,6 @@ impl DropRanges {\n         }\n         preds\n     }\n-\n-    // pub fn save_graph(&self, filename: &str) {\n-    //     use std::fs::File;\n-    //     dot::render(self, &mut File::create(filename).unwrap()).unwrap();\n-    // }\n }\n \n impl<'a> dot::GraphWalk<'a> for DropRanges {"}]}