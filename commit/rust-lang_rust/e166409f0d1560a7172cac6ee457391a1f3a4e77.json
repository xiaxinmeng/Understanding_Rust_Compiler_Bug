{"sha": "e166409f0d1560a7172cac6ee457391a1f3a4e77", "node_id": "C_kwDOAAsO6NoAKGUxNjY0MDlmMGQxNTYwYTcxNzJjYWM2ZWU0NTczOTFhMWYzYTRlNzc", "commit": {"author": {"name": "Miguel Guarniz", "email": "mi9uel9@gmail.com", "date": "2022-05-05T17:34:27Z"}, "committer": {"name": "Miguel Guarniz", "email": "mi9uel9@gmail.com", "date": "2022-05-13T15:46:06Z"}, "message": "remove Visitor impl for PrivateItemsInPublicInterfacesChecker\n\nSigned-off-by: Miguel Guarniz <mi9uel9@gmail.com>", "tree": {"sha": "85befea94c2bd68ae26bcba7ae695558bef8988f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85befea94c2bd68ae26bcba7ae695558bef8988f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e166409f0d1560a7172cac6ee457391a1f3a4e77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e166409f0d1560a7172cac6ee457391a1f3a4e77", "html_url": "https://github.com/rust-lang/rust/commit/e166409f0d1560a7172cac6ee457391a1f3a4e77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e166409f0d1560a7172cac6ee457391a1f3a4e77/comments", "author": {"login": "kckeiks", "id": 24687641, "node_id": "MDQ6VXNlcjI0Njg3NjQx", "avatar_url": "https://avatars.githubusercontent.com/u/24687641?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kckeiks", "html_url": "https://github.com/kckeiks", "followers_url": "https://api.github.com/users/kckeiks/followers", "following_url": "https://api.github.com/users/kckeiks/following{/other_user}", "gists_url": "https://api.github.com/users/kckeiks/gists{/gist_id}", "starred_url": "https://api.github.com/users/kckeiks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kckeiks/subscriptions", "organizations_url": "https://api.github.com/users/kckeiks/orgs", "repos_url": "https://api.github.com/users/kckeiks/repos", "events_url": "https://api.github.com/users/kckeiks/events{/privacy}", "received_events_url": "https://api.github.com/users/kckeiks/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kckeiks", "id": 24687641, "node_id": "MDQ6VXNlcjI0Njg3NjQx", "avatar_url": "https://avatars.githubusercontent.com/u/24687641?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kckeiks", "html_url": "https://github.com/kckeiks", "followers_url": "https://api.github.com/users/kckeiks/followers", "following_url": "https://api.github.com/users/kckeiks/following{/other_user}", "gists_url": "https://api.github.com/users/kckeiks/gists{/gist_id}", "starred_url": "https://api.github.com/users/kckeiks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kckeiks/subscriptions", "organizations_url": "https://api.github.com/users/kckeiks/orgs", "repos_url": "https://api.github.com/users/kckeiks/repos", "events_url": "https://api.github.com/users/kckeiks/events{/privacy}", "received_events_url": "https://api.github.com/users/kckeiks/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8ef5bf464f142948b7cc061ca2bb4304df088ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8ef5bf464f142948b7cc061ca2bb4304df088ff", "html_url": "https://github.com/rust-lang/rust/commit/e8ef5bf464f142948b7cc061ca2bb4304df088ff"}], "stats": {"total": 176, "additions": 95, "deletions": 81}, "files": [{"sha": "0bcb0719f9ba751750b340efe7a8c6382d61dd60", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 95, "deletions": 81, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/e166409f0d1560a7172cac6ee457391a1f3a4e77/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e166409f0d1560a7172cac6ee457391a1f3a4e77/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=e166409f0d1560a7172cac6ee457391a1f3a4e77", "patch": "@@ -14,8 +14,8 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId, LocalDefIdSet, CRATE_DEF_ID};\n-use rustc_hir::intravisit::{self, DeepVisitor, Visitor};\n-use rustc_hir::{AssocItemKind, HirIdSet, Node, PatKind};\n+use rustc_hir::intravisit::{self, Visitor};\n+use rustc_hir::{AssocItemKind, HirIdSet, ItemId, Node, PatKind};\n use rustc_middle::bug;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::privacy::{AccessLevel, AccessLevels};\n@@ -1802,12 +1802,12 @@ impl<'tcx> DefIdVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'tcx> {\n     }\n }\n \n-struct PrivateItemsInPublicInterfacesVisitor<'tcx> {\n+struct PrivateItemsInPublicInterfacesChecker<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     old_error_set_ancestry: LocalDefIdSet,\n }\n \n-impl<'tcx> PrivateItemsInPublicInterfacesVisitor<'tcx> {\n+impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n     fn check(\n         &self,\n         def_id: LocalDefId,\n@@ -1841,110 +1841,121 @@ impl<'tcx> PrivateItemsInPublicInterfacesVisitor<'tcx> {\n             check.ty();\n         }\n     }\n-}\n-\n-impl<'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'tcx> {\n-    type NestedFilter = nested_filter::OnlyBodies;\n \n-    fn nested_visit_map(&mut self) -> Self::Map {\n-        self.tcx.hir()\n-    }\n-\n-    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n+    pub fn check_item(&mut self, id: ItemId) {\n         let tcx = self.tcx;\n-        let item_visibility = tcx.visibility(item.def_id);\n+        let item_visibility = tcx.visibility(id.def_id);\n+        let def_kind = tcx.def_kind(id.def_id);\n+\n+        if matches!(\n+            def_kind,\n+            DefKind::ExternCrate\n+                | DefKind::Mod\n+                | DefKind::Use\n+                | DefKind::Macro(_)\n+                | DefKind::GlobalAsm\n+        ) {\n+            return;\n+        }\n \n-        match item.kind {\n-            // Crates are always public.\n-            hir::ItemKind::ExternCrate(..) => {}\n-            // All nested items are checked by `visit_item`.\n-            hir::ItemKind::Mod(..) => {}\n-            // Checked in resolve.\n-            hir::ItemKind::Use(..) => {}\n-            // No subitems.\n-            hir::ItemKind::Macro(..) | hir::ItemKind::GlobalAsm(..) => {}\n-            // Subitems of these items have inherited publicity.\n-            hir::ItemKind::Const(..)\n-            | hir::ItemKind::Static(..)\n-            | hir::ItemKind::Fn(..)\n-            | hir::ItemKind::TyAlias(..) => {\n-                self.check(item.def_id, item_visibility).generics().predicates().ty();\n+        match def_kind {\n+            DefKind::Const | DefKind::Static(_) | DefKind::Fn | DefKind::TyAlias => {\n+                self.check(id.def_id, item_visibility).generics().predicates().ty();\n             }\n-            hir::ItemKind::OpaqueTy(..) => {\n+            DefKind::OpaqueTy => {\n                 // `ty()` for opaque types is the underlying type,\n                 // it's not a part of interface, so we skip it.\n-                self.check(item.def_id, item_visibility).generics().bounds();\n+                self.check(id.def_id, item_visibility).generics().bounds();\n             }\n-            hir::ItemKind::Trait(.., trait_item_refs) => {\n-                self.check(item.def_id, item_visibility).generics().predicates();\n+            DefKind::Trait => {\n+                let item = tcx.hir().item(id);\n+                if let hir::ItemKind::Trait(.., trait_item_refs) = item.kind {\n+                    self.check(item.def_id, item_visibility).generics().predicates();\n \n-                for trait_item_ref in trait_item_refs {\n-                    self.check_assoc_item(\n-                        trait_item_ref.id.def_id,\n-                        trait_item_ref.kind,\n-                        trait_item_ref.defaultness,\n-                        item_visibility,\n-                    );\n-\n-                    if let AssocItemKind::Type = trait_item_ref.kind {\n-                        self.check(trait_item_ref.id.def_id, item_visibility).bounds();\n+                    for trait_item_ref in trait_item_refs {\n+                        self.check_assoc_item(\n+                            trait_item_ref.id.def_id,\n+                            trait_item_ref.kind,\n+                            trait_item_ref.defaultness,\n+                            item_visibility,\n+                        );\n+\n+                        if let AssocItemKind::Type = trait_item_ref.kind {\n+                            self.check(trait_item_ref.id.def_id, item_visibility).bounds();\n+                        }\n                     }\n                 }\n             }\n-            hir::ItemKind::TraitAlias(..) => {\n-                self.check(item.def_id, item_visibility).generics().predicates();\n+            DefKind::TraitAlias => {\n+                self.check(id.def_id, item_visibility).generics().predicates();\n             }\n-            hir::ItemKind::Enum(ref def, _) => {\n-                self.check(item.def_id, item_visibility).generics().predicates();\n+            DefKind::Enum => {\n+                let item = tcx.hir().item(id);\n+                if let hir::ItemKind::Enum(ref def, _) = item.kind {\n+                    self.check(item.def_id, item_visibility).generics().predicates();\n \n-                for variant in def.variants {\n-                    for field in variant.data.fields() {\n-                        self.check(self.tcx.hir().local_def_id(field.hir_id), item_visibility).ty();\n+                    for variant in def.variants {\n+                        for field in variant.data.fields() {\n+                            self.check(self.tcx.hir().local_def_id(field.hir_id), item_visibility)\n+                                .ty();\n+                        }\n                     }\n                 }\n             }\n             // Subitems of foreign modules have their own publicity.\n-            hir::ItemKind::ForeignMod { items, .. } => {\n-                for foreign_item in items {\n-                    let vis = tcx.visibility(foreign_item.id.def_id);\n-                    self.check(foreign_item.id.def_id, vis).generics().predicates().ty();\n+            DefKind::ForeignMod => {\n+                let item = tcx.hir().item(id);\n+                if let hir::ItemKind::ForeignMod { items, .. } = item.kind {\n+                    for foreign_item in items {\n+                        let vis = tcx.visibility(foreign_item.id.def_id);\n+                        self.check(foreign_item.id.def_id, vis).generics().predicates().ty();\n+                    }\n                 }\n             }\n             // Subitems of structs and unions have their own publicity.\n-            hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n-                self.check(item.def_id, item_visibility).generics().predicates();\n+            DefKind::Struct | DefKind::Union => {\n+                let item = tcx.hir().item(id);\n+                if let hir::ItemKind::Struct(ref struct_def, _)\n+                | hir::ItemKind::Union(ref struct_def, _) = item.kind\n+                {\n+                    self.check(item.def_id, item_visibility).generics().predicates();\n \n-                for field in struct_def.fields() {\n-                    let def_id = tcx.hir().local_def_id(field.hir_id);\n-                    let field_visibility = tcx.visibility(def_id);\n-                    self.check(def_id, min(item_visibility, field_visibility, tcx)).ty();\n+                    for field in struct_def.fields() {\n+                        let def_id = tcx.hir().local_def_id(field.hir_id);\n+                        let field_visibility = tcx.visibility(def_id);\n+                        self.check(def_id, min(item_visibility, field_visibility, tcx)).ty();\n+                    }\n                 }\n             }\n             // An inherent impl is public when its type is public\n             // Subitems of inherent impls have their own publicity.\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity.\n-            hir::ItemKind::Impl(ref impl_) => {\n-                let impl_vis = ty::Visibility::of_impl(item.def_id, tcx, &Default::default());\n-                // check that private components do not appear in the generics or predicates of inherent impls\n-                // this check is intentionally NOT performed for impls of traits, per #90586\n-                if impl_.of_trait.is_none() {\n-                    self.check(item.def_id, impl_vis).generics().predicates();\n-                }\n-                for impl_item_ref in impl_.items {\n-                    let impl_item_vis = if impl_.of_trait.is_none() {\n-                        min(tcx.visibility(impl_item_ref.id.def_id), impl_vis, tcx)\n-                    } else {\n-                        impl_vis\n-                    };\n-                    self.check_assoc_item(\n-                        impl_item_ref.id.def_id,\n-                        impl_item_ref.kind,\n-                        impl_item_ref.defaultness,\n-                        impl_item_vis,\n-                    );\n+            DefKind::Impl => {\n+                let item = tcx.hir().item(id);\n+                if let hir::ItemKind::Impl(ref impl_) = item.kind {\n+                    let impl_vis = ty::Visibility::of_impl(item.def_id, tcx, &Default::default());\n+                    // check that private components do not appear in the generics or predicates of inherent impls\n+                    // this check is intentionally NOT performed for impls of traits, per #90586\n+                    if impl_.of_trait.is_none() {\n+                        self.check(item.def_id, impl_vis).generics().predicates();\n+                    }\n+                    for impl_item_ref in impl_.items {\n+                        let impl_item_vis = if impl_.of_trait.is_none() {\n+                            min(tcx.visibility(impl_item_ref.id.def_id), impl_vis, tcx)\n+                        } else {\n+                            impl_vis\n+                        };\n+                        self.check_assoc_item(\n+                            impl_item_ref.id.def_id,\n+                            impl_item_ref.kind,\n+                            impl_item_ref.defaultness,\n+                            impl_item_vis,\n+                        );\n+                    }\n                 }\n             }\n+            _ => {}\n         }\n     }\n }\n@@ -2069,7 +2080,7 @@ fn check_private_in_public(tcx: TyCtxt<'_>, (): ()) {\n     }\n \n     // Check for private types and traits in public interfaces.\n-    let mut visitor = PrivateItemsInPublicInterfacesVisitor {\n+    let mut checker = PrivateItemsInPublicInterfacesChecker {\n         tcx,\n         // Only definition IDs are ever searched in `old_error_set_ancestry`,\n         // so we can filter away all non-definition IDs at this point.\n@@ -2078,5 +2089,8 @@ fn check_private_in_public(tcx: TyCtxt<'_>, (): ()) {\n             .filter_map(|hir_id| tcx.hir().opt_local_def_id(hir_id))\n             .collect(),\n     };\n-    tcx.hir().visit_all_item_likes(&mut DeepVisitor::new(&mut visitor));\n+\n+    for id in tcx.hir().items() {\n+        checker.check_item(id);\n+    }\n }"}]}