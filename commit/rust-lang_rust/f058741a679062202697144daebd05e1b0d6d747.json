{"sha": "f058741a679062202697144daebd05e1b0d6d747", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwNTg3NDFhNjc5MDYyMjAyNjk3MTQ0ZGFlYmQwNWUxYjBkNmQ3NDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-15T12:15:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-15T12:15:17Z"}, "message": "Auto merge of #58403 - eddyb:requalify, r=oli-obk\n\nrustc_mir: split qualify_consts' \"value qualification\" bitflags into separate computations.\n\nPrerequisite for computing those bits through a dataflow algorithm ~~(which I might do in this PR later)~~.\n\nThis PR should not change behavior overall, other than treating `simd_shuffle*` identically to `#[rustc_args_required_const]` (maybe we should just have `#[rustc_args_required_const]` on the intrinsic imports of `simd_shuffle*`? cc @gnzlbg)\n\ncc @oli-obk @alexreg", "tree": {"sha": "ca6de73a9cf216a71527762be929bd903dbbe549", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca6de73a9cf216a71527762be929bd903dbbe549"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f058741a679062202697144daebd05e1b0d6d747", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f058741a679062202697144daebd05e1b0d6d747", "html_url": "https://github.com/rust-lang/rust/commit/f058741a679062202697144daebd05e1b0d6d747", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f058741a679062202697144daebd05e1b0d6d747/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f47ec2ad5b6887b3d400aee49e2294bd27733d18", "url": "https://api.github.com/repos/rust-lang/rust/commits/f47ec2ad5b6887b3d400aee49e2294bd27733d18", "html_url": "https://github.com/rust-lang/rust/commit/f47ec2ad5b6887b3d400aee49e2294bd27733d18"}, {"sha": "f04424acd1bf894d1dc930c2a347871ea8b96dfa", "url": "https://api.github.com/repos/rust-lang/rust/commits/f04424acd1bf894d1dc930c2a347871ea8b96dfa", "html_url": "https://github.com/rust-lang/rust/commit/f04424acd1bf894d1dc930c2a347871ea8b96dfa"}], "stats": {"total": 1430, "additions": 851, "deletions": 579}, "files": [{"sha": "963bbcf0f0429b59a0164a95b6f5e7b981aa02b2", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f058741a679062202697144daebd05e1b0d6d747/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f058741a679062202697144daebd05e1b0d6d747/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f058741a679062202697144daebd05e1b0d6d747", "patch": "@@ -2822,7 +2822,6 @@ name = \"rustc_mir\"\n version = \"0.0.0\"\n dependencies = [\n  \"arena 0.0.0\",\n- \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"byteorder 1.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"either 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"graphviz 0.0.0\","}, {"sha": "c32bafa99205f4179312e8ecd74915a6f2390ccb", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f058741a679062202697144daebd05e1b0d6d747/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f058741a679062202697144daebd05e1b0d6d747/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=f058741a679062202697144daebd05e1b0d6d747", "patch": "@@ -11,7 +11,6 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n arena = { path = \"../libarena\" }\n-bitflags = \"1.0\"\n either = \"1.5.0\"\n dot = { path = \"../libgraphviz\", package = \"graphviz\" }\n log = \"0.4\""}, {"sha": "51168f650aeb774d9afea7bf15c6287654c70537", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 831, "deletions": 557, "changes": 1388, "blob_url": "https://github.com/rust-lang/rust/blob/f058741a679062202697144daebd05e1b0d6d747/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f058741a679062202697144daebd05e1b0d6d747/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=f058741a679062202697144daebd05e1b0d6d747", "patch": "@@ -21,58 +21,16 @@ use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUs\n use rustc::middle::lang_items;\n use rustc::session::config::nightly_options;\n use syntax::ast::LitKind;\n-use syntax::feature_gate::{UnstableFeatures, emit_feature_err, GateIssue};\n+use syntax::feature_gate::{emit_feature_err, GateIssue};\n use syntax_pos::{Span, DUMMY_SP};\n \n use std::fmt;\n+use std::ops::{Deref, Index, IndexMut};\n use std::usize;\n \n use crate::transform::{MirPass, MirSource};\n use super::promote_consts::{self, Candidate, TempState};\n \n-bitflags::bitflags! {\n-    // Borrows of temporaries can be promoted only if\n-    // they have none of these qualifications, with\n-    // the exception of `STATIC_REF` (in statics only).\n-    struct Qualif: u8 {\n-        // Constant containing interior mutability (UnsafeCell).\n-        const MUTABLE_INTERIOR  = 1 << 0;\n-\n-        // Constant containing an ADT that implements Drop.\n-        const NEEDS_DROP        = 1 << 1;\n-\n-        // Function argument.\n-        const FN_ARGUMENT       = 1 << 2;\n-\n-        // Not constant at all - non-`const fn` calls, asm!,\n-        // pointer comparisons, ptr-to-int casts, etc.\n-        const NOT_CONST         = 1 << 3;\n-\n-        // Refers to temporaries which cannot be promoted as\n-        // promote_consts decided they weren't simple enough.\n-        const NOT_PROMOTABLE    = 1 << 4;\n-\n-        // Const items can only have MUTABLE_INTERIOR\n-        // and NOT_PROMOTABLE without producing an error.\n-        const CONST_ERROR       = !Qualif::MUTABLE_INTERIOR.bits &\n-                                  !Qualif::NOT_PROMOTABLE.bits;\n-    }\n-}\n-\n-impl<'a, 'tcx> Qualif {\n-    /// Remove flags which are impossible for the given type.\n-    fn restrict(&mut self, ty: Ty<'tcx>,\n-                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                param_env: ty::ParamEnv<'tcx>) {\n-        if ty.is_freeze(tcx, param_env, DUMMY_SP) {\n-            *self = *self - Qualif::MUTABLE_INTERIOR;\n-        }\n-        if !ty.needs_drop(tcx, param_env) {\n-            *self = *self - Qualif::NEEDS_DROP;\n-        }\n-    }\n-}\n-\n /// What kind of item we are in.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum Mode {\n@@ -94,18 +52,534 @@ impl fmt::Display for Mode {\n     }\n }\n \n-struct Qualifier<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+const QUALIF_COUNT: usize = 4;\n+\n+// FIXME(eddyb) once we can use const generics, replace this array with\n+// something like `IndexVec` but for fixed-size arrays (`IndexArray`?).\n+#[derive(Copy, Clone, Default)]\n+struct PerQualif<T>([T; QUALIF_COUNT]);\n+\n+impl<T: Clone> PerQualif<T> {\n+    fn new(x: T) -> Self {\n+        PerQualif([x.clone(), x.clone(), x.clone(), x])\n+    }\n+}\n+\n+impl<T> PerQualif<T> {\n+    fn as_mut(&mut self) -> PerQualif<&mut T> {\n+        let [x0, x1, x2, x3] = &mut self.0;\n+        PerQualif([x0, x1, x2, x3])\n+    }\n+\n+    fn zip<U>(self, other: PerQualif<U>) -> PerQualif<(T, U)> {\n+        let [x0, x1, x2, x3] = self.0;\n+        let [y0, y1, y2, y3] = other.0;\n+        PerQualif([(x0, y0), (x1, y1), (x2, y2), (x3, y3)])\n+    }\n+}\n+\n+impl PerQualif<bool> {\n+    fn encode_to_bits(self) -> u8 {\n+        self.0.iter().enumerate().fold(0, |bits, (i, &qualif)| {\n+            bits | ((qualif as u8) << i)\n+        })\n+    }\n+\n+    fn decode_from_bits(bits: u8) -> Self {\n+        let mut qualifs = Self::default();\n+        for (i, qualif) in qualifs.0.iter_mut().enumerate() {\n+            *qualif = (bits & (1 << i)) != 0;\n+        }\n+        qualifs\n+    }\n+}\n+\n+impl<Q: Qualif, T> Index<Q> for PerQualif<T> {\n+    type Output = T;\n+\n+    fn index(&self, _: Q) -> &T {\n+        &self.0[Q::IDX]\n+    }\n+}\n+\n+impl<Q: Qualif, T> IndexMut<Q> for PerQualif<T> {\n+    fn index_mut(&mut self, _: Q) -> &mut T {\n+        &mut self.0[Q::IDX]\n+    }\n+}\n+\n+struct ConstCx<'a, 'tcx> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     mode: Mode,\n+    mir: &'a Mir<'tcx>,\n+\n+    per_local: PerQualif<BitSet<Local>>,\n+}\n+\n+impl<'a, 'tcx> ConstCx<'a, 'tcx> {\n+    fn is_const_panic_fn(&self, def_id: DefId) -> bool {\n+        Some(def_id) == self.tcx.lang_items().panic_fn() ||\n+        Some(def_id) == self.tcx.lang_items().begin_panic_fn()\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+enum ValueSource<'a, 'tcx> {\n+    Rvalue(&'a Rvalue<'tcx>),\n+    Call {\n+        callee: &'a Operand<'tcx>,\n+        args: &'a [Operand<'tcx>],\n+        return_ty: Ty<'tcx>,\n+    },\n+}\n+\n+trait Qualif {\n+    const IDX: usize;\n+\n+    /// Return the qualification that is (conservatively) correct for any value\n+    /// of the type, or `None` if the qualification is not value/type-based.\n+    fn in_any_value_of_ty(_cx: &ConstCx<'_, 'tcx>, _ty: Ty<'tcx>) -> Option<bool> {\n+        None\n+    }\n+\n+    /// Return a mask for the qualification, given a type. This is `false` iff\n+    /// no value of that type can have the qualification.\n+    fn mask_for_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool {\n+        Self::in_any_value_of_ty(cx, ty).unwrap_or(true)\n+    }\n+\n+    fn in_local(cx: &ConstCx<'_, '_>, local: Local) -> bool {\n+        cx.per_local.0[Self::IDX].contains(local)\n+    }\n+\n+    fn in_static(_cx: &ConstCx<'_, 'tcx>, _static: &Static<'tcx>) -> bool {\n+        // FIXME(eddyb) should we do anything here for value properties?\n+        false\n+    }\n+\n+    fn in_projection_structurally(\n+        cx: &ConstCx<'_, 'tcx>,\n+        proj: &PlaceProjection<'tcx>,\n+    ) -> bool {\n+        let base_qualif = Self::in_place(cx, &proj.base);\n+        let qualif = base_qualif && Self::mask_for_ty(\n+            cx,\n+            proj.base.ty(cx.mir, cx.tcx)\n+                .projection_ty(cx.tcx, &proj.elem)\n+                .to_ty(cx.tcx),\n+        );\n+        match proj.elem {\n+            ProjectionElem::Deref |\n+            ProjectionElem::Subslice { .. } |\n+            ProjectionElem::Field(..) |\n+            ProjectionElem::ConstantIndex { .. } |\n+            ProjectionElem::Downcast(..) => qualif,\n+\n+            ProjectionElem::Index(local) => qualif || Self::in_local(cx, local),\n+        }\n+    }\n+\n+    fn in_projection(cx: &ConstCx<'_, 'tcx>, proj: &PlaceProjection<'tcx>) -> bool {\n+        Self::in_projection_structurally(cx, proj)\n+    }\n+\n+    fn in_place(cx: &ConstCx<'_, 'tcx>, place: &Place<'tcx>) -> bool {\n+        match *place {\n+            Place::Local(local) => Self::in_local(cx, local),\n+            Place::Promoted(_) => bug!(\"qualifying already promoted MIR\"),\n+            Place::Static(ref static_) => Self::in_static(cx, static_),\n+            Place::Projection(ref proj) => Self::in_projection(cx, proj),\n+        }\n+    }\n+\n+    fn in_operand(cx: &ConstCx<'_, 'tcx>, operand: &Operand<'tcx>) -> bool {\n+        match *operand {\n+            Operand::Copy(ref place) |\n+            Operand::Move(ref place) => Self::in_place(cx, place),\n+\n+            Operand::Constant(ref constant) => {\n+                if let ty::LazyConst::Unevaluated(def_id, _) = constant.literal {\n+                    // Don't peek inside trait associated constants.\n+                    if cx.tcx.trait_of_item(*def_id).is_some() {\n+                        Self::in_any_value_of_ty(cx, constant.ty).unwrap_or(false)\n+                    } else {\n+                        let (bits, _) = cx.tcx.at(constant.span).mir_const_qualif(*def_id);\n+\n+                        let qualif = PerQualif::decode_from_bits(bits).0[Self::IDX];\n+\n+                        // Just in case the type is more specific than\n+                        // the definition, e.g., impl associated const\n+                        // with type parameters, take it into account.\n+                        qualif && Self::mask_for_ty(cx, constant.ty)\n+                    }\n+                } else {\n+                    false\n+                }\n+            }\n+        }\n+    }\n+\n+    fn in_rvalue_structurally(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n+        match *rvalue {\n+            Rvalue::NullaryOp(..) => false,\n+\n+            Rvalue::Discriminant(ref place) |\n+            Rvalue::Len(ref place) => Self::in_place(cx, place),\n+\n+            Rvalue::Use(ref operand) |\n+            Rvalue::Repeat(ref operand, _) |\n+            Rvalue::UnaryOp(_, ref operand) |\n+            Rvalue::Cast(_, ref operand, _) => Self::in_operand(cx, operand),\n+\n+            Rvalue::BinaryOp(_, ref lhs, ref rhs) |\n+            Rvalue::CheckedBinaryOp(_, ref lhs, ref rhs) => {\n+                Self::in_operand(cx, lhs) || Self::in_operand(cx, rhs)\n+            }\n+\n+            Rvalue::Ref(_, _, ref place) => {\n+                // Special-case reborrows to be more like a copy of the reference.\n+                if let Place::Projection(ref proj) = *place {\n+                    if let ProjectionElem::Deref = proj.elem {\n+                        let base_ty = proj.base.ty(cx.mir, cx.tcx).to_ty(cx.tcx);\n+                        if let ty::Ref(..) = base_ty.sty {\n+                            return Self::in_place(cx, &proj.base);\n+                        }\n+                    }\n+                }\n+\n+                Self::in_place(cx, place)\n+            }\n+\n+            Rvalue::Aggregate(_, ref operands) => {\n+                operands.iter().any(|o| Self::in_operand(cx, o))\n+            }\n+        }\n+    }\n+\n+    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n+        Self::in_rvalue_structurally(cx, rvalue)\n+    }\n+\n+    fn in_call(\n+        cx: &ConstCx<'_, 'tcx>,\n+        _callee: &Operand<'tcx>,\n+        _args: &[Operand<'tcx>],\n+        return_ty: Ty<'tcx>,\n+    ) -> bool {\n+        // Be conservative about the returned value of a const fn.\n+        Self::in_any_value_of_ty(cx, return_ty).unwrap_or(false)\n+    }\n+\n+    fn in_value(cx: &ConstCx<'_, 'tcx>, source: ValueSource<'_, 'tcx>) -> bool {\n+        match source {\n+            ValueSource::Rvalue(rvalue) => Self::in_rvalue(cx, rvalue),\n+            ValueSource::Call { callee, args, return_ty } => {\n+                Self::in_call(cx, callee, args, return_ty)\n+            }\n+        }\n+    }\n+}\n+\n+// Constant containing interior mutability (UnsafeCell).\n+struct HasMutInterior;\n+\n+impl Qualif for HasMutInterior {\n+    const IDX: usize = 0;\n+\n+    fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> Option<bool> {\n+        Some(!ty.is_freeze(cx.tcx, cx.param_env, DUMMY_SP))\n+    }\n+\n+    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n+        match *rvalue {\n+            // Returning `true` for `Rvalue::Ref` indicates the borrow isn't\n+            // allowed in constants (and the `Checker` will error), and/or it\n+            // won't be promoted, due to `&mut ...` or interior mutability.\n+            Rvalue::Ref(_, kind, ref place) => {\n+                let ty = place.ty(cx.mir, cx.tcx).to_ty(cx.tcx);\n+\n+                if let BorrowKind::Mut { .. } = kind {\n+                    // In theory, any zero-sized value could be borrowed\n+                    // mutably without consequences. However, only &mut []\n+                    // is allowed right now, and only in functions.\n+                    if cx.mode == Mode::StaticMut {\n+                        // Inside a `static mut`, &mut [...] is also allowed.\n+                        match ty.sty {\n+                            ty::Array(..) | ty::Slice(_) => {}\n+                            _ => return true,\n+                        }\n+                    } else if let ty::Array(_, len) = ty.sty {\n+                        // FIXME(eddyb) the `cx.mode == Mode::Fn` condition\n+                        // seems unnecessary, given that this is merely a ZST.\n+                        if !(len.unwrap_usize(cx.tcx) == 0 && cx.mode == Mode::Fn) {\n+                            return true;\n+                        }\n+                    } else {\n+                        return true;\n+                    }\n+                }\n+            }\n+\n+            Rvalue::Aggregate(ref kind, _) => {\n+                if let AggregateKind::Adt(def, ..) = **kind {\n+                    if Some(def.did) == cx.tcx.lang_items().unsafe_cell_type() {\n+                        let ty = rvalue.ty(cx.mir, cx.tcx);\n+                        assert_eq!(Self::in_any_value_of_ty(cx, ty), Some(true));\n+                        return true;\n+                    }\n+                }\n+            }\n+\n+            _ => {}\n+        }\n+\n+        Self::in_rvalue_structurally(cx, rvalue)\n+    }\n+}\n+\n+// Constant containing an ADT that implements Drop.\n+struct NeedsDrop;\n+\n+impl Qualif for NeedsDrop {\n+    const IDX: usize = 1;\n+\n+    fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> Option<bool> {\n+        Some(ty.needs_drop(cx.tcx, cx.param_env))\n+    }\n+\n+    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n+        if let Rvalue::Aggregate(ref kind, _) = *rvalue {\n+            if let AggregateKind::Adt(def, ..) = **kind {\n+                if def.has_dtor(cx.tcx) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        Self::in_rvalue_structurally(cx, rvalue)\n+    }\n+}\n+\n+// Not constant at all - non-`const fn` calls, asm!,\n+// pointer comparisons, ptr-to-int casts, etc.\n+struct IsNotConst;\n+\n+impl Qualif for IsNotConst {\n+    const IDX: usize = 2;\n+\n+    fn in_static(cx: &ConstCx<'_, 'tcx>, static_: &Static<'tcx>) -> bool {\n+        // Only allow statics (not consts) to refer to other statics.\n+        let allowed = cx.mode == Mode::Static || cx.mode == Mode::StaticMut;\n+\n+        !allowed ||\n+            cx.tcx.get_attrs(static_.def_id).iter().any(|attr| attr.check_name(\"thread_local\"))\n+    }\n+\n+    fn in_projection(cx: &ConstCx<'_, 'tcx>, proj: &PlaceProjection<'tcx>) -> bool {\n+        match proj.elem {\n+            ProjectionElem::Deref |\n+            ProjectionElem::Downcast(..) => return true,\n+\n+            ProjectionElem::ConstantIndex {..} |\n+            ProjectionElem::Subslice {..} |\n+            ProjectionElem::Index(_) => {}\n+\n+            ProjectionElem::Field(..) => {\n+                if cx.mode == Mode::Fn {\n+                    let base_ty = proj.base.ty(cx.mir, cx.tcx).to_ty(cx.tcx);\n+                    if let Some(def) = base_ty.ty_adt_def() {\n+                        if def.is_union() {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        Self::in_projection_structurally(cx, proj)\n+    }\n+\n+    fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n+        match *rvalue {\n+            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if cx.mode == Mode::Fn => {\n+                let operand_ty = operand.ty(cx.mir, cx.tcx);\n+                let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n+                let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n+                match (cast_in, cast_out) {\n+                    (CastTy::Ptr(_), CastTy::Int(_)) |\n+                    (CastTy::FnPtr, CastTy::Int(_)) => {\n+                        // in normal functions, mark such casts as not promotable\n+                        return true;\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            Rvalue::BinaryOp(op, ref lhs, _) if cx.mode == Mode::Fn => {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(cx.mir, cx.tcx).sty {\n+                    assert!(op == BinOp::Eq || op == BinOp::Ne ||\n+                            op == BinOp::Le || op == BinOp::Lt ||\n+                            op == BinOp::Ge || op == BinOp::Gt ||\n+                            op == BinOp::Offset);\n+\n+                    // raw pointer operations are not allowed inside promoteds\n+                    return true;\n+                }\n+            }\n+\n+            Rvalue::NullaryOp(NullOp::Box, _) => return true,\n+\n+            _ => {}\n+        }\n+\n+        Self::in_rvalue_structurally(cx, rvalue)\n+    }\n+\n+    fn in_call(\n+        cx: &ConstCx<'_, 'tcx>,\n+        callee: &Operand<'tcx>,\n+        args: &[Operand<'tcx>],\n+        _return_ty: Ty<'tcx>,\n+    ) -> bool {\n+        let fn_ty = callee.ty(cx.mir, cx.tcx);\n+        match fn_ty.sty {\n+            ty::FnDef(def_id, _) => {\n+                match cx.tcx.fn_sig(def_id).abi() {\n+                    Abi::RustIntrinsic |\n+                    Abi::PlatformIntrinsic => {\n+                        assert!(!cx.tcx.is_const_fn(def_id));\n+                        match &cx.tcx.item_name(def_id).as_str()[..] {\n+                            | \"size_of\"\n+                            | \"min_align_of\"\n+                            | \"needs_drop\"\n+                            | \"type_id\"\n+                            | \"bswap\"\n+                            | \"bitreverse\"\n+                            | \"ctpop\"\n+                            | \"cttz\"\n+                            | \"cttz_nonzero\"\n+                            | \"ctlz\"\n+                            | \"ctlz_nonzero\"\n+                            | \"overflowing_add\"\n+                            | \"overflowing_sub\"\n+                            | \"overflowing_mul\"\n+                            | \"unchecked_shl\"\n+                            | \"unchecked_shr\"\n+                            | \"rotate_left\"\n+                            | \"rotate_right\"\n+                            | \"add_with_overflow\"\n+                            | \"sub_with_overflow\"\n+                            | \"mul_with_overflow\"\n+                            | \"saturating_add\"\n+                            | \"saturating_sub\"\n+                            | \"transmute\"\n+                            => return true,\n+\n+                            _ => {}\n+                        }\n+                    }\n+                    _ => {\n+                        let is_const_fn =\n+                            cx.tcx.is_const_fn(def_id) ||\n+                            cx.tcx.is_unstable_const_fn(def_id).is_some() ||\n+                            cx.is_const_panic_fn(def_id);\n+                        if !is_const_fn {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+            _ => return true,\n+        }\n+\n+        Self::in_operand(cx, callee) || args.iter().any(|arg| Self::in_operand(cx, arg))\n+    }\n+}\n+\n+// Refers to temporaries which cannot be promoted as\n+// promote_consts decided they weren't simple enough.\n+struct IsNotPromotable;\n+\n+impl Qualif for IsNotPromotable {\n+    const IDX: usize = 3;\n+\n+    fn in_call(\n+        cx: &ConstCx<'_, 'tcx>,\n+        callee: &Operand<'tcx>,\n+        _args: &[Operand<'tcx>],\n+        _return_ty: Ty<'tcx>,\n+    ) -> bool {\n+        if cx.mode == Mode::Fn {\n+            if let ty::FnDef(def_id, _) = callee.ty(cx.mir, cx.tcx).sty {\n+                // Never promote runtime `const fn` calls of\n+                // functions without `#[rustc_promotable]`.\n+                if !cx.tcx.is_promotable_const_fn(def_id) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        // FIXME(eddyb) do we need \"not promotable\" in anything\n+        // other than `Mode::Fn` by any chance?\n+\n+        false\n+    }\n+}\n+\n+// Ensure the `IDX` values are sequential (`0..QUALIF_COUNT`).\n+macro_rules! static_assert_seq_qualifs {\n+    ($i:expr => $first:ident $(, $rest:ident)*) => {\n+        static_assert!(SEQ_QUALIFS: {\n+            static_assert_seq_qualifs!($i + 1 => $($rest),*);\n+\n+            $first::IDX == $i\n+        });\n+    };\n+    ($i:expr =>) => {\n+        static_assert!(SEQ_QUALIFS: QUALIF_COUNT == $i);\n+    };\n+}\n+static_assert_seq_qualifs!(0 => HasMutInterior, NeedsDrop, IsNotConst, IsNotPromotable);\n+\n+impl ConstCx<'_, 'tcx> {\n+    fn qualifs_in_any_value_of_ty(&self, ty: Ty<'tcx>) -> PerQualif<bool> {\n+        let mut qualifs = PerQualif::default();\n+        qualifs[HasMutInterior] = HasMutInterior::in_any_value_of_ty(self, ty).unwrap_or(false);\n+        qualifs[NeedsDrop] = NeedsDrop::in_any_value_of_ty(self, ty).unwrap_or(false);\n+        qualifs[IsNotConst] = IsNotConst::in_any_value_of_ty(self, ty).unwrap_or(false);\n+        qualifs[IsNotPromotable] = IsNotPromotable::in_any_value_of_ty(self, ty).unwrap_or(false);\n+        qualifs\n+    }\n+\n+    fn qualifs_in_local(&self, local: Local) -> PerQualif<bool> {\n+        let mut qualifs = PerQualif::default();\n+        qualifs[HasMutInterior] = HasMutInterior::in_local(self, local);\n+        qualifs[NeedsDrop] = NeedsDrop::in_local(self, local);\n+        qualifs[IsNotConst] = IsNotConst::in_local(self, local);\n+        qualifs[IsNotPromotable] = IsNotPromotable::in_local(self, local);\n+        qualifs\n+    }\n+\n+    fn qualifs_in_value(&self, source: ValueSource<'_, 'tcx>) -> PerQualif<bool> {\n+        let mut qualifs = PerQualif::default();\n+        qualifs[HasMutInterior] = HasMutInterior::in_value(self, source);\n+        qualifs[NeedsDrop] = NeedsDrop::in_value(self, source);\n+        qualifs[IsNotConst] = IsNotConst::in_value(self, source);\n+        qualifs[IsNotPromotable] = IsNotPromotable::in_value(self, source);\n+        qualifs\n+    }\n+}\n+\n+struct Checker<'a, 'tcx> {\n+    cx: ConstCx<'a, 'tcx>,\n+\n     span: Span,\n     def_id: DefId,\n-    mir: &'a Mir<'tcx>,\n     rpo: ReversePostorder<'a, 'tcx>,\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    local_qualif: IndexVec<Local, Option<Qualif>>,\n-    qualif: Qualif,\n+\n     temp_promotion_state: IndexVec<Local, TempState>,\n-    promotion_candidates: Vec<Candidate>\n+    promotion_candidates: Vec<Candidate>,\n }\n \n macro_rules! unleash_miri {\n@@ -117,36 +591,64 @@ macro_rules! unleash_miri {\n     }}\n }\n \n-impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n+impl Deref for Checker<'a, 'tcx> {\n+    type Target = ConstCx<'a, 'tcx>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.cx\n+    }\n+}\n+\n+impl<'a, 'tcx> Checker<'a, 'tcx> {\n     fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            def_id: DefId,\n            mir: &'a Mir<'tcx>,\n            mode: Mode)\n-           -> Qualifier<'a, 'tcx, 'tcx> {\n+           -> Self {\n         assert!(def_id.is_local());\n         let mut rpo = traversal::reverse_postorder(mir);\n         let temps = promote_consts::collect_temps(mir, &mut rpo);\n         rpo.reset();\n \n         let param_env = tcx.param_env(def_id);\n \n-        let mut local_qualif = IndexVec::from_elem(None, &mir.local_decls);\n-        for arg in mir.args_iter() {\n-            let mut qualif = Qualif::NEEDS_DROP;\n-            qualif.restrict(mir.local_decls[arg].ty, tcx, param_env);\n-            local_qualif[arg] = Some(qualif);\n+        let mut cx = ConstCx {\n+            tcx,\n+            param_env,\n+            mode,\n+            mir,\n+            per_local: PerQualif::new(BitSet::new_empty(mir.local_decls.len())),\n+        };\n+\n+        for (local, decl) in mir.local_decls.iter_enumerated() {\n+            match mir.local_kind(local) {\n+                LocalKind::Arg => {\n+                    let qualifs = cx.qualifs_in_any_value_of_ty(decl.ty);\n+                    for (per_local, qualif) in &mut cx.per_local.as_mut().zip(qualifs).0 {\n+                        if *qualif {\n+                            per_local.insert(local);\n+                        }\n+                    }\n+                    cx.per_local[IsNotPromotable].insert(local);\n+                }\n+\n+                LocalKind::Var if mode == Mode::Fn => {\n+                    cx.per_local[IsNotConst].insert(local);\n+                }\n+\n+                LocalKind::Temp if !temps[local].is_promotable() => {\n+                    cx.per_local[IsNotPromotable].insert(local);\n+                }\n+\n+                _ => {}\n+            }\n         }\n \n-        Qualifier {\n-            mode,\n+        Checker {\n+            cx,\n             span: mir.span,\n             def_id,\n-            mir,\n             rpo,\n-            tcx,\n-            param_env,\n-            local_qualif,\n-            qualif: Qualif::empty(),\n             temp_promotion_state: temps,\n             promotion_candidates: vec![]\n         }\n@@ -157,7 +659,6 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n     // slightly pointless (even with feature-gating).\n     fn not_const(&mut self) {\n         unleash_miri!(self);\n-        self.add(Qualif::NOT_CONST);\n         if self.mode != Mode::Fn {\n             let mut err = struct_span_err!(\n                 self.tcx.sess,\n@@ -176,49 +677,77 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n         }\n     }\n \n-    /// Adds the given qualification to `self.qualif`.\n-    fn add(&mut self, qualif: Qualif) {\n-        self.qualif = self.qualif | qualif;\n-    }\n+    /// Assigns an rvalue/call qualification to the given destination.\n+    fn assign(&mut self, dest: &Place<'tcx>, source: ValueSource<'_, 'tcx>, location: Location) {\n+        trace!(\"assign: {:?} <- {:?}\", dest, source);\n \n-    /// Adds the given type's qualification to `self.qualif`.\n-    fn add_type(&mut self, ty: Ty<'tcx>) {\n-        self.add(Qualif::MUTABLE_INTERIOR | Qualif::NEEDS_DROP);\n-        self.qualif.restrict(ty, self.tcx, self.param_env);\n-    }\n+        let mut qualifs = self.qualifs_in_value(source);\n \n-    /// Within the provided closure, `self.qualif` will start\n-    /// out empty, and its value after the closure returns will\n-    /// be combined with the value before the call to nest.\n-    fn nest<F: FnOnce(&mut Self)>(&mut self, f: F) {\n-        let original = self.qualif;\n-        self.qualif = Qualif::empty();\n-        f(self);\n-        self.add(original);\n-    }\n+        if let ValueSource::Rvalue(&Rvalue::Ref(_, kind, ref place)) = source {\n+            // Getting `true` from `HasMutInterior::in_rvalue` means\n+            // the borrowed place is disallowed from being borrowed,\n+            // due to either a mutable borrow (with some exceptions),\n+            // or an shared borrow of a value with interior mutability.\n+            // Then `HasMutInterior` is replaced with `IsNotConst`,\n+            // to avoid duplicate errors (e.g. from reborrowing).\n+            if qualifs[HasMutInterior] {\n+                qualifs[HasMutInterior] = false;\n+                qualifs[IsNotConst] = true;\n \n-    /// Assign the current qualification to the given destination.\n-    fn assign(&mut self, dest: &Place<'tcx>, location: Location) {\n-        trace!(\"assign: {:?}\", dest);\n-        let qualif = self.qualif;\n-        let span = self.span;\n-        let store = |slot: &mut Option<Qualif>| {\n-            if slot.is_some() {\n-                span_bug!(span, \"multiple assignments to {:?}\", dest);\n-            }\n-            *slot = Some(qualif);\n-        };\n-\n-        // Only handle promotable temps in non-const functions.\n-        if self.mode == Mode::Fn {\n-            if let Place::Local(index) = *dest {\n-                if self.mir.local_kind(index) == LocalKind::Temp\n-                && self.temp_promotion_state[index].is_promotable() {\n-                    debug!(\"store to promotable temp {:?} ({:?})\", index, qualif);\n-                    store(&mut self.local_qualif[index]);\n+                if self.mode != Mode::Fn {\n+                    if let BorrowKind::Mut { .. } = kind {\n+                        let mut err = struct_span_err!(self.tcx.sess,  self.span, E0017,\n+                                                       \"references in {}s may only refer \\\n+                                                        to immutable values\", self.mode);\n+                        err.span_label(self.span, format!(\"{}s require immutable values\",\n+                                                            self.mode));\n+                        if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                            err.note(\"References in statics and constants may only refer to \\\n+                                      immutable values.\\n\\n\\\n+                                      Statics are shared everywhere, and if they refer to \\\n+                                      mutable data one might violate memory safety since \\\n+                                      holding multiple mutable references to shared data is \\\n+                                      not allowed.\\n\\n\\\n+                                      If you really want global mutable state, try using \\\n+                                      static mut or a global UnsafeCell.\");\n+                        }\n+                        err.emit();\n+                    } else {\n+                        span_err!(self.tcx.sess, self.span, E0492,\n+                                  \"cannot borrow a constant which may contain \\\n+                                   interior mutability, create a static instead\");\n+                    }\n+                }\n+            } else {\n+                // We might have a candidate for promotion.\n+                let candidate = Candidate::Ref(location);\n+                // We can only promote interior borrows of promotable temps.\n+                let mut place = place;\n+                while let Place::Projection(ref proj) = *place {\n+                    if proj.elem == ProjectionElem::Deref {\n+                        break;\n+                    }\n+                    place = &proj.base;\n+                }\n+                debug!(\"qualify_consts: promotion candidate: place={:?}\", place);\n+                if let Place::Local(local) = *place {\n+                    if self.mir.local_kind(local) == LocalKind::Temp {\n+                        debug!(\"qualify_consts: promotion candidate: local={:?}\", local);\n+                        // The borrowed place doesn't have `HasMutInterior`\n+                        // (from `in_rvalue`), so we can safely ignore\n+                        // `HasMutInterior` from the local's qualifications.\n+                        // This allows borrowing fields which don't have\n+                        // `HasMutInterior`, from a type that does, e.g.:\n+                        // `let _: &'static _ = &(Cell::new(1), 2).1;`\n+                        let mut local_qualifs = self.qualifs_in_local(local);\n+                        local_qualifs[HasMutInterior] = false;\n+                        if !local_qualifs.0.iter().any(|&qualif| qualif) {\n+                            debug!(\"qualify_consts: promotion candidate: {:?}\", candidate);\n+                            self.promotion_candidates.push(candidate);\n+                        }\n+                    }\n                 }\n             }\n-            return;\n         }\n \n         let mut dest = dest;\n@@ -252,21 +781,44 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                 }\n             }\n         };\n-        debug!(\"store to var {:?}\", index);\n-        match &mut self.local_qualif[index] {\n-            // this is overly restrictive, because even full assignments do not clear the qualif\n-            // While we could special case full assignments, this would be inconsistent with\n-            // aggregates where we overwrite all fields via assignments, which would not get\n-            // that feature.\n-            Some(ref mut qualif) => *qualif = *qualif | self.qualif,\n-            // insert new qualification\n-            qualif @ None => *qualif = Some(self.qualif),\n+\n+        let kind = self.mir.local_kind(index);\n+        debug!(\"store to {:?} {:?}\", kind, index);\n+\n+        // Only handle promotable temps in non-const functions.\n+        if self.mode == Mode::Fn {\n+            if kind != LocalKind::Temp ||\n+               !self.temp_promotion_state[index].is_promotable() {\n+                return;\n+            }\n+        }\n+\n+        // this is overly restrictive, because even full assignments do not clear the qualif\n+        // While we could special case full assignments, this would be inconsistent with\n+        // aggregates where we overwrite all fields via assignments, which would not get\n+        // that feature.\n+        for (per_local, qualif) in &mut self.cx.per_local.as_mut().zip(qualifs).0 {\n+            if *qualif {\n+                per_local.insert(index);\n+            }\n+        }\n+\n+        // Ensure the `IsNotPromotable` qualification is preserved.\n+        // NOTE(eddyb) this is actually unnecessary right now, as\n+        // we never replace the local's qualif, but we might in\n+        // the future, and so it serves to catch changes that unset\n+        // important bits (in which case, asserting `contains` could\n+        // be replaced with calling `insert` to re-set the bit).\n+        if kind == LocalKind::Temp {\n+            if !self.temp_promotion_state[index].is_promotable() {\n+                assert!(self.cx.per_local[IsNotPromotable].contains(index));\n+            }\n         }\n     }\n \n-    /// Qualify a whole const, static initializer or const fn.\n-    fn qualify_const(&mut self) -> (Qualif, Lrc<BitSet<Local>>) {\n-        debug!(\"qualifying {} {:?}\", self.mode, self.def_id);\n+    /// Check a whole const, static initializer or const fn.\n+    fn check_const(&mut self) -> (u8, Lrc<BitSet<Local>>) {\n+        debug!(\"const-checking {} {:?}\", self.mode, self.def_id);\n \n         let mir = self.mir;\n \n@@ -317,16 +869,6 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             }\n         }\n \n-        self.qualif = self.local_qualif[RETURN_PLACE].unwrap_or(Qualif::NOT_CONST);\n-\n-        // Account for errors in consts by using the\n-        // conservative type qualification instead.\n-        if self.qualif.intersects(Qualif::CONST_ERROR) {\n-            self.qualif = Qualif::empty();\n-            let return_ty = mir.return_ty();\n-            self.add_type(return_ty);\n-        }\n-\n \n         // Collect all the temps we need to promote.\n         let mut promoted_temps = BitSet::new_empty(self.temp_promotion_state.len());\n@@ -346,61 +888,35 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             }\n         }\n \n-        (self.qualif, Lrc::new(promoted_temps))\n-    }\n-\n-    fn is_const_panic_fn(&self, def_id: DefId) -> bool {\n-        Some(def_id) == self.tcx.lang_items().panic_fn() ||\n-        Some(def_id) == self.tcx.lang_items().begin_panic_fn()\n-    }\n-}\n-\n-/// Accumulates an Rvalue or Call's effects in self.qualif.\n-/// For functions (constant or not), it also records\n-/// candidates for promotion in promotion_candidates.\n-impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n-    fn visit_local(&mut self,\n-                   &local: &Local,\n-                   _: PlaceContext<'tcx>,\n-                   _: Location) {\n-        debug!(\"visit_local: local={:?}\", local);\n-        let kind = self.mir.local_kind(local);\n-        match kind {\n-            LocalKind::ReturnPointer => {\n-                self.not_const();\n-            }\n-            LocalKind::Var if self.mode == Mode::Fn => {\n-                self.add(Qualif::NOT_CONST);\n-            }\n-            LocalKind::Var |\n-            LocalKind::Arg |\n-            LocalKind::Temp => {\n-                if let LocalKind::Arg = kind {\n-                    self.add(Qualif::FN_ARGUMENT);\n-                }\n+        let promoted_temps = Lrc::new(promoted_temps);\n \n-                if !self.temp_promotion_state[local].is_promotable() {\n-                    debug!(\"visit_local: (not promotable) local={:?}\", local);\n-                    self.add(Qualif::NOT_PROMOTABLE);\n-                }\n+        let mut qualifs = self.qualifs_in_local(RETURN_PLACE);\n \n-                if let Some(qualif) = self.local_qualif[local] {\n-                    self.add(qualif);\n-                } else {\n-                    self.not_const();\n-                }\n-            }\n+        // Account for errors in consts by using the\n+        // conservative type qualification instead.\n+        if qualifs[IsNotConst] {\n+            qualifs = self.qualifs_in_any_value_of_ty(mir.return_ty());\n         }\n+\n+        (qualifs.encode_to_bits(), promoted_temps)\n     }\n+}\n \n+/// Checks MIR for const-correctness, using `ConstCx`\n+/// for value qualifications, and accumulates writes of\n+/// rvalue/call results to locals, in `local_qualif`.\n+/// For functions (constant or not), it also records\n+/// candidates for promotion in `promotion_candidates`.\n+impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n     fn visit_place(&mut self,\n                     place: &Place<'tcx>,\n                     context: PlaceContext<'tcx>,\n                     location: Location) {\n         debug!(\"visit_place: place={:?} context={:?} location={:?}\", place, context, location);\n+        self.super_place(place, context, location);\n         match *place {\n-            Place::Local(ref local) => self.visit_local(local, context, location),\n-            Place::Promoted(_) => bug!(\"promoting already promoted MIR\"),\n+            Place::Local(_) |\n+            Place::Promoted(_) => {}\n             Place::Static(ref global) => {\n                 if self.tcx\n                        .get_attrs(global.def_id)\n@@ -411,7 +927,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                                   \"thread-local statics cannot be \\\n                                    accessed at compile-time\");\n                     }\n-                    self.add(Qualif::NOT_CONST);\n                     return;\n                 }\n \n@@ -430,7 +945,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     return;\n                 }\n                 unleash_miri!(self);\n-                self.add(Qualif::NOT_CONST);\n \n                 if self.mode != Mode::Fn {\n                     let mut err = struct_span_err!(self.tcx.sess, self.span, E0013,\n@@ -449,73 +963,64 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 }\n             }\n             Place::Projection(ref proj) => {\n-                self.nest(|this| {\n-                    this.super_place(place, context, location);\n-                    match proj.elem {\n-                        ProjectionElem::Deref => {\n-                            if context.is_mutating_use() {\n-                                // `not_const` errors out in const contexts\n-                                this.not_const()\n-                            } else {\n-                                // just make sure this doesn't get promoted\n-                                this.add(Qualif::NOT_CONST);\n-                            }\n-                            let base_ty = proj.base.ty(this.mir, this.tcx).to_ty(this.tcx);\n-                            match this.mode {\n-                                Mode::Fn => {},\n-                                _ => {\n-                                    if let ty::RawPtr(_) = base_ty.sty {\n-                                        if !this.tcx.features().const_raw_ptr_deref {\n-                                            emit_feature_err(\n-                                                &this.tcx.sess.parse_sess, \"const_raw_ptr_deref\",\n-                                                this.span, GateIssue::Language,\n-                                                &format!(\n-                                                    \"dereferencing raw pointers in {}s is unstable\",\n-                                                    this.mode,\n-                                                ),\n-                                            );\n-                                        }\n+                match proj.elem {\n+                    ProjectionElem::Deref => {\n+                        if context.is_mutating_use() {\n+                            // `not_const` errors out in const contexts\n+                            self.not_const()\n+                        }\n+                        let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                        match self.mode {\n+                            Mode::Fn => {},\n+                            _ => {\n+                                if let ty::RawPtr(_) = base_ty.sty {\n+                                    if !self.tcx.features().const_raw_ptr_deref {\n+                                        emit_feature_err(\n+                                            &self.tcx.sess.parse_sess, \"const_raw_ptr_deref\",\n+                                            self.span, GateIssue::Language,\n+                                            &format!(\n+                                                \"dereferencing raw pointers in {}s is unstable\",\n+                                                self.mode,\n+                                            ),\n+                                        );\n                                     }\n                                 }\n                             }\n                         }\n+                    }\n \n-                        ProjectionElem::ConstantIndex {..} |\n-                        ProjectionElem::Subslice {..} |\n-                        ProjectionElem::Field(..) |\n-                        ProjectionElem::Index(_) => {\n-                            let base_ty = proj.base.ty(this.mir, this.tcx).to_ty(this.tcx);\n-                            if let Some(def) = base_ty.ty_adt_def() {\n-                                if def.is_union() {\n-                                    match this.mode {\n-                                        Mode::Fn => this.not_const(),\n-                                        Mode::ConstFn => {\n-                                            if !this.tcx.features().const_fn_union {\n-                                                emit_feature_err(\n-                                                    &this.tcx.sess.parse_sess, \"const_fn_union\",\n-                                                    this.span, GateIssue::Language,\n-                                                    \"unions in const fn are unstable\",\n-                                                );\n-                                            }\n-                                        },\n-\n-                                        | Mode::Static\n-                                        | Mode::StaticMut\n-                                        | Mode::Const\n-                                        => {},\n-                                    }\n+                    ProjectionElem::ConstantIndex {..} |\n+                    ProjectionElem::Subslice {..} |\n+                    ProjectionElem::Field(..) |\n+                    ProjectionElem::Index(_) => {\n+                        let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                        if let Some(def) = base_ty.ty_adt_def() {\n+                            if def.is_union() {\n+                                match self.mode {\n+                                    Mode::ConstFn => {\n+                                        if !self.tcx.features().const_fn_union {\n+                                            emit_feature_err(\n+                                                &self.tcx.sess.parse_sess, \"const_fn_union\",\n+                                                self.span, GateIssue::Language,\n+                                                \"unions in const fn are unstable\",\n+                                            );\n+                                        }\n+                                    },\n+\n+                                    | Mode::Fn\n+                                    | Mode::Static\n+                                    | Mode::StaticMut\n+                                    | Mode::Const\n+                                    => {},\n                                 }\n                             }\n-\n-                            let ty = place.ty(this.mir, this.tcx).to_ty(this.tcx);\n-                            this.qualif.restrict(ty, this.tcx, this.param_env);\n                         }\n+                    }\n \n-                        ProjectionElem::Downcast(..) => {\n-                            this.not_const()\n-                        }\n+                    ProjectionElem::Downcast(..) => {\n+                        self.not_const()\n                     }\n-                });\n+                }\n             }\n         }\n     }\n@@ -525,40 +1030,23 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n         self.super_operand(operand, location);\n \n         match *operand {\n-            Operand::Copy(_) |\n-            Operand::Move(_) => {\n+            Operand::Move(ref place) => {\n                 // Mark the consumed locals to indicate later drops are noops.\n-                if let Operand::Move(Place::Local(local)) = *operand {\n-                    self.local_qualif[local] = self.local_qualif[local].map(|q|\n-                        q - Qualif::NEEDS_DROP\n-                    );\n-                }\n-            }\n-            Operand::Constant(ref constant) => {\n-                if let ty::LazyConst::Unevaluated(def_id, _) = constant.literal {\n-                    // Don't peek inside trait associated constants.\n-                    if self.tcx.trait_of_item(*def_id).is_some() {\n-                        self.add_type(constant.ty);\n-                    } else {\n-                        let (bits, _) = self.tcx.at(constant.span).mir_const_qualif(*def_id);\n-\n-                        let qualif = Qualif::from_bits(bits).expect(\"invalid mir_const_qualif\");\n-                        self.add(qualif);\n-\n-                        // Just in case the type is more specific than\n-                        // the definition, e.g., impl associated const\n-                        // with type parameters, take it into account.\n-                        self.qualif.restrict(constant.ty, self.tcx, self.param_env);\n-                    }\n+                if let Place::Local(local) = *place {\n+                    self.cx.per_local[NeedsDrop].remove(local);\n                 }\n             }\n+            Operand::Copy(_) |\n+            Operand::Constant(_) => {}\n         }\n     }\n \n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         debug!(\"visit_rvalue: rvalue={:?} location={:?}\", rvalue, location);\n-        // Recurse through operands and places.\n+\n+        // Check nested operands and places.\n         if let Rvalue::Ref(region, kind, ref place) = *rvalue {\n+            // Special-case reborrows.\n             let mut is_reborrow = false;\n             if let Place::Projection(ref proj) = *place {\n                 if let ProjectionElem::Deref = proj.elem {\n@@ -571,14 +1059,18 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n \n             if is_reborrow {\n                 let ctx = match kind {\n-                    BorrowKind::Shared =>\n-                        PlaceContext::NonMutatingUse(NonMutatingUseContext::SharedBorrow(region)),\n-                    BorrowKind::Shallow =>\n-                        PlaceContext::NonMutatingUse(NonMutatingUseContext::ShallowBorrow(region)),\n-                    BorrowKind::Unique =>\n-                        PlaceContext::NonMutatingUse(NonMutatingUseContext::UniqueBorrow(region)),\n-                    BorrowKind::Mut { .. } =>\n-                        PlaceContext::MutatingUse(MutatingUseContext::Borrow(region)),\n+                    BorrowKind::Shared => PlaceContext::NonMutatingUse(\n+                        NonMutatingUseContext::SharedBorrow(region),\n+                    ),\n+                    BorrowKind::Shallow => PlaceContext::NonMutatingUse(\n+                        NonMutatingUseContext::ShallowBorrow(region),\n+                    ),\n+                    BorrowKind::Unique => PlaceContext::NonMutatingUse(\n+                        NonMutatingUseContext::UniqueBorrow(region),\n+                    ),\n+                    BorrowKind::Mut { .. } => PlaceContext::MutatingUse(\n+                        MutatingUseContext::Borrow(region),\n+                    ),\n                 };\n                 self.super_place(place, ctx, location);\n             } else {\n@@ -600,124 +1092,19 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             Rvalue::Cast(CastKind::ClosureFnPointer, ..) |\n             Rvalue::Cast(CastKind::Unsize, ..) |\n             Rvalue::Discriminant(..) |\n-            Rvalue::Len(_) => {}\n-\n-            Rvalue::Ref(_, kind, ref place) => {\n-                let ty = place.ty(self.mir, self.tcx).to_ty(self.tcx);\n-\n-                // Default to forbidding the borrow and/or its promotion,\n-                // due to the potential for direct or interior mutability,\n-                // and only proceed by setting `forbidden_mut` to `false`.\n-                let mut forbidden_mut = true;\n-\n-                if let BorrowKind::Mut { .. } = kind {\n-                    // In theory, any zero-sized value could be borrowed\n-                    // mutably without consequences. However, only &mut []\n-                    // is allowed right now, and only in functions.\n-                    if self.mode == Mode::StaticMut {\n-                        // Inside a `static mut`, &mut [...] is also allowed.\n-                        match ty.sty {\n-                            ty::Array(..) | ty::Slice(_) => forbidden_mut = false,\n-                            _ => {}\n-                        }\n-                    } else if let ty::Array(_, len) = ty.sty {\n-                        // FIXME(eddyb) the `self.mode == Mode::Fn` condition\n-                        // seems unnecessary, given that this is merely a ZST.\n-                        if len.unwrap_usize(self.tcx) == 0 && self.mode == Mode::Fn {\n-                            forbidden_mut = false;\n-                        }\n-                    }\n-\n-                    if forbidden_mut {\n-                        unleash_miri!(self);\n-                        self.add(Qualif::NOT_CONST);\n-                        if self.mode != Mode::Fn {\n-                            let mut err = struct_span_err!(self.tcx.sess,  self.span, E0017,\n-                                                           \"references in {}s may only refer \\\n-                                                            to immutable values\", self.mode);\n-                            err.span_label(self.span, format!(\"{}s require immutable values\",\n-                                                                self.mode));\n-                            if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                                err.note(\"References in statics and constants may only refer to \\\n-                                          immutable values.\\n\\n\\\n-                                          Statics are shared everywhere, and if they refer to \\\n-                                          mutable data one might violate memory safety since \\\n-                                          holding multiple mutable references to shared data is \\\n-                                          not allowed.\\n\\n\\\n-                                          If you really want global mutable state, try using \\\n-                                          static mut or a global UnsafeCell.\");\n-                            }\n-                            err.emit();\n-                        }\n-                    }\n-                } else {\n-                    // Constants cannot be borrowed if they contain interior mutability as\n-                    // it means that our \"silent insertion of statics\" could change\n-                    // initializer values (very bad).\n-                    if self.qualif.contains(Qualif::MUTABLE_INTERIOR) {\n-                        // A reference of a MUTABLE_INTERIOR place is instead\n-                        // NOT_CONST (see `if forbidden_mut` below), to avoid\n-                        // duplicate errors (from reborrowing, for example).\n-                        self.qualif = self.qualif - Qualif::MUTABLE_INTERIOR;\n-                        if self.mode != Mode::Fn {\n-                            span_err!(self.tcx.sess, self.span, E0492,\n-                                      \"cannot borrow a constant which may contain \\\n-                                       interior mutability, create a static instead\");\n-                        }\n-                    } else {\n-                        // We allow immutable borrows of frozen data.\n-                        forbidden_mut = false;\n-                    }\n-                }\n-\n-                debug!(\"visit_rvalue: forbidden_mut={:?}\", forbidden_mut);\n-                if forbidden_mut {\n-                    unleash_miri!(self);\n-                    self.add(Qualif::NOT_CONST);\n-                } else {\n-                    // We might have a candidate for promotion.\n-                    let candidate = Candidate::Ref(location);\n-                    // We can only promote interior borrows of promotable temps.\n-                    let mut place = place;\n-                    while let Place::Projection(ref proj) = *place {\n-                        if proj.elem == ProjectionElem::Deref {\n-                            break;\n-                        }\n-                        place = &proj.base;\n-                    }\n-                    debug!(\"visit_rvalue: place={:?}\", place);\n-                    if let Place::Local(local) = *place {\n-                        if self.mir.local_kind(local) == LocalKind::Temp {\n-                            debug!(\"visit_rvalue: local={:?}\", local);\n-                            if let Some(qualif) = self.local_qualif[local] {\n-                                // `forbidden_mut` is false, so we can safely ignore\n-                                // `MUTABLE_INTERIOR` from the local's qualifications.\n-                                // This allows borrowing fields which don't have\n-                                // `MUTABLE_INTERIOR`, from a type that does, e.g.:\n-                                // `let _: &'static _ = &(Cell::new(1), 2).1;`\n-                                debug!(\"visit_rvalue: qualif={:?}\", qualif);\n-                                if (qualif - Qualif::MUTABLE_INTERIOR).is_empty() {\n-                                    debug!(\"visit_rvalue: candidate={:?}\", candidate);\n-                                    self.promotion_candidates.push(candidate);\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n+            Rvalue::Len(_) |\n+            Rvalue::Ref(..) |\n+            Rvalue::Aggregate(..) => {}\n \n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n                 let operand_ty = operand.ty(self.mir, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n                 match (cast_in, cast_out) {\n                     (CastTy::Ptr(_), CastTy::Int(_)) |\n-                    (CastTy::FnPtr, CastTy::Int(_)) => {\n+                    (CastTy::FnPtr, CastTy::Int(_)) if self.mode != Mode::Fn => {\n                         unleash_miri!(self);\n-                        if let Mode::Fn = self.mode {\n-                            // in normal functions, mark such casts as not promotable\n-                            self.add(Qualif::NOT_CONST);\n-                        } else if !self.tcx.features().const_raw_ptr_to_usize_cast {\n+                        if !self.tcx.features().const_raw_ptr_to_usize_cast {\n                             // in const fn and constants require the feature gate\n                             // FIXME: make it unsafe inside const fn and constants\n                             emit_feature_err(\n@@ -742,10 +1129,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                             op == BinOp::Offset);\n \n                     unleash_miri!(self);\n-                    if let Mode::Fn = self.mode {\n-                        // raw pointer operations are not allowed inside promoteds\n-                        self.add(Qualif::NOT_CONST);\n-                    } else if !self.tcx.features().const_compare_raw_pointers {\n+                    if self.mode != Mode::Fn && !self.tcx.features().const_compare_raw_pointers {\n                         // require the feature gate inside constants and const fn\n                         // FIXME: make it unsafe to use these operations\n                         emit_feature_err(\n@@ -761,7 +1145,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n \n             Rvalue::NullaryOp(NullOp::Box, _) => {\n                 unleash_miri!(self);\n-                self.add(Qualif::NOT_CONST);\n                 if self.mode != Mode::Fn {\n                     let mut err = struct_span_err!(self.tcx.sess, self.span, E0010,\n                                                    \"allocations are not allowed in {}s\", self.mode);\n@@ -777,20 +1160,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     err.emit();\n                 }\n             }\n-\n-            Rvalue::Aggregate(ref kind, _) => {\n-                if let AggregateKind::Adt(def, ..) = **kind {\n-                    if def.has_dtor(self.tcx) {\n-                        self.add(Qualif::NEEDS_DROP);\n-                    }\n-\n-                    if Some(def.did) == self.tcx.lang_items().unsafe_cell_type() {\n-                        let ty = rvalue.ty(self.mir, self.tcx);\n-                        self.add_type(ty);\n-                        assert!(self.qualif.contains(Qualif::MUTABLE_INTERIOR));\n-                    }\n-                }\n-            }\n         }\n     }\n \n@@ -800,13 +1169,17 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                              location: Location) {\n         debug!(\"visit_terminator_kind: bb={:?} kind={:?} location={:?}\", bb, kind, location);\n         if let TerminatorKind::Call { ref func, ref args, ref destination, .. } = *kind {\n-            self.visit_operand(func, location);\n+            if let Some((ref dest, _)) = *destination {\n+                self.assign(dest, ValueSource::Call {\n+                    callee: func,\n+                    args,\n+                    return_ty: dest.ty(self.mir, self.tcx).to_ty(self.tcx),\n+                }, location);\n+            }\n \n             let fn_ty = func.ty(self.mir, self.tcx);\n             let mut callee_def_id = None;\n             let mut is_shuffle = false;\n-            let mut is_const_fn = false;\n-            let mut is_promotable_const_fn = false;\n             match fn_ty.sty {\n                 ty::FnDef(def_id, _) => {\n                     callee_def_id = Some(def_id);\n@@ -815,38 +1188,11 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                         Abi::PlatformIntrinsic => {\n                             assert!(!self.tcx.is_const_fn(def_id));\n                             match &self.tcx.item_name(def_id).as_str()[..] {\n-                                | \"size_of\"\n-                                | \"min_align_of\"\n-                                | \"needs_drop\"\n-                                | \"type_id\"\n-                                | \"bswap\"\n-                                | \"bitreverse\"\n-                                | \"ctpop\"\n-                                | \"cttz\"\n-                                | \"cttz_nonzero\"\n-                                | \"ctlz\"\n-                                | \"ctlz_nonzero\"\n-                                | \"overflowing_add\"\n-                                | \"overflowing_sub\"\n-                                | \"overflowing_mul\"\n-                                | \"unchecked_shl\"\n-                                | \"unchecked_shr\"\n-                                | \"rotate_left\"\n-                                | \"rotate_right\"\n-                                | \"add_with_overflow\"\n-                                | \"sub_with_overflow\"\n-                                | \"mul_with_overflow\"\n-                                | \"saturating_add\"\n-                                | \"saturating_sub\"\n-                                // no need to check feature gates, intrinsics are only callable\n-                                // from the libstd or with forever unstable feature gates\n-                                => is_const_fn = true,\n                                 // special intrinsic that can be called diretly without an intrinsic\n                                 // feature gate needs a language feature gate\n                                 \"transmute\" => {\n                                     // never promote transmute calls\n                                     if self.mode != Mode::Fn {\n-                                        is_const_fn = true;\n                                         // const eval transmute calls only with the feature gate\n                                         if !self.tcx.features().const_transmute {\n                                             emit_feature_err(\n@@ -862,39 +1208,30 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                                     is_shuffle = true;\n                                 }\n \n+                                // no need to check feature gates, intrinsics are only callable\n+                                // from the libstd or with forever unstable feature gates\n                                 _ => {}\n                             }\n                         }\n                         _ => {\n-                            // In normal functions we only care about promotion.\n-                            if self.mode == Mode::Fn {\n-                                // Never promote const fn calls of\n-                                // functions without `#[rustc_promotable]`.\n-                                if self.tcx.is_promotable_const_fn(def_id) {\n-                                    is_const_fn = true;\n-                                    is_promotable_const_fn = true;\n-                                } else if self.tcx.is_const_fn(def_id) {\n-                                    is_const_fn = true;\n-                                }\n-                            } else {\n-                                // stable const fns or unstable const fns with their feature gate\n-                                // active\n+                            // In normal functions no calls are feature-gated.\n+                            if self.mode != Mode::Fn {\n                                 let unleash_miri = self\n                                     .tcx\n                                     .sess\n                                     .opts\n                                     .debugging_opts\n                                     .unleash_the_miri_inside_of_you;\n                                 if self.tcx.is_const_fn(def_id) || unleash_miri {\n-                                    is_const_fn = true;\n+                                    // stable const fns or unstable const fns\n+                                    // with their feature gate active\n+                                    // FIXME(eddyb) move stability checks from `is_const_fn` here.\n                                 } else if self.is_const_panic_fn(def_id) {\n                                     // Check the const_panic feature gate.\n                                     // FIXME: cannot allow this inside `allow_internal_unstable`\n                                     // because that would make `panic!` insta stable in constants,\n                                     // since the macro is marked with the attribute.\n-                                    if self.tcx.features().const_panic {\n-                                        is_const_fn = true;\n-                                    } else {\n+                                    if !self.tcx.features().const_panic {\n                                         // Don't allow panics in constants without the feature gate.\n                                         emit_feature_err(\n                                             &self.tcx.sess.parse_sess,\n@@ -909,10 +1246,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                                     // Check `#[unstable]` const fns or `#[rustc_const_unstable]`\n                                     // functions without the feature gate active in this crate in\n                                     // order to report a better error message than the one below.\n-                                    if self.span.allows_unstable(&feature.as_str()) {\n-                                        // `allow_internal_unstable` can make such calls stable.\n-                                        is_const_fn = true;\n-                                    } else {\n+                                    if !self.span.allows_unstable(&feature.as_str()) {\n                                         let mut err = self.tcx.sess.struct_span_err(self.span,\n                                             &format!(\"`{}` is not yet stable as a const fn\",\n                                                     self.tcx.item_path_str(def_id)));\n@@ -925,81 +1259,43 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                                         err.emit();\n                                     }\n                                 } else {\n-                                    // FIXME(#57563): remove this check when const fn stabilizes.\n-                                    let (msg, note) = if let UnstableFeatures::Disallow =\n-                                            self.tcx.sess.opts.unstable_features {\n-                                        (format!(\"calls in {}s are limited to \\\n-                                                tuple structs and tuple variants\",\n-                                                self.mode),\n-                                        Some(\"a limited form of compile-time function \\\n-                                            evaluation is available on a nightly \\\n-                                            compiler via `const fn`\"))\n-                                    } else {\n-                                        (format!(\"calls in {}s are limited \\\n-                                                to constant functions, \\\n-                                                tuple structs and tuple variants\",\n-                                                self.mode),\n-                                        None)\n-                                    };\n                                     let mut err = struct_span_err!(\n                                         self.tcx.sess,\n                                         self.span,\n                                         E0015,\n-                                        \"{}\",\n-                                        msg,\n+                                        \"calls in {}s are limited to constant functions, \\\n+                                         tuple structs and tuple variants\",\n+                                        self.mode,\n                                     );\n-                                    if let Some(note) = note {\n-                                        err.span_note(self.span, note);\n-                                    }\n                                     err.emit();\n                                 }\n                             }\n                         }\n                     }\n-                },\n+                }\n                 ty::FnPtr(_) => {\n                     if self.mode != Mode::Fn {\n                         let mut err = self.tcx.sess.struct_span_err(\n                             self.span,\n                             &format!(\"function pointers are not allowed in const fn\"));\n                         err.emit();\n                     }\n-                },\n+                }\n                 _ => {\n                     self.not_const();\n-                    return\n                 }\n             }\n \n-\n-            let constant_arguments = callee_def_id.and_then(|id| {\n-                args_required_const(self.tcx, id)\n-            });\n-            for (i, arg) in args.iter().enumerate() {\n-                self.nest(|this| {\n-                    this.visit_operand(arg, location);\n-                    if this.mode != Mode::Fn {\n-                        return\n-                    }\n-                    let candidate = Candidate::Argument { bb, index: i };\n-                    if is_shuffle && i == 2 {\n-                        if this.qualif.is_empty() {\n-                            debug!(\"visit_terminator_kind: candidate={:?}\", candidate);\n-                            this.promotion_candidates.push(candidate);\n-                        } else {\n-                            span_err!(this.tcx.sess, this.span, E0526,\n-                                      \"shuffle indices are not constant\");\n-                        }\n-                        return\n+            if self.mode == Mode::Fn {\n+                let constant_args = callee_def_id.and_then(|id| {\n+                    args_required_const(self.tcx, id)\n+                }).unwrap_or_default();\n+                for (i, arg) in args.iter().enumerate() {\n+                    if !(is_shuffle && i == 2 || constant_args.contains(&i)) {\n+                        continue;\n                     }\n \n-                    let constant_arguments = match constant_arguments.as_ref() {\n-                        Some(s) => s,\n-                        None => return,\n-                    };\n-                    if !constant_arguments.contains(&i) {\n-                        return\n-                    }\n+                    let candidate = Candidate::Argument { bb, index: i };\n                     // Since the argument is required to be constant,\n                     // we care about constness, not promotability.\n                     // If we checked for promotability, we'd miss out on\n@@ -1010,44 +1306,26 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     // which happens even without the user requesting it.\n                     // We can error out with a hard error if the argument is not\n                     // constant here.\n-                    if (this.qualif - Qualif::NOT_PROMOTABLE).is_empty() {\n+                    if !IsNotConst::in_operand(self, arg) {\n                         debug!(\"visit_terminator_kind: candidate={:?}\", candidate);\n-                        this.promotion_candidates.push(candidate);\n+                        self.promotion_candidates.push(candidate);\n                     } else {\n-                        this.tcx.sess.span_err(this.span,\n-                            &format!(\"argument {} is required to be a constant\",\n-                                     i + 1));\n+                        if is_shuffle {\n+                            span_err!(self.tcx.sess, self.span, E0526,\n+                                      \"shuffle indices are not constant\");\n+                        } else {\n+                            self.tcx.sess.span_err(self.span,\n+                                &format!(\"argument {} is required to be a constant\",\n+                                         i + 1));\n+                        }\n                     }\n-                });\n-            }\n-\n-            // non-const fn calls\n-            if !is_const_fn {\n-                self.qualif = Qualif::NOT_CONST;\n-                if self.mode != Mode::Fn {\n-                    self.tcx.sess.delay_span_bug(\n-                        self.span,\n-                        \"should have reported an error about non-const fn calls in constants\",\n-                    )\n                 }\n             }\n \n-            if let Some((ref dest, _)) = *destination {\n-                // Avoid propagating irrelevant callee/argument qualifications.\n-                if self.qualif.intersects(Qualif::CONST_ERROR) {\n-                    self.qualif = Qualif::NOT_CONST;\n-                } else {\n-                    // Be conservative about the returned value of a const fn.\n-                    let tcx = self.tcx;\n-                    let ty = dest.ty(self.mir, tcx).to_ty(tcx);\n-                    if is_const_fn && !is_promotable_const_fn && self.mode == Mode::Fn {\n-                        self.qualif = Qualif::NOT_PROMOTABLE;\n-                    } else {\n-                        self.qualif = Qualif::empty();\n-                    }\n-                    self.add_type(ty);\n-                }\n-                self.assign(dest, location);\n+            // Check callee and argument operands.\n+            self.visit_operand(func, location);\n+            for arg in args {\n+                self.visit_operand(arg, location);\n             }\n         } else if let TerminatorKind::Drop { location: ref place, .. } = *kind {\n             self.super_terminator_kind(bb, kind, location);\n@@ -1058,7 +1336,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 // HACK(eddyb): emulate a bit of dataflow analysis,\n                 // conservatively, that drop elaboration will do.\n                 let needs_drop = if let Place::Local(local) = *place {\n-                    if self.local_qualif[local].map_or(true, |q| q.contains(Qualif::NEEDS_DROP)) {\n+                    if NeedsDrop::in_local(self, local) {\n                         Some(self.mir.local_decls[local].source_info.span)\n                     } else {\n                         None\n@@ -1091,9 +1369,9 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     rvalue: &Rvalue<'tcx>,\n                     location: Location) {\n         debug!(\"visit_assign: dest={:?} rvalue={:?} location={:?}\", dest, rvalue, location);\n-        self.visit_rvalue(rvalue, location);\n+        self.assign(dest, ValueSource::Rvalue(rvalue), location);\n \n-        self.assign(dest, location);\n+        self.visit_rvalue(rvalue, location);\n     }\n \n     fn visit_source_info(&mut self, source_info: &SourceInfo) {\n@@ -1103,30 +1381,28 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n \n     fn visit_statement(&mut self, bb: BasicBlock, statement: &Statement<'tcx>, location: Location) {\n         debug!(\"visit_statement: bb={:?} statement={:?} location={:?}\", bb, statement, location);\n-        self.nest(|this| {\n-            this.visit_source_info(&statement.source_info);\n-            match statement.kind {\n-                StatementKind::Assign(ref place, ref rvalue) => {\n-                    this.visit_assign(bb, place, rvalue, location);\n-                }\n-                StatementKind::FakeRead(..) |\n-                StatementKind::SetDiscriminant { .. } |\n-                StatementKind::StorageLive(_) |\n-                StatementKind::StorageDead(_) |\n-                StatementKind::InlineAsm {..} |\n-                StatementKind::Retag { .. } |\n-                StatementKind::AscribeUserType(..) |\n-                StatementKind::Nop => {}\n+        match statement.kind {\n+            StatementKind::Assign(..) => {\n+                self.super_statement(bb, statement, location);\n             }\n-        });\n+            // FIXME(eddyb) should these really do nothing?\n+            StatementKind::FakeRead(..) |\n+            StatementKind::SetDiscriminant { .. } |\n+            StatementKind::StorageLive(_) |\n+            StatementKind::StorageDead(_) |\n+            StatementKind::InlineAsm {..} |\n+            StatementKind::Retag { .. } |\n+            StatementKind::AscribeUserType(..) |\n+            StatementKind::Nop => {}\n+        }\n     }\n \n     fn visit_terminator(&mut self,\n                         bb: BasicBlock,\n                         terminator: &Terminator<'tcx>,\n                         location: Location) {\n         debug!(\"visit_terminator: bb={:?} terminator={:?} location={:?}\", bb, terminator, location);\n-        self.nest(|this| this.super_terminator(bb, terminator, location));\n+        self.super_terminator(bb, terminator, location);\n     }\n }\n \n@@ -1148,12 +1424,10 @@ fn mir_const_qualif<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     if mir.return_ty().references_error() {\n         tcx.sess.delay_span_bug(mir.span, \"mir_const_qualif: Mir had errors\");\n-        return (Qualif::NOT_CONST.bits(), Lrc::new(BitSet::new_empty(0)));\n+        return (1 << IsNotConst::IDX, Lrc::new(BitSet::new_empty(0)));\n     }\n \n-    let mut qualifier = Qualifier::new(tcx, def_id, mir, Mode::Const);\n-    let (qualif, promoted_temps) = qualifier.qualify_const();\n-    (qualif.bits(), promoted_temps)\n+    Checker::new(tcx, def_id, mir, Mode::Const).check_const()\n }\n \n pub struct QualifyAndPromoteConstants;\n@@ -1195,13 +1469,13 @@ impl MirPass for QualifyAndPromoteConstants {\n \n         debug!(\"run_pass: mode={:?}\", mode);\n         if mode == Mode::Fn || mode == Mode::ConstFn {\n-            // This is ugly because Qualifier holds onto mir,\n+            // This is ugly because Checker holds onto mir,\n             // which can't be mutated until its scope ends.\n             let (temps, candidates) = {\n-                let mut qualifier = Qualifier::new(tcx, def_id, mir, mode);\n+                let mut checker = Checker::new(tcx, def_id, mir, mode);\n                 if mode == Mode::ConstFn {\n                     if tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n-                        qualifier.qualify_const();\n+                        checker.check_const();\n                     } else if tcx.is_min_const_fn(def_id) {\n                         // enforce `min_const_fn` for stable const fns\n                         use super::qualify_min_const_fn::is_min_const_fn;\n@@ -1210,19 +1484,19 @@ impl MirPass for QualifyAndPromoteConstants {\n                         } else {\n                             // this should not produce any errors, but better safe than sorry\n                             // FIXME(#53819)\n-                            qualifier.qualify_const();\n+                            checker.check_const();\n                         }\n                     } else {\n                         // Enforce a constant-like CFG for `const fn`.\n-                        qualifier.qualify_const();\n+                        checker.check_const();\n                     }\n                 } else {\n-                    while let Some((bb, data)) = qualifier.rpo.next() {\n-                        qualifier.visit_basic_block_data(bb, data);\n+                    while let Some((bb, data)) = checker.rpo.next() {\n+                        checker.visit_basic_block_data(bb, data);\n                     }\n                 }\n \n-                (qualifier.temp_promotion_state, qualifier.promotion_candidates)\n+                (checker.temp_promotion_state, checker.promotion_candidates)\n             };\n \n             // Do the actual promotion, now that we know what's viable.\n@@ -1263,7 +1537,7 @@ impl MirPass for QualifyAndPromoteConstants {\n                 // Already computed by `mir_const_qualif`.\n                 const_promoted_temps.unwrap()\n             } else {\n-                Qualifier::new(tcx, def_id, mir, mode).qualify_const().1\n+                Checker::new(tcx, def_id, mir, mode).check_const().1\n             };\n \n             // In `const` and `static` everything without `StorageDead`"}, {"sha": "0477f06010b0277c1df26357ab05b90c24eafefa", "filename": "src/test/ui/error-codes/E0017.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f058741a679062202697144daebd05e1b0d6d747/src%2Ftest%2Fui%2Ferror-codes%2FE0017.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f058741a679062202697144daebd05e1b0d6d747/src%2Ftest%2Fui%2Ferror-codes%2FE0017.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0017.nll.stderr?ref=f058741a679062202697144daebd05e1b0d6d747", "patch": "@@ -4,17 +4,17 @@ error[E0017]: references in constants may only refer to immutable values\n LL | const CR: &'static mut i32 = &mut C; //~ ERROR E0017\n    |                              ^^^^^^ constants require immutable values\n \n-error: cannot mutate statics in the initializer of another static\n+error[E0017]: references in statics may only refer to immutable values\n   --> $DIR/E0017.rs:5:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n-   |                                       ^^^^^^\n+   |                                       ^^^^^^ statics require immutable values\n \n-error[E0017]: references in statics may only refer to immutable values\n+error: cannot mutate statics in the initializer of another static\n   --> $DIR/E0017.rs:5:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n-   |                                       ^^^^^^ statics require immutable values\n+   |                                       ^^^^^^\n \n error[E0596]: cannot borrow immutable static item `X` as mutable\n   --> $DIR/E0017.rs:5:39"}, {"sha": "cc202ec912e96b2665d592910733deabc9b65ccb", "filename": "src/test/ui/error-codes/E0017.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f058741a679062202697144daebd05e1b0d6d747/src%2Ftest%2Fui%2Ferror-codes%2FE0017.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f058741a679062202697144daebd05e1b0d6d747/src%2Ftest%2Fui%2Ferror-codes%2FE0017.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0017.stderr?ref=f058741a679062202697144daebd05e1b0d6d747", "patch": "@@ -4,17 +4,17 @@ error[E0017]: references in constants may only refer to immutable values\n LL | const CR: &'static mut i32 = &mut C; //~ ERROR E0017\n    |                              ^^^^^^ constants require immutable values\n \n-error: cannot mutate statics in the initializer of another static\n+error[E0017]: references in statics may only refer to immutable values\n   --> $DIR/E0017.rs:5:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n-   |                                       ^^^^^^\n+   |                                       ^^^^^^ statics require immutable values\n \n-error[E0017]: references in statics may only refer to immutable values\n+error: cannot mutate statics in the initializer of another static\n   --> $DIR/E0017.rs:5:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n-   |                                       ^^^^^^ statics require immutable values\n+   |                                       ^^^^^^\n \n error[E0596]: cannot borrow immutable static item as mutable\n   --> $DIR/E0017.rs:5:44"}, {"sha": "a898d60a98595c9d81380eeba3cee165ccf12838", "filename": "src/test/ui/error-codes/E0388.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f058741a679062202697144daebd05e1b0d6d747/src%2Ftest%2Fui%2Ferror-codes%2FE0388.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f058741a679062202697144daebd05e1b0d6d747/src%2Ftest%2Fui%2Ferror-codes%2FE0388.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0388.nll.stderr?ref=f058741a679062202697144daebd05e1b0d6d747", "patch": "@@ -4,17 +4,17 @@ error[E0017]: references in constants may only refer to immutable values\n LL | const CR: &'static mut i32 = &mut C; //~ ERROR E0017\n    |                              ^^^^^^ constants require immutable values\n \n-error: cannot mutate statics in the initializer of another static\n+error[E0017]: references in statics may only refer to immutable values\n   --> $DIR/E0388.rs:5:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n-   |                                       ^^^^^^\n+   |                                       ^^^^^^ statics require immutable values\n \n-error[E0017]: references in statics may only refer to immutable values\n+error: cannot mutate statics in the initializer of another static\n   --> $DIR/E0388.rs:5:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n-   |                                       ^^^^^^ statics require immutable values\n+   |                                       ^^^^^^\n \n error[E0596]: cannot borrow immutable static item `X` as mutable\n   --> $DIR/E0388.rs:5:39"}, {"sha": "f641830ae9ff23076c40f76efcb3ca639fdc531a", "filename": "src/test/ui/error-codes/E0388.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f058741a679062202697144daebd05e1b0d6d747/src%2Ftest%2Fui%2Ferror-codes%2FE0388.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f058741a679062202697144daebd05e1b0d6d747/src%2Ftest%2Fui%2Ferror-codes%2FE0388.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0388.stderr?ref=f058741a679062202697144daebd05e1b0d6d747", "patch": "@@ -4,17 +4,17 @@ error[E0017]: references in constants may only refer to immutable values\n LL | const CR: &'static mut i32 = &mut C; //~ ERROR E0017\n    |                              ^^^^^^ constants require immutable values\n \n-error: cannot mutate statics in the initializer of another static\n+error[E0017]: references in statics may only refer to immutable values\n   --> $DIR/E0388.rs:5:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n-   |                                       ^^^^^^\n+   |                                       ^^^^^^ statics require immutable values\n \n-error[E0017]: references in statics may only refer to immutable values\n+error: cannot mutate statics in the initializer of another static\n   --> $DIR/E0388.rs:5:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n-   |                                       ^^^^^^ statics require immutable values\n+   |                                       ^^^^^^\n \n error[E0596]: cannot borrow immutable static item as mutable\n   --> $DIR/E0388.rs:5:44"}, {"sha": "95ef2b1b010087121b6eed5f79718bae7633e862", "filename": "src/test/ui/issues/issue-17718-const-bad-values.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f058741a679062202697144daebd05e1b0d6d747/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-bad-values.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f058741a679062202697144daebd05e1b0d6d747/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-bad-values.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-bad-values.stderr?ref=f058741a679062202697144daebd05e1b0d6d747", "patch": "@@ -4,17 +4,17 @@ error[E0017]: references in constants may only refer to immutable values\n LL | const C1: &'static mut [usize] = &mut [];\n    |                                  ^^^^^^^ constants require immutable values\n \n-error[E0013]: constants cannot refer to statics, use a constant instead\n+error[E0017]: references in constants may only refer to immutable values\n   --> $DIR/issue-17718-const-bad-values.rs:5:41\n    |\n LL | const C2: &'static mut usize = unsafe { &mut S };\n-   |                                         ^^^^^^\n+   |                                         ^^^^^^ constants require immutable values\n \n-error[E0017]: references in constants may only refer to immutable values\n+error[E0013]: constants cannot refer to statics, use a constant instead\n   --> $DIR/issue-17718-const-bad-values.rs:5:41\n    |\n LL | const C2: &'static mut usize = unsafe { &mut S };\n-   |                                         ^^^^^^ constants require immutable values\n+   |                                         ^^^^^^\n \n error: aborting due to 3 previous errors\n "}]}