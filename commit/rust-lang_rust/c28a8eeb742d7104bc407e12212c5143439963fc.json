{"sha": "c28a8eeb742d7104bc407e12212c5143439963fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyOGE4ZWViNzQyZDcxMDRiYzQwN2UxMjIxMmM1MTQzNDM5OTYzZmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-03T10:09:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-03T10:09:34Z"}, "message": "Auto merge of #1532 - divergentdave:thread-panic-payload, r=RalfJung\n\nMove panic payload state from Machine to Thread\n\nThis PR moves the panic payload storage from the `Machine` state to per-thread state. Prior to this change, if one thread panicked while another was still unwinding, Miri would fail with `thread 'rustc' panicked at 'the panic runtime should avoid double-panics', src/shims/panic.rs:51:9`. I ran into this issue while prototyping a round-robin scheduler, but it's also reachable with the current scheduler and contrived programs that use blocking API calls to cause thread switching during unwinding. I wrote a test case along those lines for this change.", "tree": {"sha": "0177fd3ab4d738b6a8bf2f3cdecc03bf0195152d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0177fd3ab4d738b6a8bf2f3cdecc03bf0195152d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c28a8eeb742d7104bc407e12212c5143439963fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c28a8eeb742d7104bc407e12212c5143439963fc", "html_url": "https://github.com/rust-lang/rust/commit/c28a8eeb742d7104bc407e12212c5143439963fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c28a8eeb742d7104bc407e12212c5143439963fc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a4ecfc22511026c20a3a245b752f80fa2d8ab28", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a4ecfc22511026c20a3a245b752f80fa2d8ab28", "html_url": "https://github.com/rust-lang/rust/commit/0a4ecfc22511026c20a3a245b752f80fa2d8ab28"}, {"sha": "a6746ad893c7f6cbcb367276534e329110e75d83", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6746ad893c7f6cbcb367276534e329110e75d83", "html_url": "https://github.com/rust-lang/rust/commit/a6746ad893c7f6cbcb367276534e329110e75d83"}], "stats": {"total": 202, "additions": 176, "deletions": 26}, "files": [{"sha": "e36a0019cdcb25ff978983c9cb9b1eb9446ad43a", "filename": "src/eval.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c28a8eeb742d7104bc407e12212c5143439963fc/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c28a8eeb742d7104bc407e12212c5143439963fc/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=c28a8eeb742d7104bc407e12212c5143439963fc", "patch": "@@ -193,12 +193,6 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         StackPopCleanup::None { cleanup: true },\n     )?;\n \n-    // Set the last_error to 0\n-    let errno_layout = ecx.machine.layouts.u32;\n-    let errno_place = ecx.allocate(errno_layout, MiriMemoryKind::Machine.into());\n-    ecx.write_scalar(Scalar::from_u32(0), errno_place.into())?;\n-    ecx.machine.last_error = Some(errno_place);\n-\n     Ok((ecx, ret_place))\n }\n "}, {"sha": "39af9d3143aaffeacbeeca5e2e602553ac695780", "filename": "src/helpers.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c28a8eeb742d7104bc407e12212c5143439963fc/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c28a8eeb742d7104bc407e12212c5143439963fc/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=c28a8eeb742d7104bc407e12212c5143439963fc", "patch": "@@ -394,17 +394,33 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         )\n     }\n \n+    /// Get last error variable as a place, lazily allocating thread-local storage for it if\n+    /// necessary.\n+    fn last_error_place(&mut self) -> InterpResult<'tcx, MPlaceTy<'tcx, Tag>> {\n+        let this = self.eval_context_mut();\n+        if let Some(errno_place) = this.active_thread_ref().last_error {\n+            Ok(errno_place)\n+        } else {\n+            // Allocate new place, set initial value to 0.\n+            let errno_layout = this.machine.layouts.u32;\n+            let errno_place = this.allocate(errno_layout, MiriMemoryKind::Machine.into());\n+            this.write_scalar(Scalar::from_u32(0), errno_place.into())?;\n+            this.active_thread_mut().last_error = Some(errno_place);\n+            Ok(errno_place)\n+        }\n+    }\n+\n     /// Sets the last error variable.\n     fn set_last_error(&mut self, scalar: Scalar<Tag>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let errno_place = this.machine.last_error.unwrap();\n+        let errno_place = this.last_error_place()?;\n         this.write_scalar(scalar, errno_place.into())\n     }\n \n     /// Gets the last error variable.\n-    fn get_last_error(&self) -> InterpResult<'tcx, Scalar<Tag>> {\n-        let this = self.eval_context_ref();\n-        let errno_place = this.machine.last_error.unwrap();\n+    fn get_last_error(&mut self) -> InterpResult<'tcx, Scalar<Tag>> {\n+        let this = self.eval_context_mut();\n+        let errno_place = this.last_error_place()?;\n         this.read_scalar(errno_place.into())?.check_init()\n     }\n "}, {"sha": "6defb2d053aa7a701d4da0fcee57136d7929a0eb", "filename": "src/machine.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c28a8eeb742d7104bc407e12212c5143439963fc/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c28a8eeb742d7104bc407e12212c5143439963fc/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=c28a8eeb742d7104bc407e12212c5143439963fc", "patch": "@@ -236,9 +236,6 @@ pub struct Evaluator<'mir, 'tcx> {\n     pub(crate) argv: Option<Scalar<Tag>>,\n     pub(crate) cmd_line: Option<Scalar<Tag>>,\n \n-    /// Last OS error location in memory. It is a 32-bit integer.\n-    pub(crate) last_error: Option<MPlaceTy<'tcx, Tag>>,\n-\n     /// TLS state.\n     pub(crate) tls: TlsData<'tcx>,\n \n@@ -252,11 +249,6 @@ pub struct Evaluator<'mir, 'tcx> {\n     pub(crate) file_handler: shims::posix::FileHandler,\n     pub(crate) dir_handler: shims::posix::DirHandler,\n \n-    /// The temporary used for storing the argument of\n-    /// the call to `miri_start_panic` (the panic payload) when unwinding.\n-    /// This is pointer-sized, and matches the `Payload` type in `src/libpanic_unwind/miri.rs`.\n-    pub(crate) panic_payload: Option<Scalar<Tag>>,\n-\n     /// The \"time anchor\" for this machine's monotone clock (for `Instant` simulation).\n     pub(crate) time_anchor: Instant,\n \n@@ -285,13 +277,11 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n             argc: None,\n             argv: None,\n             cmd_line: None,\n-            last_error: None,\n             tls: TlsData::default(),\n             communicate,\n             validate,\n             file_handler: Default::default(),\n             dir_handler: Default::default(),\n-            panic_payload: None,\n             time_anchor: Instant::now(),\n             layouts,\n             threads: ThreadManager::default(),"}, {"sha": "f907b76b679c485b949fb3ceaecb723ae733a964", "filename": "src/shims/panic.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c28a8eeb742d7104bc407e12212c5143439963fc/src%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c28a8eeb742d7104bc407e12212c5143439963fc/src%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fpanic.rs?ref=c28a8eeb742d7104bc407e12212c5143439963fc", "patch": "@@ -48,11 +48,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // Get the raw pointer stored in arg[0] (the panic payload).\n         let &[payload] = check_arg_count(args)?;\n         let payload = this.read_scalar(payload)?.check_init()?;\n+        let thread = this.active_thread_mut();\n         assert!(\n-            this.machine.panic_payload.is_none(),\n+            thread.panic_payload.is_none(),\n             \"the panic runtime should avoid double-panics\"\n         );\n-        this.machine.panic_payload = Some(payload);\n+        thread.panic_payload = Some(payload);\n \n         // Jump to the unwind block to begin unwinding.\n         this.unwind_to_block(unwind);\n@@ -132,9 +133,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // We set the return value of `try` to 1, since there was a panic.\n             this.write_scalar(Scalar::from_i32(1), catch_unwind.dest)?;\n \n-            // `panic_payload` holds what was passed to `miri_start_panic`.\n+            // The Thread's `panic_payload` holds what was passed to `miri_start_panic`.\n             // This is exactly the second argument we need to pass to `catch_fn`.\n-            let payload = this.machine.panic_payload.take().unwrap();\n+            let payload = this.active_thread_mut().panic_payload.take().unwrap();\n \n             // Push the `catch_fn` stackframe.\n             let f_instance = this.memory.get_fn(catch_unwind.catch_fn)?.as_instance()?;"}, {"sha": "357c55c926f13e31d1f7bc3c71d9801efa8ca2b4", "filename": "src/shims/posix/linux/foreign_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c28a8eeb742d7104bc407e12212c5143439963fc/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c28a8eeb742d7104bc407e12212c5143439963fc/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs?ref=c28a8eeb742d7104bc407e12212c5143439963fc", "patch": "@@ -21,7 +21,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // errno\n             \"__errno_location\" => {\n                 let &[] = check_arg_count(args)?;\n-                let errno_place = this.machine.last_error.unwrap();\n+                let errno_place = this.last_error_place()?;\n                 this.write_scalar(errno_place.to_ref().to_scalar()?, dest)?;\n             }\n "}, {"sha": "72ec7a5d97022e0cd697be4503d9f0b390492972", "filename": "src/shims/posix/macos/foreign_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c28a8eeb742d7104bc407e12212c5143439963fc/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c28a8eeb742d7104bc407e12212c5143439963fc/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fmacos%2Fforeign_items.rs?ref=c28a8eeb742d7104bc407e12212c5143439963fc", "patch": "@@ -20,7 +20,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // errno\n             \"__error\" => {\n                 let &[] = check_arg_count(args)?;\n-                let errno_place = this.machine.last_error.unwrap();\n+                let errno_place = this.last_error_place()?;\n                 this.write_scalar(errno_place.to_ref().to_scalar()?, dest)?;\n             }\n "}, {"sha": "eeaee7dc44d5df283378a4e8cf954b09665f1df7", "filename": "src/thread.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c28a8eeb742d7104bc407e12212c5143439963fc/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c28a8eeb742d7104bc407e12212c5143439963fc/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=c28a8eeb742d7104bc407e12212c5143439963fc", "patch": "@@ -106,12 +106,23 @@ enum ThreadJoinStatus {\n /// A thread.\n pub struct Thread<'mir, 'tcx> {\n     state: ThreadState,\n+\n     /// Name of the thread.\n     thread_name: Option<Vec<u8>>,\n+\n     /// The virtual call stack.\n     stack: Vec<Frame<'mir, 'tcx, Tag, FrameData<'tcx>>>,\n+\n     /// The join status.\n     join_status: ThreadJoinStatus,\n+\n+    /// The temporary used for storing the argument of\n+    /// the call to `miri_start_panic` (the panic payload) when unwinding.\n+    /// This is pointer-sized, and matches the `Payload` type in `src/libpanic_unwind/miri.rs`.\n+    pub(crate) panic_payload: Option<Scalar<Tag>>,\n+\n+    /// Last OS error location in memory. It is a 32-bit integer.\n+    pub(crate) last_error: Option<MPlaceTy<'tcx, Tag>>,\n }\n \n impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n@@ -150,6 +161,8 @@ impl<'mir, 'tcx> Default for Thread<'mir, 'tcx> {\n             thread_name: None,\n             stack: Vec::new(),\n             join_status: ThreadJoinStatus::Joinable,\n+            panic_payload: None,\n+            last_error: None,\n         }\n     }\n }\n@@ -568,6 +581,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.machine.threads.get_active_thread_id()\n     }\n \n+    #[inline]\n+    fn active_thread_mut(&mut self) -> &mut Thread<'mir, 'tcx> {\n+        let this = self.eval_context_mut();\n+        this.machine.threads.active_thread_mut()\n+    }\n+\n+    #[inline]\n+    fn active_thread_ref(&self) -> &Thread<'mir, 'tcx> {\n+        let this = self.eval_context_ref();\n+        this.machine.threads.active_thread_ref()\n+    }\n+\n     #[inline]\n     fn get_total_thread_count(&self) -> usize {\n         let this = self.eval_context_ref();"}, {"sha": "ab9a690fe1d771ffaa08cbee9c71722c5b2e2039", "filename": "tests/run-pass/libc.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c28a8eeb742d7104bc407e12212c5143439963fc/tests%2Frun-pass%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c28a8eeb742d7104bc407e12212c5143439963fc/tests%2Frun-pass%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Flibc.rs?ref=c28a8eeb742d7104bc407e12212c5143439963fc", "patch": "@@ -212,6 +212,24 @@ fn test_prctl_thread_name() {\n     }\n }\n \n+/// Tests whether each thread has its own `__errno_location`.\n+fn test_thread_local_errno() {\n+    #[cfg(not(target_os = \"macos\"))]\n+    use libc::__errno_location;\n+    #[cfg(target_os = \"macos\")]\n+    use libc::__error as __errno_location;\n+\n+    unsafe {\n+        *__errno_location() = 0xBEEF;\n+        std::thread::spawn(|| {\n+            assert_eq!(*__errno_location(), 0);\n+            *__errno_location() = 0xBAD1DEA;\n+            assert_eq!(*__errno_location(), 0xBAD1DEA);\n+        }).join().unwrap();\n+        assert_eq!(*__errno_location(), 0xBEEF);\n+    }\n+}\n+\n fn main() {\n     #[cfg(target_os = \"linux\")]\n     test_posix_fadvise();\n@@ -229,4 +247,6 @@ fn main() {\n \n     #[cfg(target_os = \"linux\")]\n     test_prctl_thread_name();\n+\n+    test_thread_local_errno();\n }"}, {"sha": "2dbfb7721d3683fb4d82c2ce771e3784be86fdc9", "filename": "tests/run-pass/libc.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c28a8eeb742d7104bc407e12212c5143439963fc/tests%2Frun-pass%2Flibc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c28a8eeb742d7104bc407e12212c5143439963fc/tests%2Frun-pass%2Flibc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Flibc.stderr?ref=c28a8eeb742d7104bc407e12212c5143439963fc", "patch": "@@ -0,0 +1,2 @@\n+warning: thread support is experimental. For example, Miri does not detect data races yet.\n+"}, {"sha": "0ff5788e204d1c64020cdb425a1fea17a3b7c451", "filename": "tests/run-pass/panic/concurrent-panic.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/c28a8eeb742d7104bc407e12212c5143439963fc/tests%2Frun-pass%2Fpanic%2Fconcurrent-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c28a8eeb742d7104bc407e12212c5143439963fc/tests%2Frun-pass%2Fpanic%2Fconcurrent-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic%2Fconcurrent-panic.rs?ref=c28a8eeb742d7104bc407e12212c5143439963fc", "patch": "@@ -0,0 +1,91 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+\n+//! Cause a panic in one thread while another thread is unwinding. This checks\n+//! that separate threads have their own panicking state.\n+\n+use std::sync::{Arc, Condvar, Mutex};\n+use std::thread::{spawn, JoinHandle};\n+\n+struct BlockOnDrop(Option<JoinHandle<()>>);\n+\n+impl BlockOnDrop {\n+    fn new(handle: JoinHandle<()>) -> BlockOnDrop {\n+        BlockOnDrop(Some(handle))\n+    }\n+}\n+\n+impl Drop for BlockOnDrop {\n+    fn drop(&mut self) {\n+        eprintln!(\"Thread 2 blocking on thread 1\");\n+        let _ = self.0.take().unwrap().join();\n+        eprintln!(\"Thread 1 has exited\");\n+    }\n+}\n+\n+fn main() {\n+    let t1_started_pair = Arc::new((Mutex::new(false), Condvar::new()));\n+    let t2_started_pair = Arc::new((Mutex::new(false), Condvar::new()));\n+\n+    let t1_continue_mutex = Arc::new(Mutex::new(()));\n+    let t1_continue_guard = t1_continue_mutex.lock();\n+\n+    let t1 = {\n+        let t1_started_pair = t1_started_pair.clone();\n+        let t1_continue_mutex = t1_continue_mutex.clone();\n+        spawn(move || {\n+            eprintln!(\"Thread 1 starting, will block on mutex\");\n+            let (mutex, condvar) = &*t1_started_pair;\n+            *mutex.lock().unwrap() = true;\n+            condvar.notify_one();\n+\n+            drop(t1_continue_mutex.lock());\n+            panic!(\"panic in thread 1\");\n+        })\n+    };\n+\n+    // Wait for thread 1 to signal it has started.\n+    let (t1_started_mutex, t1_started_condvar) = &*t1_started_pair;\n+    let mut t1_started_guard = t1_started_mutex.lock().unwrap();\n+    while !*t1_started_guard {\n+        t1_started_guard = t1_started_condvar.wait(t1_started_guard).unwrap();\n+    }\n+    eprintln!(\"Thread 1 reported it has started\");\n+    // Thread 1 should now be blocked waiting on t1_continue_mutex.\n+\n+    let t2 = {\n+        let t2_started_pair = t2_started_pair.clone();\n+        let block_on_drop = BlockOnDrop::new(t1);\n+        spawn(move || {\n+            let _ = block_on_drop;\n+\n+            let (mutex, condvar) = &*t2_started_pair;\n+            *mutex.lock().unwrap() = true;\n+            condvar.notify_one();\n+\n+            panic!(\"panic in thread 2\");\n+        })\n+    };\n+\n+    // Wait for thread 2 to signal it has started.\n+    let (t2_started_mutex, t2_started_condvar) = &*t2_started_pair;\n+    let mut t2_started_guard = t2_started_mutex.lock().unwrap();\n+    while !*t2_started_guard {\n+        t2_started_guard = t2_started_condvar.wait(t2_started_guard).unwrap();\n+    }\n+    eprintln!(\"Thread 2 reported it has started\");\n+    // Thread 2 should now have already panicked and be in the middle of\n+    // unwinding. It should now be blocked on joining thread 1.\n+\n+    // Unlock t1_continue_mutex, and allow thread 1 to proceed.\n+    eprintln!(\"Unlocking mutex\");\n+    drop(t1_continue_guard);\n+    // Thread 1 will panic the next time it is scheduled. This will test the\n+    // behavior of interest to this test, whether Miri properly handles\n+    // concurrent panics in two different threads.\n+\n+    // Block the main thread on waiting to join thread 2. Thread 2 should\n+    // already be blocked on joining thread 1, so thread 1 will be scheduled\n+    // to run next, as it is the only ready thread.\n+    assert!(t2.join().is_err());\n+    eprintln!(\"Thread 2 has exited\");\n+}"}, {"sha": "d538efdb0e88f61c22cbe835d05ce0c26494767a", "filename": "tests/run-pass/panic/concurrent-panic.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c28a8eeb742d7104bc407e12212c5143439963fc/tests%2Frun-pass%2Fpanic%2Fconcurrent-panic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c28a8eeb742d7104bc407e12212c5143439963fc/tests%2Frun-pass%2Fpanic%2Fconcurrent-panic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic%2Fconcurrent-panic.stderr?ref=c28a8eeb742d7104bc407e12212c5143439963fc", "patch": "@@ -0,0 +1,11 @@\n+warning: thread support is experimental. For example, Miri does not detect data races yet.\n+\n+Thread 1 starting, will block on mutex\n+Thread 1 reported it has started\n+thread '<unnamed>' panicked at 'panic in thread 2', $DIR/concurrent-panic.rs:65:13\n+Thread 2 blocking on thread 1\n+Thread 2 reported it has started\n+Unlocking mutex\n+thread '<unnamed>' panicked at 'panic in thread 1', $DIR/concurrent-panic.rs:42:13\n+Thread 1 has exited\n+Thread 2 has exited"}]}