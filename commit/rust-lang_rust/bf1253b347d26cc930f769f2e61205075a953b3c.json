{"sha": "bf1253b347d26cc930f769f2e61205075a953b3c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmMTI1M2IzNDdkMjZjYzkzMGY3NjlmMmU2MTIwNTA3NWE5NTNiM2M=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-14T14:42:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-14T14:42:40Z"}, "message": "Rollup merge of #64435 - eddyb:arguments-against-arg, r=rkruppe\n\ncodegen: use \"_N\" (like for other locals) instead of \"argN\", for argument names.\n\nBased on #64408 (second commit is new), fixing something I mentioned in #64408 (which turned to be an immediate blocker for unifying relevant codepaths).\n\nCloses #64408 (by containing it).\n\nr? @rkruppe", "tree": {"sha": "7ca2d87f4d963586baf794855d022549433d9b34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ca2d87f4d963586baf794855d022549433d9b34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf1253b347d26cc930f769f2e61205075a953b3c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdfPxhCRBK7hj4Ov3rIwAAdHIIAH26h3XbhuA3LOmvIzlIS7vc\neCiJZuUFtuWicKfErQDHSIanURT213vfy5OosC9YJvRREjmoQTU8QyGooJCmsbo3\n4bGruFTi9NY89QR+Y00uWGwhUK20C8MVQwklkQuXenTE4zrGIraRBq9QyDLc7w+n\nP7j3+UsO2J4SFF2/fy2g2FhLtscqxvxsij3kdYu/TjiIAVP+FhiOjFUgQXF3rj1w\nGhw7hBC5rYkqNGhWrxFWC3ooeNjDTlPBBJ0Rn47mzDNPr1iwQRiX5jK4gLDYBDp7\nerlgS25tI1UZi1YysARAi16GvRwNZyMNZmvjdNMyguPidcxphYXTF0pqyBjhe+4=\n=VBXx\n-----END PGP SIGNATURE-----\n", "payload": "tree 7ca2d87f4d963586baf794855d022549433d9b34\nparent 5160e4bf91845d71195269d4f7f872206361d6ac\nparent bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1568472160 +0200\ncommitter GitHub <noreply@github.com> 1568472160 +0200\n\nRollup merge of #64435 - eddyb:arguments-against-arg, r=rkruppe\n\ncodegen: use \"_N\" (like for other locals) instead of \"argN\", for argument names.\n\nBased on #64408 (second commit is new), fixing something I mentioned in #64408 (which turned to be an immediate blocker for unifying relevant codepaths).\n\nCloses #64408 (by containing it).\n\nr? @rkruppe\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf1253b347d26cc930f769f2e61205075a953b3c", "html_url": "https://github.com/rust-lang/rust/commit/bf1253b347d26cc930f769f2e61205075a953b3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf1253b347d26cc930f769f2e61205075a953b3c/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5160e4bf91845d71195269d4f7f872206361d6ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/5160e4bf91845d71195269d4f7f872206361d6ac", "html_url": "https://github.com/rust-lang/rust/commit/5160e4bf91845d71195269d4f7f872206361d6ac"}, {"sha": "bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f", "html_url": "https://github.com/rust-lang/rust/commit/bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f"}], "stats": {"total": 208, "additions": 98, "deletions": 110}, "files": [{"sha": "2ca517dc3b1a7e8319ece659d0e02c43db65bdf7", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=bf1253b347d26cc930f769f2e61205075a953b3c", "patch": "@@ -229,7 +229,7 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n                 // We instead thus allocate some scratch space...\n                 let scratch_size = cast.size(bx);\n                 let scratch_align = cast.align(bx);\n-                let llscratch = bx.alloca(cast.llvm_type(bx), \"abi_cast\", scratch_align);\n+                let llscratch = bx.alloca(cast.llvm_type(bx), scratch_align);\n                 bx.lifetime_start(llscratch, scratch_size);\n \n                 // ...where we first store the value..."}, {"sha": "423a01ad1f9374a6da0a7f61b914bbe6434f4a86", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=bf1253b347d26cc930f769f2e61205075a953b3c", "patch": "@@ -387,23 +387,17 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         )\n     }\n \n-    fn alloca(&mut self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n+    fn alloca(&mut self, ty: &'ll Type, align: Align) -> &'ll Value {\n         let mut bx = Builder::with_cx(self.cx);\n         bx.position_at_start(unsafe {\n             llvm::LLVMGetFirstBasicBlock(self.llfn())\n         });\n-        bx.dynamic_alloca(ty, name, align)\n+        bx.dynamic_alloca(ty, align)\n     }\n \n-    fn dynamic_alloca(&mut self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n+    fn dynamic_alloca(&mut self, ty: &'ll Type, align: Align) -> &'ll Value {\n         unsafe {\n-            let alloca = if name.is_empty() {\n-                llvm::LLVMBuildAlloca(self.llbuilder, ty, UNNAMED)\n-            } else {\n-                let name = SmallCStr::new(name);\n-                llvm::LLVMBuildAlloca(self.llbuilder, ty,\n-                                      name.as_ptr())\n-            };\n+            let alloca = llvm::LLVMBuildAlloca(self.llbuilder, ty, UNNAMED);\n             llvm::LLVMSetAlignment(alloca, align.bytes() as c_uint);\n             alloca\n         }\n@@ -412,16 +406,9 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn array_alloca(&mut self,\n                         ty: &'ll Type,\n                         len: &'ll Value,\n-                        name: &str,\n                         align: Align) -> &'ll Value {\n         unsafe {\n-            let alloca = if name.is_empty() {\n-                llvm::LLVMBuildArrayAlloca(self.llbuilder, ty, len, UNNAMED)\n-            } else {\n-                let name = SmallCStr::new(name);\n-                llvm::LLVMBuildArrayAlloca(self.llbuilder, ty, len,\n-                                           name.as_ptr())\n-            };\n+            let alloca = llvm::LLVMBuildArrayAlloca(self.llbuilder, ty, len, UNNAMED);\n             llvm::LLVMSetAlignment(alloca, align.bytes() as c_uint);\n             alloca\n         }"}, {"sha": "5fbfe9138f2a46518bdcd2354bf215bde28c1002", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=bf1253b347d26cc930f769f2e61205075a953b3c", "patch": "@@ -871,7 +871,7 @@ fn codegen_msvc_try(\n         // More information can be found in libstd's seh.rs implementation.\n         let i64p = bx.type_ptr_to(bx.type_i64());\n         let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n-        let slot = bx.alloca(i64p, \"slot\", ptr_align);\n+        let slot = bx.alloca(i64p, ptr_align);\n         bx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(), None);\n \n         normal.ret(bx.const_i32(0));"}, {"sha": "8829a33992ae3d3b06a01a9a3a5bbfdf04471d33", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=bf1253b347d26cc930f769f2e61205075a953b3c", "patch": "@@ -276,7 +276,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let llslot = match op.val {\n                     Immediate(_) | Pair(..) => {\n                         let scratch =\n-                            PlaceRef::alloca(&mut bx, self.fn_ty.ret.layout, \"ret\");\n+                            PlaceRef::alloca(&mut bx, self.fn_ty.ret.layout);\n                         op.val.store(&mut bx, scratch);\n                         scratch.llval\n                     }\n@@ -767,7 +767,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             match (arg, op.val) {\n                 (&mir::Operand::Copy(_), Ref(_, None, _)) |\n                 (&mir::Operand::Constant(_), Ref(_, None, _)) => {\n-                    let tmp = PlaceRef::alloca(&mut bx, op.layout, \"const\");\n+                    let tmp = PlaceRef::alloca(&mut bx, op.layout);\n                     op.val.store(&mut bx, tmp);\n                     op.val = Ref(tmp.llval, None, tmp.align);\n                 }\n@@ -925,7 +925,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             Immediate(_) | Pair(..) => {\n                 match arg.mode {\n                     PassMode::Indirect(..) | PassMode::Cast(_) => {\n-                        let scratch = PlaceRef::alloca(bx, arg.layout, \"arg\");\n+                        let scratch = PlaceRef::alloca(bx, arg.layout);\n                         op.val.store(bx, scratch);\n                         (scratch.llval, scratch.align, true)\n                     }\n@@ -940,7 +940,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     // think that ATM (Rust 1.16) we only pass temporaries, but we shouldn't\n                     // have scary latent bugs around.\n \n-                    let scratch = PlaceRef::alloca(bx, arg.layout, \"arg\");\n+                    let scratch = PlaceRef::alloca(bx, arg.layout);\n                     base::memcpy_ty(bx, scratch.llval, scratch.align, llval, align,\n                                     op.layout, MemFlags::empty());\n                     (scratch.llval, scratch.align, true)\n@@ -1017,7 +1017,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 cx.tcx().mk_mut_ptr(cx.tcx().types.u8),\n                 cx.tcx().types.i32\n             ]));\n-            let slot = PlaceRef::alloca(bx, layout, \"personalityslot\");\n+            let slot = PlaceRef::alloca(bx, layout);\n             self.personality_slot = Some(slot);\n             slot\n         }\n@@ -1116,15 +1116,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     return if fn_ret.is_indirect() {\n                         // Odd, but possible, case, we have an operand temporary,\n                         // but the calling convention has an indirect return.\n-                        let tmp = PlaceRef::alloca(bx, fn_ret.layout, \"tmp_ret\");\n+                        let tmp = PlaceRef::alloca(bx, fn_ret.layout);\n                         tmp.storage_live(bx);\n                         llargs.push(tmp.llval);\n                         ReturnDest::IndirectOperand(tmp, index)\n                     } else if is_intrinsic {\n                         // Currently, intrinsics always need a location to store\n                         // the result, so we create a temporary `alloca` for the\n                         // result.\n-                        let tmp = PlaceRef::alloca(bx, fn_ret.layout, \"tmp_ret\");\n+                        let tmp = PlaceRef::alloca(bx, fn_ret.layout);\n                         tmp.storage_live(bx);\n                         ReturnDest::IndirectOperand(tmp, index)\n                     } else {\n@@ -1174,7 +1174,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 LocalRef::Operand(None) => {\n                     let dst_layout = bx.layout_of(self.monomorphized_place_ty(&dst.as_ref()));\n                     assert!(!dst_layout.ty.has_erasable_regions());\n-                    let place = PlaceRef::alloca(bx, dst_layout, \"transmute_temp\");\n+                    let place = PlaceRef::alloca(bx, dst_layout);\n                     place.storage_live(bx);\n                     self.codegen_transmute_into(bx, src, place);\n                     let op = bx.load_operand(place);\n@@ -1227,7 +1227,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             DirectOperand(index) => {\n                 // If there is a cast, we have to store and reload.\n                 let op = if let PassMode::Cast(_) = ret_ty.mode {\n-                    let tmp = PlaceRef::alloca(bx, ret_ty.layout, \"tmp_ret\");\n+                    let tmp = PlaceRef::alloca(bx, ret_ty.layout);\n                     tmp.storage_live(bx);\n                     bx.store_arg_ty(&ret_ty, llval, tmp);\n                     let op = bx.load_operand(tmp);"}, {"sha": "aa3971a1da81aa0f14c5df0e1c4395d73c4eeeed", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=bf1253b347d26cc930f769f2e61205075a953b3c", "patch": "@@ -268,11 +268,13 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 debug!(\"alloc: {:?} ({}) -> place\", local, name);\n                 if layout.is_unsized() {\n                     let indirect_place =\n-                        PlaceRef::alloca_unsized_indirect(&mut bx, layout, &name.as_str());\n+                        PlaceRef::alloca_unsized_indirect(&mut bx, layout);\n+                    bx.set_var_name(indirect_place.llval, name);\n                     // FIXME: add an appropriate debuginfo\n                     LocalRef::UnsizedPlace(indirect_place)\n                 } else {\n-                    let place = PlaceRef::alloca(&mut bx, layout, &name.as_str());\n+                    let place = PlaceRef::alloca(&mut bx, layout);\n+                    bx.set_var_name(place.llval, name);\n                     if dbg {\n                         let (scope, span) = fx.debug_loc(mir::SourceInfo {\n                             span: decl.source_info.span,\n@@ -293,14 +295,13 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 } else if memory_locals.contains(local) {\n                     debug!(\"alloc: {:?} -> place\", local);\n                     if layout.is_unsized() {\n-                        let indirect_place = PlaceRef::alloca_unsized_indirect(\n-                            &mut bx,\n-                            layout,\n-                            &format!(\"{:?}\", local),\n-                        );\n+                        let indirect_place = PlaceRef::alloca_unsized_indirect(&mut bx, layout);\n+                        bx.set_var_name(indirect_place.llval, format_args!(\"{:?}\", local));\n                         LocalRef::UnsizedPlace(indirect_place)\n                     } else {\n-                        LocalRef::Place(PlaceRef::alloca(&mut bx, layout, &format!(\"{:?}\", local)))\n+                        let place = PlaceRef::alloca(&mut bx, layout);\n+                        bx.set_var_name(place.llval, format_args!(\"{:?}\", local));\n+                        LocalRef::Place(place)\n                     }\n                 } else {\n                     // If this is an immediate local, we do not create an\n@@ -452,10 +453,11 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     mir.args_iter().enumerate().map(|(arg_index, local)| {\n         let arg_decl = &mir.local_decls[local];\n \n+        // FIXME(eddyb) don't allocate a `String` unless it gets used.\n         let name = if let Some(name) = arg_decl.name {\n             name.as_str().to_string()\n         } else {\n-            format!(\"arg{}\", arg_index)\n+            format!(\"{:?}\", local)\n         };\n \n         if Some(local) == mir.spread_arg {\n@@ -470,7 +472,8 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 _ => bug!(\"spread argument isn't a tuple?!\")\n             };\n \n-            let place = PlaceRef::alloca(bx, bx.layout_of(arg_ty), &name);\n+            let place = PlaceRef::alloca(bx, bx.layout_of(arg_ty));\n+            bx.set_var_name(place.llval, name);\n             for i in 0..tupled_arg_tys.len() {\n                 let arg = &fx.fn_ty.args[idx];\n                 idx += 1;\n@@ -558,11 +561,13 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             llarg_idx += 1;\n             let indirect_operand = OperandValue::Pair(llarg, llextra);\n \n-            let tmp = PlaceRef::alloca_unsized_indirect(bx, arg.layout, &name);\n+            let tmp = PlaceRef::alloca_unsized_indirect(bx, arg.layout);\n+            bx.set_var_name(tmp.llval, name);\n             indirect_operand.store(bx, tmp);\n             tmp\n         } else {\n-            let tmp = PlaceRef::alloca(bx, arg.layout, &name);\n+            let tmp = PlaceRef::alloca(bx, arg.layout);\n+            bx.set_var_name(tmp.llval, name);\n             if fx.fn_ty.c_variadic && last_arg_idx.map(|idx| arg_index == idx).unwrap_or(false) {\n                 let va_list_did = match tcx.lang_items().va_list() {\n                     Some(did) => did,"}, {"sha": "daa25b2ea0591f572d82853cb20c7c980bf68bdd", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=bf1253b347d26cc930f769f2e61205075a953b3c", "patch": "@@ -367,7 +367,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandValue<V> {\n \n         // Allocate an appropriate region on the stack, and copy the value into it\n         let (llsize, _) = glue::size_and_align_of_dst(bx, unsized_ty, Some(llextra));\n-        let lldst = bx.array_alloca(bx.cx().type_i8(), llsize, \"unsized_tmp\", max_align);\n+        let lldst = bx.array_alloca(bx.cx().type_i8(), llsize, max_align);\n         bx.memcpy(lldst, max_align, llptr, min_align, llsize, flags);\n \n         // Store the allocated region and the extra to the indirect place."}, {"sha": "a4b4cb53bb1fb883c4459e5108fefdaf47c597f5", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=bf1253b347d26cc930f769f2e61205075a953b3c", "patch": "@@ -71,25 +71,21 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     pub fn alloca<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n         layout: TyLayout<'tcx>,\n-        name: &str\n     ) -> Self {\n-        debug!(\"alloca({:?}: {:?})\", name, layout);\n         assert!(!layout.is_unsized(), \"tried to statically allocate unsized place\");\n-        let tmp = bx.alloca(bx.cx().backend_type(layout), name, layout.align.abi);\n+        let tmp = bx.alloca(bx.cx().backend_type(layout), layout.align.abi);\n         Self::new_sized(tmp, layout)\n     }\n \n     /// Returns a place for an indirect reference to an unsized place.\n     pub fn alloca_unsized_indirect<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n         layout: TyLayout<'tcx>,\n-        name: &str,\n     ) -> Self {\n-        debug!(\"alloca_unsized_indirect({:?}: {:?})\", name, layout);\n         assert!(layout.is_unsized(), \"tried to allocate indirect place for sized values\");\n         let ptr_ty = bx.cx().tcx().mk_mut_ptr(layout.ty);\n         let ptr_layout = bx.cx().layout_of(ptr_ty);\n-        Self::alloca(bx, ptr_layout, name)\n+        Self::alloca(bx, ptr_layout)\n     }\n \n     pub fn len<Cx: ConstMethods<'tcx, Value = V>>("}, {"sha": "f21836a953c223ff31c81c57394ad04faeac53cf", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=bf1253b347d26cc930f769f2e61205075a953b3c", "patch": "@@ -64,7 +64,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         // index into the struct, and this case isn't\n                         // important enough for it.\n                         debug!(\"codegen_rvalue: creating ugly alloca\");\n-                        let scratch = PlaceRef::alloca(&mut bx, operand.layout, \"__unsize_temp\");\n+                        let scratch = PlaceRef::alloca(&mut bx, operand.layout);\n                         scratch.storage_live(&mut bx);\n                         operand.val.store(&mut bx, scratch);\n                         base::coerce_unsized_into(&mut bx, scratch, dest);"}, {"sha": "1886701fb3a88d95e1c9d4c274c1afe2f64039b6", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=bf1253b347d26cc930f769f2e61205075a953b3c", "patch": "@@ -109,13 +109,12 @@ pub trait BuilderMethods<'a, 'tcx>:\n         rhs: Self::Value,\n     ) -> (Self::Value, Self::Value);\n \n-    fn alloca(&mut self, ty: Self::Type, name: &str, align: Align) -> Self::Value;\n-    fn dynamic_alloca(&mut self, ty: Self::Type, name: &str, align: Align) -> Self::Value;\n+    fn alloca(&mut self, ty: Self::Type, align: Align) -> Self::Value;\n+    fn dynamic_alloca(&mut self, ty: Self::Type, align: Align) -> Self::Value;\n     fn array_alloca(\n         &mut self,\n         ty: Self::Type,\n         len: Self::Value,\n-        name: &str,\n         align: Align,\n     ) -> Self::Value;\n "}, {"sha": "ded310d0aebb13543cbc9e1da126c3aed7324a67", "filename": "src/test/codegen/adjustments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Ftest%2Fcodegen%2Fadjustments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Ftest%2Fcodegen%2Fadjustments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fadjustments.rs?ref=bf1253b347d26cc930f769f2e61205075a953b3c", "patch": "@@ -3,7 +3,7 @@\n #![crate_type = \"lib\"]\n \n // Hack to get the correct size for the length part in slices\n-// CHECK: @helper([[USIZE:i[0-9]+]] %arg0)\n+// CHECK: @helper([[USIZE:i[0-9]+]] %_1)\n #[no_mangle]\n pub fn helper(_: usize) {\n }"}, {"sha": "f67487c83ba23d2dc83b8ac5b7c90b552e0545e9", "filename": "src/test/codegen/fastcall-inreg.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Ftest%2Fcodegen%2Ffastcall-inreg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Ftest%2Fcodegen%2Ffastcall-inreg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffastcall-inreg.rs?ref=bf1253b347d26cc930f769f2e61205075a953b3c", "patch": "@@ -49,27 +49,27 @@\n #![crate_type = \"lib\"]\n \n pub mod tests {\n-    // CHECK: @f1(i32 inreg %arg0, i32 inreg %arg1, i32 %arg2)\n+    // CHECK: @f1(i32 inreg %_1, i32 inreg %_2, i32 %_3)\n     #[no_mangle]\n     pub extern \"fastcall\" fn f1(_: i32, _: i32, _: i32) {}\n \n-    // CHECK: @f2(i32* inreg %arg0, i32* inreg %arg1, i32* %arg2)\n+    // CHECK: @f2(i32* inreg %_1, i32* inreg %_2, i32* %_3)\n     #[no_mangle]\n     pub extern \"fastcall\" fn f2(_: *const i32, _: *const i32, _: *const i32) {}\n \n-    // CHECK: @f3(float %arg0, i32 inreg %arg1, i32 inreg %arg2, i32 %arg3)\n+    // CHECK: @f3(float %_1, i32 inreg %_2, i32 inreg %_3, i32 %_4)\n     #[no_mangle]\n     pub extern \"fastcall\" fn f3(_: f32, _: i32, _: i32, _: i32) {}\n \n-    // CHECK: @f4(i32 inreg %arg0, float %arg1, i32 inreg %arg2, i32 %arg3)\n+    // CHECK: @f4(i32 inreg %_1, float %_2, i32 inreg %_3, i32 %_4)\n     #[no_mangle]\n     pub extern \"fastcall\" fn f4(_: i32, _: f32, _: i32, _: i32) {}\n \n-    // CHECK: @f5(i64 %arg0, i32 %arg1)\n+    // CHECK: @f5(i64 %_1, i32 %_2)\n     #[no_mangle]\n     pub extern \"fastcall\" fn f5(_: i64, _: i32) {}\n \n-    // CHECK: @f6(i1 inreg zeroext %arg0, i32 inreg %arg1, i32 %arg2)\n+    // CHECK: @f6(i1 inreg zeroext %_1, i32 inreg %_2, i32 %_3)\n     #[no_mangle]\n     pub extern \"fastcall\" fn f6(_: bool, _: i32, _: i32) {}\n }"}, {"sha": "7e1791cd4f296f5c3ace1b66e5736c6ceaa5f9d4", "filename": "src/test/codegen/function-arguments.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs?ref=bf1253b347d26cc930f769f2e61205075a953b3c", "patch": "@@ -18,48 +18,48 @@ pub fn boolean(x: bool) -> bool {\n   x\n }\n \n-// CHECK: @readonly_borrow(i32* noalias readonly align 4 dereferenceable(4) %arg0)\n+// CHECK: @readonly_borrow(i32* noalias readonly align 4 dereferenceable(4) %_1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn readonly_borrow(_: &i32) {\n }\n \n-// CHECK: @static_borrow(i32* noalias readonly align 4 dereferenceable(4) %arg0)\n+// CHECK: @static_borrow(i32* noalias readonly align 4 dereferenceable(4) %_1)\n // static borrow may be captured\n #[no_mangle]\n pub fn static_borrow(_: &'static i32) {\n }\n \n-// CHECK: @named_borrow(i32* noalias readonly align 4 dereferenceable(4) %arg0)\n+// CHECK: @named_borrow(i32* noalias readonly align 4 dereferenceable(4) %_1)\n // borrow with named lifetime may be captured\n #[no_mangle]\n pub fn named_borrow<'r>(_: &'r i32) {\n }\n \n-// CHECK: @unsafe_borrow(i16* align 2 dereferenceable(2) %arg0)\n+// CHECK: @unsafe_borrow(i16* align 2 dereferenceable(2) %_1)\n // unsafe interior means this isn't actually readonly and there may be aliases ...\n #[no_mangle]\n pub fn unsafe_borrow(_: &UnsafeInner) {\n }\n \n-// CHECK: @mutable_unsafe_borrow(i16* align 2 dereferenceable(2) %arg0)\n+// CHECK: @mutable_unsafe_borrow(i16* align 2 dereferenceable(2) %_1)\n // ... unless this is a mutable borrow, those never alias\n #[no_mangle]\n pub fn mutable_unsafe_borrow(_: &mut UnsafeInner) {\n }\n \n-// CHECK: @mutable_borrow(i32* align 4 dereferenceable(4) %arg0)\n+// CHECK: @mutable_borrow(i32* align 4 dereferenceable(4) %_1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn mutable_borrow(_: &mut i32) {\n }\n \n-// CHECK: @indirect_struct(%S* noalias nocapture dereferenceable(32) %arg0)\n+// CHECK: @indirect_struct(%S* noalias nocapture dereferenceable(32) %_1)\n #[no_mangle]\n pub fn indirect_struct(_: S) {\n }\n \n-// CHECK: @borrowed_struct(%S* noalias readonly align 4 dereferenceable(32) %arg0)\n+// CHECK: @borrowed_struct(%S* noalias readonly align 4 dereferenceable(32) %_1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn borrowed_struct(_: &S) {\n@@ -80,36 +80,36 @@ pub fn struct_return() -> S {\n }\n \n // Hack to get the correct size for the length part in slices\n-// CHECK: @helper([[USIZE:i[0-9]+]] %arg0)\n+// CHECK: @helper([[USIZE:i[0-9]+]] %_1)\n #[no_mangle]\n pub fn helper(_: usize) {\n }\n \n-// CHECK: @slice([0 x i8]* noalias nonnull readonly align 1 %arg0.0, [[USIZE]] %arg0.1)\n+// CHECK: @slice([0 x i8]* noalias nonnull readonly align 1 %_1.0, [[USIZE]] %_1.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn slice(_: &[u8]) {\n }\n \n-// CHECK: @mutable_slice([0 x i8]* nonnull align 1 %arg0.0, [[USIZE]] %arg0.1)\n+// CHECK: @mutable_slice([0 x i8]* nonnull align 1 %_1.0, [[USIZE]] %_1.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn mutable_slice(_: &mut [u8]) {\n }\n \n-// CHECK: @unsafe_slice([0 x i16]* nonnull align 2 %arg0.0, [[USIZE]] %arg0.1)\n+// CHECK: @unsafe_slice([0 x i16]* nonnull align 2 %_1.0, [[USIZE]] %_1.1)\n // unsafe interior means this isn't actually readonly and there may be aliases ...\n #[no_mangle]\n pub fn unsafe_slice(_: &[UnsafeInner]) {\n }\n \n-// CHECK: @str([0 x i8]* noalias nonnull readonly align 1 %arg0.0, [[USIZE]] %arg0.1)\n+// CHECK: @str([0 x i8]* noalias nonnull readonly align 1 %_1.0, [[USIZE]] %_1.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn str(_: &[u8]) {\n }\n \n-// CHECK: @trait_borrow({}* nonnull align 1 %arg0.0, [3 x [[USIZE]]]* noalias readonly align {{.*}} dereferenceable({{.*}}) %arg0.1)\n+// CHECK: @trait_borrow({}* nonnull align 1 %_1.0, [3 x [[USIZE]]]* noalias readonly align {{.*}} dereferenceable({{.*}}) %_1.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn trait_borrow(_: &Drop) {"}, {"sha": "05888c0e733ad10bbcb52a7a40a238d9e29c319c", "filename": "src/test/codegen/personality_lifetimes.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Ftest%2Fcodegen%2Fpersonality_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Ftest%2Fcodegen%2Fpersonality_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fpersonality_lifetimes.rs?ref=bf1253b347d26cc930f769f2e61205075a953b3c", "patch": "@@ -20,12 +20,13 @@ pub fn test() {\n     let _s = S;\n     // Check that the personality slot alloca gets a lifetime start in each cleanup block, not just\n     // in the first one.\n+    // CHECK: [[SLOT:%[0-9]+]] = alloca { i8*, i32 }\n     // CHECK-LABEL: cleanup:\n-    // CHECK: bitcast{{.*}}personalityslot\n-    // CHECK-NEXT: call void @llvm.lifetime.start\n+    // CHECK: [[BITCAST:%[0-9]+]] = bitcast { i8*, i32 }* [[SLOT]] to i8*\n+    // CHECK-NEXT: call void @llvm.lifetime.start.{{.*}}({{.*}}, i8* [[BITCAST]])\n     // CHECK-LABEL: cleanup1:\n-    // CHECK: bitcast{{.*}}personalityslot\n-    // CHECK-NEXT: call void @llvm.lifetime.start\n+    // CHECK: [[BITCAST1:%[0-9]+]] = bitcast { i8*, i32 }* [[SLOT]] to i8*\n+    // CHECK-NEXT: call void @llvm.lifetime.start.{{.*}}({{.*}}, i8* [[BITCAST1]])\n     might_unwind();\n     let _t = S;\n     might_unwind();"}, {"sha": "15f99fd0c22a023094251b5f4511dfb0fb07d149", "filename": "src/test/codegen/refs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Ftest%2Fcodegen%2Frefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Ftest%2Fcodegen%2Frefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frefs.rs?ref=bf1253b347d26cc930f769f2e61205075a953b3c", "patch": "@@ -3,7 +3,7 @@\n #![crate_type = \"lib\"]\n \n // Hack to get the correct size for the length part in slices\n-// CHECK: @helper([[USIZE:i[0-9]+]] %arg0)\n+// CHECK: @helper([[USIZE:i[0-9]+]] %_1)\n #[no_mangle]\n pub fn helper(_: usize) {\n }"}, {"sha": "87f29f6047c6a0af8932ad2887a7d343268fa007", "filename": "src/test/codegen/repeat-trusted-len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Ftest%2Fcodegen%2Frepeat-trusted-len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Ftest%2Fcodegen%2Frepeat-trusted-len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frepeat-trusted-len.rs?ref=bf1253b347d26cc930f769f2e61205075a953b3c", "patch": "@@ -6,7 +6,7 @@\n \n use std::iter;\n \n-// CHECK: @helper([[USIZE:i[0-9]+]] %arg0)\n+// CHECK: @helper([[USIZE:i[0-9]+]] %_1)\n #[no_mangle]\n pub fn helper(_: usize) {\n }"}, {"sha": "e705d5ce3cd72d87acb2e385ba44f9beb3ffe048", "filename": "src/test/codegen/repr-transparent.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Ftest%2Fcodegen%2Frepr-transparent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Ftest%2Fcodegen%2Frepr-transparent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frepr-transparent.rs?ref=bf1253b347d26cc930f769f2e61205075a953b3c", "patch": "@@ -14,36 +14,36 @@ pub struct Zst2(());\n #[repr(transparent)]\n pub struct F32(f32);\n \n-// CHECK: define float @test_F32(float %arg0)\n+// CHECK: define float @test_F32(float %_1)\n #[no_mangle]\n pub extern fn test_F32(_: F32) -> F32 { loop {} }\n \n #[repr(transparent)]\n pub struct Ptr(*mut u8);\n \n-// CHECK: define i8* @test_Ptr(i8* %arg0)\n+// CHECK: define i8* @test_Ptr(i8* %_1)\n #[no_mangle]\n pub extern fn test_Ptr(_: Ptr) -> Ptr { loop {} }\n \n #[repr(transparent)]\n pub struct WithZst(u64, Zst1);\n \n-// CHECK: define i64 @test_WithZst(i64 %arg0)\n+// CHECK: define i64 @test_WithZst(i64 %_1)\n #[no_mangle]\n pub extern fn test_WithZst(_: WithZst) -> WithZst { loop {} }\n \n #[repr(transparent)]\n pub struct WithZeroSizedArray(*const f32, [i8; 0]);\n \n // Apparently we use i32* when newtype-unwrapping f32 pointers. Whatever.\n-// CHECK: define i32* @test_WithZeroSizedArray(i32* %arg0)\n+// CHECK: define i32* @test_WithZeroSizedArray(i32* %_1)\n #[no_mangle]\n pub extern fn test_WithZeroSizedArray(_: WithZeroSizedArray) -> WithZeroSizedArray { loop {} }\n \n #[repr(transparent)]\n pub struct Generic<T>(T);\n \n-// CHECK: define double @test_Generic(double %arg0)\n+// CHECK: define double @test_Generic(double %_1)\n #[no_mangle]\n pub extern fn test_Generic(_: Generic<f64>) -> Generic<f64> { loop {} }\n \n@@ -53,14 +53,14 @@ pub struct GenericPlusZst<T>(T, Zst2);\n #[repr(u8)]\n pub enum Bool { True, False, FileNotFound }\n \n-// CHECK: define{{( zeroext)?}} i8 @test_Gpz(i8{{( zeroext)?}} %arg0)\n+// CHECK: define{{( zeroext)?}} i8 @test_Gpz(i8{{( zeroext)?}} %_1)\n #[no_mangle]\n pub extern fn test_Gpz(_: GenericPlusZst<Bool>) -> GenericPlusZst<Bool> { loop {} }\n \n #[repr(transparent)]\n pub struct LifetimePhantom<'a, T: 'a>(*const T, PhantomData<&'a T>);\n \n-// CHECK: define i16* @test_LifetimePhantom(i16* %arg0)\n+// CHECK: define i16* @test_LifetimePhantom(i16* %_1)\n #[no_mangle]\n pub extern fn test_LifetimePhantom(_: LifetimePhantom<i16>) -> LifetimePhantom<i16> { loop {} }\n \n@@ -70,28 +70,28 @@ pub struct UnitPhantom<T, U> { val: T, unit: PhantomData<U> }\n \n pub struct Px;\n \n-// CHECK: define float @test_UnitPhantom(float %arg0)\n+// CHECK: define float @test_UnitPhantom(float %_1)\n #[no_mangle]\n pub extern fn test_UnitPhantom(_: UnitPhantom<f32, Px>) -> UnitPhantom<f32, Px> { loop {} }\n \n #[repr(transparent)]\n pub struct TwoZsts(Zst1, i8, Zst2);\n \n-// CHECK: define{{( signext)?}} i8 @test_TwoZsts(i8{{( signext)?}} %arg0)\n+// CHECK: define{{( signext)?}} i8 @test_TwoZsts(i8{{( signext)?}} %_1)\n #[no_mangle]\n pub extern fn test_TwoZsts(_: TwoZsts) -> TwoZsts { loop {} }\n \n #[repr(transparent)]\n pub struct Nested1(Zst2, Generic<f64>);\n \n-// CHECK: define double @test_Nested1(double %arg0)\n+// CHECK: define double @test_Nested1(double %_1)\n #[no_mangle]\n pub extern fn test_Nested1(_: Nested1) -> Nested1 { loop {} }\n \n #[repr(transparent)]\n pub struct Nested2(Nested1, Zst1);\n \n-// CHECK: define double @test_Nested2(double %arg0)\n+// CHECK: define double @test_Nested2(double %_1)\n #[no_mangle]\n pub extern fn test_Nested2(_: Nested2) -> Nested2 { loop {} }\n \n@@ -101,7 +101,7 @@ struct f32x4(f32, f32, f32, f32);\n #[repr(transparent)]\n pub struct Vector(f32x4);\n \n-// CHECK: define <4 x float> @test_Vector(<4 x float> %arg0)\n+// CHECK: define <4 x float> @test_Vector(<4 x float> %_1)\n #[no_mangle]\n pub extern fn test_Vector(_: Vector) -> Vector { loop {} }\n \n@@ -111,7 +111,7 @@ impl<T: ?Sized> Mirror for T { type It = Self; }\n #[repr(transparent)]\n pub struct StructWithProjection(<f32 as Mirror>::It);\n \n-// CHECK: define float @test_Projection(float %arg0)\n+// CHECK: define float @test_Projection(float %_1)\n #[no_mangle]\n pub extern fn test_Projection(_: StructWithProjection) -> StructWithProjection { loop {} }\n \n@@ -120,7 +120,7 @@ pub enum EnumF32 {\n     Variant(F32)\n }\n \n-// CHECK: define float @test_EnumF32(float %arg0)\n+// CHECK: define float @test_EnumF32(float %_1)\n #[no_mangle]\n pub extern fn test_EnumF32(_: EnumF32) -> EnumF32 { loop {} }\n \n@@ -129,7 +129,7 @@ pub enum EnumF32WithZsts {\n     Variant(Zst1, F32, Zst2)\n }\n \n-// CHECK: define float @test_EnumF32WithZsts(float %arg0)\n+// CHECK: define float @test_EnumF32WithZsts(float %_1)\n #[no_mangle]\n pub extern fn test_EnumF32WithZsts(_: EnumF32WithZsts) -> EnumF32WithZsts { loop {} }\n \n@@ -138,7 +138,7 @@ pub union UnionF32 {\n     field: F32,\n }\n \n-// CHECK: define float @test_UnionF32(float %arg0)\n+// CHECK: define float @test_UnionF32(float %_1)\n #[no_mangle]\n pub extern fn test_UnionF32(_: UnionF32) -> UnionF32 { loop {} }\n \n@@ -149,7 +149,7 @@ pub union UnionF32WithZsts {\n     zst2: Zst2,\n }\n \n-// CHECK: define float @test_UnionF32WithZsts(float %arg0)\n+// CHECK: define float @test_UnionF32WithZsts(float %_1)\n #[no_mangle]\n pub extern fn test_UnionF32WithZsts(_: UnionF32WithZsts) -> UnionF32WithZsts { loop {} }\n "}, {"sha": "d91ee7f816dede3620fc035ff1d2bbbe9c56e2cd", "filename": "src/test/codegen/scalar-pair-bool.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Ftest%2Fcodegen%2Fscalar-pair-bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Ftest%2Fcodegen%2Fscalar-pair-bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fscalar-pair-bool.rs?ref=bf1253b347d26cc930f769f2e61205075a953b3c", "patch": "@@ -20,24 +20,24 @@ pub fn pair_i32_bool(pair: (i32, bool)) -> (i32, bool) {\n     pair\n }\n \n-// CHECK: define { i8, i8 } @pair_and_or(i1 zeroext %arg0.0, i1 zeroext %arg0.1)\n+// CHECK: define { i8, i8 } @pair_and_or(i1 zeroext %_1.0, i1 zeroext %_1.1)\n #[no_mangle]\n pub fn pair_and_or((a, b): (bool, bool)) -> (bool, bool) {\n     // Make sure it can operate directly on the unpacked args\n-    // CHECK: and i1 %arg0.0, %arg0.1\n-    // CHECK: or i1 %arg0.0, %arg0.1\n+    // CHECK: and i1 %_1.0, %_1.1\n+    // CHECK: or i1 %_1.0, %_1.1\n     (a && b, a || b)\n }\n \n-// CHECK: define void @pair_branches(i1 zeroext %arg0.0, i1 zeroext %arg0.1)\n+// CHECK: define void @pair_branches(i1 zeroext %_1.0, i1 zeroext %_1.1)\n #[no_mangle]\n pub fn pair_branches((a, b): (bool, bool)) {\n     // Make sure it can branch directly on the unpacked bool args\n-    // CHECK: br i1 %arg0.0\n+    // CHECK: br i1 %_1.0\n     if a {\n         println!(\"Hello!\");\n     }\n-    // CHECK: br i1 %arg0.1\n+    // CHECK: br i1 %_1.1\n     if b {\n         println!(\"Goodbye!\");\n     }"}, {"sha": "7339df17b057a230004e2eb3fbc703fc534ce668", "filename": "src/test/codegen/union-abi.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Ftest%2Fcodegen%2Funion-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1253b347d26cc930f769f2e61205075a953b3c/src%2Ftest%2Fcodegen%2Funion-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funion-abi.rs?ref=bf1253b347d26cc930f769f2e61205075a953b3c", "patch": "@@ -16,38 +16,38 @@ pub struct i64x4(i64, i64, i64, i64);\n #[derive(Copy, Clone)]\n pub union UnionI64x4{ a:(), b: i64x4 }\n \n-// CHECK: define void @test_UnionI64x4(<4 x i64>* {{.*}} %arg0)\n+// CHECK: define void @test_UnionI64x4(<4 x i64>* {{.*}} %_1)\n #[no_mangle]\n pub fn test_UnionI64x4(_: UnionI64x4) { loop {} }\n \n pub union UnionI64x4_{ a: i64x4, b: (), c:i64x4, d: Unhab, e: ((),()), f: UnionI64x4 }\n \n-// CHECK: define void @test_UnionI64x4_(<4 x i64>* {{.*}} %arg0)\n+// CHECK: define void @test_UnionI64x4_(<4 x i64>* {{.*}} %_1)\n #[no_mangle]\n pub fn test_UnionI64x4_(_: UnionI64x4_) { loop {} }\n \n pub union UnionI64x4I64{ a: i64x4, b: i64 }\n \n-// CHECK: define void @test_UnionI64x4I64(%UnionI64x4I64* {{.*}} %arg0)\n+// CHECK: define void @test_UnionI64x4I64(%UnionI64x4I64* {{.*}} %_1)\n #[no_mangle]\n pub fn test_UnionI64x4I64(_: UnionI64x4I64) { loop {} }\n \n pub union UnionI64x4Tuple{ a: i64x4, b: (i64, i64, i64, i64) }\n \n-// CHECK: define void @test_UnionI64x4Tuple(%UnionI64x4Tuple* {{.*}} %arg0)\n+// CHECK: define void @test_UnionI64x4Tuple(%UnionI64x4Tuple* {{.*}} %_1)\n #[no_mangle]\n pub fn test_UnionI64x4Tuple(_: UnionI64x4Tuple) { loop {} }\n \n \n pub union UnionF32{a:f32}\n \n-// CHECK: define float @test_UnionF32(float %arg0)\n+// CHECK: define float @test_UnionF32(float %_1)\n #[no_mangle]\n pub fn test_UnionF32(_: UnionF32) -> UnionF32 { loop {} }\n \n pub union UnionF32F32{a:f32, b:f32}\n \n-// CHECK: define float @test_UnionF32F32(float %arg0)\n+// CHECK: define float @test_UnionF32F32(float %_1)\n #[no_mangle]\n pub fn test_UnionF32F32(_: UnionF32F32) -> UnionF32F32 { loop {} }\n \n@@ -58,13 +58,13 @@ pub union UnionF32U32{a:f32, b:u32}\n pub fn test_UnionF32U32(_: UnionF32U32) -> UnionF32U32 { loop {} }\n \n pub union UnionU128{a:u128}\n-// CHECK: define i128 @test_UnionU128(i128 %arg0)\n+// CHECK: define i128 @test_UnionU128(i128 %_1)\n #[no_mangle]\n pub fn test_UnionU128(_: UnionU128) -> UnionU128 { loop {} }\n \n #[repr(C)]\n pub union CUnionU128{a:u128}\n-// CHECK: define void @test_CUnionU128(%CUnionU128* {{.*}} %arg0)\n+// CHECK: define void @test_CUnionU128(%CUnionU128* {{.*}} %_1)\n #[no_mangle]\n pub fn test_CUnionU128(_: CUnionU128) { loop {} }\n "}]}