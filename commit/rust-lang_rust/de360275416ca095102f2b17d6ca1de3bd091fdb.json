{"sha": "de360275416ca095102f2b17d6ca1de3bd091fdb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlMzYwMjc1NDE2Y2EwOTUxMDJmMmIxN2Q2Y2ExZGUzYmQwOTFmZGI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-15T01:23:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-15T01:23:29Z"}, "message": "Merge #7966\n\n7966: Diagnose files that aren't in the module tree r=jonas-schievink a=jonas-schievink\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/6377\r\n\r\nI'm not sure if this is the best way to do this. It will cause false positives for all `include!`d files (though I'm not sure how much IDE functionality we have for these).\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "319752b9ec07b075941aeab8795242f3a92ec2c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/319752b9ec07b075941aeab8795242f3a92ec2c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de360275416ca095102f2b17d6ca1de3bd091fdb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgTrcRCRBK7hj4Ov3rIwAAdHIIAD+XLOXYH5mFcLcS3CoEKDLv\nE3WRXc6h0w42sKnFl09l161m3WOoLByEBpg5KThdogFSBTRN5pKJm8D1/x1tyDbF\nzJJ/ajLO2xAJyx9tjzERqDOxjvGGkvu0CCX+lZ4sJFDAC9Vb2QlRgG+OQcO+UMgj\nE8zW1R1PHgnob/We3dmgkmaPqsSOmbck+4ujEh4ri/Djts6eh5xWE1j7RxXlSbnk\naRDkVqMTjMUEsKGjuFT0gWC+TmGV33jjEXxx/WBgk1qP0Zi3gKSs1oOJ3g+SzCNh\nOeqxIYXWCjpB4jRcUokCKWtroXKImHsbIdJ0vwTJeLFOkZ5dBi/Tfi6W9C0SfPQ=\n=iy8j\n-----END PGP SIGNATURE-----\n", "payload": "tree 319752b9ec07b075941aeab8795242f3a92ec2c0\nparent 5ba7852cf153688d5b5035a9a2a2145aa7334d79\nparent 32e1ca54eac6b5d401c2f33ec1281794ef9a0a52\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1615771409 +0000\ncommitter GitHub <noreply@github.com> 1615771409 +0000\n\nMerge #7966\n\n7966: Diagnose files that aren't in the module tree r=jonas-schievink a=jonas-schievink\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/6377\r\n\r\nI'm not sure if this is the best way to do this. It will cause false positives for all `include!`d files (though I'm not sure how much IDE functionality we have for these).\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de360275416ca095102f2b17d6ca1de3bd091fdb", "html_url": "https://github.com/rust-lang/rust/commit/de360275416ca095102f2b17d6ca1de3bd091fdb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de360275416ca095102f2b17d6ca1de3bd091fdb/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ba7852cf153688d5b5035a9a2a2145aa7334d79", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ba7852cf153688d5b5035a9a2a2145aa7334d79", "html_url": "https://github.com/rust-lang/rust/commit/5ba7852cf153688d5b5035a9a2a2145aa7334d79"}, {"sha": "32e1ca54eac6b5d401c2f33ec1281794ef9a0a52", "url": "https://api.github.com/repos/rust-lang/rust/commits/32e1ca54eac6b5d401c2f33ec1281794ef9a0a52", "html_url": "https://github.com/rust-lang/rust/commit/32e1ca54eac6b5d401c2f33ec1281794ef9a0a52"}], "stats": {"total": 320, "additions": 317, "deletions": 3}, "files": [{"sha": "6ae7c9e6cc4edf531ab3f9c8a3cc21867c783c9d", "filename": "crates/ide/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/de360275416ca095102f2b17d6ca1de3bd091fdb/crates%2Fide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/de360275416ca095102f2b17d6ca1de3bd091fdb/crates%2Fide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2FCargo.toml?ref=de360275416ca095102f2b17d6ca1de3bd091fdb", "patch": "@@ -38,3 +38,4 @@ hir = { path = \"../hir\", version = \"0.0.0\" }\n [dev-dependencies]\n test_utils = { path = \"../test_utils\" }\n expect-test = \"1.1\"\n+cov-mark = \"1.1.0\""}, {"sha": "22697a5374a317a98a00bb015e52293eb0c62b2a", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 160, "deletions": 3, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/de360275416ca095102f2b17d6ca1de3bd091fdb/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de360275416ca095102f2b17d6ca1de3bd091fdb/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=de360275416ca095102f2b17d6ca1de3bd091fdb", "patch": "@@ -6,6 +6,7 @@\n \n mod fixes;\n mod field_shorthand;\n+mod unlinked_file;\n \n use std::cell::RefCell;\n \n@@ -22,6 +23,7 @@ use syntax::{\n     SyntaxNode, SyntaxNodePtr, TextRange,\n };\n use text_edit::TextEdit;\n+use unlinked_file::UnlinkedFile;\n \n use crate::{FileId, Label, SourceChange};\n \n@@ -156,6 +158,18 @@ pub(crate) fn diagnostics(\n                 .with_code(Some(d.code())),\n             );\n         })\n+        .on::<UnlinkedFile, _>(|d| {\n+            // Override severity and mark as unused.\n+            res.borrow_mut().push(\n+                Diagnostic::hint(\n+                    sema.diagnostics_display_range(d.display_source()).range,\n+                    d.message(),\n+                )\n+                .with_unused(true)\n+                .with_fix(d.fix(&sema))\n+                .with_code(Some(d.code())),\n+            );\n+        })\n         .on::<hir::diagnostics::UnresolvedProcMacro, _>(|d| {\n             // Use more accurate position if available.\n             let display_range = d\n@@ -197,9 +211,13 @@ pub(crate) fn diagnostics(\n             );\n         });\n \n-    if let Some(m) = sema.to_module_def(file_id) {\n-        m.diagnostics(db, &mut sink);\n-    };\n+    match sema.to_module_def(file_id) {\n+        Some(m) => m.diagnostics(db, &mut sink),\n+        None => {\n+            sink.push(UnlinkedFile { file_id, node: SyntaxNodePtr::new(&parse.tree().syntax()) });\n+        }\n+    }\n+\n     drop(sink);\n     res.into_inner()\n }\n@@ -307,6 +325,17 @@ mod tests {\n         );\n     }\n \n+    /// Checks that there's a diagnostic *without* fix at `$0`.\n+    fn check_no_fix(ra_fixture: &str) {\n+        let (analysis, file_position) = fixture::position(ra_fixture);\n+        let diagnostic = analysis\n+            .diagnostics(&DiagnosticsConfig::default(), file_position.file_id)\n+            .unwrap()\n+            .pop()\n+            .unwrap();\n+        assert!(diagnostic.fix.is_none(), \"got a fix when none was expected: {:?}\", diagnostic);\n+    }\n+\n     /// Takes a multi-file input fixture with annotated cursor position and checks that no diagnostics\n     /// apply to the file containing the cursor.\n     pub(crate) fn check_no_diagnostics(ra_fixture: &str) {\n@@ -975,4 +1004,132 @@ impl TestStruct {\n \n         check_fix(input, expected);\n     }\n+\n+    #[test]\n+    fn unlinked_file_prepend_first_item() {\n+        cov_mark::check!(unlinked_file_prepend_before_first_item);\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+fn f() {}\n+//- /foo.rs\n+$0\n+\"#,\n+            r#\"\n+mod foo;\n+\n+fn f() {}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_append_mod() {\n+        cov_mark::check!(unlinked_file_append_to_existing_mods);\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+//! Comment on top\n+\n+mod preexisting;\n+\n+mod preexisting2;\n+\n+struct S;\n+\n+mod preexisting_bottom;)\n+//- /foo.rs\n+$0\n+\"#,\n+            r#\"\n+//! Comment on top\n+\n+mod preexisting;\n+\n+mod preexisting2;\n+mod foo;\n+\n+struct S;\n+\n+mod preexisting_bottom;)\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_insert_in_empty_file() {\n+        cov_mark::check!(unlinked_file_empty_file);\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+//- /foo.rs\n+$0\n+\"#,\n+            r#\"\n+mod foo;\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_old_style_modrs() {\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+mod submod;\n+//- /submod/mod.rs\n+// in mod.rs\n+//- /submod/foo.rs\n+$0\n+\"#,\n+            r#\"\n+// in mod.rs\n+mod foo;\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_new_style_mod() {\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+mod submod;\n+//- /submod.rs\n+//- /submod/foo.rs\n+$0\n+\"#,\n+            r#\"\n+mod foo;\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_with_cfg_off() {\n+        cov_mark::check!(unlinked_file_skip_fix_when_mod_already_exists);\n+        check_no_fix(\n+            r#\"\n+//- /main.rs\n+#[cfg(never)]\n+mod foo;\n+\n+//- /foo.rs\n+$0\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unlinked_file_with_cfg_on() {\n+        check_no_diagnostics(\n+            r#\"\n+//- /main.rs\n+#[cfg(not(never))]\n+mod foo;\n+\n+//- /foo.rs\n+\"#,\n+        );\n+    }\n }"}, {"sha": "c5741bf6bf3232b011f8a3f18133ff6eba92e475", "filename": "crates/ide/src/diagnostics/unlinked_file.rs", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/de360275416ca095102f2b17d6ca1de3bd091fdb/crates%2Fide%2Fsrc%2Fdiagnostics%2Funlinked_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de360275416ca095102f2b17d6ca1de3bd091fdb/crates%2Fide%2Fsrc%2Fdiagnostics%2Funlinked_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Funlinked_file.rs?ref=de360275416ca095102f2b17d6ca1de3bd091fdb", "patch": "@@ -0,0 +1,156 @@\n+//! Diagnostic emitted for files that aren't part of any crate.\n+\n+use hir::{\n+    db::DefDatabase,\n+    diagnostics::{Diagnostic, DiagnosticCode},\n+    InFile,\n+};\n+use ide_db::{\n+    base_db::{FileId, FileLoader, SourceDatabase, SourceDatabaseExt},\n+    source_change::SourceChange,\n+    RootDatabase,\n+};\n+use syntax::{\n+    ast::{self, ModuleItemOwner, NameOwner},\n+    AstNode, SyntaxNodePtr,\n+};\n+use text_edit::TextEdit;\n+\n+use crate::Fix;\n+\n+use super::fixes::DiagnosticWithFix;\n+\n+#[derive(Debug)]\n+pub(crate) struct UnlinkedFile {\n+    pub(crate) file_id: FileId,\n+    pub(crate) node: SyntaxNodePtr,\n+}\n+\n+impl Diagnostic for UnlinkedFile {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"unlinked-file\")\n+    }\n+\n+    fn message(&self) -> String {\n+        \"file not included in module tree\".to_string()\n+    }\n+\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile::new(self.file_id.into(), self.node.clone())\n+    }\n+\n+    fn as_any(&self) -> &(dyn std::any::Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+impl DiagnosticWithFix for UnlinkedFile {\n+    fn fix(&self, sema: &hir::Semantics<RootDatabase>) -> Option<Fix> {\n+        // If there's an existing module that could add a `mod` item to include the unlinked file,\n+        // suggest that as a fix.\n+\n+        let source_root = sema.db.source_root(sema.db.file_source_root(self.file_id));\n+        let our_path = source_root.path_for_file(&self.file_id)?;\n+        let module_name = our_path.name_and_extension()?.0;\n+\n+        // Candidates to look for:\n+        // - `mod.rs` in the same folder\n+        //   - we also check `main.rs` and `lib.rs`\n+        // - `$dir.rs` in the parent folder, where `$dir` is the directory containing `self.file_id`\n+        let parent = our_path.parent()?;\n+        let mut paths =\n+            vec![parent.join(\"mod.rs\")?, parent.join(\"main.rs\")?, parent.join(\"lib.rs\")?];\n+\n+        // `submod/bla.rs` -> `submod.rs`\n+        if let Some(newmod) = (|| {\n+            let name = parent.name_and_extension()?.0;\n+            parent.parent()?.join(&format!(\"{}.rs\", name))\n+        })() {\n+            paths.push(newmod);\n+        }\n+\n+        for path in &paths {\n+            if let Some(parent_id) = source_root.file_for_path(path) {\n+                for krate in sema.db.relevant_crates(*parent_id).iter() {\n+                    let crate_def_map = sema.db.crate_def_map(*krate);\n+                    for (_, module) in crate_def_map.modules() {\n+                        if module.origin.is_inline() {\n+                            // We don't handle inline `mod parent {}`s, they use different paths.\n+                            continue;\n+                        }\n+\n+                        if module.origin.file_id() == Some(*parent_id) {\n+                            return make_fix(sema.db, *parent_id, module_name, self.file_id);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+}\n+\n+fn make_fix(\n+    db: &RootDatabase,\n+    parent_file_id: FileId,\n+    new_mod_name: &str,\n+    added_file_id: FileId,\n+) -> Option<Fix> {\n+    fn is_outline_mod(item: &ast::Item) -> bool {\n+        matches!(item, ast::Item::Module(m) if m.item_list().is_none())\n+    }\n+\n+    let mod_decl = format!(\"mod {};\", new_mod_name);\n+    let ast: ast::SourceFile = db.parse(parent_file_id).tree();\n+\n+    let mut builder = TextEdit::builder();\n+\n+    // If there's an existing `mod m;` statement matching the new one, don't emit a fix (it's\n+    // probably `#[cfg]`d out).\n+    for item in ast.items() {\n+        if let ast::Item::Module(m) = item {\n+            if let Some(name) = m.name() {\n+                if m.item_list().is_none() && name.to_string() == new_mod_name {\n+                    cov_mark::hit!(unlinked_file_skip_fix_when_mod_already_exists);\n+                    return None;\n+                }\n+            }\n+        }\n+    }\n+\n+    // If there are existing `mod m;` items, append after them (after the first group of them, rather).\n+    match ast\n+        .items()\n+        .skip_while(|item| !is_outline_mod(item))\n+        .take_while(|item| is_outline_mod(item))\n+        .last()\n+    {\n+        Some(last) => {\n+            cov_mark::hit!(unlinked_file_append_to_existing_mods);\n+            builder.insert(last.syntax().text_range().end(), format!(\"\\n{}\", mod_decl));\n+        }\n+        None => {\n+            // Prepend before the first item in the file.\n+            match ast.items().next() {\n+                Some(item) => {\n+                    cov_mark::hit!(unlinked_file_prepend_before_first_item);\n+                    builder.insert(item.syntax().text_range().start(), format!(\"{}\\n\\n\", mod_decl));\n+                }\n+                None => {\n+                    // No items in the file, so just append at the end.\n+                    cov_mark::hit!(unlinked_file_empty_file);\n+                    builder.insert(ast.syntax().text_range().end(), format!(\"{}\\n\", mod_decl));\n+                }\n+            }\n+        }\n+    }\n+\n+    let edit = builder.finish();\n+    let trigger_range = db.parse(added_file_id).tree().syntax().text_range();\n+    Some(Fix::new(\n+        &format!(\"Insert `{}`\", mod_decl),\n+        SourceChange::from_text_edit(parent_file_id, edit),\n+        trigger_range,\n+    ))\n+}"}]}