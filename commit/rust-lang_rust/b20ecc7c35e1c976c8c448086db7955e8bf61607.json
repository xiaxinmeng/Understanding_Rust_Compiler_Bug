{"sha": "b20ecc7c35e1c976c8c448086db7955e8bf61607", "node_id": "C_kwDOAAsO6NoAKGIyMGVjYzdjMzVlMWM5NzZjOGM0NDgwODZkYjc5NTVlOGJmNjE2MDc", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-04-07T16:15:05Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-04-08T10:29:16Z"}, "message": "rustdoc: Migrate some logic to `module_reexports`", "tree": {"sha": "1fcb009488c2762e414ab4080c762310a1746014", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fcb009488c2762e414ab4080c762310a1746014"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b20ecc7c35e1c976c8c448086db7955e8bf61607", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b20ecc7c35e1c976c8c448086db7955e8bf61607", "html_url": "https://github.com/rust-lang/rust/commit/b20ecc7c35e1c976c8c448086db7955e8bf61607", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b20ecc7c35e1c976c8c448086db7955e8bf61607/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d11b9165ee594fc6dd30b40e96bd7b32c04d2d3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d11b9165ee594fc6dd30b40e96bd7b32c04d2d3c", "html_url": "https://github.com/rust-lang/rust/commit/d11b9165ee594fc6dd30b40e96bd7b32c04d2d3c"}], "stats": {"total": 181, "additions": 34, "deletions": 147}, "files": [{"sha": "cfff4e206897a967c64824af11452b4e75defb10", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 29, "deletions": 140, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/b20ecc7c35e1c976c8c448086db7955e8bf61607/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20ecc7c35e1c976c8c448086db7955e8bf61607/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b20ecc7c35e1c976c8c448086db7955e8bf61607", "patch": "@@ -21,6 +21,7 @@ use rustc_hir::def_id::{DefId, DefIdMap, DefIdSet, LocalDefId, LOCAL_CRATE};\n use rustc_hir::PredicateOrigin;\n use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_infer::infer::region_constraints::{Constraint, RegionConstraintData};\n+use rustc_middle::metadata::Reexport;\n use rustc_middle::middle::resolve_bound_vars as rbv;\n use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::InternalSubsts;\n@@ -2056,141 +2057,44 @@ fn clean_bare_fn_ty<'tcx>(\n     BareFunctionDecl { unsafety: bare_fn.unsafety, abi: bare_fn.abi, decl, generic_params }\n }\n \n-/// Get DefId of of an item's user-visible parent.\n-///\n-/// \"User-visible\" should account for re-exporting and inlining, which is why this function isn't\n-/// just `tcx.parent(def_id)`. If the provided `path` has more than one path element, the `DefId`\n-/// of the second-to-last will be given.\n-///\n-/// ```text\n-/// use crate::foo::Bar;\n-///            ^^^ DefId of this item will be returned\n-/// ```\n-///\n-/// If the provided path has only one item, `tcx.parent(def_id)` will be returned instead.\n-fn get_path_parent_def_id(\n-    tcx: TyCtxt<'_>,\n-    def_id: DefId,\n-    path: &hir::UsePath<'_>,\n-) -> Option<DefId> {\n-    if let [.., parent_segment, _] = &path.segments {\n-        match parent_segment.res {\n-            hir::def::Res::Def(_, parent_def_id) => Some(parent_def_id),\n-            _ if parent_segment.ident.name == kw::Crate => {\n-                // In case the \"parent\" is the crate, it'll give `Res::Err` so we need to\n-                // circumvent it this way.\n-                Some(tcx.parent(def_id))\n-            }\n-            _ => None,\n-        }\n-    } else {\n-        // If the path doesn't have a parent, then the parent is the current module.\n-        Some(tcx.parent(def_id))\n-    }\n-}\n-\n-/// This visitor is used to find an HIR Item based on its `use` path. This doesn't use the ordinary\n-/// name resolver because it does not walk all the way through a chain of re-exports.\n-pub(crate) struct OneLevelVisitor<'hir> {\n-    map: rustc_middle::hir::map::Map<'hir>,\n-    pub(crate) item: Option<&'hir hir::Item<'hir>>,\n-    looking_for: Ident,\n+pub(crate) fn reexport_chain<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    import_def_id: LocalDefId,\n     target_def_id: LocalDefId,\n-}\n-\n-impl<'hir> OneLevelVisitor<'hir> {\n-    pub(crate) fn new(map: rustc_middle::hir::map::Map<'hir>, target_def_id: LocalDefId) -> Self {\n-        Self { map, item: None, looking_for: Ident::empty(), target_def_id }\n-    }\n-\n-    pub(crate) fn find_target(\n-        &mut self,\n-        tcx: TyCtxt<'_>,\n-        def_id: DefId,\n-        path: &hir::UsePath<'_>,\n-    ) -> Option<&'hir hir::Item<'hir>> {\n-        let parent_def_id = get_path_parent_def_id(tcx, def_id, path)?;\n-        let parent = self.map.get_if_local(parent_def_id)?;\n-\n-        // We get the `Ident` we will be looking for into `item`.\n-        self.looking_for = path.segments[path.segments.len() - 1].ident;\n-        // We reset the `item`.\n-        self.item = None;\n-\n-        match parent {\n-            hir::Node::Item(parent_item) => {\n-                hir::intravisit::walk_item(self, parent_item);\n-            }\n-            hir::Node::Crate(m) => {\n-                hir::intravisit::walk_mod(\n-                    self,\n-                    m,\n-                    tcx.local_def_id_to_hir_id(parent_def_id.as_local().unwrap()),\n-                );\n-            }\n-            _ => return None,\n-        }\n-        self.item\n-    }\n-}\n-\n-impl<'hir> hir::intravisit::Visitor<'hir> for OneLevelVisitor<'hir> {\n-    type NestedFilter = rustc_middle::hir::nested_filter::All;\n-\n-    fn nested_visit_map(&mut self) -> Self::Map {\n-        self.map\n-    }\n-\n-    fn visit_item(&mut self, item: &'hir hir::Item<'hir>) {\n-        if self.item.is_none()\n-            && item.ident == self.looking_for\n-            && (matches!(item.kind, hir::ItemKind::Use(_, _))\n-                || item.owner_id.def_id == self.target_def_id)\n+) -> &'tcx [Reexport] {\n+    for child in tcx.module_reexports(tcx.local_parent(import_def_id)).unwrap_or_default() {\n+        if child.res.opt_def_id() == Some(target_def_id.to_def_id())\n+            && child.reexport_chain[0].id() == Some(import_def_id.to_def_id())\n         {\n-            self.item = Some(item);\n+            return &child.reexport_chain;\n         }\n     }\n+    &[]\n }\n \n-/// Because a `Use` item directly links to the imported item, we need to manually go through each\n-/// import one by one. To do so, we go to the parent item and look for the `Ident` into it. Then,\n-/// if we found the \"end item\" (the imported one), we stop there because we don't need its\n-/// documentation. Otherwise, we repeat the same operation until we find the \"end item\".\n+/// Collect attributes from the whole import chain.\n fn get_all_import_attributes<'hir>(\n-    mut item: &hir::Item<'hir>,\n     cx: &mut DocContext<'hir>,\n+    import_def_id: LocalDefId,\n     target_def_id: LocalDefId,\n     is_inline: bool,\n-    mut prev_import: LocalDefId,\n ) -> Vec<(Cow<'hir, ast::Attribute>, Option<DefId>)> {\n-    let mut attributes: Vec<(Cow<'hir, ast::Attribute>, Option<DefId>)> = Vec::new();\n+    let mut attrs = Vec::new();\n     let mut first = true;\n-    let hir_map = cx.tcx.hir();\n-    let mut visitor = OneLevelVisitor::new(hir_map, target_def_id);\n-    let mut visited = FxHashSet::default();\n-\n-    // If the item is an import and has at least a path with two parts, we go into it.\n-    while let hir::ItemKind::Use(path, _) = item.kind && visited.insert(item.hir_id()) {\n-        let import_parent = cx.tcx.opt_local_parent(prev_import).map(|def_id| def_id.to_def_id());\n+    for def_id in reexport_chain(cx.tcx, import_def_id, target_def_id)\n+        .iter()\n+        .flat_map(|reexport| reexport.id())\n+    {\n+        let import_attrs = inline::load_attrs(cx, def_id);\n         if first {\n             // This is the \"original\" reexport so we get all its attributes without filtering them.\n-            attributes = hir_map.attrs(item.hir_id())\n-                .iter()\n-                .map(|attr| (Cow::Borrowed(attr), import_parent))\n-                .collect::<Vec<_>>();\n+            attrs = import_attrs.iter().map(|attr| (Cow::Borrowed(attr), Some(def_id))).collect();\n             first = false;\n         } else {\n-            add_without_unwanted_attributes(&mut attributes, hir_map.attrs(item.hir_id()), is_inline, import_parent);\n+            add_without_unwanted_attributes(&mut attrs, import_attrs, is_inline, Some(def_id));\n         }\n-\n-        if let Some(i) = visitor.find_target(cx.tcx, item.owner_id.def_id.to_def_id(), path) {\n-            item = i;\n-        } else {\n-            break;\n-        }\n-        prev_import = item.owner_id.def_id;\n     }\n-    attributes\n+    attrs\n }\n \n fn filter_tokens_from_list(\n@@ -2375,39 +2279,24 @@ fn clean_maybe_renamed_item<'tcx>(\n             _ => unreachable!(\"not yet converted\"),\n         };\n \n-        let attrs = if let Some(import_id) = import_id &&\n-            let Some(hir::Node::Item(use_node)) = cx.tcx.hir().find_by_def_id(import_id)\n-        {\n+        let target_attrs = inline::load_attrs(cx, def_id);\n+        let attrs = if let Some(import_id) = import_id {\n             let is_inline = inline::load_attrs(cx, import_id.to_def_id())\n                 .lists(sym::doc)\n                 .get_word_attr(sym::inline)\n                 .is_some();\n-            // Then we get all the various imports' attributes.\n-            let mut attrs = get_all_import_attributes(\n-                use_node,\n-                cx,\n-                item.owner_id.def_id,\n-                is_inline,\n-                import_id,\n-            );\n-\n-            add_without_unwanted_attributes(\n-                &mut attrs,\n-                inline::load_attrs(cx, def_id),\n-                is_inline,\n-                None\n-            );\n+            let mut attrs =\n+                get_all_import_attributes(cx, import_id, item.owner_id.def_id, is_inline);\n+            add_without_unwanted_attributes(&mut attrs, target_attrs, is_inline, None);\n             attrs\n         } else {\n             // We only keep the item's attributes.\n-            inline::load_attrs(cx, def_id).iter().map(|attr| (Cow::Borrowed(attr), None)).collect::<Vec<_>>()\n+            target_attrs.iter().map(|attr| (Cow::Borrowed(attr), None)).collect()\n         };\n \n         let cfg = attrs.cfg(cx.tcx, &cx.cache.hidden_cfg);\n-        let attrs = Attributes::from_ast_iter(attrs.iter().map(|(attr, did)| match attr {\n-            Cow::Borrowed(attr) => (*attr, *did),\n-            Cow::Owned(attr) => (attr, *did)\n-        }), false);\n+        let attrs =\n+            Attributes::from_ast_iter(attrs.iter().map(|(attr, did)| (&**attr, *did)), false);\n \n         let mut item =\n             Item::from_def_id_and_attrs_and_parts(def_id, Some(name), kind, Box::new(attrs), cfg);"}, {"sha": "383e8f66943302dadb6aeee8860c9e20d1af6a12", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b20ecc7c35e1c976c8c448086db7955e8bf61607/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20ecc7c35e1c976c8c448086db7955e8bf61607/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=b20ecc7c35e1c976c8c448086db7955e8bf61607", "patch": "@@ -13,9 +13,9 @@ use rustc_span::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n \n-use std::mem;\n+use std::{iter, mem};\n \n-use crate::clean::{cfg::Cfg, AttributesExt, NestedAttributesExt, OneLevelVisitor};\n+use crate::clean::{cfg::Cfg, reexport_chain, AttributesExt, NestedAttributesExt};\n use crate::core;\n \n /// This module is used to store stuff from Rust's AST in a more convenient\n@@ -220,7 +220,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         renamed: Option<Symbol>,\n         glob: bool,\n         please_inline: bool,\n-        path: &hir::UsePath<'_>,\n     ) -> bool {\n         debug!(\"maybe_inline_local res: {:?}\", res);\n \n@@ -266,9 +265,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         }\n \n         if !please_inline &&\n-            let mut visitor = OneLevelVisitor::new(self.cx.tcx.hir(), res_did) &&\n-            let Some(item) = visitor.find_target(self.cx.tcx, def_id.to_def_id(), path) &&\n-            let item_def_id = item.owner_id.def_id &&\n+            let Some(item_def_id) = reexport_chain(self.cx.tcx, def_id, res_did).iter()\n+                .flat_map(|reexport| reexport.id()).map(|id| id.expect_local())\n+                .chain(iter::once(res_did)).nth(1) &&\n             item_def_id != def_id &&\n             self\n                 .cx\n@@ -383,7 +382,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                             ident,\n                             is_glob,\n                             please_inline,\n-                            path,\n                         ) {\n                             continue;\n                         }"}]}