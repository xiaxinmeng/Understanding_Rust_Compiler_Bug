{"sha": "d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1YjFmZWU2ZmQ2NThiZjQ2NDkwMmQ0NmY5YTZjOWMyZjhhYjg3ZDc=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-09-14T13:10:24Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-09-18T09:29:47Z"}, "message": "incr.comp.: Remove tcx from StableHashingContext.", "tree": {"sha": "348abaa69ce23bd9608082326daec14866911e54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/348abaa69ce23bd9608082326daec14866911e54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "html_url": "https://github.com/rust-lang/rust/commit/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba6f93ca76d7d71399a13d5c9722c3239497f8ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba6f93ca76d7d71399a13d5c9722c3239497f8ef", "html_url": "https://github.com/rust-lang/rust/commit/ba6f93ca76d7d71399a13d5c9722c3239497f8ef"}], "stats": {"total": 577, "additions": 300, "deletions": 277}, "files": [{"sha": "7c21bba49f81b3ff594f683eae0417435431e7ee", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -603,12 +603,12 @@ trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {\n }\n \n impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a, T> DepNodeParams<'a, 'gcx, 'tcx> for T\n-    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>> + fmt::Debug\n+    where T: HashStable<StableHashingContext<'gcx>> + fmt::Debug\n {\n     default const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n \n     default fn to_fingerprint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Fingerprint {\n-        let mut hcx = StableHashingContext::new(tcx);\n+        let mut hcx = tcx.create_stable_hashing_context();\n         let mut hasher = StableHasher::new();\n \n         self.hash_stable(&mut hcx, &mut hasher);"}, {"sha": "b2d6886e7f22800bcd137c734953c75247be70c3", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -247,7 +247,7 @@ pub struct Map<'hir> {\n     /// plain old integers.\n     map: Vec<MapEntry<'hir>>,\n \n-    definitions: Definitions,\n+    definitions: &'hir Definitions,\n \n     /// Bodies inlined from other crates are cached here.\n     inlined_bodies: RefCell<DefIdMap<&'hir Body>>,\n@@ -304,8 +304,8 @@ impl<'hir> Map<'hir> {\n     }\n \n     #[inline]\n-    pub fn definitions(&self) -> &Definitions {\n-        &self.definitions\n+    pub fn definitions(&self) -> &'hir Definitions {\n+        self.definitions\n     }\n \n     pub fn def_key(&self, def_id: DefId) -> DefKey {\n@@ -1013,7 +1013,7 @@ impl Named for TraitItem { fn name(&self) -> Name { self.name } }\n impl Named for ImplItem { fn name(&self) -> Name { self.name } }\n \n pub fn map_crate<'hir>(forest: &'hir mut Forest,\n-                       definitions: Definitions)\n+                       definitions: &'hir Definitions)\n                        -> Map<'hir> {\n     let map = {\n         let mut collector = NodeCollector::root(&forest.krate,"}, {"sha": "0a2566f06924942eff4668c7ac4a2b7d2efbbe9a", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 51, "deletions": 37, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -11,7 +11,9 @@\n use hir;\n use hir::def_id::{DefId, DefIndex};\n use hir::map::DefPathHash;\n+use hir::map::definitions::Definitions;\n use ich::{self, CachingCodemapView};\n+use middle::cstore::CrateStore;\n use session::config::DebugInfoLevel::NoDebugInfo;\n use ty::{self, TyCtxt, fast_reject};\n use session::Session;\n@@ -41,8 +43,10 @@ thread_local!(static IGNORED_ATTR_NAMES: RefCell<FxHashSet<Symbol>> =\n /// enough information to transform DefIds and HirIds into stable DefPaths (i.e.\n /// a reference to the TyCtxt) and it holds a few caches for speeding up various\n /// things (e.g. each DefId/DefPath is only hashed once).\n-pub struct StableHashingContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub struct StableHashingContext<'gcx> {\n+    sess: &'gcx Session,\n+    definitions: &'gcx Definitions,\n+    cstore: &'gcx CrateStore,\n     body_resolver: BodyResolver<'gcx>,\n     hash_spans: bool,\n     hash_bodies: bool,\n@@ -65,21 +69,27 @@ pub enum NodeIdHashingMode {\n /// We could also just store a plain reference to the hir::Crate but we want\n /// to avoid that the crate is used to get untracked access to all of the HIR.\n #[derive(Clone, Copy)]\n-struct BodyResolver<'hir>(&'hir hir::Crate);\n+struct BodyResolver<'gcx>(&'gcx hir::Crate);\n \n-impl<'hir> BodyResolver<'hir> {\n+impl<'gcx> BodyResolver<'gcx> {\n     // Return a reference to the hir::Body with the given BodyId.\n     // DOES NOT DO ANY TRACKING, use carefully.\n-    fn body(self, id: hir::BodyId) -> &'hir hir::Body {\n+    fn body(self, id: hir::BodyId) -> &'gcx hir::Body {\n         self.0.body(id)\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> StableHashingContext<'a, 'gcx, 'tcx> {\n-\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n-        let hash_spans_initial = tcx.sess.opts.debuginfo != NoDebugInfo;\n-        let check_overflow_initial = tcx.sess.overflow_checks();\n+impl<'gcx> StableHashingContext<'gcx> {\n+    // The `krate` here is only used for mapping BodyIds to Bodies.\n+    // Don't use it for anything else or you'll run the risk of\n+    // leaking data out of the tracking system.\n+    pub fn new(sess: &'gcx Session,\n+               krate: &'gcx hir::Crate,\n+               definitions: &'gcx Definitions,\n+               cstore: &'gcx CrateStore)\n+               -> Self {\n+        let hash_spans_initial = sess.opts.debuginfo != NoDebugInfo;\n+        let check_overflow_initial = sess.overflow_checks();\n \n         debug_assert!(ich::IGNORED_ATTRIBUTES.len() > 0);\n         IGNORED_ATTR_NAMES.with(|names| {\n@@ -90,13 +100,13 @@ impl<'a, 'gcx, 'tcx> StableHashingContext<'a, 'gcx, 'tcx> {\n             }\n         });\n \n-        let body_resolver = BodyResolver(tcx.dep_graph.with_ignore(|| tcx.hir.krate()));\n-\n         StableHashingContext {\n-            tcx,\n-            body_resolver,\n+            sess,\n+            body_resolver: BodyResolver(krate),\n+            definitions,\n+            cstore,\n             caching_codemap: None,\n-            raw_codemap: tcx.sess.codemap(),\n+            raw_codemap: sess.codemap(),\n             hash_spans: hash_spans_initial,\n             hash_bodies: true,\n             overflow_checks_enabled: check_overflow_initial,\n@@ -106,7 +116,7 @@ impl<'a, 'gcx, 'tcx> StableHashingContext<'a, 'gcx, 'tcx> {\n \n     #[inline]\n     pub fn sess(&self) -> &'gcx Session {\n-        self.tcx.sess\n+        self.sess\n     }\n \n     pub fn force_span_hashing(mut self) -> Self {\n@@ -146,12 +156,16 @@ impl<'a, 'gcx, 'tcx> StableHashingContext<'a, 'gcx, 'tcx> {\n \n     #[inline]\n     pub fn def_path_hash(&self, def_id: DefId) -> DefPathHash {\n-        self.tcx.def_path_hash(def_id)\n+        if def_id.is_local() {\n+            self.definitions.def_path_hash(def_id.index)\n+        } else {\n+            self.cstore.def_path_hash(def_id)\n+        }\n     }\n \n     #[inline]\n     pub fn local_def_path_hash(&self, def_index: DefIndex) -> DefPathHash {\n-        self.tcx.hir.definitions().def_path_hash(def_index)\n+        self.definitions.def_path_hash(def_index)\n     }\n \n     #[inline]\n@@ -239,26 +253,26 @@ impl<'a, 'gcx, 'tcx> StableHashingContext<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'lcx> StableHashingContextProvider for ty::TyCtxt<'a, 'gcx, 'lcx> {\n-    type ContextType = StableHashingContext<'a, 'gcx, 'lcx>;\n+    type ContextType = StableHashingContext<'gcx>;\n     fn create_stable_hashing_context(&self) -> Self::ContextType {\n-        StableHashingContext::new(*self)\n+        (*self).create_stable_hashing_context()\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::BodyId {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::BodyId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         if hcx.hash_bodies() {\n             hcx.body_resolver.body(*self).hash_stable(hcx, hasher);\n         }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::HirId {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::HirId {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         match hcx.node_id_hashing_mode {\n             NodeIdHashingMode::Ignore => {\n@@ -270,52 +284,52 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::H\n                     local_id,\n                 } = *self;\n \n-                hcx.tcx.hir.definitions().def_path_hash(owner).hash_stable(hcx, hasher);\n+                hcx.local_def_path_hash(owner).hash_stable(hcx, hasher);\n                 local_id.hash_stable(hcx, hasher);\n             }\n         }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> ToStableHashKey<StableHashingContext<'a, 'gcx, 'tcx>> for hir::HirId {\n+impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for hir::HirId {\n     type KeyType = (DefPathHash, hir::ItemLocalId);\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n-                          hcx: &StableHashingContext<'a, 'gcx, 'tcx>)\n+                          hcx: &StableHashingContext<'gcx>)\n                           -> (DefPathHash, hir::ItemLocalId) {\n         let def_path_hash = hcx.local_def_path_hash(self.owner);\n         (def_path_hash, self.local_id)\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::NodeId {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::NodeId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         match hcx.node_id_hashing_mode {\n             NodeIdHashingMode::Ignore => {\n                 // Don't do anything.\n             }\n             NodeIdHashingMode::HashDefPath => {\n-                hcx.tcx.hir.node_to_hir_id(*self).hash_stable(hcx, hasher);\n+                hcx.definitions.node_to_hir_id(*self).hash_stable(hcx, hasher);\n             }\n         }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> ToStableHashKey<StableHashingContext<'a, 'gcx, 'tcx>> for ast::NodeId {\n+impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for ast::NodeId {\n     type KeyType = (DefPathHash, hir::ItemLocalId);\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n-                          hcx: &StableHashingContext<'a, 'gcx, 'tcx>)\n+                          hcx: &StableHashingContext<'gcx>)\n                           -> (DefPathHash, hir::ItemLocalId) {\n-        hcx.tcx.hir.node_to_hir_id(*self).to_stable_hash_key(hcx)\n+        hcx.definitions.node_to_hir_id(*self).to_stable_hash_key(hcx)\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Span {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for Span {\n \n     // Hash a span in a stable way. We can't directly hash the span's BytePos\n     // fields (that would be similar to hashing pointers, since those are just\n@@ -327,7 +341,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Span {\n     // Also, hashing filenames is expensive so we avoid doing it twice when the\n     // span starts and ends in the same file, which is almost always the case.\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use syntax_pos::Pos;\n \n@@ -390,8 +404,8 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Span {\n     }\n }\n \n-pub fn hash_stable_trait_impls<'a, 'tcx, 'gcx, W, R>(\n-    hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+pub fn hash_stable_trait_impls<'gcx, W, R>(\n+    hcx: &mut StableHashingContext<'gcx>,\n     hasher: &mut StableHasher<W>,\n     blanket_impls: &Vec<DefId>,\n     non_blanket_impls: &HashMap<fast_reject::SimplifiedType, Vec<DefId>, R>)"}, {"sha": "9582b03ce1c8a80b7b373a4d5e429a073f25b532", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -20,28 +20,28 @@ use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n use std::mem;\n use syntax::ast;\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for DefId {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for DefId {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.def_path_hash(*self).hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> ToStableHashKey<StableHashingContext<'a, 'gcx, 'tcx>> for DefId {\n+impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for DefId {\n     type KeyType = DefPathHash;\n \n     #[inline]\n-    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'a, 'gcx, 'tcx>) -> DefPathHash {\n+    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'gcx>) -> DefPathHash {\n         hcx.def_path_hash(*self)\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for CrateNum {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for CrateNum {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.def_path_hash(DefId {\n             krate: *self,\n@@ -50,25 +50,25 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for CrateN\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> ToStableHashKey<StableHashingContext<'a, 'gcx, 'tcx>> for CrateNum {\n+impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for CrateNum {\n     type KeyType = DefPathHash;\n \n     #[inline]\n-    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'a, 'gcx, 'tcx>) -> DefPathHash {\n+    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'gcx>) -> DefPathHash {\n         let def_id = DefId { krate: *self, index: CRATE_DEF_INDEX };\n         def_id.to_stable_hash_key(hcx)\n     }\n }\n \n impl_stable_hash_for!(tuple_struct hir::ItemLocalId { index });\n \n-impl<'a, 'gcx, 'lcx> ToStableHashKey<StableHashingContext<'a, 'gcx, 'lcx>>\n+impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>>\n for hir::ItemLocalId {\n     type KeyType = hir::ItemLocalId;\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n-                          _: &StableHashingContext<'a, 'gcx, 'lcx>)\n+                          _: &StableHashingContext<'gcx>)\n                           -> hir::ItemLocalId {\n         *self\n     }\n@@ -81,9 +81,9 @@ for hir::ItemLocalId {\n // want to pick up on a reference changing its target, so we hash the NodeIds\n // in \"DefPath Mode\".\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::ItemId {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ItemId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ItemId {\n             id\n@@ -95,9 +95,9 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::I\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::TraitItemId {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::TraitItemId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitItemId {\n             node_id\n@@ -109,9 +109,9 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::T\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::ImplItemId {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ImplItemId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ImplItemId {\n             node_id\n@@ -231,9 +231,9 @@ impl_stable_hash_for!(struct hir::TypeBinding {\n     span\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Ty {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Ty {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Ty {\n@@ -292,9 +292,9 @@ impl_stable_hash_for!(enum hir::FunctionRetTy {\n     Return(t)\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::TraitRef {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::TraitRef {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitRef {\n             ref path,\n@@ -329,9 +329,9 @@ impl_stable_hash_for!(struct hir::MacroDef {\n });\n \n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Block {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Block {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Block {\n             ref stmts,\n@@ -377,9 +377,9 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::B\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Pat {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Pat {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Pat {\n             id: _,\n@@ -504,9 +504,9 @@ impl_stable_hash_for!(enum hir::UnsafeSource {\n     UserProvided\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Expr {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Expr {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Expr {\n@@ -622,9 +622,9 @@ impl_stable_hash_for!(enum hir::LoopSource {\n     ForLoop\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::MatchSource {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::MatchSource {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use hir::MatchSource;\n \n@@ -673,9 +673,9 @@ impl_stable_hash_for!(enum hir::ScopeTarget {\n     Loop(loop_id_result)\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::Ident {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::Ident {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ast::Ident {\n             ref name,\n@@ -686,9 +686,9 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::I\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::TraitItem {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::TraitItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitItem {\n             id,\n@@ -720,9 +720,9 @@ impl_stable_hash_for!(enum hir::TraitItemKind {\n     Type(bounds, rhs)\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::ImplItem {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ImplItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ImplItem {\n             id,\n@@ -753,9 +753,9 @@ impl_stable_hash_for!(enum hir::ImplItemKind {\n     Type(t)\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Visibility {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Visibility {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -774,9 +774,9 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::V\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Defaultness {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Defaultness {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -795,9 +795,9 @@ impl_stable_hash_for!(enum hir::ImplPolarity {\n     Negative\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Mod {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Mod {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Mod {\n             inner,\n@@ -850,9 +850,9 @@ impl_stable_hash_for!(enum hir::VariantData {\n     Unit(id)\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Item {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Item {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hash_spans = match self.node {\n             hir::ItemStatic(..)      |\n@@ -933,10 +933,10 @@ impl_stable_hash_for!(struct hir::ImplItemRef {\n     defaultness\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for hir::AssociatedItemKind {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -977,9 +977,9 @@ impl_stable_hash_for!(struct hir::Arg {\n     hir_id\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Body {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Body {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Body {\n             ref arguments,\n@@ -995,12 +995,12 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::B\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> ToStableHashKey<StableHashingContext<'a, 'gcx, 'tcx>> for hir::BodyId {\n+impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for hir::BodyId {\n     type KeyType = (DefPathHash, hir::ItemLocalId);\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n-                          hcx: &StableHashingContext<'a, 'gcx, 'tcx>)\n+                          hcx: &StableHashingContext<'gcx>)\n                           -> (DefPathHash, hir::ItemLocalId) {\n         let hir::BodyId { node_id } = *self;\n         node_id.to_stable_hash_key(hcx)\n@@ -1013,9 +1013,9 @@ impl_stable_hash_for!(struct hir::InlineAsmOutput {\n     is_indirect\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::GlobalAsm {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::GlobalAsm {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::GlobalAsm {\n             asm,\n@@ -1026,9 +1026,9 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::G\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::InlineAsm {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::InlineAsm {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::InlineAsm {\n             asm,\n@@ -1103,22 +1103,22 @@ impl_stable_hash_for!(enum hir::Constness {\n     NotConst\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for hir::def_id::DefIndex {\n \n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.local_def_path_hash(*self).hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> ToStableHashKey<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>>\n for hir::def_id::DefIndex {\n     type KeyType = DefPathHash;\n \n     #[inline]\n-    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'a, 'gcx, 'tcx>) -> DefPathHash {\n+    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'gcx>) -> DefPathHash {\n          hcx.local_def_path_hash(*self)\n     }\n }\n@@ -1129,10 +1129,10 @@ impl_stable_hash_for!(struct hir::def::Export {\n     span\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for ::middle::lang_items::LangItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          _: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         ::std::hash::Hash::hash(self, hasher);\n     }\n@@ -1143,10 +1143,10 @@ impl_stable_hash_for!(struct ::middle::lang_items::LanguageItems {\n     missing\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for hir::TraitCandidate {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n             let hir::TraitCandidate {"}, {"sha": "9b6613e4cae96a61d6853be19e3d38d4779b70c3", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -33,11 +33,11 @@ impl_stable_hash_for!(struct mir::LocalDecl<'tcx> {\n impl_stable_hash_for!(struct mir::UpvarDecl { debug_name, by_ref });\n impl_stable_hash_for!(struct mir::BasicBlockData<'tcx> { statements, terminator, is_cleanup });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for mir::Terminator<'gcx> {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let mir::Terminator {\n             ref kind,\n@@ -76,61 +76,61 @@ for mir::Terminator<'gcx> {\n }\n \n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Local {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Local {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::BasicBlock {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::BasicBlock {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Field {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Field {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for mir::VisibilityScope {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Promoted {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Promoted {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for mir::TerminatorKind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -196,10 +196,10 @@ for mir::TerminatorKind<'gcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for mir::AssertMessage<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -219,10 +219,10 @@ for mir::AssertMessage<'gcx> {\n \n impl_stable_hash_for!(struct mir::Statement<'tcx> { source_info, kind });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for mir::StatementKind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -256,12 +256,12 @@ for mir::StatementKind<'gcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx, T> HashStable<StableHashingContext<'gcx>>\n     for mir::ValidationOperand<'gcx, T>\n-    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+    where T: HashStable<StableHashingContext<'gcx>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>)\n     {\n         self.lval.hash_stable(hcx, hasher);\n@@ -273,9 +273,9 @@ impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n \n impl_stable_hash_for!(enum mir::ValidationOp { Acquire, Release, Suspend(region_scope) });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Lvalue<'gcx> {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Lvalue<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -292,14 +292,14 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::L\n     }\n }\n \n-impl<'a, 'gcx, 'tcx, B, V, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx, B, V, T> HashStable<StableHashingContext<'gcx>>\n for mir::Projection<'gcx, B, V, T>\n-    where B: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n-          V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n-          T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+    where B: HashStable<StableHashingContext<'gcx>>,\n+          V: HashStable<StableHashingContext<'gcx>>,\n+          T: HashStable<StableHashingContext<'gcx>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let mir::Projection {\n             ref base,\n@@ -311,13 +311,13 @@ for mir::Projection<'gcx, B, V, T>\n     }\n }\n \n-impl<'a, 'gcx, 'tcx, V, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx, V, T> HashStable<StableHashingContext<'gcx>>\n for mir::ProjectionElem<'gcx, V, T>\n-    where V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n-          T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+    where V: HashStable<StableHashingContext<'gcx>>,\n+          T: HashStable<StableHashingContext<'gcx>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -348,9 +348,9 @@ for mir::ProjectionElem<'gcx, V, T>\n \n impl_stable_hash_for!(struct mir::VisibilityScopeData { span, parent_scope });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Operand<'gcx> {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Operand<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -365,9 +365,9 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::O\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Rvalue<'gcx> {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Rvalue<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -425,10 +425,10 @@ impl_stable_hash_for!(enum mir::CastKind {\n     Unsize\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for mir::AggregateKind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -487,9 +487,9 @@ impl_stable_hash_for!(enum mir::NullOp {\n \n impl_stable_hash_for!(struct mir::Constant<'tcx> { span, ty, literal });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Literal<'gcx> {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Literal<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {"}, {"sha": "6821ac85298001627eb9e2e27d7f0960d0234bc3", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -28,42 +28,42 @@ use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n                                            StableHasher, StableHasherResult};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for InternedString {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for InternedString {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let s: &str = &**self;\n         s.hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> ToStableHashKey<StableHashingContext<'a, 'gcx, 'tcx>> for InternedString {\n+impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for InternedString {\n     type KeyType = InternedString;\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n-                          _: &StableHashingContext<'a, 'gcx, 'tcx>)\n+                          _: &StableHashingContext<'gcx>)\n                           -> InternedString {\n         self.clone()\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::Name {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::Name {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         self.as_str().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> ToStableHashKey<StableHashingContext<'a, 'gcx, 'tcx>> for ast::Name {\n+impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for ast::Name {\n     type KeyType = InternedString;\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n-                          _: &StableHashingContext<'a, 'gcx, 'tcx>)\n+                          _: &StableHashingContext<'gcx>)\n                           -> InternedString {\n         self.as_str()\n     }\n@@ -110,10 +110,10 @@ impl_stable_hash_for!(struct ::syntax::attr::Stability {\n     rustc_const_unstable\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for ::syntax::attr::StabilityLevel {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -165,9 +165,9 @@ impl_stable_hash_for!(struct ::syntax::ast::Lifetime { id, span, ident });\n impl_stable_hash_for!(enum ::syntax::ast::StrStyle { Cooked, Raw(pounds) });\n impl_stable_hash_for!(enum ::syntax::ast::AttrStyle { Outer, Inner });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for [ast::Attribute] {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for [ast::Attribute] {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         if self.len() == 0 {\n             self.len().hash_stable(hcx, hasher);\n@@ -190,9 +190,9 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for [ast::\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::Attribute {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::Attribute {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         // Make sure that these have been filtered out.\n         debug_assert!(self.name().map(|name| !hcx.is_ignored_attr(name)).unwrap_or(true));\n@@ -219,10 +219,10 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::A\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for tokenstream::TokenTree {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -241,21 +241,21 @@ for tokenstream::TokenTree {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for tokenstream::TokenStream {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         for sub_tt in self.trees() {\n             sub_tt.hash_stable(hcx, hasher);\n         }\n     }\n }\n \n-fn hash_token<'a, 'gcx, 'tcx, W: StableHasherResult>(token: &token::Token,\n-                                               hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n-                                               hasher: &mut StableHasher<W>,\n-                                               error_reporting_span: Span) {\n+fn hash_token<'gcx, W: StableHasherResult>(token: &token::Token,\n+                                           hcx: &mut StableHashingContext<'gcx>,\n+                                           hasher: &mut StableHasher<W>,\n+                                           error_reporting_span: Span) {\n     mem::discriminant(token).hash_stable(hcx, hasher);\n     match *token {\n         token::Token::Eq |\n@@ -358,9 +358,9 @@ impl_stable_hash_for!(enum ::syntax::ast::MetaItemKind {\n     NameValue(lit)\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for FileMap {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for FileMap {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let FileMap {\n             ref name,"}, {"sha": "e3ecaae953a6bdaadb0d2e1fee8549ce8f5f22c9", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -20,30 +20,30 @@ use middle::region;\n use traits;\n use ty;\n \n-impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx, T> HashStable<StableHashingContext<'gcx>>\n for &'gcx ty::Slice<T>\n-    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>> {\n+    where T: HashStable<StableHashingContext<'gcx>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         (&self[..]).hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for ty::subst::Kind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         self.as_type().hash_stable(hcx, hasher);\n         self.as_region().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for ty::RegionKind {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -81,10 +81,10 @@ for ty::RegionKind {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for ty::adjustment::AutoBorrow<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -99,10 +99,10 @@ for ty::adjustment::AutoBorrow<'gcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for ty::adjustment::Adjust<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -134,10 +134,10 @@ impl_stable_hash_for!(enum ty::BorrowKind {\n     MutBorrow\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for ty::UpvarCapture<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -161,11 +161,11 @@ impl_stable_hash_for!(struct ty::FnSig<'tcx> {\n     abi\n });\n \n-impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::Binder<T>\n-    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx, T> HashStable<StableHashingContext<'gcx>> for ty::Binder<T>\n+    where T: HashStable<StableHashingContext<'gcx>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::Binder(ref inner) = *self;\n         inner.hash_stable(hcx, hasher);\n@@ -185,13 +185,13 @@ impl_stable_hash_for!(struct ty::TraitPredicate<'tcx> { trait_ref });\n impl_stable_hash_for!(tuple_struct ty::EquatePredicate<'tcx> { t1, t2 });\n impl_stable_hash_for!(struct ty::SubtypePredicate<'tcx> { a_is_expected, a, b });\n \n-impl<'a, 'gcx, 'tcx, A, B> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx, A, B> HashStable<StableHashingContext<'gcx>>\n for ty::OutlivesPredicate<A, B>\n-    where A: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n-          B: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n+    where A: HashStable<StableHashingContext<'gcx>>,\n+          B: HashStable<StableHashingContext<'gcx>>,\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::OutlivesPredicate(ref a, ref b) = *self;\n         a.hash_stable(hcx, hasher);\n@@ -203,9 +203,9 @@ impl_stable_hash_for!(struct ty::ProjectionPredicate<'tcx> { projection_ty, ty }\n impl_stable_hash_for!(struct ty::ProjectionTy<'tcx> { substs, item_def_id });\n \n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::Predicate<'gcx> {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::Predicate<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -245,9 +245,9 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::Pr\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::AdtFlags {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::AdtFlags {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          _: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         std_hash::Hash::hash(self, hasher);\n     }\n@@ -272,10 +272,10 @@ impl_stable_hash_for!(struct ty::FieldDef {\n     vis\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for ::middle::const_val::ConstVal<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use middle::const_val::ConstVal::*;\n         use middle::const_val::ConstAggregate::*;\n@@ -347,10 +347,10 @@ impl_stable_hash_for!(struct ::middle::const_val::ConstEvalErr<'tcx> {\n     kind\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for ::middle::const_val::ErrKind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use middle::const_val::ErrKind::*;\n \n@@ -410,9 +410,9 @@ impl_stable_hash_for!(enum ty::adjustment::CustomCoerceUnsized {\n     Struct(index)\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::Generics {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::Generics {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::Generics {\n             parent,\n@@ -438,10 +438,10 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::Ge\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for ty::RegionParameterDef {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::RegionParameterDef {\n             name,\n@@ -466,12 +466,12 @@ impl_stable_hash_for!(struct ty::TypeParameterDef {\n     pure_wrt_drop\n });\n \n-impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx, T> HashStable<StableHashingContext<'gcx>>\n for ::middle::resolve_lifetime::Set1<T>\n-    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+    where T: HashStable<StableHashingContext<'gcx>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use middle::resolve_lifetime::Set1;\n \n@@ -522,11 +522,11 @@ impl_stable_hash_for!(enum ::middle::region::Scope {\n     Remainder(block_remainder)\n });\n \n-impl<'a, 'gcx, 'tcx> ToStableHashKey<StableHashingContext<'a, 'gcx, 'tcx>> for region::Scope {\n+impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for region::Scope {\n     type KeyType = region::Scope;\n \n     #[inline]\n-    fn to_stable_hash_key(&self, _: &StableHashingContext<'a, 'gcx, 'tcx>) -> region::Scope {\n+    fn to_stable_hash_key(&self, _: &StableHashingContext<'gcx>) -> region::Scope {\n         *self\n     }\n }\n@@ -552,11 +552,11 @@ impl_stable_hash_for!(enum ty::BoundRegion {\n     BrEnv\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for ty::TypeVariants<'gcx>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use ty::TypeVariants::*;\n \n@@ -648,11 +648,11 @@ impl_stable_hash_for!(struct ty::TypeAndMut<'tcx> {\n     mutbl\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for ty::ExistentialPredicate<'gcx>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -685,9 +685,9 @@ impl_stable_hash_for!(struct ty::Instance<'tcx> {\n     substs\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::InstanceDef<'gcx> {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::InstanceDef<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -721,9 +721,9 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::In\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::TraitDef {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::TraitDef {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::TraitDef {\n             // We already have the def_path_hash below, no need to hash it twice\n@@ -751,9 +751,9 @@ impl_stable_hash_for!(struct ty::DtorckConstraint<'tcx> {\n });\n \n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::CrateVariancesMap {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::CrateVariancesMap {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::CrateVariancesMap {\n             ref dependencies,\n@@ -789,12 +789,12 @@ impl_stable_hash_for!(enum ty::AssociatedItemContainer {\n });\n \n \n-impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx, T> HashStable<StableHashingContext<'gcx>>\n for ty::steal::Steal<T>\n-    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+    where T: HashStable<StableHashingContext<'gcx>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         self.borrow().hash_stable(hcx, hasher);\n     }\n@@ -816,10 +816,10 @@ impl_stable_hash_for!(enum ::middle::privacy::AccessLevel {\n     Public\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for ::middle::privacy::AccessLevels {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n             let ::middle::privacy::AccessLevels {"}, {"sha": "21dfd3267df5125910694b6b5472e66b4baa1580", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -386,10 +386,10 @@ impl LintLevelMap {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for LintLevelMap {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for LintLevelMap {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let LintLevelMap {\n             ref sets,"}, {"sha": "f0285d6a937824b2487dee5b0c70d7ab1902f111", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -73,10 +73,10 @@ macro_rules! __impl_stable_hash_field {\n #[macro_export]\n macro_rules! impl_stable_hash_for {\n     (enum $enum_name:path { $( $variant:ident $( ( $($arg:ident),* ) )* ),* }) => {\n-        impl<'a, 'tcx, 'lcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a, 'tcx, 'lcx>> for $enum_name {\n+        impl<'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'tcx>> for $enum_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n-                                                  __ctx: &mut $crate::ich::StableHashingContext<'a, 'tcx, 'lcx>,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'tcx>,\n                                                   __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n                 use $enum_name::*;\n                 ::std::mem::discriminant(self).hash_stable(__ctx, __hasher);\n@@ -92,10 +92,10 @@ macro_rules! impl_stable_hash_for {\n         }\n     };\n     (struct $struct_name:path { $($field:ident),* }) => {\n-        impl<'a, 'tcx, 'lcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a, 'tcx, 'lcx>> for $struct_name {\n+        impl<'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'tcx>> for $struct_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n-                                                  __ctx: &mut $crate::ich::StableHashingContext<'a, 'tcx, 'lcx>,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'tcx>,\n                                                   __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n                 let $struct_name {\n                     $(ref $field),*\n@@ -106,10 +106,10 @@ macro_rules! impl_stable_hash_for {\n         }\n     };\n     (tuple_struct $struct_name:path { $($field:ident),* }) => {\n-        impl<'a, 'tcx, 'lcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a, 'tcx, 'lcx>> for $struct_name {\n+        impl<'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'tcx>> for $struct_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n-                                                  __ctx: &mut $crate::ich::StableHashingContext<'a, 'tcx, 'lcx>,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'tcx>,\n                                                   __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n                 let $struct_name (\n                     $(ref $field),*\n@@ -125,11 +125,11 @@ macro_rules! impl_stable_hash_for {\n macro_rules! impl_stable_hash_for_spanned {\n     ($T:path) => (\n \n-        impl<'a, 'tcx, 'lcx> HashStable<StableHashingContext<'a, 'tcx, 'lcx>> for ::syntax::codemap::Spanned<$T>\n+        impl<'tcx> HashStable<StableHashingContext<'tcx>> for ::syntax::codemap::Spanned<$T>\n         {\n             #[inline]\n             fn hash_stable<W: StableHasherResult>(&self,\n-                                                  hcx: &mut StableHashingContext<'a, 'tcx, 'lcx>,\n+                                                  hcx: &mut StableHashingContext<'tcx>,\n                                                   hasher: &mut StableHasher<W>) {\n                 self.node.hash_stable(hcx, hasher);\n                 self.span.hash_stable(hcx, hasher);"}, {"sha": "5b286c6593b7adfc09400161fba186eeaa85e002", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -1239,9 +1239,9 @@ pub fn provide(providers: &mut Providers) {\n     };\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ScopeTree {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ScopeTree {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ScopeTree {\n             root_body,"}, {"sha": "efc2f647cfdf532827cdcf08419f440e9493096a", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -35,9 +35,9 @@ impl serialize::Decodable for Cache {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Cache {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for Cache {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          _: &mut StableHashingContext<'gcx>,\n                                           _: &mut StableHasher<W>) {\n         // do nothing\n     }"}, {"sha": "0651d1904bf06697f0a6ba0fe26c912880552989", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -369,9 +369,9 @@ pub fn ancestors(tcx: TyCtxt,\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Children {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for Children {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let Children {\n             ref nonblanket_impls,"}, {"sha": "8005714433f5ef9d0e3eb9e30a2cda1db0e01562", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -687,9 +687,9 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for TypeckTables<'gcx> {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for TypeckTables<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::TypeckTables {\n             local_id_root,\n@@ -1225,6 +1225,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn crate_data_as_rc_any(self, cnum: CrateNum) -> Rc<Any> {\n         self.cstore.crate_data_as_rc_any(cnum)\n     }\n+\n+    pub fn create_stable_hashing_context(self) -> StableHashingContext<'gcx> {\n+        let krate = self.dep_graph.with_ignore(|| self.gcx.hir.krate());\n+\n+        StableHashingContext::new(self.sess,\n+                                  krate,\n+                                  self.hir.definitions(),\n+                                  self.cstore)\n+    }\n }\n \n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {"}, {"sha": "490bfe78a9a1f4e816cf6a805566a6a90cf70d63", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -144,12 +144,12 @@ impl<D: Copy + Debug + Ord + Eq + Hash> SimplifiedTypeGen<D> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx, D> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for SimplifiedTypeGen<D>\n+impl<'gcx, D> HashStable<StableHashingContext<'gcx>> for SimplifiedTypeGen<D>\n     where D: Copy + Debug + Ord + Eq + Hash +\n-             HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n+             HashStable<StableHashingContext<'gcx>>,\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {"}, {"sha": "1709f9ed2df1c9a8e5d6d773955043703d982855", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -2306,10 +2306,10 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Layout\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for Layout\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use ty::layout::Layout::*;\n         mem::discriminant(self).hash_stable(hcx, hasher);\n@@ -2399,10 +2399,10 @@ impl_stable_hash_for!(struct ::ty::layout::Size {\n     raw\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for LayoutError<'gcx>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for LayoutError<'gcx>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use ty::layout::LayoutError::*;\n         mem::discriminant(self).hash_stable(hcx, hasher);"}, {"sha": "32d8a5114a79d0bca1bd8fa2f7b44baf25a4a01f", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -500,9 +500,9 @@ impl<'tcx> TyS<'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::TyS<'gcx> {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::TyS<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::TyS {\n             ref sty,\n@@ -1334,9 +1334,9 @@ impl<'tcx> serialize::UseSpecializedEncodable for &'tcx AdtDef {\n impl<'tcx> serialize::UseSpecializedDecodable for &'tcx AdtDef {}\n \n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for AdtDef {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for AdtDef {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::AdtDef {\n             did,"}, {"sha": "e0b05c2ba39ac7ad3dab4283363db1061bbdcb18", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -186,9 +186,9 @@ pub(super) fn trait_impls_of_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     })\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for TraitImpls {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for TraitImpls {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let TraitImpls {\n             ref blanket_impls,"}, {"sha": "27819f551b9b3f47cabcd6fb319eb82395cf8aff", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -12,7 +12,7 @@\n \n use hir::def_id::{DefId, LOCAL_CRATE};\n use hir::map::DefPathData;\n-use ich::{StableHashingContext, NodeIdHashingMode};\n+use ich::NodeIdHashingMode;\n use middle::const_val::ConstVal;\n use traits::{self, Reveal};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -214,7 +214,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     /// context it's calculated within. This is used by the `type_id` intrinsic.\n     pub fn type_id_hash(self, ty: Ty<'tcx>) -> u64 {\n         let mut hasher = StableHasher::new();\n-        let mut hcx = StableHashingContext::new(self);\n+        let mut hcx = self.create_stable_hashing_context();\n \n         // We want the type_id be independent of the types free regions, so we\n         // erase them. The erase_regions() call will also anonymize bound"}, {"sha": "d50d3deb67347f9e5a3ff69b9e6c986432939e30", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -175,7 +175,7 @@ pub fn compile_input(sess: &Session,\n         // Construct the HIR map\n         let hir_map = time(sess.time_passes(),\n                            \"indexing hir\",\n-                           || hir_map::map_crate(&mut hir_forest, defs));\n+                           || hir_map::map_crate(&mut hir_forest, &defs));\n \n         {\n             let _ignore = hir_map.dep_graph.in_ignore();"}, {"sha": "daabf481e461f941565f00ab1818c8f959adfcb1", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -133,7 +133,7 @@ fn test_env<F>(source_string: &str,\n \n     let arena = DroplessArena::new();\n     let arenas = ty::GlobalArenas::new();\n-    let hir_map = hir_map::map_crate(&mut hir_forest, defs);\n+    let hir_map = hir_map::map_crate(&mut hir_forest, &defs);\n \n     // run just enough stuff to build a tcx:\n     let named_region_map = resolve_lifetime::krate(&sess, &*cstore, &hir_map);"}, {"sha": "0329aa8d6741b71e1476089419735d8d86eb3c14", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -91,7 +91,7 @@ impl<'a> ::std::ops::Index<&'a DepNode> for IncrementalHashesMap {\n \n struct ComputeItemHashesVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    hcx: StableHashingContext<'a, 'tcx, 'tcx>,\n+    hcx: StableHashingContext<'tcx>,\n     hashes: IncrementalHashesMap,\n }\n \n@@ -100,7 +100,7 @@ impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n                                               def_index: DefIndex,\n                                               hash_bodies: bool,\n                                               item_like: T)\n-        where T: HashStable<StableHashingContext<'a, 'tcx, 'tcx>>\n+        where T: HashStable<StableHashingContext<'tcx>>\n     {\n         if !hash_bodies && !self.tcx.sess.opts.build_dep_graph() {\n             // If we just need the hashes in order to compute the SVH, we don't\n@@ -303,7 +303,7 @@ pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n \n     let mut visitor = ComputeItemHashesVisitor {\n         tcx,\n-        hcx: StableHashingContext::new(tcx),\n+        hcx: tcx.create_stable_hashing_context(),\n         hashes: IncrementalHashesMap::new(),\n     };\n "}, {"sha": "d9ab2562efff26b87d70643bea77b9504c2d3ca2", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -16,7 +16,7 @@ use schema::*;\n use rustc::hir;\n use rustc::ty::{self, TyCtxt};\n \n-use rustc::ich::{StableHashingContext, Fingerprint};\n+use rustc::ich::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -43,7 +43,7 @@ impl<'a, 'b, 'tcx> IsolatedEncoder<'a, 'b, 'tcx> {\n         // In order to avoid having to hash hir::Bodies from extern crates, we\n         // hash them here, during export, and store the hash with metadata.\n         let stable_bodies_hash = {\n-            let mut hcx = StableHashingContext::new(self.tcx);\n+            let mut hcx = self.tcx.create_stable_hashing_context();\n             let mut hasher = StableHasher::new();\n \n             hcx.while_hashing_hir_bodies(true, |hcx| {"}, {"sha": "7dc50fe29df07a245bc9a53cbfb9cc64300de779", "filename": "src/librustc_metadata/isolated_encoder.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc_metadata%2Fisolated_encoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc_metadata%2Fisolated_encoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fisolated_encoder.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -23,7 +23,7 @@ use rustc_serialize::Encodable;\n pub struct IsolatedEncoder<'a, 'b: 'a, 'tcx: 'b> {\n     pub tcx: TyCtxt<'b, 'tcx, 'tcx>,\n     ecx: &'a mut EncodeContext<'b, 'tcx>,\n-    hcx: Option<(StableHashingContext<'b, 'tcx, 'tcx>, StableHasher<Fingerprint>)>,\n+    hcx: Option<(StableHashingContext<'tcx>, StableHasher<Fingerprint>)>,\n }\n \n impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n@@ -40,9 +40,9 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 // Except when -Zquery-dep-graph is specified because we don't\n                 // want to mess up our tests.\n                 let hcx = if tcx.sess.opts.debugging_opts.query_dep_graph {\n-                    StableHashingContext::new(tcx)\n+                    tcx.create_stable_hashing_context()\n                 } else {\n-                    StableHashingContext::new(tcx).force_span_hashing()\n+                    tcx.create_stable_hashing_context().force_span_hashing()\n                 };\n \n                 Some((hcx, StableHasher::new()))\n@@ -61,7 +61,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     pub fn lazy<T>(&mut self, value: &T) -> Lazy<T>\n-        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx, 'tcx>>\n+        where T: Encodable + HashStable<StableHashingContext<'tcx>>\n     {\n         if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n             value.hash_stable(hcx, hasher);\n@@ -72,7 +72,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n     pub fn lazy_seq<I, T>(&mut self, iter: I) -> LazySeq<T>\n         where I: IntoIterator<Item = T>,\n-              T: Encodable + HashStable<StableHashingContext<'b, 'tcx, 'tcx>>\n+              T: Encodable + HashStable<StableHashingContext<'tcx>>\n     {\n         if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n             let iter = iter.into_iter();\n@@ -111,7 +111,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n     pub fn lazy_seq_ref<'x, I, T>(&mut self, iter: I) -> LazySeq<T>\n         where I: IntoIterator<Item = &'x T>,\n-              T: 'x + Encodable + HashStable<StableHashingContext<'b, 'tcx, 'tcx>>\n+              T: 'x + Encodable + HashStable<StableHashingContext<'tcx>>\n     {\n         if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n             let iter = iter.into_iter();\n@@ -149,7 +149,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     pub fn lazy_seq_from_slice<T>(&mut self, slice: &[T]) -> LazySeq<T>\n-        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx, 'tcx>>\n+        where T: Encodable + HashStable<StableHashingContext<'tcx>>\n     {\n         if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n             slice.hash_stable(hcx, hasher);\n@@ -159,7 +159,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     pub fn lazy_seq_ref_from_slice<T>(&mut self, slice: &[&T]) -> LazySeq<T>\n-        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx, 'tcx>>\n+        where T: Encodable + HashStable<StableHashingContext<'tcx>>\n     {\n         if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n             slice.hash_stable(hcx, hasher);"}, {"sha": "dad0d26d2715d172ae92150765170b20039b86d4", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -229,9 +229,9 @@ pub struct TraitImpls {\n     pub impls: LazySeq<DefIndex>,\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for TraitImpls {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for TraitImpls {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let TraitImpls {\n             trait_id: (krate, def_index),\n@@ -312,9 +312,9 @@ pub enum EntryKind<'tcx> {\n     AssociatedConst(AssociatedContainer, u8),\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for EntryKind<'tcx> {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for EntryKind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {"}, {"sha": "7e75eb9c78bab2b6e395b99d2267f04d2e263234", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -141,10 +141,10 @@ impl<'a, 'tcx> DepGraphSafe for SharedCrateContext<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> StableHashingContextProvider for SharedCrateContext<'a, 'tcx> {\n-    type ContextType = StableHashingContext<'a, 'tcx, 'tcx>;\n+    type ContextType = StableHashingContext<'tcx>;\n \n     fn create_stable_hashing_context(&self) -> Self::ContextType {\n-        StableHashingContext::new(self.tcx)\n+        self.tcx.create_stable_hashing_context()\n     }\n }\n "}, {"sha": "29da763f334c7b016eafadbbd78c2326e1e32aa5", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -141,10 +141,10 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> StableHashingContextProvider for ConstraintContext<'a, 'tcx> {\n-    type ContextType = StableHashingContext<'a, 'tcx, 'tcx>;\n+    type ContextType = StableHashingContext<'tcx>;\n \n     fn create_stable_hashing_context(&self) -> Self::ContextType {\n-         StableHashingContext::new(self.terms_cx.tcx)\n+         self.terms_cx.tcx.create_stable_hashing_context()\n     }\n }\n "}, {"sha": "1663e5ad142864072a8ca9f534fe4c72e7940540", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -175,7 +175,7 @@ pub fn run_core(search_paths: SearchPaths,\n \n     let arena = DroplessArena::new();\n     let arenas = GlobalArenas::new();\n-    let hir_map = hir_map::map_crate(&mut hir_forest, defs);\n+    let hir_map = hir_map::map_crate(&mut hir_forest, &defs);\n     let output_filenames = driver::build_output_filenames(&input,\n                                                           &None,\n                                                           &None,"}, {"sha": "36efc37a8095c8927be6881b32a88bb513967bdf", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=d5b1fee6fd658bf464902d46f9a6c9c2f8ab87d7", "patch": "@@ -124,7 +124,7 @@ pub fn run(input: &str,\n                                        render_type);\n \n     {\n-        let map = hir::map::map_crate(&mut hir_forest, defs);\n+        let map = hir::map::map_crate(&mut hir_forest, &defs);\n         let krate = map.krate();\n         let mut hir_collector = HirCollector {\n             sess: &sess,"}]}