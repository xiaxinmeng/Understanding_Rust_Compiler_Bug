{"sha": "393a37ecbd5fbeda49246dc7f3885af69130151a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5M2EzN2VjYmQ1ZmJlZGE0OTI0NmRjN2YzODg1YWY2OTEzMDE1MWE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-05-12T16:02:39Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-05-12T16:02:39Z"}, "message": "Correct various small points, expand some sections, while avoiding\ntoo much detail.", "tree": {"sha": "75cf3c3e333d791892f7e04a20431075e6a12a33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75cf3c3e333d791892f7e04a20431075e6a12a33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/393a37ecbd5fbeda49246dc7f3885af69130151a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/393a37ecbd5fbeda49246dc7f3885af69130151a", "html_url": "https://github.com/rust-lang/rust/commit/393a37ecbd5fbeda49246dc7f3885af69130151a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/393a37ecbd5fbeda49246dc7f3885af69130151a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2e1a1b50eee3dd98bbd760d71ae7b5fce360165", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2e1a1b50eee3dd98bbd760d71ae7b5fce360165", "html_url": "https://github.com/rust-lang/rust/commit/f2e1a1b50eee3dd98bbd760d71ae7b5fce360165"}], "stats": {"total": 203, "additions": 151, "deletions": 52}, "files": [{"sha": "2ddec9ba424f2009cdebbb755fc048ff84006735", "filename": "src/doc/reference.md", "status": "modified", "additions": 151, "deletions": 52, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/393a37ecbd5fbeda49246dc7f3885af69130151a/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/393a37ecbd5fbeda49246dc7f3885af69130151a/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=393a37ecbd5fbeda49246dc7f3885af69130151a", "patch": "@@ -426,12 +426,12 @@ x;\n x::y::z;\n ```\n \n-Path components are usually [identifiers](#identifiers), but the trailing\n-component of a path may be an angle-bracket-enclosed list of type arguments. In\n-[expression](#expressions) context, the type argument list is given after a\n-final (`::`) namespace qualifier in order to disambiguate it from a relational\n-expression involving the less-than symbol (`<`). In type expression context,\n-the final namespace qualifier is omitted.\n+Path components are usually [identifiers](#identifiers), but they may\n+also include angle-bracket-enclosed lists of type arguments. In\n+[expression](#expressions) context, the type argument list is given\n+after a `::` namespace qualifier in order to disambiguate it from a\n+relational expression involving the less-than symbol (`<`). In type\n+expression context, the final namespace qualifier is omitted.\n \n Two examples of paths with type arguments:\n \n@@ -497,8 +497,9 @@ names, and invoked through a consistent syntax: `some_extension!(...)`.\n \n Users of `rustc` can define new syntax extensions in two ways:\n \n-* [Compiler plugins][plugin] can include arbitrary\n-  Rust code that manipulates syntax trees at compile time.\n+* [Compiler plugins][plugin] can include arbitrary Rust code that\n+  manipulates syntax trees at compile time. Note that the interface\n+  for compiler plugins is considered highly unstable.\n \n * [Macros](book/macros.html) define new syntax in a higher-level,\n   declarative way.\n@@ -560,14 +561,18 @@ Nested repetitions are allowed.\n The parser used by the macro system is reasonably powerful, but the parsing of\n Rust syntax is restricted in two ways:\n \n-1. The parser will always parse as much as possible. If it attempts to match\n-   `$i:expr [ , ]` against `8 [ , ]`, it will attempt to parse `i` as an array\n-   index operation and fail. Adding a separator can solve this problem.\n+1. Macro definitions are required to include suitable separators after parsing\n+   expressions and other bits of the Rust grammar. This implies that\n+   a macro definition like `$i:expr [ , ]` is not legal, because `[` could be part\n+   of an expression. A macro definition like `$i:expr,` or `$i:expr;` would be legal,\n+   however, because `,` and `;` are legal separators. See [RFC 550] for more information.\n 2. The parser must have eliminated all ambiguity by the time it reaches a `$`\n    _name_ `:` _designator_. This requirement most often affects name-designator\n    pairs when they occur at the beginning of, or immediately after, a `$(...)*`;\n    requiring a distinctive token in front can solve the problem.\n \n+[RFC 550]: https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md\n+\n # Crates and source files\n \n Although Rust, like any other language, can be implemented by an interpreter as\n@@ -686,7 +691,8 @@ type arguments as a list of comma-separated types enclosed within angle\n brackets, in order to refer to the type-parameterized item. In practice, the\n type-inference system can usually infer such argument types from context. There\n are no general type-parametric types, only type-parametric items. That is, Rust\n-has no notion of type abstraction: there are no first-class \"forall\" types.\n+has no notion of type abstraction: there are no higher-ranked (or \"forall\") types\n+abstracted over other types, though higher-ranked types do exist for lifetimes.\n \n ### Modules\n \n@@ -732,6 +738,7 @@ mod vec;\n \n mod thread {\n     // Load the `local_data` module from `thread/local_data.rs`\n+    // or `thread/local_data/mod.rs`.\n     mod local_data;\n }\n ```\n@@ -1004,7 +1011,8 @@ the guarantee that these issues are never caused by safe code.\n * `&mut` and `&` follow LLVM\u2019s scoped [noalias] model, except if the `&T`\n   contains an `UnsafeCell<U>`. Unsafe code must not violate these aliasing\n   guarantees.\n-* Mutating an immutable value/reference without `UnsafeCell<U>`\n+* Mutating non-mutable data (that is, data reached through a shared reference or\n+  data owned by a `let` binding), unless that data is contained within an `UnsafeCell<U>`.\n * Invoking undefined behavior via compiler intrinsics:\n   * Indexing outside of the bounds of an object with `std::ptr::offset`\n     (`offset` intrinsic), with\n@@ -1034,9 +1042,13 @@ be undesired.\n * Exiting without calling destructors\n * Sending signals\n * Accessing/modifying the file system\n-* Unsigned integer overflow (well-defined as wrapping)\n-* Signed integer overflow (well-defined as two\u2019s complement representation\n-  wrapping)\n+* Integer overflow\n+  - Overflow is considered \"unexpected\" behavior and is always user-error,\n+    unless the `wrapping` primitives are used. In non-optimized builds, the compiler\n+    will insert debug checks that panic on overflow, but in optimized builds overflow\n+    instead results in wrapped values. See [RFC 560] for the rationale and more details.\n+\n+[RFC 560]: https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md\n \n #### Diverging functions\n \n@@ -1310,11 +1322,26 @@ type of the value is not required to ascribe to `Sync`.\n \n ### Traits\n \n-A _trait_ describes a set of method types.\n+A _trait_ describes an abstract interface that types can\n+implement. This interface consists of associated items, which come in\n+three varieties:\n+\n+- functions\n+- constants\n+- types\n+\n+Associated functions whose first parameter is named `self` are called\n+methods and may be invoked using `.` notation (e.g., `x.foo()`).\n+\n+All traits define an implicit type parameter `Self` that refers to\n+\"the type that is implementing this interface\". Traits may also\n+contain additional type parameters. These type parameters (including\n+`Self`) may be constrained by other traits and so forth as usual.\n \n-Traits can include default implementations of methods, written in terms of some\n-unknown [`self` type](#self-types); the `self` type may either be completely\n-unspecified, or constrained by some other trait.\n+Trait bounds on `Self` are considered \"supertraits\". These are\n+required to be acyclic.  Supertraits are somewhat different from other\n+constraints in that they affect what methods are available in the\n+vtable when the trait is used as a [trait object](#trait-objects).\n \n Traits are implemented for specific types through separate\n [implementations](#implementations).\n@@ -1359,15 +1386,18 @@ fn draw_twice<T: Shape>(surface: Surface, sh: T) {\n }\n ```\n \n-Traits also define an [trait object](#trait-objects) with the same name as the\n-trait. Values of this type are created by [casting](#type-cast-expressions)\n-pointer values (pointing to a type for which an implementation of the given\n-trait is in scope) to pointers to the trait name, used as a type.\n+Traits also define an [trait object](#trait-objects) with the same\n+name as the trait. Values of this type are created by coercing from a\n+pointer of some specific type to a pointer of trait type. For example,\n+`&T` could be coerced to `&Shape` if `T: Shape` holds (and similarly\n+for `Box<T>`). This coercion can either be implicit or\n+[explicit](#type-cast-expressions). Here is an example of an explicit\n+coercion:\n \n ```\n-# trait Shape { fn dummy(&self) { } }\n-# impl Shape for i32 { }\n-# let mycircle = 0i32;\n+trait Shape { }\n+impl Shape for i32 { }\n+let mycircle = 0i32;\n let myshape: Box<Shape> = Box::new(mycircle) as Box<Shape>;\n ```\n \n@@ -2041,7 +2071,8 @@ The name `str_eq` has a special meaning to the Rust compiler, and the presence\n of this definition means that it will use this definition when generating calls\n to the string equality function.\n \n-A complete list of the built-in language items will be added in the future.\n+The set of language items is currently considered unstable. A complete\n+list of the built-in language items will be added in the future.\n \n ### Inline attributes\n \n@@ -2053,11 +2084,6 @@ The compiler automatically inlines functions based on internal heuristics.\n Incorrectly inlining functions can actually make the program slower, so it\n should be used with care.\n \n-Immutable statics are always considered inlineable unless marked with\n-`#[inline(never)]`. It is undefined whether two different inlineable statics\n-have the same memory address. In other words, the compiler is free to collapse\n-duplicate inlineable statics together.\n-\n `#[inline]` and `#[inline(always)]` always cause the function to be serialized\n into the crate metadata to allow cross-crate inlining.\n \n@@ -2259,10 +2285,6 @@ The currently implemented features of the reference compiler are:\n * `unboxed_closures` - Rust's new closure design, which is currently a work in\n                        progress feature with many known bugs.\n \n-* `unsafe_destructor` - Allows use of the `#[unsafe_destructor]` attribute,\n-                        which is considered wildly unsafe and will be\n-                        obsoleted by language improvements.\n-\n * `unsafe_no_drop_flag` - Allows use of the `#[unsafe_no_drop_flag]` attribute,\n                           which removes hidden flag added to a type that\n                           implements the `Drop` trait. The design for the\n@@ -2382,18 +2404,54 @@ expressions](#index-expressions) (`expr[expr]`), and [field\n references](#field-expressions) (`expr.f`). All other expressions are rvalues.\n \n The left operand of an [assignment](#assignment-expressions) or\n-[compound-assignment](#compound-assignment-expressions) expression is an lvalue\n-context, as is the single operand of a unary\n-[borrow](#unary-operator-expressions). All other expression contexts are\n-rvalue contexts.\n+[compound-assignment](#compound-assignment-expressions) expression is\n+an lvalue context, as is the single operand of a unary\n+[borrow](#unary-operator-expressions). The discriminant or subject of\n+a [match expression](#match-expressions) may be an lvalue context, if\n+ref bindings are made, but is otherwise an rvalue context. All other\n+expression contexts are rvalue contexts.\n \n When an lvalue is evaluated in an _lvalue context_, it denotes a memory\n location; when evaluated in an _rvalue context_, it denotes the value held _in_\n that memory location.\n \n-When an rvalue is used in an lvalue context, a temporary un-named lvalue is\n-created and used instead. A temporary's lifetime equals the largest lifetime\n-of any reference that points to it.\n+##### Temporary lifetimes\n+\n+When an rvalue is used in an lvalue context, a temporary un-named\n+lvalue is created and used instead. The lifetime of temporary values\n+is typically the innermost enclosing statement; the tail expression of\n+a block is considered part of the statement that encloses the block.\n+\n+When a temporary rvalue is being created that is assigned into a `let`\n+declaration, however, the temporary is created with the lifetime of\n+the enclosing block instead, as using the enclosing statement (the\n+`let` declaration) would be a guaranteed error (since a pointer to the\n+temporary would be stored into a variable, but the temporary would be\n+freed before the variable could be used). The compiler uses simple\n+syntactic rules to decide which values are being assigned into a `let`\n+binding, and therefore deserve a longer temporary lifetime.\n+\n+Here are some examples:\n+\n+- `let x = foo(&temp())`. The expression `temp()` is an rvalue. As it\n+  is being borrowed, a temporary is created which will be freed after\n+  the innermost enclosing statement (the `let` declaration, in this case).\n+- `let x = temp().foo()`. This is the same as the previous example,\n+  except that the value of `temp()` is being borrowed via autoref on a\n+  method-call. Here we are assuming that `foo()` is an `&self` method\n+  defined in some trait, say `Foo`. In other words, the expression\n+  `temp().foo()` is equivalent to `Foo::foo(&temp())`.\n+- `let x = &temp()`. Here, the same temporary is being assigned into\n+  `x`, rather than being passed as a parameter, and hence the\n+  temporary's lifetime is considered to be the enclosing block.\n+- `let x = SomeStruct { foo: &temp() }`. As in the previous case, the\n+  temporary is assigned into a struct which is then assigned into a\n+  binding, and hence it is given the lifetime of the enclosing block.\n+- `let x = [ &temp() ]`. As in the previous case, the\n+  temporary is assigned into an array which is then assigned into a\n+  binding, and hence it is given the lifetime of the enclosing block.\n+- `let ref x = temp()`. In this case, the temporary is created using a ref binding,\n+  but the result is the same: the lifetime is extended to the enclosing block.\n \n #### Moved and copied types\n \n@@ -2535,8 +2593,10 @@ A field access is an [lvalue](#lvalues,-rvalues-and-temporaries) referring to\n the value of that field. When the type providing the field inherits mutability,\n it can be [assigned](#assignment-expressions) to.\n \n-Also, if the type of the expression to the left of the dot is a pointer, it is\n-automatically dereferenced to make the field access possible.\n+Also, if the type of the expression to the left of the dot is a\n+pointer, it is automatically dereferenced as many times as necessary\n+to make the field access possible. In cases of ambiguity, we prefer\n+fewer autoderefs to more.\n \n ### Array expressions\n \n@@ -2577,6 +2637,11 @@ let arr = [\"a\", \"b\"];\n arr[10]; // panics\n ```\n \n+Also, if the type of the expression to the left of the brackets is a\n+pointer, it is automatically dereferenced as many times as necessary\n+to make the indexing possible. In cases of ambiguity, we prefer fewer\n+autoderefs to more.\n+\n ### Range expressions\n \n The `..` operator will construct an object of one of the `std::ops::Range` variants.\n@@ -2599,7 +2664,7 @@ assert_eq!(x,y);\n \n ### Unary operator expressions\n \n-Rust defines three unary operators. They are all written as prefix operators,\n+Rust defines the following unary operators. They are all written as prefix operators,\n before the expression they apply to.\n \n * `-`\n@@ -2613,11 +2678,20 @@ before the expression they apply to.\n     implemented by the type and required for an outer expression that will or\n     could mutate the dereference), and produces the result of dereferencing the\n     `&` or `&mut` borrowed pointer returned from the overload method.\n-\n * `!`\n   : Logical negation. On the boolean type, this flips between `true` and\n     `false`. On integer types, this inverts the individual bits in the\n     two's complement representation of the value.\n+* `&` and `&mut`\n+  : Borrowing. When applied to an lvalue, these operators produce a\n+    reference (pointer) to the lvalue. The lvalue is also placed into\n+    a borrowed state for the duration of the reference. For a shared\n+    borrow (`&`), this implies that the lvalue may not be mutated, but\n+    it may be read or shared again. For a mutable borrow (`&mut`), the\n+    lvalue may not be accessed in any way until the borrow expires.\n+    If the `&` or `&mut` operators are applied to an rvalue, a\n+    temporary value is created; the lifetime of this temporary value\n+    is defined by [syntactic rules](#temporary-lifetimes).\n \n ### Binary operator expressions\n \n@@ -2727,6 +2801,13 @@ fn avg(v: &[f64]) -> f64 {\n }\n ```\n \n+Some of the conversions which can be done through the `as` operator\n+can also be done implicitly at various points in the program, such as\n+argument passing and assignment to a `let` binding with an explicit\n+type. Implicit conversions are limited to \"harmless\" conversions that\n+do not lose information and which have minimal or no risk of\n+surprising side-effects on the dynamic execution semantics.\n+\n #### Assignment expressions\n \n An _assignment expression_ consists of an\n@@ -3348,6 +3429,22 @@ let bo: Binop = add;\n x = bo(5,7);\n ```\n \n+#### Function types for specific items\n+\n+Internally to the compiler, there are also function types that are specific to a particular\n+function item. In the following snippet, for example, the internal types of the functions\n+`foo` and `bar` are different, despite the fact that they have the same signature:\n+\n+```\n+fn foo() { }\n+fn bar() { }\n+```\n+\n+The types of `foo` and `bar` can both be implicitly coerced to the fn\n+pointer type `fn()`. There is currently no syntax for unique fn types,\n+though the compiler will emit a type like `fn() {foo}` in error\n+messages to indicate \"the unique fn type for the function `foo`\".\n+\n ### Closure types\n \n A [lambda expression](#lambda-expressions) produces a closure value with\n@@ -3432,8 +3529,9 @@ has type `Vec<A>`, a vector with element type `A`.\n \n ### Self types\n \n-The special type `self` has a meaning within methods inside an impl item. It\n-refers to the type of the implicit `self` argument. For example, in:\n+The special type `Self` has a meaning within traits and impls. In a trait definition, it refers\n+to an implicit type parameter representing the \"implementing\" type. In an impl,\n+it is an alias for the implementing type. For example, in:\n \n ```\n trait Printable {\n@@ -3447,8 +3545,9 @@ impl Printable for String {\n }\n ```\n \n-`self` refers to the value of type `String` that is the receiver for a call to\n-the method `make_string`.\n+The notation `&self` is a shorthand for `self: &Self`. In this case,\n+in the impl, `Self` refers to the value of type `String` that is the\n+receiver for a call to the method `make_string`.\n \n # Special traits\n "}]}