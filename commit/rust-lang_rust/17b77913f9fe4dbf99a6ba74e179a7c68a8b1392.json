{"sha": "17b77913f9fe4dbf99a6ba74e179a7c68a8b1392", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3Yjc3OTEzZjlmZTRkYmY5OWE2YmE3NGUxNzlhN2M2OGE4YjEzOTI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-08T10:51:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-08T10:51:18Z"}, "message": "Rollup merge of #69805 - petrochenkov:importname, r=Centril\n\nresolve: Modernize some naming\n\n`ImportDirective` -> `Import`\n`ImportDirectiveSubclass` -> `ImportKind`\n`ImportKind::SingleImport` -> `ImportKind::Single`\n`ImportKind::GlobImport` -> `ImportKind::Glob`", "tree": {"sha": "bd6f29d9de99bc012da0e109385d9b5c31163e58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd6f29d9de99bc012da0e109385d9b5c31163e58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17b77913f9fe4dbf99a6ba74e179a7c68a8b1392", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeZM4mCRBK7hj4Ov3rIwAAdHIIADs6gCssTEzHwXIq9hxZcCw2\nKrXvjsjjq+6DVNklXn7zEpBST4LYqW12c2w98apbll60IztBT3qwF+mLOM9UUglj\np9xkucRU6sHv7H46W6AFiRYdvgUZLDwHievnq9UfZdnFg1wssCmKwaBWlRyHYL1e\n+6gdT+5+gYKIw8Op5xu7IKL0ygrLtv+LTmSJUvXvyjYkuOGCg3kMAIXpjeRudJo/\nitXBtNxREWiAJmPoLyDNCOZ0OdCVJ5plabjWBsC25+biH0twncCtsNUHKeOlhCF7\nqjiMvT2KmmjhDD/zAu9svfuOsTEotxS9nuFsgnrUa4TVv56J7rAeDcVKQqdq2Xc=\n=FPJV\n-----END PGP SIGNATURE-----\n", "payload": "tree bd6f29d9de99bc012da0e109385d9b5c31163e58\nparent f497325b13fea12b5771b0f123880847598dd9d1\nparent 66d7a88c41ebcc25e499babd103177a9d8df6cdb\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1583664678 +0100\ncommitter GitHub <noreply@github.com> 1583664678 +0100\n\nRollup merge of #69805 - petrochenkov:importname, r=Centril\n\nresolve: Modernize some naming\n\n`ImportDirective` -> `Import`\n`ImportDirectiveSubclass` -> `ImportKind`\n`ImportKind::SingleImport` -> `ImportKind::Single`\n`ImportKind::GlobImport` -> `ImportKind::Glob`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17b77913f9fe4dbf99a6ba74e179a7c68a8b1392", "html_url": "https://github.com/rust-lang/rust/commit/17b77913f9fe4dbf99a6ba74e179a7c68a8b1392", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17b77913f9fe4dbf99a6ba74e179a7c68a8b1392/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f497325b13fea12b5771b0f123880847598dd9d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f497325b13fea12b5771b0f123880847598dd9d1", "html_url": "https://github.com/rust-lang/rust/commit/f497325b13fea12b5771b0f123880847598dd9d1"}, {"sha": "66d7a88c41ebcc25e499babd103177a9d8df6cdb", "url": "https://api.github.com/repos/rust-lang/rust/commits/66d7a88c41ebcc25e499babd103177a9d8df6cdb", "html_url": "https://github.com/rust-lang/rust/commit/66d7a88c41ebcc25e499babd103177a9d8df6cdb"}], "stats": {"total": 608, "additions": 283, "deletions": 325}, "files": [{"sha": "ec5a8c4a0b896c92ed7322be9c9489130591c162", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 32, "deletions": 45, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/17b77913f9fe4dbf99a6ba74e179a7c68a8b1392/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17b77913f9fe4dbf99a6ba74e179a7c68a8b1392/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=17b77913f9fe4dbf99a6ba74e179a7c68a8b1392", "patch": "@@ -6,8 +6,7 @@\n //! Imports are also considered items and placed into modules here, but not resolved yet.\n \n use crate::def_collector::collect_definitions;\n-use crate::imports::ImportDirective;\n-use crate::imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n+use crate::imports::{Import, ImportKind};\n use crate::macros::{LegacyBinding, LegacyScope};\n use crate::Namespace::{self, MacroNS, TypeNS, ValueNS};\n use crate::{CrateLint, Determinacy, PathResult, ResolutionError, VisResolutionError};\n@@ -308,11 +307,11 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         })\n     }\n \n-    // Add an import directive to the current module.\n-    fn add_import_directive(\n+    // Add an import to the current module.\n+    fn add_import(\n         &mut self,\n         module_path: Vec<Segment>,\n-        subclass: ImportDirectiveSubclass<'a>,\n+        kind: ImportKind<'a>,\n         span: Span,\n         id: NodeId,\n         item: &ast::Item,\n@@ -321,11 +320,11 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         vis: ty::Visibility,\n     ) {\n         let current_module = self.parent_scope.module;\n-        let directive = self.r.arenas.alloc_import_directive(ImportDirective {\n+        let import = self.r.arenas.alloc_import(Import {\n+            kind,\n             parent_scope: self.parent_scope,\n             module_path,\n             imported_module: Cell::new(None),\n-            subclass,\n             span,\n             id,\n             use_span: item.span,\n@@ -337,25 +336,25 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             used: Cell::new(false),\n         });\n \n-        debug!(\"add_import_directive({:?})\", directive);\n+        debug!(\"add_import({:?})\", import);\n \n-        self.r.indeterminate_imports.push(directive);\n-        match directive.subclass {\n+        self.r.indeterminate_imports.push(import);\n+        match import.kind {\n             // Don't add unresolved underscore imports to modules\n-            SingleImport { target: Ident { name: kw::Underscore, .. }, .. } => {}\n-            SingleImport { target, type_ns_only, .. } => {\n+            ImportKind::Single { target: Ident { name: kw::Underscore, .. }, .. } => {}\n+            ImportKind::Single { target, type_ns_only, .. } => {\n                 self.r.per_ns(|this, ns| {\n                     if !type_ns_only || ns == TypeNS {\n                         let key = this.new_key(target, ns);\n                         let mut resolution = this.resolution(current_module, key).borrow_mut();\n-                        resolution.add_single_import(directive);\n+                        resolution.add_single_import(import);\n                     }\n                 });\n             }\n             // We don't add prelude imports to the globs since they only affect lexical scopes,\n             // which are not relevant to import resolution.\n-            GlobImport { is_prelude: true, .. } => {}\n-            GlobImport { .. } => current_module.globs.borrow_mut().push(directive),\n+            ImportKind::Glob { is_prelude: true, .. } => {}\n+            ImportKind::Glob { .. } => current_module.globs.borrow_mut().push(import),\n             _ => unreachable!(),\n         }\n     }\n@@ -480,7 +479,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     );\n                 }\n \n-                let subclass = SingleImport {\n+                let kind = ImportKind::Single {\n                     source: source.ident,\n                     target: ident,\n                     source_bindings: PerNS {\n@@ -496,9 +495,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     type_ns_only,\n                     nested,\n                 };\n-                self.add_import_directive(\n+                self.add_import(\n                     module_path,\n-                    subclass,\n+                    kind,\n                     use_tree.span,\n                     id,\n                     item,\n@@ -508,20 +507,11 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 );\n             }\n             ast::UseTreeKind::Glob => {\n-                let subclass = GlobImport {\n+                let kind = ImportKind::Glob {\n                     is_prelude: attr::contains_name(&item.attrs, sym::prelude_import),\n                     max_vis: Cell::new(ty::Visibility::Invisible),\n                 };\n-                self.add_import_directive(\n-                    prefix,\n-                    subclass,\n-                    use_tree.span,\n-                    id,\n-                    item,\n-                    root_span,\n-                    item.id,\n-                    vis,\n-                );\n+                self.add_import(prefix, kind, use_tree.span, id, item, root_span, item.id, vis);\n             }\n             ast::UseTreeKind::Nested(ref items) => {\n                 // Ensure there is at most one `self` in the list\n@@ -637,15 +627,12 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 let used = self.process_legacy_macro_imports(item, module);\n                 let binding =\n                     (module, ty::Visibility::Public, sp, expansion).to_name_binding(self.r.arenas);\n-                let directive = self.r.arenas.alloc_import_directive(ImportDirective {\n+                let import = self.r.arenas.alloc_import(Import {\n+                    kind: ImportKind::ExternCrate { source: orig_name, target: ident },\n                     root_id: item.id,\n                     id: item.id,\n                     parent_scope: self.parent_scope,\n                     imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n-                    subclass: ImportDirectiveSubclass::ExternCrate {\n-                        source: orig_name,\n-                        target: ident,\n-                    },\n                     has_attributes: !item.attrs.is_empty(),\n                     use_span_with_attributes: item.span_with_attributes(),\n                     use_span: item.span,\n@@ -655,8 +642,8 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     vis: Cell::new(vis),\n                     used: Cell::new(used),\n                 });\n-                self.r.potentially_unused_imports.push(directive);\n-                let imported_binding = self.r.import(binding, directive);\n+                self.r.potentially_unused_imports.push(import);\n+                let imported_binding = self.r.import(binding, import);\n                 if ptr::eq(parent, self.r.graph_root) {\n                     if let Some(entry) = self.r.extern_prelude.get(&ident.modern()) {\n                         if expansion != ExpnId::root()\n@@ -992,13 +979,13 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             }\n         }\n \n-        let macro_use_directive = |this: &Self, span| {\n-            this.r.arenas.alloc_import_directive(ImportDirective {\n+        let macro_use_import = |this: &Self, span| {\n+            this.r.arenas.alloc_import(Import {\n+                kind: ImportKind::MacroUse,\n                 root_id: item.id,\n                 id: item.id,\n                 parent_scope: this.parent_scope,\n                 imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n-                subclass: ImportDirectiveSubclass::MacroUse,\n                 use_span_with_attributes: item.span_with_attributes(),\n                 has_attributes: !item.attrs.is_empty(),\n                 use_span: item.span,\n@@ -1012,11 +999,11 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n         let allow_shadowing = self.parent_scope.expansion == ExpnId::root();\n         if let Some(span) = import_all {\n-            let directive = macro_use_directive(self, span);\n-            self.r.potentially_unused_imports.push(directive);\n+            let import = macro_use_import(self, span);\n+            self.r.potentially_unused_imports.push(import);\n             module.for_each_child(self, |this, ident, ns, binding| {\n                 if ns == MacroNS {\n-                    let imported_binding = this.r.import(binding, directive);\n+                    let imported_binding = this.r.import(binding, import);\n                     this.legacy_import_macro(ident.name, imported_binding, span, allow_shadowing);\n                 }\n             });\n@@ -1031,9 +1018,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     ident.span,\n                 );\n                 if let Ok(binding) = result {\n-                    let directive = macro_use_directive(self, ident.span);\n-                    self.r.potentially_unused_imports.push(directive);\n-                    let imported_binding = self.r.import(binding, directive);\n+                    let import = macro_use_import(self, ident.span);\n+                    self.r.potentially_unused_imports.push(import);\n+                    let imported_binding = self.r.import(binding, import);\n                     self.legacy_import_macro(\n                         ident.name,\n                         imported_binding,"}, {"sha": "722f843ab6e7ead20f33305bcde33f7613e342ba", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/17b77913f9fe4dbf99a6ba74e179a7c68a8b1392/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17b77913f9fe4dbf99a6ba74e179a7c68a8b1392/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=17b77913f9fe4dbf99a6ba74e179a7c68a8b1392", "patch": "@@ -3,7 +3,7 @@\n //\n // Although this is mostly a lint pass, it lives in here because it depends on\n // resolve data structures and because it finalises the privacy information for\n-// `use` directives.\n+// `use` items.\n //\n // Unused trait imports can't be checked until the method resolution. We save\n // candidates here, and do the actual check in librustc_typeck/check_unused.rs.\n@@ -23,7 +23,7 @@\n //  - `check_crate` finally emits the diagnostics based on the data generated\n //    in the last step\n \n-use crate::imports::ImportDirectiveSubclass;\n+use crate::imports::ImportKind;\n use crate::Resolver;\n \n use rustc::{lint, ty};\n@@ -58,7 +58,7 @@ struct UnusedImportCheckVisitor<'a, 'b> {\n }\n \n impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n-    // We have information about whether `use` (import) directives are actually\n+    // We have information about whether `use` (import) items are actually\n     // used now. If an import is not used at all, we signal a lint error.\n     fn check_import(&mut self, id: ast::NodeId) {\n         let mut used = false;\n@@ -223,33 +223,33 @@ fn calc_unused_spans(\n \n impl Resolver<'_> {\n     crate fn check_unused(&mut self, krate: &ast::Crate) {\n-        for directive in self.potentially_unused_imports.iter() {\n-            match directive.subclass {\n-                _ if directive.used.get()\n-                    || directive.vis.get() == ty::Visibility::Public\n-                    || directive.span.is_dummy() =>\n+        for import in self.potentially_unused_imports.iter() {\n+            match import.kind {\n+                _ if import.used.get()\n+                    || import.vis.get() == ty::Visibility::Public\n+                    || import.span.is_dummy() =>\n                 {\n-                    if let ImportDirectiveSubclass::MacroUse = directive.subclass {\n-                        if !directive.span.is_dummy() {\n+                    if let ImportKind::MacroUse = import.kind {\n+                        if !import.span.is_dummy() {\n                             self.lint_buffer.buffer_lint(\n                                 lint::builtin::MACRO_USE_EXTERN_CRATE,\n-                                directive.id,\n-                                directive.span,\n-                                \"deprecated `#[macro_use]` directive used to \\\n+                                import.id,\n+                                import.span,\n+                                \"deprecated `#[macro_use]` attribute used to \\\n                                 import macros should be replaced at use sites \\\n-                                with a `use` statement to import the macro \\\n+                                with a `use` item to import the macro \\\n                                 instead\",\n                             );\n                         }\n                     }\n                 }\n-                ImportDirectiveSubclass::ExternCrate { .. } => {\n-                    self.maybe_unused_extern_crates.push((directive.id, directive.span));\n+                ImportKind::ExternCrate { .. } => {\n+                    self.maybe_unused_extern_crates.push((import.id, import.span));\n                 }\n-                ImportDirectiveSubclass::MacroUse => {\n+                ImportKind::MacroUse => {\n                     let lint = lint::builtin::UNUSED_IMPORTS;\n                     let msg = \"unused `#[macro_use]` import\";\n-                    self.lint_buffer.buffer_lint(lint, directive.id, directive.span, msg);\n+                    self.lint_buffer.buffer_lint(lint, import.id, import.span, msg);\n                 }\n                 _ => {}\n             }"}, {"sha": "47a05ec90d42fc8cfa7427f8da3577cf29f0f226", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/17b77913f9fe4dbf99a6ba74e179a7c68a8b1392/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17b77913f9fe4dbf99a6ba74e179a7c68a8b1392/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=17b77913f9fe4dbf99a6ba74e179a7c68a8b1392", "patch": "@@ -18,7 +18,7 @@ use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{BytePos, MultiSpan, Span};\n \n-use crate::imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n+use crate::imports::{Import, ImportKind, ImportResolver};\n use crate::path_names_to_string;\n use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind};\n use crate::{BindingError, CrateLint, HasGenericParams, LegacyScope, Module, ModuleOrUniformRoot};\n@@ -1125,7 +1125,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     /// ```\n     pub(crate) fn check_for_module_export_macro(\n         &mut self,\n-        directive: &'b ImportDirective<'b>,\n+        import: &'b Import<'b>,\n         module: ModuleOrUniformRoot<'b>,\n         ident: Ident,\n     ) -> Option<(Option<Suggestion>, Vec<String>)> {\n@@ -1150,28 +1150,26 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         let binding = resolution.borrow().binding()?;\n         if let Res::Def(DefKind::Macro(MacroKind::Bang), _) = binding.res() {\n             let module_name = crate_module.kind.name().unwrap();\n-            let import = match directive.subclass {\n-                ImportDirectiveSubclass::SingleImport { source, target, .. }\n-                    if source != target =>\n-                {\n+            let import_snippet = match import.kind {\n+                ImportKind::Single { source, target, .. } if source != target => {\n                     format!(\"{} as {}\", source, target)\n                 }\n                 _ => format!(\"{}\", ident),\n             };\n \n             let mut corrections: Vec<(Span, String)> = Vec::new();\n-            if !directive.is_nested() {\n+            if !import.is_nested() {\n                 // Assume this is the easy case of `use issue_59764::foo::makro;` and just remove\n                 // intermediate segments.\n-                corrections.push((directive.span, format!(\"{}::{}\", module_name, import)));\n+                corrections.push((import.span, format!(\"{}::{}\", module_name, import_snippet)));\n             } else {\n                 // Find the binding span (and any trailing commas and spaces).\n                 //   ie. `use a::b::{c, d, e};`\n                 //                      ^^^\n                 let (found_closing_brace, binding_span) = find_span_of_binding_until_next_binding(\n                     self.r.session,\n-                    directive.span,\n-                    directive.use_span,\n+                    import.span,\n+                    import.use_span,\n                 );\n                 debug!(\n                     \"check_for_module_export_macro: found_closing_brace={:?} binding_span={:?}\",\n@@ -1208,7 +1206,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 let (has_nested, after_crate_name) = find_span_immediately_after_crate_name(\n                     self.r.session,\n                     module_name,\n-                    directive.use_span,\n+                    import.use_span,\n                 );\n                 debug!(\n                     \"check_for_module_export_macro: has_nested={:?} after_crate_name={:?}\",\n@@ -1224,11 +1222,11 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         start_point,\n                         if has_nested {\n                             // In this case, `start_snippet` must equal '{'.\n-                            format!(\"{}{}, \", start_snippet, import)\n+                            format!(\"{}{}, \", start_snippet, import_snippet)\n                         } else {\n                             // In this case, add a `{`, then the moved import, then whatever\n                             // was there before.\n-                            format!(\"{{{}, {}\", import, start_snippet)\n+                            format!(\"{{{}, {}\", import_snippet, start_snippet)\n                         },\n                     ));\n                 }"}, {"sha": "485b86636a0bada0519a90e7a3e23bfb15bfd8d9", "filename": "src/librustc_resolve/imports.rs", "status": "modified", "additions": 169, "deletions": 191, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/17b77913f9fe4dbf99a6ba74e179a7c68a8b1392/src%2Flibrustc_resolve%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17b77913f9fe4dbf99a6ba74e179a7c68a8b1392/src%2Flibrustc_resolve%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fimports.rs?ref=17b77913f9fe4dbf99a6ba74e179a7c68a8b1392", "patch": "@@ -1,7 +1,5 @@\n //! A bunch of methods and structures more or less related to resolving imports.\n \n-use ImportDirectiveSubclass::*;\n-\n use crate::diagnostics::Suggestion;\n use crate::Determinacy::{self, *};\n use crate::Namespace::{self, MacroNS, TypeNS};\n@@ -36,10 +34,10 @@ use std::{mem, ptr};\n \n type Res = def::Res<NodeId>;\n \n-/// Contains data for specific types of import directives.\n+/// Contains data for specific kinds of imports.\n #[derive(Clone, Debug)]\n-pub enum ImportDirectiveSubclass<'a> {\n-    SingleImport {\n+pub enum ImportKind<'a> {\n+    Single {\n         /// `source` in `use prefix::source as target`.\n         source: Ident,\n         /// `target` in `use prefix::source as target`.\n@@ -53,7 +51,7 @@ pub enum ImportDirectiveSubclass<'a> {\n         /// Did this import result from a nested import? ie. `use foo::{bar, baz};`\n         nested: bool,\n     },\n-    GlobImport {\n+    Glob {\n         is_prelude: bool,\n         max_vis: Cell<ty::Visibility>, // The visibility of the greatest re-export.\n                                        // n.b. `max_vis` is only used in `finalize_import` to check for re-export errors.\n@@ -65,19 +63,21 @@ pub enum ImportDirectiveSubclass<'a> {\n     MacroUse,\n }\n \n-/// One import directive.\n+/// One import.\n #[derive(Debug, Clone)]\n-crate struct ImportDirective<'a> {\n-    /// The ID of the `extern crate`, `UseTree` etc that imported this `ImportDirective`.\n+crate struct Import<'a> {\n+    pub kind: ImportKind<'a>,\n+\n+    /// The ID of the `extern crate`, `UseTree` etc that imported this `Import`.\n     ///\n-    /// In the case where the `ImportDirective` was expanded from a \"nested\" use tree,\n+    /// In the case where the `Import` was expanded from a \"nested\" use tree,\n     /// this id is the ID of the leaf tree. For example:\n     ///\n     /// ```ignore (pacify the mercilous tidy)\n     /// use foo::bar::{a, b}\n     /// ```\n     ///\n-    /// If this is the import directive for `foo::bar::a`, we would have the ID of the `UseTree`\n+    /// If this is the import for `foo::bar::a`, we would have the ID of the `UseTree`\n     /// for `a` in this field.\n     pub id: NodeId,\n \n@@ -107,22 +107,21 @@ crate struct ImportDirective<'a> {\n     pub module_path: Vec<Segment>,\n     /// The resolution of `module_path`.\n     pub imported_module: Cell<Option<ModuleOrUniformRoot<'a>>>,\n-    pub subclass: ImportDirectiveSubclass<'a>,\n     pub vis: Cell<ty::Visibility>,\n     pub used: Cell<bool>,\n }\n \n-impl<'a> ImportDirective<'a> {\n+impl<'a> Import<'a> {\n     pub fn is_glob(&self) -> bool {\n-        match self.subclass {\n-            ImportDirectiveSubclass::GlobImport { .. } => true,\n+        match self.kind {\n+            ImportKind::Glob { .. } => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_nested(&self) -> bool {\n-        match self.subclass {\n-            ImportDirectiveSubclass::SingleImport { nested, .. } => nested,\n+        match self.kind {\n+            ImportKind::Single { nested, .. } => nested,\n             _ => false,\n         }\n     }\n@@ -136,8 +135,8 @@ impl<'a> ImportDirective<'a> {\n /// Records information about the resolution of a name in a namespace of a module.\n pub struct NameResolution<'a> {\n     /// Single imports that may define the name in the namespace.\n-    /// Import directives are arena-allocated, so it's ok to use pointers as keys.\n-    single_imports: FxHashSet<PtrKey<'a, ImportDirective<'a>>>,\n+    /// Imports are arena-allocated, so it's ok to use pointers as keys.\n+    single_imports: FxHashSet<PtrKey<'a, Import<'a>>>,\n     /// The least shadowable known binding for this name, or None if there are no known bindings.\n     pub binding: Option<&'a NameBinding<'a>>,\n     shadowed_glob: Option<&'a NameBinding<'a>>,\n@@ -155,8 +154,8 @@ impl<'a> NameResolution<'a> {\n         })\n     }\n \n-    crate fn add_single_import(&mut self, directive: &'a ImportDirective<'a>) {\n-        self.single_imports.insert(PtrKey(directive));\n+    crate fn add_single_import(&mut self, import: &'a Import<'a>) {\n+        self.single_imports.insert(PtrKey(import));\n     }\n }\n \n@@ -348,8 +347,8 @@ impl<'a> Resolver<'a> {\n                 single_import.imported_module.get(),\n                 return Err((Undetermined, Weak::No))\n             );\n-            let ident = match single_import.subclass {\n-                SingleImport { source, .. } => source,\n+            let ident = match single_import.kind {\n+                ImportKind::Single { source, .. } => source,\n                 _ => unreachable!(),\n             };\n             match self.resolve_ident_in_module(\n@@ -451,34 +450,34 @@ impl<'a> Resolver<'a> {\n         Err((Determined, Weak::No))\n     }\n \n-    // Given a binding and an import directive that resolves to it,\n-    // return the corresponding binding defined by the import directive.\n+    // Given a binding and an import that resolves to it,\n+    // return the corresponding binding defined by the import.\n     crate fn import(\n         &self,\n         binding: &'a NameBinding<'a>,\n-        directive: &'a ImportDirective<'a>,\n+        import: &'a Import<'a>,\n     ) -> &'a NameBinding<'a> {\n-        let vis = if binding.pseudo_vis().is_at_least(directive.vis.get(), self) ||\n+        let vis = if binding.pseudo_vis().is_at_least(import.vis.get(), self) ||\n                      // cf. `PUB_USE_OF_PRIVATE_EXTERN_CRATE`\n-                     !directive.is_glob() && binding.is_extern_crate()\n+                     !import.is_glob() && binding.is_extern_crate()\n         {\n-            directive.vis.get()\n+            import.vis.get()\n         } else {\n             binding.pseudo_vis()\n         };\n \n-        if let GlobImport { ref max_vis, .. } = directive.subclass {\n-            if vis == directive.vis.get() || vis.is_at_least(max_vis.get(), self) {\n+        if let ImportKind::Glob { ref max_vis, .. } = import.kind {\n+            if vis == import.vis.get() || vis.is_at_least(max_vis.get(), self) {\n                 max_vis.set(vis)\n             }\n         }\n \n         self.arenas.alloc_name_binding(NameBinding {\n-            kind: NameBindingKind::Import { binding, directive, used: Cell::new(false) },\n+            kind: NameBindingKind::Import { binding, import, used: Cell::new(false) },\n             ambiguity: None,\n-            span: directive.span,\n+            span: import.span,\n             vis,\n-            expansion: directive.parent_scope.expansion,\n+            expansion: import.parent_scope.expansion,\n         })\n     }\n \n@@ -577,17 +576,17 @@ impl<'a> Resolver<'a> {\n         };\n \n         // Define `binding` in `module`s glob importers.\n-        for directive in module.glob_importers.borrow_mut().iter() {\n+        for import in module.glob_importers.borrow_mut().iter() {\n             let mut ident = key.ident;\n-            let scope = match ident.span.reverse_glob_adjust(module.expansion, directive.span) {\n+            let scope = match ident.span.reverse_glob_adjust(module.expansion, import.span) {\n                 Some(Some(def)) => self.macro_def_scope(def),\n-                Some(None) => directive.parent_scope.module,\n+                Some(None) => import.parent_scope.module,\n                 None => continue,\n             };\n             if self.is_accessible_from(binding.vis, scope) {\n-                let imported_binding = self.import(binding, directive);\n+                let imported_binding = self.import(binding, import);\n                 let key = BindingKey { ident, ..key };\n-                let _ = self.try_define(directive.parent_scope.module, key, imported_binding);\n+                let _ = self.try_define(import.parent_scope.module, key, imported_binding);\n             }\n         }\n \n@@ -596,13 +595,13 @@ impl<'a> Resolver<'a> {\n \n     // Define a \"dummy\" resolution containing a Res::Err as a placeholder for a\n     // failed resolution\n-    fn import_dummy_binding(&mut self, directive: &'a ImportDirective<'a>) {\n-        if let SingleImport { target, .. } = directive.subclass {\n+    fn import_dummy_binding(&mut self, import: &'a Import<'a>) {\n+        if let ImportKind::Single { target, .. } = import.kind {\n             let dummy_binding = self.dummy_binding;\n-            let dummy_binding = self.import(dummy_binding, directive);\n+            let dummy_binding = self.import(dummy_binding, import);\n             self.per_ns(|this, ns| {\n                 let key = this.new_key(target, ns);\n-                let _ = this.try_define(directive.parent_scope.module, key, dummy_binding);\n+                let _ = this.try_define(import.parent_scope.module, key, dummy_binding);\n                 // Consider erroneous imports used to avoid duplicate diagnostics.\n                 this.record_use(target, ns, dummy_binding, false);\n             });\n@@ -671,7 +670,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             .chain(indeterminate_imports.into_iter().map(|i| (true, i)))\n         {\n             if let Some(err) = self.finalize_import(import) {\n-                if let SingleImport { source, ref source_bindings, .. } = import.subclass {\n+                if let ImportKind::Single { source, ref source_bindings, .. } = import.kind {\n                     if source.name == kw::SelfLower {\n                         // Silence `unresolved import` error if E0429 is already emitted\n                         if let Err(Determined) = source_bindings.value_ns.get() {\n@@ -695,7 +694,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 if seen_spans.insert(err.span) {\n                     let path = import_path_to_string(\n                         &import.module_path.iter().map(|seg| seg.ident).collect::<Vec<_>>(),\n-                        &import.subclass,\n+                        &import.kind,\n                         err.span,\n                     );\n                     errors.push((path, err));\n@@ -706,7 +705,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 self.r.used_imports.insert((import.id, TypeNS));\n                 let path = import_path_to_string(\n                     &import.module_path.iter().map(|seg| seg.ident).collect::<Vec<_>>(),\n-                    &import.subclass,\n+                    &import.kind,\n                     import.span,\n                 );\n                 let err = UnresolvedImportError {\n@@ -767,28 +766,28 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n     /// Attempts to resolve the given import, returning true if its resolution is determined.\n     /// If successful, the resolved bindings are written into the module.\n-    fn resolve_import(&mut self, directive: &'b ImportDirective<'b>) -> bool {\n+    fn resolve_import(&mut self, import: &'b Import<'b>) -> bool {\n         debug!(\n             \"(resolving import for module) resolving import `{}::...` in `{}`\",\n-            Segment::names_to_string(&directive.module_path),\n-            module_to_string(directive.parent_scope.module).unwrap_or_else(|| \"???\".to_string()),\n+            Segment::names_to_string(&import.module_path),\n+            module_to_string(import.parent_scope.module).unwrap_or_else(|| \"???\".to_string()),\n         );\n \n-        let module = if let Some(module) = directive.imported_module.get() {\n+        let module = if let Some(module) = import.imported_module.get() {\n             module\n         } else {\n             // For better failure detection, pretend that the import will\n             // not define any names while resolving its module path.\n-            let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n+            let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n             let path_res = self.r.resolve_path(\n-                &directive.module_path,\n+                &import.module_path,\n                 None,\n-                &directive.parent_scope,\n+                &import.parent_scope,\n                 false,\n-                directive.span,\n-                directive.crate_lint(),\n+                import.span,\n+                import.crate_lint(),\n             );\n-            directive.vis.set(orig_vis);\n+            import.vis.set(orig_vis);\n \n             match path_res {\n                 PathResult::Module(module) => module,\n@@ -797,68 +796,67 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             }\n         };\n \n-        directive.imported_module.set(Some(module));\n-        let (source, target, source_bindings, target_bindings, type_ns_only) =\n-            match directive.subclass {\n-                SingleImport {\n-                    source,\n-                    target,\n-                    ref source_bindings,\n-                    ref target_bindings,\n-                    type_ns_only,\n-                    ..\n-                } => (source, target, source_bindings, target_bindings, type_ns_only),\n-                GlobImport { .. } => {\n-                    self.resolve_glob_import(directive);\n-                    return true;\n-                }\n-                _ => unreachable!(),\n-            };\n+        import.imported_module.set(Some(module));\n+        let (source, target, source_bindings, target_bindings, type_ns_only) = match import.kind {\n+            ImportKind::Single {\n+                source,\n+                target,\n+                ref source_bindings,\n+                ref target_bindings,\n+                type_ns_only,\n+                ..\n+            } => (source, target, source_bindings, target_bindings, type_ns_only),\n+            ImportKind::Glob { .. } => {\n+                self.resolve_glob_import(import);\n+                return true;\n+            }\n+            _ => unreachable!(),\n+        };\n \n         let mut indeterminate = false;\n         self.r.per_ns(|this, ns| {\n             if !type_ns_only || ns == TypeNS {\n                 if let Err(Undetermined) = source_bindings[ns].get() {\n                     // For better failure detection, pretend that the import will\n                     // not define any names while resolving its module path.\n-                    let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n+                    let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n                     let binding = this.resolve_ident_in_module(\n                         module,\n                         source,\n                         ns,\n-                        &directive.parent_scope,\n+                        &import.parent_scope,\n                         false,\n-                        directive.span,\n+                        import.span,\n                     );\n-                    directive.vis.set(orig_vis);\n+                    import.vis.set(orig_vis);\n \n                     source_bindings[ns].set(binding);\n                 } else {\n                     return;\n                 };\n \n-                let parent = directive.parent_scope.module;\n+                let parent = import.parent_scope.module;\n                 match source_bindings[ns].get() {\n                     Err(Undetermined) => indeterminate = true,\n                     // Don't update the resolution, because it was never added.\n                     Err(Determined) if target.name == kw::Underscore => {}\n                     Err(Determined) => {\n                         let key = this.new_key(target, ns);\n                         this.update_resolution(parent, key, |_, resolution| {\n-                            resolution.single_imports.remove(&PtrKey(directive));\n+                            resolution.single_imports.remove(&PtrKey(import));\n                         });\n                     }\n                     Ok(binding) if !binding.is_importable() => {\n                         let msg = format!(\"`{}` is not directly importable\", target);\n-                        struct_span_err!(this.session, directive.span, E0253, \"{}\", &msg)\n-                            .span_label(directive.span, \"cannot be imported directly\")\n+                        struct_span_err!(this.session, import.span, E0253, \"{}\", &msg)\n+                            .span_label(import.span, \"cannot be imported directly\")\n                             .emit();\n                         // Do not import this illegal binding. Import a dummy binding and pretend\n                         // everything is fine\n-                        this.import_dummy_binding(directive);\n+                        this.import_dummy_binding(import);\n                     }\n                     Ok(binding) => {\n-                        let imported_binding = this.import(binding, directive);\n+                        let imported_binding = this.import(binding, import);\n                         target_bindings[ns].set(Some(imported_binding));\n                         this.define(parent, target, ns, imported_binding);\n                     }\n@@ -873,58 +871,55 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     ///\n     /// Optionally returns an unresolved import error. This error is buffered and used to\n     /// consolidate multiple unresolved import errors into a single diagnostic.\n-    fn finalize_import(\n-        &mut self,\n-        directive: &'b ImportDirective<'b>,\n-    ) -> Option<UnresolvedImportError> {\n-        let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n+    fn finalize_import(&mut self, import: &'b Import<'b>) -> Option<UnresolvedImportError> {\n+        let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n         let prev_ambiguity_errors_len = self.r.ambiguity_errors.len();\n         let path_res = self.r.resolve_path(\n-            &directive.module_path,\n+            &import.module_path,\n             None,\n-            &directive.parent_scope,\n+            &import.parent_scope,\n             true,\n-            directive.span,\n-            directive.crate_lint(),\n+            import.span,\n+            import.crate_lint(),\n         );\n         let no_ambiguity = self.r.ambiguity_errors.len() == prev_ambiguity_errors_len;\n-        directive.vis.set(orig_vis);\n+        import.vis.set(orig_vis);\n         if let PathResult::Failed { .. } | PathResult::NonModule(..) = path_res {\n             // Consider erroneous imports used to avoid duplicate diagnostics.\n-            self.r.used_imports.insert((directive.id, TypeNS));\n+            self.r.used_imports.insert((import.id, TypeNS));\n         }\n         let module = match path_res {\n             PathResult::Module(module) => {\n                 // Consistency checks, analogous to `finalize_macro_resolutions`.\n-                if let Some(initial_module) = directive.imported_module.get() {\n+                if let Some(initial_module) = import.imported_module.get() {\n                     if !ModuleOrUniformRoot::same_def(module, initial_module) && no_ambiguity {\n-                        span_bug!(directive.span, \"inconsistent resolution for an import\");\n+                        span_bug!(import.span, \"inconsistent resolution for an import\");\n                     }\n                 } else {\n                     if self.r.privacy_errors.is_empty() {\n                         let msg = \"cannot determine resolution for the import\";\n                         let msg_note = \"import resolution is stuck, try simplifying other imports\";\n-                        self.r.session.struct_span_err(directive.span, msg).note(msg_note).emit();\n+                        self.r.session.struct_span_err(import.span, msg).note(msg_note).emit();\n                     }\n                 }\n \n                 module\n             }\n             PathResult::Failed { is_error_from_last_segment: false, span, label, suggestion } => {\n                 if no_ambiguity {\n-                    assert!(directive.imported_module.get().is_none());\n+                    assert!(import.imported_module.get().is_none());\n                     self.r\n                         .report_error(span, ResolutionError::FailedToResolve { label, suggestion });\n                 }\n                 return None;\n             }\n             PathResult::Failed { is_error_from_last_segment: true, span, label, suggestion } => {\n                 if no_ambiguity {\n-                    assert!(directive.imported_module.get().is_none());\n+                    assert!(import.imported_module.get().is_none());\n                     let err = match self.make_path_suggestion(\n                         span,\n-                        directive.module_path.clone(),\n-                        &directive.parent_scope,\n+                        import.module_path.clone(),\n+                        &import.parent_scope,\n                     ) {\n                         Some((suggestion, note)) => UnresolvedImportError {\n                             span,\n@@ -949,44 +944,42 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             }\n             PathResult::NonModule(path_res) if path_res.base_res() == Res::Err => {\n                 if no_ambiguity {\n-                    assert!(directive.imported_module.get().is_none());\n+                    assert!(import.imported_module.get().is_none());\n                 }\n                 // The error was already reported earlier.\n                 return None;\n             }\n             PathResult::Indeterminate | PathResult::NonModule(..) => unreachable!(),\n         };\n \n-        let (ident, target, source_bindings, target_bindings, type_ns_only) = match directive\n-            .subclass\n-        {\n-            SingleImport {\n+        let (ident, target, source_bindings, target_bindings, type_ns_only) = match import.kind {\n+            ImportKind::Single {\n                 source,\n                 target,\n                 ref source_bindings,\n                 ref target_bindings,\n                 type_ns_only,\n                 ..\n             } => (source, target, source_bindings, target_bindings, type_ns_only),\n-            GlobImport { is_prelude, ref max_vis } => {\n-                if directive.module_path.len() <= 1 {\n+            ImportKind::Glob { is_prelude, ref max_vis } => {\n+                if import.module_path.len() <= 1 {\n                     // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n                     // 2 segments, so the `resolve_path` above won't trigger it.\n-                    let mut full_path = directive.module_path.clone();\n+                    let mut full_path = import.module_path.clone();\n                     full_path.push(Segment::from_ident(Ident::invalid()));\n                     self.r.lint_if_path_starts_with_module(\n-                        directive.crate_lint(),\n+                        import.crate_lint(),\n                         &full_path,\n-                        directive.span,\n+                        import.span,\n                         None,\n                     );\n                 }\n \n                 if let ModuleOrUniformRoot::Module(module) = module {\n-                    if module.def_id() == directive.parent_scope.module.def_id() {\n+                    if module.def_id() == import.parent_scope.module.def_id() {\n                         // Importing a module into itself is not allowed.\n                         return Some(UnresolvedImportError {\n-                            span: directive.span,\n+                            span: import.span,\n                             label: Some(String::from(\"cannot glob-import a module into itself\")),\n                             note: Vec::new(),\n                             suggestion: None,\n@@ -995,15 +988,10 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 }\n                 if !is_prelude &&\n                    max_vis.get() != ty::Visibility::Invisible && // Allow empty globs.\n-                   !max_vis.get().is_at_least(directive.vis.get(), &*self)\n+                   !max_vis.get().is_at_least(import.vis.get(), &*self)\n                 {\n                     let msg = \"glob import doesn't reexport anything because no candidate is public enough\";\n-                    self.r.lint_buffer.buffer_lint(\n-                        UNUSED_IMPORTS,\n-                        directive.id,\n-                        directive.span,\n-                        msg,\n-                    );\n+                    self.r.lint_buffer.buffer_lint(UNUSED_IMPORTS, import.id, import.span, msg);\n                 }\n                 return None;\n             }\n@@ -1013,21 +1001,21 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         let mut all_ns_err = true;\n         self.r.per_ns(|this, ns| {\n             if !type_ns_only || ns == TypeNS {\n-                let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n+                let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n                 let orig_blacklisted_binding =\n                     mem::replace(&mut this.blacklisted_binding, target_bindings[ns].get());\n                 let orig_last_import_segment = mem::replace(&mut this.last_import_segment, true);\n                 let binding = this.resolve_ident_in_module(\n                     module,\n                     ident,\n                     ns,\n-                    &directive.parent_scope,\n+                    &import.parent_scope,\n                     true,\n-                    directive.span,\n+                    import.span,\n                 );\n                 this.last_import_segment = orig_last_import_segment;\n                 this.blacklisted_binding = orig_blacklisted_binding;\n-                directive.vis.set(orig_vis);\n+                import.vis.set(orig_vis);\n \n                 match binding {\n                     Ok(binding) => {\n@@ -1044,7 +1032,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                                         ident,\n                                         ns,\n                                         target_binding,\n-                                        directive.module_path.is_empty(),\n+                                        import.module_path.is_empty(),\n                                     );\n                                 }\n                             }\n@@ -1053,7 +1041,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         let res = binding.res();\n                         if let Ok(initial_res) = initial_res {\n                             if res != initial_res && this.ambiguity_errors.is_empty() {\n-                                span_bug!(directive.span, \"inconsistent resolution for an import\");\n+                                span_bug!(import.span, \"inconsistent resolution for an import\");\n                             }\n                         } else {\n                             if res != Res::Err\n@@ -1064,7 +1052,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                                 let msg_note =\n                                     \"import resolution is stuck, try simplifying other imports\";\n                                 this.session\n-                                    .struct_span_err(directive.span, msg)\n+                                    .struct_span_err(import.span, msg)\n                                     .note(msg_note)\n                                     .emit();\n                             }\n@@ -1090,9 +1078,9 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         module,\n                         ident,\n                         ns,\n-                        &directive.parent_scope,\n+                        &import.parent_scope,\n                         true,\n-                        directive.span,\n+                        import.span,\n                     );\n                     if binding.is_ok() {\n                         all_ns_failed = false;\n@@ -1143,7 +1131,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     });\n \n                 let (suggestion, note) =\n-                    match self.check_for_module_export_macro(directive, module, ident) {\n+                    match self.check_for_module_export_macro(import, module, ident) {\n                         Some((suggestion, note)) => (suggestion.or(lev_suggestion), note),\n                         _ => (lev_suggestion, Vec::new()),\n                     };\n@@ -1169,14 +1157,14 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 };\n \n                 Some(UnresolvedImportError {\n-                    span: directive.span,\n+                    span: import.span,\n                     label: Some(label),\n                     note,\n                     suggestion,\n                 })\n             } else {\n                 // `resolve_ident_in_module` reported a privacy error.\n-                self.r.import_dummy_binding(directive);\n+                self.r.import_dummy_binding(import);\n                 None\n             };\n         }\n@@ -1185,7 +1173,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         let mut any_successful_reexport = false;\n         self.r.per_ns(|this, ns| {\n             if let Ok(binding) = source_bindings[ns].get() {\n-                let vis = directive.vis.get();\n+                let vis = import.vis.get();\n                 if !binding.pseudo_vis().is_at_least(vis, &*this) {\n                     reexport_error = Some((ns, binding));\n                 } else {\n@@ -1206,42 +1194,42 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 );\n                 self.r.lint_buffer.buffer_lint(\n                     PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n-                    directive.id,\n-                    directive.span,\n+                    import.id,\n+                    import.span,\n                     &msg,\n                 );\n             } else if ns == TypeNS {\n                 struct_span_err!(\n                     self.r.session,\n-                    directive.span,\n+                    import.span,\n                     E0365,\n                     \"`{}` is private, and cannot be re-exported\",\n                     ident\n                 )\n-                .span_label(directive.span, format!(\"re-export of private `{}`\", ident))\n+                .span_label(import.span, format!(\"re-export of private `{}`\", ident))\n                 .note(&format!(\"consider declaring type or module `{}` with `pub`\", ident))\n                 .emit();\n             } else {\n                 let msg = format!(\"`{}` is private, and cannot be re-exported\", ident);\n                 let note_msg =\n                     format!(\"consider marking `{}` as `pub` in the imported module\", ident,);\n-                struct_span_err!(self.r.session, directive.span, E0364, \"{}\", &msg)\n-                    .span_note(directive.span, &note_msg)\n+                struct_span_err!(self.r.session, import.span, E0364, \"{}\", &msg)\n+                    .span_note(import.span, &note_msg)\n                     .emit();\n             }\n         }\n \n-        if directive.module_path.len() <= 1 {\n+        if import.module_path.len() <= 1 {\n             // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n             // 2 segments, so the `resolve_path` above won't trigger it.\n-            let mut full_path = directive.module_path.clone();\n+            let mut full_path = import.module_path.clone();\n             full_path.push(Segment::from_ident(ident));\n             self.r.per_ns(|this, ns| {\n                 if let Ok(binding) = source_bindings[ns].get() {\n                     this.lint_if_path_starts_with_module(\n-                        directive.crate_lint(),\n+                        import.crate_lint(),\n                         &full_path,\n-                        directive.span,\n+                        import.span,\n                         Some(binding),\n                     );\n                 }\n@@ -1253,17 +1241,11 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         // purposes it's good enough to just favor one over the other.\n         self.r.per_ns(|this, ns| {\n             if let Ok(binding) = source_bindings[ns].get() {\n-                this.import_res_map.entry(directive.id).or_default()[ns] = Some(binding.res());\n+                this.import_res_map.entry(import.id).or_default()[ns] = Some(binding.res());\n             }\n         });\n \n-        self.check_for_redundant_imports(\n-            ident,\n-            directive,\n-            source_bindings,\n-            target_bindings,\n-            target,\n-        );\n+        self.check_for_redundant_imports(ident, import, source_bindings, target_bindings, target);\n \n         debug!(\"(resolving single import) successfully resolved import\");\n         None\n@@ -1272,19 +1254,19 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     fn check_for_redundant_imports(\n         &mut self,\n         ident: Ident,\n-        directive: &'b ImportDirective<'b>,\n+        import: &'b Import<'b>,\n         source_bindings: &PerNS<Cell<Result<&'b NameBinding<'b>, Determinacy>>>,\n         target_bindings: &PerNS<Cell<Option<&'b NameBinding<'b>>>>,\n         target: Ident,\n     ) {\n         // Skip if the import was produced by a macro.\n-        if directive.parent_scope.expansion != ExpnId::root() {\n+        if import.parent_scope.expansion != ExpnId::root() {\n             return;\n         }\n \n         // Skip if we are inside a named module (in contrast to an anonymous\n         // module defined by a block).\n-        if let ModuleKind::Def(..) = directive.parent_scope.module.kind {\n+        if let ModuleKind::Def(..) = import.parent_scope.module.kind {\n             return;\n         }\n \n@@ -1304,10 +1286,10 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 match this.early_resolve_ident_in_lexical_scope(\n                     target,\n                     ScopeSet::All(ns, false),\n-                    &directive.parent_scope,\n+                    &import.parent_scope,\n                     false,\n                     false,\n-                    directive.span,\n+                    import.span,\n                 ) {\n                     Ok(other_binding) => {\n                         is_redundant[ns] = Some(\n@@ -1329,35 +1311,35 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             redundant_spans.dedup();\n             self.r.lint_buffer.buffer_lint_with_diagnostic(\n                 UNUSED_IMPORTS,\n-                directive.id,\n-                directive.span,\n+                import.id,\n+                import.span,\n                 &format!(\"the item `{}` is imported redundantly\", ident),\n                 BuiltinLintDiagnostics::RedundantImport(redundant_spans, ident),\n             );\n         }\n     }\n \n-    fn resolve_glob_import(&mut self, directive: &'b ImportDirective<'b>) {\n-        let module = match directive.imported_module.get().unwrap() {\n+    fn resolve_glob_import(&mut self, import: &'b Import<'b>) {\n+        let module = match import.imported_module.get().unwrap() {\n             ModuleOrUniformRoot::Module(module) => module,\n             _ => {\n-                self.r.session.span_err(directive.span, \"cannot glob-import all possible crates\");\n+                self.r.session.span_err(import.span, \"cannot glob-import all possible crates\");\n                 return;\n             }\n         };\n \n         if module.is_trait() {\n-            self.r.session.span_err(directive.span, \"items in traits are not importable.\");\n+            self.r.session.span_err(import.span, \"items in traits are not importable.\");\n             return;\n-        } else if module.def_id() == directive.parent_scope.module.def_id() {\n+        } else if module.def_id() == import.parent_scope.module.def_id() {\n             return;\n-        } else if let GlobImport { is_prelude: true, .. } = directive.subclass {\n+        } else if let ImportKind::Glob { is_prelude: true, .. } = import.kind {\n             self.r.prelude = Some(module);\n             return;\n         }\n \n         // Add to module's glob_importers\n-        module.glob_importers.borrow_mut().push(directive);\n+        module.glob_importers.borrow_mut().push(import);\n \n         // Ensure that `resolutions` isn't borrowed during `try_define`,\n         // since it might get updated via a glob cycle.\n@@ -1371,19 +1353,19 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             })\n             .collect::<Vec<_>>();\n         for (mut key, binding) in bindings {\n-            let scope = match key.ident.span.reverse_glob_adjust(module.expansion, directive.span) {\n+            let scope = match key.ident.span.reverse_glob_adjust(module.expansion, import.span) {\n                 Some(Some(def)) => self.r.macro_def_scope(def),\n-                Some(None) => directive.parent_scope.module,\n+                Some(None) => import.parent_scope.module,\n                 None => continue,\n             };\n             if self.r.is_accessible_from(binding.pseudo_vis(), scope) {\n-                let imported_binding = self.r.import(binding, directive);\n-                let _ = self.r.try_define(directive.parent_scope.module, key, imported_binding);\n+                let imported_binding = self.r.import(binding, import);\n+                let _ = self.r.try_define(import.parent_scope.module, key, imported_binding);\n             }\n         }\n \n         // Record the destination of this import\n-        self.r.record_partial_res(directive.id, PartialRes::new(module.res().unwrap()));\n+        self.r.record_partial_res(import.id, PartialRes::new(module.res().unwrap()));\n     }\n \n     // Miscellaneous post-processing, including recording re-exports,\n@@ -1407,16 +1389,16 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 }\n             }\n \n-            if let NameBindingKind::Import { binding: orig_binding, directive, .. } = binding.kind {\n+            if let NameBindingKind::Import { binding: orig_binding, import, .. } = binding.kind {\n                 if ns == TypeNS\n                     && orig_binding.is_variant()\n                     && !orig_binding.vis.is_at_least(binding.vis, &*this)\n                 {\n-                    let msg = match directive.subclass {\n-                        ImportDirectiveSubclass::SingleImport { .. } => {\n+                    let msg = match import.kind {\n+                        ImportKind::Single { .. } => {\n                             format!(\"variant `{}` is private and cannot be re-exported\", ident)\n                         }\n-                        ImportDirectiveSubclass::GlobImport { .. } => {\n+                        ImportKind::Glob { .. } => {\n                             let msg = \"enum is private and its variants \\\n                                            cannot be re-exported\"\n                                 .to_owned();\n@@ -1432,18 +1414,18 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                             }\n                             msg\n                         }\n-                        ref s => bug!(\"unexpected import subclass {:?}\", s),\n+                        ref s => bug!(\"unexpected import kind {:?}\", s),\n                     };\n                     let mut err = this.session.struct_span_err(binding.span, &msg);\n \n-                    let imported_module = match directive.imported_module.get() {\n+                    let imported_module = match import.imported_module.get() {\n                         Some(ModuleOrUniformRoot::Module(module)) => module,\n                         _ => bug!(\"module should exist\"),\n                     };\n                     let parent_module = imported_module.parent.expect(\"parent should exist\");\n                     let resolutions = this.resolutions(parent_module).borrow();\n-                    let enum_path_segment_index = directive.module_path.len() - 1;\n-                    let enum_ident = directive.module_path[enum_path_segment_index].ident;\n+                    let enum_path_segment_index = import.module_path.len() - 1;\n+                    let enum_ident = import.module_path[enum_path_segment_index].ident;\n \n                     let key = this.new_key(enum_ident, TypeNS);\n                     let enum_resolution = resolutions.get(&key).expect(\"resolution should exist\");\n@@ -1481,11 +1463,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     }\n }\n \n-fn import_path_to_string(\n-    names: &[Ident],\n-    subclass: &ImportDirectiveSubclass<'_>,\n-    span: Span,\n-) -> String {\n+fn import_path_to_string(names: &[Ident], import_kind: &ImportKind<'_>, span: Span) -> String {\n     let pos = names.iter().position(|p| span == p.span && p.name != kw::PathRoot);\n     let global = !names.is_empty() && names[0].name == kw::PathRoot;\n     if let Some(pos) = pos {\n@@ -1494,22 +1472,22 @@ fn import_path_to_string(\n     } else {\n         let names = if global { &names[1..] } else { names };\n         if names.is_empty() {\n-            import_directive_subclass_to_string(subclass)\n+            import_kind_to_string(import_kind)\n         } else {\n             format!(\n                 \"{}::{}\",\n                 names_to_string(&names.iter().map(|ident| ident.name).collect::<Vec<_>>()),\n-                import_directive_subclass_to_string(subclass),\n+                import_kind_to_string(import_kind),\n             )\n         }\n     }\n }\n \n-fn import_directive_subclass_to_string(subclass: &ImportDirectiveSubclass<'_>) -> String {\n-    match *subclass {\n-        SingleImport { source, .. } => source.to_string(),\n-        GlobImport { .. } => \"*\".to_string(),\n-        ExternCrate { .. } => \"<extern crate>\".to_string(),\n-        MacroUse => \"#[macro_use]\".to_string(),\n+fn import_kind_to_string(import_kind: &ImportKind<'_>) -> String {\n+    match import_kind {\n+        ImportKind::Single { source, .. } => source.to_string(),\n+        ImportKind::Glob { .. } => \"*\".to_string(),\n+        ImportKind::ExternCrate { .. } => \"<extern crate>\".to_string(),\n+        ImportKind::MacroUse => \"#[macro_use]\".to_string(),\n     }\n }"}, {"sha": "97d60e1a23d8dcad7aae37450e14ce40d7dda06c", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/17b77913f9fe4dbf99a6ba74e179a7c68a8b1392/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17b77913f9fe4dbf99a6ba74e179a7c68a8b1392/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=17b77913f9fe4dbf99a6ba74e179a7c68a8b1392", "patch": "@@ -2189,10 +2189,10 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         trait_name: Ident,\n     ) -> SmallVec<[NodeId; 1]> {\n         let mut import_ids = smallvec![];\n-        while let NameBindingKind::Import { directive, binding, .. } = kind {\n-            self.r.maybe_unused_trait_imports.insert(directive.id);\n-            self.r.add_to_glob_map(&directive, trait_name);\n-            import_ids.push(directive.id);\n+        while let NameBindingKind::Import { import, binding, .. } = kind {\n+            self.r.maybe_unused_trait_imports.insert(import.id);\n+            self.r.add_to_glob_map(&import, trait_name);\n+            import_ids.push(import.id);\n             kind = &binding.kind;\n         }\n         import_ids"}, {"sha": "492ac6ed839770f8847ad79c3257c874cd3ebd12", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 47, "deletions": 52, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/17b77913f9fe4dbf99a6ba74e179a7c68a8b1392/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17b77913f9fe4dbf99a6ba74e179a7c68a8b1392/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=17b77913f9fe4dbf99a6ba74e179a7c68a8b1392", "patch": "@@ -56,7 +56,7 @@ use std::{cmp, fmt, iter, ptr};\n \n use diagnostics::{extend_span_to_previous_binding, find_span_of_binding_until_next_binding};\n use diagnostics::{ImportSuggestion, Suggestion};\n-use imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver, NameResolution};\n+use imports::{Import, ImportKind, ImportResolver, NameResolution};\n use late::{HasGenericParams, PathSource, Rib, RibKind::*};\n use macros::{LegacyBinding, LegacyScope};\n \n@@ -456,8 +456,8 @@ pub struct ModuleData<'a> {\n \n     no_implicit_prelude: bool,\n \n-    glob_importers: RefCell<Vec<&'a ImportDirective<'a>>>,\n-    globs: RefCell<Vec<&'a ImportDirective<'a>>>,\n+    glob_importers: RefCell<Vec<&'a Import<'a>>>,\n+    globs: RefCell<Vec<&'a Import<'a>>>,\n \n     // Used to memoize the traits in this module for faster searches through all traits in scope.\n     traits: RefCell<Option<Box<[(Ident, &'a NameBinding<'a>)]>>>,\n@@ -584,7 +584,7 @@ impl<'a> ToNameBinding<'a> for &'a NameBinding<'a> {\n enum NameBindingKind<'a> {\n     Res(Res, /* is_macro_export */ bool),\n     Module(Module<'a>),\n-    Import { binding: &'a NameBinding<'a>, directive: &'a ImportDirective<'a>, used: Cell<bool> },\n+    Import { binding: &'a NameBinding<'a>, import: &'a Import<'a>, used: Cell<bool> },\n }\n \n impl<'a> NameBindingKind<'a> {\n@@ -713,8 +713,7 @@ impl<'a> NameBinding<'a> {\n     fn is_extern_crate(&self) -> bool {\n         match self.kind {\n             NameBindingKind::Import {\n-                directive:\n-                    &ImportDirective { subclass: ImportDirectiveSubclass::ExternCrate { .. }, .. },\n+                import: &Import { kind: ImportKind::ExternCrate { .. }, .. },\n                 ..\n             } => true,\n             NameBindingKind::Module(&ModuleData {\n@@ -734,7 +733,7 @@ impl<'a> NameBinding<'a> {\n \n     fn is_glob_import(&self) -> bool {\n         match self.kind {\n-            NameBindingKind::Import { directive, .. } => directive.is_glob(),\n+            NameBindingKind::Import { import, .. } => import.is_glob(),\n             _ => false,\n         }\n     }\n@@ -839,10 +838,10 @@ pub struct Resolver<'a> {\n     field_names: FxHashMap<DefId, Vec<Spanned<Name>>>,\n \n     /// All imports known to succeed or fail.\n-    determined_imports: Vec<&'a ImportDirective<'a>>,\n+    determined_imports: Vec<&'a Import<'a>>,\n \n     /// All non-determined imports.\n-    indeterminate_imports: Vec<&'a ImportDirective<'a>>,\n+    indeterminate_imports: Vec<&'a Import<'a>>,\n \n     /// FIXME: Refactor things so that these fields are passed through arguments and not resolver.\n     /// We are resolving a last import segment during import validation.\n@@ -947,7 +946,7 @@ pub struct Resolver<'a> {\n     /// Avoid duplicated errors for \"name already defined\".\n     name_already_seen: FxHashMap<Name, Span>,\n \n-    potentially_unused_imports: Vec<&'a ImportDirective<'a>>,\n+    potentially_unused_imports: Vec<&'a Import<'a>>,\n \n     /// Table for mapping struct IDs into struct constructor IDs,\n     /// it's not used during normal resolution, only for better error reporting.\n@@ -971,7 +970,7 @@ pub struct ResolverArenas<'a> {\n     modules: arena::TypedArena<ModuleData<'a>>,\n     local_modules: RefCell<Vec<Module<'a>>>,\n     name_bindings: arena::TypedArena<NameBinding<'a>>,\n-    import_directives: arena::TypedArena<ImportDirective<'a>>,\n+    imports: arena::TypedArena<Import<'a>>,\n     name_resolutions: arena::TypedArena<RefCell<NameResolution<'a>>>,\n     legacy_bindings: arena::TypedArena<LegacyBinding<'a>>,\n     ast_paths: arena::TypedArena<ast::Path>,\n@@ -991,11 +990,8 @@ impl<'a> ResolverArenas<'a> {\n     fn alloc_name_binding(&'a self, name_binding: NameBinding<'a>) -> &'a NameBinding<'a> {\n         self.name_bindings.alloc(name_binding)\n     }\n-    fn alloc_import_directive(\n-        &'a self,\n-        import_directive: ImportDirective<'a>,\n-    ) -> &'a ImportDirective<'_> {\n-        self.import_directives.alloc(import_directive)\n+    fn alloc_import(&'a self, import: Import<'a>) -> &'a Import<'_> {\n+        self.imports.alloc(import)\n     }\n     fn alloc_name_resolution(&'a self) -> &'a RefCell<NameResolution<'a>> {\n         self.name_resolutions.alloc(Default::default())\n@@ -1410,7 +1406,7 @@ impl<'a> Resolver<'a> {\n                 misc2: AmbiguityErrorMisc::None,\n             });\n         }\n-        if let NameBindingKind::Import { directive, binding, ref used } = used_binding.kind {\n+        if let NameBindingKind::Import { import, binding, ref used } = used_binding.kind {\n             // Avoid marking `extern crate` items that refer to a name from extern prelude,\n             // but not introduce it, as used if they are accessed from lexical scope.\n             if is_lexical_scope {\n@@ -1423,17 +1419,17 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             used.set(true);\n-            directive.used.set(true);\n-            self.used_imports.insert((directive.id, ns));\n-            self.add_to_glob_map(&directive, ident);\n+            import.used.set(true);\n+            self.used_imports.insert((import.id, ns));\n+            self.add_to_glob_map(&import, ident);\n             self.record_use(ident, ns, binding, false);\n         }\n     }\n \n     #[inline]\n-    fn add_to_glob_map(&mut self, directive: &ImportDirective<'_>, ident: Ident) {\n-        if directive.is_glob() {\n-            self.glob_map.entry(directive.id).or_default().insert(ident.name);\n+    fn add_to_glob_map(&mut self, import: &Import<'_>, ident: Ident) {\n+        if import.is_glob() {\n+            self.glob_map.entry(import.id).or_default().insert(ident.name);\n         }\n     }\n \n@@ -2258,10 +2254,9 @@ impl<'a> Resolver<'a> {\n         // `ExternCrate` (also used for `crate::...`) then no need to issue a\n         // warning, this looks all good!\n         if let Some(binding) = second_binding {\n-            if let NameBindingKind::Import { directive: d, .. } = binding.kind {\n-                // Careful: we still want to rewrite paths from\n-                // renamed extern crates.\n-                if let ImportDirectiveSubclass::ExternCrate { source: None, .. } = d.subclass {\n+            if let NameBindingKind::Import { import, .. } = binding.kind {\n+                // Careful: we still want to rewrite paths from renamed extern crates.\n+                if let ImportKind::ExternCrate { source: None, .. } = import.kind {\n                     return;\n                 }\n             }\n@@ -2564,10 +2559,10 @@ impl<'a> Resolver<'a> {\n \n         // See https://github.com/rust-lang/rust/issues/32354\n         use NameBindingKind::Import;\n-        let directive = match (&new_binding.kind, &old_binding.kind) {\n+        let import = match (&new_binding.kind, &old_binding.kind) {\n             // If there are two imports where one or both have attributes then prefer removing the\n             // import without attributes.\n-            (Import { directive: new, .. }, Import { directive: old, .. })\n+            (Import { import: new, .. }, Import { import: old, .. })\n                 if {\n                     !new_binding.span.is_dummy()\n                         && !old_binding.span.is_dummy()\n@@ -2581,11 +2576,11 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             // Otherwise prioritize the new binding.\n-            (Import { directive, .. }, other) if !new_binding.span.is_dummy() => {\n-                Some((directive, new_binding.span, other.is_import()))\n+            (Import { import, .. }, other) if !new_binding.span.is_dummy() => {\n+                Some((import, new_binding.span, other.is_import()))\n             }\n-            (other, Import { directive, .. }) if !old_binding.span.is_dummy() => {\n-                Some((directive, old_binding.span, other.is_import()))\n+            (other, Import { import, .. }) if !old_binding.span.is_dummy() => {\n+                Some((import, old_binding.span, other.is_import()))\n             }\n             _ => None,\n         };\n@@ -2602,22 +2597,22 @@ impl<'a> Resolver<'a> {\n             && !has_dummy_span\n             && ((new_binding.is_extern_crate() || old_binding.is_extern_crate()) || from_item);\n \n-        match directive {\n-            Some((directive, span, true)) if should_remove_import && directive.is_nested() => {\n-                self.add_suggestion_for_duplicate_nested_use(&mut err, directive, span)\n+        match import {\n+            Some((import, span, true)) if should_remove_import && import.is_nested() => {\n+                self.add_suggestion_for_duplicate_nested_use(&mut err, import, span)\n             }\n-            Some((directive, _, true)) if should_remove_import && !directive.is_glob() => {\n+            Some((import, _, true)) if should_remove_import && !import.is_glob() => {\n                 // Simple case - remove the entire import. Due to the above match arm, this can\n                 // only be a single use so just remove it entirely.\n                 err.tool_only_span_suggestion(\n-                    directive.use_span_with_attributes,\n+                    import.use_span_with_attributes,\n                     \"remove unnecessary import\",\n                     String::new(),\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n-            Some((directive, span, _)) => {\n-                self.add_suggestion_for_rename_of_use(&mut err, name, directive, span)\n+            Some((import, span, _)) => {\n+                self.add_suggestion_for_rename_of_use(&mut err, name, import, span)\n             }\n             _ => {}\n         }\n@@ -2639,7 +2634,7 @@ impl<'a> Resolver<'a> {\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         name: Name,\n-        directive: &ImportDirective<'_>,\n+        import: &Import<'_>,\n         binding_span: Span,\n     ) {\n         let suggested_name = if name.as_str().chars().next().unwrap().is_uppercase() {\n@@ -2649,11 +2644,11 @@ impl<'a> Resolver<'a> {\n         };\n \n         let mut suggestion = None;\n-        match directive.subclass {\n-            ImportDirectiveSubclass::SingleImport { type_ns_only: true, .. } => {\n+        match import.kind {\n+            ImportKind::Single { type_ns_only: true, .. } => {\n                 suggestion = Some(format!(\"self as {}\", suggested_name))\n             }\n-            ImportDirectiveSubclass::SingleImport { source, .. } => {\n+            ImportKind::Single { source, .. } => {\n                 if let Some(pos) =\n                     source.span.hi().0.checked_sub(binding_span.lo().0).map(|pos| pos as usize)\n                 {\n@@ -2669,7 +2664,7 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n             }\n-            ImportDirectiveSubclass::ExternCrate { source, target, .. } => {\n+            ImportKind::ExternCrate { source, target, .. } => {\n                 suggestion = Some(format!(\n                     \"extern crate {} as {};\",\n                     source.unwrap_or(target.name),\n@@ -2711,27 +2706,27 @@ impl<'a> Resolver<'a> {\n     /// If the nested use contains only one import then the suggestion will remove the entire\n     /// line.\n     ///\n-    /// It is expected that the directive provided is a nested import - this isn't checked by the\n+    /// It is expected that the provided import is nested - this isn't checked by the\n     /// function. If this invariant is not upheld, this function's behaviour will be unexpected\n     /// as characters expected by span manipulations won't be present.\n     fn add_suggestion_for_duplicate_nested_use(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        directive: &ImportDirective<'_>,\n+        import: &Import<'_>,\n         binding_span: Span,\n     ) {\n-        assert!(directive.is_nested());\n+        assert!(import.is_nested());\n         let message = \"remove unnecessary import\";\n \n         // Two examples will be used to illustrate the span manipulations we're doing:\n         //\n         // - Given `use issue_52891::{d, a, e};` where `a` is a duplicate then `binding_span` is\n-        //   `a` and `directive.use_span` is `issue_52891::{d, a, e};`.\n+        //   `a` and `import.use_span` is `issue_52891::{d, a, e};`.\n         // - Given `use issue_52891::{d, e, a};` where `a` is a duplicate then `binding_span` is\n-        //   `a` and `directive.use_span` is `issue_52891::{d, e, a};`.\n+        //   `a` and `import.use_span` is `issue_52891::{d, e, a};`.\n \n         let (found_closing_brace, span) =\n-            find_span_of_binding_until_next_binding(self.session, binding_span, directive.use_span);\n+            find_span_of_binding_until_next_binding(self.session, binding_span, import.use_span);\n \n         // If there was a closing brace then identify the span to remove any trailing commas from\n         // previous imports.\n@@ -2747,7 +2742,7 @@ impl<'a> Resolver<'a> {\n                 // Remove the entire line if we cannot extend the span back, this indicates a\n                 // `issue_52891::{self}` case.\n                 err.span_suggestion(\n-                    directive.use_span_with_attributes,\n+                    import.use_span_with_attributes,\n                     message,\n                     String::new(),\n                     Applicability::MaybeIncorrect,"}, {"sha": "65400163ddd86ab09fe09102de41923eabda44d5", "filename": "src/test/ui/rust-2018/macro-use-warned-against.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/17b77913f9fe4dbf99a6ba74e179a7c68a8b1392/src%2Ftest%2Fui%2Frust-2018%2Fmacro-use-warned-against.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17b77913f9fe4dbf99a6ba74e179a7c68a8b1392/src%2Ftest%2Fui%2Frust-2018%2Fmacro-use-warned-against.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fmacro-use-warned-against.rs?ref=17b77913f9fe4dbf99a6ba74e179a7c68a8b1392", "patch": "@@ -4,7 +4,7 @@\n \n #![warn(macro_use_extern_crate, unused)]\n \n-#[macro_use] //~ WARN should be replaced at use sites with a `use` statement\n+#[macro_use] //~ WARN should be replaced at use sites with a `use` item\n extern crate macro_use_warned_against;\n #[macro_use] //~ WARN unused `#[macro_use]`\n extern crate macro_use_warned_against2;"}, {"sha": "ef00b865815c06032c5b268751921c2904350b16", "filename": "src/test/ui/rust-2018/macro-use-warned-against.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/17b77913f9fe4dbf99a6ba74e179a7c68a8b1392/src%2Ftest%2Fui%2Frust-2018%2Fmacro-use-warned-against.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/17b77913f9fe4dbf99a6ba74e179a7c68a8b1392/src%2Ftest%2Fui%2Frust-2018%2Fmacro-use-warned-against.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fmacro-use-warned-against.stderr?ref=17b77913f9fe4dbf99a6ba74e179a7c68a8b1392", "patch": "@@ -1,4 +1,4 @@\n-warning: deprecated `#[macro_use]` directive used to import macros should be replaced at use sites with a `use` statement to import the macro instead\n+warning: deprecated `#[macro_use]` attribute used to import macros should be replaced at use sites with a `use` item to import the macro instead\n   --> $DIR/macro-use-warned-against.rs:7:1\n    |\n LL | #[macro_use]"}]}