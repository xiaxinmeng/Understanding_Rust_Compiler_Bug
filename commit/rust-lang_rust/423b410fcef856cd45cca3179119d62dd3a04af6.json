{"sha": "423b410fcef856cd45cca3179119d62dd3a04af6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyM2I0MTBmY2VmODU2Y2Q0NWNjYTMxNzkxMTlkNjJkZDNhMDRhZjY=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-05-28T02:54:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-05-28T02:54:04Z"}, "message": "Rollup merge of #42260 - stjepang:document-cmp-traits-agreement, r=alexcrichton\n\nDocs: impls of PartialEq/PartialOrd/Ord must agree\n\nFixes #41270.\n\nThis PR brings two improvements to the docs:\n\n1. Docs for `PartialEq`, `PartialOrd`, and `Ord` clarify that their implementations must agree.\n2. Fixes a subtle bug in the Dijkstra example for `BinaryHeap`, where the impls are inconsistent.\nThanks @Rufflewind for spotting the bug!\n\nr? @alexcrichton\ncc @frankmcsherry", "tree": {"sha": "f01300cc11a5676a794a1216108f7840dde788e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f01300cc11a5676a794a1216108f7840dde788e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/423b410fcef856cd45cca3179119d62dd3a04af6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/423b410fcef856cd45cca3179119d62dd3a04af6", "html_url": "https://github.com/rust-lang/rust/commit/423b410fcef856cd45cca3179119d62dd3a04af6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/423b410fcef856cd45cca3179119d62dd3a04af6/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "906c9bcfb97c4618765e6a8b8fb009ccbc4dbd3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/906c9bcfb97c4618765e6a8b8fb009ccbc4dbd3b", "html_url": "https://github.com/rust-lang/rust/commit/906c9bcfb97c4618765e6a8b8fb009ccbc4dbd3b"}, {"sha": "f5421367a2d72d5da415d2bbf97538099ff3ade0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5421367a2d72d5da415d2bbf97538099ff3ade0", "html_url": "https://github.com/rust-lang/rust/commit/f5421367a2d72d5da415d2bbf97538099ff3ade0"}], "stats": {"total": 21, "additions": 18, "deletions": 3}, "files": [{"sha": "988f88516255731e47a4f43cb9cdc9987b574afc", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/423b410fcef856cd45cca3179119d62dd3a04af6/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/423b410fcef856cd45cca3179119d62dd3a04af6/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=423b410fcef856cd45cca3179119d62dd3a04af6", "patch": "@@ -43,8 +43,11 @@\n //! // instead of a max-heap.\n //! impl Ord for State {\n //!     fn cmp(&self, other: &State) -> Ordering {\n-//!         // Notice that the we flip the ordering here\n+//!         // Notice that the we flip the ordering on costs.\n+//!         // In case of a tie we compare positions - this step is necessary\n+//!         // to make implementations of `PartialEq` and `Ord` consistent.\n //!         other.cost.cmp(&self.cost)\n+//!             .then_with(|| self.position.cmp(&other.position))\n //!     }\n //! }\n //!"}, {"sha": "661cf73c7f30e3f36daf2da8d55eea9399ca1ed1", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/423b410fcef856cd45cca3179119d62dd3a04af6/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/423b410fcef856cd45cca3179119d62dd3a04af6/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=423b410fcef856cd45cca3179119d62dd3a04af6", "patch": "@@ -67,6 +67,10 @@ use self::Ordering::*;\n /// the rule that `eq` is a strict inverse of `ne`; that is, `!(a == b)` if and\n /// only if `a != b`.\n ///\n+/// Implementations of `PartialEq`, `PartialOrd`, and `Ord` *must* agree with\n+/// each other. It's easy to accidentally make them disagree by deriving some\n+/// of the traits and manually implementing others.\n+///\n /// An example implementation for a domain in which two books are considered\n /// the same book if their ISBN matches, even if the formats differ:\n ///\n@@ -386,6 +390,10 @@ impl<T: Ord> Ord for Reverse<T> {\n /// Then you must define an implementation for `cmp()`. You may find it useful to use\n /// `cmp()` on your type's fields.\n ///\n+/// Implementations of `PartialEq`, `PartialOrd`, and `Ord` *must* agree with each other. It's\n+/// easy to accidentally make them disagree by deriving some of the traits and manually\n+/// implementing others.\n+///\n /// Here's an example where you want to sort people by height only, disregarding `id`\n /// and `name`:\n ///\n@@ -474,15 +482,19 @@ impl PartialOrd for Ordering {\n ///\n /// ## How can I implement `PartialOrd`?\n ///\n-/// PartialOrd only requires implementation of the `partial_cmp` method, with the others generated\n-/// from default implementations.\n+/// `PartialOrd` only requires implementation of the `partial_cmp` method, with the others\n+/// generated from default implementations.\n ///\n /// However it remains possible to implement the others separately for types which do not have a\n /// total order. For example, for floating point numbers, `NaN < 0 == false` and `NaN >= 0 ==\n /// false` (cf. IEEE 754-2008 section 5.11).\n ///\n /// `PartialOrd` requires your type to be `PartialEq`.\n ///\n+/// Implementations of `PartialEq`, `PartialOrd`, and `Ord` *must* agree with each other. It's\n+/// easy to accidentally make them disagree by deriving some of the traits and manually\n+/// implementing others.\n+///\n /// If your type is `Ord`, you can implement `partial_cmp()` by using `cmp()`:\n ///\n /// ```"}]}