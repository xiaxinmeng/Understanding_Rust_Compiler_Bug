{"sha": "b365de94df941ae1bace2744620e453972560cdf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzNjVkZTk0ZGY5NDFhZTFiYWNlMjc0NDYyMGU0NTM5NzI1NjBjZGY=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-09-12T04:17:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-09-12T04:17:26Z"}, "message": "Rollup merge of #54031 - ljedrz:cleanup_passes, r=oli-obk\n\nA few cleanups and minor improvements to rustc_passes\n\n- prefer `if let` to `match` when only one branch matters\n- prefer equality checks to pattern matching\n- prefer `is_empty` to `len() == 0`\n- collapse a couple of `if` expressions\n- rename `label` to `destination` when destructuring `hir::ExprKind::Continue`\n- `derive Copy` for `Promotability`\n- `impl BitAndAssign` for `Promotability`\n- a few formatting fixes\n- a few other minor cleanups", "tree": {"sha": "06aadbf161c53df19d3070e85d9d55affc0af365", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06aadbf161c53df19d3070e85d9d55affc0af365"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b365de94df941ae1bace2744620e453972560cdf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbmJNXCRBK7hj4Ov3rIwAAdHIIAB8Czb8CaVlgnueSBfi+MrIZ\nmi5MH0pi1KTsmuFCIopi6iWGtmFd8PwRk4NB5BCpDEDkkLNGdmTQTwDQ0xnKVO4t\nDRBDFY2GcZGZ2hAUHrMoEpWuM/5Tju1H1CtQbvAa7MMgaD2XX8M5YUPE0tBDRDcg\n1uLWxMTn+1ANhTbLJD8LORIHCo3BaRe5+NdNT7V/gmAlU4Vq9NHft4uO9I/alRPI\nbJjluJWdVipZ+FC3ulmt4tHDb2horCmBcP0FmjVcINy48auD1GxD8qVdL1RlgZ7C\nThc7MlaZOSk/IXauvsyyWbDIBYBl9MH+12RPh6Cru0O6nZmNUoY5sy5V9vXRzr0=\n=Citu\n-----END PGP SIGNATURE-----\n", "payload": "tree 06aadbf161c53df19d3070e85d9d55affc0af365\nparent 4f62077a2c203a74363589db8c010de11ba5f5d7\nparent 8bbe1789fae9c53be44c30159e47cf4ac6bc0f9e\nauthor kennytm <kennytm@gmail.com> 1536725846 +0800\ncommitter GitHub <noreply@github.com> 1536725846 +0800\n\nRollup merge of #54031 - ljedrz:cleanup_passes, r=oli-obk\n\nA few cleanups and minor improvements to rustc_passes\n\n- prefer `if let` to `match` when only one branch matters\n- prefer equality checks to pattern matching\n- prefer `is_empty` to `len() == 0`\n- collapse a couple of `if` expressions\n- rename `label` to `destination` when destructuring `hir::ExprKind::Continue`\n- `derive Copy` for `Promotability`\n- `impl BitAndAssign` for `Promotability`\n- a few formatting fixes\n- a few other minor cleanups\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b365de94df941ae1bace2744620e453972560cdf", "html_url": "https://github.com/rust-lang/rust/commit/b365de94df941ae1bace2744620e453972560cdf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b365de94df941ae1bace2744620e453972560cdf/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f62077a2c203a74363589db8c010de11ba5f5d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f62077a2c203a74363589db8c010de11ba5f5d7", "html_url": "https://github.com/rust-lang/rust/commit/4f62077a2c203a74363589db8c010de11ba5f5d7"}, {"sha": "8bbe1789fae9c53be44c30159e47cf4ac6bc0f9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bbe1789fae9c53be44c30159e47cf4ac6bc0f9e", "html_url": "https://github.com/rust-lang/rust/commit/8bbe1789fae9c53be44c30159e47cf4ac6bc0f9e"}], "stats": {"total": 224, "additions": 96, "deletions": 128}, "files": [{"sha": "2ee5415018f934ece32799bb45f132a1139caac5", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 23, "deletions": 30, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b365de94df941ae1bace2744620e453972560cdf/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b365de94df941ae1bace2744620e453972560cdf/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=b365de94df941ae1bace2744620e453972560cdf", "patch": "@@ -99,22 +99,19 @@ impl<'a> AstValidator<'a> {\n     }\n \n     fn check_trait_fn_not_const(&self, constness: Spanned<Constness>) {\n-        match constness.node {\n-            Constness::Const => {\n-                struct_span_err!(self.session, constness.span, E0379,\n-                                 \"trait fns cannot be declared const\")\n-                    .span_label(constness.span, \"trait fns cannot be const\")\n-                    .emit();\n-            }\n-            _ => {}\n+        if constness.node == Constness::Const {\n+            struct_span_err!(self.session, constness.span, E0379,\n+                             \"trait fns cannot be declared const\")\n+                .span_label(constness.span, \"trait fns cannot be const\")\n+                .emit();\n         }\n     }\n \n     fn no_questions_in_bounds(&self, bounds: &GenericBounds, where_: &str, is_trait: bool) {\n         for bound in bounds {\n             if let GenericBound::Trait(ref poly, TraitBoundModifier::Maybe) = *bound {\n                 let mut err = self.err_handler().struct_span_err(poly.span,\n-                                    &format!(\"`?Trait` is not permitted in {}\", where_));\n+                    &format!(\"`?Trait` is not permitted in {}\", where_));\n                 if is_trait {\n                     err.note(&format!(\"traits are `?{}` by default\", poly.trait_ref.path));\n                 }\n@@ -153,16 +150,16 @@ impl<'a> AstValidator<'a> {\n         // Check only lifetime parameters are present and that the lifetime\n         // parameters that are present have no bounds.\n         let non_lt_param_spans: Vec<_> = params.iter().filter_map(|param| match param.kind {\n-                GenericParamKind::Lifetime { .. } => {\n-                    if !param.bounds.is_empty() {\n-                        let spans: Vec<_> = param.bounds.iter().map(|b| b.span()).collect();\n-                        self.err_handler()\n-                            .span_err(spans, \"lifetime bounds cannot be used in this context\");\n-                    }\n-                    None\n+            GenericParamKind::Lifetime { .. } => {\n+                if !param.bounds.is_empty() {\n+                    let spans: Vec<_> = param.bounds.iter().map(|b| b.span()).collect();\n+                    self.err_handler()\n+                        .span_err(spans, \"lifetime bounds cannot be used in this context\");\n                 }\n-                _ => Some(param.ident.span),\n-            }).collect();\n+                None\n+            }\n+            _ => Some(param.ident.span),\n+        }).collect();\n         if !non_lt_param_spans.is_empty() {\n             self.err_handler().span_err(non_lt_param_spans,\n                 \"only lifetime parameters can be used in this context\");\n@@ -438,7 +435,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     self.err_handler().span_err(item.span,\n                                                 \"tuple and unit unions are not permitted\");\n                 }\n-                if vdata.fields().len() == 0 {\n+                if vdata.fields().is_empty() {\n                     self.err_handler().span_err(item.span,\n                                                 \"unions cannot have zero fields\");\n                 }\n@@ -465,14 +462,11 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_vis(&mut self, vis: &'a Visibility) {\n-        match vis.node {\n-            VisibilityKind::Restricted { ref path, .. } => {\n-                path.segments.iter().find(|segment| segment.args.is_some()).map(|segment| {\n-                    self.err_handler().span_err(segment.args.as_ref().unwrap().span(),\n-                                                \"generic arguments in visibility path\");\n-                });\n-            }\n-            _ => {}\n+        if let VisibilityKind::Restricted { ref path, .. } = vis.node {\n+            path.segments.iter().find(|segment| segment.args.is_some()).map(|segment| {\n+                self.err_handler().span_err(segment.args.as_ref().unwrap().span(),\n+                                            \"generic arguments in visibility path\");\n+            });\n         }\n \n         visit::walk_vis(self, vis)\n@@ -642,8 +636,7 @@ impl<'a> Visitor<'a> for ImplTraitProjectionVisitor<'a> {\n             TyKind::ImplTrait(..) => {\n                 if self.is_banned {\n                     struct_span_err!(self.session, t.span, E0667,\n-                                 \"`impl Trait` is not allowed in path parameters\")\n-                        .emit();\n+                        \"`impl Trait` is not allowed in path parameters\").emit();\n                 }\n             }\n             TyKind::Path(ref qself, ref path) => {\n@@ -667,7 +660,7 @@ impl<'a> Visitor<'a> for ImplTraitProjectionVisitor<'a> {\n \n                 for (i, segment) in path.segments.iter().enumerate() {\n                     // Allow `impl Trait` iff we're on the final path segment\n-                    if i == (path.segments.len() - 1) {\n+                    if i == path.segments.len() - 1 {\n                         visit::walk_path_segment(self, path.span, segment);\n                     } else {\n                         self.with_ban(|this|"}, {"sha": "b65a2e3f0e5306f3033f71269c2e0db136a5c07c", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b365de94df941ae1bace2744620e453972560cdf/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b365de94df941ae1bace2744620e453972560cdf/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=b365de94df941ae1bace2744620e453972560cdf", "patch": "@@ -61,10 +61,8 @@ pub fn print_ast_stats<'v>(krate: &'v ast::Crate, title: &str) {\n impl<'k> StatCollector<'k> {\n \n     fn record<T>(&mut self, label: &'static str, id: Id, node: &T) {\n-        if id != Id::None {\n-            if !self.seen.insert(id) {\n-                return\n-            }\n+        if id != Id::None && !self.seen.insert(id) {\n+            return\n         }\n \n         let entry = self.data.entry(label).or_insert(NodeData {\n@@ -135,40 +133,46 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_item(self, i)\n     }\n \n-    ///////////////////////////////////////////////////////////////////////////\n-\n     fn visit_mod(&mut self, m: &'v hir::Mod, _s: Span, n: NodeId) {\n         self.record(\"Mod\", Id::None, m);\n         hir_visit::walk_mod(self, m, n)\n     }\n+\n     fn visit_foreign_item(&mut self, i: &'v hir::ForeignItem) {\n         self.record(\"ForeignItem\", Id::Node(i.id), i);\n         hir_visit::walk_foreign_item(self, i)\n     }\n+\n     fn visit_local(&mut self, l: &'v hir::Local) {\n         self.record(\"Local\", Id::Node(l.id), l);\n         hir_visit::walk_local(self, l)\n     }\n+\n     fn visit_block(&mut self, b: &'v hir::Block) {\n         self.record(\"Block\", Id::Node(b.id), b);\n         hir_visit::walk_block(self, b)\n     }\n+\n     fn visit_stmt(&mut self, s: &'v hir::Stmt) {\n         self.record(\"Stmt\", Id::Node(s.node.id()), s);\n         hir_visit::walk_stmt(self, s)\n     }\n+\n     fn visit_arm(&mut self, a: &'v hir::Arm) {\n         self.record(\"Arm\", Id::None, a);\n         hir_visit::walk_arm(self, a)\n     }\n+\n     fn visit_pat(&mut self, p: &'v hir::Pat) {\n         self.record(\"Pat\", Id::Node(p.id), p);\n         hir_visit::walk_pat(self, p)\n     }\n+\n     fn visit_decl(&mut self, d: &'v hir::Decl) {\n         self.record(\"Decl\", Id::None, d);\n         hir_visit::walk_decl(self, d)\n     }\n+\n     fn visit_expr(&mut self, ex: &'v hir::Expr) {\n         self.record(\"Expr\", Id::Node(ex.id), ex);\n         hir_visit::walk_expr(self, ex)\n@@ -198,6 +202,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         self.record(\"TraitItem\", Id::Node(ti.id), ti);\n         hir_visit::walk_trait_item(self, ti)\n     }\n+\n     fn visit_impl_item(&mut self, ii: &'v hir::ImplItem) {\n         self.record(\"ImplItem\", Id::Node(ii.id), ii);\n         hir_visit::walk_impl_item(self, ii)\n@@ -220,31 +225,38 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         self.record(\"Variant\", Id::None, v);\n         hir_visit::walk_variant(self, v, g, item_id)\n     }\n+\n     fn visit_lifetime(&mut self, lifetime: &'v hir::Lifetime) {\n         self.record(\"Lifetime\", Id::Node(lifetime.id), lifetime);\n         hir_visit::walk_lifetime(self, lifetime)\n     }\n+\n     fn visit_qpath(&mut self, qpath: &'v hir::QPath, id: hir::HirId, span: Span) {\n         self.record(\"QPath\", Id::None, qpath);\n         hir_visit::walk_qpath(self, qpath, id, span)\n     }\n+\n     fn visit_path(&mut self, path: &'v hir::Path, _id: hir::HirId) {\n         self.record(\"Path\", Id::None, path);\n         hir_visit::walk_path(self, path)\n     }\n+\n     fn visit_path_segment(&mut self,\n                           path_span: Span,\n                           path_segment: &'v hir::PathSegment) {\n         self.record(\"PathSegment\", Id::None, path_segment);\n         hir_visit::walk_path_segment(self, path_span, path_segment)\n     }\n+\n     fn visit_assoc_type_binding(&mut self, type_binding: &'v hir::TypeBinding) {\n         self.record(\"TypeBinding\", Id::Node(type_binding.id), type_binding);\n         hir_visit::walk_assoc_type_binding(self, type_binding)\n     }\n+\n     fn visit_attribute(&mut self, attr: &'v ast::Attribute) {\n         self.record(\"Attribute\", Id::Attr(attr.id), attr);\n     }\n+\n     fn visit_macro_def(&mut self, macro_def: &'v hir::MacroDef) {\n         self.record(\"MacroDef\", Id::Node(macro_def.id), macro_def);\n         hir_visit::walk_macro_def(self, macro_def)"}, {"sha": "61c2ac161bb08096d35fa7d930246940f0436d34", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b365de94df941ae1bace2744620e453972560cdf/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b365de94df941ae1bace2744620e453972560cdf/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=b365de94df941ae1bace2744620e453972560cdf", "patch": "@@ -114,9 +114,8 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                 };\n \n                 if loop_id != ast::DUMMY_NODE_ID {\n-                    match self.hir_map.find(loop_id).unwrap() {\n-                        Node::Block(_) => return,\n-                        _=> (),\n+                    if let Node::Block(_) = self.hir_map.find(loop_id).unwrap() {\n+                        return\n                     }\n                 }\n \n@@ -153,10 +152,10 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n \n                 self.require_break_cx(\"break\", e.span);\n             }\n-            hir::ExprKind::Continue(label) => {\n-                self.require_label_in_labeled_block(e.span, &label, \"continue\");\n+            hir::ExprKind::Continue(destination) => {\n+                self.require_label_in_labeled_block(e.span, &destination, \"continue\");\n \n-                match label.target_id {\n+                match destination.target_id {\n                     Ok(loop_id) => {\n                         if let Node::Block(block) = self.hir_map.find(loop_id).unwrap() {\n                             struct_span_err!(self.sess, e.span, E0696,\n@@ -171,7 +170,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                     Err(hir::LoopIdError::UnlabeledCfInWhileCondition) => {\n                         self.emit_unlabled_cf_in_while_condition(e.span, \"continue\");\n                     }\n-                    _ => {}\n+                    Err(_) => {}\n                 }\n                 self.require_break_cx(\"continue\", e.span)\n             },\n@@ -192,8 +191,7 @@ impl<'a, 'hir> CheckLoopVisitor<'a, 'hir> {\n \n     fn require_break_cx(&self, name: &str, span: Span) {\n         match self.cx {\n-            LabeledBlock |\n-            Loop(_) => {}\n+            LabeledBlock | Loop(_) => {}\n             Closure => {\n                 struct_span_err!(self.sess, span, E0267, \"`{}` inside of a closure\", name)\n                 .span_label(span, \"cannot break inside of a closure\")"}, {"sha": "0120b5bc5322f1239490cd405c588a6dd72c675e", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 11, "deletions": 30, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b365de94df941ae1bace2744620e453972560cdf/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b365de94df941ae1bace2744620e453972560cdf/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=b365de94df941ae1bace2744620e453972560cdf", "patch": "@@ -65,15 +65,12 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.super_mir(mir);\n     }\n \n-    fn visit_basic_block_data(&mut self,\n-                              block: BasicBlock,\n-                              data: &BasicBlockData<'tcx>) {\n+    fn visit_basic_block_data(&mut self, block: BasicBlock, data: &BasicBlockData<'tcx>) {\n         self.record(\"BasicBlockData\", data);\n         self.super_basic_block_data(block, data);\n     }\n \n-    fn visit_source_scope_data(&mut self,\n-                                   scope_data: &SourceScopeData) {\n+    fn visit_source_scope_data(&mut self, scope_data: &SourceScopeData) {\n         self.record(\"SourceScopeData\", scope_data);\n         self.super_source_scope_data(scope_data);\n     }\n@@ -130,9 +127,7 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.super_terminator_kind(block, kind, location);\n     }\n \n-    fn visit_assert_message(&mut self,\n-                            msg: &AssertMessage<'tcx>,\n-                            location: Location) {\n+    fn visit_assert_message(&mut self, msg: &AssertMessage<'tcx>, location: Location) {\n         self.record(\"AssertMessage\", msg);\n         self.record(match *msg {\n             EvalErrorKind::BoundsCheck { .. } => \"AssertMessage::BoundsCheck\",\n@@ -151,9 +146,7 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.super_assert_message(msg, location);\n     }\n \n-    fn visit_rvalue(&mut self,\n-                    rvalue: &Rvalue<'tcx>,\n-                    location: Location) {\n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         self.record(\"Rvalue\", rvalue);\n         let rvalue_kind = match *rvalue {\n             Rvalue::Use(..) => \"Rvalue::Use\",\n@@ -184,9 +177,7 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.super_rvalue(rvalue, location);\n     }\n \n-    fn visit_operand(&mut self,\n-                     operand: &Operand<'tcx>,\n-                     location: Location) {\n+    fn visit_operand(&mut self, operand: &Operand<'tcx>, location: Location) {\n         self.record(\"Operand\", operand);\n         self.record(match *operand {\n             Operand::Copy(..) => \"Operand::Copy\",\n@@ -234,42 +225,32 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.super_projection_elem(place, context, location);\n     }\n \n-    fn visit_constant(&mut self,\n-                      constant: &Constant<'tcx>,\n-                      location: Location) {\n+    fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         self.record(\"Constant\", constant);\n         self.super_constant(constant, location);\n     }\n \n-    fn visit_source_info(&mut self,\n-                         source_info: &SourceInfo) {\n+    fn visit_source_info(&mut self, source_info: &SourceInfo) {\n         self.record(\"SourceInfo\", source_info);\n         self.super_source_info(source_info);\n     }\n \n-    fn visit_closure_substs(&mut self,\n-                            substs: &ClosureSubsts<'tcx>,\n-                            _: Location) {\n+    fn visit_closure_substs(&mut self, substs: &ClosureSubsts<'tcx>, _: Location) {\n         self.record(\"ClosureSubsts\", substs);\n         self.super_closure_substs(substs);\n     }\n \n-    fn visit_const(&mut self,\n-                   constant: &&'tcx ty::Const<'tcx>,\n-                   _: Location) {\n+    fn visit_const(&mut self, constant: &&'tcx ty::Const<'tcx>, _: Location) {\n         self.record(\"Const\", constant);\n         self.super_const(constant);\n     }\n \n-    fn visit_local_decl(&mut self,\n-                        local: Local,\n-                        local_decl: &LocalDecl<'tcx>) {\n+    fn visit_local_decl(&mut self, local: Local, local_decl: &LocalDecl<'tcx>) {\n         self.record(\"LocalDecl\", local_decl);\n         self.super_local_decl(local, local_decl);\n     }\n \n-    fn visit_source_scope(&mut self,\n-                              scope: &SourceScope) {\n+    fn visit_source_scope(&mut self, scope: &SourceScope) {\n         self.record(\"VisiblityScope\", scope);\n         self.super_source_scope(scope);\n     }"}, {"sha": "74b010f57b01d7c1279b7375ef0ddb1c30210cd4", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 37, "deletions": 53, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/b365de94df941ae1bace2744620e453972560cdf/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b365de94df941ae1bace2744620e453972560cdf/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=b365de94df941ae1bace2744620e453972560cdf", "patch": "@@ -41,8 +41,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax_pos::{Span, DUMMY_SP};\n use self::Promotability::*;\n-use std::ops::{BitAnd, BitOr};\n-\n+use std::ops::{BitAnd, BitAndAssign, BitOr};\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n@@ -114,7 +113,7 @@ struct CheckCrateVisitor<'a, 'tcx: 'a> {\n }\n \n #[must_use]\n-#[derive(Debug, PartialEq)]\n+#[derive(Debug, Clone, Copy, PartialEq)]\n enum Promotability {\n     Promotable,\n     NotPromotable\n@@ -125,23 +124,25 @@ impl BitAnd for Promotability {\n \n     fn bitand(self, rhs: Self) -> Self {\n         match (self, rhs) {\n-            (Promotable, NotPromotable) => NotPromotable,\n-            (NotPromotable, Promotable) => NotPromotable,\n-            (NotPromotable, NotPromotable) => NotPromotable,\n             (Promotable, Promotable) => Promotable,\n+            _ => NotPromotable,\n         }\n     }\n }\n \n+impl BitAndAssign for Promotability {\n+    fn bitand_assign(&mut self, rhs: Self) {\n+        *self = *self & rhs\n+    }\n+}\n+\n impl BitOr for Promotability {\n     type Output = Self;\n \n     fn bitor(self, rhs: Self) -> Self {\n         match (self, rhs) {\n-            (Promotable, NotPromotable) => Promotable,\n-            (NotPromotable, Promotable) => Promotable,\n             (NotPromotable, NotPromotable) => NotPromotable,\n-            (Promotable, Promotable) => Promotable,\n+            _ => Promotable,\n         }\n     }\n }\n@@ -161,7 +162,7 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n \n     fn handle_const_fn_call(&mut self, def_id: DefId,\n                             ret_ty: Ty<'gcx>, span: Span) -> Promotability {\n-        if let NotPromotable = self.type_promotability(ret_ty) {\n+        if self.type_promotability(ret_ty) == NotPromotable {\n             return NotPromotable;\n         }\n \n@@ -266,9 +267,8 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n                             }\n                         }\n \n-                        match local.init {\n-                            Some(ref expr) => { let _ = self.check_expr(&expr); },\n-                            None => {},\n+                        if let Some(ref expr) = local.init {\n+                            let _ = self.check_expr(&expr);\n                         }\n                         NotPromotable\n                     }\n@@ -287,7 +287,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     fn check_expr(&mut self, ex: &'tcx hir::Expr) -> Promotability {\n         let node_ty = self.tables.node_id_to_type(ex.hir_id);\n         let mut outer = check_expr_kind(self, ex, node_ty);\n-        outer = outer & check_adjustments(self, ex);\n+        outer &= check_adjustments(self, ex);\n \n         // Handle borrows on (or inside the autorefs of) this expression.\n         if self.mut_rvalue_borrows.remove(&ex.id) {\n@@ -303,7 +303,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     fn check_block(&mut self, block: &'tcx hir::Block) -> Promotability {\n         let mut iter_result = Promotable;\n         for index in block.stmts.iter() {\n-            iter_result = iter_result & self.check_stmt(index);\n+            iter_result &= self.check_stmt(index);\n         }\n         match block.expr {\n             Some(ref box_expr) => iter_result & self.check_expr(&*box_expr),\n@@ -336,10 +336,7 @@ fn check_expr_kind<'a, 'tcx>(\n         }\n         hir::ExprKind::Unary(op, ref expr) => {\n             let expr_promotability = v.check_expr(expr);\n-            if v.tables.is_method_call(e) {\n-                return NotPromotable;\n-            }\n-            if op == hir::UnDeref {\n+            if v.tables.is_method_call(e) || op == hir::UnDeref {\n                 return NotPromotable;\n             }\n             expr_promotability\n@@ -353,8 +350,8 @@ fn check_expr_kind<'a, 'tcx>(\n             match v.tables.node_id_to_type(lhs.hir_id).sty {\n                 ty::RawPtr(_) => {\n                     assert!(op.node == hir::BinOpKind::Eq || op.node == hir::BinOpKind::Ne ||\n-                        op.node == hir::BinOpKind::Le || op.node == hir::BinOpKind::Lt ||\n-                        op.node == hir::BinOpKind::Ge || op.node == hir::BinOpKind::Gt);\n+                            op.node == hir::BinOpKind::Le || op.node == hir::BinOpKind::Lt ||\n+                            op.node == hir::BinOpKind::Ge || op.node == hir::BinOpKind::Gt);\n \n                     NotPromotable\n                 }\n@@ -400,7 +397,6 @@ fn check_expr_kind<'a, 'tcx>(\n                         debug!(\"Reference to Static(id={:?}) is unpromotable as it is not \\\n                                referenced from a static\", did);\n                         NotPromotable\n-\n                     }\n                 }\n \n@@ -425,7 +421,7 @@ fn check_expr_kind<'a, 'tcx>(\n         hir::ExprKind::Call(ref callee, ref hirvec) => {\n             let mut call_result = v.check_expr(callee);\n             for index in hirvec.iter() {\n-                call_result = call_result & v.check_expr(index);\n+                call_result &= v.check_expr(index);\n             }\n             let mut callee = &**callee;\n             loop {\n@@ -464,7 +460,7 @@ fn check_expr_kind<'a, 'tcx>(\n         hir::ExprKind::MethodCall(ref _pathsegment, ref _span, ref hirvec) => {\n             let mut method_call_result = Promotable;\n             for index in hirvec.iter() {\n-                method_call_result = method_call_result & v.check_expr(index);\n+                method_call_result &= v.check_expr(index);\n             }\n             if let Some(def) = v.tables.type_dependent_defs().get(e.hir_id) {\n                 let def_id = def.def_id();\n@@ -483,11 +479,10 @@ fn check_expr_kind<'a, 'tcx>(\n         hir::ExprKind::Struct(ref _qpath, ref hirvec, ref option_expr) => {\n             let mut struct_result = Promotable;\n             for index in hirvec.iter() {\n-                struct_result = struct_result & v.check_expr(&index.expr);\n+                struct_result &= v.check_expr(&index.expr);\n             }\n-            match *option_expr {\n-                Some(ref expr) => { struct_result = struct_result & v.check_expr(&expr); },\n-                None => {},\n+            if let Some(ref expr) = *option_expr {\n+                struct_result &= v.check_expr(&expr);\n             }\n             if let ty::Adt(adt, ..) = v.tables.expr_ty(e).sty {\n                 // unsafe_cell_type doesn't necessarily exist with no_core\n@@ -506,7 +501,7 @@ fn check_expr_kind<'a, 'tcx>(\n         }\n \n         hir::ExprKind::Closure(_capture_clause, ref _box_fn_decl,\n-                         body_id, _span, _option_generator_movability) => {\n+                               body_id, _span, _option_generator_movability) => {\n             let nested_body_promotable = v.check_nested_body(body_id);\n             // Paths in constant contexts cannot refer to local variables,\n             // as there are none, and thus closures can't have upvars there.\n@@ -543,7 +538,7 @@ fn check_expr_kind<'a, 'tcx>(\n         hir::ExprKind::Array(ref hirvec) => {\n             let mut array_result = Promotable;\n             for index in hirvec.iter() {\n-                array_result = array_result & v.check_expr(index);\n+                array_result &= v.check_expr(index);\n             }\n             array_result\n         }\n@@ -555,7 +550,7 @@ fn check_expr_kind<'a, 'tcx>(\n         hir::ExprKind::Tup(ref hirvec) => {\n             let mut tup_result = Promotable;\n             for index in hirvec.iter() {\n-                tup_result = tup_result & v.check_expr(index);\n+                tup_result &= v.check_expr(index);\n             }\n             tup_result\n         }\n@@ -576,23 +571,19 @@ fn check_expr_kind<'a, 'tcx>(\n             let _ = v.check_expr(expr);\n             for index in hirvec_arm.iter() {\n                 let _ = v.check_expr(&*index.body);\n-                match index.guard {\n-                    Some(hir::Guard::If(ref expr)) => {\n-                        let _ = v.check_expr(&expr);\n-                    },\n-                    None => {},\n-                };\n+                if let Some(hir::Guard::If(ref expr)) = index.guard {\n+                    let _ = v.check_expr(&expr);\n+                }\n             }\n             NotPromotable\n         }\n \n         hir::ExprKind::If(ref lhs, ref rhs, ref option_expr) => {\n             let _ = v.check_expr(lhs);\n             let _ = v.check_expr(rhs);\n-            match option_expr {\n-                Some(ref expr) => { let _ = v.check_expr(&expr); },\n-                None => {},\n-            };\n+            if let Some(ref expr) = option_expr {\n+                let _ = v.check_expr(&expr);\n+            }\n             NotPromotable\n         }\n \n@@ -610,9 +601,8 @@ fn check_expr_kind<'a, 'tcx>(\n \n         // More control flow (also not very meaningful).\n         hir::ExprKind::Break(_, ref option_expr) | hir::ExprKind::Ret(ref option_expr) => {\n-            match *option_expr {\n-                Some(ref expr) => { let _ = v.check_expr(&expr); },\n-                None => {},\n+            if let Some(ref expr) = *option_expr {\n+                 let _ = v.check_expr(&expr);\n             }\n             NotPromotable\n         }\n@@ -635,10 +625,7 @@ fn check_expr_kind<'a, 'tcx>(\n         }\n \n         hir::ExprKind::InlineAsm(ref _inline_asm, ref hirvec_lhs, ref hirvec_rhs) => {\n-            for index in hirvec_lhs.iter() {\n-                let _ = v.check_expr(index);\n-            }\n-            for index in hirvec_rhs.iter() {\n+            for index in hirvec_lhs.iter().chain(hirvec_rhs.iter()) {\n                 let _ = v.check_expr(index);\n             }\n             NotPromotable\n@@ -703,11 +690,8 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n         // These occur when we convert a &T or *T to a *U, as well as\n         // when making a thin pointer (e.g., `*T`) into a fat pointer\n         // (e.g., `*Trait`).\n-        match loan_cause {\n-            euv::LoanCause::AutoUnsafe => {\n-                return;\n-            }\n-            _ => {}\n+        if let euv::LoanCause::AutoUnsafe = loan_cause {\n+            return;\n         }\n \n         let mut cur = cmt;"}]}