{"sha": "06540cb205545e5e7e509933af27142ca35eae17", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2NTQwY2IyMDU1NDVlNWU3ZTUwOTkzM2FmMjcxNDJjYTM1ZWFlMTc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-02-17T07:07:09Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-06-23T23:11:39Z"}, "message": "rustc: Enable #[thread_local] for Windows\n\nI think LLVM has had support for quite some time now for this, we just never got\naround to testing it out and binding it. We've had some trouble landing this in\nthe past I believe, but it's time to try again!\n\nThis commit flags the `#[thread_local]` attribute as being available for Windows\ntargets and adds an implementation of `register_dtor` in the `thread::local`\nmodule to ensure we can destroy these keys. The same functionality is\nimplemented in clang via a function called `__tlregdtor` (presumably provided in\nsome Windows runtime somewhere), but this function unfortunately does not take a\ndata pointer (just a thunk) which means we can't easily call it. For now\ndestructors are just run in the same way the Linux fallback is implemented,\nwhich is just keeping track via a single OS-based TLS key.", "tree": {"sha": "61ae222629f05fdd91587e2b58e4dda3b95c1bea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61ae222629f05fdd91587e2b58e4dda3b95c1bea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06540cb205545e5e7e509933af27142ca35eae17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06540cb205545e5e7e509933af27142ca35eae17", "html_url": "https://github.com/rust-lang/rust/commit/06540cb205545e5e7e509933af27142ca35eae17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06540cb205545e5e7e509933af27142ca35eae17/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "622e7e6487b6fb7fdbb901720cd4214f9179ed67", "url": "https://api.github.com/repos/rust-lang/rust/commits/622e7e6487b6fb7fdbb901720cd4214f9179ed67", "html_url": "https://github.com/rust-lang/rust/commit/622e7e6487b6fb7fdbb901720cd4214f9179ed67"}], "stats": {"total": 250, "additions": 141, "deletions": 109}, "files": [{"sha": "7eb673d8b363cdb2c7f20fc2ea8e1cb0ebd4ea97", "filename": "src/librustc_back/target/x86_64_pc_windows_msvc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06540cb205545e5e7e509933af27142ca35eae17/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06540cb205545e5e7e509933af27142ca35eae17/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_msvc.rs?ref=06540cb205545e5e7e509933af27142ca35eae17", "patch": "@@ -15,6 +15,7 @@ pub fn target() -> TargetResult {\n     let mut base = super::windows_msvc_base::opts();\n     base.cpu = \"x86-64\".to_string();\n     base.max_atomic_width = Some(64);\n+    base.has_elf_tls = true;\n \n     Ok(Target {\n         llvm_target: \"x86_64-pc-windows-msvc\".to_string(),"}, {"sha": "6cdbe5df75d5162b2d0f051fb134af80ea95f612", "filename": "src/libstd/sys/unix/fast_thread_local.rs", "status": "modified", "additions": 7, "deletions": 104, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/06540cb205545e5e7e509933af27142ca35eae17/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06540cb205545e5e7e509933af27142ca35eae17/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs?ref=06540cb205545e5e7e509933af27142ca35eae17", "patch": "@@ -11,92 +11,6 @@\n #![cfg(target_thread_local)]\n #![unstable(feature = \"thread_local_internals\", issue = \"0\")]\n \n-use cell::{Cell, UnsafeCell};\n-use fmt;\n-use mem;\n-use ptr;\n-\n-pub struct Key<T> {\n-    inner: UnsafeCell<Option<T>>,\n-\n-    // Metadata to keep track of the state of the destructor. Remember that\n-    // these variables are thread-local, not global.\n-    dtor_registered: Cell<bool>,\n-    dtor_running: Cell<bool>,\n-}\n-\n-impl<T> fmt::Debug for Key<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.pad(\"Key { .. }\")\n-    }\n-}\n-\n-unsafe impl<T> ::marker::Sync for Key<T> { }\n-\n-impl<T> Key<T> {\n-    pub const fn new() -> Key<T> {\n-        Key {\n-            inner: UnsafeCell::new(None),\n-            dtor_registered: Cell::new(false),\n-            dtor_running: Cell::new(false)\n-        }\n-    }\n-\n-    pub fn get(&'static self) -> Option<&'static UnsafeCell<Option<T>>> {\n-        unsafe {\n-            if mem::needs_drop::<T>() && self.dtor_running.get() {\n-                return None\n-            }\n-            self.register_dtor();\n-        }\n-        Some(&self.inner)\n-    }\n-\n-    unsafe fn register_dtor(&self) {\n-        if !mem::needs_drop::<T>() || self.dtor_registered.get() {\n-            return\n-        }\n-\n-        register_dtor(self as *const _ as *mut u8,\n-                      destroy_value::<T>);\n-        self.dtor_registered.set(true);\n-    }\n-}\n-\n-#[cfg(any(target_os = \"linux\", target_os = \"fuchsia\"))]\n-unsafe fn register_dtor_fallback(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n-    // The fallback implementation uses a vanilla OS-based TLS key to track\n-    // the list of destructors that need to be run for this thread. The key\n-    // then has its own destructor which runs all the other destructors.\n-    //\n-    // The destructor for DTORS is a little special in that it has a `while`\n-    // loop to continuously drain the list of registered destructors. It\n-    // *should* be the case that this loop always terminates because we\n-    // provide the guarantee that a TLS key cannot be set after it is\n-    // flagged for destruction.\n-    use sys_common::thread_local as os;\n-\n-    static DTORS: os::StaticKey = os::StaticKey::new(Some(run_dtors));\n-    type List = Vec<(*mut u8, unsafe extern fn(*mut u8))>;\n-    if DTORS.get().is_null() {\n-        let v: Box<List> = box Vec::new();\n-        DTORS.set(Box::into_raw(v) as *mut u8);\n-    }\n-    let list: &mut List = &mut *(DTORS.get() as *mut List);\n-    list.push((t, dtor));\n-\n-    unsafe extern fn run_dtors(mut ptr: *mut u8) {\n-        while !ptr.is_null() {\n-            let list: Box<List> = Box::from_raw(ptr as *mut List);\n-            for &(ptr, dtor) in list.iter() {\n-                dtor(ptr);\n-            }\n-            ptr = DTORS.get();\n-            DTORS.set(ptr::null_mut());\n-        }\n-    }\n-}\n-\n // Since what appears to be glibc 2.18 this symbol has been shipped which\n // GCC and clang both use to invoke destructors in thread_local globals, so\n // let's do the same!\n@@ -107,9 +21,10 @@ unsafe fn register_dtor_fallback(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n //\n // Due to rust-lang/rust#18804, make sure this is not generic!\n #[cfg(target_os = \"linux\")]\n-unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n-    use mem;\n+pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n     use libc;\n+    use mem;\n+    use sys_common::thread_local::register_dtor_fallback;\n \n     extern {\n         #[linkage = \"extern_weak\"]\n@@ -132,7 +47,7 @@ unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n // The disassembly of thread_local globals in C++ (at least produced by\n // clang) will have this show up in the output.\n #[cfg(target_os = \"macos\")]\n-unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n+pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n     extern {\n         fn _tlv_atexit(dtor: unsafe extern fn(*mut u8),\n                        arg: *mut u8);\n@@ -143,17 +58,9 @@ unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n // Just use the thread_local fallback implementation, at least until there's\n // a more direct implementation.\n #[cfg(target_os = \"fuchsia\")]\n-unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n-    register_dtor_fallback(t, dtor);\n-}\n-\n-pub unsafe extern fn destroy_value<T>(ptr: *mut u8) {\n-    let ptr = ptr as *mut Key<T>;\n-    // Right before we run the user destructor be sure to flag the\n-    // destructor as running for this thread so calls to `get` will return\n-    // `None`.\n-    (*ptr).dtor_running.set(true);\n+pub use sys_common::thread_local::register_dtor_fallback as register_dtor;\n \n+pub fn requires_move_before_drop() -> bool {\n     // The macOS implementation of TLS apparently had an odd aspect to it\n     // where the pointer we have may be overwritten while this destructor\n     // is running. Specifically if a TLS destructor re-accesses TLS it may\n@@ -166,9 +73,5 @@ pub unsafe extern fn destroy_value<T>(ptr: *mut u8) {\n     //\n     // Hence, we use `ptr::read` on macOS (to move to a \"safe\" location)\n     // instead of drop_in_place.\n-    if cfg!(target_os = \"macos\") {\n-        ptr::read((*ptr).inner.get());\n-    } else {\n-        ptr::drop_in_place((*ptr).inner.get());\n-    }\n+    cfg!(target_os = \"macos\")\n }"}, {"sha": "9fee9bd93b47e090d5512b221f7f70dad1de8d49", "filename": "src/libstd/sys/windows/fast_thread_local.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/06540cb205545e5e7e509933af27142ca35eae17/src%2Flibstd%2Fsys%2Fwindows%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06540cb205545e5e7e509933af27142ca35eae17/src%2Flibstd%2Fsys%2Fwindows%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffast_thread_local.rs?ref=06540cb205545e5e7e509933af27142ca35eae17", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![unstable(feature = \"thread_local_internals\", issue = \"0\")]\n+#![cfg(target_thread_local)]\n+\n+pub use sys_common::thread_local::register_dtor_fallback as register_dtor;\n+\n+pub fn requires_move_before_drop() -> bool {\n+    false\n+}"}, {"sha": "840e7fdfc9b26942c56e4e5d11d8c038707072ad", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06540cb205545e5e7e509933af27142ca35eae17/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06540cb205545e5e7e509933af27142ca35eae17/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=06540cb205545e5e7e509933af27142ca35eae17", "patch": "@@ -26,6 +26,7 @@ pub mod condvar;\n pub mod dynamic_lib;\n pub mod env;\n pub mod ext;\n+pub mod fast_thread_local;\n pub mod fs;\n pub mod handle;\n pub mod memchr;"}, {"sha": "7592eda16f061c9ef058f1f9678b5664aa86874b", "filename": "src/libstd/sys_common/thread_local.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/06540cb205545e5e7e509933af27142ca35eae17/src%2Flibstd%2Fsys_common%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06540cb205545e5e7e509933af27142ca35eae17/src%2Flibstd%2Fsys_common%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fthread_local.rs?ref=06540cb205545e5e7e509933af27142ca35eae17", "patch": "@@ -58,8 +58,8 @@\n #![unstable(feature = \"thread_local_internals\", issue = \"0\")]\n #![allow(dead_code)] // sys isn't exported yet\n \n+use ptr;\n use sync::atomic::{self, AtomicUsize, Ordering};\n-\n use sys::thread_local as imp;\n use sys_common::mutex::Mutex;\n \n@@ -238,6 +238,39 @@ impl Drop for Key {\n     }\n }\n \n+pub unsafe fn register_dtor_fallback(t: *mut u8,\n+                                     dtor: unsafe extern fn(*mut u8)) {\n+    // The fallback implementation uses a vanilla OS-based TLS key to track\n+    // the list of destructors that need to be run for this thread. The key\n+    // then has its own destructor which runs all the other destructors.\n+    //\n+    // The destructor for DTORS is a little special in that it has a `while`\n+    // loop to continuously drain the list of registered destructors. It\n+    // *should* be the case that this loop always terminates because we\n+    // provide the guarantee that a TLS key cannot be set after it is\n+    // flagged for destruction.\n+\n+    static DTORS: StaticKey = StaticKey::new(Some(run_dtors));\n+    type List = Vec<(*mut u8, unsafe extern fn(*mut u8))>;\n+    if DTORS.get().is_null() {\n+        let v: Box<List> = box Vec::new();\n+        DTORS.set(Box::into_raw(v) as *mut u8);\n+    }\n+    let list: &mut List = &mut *(DTORS.get() as *mut List);\n+    list.push((t, dtor));\n+\n+    unsafe extern fn run_dtors(mut ptr: *mut u8) {\n+        while !ptr.is_null() {\n+            let list: Box<List> = Box::from_raw(ptr as *mut List);\n+            for &(ptr, dtor) in list.iter() {\n+                dtor(ptr);\n+            }\n+            ptr = DTORS.get();\n+            DTORS.set(ptr::null_mut());\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::{Key, StaticKey};"}, {"sha": "dad21473eae1e043f61c45aa96efc79b6c450e1a", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 79, "deletions": 3, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/06540cb205545e5e7e509933af27142ca35eae17/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06540cb205545e5e7e509933af27142ca35eae17/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=06540cb205545e5e7e509933af27142ca35eae17", "patch": "@@ -333,6 +333,82 @@ impl<T: 'static> LocalKey<T> {\n     }\n }\n \n+#[doc(hidden)]\n+#[cfg(target_thread_local)]\n+pub mod fast {\n+    use cell::{Cell, UnsafeCell};\n+    use fmt;\n+    use mem;\n+    use ptr;\n+    use sys::fast_thread_local::{register_dtor, requires_move_before_drop};\n+\n+    pub struct Key<T> {\n+        inner: UnsafeCell<Option<T>>,\n+\n+        // Metadata to keep track of the state of the destructor. Remember that\n+        // these variables are thread-local, not global.\n+        dtor_registered: Cell<bool>,\n+        dtor_running: Cell<bool>,\n+    }\n+\n+    impl<T> fmt::Debug for Key<T> {\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            f.pad(\"Key { .. }\")\n+        }\n+    }\n+\n+    unsafe impl<T> ::marker::Sync for Key<T> { }\n+\n+    impl<T> Key<T> {\n+        pub const fn new() -> Key<T> {\n+            Key {\n+                inner: UnsafeCell::new(None),\n+                dtor_registered: Cell::new(false),\n+                dtor_running: Cell::new(false)\n+            }\n+        }\n+\n+        pub fn get(&'static self) -> Option<&'static UnsafeCell<Option<T>>> {\n+            unsafe {\n+                if mem::needs_drop::<T>() && self.dtor_running.get() {\n+                    return None\n+                }\n+                self.register_dtor();\n+            }\n+            Some(&self.inner)\n+        }\n+\n+        unsafe fn register_dtor(&self) {\n+            if !mem::needs_drop::<T>() || self.dtor_registered.get() {\n+                return\n+            }\n+\n+            register_dtor(self as *const _ as *mut u8,\n+                          destroy_value::<T>);\n+            self.dtor_registered.set(true);\n+        }\n+    }\n+\n+    unsafe extern fn destroy_value<T>(ptr: *mut u8) {\n+        let ptr = ptr as *mut Key<T>;\n+        // Right before we run the user destructor be sure to flag the\n+        // destructor as running for this thread so calls to `get` will return\n+        // `None`.\n+        (*ptr).dtor_running.set(true);\n+\n+        // Some implementations may require us to move the value before we drop\n+        // it as it could get re-initialized in-place during destruction.\n+        //\n+        // Hence, we use `ptr::read` on those platforms (to move to a \"safe\"\n+        // location) instead of drop_in_place.\n+        if requires_move_before_drop() {\n+            ptr::read((*ptr).inner.get());\n+        } else {\n+            ptr::drop_in_place((*ptr).inner.get());\n+        }\n+    }\n+}\n+\n #[doc(hidden)]\n pub mod os {\n     use cell::{Cell, UnsafeCell};\n@@ -378,8 +454,8 @@ pub mod os {\n                     return Some(&(*ptr).value);\n                 }\n \n-                // If the lookup returned null, we haven't initialized our own local\n-                // copy, so do that now.\n+                // If the lookup returned null, we haven't initialized our own\n+                // local copy, so do that now.\n                 let ptr: Box<Value<T>> = box Value {\n                     key: self,\n                     value: UnsafeCell::new(None),\n@@ -391,7 +467,7 @@ pub mod os {\n         }\n     }\n \n-    pub unsafe extern fn destroy_value<T: 'static>(ptr: *mut u8) {\n+    unsafe extern fn destroy_value<T: 'static>(ptr: *mut u8) {\n         // The OS TLS ensures that this key contains a NULL value when this\n         // destructor starts to run. We set it back to a sentinel value of 1 to\n         // ensure that any future calls to `get` for this thread will return"}, {"sha": "743b7c3220a8995457c48ba571f7a5d96b530fb9", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06540cb205545e5e7e509933af27142ca35eae17/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06540cb205545e5e7e509933af27142ca35eae17/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=06540cb205545e5e7e509933af27142ca35eae17", "patch": "@@ -172,7 +172,7 @@ pub use self::local::{LocalKey, LocalKeyState};\n \n #[unstable(feature = \"libstd_thread_internals\", issue = \"0\")]\n #[cfg(target_thread_local)]\n-#[doc(hidden)] pub use sys::fast_thread_local::Key as __FastLocalKeyInner;\n+#[doc(hidden)] pub use self::local::fast::Key as __FastLocalKeyInner;\n #[unstable(feature = \"libstd_thread_internals\", issue = \"0\")]\n #[doc(hidden)] pub use self::local::os::Key as __OsLocalKeyInner;\n "}]}