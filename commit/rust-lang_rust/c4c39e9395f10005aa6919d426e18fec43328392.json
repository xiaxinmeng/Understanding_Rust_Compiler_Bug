{"sha": "c4c39e9395f10005aa6919d426e18fec43328392", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0YzM5ZTkzOTVmMTAwMDVhYTY5MTlkNDI2ZTE4ZmVjNDMzMjgzOTI=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-10-06T09:42:14Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-11-10T18:22:38Z"}, "message": "codegen_llvm_back: use Cow<'static, str> where applicable", "tree": {"sha": "355db5d2d3cbc2db293fbae336ecdcb55169ddfd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/355db5d2d3cbc2db293fbae336ecdcb55169ddfd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4c39e9395f10005aa6919d426e18fec43328392", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4c39e9395f10005aa6919d426e18fec43328392", "html_url": "https://github.com/rust-lang/rust/commit/c4c39e9395f10005aa6919d426e18fec43328392", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4c39e9395f10005aa6919d426e18fec43328392/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d1dc48407e9feb5443173aefb3fd0db252e82c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d1dc48407e9feb5443173aefb3fd0db252e82c7", "html_url": "https://github.com/rust-lang/rust/commit/1d1dc48407e9feb5443173aefb3fd0db252e82c7"}], "stats": {"total": 43, "additions": 21, "deletions": 22}, "files": [{"sha": "a69d5b7fd9b99e43ffe92dc304fdb498db1b72ed", "filename": "src/librustc_codegen_llvm/back/archive.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c4c39e9395f10005aa6919d426e18fec43328392/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4c39e9395f10005aa6919d426e18fec43328392/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs?ref=c4c39e9395f10005aa6919d426e18fec43328392", "patch": "@@ -282,10 +282,9 @@ impl<'a> ArchiveBuilder<'a> {\n             let ret = if r.into_result().is_err() {\n                 let err = llvm::LLVMRustGetLastError();\n                 let msg = if err.is_null() {\n-                    \"failed to write archive\".to_string()\n+                    \"failed to write archive\".into()\n                 } else {\n                     String::from_utf8_lossy(CStr::from_ptr(err).to_bytes())\n-                            .into_owned()\n                 };\n                 Err(io::Error::new(io::ErrorKind::Other, msg))\n             } else {"}, {"sha": "c6cb94a7e3395729dae12e6ef91a9149c0b8876a", "filename": "src/librustc_codegen_llvm/back/bytecode.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c4c39e9395f10005aa6919d426e18fec43328392/src%2Flibrustc_codegen_llvm%2Fback%2Fbytecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4c39e9395f10005aa6919d426e18fec43328392/src%2Flibrustc_codegen_llvm%2Fback%2Fbytecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fbytecode.rs?ref=c4c39e9395f10005aa6919d426e18fec43328392", "patch": "@@ -106,39 +106,39 @@ pub struct DecodedBytecode<'a> {\n }\n \n impl<'a> DecodedBytecode<'a> {\n-    pub fn new(data: &'a [u8]) -> Result<DecodedBytecode<'a>, String> {\n+    pub fn new(data: &'a [u8]) -> Result<DecodedBytecode<'a>, &'static str> {\n         if !data.starts_with(RLIB_BYTECODE_OBJECT_MAGIC) {\n-            return Err(\"magic bytecode prefix not found\".to_string())\n+            return Err(\"magic bytecode prefix not found\")\n         }\n         let data = &data[RLIB_BYTECODE_OBJECT_MAGIC.len()..];\n         if !data.starts_with(&[RLIB_BYTECODE_OBJECT_VERSION, 0, 0, 0]) {\n-            return Err(\"wrong version prefix found in bytecode\".to_string())\n+            return Err(\"wrong version prefix found in bytecode\")\n         }\n         let data = &data[4..];\n         if data.len() < 4 {\n-            return Err(\"bytecode corrupted\".to_string())\n+            return Err(\"bytecode corrupted\")\n         }\n         let identifier_len = unsafe {\n             u32::from_le(ptr::read_unaligned(data.as_ptr() as *const u32)) as usize\n         };\n         let data = &data[4..];\n         if data.len() < identifier_len {\n-            return Err(\"bytecode corrupted\".to_string())\n+            return Err(\"bytecode corrupted\")\n         }\n         let identifier = match str::from_utf8(&data[..identifier_len]) {\n             Ok(s) => s,\n-            Err(_) => return Err(\"bytecode corrupted\".to_string())\n+            Err(_) => return Err(\"bytecode corrupted\")\n         };\n         let data = &data[identifier_len..];\n         if data.len() < 8 {\n-            return Err(\"bytecode corrupted\".to_string())\n+            return Err(\"bytecode corrupted\")\n         }\n         let bytecode_len = unsafe {\n             u64::from_le(ptr::read_unaligned(data.as_ptr() as *const u64)) as usize\n         };\n         let data = &data[8..];\n         if data.len() < bytecode_len {\n-            return Err(\"bytecode corrupted\".to_string())\n+            return Err(\"bytecode corrupted\")\n         }\n         let encoded_bytecode = &data[..bytecode_len];\n "}, {"sha": "5521ddf0e6a3871eeb338c17f738857a67e5b3bb", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c4c39e9395f10005aa6919d426e18fec43328392/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4c39e9395f10005aa6919d426e18fec43328392/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=c4c39e9395f10005aa6919d426e18fec43328392", "patch": "@@ -296,7 +296,7 @@ fn fat_lto(cgcx: &CodegenContext,\n                 let data = bc_decoded.data();\n                 linker.add(&data).map_err(|()| {\n                     let msg = format!(\"failed to load bc of {:?}\", name);\n-                    write::llvm_err(&diag_handler, msg)\n+                    write::llvm_err(&diag_handler, &msg)\n                 })\n             })?;\n             timeline.record(&format!(\"link {:?}\", name));\n@@ -490,7 +490,7 @@ fn thin_lto(cgcx: &CodegenContext,\n             symbol_white_list.as_ptr(),\n             symbol_white_list.len() as u32,\n         ).ok_or_else(|| {\n-            write::llvm_err(&diag_handler, \"failed to prepare thin LTO context\".to_string())\n+            write::llvm_err(&diag_handler, \"failed to prepare thin LTO context\")\n         })?;\n \n         info!(\"thin LTO data created\");\n@@ -746,7 +746,7 @@ impl ThinModule {\n     {\n         let diag_handler = cgcx.create_diag_handler();\n         let tm = (cgcx.tm_factory)().map_err(|e| {\n-            write::llvm_err(&diag_handler, e)\n+            write::llvm_err(&diag_handler, &e)\n         })?;\n \n         // Right now the implementation we've got only works over serialized\n@@ -761,7 +761,7 @@ impl ThinModule {\n             self.data().len(),\n             self.shared.module_names[self.idx].as_ptr(),\n         ).ok_or_else(|| {\n-            let msg = \"failed to parse bitcode for thin LTO module\".to_string();\n+            let msg = \"failed to parse bitcode for thin LTO module\";\n             write::llvm_err(&diag_handler, msg)\n         })? as *const _;\n         let module = ModuleCodegen {\n@@ -785,7 +785,7 @@ impl ThinModule {\n             let mut cu2 = ptr::null_mut();\n             llvm::LLVMRustThinLTOGetDICompileUnit(llmod, &mut cu1, &mut cu2);\n             if !cu2.is_null() {\n-                let msg = \"multiple source DICompileUnits found\".to_string();\n+                let msg = \"multiple source DICompileUnits found\";\n                 return Err(write::llvm_err(&diag_handler, msg))\n             }\n \n@@ -806,25 +806,25 @@ impl ThinModule {\n             // You can find some more comments about these functions in the LLVM\n             // bindings we've got (currently `PassWrapper.cpp`)\n             if !llvm::LLVMRustPrepareThinLTORename(self.shared.data.0, llmod) {\n-                let msg = \"failed to prepare thin LTO module\".to_string();\n+                let msg = \"failed to prepare thin LTO module\";\n                 return Err(write::llvm_err(&diag_handler, msg))\n             }\n             cgcx.save_temp_bitcode(&module, \"thin-lto-after-rename\");\n             timeline.record(\"rename\");\n             if !llvm::LLVMRustPrepareThinLTOResolveWeak(self.shared.data.0, llmod) {\n-                let msg = \"failed to prepare thin LTO module\".to_string();\n+                let msg = \"failed to prepare thin LTO module\";\n                 return Err(write::llvm_err(&diag_handler, msg))\n             }\n             cgcx.save_temp_bitcode(&module, \"thin-lto-after-resolve\");\n             timeline.record(\"resolve\");\n             if !llvm::LLVMRustPrepareThinLTOInternalize(self.shared.data.0, llmod) {\n-                let msg = \"failed to prepare thin LTO module\".to_string();\n+                let msg = \"failed to prepare thin LTO module\";\n                 return Err(write::llvm_err(&diag_handler, msg))\n             }\n             cgcx.save_temp_bitcode(&module, \"thin-lto-after-internalize\");\n             timeline.record(\"internalize\");\n             if !llvm::LLVMRustPrepareThinLTOImport(self.shared.data.0, llmod) {\n-                let msg = \"failed to prepare thin LTO module\".to_string();\n+                let msg = \"failed to prepare thin LTO module\";\n                 return Err(write::llvm_err(&diag_handler, msg))\n             }\n             cgcx.save_temp_bitcode(&module, \"thin-lto-after-import\");"}, {"sha": "f5c7da138c472d922a9cb925d95578de74e2d40c", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c4c39e9395f10005aa6919d426e18fec43328392/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4c39e9395f10005aa6919d426e18fec43328392/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=c4c39e9395f10005aa6919d426e18fec43328392", "patch": "@@ -90,7 +90,7 @@ pub const TLS_MODEL_ARGS : [(&'static str, llvm::ThreadLocalMode); 4] = [\n \n const PRE_THIN_LTO_BC_EXT: &str = \"pre-thin-lto.bc\";\n \n-pub fn llvm_err(handler: &errors::Handler, msg: String) -> FatalError {\n+pub fn llvm_err(handler: &errors::Handler, msg: &str) -> FatalError {\n     match llvm::last_error() {\n         Some(err) => handler.fatal(&format!(\"{}: {}\", msg, err)),\n         None => handler.fatal(&msg),\n@@ -109,7 +109,7 @@ pub fn write_output_file(\n         let result = llvm::LLVMRustWriteOutputFile(target, pm, m, output_c.as_ptr(), file_type);\n         if result.into_result().is_err() {\n             let msg = format!(\"could not write output to {}\", output.display());\n-            Err(llvm_err(handler, msg))\n+            Err(llvm_err(handler, &msg))\n         } else {\n             Ok(())\n         }\n@@ -139,7 +139,7 @@ pub fn create_target_machine(\n     find_features: bool,\n ) -> &'static mut llvm::TargetMachine {\n     target_machine_factory(sess, find_features)().unwrap_or_else(|err| {\n-        llvm_err(sess.diagnostic(), err).raise()\n+        llvm_err(sess.diagnostic(), &err).raise()\n     })\n }\n "}]}