{"sha": "4b6af9704ae183cb76027624f3f8a5d51eb7dc26", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiNmFmOTcwNGFlMTgzY2I3NjAyNzYyNGYzZjhhNWQ1MWViN2RjMjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-08T04:22:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-08T04:22:49Z"}, "message": "Auto merge of #43072 - cuviper:linux-stack-guard, r=alexcrichton\n\nSkip the main thread's manual stack guard on Linux\n\nLinux doesn't allocate the whole stack right away, and the kernel has its own stack-guard mechanism to fault when growing too close to an existing mapping.  If we map our own guard, then the kernel starts enforcing a rather large gap above that, rendering much of the possible stack space useless.\n\nInstead, we'll just note where we expect rlimit to start faulting, so our handler can report \"stack overflow\", and trust that the kernel's own stack guard will work.\n\nFixes #43052.\nr? @alexcrichton\n\n### Kernel compatibility:\n\nStrictly speaking, Rust claims support for Linux kernels >= 2.6.18, and stack guards were only added to mainline in 2.6.36 for [CVE-2010-2240].  But since that vulnerability was so severe, the guards were backported to many stable branches, and Red Hat patched this all the way back to RHEL3's 2.4.21!  I think it's reasonable for us to assume that any *supportable* kernel should have these stack guards.\n\nAt that time, the kernel only enforced one page of padding between the stack and other mappings, but thanks to [Stack Clash] that padding is now much larger, causing #43052.  The kernel side of those fixes are in [CVE-2017-1000364], which Red Hat has backported to at least RHEL5's 2.6.18 so far.\n\n[CVE-2010-2240]: https://access.redhat.com/security/cve/CVE-2010-2240\n[CVE-2017-1000364]: https://access.redhat.com/security/cve/CVE-2017-1000364\n[Stack Clash]: https://access.redhat.com/security/vulnerabilities/stackguard", "tree": {"sha": "b189a4bf553eecf5c5a330b4a42191d261ed0cee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b189a4bf553eecf5c5a330b4a42191d261ed0cee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b6af9704ae183cb76027624f3f8a5d51eb7dc26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b6af9704ae183cb76027624f3f8a5d51eb7dc26", "html_url": "https://github.com/rust-lang/rust/commit/4b6af9704ae183cb76027624f3f8a5d51eb7dc26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b6af9704ae183cb76027624f3f8a5d51eb7dc26/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb4fa6080fe597d5234371c21fa79523e1492a9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb4fa6080fe597d5234371c21fa79523e1492a9a", "html_url": "https://github.com/rust-lang/rust/commit/fb4fa6080fe597d5234371c21fa79523e1492a9a"}, {"sha": "be509b3387aebb453b09a4942cf902c7d05a0f1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/be509b3387aebb453b09a4942cf902c7d05a0f1e", "html_url": "https://github.com/rust-lang/rust/commit/be509b3387aebb453b09a4942cf902c7d05a0f1e"}], "stats": {"total": 44, "additions": 29, "deletions": 15}, "files": [{"sha": "15747746611c9dd72efac438e8b52fe5c96869b5", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4b6af9704ae183cb76027624f3f8a5d51eb7dc26/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b6af9704ae183cb76027624f3f8a5d51eb7dc26/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=4b6af9704ae183cb76027624f3f8a5d51eb7dc26", "patch": "@@ -264,23 +264,37 @@ pub mod guard {\n                 as *mut libc::c_void;\n         }\n \n-        // Rellocate the last page of the stack.\n-        // This ensures SIGBUS will be raised on\n-        // stack overflow.\n-        let result = mmap(stackaddr, psize, PROT_NONE,\n-                          MAP_PRIVATE | MAP_ANON | MAP_FIXED, -1, 0);\n-\n-        if result != stackaddr || result == MAP_FAILED {\n-            panic!(\"failed to allocate a guard page\");\n-        }\n-\n-        let offset = if cfg!(any(target_os = \"linux\", target_os = \"freebsd\")) {\n-            2\n+        if cfg!(target_os = \"linux\") {\n+            // Linux doesn't allocate the whole stack right away, and\n+            // the kernel has its own stack-guard mechanism to fault\n+            // when growing too close to an existing mapping.  If we map\n+            // our own guard, then the kernel starts enforcing a rather\n+            // large gap above that, rendering much of the possible\n+            // stack space useless.  See #43052.\n+            //\n+            // Instead, we'll just note where we expect rlimit to start\n+            // faulting, so our handler can report \"stack overflow\", and\n+            // trust that the kernel's own stack guard will work.\n+            Some(stackaddr as usize)\n         } else {\n-            1\n-        };\n+            // Reallocate the last page of the stack.\n+            // This ensures SIGBUS will be raised on\n+            // stack overflow.\n+            let result = mmap(stackaddr, psize, PROT_NONE,\n+                              MAP_PRIVATE | MAP_ANON | MAP_FIXED, -1, 0);\n+\n+            if result != stackaddr || result == MAP_FAILED {\n+                panic!(\"failed to allocate a guard page\");\n+            }\n \n-        Some(stackaddr as usize + offset * psize)\n+            let offset = if cfg!(target_os = \"freebsd\") {\n+                2\n+            } else {\n+                1\n+            };\n+\n+            Some(stackaddr as usize + offset * psize)\n+        }\n     }\n \n     #[cfg(target_os = \"solaris\")]"}]}