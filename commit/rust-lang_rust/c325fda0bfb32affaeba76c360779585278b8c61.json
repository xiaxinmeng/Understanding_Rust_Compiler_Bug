{"sha": "c325fda0bfb32affaeba76c360779585278b8c61", "node_id": "C_kwDOAAsO6NoAKGMzMjVmZGEwYmZiMzJhZmZhZWJhNzZjMzYwNzc5NTg1Mjc4YjhjNjE", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2023-04-04T04:20:45Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2023-04-05T14:49:30Z"}, "message": "rustdoc: migrate `item_union` to an Askama template", "tree": {"sha": "9e052878fb72b9e3b088bc1ff1ad88ea4df99350", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e052878fb72b9e3b088bc1ff1ad88ea4df99350"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c325fda0bfb32affaeba76c360779585278b8c61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c325fda0bfb32affaeba76c360779585278b8c61", "html_url": "https://github.com/rust-lang/rust/commit/c325fda0bfb32affaeba76c360779585278b8c61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c325fda0bfb32affaeba76c360779585278b8c61/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19f9f658d64c4cb3eae674db677aabbe9b41cb0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/19f9f658d64c4cb3eae674db677aabbe9b41cb0f", "html_url": "https://github.com/rust-lang/rust/commit/19f9f658d64c4cb3eae674db677aabbe9b41cb0f"}], "stats": {"total": 677, "additions": 384, "deletions": 293}, "files": [{"sha": "77c2cd5b425d890c6147218f10db59a3625bdc70", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c325fda0bfb32affaeba76c360779585278b8c61/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c325fda0bfb32affaeba76c360779585278b8c61/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=c325fda0bfb32affaeba76c360779585278b8c61", "patch": "@@ -136,10 +136,6 @@ impl Buffer {\n         self.into_inner()\n     }\n \n-    pub(crate) fn is_for_html(&self) -> bool {\n-        self.for_html\n-    }\n-\n     pub(crate) fn reserve(&mut self, additional: usize) {\n         self.buffer.reserve(additional)\n     }"}, {"sha": "1e3cd2668506fa6b4ac49379ef018b59de739029", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 42, "deletions": 35, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/c325fda0bfb32affaeba76c360779585278b8c61/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c325fda0bfb32affaeba76c360779585278b8c61/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=c325fda0bfb32affaeba76c360779585278b8c61", "patch": "@@ -660,7 +660,7 @@ fn short_item_info(\n // \"Auto Trait Implementations,\" \"Blanket Trait Implementations\" (on struct/enum pages).\n pub(crate) fn render_impls(\n     cx: &mut Context<'_>,\n-    w: &mut Buffer,\n+    mut w: impl Write,\n     impls: &[&Impl],\n     containing_item: &clean::Item,\n     toggle_open_by_default: bool,\n@@ -672,7 +672,7 @@ pub(crate) fn render_impls(\n             let did = i.trait_did().unwrap();\n             let provided_trait_methods = i.inner_impl().provided_trait_methods(tcx);\n             let assoc_link = AssocItemLink::GotoSource(did.into(), &provided_trait_methods);\n-            let mut buffer = if w.is_for_html() { Buffer::html() } else { Buffer::new() };\n+            let mut buffer = Buffer::new();\n             render_impl(\n                 &mut buffer,\n                 cx,\n@@ -693,7 +693,7 @@ pub(crate) fn render_impls(\n         })\n         .collect::<Vec<_>>();\n     rendered_impls.sort();\n-    w.write_str(&rendered_impls.join(\"\"));\n+    w.write_str(&rendered_impls.join(\"\")).unwrap();\n }\n \n /// Build a (possibly empty) `href` attribute (a key-value pair) for the given associated item.\n@@ -1080,61 +1080,68 @@ impl<'a> AssocItemLink<'a> {\n     }\n }\n \n-fn write_impl_section_heading(w: &mut Buffer, title: &str, id: &str) {\n+fn write_impl_section_heading(mut w: impl fmt::Write, title: &str, id: &str) {\n     write!(\n         w,\n         \"<h2 id=\\\"{id}\\\" class=\\\"small-section-header\\\">\\\n             {title}\\\n             <a href=\\\"#{id}\\\" class=\\\"anchor\\\">\u00a7</a>\\\n          </h2>\"\n-    );\n+    )\n+    .unwrap();\n }\n \n pub(crate) fn render_all_impls(\n-    w: &mut Buffer,\n+    mut w: impl Write,\n     cx: &mut Context<'_>,\n     containing_item: &clean::Item,\n     concrete: &[&Impl],\n     synthetic: &[&Impl],\n     blanket_impl: &[&Impl],\n ) {\n-    let mut impls = Buffer::empty_from(w);\n+    let mut impls = Buffer::html();\n     render_impls(cx, &mut impls, concrete, containing_item, true);\n     let impls = impls.into_inner();\n     if !impls.is_empty() {\n-        write_impl_section_heading(w, \"Trait Implementations\", \"trait-implementations\");\n-        write!(w, \"<div id=\\\"trait-implementations-list\\\">{}</div>\", impls);\n+        write_impl_section_heading(&mut w, \"Trait Implementations\", \"trait-implementations\");\n+        write!(w, \"<div id=\\\"trait-implementations-list\\\">{}</div>\", impls).unwrap();\n     }\n \n     if !synthetic.is_empty() {\n-        write_impl_section_heading(w, \"Auto Trait Implementations\", \"synthetic-implementations\");\n-        w.write_str(\"<div id=\\\"synthetic-implementations-list\\\">\");\n-        render_impls(cx, w, synthetic, containing_item, false);\n-        w.write_str(\"</div>\");\n+        write_impl_section_heading(\n+            &mut w,\n+            \"Auto Trait Implementations\",\n+            \"synthetic-implementations\",\n+        );\n+        w.write_str(\"<div id=\\\"synthetic-implementations-list\\\">\").unwrap();\n+        render_impls(cx, &mut w, synthetic, containing_item, false);\n+        w.write_str(\"</div>\").unwrap();\n     }\n \n     if !blanket_impl.is_empty() {\n-        write_impl_section_heading(w, \"Blanket Implementations\", \"blanket-implementations\");\n-        w.write_str(\"<div id=\\\"blanket-implementations-list\\\">\");\n-        render_impls(cx, w, blanket_impl, containing_item, false);\n-        w.write_str(\"</div>\");\n+        write_impl_section_heading(&mut w, \"Blanket Implementations\", \"blanket-implementations\");\n+        w.write_str(\"<div id=\\\"blanket-implementations-list\\\">\").unwrap();\n+        render_impls(cx, &mut w, blanket_impl, containing_item, false);\n+        w.write_str(\"</div>\").unwrap();\n     }\n }\n \n-fn render_assoc_items(\n-    w: &mut Buffer,\n-    cx: &mut Context<'_>,\n-    containing_item: &clean::Item,\n+fn render_assoc_items<'a, 'cx: 'a>(\n+    cx: &'a mut Context<'cx>,\n+    containing_item: &'a clean::Item,\n     it: DefId,\n-    what: AssocItemRender<'_>,\n-) {\n+    what: AssocItemRender<'a>,\n+) -> impl fmt::Display + 'a + Captures<'cx> {\n     let mut derefs = DefIdSet::default();\n     derefs.insert(it);\n-    render_assoc_items_inner(w, cx, containing_item, it, what, &mut derefs)\n+    display_fn(move |f| {\n+        render_assoc_items_inner(f, cx, containing_item, it, what, &mut derefs);\n+        Ok(())\n+    })\n }\n \n fn render_assoc_items_inner(\n-    w: &mut Buffer,\n+    mut w: &mut dyn fmt::Write,\n     cx: &mut Context<'_>,\n     containing_item: &clean::Item,\n     it: DefId,\n@@ -1147,7 +1154,7 @@ fn render_assoc_items_inner(\n     let Some(v) = cache.impls.get(&it) else { return };\n     let (non_trait, traits): (Vec<_>, _) = v.iter().partition(|i| i.inner_impl().trait_.is_none());\n     if !non_trait.is_empty() {\n-        let mut tmp_buf = Buffer::empty_from(w);\n+        let mut tmp_buf = Buffer::html();\n         let (render_mode, id) = match what {\n             AssocItemRender::All => {\n                 write_impl_section_heading(&mut tmp_buf, \"Implementations\", \"implementations\");\n@@ -1171,7 +1178,7 @@ fn render_assoc_items_inner(\n                 (RenderMode::ForDeref { mut_: deref_mut_ }, cx.derive_id(id))\n             }\n         };\n-        let mut impls_buf = Buffer::empty_from(w);\n+        let mut impls_buf = Buffer::html();\n         for i in &non_trait {\n             render_impl(\n                 &mut impls_buf,\n@@ -1191,10 +1198,10 @@ fn render_assoc_items_inner(\n             );\n         }\n         if !impls_buf.is_empty() {\n-            w.push_buffer(tmp_buf);\n-            write!(w, \"<div id=\\\"{}\\\">\", id);\n-            w.push_buffer(impls_buf);\n-            w.write_str(\"</div>\");\n+            write!(w, \"{}\", tmp_buf.into_inner()).unwrap();\n+            write!(w, \"<div id=\\\"{}\\\">\", id).unwrap();\n+            write!(w, \"{}\", impls_buf.into_inner()).unwrap();\n+            w.write_str(\"</div>\").unwrap();\n         }\n     }\n \n@@ -1204,7 +1211,7 @@ fn render_assoc_items_inner(\n         if let Some(impl_) = deref_impl {\n             let has_deref_mut =\n                 traits.iter().any(|t| t.trait_did() == cx.tcx().lang_items().deref_mut_trait());\n-            render_deref_methods(w, cx, impl_, containing_item, has_deref_mut, derefs);\n+            render_deref_methods(&mut w, cx, impl_, containing_item, has_deref_mut, derefs);\n         }\n \n         // If we were already one level into rendering deref methods, we don't want to render\n@@ -1223,7 +1230,7 @@ fn render_assoc_items_inner(\n }\n \n fn render_deref_methods(\n-    w: &mut Buffer,\n+    mut w: impl Write,\n     cx: &mut Context<'_>,\n     impl_: &Impl,\n     container_item: &clean::Item,\n@@ -1255,10 +1262,10 @@ fn render_deref_methods(\n                 return;\n             }\n         }\n-        render_assoc_items_inner(w, cx, container_item, did, what, derefs);\n+        render_assoc_items_inner(&mut w, cx, container_item, did, what, derefs);\n     } else if let Some(prim) = target.primitive_type() {\n         if let Some(&did) = cache.primitive_locations.get(&prim) {\n-            render_assoc_items_inner(w, cx, container_item, did, what, derefs);\n+            render_assoc_items_inner(&mut w, cx, container_item, did, what, derefs);\n         }\n     }\n }"}, {"sha": "6bce57340040bfe355beaead3081780116a2596c", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 319, "deletions": 254, "changes": 573, "blob_url": "https://github.com/rust-lang/rust/blob/c325fda0bfb32affaeba76c360779585278b8c61/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c325fda0bfb32affaeba76c360779585278b8c61/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=c325fda0bfb32affaeba76c360779585278b8c61", "patch": "@@ -202,19 +202,20 @@ fn should_hide_fields(n_fields: usize) -> bool {\n     n_fields > 12\n }\n \n-fn toggle_open(w: &mut Buffer, text: impl fmt::Display) {\n+fn toggle_open(mut w: impl fmt::Write, text: impl fmt::Display) {\n     write!(\n         w,\n         \"<details class=\\\"toggle type-contents-toggle\\\">\\\n             <summary class=\\\"hideme\\\">\\\n                 <span>Show {}</span>\\\n             </summary>\",\n         text\n-    );\n+    )\n+    .unwrap();\n }\n \n-fn toggle_close(w: &mut Buffer) {\n-    w.write_str(\"</details>\");\n+fn toggle_close(mut w: impl fmt::Write) {\n+    w.write_str(\"</details>\").unwrap();\n }\n \n fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items: &[clean::Item]) {\n@@ -580,7 +581,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n     let must_implement_one_of_functions = tcx.trait_def(t.def_id).must_implement_one_of.clone();\n \n     // Output the trait definition\n-    wrap_item(w, |w| {\n+    wrap_item(w, |mut w| {\n         write!(\n             w,\n             \"{attrs}{}{}{}trait {}{}{}\",\n@@ -610,7 +611,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n             if should_hide_fields(count_types) {\n                 toggle = true;\n                 toggle_open(\n-                    w,\n+                    &mut w,\n                     format_args!(\"{} associated items\", count_types + count_consts + count_methods),\n                 );\n             }\n@@ -634,7 +635,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n             if !toggle && should_hide_fields(count_types + count_consts) {\n                 toggle = true;\n                 toggle_open(\n-                    w,\n+                    &mut w,\n                     format_args!(\n                         \"{} associated constant{} and {} method{}\",\n                         count_consts,\n@@ -662,7 +663,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n             }\n             if !toggle && should_hide_fields(count_methods) {\n                 toggle = true;\n-                toggle_open(w, format_args!(\"{} methods\", count_methods));\n+                toggle_open(&mut w, format_args!(\"{} methods\", count_methods));\n             }\n             if count_consts != 0 && count_methods != 0 {\n                 w.write_str(\"\\n\");\n@@ -710,7 +711,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n                 }\n             }\n             if toggle {\n-                toggle_close(w);\n+                toggle_close(&mut w);\n             }\n             w.write_str(\"}\");\n         }\n@@ -847,7 +848,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n     }\n \n     // If there are methods directly on this trait object, render them here.\n-    render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All);\n+    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All));\n \n     let cloned_shared = Rc::clone(&cx.shared);\n     let cache = &cloned_shared.cache;\n@@ -1074,7 +1075,7 @@ fn item_trait_alias(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All)\n+    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All))\n }\n \n fn item_opaque_ty(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean::OpaqueTy) {\n@@ -1096,7 +1097,7 @@ fn item_opaque_ty(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &cl\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All)\n+    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All))\n }\n \n fn item_typedef(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n@@ -1124,54 +1125,102 @@ fn item_typedef(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clea\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, def_id, AssocItemRender::All);\n-    document_type_layout(w, cx, def_id);\n+    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All));\n+    write!(w, \"{}\", document_type_layout(cx, def_id));\n }\n \n fn item_union(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean::Union) {\n-    wrap_item(w, |w| {\n-        write!(w, \"{}\", render_attributes_in_pre(it, \"\"));\n-        render_union(w, it, Some(&s.generics), &s.fields, cx);\n-    });\n+    #[derive(Template)]\n+    #[template(path = \"item_union.html\")]\n+    struct ItemUnion<'a, 'cx> {\n+        cx: std::cell::RefCell<&'a mut Context<'cx>>,\n+        it: &'a clean::Item,\n+        s: &'a clean::Union,\n+    }\n \n-    write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n+    impl<'a, 'cx: 'a> ItemUnion<'a, 'cx> {\n+        fn render_assoc_items<'b>(\n+            &'b self,\n+        ) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n+            display_fn(move |f| {\n+                let def_id = self.it.item_id.expect_def_id();\n+                let mut cx = self.cx.borrow_mut();\n+                let v = render_assoc_items(*cx, self.it, def_id, AssocItemRender::All);\n+                write!(f, \"{v}\")\n+            })\n+        }\n+        fn document_type_layout<'b>(\n+            &'b self,\n+        ) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n+            display_fn(move |f| {\n+                let def_id = self.it.item_id.expect_def_id();\n+                let cx = self.cx.borrow_mut();\n+                let v = document_type_layout(*cx, def_id);\n+                write!(f, \"{v}\")\n+            })\n+        }\n+        fn render_union<'b>(&'b self) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n+            display_fn(move |f| {\n+                let cx = self.cx.borrow_mut();\n+                let v = render_union(self.it, Some(&self.s.generics), &self.s.fields, *cx);\n+                write!(f, \"{v}\")\n+            })\n+        }\n+        fn render_attributes_in_pre<'b>(\n+            &'b self,\n+        ) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n+            display_fn(move |f| {\n+                let v = render_attributes_in_pre(self.it, \"\");\n+                write!(f, \"{v}\")\n+            })\n+        }\n+        fn document<'b>(&'b self) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n+            display_fn(move |f| {\n+                let mut cx = self.cx.borrow_mut();\n+                let v = document(*cx, self.it, None, HeadingOffset::H2);\n+                write!(f, \"{v}\")\n+            })\n+        }\n+        fn document_field<'b>(\n+            &'b self,\n+            field: &'a clean::Item,\n+        ) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n+            display_fn(move |f| {\n+                let mut cx = self.cx.borrow_mut();\n+                let v = document(*cx, field, Some(self.it), HeadingOffset::H3);\n+                write!(f, \"{v}\")\n+            })\n+        }\n+        fn stability_field(&self, field: &clean::Item) -> Option<String> {\n+            let cx = self.cx.borrow();\n+            field.stability_class(cx.tcx())\n+        }\n+        fn print_ty<'b>(\n+            &'b self,\n+            ty: &'a clean::Type,\n+        ) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n+            display_fn(move |f| {\n+                let cx = self.cx.borrow();\n+                let v = ty.print(*cx);\n+                write!(f, \"{v}\")\n+            })\n+        }\n \n-    let mut fields = s\n-        .fields\n-        .iter()\n-        .filter_map(|f| match *f.kind {\n-            clean::StructFieldItem(ref ty) => Some((f, ty)),\n-            _ => None,\n-        })\n-        .peekable();\n-    if fields.peek().is_some() {\n-        write!(\n-            w,\n-            \"<h2 id=\\\"fields\\\" class=\\\"fields small-section-header\\\">\\\n-                Fields<a href=\\\"#fields\\\" class=\\\"anchor\\\">\u00a7</a>\\\n-            </h2>\"\n-        );\n-        for (field, ty) in fields {\n-            let name = field.name.expect(\"union field name\");\n-            let id = format!(\"{}.{}\", ItemType::StructField, name);\n-            write!(\n-                w,\n-                \"<span id=\\\"{id}\\\" class=\\\"{shortty} small-section-header\\\">\\\n-                     <a href=\\\"#{id}\\\" class=\\\"anchor field\\\">\u00a7</a>\\\n-                     <code>{name}: {ty}</code>\\\n-                 </span>\",\n-                shortty = ItemType::StructField,\n-                ty = ty.print(cx),\n-            );\n-            if let Some(stability_class) = field.stability_class(cx.tcx()) {\n-                write!(w, \"<span class=\\\"stab {stability_class}\\\"></span>\");\n-            }\n-            write!(w, \"{}\", document(cx, field, Some(it), HeadingOffset::H3));\n+        fn fields_iter(\n+            &self,\n+        ) -> std::iter::Peekable<impl Iterator<Item = (&'a clean::Item, &'a clean::Type)>> {\n+            self.s\n+                .fields\n+                .iter()\n+                .filter_map(|f| match *f.kind {\n+                    clean::StructFieldItem(ref ty) => Some((f, ty)),\n+                    _ => None,\n+                })\n+                .peekable()\n         }\n     }\n-    let def_id = it.item_id.expect_def_id();\n-    render_assoc_items(w, cx, it, def_id, AssocItemRender::All);\n-    document_type_layout(w, cx, def_id);\n+\n+    ItemUnion { cx: std::cell::RefCell::new(cx), it, s }.render_into(w).unwrap();\n }\n \n fn print_tuple_struct_fields<'a, 'cx: 'a>(\n@@ -1196,7 +1245,7 @@ fn print_tuple_struct_fields<'a, 'cx: 'a>(\n fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::Enum) {\n     let tcx = cx.tcx();\n     let count_variants = e.variants().count();\n-    wrap_item(w, |w| {\n+    wrap_item(w, |mut w| {\n         write!(\n             w,\n             \"{attrs}{}enum {}{}\",\n@@ -1217,7 +1266,7 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n             w.write_str(\"{\\n\");\n             let toggle = should_hide_fields(count_variants);\n             if toggle {\n-                toggle_open(w, format_args!(\"{} variants\", count_variants));\n+                toggle_open(&mut w, format_args!(\"{} variants\", count_variants));\n             }\n             for v in e.variants() {\n                 w.write_str(\"    \");\n@@ -1242,7 +1291,7 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n                 w.write_str(\"    // some variants omitted\\n\");\n             }\n             if toggle {\n-                toggle_close(w);\n+                toggle_close(&mut w);\n             }\n             w.write_str(\"}\");\n         }\n@@ -1255,11 +1304,12 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n             w,\n             \"<h2 id=\\\"variants\\\" class=\\\"variants small-section-header\\\">\\\n                 Variants{}<a href=\\\"#variants\\\" class=\\\"anchor\\\">\u00a7</a>\\\n-            </h2>\",\n-            document_non_exhaustive_header(it)\n+            </h2>\\\n+            {}\\\n+            <div class=\\\"variants\\\">\",\n+            document_non_exhaustive_header(it),\n+            document_non_exhaustive(it)\n         );\n-        document_non_exhaustive(w, it);\n-        write!(w, \"<div class=\\\"variants\\\">\");\n         for variant in e.variants() {\n             let id = cx.derive_id(format!(\"{}.{}\", ItemType::Variant, variant.name.unwrap()));\n             write!(\n@@ -1304,9 +1354,10 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n                 write!(\n                     w,\n                     \"<div class=\\\"sub-variant\\\" id=\\\"{variant_id}\\\">\\\n-                        <h4>{heading}</h4>\",\n+                        <h4>{heading}</h4>\\\n+                        {}\",\n+                    document_non_exhaustive(variant)\n                 );\n-                document_non_exhaustive(w, variant);\n                 for field in fields {\n                     match *field.kind {\n                         clean::StrippedItem(box clean::StructFieldItem(_)) => {}\n@@ -1343,8 +1394,8 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n         write!(w, \"</div>\");\n     }\n     let def_id = it.item_id.expect_def_id();\n-    render_assoc_items(w, cx, it, def_id, AssocItemRender::All);\n-    document_type_layout(w, cx, def_id);\n+    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All));\n+    write!(w, \"{}\", document_type_layout(cx, def_id));\n }\n \n fn item_macro(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean::Macro) {\n@@ -1382,7 +1433,7 @@ fn item_primitive(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {\n     let def_id = it.item_id.expect_def_id();\n     write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n     if it.name.map(|n| n.as_str() != \"reference\").unwrap_or(false) {\n-        render_assoc_items(w, cx, it, def_id, AssocItemRender::All);\n+        write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All));\n     } else {\n         // We handle the \"reference\" primitive type on its own because we only want to list\n         // implementations on generic types.\n@@ -1463,11 +1514,12 @@ fn item_struct(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean\n                 w,\n                 \"<h2 id=\\\"fields\\\" class=\\\"fields small-section-header\\\">\\\n                      {}{}<a href=\\\"#fields\\\" class=\\\"anchor\\\">\u00a7</a>\\\n-                 </h2>\",\n+                 </h2>\\\n+                 {}\",\n                 if s.ctor_kind.is_none() { \"Fields\" } else { \"Tuple Fields\" },\n-                document_non_exhaustive_header(it)\n+                document_non_exhaustive_header(it),\n+                document_non_exhaustive(it)\n             );\n-            document_non_exhaustive(w, it);\n             for (index, (field, ty)) in fields.enumerate() {\n                 let field_name =\n                     field.name.map_or_else(|| index.to_string(), |sym| sym.as_str().to_string());\n@@ -1486,8 +1538,8 @@ fn item_struct(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean\n         }\n     }\n     let def_id = it.item_id.expect_def_id();\n-    render_assoc_items(w, cx, it, def_id, AssocItemRender::All);\n-    document_type_layout(w, cx, def_id);\n+    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All));\n+    write!(w, \"{}\", document_type_layout(cx, def_id));\n }\n \n fn item_static(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean::Static) {\n@@ -1519,7 +1571,7 @@ fn item_foreign_type(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {\n \n     write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n \n-    render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All)\n+    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All))\n }\n \n fn item_keyword(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {\n@@ -1660,64 +1712,69 @@ fn render_implementor(\n     );\n }\n \n-fn render_union(\n-    w: &mut Buffer,\n-    it: &clean::Item,\n-    g: Option<&clean::Generics>,\n-    fields: &[clean::Item],\n-    cx: &Context<'_>,\n-) {\n-    let tcx = cx.tcx();\n-    write!(\n-        w,\n-        \"{}union {}\",\n-        visibility_print_with_space(it.visibility(tcx), it.item_id, cx),\n-        it.name.unwrap(),\n-    );\n-\n-    let where_displayed = g\n-        .map(|g| {\n-            write!(w, \"{}\", g.print(cx));\n-            print_where_clause_and_check(w, g, cx)\n-        })\n-        .unwrap_or(false);\n+fn render_union<'a, 'cx: 'a>(\n+    it: &'a clean::Item,\n+    g: Option<&'a clean::Generics>,\n+    fields: &'a [clean::Item],\n+    cx: &'a Context<'cx>,\n+) -> impl fmt::Display + 'a + Captures<'cx> {\n+    display_fn(move |mut f| {\n+        let tcx = cx.tcx();\n+        write!(\n+            f,\n+            \"{}union {}\",\n+            visibility_print_with_space(it.visibility(tcx), it.item_id, cx),\n+            it.name.unwrap(),\n+        )?;\n+\n+        let where_displayed = g\n+            .map(|g| {\n+                let mut buf = Buffer::html();\n+                write!(buf, \"{}\", g.print(cx));\n+                let where_displayed = print_where_clause_and_check(&mut buf, g, cx);\n+                write!(f, \"{buf}\", buf = buf.into_inner()).unwrap();\n+                where_displayed\n+            })\n+            .unwrap_or(false);\n \n-    // If there wasn't a `where` clause, we add a whitespace.\n-    if !where_displayed {\n-        w.write_str(\" \");\n-    }\n+        // If there wasn't a `where` clause, we add a whitespace.\n+        if !where_displayed {\n+            f.write_str(\" \")?;\n+        }\n \n-    write!(w, \"{{\\n\");\n-    let count_fields =\n-        fields.iter().filter(|f| matches!(*f.kind, clean::StructFieldItem(..))).count();\n-    let toggle = should_hide_fields(count_fields);\n-    if toggle {\n-        toggle_open(w, format_args!(\"{} fields\", count_fields));\n-    }\n+        write!(f, \"{{\\n\")?;\n+        let count_fields =\n+            fields.iter().filter(|field| matches!(*field.kind, clean::StructFieldItem(..))).count();\n+        let toggle = should_hide_fields(count_fields);\n+        if toggle {\n+            toggle_open(&mut f, format_args!(\"{} fields\", count_fields));\n+        }\n \n-    for field in fields {\n-        if let clean::StructFieldItem(ref ty) = *field.kind {\n-            write!(\n-                w,\n-                \"    {}{}: {},\\n\",\n-                visibility_print_with_space(field.visibility(tcx), field.item_id, cx),\n-                field.name.unwrap(),\n-                ty.print(cx)\n-            );\n+        for field in fields {\n+            if let clean::StructFieldItem(ref ty) = *field.kind {\n+                write!(\n+                    f,\n+                    \"    {}{}: {},\\n\",\n+                    visibility_print_with_space(field.visibility(tcx), field.item_id, cx),\n+                    field.name.unwrap(),\n+                    ty.print(cx)\n+                )?;\n+            }\n         }\n-    }\n \n-    if it.has_stripped_entries().unwrap() {\n-        write!(w, \"    /* private fields */\\n\");\n-    }\n-    if toggle {\n-        toggle_close(w);\n-    }\n-    w.write_str(\"}\");\n+        if it.has_stripped_entries().unwrap() {\n+            write!(f, \"    /* private fields */\\n\")?;\n+        }\n+        if toggle {\n+            toggle_close(&mut f);\n+        }\n+        f.write_str(\"}\").unwrap();\n+        Ok(())\n+    })\n }\n \n fn render_struct(\n-    w: &mut Buffer,\n+    mut w: &mut Buffer,\n     it: &clean::Item,\n     g: Option<&clean::Generics>,\n     ty: Option<CtorKind>,\n@@ -1752,7 +1809,7 @@ fn render_struct(\n             let has_visible_fields = count_fields > 0;\n             let toggle = should_hide_fields(count_fields);\n             if toggle {\n-                toggle_open(w, format_args!(\"{} fields\", count_fields));\n+                toggle_open(&mut w, format_args!(\"{} fields\", count_fields));\n             }\n             for field in fields {\n                 if let clean::StructFieldItem(ref ty) = *field.kind {\n@@ -1776,7 +1833,7 @@ fn render_struct(\n                 write!(w, \" /* private fields */ \");\n             }\n             if toggle {\n-                toggle_close(w);\n+                toggle_close(&mut w);\n             }\n             w.write_str(\"}\");\n         }\n@@ -1822,161 +1879,169 @@ fn document_non_exhaustive_header(item: &clean::Item) -> &str {\n     if item.is_non_exhaustive() { \" (Non-exhaustive)\" } else { \"\" }\n }\n \n-fn document_non_exhaustive(w: &mut Buffer, item: &clean::Item) {\n-    if item.is_non_exhaustive() {\n-        write!(\n-            w,\n-            \"<details class=\\\"toggle non-exhaustive\\\">\\\n-                 <summary class=\\\"hideme\\\"><span>{}</span></summary>\\\n-                 <div class=\\\"docblock\\\">\",\n-            {\n-                if item.is_struct() {\n-                    \"This struct is marked as non-exhaustive\"\n-                } else if item.is_enum() {\n-                    \"This enum is marked as non-exhaustive\"\n-                } else if item.is_variant() {\n-                    \"This variant is marked as non-exhaustive\"\n-                } else {\n-                    \"This type is marked as non-exhaustive\"\n+fn document_non_exhaustive<'a>(item: &'a clean::Item) -> impl fmt::Display + 'a {\n+    display_fn(|f| {\n+        if item.is_non_exhaustive() {\n+            write!(\n+                f,\n+                \"<details class=\\\"toggle non-exhaustive\\\">\\\n+                    <summary class=\\\"hideme\\\"><span>{}</span></summary>\\\n+                    <div class=\\\"docblock\\\">\",\n+                {\n+                    if item.is_struct() {\n+                        \"This struct is marked as non-exhaustive\"\n+                    } else if item.is_enum() {\n+                        \"This enum is marked as non-exhaustive\"\n+                    } else if item.is_variant() {\n+                        \"This variant is marked as non-exhaustive\"\n+                    } else {\n+                        \"This type is marked as non-exhaustive\"\n+                    }\n                 }\n+            )?;\n+\n+            if item.is_struct() {\n+                f.write_str(\n+                    \"Non-exhaustive structs could have additional fields added in future. \\\n+                    Therefore, non-exhaustive structs cannot be constructed in external crates \\\n+                    using the traditional <code>Struct { .. }</code> syntax; cannot be \\\n+                    matched against without a wildcard <code>..</code>; and \\\n+                    struct update syntax will not work.\",\n+                )?;\n+            } else if item.is_enum() {\n+                f.write_str(\n+                    \"Non-exhaustive enums could have additional variants added in future. \\\n+                    Therefore, when matching against variants of non-exhaustive enums, an \\\n+                    extra wildcard arm must be added to account for any future variants.\",\n+                )?;\n+            } else if item.is_variant() {\n+                f.write_str(\n+                    \"Non-exhaustive enum variants could have additional fields added in future. \\\n+                    Therefore, non-exhaustive enum variants cannot be constructed in external \\\n+                    crates and cannot be matched against.\",\n+                )?;\n+            } else {\n+                f.write_str(\n+                    \"This type will require a wildcard arm in any match statements or constructors.\",\n+                )?;\n             }\n-        );\n \n-        if item.is_struct() {\n-            w.write_str(\n-                \"Non-exhaustive structs could have additional fields added in future. \\\n-                 Therefore, non-exhaustive structs cannot be constructed in external crates \\\n-                 using the traditional <code>Struct { .. }</code> syntax; cannot be \\\n-                 matched against without a wildcard <code>..</code>; and \\\n-                 struct update syntax will not work.\",\n-            );\n-        } else if item.is_enum() {\n-            w.write_str(\n-                \"Non-exhaustive enums could have additional variants added in future. \\\n-                 Therefore, when matching against variants of non-exhaustive enums, an \\\n-                 extra wildcard arm must be added to account for any future variants.\",\n-            );\n-        } else if item.is_variant() {\n-            w.write_str(\n-                \"Non-exhaustive enum variants could have additional fields added in future. \\\n-                 Therefore, non-exhaustive enum variants cannot be constructed in external \\\n-                 crates and cannot be matched against.\",\n-            );\n-        } else {\n-            w.write_str(\n-                \"This type will require a wildcard arm in any match statements or constructors.\",\n-            );\n+            f.write_str(\"</div></details>\")?;\n         }\n-\n-        w.write_str(\"</div></details>\");\n-    }\n+        Ok(())\n+    })\n }\n \n-fn document_type_layout(w: &mut Buffer, cx: &Context<'_>, ty_def_id: DefId) {\n-    fn write_size_of_layout(w: &mut Buffer, layout: &LayoutS, tag_size: u64) {\n+fn document_type_layout<'a, 'cx: 'a>(\n+    cx: &'a Context<'cx>,\n+    ty_def_id: DefId,\n+) -> impl fmt::Display + 'a + Captures<'cx> {\n+    fn write_size_of_layout(mut w: impl fmt::Write, layout: &LayoutS, tag_size: u64) {\n         if layout.abi.is_unsized() {\n-            write!(w, \"(unsized)\");\n+            write!(w, \"(unsized)\").unwrap();\n         } else {\n             let size = layout.size.bytes() - tag_size;\n-            write!(w, \"{size} byte{pl}\", pl = if size == 1 { \"\" } else { \"s\" },);\n+            write!(w, \"{size} byte{pl}\", pl = if size == 1 { \"\" } else { \"s\" }).unwrap();\n             if layout.abi.is_uninhabited() {\n                 write!(\n                     w,\n                     \" (<a href=\\\"https://doc.rust-lang.org/stable/reference/glossary.html#uninhabited\\\">uninhabited</a>)\"\n-                );\n+                ).unwrap();\n             }\n         }\n     }\n \n-    if !cx.shared.show_type_layout {\n-        return;\n-    }\n-\n-    writeln!(\n-        w,\n-        \"<h2 id=\\\"layout\\\" class=\\\"small-section-header\\\"> \\\n-        Layout<a href=\\\"#layout\\\" class=\\\"anchor\\\">\u00a7</a></h2>\"\n-    );\n-    writeln!(w, \"<div class=\\\"docblock\\\">\");\n-\n-    let tcx = cx.tcx();\n-    let param_env = tcx.param_env(ty_def_id);\n-    let ty = tcx.type_of(ty_def_id).subst_identity();\n-    match tcx.layout_of(param_env.and(ty)) {\n-        Ok(ty_layout) => {\n-            writeln!(\n-                w,\n-                \"<div class=\\\"warning\\\"><p><strong>Note:</strong> Most layout information is \\\n-                 <strong>completely unstable</strong> and may even differ between compilations. \\\n-                 The only exception is types with certain <code>repr(...)</code> attributes. \\\n-                 Please see the Rust Reference\u2019s \\\n-                 <a href=\\\"https://doc.rust-lang.org/reference/type-layout.html\\\">\u201cType Layout\u201d</a> \\\n-                 chapter for details on type layout guarantees.</p></div>\"\n-            );\n-            w.write_str(\"<p><strong>Size:</strong> \");\n-            write_size_of_layout(w, &ty_layout.layout.0, 0);\n-            writeln!(w, \"</p>\");\n-            if let Variants::Multiple { variants, tag, tag_encoding, .. } =\n-                &ty_layout.layout.variants()\n-            {\n-                if !variants.is_empty() {\n-                    w.write_str(\n-                        \"<p><strong>Size for each variant:</strong></p>\\\n-                            <ul>\",\n-                    );\n-\n-                    let Adt(adt, _) = ty_layout.ty.kind() else {\n-                        span_bug!(tcx.def_span(ty_def_id), \"not an adt\")\n-                    };\n+    display_fn(move |mut f| {\n+        if !cx.shared.show_type_layout {\n+            return Ok(());\n+        }\n \n-                    let tag_size = if let TagEncoding::Niche { .. } = tag_encoding {\n-                        0\n-                    } else if let Primitive::Int(i, _) = tag.primitive() {\n-                        i.size().bytes()\n-                    } else {\n-                        span_bug!(tcx.def_span(ty_def_id), \"tag is neither niche nor int\")\n-                    };\n+        writeln!(\n+            f,\n+            \"<h2 id=\\\"layout\\\" class=\\\"small-section-header\\\"> \\\n+            Layout<a href=\\\"#layout\\\" class=\\\"anchor\\\">\u00a7</a></h2>\"\n+        )?;\n+        writeln!(f, \"<div class=\\\"docblock\\\">\")?;\n \n-                    for (index, layout) in variants.iter_enumerated() {\n-                        let name = adt.variant(index).name;\n-                        write!(w, \"<li><code>{name}</code>: \");\n-                        write_size_of_layout(w, layout, tag_size);\n-                        writeln!(w, \"</li>\");\n+        let tcx = cx.tcx();\n+        let param_env = tcx.param_env(ty_def_id);\n+        let ty = tcx.type_of(ty_def_id).subst_identity();\n+        match tcx.layout_of(param_env.and(ty)) {\n+            Ok(ty_layout) => {\n+                writeln!(\n+                    f,\n+                    \"<div class=\\\"warning\\\"><p><strong>Note:</strong> Most layout information is \\\n+                    <strong>completely unstable</strong> and may even differ between compilations. \\\n+                    The only exception is types with certain <code>repr(...)</code> attributes. \\\n+                    Please see the Rust Reference\u2019s \\\n+                    <a href=\\\"https://doc.rust-lang.org/reference/type-layout.html\\\">\u201cType Layout\u201d</a> \\\n+                    chapter for details on type layout guarantees.</p></div>\"\n+                )?;\n+                f.write_str(\"<p><strong>Size:</strong> \")?;\n+                write_size_of_layout(&mut f, &ty_layout.layout.0, 0);\n+                writeln!(f, \"</p>\")?;\n+                if let Variants::Multiple { variants, tag, tag_encoding, .. } =\n+                    &ty_layout.layout.variants()\n+                {\n+                    if !variants.is_empty() {\n+                        f.write_str(\n+                            \"<p><strong>Size for each variant:</strong></p>\\\n+                                <ul>\",\n+                        )?;\n+\n+                        let Adt(adt, _) = ty_layout.ty.kind() else {\n+                            span_bug!(tcx.def_span(ty_def_id), \"not an adt\")\n+                        };\n+\n+                        let tag_size = if let TagEncoding::Niche { .. } = tag_encoding {\n+                            0\n+                        } else if let Primitive::Int(i, _) = tag.primitive() {\n+                            i.size().bytes()\n+                        } else {\n+                            span_bug!(tcx.def_span(ty_def_id), \"tag is neither niche nor int\")\n+                        };\n+\n+                        for (index, layout) in variants.iter_enumerated() {\n+                            let name = adt.variant(index).name;\n+                            write!(&mut f, \"<li><code>{name}</code>: \")?;\n+                            write_size_of_layout(&mut f, layout, tag_size);\n+                            writeln!(&mut f, \"</li>\")?;\n+                        }\n+                        f.write_str(\"</ul>\")?;\n                     }\n-                    w.write_str(\"</ul>\");\n                 }\n             }\n+            // This kind of layout error can occur with valid code, e.g. if you try to\n+            // get the layout of a generic type such as `Vec<T>`.\n+            Err(LayoutError::Unknown(_)) => {\n+                writeln!(\n+                    f,\n+                    \"<p><strong>Note:</strong> Unable to compute type layout, \\\n+                    possibly due to this type having generic parameters. \\\n+                    Layout can only be computed for concrete, fully-instantiated types.</p>\"\n+                )?;\n+            }\n+            // This kind of error probably can't happen with valid code, but we don't\n+            // want to panic and prevent the docs from building, so we just let the\n+            // user know that we couldn't compute the layout.\n+            Err(LayoutError::SizeOverflow(_)) => {\n+                writeln!(\n+                    f,\n+                    \"<p><strong>Note:</strong> Encountered an error during type layout; \\\n+                    the type was too big.</p>\"\n+                )?;\n+            }\n+            Err(LayoutError::NormalizationFailure(_, _)) => {\n+                writeln!(\n+                    f,\n+                    \"<p><strong>Note:</strong> Encountered an error during type layout; \\\n+                    the type failed to be normalized.</p>\"\n+                )?;\n+            }\n         }\n-        // This kind of layout error can occur with valid code, e.g. if you try to\n-        // get the layout of a generic type such as `Vec<T>`.\n-        Err(LayoutError::Unknown(_)) => {\n-            writeln!(\n-                w,\n-                \"<p><strong>Note:</strong> Unable to compute type layout, \\\n-                 possibly due to this type having generic parameters. \\\n-                 Layout can only be computed for concrete, fully-instantiated types.</p>\"\n-            );\n-        }\n-        // This kind of error probably can't happen with valid code, but we don't\n-        // want to panic and prevent the docs from building, so we just let the\n-        // user know that we couldn't compute the layout.\n-        Err(LayoutError::SizeOverflow(_)) => {\n-            writeln!(\n-                w,\n-                \"<p><strong>Note:</strong> Encountered an error during type layout; \\\n-                 the type was too big.</p>\"\n-            );\n-        }\n-        Err(LayoutError::NormalizationFailure(_, _)) => {\n-            writeln!(\n-                w,\n-                \"<p><strong>Note:</strong> Encountered an error during type layout; \\\n-                the type failed to be normalized.</p>\"\n-            )\n-        }\n-    }\n \n-    writeln!(w, \"</div>\");\n+        writeln!(f, \"</div>\")\n+    })\n }\n \n fn pluralize(count: usize) -> &'static str {"}, {"sha": "a01457971c178e8c16a86effce9eeab8938e5b96", "filename": "src/librustdoc/html/templates/item_union.html", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c325fda0bfb32affaeba76c360779585278b8c61/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fitem_union.html", "raw_url": "https://github.com/rust-lang/rust/raw/c325fda0bfb32affaeba76c360779585278b8c61/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fitem_union.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fitem_union.html?ref=c325fda0bfb32affaeba76c360779585278b8c61", "patch": "@@ -0,0 +1,23 @@\n+<pre class=\"rust item-decl\"><code>\n+    {{ self.render_attributes_in_pre() | safe }}\n+    {{ self.render_union() | safe }}\n+</code></pre>\n+{{ self.document() | safe }}\n+{% if self.fields_iter().peek().is_some() %}\n+    <h2 id=\"fields\" class=\"fields small-section-header\">\n+        Fields<a href=\"#fields\" class=\"anchor\">\u00a7</a>\n+    </h2>\n+    {% for (field, ty) in self.fields_iter() %}\n+        {% let name = field.name.expect(\"union field name\") %}\n+        <span id=\"structfield.{{ name }}\" class=\"{{ ItemType::StructField }} small-section-header\">\n+            <a href=\"#structfield.{{ name }}\" class=\"anchor field\">\u00a7</a>\n+            <code>{{ name }}: {{ self.print_ty(ty) | safe }}</code>\n+        </span>\n+        {% if let Some(stability_class) = self.stability_field(field) %}\n+            <span class=\"stab {{ stability_class }}\"></span>\n+        {% endif %}\n+        {{ self.document_field(field) | safe }}\n+    {% endfor %}\n+{% endif %}\n+{{ self.render_assoc_items() | safe }}\n+{{ self.document_type_layout() | safe }}"}]}