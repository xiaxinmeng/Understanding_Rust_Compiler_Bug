{"sha": "f93cd924ec50ba9e6ccf346bd0341e908fd87de0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5M2NkOTI0ZWM1MGJhOWU2Y2NmMzQ2YmQwMzQxZTkwOGZkODdkZTA=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-08-12T15:25:16Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-08-12T15:25:16Z"}, "message": "Implement float -> small int cast\n\nAlso workaround small signed int eq/ne binop clif bug", "tree": {"sha": "3f03214c0860be549e353701a8d00ec08bd676e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f03214c0860be549e353701a8d00ec08bd676e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f93cd924ec50ba9e6ccf346bd0341e908fd87de0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f93cd924ec50ba9e6ccf346bd0341e908fd87de0", "html_url": "https://github.com/rust-lang/rust/commit/f93cd924ec50ba9e6ccf346bd0341e908fd87de0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f93cd924ec50ba9e6ccf346bd0341e908fd87de0/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5b0a68fbfbaa542becc269b64e99efb5c9abaec", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5b0a68fbfbaa542becc269b64e99efb5c9abaec", "html_url": "https://github.com/rust-lang/rust/commit/f5b0a68fbfbaa542becc269b64e99efb5c9abaec"}], "stats": {"total": 245, "additions": 128, "deletions": 117}, "files": [{"sha": "a23c94aa7babd8fba205a288ff2d07d037ceadb4", "filename": "example/mini_core.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f93cd924ec50ba9e6ccf346bd0341e908fd87de0/example%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93cd924ec50ba9e6ccf346bd0341e908fd87de0/example%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fmini_core.rs?ref=f93cd924ec50ba9e6ccf346bd0341e908fd87de0", "patch": "@@ -52,6 +52,7 @@ unsafe impl Copy for i8 {}\n unsafe impl Copy for i16 {}\n unsafe impl Copy for i32 {}\n unsafe impl Copy for isize {}\n+unsafe impl Copy for f32 {}\n unsafe impl Copy for char {}\n unsafe impl<'a, T: ?Sized> Copy for &'a T {}\n unsafe impl<T: ?Sized> Copy for *const T {}\n@@ -277,6 +278,15 @@ impl PartialEq for usize {\n     }\n }\n \n+impl PartialEq for i8 {\n+    fn eq(&self, other: &i8) -> bool {\n+        (*self) == (*other)\n+    }\n+    fn ne(&self, other: &i8) -> bool {\n+        (*self) != (*other)\n+    }\n+}\n+\n impl PartialEq for i32 {\n     fn eq(&self, other: &i32) -> bool {\n         (*self) == (*other)\n@@ -344,6 +354,14 @@ impl Neg for isize {\n     }\n }\n \n+impl Neg for f32 {\n+    type Output = f32;\n+\n+    fn neg(self) -> f32 {\n+        -self\n+    }\n+}\n+\n pub enum Option<T> {\n     Some(T),\n     None,"}, {"sha": "282a9baf7524e4272b5f1d674a57a82bc0cdb5c5", "filename": "example/mini_core_hello_world.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f93cd924ec50ba9e6ccf346bd0341e908fd87de0/example%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93cd924ec50ba9e6ccf346bd0341e908fd87de0/example%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fmini_core_hello_world.rs?ref=f93cd924ec50ba9e6ccf346bd0341e908fd87de0", "patch": "@@ -250,4 +250,10 @@ fn main() {\n     unsafe { assert_eq!(ABC as usize, 0); }\n \n     &mut (|| Some(0 as *const ())) as &mut dyn FnMut() -> Option<*const ()>;\n+\n+    let f = 1000.0;\n+    assert_eq!(f as u8, 255);\n+    let f2 = -1000.0;\n+    assert_eq!(f2 as i8, -128);\n+    assert_eq!(f2 as u8, 0);\n }"}, {"sha": "d636ba3d763550b718f62726321a390e20e22540", "filename": "src/base.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f93cd924ec50ba9e6ccf346bd0341e908fd87de0/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93cd924ec50ba9e6ccf346bd0341e908fd87de0/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=f93cd924ec50ba9e6ccf346bd0341e908fd87de0", "patch": "@@ -334,11 +334,7 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                     let lhs = trans_operand(fx, lhs);\n                     let rhs = trans_operand(fx, rhs);\n \n-                    let signed = match ty.sty {\n-                        ty::Uint(_) => false,\n-                        ty::Int(_) => true,\n-                        _ => unimplemented!(\"checked binop {:?} for {:?}\", bin_op, ty),\n-                    };\n+                    let signed = type_sign(ty);\n \n                     let res = if !fx.tcx.sess.overflow_checks() {\n                         let val = trans_int_binop(fx, *bin_op, lhs, rhs, lhs.layout().ty, signed).load_scalar(fx);\n@@ -444,14 +440,7 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                         let to_clif_ty = fx.clif_type(to_ty).unwrap();\n                         let from = operand.load_scalar(fx);\n \n-                        let signed = match from_ty.sty {\n-                            ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..) | ty::Char | ty::Uint(..) | ty::Bool => false,\n-                            ty::Int(..) => true,\n-                            ty::Float(..) => false, // `signed` is unused for floats\n-                            _ => panic!(\"{}\", from_ty),\n-                        };\n-\n-                        let res = clif_int_or_float_cast(fx, from, to_clif_ty, signed);\n+                        let res = clif_int_or_float_cast(fx, from, type_sign(from_ty), to_clif_ty, type_sign(to_ty));\n                         lval.write_cvalue(fx, CValue::by_val(res, dest_layout));\n                     }\n                 }\n@@ -809,6 +798,21 @@ pub fn trans_int_binop<'a, 'tcx: 'a>(\n         return res;\n     }\n \n+    let (lhs, rhs) = if\n+        (bin_op == BinOp::Eq || bin_op == BinOp::Ne)\n+        && (lhs.layout().ty.sty == fx.tcx.types.i8.sty || lhs.layout().ty.sty == fx.tcx.types.i16.sty)\n+    {\n+        // FIXME(CraneStation/cranelift#896) icmp_imm.i8/i16 with eq/ne for signed ints is implemented wrong.\n+        let lhs = lhs.load_scalar(fx);\n+        let rhs = rhs.load_scalar(fx);\n+        (\n+            CValue::by_val(fx.bcx.ins().sextend(types::I32, lhs), fx.layout_of(fx.tcx.types.i32)),\n+            CValue::by_val(fx.bcx.ins().sextend(types::I32, rhs), fx.layout_of(fx.tcx.types.i32)),\n+        )\n+    } else {\n+        (lhs, rhs)\n+    };\n+\n     binop_match! {\n         fx, bin_op, signed, lhs, rhs, out_ty, \"int/uint\";\n         Add (_) iadd;"}, {"sha": "39aa2c96d4d36003a75b1c90065afc0b70b09a2b", "filename": "src/cast.rs", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f93cd924ec50ba9e6ccf346bd0341e908fd87de0/src%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93cd924ec50ba9e6ccf346bd0341e908fd87de0/src%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcast.rs?ref=f93cd924ec50ba9e6ccf346bd0341e908fd87de0", "patch": "@@ -49,8 +49,9 @@ pub fn clif_intcast<'a, 'tcx: 'a>(\n pub fn clif_int_or_float_cast(\n     fx: &mut FunctionCx<'_, '_, impl Backend>,\n     from: Value,\n+    from_signed: bool,\n     to_ty: Type,\n-    signed: bool,\n+    to_signed: bool,\n ) -> Value {\n     let from_ty = fx.bcx.func.dfg.value_type(from);\n \n@@ -60,21 +61,56 @@ pub fn clif_int_or_float_cast(\n             fx,\n             from,\n             to_ty,\n-            signed,\n+            from_signed, // FIXME is this correct?\n         )\n     } else if from_ty.is_int() && to_ty.is_float() {\n         // int-like -> float\n-        if signed {\n+        if from_signed {\n             fx.bcx.ins().fcvt_from_sint(to_ty, from)\n         } else {\n             fx.bcx.ins().fcvt_from_uint(to_ty, from)\n         }\n     } else if from_ty.is_float() && to_ty.is_int() {\n         // float -> int-like\n-        if signed {\n-            fx.bcx.ins().fcvt_to_sint_sat(to_ty, from)\n+        if to_ty == types::I8 || to_ty == types::I16 {\n+            // FIXME implement fcbt_to_*int_sat.i8/i16\n+            let val = if to_signed {\n+                fx.bcx.ins().fcvt_to_sint_sat(types::I32, from)\n+            } else {\n+                fx.bcx.ins().fcvt_to_uint_sat(types::I32, from)\n+            };\n+            let (min, max) = type_min_max_value(to_ty, to_signed);\n+            let min_val = fx.bcx.ins().iconst(types::I32, min);\n+            let max_val = fx.bcx.ins().iconst(types::I32, max);\n+\n+            let val = if to_signed {\n+                let has_underflow = fx.bcx.ins().icmp_imm(\n+                    IntCC::SignedLessThan,\n+                    val,\n+                    min,\n+                );\n+                let has_overflow = fx.bcx.ins().icmp_imm(\n+                    IntCC::SignedGreaterThan,\n+                    val,\n+                    max,\n+                );\n+                let bottom_capped = fx.bcx.ins().select(has_underflow, min_val, val);\n+                fx.bcx.ins().select(has_overflow, max_val, bottom_capped)\n+            } else {\n+                let has_overflow = fx.bcx.ins().icmp_imm(\n+                    IntCC::UnsignedGreaterThan,\n+                    val,\n+                    max,\n+                );\n+                fx.bcx.ins().select(has_overflow, max_val, val)\n+            };\n+            fx.bcx.ins().ireduce(to_ty, val)\n         } else {\n-            fx.bcx.ins().fcvt_to_uint_sat(to_ty, from)\n+            if to_signed {\n+                fx.bcx.ins().fcvt_to_sint_sat(to_ty, from)\n+            } else {\n+                fx.bcx.ins().fcvt_to_uint_sat(to_ty, from)\n+            }\n         }\n     } else if from_ty.is_float() && to_ty.is_float() {\n         // float -> float"}, {"sha": "46dcb5aad0354aad46a34fd5de77b1baf5a34b94", "filename": "src/common.rs", "status": "modified", "additions": 31, "deletions": 59, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/f93cd924ec50ba9e6ccf346bd0341e908fd87de0/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93cd924ec50ba9e6ccf346bd0341e908fd87de0/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=f93cd924ec50ba9e6ccf346bd0341e908fd87de0", "patch": "@@ -116,74 +116,46 @@ pub fn resolve_value_imm(func: &Function, val: Value) -> Option<u128> {\n     }\n }\n \n-pub fn type_min_max_value<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> (i64, i64) {\n-    use syntax::ast::UintTy::*;\n-    use syntax::ast::IntTy::*;\n-\n-    let uint_usize_cvt = |uint| {\n-        match uint {\n-            UintTy::Usize => match pointer_ty(tcx) {\n-                types::I16 => UintTy::U16,\n-                types::I32 => UintTy::U32,\n-                types::I64 => UintTy::U64,\n-                ty => unreachable!(\"{:?}\", ty),\n-            }\n-            _ => uint,\n-        }\n-    };\n-\n-    let int_isize_cvt = |int| {\n-        match int {\n-            IntTy::Isize => match pointer_ty(tcx) {\n-                types::I16 => IntTy::I16,\n-                types::I32 => IntTy::I32,\n-                types::I64 => IntTy::I64,\n-                ty => unreachable!(\"{:?}\", ty),\n-            }\n-            _ => int,\n-        }\n-    };\n-\n-    let min = match ty.sty {\n-        ty::Uint(uint) => match uint_usize_cvt(uint) {\n-            U8 | U16 | U32 | U64 => 0i64,\n-            U128 => unimplemented!(),\n-            Usize => unreachable!(),\n-        }\n-        ty::Int(int) => match int_isize_cvt(int) {\n-            I8 => i8::min_value() as i64,\n-            I16 => i16::min_value() as i64,\n-            I32 => i32::min_value() as i64,\n-            I64 => i64::min_value(),\n-            I128 => unimplemented!(),\n-            Isize => unreachable!(),\n-        }\n+pub fn type_min_max_value(ty: Type, signed: bool) -> (i64, i64) {\n+    assert!(ty.is_int());\n+    let min = match (ty, signed) {\n+        (types::I8 , false)\n+        | (types::I16, false)\n+        | (types::I32, false)\n+        | (types::I64, false) => 0i64,\n+        (types::I8, true) => i8::min_value() as i64,\n+        (types::I16, true) => i16::min_value() as i64,\n+        (types::I32, true) => i32::min_value() as i64,\n+        (types::I64, true) => i64::min_value(),\n+        (types::I128, _) => unimplemented!(),\n         _ => unreachable!(),\n     };\n \n-    let max = match ty.sty {\n-        ty::Uint(uint) => match uint_usize_cvt(uint) {\n-            U8 => u8::max_value() as i64,\n-            U16 => u16::max_value() as i64,\n-            U32 => u32::max_value() as i64,\n-            U64 => u64::max_value() as i64,\n-            U128 => unimplemented!(),\n-            Usize => unreachable!(),\n-        }\n-        ty::Int(int) => match int_isize_cvt(int) {\n-            I8 => i8::max_value() as i64,\n-            I16 => i16::max_value() as i64,\n-            I32 => i32::max_value() as i64,\n-            I64 => i64::max_value(),\n-            I128 => unimplemented!(),\n-            Isize => unreachable!(),\n-        }\n+    let max = match (ty, signed) {\n+        (types::I8, false) => u8::max_value() as i64,\n+        (types::I16, false) => u16::max_value() as i64,\n+        (types::I32, false) => u32::max_value() as i64,\n+        (types::I64, false) => u64::max_value() as i64,\n+        (types::I8, true) => i8::max_value() as i64,\n+        (types::I16, true) => i16::max_value() as i64,\n+        (types::I32, true) => i32::max_value() as i64,\n+        (types::I64, true) => i64::max_value(),\n+        (types::I128, _) => unimplemented!(),\n         _ => unreachable!(),\n     };\n \n     (min, max)\n }\n \n+pub fn type_sign(ty: Ty<'_>) -> bool {\n+    match ty.sty {\n+        ty::Ref(..) | ty::RawPtr(..) | ty::FnPtr(..) | ty::Char | ty::Uint(..) | ty::Bool => false,\n+        ty::Int(..) => true,\n+        ty::Float(..) => false, // `signed` is unused for floats\n+        _ => panic!(\"{}\", ty),\n+    }\n+}\n+\n pub struct FunctionCx<'a, 'tcx: 'a, B: Backend> {\n     // FIXME use a reference to `CodegenCx` instead of `tcx`, `module` and `constants` and `caches`\n     pub tcx: TyCtxt<'tcx>,"}, {"sha": "b9ec2a0e1828338ddd3a1166c8bb571f9710090e", "filename": "src/intrinsics.rs", "status": "modified", "additions": 14, "deletions": 39, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f93cd924ec50ba9e6ccf346bd0341e908fd87de0/src%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93cd924ec50ba9e6ccf346bd0341e908fd87de0/src%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics.rs?ref=f93cd924ec50ba9e6ccf346bd0341e908fd87de0", "patch": "@@ -473,19 +473,13 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n                 _ => unimplemented!(\"intrinsic {}\", intrinsic),\n             };\n \n-            let signed = match T.sty {\n-                ty::Uint(_) => false,\n-                ty::Int(_) => true,\n-                _ => unimplemented!(\"{} for {:?}\", intrinsic, T),\n-            };\n-\n             let res = crate::base::trans_checked_int_binop(\n                 fx,\n                 bin_op,\n                 x,\n                 y,\n                 ret.layout().ty,\n-                signed,\n+                type_sign(T),\n             );\n             ret.write_cvalue(fx, res);\n         };\n@@ -497,25 +491,14 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n                 \"overflowing_mul\" => BinOp::Mul,\n                 _ => unimplemented!(\"intrinsic {}\", intrinsic),\n             };\n-            let res = match T.sty {\n-                ty::Uint(_) => crate::base::trans_int_binop(\n-                    fx,\n-                    bin_op,\n-                    x,\n-                    y,\n-                    ret.layout().ty,\n-                    false,\n-                ),\n-                ty::Int(_) => crate::base::trans_int_binop(\n-                    fx,\n-                    bin_op,\n-                    x,\n-                    y,\n-                    ret.layout().ty,\n-                    true,\n-                ),\n-                _ => panic!(),\n-            };\n+            let res = crate::base::trans_int_binop(\n+                fx,\n+                bin_op,\n+                x,\n+                y,\n+                ret.layout().ty,\n+                type_sign(T),\n+            );\n             ret.write_cvalue(fx, res);\n         };\n         _ if intrinsic.starts_with(\"saturating_\"), <T> (c x, c y) {\n@@ -527,11 +510,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n                 _ => unimplemented!(\"intrinsic {}\", intrinsic),\n             };\n \n-            let signed = match T.sty {\n-                ty::Uint(_) => false,\n-                ty::Int(_) => true,\n-                _ => unimplemented!(\"{} for {:?}\", intrinsic, T),\n-            };\n+            let signed = type_sign(T);\n \n             let checked_res = crate::base::trans_checked_int_binop(\n                 fx,\n@@ -548,7 +527,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n             // `select.i8` is not implemented by Cranelift.\n             let has_overflow = fx.bcx.ins().uextend(types::I32, has_overflow);\n \n-            let (min, max) = type_min_max_value(fx.tcx, T);\n+            let (min, max) = type_min_max_value(clif_ty, signed);\n             let min = fx.bcx.ins().iconst(clif_ty, min);\n             let max = fx.bcx.ins().iconst(clif_ty, max);\n \n@@ -879,18 +858,14 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n \n             let ret_lane_ty = fx.clif_type(ret_lane_layout.ty).unwrap();\n \n-            let signed = match lane_layout.ty.sty {\n-                ty::Uint(..) => false,\n-                ty::Int(..) => true,\n-                ty::Float(..) => false, // `signed` is unused for floats\n-                _ => panic!(\"{}\", lane_layout.ty),\n-            };\n+            let from_signed = type_sign(lane_layout.ty);\n+            let to_signed = type_sign(ret_lane_layout.ty);\n \n             for lane in 0..lane_count {\n                 let lane = mir::Field::new(lane.try_into().unwrap());\n \n                 let a_lane = a.value_field(fx, lane).load_scalar(fx);\n-                let res = clif_int_or_float_cast(fx, a_lane, ret_lane_ty, signed);\n+                let res = clif_int_or_float_cast(fx, a_lane, from_signed, ret_lane_ty, to_signed);\n                 ret.place_field(fx, lane).write_cvalue(fx, CValue::by_val(res, ret_lane_layout));\n             }\n         };"}]}