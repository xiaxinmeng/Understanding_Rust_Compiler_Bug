{"sha": "cf148a717a275741a35b5f51eab182aa42bd06a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmMTQ4YTcxN2EyNzU3NDFhMzViNWY1MWVhYjE4MmFhNDJiZDA2YTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-27T03:34:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-27T03:34:54Z"}, "message": "Auto merge of #65288 - estebank:point-at-assoc-type, r=nikomatsakis\n\nPoint at associated type for some obligations\n\nPartially address #57663.", "tree": {"sha": "b97e5b9189f938fe34a367a6d3d9a06caad964cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b97e5b9189f938fe34a367a6d3d9a06caad964cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf148a717a275741a35b5f51eab182aa42bd06a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf148a717a275741a35b5f51eab182aa42bd06a6", "html_url": "https://github.com/rust-lang/rust/commit/cf148a717a275741a35b5f51eab182aa42bd06a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf148a717a275741a35b5f51eab182aa42bd06a6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcf516d827300d21eb9f6312e799578b6f359d5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcf516d827300d21eb9f6312e799578b6f359d5d", "html_url": "https://github.com/rust-lang/rust/commit/fcf516d827300d21eb9f6312e799578b6f359d5d"}, {"sha": "3a4cacd45891db4a898606fc7b26d4b73009e5c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a4cacd45891db4a898606fc7b26d4b73009e5c3", "html_url": "https://github.com/rust-lang/rust/commit/3a4cacd45891db4a898606fc7b26d4b73009e5c3"}], "stats": {"total": 365, "additions": 304, "deletions": 61}, "files": [{"sha": "be9e24cb1a291ce8ac7dca25adb5e2ed526f5c6b", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 37, "deletions": 15, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=cf148a717a275741a35b5f51eab182aa42bd06a6", "patch": "@@ -195,8 +195,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n         error: &MismatchedProjectionTypes<'tcx>,\n     ) {\n-        let predicate =\n-            self.resolve_vars_if_possible(&obligation.predicate);\n+        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n \n         if predicate.references_error() {\n             return\n@@ -228,7 +227,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     &mut obligations\n                 );\n                 if let Err(error) = self.at(&obligation.cause, obligation.param_env)\n-                                        .eq(normalized_ty, data.ty) {\n+                    .eq(normalized_ty, data.ty)\n+                {\n                     values = Some(infer::ValuePairs::Types(ExpectedFound {\n                         expected: normalized_ty,\n                         found: data.ty,\n@@ -239,13 +239,19 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n \n             let msg = format!(\"type mismatch resolving `{}`\", predicate);\n-            let error_id = (DiagnosticMessageId::ErrorId(271),\n-                            Some(obligation.cause.span), msg);\n+            let error_id = (\n+                DiagnosticMessageId::ErrorId(271),\n+                Some(obligation.cause.span),\n+                msg,\n+            );\n             let fresh = self.tcx.sess.one_time_diagnostics.borrow_mut().insert(error_id);\n             if fresh {\n                 let mut diag = struct_span_err!(\n-                    self.tcx.sess, obligation.cause.span, E0271,\n-                    \"type mismatch resolving `{}`\", predicate\n+                    self.tcx.sess,\n+                    obligation.cause.span,\n+                    E0271,\n+                    \"type mismatch resolving `{}`\",\n+                    predicate\n                 );\n                 self.note_type_err(&mut diag, &obligation.cause, None, values, err);\n                 self.note_obligation_cause(&mut diag, obligation);\n@@ -532,23 +538,33 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// whose result could not be truly determined and thus we can't say\n     /// if the program type checks or not -- and they are unusual\n     /// occurrences in any case.\n-    pub fn report_overflow_error<T>(&self,\n-                                    obligation: &Obligation<'tcx, T>,\n-                                    suggest_increasing_limit: bool) -> !\n+    pub fn report_overflow_error<T>(\n+        &self,\n+        obligation: &Obligation<'tcx, T>,\n+        suggest_increasing_limit: bool,\n+    ) -> !\n         where T: fmt::Display + TypeFoldable<'tcx>\n     {\n         let predicate =\n             self.resolve_vars_if_possible(&obligation.predicate);\n-        let mut err = struct_span_err!(self.tcx.sess, obligation.cause.span, E0275,\n-                                       \"overflow evaluating the requirement `{}`\",\n-                                       predicate);\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            obligation.cause.span,\n+            E0275,\n+            \"overflow evaluating the requirement `{}`\",\n+            predicate\n+        );\n \n         if suggest_increasing_limit {\n             self.suggest_new_overflow_limit(&mut err);\n         }\n \n-        self.note_obligation_cause_code(&mut err, &obligation.predicate, &obligation.cause.code,\n-                                        &mut vec![]);\n+        self.note_obligation_cause_code(\n+            &mut err,\n+            &obligation.predicate,\n+            &obligation.cause.code,\n+            &mut vec![],\n+        );\n \n         err.emit();\n         self.tcx.sess.abort_if_errors();\n@@ -2197,6 +2213,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     );\n                 }\n             }\n+            ObligationCauseCode::AssocTypeBound(impl_span, orig) => {\n+                err.span_label(orig, \"associated type defined here\");\n+                if let Some(sp) = impl_span {\n+                    err.span_label(sp, \"in this `impl` item\");\n+                }\n+            }\n         }\n     }\n "}, {"sha": "1a1c021c3ea2790fab91d55d6eda544321e4e962", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=cf148a717a275741a35b5f51eab182aa42bd06a6", "patch": "@@ -271,6 +271,8 @@ pub enum ObligationCauseCode<'tcx> {\n \n     /// #[feature(trivial_bounds)] is not enabled\n     TrivialBound,\n+\n+    AssocTypeBound(/*impl*/ Option<Span>, /*original*/ Span),\n }\n \n // `ObligationCauseCode` is used a lot. Make sure it doesn't unintentionally get bigger."}, {"sha": "ca80bb66cb76175df538db1dcce6ec73c630e1d9", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=cf148a717a275741a35b5f51eab182aa42bd06a6", "patch": "@@ -548,6 +548,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::MethodReceiver => Some(super::MethodReceiver),\n             super::BlockTailExpression(id) => Some(super::BlockTailExpression(id)),\n             super::TrivialBound => Some(super::TrivialBound),\n+            super::AssocTypeBound(impl_sp, sp) => Some(super::AssocTypeBound(impl_sp, sp)),\n         }\n     }\n }"}, {"sha": "ca01992f2d0f41508cc78ca93d0c9f8900866673", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=cf148a717a275741a35b5f51eab182aa42bd06a6", "patch": "@@ -3141,6 +3141,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n+#[derive(Clone)]\n pub struct AssocItemsIterator<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     def_ids: &'tcx [DefId],"}, {"sha": "4ea01bf96476a8cde90efd60641ebbe3f04dc3fe", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 153, "deletions": 19, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=cf148a717a275741a35b5f51eab182aa42bd06a6", "patch": "@@ -22,11 +22,14 @@ pub fn obligations<'a, 'tcx>(\n     ty: Ty<'tcx>,\n     span: Span,\n ) -> Option<Vec<traits::PredicateObligation<'tcx>>> {\n-    let mut wf = WfPredicates { infcx,\n-                                param_env,\n-                                body_id,\n-                                span,\n-                                out: vec![] };\n+    let mut wf = WfPredicates {\n+        infcx,\n+        param_env,\n+        body_id,\n+        span,\n+        out: vec![],\n+        item: None,\n+    };\n     if wf.compute(ty) {\n         debug!(\"wf::obligations({:?}, body_id={:?}) = {:?}\", ty, body_id, wf.out);\n         let result = wf.normalize();\n@@ -47,8 +50,9 @@ pub fn trait_obligations<'a, 'tcx>(\n     body_id: hir::HirId,\n     trait_ref: &ty::TraitRef<'tcx>,\n     span: Span,\n+    item: Option<&'tcx hir::Item>,\n ) -> Vec<traits::PredicateObligation<'tcx>> {\n-    let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![] };\n+    let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![], item };\n     wf.compute_trait_ref(trait_ref, Elaborate::All);\n     wf.normalize()\n }\n@@ -60,7 +64,7 @@ pub fn predicate_obligations<'a, 'tcx>(\n     predicate: &ty::Predicate<'tcx>,\n     span: Span,\n ) -> Vec<traits::PredicateObligation<'tcx>> {\n-    let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![] };\n+    let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![], item: None };\n \n     // (*) ok to skip binders, because wf code is prepared for it\n     match *predicate {\n@@ -107,6 +111,7 @@ struct WfPredicates<'a, 'tcx> {\n     body_id: hir::HirId,\n     span: Span,\n     out: Vec<traits::PredicateObligation<'tcx>>,\n+    item: Option<&'tcx hir::Item>,\n }\n \n /// Controls whether we \"elaborate\" supertraits and so forth on the WF\n@@ -157,33 +162,162 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 .collect()\n     }\n \n-    /// Pushes the obligations required for `trait_ref` to be WF into\n-    /// `self.out`.\n+    /// Pushes the obligations required for `trait_ref` to be WF into `self.out`.\n     fn compute_trait_ref(&mut self, trait_ref: &ty::TraitRef<'tcx>, elaborate: Elaborate) {\n+        let tcx = self.infcx.tcx;\n         let obligations = self.nominal_obligations(trait_ref.def_id, trait_ref.substs);\n \n         let cause = self.cause(traits::MiscObligation);\n         let param_env = self.param_env;\n \n+        let item = &self.item;\n+        let extend_cause_with_original_assoc_item_obligation = |\n+            cause: &mut traits::ObligationCause<'_>,\n+            pred: &ty::Predicate<'_>,\n+            trait_assoc_items: ty::AssocItemsIterator<'_>,\n+        | {\n+            let item_span = item.map(|i| tcx.sess.source_map().def_span(i.span));\n+            match pred {\n+                ty::Predicate::Projection(proj) => {\n+                    // The obligation comes not from the current `impl` nor the `trait` being\n+                    // implemented, but rather from a \"second order\" obligation, like in\n+                    // `src/test/ui/associated-types/point-at-type-on-obligation-failure.rs`:\n+                    //\n+                    //   error[E0271]: type mismatch resolving `<Foo2 as Bar2>::Ok == ()`\n+                    //     --> $DIR/point-at-type-on-obligation-failure.rs:13:5\n+                    //      |\n+                    //   LL |     type Ok;\n+                    //      |          -- associated type defined here\n+                    //   ...\n+                    //   LL | impl Bar for Foo {\n+                    //      | ---------------- in this `impl` item\n+                    //   LL |     type Ok = ();\n+                    //      |     ^^^^^^^^^^^^^ expected u32, found ()\n+                    //      |\n+                    //      = note: expected type `u32`\n+                    //                 found type `()`\n+                    //\n+                    // FIXME: we would want to point a span to all places that contributed to this\n+                    // obligation. In the case above, it should be closer to:\n+                    //\n+                    //   error[E0271]: type mismatch resolving `<Foo2 as Bar2>::Ok == ()`\n+                    //     --> $DIR/point-at-type-on-obligation-failure.rs:13:5\n+                    //      |\n+                    //   LL |     type Ok;\n+                    //      |          -- associated type defined here\n+                    //   LL |     type Sibling: Bar2<Ok=Self::Ok>;\n+                    //      |     -------------------------------- obligation set here\n+                    //   ...\n+                    //   LL | impl Bar for Foo {\n+                    //      | ---------------- in this `impl` item\n+                    //   LL |     type Ok = ();\n+                    //      |     ^^^^^^^^^^^^^ expected u32, found ()\n+                    //   ...\n+                    //   LL | impl Bar2 for Foo2 {\n+                    //      | ---------------- in this `impl` item\n+                    //   LL |     type Ok = u32;\n+                    //      |     -------------- obligation set here\n+                    //      |\n+                    //      = note: expected type `u32`\n+                    //                 found type `()`\n+                    if let Some(hir::ItemKind::Impl(.., impl_items)) = item.map(|i| &i.kind) {\n+                        let trait_assoc_item = tcx.associated_item(proj.projection_def_id());\n+                        if let Some(impl_item) = impl_items.iter().filter(|item| {\n+                            item.ident == trait_assoc_item.ident\n+                        }).next() {\n+                            cause.span = impl_item.span;\n+                            cause.code = traits::AssocTypeBound(\n+                                item_span,\n+                                trait_assoc_item.ident.span,\n+                            );\n+                        }\n+                    }\n+                }\n+                ty::Predicate::Trait(proj) => {\n+                    // An associated item obligation born out of the `trait` failed to be met.\n+                    // Point at the `impl` that failed the obligation, the associated item that\n+                    // needed to meet the obligation, and the definition of that associated item,\n+                    // which should hold the obligation in most cases. An example can be seen in\n+                    // `src/test/ui/associated-types/point-at-type-on-obligation-failure-2.rs`:\n+                    //\n+                    //   error[E0277]: the trait bound `bool: Bar` is not satisfied\n+                    //     --> $DIR/point-at-type-on-obligation-failure-2.rs:8:5\n+                    //      |\n+                    //   LL |     type Assoc: Bar;\n+                    //      |          ----- associated type defined here\n+                    //   ...\n+                    //   LL | impl Foo for () {\n+                    //      | --------------- in this `impl` item\n+                    //   LL |     type Assoc = bool;\n+                    //      |     ^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `bool`\n+                    //\n+                    // FIXME: if the obligation comes from the where clause in the `trait`, we\n+                    // should point at it:\n+                    //\n+                    //   error[E0277]: the trait bound `bool: Bar` is not satisfied\n+                    //     --> $DIR/point-at-type-on-obligation-failure-2.rs:8:5\n+                    //      |\n+                    //      | trait Foo where <Self as Foo>>::Assoc: Bar {\n+                    //      |                 -------------------------- obligation set here\n+                    //   LL |     type Assoc;\n+                    //      |          ----- associated type defined here\n+                    //   ...\n+                    //   LL | impl Foo for () {\n+                    //      | --------------- in this `impl` item\n+                    //   LL |     type Assoc = bool;\n+                    //      |     ^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `bool`\n+                    if let (\n+                        ty::Projection(ty::ProjectionTy { item_def_id, .. }),\n+                        Some(hir::ItemKind::Impl(.., impl_items)),\n+                    ) = (&proj.skip_binder().self_ty().kind, item.map(|i| &i.kind)) {\n+                        if let Some((impl_item, trait_assoc_item)) = trait_assoc_items\n+                            .filter(|i| i.def_id == *item_def_id)\n+                            .next()\n+                            .and_then(|trait_assoc_item| impl_items.iter()\n+                                .filter(|i| i.ident == trait_assoc_item.ident)\n+                                .next()\n+                                .map(|impl_item| (impl_item, trait_assoc_item)))\n+                        {\n+                            cause.span = impl_item.span;\n+                            cause.code = traits::AssocTypeBound(\n+                                item_span,\n+                                trait_assoc_item.ident.span,\n+                            );\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+        };\n+\n         if let Elaborate::All = elaborate {\n+            let trait_assoc_items = tcx.associated_items(trait_ref.def_id);\n+\n             let predicates = obligations.iter()\n-                                        .map(|obligation| obligation.predicate.clone())\n-                                        .collect();\n-            let implied_obligations = traits::elaborate_predicates(self.infcx.tcx, predicates);\n+                .map(|obligation| obligation.predicate.clone())\n+                .collect();\n+            let implied_obligations = traits::elaborate_predicates(tcx, predicates);\n             let implied_obligations = implied_obligations.map(|pred| {\n-                traits::Obligation::new(cause.clone(), param_env, pred)\n+                let mut cause = cause.clone();\n+                extend_cause_with_original_assoc_item_obligation(\n+                    &mut cause,\n+                    &pred,\n+                    trait_assoc_items.clone(),\n+                );\n+                traits::Obligation::new(cause, param_env, pred)\n             });\n             self.out.extend(implied_obligations);\n         }\n \n         self.out.extend(obligations);\n \n-        self.out.extend(\n-            trait_ref.substs.types()\n-                            .filter(|ty| !ty.has_escaping_bound_vars())\n-                            .map(|ty| traits::Obligation::new(cause.clone(),\n-                                                              param_env,\n-                                                              ty::Predicate::WellFormed(ty))));\n+        self.out.extend(trait_ref.substs.types()\n+            .filter(|ty| !ty.has_escaping_bound_vars())\n+            .map(|ty| traits::Obligation::new(\n+                cause.clone(),\n+                param_env,\n+                ty::Predicate::WellFormed(ty),\n+            )));\n     }\n \n     /// Pushes the obligations required for `trait_ref::Item` to be WF"}, {"sha": "b4b8d4566d577a48a40e4900a9449ea8a83e9a0f", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=cf148a717a275741a35b5f51eab182aa42bd06a6", "patch": "@@ -430,7 +430,7 @@ fn check_item_type(\n \n fn check_impl<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    item: &hir::Item,\n+    item: &'tcx hir::Item,\n     ast_self_ty: &hir::Ty,\n     ast_trait_ref: &Option<hir::TraitRef>,\n ) {\n@@ -445,15 +445,18 @@ fn check_impl<'tcx>(\n                 // therefore don't need to be WF (the trait's `Self: Trait` predicate\n                 // won't hold).\n                 let trait_ref = fcx.tcx.impl_trait_ref(item_def_id).unwrap();\n-                let trait_ref =\n-                    fcx.normalize_associated_types_in(\n-                        ast_trait_ref.path.span, &trait_ref);\n-                let obligations =\n-                    ty::wf::trait_obligations(fcx,\n-                                              fcx.param_env,\n-                                              fcx.body_id,\n-                                              &trait_ref,\n-                                              ast_trait_ref.path.span);\n+                let trait_ref = fcx.normalize_associated_types_in(\n+                    ast_trait_ref.path.span,\n+                    &trait_ref,\n+                );\n+                let obligations = ty::wf::trait_obligations(\n+                    fcx,\n+                    fcx.param_env,\n+                    fcx.body_id,\n+                    &trait_ref,\n+                    ast_trait_ref.path.span,\n+                    Some(item),\n+                );\n                 for obligation in obligations {\n                     fcx.register_predicate(obligation);\n                 }"}, {"sha": "6bb4cf86e7986aef58f568d368dd25e5b1516961", "filename": "src/test/compile-fail/chalkify/impl_wf.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Ftest%2Fcompile-fail%2Fchalkify%2Fimpl_wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Ftest%2Fcompile-fail%2Fchalkify%2Fimpl_wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fchalkify%2Fimpl_wf.rs?ref=cf148a717a275741a35b5f51eab182aa42bd06a6", "patch": "@@ -25,6 +25,7 @@ impl<T> Bar for Option<T> {\n impl Bar for f32 {\n //~^ ERROR the trait bound `f32: Foo` is not satisfied\n     type Item = f32;\n+    //~^ ERROR the trait bound `f32: Foo` is not satisfied\n }\n \n trait Baz<U: ?Sized> where U: Foo { }"}, {"sha": "9360d96f05e174a29c7a38389f3f37c7e6e621a8", "filename": "src/test/ui/associated-types/point-at-type-on-obligation-failure-2.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure-2.rs?ref=cf148a717a275741a35b5f51eab182aa42bd06a6", "patch": "@@ -0,0 +1,11 @@\n+trait Bar {}\n+\n+trait Foo {\n+    type Assoc: Bar;\n+}\n+\n+impl Foo for () {\n+    type Assoc = bool; //~ ERROR the trait bound `bool: Bar` is not satisfied\n+}\n+\n+fn main() {}"}, {"sha": "f1a2e343a7ec370e98c374e325a8203cf80879b9", "filename": "src/test/ui/associated-types/point-at-type-on-obligation-failure-2.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure-2.stderr?ref=cf148a717a275741a35b5f51eab182aa42bd06a6", "patch": "@@ -0,0 +1,14 @@\n+error[E0277]: the trait bound `bool: Bar` is not satisfied\n+  --> $DIR/point-at-type-on-obligation-failure-2.rs:8:5\n+   |\n+LL |     type Assoc: Bar;\n+   |          ----- associated type defined here\n+...\n+LL | impl Foo for () {\n+   | --------------- in this `impl` item\n+LL |     type Assoc = bool;\n+   |     ^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `bool`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "dc43dbaf54b99b1669ff85137f5f2b80dfec5cb9", "filename": "src/test/ui/associated-types/point-at-type-on-obligation-failure.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure.rs?ref=cf148a717a275741a35b5f51eab182aa42bd06a6", "patch": "@@ -0,0 +1,20 @@\n+trait Bar {\n+    type Ok;\n+    type Sibling: Bar2<Ok=Self::Ok>;\n+}\n+trait Bar2 {\n+    type Ok;\n+}\n+\n+struct Foo;\n+struct Foo2;\n+\n+impl Bar for Foo {\n+    type Ok = ();  //~ ERROR type mismatch resolving `<Foo2 as Bar2>::Ok == ()`\n+    type Sibling = Foo2;\n+}\n+impl Bar2 for Foo2 {\n+    type Ok = u32;\n+}\n+\n+fn main() {}"}, {"sha": "e4bd39c8ba62c53ab698197bdf509c0fcdc279db", "filename": "src/test/ui/associated-types/point-at-type-on-obligation-failure.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure.stderr?ref=cf148a717a275741a35b5f51eab182aa42bd06a6", "patch": "@@ -0,0 +1,17 @@\n+error[E0271]: type mismatch resolving `<Foo2 as Bar2>::Ok == ()`\n+  --> $DIR/point-at-type-on-obligation-failure.rs:13:5\n+   |\n+LL |     type Ok;\n+   |          -- associated type defined here\n+...\n+LL | impl Bar for Foo {\n+   | ---------------- in this `impl` item\n+LL |     type Ok = ();\n+   |     ^^^^^^^^^^^^^ expected u32, found ()\n+   |\n+   = note: expected type `u32`\n+              found type `()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "92083d88f1b82a8fc694c81d4bf3b63aeb1c456a", "filename": "src/test/ui/issues/issue-43784-associated-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Ftest%2Fui%2Fissues%2Fissue-43784-associated-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Ftest%2Fui%2Fissues%2Fissue-43784-associated-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-43784-associated-type.rs?ref=cf148a717a275741a35b5f51eab182aa42bd06a6", "patch": "@@ -10,8 +10,8 @@ impl<T> Partial<T> for T::Assoc where\n {\n }\n \n-impl<T> Complete for T { //~ ERROR the trait bound `T: std::marker::Copy` is not satisfied\n-    type Assoc = T;\n+impl<T> Complete for T {\n+    type Assoc = T; //~ ERROR the trait bound `T: std::marker::Copy` is not satisfied\n }\n \n fn main() {}"}, {"sha": "393b012f5f8a7f27e78b2d94b8b8276dfcab53da", "filename": "src/test/ui/issues/issue-43784-associated-type.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Ftest%2Fui%2Fissues%2Fissue-43784-associated-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Ftest%2Fui%2Fissues%2Fissue-43784-associated-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-43784-associated-type.stderr?ref=cf148a717a275741a35b5f51eab182aa42bd06a6", "patch": "@@ -1,10 +1,16 @@\n error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n-  --> $DIR/issue-43784-associated-type.rs:13:9\n+  --> $DIR/issue-43784-associated-type.rs:14:5\n    |\n+LL |     type Assoc: Partial<Self>;\n+   |          ----- associated type defined here\n+...\n LL | impl<T> Complete for T {\n-   |      -  ^^^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n-   |      |\n-   |      help: consider restricting this bound: `T: std::marker::Copy`\n+   | ----------------------\n+   | |    |\n+   | |    help: consider restricting this bound: `T: std::marker::Copy`\n+   | in this `impl` item\n+LL |     type Assoc = T;\n+   |     ^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n \n error: aborting due to previous error\n "}, {"sha": "394512c57947455366e35103fbc590c4e96d5145", "filename": "src/test/ui/suggestions/missing-assoc-type-bound-restriction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-assoc-type-bound-restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-assoc-type-bound-restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-assoc-type-bound-restriction.rs?ref=cf148a717a275741a35b5f51eab182aa42bd06a6", "patch": "@@ -16,10 +16,10 @@ struct ParentWrapper<T>(T);\n \n impl<A, T: Parent<Ty = A>> Parent for ParentWrapper<T> {\n     //~^ ERROR the trait bound `<T as Parent>::Assoc: Child<A>` is not satisfied\n-    //~| ERROR the trait bound `<T as Parent>::Assoc: Child<A>` is not satisfied\n     type Ty = A;\n     type Assoc = ChildWrapper<T::Assoc>;\n     //~^ ERROR the trait bound `<T as Parent>::Assoc: Child<A>` is not satisfied\n+    //~| ERROR the trait bound `<T as Parent>::Assoc: Child<A>` is not satisfied\n }\n \n fn main() {}"}, {"sha": "c6f2e5cda66af5b2bcd40c2317ae2892f84507f4", "filename": "src/test/ui/suggestions/missing-assoc-type-bound-restriction.stderr", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-assoc-type-bound-restriction.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-assoc-type-bound-restriction.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-assoc-type-bound-restriction.stderr?ref=cf148a717a275741a35b5f51eab182aa42bd06a6", "patch": "@@ -9,25 +9,31 @@ LL |   impl<A, T: Parent<Ty = A>> Parent for ParentWrapper<T> {\n    |  _|\n    | |\n LL | |\n-LL | |\n LL | |     type Ty = A;\n LL | |     type Assoc = ChildWrapper<T::Assoc>;\n LL | |\n+LL | |\n LL | | }\n    | |_^ the trait `Child<A>` is not implemented for `<T as Parent>::Assoc`\n \n error[E0277]: the trait bound `<T as Parent>::Assoc: Child<A>` is not satisfied\n-  --> $DIR/missing-assoc-type-bound-restriction.rs:17:28\n+  --> $DIR/missing-assoc-type-bound-restriction.rs:20:5\n    |\n+LL |     type Assoc: Child<Self::Ty>;\n+   |          ----- associated type defined here\n+...\n LL | impl<A, T: Parent<Ty = A>> Parent for ParentWrapper<T> {\n-   |                            ^^^^^^                     - help: consider further restricting the associated type: `where <T as Parent>::Assoc: Child<A>`\n-   |                            |\n-   |                            the trait `Child<A>` is not implemented for `<T as Parent>::Assoc`\n+   | ------------------------------------------------------- help: consider further restricting the associated type: `where <T as Parent>::Assoc: Child<A>`\n+   | |\n+   | in this `impl` item\n+...\n+LL |     type Assoc = ChildWrapper<T::Assoc>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Child<A>` is not implemented for `<T as Parent>::Assoc`\n    |\n    = note: required because of the requirements on the impl of `Child<A>` for `ChildWrapper<<T as Parent>::Assoc>`\n \n error[E0277]: the trait bound `<T as Parent>::Assoc: Child<A>` is not satisfied\n-  --> $DIR/missing-assoc-type-bound-restriction.rs:21:5\n+  --> $DIR/missing-assoc-type-bound-restriction.rs:20:5\n    |\n LL | trait Parent {\n    | ------------ required by `Parent`"}, {"sha": "cbddef082be6732465e712fc4a213ecd20134c36", "filename": "src/test/ui/traits/cycle-cache-err-60010.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.rs?ref=cf148a717a275741a35b5f51eab182aa42bd06a6", "patch": "@@ -27,8 +27,8 @@ struct SalsaStorage {\n     _parse: <ParseQuery as Query<RootDatabase>>::Data, //~ ERROR overflow\n }\n \n-impl Database for RootDatabase { //~ ERROR overflow\n-    type Storage = SalsaStorage;\n+impl Database for RootDatabase {\n+    type Storage = SalsaStorage; //~ ERROR overflow\n }\n impl HasQueryGroup for RootDatabase {}\n impl<DB> Query<DB> for ParseQuery"}, {"sha": "f439de88261179519c417e62ca90f271501cde97", "filename": "src/test/ui/traits/cycle-cache-err-60010.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf148a717a275741a35b5f51eab182aa42bd06a6/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.stderr?ref=cf148a717a275741a35b5f51eab182aa42bd06a6", "patch": "@@ -7,10 +7,15 @@ LL |     _parse: <ParseQuery as Query<RootDatabase>>::Data,\n    = note: required because of the requirements on the impl of `Query<RootDatabase>` for `ParseQuery`\n \n error[E0275]: overflow evaluating the requirement `RootDatabase: SourceDatabase`\n-  --> $DIR/cycle-cache-err-60010.rs:30:6\n+  --> $DIR/cycle-cache-err-60010.rs:31:5\n    |\n+LL |     type Storage;\n+   |          ------- associated type defined here\n+...\n LL | impl Database for RootDatabase {\n-   |      ^^^^^^^^\n+   | ------------------------------ in this `impl` item\n+LL |     type Storage = SalsaStorage;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: required because of the requirements on the impl of `Query<RootDatabase>` for `ParseQuery`\n    = note: required because it appears within the type `SalsaStorage`"}]}