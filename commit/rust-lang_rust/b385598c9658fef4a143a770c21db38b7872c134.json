{"sha": "b385598c9658fef4a143a770c21db38b7872c134", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzODU1OThjOTY1OGZlZjRhMTQzYTc3MGMyMWRiMzhiNzg3MmMxMzQ=", "commit": {"author": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2020-10-10T07:30:10Z"}, "committer": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2020-10-10T13:56:51Z"}, "message": "Apply suggestions from code review\n\nCo-authored-by: Joshua Nelson <joshua@yottadb.com>", "tree": {"sha": "224ad9e0ce128f9454058a72ebc1893d8248933a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/224ad9e0ce128f9454058a72ebc1893d8248933a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b385598c9658fef4a143a770c21db38b7872c134", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b385598c9658fef4a143a770c21db38b7872c134", "html_url": "https://github.com/rust-lang/rust/commit/b385598c9658fef4a143a770c21db38b7872c134", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b385598c9658fef4a143a770c21db38b7872c134/comments", "author": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5fbfab8c0c2f36dbb631d77df272b3965bd074c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5fbfab8c0c2f36dbb631d77df272b3965bd074c", "html_url": "https://github.com/rust-lang/rust/commit/a5fbfab8c0c2f36dbb631d77df272b3965bd074c"}], "stats": {"total": 38, "additions": 22, "deletions": 16}, "files": [{"sha": "8be9482acffdea753eec7f10ec8dded7ad75e7b3", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b385598c9658fef4a143a770c21db38b7872c134/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b385598c9658fef4a143a770c21db38b7872c134/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=b385598c9658fef4a143a770c21db38b7872c134", "patch": "@@ -238,7 +238,6 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     fn resolve_primitive_associated_item(\n         &self,\n         prim_ty: hir::PrimTy,\n-        prim: Res,\n         ns: Namespace,\n         module_id: DefId,\n         item_name: Symbol,\n@@ -263,7 +262,12 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         ty::AssocKind::Const => \"associatedconstant\",\n                         ty::AssocKind::Type => \"associatedtype\",\n                     })\n-                    .map(|out| (prim, Some(format!(\"{}#{}.{}\", prim_ty.name(), out, item_str))))\n+                    .map(|out| {\n+                        (\n+                            Res::PrimTy(prim_ty),\n+                            Some(format!(\"{}#{}.{}\", prim_ty.name(), out, item_str)),\n+                        )\n+                    })\n             })\n             .ok_or_else(|| {\n                 debug!(\n@@ -274,7 +278,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 );\n                 ResolutionFailure::NotResolved {\n                     module_id,\n-                    partial_res: Some(prim),\n+                    partial_res: Some(Res::PrimTy(prim_ty)),\n                     unresolved: item_str.into(),\n                 }\n                 .into()\n@@ -328,10 +332,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         });\n         debug!(\"{} resolved to {:?} in namespace {:?}\", path_str, result, ns);\n         match result.map(|(_, res)| res) {\n-            Ok(Res::Err) | Err(()) => is_bool_value(path_str, ns).map(|(_, res)| res),\n-\n             // resolver doesn't know about true and false so we'll have to resolve them\n             // manually as bool\n+            Ok(Res::Err) | Err(()) => is_bool_value(path_str, ns).map(|(_, res)| res),\n             Ok(res) => Some(res.map_id(|_| panic!(\"unexpected node_id\"))),\n         }\n     }\n@@ -406,6 +409,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 }\n             })?;\n \n+        // FIXME: are these both necessary?\n         let ty_res = if let Some(ty_res) = is_primitive(&path_root, TypeNS)\n             .map(|(_, res)| res)\n             .or_else(|| self.resolve_path(&path_root, TypeNS, module_id))\n@@ -426,9 +430,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         };\n \n         let res = match ty_res {\n-            Res::PrimTy(prim) => Some(self.resolve_primitive_associated_item(\n-                prim, ty_res, ns, module_id, item_name, item_str,\n-            )),\n+            Res::PrimTy(prim) => Some(\n+                self.resolve_primitive_associated_item(prim, ns, module_id, item_name, item_str),\n+            ),\n             Res::Def(DefKind::Struct | DefKind::Union | DefKind::Enum | DefKind::TyAlias, did) => {\n                 debug!(\"looking for associated item named {} for item {:?}\", item_name, did);\n                 // Checks if item_name belongs to `impl SomeItem`\n@@ -1086,7 +1090,7 @@ impl LinkCollector<'_, '_> {\n                         return None;\n                     }\n                     res = prim;\n-                    fragment = Some((*path.as_str()).to_owned());\n+                    fragment = Some(path.as_str().to_string());\n                 } else {\n                     // `[char]` when a `char` module is in scope\n                     let candidates = vec![res, prim];\n@@ -1943,14 +1947,14 @@ fn handle_variant(\n     if extra_fragment.is_some() {\n         return Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(res)));\n     }\n-    cx.tcx.parent(res.def_id()).map_or_else(\n-        || Err(ResolutionFailure::NoParentItem.into()),\n-        |parent| {\n+    cx.tcx\n+        .parent(res.def_id())\n+        .map(|parent| {\n             let parent_def = Res::Def(DefKind::Enum, parent);\n             let variant = cx.tcx.expect_variant_res(res);\n-            Ok((parent_def, Some(format!(\"variant.{}\", variant.ident.name))))\n-        },\n-    )\n+            (parent_def, Some(format!(\"variant.{}\", variant.ident.name)))\n+        })\n+        .ok_or_else(|| ResolutionFailure::NoParentItem.into())\n }\n \n // FIXME: At this point, this is basically a copy of the PrimitiveTypeTable\n@@ -1977,7 +1981,9 @@ const PRIMITIVES: &[(Symbol, Res)] = &[\n fn is_primitive(path_str: &str, ns: Namespace) -> Option<(Symbol, Res)> {\n     is_bool_value(path_str, ns).or_else(|| {\n         if ns == TypeNS {\n-            PRIMITIVES.iter().find(|x| x.0.as_str() == path_str).copied()\n+            // FIXME: this should be replaced by a lookup in PrimitiveTypeTable\n+            let maybe_primitive = Symbol::intern(path_str);\n+            PRIMITIVES.iter().find(|x| x.0 == maybe_primitive).copied()\n         } else {\n             None\n         }"}]}