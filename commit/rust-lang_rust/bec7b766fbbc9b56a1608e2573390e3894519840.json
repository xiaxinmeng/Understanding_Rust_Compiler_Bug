{"sha": "bec7b766fbbc9b56a1608e2573390e3894519840", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlYzdiNzY2ZmJiYzliNTZhMTYwOGUyNTczMzkwZTM4OTQ1MTk4NDA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-28T22:34:26Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-07T01:45:48Z"}, "message": "rustc: Move to FNV hashing for node/def ids\n\nThis leverages the new hashing framework and hashmap implementation to provide a\nmuch speedier hashing algorithm for node ids and def ids. The hash algorithm\nused is currentl FNV hashing, but it's quite easy to swap out.\n\nI originally implemented hashing as the identity function, but this actually\nended up in slowing down rustc compiling libstd from 8s to 13s. I would suspect\nthat this is a result of a large number of collisions.\n\nWith FNV hashing, we get these timings (compiling with --no-trans, in seconds):\n\n|           |  before  |  after  |\n|-----------|---------:|--------:|\n| libstd    |   8.324  |  6.703  |\n| stdtest   |  47.674  | 46.857  |\n| libsyntax |   9.918  |  8.400  |", "tree": {"sha": "e867bdfab8c090f94d1aee36ae96f5f86e22fbdf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e867bdfab8c090f94d1aee36ae96f5f86e22fbdf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bec7b766fbbc9b56a1608e2573390e3894519840", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bec7b766fbbc9b56a1608e2573390e3894519840", "html_url": "https://github.com/rust-lang/rust/commit/bec7b766fbbc9b56a1608e2573390e3894519840", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bec7b766fbbc9b56a1608e2573390e3894519840/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e95b086db515386faf41549b490515a540165b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e95b086db515386faf41549b490515a540165b1", "html_url": "https://github.com/rust-lang/rust/commit/0e95b086db515386faf41549b490515a540165b1"}], "stats": {"total": 559, "additions": 364, "deletions": 195}, "files": [{"sha": "58eb2119c6af9895f238352dabf6a6162f9e72c7", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -27,6 +27,7 @@ use middle::{trans, freevars, kind, ty, typeck, lint, astencode, reachable};\n use middle;\n use util::common::time;\n use util::ppaux;\n+use util::nodemap::NodeSet;\n \n use serialize::{json, Encodable};\n \n@@ -38,7 +39,7 @@ use std::os;\n use std::vec;\n use std::vec_ng::Vec;\n use std::vec_ng;\n-use collections::{HashMap, HashSet};\n+use collections::HashMap;\n use getopts::{optopt, optmulti, optflag, optflagopt, opt};\n use MaybeHasArg = getopts::Maybe;\n use OccurOptional = getopts::Optional;\n@@ -258,7 +259,7 @@ pub struct CrateAnalysis {\n     public_items: middle::privacy::PublicItems,\n     ty_cx: ty::ctxt,\n     maps: astencode::Maps,\n-    reachable: @RefCell<HashSet<ast::NodeId>>\n+    reachable: @RefCell<NodeSet>,\n }\n \n /// Run the resolution, typechecking, region checking and other"}, {"sha": "d1560abf773d1eb035765b2e919f07a815b40054", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -29,7 +29,7 @@ This API is completely unstable and subject to change.\n \n #[allow(deprecated)];\n #[feature(macro_rules, globs, struct_variant, managed_boxes)];\n-#[feature(quote)];\n+#[feature(quote, default_type_params)];\n \n extern crate extra;\n extern crate flate;\n@@ -125,6 +125,7 @@ pub mod util {\n     pub mod common;\n     pub mod ppaux;\n     pub mod sha2;\n+    pub mod nodemap;\n }\n \n pub mod lib {"}, {"sha": "7d5688ba19ba3ebc7243927332d0717ab708ec8c", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -23,6 +23,7 @@ use middle::astencode;\n use middle::ty;\n use middle::typeck;\n use middle;\n+use util::nodemap::{NodeMap, NodeSet};\n \n use serialize::Encodable;\n use std::cast;\n@@ -31,7 +32,7 @@ use std::hash;\n use std::hash::Hash;\n use std::io::MemWriter;\n use std::str;\n-use collections::{HashMap, HashSet};\n+use collections::HashMap;\n use syntax::abi::AbiSet;\n use syntax::ast::*;\n use syntax::ast;\n@@ -69,8 +70,8 @@ pub struct EncodeParams<'a> {\n     diag: @SpanHandler,\n     tcx: ty::ctxt,\n     reexports2: middle::resolve::ExportMap2,\n-    item_symbols: &'a RefCell<HashMap<ast::NodeId, ~str>>,\n-    non_inlineable_statics: &'a RefCell<HashSet<ast::NodeId>>,\n+    item_symbols: &'a RefCell<NodeMap<~str>>,\n+    non_inlineable_statics: &'a RefCell<NodeSet>,\n     link_meta: &'a LinkMeta,\n     cstore: @cstore::CStore,\n     encode_inlined_item: EncodeInlinedItem<'a>,\n@@ -97,8 +98,8 @@ pub struct EncodeContext<'a> {\n     tcx: ty::ctxt,\n     stats: @Stats,\n     reexports2: middle::resolve::ExportMap2,\n-    item_symbols: &'a RefCell<HashMap<ast::NodeId, ~str>>,\n-    non_inlineable_statics: &'a RefCell<HashSet<ast::NodeId>>,\n+    item_symbols: &'a RefCell<NodeMap<~str>>,\n+    non_inlineable_statics: &'a RefCell<NodeSet>,\n     link_meta: &'a LinkMeta,\n     cstore: &'a cstore::CStore,\n     encode_inlined_item: EncodeInlinedItem<'a>,"}, {"sha": "099ef284d95b1ab77f014f733b23102314fd327a", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -12,15 +12,15 @@ use middle::cfg::*;\n use middle::graph;\n use middle::typeck;\n use middle::ty;\n-use collections::HashMap;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::opt_vec;\n+use util::nodemap::NodeMap;\n \n struct CFGBuilder {\n     tcx: ty::ctxt,\n     method_map: typeck::MethodMap,\n-    exit_map: HashMap<ast::NodeId, CFGIndex>,\n+    exit_map: NodeMap<CFGIndex>,\n     graph: CFGGraph,\n     loop_scopes: ~[LoopScope],\n }\n@@ -35,7 +35,7 @@ pub fn construct(tcx: ty::ctxt,\n                  method_map: typeck::MethodMap,\n                  blk: &ast::Block) -> CFG {\n     let mut cfg_builder = CFGBuilder {\n-        exit_map: HashMap::new(),\n+        exit_map: NodeMap::new(),\n         graph: graph::Graph::new(),\n         tcx: tcx,\n         method_map: method_map,"}, {"sha": "bdf39e3e8ec6382fa48dd81e7a783a378434cea3", "filename": "src/librustc/middle/cfg/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -18,14 +18,14 @@ Uses `Graph` as the underlying representation.\n use middle::graph;\n use middle::ty;\n use middle::typeck;\n-use collections::HashMap;\n use syntax::ast;\n use syntax::opt_vec::OptVec;\n+use util::nodemap::NodeMap;\n \n mod construct;\n \n pub struct CFG {\n-    exit_map: HashMap<ast::NodeId, CFGIndex>,\n+    exit_map: NodeMap<CFGIndex>,\n     graph: CFGGraph,\n     entry: CFGIndex,\n     exit: CFGIndex,"}, {"sha": "effdbd8e45176b30be1ae540c8289a79a31697de", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -16,6 +16,7 @@ use middle::astencode;\n use middle::ty;\n use middle::typeck::astconv;\n use middle;\n+use util::nodemap::{DefIdMap, NodeMap};\n \n use syntax::ast::*;\n use syntax::parse::token::InternedString;\n@@ -66,7 +67,7 @@ pub enum constness {\n     non_const\n }\n \n-type constness_cache = HashMap<ast::DefId, constness>;\n+type constness_cache = DefIdMap<constness>;\n \n pub fn join(a: constness, b: constness) -> constness {\n     match (a, b) {\n@@ -134,9 +135,9 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n         }\n         let maps = astencode::Maps {\n             root_map: @RefCell::new(HashMap::new()),\n-            method_map: @RefCell::new(HashMap::new()),\n-            vtable_map: @RefCell::new(HashMap::new()),\n-            capture_map: @RefCell::new(HashMap::new())\n+            method_map: @RefCell::new(NodeMap::new()),\n+            vtable_map: @RefCell::new(NodeMap::new()),\n+            capture_map: @RefCell::new(NodeMap::new())\n         };\n         let e = match csearch::maybe_get_item_ast(tcx, enum_def,\n             |a, b, c, d| astencode::decode_inlined_item(a, b,\n@@ -184,9 +185,9 @@ pub fn lookup_const_by_id(tcx: ty::ctxt, def_id: ast::DefId)\n         }\n         let maps = astencode::Maps {\n             root_map: @RefCell::new(HashMap::new()),\n-            method_map: @RefCell::new(HashMap::new()),\n-            vtable_map: @RefCell::new(HashMap::new()),\n-            capture_map: @RefCell::new(HashMap::new())\n+            method_map: @RefCell::new(NodeMap::new()),\n+            vtable_map: @RefCell::new(NodeMap::new()),\n+            capture_map: @RefCell::new(NodeMap::new())\n         };\n         let e = match csearch::maybe_get_item_ast(tcx, def_id,\n             |a, b, c, d| astencode::decode_inlined_item(a, b, maps, c, d)) {\n@@ -305,7 +306,7 @@ pub fn process_crate(krate: &ast::Crate,\n                      tcx: ty::ctxt) {\n     let mut v = ConstEvalVisitor {\n         tcx: tcx,\n-        ccache: HashMap::new(),\n+        ccache: DefIdMap::new(),\n     };\n     visit::walk_crate(&mut v, krate, ());\n     tcx.sess.abort_if_errors();"}, {"sha": "700a3d5a4a4c0360918a6a28ef3c2ef6ed440fa9", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -20,14 +20,14 @@\n use std::io;\n use std::uint;\n use std::vec;\n-use collections::HashMap;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::ast_util::IdRange;\n use syntax::print::{pp, pprust};\n use middle::ty;\n use middle::typeck;\n use util::ppaux::Repr;\n+use util::nodemap::NodeMap;\n \n #[deriving(Clone)]\n pub struct DataFlowContext<O> {\n@@ -45,7 +45,7 @@ pub struct DataFlowContext<O> {\n     priv words_per_id: uint,\n \n     // mapping from node to bitset index.\n-    priv nodeid_to_bitset: HashMap<ast::NodeId,uint>,\n+    priv nodeid_to_bitset: NodeMap<uint>,\n \n     // Bit sets per id.  The following three fields (`gens`, `kills`,\n     // and `on_entry`) all have the same structure. For each id in\n@@ -139,7 +139,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n             tcx: tcx,\n             method_map: method_map,\n             words_per_id: words_per_id,\n-            nodeid_to_bitset: HashMap::new(),\n+            nodeid_to_bitset: NodeMap::new(),\n             bits_per_id: bits_per_id,\n             oper: oper,\n             gens: gens,"}, {"sha": "eaf665119d3e28df4c331c3b8102edad0bb1875e", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -16,6 +16,7 @@ use middle::lint::{allow, contains_lint, DeadCode};\n use middle::privacy;\n use middle::ty;\n use middle::typeck;\n+use util::nodemap::NodeSet;\n \n use collections::HashSet;\n use syntax::ast;\n@@ -252,7 +253,7 @@ impl Visitor<()> for LifeSeeder {\n \n fn create_and_seed_worklist(tcx: ty::ctxt,\n                             exported_items: &privacy::ExportedItems,\n-                            reachable_symbols: &HashSet<ast::NodeId>,\n+                            reachable_symbols: &NodeSet,\n                             krate: &ast::Crate) -> ~[ast::NodeId] {\n     let mut worklist = ~[];\n \n@@ -286,7 +287,7 @@ fn create_and_seed_worklist(tcx: ty::ctxt,\n fn find_live(tcx: ty::ctxt,\n              method_map: typeck::MethodMap,\n              exported_items: &privacy::ExportedItems,\n-             reachable_symbols: &HashSet<ast::NodeId>,\n+             reachable_symbols: &NodeSet,\n              krate: &ast::Crate)\n              -> ~HashSet<ast::NodeId> {\n     let worklist = create_and_seed_worklist(tcx, exported_items,\n@@ -409,7 +410,7 @@ impl Visitor<()> for DeadVisitor {\n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: typeck::MethodMap,\n                    exported_items: &privacy::ExportedItems,\n-                   reachable_symbols: &HashSet<ast::NodeId>,\n+                   reachable_symbols: &NodeSet,\n                    krate: &ast::Crate) {\n     let live_symbols = find_live(tcx, method_map, exported_items,\n                                  reachable_symbols, krate);"}, {"sha": "b41398b440156785f2a75e13b5815227fdaa9aa0", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -15,8 +15,8 @@\n \n use middle::resolve;\n use middle::ty;\n+use util::nodemap::{NodeMap, NodeSet};\n \n-use collections::HashMap;\n use syntax::codemap::Span;\n use syntax::{ast, ast_util};\n use syntax::visit;\n@@ -30,10 +30,10 @@ pub struct freevar_entry {\n     span: Span     //< First span where it is accessed (there can be multiple)\n }\n pub type freevar_info = @~[@freevar_entry];\n-pub type freevar_map = HashMap<ast::NodeId, freevar_info>;\n+pub type freevar_map = NodeMap<freevar_info>;\n \n struct CollectFreevarsVisitor {\n-    seen: HashMap<ast::NodeId, ()>,\n+    seen: NodeSet,\n     refs: ~[@freevar_entry],\n     def_map: resolve::DefMap,\n }\n@@ -65,12 +65,12 @@ impl Visitor<int> for CollectFreevarsVisitor {\n                         }\n                         if i == depth { // Made it to end of loop\n                             let dnum = ast_util::def_id_of_def(def).node;\n-                            if !self.seen.contains_key(&dnum) {\n+                            if !self.seen.contains(&dnum) {\n                                 self.refs.push(@freevar_entry {\n                                     def: def,\n                                     span: expr.span,\n                                 });\n-                                self.seen.insert(dnum, ());\n+                                self.seen.insert(dnum);\n                             }\n                         }\n                     }\n@@ -89,7 +89,7 @@ impl Visitor<int> for CollectFreevarsVisitor {\n // of the AST, we take a walker function that we invoke with a visitor\n // in order to start the search.\n fn collect_freevars(def_map: resolve::DefMap, blk: &ast::Block) -> freevar_info {\n-    let seen = HashMap::new();\n+    let seen = NodeSet::new();\n     let refs = ~[];\n \n     let mut v = CollectFreevarsVisitor {\n@@ -129,7 +129,7 @@ pub fn annotate_freevars(def_map: resolve::DefMap, krate: &ast::Crate) ->\n    freevar_map {\n     let mut visitor = AnnotateFreevarsVisitor {\n         def_map: def_map,\n-        freevars: HashMap::new(),\n+        freevars: NodeMap::new(),\n     };\n     visit::walk_crate(&mut visitor, krate, ());\n "}, {"sha": "3ae85bbd6c7ace7a18395b439a248e97e4d27821", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -108,6 +108,7 @@ use middle::pat_util;\n use middle::ty;\n use middle::typeck;\n use middle::moves;\n+use util::nodemap::NodeMap;\n \n use std::cast::transmute;\n use std::cell::{Cell, RefCell};\n@@ -116,7 +117,6 @@ use std::io;\n use std::str;\n use std::uint;\n use std::vec;\n-use collections::HashMap;\n use syntax::ast::*;\n use syntax::codemap::Span;\n use syntax::parse::token::special_idents;\n@@ -258,9 +258,9 @@ pub struct IrMaps {\n \n     num_live_nodes: Cell<uint>,\n     num_vars: Cell<uint>,\n-    live_node_map: RefCell<HashMap<NodeId, LiveNode>>,\n-    variable_map: RefCell<HashMap<NodeId, Variable>>,\n-    capture_info_map: RefCell<HashMap<NodeId, @~[CaptureInfo]>>,\n+    live_node_map: RefCell<NodeMap<LiveNode>>,\n+    variable_map: RefCell<NodeMap<Variable>>,\n+    capture_info_map: RefCell<NodeMap<@~[CaptureInfo]>>,\n     var_kinds: RefCell<~[VarKind]>,\n     lnks: RefCell<~[LiveNodeKind]>,\n }\n@@ -275,9 +275,9 @@ fn IrMaps(tcx: ty::ctxt,\n         capture_map: capture_map,\n         num_live_nodes: Cell::new(0),\n         num_vars: Cell::new(0),\n-        live_node_map: RefCell::new(HashMap::new()),\n-        variable_map: RefCell::new(HashMap::new()),\n-        capture_info_map: RefCell::new(HashMap::new()),\n+        live_node_map: RefCell::new(NodeMap::new()),\n+        variable_map: RefCell::new(NodeMap::new()),\n+        capture_info_map: RefCell::new(NodeMap::new()),\n         var_kinds: RefCell::new(~[]),\n         lnks: RefCell::new(~[]),\n     }\n@@ -584,7 +584,7 @@ static ACC_READ: uint = 1u;\n static ACC_WRITE: uint = 2u;\n static ACC_USE: uint = 4u;\n \n-pub type LiveNodeMap = @RefCell<HashMap<NodeId, LiveNode>>;\n+pub type LiveNodeMap = @RefCell<NodeMap<LiveNode>>;\n \n pub struct Liveness {\n     tcx: ty::ctxt,\n@@ -613,8 +613,8 @@ fn Liveness(ir: @IrMaps, specials: Specials) -> Liveness {\n                                             ir.num_vars.get(),\n                                             invalid_users())),\n         loop_scope: @RefCell::new(~[]),\n-        break_ln: @RefCell::new(HashMap::new()),\n-        cont_ln: @RefCell::new(HashMap::new()),\n+        break_ln: @RefCell::new(NodeMap::new()),\n+        cont_ln: @RefCell::new(NodeMap::new()),\n     }\n }\n "}, {"sha": "41ea80cff28e73908f0767149c741a58bbde5f65", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -135,10 +135,10 @@ use util::ppaux;\n use util::ppaux::Repr;\n use util::common::indenter;\n use util::ppaux::UserString;\n+use util::nodemap::{NodeMap, NodeSet};\n \n use std::cell::RefCell;\n use std::rc::Rc;\n-use collections::{HashSet, HashMap};\n use syntax::ast::*;\n use syntax::ast_util;\n use syntax::visit;\n@@ -159,17 +159,17 @@ pub struct CaptureVar {\n     mode: CaptureMode // How variable is being accessed\n }\n \n-pub type CaptureMap = @RefCell<HashMap<NodeId, Rc<~[CaptureVar]>>>;\n+pub type CaptureMap = @RefCell<NodeMap<Rc<~[CaptureVar]>>>;\n \n-pub type MovesMap = @RefCell<HashSet<NodeId>>;\n+pub type MovesMap = @RefCell<NodeSet>;\n \n /**\n  * Set of variable node-ids that are moved.\n  *\n  * Note: The `VariableMovesMap` stores expression ids that\n  * are moves, whereas this set stores the ids of the variables\n  * that are moved at some point */\n-pub type MovedVariablesSet = @RefCell<HashSet<NodeId>>;\n+pub type MovedVariablesSet = @RefCell<NodeSet>;\n \n /** See the section Output on the module comment for explanation. */\n #[deriving(Clone)]\n@@ -215,9 +215,9 @@ pub fn compute_moves(tcx: ty::ctxt,\n         tcx: tcx,\n         method_map: method_map,\n         move_maps: MoveMaps {\n-            moves_map: @RefCell::new(HashSet::new()),\n-            capture_map: @RefCell::new(HashMap::new()),\n-            moved_variables_set: @RefCell::new(HashSet::new())\n+            moves_map: @RefCell::new(NodeSet::new()),\n+            capture_map: @RefCell::new(NodeMap::new()),\n+            moved_variables_set: @RefCell::new(NodeSet::new())\n         }\n     };\n     let visit_cx = &mut visit_cx;"}, {"sha": "182a52817b2581ef8a0edb891e25c2754612750a", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -13,14 +13,14 @@\n //! which are available for use externally when compiled as a library.\n \n use std::mem::replace;\n-use collections::{HashSet, HashMap};\n \n use metadata::csearch;\n use middle::lint;\n use middle::resolve;\n use middle::ty;\n use middle::typeck::{MethodMap, MethodOrigin, MethodParam};\n use middle::typeck::{MethodStatic, MethodObject};\n+use util::nodemap::{NodeMap, NodeSet};\n \n use syntax::ast;\n use syntax::ast_map;\n@@ -35,12 +35,12 @@ use syntax::visit::Visitor;\n type Context<'a> = (&'a MethodMap, &'a resolve::ExportMap2);\n \n /// A set of AST nodes exported by the crate.\n-pub type ExportedItems = HashSet<ast::NodeId>;\n+pub type ExportedItems = NodeSet;\n \n /// A set of AST nodes that are fully public in the crate. This map is used for\n /// documentation purposes (reexporting a private struct inlines the doc,\n /// reexporting a public struct doesn't inline the doc).\n-pub type PublicItems = HashSet<ast::NodeId>;\n+pub type PublicItems = NodeSet;\n \n /// Result of a checking operation - None => no errors were found. Some => an\n /// error and contains the span and message for reporting that error and\n@@ -52,7 +52,7 @@ type CheckResult = Option<(Span, ~str, Option<(Span, ~str)>)>;\n ////////////////////////////////////////////////////////////////////////////////\n \n struct ParentVisitor {\n-    parents: HashMap<ast::NodeId, ast::NodeId>,\n+    parents: NodeMap<ast::NodeId>,\n     curparent: ast::NodeId,\n }\n \n@@ -161,7 +161,7 @@ struct EmbargoVisitor<'a> {\n     // all nodes which are reexported *and* reachable from external crates. This\n     // means that the destination of the reexport is exported, and hence the\n     // destination must also be exported.\n-    reexports: HashSet<ast::NodeId>,\n+    reexports: NodeSet,\n \n     // These two fields are closely related to one another in that they are only\n     // used for generation of the 'PublicItems' set, not for privacy checking at\n@@ -349,7 +349,7 @@ struct PrivacyVisitor<'a> {\n     in_fn: bool,\n     in_foreign: bool,\n     method_map: &'a MethodMap,\n-    parents: HashMap<ast::NodeId, ast::NodeId>,\n+    parents: NodeMap<ast::NodeId>,\n     external_exports: resolve::ExternalExports,\n     last_private_map: resolve::LastPrivateMap,\n }\n@@ -1424,7 +1424,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                    krate: &ast::Crate) -> (ExportedItems, PublicItems) {\n     // Figure out who everyone's parent is\n     let mut visitor = ParentVisitor {\n-        parents: HashMap::new(),\n+        parents: NodeMap::new(),\n         curparent: ast::DUMMY_NODE_ID,\n     };\n     visit::walk_crate(&mut visitor, krate, ());\n@@ -1456,9 +1456,9 @@ pub fn check_crate(tcx: ty::ctxt,\n     // items which are reachable from external crates based on visibility.\n     let mut visitor = EmbargoVisitor {\n         tcx: tcx,\n-        exported_items: HashSet::new(),\n-        public_items: HashSet::new(),\n-        reexports: HashSet::new(),\n+        exported_items: NodeSet::new(),\n+        public_items: NodeSet::new(),\n+        reexports: NodeSet::new(),\n         exp_map2: exp_map2,\n         prev_exported: true,\n         prev_public: true,"}, {"sha": "4ade65294d9e4c9f07260032ad0e0e3058ba83e2", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -18,6 +18,7 @@\n use middle::ty;\n use middle::typeck;\n use middle::privacy;\n+use util::nodemap::NodeSet;\n \n use std::cell::RefCell;\n use collections::HashSet;\n@@ -88,7 +89,7 @@ struct ReachableContext {\n     // methods they've been resolved to.\n     method_map: typeck::MethodMap,\n     // The set of items which must be exported in the linkage sense.\n-    reachable_symbols: @RefCell<HashSet<ast::NodeId>>,\n+    reachable_symbols: @RefCell<NodeSet>,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n     // and will be scanned for further references.\n     worklist: @RefCell<~[ast::NodeId]>,\n@@ -98,7 +99,7 @@ struct MarkSymbolVisitor {\n     worklist: @RefCell<~[ast::NodeId]>,\n     method_map: typeck::MethodMap,\n     tcx: ty::ctxt,\n-    reachable_symbols: @RefCell<HashSet<ast::NodeId>>,\n+    reachable_symbols: @RefCell<NodeSet>,\n }\n \n impl Visitor<()> for MarkSymbolVisitor {\n@@ -188,7 +189,7 @@ impl ReachableContext {\n         ReachableContext {\n             tcx: tcx,\n             method_map: method_map,\n-            reachable_symbols: @RefCell::new(HashSet::new()),\n+            reachable_symbols: @RefCell::new(NodeSet::new()),\n             worklist: @RefCell::new(~[]),\n         }\n     }\n@@ -395,7 +396,7 @@ impl ReachableContext {\n pub fn find_reachable(tcx: ty::ctxt,\n                       method_map: typeck::MethodMap,\n                       exported_items: &privacy::ExportedItems)\n-                      -> @RefCell<HashSet<ast::NodeId>> {\n+                      -> @RefCell<NodeSet> {\n     let reachable_context = ReachableContext::new(tcx, method_map);\n \n     // Step 1: Seed the worklist with all nodes which were found to be public as"}, {"sha": "07b68900ba5f1a2494308deba465990a5f0ea213", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -24,6 +24,7 @@ Most of the documentation on regions can be found in\n use driver::session::Session;\n use middle::ty::{FreeRegion};\n use middle::ty;\n+use util::nodemap::NodeMap;\n \n use std::cell::RefCell;\n use collections::{HashMap, HashSet};\n@@ -74,10 +75,10 @@ The region maps encode information about region relationships.\n   for dynamic checks and/or arbitrary amounts of stack space.\n */\n pub struct RegionMaps {\n-    priv scope_map: RefCell<HashMap<ast::NodeId, ast::NodeId>>,\n-    priv var_map: RefCell<HashMap<ast::NodeId, ast::NodeId>>,\n+    priv scope_map: RefCell<NodeMap<ast::NodeId>>,\n+    priv var_map: RefCell<NodeMap<ast::NodeId>>,\n     priv free_region_map: RefCell<HashMap<FreeRegion, ~[FreeRegion]>>,\n-    priv rvalue_scopes: RefCell<HashMap<ast::NodeId, ast::NodeId>>,\n+    priv rvalue_scopes: RefCell<NodeMap<ast::NodeId>>,\n     priv terminating_scopes: RefCell<HashSet<ast::NodeId>>,\n }\n \n@@ -910,10 +911,10 @@ impl<'a> Visitor<Context> for RegionResolutionVisitor<'a> {\n \n pub fn resolve_crate(sess: Session, krate: &ast::Crate) -> RegionMaps {\n     let maps = RegionMaps {\n-        scope_map: RefCell::new(HashMap::new()),\n-        var_map: RefCell::new(HashMap::new()),\n+        scope_map: RefCell::new(NodeMap::new()),\n+        var_map: RefCell::new(NodeMap::new()),\n         free_region_map: RefCell::new(HashMap::new()),\n-        rvalue_scopes: RefCell::new(HashMap::new()),\n+        rvalue_scopes: RefCell::new(NodeMap::new()),\n         terminating_scopes: RefCell::new(HashSet::new()),\n     };\n     {"}, {"sha": "46faf5b040fcfa6909e494fcfe98018c2c86fbe7", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -16,6 +16,7 @@ use metadata::decoder::{DefLike, DlDef, DlField, DlImpl};\n use middle::lang_items::LanguageItems;\n use middle::lint::{UnnecessaryQualification, UnusedImports};\n use middle::pat_util::pat_bindings;\n+use util::nodemap::{NodeMap, DefIdSet};\n \n use syntax::ast::*;\n use syntax::ast;\n@@ -36,7 +37,7 @@ use std::mem::replace;\n use collections::{HashMap, HashSet};\n \n // Definition mapping\n-pub type DefMap = @RefCell<HashMap<NodeId,Def>>;\n+pub type DefMap = @RefCell<NodeMap<Def>>;\n \n struct binding_info {\n     span: Span,\n@@ -47,11 +48,11 @@ struct binding_info {\n type BindingMap = HashMap<Name,binding_info>;\n \n // Trait method resolution\n-pub type TraitMap = HashMap<NodeId, ~[DefId]>;\n+pub type TraitMap = NodeMap<~[DefId]>;\n \n // This is the replacement export map. It maps a module to all of the exports\n // within.\n-pub type ExportMap2 = @RefCell<HashMap<NodeId, ~[Export2]>>;\n+pub type ExportMap2 = @RefCell<NodeMap<~[Export2]>>;\n \n pub struct Export2 {\n     name: ~str,        // The name of the target.\n@@ -60,10 +61,10 @@ pub struct Export2 {\n \n // This set contains all exported definitions from external crates. The set does\n // not contain any entries from local crates.\n-pub type ExternalExports = HashSet<DefId>;\n+pub type ExternalExports = DefIdSet;\n \n // FIXME: dox\n-pub type LastPrivateMap = HashMap<NodeId, LastPrivate>;\n+pub type LastPrivateMap = NodeMap<LastPrivate>;\n \n pub enum LastPrivate {\n     LastMod(PrivateDep),\n@@ -457,7 +458,7 @@ struct Module {\n     //\n     // There will be an anonymous module created around `g` with the ID of the\n     // entry block for `f`.\n-    anonymous_children: RefCell<HashMap<NodeId,@Module>>,\n+    anonymous_children: RefCell<NodeMap<@Module>>,\n \n     // The status of resolving each import in this module.\n     import_resolutions: RefCell<HashMap<Name, @ImportResolution>>,\n@@ -489,7 +490,7 @@ impl Module {\n             children: RefCell::new(HashMap::new()),\n             imports: RefCell::new(~[]),\n             external_module_children: RefCell::new(HashMap::new()),\n-            anonymous_children: RefCell::new(HashMap::new()),\n+            anonymous_children: RefCell::new(NodeMap::new()),\n             import_resolutions: RefCell::new(HashMap::new()),\n             glob_count: Cell::new(0),\n             resolved_import_count: Cell::new(0),\n@@ -827,12 +828,12 @@ fn Resolver(session: Session,\n \n         namespaces: ~[ TypeNS, ValueNS ],\n \n-        def_map: @RefCell::new(HashMap::new()),\n-        export_map2: @RefCell::new(HashMap::new()),\n-        trait_map: HashMap::new(),\n+        def_map: @RefCell::new(NodeMap::new()),\n+        export_map2: @RefCell::new(NodeMap::new()),\n+        trait_map: NodeMap::new(),\n         used_imports: HashSet::new(),\n-        external_exports: HashSet::new(),\n-        last_private: HashMap::new(),\n+        external_exports: DefIdSet::new(),\n+        last_private: NodeMap::new(),\n \n         emit_errors: true,\n     };"}, {"sha": "c8e28d45e3cf1f686dd5e15237f49f843a536dfb", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -19,7 +19,7 @@\n \n use driver::session;\n use std::cell::RefCell;\n-use collections::HashMap;\n+use util::nodemap::NodeMap;\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::opt_vec::OptVec;\n@@ -31,7 +31,7 @@ use syntax::visit::Visitor;\n \n // maps the id of each lifetime reference to the lifetime decl\n // that it corresponds to\n-pub type NamedRegionMap = HashMap<ast::NodeId, ast::DefRegion>;\n+pub type NamedRegionMap = NodeMap<ast::DefRegion>;\n \n struct LifetimeContext {\n     sess: session::Session,\n@@ -49,7 +49,7 @@ pub fn krate(sess: session::Session, krate: &ast::Crate)\n              -> @RefCell<NamedRegionMap> {\n     let mut ctxt = LifetimeContext {\n         sess: sess,\n-        named_region_map: @RefCell::new(HashMap::new())\n+        named_region_map: @RefCell::new(NodeMap::new())\n     };\n     visit::walk_crate(&mut ctxt, krate, &RootScope);\n     sess.abort_if_errors();"}, {"sha": "625b130d47af96be708b871d3580dbbf4a6696fd", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -70,6 +70,7 @@ use middle::typeck;\n use util::common::indenter;\n use util::ppaux::{Repr, ty_to_str};\n use util::sha2::Sha256;\n+use util::nodemap::NodeMap;\n \n use arena::TypedArena;\n use std::c_str::ToCStr;\n@@ -1245,9 +1246,9 @@ pub fn new_fn_ctxt<'a>(ccx: @CrateContext,\n           llreturn: Cell::new(None),\n           personality: Cell::new(None),\n           caller_expects_out_pointer: uses_outptr,\n-          llargs: RefCell::new(HashMap::new()),\n-          lllocals: RefCell::new(HashMap::new()),\n-          llupvars: RefCell::new(HashMap::new()),\n+          llargs: RefCell::new(NodeMap::new()),\n+          lllocals: RefCell::new(NodeMap::new()),\n+          llupvars: RefCell::new(NodeMap::new()),\n           id: id,\n           param_substs: param_substs,\n           span: sp,"}, {"sha": "90f3765183388e38aad760859ae0fb439184abfd", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -29,6 +29,7 @@ use middle::ty::substs;\n use middle::ty;\n use middle::typeck;\n use util::ppaux::Repr;\n+use util::nodemap::NodeMap;\n \n use arena::TypedArena;\n use std::c_str::ToCStr;\n@@ -253,14 +254,14 @@ pub struct FunctionContext<'a> {\n     caller_expects_out_pointer: bool,\n \n     // Maps arguments to allocas created for them in llallocas.\n-    llargs: RefCell<HashMap<ast::NodeId, LvalueDatum>>,\n+    llargs: RefCell<NodeMap<LvalueDatum>>,\n \n     // Maps the def_ids for local variables to the allocas created for\n     // them in llallocas.\n-    lllocals: RefCell<HashMap<ast::NodeId, LvalueDatum>>,\n+    lllocals: RefCell<NodeMap<LvalueDatum>>,\n \n     // Same as above, but for closure upvars\n-    llupvars: RefCell<HashMap<ast::NodeId, ValueRef>>,\n+    llupvars: RefCell<NodeMap<ValueRef>>,\n \n     // The NodeId of the function, or -1 if it doesn't correspond to\n     // a user-defined function."}, {"sha": "652336ecc000b4c889ebb767a8e2cba9d048c61d", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -27,6 +27,7 @@ use middle::trans::debuginfo;\n use middle::trans::type_::Type;\n use middle::ty;\n use util::sha2::Sha256;\n+use util::nodemap::{NodeMap, NodeSet, DefIdMap};\n \n use std::cell::{Cell, RefCell};\n use std::c_str::ToCStr;\n@@ -45,28 +46,28 @@ pub struct CrateContext {\n     tn: TypeNames,\n     externs: RefCell<ExternMap>,\n     intrinsics: HashMap<&'static str, ValueRef>,\n-    item_vals: RefCell<HashMap<ast::NodeId, ValueRef>>,\n+    item_vals: RefCell<NodeMap<ValueRef>>,\n     exp_map2: resolve::ExportMap2,\n-    reachable: @RefCell<HashSet<ast::NodeId>>,\n-    item_symbols: RefCell<HashMap<ast::NodeId, ~str>>,\n+    reachable: @RefCell<NodeSet>,\n+    item_symbols: RefCell<NodeMap<~str>>,\n     link_meta: LinkMeta,\n     drop_glues: RefCell<HashMap<ty::t, ValueRef>>,\n     tydescs: RefCell<HashMap<ty::t, @tydesc_info>>,\n     // Set when running emit_tydescs to enforce that no more tydescs are\n     // created.\n     finished_tydescs: Cell<bool>,\n     // Track mapping of external ids to local items imported for inlining\n-    external: RefCell<HashMap<ast::DefId, Option<ast::NodeId>>>,\n+    external: RefCell<DefIdMap<Option<ast::NodeId>>>,\n     // Backwards version of the `external` map (inlined items to where they\n     // came from)\n-    external_srcs: RefCell<HashMap<ast::NodeId, ast::DefId>>,\n+    external_srcs: RefCell<NodeMap<ast::DefId>>,\n     // A set of static items which cannot be inlined into other crates. This\n     // will pevent in IIItem() structures from being encoded into the metadata\n     // that is generated\n-    non_inlineable_statics: RefCell<HashSet<ast::NodeId>>,\n+    non_inlineable_statics: RefCell<NodeSet>,\n     // Cache instances of monomorphized functions\n     monomorphized: RefCell<HashMap<mono_id, ValueRef>>,\n-    monomorphizing: RefCell<HashMap<ast::DefId, uint>>,\n+    monomorphizing: RefCell<DefIdMap<uint>>,\n     // Cache generated vtables\n     vtables: RefCell<HashMap<(ty::t, mono_id), ValueRef>>,\n     // Cache of constant strings,\n@@ -83,10 +84,10 @@ pub struct CrateContext {\n     const_globals: RefCell<HashMap<int, ValueRef>>,\n \n     // Cache of emitted const values\n-    const_values: RefCell<HashMap<ast::NodeId, ValueRef>>,\n+    const_values: RefCell<NodeMap<ValueRef>>,\n \n     // Cache of external const values\n-    extern_const_values: RefCell<HashMap<ast::DefId, ValueRef>>,\n+    extern_const_values: RefCell<DefIdMap<ValueRef>>,\n \n     impl_method_cache: RefCell<HashMap<(ast::DefId, ast::Name), ast::DefId>>,\n \n@@ -125,7 +126,7 @@ impl CrateContext {\n                maps: astencode::Maps,\n                symbol_hasher: Sha256,\n                link_meta: LinkMeta,\n-               reachable: @RefCell<HashSet<ast::NodeId>>)\n+               reachable: @RefCell<NodeSet>)\n                -> CrateContext {\n         unsafe {\n             let llcx = llvm::LLVMContextCreate();\n@@ -185,24 +186,24 @@ impl CrateContext {\n                  tn: tn,\n                  externs: RefCell::new(HashMap::new()),\n                  intrinsics: intrinsics,\n-                 item_vals: RefCell::new(HashMap::new()),\n+                 item_vals: RefCell::new(NodeMap::new()),\n                  exp_map2: emap2,\n                  reachable: reachable,\n-                 item_symbols: RefCell::new(HashMap::new()),\n+                 item_symbols: RefCell::new(NodeMap::new()),\n                  link_meta: link_meta,\n                  drop_glues: RefCell::new(HashMap::new()),\n                  tydescs: RefCell::new(HashMap::new()),\n                  finished_tydescs: Cell::new(false),\n-                 external: RefCell::new(HashMap::new()),\n-                 external_srcs: RefCell::new(HashMap::new()),\n-                 non_inlineable_statics: RefCell::new(HashSet::new()),\n+                 external: RefCell::new(DefIdMap::new()),\n+                 external_srcs: RefCell::new(NodeMap::new()),\n+                 non_inlineable_statics: RefCell::new(NodeSet::new()),\n                  monomorphized: RefCell::new(HashMap::new()),\n-                 monomorphizing: RefCell::new(HashMap::new()),\n+                 monomorphizing: RefCell::new(DefIdMap::new()),\n                  vtables: RefCell::new(HashMap::new()),\n                  const_cstr_cache: RefCell::new(HashMap::new()),\n                  const_globals: RefCell::new(HashMap::new()),\n-                 const_values: RefCell::new(HashMap::new()),\n-                 extern_const_values: RefCell::new(HashMap::new()),\n+                 const_values: RefCell::new(NodeMap::new()),\n+                 extern_const_values: RefCell::new(DefIdMap::new()),\n                  impl_method_cache: RefCell::new(HashMap::new()),\n                  closure_bare_wrapper_cache: RefCell::new(HashMap::new()),\n                  module_data: RefCell::new(HashMap::new()),"}, {"sha": "db9f3ed5a8157bf24076c991a64be529995282d1", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -66,11 +66,10 @@ use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn};\n use middle::ty;\n use util::common::indenter;\n use util::ppaux::Repr;\n+use util::nodemap::NodeMap;\n use middle::trans::machine::llsize_of;\n-\n use middle::trans::type_::Type;\n \n-use collections::HashMap;\n use std::vec;\n use syntax::ast;\n use syntax::ast_map;\n@@ -944,7 +943,7 @@ pub fn trans_local_var<'a>(bcx: &'a Block<'a>,\n     };\n \n     fn take_local<'a>(bcx: &'a Block<'a>,\n-                      table: &HashMap<ast::NodeId, Datum<Lvalue>>,\n+                      table: &NodeMap<Datum<Lvalue>>,\n                       nid: ast::NodeId)\n                       -> Datum<Lvalue> {\n         let datum = match table.find(&nid) {"}, {"sha": "a83a03c9838fd751fdc6e1440244c7b8903ef4eb", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 64, "deletions": 63, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -30,6 +30,7 @@ use util::ppaux::{note_and_explain_region, bound_region_ptr_to_str};\n use util::ppaux::{trait_store_to_str, ty_to_str, vstore_to_str};\n use util::ppaux::{Repr, UserString};\n use util::common::{indenter};\n+use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n \n use std::cast;\n use std::cell::{Cell, RefCell};\n@@ -178,11 +179,9 @@ impl cmp::Eq for intern_key {\n     }\n }\n \n-impl Hash for intern_key {\n-    fn hash(&self, s: &mut sip::SipState) {\n-        unsafe {\n-            (*self.sty).hash(s)\n-        }\n+impl<W:Writer> Hash<W> for intern_key {\n+    fn hash(&self, s: &mut W) {\n+        unsafe { (*self.sty).hash(s) }\n     }\n }\n \n@@ -250,7 +249,9 @@ pub type ctxt = @ctxt_;\n /// later on.\n pub struct ctxt_ {\n     diag: @syntax::diagnostic::SpanHandler,\n-    interner: RefCell<HashMap<intern_key, ~t_box_>>,\n+    // Specifically use a speedy hash algorithm for this hash map, it's used\n+    // quite often.\n+    interner: RefCell<HashMap<intern_key, ~t_box_, ::util::nodemap::FnvHasher>>,\n     next_id: Cell<uint>,\n     cstore: @metadata::cstore::CStore,\n     sess: session::Session,\n@@ -269,94 +270,94 @@ pub struct ctxt_ {\n     // of this node.  This only applies to nodes that refer to entities\n     // parameterized by type parameters, such as generic fns, types, or\n     // other items.\n-    node_type_substs: RefCell<HashMap<NodeId, ~[t]>>,\n+    node_type_substs: RefCell<NodeMap<~[t]>>,\n \n     // Maps from a method to the method \"descriptor\"\n-    methods: RefCell<HashMap<DefId, @Method>>,\n+    methods: RefCell<DefIdMap<@Method>>,\n \n     // Maps from a trait def-id to a list of the def-ids of its methods\n-    trait_method_def_ids: RefCell<HashMap<DefId, @~[DefId]>>,\n+    trait_method_def_ids: RefCell<DefIdMap<@~[DefId]>>,\n \n     // A cache for the trait_methods() routine\n-    trait_methods_cache: RefCell<HashMap<DefId, @~[@Method]>>,\n+    trait_methods_cache: RefCell<DefIdMap<@~[@Method]>>,\n \n-    impl_trait_cache: RefCell<HashMap<ast::DefId, Option<@ty::TraitRef>>>,\n+    impl_trait_cache: RefCell<DefIdMap<Option<@ty::TraitRef>>>,\n \n-    trait_refs: RefCell<HashMap<NodeId, @TraitRef>>,\n-    trait_defs: RefCell<HashMap<DefId, @TraitDef>>,\n+    trait_refs: RefCell<NodeMap<@TraitRef>>,\n+    trait_defs: RefCell<DefIdMap<@TraitDef>>,\n \n     map: ast_map::Map,\n-    intrinsic_defs: RefCell<HashMap<ast::DefId, t>>,\n+    intrinsic_defs: RefCell<DefIdMap<t>>,\n     freevars: RefCell<freevars::freevar_map>,\n     tcache: type_cache,\n     rcache: creader_cache,\n     short_names_cache: RefCell<HashMap<t, ~str>>,\n     needs_unwind_cleanup_cache: RefCell<HashMap<t, bool>>,\n     tc_cache: RefCell<HashMap<uint, TypeContents>>,\n-    ast_ty_to_ty_cache: RefCell<HashMap<NodeId, ast_ty_to_ty_cache_entry>>,\n-    enum_var_cache: RefCell<HashMap<DefId, @~[@VariantInfo]>>,\n-    ty_param_defs: RefCell<HashMap<ast::NodeId, TypeParameterDef>>,\n-    adjustments: RefCell<HashMap<ast::NodeId, @AutoAdjustment>>,\n+    ast_ty_to_ty_cache: RefCell<NodeMap<ast_ty_to_ty_cache_entry>>,\n+    enum_var_cache: RefCell<DefIdMap<@~[@VariantInfo]>>,\n+    ty_param_defs: RefCell<NodeMap<TypeParameterDef>>,\n+    adjustments: RefCell<NodeMap<@AutoAdjustment>>,\n     normalized_cache: RefCell<HashMap<t, t>>,\n     lang_items: @middle::lang_items::LanguageItems,\n     // A mapping of fake provided method def_ids to the default implementation\n-    provided_method_sources: RefCell<HashMap<ast::DefId, ast::DefId>>,\n-    supertraits: RefCell<HashMap<ast::DefId, @~[@TraitRef]>>,\n+    provided_method_sources: RefCell<DefIdMap<ast::DefId>>,\n+    supertraits: RefCell<DefIdMap<@~[@TraitRef]>>,\n \n     // Maps from def-id of a type or region parameter to its\n     // (inferred) variance.\n-    item_variance_map: RefCell<HashMap<ast::DefId, @ItemVariances>>,\n+    item_variance_map: RefCell<DefIdMap<@ItemVariances>>,\n \n     // A mapping from the def ID of an enum or struct type to the def ID\n     // of the method that implements its destructor. If the type is not\n     // present in this map, it does not have a destructor. This map is\n     // populated during the coherence phase of typechecking.\n-    destructor_for_type: RefCell<HashMap<ast::DefId, ast::DefId>>,\n+    destructor_for_type: RefCell<DefIdMap<ast::DefId>>,\n \n     // A method will be in this list if and only if it is a destructor.\n-    destructors: RefCell<HashSet<ast::DefId>>,\n+    destructors: RefCell<DefIdSet>,\n \n     // Maps a trait onto a list of impls of that trait.\n-    trait_impls: RefCell<HashMap<ast::DefId, @RefCell<~[@Impl]>>>,\n+    trait_impls: RefCell<DefIdMap<@RefCell<~[@Impl]>>>,\n \n     // Maps a def_id of a type to a list of its inherent impls.\n     // Contains implementations of methods that are inherent to a type.\n     // Methods in these implementations don't need to be exported.\n-    inherent_impls: RefCell<HashMap<ast::DefId, @RefCell<~[@Impl]>>>,\n+    inherent_impls: RefCell<DefIdMap<@RefCell<~[@Impl]>>>,\n \n     // Maps a def_id of an impl to an Impl structure.\n     // Note that this contains all of the impls that we know about,\n     // including ones in other crates. It's not clear that this is the best\n     // way to do it.\n-    impls: RefCell<HashMap<ast::DefId, @Impl>>,\n+    impls: RefCell<DefIdMap<@Impl>>,\n \n     // Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n     // present in this set can be warned about.\n-    used_unsafe: RefCell<HashSet<ast::NodeId>>,\n+    used_unsafe: RefCell<NodeSet>,\n \n     // Set of nodes which mark locals as mutable which end up getting used at\n     // some point. Local variable definitions not in this set can be warned\n     // about.\n-    used_mut_nodes: RefCell<HashSet<ast::NodeId>>,\n+    used_mut_nodes: RefCell<NodeSet>,\n \n     // vtable resolution information for impl declarations\n     impl_vtables: typeck::impl_vtable_map,\n \n     // The set of external nominal types whose implementations have been read.\n     // This is used for lazy resolution of methods.\n-    populated_external_types: RefCell<HashSet<ast::DefId>>,\n+    populated_external_types: RefCell<DefIdSet>,\n \n     // The set of external traits whose implementations have been read. This\n     // is used for lazy resolution of traits.\n-    populated_external_traits: RefCell<HashSet<ast::DefId>>,\n+    populated_external_traits: RefCell<DefIdSet>,\n \n     // Borrows\n     upvar_borrow_map: RefCell<UpvarBorrowMap>,\n \n     // These two caches are used by const_eval when decoding external statics\n     // and variants that are found.\n-    extern_const_statics: RefCell<HashMap<ast::DefId, Option<@ast::Expr>>>,\n-    extern_const_variants: RefCell<HashMap<ast::DefId, Option<@ast::Expr>>>,\n+    extern_const_statics: RefCell<DefIdMap<Option<@ast::Expr>>>,\n+    extern_const_variants: RefCell<DefIdMap<Option<@ast::Expr>>>,\n }\n \n pub enum tbox_flag {\n@@ -1068,7 +1069,7 @@ pub struct ty_param_substs_and_ty {\n     ty: ty::t\n }\n \n-pub type type_cache = RefCell<HashMap<ast::DefId, ty_param_bounds_and_ty>>;\n+pub type type_cache = RefCell<DefIdMap<ty_param_bounds_and_ty>>;\n \n pub type node_type_table = RefCell<HashMap<uint,t>>;\n \n@@ -1083,51 +1084,51 @@ pub fn mk_ctxt(s: session::Session,\n \n     @ctxt_ {\n         named_region_map: named_region_map,\n-        item_variance_map: RefCell::new(HashMap::new()),\n+        item_variance_map: RefCell::new(DefIdMap::new()),\n         diag: s.diagnostic(),\n-        interner: RefCell::new(HashMap::new()),\n+        interner: RefCell::new(HashMap::with_hasher(::util::nodemap::FnvHasher)),\n         next_id: Cell::new(primitives::LAST_PRIMITIVE_ID),\n         cstore: s.cstore,\n         sess: s,\n         def_map: dm,\n         region_maps: region_maps,\n         node_types: RefCell::new(HashMap::new()),\n-        node_type_substs: RefCell::new(HashMap::new()),\n-        trait_refs: RefCell::new(HashMap::new()),\n-        trait_defs: RefCell::new(HashMap::new()),\n+        node_type_substs: RefCell::new(NodeMap::new()),\n+        trait_refs: RefCell::new(NodeMap::new()),\n+        trait_defs: RefCell::new(DefIdMap::new()),\n         map: map,\n-        intrinsic_defs: RefCell::new(HashMap::new()),\n+        intrinsic_defs: RefCell::new(DefIdMap::new()),\n         freevars: RefCell::new(freevars),\n-        tcache: RefCell::new(HashMap::new()),\n+        tcache: RefCell::new(DefIdMap::new()),\n         rcache: RefCell::new(HashMap::new()),\n         short_names_cache: RefCell::new(HashMap::new()),\n         needs_unwind_cleanup_cache: RefCell::new(HashMap::new()),\n         tc_cache: RefCell::new(HashMap::new()),\n-        ast_ty_to_ty_cache: RefCell::new(HashMap::new()),\n-        enum_var_cache: RefCell::new(HashMap::new()),\n-        methods: RefCell::new(HashMap::new()),\n-        trait_method_def_ids: RefCell::new(HashMap::new()),\n-        trait_methods_cache: RefCell::new(HashMap::new()),\n-        impl_trait_cache: RefCell::new(HashMap::new()),\n-        ty_param_defs: RefCell::new(HashMap::new()),\n-        adjustments: RefCell::new(HashMap::new()),\n+        ast_ty_to_ty_cache: RefCell::new(NodeMap::new()),\n+        enum_var_cache: RefCell::new(DefIdMap::new()),\n+        methods: RefCell::new(DefIdMap::new()),\n+        trait_method_def_ids: RefCell::new(DefIdMap::new()),\n+        trait_methods_cache: RefCell::new(DefIdMap::new()),\n+        impl_trait_cache: RefCell::new(DefIdMap::new()),\n+        ty_param_defs: RefCell::new(NodeMap::new()),\n+        adjustments: RefCell::new(NodeMap::new()),\n         normalized_cache: RefCell::new(HashMap::new()),\n         lang_items: lang_items,\n-        provided_method_sources: RefCell::new(HashMap::new()),\n-        supertraits: RefCell::new(HashMap::new()),\n-        destructor_for_type: RefCell::new(HashMap::new()),\n-        destructors: RefCell::new(HashSet::new()),\n-        trait_impls: RefCell::new(HashMap::new()),\n-        inherent_impls: RefCell::new(HashMap::new()),\n-        impls: RefCell::new(HashMap::new()),\n-        used_unsafe: RefCell::new(HashSet::new()),\n-        used_mut_nodes: RefCell::new(HashSet::new()),\n-        impl_vtables: RefCell::new(HashMap::new()),\n-        populated_external_types: RefCell::new(HashSet::new()),\n-        populated_external_traits: RefCell::new(HashSet::new()),\n+        provided_method_sources: RefCell::new(DefIdMap::new()),\n+        supertraits: RefCell::new(DefIdMap::new()),\n+        destructor_for_type: RefCell::new(DefIdMap::new()),\n+        destructors: RefCell::new(DefIdSet::new()),\n+        trait_impls: RefCell::new(DefIdMap::new()),\n+        inherent_impls: RefCell::new(DefIdMap::new()),\n+        impls: RefCell::new(DefIdMap::new()),\n+        used_unsafe: RefCell::new(NodeSet::new()),\n+        used_mut_nodes: RefCell::new(NodeSet::new()),\n+        impl_vtables: RefCell::new(DefIdMap::new()),\n+        populated_external_types: RefCell::new(DefIdSet::new()),\n+        populated_external_traits: RefCell::new(DefIdSet::new()),\n         upvar_borrow_map: RefCell::new(HashMap::new()),\n-        extern_const_statics: RefCell::new(HashMap::new()),\n-        extern_const_variants: RefCell::new(HashMap::new()),\n+        extern_const_statics: RefCell::new(DefIdMap::new()),\n+        extern_const_variants: RefCell::new(DefIdMap::new()),\n     }\n }\n \n@@ -3787,7 +3788,7 @@ pub fn trait_ref_supertraits(cx: ctxt, trait_ref: &ty::TraitRef) -> ~[@TraitRef]\n fn lookup_locally_or_in_crate_store<V:Clone>(\n                                     descr: &str,\n                                     def_id: ast::DefId,\n-                                    map: &mut HashMap<ast::DefId, V>,\n+                                    map: &mut DefIdMap<V>,\n                                     load_external: || -> V) -> V {\n     /*!\n      * Helper for looking things up in the various maps"}, {"sha": "6a41f63a779d3c0b5059df02f1a2619d78dceedb", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -111,6 +111,7 @@ use middle::lang_items::TypeIdLangItem;\n use util::common::{block_query, indenter, loop_query};\n use util::ppaux;\n use util::ppaux::{UserString, Repr};\n+use util::nodemap::NodeMap;\n \n use std::cell::{Cell, RefCell};\n use collections::HashMap;\n@@ -153,13 +154,13 @@ pub mod method;\n /// share the inherited fields.\n pub struct Inherited {\n     infcx: infer::InferCtxt,\n-    locals: @RefCell<HashMap<ast::NodeId, ty::t>>,\n+    locals: @RefCell<NodeMap<ty::t>>,\n     param_env: ty::ParameterEnvironment,\n \n     // Temporary tables:\n-    node_types: RefCell<HashMap<ast::NodeId, ty::t>>,\n-    node_type_substs: RefCell<HashMap<ast::NodeId, ty::substs>>,\n-    adjustments: RefCell<HashMap<ast::NodeId, @ty::AutoAdjustment>>,\n+    node_types: RefCell<NodeMap<ty::t>>,\n+    node_type_substs: RefCell<NodeMap<ty::substs>>,\n+    adjustments: RefCell<NodeMap<@ty::AutoAdjustment>>,\n     method_map: MethodMap,\n     vtable_map: vtable_map,\n     upvar_borrow_map: RefCell<ty::UpvarBorrowMap>,\n@@ -258,13 +259,13 @@ impl Inherited {\n            -> Inherited {\n         Inherited {\n             infcx: infer::new_infer_ctxt(tcx),\n-            locals: @RefCell::new(HashMap::new()),\n+            locals: @RefCell::new(NodeMap::new()),\n             param_env: param_env,\n-            node_types: RefCell::new(HashMap::new()),\n-            node_type_substs: RefCell::new(HashMap::new()),\n-            adjustments: RefCell::new(HashMap::new()),\n-            method_map: @RefCell::new(HashMap::new()),\n-            vtable_map: @RefCell::new(HashMap::new()),\n+            node_types: RefCell::new(NodeMap::new()),\n+            node_type_substs: RefCell::new(NodeMap::new()),\n+            adjustments: RefCell::new(NodeMap::new()),\n+            method_map: @RefCell::new(NodeMap::new()),\n+            vtable_map: @RefCell::new(NodeMap::new()),\n             upvar_borrow_map: RefCell::new(HashMap::new()),\n         }\n     }"}, {"sha": "aee2b24e60f4ca69bb06a521c2af01e99c49f2f2", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -68,9 +68,9 @@ use middle::ty;\n use util::common::time;\n use util::ppaux::Repr;\n use util::ppaux;\n+use util::nodemap::{DefIdMap, NodeMap};\n \n use std::cell::RefCell;\n-use collections::HashMap;\n use std::rc::Rc;\n use collections::List;\n use syntax::codemap::Span;\n@@ -150,7 +150,7 @@ pub struct MethodCallee {\n \n // maps from an expression id that corresponds to a method call to the details\n // of the method to be invoked\n-pub type MethodMap = @RefCell<HashMap<ast::NodeId, MethodCallee>>;\n+pub type MethodMap = @RefCell<NodeMap<MethodCallee>>;\n \n pub type vtable_param_res = @~[vtable_origin];\n // Resolutions for bounds of all parameters, left to right, for a given path.\n@@ -194,7 +194,7 @@ impl Repr for vtable_origin {\n     }\n }\n \n-pub type vtable_map = @RefCell<HashMap<ast::NodeId, vtable_res>>;\n+pub type vtable_map = @RefCell<NodeMap<vtable_res>>;\n \n \n // Information about the vtable resolutions for a trait impl.\n@@ -216,7 +216,7 @@ impl Repr for impl_res {\n     }\n }\n \n-pub type impl_vtable_map = RefCell<HashMap<ast::DefId, impl_res>>;\n+pub type impl_vtable_map = RefCell<DefIdMap<impl_res>>;\n \n pub struct CrateCtxt {\n     // A mapping from method call sites to traits that have that method.\n@@ -441,8 +441,8 @@ pub fn check_crate(tcx: ty::ctxt,\n     let time_passes = tcx.sess.time_passes();\n     let ccx = @CrateCtxt {\n         trait_map: trait_map,\n-        method_map: @RefCell::new(HashMap::new()),\n-        vtable_map: @RefCell::new(HashMap::new()),\n+        method_map: @RefCell::new(NodeMap::new()),\n+        vtable_map: @RefCell::new(NodeMap::new()),\n         tcx: tcx\n     };\n "}, {"sha": "84b579a1fb07ce34860c293bdeb77708998d8ccf", "filename": "src/librustc/util/nodemap.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -0,0 +1,80 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! An efficient hash map for node IDs\n+\n+use collections::{HashMap, HashSet};\n+use std::hash::{Hasher, Hash};\n+use std::io;\n+use syntax::ast;\n+\n+pub type NodeMap<T> = HashMap<ast::NodeId, T, FnvHasher>;\n+pub type DefIdMap<T> = HashMap<ast::DefId, T, FnvHasher>;\n+pub type NodeSet = HashSet<ast::NodeId, FnvHasher>;\n+pub type DefIdSet = HashSet<ast::DefId, FnvHasher>;\n+\n+// Hacks to get good names\n+pub mod NodeMap {\n+    use collections::HashMap;\n+    pub fn new<T>() -> super::NodeMap<T> {\n+        HashMap::with_hasher(super::FnvHasher)\n+    }\n+}\n+pub mod NodeSet {\n+    use collections::HashSet;\n+    pub fn new() -> super::NodeSet {\n+        HashSet::with_hasher(super::FnvHasher)\n+    }\n+}\n+pub mod DefIdMap {\n+    use collections::HashMap;\n+    pub fn new<T>() -> super::DefIdMap<T> {\n+        HashMap::with_hasher(super::FnvHasher)\n+    }\n+}\n+pub mod DefIdSet {\n+    use collections::HashSet;\n+    pub fn new() -> super::DefIdSet {\n+        HashSet::with_hasher(super::FnvHasher)\n+    }\n+}\n+\n+/// A speedy hash algorithm for node ids and def ids. The hashmap in\n+/// libcollections by default uses SipHash which isn't quite as speedy as we\n+/// want. In the compiler we're not really worried about DOS attempts, so we\n+/// just default to a non-cryptographic hash.\n+///\n+/// This uses FNV hashing, as described here:\n+/// http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function\n+#[deriving(Clone)]\n+pub struct FnvHasher;\n+\n+struct FnvState(u64);\n+\n+impl Hasher<FnvState> for FnvHasher {\n+    fn hash<T: Hash<FnvState>>(&self, t: &T) -> u64 {\n+        let mut state = FnvState(0xcbf29ce484222325);\n+        t.hash(&mut state);\n+        let FnvState(ret) = state;\n+        return ret;\n+    }\n+}\n+\n+impl Writer for FnvState {\n+    fn write(&mut self, bytes: &[u8]) -> io::IoResult<()> {\n+        let FnvState(mut hash) = *self;\n+        for byte in bytes.iter() {\n+            hash = hash * 0x100000001b3;\n+            hash = hash ^ (*byte as u64);\n+        }\n+        *self = FnvState(hash);\n+        Ok(())\n+    }\n+}"}, {"sha": "1029cc7444de3b01d2c880ee1bbd1caf1b15dd18", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -46,6 +46,7 @@ use serialize::json::ToJson;\n use syntax::ast;\n use syntax::attr;\n use syntax::parse::token::InternedString;\n+use rustc::util::nodemap::NodeSet;\n \n use clean;\n use doctree;\n@@ -158,7 +159,7 @@ pub struct Cache {\n     priv parent_stack: ~[ast::NodeId],\n     priv search_index: ~[IndexItem],\n     priv privmod: bool,\n-    priv public_items: HashSet<ast::NodeId>,\n+    priv public_items: NodeSet,\n }\n \n /// Helper struct to render all source code to HTML pages\n@@ -235,7 +236,7 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n     // Crawl the crate to build various caches used for the output\n     let mut cache = local_data::get(::analysiskey, |analysis| {\n         let public_items = analysis.map(|a| a.public_items.clone());\n-        let public_items = public_items.unwrap_or(HashSet::new());\n+        let public_items = public_items.unwrap_or(NodeSet::new());\n         Cache {\n             impls: HashMap::new(),\n             typarams: HashMap::new(),"}, {"sha": "fdd637b1d0f78b4f66e1e1eb138d944f96036bb3", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -13,6 +13,7 @@ use collections::HashSet;\n use std::local_data;\n use std::uint;\n use syntax::ast;\n+use rustc::util::nodemap::NodeSet;\n \n use clean;\n use clean::Item;\n@@ -110,7 +111,7 @@ pub fn strip_private(krate: clean::Crate) -> plugins::PluginResult {\n \n struct Stripper<'a> {\n     retained: &'a mut HashSet<ast::NodeId>,\n-    exported_items: &'a HashSet<ast::NodeId>,\n+    exported_items: &'a NodeSet,\n }\n \n impl<'a> fold::DocFolder for Stripper<'a> {"}, {"sha": "e9ace61eb9570a667850cee3fd47fc2c3ab596b9", "filename": "src/libsyntax/util/nodemap.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibsyntax%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bec7b766fbbc9b56a1608e2573390e3894519840/src%2Flibsyntax%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fnodemap.rs?ref=bec7b766fbbc9b56a1608e2573390e3894519840", "patch": "@@ -0,0 +1,75 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! An efficient hash map for node IDs\n+\n+use collections::hashmap;\n+use collections::{HashMap, HashSet};\n+use std::hash::{Hasher, Hash};\n+use std::iter;\n+use ast;\n+\n+pub type NodeMap<T> = HashMap<ast::NodeId, T, NodeHasher>;\n+pub type DefIdMap<T> = HashMap<ast::DefId, T, NodeHasher>;\n+pub type NodeSet = HashSet<ast::NodeId, NodeHasher>;\n+pub type DefIdSet = HashSet<ast::DefId, NodeHasher>;\n+\n+#[deriving(Clone)]\n+struct NodeHasher;\n+\n+impl Hasher<u64> for NodeHasher {\n+    fn hash<T: Hash<u64>>(&self, t: &T) -> u64 {\n+        let mut last = 0;\n+        t.hash(&mut last);\n+        return last\n+    }\n+}\n+\n+impl Hash<u64> for ast::NodeId {\n+    fn hash(&self, state: &mut u64) {\n+        *state = self.get() as u64;\n+    }\n+}\n+\n+impl Hash<u64> for ast::DefId {\n+    fn hash(&self, state: &mut u64) {\n+        let ast::DefId { krate, node } = *self;\n+        // assert that these two types are each 32 bits\n+        let krate: u32 = krate;\n+        let node: u32 = node;\n+        *state = (krate << 32) as u64 | (node as u64);\n+    }\n+}\n+\n+// Hacks to get good names\n+pub mod NodeMap {\n+    use collections::HashMap;\n+    pub fn new<T>() -> super::NodeMap<T> {\n+        HashMap::with_hasher(super::NodeHasher)\n+    }\n+}\n+pub mod NodeSet {\n+    use collections::HashSet;\n+    pub fn new() -> super::NodeSet {\n+        HashSet::with_hasher(super::NodeHasher)\n+    }\n+}\n+pub mod DefIdMap {\n+    use collections::HashMap;\n+    pub fn new<T>() -> super::DefIdMap<T> {\n+        HashMap::with_hasher(super::NodeHasher)\n+    }\n+}\n+pub mod DefIdSet {\n+    use collections::HashSet;\n+    pub fn new() -> super::DefIdSet {\n+        HashSet::with_hasher(super::NodeHasher)\n+    }\n+}"}]}