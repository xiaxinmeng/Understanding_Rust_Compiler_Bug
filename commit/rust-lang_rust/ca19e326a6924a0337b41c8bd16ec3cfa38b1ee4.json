{"sha": "ca19e326a6924a0337b41c8bd16ec3cfa38b1ee4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhMTllMzI2YTY5MjRhMDMzN2I0MWM4YmQxNmVjM2NmYTM4YjFlZTQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-10T12:47:23Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-10T18:24:42Z"}, "message": "lowering: extract lower_expr_async_closure", "tree": {"sha": "064a711850ef72eb272796a12574a10f49928347", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/064a711850ef72eb272796a12574a10f49928347"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca19e326a6924a0337b41c8bd16ec3cfa38b1ee4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca19e326a6924a0337b41c8bd16ec3cfa38b1ee4", "html_url": "https://github.com/rust-lang/rust/commit/ca19e326a6924a0337b41c8bd16ec3cfa38b1ee4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca19e326a6924a0337b41c8bd16ec3cfa38b1ee4/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "309bf2fcad3852c6675c38e14990f7a39276cb22", "url": "https://api.github.com/repos/rust-lang/rust/commits/309bf2fcad3852c6675c38e14990f7a39276cb22", "html_url": "https://github.com/rust-lang/rust/commit/309bf2fcad3852c6675c38e14990f7a39276cb22"}], "stats": {"total": 116, "additions": 67, "deletions": 49}, "files": [{"sha": "01eca00a913c79ad413be0244f7a164750067616", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 67, "deletions": 49, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/ca19e326a6924a0337b41c8bd16ec3cfa38b1ee4/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca19e326a6924a0337b41c8bd16ec3cfa38b1ee4/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=ca19e326a6924a0337b41c8bd16ec3cfa38b1ee4", "patch": "@@ -268,55 +268,13 @@ impl LoweringContext<'_> {\n                 capture_clause, asyncness, movability, ref decl, ref body, fn_decl_span\n             ) => {\n                 if let IsAsync::Async { closure_id, .. } = asyncness {\n-                    let outer_decl = FnDecl {\n-                        inputs: decl.inputs.clone(),\n-                        output: FunctionRetTy::Default(fn_decl_span),\n-                        c_variadic: false,\n-                    };\n-                    // We need to lower the declaration outside the new scope, because we\n-                    // have to conserve the state of being inside a loop condition for the\n-                    // closure argument types.\n-                    let fn_decl = self.lower_fn_decl(&outer_decl, None, false, None);\n-\n-                    self.with_new_scopes(|this| {\n-                        // FIXME(cramertj): allow `async` non-`move` closures with arguments.\n-                        if capture_clause == CaptureBy::Ref &&\n-                            !decl.inputs.is_empty()\n-                        {\n-                            struct_span_err!(\n-                                this.sess,\n-                                fn_decl_span,\n-                                E0708,\n-                                \"`async` non-`move` closures with arguments \\\n-                                are not currently supported\",\n-                            )\n-                                .help(\"consider using `let` statements to manually capture \\\n-                                       variables by reference before entering an \\\n-                                       `async move` closure\")\n-                                .emit();\n-                        }\n-\n-                        // Transform `async |x: u8| -> X { ... }` into\n-                        // `|x: u8| future_from_generator(|| -> X { ... })`.\n-                        let body_id = this.lower_fn_body(&outer_decl, |this| {\n-                            let async_ret_ty = if let FunctionRetTy::Ty(ty) = &decl.output {\n-                                Some(ty.clone())\n-                            } else { None };\n-                            let async_body = this.make_async_expr(\n-                                capture_clause, closure_id, async_ret_ty, body.span,\n-                                |this| {\n-                                    this.with_new_scopes(|this| this.lower_expr(body))\n-                                });\n-                            this.expr(fn_decl_span, async_body, ThinVec::new())\n-                        });\n-                        hir::ExprKind::Closure(\n-                            this.lower_capture_clause(capture_clause),\n-                            fn_decl,\n-                            body_id,\n-                            fn_decl_span,\n-                            None,\n-                        )\n-                    })\n+                    self.lower_expr_async_closure(\n+                        capture_clause,\n+                        closure_id,\n+                        decl,\n+                        body,\n+                        fn_decl_span,\n+                    )\n                 } else {\n                     // Lower outside new scope to preserve `is_in_loop_condition`.\n                     let fn_decl = self.lower_fn_decl(decl, None, false, None);\n@@ -449,6 +407,66 @@ impl LoweringContext<'_> {\n         }\n     }\n \n+    fn lower_expr_async_closure(\n+        &mut self,\n+        capture_clause: CaptureBy,\n+        closure_id: NodeId,\n+        decl: &FnDecl,\n+        body: &Expr,\n+        fn_decl_span: Span,\n+    ) -> hir::ExprKind {\n+        let outer_decl = FnDecl {\n+            inputs: decl.inputs.clone(),\n+            output: FunctionRetTy::Default(fn_decl_span),\n+            c_variadic: false,\n+        };\n+        // We need to lower the declaration outside the new scope, because we\n+        // have to conserve the state of being inside a loop condition for the\n+        // closure argument types.\n+        let fn_decl = self.lower_fn_decl(&outer_decl, None, false, None);\n+\n+        self.with_new_scopes(|this| {\n+            // FIXME(cramertj): allow `async` non-`move` closures with arguments.\n+            if capture_clause == CaptureBy::Ref && !decl.inputs.is_empty() {\n+                struct_span_err!(\n+                    this.sess,\n+                    fn_decl_span,\n+                    E0708,\n+                    \"`async` non-`move` closures with arguments are not currently supported\",\n+                )\n+                .help(\n+                    \"consider using `let` statements to manually capture \\\n+                    variables by reference before entering an `async move` closure\"\n+                )\n+                .emit();\n+            }\n+\n+            // Transform `async |x: u8| -> X { ... }` into\n+            // `|x: u8| future_from_generator(|| -> X { ... })`.\n+            let body_id = this.lower_fn_body(&outer_decl, |this| {\n+                let async_ret_ty = if let FunctionRetTy::Ty(ty) = &decl.output {\n+                    Some(ty.clone())\n+                } else {\n+                    None\n+                };\n+                let async_body = this.make_async_expr(\n+                    capture_clause, closure_id, async_ret_ty, body.span,\n+                    |this| {\n+                        this.with_new_scopes(|this| this.lower_expr(body))\n+                    }\n+                );\n+                this.expr(fn_decl_span, async_body, ThinVec::new())\n+            });\n+            hir::ExprKind::Closure(\n+                this.lower_capture_clause(capture_clause),\n+                fn_decl,\n+                body_id,\n+                fn_decl_span,\n+                None,\n+            )\n+        })\n+    }\n+\n     /// Desugar `<start>..=<end>` into `std::ops::RangeInclusive::new(<start>, <end>)`.\n     fn lower_expr_range_closed(&mut self, span: Span, e1: &Expr, e2: &Expr) -> hir::ExprKind {\n         let id = self.next_id();"}]}