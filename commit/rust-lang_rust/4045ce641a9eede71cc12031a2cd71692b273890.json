{"sha": "4045ce641a9eede71cc12031a2cd71692b273890", "node_id": "C_kwDOAAsO6NoAKDQwNDVjZTY0MWE5ZWVkZTcxY2MxMjAzMWEyY2Q3MTY5MmIyNzM4OTA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-05T06:44:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-05T06:44:49Z"}, "message": "Auto merge of #98910 - Dylan-DPC:rollup-9x82wdg, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #97300 (Implement `FusedIterator` for `std::net::[Into]Incoming`)\n - #98761 (more `need_type_info` improvements)\n - #98811 (Interpret: AllocRange Debug impl, and use it more consistently)\n - #98847 (fix interpreter validity check on Box)\n - #98854 (clean up the borrowing in rustc_hir_pretty)\n - #98873 (Suggest `#[derive(Default)]` to enums with `#[default]`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "221b79d26ba77ab7c326ed5adde09d31de509ed4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/221b79d26ba77ab7c326ed5adde09d31de509ed4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4045ce641a9eede71cc12031a2cd71692b273890", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4045ce641a9eede71cc12031a2cd71692b273890", "html_url": "https://github.com/rust-lang/rust/commit/4045ce641a9eede71cc12031a2cd71692b273890", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4045ce641a9eede71cc12031a2cd71692b273890/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "880646ca9c6dc21e04efe2f1940369a45b71ff2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/880646ca9c6dc21e04efe2f1940369a45b71ff2d", "html_url": "https://github.com/rust-lang/rust/commit/880646ca9c6dc21e04efe2f1940369a45b71ff2d"}, {"sha": "9a2274cf81463280aa84d321054662d540257395", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a2274cf81463280aa84d321054662d540257395", "html_url": "https://github.com/rust-lang/rust/commit/9a2274cf81463280aa84d321054662d540257395"}], "stats": {"total": 1020, "additions": 574, "deletions": 446}, "files": [{"sha": "509fe576893b7637baceceb7a190d3374339b3cf", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 17, "deletions": 31, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -276,7 +276,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx> {\n         let (alloc_id, offset, tag) = self.ptr_get_alloc_id(ptr)?;\n-        trace!(\"deallocating: {}\", alloc_id);\n+        trace!(\"deallocating: {alloc_id:?}\");\n \n         if offset.bytes() != 0 {\n             throw_ub_format!(\n@@ -289,10 +289,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // Deallocating global memory -- always an error\n             return Err(match self.tcx.get_global_alloc(alloc_id) {\n                 Some(GlobalAlloc::Function(..)) => {\n-                    err_ub_format!(\"deallocating {}, which is a function\", alloc_id)\n+                    err_ub_format!(\"deallocating {alloc_id:?}, which is a function\")\n                 }\n                 Some(GlobalAlloc::Static(..) | GlobalAlloc::Memory(..)) => {\n-                    err_ub_format!(\"deallocating {}, which is static memory\", alloc_id)\n+                    err_ub_format!(\"deallocating {alloc_id:?}, which is static memory\")\n                 }\n                 None => err_ub!(PointerUseAfterFree(alloc_id)),\n             }\n@@ -302,21 +302,17 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         debug!(?alloc);\n \n         if alloc.mutability == Mutability::Not {\n-            throw_ub_format!(\"deallocating immutable allocation {}\", alloc_id);\n+            throw_ub_format!(\"deallocating immutable allocation {alloc_id:?}\");\n         }\n         if alloc_kind != kind {\n             throw_ub_format!(\n-                \"deallocating {}, which is {} memory, using {} deallocation operation\",\n-                alloc_id,\n-                alloc_kind,\n-                kind\n+                \"deallocating {alloc_id:?}, which is {alloc_kind} memory, using {kind} deallocation operation\"\n             );\n         }\n         if let Some((size, align)) = old_size_and_align {\n             if size != alloc.size() || align != alloc.align {\n                 throw_ub_format!(\n-                    \"incorrect layout on deallocation: {} has size {} and alignment {}, but gave size {} and alignment {}\",\n-                    alloc_id,\n+                    \"incorrect layout on deallocation: {alloc_id:?} has size {} and alignment {}, but gave size {} and alignment {}\",\n                     alloc.size().bytes(),\n                     alloc.align.bytes(),\n                     size.bytes(),\n@@ -815,7 +811,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n                 continue;\n             }\n \n-            write!(fmt, \"{}\", id)?;\n+            write!(fmt, \"{id:?}\")?;\n             match self.ecx.memory.alloc_map.get(id) {\n                 Some(&(kind, ref alloc)) => {\n                     // normal alloc\n@@ -859,25 +855,21 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n \n /// Reading and writing.\n impl<'tcx, 'a, Tag: Provenance, Extra> AllocRefMut<'a, 'tcx, Tag, Extra> {\n+    /// `range` is relative to this allocation reference, not the base of the allocation.\n     pub fn write_scalar(\n         &mut self,\n         range: AllocRange,\n         val: ScalarMaybeUninit<Tag>,\n     ) -> InterpResult<'tcx> {\n         let range = self.range.subrange(range);\n-        debug!(\n-            \"write_scalar in {} at {:#x}, size {}: {:?}\",\n-            self.alloc_id,\n-            range.start.bytes(),\n-            range.size.bytes(),\n-            val\n-        );\n+        debug!(\"write_scalar at {:?}{range:?}: {val:?}\", self.alloc_id);\n         Ok(self\n             .alloc\n             .write_scalar(&self.tcx, range, val)\n             .map_err(|e| e.to_interp_error(self.alloc_id))?)\n     }\n \n+    /// `offset` is relative to this allocation reference, not the base of the allocation.\n     pub fn write_ptr_sized(\n         &mut self,\n         offset: Size,\n@@ -896,6 +888,7 @@ impl<'tcx, 'a, Tag: Provenance, Extra> AllocRefMut<'a, 'tcx, Tag, Extra> {\n }\n \n impl<'tcx, 'a, Tag: Provenance, Extra> AllocRef<'a, 'tcx, Tag, Extra> {\n+    /// `range` is relative to this allocation reference, not the base of the allocation.\n     pub fn read_scalar(\n         &self,\n         range: AllocRange,\n@@ -906,31 +899,24 @@ impl<'tcx, 'a, Tag: Provenance, Extra> AllocRef<'a, 'tcx, Tag, Extra> {\n             .alloc\n             .read_scalar(&self.tcx, range, read_provenance)\n             .map_err(|e| e.to_interp_error(self.alloc_id))?;\n-        debug!(\n-            \"read_scalar in {} at {:#x}, size {}: {:?}\",\n-            self.alloc_id,\n-            range.start.bytes(),\n-            range.size.bytes(),\n-            res\n-        );\n+        debug!(\"read_scalar at {:?}{range:?}: {res:?}\", self.alloc_id);\n         Ok(res)\n     }\n \n-    pub fn read_integer(\n-        &self,\n-        offset: Size,\n-        size: Size,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-        self.read_scalar(alloc_range(offset, size), /*read_provenance*/ false)\n+    /// `range` is relative to this allocation reference, not the base of the allocation.\n+    pub fn read_integer(&self, range: AllocRange) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+        self.read_scalar(range, /*read_provenance*/ false)\n     }\n \n+    /// `offset` is relative to this allocation reference, not the base of the allocation.\n     pub fn read_pointer(&self, offset: Size) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n         self.read_scalar(\n             alloc_range(offset, self.tcx.data_layout().pointer_size),\n             /*read_provenance*/ true,\n         )\n     }\n \n+    /// `range` is relative to this allocation reference, not the base of the allocation.\n     pub fn check_bytes(\n         &self,\n         range: AllocRange,"}, {"sha": "22c23df7b1ab34185c1a5ba01604e76faad1f180", "filename": "compiler/rustc_const_eval/src/interpret/traits.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -1,6 +1,6 @@\n use std::convert::TryFrom;\n \n-use rustc_middle::mir::interpret::{InterpResult, Pointer, PointerArithmetic};\n+use rustc_middle::mir::interpret::{alloc_range, InterpResult, Pointer, PointerArithmetic};\n use rustc_middle::ty::{\n     self, Ty, TyCtxt, COMMON_VTABLE_ENTRIES_ALIGN, COMMON_VTABLE_ENTRIES_DROPINPLACE,\n     COMMON_VTABLE_ENTRIES_SIZE,\n@@ -102,18 +102,18 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             )?\n             .expect(\"cannot be a ZST\");\n         let size = vtable\n-            .read_integer(\n+            .read_integer(alloc_range(\n                 pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES_SIZE).unwrap(),\n                 pointer_size,\n-            )?\n+            ))?\n             .check_init()?;\n         let size = size.to_machine_usize(self)?;\n         let size = Size::from_bytes(size);\n         let align = vtable\n-            .read_integer(\n+            .read_integer(alloc_range(\n                 pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES_ALIGN).unwrap(),\n                 pointer_size,\n-            )?\n+            ))?\n             .check_init()?;\n         let align = align.to_machine_usize(self)?;\n         let align = Align::from_bytes(align).map_err(|e| err_ub!(InvalidVtableAlignment(e)))?;"}, {"sha": "0bf78446e37fa0ff27573433cc9bac121a27337b", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -593,16 +593,6 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 self.check_safe_pointer(value, \"reference\")?;\n                 Ok(true)\n             }\n-            ty::Adt(def, ..) if def.is_box() => {\n-                let unique = self.ecx.operand_field(value, 0)?;\n-                let nonnull = self.ecx.operand_field(&unique, 0)?;\n-                let ptr = self.ecx.operand_field(&nonnull, 0)?;\n-                self.check_safe_pointer(&ptr, \"box\")?;\n-\n-                // Check other fields of Box\n-                self.walk_value(value)?;\n-                Ok(true)\n-            }\n             ty::FnPtr(_sig) => {\n                 let value = try_validation!(\n                     self.ecx.read_scalar(value).and_then(|v| v.check_init()),\n@@ -813,6 +803,12 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         Ok(())\n     }\n \n+    #[inline]\n+    fn visit_box(&mut self, op: &OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n+        self.check_safe_pointer(op, \"box\")?;\n+        Ok(())\n+    }\n+\n     #[inline]\n     fn visit_value(&mut self, op: &OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n         trace!(\"visit_value: {:?}, {:?}\", *op, op.layout);\n@@ -821,8 +817,6 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         if self.try_visit_primitive(op)? {\n             return Ok(());\n         }\n-        // Sanity check: `builtin_deref` does not know any pointers that are not primitive.\n-        assert!(op.layout.ty.builtin_deref(true).is_none());\n \n         // Special check preventing `UnsafeCell` in the inner part of constants\n         if let Some(def) = op.layout.ty.ty_adt_def() {"}, {"sha": "ded4c6a557a402e77849078c053e1819502ebab3", "filename": "compiler/rustc_const_eval/src/interpret/visitor.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -151,6 +151,14 @@ macro_rules! make_value_visitor {\n             {\n                 Ok(())\n             }\n+            /// Visits the given value as the pointer of a `Box`. There is nothing to recurse into.\n+            /// The type of `v` will be a raw pointer, but this is a field of `Box<T>` and the\n+            /// pointee type is the actual `T`.\n+            #[inline(always)]\n+            fn visit_box(&mut self, _v: &Self::V) -> InterpResult<'tcx>\n+            {\n+                Ok(())\n+            }\n             /// Visits this value as an aggregate, you are getting an iterator yielding\n             /// all the fields (still in an `InterpResult`, you have to do error handling yourself).\n             /// Recurses into the fields.\n@@ -221,6 +229,47 @@ macro_rules! make_value_visitor {\n                     // Slices do not need special handling here: they have `Array` field\n                     // placement with length 0, so we enter the `Array` case below which\n                     // indirectly uses the metadata to determine the actual length.\n+\n+                    // However, `Box`... let's talk about `Box`.\n+                    ty::Adt(def, ..) if def.is_box() => {\n+                        // `Box` is a hybrid primitive-library-defined type that one the one hand is\n+                        // a dereferenceable pointer, on the other hand has *basically arbitrary\n+                        // user-defined layout* since the user controls the 'allocator' field. So it\n+                        // cannot be treated like a normal pointer, since it does not fit into an\n+                        // `Immediate`. Yeah, it is quite terrible. But many visitors want to do\n+                        // something with \"all boxed pointers\", so we handle this mess for them.\n+                        //\n+                        // When we hit a `Box`, we do not do the usual `visit_aggregate`; instead,\n+                        // we (a) call `visit_box` on the pointer value, and (b) recurse on the\n+                        // allocator field. We also assert tons of things to ensure we do not miss\n+                        // any other fields.\n+\n+                        // `Box` has two fields: the pointer we care about, and the allocator.\n+                        assert_eq!(v.layout().fields.count(), 2, \"`Box` must have exactly 2 fields\");\n+                        let (unique_ptr, alloc) =\n+                            (v.project_field(self.ecx(), 0)?, v.project_field(self.ecx(), 1)?);\n+                        // Unfortunately there is some type junk in the way here: `unique_ptr` is a `Unique`...\n+                        // (which means another 2 fields, the second of which is a `PhantomData`)\n+                        assert_eq!(unique_ptr.layout().fields.count(), 2);\n+                        let (nonnull_ptr, phantom) = (\n+                            unique_ptr.project_field(self.ecx(), 0)?,\n+                            unique_ptr.project_field(self.ecx(), 1)?,\n+                        );\n+                        assert!(\n+                            phantom.layout().ty.ty_adt_def().is_some_and(|adt| adt.is_phantom_data()),\n+                            \"2nd field of `Unique` should be PhantomData but is {:?}\",\n+                            phantom.layout().ty,\n+                        );\n+                        // ... that contains a `NonNull`... (gladly, only a single field here)\n+                        assert_eq!(nonnull_ptr.layout().fields.count(), 1);\n+                        let raw_ptr = nonnull_ptr.project_field(self.ecx(), 0)?; // the actual raw ptr\n+                        // ... whose only field finally is a raw ptr we can dereference.\n+                        self.visit_box(&raw_ptr)?;\n+\n+                        // The second `Box` field is the allocator, which we recursively check for validity\n+                        // like in regular structs.\n+                        self.visit_field(v, 1, &alloc)?;\n+                    }\n                     _ => {},\n                 };\n "}, {"sha": "2d42ae236ad9d99344b5f4a55ff7c0c85699f992", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -21,6 +21,7 @@ Rust MIR: a lowered representation of Rust.\n #![feature(trusted_step)]\n #![feature(try_blocks)]\n #![feature(yeet_expr)]\n+#![feature(is_some_with)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n "}, {"sha": "50acb0270b0bee7fe6199c2f2feff4d928710d6c", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 264, "deletions": 281, "changes": 545, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -59,7 +59,7 @@ impl PpAnn for &dyn rustc_hir::intravisit::Map<'_> {\n             Nested::ImplItem(id) => state.print_impl_item(self.impl_item(id)),\n             Nested::ForeignItem(id) => state.print_foreign_item(self.foreign_item(id)),\n             Nested::Body(id) => state.print_expr(&self.body(id).value),\n-            Nested::BodyParamPat(id, i) => state.print_pat(&self.body(id).params[i].pat),\n+            Nested::BodyParamPat(id, i) => state.print_pat(self.body(id).params[i].pat),\n         }\n     }\n }\n@@ -74,37 +74,37 @@ pub struct State<'a> {\n impl<'a> State<'a> {\n     pub fn print_node(&mut self, node: Node<'_>) {\n         match node {\n-            Node::Param(a) => self.print_param(&a),\n-            Node::Item(a) => self.print_item(&a),\n-            Node::ForeignItem(a) => self.print_foreign_item(&a),\n+            Node::Param(a) => self.print_param(a),\n+            Node::Item(a) => self.print_item(a),\n+            Node::ForeignItem(a) => self.print_foreign_item(a),\n             Node::TraitItem(a) => self.print_trait_item(a),\n             Node::ImplItem(a) => self.print_impl_item(a),\n-            Node::Variant(a) => self.print_variant(&a),\n-            Node::AnonConst(a) => self.print_anon_const(&a),\n-            Node::Expr(a) => self.print_expr(&a),\n-            Node::Stmt(a) => self.print_stmt(&a),\n-            Node::PathSegment(a) => self.print_path_segment(&a),\n-            Node::Ty(a) => self.print_type(&a),\n-            Node::TypeBinding(a) => self.print_type_binding(&a),\n-            Node::TraitRef(a) => self.print_trait_ref(&a),\n-            Node::Pat(a) => self.print_pat(&a),\n-            Node::Arm(a) => self.print_arm(&a),\n+            Node::Variant(a) => self.print_variant(a),\n+            Node::AnonConst(a) => self.print_anon_const(a),\n+            Node::Expr(a) => self.print_expr(a),\n+            Node::Stmt(a) => self.print_stmt(a),\n+            Node::PathSegment(a) => self.print_path_segment(a),\n+            Node::Ty(a) => self.print_type(a),\n+            Node::TypeBinding(a) => self.print_type_binding(a),\n+            Node::TraitRef(a) => self.print_trait_ref(a),\n+            Node::Pat(a) => self.print_pat(a),\n+            Node::Arm(a) => self.print_arm(a),\n             Node::Infer(_) => self.word(\"_\"),\n             Node::Block(a) => {\n                 // Containing cbox, will be closed by print-block at `}`.\n                 self.cbox(INDENT_UNIT);\n                 // Head-ibox, will be closed by print-block after `{`.\n                 self.ibox(0);\n-                self.print_block(&a)\n+                self.print_block(a);\n             }\n-            Node::Lifetime(a) => self.print_lifetime(&a),\n+            Node::Lifetime(a) => self.print_lifetime(a),\n             Node::GenericParam(_) => panic!(\"cannot print Node::GenericParam\"),\n             Node::Field(_) => panic!(\"cannot print Node::Field\"),\n             // These cases do not carry enough information in the\n             // `hir_map` to reconstruct their full structure for pretty\n             // printing.\n             Node::Ctor(..) => panic!(\"cannot print isolated Ctor\"),\n-            Node::Local(a) => self.print_local_decl(&a),\n+            Node::Local(a) => self.print_local_decl(a),\n             Node::Crate(..) => panic!(\"cannot print Crate\"),\n         }\n     }\n@@ -266,7 +266,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn commasep_exprs(&mut self, b: Breaks, exprs: &[hir::Expr<'_>]) {\n-        self.commasep_cmnt(b, exprs, |s, e| s.print_expr(&e), |e| e.span)\n+        self.commasep_cmnt(b, exprs, |s, e| s.print_expr(e), |e| e.span);\n     }\n \n     pub fn print_mod(&mut self, _mod: &hir::Mod<'_>, attrs: &[ast::Attribute]) {\n@@ -287,9 +287,9 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(ty.span.lo());\n         self.ibox(0);\n         match ty.kind {\n-            hir::TyKind::Slice(ref ty) => {\n+            hir::TyKind::Slice(ty) => {\n                 self.word(\"[\");\n-                self.print_type(&ty);\n+                self.print_type(ty);\n                 self.word(\"]\");\n             }\n             hir::TyKind::Ptr(ref mt) => {\n@@ -304,23 +304,16 @@ impl<'a> State<'a> {\n             hir::TyKind::Never => {\n                 self.word(\"!\");\n             }\n-            hir::TyKind::Tup(ref elts) => {\n+            hir::TyKind::Tup(elts) => {\n                 self.popen();\n-                self.commasep(Inconsistent, &elts, |s, ty| s.print_type(&ty));\n+                self.commasep(Inconsistent, elts, |s, ty| s.print_type(ty));\n                 if elts.len() == 1 {\n                     self.word(\",\");\n                 }\n                 self.pclose();\n             }\n-            hir::TyKind::BareFn(ref f) => {\n-                self.print_ty_fn(\n-                    f.abi,\n-                    f.unsafety,\n-                    &f.decl,\n-                    None,\n-                    &f.generic_params,\n-                    f.param_names,\n-                );\n+            hir::TyKind::BareFn(f) => {\n+                self.print_ty_fn(f.abi, f.unsafety, f.decl, None, f.generic_params, f.param_names);\n             }\n             hir::TyKind::OpaqueDef(..) => self.word(\"/*impl Trait*/\"),\n             hir::TyKind::Path(ref qpath) => self.print_qpath(qpath, false),\n@@ -344,9 +337,9 @@ impl<'a> State<'a> {\n                     self.print_lifetime(lifetime);\n                 }\n             }\n-            hir::TyKind::Array(ref ty, ref length) => {\n+            hir::TyKind::Array(ty, ref length) => {\n                 self.word(\"[\");\n-                self.print_type(&ty);\n+                self.print_type(ty);\n                 self.word(\"; \");\n                 self.print_array_length(length);\n                 self.word(\"]\");\n@@ -373,7 +366,7 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(item.span.lo());\n         self.print_outer_attributes(self.attrs(item.hir_id()));\n         match item.kind {\n-            hir::ForeignItemKind::Fn(ref decl, ref arg_names, ref generics) => {\n+            hir::ForeignItemKind::Fn(decl, arg_names, generics) => {\n                 self.head(\"\");\n                 self.print_fn(\n                     decl,\n@@ -392,14 +385,14 @@ impl<'a> State<'a> {\n                 self.word(\";\");\n                 self.end() // end the outer fn box\n             }\n-            hir::ForeignItemKind::Static(ref t, m) => {\n+            hir::ForeignItemKind::Static(t, m) => {\n                 self.head(\"static\");\n                 if m == hir::Mutability::Mut {\n                     self.word_space(\"mut\");\n                 }\n                 self.print_ident(item.ident);\n                 self.word_space(\":\");\n-                self.print_type(&t);\n+                self.print_type(t);\n                 self.word(\";\");\n                 self.end(); // end the head-ibox\n                 self.end() // end the outer cbox\n@@ -442,7 +435,7 @@ impl<'a> State<'a> {\n     ) {\n         self.word_space(\"type\");\n         self.print_ident(ident);\n-        self.print_generic_params(&generics.params);\n+        self.print_generic_params(generics.params);\n         if let Some(bounds) = bounds {\n             self.print_bounds(\":\", bounds);\n         }\n@@ -463,7 +456,7 @@ impl<'a> State<'a> {\n     ) {\n         self.head(\"type\");\n         self.print_ident(item.ident);\n-        self.print_generic_params(&generics.params);\n+        self.print_generic_params(generics.params);\n         self.end(); // end the inner ibox\n \n         self.print_where_clause(generics);\n@@ -494,7 +487,7 @@ impl<'a> State<'a> {\n                 self.end(); // end inner head-block\n                 self.end(); // end outer head-block\n             }\n-            hir::ItemKind::Use(ref path, kind) => {\n+            hir::ItemKind::Use(path, kind) => {\n                 self.head(\"use\");\n                 self.print_path(path, false);\n \n@@ -513,14 +506,14 @@ impl<'a> State<'a> {\n                 self.end(); // end inner head-block\n                 self.end(); // end outer head-block\n             }\n-            hir::ItemKind::Static(ref ty, m, expr) => {\n+            hir::ItemKind::Static(ty, m, expr) => {\n                 self.head(\"static\");\n                 if m == hir::Mutability::Mut {\n                     self.word_space(\"mut\");\n                 }\n                 self.print_ident(item.ident);\n                 self.word_space(\":\");\n-                self.print_type(&ty);\n+                self.print_type(ty);\n                 self.space();\n                 self.end(); // end the head-ibox\n \n@@ -529,11 +522,11 @@ impl<'a> State<'a> {\n                 self.word(\";\");\n                 self.end(); // end the outer cbox\n             }\n-            hir::ItemKind::Const(ref ty, expr) => {\n+            hir::ItemKind::Const(ty, expr) => {\n                 self.head(\"const\");\n                 self.print_ident(item.ident);\n                 self.word_space(\":\");\n-                self.print_type(&ty);\n+                self.print_type(ty);\n                 self.space();\n                 self.end(); // end the head-ibox\n \n@@ -542,10 +535,10 @@ impl<'a> State<'a> {\n                 self.word(\";\");\n                 self.end(); // end the outer cbox\n             }\n-            hir::ItemKind::Fn(ref sig, ref param_names, body) => {\n+            hir::ItemKind::Fn(ref sig, param_names, body) => {\n                 self.head(\"\");\n                 self.print_fn(\n-                    &sig.decl,\n+                    sig.decl,\n                     sig.header,\n                     Some(item.ident.name),\n                     param_names,\n@@ -578,22 +571,22 @@ impl<'a> State<'a> {\n                 }\n                 self.bclose(item.span);\n             }\n-            hir::ItemKind::GlobalAsm(ref asm) => {\n+            hir::ItemKind::GlobalAsm(asm) => {\n                 self.head(\"global_asm!\");\n                 self.print_inline_asm(asm);\n                 self.end()\n             }\n-            hir::ItemKind::TyAlias(ref ty, ref generics) => {\n-                self.print_item_type(item, &generics, |state| {\n+            hir::ItemKind::TyAlias(ty, generics) => {\n+                self.print_item_type(item, generics, |state| {\n                     state.word_space(\"=\");\n-                    state.print_type(&ty);\n+                    state.print_type(ty);\n                 });\n             }\n             hir::ItemKind::OpaqueTy(ref opaque_ty) => {\n-                self.print_item_type(item, &opaque_ty.generics, |state| {\n+                self.print_item_type(item, opaque_ty.generics, |state| {\n                     let mut real_bounds = Vec::with_capacity(opaque_ty.bounds.len());\n-                    for b in opaque_ty.bounds.iter() {\n-                        if let GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = *b {\n+                    for b in opaque_ty.bounds {\n+                        if let GenericBound::Trait(ptr, hir::TraitBoundModifier::Maybe) = b {\n                             state.space();\n                             state.word_space(\"for ?\");\n                             state.print_trait_ref(&ptr.trait_ref);\n@@ -604,73 +597,73 @@ impl<'a> State<'a> {\n                     state.print_bounds(\"= impl\", real_bounds);\n                 });\n             }\n-            hir::ItemKind::Enum(ref enum_definition, ref params) => {\n+            hir::ItemKind::Enum(ref enum_definition, params) => {\n                 self.print_enum_def(enum_definition, params, item.ident.name, item.span);\n             }\n-            hir::ItemKind::Struct(ref struct_def, ref generics) => {\n+            hir::ItemKind::Struct(ref struct_def, generics) => {\n                 self.head(\"struct\");\n                 self.print_struct(struct_def, generics, item.ident.name, item.span, true);\n             }\n-            hir::ItemKind::Union(ref struct_def, ref generics) => {\n+            hir::ItemKind::Union(ref struct_def, generics) => {\n                 self.head(\"union\");\n                 self.print_struct(struct_def, generics, item.ident.name, item.span, true);\n             }\n-            hir::ItemKind::Impl(hir::Impl {\n+            hir::ItemKind::Impl(&hir::Impl {\n                 unsafety,\n                 polarity,\n                 defaultness,\n                 constness,\n                 defaultness_span: _,\n-                ref generics,\n+                generics,\n                 ref of_trait,\n-                ref self_ty,\n+                self_ty,\n                 items,\n             }) => {\n                 self.head(\"\");\n-                self.print_defaultness(*defaultness);\n-                self.print_unsafety(*unsafety);\n+                self.print_defaultness(defaultness);\n+                self.print_unsafety(unsafety);\n                 self.word_nbsp(\"impl\");\n \n                 if !generics.params.is_empty() {\n-                    self.print_generic_params(&generics.params);\n+                    self.print_generic_params(generics.params);\n                     self.space();\n                 }\n \n-                if *constness == hir::Constness::Const {\n+                if constness == hir::Constness::Const {\n                     self.word_nbsp(\"const\");\n                 }\n \n                 if let hir::ImplPolarity::Negative(_) = polarity {\n                     self.word(\"!\");\n                 }\n \n-                if let Some(ref t) = of_trait {\n+                if let Some(t) = of_trait {\n                     self.print_trait_ref(t);\n                     self.space();\n                     self.word_space(\"for\");\n                 }\n \n-                self.print_type(&self_ty);\n+                self.print_type(self_ty);\n                 self.print_where_clause(generics);\n \n                 self.space();\n                 self.bopen();\n                 self.print_inner_attributes(attrs);\n-                for impl_item in *items {\n+                for impl_item in items {\n                     self.ann.nested(self, Nested::ImplItem(impl_item.id));\n                 }\n                 self.bclose(item.span);\n             }\n-            hir::ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, trait_items) => {\n+            hir::ItemKind::Trait(is_auto, unsafety, generics, bounds, trait_items) => {\n                 self.head(\"\");\n                 self.print_is_auto(is_auto);\n                 self.print_unsafety(unsafety);\n                 self.word_nbsp(\"trait\");\n                 self.print_ident(item.ident);\n-                self.print_generic_params(&generics.params);\n+                self.print_generic_params(generics.params);\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n-                for b in bounds.iter() {\n-                    if let GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = *b {\n+                for b in bounds {\n+                    if let GenericBound::Trait(ptr, hir::TraitBoundModifier::Maybe) = b {\n                         self.space();\n                         self.word_space(\"for ?\");\n                         self.print_trait_ref(&ptr.trait_ref);\n@@ -687,14 +680,14 @@ impl<'a> State<'a> {\n                 }\n                 self.bclose(item.span);\n             }\n-            hir::ItemKind::TraitAlias(ref generics, ref bounds) => {\n+            hir::ItemKind::TraitAlias(generics, bounds) => {\n                 self.head(\"trait\");\n                 self.print_ident(item.ident);\n-                self.print_generic_params(&generics.params);\n+                self.print_generic_params(generics.params);\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 // FIXME(durka) this seems to be some quite outdated syntax\n-                for b in bounds.iter() {\n-                    if let GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = *b {\n+                for b in bounds {\n+                    if let GenericBound::Trait(ptr, hir::TraitBoundModifier::Maybe) = b {\n                         self.space();\n                         self.word_space(\"for ?\");\n                         self.print_trait_ref(&ptr.trait_ref);\n@@ -714,7 +707,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_trait_ref(&mut self, t: &hir::TraitRef<'_>) {\n-        self.print_path(&t.path, false)\n+        self.print_path(t.path, false);\n     }\n \n     fn print_formal_generic_params(&mut self, generic_params: &[hir::GenericParam<'_>]) {\n@@ -726,8 +719,8 @@ impl<'a> State<'a> {\n     }\n \n     fn print_poly_trait_ref(&mut self, t: &hir::PolyTraitRef<'_>) {\n-        self.print_formal_generic_params(&t.bound_generic_params);\n-        self.print_trait_ref(&t.trait_ref)\n+        self.print_formal_generic_params(t.bound_generic_params);\n+        self.print_trait_ref(&t.trait_ref);\n     }\n \n     pub fn print_enum_def(\n@@ -739,10 +732,10 @@ impl<'a> State<'a> {\n     ) {\n         self.head(\"enum\");\n         self.print_name(name);\n-        self.print_generic_params(&generics.params);\n+        self.print_generic_params(generics.params);\n         self.print_where_clause(generics);\n         self.space();\n-        self.print_variants(&enum_definition.variants, span)\n+        self.print_variants(enum_definition.variants, span);\n     }\n \n     pub fn print_variants(&mut self, variants: &[hir::Variant<'_>], span: rustc_span::Span) {\n@@ -776,15 +769,15 @@ impl<'a> State<'a> {\n         print_finalizer: bool,\n     ) {\n         self.print_name(name);\n-        self.print_generic_params(&generics.params);\n+        self.print_generic_params(generics.params);\n         match struct_def {\n             hir::VariantData::Tuple(..) | hir::VariantData::Unit(..) => {\n                 if let hir::VariantData::Tuple(..) = struct_def {\n                     self.popen();\n                     self.commasep(Inconsistent, struct_def.fields(), |s, field| {\n                         s.maybe_print_comment(field.span.lo());\n                         s.print_outer_attributes(s.attrs(field.hir_id));\n-                        s.print_type(&field.ty)\n+                        s.print_type(field.ty);\n                     });\n                     self.pclose();\n                 }\n@@ -807,7 +800,7 @@ impl<'a> State<'a> {\n                     self.print_outer_attributes(self.attrs(field.hir_id));\n                     self.print_ident(field.ident);\n                     self.word_nbsp(\":\");\n-                    self.print_type(&field.ty);\n+                    self.print_type(field.ty);\n                     self.word(\",\");\n                 }\n \n@@ -819,7 +812,7 @@ impl<'a> State<'a> {\n     pub fn print_variant(&mut self, v: &hir::Variant<'_>) {\n         self.head(\"\");\n         let generics = hir::Generics::empty();\n-        self.print_struct(&v.data, &generics, v.ident.name, v.span, false);\n+        self.print_struct(&v.data, generics, v.ident.name, v.span, false);\n         if let Some(ref d) = v.disr_expr {\n             self.space();\n             self.word_space(\"=\");\n@@ -834,7 +827,7 @@ impl<'a> State<'a> {\n         arg_names: &[Ident],\n         body_id: Option<hir::BodyId>,\n     ) {\n-        self.print_fn(&m.decl, m.header, Some(ident.name), generics, arg_names, body_id)\n+        self.print_fn(m.decl, m.header, Some(ident.name), generics, arg_names, body_id);\n     }\n \n     pub fn print_trait_item(&mut self, ti: &hir::TraitItem<'_>) {\n@@ -843,28 +836,23 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(ti.span.lo());\n         self.print_outer_attributes(self.attrs(ti.hir_id()));\n         match ti.kind {\n-            hir::TraitItemKind::Const(ref ty, default) => {\n-                self.print_associated_const(ti.ident, &ty, default);\n+            hir::TraitItemKind::Const(ty, default) => {\n+                self.print_associated_const(ti.ident, ty, default);\n             }\n-            hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(ref arg_names)) => {\n-                self.print_method_sig(ti.ident, sig, &ti.generics, arg_names, None);\n+            hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(arg_names)) => {\n+                self.print_method_sig(ti.ident, sig, ti.generics, arg_names, None);\n                 self.word(\";\");\n             }\n             hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n                 self.head(\"\");\n-                self.print_method_sig(ti.ident, sig, &ti.generics, &[], Some(body));\n+                self.print_method_sig(ti.ident, sig, ti.generics, &[], Some(body));\n                 self.nbsp();\n                 self.end(); // need to close a box\n                 self.end(); // need to close a box\n                 self.ann.nested(self, Nested::Body(body));\n             }\n-            hir::TraitItemKind::Type(ref bounds, ref default) => {\n-                self.print_associated_type(\n-                    ti.ident,\n-                    &ti.generics,\n-                    Some(bounds),\n-                    default.as_ref().map(|ty| &**ty),\n-                );\n+            hir::TraitItemKind::Type(bounds, default) => {\n+                self.print_associated_type(ti.ident, ti.generics, Some(bounds), default);\n             }\n         }\n         self.ann.post(self, AnnNode::SubItem(ti.hir_id()))\n@@ -877,19 +865,19 @@ impl<'a> State<'a> {\n         self.print_outer_attributes(self.attrs(ii.hir_id()));\n \n         match ii.kind {\n-            hir::ImplItemKind::Const(ref ty, expr) => {\n-                self.print_associated_const(ii.ident, &ty, Some(expr));\n+            hir::ImplItemKind::Const(ty, expr) => {\n+                self.print_associated_const(ii.ident, ty, Some(expr));\n             }\n             hir::ImplItemKind::Fn(ref sig, body) => {\n                 self.head(\"\");\n-                self.print_method_sig(ii.ident, sig, &ii.generics, &[], Some(body));\n+                self.print_method_sig(ii.ident, sig, ii.generics, &[], Some(body));\n                 self.nbsp();\n                 self.end(); // need to close a box\n                 self.end(); // need to close a box\n                 self.ann.nested(self, Nested::Body(body));\n             }\n-            hir::ImplItemKind::TyAlias(ref ty) => {\n-                self.print_associated_type(ii.ident, &ii.generics, None, Some(ty));\n+            hir::ImplItemKind::TyAlias(ty) => {\n+                self.print_associated_type(ii.ident, ii.generics, None, Some(ty));\n             }\n         }\n         self.ann.post(self, AnnNode::SubItem(ii.hir_id()))\n@@ -904,28 +892,28 @@ impl<'a> State<'a> {\n         decl(self);\n         self.end();\n \n-        if let Some(ref init) = init {\n+        if let Some(init) = init {\n             self.nbsp();\n             self.word_space(\"=\");\n-            self.print_expr(&init);\n+            self.print_expr(init);\n         }\n         self.end()\n     }\n \n     pub fn print_stmt(&mut self, st: &hir::Stmt<'_>) {\n         self.maybe_print_comment(st.span.lo());\n         match st.kind {\n-            hir::StmtKind::Local(ref loc) => {\n-                self.print_local(loc.init, |this| this.print_local_decl(&loc));\n+            hir::StmtKind::Local(loc) => {\n+                self.print_local(loc.init, |this| this.print_local_decl(loc));\n             }\n             hir::StmtKind::Item(item) => self.ann.nested(self, Nested::Item(item)),\n-            hir::StmtKind::Expr(ref expr) => {\n+            hir::StmtKind::Expr(expr) => {\n                 self.space_if_not_bol();\n-                self.print_expr(&expr);\n+                self.print_expr(expr);\n             }\n-            hir::StmtKind::Semi(ref expr) => {\n+            hir::StmtKind::Semi(expr) => {\n                 self.space_if_not_bol();\n-                self.print_expr(&expr);\n+                self.print_expr(expr);\n                 self.word(\";\");\n             }\n         }\n@@ -966,9 +954,9 @@ impl<'a> State<'a> {\n         for st in blk.stmts {\n             self.print_stmt(st);\n         }\n-        if let Some(ref expr) = blk.expr {\n+        if let Some(expr) = blk.expr {\n             self.space_if_not_bol();\n-            self.print_expr(&expr);\n+            self.print_expr(expr);\n             self.maybe_print_trailing_comment(expr.span, Some(blk.span.hi()));\n         }\n         self.bclose_maybe_open(blk.span, close_box);\n@@ -979,21 +967,21 @@ impl<'a> State<'a> {\n         if let Some(els_inner) = els {\n             match els_inner.kind {\n                 // Another `else if` block.\n-                hir::ExprKind::If(ref i, ref then, ref e) => {\n+                hir::ExprKind::If(i, then, e) => {\n                     self.cbox(INDENT_UNIT - 1);\n                     self.ibox(0);\n                     self.word(\" else if \");\n-                    self.print_expr_as_cond(&i);\n+                    self.print_expr_as_cond(i);\n                     self.space();\n-                    self.print_expr(&then);\n-                    self.print_else(e.as_ref().map(|e| &**e))\n+                    self.print_expr(then);\n+                    self.print_else(e);\n                 }\n                 // Final `else` block.\n-                hir::ExprKind::Block(ref b, _) => {\n+                hir::ExprKind::Block(b, _) => {\n                     self.cbox(INDENT_UNIT - 1);\n                     self.ibox(0);\n                     self.word(\" else \");\n-                    self.print_block(&b)\n+                    self.print_block(b);\n                 }\n                 // Constraints would be great here!\n                 _ => {\n@@ -1048,7 +1036,7 @@ impl<'a> State<'a> {\n         if needs_par {\n             self.popen();\n         }\n-        if let hir::ExprKind::DropTemps(ref actual_expr) = expr.kind {\n+        if let hir::ExprKind::DropTemps(actual_expr) = expr.kind {\n             self.print_expr(actual_expr);\n         } else {\n             self.print_expr(expr);\n@@ -1114,7 +1102,7 @@ impl<'a> State<'a> {\n         &mut self,\n         qpath: &hir::QPath<'_>,\n         fields: &[hir::ExprField<'_>],\n-        wth: &Option<&hir::Expr<'_>>,\n+        wth: Option<&hir::Expr<'_>>,\n     ) {\n         self.print_qpath(qpath, true);\n         self.word(\"{\");\n@@ -1127,28 +1115,24 @@ impl<'a> State<'a> {\n                     s.print_ident(field.ident);\n                     s.word_space(\":\");\n                 }\n-                s.print_expr(&field.expr);\n+                s.print_expr(field.expr);\n                 s.end()\n             },\n             |f| f.span,\n         );\n-        match *wth {\n-            Some(ref expr) => {\n-                self.ibox(INDENT_UNIT);\n-                if !fields.is_empty() {\n-                    self.word(\",\");\n-                    self.space();\n-                }\n-                self.word(\"..\");\n-                self.print_expr(&expr);\n-                self.end();\n-            }\n-            _ => {\n-                if !fields.is_empty() {\n-                    self.word(\",\")\n-                }\n+        if let Some(expr) = wth {\n+            self.ibox(INDENT_UNIT);\n+            if !fields.is_empty() {\n+                self.word(\",\");\n+                self.space();\n             }\n+            self.word(\"..\");\n+            self.print_expr(expr);\n+            self.end();\n+        } else if !fields.is_empty() {\n+            self.word(\",\");\n         }\n+\n         self.word(\"}\");\n     }\n \n@@ -1249,27 +1233,26 @@ impl<'a> State<'a> {\n             Options(ast::InlineAsmOptions),\n         }\n \n-        let mut args =\n-            vec![AsmArg::Template(ast::InlineAsmTemplatePiece::to_string(&asm.template))];\n+        let mut args = vec![AsmArg::Template(ast::InlineAsmTemplatePiece::to_string(asm.template))];\n         args.extend(asm.operands.iter().map(|(o, _)| AsmArg::Operand(o)));\n         if !asm.options.is_empty() {\n             args.push(AsmArg::Options(asm.options));\n         }\n \n         self.popen();\n-        self.commasep(Consistent, &args, |s, arg| match arg {\n-            AsmArg::Template(template) => s.print_string(&template, ast::StrStyle::Cooked),\n-            AsmArg::Operand(op) => match op {\n-                hir::InlineAsmOperand::In { reg, expr } => {\n+        self.commasep(Consistent, &args, |s, arg| match *arg {\n+            AsmArg::Template(ref template) => s.print_string(template, ast::StrStyle::Cooked),\n+            AsmArg::Operand(op) => match *op {\n+                hir::InlineAsmOperand::In { reg, ref expr } => {\n                     s.word(\"in\");\n                     s.popen();\n                     s.word(format!(\"{}\", reg));\n                     s.pclose();\n                     s.space();\n                     s.print_expr(expr);\n                 }\n-                hir::InlineAsmOperand::Out { reg, late, expr } => {\n-                    s.word(if *late { \"lateout\" } else { \"out\" });\n+                hir::InlineAsmOperand::Out { reg, late, ref expr } => {\n+                    s.word(if late { \"lateout\" } else { \"out\" });\n                     s.popen();\n                     s.word(format!(\"{}\", reg));\n                     s.pclose();\n@@ -1279,16 +1262,16 @@ impl<'a> State<'a> {\n                         None => s.word(\"_\"),\n                     }\n                 }\n-                hir::InlineAsmOperand::InOut { reg, late, expr } => {\n-                    s.word(if *late { \"inlateout\" } else { \"inout\" });\n+                hir::InlineAsmOperand::InOut { reg, late, ref expr } => {\n+                    s.word(if late { \"inlateout\" } else { \"inout\" });\n                     s.popen();\n                     s.word(format!(\"{}\", reg));\n                     s.pclose();\n                     s.space();\n                     s.print_expr(expr);\n                 }\n-                hir::InlineAsmOperand::SplitInOut { reg, late, in_expr, out_expr } => {\n-                    s.word(if *late { \"inlateout\" } else { \"inout\" });\n+                hir::InlineAsmOperand::SplitInOut { reg, late, ref in_expr, ref out_expr } => {\n+                    s.word(if late { \"inlateout\" } else { \"inout\" });\n                     s.popen();\n                     s.word(format!(\"{}\", reg));\n                     s.pclose();\n@@ -1301,17 +1284,17 @@ impl<'a> State<'a> {\n                         None => s.word(\"_\"),\n                     }\n                 }\n-                hir::InlineAsmOperand::Const { anon_const } => {\n+                hir::InlineAsmOperand::Const { ref anon_const } => {\n                     s.word(\"const\");\n                     s.space();\n                     s.print_anon_const(anon_const);\n                 }\n-                hir::InlineAsmOperand::SymFn { anon_const } => {\n+                hir::InlineAsmOperand::SymFn { ref anon_const } => {\n                     s.word(\"sym_fn\");\n                     s.space();\n                     s.print_anon_const(anon_const);\n                 }\n-                hir::InlineAsmOperand::SymStatic { path, def_id: _ } => {\n+                hir::InlineAsmOperand::SymStatic { ref path, def_id: _ } => {\n                     s.word(\"sym_static\");\n                     s.space();\n                     s.print_qpath(path, true);\n@@ -1363,57 +1346,57 @@ impl<'a> State<'a> {\n         self.ibox(INDENT_UNIT);\n         self.ann.pre(self, AnnNode::Expr(expr));\n         match expr.kind {\n-            hir::ExprKind::Box(ref expr) => {\n+            hir::ExprKind::Box(expr) => {\n                 self.word_space(\"box\");\n                 self.print_expr_maybe_paren(expr, parser::PREC_PREFIX);\n             }\n-            hir::ExprKind::Array(ref exprs) => {\n+            hir::ExprKind::Array(exprs) => {\n                 self.print_expr_vec(exprs);\n             }\n             hir::ExprKind::ConstBlock(ref anon_const) => {\n                 self.print_expr_anon_const(anon_const);\n             }\n-            hir::ExprKind::Repeat(ref element, ref count) => {\n-                self.print_expr_repeat(&element, count);\n+            hir::ExprKind::Repeat(element, ref count) => {\n+                self.print_expr_repeat(element, count);\n             }\n-            hir::ExprKind::Struct(ref qpath, fields, ref wth) => {\n+            hir::ExprKind::Struct(qpath, fields, wth) => {\n                 self.print_expr_struct(qpath, fields, wth);\n             }\n-            hir::ExprKind::Tup(ref exprs) => {\n+            hir::ExprKind::Tup(exprs) => {\n                 self.print_expr_tup(exprs);\n             }\n-            hir::ExprKind::Call(ref func, ref args) => {\n-                self.print_expr_call(&func, args);\n+            hir::ExprKind::Call(func, args) => {\n+                self.print_expr_call(func, args);\n             }\n-            hir::ExprKind::MethodCall(ref segment, ref args, _) => {\n+            hir::ExprKind::MethodCall(segment, args, _) => {\n                 self.print_expr_method_call(segment, args);\n             }\n-            hir::ExprKind::Binary(op, ref lhs, ref rhs) => {\n-                self.print_expr_binary(op, &lhs, &rhs);\n+            hir::ExprKind::Binary(op, lhs, rhs) => {\n+                self.print_expr_binary(op, lhs, rhs);\n             }\n-            hir::ExprKind::Unary(op, ref expr) => {\n-                self.print_expr_unary(op, &expr);\n+            hir::ExprKind::Unary(op, expr) => {\n+                self.print_expr_unary(op, expr);\n             }\n-            hir::ExprKind::AddrOf(k, m, ref expr) => {\n-                self.print_expr_addr_of(k, m, &expr);\n+            hir::ExprKind::AddrOf(k, m, expr) => {\n+                self.print_expr_addr_of(k, m, expr);\n             }\n             hir::ExprKind::Lit(ref lit) => {\n-                self.print_literal(&lit);\n+                self.print_literal(lit);\n             }\n-            hir::ExprKind::Cast(ref expr, ref ty) => {\n+            hir::ExprKind::Cast(expr, ty) => {\n                 let prec = AssocOp::As.precedence() as i8;\n-                self.print_expr_maybe_paren(&expr, prec);\n+                self.print_expr_maybe_paren(expr, prec);\n                 self.space();\n                 self.word_space(\"as\");\n-                self.print_type(&ty);\n+                self.print_type(ty);\n             }\n-            hir::ExprKind::Type(ref expr, ref ty) => {\n+            hir::ExprKind::Type(expr, ty) => {\n                 let prec = AssocOp::Colon.precedence() as i8;\n-                self.print_expr_maybe_paren(&expr, prec);\n+                self.print_expr_maybe_paren(expr, prec);\n                 self.word_space(\":\");\n-                self.print_type(&ty);\n+                self.print_type(ty);\n             }\n-            hir::ExprKind::DropTemps(ref init) => {\n+            hir::ExprKind::DropTemps(init) => {\n                 // Print `{`:\n                 self.cbox(INDENT_UNIT);\n                 self.ibox(0);\n@@ -1431,25 +1414,25 @@ impl<'a> State<'a> {\n                 // Print `}`:\n                 self.bclose_maybe_open(expr.span, true);\n             }\n-            hir::ExprKind::Let(hir::Let { pat, ty, init, .. }) => {\n-                self.print_let(pat, *ty, init);\n+            hir::ExprKind::Let(&hir::Let { pat, ty, init, .. }) => {\n+                self.print_let(pat, ty, init);\n             }\n-            hir::ExprKind::If(ref test, ref blk, ref elseopt) => {\n-                self.print_if(&test, &blk, elseopt.as_ref().map(|e| &**e));\n+            hir::ExprKind::If(test, blk, elseopt) => {\n+                self.print_if(test, blk, elseopt);\n             }\n-            hir::ExprKind::Loop(ref blk, opt_label, _, _) => {\n+            hir::ExprKind::Loop(blk, opt_label, _, _) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");\n                 }\n                 self.head(\"loop\");\n-                self.print_block(&blk);\n+                self.print_block(blk);\n             }\n-            hir::ExprKind::Match(ref expr, arms, _) => {\n+            hir::ExprKind::Match(expr, arms, _) => {\n                 self.cbox(INDENT_UNIT);\n                 self.ibox(INDENT_UNIT);\n                 self.word_nbsp(\"match\");\n-                self.print_expr_as_cond(&expr);\n+                self.print_expr_as_cond(expr);\n                 self.space();\n                 self.bopen();\n                 for arm in arms {\n@@ -1460,15 +1443,15 @@ impl<'a> State<'a> {\n             hir::ExprKind::Closure {\n                 capture_clause,\n                 bound_generic_params,\n-                ref fn_decl,\n+                fn_decl,\n                 body,\n                 fn_decl_span: _,\n                 movability: _,\n             } => {\n                 self.print_formal_generic_params(bound_generic_params);\n                 self.print_capture_clause(capture_clause);\n \n-                self.print_closure_params(&fn_decl, body);\n+                self.print_closure_params(fn_decl, body);\n                 self.space();\n \n                 // This is a bare expression.\n@@ -1480,7 +1463,7 @@ impl<'a> State<'a> {\n                 // empty box to satisfy the close.\n                 self.ibox(0);\n             }\n-            hir::ExprKind::Block(ref blk, opt_label) => {\n+            hir::ExprKind::Block(blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");\n@@ -1489,42 +1472,42 @@ impl<'a> State<'a> {\n                 self.cbox(INDENT_UNIT);\n                 // head-box, will be closed by print-block after `{`\n                 self.ibox(0);\n-                self.print_block(&blk);\n+                self.print_block(blk);\n             }\n-            hir::ExprKind::Assign(ref lhs, ref rhs, _) => {\n+            hir::ExprKind::Assign(lhs, rhs, _) => {\n                 let prec = AssocOp::Assign.precedence() as i8;\n-                self.print_expr_maybe_paren(&lhs, prec + 1);\n+                self.print_expr_maybe_paren(lhs, prec + 1);\n                 self.space();\n                 self.word_space(\"=\");\n-                self.print_expr_maybe_paren(&rhs, prec);\n+                self.print_expr_maybe_paren(rhs, prec);\n             }\n-            hir::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n+            hir::ExprKind::AssignOp(op, lhs, rhs) => {\n                 let prec = AssocOp::Assign.precedence() as i8;\n-                self.print_expr_maybe_paren(&lhs, prec + 1);\n+                self.print_expr_maybe_paren(lhs, prec + 1);\n                 self.space();\n                 self.word(op.node.as_str());\n                 self.word_space(\"=\");\n-                self.print_expr_maybe_paren(&rhs, prec);\n+                self.print_expr_maybe_paren(rhs, prec);\n             }\n-            hir::ExprKind::Field(ref expr, ident) => {\n+            hir::ExprKind::Field(expr, ident) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n                 self.word(\".\");\n                 self.print_ident(ident);\n             }\n-            hir::ExprKind::Index(ref expr, ref index) => {\n-                self.print_expr_maybe_paren(&expr, parser::PREC_POSTFIX);\n+            hir::ExprKind::Index(expr, index) => {\n+                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX);\n                 self.word(\"[\");\n-                self.print_expr(&index);\n+                self.print_expr(index);\n                 self.word(\"]\");\n             }\n             hir::ExprKind::Path(ref qpath) => self.print_qpath(qpath, true),\n-            hir::ExprKind::Break(destination, ref opt_expr) => {\n+            hir::ExprKind::Break(destination, opt_expr) => {\n                 self.word(\"break\");\n                 if let Some(label) = destination.label {\n                     self.space();\n                     self.print_ident(label.ident);\n                 }\n-                if let Some(ref expr) = *opt_expr {\n+                if let Some(expr) = opt_expr {\n                     self.space();\n                     self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n                 }\n@@ -1536,20 +1519,20 @@ impl<'a> State<'a> {\n                     self.print_ident(label.ident);\n                 }\n             }\n-            hir::ExprKind::Ret(ref result) => {\n+            hir::ExprKind::Ret(result) => {\n                 self.word(\"return\");\n-                if let Some(ref expr) = *result {\n+                if let Some(expr) = result {\n                     self.word(\" \");\n-                    self.print_expr_maybe_paren(&expr, parser::PREC_JUMP);\n+                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n                 }\n             }\n-            hir::ExprKind::InlineAsm(ref asm) => {\n+            hir::ExprKind::InlineAsm(asm) => {\n                 self.word(\"asm!\");\n                 self.print_inline_asm(asm);\n             }\n-            hir::ExprKind::Yield(ref expr, _) => {\n+            hir::ExprKind::Yield(expr, _) => {\n                 self.word_space(\"yield\");\n-                self.print_expr_maybe_paren(&expr, parser::PREC_JUMP);\n+                self.print_expr_maybe_paren(expr, parser::PREC_JUMP);\n             }\n             hir::ExprKind::Err => {\n                 self.popen();\n@@ -1562,10 +1545,10 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_local_decl(&mut self, loc: &hir::Local<'_>) {\n-        self.print_pat(&loc.pat);\n-        if let Some(ref ty) = loc.ty {\n+        self.print_pat(loc.pat);\n+        if let Some(ty) = loc.ty {\n             self.word_space(\":\");\n-            self.print_type(&ty);\n+            self.print_type(ty);\n         }\n     }\n \n@@ -1596,8 +1579,8 @@ impl<'a> State<'a> {\n \n     pub fn print_qpath(&mut self, qpath: &hir::QPath<'_>, colons_before_params: bool) {\n         match *qpath {\n-            hir::QPath::Resolved(None, ref path) => self.print_path(path, colons_before_params),\n-            hir::QPath::Resolved(Some(ref qself), ref path) => {\n+            hir::QPath::Resolved(None, path) => self.print_path(path, colons_before_params),\n+            hir::QPath::Resolved(Some(qself), path) => {\n                 self.word(\"<\");\n                 self.print_type(qself);\n                 self.space();\n@@ -1627,11 +1610,11 @@ impl<'a> State<'a> {\n                     colons_before_params,\n                 )\n             }\n-            hir::QPath::TypeRelative(ref qself, ref item_segment) => {\n+            hir::QPath::TypeRelative(qself, item_segment) => {\n                 // If we've got a compound-qualified-path, let's push an additional pair of angle\n                 // brackets, so that we pretty-print `<<A::B>::C>` as `<A::B>::C`, instead of just\n                 // `A::B::C` (since the latter could be ambiguous to the user)\n-                if let hir::TyKind::Path(hir::QPath::Resolved(None, _)) = &qself.kind {\n+                if let hir::TyKind::Path(hir::QPath::Resolved(None, _)) = qself.kind {\n                     self.print_type(qself);\n                 } else {\n                     self.word(\"<\");\n@@ -1663,7 +1646,7 @@ impl<'a> State<'a> {\n     ) {\n         if generic_args.parenthesized {\n             self.word(\"(\");\n-            self.commasep(Inconsistent, generic_args.inputs(), |s, ty| s.print_type(&ty));\n+            self.commasep(Inconsistent, generic_args.inputs(), |s, ty| s.print_type(ty));\n             self.word(\")\");\n \n             self.space_if_not_bol();\n@@ -1694,7 +1677,7 @@ impl<'a> State<'a> {\n                 start_or_comma(self);\n                 self.commasep(\n                     Inconsistent,\n-                    &generic_args.args,\n+                    generic_args.args,\n                     |s, generic_arg| match generic_arg {\n                         GenericArg::Lifetime(lt) if !elide_lifetimes => s.print_lifetime(lt),\n                         GenericArg::Lifetime(_) => {}\n@@ -1712,7 +1695,7 @@ impl<'a> State<'a> {\n                 self.word(\"..\");\n             }\n \n-            for binding in generic_args.bindings.iter() {\n+            for binding in generic_args.bindings {\n                 start_or_comma(self);\n                 self.print_type_binding(binding);\n             }\n@@ -1731,7 +1714,7 @@ impl<'a> State<'a> {\n             hir::TypeBindingKind::Equality { ref term } => {\n                 self.word_space(\"=\");\n                 match term {\n-                    Term::Ty(ref ty) => self.print_type(ty),\n+                    Term::Ty(ty) => self.print_type(ty),\n                     Term::Const(ref c) => self.print_anon_const(c),\n                 }\n             }\n@@ -1748,7 +1731,7 @@ impl<'a> State<'a> {\n         // is that it doesn't matter\n         match pat.kind {\n             PatKind::Wild => self.word(\"_\"),\n-            PatKind::Binding(binding_mode, _, ident, ref sub) => {\n+            PatKind::Binding(binding_mode, _, ident, sub) => {\n                 match binding_mode {\n                     hir::BindingAnnotation::Ref => {\n                         self.word_nbsp(\"ref\");\n@@ -1764,33 +1747,33 @@ impl<'a> State<'a> {\n                     }\n                 }\n                 self.print_ident(ident);\n-                if let Some(ref p) = *sub {\n+                if let Some(p) = sub {\n                     self.word(\"@\");\n-                    self.print_pat(&p);\n+                    self.print_pat(p);\n                 }\n             }\n-            PatKind::TupleStruct(ref qpath, ref elts, ddpos) => {\n+            PatKind::TupleStruct(ref qpath, elts, ddpos) => {\n                 self.print_qpath(qpath, true);\n                 self.popen();\n                 if let Some(ddpos) = ddpos {\n-                    self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(&p));\n+                    self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(p));\n                     if ddpos != 0 {\n                         self.word_space(\",\");\n                     }\n                     self.word(\"..\");\n                     if ddpos != elts.len() {\n                         self.word(\",\");\n-                        self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(&p));\n+                        self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(p));\n                     }\n                 } else {\n-                    self.commasep(Inconsistent, &elts, |s, p| s.print_pat(&p));\n+                    self.commasep(Inconsistent, elts, |s, p| s.print_pat(p));\n                 }\n                 self.pclose();\n             }\n             PatKind::Path(ref qpath) => {\n                 self.print_qpath(qpath, true);\n             }\n-            PatKind::Struct(ref qpath, ref fields, etc) => {\n+            PatKind::Struct(ref qpath, fields, etc) => {\n                 self.print_qpath(qpath, true);\n                 self.nbsp();\n                 self.word(\"{\");\n@@ -1800,14 +1783,14 @@ impl<'a> State<'a> {\n                 }\n                 self.commasep_cmnt(\n                     Consistent,\n-                    &fields,\n+                    fields,\n                     |s, f| {\n                         s.cbox(INDENT_UNIT);\n                         if !f.is_shorthand {\n                             s.print_ident(f.ident);\n                             s.word_nbsp(\":\");\n                         }\n-                        s.print_pat(&f.pat);\n+                        s.print_pat(f.pat);\n                         s.end()\n                     },\n                     |f| f.pat.span,\n@@ -1823,83 +1806,83 @@ impl<'a> State<'a> {\n                 }\n                 self.word(\"}\");\n             }\n-            PatKind::Or(ref pats) => {\n-                self.strsep(\"|\", true, Inconsistent, &pats, |s, p| s.print_pat(&p));\n+            PatKind::Or(pats) => {\n+                self.strsep(\"|\", true, Inconsistent, pats, |s, p| s.print_pat(p));\n             }\n-            PatKind::Tuple(ref elts, ddpos) => {\n+            PatKind::Tuple(elts, ddpos) => {\n                 self.popen();\n                 if let Some(ddpos) = ddpos {\n-                    self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(&p));\n+                    self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(p));\n                     if ddpos != 0 {\n                         self.word_space(\",\");\n                     }\n                     self.word(\"..\");\n                     if ddpos != elts.len() {\n                         self.word(\",\");\n-                        self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(&p));\n+                        self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(p));\n                     }\n                 } else {\n-                    self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(&p));\n+                    self.commasep(Inconsistent, elts, |s, p| s.print_pat(p));\n                     if elts.len() == 1 {\n                         self.word(\",\");\n                     }\n                 }\n                 self.pclose();\n             }\n-            PatKind::Box(ref inner) => {\n+            PatKind::Box(inner) => {\n                 let is_range_inner = matches!(inner.kind, PatKind::Range(..));\n                 self.word(\"box \");\n                 if is_range_inner {\n                     self.popen();\n                 }\n-                self.print_pat(&inner);\n+                self.print_pat(inner);\n                 if is_range_inner {\n                     self.pclose();\n                 }\n             }\n-            PatKind::Ref(ref inner, mutbl) => {\n+            PatKind::Ref(inner, mutbl) => {\n                 let is_range_inner = matches!(inner.kind, PatKind::Range(..));\n                 self.word(\"&\");\n                 self.word(mutbl.prefix_str());\n                 if is_range_inner {\n                     self.popen();\n                 }\n-                self.print_pat(&inner);\n+                self.print_pat(inner);\n                 if is_range_inner {\n                     self.pclose();\n                 }\n             }\n-            PatKind::Lit(ref e) => self.print_expr(&e),\n-            PatKind::Range(ref begin, ref end, ref end_kind) => {\n+            PatKind::Lit(e) => self.print_expr(e),\n+            PatKind::Range(begin, end, end_kind) => {\n                 if let Some(expr) = begin {\n                     self.print_expr(expr);\n                 }\n-                match *end_kind {\n+                match end_kind {\n                     RangeEnd::Included => self.word(\"...\"),\n                     RangeEnd::Excluded => self.word(\"..\"),\n                 }\n                 if let Some(expr) = end {\n                     self.print_expr(expr);\n                 }\n             }\n-            PatKind::Slice(ref before, ref slice, ref after) => {\n+            PatKind::Slice(before, slice, after) => {\n                 self.word(\"[\");\n-                self.commasep(Inconsistent, &before, |s, p| s.print_pat(&p));\n-                if let Some(ref p) = *slice {\n+                self.commasep(Inconsistent, before, |s, p| s.print_pat(p));\n+                if let Some(p) = slice {\n                     if !before.is_empty() {\n                         self.word_space(\",\");\n                     }\n                     if let PatKind::Wild = p.kind {\n                         // Print nothing.\n                     } else {\n-                        self.print_pat(&p);\n+                        self.print_pat(p);\n                     }\n                     self.word(\"..\");\n                     if !after.is_empty() {\n                         self.word_space(\",\");\n                     }\n                 }\n-                self.commasep(Inconsistent, &after, |s, p| s.print_pat(&p));\n+                self.commasep(Inconsistent, after, |s, p| s.print_pat(p));\n                 self.word(\"]\");\n             }\n         }\n@@ -1908,7 +1891,7 @@ impl<'a> State<'a> {\n \n     pub fn print_param(&mut self, arg: &hir::Param<'_>) {\n         self.print_outer_attributes(self.attrs(arg.hir_id));\n-        self.print_pat(&arg.pat);\n+        self.print_pat(arg.pat);\n     }\n \n     pub fn print_arm(&mut self, arm: &hir::Arm<'_>) {\n@@ -1920,32 +1903,32 @@ impl<'a> State<'a> {\n         self.cbox(INDENT_UNIT);\n         self.ann.pre(self, AnnNode::Arm(arm));\n         self.ibox(0);\n-        self.print_outer_attributes(&self.attrs(arm.hir_id));\n-        self.print_pat(&arm.pat);\n+        self.print_outer_attributes(self.attrs(arm.hir_id));\n+        self.print_pat(arm.pat);\n         self.space();\n         if let Some(ref g) = arm.guard {\n-            match g {\n+            match *g {\n                 hir::Guard::If(e) => {\n                     self.word_space(\"if\");\n-                    self.print_expr(&e);\n+                    self.print_expr(e);\n                     self.space();\n                 }\n-                hir::Guard::IfLet(hir::Let { pat, ty, init, .. }) => {\n+                hir::Guard::IfLet(&hir::Let { pat, ty, init, .. }) => {\n                     self.word_nbsp(\"if\");\n-                    self.print_let(pat, *ty, init);\n+                    self.print_let(pat, ty, init);\n                 }\n             }\n         }\n         self.word_space(\"=>\");\n \n         match arm.body.kind {\n-            hir::ExprKind::Block(ref blk, opt_label) => {\n+            hir::ExprKind::Block(blk, opt_label) => {\n                 if let Some(label) = opt_label {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");\n                 }\n                 // the block will close the pattern's ibox\n-                self.print_block_unclosed(&blk);\n+                self.print_block_unclosed(blk);\n \n                 // If it is a user-provided unsafe block, print a comma after it\n                 if let hir::BlockCheckMode::UnsafeBlock(hir::UnsafeSource::UserProvided) = blk.rules\n@@ -1955,7 +1938,7 @@ impl<'a> State<'a> {\n             }\n             _ => {\n                 self.end(); // close the ibox for the pattern\n-                self.print_expr(&arm.body);\n+                self.print_expr(arm.body);\n                 self.word(\",\");\n             }\n         }\n@@ -1978,13 +1961,13 @@ impl<'a> State<'a> {\n             self.nbsp();\n             self.print_name(name);\n         }\n-        self.print_generic_params(&generics.params);\n+        self.print_generic_params(generics.params);\n \n         self.popen();\n         let mut i = 0;\n         // Make sure we aren't supplied *both* `arg_names` and `body_id`.\n         assert!(arg_names.is_empty() || body_id.is_none());\n-        self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n+        self.commasep(Inconsistent, decl.inputs, |s, ty| {\n             s.ibox(INDENT_UNIT);\n             if let Some(arg_name) = arg_names.get(i) {\n                 s.word(arg_name.to_string());\n@@ -2011,7 +1994,7 @@ impl<'a> State<'a> {\n     fn print_closure_params(&mut self, decl: &hir::FnDecl<'_>, body_id: hir::BodyId) {\n         self.word(\"|\");\n         let mut i = 0;\n-        self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n+        self.commasep(Inconsistent, decl.inputs, |s, ty| {\n             s.ibox(INDENT_UNIT);\n \n             s.ann.nested(s, Nested::BodyParamPat(body_id, i));\n@@ -2035,8 +2018,8 @@ impl<'a> State<'a> {\n         self.space_if_not_bol();\n         self.word_space(\"->\");\n         match decl.output {\n-            hir::FnRetTy::Return(ref ty) => {\n-                self.print_type(&ty);\n+            hir::FnRetTy::Return(ty) => {\n+                self.print_type(ty);\n                 self.maybe_print_comment(ty.span.lo());\n             }\n             hir::FnRetTy::DefaultReturn(..) => unreachable!(),\n@@ -2107,20 +2090,20 @@ impl<'a> State<'a> {\n \n         match param.kind {\n             GenericParamKind::Lifetime { .. } => {}\n-            GenericParamKind::Type { ref default, .. } => {\n+            GenericParamKind::Type { default, .. } => {\n                 if let Some(default) = default {\n                     self.space();\n                     self.word_space(\"=\");\n-                    self.print_type(&default)\n+                    self.print_type(default);\n                 }\n             }\n-            GenericParamKind::Const { ref ty, ref default } => {\n+            GenericParamKind::Const { ty, ref default } => {\n                 self.word_space(\":\");\n                 self.print_type(ty);\n-                if let Some(ref default) = default {\n+                if let Some(default) = default {\n                     self.space();\n                     self.word_space(\"=\");\n-                    self.print_anon_const(&default)\n+                    self.print_anon_const(default);\n                 }\n             }\n         }\n@@ -2143,19 +2126,19 @@ impl<'a> State<'a> {\n                 self.word_space(\",\");\n             }\n \n-            match predicate {\n+            match *predicate {\n                 hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n                     bound_generic_params,\n                     bounded_ty,\n                     bounds,\n                     ..\n                 }) => {\n                     self.print_formal_generic_params(bound_generic_params);\n-                    self.print_type(&bounded_ty);\n-                    self.print_bounds(\":\", *bounds);\n+                    self.print_type(bounded_ty);\n+                    self.print_bounds(\":\", bounds);\n                 }\n                 hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n-                    lifetime,\n+                    ref lifetime,\n                     bounds,\n                     ..\n                 }) => {\n@@ -2200,7 +2183,7 @@ impl<'a> State<'a> {\n \n     pub fn print_mt(&mut self, mt: &hir::MutTy<'_>, print_const: bool) {\n         self.print_mutability(mt.mutbl, print_const);\n-        self.print_type(&mt.ty)\n+        self.print_type(mt.ty);\n     }\n \n     pub fn print_fn_output(&mut self, decl: &hir::FnDecl<'_>) {\n@@ -2213,11 +2196,11 @@ impl<'a> State<'a> {\n         self.word_space(\"->\");\n         match decl.output {\n             hir::FnRetTy::DefaultReturn(..) => unreachable!(),\n-            hir::FnRetTy::Return(ref ty) => self.print_type(&ty),\n+            hir::FnRetTy::Return(ty) => self.print_type(ty),\n         }\n         self.end();\n \n-        if let hir::FnRetTy::Return(ref output) = decl.output {\n+        if let hir::FnRetTy::Return(output) = decl.output {\n             self.maybe_print_comment(output.span.lo());\n         }\n     }\n@@ -2243,7 +2226,7 @@ impl<'a> State<'a> {\n                 asyncness: hir::IsAsync::NotAsync,\n             },\n             name,\n-            &generics,\n+            generics,\n             arg_names,\n             None,\n         );\n@@ -2312,7 +2295,7 @@ fn stmt_ends_with_semi(stmt: &hir::StmtKind<'_>) -> bool {\n     match *stmt {\n         hir::StmtKind::Local(_) => true,\n         hir::StmtKind::Item(_) => false,\n-        hir::StmtKind::Expr(ref e) => expr_requires_semi_to_be_stmt(&e),\n+        hir::StmtKind::Expr(e) => expr_requires_semi_to_be_stmt(e),\n         hir::StmtKind::Semi(..) => false,\n     }\n }\n@@ -2351,22 +2334,22 @@ fn contains_exterior_struct_lit(value: &hir::Expr<'_>) -> bool {\n     match value.kind {\n         hir::ExprKind::Struct(..) => true,\n \n-        hir::ExprKind::Assign(ref lhs, ref rhs, _)\n-        | hir::ExprKind::AssignOp(_, ref lhs, ref rhs)\n-        | hir::ExprKind::Binary(_, ref lhs, ref rhs) => {\n+        hir::ExprKind::Assign(lhs, rhs, _)\n+        | hir::ExprKind::AssignOp(_, lhs, rhs)\n+        | hir::ExprKind::Binary(_, lhs, rhs) => {\n             // `X { y: 1 } + X { y: 2 }`\n-            contains_exterior_struct_lit(&lhs) || contains_exterior_struct_lit(&rhs)\n+            contains_exterior_struct_lit(lhs) || contains_exterior_struct_lit(rhs)\n         }\n-        hir::ExprKind::Unary(_, ref x)\n-        | hir::ExprKind::Cast(ref x, _)\n-        | hir::ExprKind::Type(ref x, _)\n-        | hir::ExprKind::Field(ref x, _)\n-        | hir::ExprKind::Index(ref x, _) => {\n+        hir::ExprKind::Unary(_, x)\n+        | hir::ExprKind::Cast(x, _)\n+        | hir::ExprKind::Type(x, _)\n+        | hir::ExprKind::Field(x, _)\n+        | hir::ExprKind::Index(x, _) => {\n             // `&X { y: 1 }, X { y: 1 }.y`\n-            contains_exterior_struct_lit(&x)\n+            contains_exterior_struct_lit(x)\n         }\n \n-        hir::ExprKind::MethodCall(.., ref exprs, _) => {\n+        hir::ExprKind::MethodCall(.., exprs, _) => {\n             // `X { y: 1 }.bar(...)`\n             contains_exterior_struct_lit(&exprs[0])\n         }"}, {"sha": "4d29fc469462c43b01434e1ab086e04657be794b", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 76, "deletions": 31, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -315,8 +315,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         body_id: Option<hir::BodyId>,\n         failure_span: Span,\n         arg: GenericArg<'tcx>,\n-        // FIXME(#94483): Either use this or remove it.\n-        _impl_candidates: Vec<ty::TraitRef<'tcx>>,\n         error_code: TypeAnnotationNeeded,\n         should_label_span: bool,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n@@ -534,6 +532,23 @@ enum InferSourceKind<'tcx> {\n     },\n }\n \n+impl<'tcx> InferSource<'tcx> {\n+    fn from_expansion(&self) -> bool {\n+        let source_from_expansion = match self.kind {\n+            InferSourceKind::LetBinding { insert_span, .. }\n+            | InferSourceKind::ClosureArg { insert_span, .. }\n+            | InferSourceKind::GenericArg { insert_span, .. } => insert_span.from_expansion(),\n+            InferSourceKind::FullyQualifiedMethodCall { receiver, .. } => {\n+                receiver.span.from_expansion()\n+            }\n+            InferSourceKind::ClosureReturn { data, should_wrap_expr, .. } => {\n+                data.span().from_expansion() || should_wrap_expr.map_or(false, Span::from_expansion)\n+            }\n+        };\n+        source_from_expansion || self.span.from_expansion()\n+    }\n+}\n+\n impl<'tcx> InferSourceKind<'tcx> {\n     fn ty_msg(&self, infcx: &InferCtxt<'_, 'tcx>) -> String {\n         match *self {\n@@ -604,57 +619,85 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n     /// Sources with a small cost are prefer and should result\n     /// in a clearer and idiomatic suggestion.\n     fn source_cost(&self, source: &InferSource<'tcx>) -> usize {\n-        let tcx = self.infcx.tcx;\n-\n-        fn arg_cost<'tcx>(arg: GenericArg<'tcx>) -> usize {\n-            match arg.unpack() {\n-                GenericArgKind::Lifetime(_) => 0, // erased\n-                GenericArgKind::Type(ty) => ty_cost(ty),\n-                GenericArgKind::Const(_) => 3, // some non-zero value\n-            }\n+        #[derive(Clone, Copy)]\n+        struct CostCtxt<'tcx> {\n+            tcx: TyCtxt<'tcx>,\n         }\n-        fn ty_cost<'tcx>(ty: Ty<'tcx>) -> usize {\n-            match ty.kind() {\n-                ty::Closure(..) => 100,\n-                ty::FnDef(..) => 20,\n-                ty::FnPtr(..) => 10,\n-                ty::Infer(..) => 0,\n-                _ => 1,\n+        impl<'tcx> CostCtxt<'tcx> {\n+            fn arg_cost(self, arg: GenericArg<'tcx>) -> usize {\n+                match arg.unpack() {\n+                    GenericArgKind::Lifetime(_) => 0, // erased\n+                    GenericArgKind::Type(ty) => self.ty_cost(ty),\n+                    GenericArgKind::Const(_) => 3, // some non-zero value\n+                }\n+            }\n+            fn ty_cost(self, ty: Ty<'tcx>) -> usize {\n+                match *ty.kind() {\n+                    ty::Closure(..) => 1000,\n+                    ty::FnDef(..) => 150,\n+                    ty::FnPtr(..) => 30,\n+                    ty::Adt(def, substs) => {\n+                        5 + self\n+                            .tcx\n+                            .generics_of(def.did())\n+                            .own_substs_no_defaults(self.tcx, substs)\n+                            .iter()\n+                            .map(|&arg| self.arg_cost(arg))\n+                            .sum::<usize>()\n+                    }\n+                    ty::Tuple(args) => 5 + args.iter().map(|arg| self.ty_cost(arg)).sum::<usize>(),\n+                    ty::Ref(_, ty, _) => 2 + self.ty_cost(ty),\n+                    ty::Infer(..) => 0,\n+                    _ => 1,\n+                }\n             }\n         }\n \n         // The sources are listed in order of preference here.\n-        match source.kind {\n-            InferSourceKind::LetBinding { ty, .. } => ty_cost(ty),\n-            InferSourceKind::ClosureArg { ty, .. } => 5 + ty_cost(ty),\n+        let tcx = self.infcx.tcx;\n+        let ctx = CostCtxt { tcx };\n+        let base_cost = match source.kind {\n+            InferSourceKind::LetBinding { ty, .. } => ctx.ty_cost(ty),\n+            InferSourceKind::ClosureArg { ty, .. } => ctx.ty_cost(ty),\n             InferSourceKind::GenericArg { def_id, generic_args, .. } => {\n                 let variant_cost = match tcx.def_kind(def_id) {\n-                    DefKind::Variant | DefKind::Ctor(CtorOf::Variant, _) => 15, // `None::<u32>` and friends are ugly.\n-                    _ => 12,\n+                    // `None::<u32>` and friends are ugly.\n+                    DefKind::Variant | DefKind::Ctor(CtorOf::Variant, _) => 15,\n+                    _ => 10,\n                 };\n-                variant_cost + generic_args.iter().map(|&arg| arg_cost(arg)).sum::<usize>()\n+                variant_cost + generic_args.iter().map(|&arg| ctx.arg_cost(arg)).sum::<usize>()\n             }\n             InferSourceKind::FullyQualifiedMethodCall { substs, .. } => {\n-                20 + substs.iter().map(|arg| arg_cost(arg)).sum::<usize>()\n+                20 + substs.iter().map(|arg| ctx.arg_cost(arg)).sum::<usize>()\n             }\n             InferSourceKind::ClosureReturn { ty, should_wrap_expr, .. } => {\n-                30 + ty_cost(ty) + if should_wrap_expr.is_some() { 10 } else { 0 }\n+                30 + ctx.ty_cost(ty) + if should_wrap_expr.is_some() { 10 } else { 0 }\n             }\n-        }\n+        };\n+\n+        let suggestion_may_apply = if source.from_expansion() { 10000 } else { 0 };\n+\n+        base_cost + suggestion_may_apply\n     }\n \n     /// Uses `fn source_cost` to determine whether this inference source is preferable to\n     /// previous sources. We generally prefer earlier sources.\n     #[instrument(level = \"debug\", skip(self))]\n     fn update_infer_source(&mut self, new_source: InferSource<'tcx>) {\n         let cost = self.source_cost(&new_source) + self.attempt;\n+        debug!(?cost);\n         self.attempt += 1;\n         if cost < self.infer_source_cost {\n             self.infer_source_cost = cost;\n             self.infer_source = Some(new_source);\n         }\n     }\n \n+    fn node_substs_opt(&self, hir_id: HirId) -> Option<SubstsRef<'tcx>> {\n+        let substs = self.typeck_results.node_substs_opt(hir_id);\n+        self.infcx.resolve_vars_if_possible(substs)\n+    }\n+\n     fn opt_node_type(&self, hir_id: HirId) -> Option<Ty<'tcx>> {\n         let ty = self.typeck_results.node_type_opt(hir_id);\n         self.infcx.resolve_vars_if_possible(ty)\n@@ -737,7 +780,7 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n         let tcx = self.infcx.tcx;\n         match expr.kind {\n             hir::ExprKind::Path(ref path) => {\n-                if let Some(substs) = self.typeck_results.node_substs_opt(expr.hir_id) {\n+                if let Some(substs) = self.node_substs_opt(expr.hir_id) {\n                     return self.path_inferred_subst_iter(expr.hir_id, substs, path);\n                 }\n             }\n@@ -765,7 +808,7 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n                         if generics.has_impl_trait() {\n                             None?\n                         }\n-                        let substs = self.typeck_results.node_substs_opt(expr.hir_id)?;\n+                        let substs = self.node_substs_opt(expr.hir_id)?;\n                         let span = tcx.hir().span(segment.hir_id?);\n                         let insert_span = segment.ident.span.shrink_to_hi().with_hi(span.hi());\n                         InsertableGenericArgs {\n@@ -980,8 +1023,10 @@ impl<'a, 'tcx> Visitor<'tcx> for FindInferSourceVisitor<'a, 'tcx> {\n             debug!(?args);\n             let InsertableGenericArgs { insert_span, substs, generics_def_id, def_id } = args;\n             let generics = tcx.generics_of(generics_def_id);\n-            if let Some(argument_index) =\n-                generics.own_substs(substs).iter().position(|&arg| self.generic_arg_is_target(arg))\n+            if let Some(argument_index) = generics\n+                .own_substs(substs)\n+                .iter()\n+                .position(|&arg| self.generic_arg_contains_target(arg))\n             {\n                 let substs = self.infcx.resolve_vars_if_possible(substs);\n                 let generic_args = &generics.own_substs_no_defaults(tcx, substs)\n@@ -1037,7 +1082,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FindInferSourceVisitor<'a, 'tcx> {\n             .any(|generics| generics.has_impl_trait())\n         };\n         if let ExprKind::MethodCall(path, args, span) = expr.kind\n-            && let Some(substs) = self.typeck_results.node_substs_opt(expr.hir_id)\n+            && let Some(substs) = self.node_substs_opt(expr.hir_id)\n             && substs.iter().any(|arg| self.generic_arg_contains_target(arg))\n             && let Some(def_id) = self.typeck_results.type_dependent_def_id(expr.hir_id)\n             && self.infcx.tcx.trait_of_item(def_id).is_some()"}, {"sha": "1bbd71c3f1f517d45d1d1e7fbd1c762701c3cf47", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -160,12 +160,18 @@ impl AllocError {\n }\n \n /// The information that makes up a memory access: offset and size.\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone)]\n pub struct AllocRange {\n     pub start: Size,\n     pub size: Size,\n }\n \n+impl fmt::Debug for AllocRange {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"[{:#x}..{:#x}]\", self.start.bytes(), self.end().bytes())\n+    }\n+}\n+\n /// Free-starting constructor for less syntactic overhead.\n #[inline(always)]\n pub fn alloc_range(start: Size, size: Size) -> AllocRange {"}, {"sha": "f30769248c0747fb3c2e6922f94d2c3dafe0f525", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -334,45 +334,39 @@ impl fmt::Display for UndefinedBehaviorInfo<'_> {\n                 p,\n             ),\n             PointerUseAfterFree(a) => {\n-                write!(f, \"pointer to {} was dereferenced after this allocation got freed\", a)\n+                write!(f, \"pointer to {a:?} was dereferenced after this allocation got freed\")\n             }\n             PointerOutOfBounds { alloc_id, alloc_size, ptr_offset, ptr_size: Size::ZERO, msg } => {\n                 write!(\n                     f,\n-                    \"{}{alloc_id} has size {alloc_size}, so pointer at offset {ptr_offset} is out-of-bounds\",\n-                    msg,\n-                    alloc_id = alloc_id,\n+                    \"{msg}{alloc_id:?} has size {alloc_size}, so pointer at offset {ptr_offset} is out-of-bounds\",\n                     alloc_size = alloc_size.bytes(),\n-                    ptr_offset = ptr_offset,\n                 )\n             }\n             PointerOutOfBounds { alloc_id, alloc_size, ptr_offset, ptr_size, msg } => write!(\n                 f,\n-                \"{}{alloc_id} has size {alloc_size}, so pointer to {ptr_size} byte{ptr_size_p} starting at offset {ptr_offset} is out-of-bounds\",\n-                msg,\n-                alloc_id = alloc_id,\n+                \"{msg}{alloc_id:?} has size {alloc_size}, so pointer to {ptr_size} byte{ptr_size_p} starting at offset {ptr_offset} is out-of-bounds\",\n                 alloc_size = alloc_size.bytes(),\n                 ptr_size = ptr_size.bytes(),\n                 ptr_size_p = pluralize!(ptr_size.bytes()),\n-                ptr_offset = ptr_offset,\n             ),\n             DanglingIntPointer(0, CheckInAllocMsg::InboundsTest) => {\n                 write!(f, \"null pointer is not a valid pointer for this operation\")\n             }\n             DanglingIntPointer(0, msg) => {\n-                write!(f, \"{}null pointer is not a valid pointer\", msg)\n+                write!(f, \"{msg}null pointer is not a valid pointer\")\n             }\n             DanglingIntPointer(i, msg) => {\n-                write!(f, \"{}0x{:x} is not a valid pointer\", msg, i)\n+                write!(f, \"{msg}{i:#x} is not a valid pointer\")\n             }\n             AlignmentCheckFailed { required, has } => write!(\n                 f,\n                 \"accessing memory with alignment {}, but alignment {} is required\",\n                 has.bytes(),\n                 required.bytes()\n             ),\n-            WriteToReadOnly(a) => write!(f, \"writing to {} which is read-only\", a),\n-            DerefFunctionPointer(a) => write!(f, \"accessing {} which contains a function\", a),\n+            WriteToReadOnly(a) => write!(f, \"writing to {a:?} which is read-only\"),\n+            DerefFunctionPointer(a) => write!(f, \"accessing {a:?} which contains a function\"),\n             ValidationFailure { path: None, msg } => {\n                 write!(f, \"constructing invalid value: {}\", msg)\n             }"}, {"sha": "698024b23301ea054e9f71dabe38c86525bc8898", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -190,11 +190,7 @@ impl fmt::Debug for AllocId {\n     }\n }\n \n-impl fmt::Display for AllocId {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Debug::fmt(self, f)\n-    }\n-}\n+// No \"Display\" since AllocIds are not usually user-visible.\n \n #[derive(TyDecodable, TyEncodable)]\n enum AllocDiscriminant {\n@@ -470,7 +466,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             return alloc_id;\n         }\n         let id = alloc_map.reserve();\n-        debug!(\"creating alloc {:?} with id {}\", alloc, id);\n+        debug!(\"creating alloc {alloc:?} with id {id:?}\");\n         alloc_map.alloc_map.insert(id, alloc.clone());\n         alloc_map.dedup.insert(alloc, id);\n         id\n@@ -538,15 +534,15 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn global_alloc(self, id: AllocId) -> GlobalAlloc<'tcx> {\n         match self.get_global_alloc(id) {\n             Some(alloc) => alloc,\n-            None => bug!(\"could not find allocation for {}\", id),\n+            None => bug!(\"could not find allocation for {id:?}\"),\n         }\n     }\n \n     /// Freezes an `AllocId` created with `reserve` by pointing it at an `Allocation`. Trying to\n     /// call this function twice, even with the same `Allocation` will ICE the compiler.\n     pub fn set_alloc_id_memory(self, id: AllocId, mem: ConstAllocation<'tcx>) {\n         if let Some(old) = self.alloc_map.lock().alloc_map.insert(id, GlobalAlloc::Memory(mem)) {\n-            bug!(\"tried to set allocation ID {}, but it was already existing as {:#?}\", id, old);\n+            bug!(\"tried to set allocation ID {id:?}, but it was already existing as {old:#?}\");\n         }\n     }\n "}, {"sha": "81d744107fd569a288423ff27a2fa02039481b21", "filename": "compiler/rustc_middle/src/mir/interpret/pointer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -144,7 +144,7 @@ impl Provenance for AllocId {\n         }\n         // Print offset only if it is non-zero.\n         if ptr.offset.bytes() > 0 {\n-            write!(f, \"+0x{:x}\", ptr.offset.bytes())?;\n+            write!(f, \"+{:#x}\", ptr.offset.bytes())?;\n         }\n         Ok(())\n     }\n@@ -181,7 +181,7 @@ impl<Tag: Provenance> fmt::Debug for Pointer<Option<Tag>> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.provenance {\n             Some(tag) => Provenance::fmt(&Pointer::new(tag, self.offset), f),\n-            None => write!(f, \"0x{:x}\", self.offset.bytes()),\n+            None => write!(f, \"{:#x}\", self.offset.bytes()),\n         }\n     }\n }"}, {"sha": "8ecbb5ab0b31f70f068a02d770e3c6be2fae10d3", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -167,7 +167,7 @@ impl<Tag: Provenance> fmt::LowerHex for Scalar<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             Scalar::Ptr(ptr, _size) => write!(f, \"pointer to {:?}\", ptr),\n-            Scalar::Int(int) => write!(f, \"0x{:x}\", int),\n+            Scalar::Int(int) => write!(f, \"{:#x}\", int),\n         }\n     }\n }"}, {"sha": "24c6cd91d0a54cfef880baf7fdb5686409544773", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -716,12 +716,12 @@ pub fn write_allocations<'tcx>(\n                 }\n                 write!(w, \"{}\", display_allocation(tcx, alloc.inner()))\n             };\n-        write!(w, \"\\n{}\", id)?;\n+        write!(w, \"\\n{id:?}\")?;\n         match tcx.get_global_alloc(id) {\n             // This can't really happen unless there are bugs, but it doesn't cost us anything to\n             // gracefully handle it and allow buggy rustc to be debugged via allocation printing.\n             None => write!(w, \" (deallocated)\")?,\n-            Some(GlobalAlloc::Function(inst)) => write!(w, \" (fn: {})\", inst)?,\n+            Some(GlobalAlloc::Function(inst)) => write!(w, \" (fn: {inst})\")?,\n             Some(GlobalAlloc::Static(did)) if !tcx.is_foreign_item(did) => {\n                 match tcx.eval_static_initializer(did) {\n                     Ok(alloc) => {"}, {"sha": "c7c2692281ebb9580ac2871dcfa874403eb9ccaf", "filename": "compiler/rustc_middle/src/ty/consts/int.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -452,6 +452,10 @@ impl fmt::Debug for ScalarInt {\n impl fmt::LowerHex for ScalarInt {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         self.check_data();\n+        if f.alternate() {\n+            // Like regular ints, alternate flag adds leading `0x`.\n+            write!(f, \"0x\")?;\n+        }\n         // Format as hex number wide enough to fit any value of the given `size`.\n         // So data=20, size=1 will be \"0x14\", but with size=4 it'll be \"0x00000014\".\n         // Using a block `{self.data}` here to force a copy instead of using `self.data`"}, {"sha": "4fbbd9deaebb4c27868b8be39530c8aaec7a37f4", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -1495,6 +1495,15 @@ impl<'a> Resolver<'a> {\n             err.help(\"have you added the `#[macro_use]` on the module/import?\");\n             return;\n         }\n+        if ident.name == kw::Default\n+            && let ModuleKind::Def(DefKind::Enum, def_id, _) = parent_scope.module.kind\n+            && let Some(span) = self.opt_span(def_id)\n+        {\n+            err.span_help(\n+                self.session.source_map().guess_head_span(span),\n+                \"consider adding `#[derive(Default)]` to this enum\",\n+            );\n+        }\n         for ns in [Namespace::MacroNS, Namespace::TypeNS, Namespace::ValueNS] {\n             if let Ok(binding) = self.early_resolve_ident_in_lexical_scope(\n                 ident,"}, {"sha": "88b09f4de0a4c260485e7262b84aef91f5b42797", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -1980,7 +1980,6 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                             body_id,\n                             span,\n                             trait_ref.self_ty().skip_binder().into(),\n-                            vec![],\n                             ErrorCode::E0282,\n                             false,\n                         )\n@@ -2005,19 +2004,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                 let subst = data.trait_ref.substs.iter().find(|s| s.has_infer_types_or_consts());\n \n                 let mut err = if let Some(subst) = subst {\n-                    let impl_candidates = self\n-                        .find_similar_impl_candidates(trait_ref)\n-                        .into_iter()\n-                        .map(|candidate| candidate.trait_ref)\n-                        .collect();\n-                    self.emit_inference_failure_err(\n-                        body_id,\n-                        span,\n-                        subst,\n-                        impl_candidates,\n-                        ErrorCode::E0283,\n-                        true,\n-                    )\n+                    self.emit_inference_failure_err(body_id, span, subst, ErrorCode::E0283, true)\n                 } else {\n                     struct_span_err!(\n                         self.tcx.sess,\n@@ -2117,7 +2104,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                     return;\n                 }\n \n-                self.emit_inference_failure_err(body_id, span, arg, vec![], ErrorCode::E0282, false)\n+                self.emit_inference_failure_err(body_id, span, arg, ErrorCode::E0282, false)\n             }\n \n             ty::PredicateKind::Subtype(data) => {\n@@ -2131,14 +2118,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                 let SubtypePredicate { a_is_expected: _, a, b } = data;\n                 // both must be type variables, or the other would've been instantiated\n                 assert!(a.is_ty_var() && b.is_ty_var());\n-                self.emit_inference_failure_err(\n-                    body_id,\n-                    span,\n-                    a.into(),\n-                    vec![],\n-                    ErrorCode::E0282,\n-                    true,\n-                )\n+                self.emit_inference_failure_err(body_id, span, a.into(), ErrorCode::E0282, true)\n             }\n             ty::PredicateKind::Projection(data) => {\n                 if predicate.references_error() || self.is_tainted_by_errors() {\n@@ -2155,7 +2135,6 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                         body_id,\n                         span,\n                         subst,\n-                        vec![],\n                         ErrorCode::E0284,\n                         true,\n                     );"}, {"sha": "5297c48b4c37d07058aa152d2931dffb6ee2c041", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -1538,15 +1538,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty\n         } else {\n             if !self.is_tainted_by_errors() {\n-                self.emit_inference_failure_err(\n-                    (**self).body_id,\n-                    sp,\n-                    ty.into(),\n-                    vec![],\n-                    E0282,\n-                    true,\n-                )\n-                .emit();\n+                self.emit_inference_failure_err((**self).body_id, sp, ty.into(), E0282, true)\n+                    .emit();\n             }\n             let err = self.tcx.ty_error();\n             self.demand_suptype(sp, err, ty);"}, {"sha": "16e5639096c5e7c62dd339cf797775c05e2e452b", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -692,7 +692,6 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n                     Some(self.body.id()),\n                     self.span.to_span(self.tcx),\n                     t.into(),\n-                    vec![],\n                     E0282,\n                     false,\n                 )\n@@ -707,7 +706,6 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n                     Some(self.body.id()),\n                     self.span.to_span(self.tcx),\n                     c.into(),\n-                    vec![],\n                     E0282,\n                     false,\n                 )"}, {"sha": "69b72a81c5b6d8437ccb806256ec91f0278f7b24", "filename": "library/std/src/net/tcp.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -7,6 +7,7 @@ use crate::io::prelude::*;\n \n use crate::fmt;\n use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::iter::FusedIterator;\n use crate::net::{Shutdown, SocketAddr, ToSocketAddrs};\n use crate::sys_common::net as net_imp;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n@@ -1009,6 +1010,9 @@ impl<'a> Iterator for Incoming<'a> {\n     }\n }\n \n+#[stable(feature = \"tcp_listener_incoming_fused_iterator\", since = \"1.64.0\")]\n+impl FusedIterator for Incoming<'_> {}\n+\n #[unstable(feature = \"tcplistener_into_incoming\", issue = \"88339\")]\n impl Iterator for IntoIncoming {\n     type Item = io::Result<TcpStream>;\n@@ -1017,6 +1021,9 @@ impl Iterator for IntoIncoming {\n     }\n }\n \n+#[unstable(feature = \"tcplistener_into_incoming\", issue = \"88339\")]\n+impl FusedIterator for IntoIncoming {}\n+\n impl AsInner<net_imp::TcpListener> for TcpListener {\n     fn as_inner(&self) -> &net_imp::TcpListener {\n         &self.0"}, {"sha": "33bd0d240813990739daff593735713015e01870", "filename": "src/test/ui/enum/suggest-default-attribute.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/src%2Ftest%2Fui%2Fenum%2Fsuggest-default-attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/src%2Ftest%2Fui%2Fenum%2Fsuggest-default-attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum%2Fsuggest-default-attribute.rs?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -0,0 +1,8 @@\n+pub enum Test { //~ HELP consider adding `#[derive(Default)]` to this enum\n+    #[default]\n+    //~^ ERROR cannot find attribute `default` in this scope\n+    First,\n+    Second,\n+}\n+\n+fn main() {}"}, {"sha": "791f219e8f95f6c64e3d038f74c7ff2bba3f3053", "filename": "src/test/ui/enum/suggest-default-attribute.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/src%2Ftest%2Fui%2Fenum%2Fsuggest-default-attribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/src%2Ftest%2Fui%2Fenum%2Fsuggest-default-attribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum%2Fsuggest-default-attribute.stderr?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -0,0 +1,14 @@\n+error: cannot find attribute `default` in this scope\n+  --> $DIR/suggest-default-attribute.rs:2:7\n+   |\n+LL |     #[default]\n+   |       ^^^^^^^\n+   |\n+help: consider adding `#[derive(Default)]` to this enum\n+  --> $DIR/suggest-default-attribute.rs:1:1\n+   |\n+LL | pub enum Test {\n+   | ^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "9cbe221de1393f86ee5b6cb3d70350b24acee14b", "filename": "src/test/ui/inference/ambiguous_type_parameter.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/src%2Ftest%2Fui%2Finference%2Fambiguous_type_parameter.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/src%2Ftest%2Fui%2Finference%2Fambiguous_type_parameter.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fambiguous_type_parameter.stderr?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -2,7 +2,12 @@ error[E0282]: type annotations needed\n   --> $DIR/ambiguous_type_parameter.rs:16:19\n    |\n LL |     InMemoryStore.get_raw(&String::default());\n-   |                   ^^^^^^^ cannot infer type for type parameter `K`\n+   |                   ^^^^^^^\n+   |\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <InMemoryStore as Store<String, HashMap<K, String>>>::get_raw(&InMemoryStore, &String::default());\n+   |     +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++             ~\n \n error: aborting due to previous error\n "}, {"sha": "b555697dc3461058cb0648ed1e0d01f3fd022985", "filename": "src/test/ui/inference/cannot-infer-partial-try-return.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.rs?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -16,8 +16,8 @@ fn infallible() -> Result<(), std::convert::Infallible> {\n \n fn main() {\n     let x = || -> Result<_, QualifiedError<_>> {\n-        //~^ ERROR type annotations needed for `Result<(), QualifiedError<_>>`\n         infallible()?;\n         Ok(())\n+        //~^ ERROR type annotations needed\n     };\n }"}, {"sha": "2a56aaa44fef23b3ae435b47451aa9e7986f4769", "filename": "src/test/ui/inference/cannot-infer-partial-try-return.stderr", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.stderr?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -1,16 +1,15 @@\n-error[E0282]: type annotations needed for `Result<(), QualifiedError<_>>`\n-  --> $DIR/cannot-infer-partial-try-return.rs:18:13\n+error[E0282]: type annotations needed\n+  --> $DIR/cannot-infer-partial-try-return.rs:20:9\n    |\n-LL |     let x = || -> Result<_, QualifiedError<_>> {\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-LL |\n LL |         infallible()?;\n    |         ------------- type must be known at this point\n+LL |         Ok(())\n+   |         ^^ cannot infer type of the type parameter `E` declared on the enum `Result`\n    |\n-help: try giving this closure an explicit return type\n+help: consider specifying the generic arguments\n    |\n-LL |     let x = || -> Result<(), QualifiedError<_>> {\n-   |                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+LL |         Ok::<(), QualifiedError<_>>(())\n+   |           +++++++++++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "e2ba5a9417138abf8a4de9ef6a6eea6b0ce38dbe", "filename": "src/test/ui/inference/need_type_info/channel.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/src%2Ftest%2Fui%2Finference%2Fneed_type_info%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/src%2Ftest%2Fui%2Finference%2Fneed_type_info%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fneed_type_info%2Fchannel.rs?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -0,0 +1,19 @@\n+// Test that we suggest specifying the generic argument of `channel`\n+// instead of the return type of that function, which is a lot more\n+// complex.\n+use std::sync::mpsc::channel;\n+\n+fn no_tuple() {\n+    let _data =\n+        channel(); //~ ERROR type annotations needed\n+}\n+\n+fn tuple() {\n+    let (_sender, _receiver) =\n+        channel(); //~ ERROR type annotations needed\n+}\n+\n+fn main() {\n+    no_tuple();\n+    tuple();\n+}"}, {"sha": "e33ace0338d5040b8b360870082532aa02df23f7", "filename": "src/test/ui/inference/need_type_info/channel.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/src%2Ftest%2Fui%2Finference%2Fneed_type_info%2Fchannel.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/src%2Ftest%2Fui%2Finference%2Fneed_type_info%2Fchannel.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fneed_type_info%2Fchannel.stderr?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -0,0 +1,25 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/channel.rs:8:9\n+   |\n+LL |         channel();\n+   |         ^^^^^^^ cannot infer type of the type parameter `T` declared on the function `channel`\n+   |\n+help: consider specifying the generic argument\n+   |\n+LL |         channel::<T>();\n+   |                +++++\n+\n+error[E0282]: type annotations needed\n+  --> $DIR/channel.rs:13:9\n+   |\n+LL |         channel();\n+   |         ^^^^^^^ cannot infer type of the type parameter `T` declared on the function `channel`\n+   |\n+help: consider specifying the generic argument\n+   |\n+LL |         channel::<T>();\n+   |                +++++\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "7b9a1634a0d4c146fcf552639d47cd17af7c1b7e", "filename": "src/test/ui/issues/issue-23041.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/src%2Ftest%2Fui%2Fissues%2Fissue-23041.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/src%2Ftest%2Fui%2Fissues%2Fissue-23041.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23041.stderr?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -1,8 +1,13 @@\n error[E0282]: type annotations needed\n-  --> $DIR/issue-23041.rs:6:22\n+  --> $DIR/issue-23041.rs:6:7\n    |\n LL |     b.downcast_ref::<fn(_)->_>();\n-   |                      ^^^^^^^^ cannot infer type\n+   |       ^^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the associated function `downcast_ref`\n+   |\n+help: consider specifying the generic arguments\n+   |\n+LL |     b.downcast_ref::<fn(_) -> _>();\n+   |                   ~~~~~~~~~~~~~~\n \n error: aborting due to previous error\n "}, {"sha": "863993f45090460bca6f8277e5712b5a6c4169b2", "filename": "src/test/ui/issues/issue-24013.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/src%2Ftest%2Fui%2Fissues%2Fissue-24013.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/src%2Ftest%2Fui%2Fissues%2Fissue-24013.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24013.stderr?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -1,8 +1,13 @@\n error[E0282]: type annotations needed\n-  --> $DIR/issue-24013.rs:5:20\n+  --> $DIR/issue-24013.rs:5:13\n    |\n LL |     unsafe {swap::<&mut _>(transmute(&a), transmute(&b))};\n-   |                    ^^^^^^ cannot infer type\n+   |             ^^^^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the function `swap`\n+   |\n+help: consider specifying the generic arguments\n+   |\n+LL |     unsafe {swap::<&mut _>(transmute(&a), transmute(&b))};\n+   |                 ~~~~~~~~~~\n \n error: aborting due to previous error\n "}, {"sha": "4be83457f7a8be46f232542df8f4eb392be9eeb6", "filename": "src/test/ui/issues/issue-25368.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/src%2Ftest%2Fui%2Fissues%2Fissue-25368.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/src%2Ftest%2Fui%2Fissues%2Fissue-25368.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-25368.rs?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -5,10 +5,10 @@ use std::marker::PhantomData;\n struct Foo<T> {foo: PhantomData<T>}\n \n fn main() {\n-    let (tx, rx) = //~ ERROR type annotations needed\n+    let (tx, rx) =\n         channel();\n-    // FIXME(#89862): Suggest adding a generic argument to `channel` instead\n     spawn(move || {\n         tx.send(Foo{ foo: PhantomData });\n+        //~^ ERROR type annotations needed\n     });\n }"}, {"sha": "e6ed3aac71032f1d646a4d6efa09785f6abb3934", "filename": "src/test/ui/issues/issue-25368.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/src%2Ftest%2Fui%2Fissues%2Fissue-25368.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/src%2Ftest%2Fui%2Fissues%2Fissue-25368.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-25368.stderr?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -1,13 +1,13 @@\n-error[E0282]: type annotations needed for `(Sender<Foo<T>>, std::sync::mpsc::Receiver<Foo<T>>)`\n-  --> $DIR/issue-25368.rs:8:9\n+error[E0282]: type annotations needed\n+  --> $DIR/issue-25368.rs:11:27\n    |\n-LL |     let (tx, rx) =\n-   |         ^^^^^^^^\n+LL |         tx.send(Foo{ foo: PhantomData });\n+   |                           ^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the struct `PhantomData`\n    |\n-help: consider giving this pattern a type, where the type for type parameter `T` is specified\n+help: consider specifying the generic argument\n    |\n-LL |     let (tx, rx): (Sender<Foo<T>>, std::sync::mpsc::Receiver<Foo<T>>) =\n-   |                 +++++++++++++++++++++++++++++++++++++++++++++++++++++\n+LL |         tx.send(Foo{ foo: PhantomData::<T> });\n+   |                                      +++++\n \n error: aborting due to previous error\n "}, {"sha": "e0f8a5447b081b884cf4640562efe0cd8ff1a4db", "filename": "src/test/ui/methods/method-ambig-one-trait-unknown-int-type.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4045ce641a9eede71cc12031a2cd71692b273890/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-one-trait-unknown-int-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4045ce641a9eede71cc12031a2cd71692b273890/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-one-trait-unknown-int-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-one-trait-unknown-int-type.stderr?ref=4045ce641a9eede71cc12031a2cd71692b273890", "patch": "@@ -13,7 +13,7 @@ error[E0283]: type annotations needed\n   --> $DIR/method-ambig-one-trait-unknown-int-type.rs:26:7\n    |\n LL |     x.foo();\n-   |       ^^^ cannot infer type for struct `Vec<_>`\n+   |       ^^^\n    |\n note: multiple `impl`s satisfying `Vec<_>: Foo` found\n   --> $DIR/method-ambig-one-trait-unknown-int-type.rs:9:1\n@@ -23,6 +23,10 @@ LL | impl Foo for Vec<usize> {\n ...\n LL | impl Foo for Vec<isize> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     <Vec<T> as Foo>::foo(&x);\n+   |     ++++++++++++++++++++++ ~\n \n error[E0308]: mismatched types\n   --> $DIR/method-ambig-one-trait-unknown-int-type.rs:33:20"}]}