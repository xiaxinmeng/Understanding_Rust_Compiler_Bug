{"sha": "afaf3e07aaa7ca9873bdb439caec53faffa4230c", "node_id": "C_kwDOAAsO6NoAKGFmYWYzZTA3YWFhN2NhOTg3M2JkYjQzOWNhZWM1M2ZhZmZhNDIzMGM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-14T20:53:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-14T20:53:37Z"}, "message": "Auto merge of #106866 - matthiaskrgr:rollup-r063s44, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #105526 (libcore: make result of iter::from_generator Clone)\n - #106563 (Fix `unused_braces` on generic const expr macro call)\n - #106661 (Stop probing for statx unless necessary)\n - #106820 (Deprioritize fulfillment errors that come from expansions.)\n - #106828 (rustdoc: remove `docblock` class from notable trait popover)\n - #106849 (Allocate one less vec while parsing arrays)\n - #106855 (rustdoc: few small cleanups)\n - #106860 (Remove various double spaces in the libraries.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "64e4ad70d0a7b3ca30376a8d88921e7b837e26af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64e4ad70d0a7b3ca30376a8d88921e7b837e26af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afaf3e07aaa7ca9873bdb439caec53faffa4230c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afaf3e07aaa7ca9873bdb439caec53faffa4230c", "html_url": "https://github.com/rust-lang/rust/commit/afaf3e07aaa7ca9873bdb439caec53faffa4230c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afaf3e07aaa7ca9873bdb439caec53faffa4230c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8f9cb345ab1401f2fbd14cc23f64dda9dd2314e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8f9cb345ab1401f2fbd14cc23f64dda9dd2314e", "html_url": "https://github.com/rust-lang/rust/commit/b8f9cb345ab1401f2fbd14cc23f64dda9dd2314e"}, {"sha": "e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9", "html_url": "https://github.com/rust-lang/rust/commit/e0eb63a73ccfb9aa7b09b39b3c9fe23287f5cac9"}], "stats": {"total": 382, "additions": 221, "deletions": 161}, "files": [{"sha": "f2ee9ab1a19873cfac16b3e6f2c29c253a5267a5", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -1105,6 +1105,7 @@ impl UnusedDelimLint for UnusedBraces {\n                                 || matches!(expr.kind, ast::ExprKind::Lit(_)))\n                             && !cx.sess().source_map().is_multiline(value.span)\n                             && value.attrs.is_empty()\n+                            && !expr.span.from_expansion()\n                             && !value.span.from_expansion()\n                             && !inner.span.from_expansion()\n                         {"}, {"sha": "d58afcd4c9fc43b906ee2249b980ea0dd66e092c", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -1475,9 +1475,8 @@ impl<'a> Parser<'a> {\n             } else if self.eat(&token::Comma) {\n                 // Vector with two or more elements.\n                 let sep = SeqSep::trailing_allowed(token::Comma);\n-                let (remaining_exprs, _) = self.parse_seq_to_end(close, sep, |p| p.parse_expr())?;\n-                let mut exprs = vec![first_expr];\n-                exprs.extend(remaining_exprs);\n+                let (mut exprs, _) = self.parse_seq_to_end(close, sep, |p| p.parse_expr())?;\n+                exprs.insert(0, first_expr);\n                 ExprKind::Array(exprs)\n             } else {\n                 // Vector with one element"}, {"sha": "1434c07203836e357e0a8fc928b27dcf94264fe5", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -454,9 +454,11 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             }\n         }\n \n-        for (error, suppressed) in iter::zip(errors, is_suppressed) {\n-            if !suppressed {\n-                self.report_fulfillment_error(error, body_id);\n+        for from_expansion in [false, true] {\n+            for (error, suppressed) in iter::zip(errors, &is_suppressed) {\n+                if !suppressed && error.obligation.cause.span.from_expansion() == from_expansion {\n+                    self.report_fulfillment_error(error, body_id);\n+                }\n             }\n         }\n "}, {"sha": "3a797bd5ecaa8ea84e8d90f8a47dab4f5b6c94b9", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -20,7 +20,7 @@ use core::marker::Destruct;\n mod tests;\n \n extern \"Rust\" {\n-    // These are the magic symbols to call the global allocator.  rustc generates\n+    // These are the magic symbols to call the global allocator. rustc generates\n     // them to call `__rg_alloc` etc. if there is a `#[global_allocator]` attribute\n     // (the code expanding that attribute macro generates those functions), or to call\n     // the default implementations in std (`__rdl_alloc` etc. in `library/std/src/alloc.rs`)\n@@ -353,7 +353,7 @@ pub(crate) const unsafe fn box_free<T: ?Sized, A: ~const Allocator + ~const Dest\n \n #[cfg(not(no_global_oom_handling))]\n extern \"Rust\" {\n-    // This is the magic symbol to call the global alloc error handler.  rustc generates\n+    // This is the magic symbol to call the global alloc error handler. rustc generates\n     // it to call `__rg_oom` if there is a `#[alloc_error_handler]`, or to call the\n     // default implementations below (`__rdl_oom`) otherwise.\n     fn __rust_alloc_error_handler(size: usize, align: usize) -> !;"}, {"sha": "c9aa23fc4af1f275e98ff6352e4e34480d6044cb", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -2179,7 +2179,7 @@ pub struct Weak<T: ?Sized> {\n     // This is a `NonNull` to allow optimizing the size of this type in enums,\n     // but it is not necessarily a valid pointer.\n     // `Weak::new` sets this to `usize::MAX` so that it doesn\u2019t need\n-    // to allocate space on the heap.  That's not a value a real pointer\n+    // to allocate space on the heap. That's not a value a real pointer\n     // will ever have because RcBox has alignment at least 2.\n     // This is only possible when `T: Sized`; unsized `T` never dangle.\n     ptr: NonNull<RcBox<T>>,"}, {"sha": "bab7f5f53657a58cfa55f9614684a6a8b4978700", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -295,7 +295,7 @@ pub struct Weak<T: ?Sized> {\n     // This is a `NonNull` to allow optimizing the size of this type in enums,\n     // but it is not necessarily a valid pointer.\n     // `Weak::new` sets this to `usize::MAX` so that it doesn\u2019t need\n-    // to allocate space on the heap.  That's not a value a real pointer\n+    // to allocate space on the heap. That's not a value a real pointer\n     // will ever have because RcBox has alignment at least 2.\n     // This is only possible when `T: Sized`; unsized `T` never dangle.\n     ptr: NonNull<ArcInner<T>>,\n@@ -1656,7 +1656,7 @@ impl<T: ?Sized> Arc<T> {\n         //\n         // The acquire label here ensures a happens-before relationship with any\n         // writes to `strong` (in particular in `Weak::upgrade`) prior to decrements\n-        // of the `weak` count (via `Weak::drop`, which uses release).  If the upgraded\n+        // of the `weak` count (via `Weak::drop`, which uses release). If the upgraded\n         // weak ref was never dropped, the CAS here will fail so we do not care to synchronize.\n         if self.inner().weak.compare_exchange(1, usize::MAX, Acquire, Relaxed).is_ok() {\n             // This needs to be an `Acquire` to synchronize with the decrement of the `strong`\n@@ -1712,7 +1712,7 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Arc<T> {\n         }\n \n         // This fence is needed to prevent reordering of use of the data and\n-        // deletion of the data.  Because it is marked `Release`, the decreasing\n+        // deletion of the data. Because it is marked `Release`, the decreasing\n         // of the reference count synchronizes with this `Acquire` fence. This\n         // means that use of the data happens before decreasing the reference\n         // count, which happens before this fence, which happens before the\n@@ -2172,7 +2172,7 @@ impl<T: ?Sized> Clone for Weak<T> {\n         } else {\n             return Weak { ptr: self.ptr };\n         };\n-        // See comments in Arc::clone() for why this is relaxed.  This can use a\n+        // See comments in Arc::clone() for why this is relaxed. This can use a\n         // fetch_add (ignoring the lock) because the weak count is only locked\n         // where are *no other* weak pointers in existence. (So we can't be\n         // running this code in that case)."}, {"sha": "37966007eb7e43eb1fb661d8925567b303f905ba", "filename": "library/alloc/src/vec/into_iter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -40,7 +40,7 @@ pub struct IntoIter<\n     // to avoid dropping the allocator twice we need to wrap it into ManuallyDrop\n     pub(super) alloc: ManuallyDrop<A>,\n     pub(super) ptr: *const T,\n-    pub(super) end: *const T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n+    pub(super) end: *const T, // If T is a ZST, this is actually ptr+len. This encoding is picked so that\n                               // ptr == end is a quick test for the Iterator being empty, that works\n                               // for both ZST and non-ZST.\n }\n@@ -146,9 +146,9 @@ impl<T, A: Allocator> IntoIter<T, A> {\n         let mut this = ManuallyDrop::new(self);\n \n         // SAFETY: This allocation originally came from a `Vec`, so it passes\n-        // all those checks.  We have `this.buf` \u2264 `this.ptr` \u2264 `this.end`,\n+        // all those checks. We have `this.buf` \u2264 `this.ptr` \u2264 `this.end`,\n         // so the `sub_ptr`s below cannot wrap, and will produce a well-formed\n-        // range.  `end` \u2264 `buf + cap`, so the range will be in-bounds.\n+        // range. `end` \u2264 `buf + cap`, so the range will be in-bounds.\n         // Taking `alloc` is ok because nothing else is going to look at it,\n         // since our `Drop` impl isn't going to run so there's no more code.\n         unsafe {"}, {"sha": "26120270c0cb0da8402a60b346e0999acf2873f8", "filename": "library/alloc/src/vec/is_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Falloc%2Fsrc%2Fvec%2Fis_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Falloc%2Fsrc%2Fvec%2Fis_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fis_zero.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -57,7 +57,7 @@ unsafe impl<T: IsZero, const N: usize> IsZero for [T; N] {\n     #[inline]\n     fn is_zero(&self) -> bool {\n         // Because this is generated as a runtime check, it's not obvious that\n-        // it's worth doing if the array is really long.  The threshold here\n+        // it's worth doing if the array is really long. The threshold here\n         // is largely arbitrary, but was picked because as of 2022-07-01 LLVM\n         // fails to const-fold the check in `vec![[1; 32]; n]`\n         // See https://github.com/rust-lang/rust/pull/97581#issuecomment-1166628022"}, {"sha": "36b0b3c9e7cc072aca6f39d2f165d277d52cbdc3", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -2429,7 +2429,7 @@ impl<T: Clone, A: Allocator> Vec<T, A> {\n         self.reserve(range.len());\n \n         // SAFETY:\n-        // - `slice::range` guarantees  that the given range is valid for indexing self\n+        // - `slice::range` guarantees that the given range is valid for indexing self\n         unsafe {\n             self.spec_extend_from_within(range);\n         }\n@@ -2686,7 +2686,7 @@ impl<T: Clone, A: Allocator + Clone> Clone for Vec<T, A> {\n \n     // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is\n     // required for this method definition, is not available. Instead use the\n-    // `slice::to_vec`  function which is only available with cfg(test)\n+    // `slice::to_vec` function which is only available with cfg(test)\n     // NB see the slice::hack module in slice.rs for more information\n     #[cfg(test)]\n     fn clone(&self) -> Self {"}, {"sha": "2f07c2911a50264aee57ab1a67b966a869045ef3", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -1849,7 +1849,7 @@ fn test_stable_pointers() {\n     }\n \n     // Test that, if we reserved enough space, adding and removing elements does not\n-    // invalidate references into the vector (such as `v0`).  This test also\n+    // invalidate references into the vector (such as `v0`). This test also\n     // runs in Miri, which would detect such problems.\n     // Note that this test does *not* constitute a stable guarantee that all these functions do not\n     // reallocate! Only what is explicitly documented at"}, {"sha": "8259c087d22e4ff13cce9566ed8a828a169f0977", "filename": "library/core/src/array/iter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fiter.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -109,8 +109,8 @@ impl<T, const N: usize> IntoIter<T, N> {\n     /// use std::array::IntoIter;\n     /// use std::mem::MaybeUninit;\n     ///\n-    /// # // Hi!  Thanks for reading the code.  This is restricted to `Copy` because\n-    /// # // otherwise it could leak.  A fully-general version this would need a drop\n+    /// # // Hi!  Thanks for reading the code. This is restricted to `Copy` because\n+    /// # // otherwise it could leak. A fully-general version this would need a drop\n     /// # // guard to handle panics from the iterator, but this works for an example.\n     /// fn next_chunk<T: Copy, const N: usize>(\n     ///     it: &mut impl Iterator<Item = T>,\n@@ -211,7 +211,7 @@ impl<T, const N: usize> IntoIter<T, N> {\n         let initialized = 0..0;\n \n         // SAFETY: We're telling it that none of the elements are initialized,\n-        // which is trivially true.  And \u2200N: usize, 0 <= N.\n+        // which is trivially true. And \u2200N: usize, 0 <= N.\n         unsafe { Self::new_unchecked(buffer, initialized) }\n     }\n "}, {"sha": "b5739f2f3c0b057d286ecff2095d80f861c5ca18", "filename": "library/core/src/iter/range.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Frange.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -756,7 +756,7 @@ impl<A: Step> Iterator for ops::Range<A> {\n     where\n         Self: TrustedRandomAccessNoCoerce,\n     {\n-        // SAFETY: The TrustedRandomAccess contract requires that callers only  pass an index\n+        // SAFETY: The TrustedRandomAccess contract requires that callers only pass an index\n         // that is in bounds.\n         // Additionally Self: TrustedRandomAccess is only implemented for Copy types\n         // which means even repeated reads of the same index would be safe."}, {"sha": "4cbe731b222f920131e999b0bd409747aa387a88", "filename": "library/core/src/iter/sources/from_generator.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Ffrom_generator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Ffrom_generator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Ffrom_generator.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -1,3 +1,4 @@\n+use crate::fmt;\n use crate::ops::{Generator, GeneratorState};\n use crate::pin::Pin;\n \n@@ -23,14 +24,21 @@ use crate::pin::Pin;\n /// ```\n #[inline]\n #[unstable(feature = \"iter_from_generator\", issue = \"43122\", reason = \"generators are unstable\")]\n-pub fn from_generator<G: Generator<Return = ()> + Unpin>(\n-    generator: G,\n-) -> impl Iterator<Item = G::Yield> {\n+pub fn from_generator<G: Generator<Return = ()> + Unpin>(generator: G) -> FromGenerator<G> {\n     FromGenerator(generator)\n }\n \n-struct FromGenerator<G>(G);\n+/// An iterator over the values yielded by an underlying generator.\n+///\n+/// This `struct` is created by the [`iter::from_generator()`] function. See its documentation for\n+/// more.\n+///\n+/// [`iter::from_generator()`]: from_generator\n+#[unstable(feature = \"iter_from_generator\", issue = \"43122\", reason = \"generators are unstable\")]\n+#[derive(Clone)]\n+pub struct FromGenerator<G>(G);\n \n+#[unstable(feature = \"iter_from_generator\", issue = \"43122\", reason = \"generators are unstable\")]\n impl<G: Generator<Return = ()> + Unpin> Iterator for FromGenerator<G> {\n     type Item = G::Yield;\n \n@@ -41,3 +49,10 @@ impl<G: Generator<Return = ()> + Unpin> Iterator for FromGenerator<G> {\n         }\n     }\n }\n+\n+#[unstable(feature = \"iter_from_generator\", issue = \"43122\", reason = \"generators are unstable\")]\n+impl<G> fmt::Debug for FromGenerator<G> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"FromGenerator\").finish()\n+    }\n+}"}, {"sha": "3806977f70ee4598d6a78aa88483b10086460b36", "filename": "library/core/src/num/dec2flt/fpu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Ffpu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Ffpu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Ffpu.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -26,7 +26,7 @@ mod fpu_precision {\n     /// Developer's Manual (Volume 1).\n     ///\n     /// The only field which is relevant for the following code is PC, Precision Control. This\n-    /// field determines the precision of the operations performed by the  FPU. It can be set to:\n+    /// field determines the precision of the operations performed by the FPU. It can be set to:\n     ///  - 0b00, single precision i.e., 32-bits\n     ///  - 0b10, double precision i.e., 64-bits\n     ///  - 0b11, double extended precision i.e., 80-bits (default state)"}, {"sha": "7071a656d613d59e772255946a2003a845f61729", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -1538,7 +1538,7 @@ macro_rules! int_impl {\n         ///\n         /// ```\n         /// #![feature(bigint_helper_methods)]\n-        /// // Only the  most significant word is signed.\n+        /// // Only the most significant word is signed.\n         /// //\n         #[doc = concat!(\"//   10  MAX    (a = 10 \u00d7 2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n         #[doc = concat!(\"// + -5    9    (b = -5 \u00d7 2^\", stringify!($BITS), \" + 9)\")]\n@@ -1646,7 +1646,7 @@ macro_rules! int_impl {\n         ///\n         /// ```\n         /// #![feature(bigint_helper_methods)]\n-        /// // Only the  most significant word is signed.\n+        /// // Only the most significant word is signed.\n         /// //\n         #[doc = concat!(\"//    6    8    (a = 6 \u00d7 2^\", stringify!($BITS), \" + 8)\")]\n         #[doc = concat!(\"// - -5    9    (b = -5 \u00d7 2^\", stringify!($BITS), \" + 9)\")]"}, {"sha": "ec0c9984841e68089536f9836cfe70e5bb7dcd81", "filename": "library/core/src/pin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fcore%2Fsrc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fcore%2Fsrc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpin.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -753,7 +753,7 @@ impl<P: DerefMut> Pin<P> {\n impl<'a, T: ?Sized> Pin<&'a T> {\n     /// Constructs a new pin by mapping the interior value.\n     ///\n-    /// For example, if you  wanted to get a `Pin` of a field of something,\n+    /// For example, if you wanted to get a `Pin` of a field of something,\n     /// you could use this to get access to that field in one line of code.\n     /// However, there are several gotchas with these \"pinning projections\";\n     /// see the [`pin` module] documentation for further details on that topic.\n@@ -856,7 +856,7 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n \n     /// Construct a new pin by mapping the interior value.\n     ///\n-    /// For example, if you  wanted to get a `Pin` of a field of something,\n+    /// For example, if you wanted to get a `Pin` of a field of something,\n     /// you could use this to get access to that field in one line of code.\n     /// However, there are several gotchas with these \"pinning projections\";\n     /// see the [`pin` module] documentation for further details on that topic."}, {"sha": "1ad9af1549a47fcdf12e46b391e12891c2fba0bd", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -1701,7 +1701,7 @@ pub(crate) const unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usiz\n         // offset is not a multiple of `stride`, the input pointer was misaligned and no pointer\n         // offset will be able to produce a `p` aligned to the specified `a`.\n         //\n-        // The naive `-p (mod a)` equation  inhibits LLVM's ability to select instructions\n+        // The naive `-p (mod a)` equation inhibits LLVM's ability to select instructions\n         // like `lea`. We compute `(round_up_to_next_alignment(p, a) - p)` instead. This\n         // redistributes operations around the load-bearing, but pessimizing `and` instruction\n         // sufficiently for LLVM to be able to utilize the various optimizations it knows about."}, {"sha": "c3e7f2eb302ca38102f4dad1bd55d35105f10036", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -65,7 +65,7 @@ fn size_from_ptr<T>(_: *const T) -> usize {\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct Iter<'a, T: 'a> {\n     ptr: NonNull<T>,\n-    end: *const T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n+    end: *const T, // If T is a ZST, this is actually ptr+len. This encoding is picked so that\n     // ptr == end is a quick test for the Iterator being empty, that works\n     // for both ZST and non-ZST.\n     _marker: PhantomData<&'a T>,\n@@ -186,7 +186,7 @@ impl<T> AsRef<[T]> for Iter<'_, T> {\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct IterMut<'a, T: 'a> {\n     ptr: NonNull<T>,\n-    end: *mut T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n+    end: *mut T, // If T is a ZST, this is actually ptr+len. This encoding is picked so that\n     // ptr == end is a quick test for the Iterator being empty, that works\n     // for both ZST and non-ZST.\n     _marker: PhantomData<&'a mut T>,"}, {"sha": "55af4cb61dcc09383f4a23603f5d843767648896", "filename": "library/core/src/slice/iter/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -23,7 +23,7 @@ macro_rules! len {\n             $self.end.addr().wrapping_sub(start.as_ptr().addr())\n         } else {\n             // We know that `start <= end`, so can do better than `offset_from`,\n-            // which needs to deal in signed.  By setting appropriate flags here\n+            // which needs to deal in signed. By setting appropriate flags here\n             // we can tell LLVM this, which helps it remove bounds checks.\n             // SAFETY: By the type invariant, `start <= end`\n             let diff = unsafe { unchecked_sub($self.end.addr(), start.as_ptr().addr()) };"}, {"sha": "df7fe2bf76dcda7568976ec874956de7aa6eb3f1", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -703,7 +703,7 @@ impl<T> [T] {\n \n             // Because this function is first compiled in isolation,\n             // this check tells LLVM that the indexing below is\n-            // in-bounds.  Then after inlining -- once the actual\n+            // in-bounds. Then after inlining -- once the actual\n             // lengths of the slices are known -- it's removed.\n             let (a, b) = (&mut a[..n], &mut b[..n]);\n \n@@ -1248,7 +1248,7 @@ impl<T> [T] {\n         ArrayChunksMut::new(self)\n     }\n \n-    /// Returns an iterator over overlapping windows of `N` elements of  a slice,\n+    /// Returns an iterator over overlapping windows of `N` elements of a slice,\n     /// starting at the beginning of the slice.\n     ///\n     /// This is the const generic equivalent of [`windows`].\n@@ -2476,7 +2476,7 @@ impl<T> [T] {\n             let mid = left + size / 2;\n \n             // SAFETY: the while condition means `size` is strictly positive, so\n-            // `size/2 < size`.  Thus `left + size/2 < left + size`, which\n+            // `size/2 < size`. Thus `left + size/2 < left + size`, which\n             // coupled with the `left + size <= self.len()` invariant means\n             // we have `left + size/2 < self.len()`, and this is in-bounds.\n             let cmp = f(unsafe { self.get_unchecked(mid) });"}, {"sha": "4d2fcd917849caf5378a0c04f70a2a0dbf593fd4", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -18,9 +18,9 @@ struct CopyOnDrop<T> {\n \n impl<T> Drop for CopyOnDrop<T> {\n     fn drop(&mut self) {\n-        // SAFETY:  This is a helper class.\n-        //          Please refer to its usage for correctness.\n-        //          Namely, one must be sure that `src` and `dst` does not overlap as required by `ptr::copy_nonoverlapping`.\n+        // SAFETY: This is a helper class.\n+        //         Please refer to its usage for correctness.\n+        //         Namely, one must be sure that `src` and `dst` does not overlap as required by `ptr::copy_nonoverlapping`.\n         unsafe {\n             ptr::copy_nonoverlapping(self.src, self.dest, 1);\n         }"}, {"sha": "39559cdbb5ea9c275b9b3db5b1db08291ec90c64", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -1488,7 +1488,7 @@ mod slice_index {\n                 // optional:\n                 //\n                 // one or more similar inputs for which data[input] succeeds,\n-                // and the corresponding output as an array.  This helps validate\n+                // and the corresponding output as an array. This helps validate\n                 // \"critical points\" where an input range straddles the boundary\n                 // between valid and invalid.\n                 // (such as the input `len..len`, which is just barely valid)"}, {"sha": "286ad68fd13e8fdf70efab2fb31cb122ec23286d", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -1512,7 +1512,7 @@ impl FileType {\n     }\n \n     /// Tests whether this file type represents a regular file.\n-    /// The result is  mutually exclusive to the results of\n+    /// The result is mutually exclusive to the results of\n     /// [`is_dir`] and [`is_symlink`]; only zero or one of these\n     /// tests may pass.\n     ///"}, {"sha": "4c1b7d57684ddcf01b890b8742bc4732588248e8", "filename": "library/std/src/io/buffered/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -288,8 +288,8 @@ fn test_buffered_reader_seek_underflow_discard_buffer_between_seeks() {\n     let mut reader = BufReader::with_capacity(5, ErrAfterFirstSeekReader { first_seek: true });\n     assert_eq!(reader.fill_buf().ok(), Some(&[0, 0, 0, 0, 0][..]));\n \n-    // The following seek will require two underlying seeks.  The first will\n-    // succeed but the second will fail.  This should still invalidate the\n+    // The following seek will require two underlying seeks. The first will\n+    // succeed but the second will fail. This should still invalidate the\n     // buffer.\n     assert!(reader.seek(SeekFrom::Current(i64::MIN)).is_err());\n     assert_eq!(reader.buffer().len(), 0);"}, {"sha": "c41e093a7e5c6442f7022cd09d7f587f680af185", "filename": "library/std/src/os/fd/owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffd%2Fowned.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -100,7 +100,7 @@ impl BorrowedFd<'_> {\n \n         // For ESP-IDF, F_DUPFD is used instead, because the CLOEXEC semantics\n         // will never be supported, as this is a bare metal framework with\n-        // no capabilities for multi-process execution.  While F_DUPFD is also\n+        // no capabilities for multi-process execution. While F_DUPFD is also\n         // not supported yet, it might be (currently it returns ENOSYS).\n         #[cfg(target_os = \"espidf\")]\n         let cmd = libc::F_DUPFD;"}, {"sha": "b0db3112e22fd34470d06fa910b73ef4d118f4a7", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -306,11 +306,11 @@ pub mod panic_count {\n     // and after increase and decrease, but not necessarily during their execution.\n     //\n     // Additionally, the top bit of GLOBAL_PANIC_COUNT (GLOBAL_ALWAYS_ABORT_FLAG)\n-    // records whether panic::always_abort() has been called.  This can only be\n+    // records whether panic::always_abort() has been called. This can only be\n     // set, never cleared.\n     // panic::always_abort() is usually called to prevent memory allocations done by\n     // the panic handling in the child created by `libc::fork`.\n-    // Memory allocations performed in  a child created with `libc::fork` are undefined\n+    // Memory allocations performed in a child created with `libc::fork` are undefined\n     // behavior in most operating systems.\n     // Accessing LOCAL_PANIC_COUNT in a child created by `libc::fork` would lead to a memory\n     // allocation. Only GLOBAL_PANIC_COUNT can be accessed in this situation. This is"}, {"sha": "c3593264e520b3243f98c01cbf80f12e9fa0b44c", "filename": "library/std/src/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -607,7 +607,7 @@ pub struct Components<'a> {\n \n     // true if path *physically* has a root separator; for most Windows\n     // prefixes, it may have a \"logical\" root separator for the purposes of\n-    // normalization, e.g.,  \\\\server\\share == \\\\server\\share\\.\n+    // normalization, e.g., \\\\server\\share == \\\\server\\share\\.\n     has_physical_root: bool,\n \n     // The iterator is double-ended, and these two states keep track of what has"}, {"sha": "19350b83fab884d8cf3ebd0efdabb7b9de30d4a3", "filename": "library/std/src/sys/itron/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -294,7 +294,7 @@ impl Drop for Thread {\n                 // Terminate and delete the task\n                 // Safety: `self.task` still represents a task we own (because\n                 //         this method or `join_inner` is called only once for\n-                //         each `Thread`). The task  indicated that it's safe to\n+                //         each `Thread`). The task indicated that it's safe to\n                 //         delete by entering the `FINISHED` state.\n                 unsafe { terminate_and_delete_task(self.task) };\n "}, {"sha": "8e1f35d6cc92011cac5704c196d5384390e3de3c", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 43, "deletions": 29, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -149,12 +149,13 @@ cfg_has_statx! {{\n     ) -> Option<io::Result<FileAttr>> {\n         use crate::sync::atomic::{AtomicU8, Ordering};\n \n-        // Linux kernel prior to 4.11 or glibc prior to glibc 2.28 don't support `statx`\n-        // We store the availability in global to avoid unnecessary syscalls.\n-        // 0: Unknown\n-        // 1: Not available\n-        // 2: Available\n-        static STATX_STATE: AtomicU8 = AtomicU8::new(0);\n+        // Linux kernel prior to 4.11 or glibc prior to glibc 2.28 don't support `statx`.\n+        // We check for it on first failure and remember availability to avoid having to\n+        // do it again.\n+        #[repr(u8)]\n+        enum STATX_STATE{ Unknown = 0, Present, Unavailable }\n+        static STATX_SAVED_STATE: AtomicU8 = AtomicU8::new(STATX_STATE::Unknown as u8);\n+\n         syscall! {\n             fn statx(\n                 fd: c_int,\n@@ -165,31 +166,44 @@ cfg_has_statx! {{\n             ) -> c_int\n         }\n \n-        match STATX_STATE.load(Ordering::Relaxed) {\n-            0 => {\n-                // It is a trick to call `statx` with null pointers to check if the syscall\n-                // is available. According to the manual, it is expected to fail with EFAULT.\n-                // We do this mainly for performance, since it is nearly hundreds times\n-                // faster than a normal successful call.\n-                let err = cvt(statx(0, ptr::null(), 0, libc::STATX_ALL, ptr::null_mut()))\n-                    .err()\n-                    .and_then(|e| e.raw_os_error());\n-                // We don't check `err == Some(libc::ENOSYS)` because the syscall may be limited\n-                // and returns `EPERM`. Listing all possible errors seems not a good idea.\n-                // See: https://github.com/rust-lang/rust/issues/65662\n-                if err != Some(libc::EFAULT) {\n-                    STATX_STATE.store(1, Ordering::Relaxed);\n-                    return None;\n-                }\n-                STATX_STATE.store(2, Ordering::Relaxed);\n-            }\n-            1 => return None,\n-            _ => {}\n+        if STATX_SAVED_STATE.load(Ordering::Relaxed) == STATX_STATE::Unavailable as u8 {\n+            return None;\n         }\n \n         let mut buf: libc::statx = mem::zeroed();\n         if let Err(err) = cvt(statx(fd, path, flags, mask, &mut buf)) {\n-            return Some(Err(err));\n+            if STATX_SAVED_STATE.load(Ordering::Relaxed) == STATX_STATE::Present as u8 {\n+                return Some(Err(err));\n+            }\n+\n+            // Availability not checked yet.\n+            //\n+            // First try the cheap way.\n+            if err.raw_os_error() == Some(libc::ENOSYS) {\n+                STATX_SAVED_STATE.store(STATX_STATE::Unavailable as u8, Ordering::Relaxed);\n+                return None;\n+            }\n+\n+            // Error other than `ENOSYS` is not a good enough indicator -- it is\n+            // known that `EPERM` can be returned as a result of using seccomp to\n+            // block the syscall.\n+            // Availability is checked by performing a call which expects `EFAULT`\n+            // if the syscall is usable.\n+            // See: https://github.com/rust-lang/rust/issues/65662\n+            // FIXME this can probably just do the call if `EPERM` was received, but\n+            // previous iteration of the code checked it for all errors and for now\n+            // this is retained.\n+            // FIXME what about transient conditions like `ENOMEM`?\n+            let err2 = cvt(statx(0, ptr::null(), 0, libc::STATX_ALL, ptr::null_mut()))\n+                .err()\n+                .and_then(|e| e.raw_os_error());\n+            if err2 == Some(libc::EFAULT) {\n+                STATX_SAVED_STATE.store(STATX_STATE::Present as u8, Ordering::Relaxed);\n+                return Some(Err(err));\n+            } else {\n+                STATX_SAVED_STATE.store(STATX_STATE::Unavailable as u8, Ordering::Relaxed);\n+                return None;\n+            }\n         }\n \n         // We cannot fill `stat64` exhaustively because of private padding fields.\n@@ -600,13 +614,13 @@ impl Iterator for ReadDir {\n             loop {\n                 // As of POSIX.1-2017, readdir() is not required to be thread safe; only\n                 // readdir_r() is. However, readdir_r() cannot correctly handle platforms\n-                // with unlimited or variable NAME_MAX.  Many modern platforms guarantee\n+                // with unlimited or variable NAME_MAX. Many modern platforms guarantee\n                 // thread safety for readdir() as long an individual DIR* is not accessed\n                 // concurrently, which is sufficient for Rust.\n                 super::os::set_errno(0);\n                 let entry_ptr = readdir64(self.inner.dirp.0);\n                 if entry_ptr.is_null() {\n-                    // We either encountered an error, or reached the end.  Either way,\n+                    // We either encountered an error, or reached the end. Either way,\n                     // the next call to next() should return None.\n                     self.end_of_stream = true;\n "}, {"sha": "73b9bef7e2ac9b68b3b8480d27a2e288a7c4cd24", "filename": "library/std/src/sys/unix/kernel_copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -587,7 +587,7 @@ pub(super) fn copy_regular_files(reader: RawFd, writer: RawFd, max_len: u64) ->\n                         // - copy_file_range file is immutable or syscall is blocked by seccomp\u00b9 (EPERM)\n                         // - copy_file_range cannot be used with pipes or device nodes (EINVAL)\n                         // - the writer fd was opened with O_APPEND (EBADF\u00b2)\n-                        // and no bytes were written successfully yet.  (All these errnos should\n+                        // and no bytes were written successfully yet. (All these errnos should\n                         // not be returned if something was already written, but they happen in\n                         // the wild, see #91152.)\n                         //"}, {"sha": "d4c7e58b34d2ef85c2d5864962928745d6eebd14", "filename": "library/std/src/sys/unix/process/process_fuchsia.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -262,7 +262,7 @@ impl ExitStatus {\n     // available on Fuchsia.\n     //\n     // It does not appear that Fuchsia is Unix-like enough to implement ExitStatus (or indeed many\n-    // other things from std::os::unix) properly.  This veneer is always going to be a bodge.  So\n+    // other things from std::os::unix) properly. This veneer is always going to be a bodge. So\n     // while I don't know if these implementations are actually correct, I think they will do for\n     // now at least.\n     pub fn core_dumped(&self) -> bool {\n@@ -277,24 +277,24 @@ impl ExitStatus {\n \n     pub fn into_raw(&self) -> c_int {\n         // We don't know what someone who calls into_raw() will do with this value, but it should\n-        // have the conventional Unix representation.  Despite the fact that this is not\n+        // have the conventional Unix representation. Despite the fact that this is not\n         // standardised in SuS or POSIX, all Unix systems encode the signal and exit status the\n-        // same way.  (Ie the WIFEXITED, WEXITSTATUS etc. macros have identical behaviour on every\n+        // same way. (Ie the WIFEXITED, WEXITSTATUS etc. macros have identical behaviour on every\n         // Unix.)\n         //\n         // The caller of `std::os::unix::into_raw` is probably wanting a Unix exit status, and may\n         // do their own shifting and masking, or even pass the status to another computer running a\n         // different Unix variant.\n         //\n         // The other view would be to say that the caller on Fuchsia ought to know that `into_raw`\n-        // will give a raw Fuchsia status (whatever that is - I don't know, personally).  That is\n+        // will give a raw Fuchsia status (whatever that is - I don't know, personally). That is\n         // not possible here because we must return a c_int because that's what Unix (including\n         // SuS and POSIX) say a wait status is, but Fuchsia apparently uses a u64, so it won't\n         // necessarily fit.\n         //\n         // It seems to me that the right answer would be to provide std::os::fuchsia with its\n         // own ExitStatusExt, rather that trying to provide a not very convincing imitation of\n-        // Unix.  Ie, std::os::unix::process:ExitStatusExt ought not to exist on Fuchsia.  But\n+        // Unix. Ie, std::os::unix::process:ExitStatusExt ought not to exist on Fuchsia. But\n         // fixing this up that is beyond the scope of my efforts now.\n         let exit_status_as_if_unix: u8 = self.0.try_into().expect(\"Fuchsia process return code bigger than 8 bits, but std::os::unix::ExitStatusExt::into_raw() was called to try to convert the value into a traditional Unix-style wait status, which cannot represent values greater than 255.\");\n         let wait_status_as_if_unix = (exit_status_as_if_unix as c_int) << 8;"}, {"sha": "c2c4aa1c9dfceff80d98f79999e772fd324c28de", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -666,11 +666,11 @@ impl ExitStatus {\n     }\n \n     pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n-        // This assumes that WIFEXITED(status) && WEXITSTATUS==0 corresponds to status==0.  This is\n+        // This assumes that WIFEXITED(status) && WEXITSTATUS==0 corresponds to status==0. This is\n         // true on all actual versions of Unix, is widely assumed, and is specified in SuS\n-        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html .  If it is not\n+        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html. If it is not\n         // true for a platform pretending to be Unix, the tests (our doctests, and also\n-        // procsss_unix/tests.rs) will spot it.  `ExitStatusError::code` assumes this too.\n+        // procsss_unix/tests.rs) will spot it. `ExitStatusError::code` assumes this too.\n         match NonZero_c_int::try_from(self.0) {\n             /* was nonzero */ Ok(failure) => Err(ExitStatusError(failure)),\n             /* was zero, couldn't convert */ Err(_) => Ok(()),"}, {"sha": "e5e1f956bc351e43c16878ea2d37b6b65d876025", "filename": "library/std/src/sys/unix/process/process_unix/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix%2Ftests.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -19,17 +19,17 @@ fn exitstatus_display_tests() {\n     t(0x00000, \"exit status: 0\");\n     t(0x0ff00, \"exit status: 255\");\n \n-    // On MacOS, 0x0137f is WIFCONTINUED, not WIFSTOPPED.  Probably *BSD is similar.\n+    // On MacOS, 0x0137f is WIFCONTINUED, not WIFSTOPPED. Probably *BSD is similar.\n     //   https://github.com/rust-lang/rust/pull/82749#issuecomment-790525956\n     // The purpose of this test is to test our string formatting, not our understanding of the wait\n-    // status magic numbers.  So restrict these to Linux.\n+    // status magic numbers. So restrict these to Linux.\n     if cfg!(target_os = \"linux\") {\n         t(0x0137f, \"stopped (not terminated) by signal: 19 (SIGSTOP)\");\n         t(0x0ffff, \"continued (WIFCONTINUED)\");\n     }\n \n     // Testing \"unrecognised wait status\" is hard because the wait.h macros typically\n-    // assume that the value came from wait and isn't mad.  With the glibc I have here\n+    // assume that the value came from wait and isn't mad. With the glibc I have here\n     // this works:\n     if cfg!(all(target_os = \"linux\", target_env = \"gnu\")) {\n         t(0x000ff, \"unrecognised wait status: 255 0xff\");"}, {"sha": "569a4b149125d618bd8847691b7b4434d8ab0cb7", "filename": "library/std/src/sys/unix/process/process_vxworks.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_vxworks.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -195,11 +195,11 @@ impl ExitStatus {\n     }\n \n     pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n-        // This assumes that WIFEXITED(status) && WEXITSTATUS==0 corresponds to status==0.  This is\n+        // This assumes that WIFEXITED(status) && WEXITSTATUS==0 corresponds to status==0. This is\n         // true on all actual versions of Unix, is widely assumed, and is specified in SuS\n-        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html .  If it is not\n+        // https://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html. If it is not\n         // true for a platform pretending to be Unix, the tests (our doctests, and also\n-        // procsss_unix/tests.rs) will spot it.  `ExitStatusError::code` assumes this too.\n+        // procsss_unix/tests.rs) will spot it. `ExitStatusError::code` assumes this too.\n         match NonZero_c_int::try_from(self.0) {\n             Ok(failure) => Err(ExitStatusError(failure)),\n             Err(_) => Ok(()),"}, {"sha": "2a1830d060edc5cb934998bd1cac294e3512d281", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -73,7 +73,7 @@ impl Thread {\n                 n => {\n                     assert_eq!(n, libc::EINVAL);\n                     // EINVAL means |stack_size| is either too small or not a\n-                    // multiple of the system page size.  Because it's definitely\n+                    // multiple of the system page size. Because it's definitely\n                     // >= PTHREAD_STACK_MIN, it must be an alignment issue.\n                     // Round up to the nearest page and try again.\n                     let page_size = os::page_size();\n@@ -755,10 +755,10 @@ pub mod guard {\n         if cfg!(all(target_os = \"linux\", not(target_env = \"musl\"))) {\n             // Linux doesn't allocate the whole stack right away, and\n             // the kernel has its own stack-guard mechanism to fault\n-            // when growing too close to an existing mapping.  If we map\n+            // when growing too close to an existing mapping. If we map\n             // our own guard, then the kernel starts enforcing a rather\n             // large gap above that, rendering much of the possible\n-            // stack space useless.  See #43052.\n+            // stack space useless. See #43052.\n             //\n             // Instead, we'll just note where we expect rlimit to start\n             // faulting, so our handler can report \"stack overflow\", and\n@@ -774,14 +774,14 @@ pub mod guard {\n             None\n         } else if cfg!(target_os = \"freebsd\") {\n             // FreeBSD's stack autogrows, and optionally includes a guard page\n-            // at the bottom.  If we try to remap the bottom of the stack\n-            // ourselves, FreeBSD's guard page moves upwards.  So we'll just use\n+            // at the bottom. If we try to remap the bottom of the stack\n+            // ourselves, FreeBSD's guard page moves upwards. So we'll just use\n             // the builtin guard page.\n             let stackptr = get_stack_start_aligned()?;\n             let guardaddr = stackptr.addr();\n             // Technically the number of guard pages is tunable and controlled\n             // by the security.bsd.stack_guard_page sysctl, but there are\n-            // few reasons to change it from the default.  The default value has\n+            // few reasons to change it from the default. The default value has\n             // been 1 ever since FreeBSD 11.1 and 10.4.\n             const GUARD_PAGES: usize = 1;\n             let guard = guardaddr..guardaddr + GUARD_PAGES * page_size;\n@@ -877,9 +877,9 @@ pub mod guard {\n             } else if cfg!(all(target_os = \"linux\", any(target_env = \"gnu\", target_env = \"uclibc\")))\n             {\n                 // glibc used to include the guard area within the stack, as noted in the BUGS\n-                // section of `man pthread_attr_getguardsize`.  This has been corrected starting\n+                // section of `man pthread_attr_getguardsize`. This has been corrected starting\n                 // with glibc 2.27, and in some distro backports, so the guard is now placed at the\n-                // end (below) the stack.  There's no easy way for us to know which we have at\n+                // end (below) the stack. There's no easy way for us to know which we have at\n                 // runtime, so we'll just match any fault in the range right above or below the\n                 // stack base to call that fault a stack overflow.\n                 Some(stackaddr - guardsize..stackaddr + guardsize)"}, {"sha": "d7adeb266ed93f30918a8fab50137fec6852be98", "filename": "library/std/src/sys/windows/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -157,7 +157,7 @@ impl<'a> Iterator for SplitPaths<'a> {\n         // Double quotes are used as a way of introducing literal semicolons\n         // (since c:\\some;dir is a valid Windows path). Double quotes are not\n         // themselves permitted in path names, so there is no way to escape a\n-        // double quote.  Quoted regions can appear in arbitrary locations, so\n+        // double quote. Quoted regions can appear in arbitrary locations, so\n         //\n         //   c:\\foo;c:\\som\"e;di\"r;c:\\bar\n         //"}, {"sha": "1cb576c95947a5aeddde2a708fd0665ec9c49a56", "filename": "library/std/src/sys/windows/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -26,7 +26,7 @@ impl Thread {\n \n         // FIXME On UNIX, we guard against stack sizes that are too small but\n         // that's because pthreads enforces that stacks are at least\n-        // PTHREAD_STACK_MIN bytes big.  Windows has no such lower limit, it's\n+        // PTHREAD_STACK_MIN bytes big. Windows has no such lower limit, it's\n         // just that below a certain threshold you can't do anything useful.\n         // That threshold is application and architecture-specific, however.\n         let ret = c::CreateThread("}, {"sha": "69fb529d7f563b56e310bb85cf6b7a1f8282b6f6", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -116,7 +116,7 @@ pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>, options: Option<Opt\n     } else {\n         if !opts.nocapture {\n             // If we encounter a non-unwinding panic, flush any captured output from the current test,\n-            // and stop  capturing output to ensure that the non-unwinding panic message is visible.\n+            // and stop capturing output to ensure that the non-unwinding panic message is visible.\n             // We also acquire the locks for both output streams to prevent output from other threads\n             // from interleaving with the panic message or appearing after it.\n             let builtin_panic_hook = panic::take_hook();"}, {"sha": "3e8ccc91ab0517fd8ef676174a3e1d56c5ef9d59", "filename": "library/test/src/term/terminfo/searcher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fterm%2Fterminfo%2Fsearcher.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -30,7 +30,7 @@ pub(crate) fn get_dbpath_for_term(term: &str) -> Option<PathBuf> {\n         }\n     } else {\n         // Found nothing in TERMINFO_DIRS, use the default paths:\n-        // According to  /etc/terminfo/README, after looking at\n+        // According to /etc/terminfo/README, after looking at\n         // ~/.terminfo, ncurses will search /etc/terminfo, then\n         // /lib/terminfo, and eventually /usr/share/terminfo.\n         // On Haiku the database can be found at /boot/system/data/terminfo"}, {"sha": "3149c22b8e55ff6fcdd1293ef3594ce85a74d4a5", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -242,7 +242,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n         }\n \n         // Index this method for searching later on.\n-        if let Some(ref s) = item.name.or_else(|| {\n+        if let Some(s) = item.name.or_else(|| {\n             if item.is_stripped() {\n                 None\n             } else if let clean::ImportItem(ref i) = *item.kind &&\n@@ -317,14 +317,15 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                             short_markdown_summary(x.as_str(), &item.link_names(self.cache))\n                         });\n                         let ty = item.type_();\n-                        let name = s.to_string();\n-                        if ty != ItemType::StructField || u16::from_str_radix(&name, 10).is_err() {\n+                        if ty != ItemType::StructField\n+                            || u16::from_str_radix(s.as_str(), 10).is_err()\n+                        {\n                             // In case this is a field from a tuple struct, we don't add it into\n                             // the search index because its name is something like \"0\", which is\n                             // not useful for rustdoc search.\n                             self.cache.search_index.push(IndexItem {\n                                 ty,\n-                                name,\n+                                name: s,\n                                 path: join_with_double_colon(path),\n                                 desc,\n                                 parent,"}, {"sha": "006076baf7257dab55ae538a5361fb17a06be287", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -569,7 +569,7 @@ fn generate_macro_def_id_path(\n     root_path: Option<&str>,\n ) -> Result<(String, ItemType, Vec<Symbol>), HrefError> {\n     let tcx = cx.shared.tcx;\n-    let crate_name = tcx.crate_name(def_id.krate).to_string();\n+    let crate_name = tcx.crate_name(def_id.krate);\n     let cache = cx.cache();\n \n     let fqp: Vec<Symbol> = tcx\n@@ -584,7 +584,7 @@ fn generate_macro_def_id_path(\n             }\n         })\n         .collect();\n-    let mut relative = fqp.iter().map(|elem| elem.to_string());\n+    let mut relative = fqp.iter().copied();\n     let cstore = CStore::from_tcx(tcx);\n     // We need this to prevent a `panic` when this function is used from intra doc links...\n     if !cstore.has_crate_data(def_id.krate) {\n@@ -602,9 +602,9 @@ fn generate_macro_def_id_path(\n     };\n \n     let mut path = if is_macro_2 {\n-        once(crate_name.clone()).chain(relative).collect()\n+        once(crate_name).chain(relative).collect()\n     } else {\n-        vec![crate_name.clone(), relative.next_back().unwrap()]\n+        vec![crate_name, relative.next_back().unwrap()]\n     };\n     if path.len() < 2 {\n         // The minimum we can have is the crate name followed by the macro name. If shorter, then\n@@ -614,17 +614,22 @@ fn generate_macro_def_id_path(\n     }\n \n     if let Some(last) = path.last_mut() {\n-        *last = format!(\"macro.{}.html\", last);\n+        *last = Symbol::intern(&format!(\"macro.{}.html\", last.as_str()));\n     }\n \n     let url = match cache.extern_locations[&def_id.krate] {\n         ExternalLocation::Remote(ref s) => {\n             // `ExternalLocation::Remote` always end with a `/`.\n-            format!(\"{}{}\", s, path.join(\"/\"))\n+            format!(\"{}{}\", s, path.iter().map(|p| p.as_str()).join(\"/\"))\n         }\n         ExternalLocation::Local => {\n             // `root_path` always end with a `/`.\n-            format!(\"{}{}/{}\", root_path.unwrap_or(\"\"), crate_name, path.join(\"/\"))\n+            format!(\n+                \"{}{}/{}\",\n+                root_path.unwrap_or(\"\"),\n+                crate_name,\n+                path.iter().map(|p| p.as_str()).join(\"/\")\n+            )\n         }\n         ExternalLocation::Unknown => {\n             debug!(\"crate {} not in cache when linkifying macros\", crate_name);\n@@ -1050,7 +1055,7 @@ fn fmt_type<'cx>(\n                 _ => String::new(),\n             };\n             let m = mutability.print_with_space();\n-            let amp = if f.alternate() { \"&\".to_string() } else { \"&amp;\".to_string() };\n+            let amp = if f.alternate() { \"&\" } else { \"&amp;\" };\n             match **ty {\n                 clean::DynTrait(ref bounds, ref trait_lt)\n                     if bounds.len() > 1 || trait_lt.is_some() =>"}, {"sha": "4ff67fe1551dd019f638bc79ce4ee6460047e6bf", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -30,7 +30,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::HirId;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::edition::Edition;\n-use rustc_span::Span;\n+use rustc_span::{Span, Symbol};\n \n use once_cell::sync::Lazy;\n use std::borrow::Cow;\n@@ -198,7 +198,7 @@ fn slugify(c: char) -> Option<char> {\n \n #[derive(Clone, Debug)]\n pub struct Playground {\n-    pub crate_name: Option<String>,\n+    pub crate_name: Option<Symbol>,\n     pub url: String,\n }\n \n@@ -290,7 +290,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n                 .map(|l| map_line(l).for_code())\n                 .intersperse(\"\\n\".into())\n                 .collect::<String>();\n-            let krate = krate.as_ref().map(|s| &**s);\n+            let krate = krate.as_ref().map(|s| s.as_str());\n             let (test, _, _) =\n                 doctest::make_test(&test, krate, false, &Default::default(), edition, None);\n             let channel = if test.contains(\"#![feature(\") { \"&amp;version=nightly\" } else { \"\" };"}, {"sha": "5cefe9475e77576e63458dc5d3a9dfeb1d469285", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -464,8 +464,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n         // If user passed in `--playground-url` arg, we fill in crate name here\n         let mut playground = None;\n         if let Some(url) = playground_url {\n-            playground =\n-                Some(markdown::Playground { crate_name: Some(krate.name(tcx).to_string()), url });\n+            playground = Some(markdown::Playground { crate_name: Some(krate.name(tcx)), url });\n         }\n         let mut layout = layout::Layout {\n             logo: String::new(),\n@@ -491,7 +490,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n                 }\n                 (sym::html_playground_url, Some(s)) => {\n                     playground = Some(markdown::Playground {\n-                        crate_name: Some(krate.name(tcx).to_string()),\n+                        crate_name: Some(krate.name(tcx)),\n                         url: s.to_string(),\n                     });\n                 }"}, {"sha": "f95d8e4303594900aa892473baed229afcceaacb", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -100,7 +100,7 @@ pub(crate) fn ensure_trailing_slash(v: &str) -> impl fmt::Display + '_ {\n #[derive(Debug)]\n pub(crate) struct IndexItem {\n     pub(crate) ty: ItemType,\n-    pub(crate) name: String,\n+    pub(crate) name: Symbol,\n     pub(crate) path: String,\n     pub(crate) desc: String,\n     pub(crate) parent: Option<DefId>,\n@@ -1343,7 +1343,7 @@ fn notable_traits_decl(ty: &clean::Type, cx: &Context<'_>) -> (String, String) {\n                     write!(\n                         &mut out,\n                         \"<h3>Notable traits for <code>{}</code></h3>\\\n-                     <pre class=\\\"content\\\"><code>\",\n+                     <pre><code>\",\n                         impl_.for_.print(cx)\n                     );\n                 }\n@@ -2769,8 +2769,8 @@ fn collect_paths_for_type(first_ty: clean::Type, cache: &Cache) -> Vec<String> {\n     let mut work = VecDeque::new();\n \n     let mut process_path = |did: DefId| {\n-        let get_extern = || cache.external_paths.get(&did).map(|s| s.0.clone());\n-        let fqp = cache.exact_paths.get(&did).cloned().or_else(get_extern);\n+        let get_extern = || cache.external_paths.get(&did).map(|s| &s.0);\n+        let fqp = cache.exact_paths.get(&did).or_else(get_extern);\n \n         if let Some(path) = fqp {\n             out.push(join_with_double_colon(&path));"}, {"sha": "b93db7e28b2d701de6649819290c3d44b2c79457", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -1027,8 +1027,8 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n         .chain(std::iter::once(\"implementors\"))\n         .collect();\n     if let Some(did) = it.item_id.as_def_id() &&\n-        let get_extern = { || cache.external_paths.get(&did).map(|s| s.0.clone()) } &&\n-        let Some(fqp) = cache.exact_paths.get(&did).cloned().or_else(get_extern) {\n+        let get_extern = { || cache.external_paths.get(&did).map(|s| &s.0) } &&\n+        let Some(fqp) = cache.exact_paths.get(&did).or_else(get_extern) {\n         js_src_path.extend(fqp[..fqp.len() - 1].iter().copied());\n         js_src_path.push_fmt(format_args!(\"{}.{}.js\", it.type_(), fqp.last().unwrap()));\n     } else {"}, {"sha": "c64349f413cee8e3b19361c05808a0c5130e709d", "filename": "src/librustdoc/html/render/search_index.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -35,7 +35,7 @@ pub(crate) fn build_index<'tcx>(\n                 .map_or_else(String::new, |s| short_markdown_summary(&s, &item.link_names(cache)));\n             cache.search_index.push(IndexItem {\n                 ty: item.type_(),\n-                name: item.name.unwrap().to_string(),\n+                name: item.name.unwrap(),\n                 path: join_with_double_colon(&fqp[..fqp.len() - 1]),\n                 desc,\n                 parent: Some(parent),\n@@ -58,8 +58,8 @@ pub(crate) fn build_index<'tcx>(\n     // Sort search index items. This improves the compressibility of the search index.\n     cache.search_index.sort_unstable_by(|k1, k2| {\n         // `sort_unstable_by_key` produces lifetime errors\n-        let k1 = (&k1.path, &k1.name, &k1.ty, &k1.parent);\n-        let k2 = (&k2.path, &k2.name, &k2.ty, &k2.parent);\n+        let k1 = (&k1.path, k1.name.as_str(), &k1.ty, &k1.parent);\n+        let k2 = (&k2.path, k2.name.as_str(), &k2.ty, &k2.parent);\n         std::cmp::Ord::cmp(&k1, &k2)\n     });\n \n@@ -240,7 +240,7 @@ pub(crate) fn build_index<'tcx>(\n             )?;\n             crate_data.serialize_field(\n                 \"n\",\n-                &self.items.iter().map(|item| &item.name).collect::<Vec<_>>(),\n+                &self.items.iter().map(|item| item.name.as_str()).collect::<Vec<_>>(),\n             )?;\n             crate_data.serialize_field(\n                 \"q\",\n@@ -299,7 +299,7 @@ pub(crate) fn build_index<'tcx>(\n             )?;\n             crate_data.serialize_field(\n                 \"p\",\n-                &self.paths.iter().map(|(it, s)| (it, s.to_string())).collect::<Vec<_>>(),\n+                &self.paths.iter().map(|(it, s)| (it, s.as_str())).collect::<Vec<_>>(),\n             )?;\n             if has_aliases {\n                 crate_data.serialize_field(\"a\", &self.aliases)?;"}, {"sha": "a08b8d89db67d22454f8d0f59a90db37346c838d", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -1214,18 +1214,22 @@ a.test-arrow:hover {\n \tcontent: \"\\00a0\";\n }\n \n-.notable .docblock {\n+.notable .content {\n \tmargin: 0.25em 0.5em;\n }\n \n-.notable .docblock pre, .notable .docblock code {\n+.notable .content pre, .notable .content code {\n \tbackground: transparent;\n \tmargin: 0;\n \tpadding: 0;\n \tfont-size: 1.25rem;\n \twhite-space: pre-wrap;\n }\n \n+.notable .content > h3:first-child {\n+\tmargin: 0 0 5px 0;\n+}\n+\n .search-failed {\n \ttext-align: center;\n \tmargin-top: 20px;"}, {"sha": "f52229d80953630ec0696743d5534b0e9faf3b59", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -847,7 +847,7 @@ function loadCss(cssUrl) {\n         window.hideAllModals(false);\n         const ty = e.getAttribute(\"data-ty\");\n         const wrapper = document.createElement(\"div\");\n-        wrapper.innerHTML = \"<div class=\\\"docblock\\\">\" + window.NOTABLE_TRAITS[ty] + \"</div>\";\n+        wrapper.innerHTML = \"<div class=\\\"content\\\">\" + window.NOTABLE_TRAITS[ty] + \"</div>\";\n         wrapper.className = \"notable popover\";\n         const focusCatcher = document.createElement(\"div\");\n         focusCatcher.setAttribute(\"tabindex\", \"0\");"}, {"sha": "d6d19a3fe8159ccc66ceb1ad7cf44e9ba9da742b", "filename": "src/tools/miri/tests/pass-dep/shims/libc-fs-with-isolation.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs-with-isolation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs-with-isolation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs-with-isolation.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -22,7 +22,8 @@ fn main() {\n     }\n \n     // test `stat`\n-    assert_eq!(fs::metadata(\"foo.txt\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n+    let err = fs::metadata(\"foo.txt\").unwrap_err();\n+    assert_eq!(err.kind(), ErrorKind::PermissionDenied);\n     // check that it is the right kind of `PermissionDenied`\n-    assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EACCES));\n+    assert_eq!(err.raw_os_error(), Some(libc::EACCES));\n }"}, {"sha": "46be00a080482818f4af2c588dbdf6612953ea4a", "filename": "tests/rustdoc/doc-notable_trait-slice.bare_fn_matches.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/tests%2Frustdoc%2Fdoc-notable_trait-slice.bare_fn_matches.html", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/tests%2Frustdoc%2Fdoc-notable_trait-slice.bare_fn_matches.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fdoc-notable_trait-slice.bare_fn_matches.html?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -1 +1 @@\n-<script type=\"text/json\" id=\"notable-traits-data\">{\"&amp;'static [SomeStruct]\":\"&lt;h3&gt;Notable traits for &lt;code&gt;&amp;amp;[&lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait_slice::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;]&lt;/code&gt;&lt;/h3&gt;&lt;pre class=\\\"content\\\"&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl &lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait_slice::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt; for &amp;amp;[&lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait_slice::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;]&lt;/span&gt;\"}</script>\n\\ No newline at end of file\n+<script type=\"text/json\" id=\"notable-traits-data\">{\"&amp;'static [SomeStruct]\":\"&lt;h3&gt;Notable traits for &lt;code&gt;&amp;amp;[&lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait_slice::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;]&lt;/code&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl &lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait_slice::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt; for &amp;amp;[&lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait_slice::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;]&lt;/span&gt;\"}</script>\n\\ No newline at end of file"}, {"sha": "f592e3b375c026061ec0fb7274a8eef453f201b5", "filename": "tests/rustdoc/doc-notable_trait.bare-fn.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/tests%2Frustdoc%2Fdoc-notable_trait.bare-fn.html", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/tests%2Frustdoc%2Fdoc-notable_trait.bare-fn.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fdoc-notable_trait.bare-fn.html?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -1 +1 @@\n-<script type=\"text/json\" id=\"notable-traits-data\">{\"SomeStruct\":\"&lt;h3&gt;Notable traits for &lt;code&gt;&lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;&lt;/code&gt;&lt;/h3&gt;&lt;pre class=\\\"content\\\"&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl &lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt; for &lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;&lt;/span&gt;\"}</script>\n\\ No newline at end of file\n+<script type=\"text/json\" id=\"notable-traits-data\">{\"SomeStruct\":\"&lt;h3&gt;Notable traits for &lt;code&gt;&lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;&lt;/code&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl &lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt; for &lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;&lt;/span&gt;\"}</script>\n\\ No newline at end of file"}, {"sha": "384be668954000f0a61b53d43cdccd4249881487", "filename": "tests/rustdoc/doc-notable_trait.some-struct-new.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/tests%2Frustdoc%2Fdoc-notable_trait.some-struct-new.html", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/tests%2Frustdoc%2Fdoc-notable_trait.some-struct-new.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fdoc-notable_trait.some-struct-new.html?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -1 +1 @@\n-<script type=\"text/json\" id=\"notable-traits-data\">{\"SomeStruct\":\"&lt;h3&gt;Notable traits for &lt;code&gt;&lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;&lt;/code&gt;&lt;/h3&gt;&lt;pre class=\\\"content\\\"&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl &lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt; for &lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;&lt;/span&gt;\",\"Wrapper&lt;Self&gt;\":\"&lt;h3&gt;Notable traits for &lt;code&gt;&lt;a class=\\\"struct\\\" href=\\\"struct.Wrapper.html\\\" title=\\\"struct doc_notable_trait::Wrapper\\\"&gt;Wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/h3&gt;&lt;pre class=\\\"content\\\"&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl&amp;lt;T:&amp;nbsp;&lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt;&amp;gt; &lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt; for &lt;a class=\\\"struct\\\" href=\\\"struct.Wrapper.html\\\" title=\\\"struct doc_notable_trait::Wrapper\\\"&gt;Wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/span&gt;\"}</script>\n\\ No newline at end of file\n+<script type=\"text/json\" id=\"notable-traits-data\">{\"SomeStruct\":\"&lt;h3&gt;Notable traits for &lt;code&gt;&lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;&lt;/code&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl &lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt; for &lt;a class=\\\"struct\\\" href=\\\"struct.SomeStruct.html\\\" title=\\\"struct doc_notable_trait::SomeStruct\\\"&gt;SomeStruct&lt;/a&gt;&lt;/span&gt;\",\"Wrapper&lt;Self&gt;\":\"&lt;h3&gt;Notable traits for &lt;code&gt;&lt;a class=\\\"struct\\\" href=\\\"struct.Wrapper.html\\\" title=\\\"struct doc_notable_trait::Wrapper\\\"&gt;Wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl&amp;lt;T:&amp;nbsp;&lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt;&amp;gt; &lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt; for &lt;a class=\\\"struct\\\" href=\\\"struct.Wrapper.html\\\" title=\\\"struct doc_notable_trait::Wrapper\\\"&gt;Wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/span&gt;\"}</script>\n\\ No newline at end of file"}, {"sha": "0cc1ee10fd33571f268e88aacd0fe54a185e8013", "filename": "tests/rustdoc/doc-notable_trait.wrap-me.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/tests%2Frustdoc%2Fdoc-notable_trait.wrap-me.html", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/tests%2Frustdoc%2Fdoc-notable_trait.wrap-me.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fdoc-notable_trait.wrap-me.html?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -1 +1 @@\n-<script type=\"text/json\" id=\"notable-traits-data\">{\"Wrapper&lt;Self&gt;\":\"&lt;h3&gt;Notable traits for &lt;code&gt;&lt;a class=\\\"struct\\\" href=\\\"struct.Wrapper.html\\\" title=\\\"struct doc_notable_trait::Wrapper\\\"&gt;Wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/h3&gt;&lt;pre class=\\\"content\\\"&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl&amp;lt;T:&amp;nbsp;&lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt;&amp;gt; &lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt; for &lt;a class=\\\"struct\\\" href=\\\"struct.Wrapper.html\\\" title=\\\"struct doc_notable_trait::Wrapper\\\"&gt;Wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/span&gt;\"}</script>\n\\ No newline at end of file\n+<script type=\"text/json\" id=\"notable-traits-data\">{\"Wrapper&lt;Self&gt;\":\"&lt;h3&gt;Notable traits for &lt;code&gt;&lt;a class=\\\"struct\\\" href=\\\"struct.Wrapper.html\\\" title=\\\"struct doc_notable_trait::Wrapper\\\"&gt;Wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl&amp;lt;T:&amp;nbsp;&lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt;&amp;gt; &lt;a class=\\\"trait\\\" href=\\\"trait.SomeTrait.html\\\" title=\\\"trait doc_notable_trait::SomeTrait\\\"&gt;SomeTrait&lt;/a&gt; for &lt;a class=\\\"struct\\\" href=\\\"struct.Wrapper.html\\\" title=\\\"struct doc_notable_trait::Wrapper\\\"&gt;Wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/span&gt;\"}</script>\n\\ No newline at end of file"}, {"sha": "5f54b7522ae38774e61e4c8cd7c44dc775ad410b", "filename": "tests/rustdoc/spotlight-from-dependency.odd.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/tests%2Frustdoc%2Fspotlight-from-dependency.odd.html", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/tests%2Frustdoc%2Fspotlight-from-dependency.odd.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fspotlight-from-dependency.odd.html?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -1 +1 @@\n-<script type=\"text/json\" id=\"notable-traits-data\">{\"Odd\":\"&lt;h3&gt;Notable traits for &lt;code&gt;&lt;a class=\\\"struct\\\" href=\\\"struct.Odd.html\\\" title=\\\"struct foo::Odd\\\"&gt;Odd&lt;/a&gt;&lt;/code&gt;&lt;/h3&gt;&lt;pre class=\\\"content\\\"&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl &lt;a class=\\\"trait\\\" href=\\\"{{channel}}/core/iter/traits/iterator/trait.Iterator.html\\\" title=\\\"trait core::iter::traits::iterator::Iterator\\\"&gt;Iterator&lt;/a&gt; for &lt;a class=\\\"struct\\\" href=\\\"struct.Odd.html\\\" title=\\\"struct foo::Odd\\\"&gt;Odd&lt;/a&gt;&lt;/span&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;    type &lt;a href=\\\"{{channel}}/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\"&gt;Item&lt;/a&gt; = &lt;a class=\\\"primitive\\\" href=\\\"{{channel}}/std/primitive.usize.html\\\"&gt;usize&lt;/a&gt;;&lt;/span&gt;\"}</script>\n\\ No newline at end of file\n+<script type=\"text/json\" id=\"notable-traits-data\">{\"Odd\":\"&lt;h3&gt;Notable traits for &lt;code&gt;&lt;a class=\\\"struct\\\" href=\\\"struct.Odd.html\\\" title=\\\"struct foo::Odd\\\"&gt;Odd&lt;/a&gt;&lt;/code&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;impl &lt;a class=\\\"trait\\\" href=\\\"{{channel}}/core/iter/traits/iterator/trait.Iterator.html\\\" title=\\\"trait core::iter::traits::iterator::Iterator\\\"&gt;Iterator&lt;/a&gt; for &lt;a class=\\\"struct\\\" href=\\\"struct.Odd.html\\\" title=\\\"struct foo::Odd\\\"&gt;Odd&lt;/a&gt;&lt;/span&gt;&lt;span class=\\\"where fmt-newline\\\"&gt;    type &lt;a href=\\\"{{channel}}/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\\\" class=\\\"associatedtype\\\"&gt;Item&lt;/a&gt; = &lt;a class=\\\"primitive\\\" href=\\\"{{channel}}/std/primitive.usize.html\\\"&gt;usize&lt;/a&gt;;&lt;/span&gt;\"}</script>\n\\ No newline at end of file"}, {"sha": "4c1926387b926a4e843b3e6c5176af7d0b964c95", "filename": "tests/ui/const-generics/unused_braces.fixed", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/tests%2Fui%2Fconst-generics%2Funused_braces.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/tests%2Fui%2Fconst-generics%2Funused_braces.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Funused_braces.fixed?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -2,10 +2,17 @@\n // run-rustfix\n #![warn(unused_braces)]\n \n+macro_rules! make_1 {\n+    () => {\n+        1\n+    }\n+}\n+\n struct A<const N: usize>;\n \n fn main() {\n     let _: A<7>; // ok\n     let _: A<7>; //~ WARN unnecessary braces\n     let _: A<{ 3 + 5 }>; // ok\n+    let _: A<{make_1!()}>; // ok\n }"}, {"sha": "e9f15b401807915c0f85cf7893e8e14d67d60ab0", "filename": "tests/ui/const-generics/unused_braces.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/tests%2Fui%2Fconst-generics%2Funused_braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/tests%2Fui%2Fconst-generics%2Funused_braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Funused_braces.rs?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -2,10 +2,17 @@\n // run-rustfix\n #![warn(unused_braces)]\n \n+macro_rules! make_1 {\n+    () => {\n+        1\n+    }\n+}\n+\n struct A<const N: usize>;\n \n fn main() {\n     let _: A<7>; // ok\n     let _: A<{ 7 }>; //~ WARN unnecessary braces\n     let _: A<{ 3 + 5 }>; // ok\n+    let _: A<{make_1!()}>; // ok\n }"}, {"sha": "2c8031c430020b8f86e38ab53137ab02c3783e30", "filename": "tests/ui/const-generics/unused_braces.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/tests%2Fui%2Fconst-generics%2Funused_braces.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/tests%2Fui%2Fconst-generics%2Funused_braces.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Funused_braces.stderr?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -1,5 +1,5 @@\n warning: unnecessary braces around const expression\n-  --> $DIR/unused_braces.rs:9:14\n+  --> $DIR/unused_braces.rs:15:14\n    |\n LL |     let _: A<{ 7 }>;\n    |              ^^ ^^"}, {"sha": "888c321bc479b8269d1c87b8a22fa8ca7a6be61f", "filename": "tests/ui/inference/cannot-infer-partial-try-return.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/tests%2Fui%2Finference%2Fcannot-infer-partial-try-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/tests%2Fui%2Finference%2Fcannot-infer-partial-try-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finference%2Fcannot-infer-partial-try-return.stderr?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -1,8 +1,6 @@\n error[E0282]: type annotations needed\n   --> $DIR/cannot-infer-partial-try-return.rs:20:9\n    |\n-LL |         infallible()?;\n-   |         ------------- type must be known at this point\n LL |         Ok(())\n    |         ^^ cannot infer type of the type parameter `E` declared on the enum `Result`\n    |"}, {"sha": "a9cb7e5257c83d1db6c8fa8df7e3a1fed7811586", "filename": "tests/ui/inference/question-mark-type-infer.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/tests%2Fui%2Finference%2Fquestion-mark-type-infer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/tests%2Fui%2Finference%2Fquestion-mark-type-infer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finference%2Fquestion-mark-type-infer.stderr?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -1,8 +1,13 @@\n error[E0282]: type annotations needed\n-  --> $DIR/question-mark-type-infer.rs:10:30\n+  --> $DIR/question-mark-type-infer.rs:10:21\n    |\n LL |     l.iter().map(f).collect()?\n-   |                              ^ cannot infer type\n+   |                     ^^^^^^^ cannot infer type of the type parameter `B` declared on the associated function `collect`\n+   |\n+help: consider specifying the generic argument\n+   |\n+LL |     l.iter().map(f).collect::<Vec<_>>()?\n+   |                            ++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "fc343bb54aace29f40aa5fd3cd5e87a2497de3e3", "filename": "tests/ui/issues/issue-69455.stderr", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/tests%2Fui%2Fissues%2Fissue-69455.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/tests%2Fui%2Fissues%2Fissue-69455.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-69455.stderr?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -1,14 +1,16 @@\n-error[E0282]: type annotations needed\n-  --> $DIR/issue-69455.rs:29:20\n+error[E0284]: type annotations needed\n+  --> $DIR/issue-69455.rs:29:41\n    |\n LL |     println!(\"{}\", 23u64.test(xs.iter().sum()));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the associated function `new_display`\n+   |                          ----           ^^^ cannot infer type of the type parameter `S` declared on the associated function `sum`\n+   |                          |\n+   |                          type must be known at this point\n    |\n-   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = note: cannot satisfy `<u64 as Test<_>>::Output == _`\n help: consider specifying the generic argument\n    |\n-LL |     println!(\"{}\", 23u64.test(xs.iter().sum())::<T>);\n-   |                                               +++++\n+LL |     println!(\"{}\", 23u64.test(xs.iter().sum::<S>()));\n+   |                                            +++++\n \n error[E0283]: type annotations needed\n   --> $DIR/issue-69455.rs:29:41\n@@ -33,5 +35,5 @@ LL |     println!(\"{}\", 23u64.test(xs.iter().sum::<S>()));\n \n error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0282, E0283.\n-For more information about an error, try `rustc --explain E0282`.\n+Some errors have detailed explanations: E0283, E0284.\n+For more information about an error, try `rustc --explain E0283`."}, {"sha": "e544b369515489ba17258e2eac2ea7eb50575cb5", "filename": "tests/ui/type/type-check/cannot_infer_local_or_vec_in_tuples.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afaf3e07aaa7ca9873bdb439caec53faffa4230c/tests%2Fui%2Ftype%2Ftype-check%2Fcannot_infer_local_or_vec_in_tuples.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/afaf3e07aaa7ca9873bdb439caec53faffa4230c/tests%2Fui%2Ftype%2Ftype-check%2Fcannot_infer_local_or_vec_in_tuples.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fcannot_infer_local_or_vec_in_tuples.stderr?ref=afaf3e07aaa7ca9873bdb439caec53faffa4230c", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed for `(Vec<T>,)`\n   --> $DIR/cannot_infer_local_or_vec_in_tuples.rs:2:9\n    |\n LL |     let (x, ) = (vec![], );\n-   |         ^^^^^\n+   |         ^^^^^   ---------- type must be known at this point\n    |\n help: consider giving this pattern a type, where the type for type parameter `T` is specified\n    |"}]}