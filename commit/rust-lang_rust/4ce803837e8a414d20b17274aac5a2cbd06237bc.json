{"sha": "4ce803837e8a414d20b17274aac5a2cbd06237bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjZTgwMzgzN2U4YTQxNGQyMGIxNzI3NGFhYzVhMmNiZDA2MjM3YmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-15T07:13:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-15T07:13:02Z"}, "message": "Auto merge of #31648 - jseyfried:fix_diagnostics, r=nrc\n\nThis PR fixes two unrelated diagnostics bugs in resolve.\n\nFirst, it reports privacy errors for an import only after the import resolution is determined, fixing #31402.\n\nSecond, it expands the per-module map from block ids to anonymous modules so that it also maps module declarations ids to modules, and it uses this map to in `with_scope` to fix #31644.\n\nr? @nrc", "tree": {"sha": "9379b6bd619a80ef936e0a9a832e202d91bead59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9379b6bd619a80ef936e0a9a832e202d91bead59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ce803837e8a414d20b17274aac5a2cbd06237bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ce803837e8a414d20b17274aac5a2cbd06237bc", "html_url": "https://github.com/rust-lang/rust/commit/4ce803837e8a414d20b17274aac5a2cbd06237bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ce803837e8a414d20b17274aac5a2cbd06237bc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69ad91290de8416cb309ed303ba0883b12b8017a", "url": "https://api.github.com/repos/rust-lang/rust/commits/69ad91290de8416cb309ed303ba0883b12b8017a", "html_url": "https://github.com/rust-lang/rust/commit/69ad91290de8416cb309ed303ba0883b12b8017a"}, {"sha": "81d5d02c3733772f80fc23d834189bde248d68d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/81d5d02c3733772f80fc23d834189bde248d68d7", "html_url": "https://github.com/rust-lang/rust/commit/81d5d02c3733772f80fc23d834189bde248d68d7"}], "stats": {"total": 135, "additions": 43, "deletions": 92}, "files": [{"sha": "5c94c6e4369b09288f336f9046e8f6310385c1a9", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ce803837e8a414d20b17274aac5a2cbd06237bc/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce803837e8a414d20b17274aac5a2cbd06237bc/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=4ce803837e8a414d20b17274aac5a2cbd06237bc", "patch": "@@ -306,6 +306,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let def = Def::Mod(self.ast_map.local_def_id(item.id));\n                 let module = self.new_module(parent_link, Some(def), false, is_public);\n                 self.define(parent, name, TypeNS, (module, sp));\n+                parent.module_children.borrow_mut().insert(item.id, module);\n                 module\n             }\n \n@@ -474,7 +475,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n             let parent_link = BlockParentLink(parent, block_id);\n             let new_module = self.new_module(parent_link, None, false, false);\n-            parent.anonymous_children.borrow_mut().insert(block_id, new_module);\n+            parent.module_children.borrow_mut().insert(block_id, new_module);\n             new_module\n         } else {\n             parent"}, {"sha": "3244d2f1d96090cfd50249366414b68937d4f4a3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 18, "deletions": 57, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/4ce803837e8a414d20b17274aac5a2cbd06237bc/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce803837e8a414d20b17274aac5a2cbd06237bc/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=4ce803837e8a414d20b17274aac5a2cbd06237bc", "patch": "@@ -798,12 +798,12 @@ pub struct ModuleS<'a> {\n     is_public: bool,\n     is_extern_crate: bool,\n \n-    children: RefCell<HashMap<(Name, Namespace), NameResolution<'a>>>,\n+    resolutions: RefCell<HashMap<(Name, Namespace), NameResolution<'a>>>,\n     imports: RefCell<Vec<ImportDirective>>,\n \n-    // The anonymous children of this node. Anonymous children are pseudo-\n-    // modules that are implicitly created around items contained within\n-    // blocks.\n+    // The module children of this node, including normal modules and anonymous modules.\n+    // Anonymous children are pseudo-modules that are implicitly created around items\n+    // contained within blocks.\n     //\n     // For example, if we have this:\n     //\n@@ -815,7 +815,7 @@ pub struct ModuleS<'a> {\n     //\n     // There will be an anonymous module created around `g` with the ID of the\n     // entry block for `f`.\n-    anonymous_children: RefCell<NodeMap<Module<'a>>>,\n+    module_children: RefCell<NodeMap<Module<'a>>>,\n \n     shadowed_traits: RefCell<Vec<&'a NameBinding<'a>>>,\n \n@@ -846,9 +846,9 @@ impl<'a> ModuleS<'a> {\n             def: def,\n             is_public: is_public,\n             is_extern_crate: false,\n-            children: RefCell::new(HashMap::new()),\n+            resolutions: RefCell::new(HashMap::new()),\n             imports: RefCell::new(Vec::new()),\n-            anonymous_children: RefCell::new(NodeMap()),\n+            module_children: RefCell::new(NodeMap()),\n             shadowed_traits: RefCell::new(Vec::new()),\n             glob_count: Cell::new(0),\n             pub_count: Cell::new(0),\n@@ -863,7 +863,7 @@ impl<'a> ModuleS<'a> {\n         let glob_count =\n             if allow_private_imports { self.glob_count.get() } else { self.pub_glob_count.get() };\n \n-        self.children.borrow().get(&(name, ns)).cloned().unwrap_or_default().result(glob_count)\n+        self.resolutions.borrow().get(&(name, ns)).cloned().unwrap_or_default().result(glob_count)\n             .and_then(|binding| {\n                 let allowed = allow_private_imports || !binding.is_import() || binding.is_public();\n                 if allowed { Success(binding) } else { Failed(None) }\n@@ -873,7 +873,7 @@ impl<'a> ModuleS<'a> {\n     // Define the name or return the existing binding if there is a collision.\n     fn try_define_child(&self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>)\n                         -> Result<(), &'a NameBinding<'a>> {\n-        let mut children = self.children.borrow_mut();\n+        let mut children = self.resolutions.borrow_mut();\n         let resolution = children.entry((name, ns)).or_insert_with(Default::default);\n \n         // FIXME #31379: We can use methods from imported traits shadowed by non-import items\n@@ -889,31 +889,23 @@ impl<'a> ModuleS<'a> {\n     }\n \n     fn increment_outstanding_references_for(&self, name: Name, ns: Namespace) {\n-        let mut children = self.children.borrow_mut();\n+        let mut children = self.resolutions.borrow_mut();\n         children.entry((name, ns)).or_insert_with(Default::default).outstanding_references += 1;\n     }\n \n     fn decrement_outstanding_references_for(&self, name: Name, ns: Namespace) {\n-        match self.children.borrow_mut().get_mut(&(name, ns)).unwrap().outstanding_references {\n+        match self.resolutions.borrow_mut().get_mut(&(name, ns)).unwrap().outstanding_references {\n             0 => panic!(\"No more outstanding references!\"),\n             ref mut outstanding_references => { *outstanding_references -= 1; }\n         }\n     }\n \n     fn for_each_child<F: FnMut(Name, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) {\n-        for (&(name, ns), name_resolution) in self.children.borrow().iter() {\n+        for (&(name, ns), name_resolution) in self.resolutions.borrow().iter() {\n             name_resolution.binding.map(|binding| f(name, ns, binding));\n         }\n     }\n \n-    fn for_each_local_child<F: FnMut(Name, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) {\n-        self.for_each_child(|name, ns, name_binding| {\n-            if !name_binding.is_import() && !name_binding.is_extern_crate() {\n-                f(name, ns, name_binding)\n-            }\n-        })\n-    }\n-\n     fn def_id(&self) -> Option<DefId> {\n         self.def.as_ref().map(Def::def_id)\n     }\n@@ -1640,20 +1632,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         // Descend into children and anonymous children.\n-        build_reduced_graph::populate_module_if_necessary(self, module_);\n-\n-        module_.for_each_local_child(|_, _, child_node| {\n-            match child_node.module() {\n-                None => {\n-                    // Continue.\n-                }\n-                Some(child_module) => {\n-                    self.report_unresolved_imports(child_module);\n-                }\n-            }\n-        });\n-\n-        for (_, module_) in module_.anonymous_children.borrow().iter() {\n+        for (_, module_) in module_.module_children.borrow().iter() {\n             self.report_unresolved_imports(module_);\n         }\n     }\n@@ -1676,32 +1655,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     // generate a fake \"implementation scope\" containing all the\n     // implementations thus found, for compatibility with old resolve pass.\n \n-    fn with_scope<F>(&mut self, name: Option<Name>, f: F)\n+    fn with_scope<F>(&mut self, id: NodeId, f: F)\n         where F: FnOnce(&mut Resolver)\n     {\n         let orig_module = self.current_module;\n \n         // Move down in the graph.\n-        match name {\n-            None => {\n-                // Nothing to do.\n-            }\n-            Some(name) => {\n-                build_reduced_graph::populate_module_if_necessary(self, &orig_module);\n-\n-                if let Success(name_binding) = orig_module.resolve_name(name, TypeNS, false) {\n-                    match name_binding.module() {\n-                        None => {\n-                            debug!(\"!!! (with scope) didn't find module for `{}` in `{}`\",\n-                                   name,\n-                                   module_to_string(orig_module));\n-                        }\n-                        Some(module) => {\n-                            self.current_module = module;\n-                        }\n-                    }\n-                }\n-            }\n+        if let Some(module) = orig_module.module_children.borrow().get(&id) {\n+            self.current_module = module;\n         }\n \n         f(self);\n@@ -1825,7 +1786,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             ItemMod(_) | ItemForeignMod(_) => {\n-                self.with_scope(Some(name), |this| {\n+                self.with_scope(item.id, |this| {\n                     intravisit::walk_item(this, item);\n                 });\n             }\n@@ -2261,7 +2222,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Move down in the graph, if there's an anonymous module rooted here.\n         let orig_module = self.current_module;\n         let anonymous_module =\n-            orig_module.anonymous_children.borrow().get(&block.id).map(|module| *module);\n+            orig_module.module_children.borrow().get(&block.id).map(|module| *module);\n \n         if let Some(anonymous_module) = anonymous_module {\n             debug!(\"(resolving block) found anonymous module, moving down\");"}, {"sha": "1253d4f9ceff055ed7f04d1388d4c67b2f3aacea", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 18, "deletions": 30, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4ce803837e8a414d20b17274aac5a2cbd06237bc/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce803837e8a414d20b17274aac5a2cbd06237bc/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=4ce803837e8a414d20b17274aac5a2cbd06237bc", "patch": "@@ -243,19 +243,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         errors.extend(self.resolve_imports_for_module(module_));\n         self.resolver.current_module = orig_module;\n \n-        build_reduced_graph::populate_module_if_necessary(self.resolver, module_);\n-        module_.for_each_local_child(|_, _, child_node| {\n-            match child_node.module() {\n-                None => {\n-                    // Nothing to do.\n-                }\n-                Some(child_module) => {\n-                    errors.extend(self.resolve_imports_for_module_subtree(child_module));\n-                }\n-            }\n-        });\n-\n-        for (_, child_module) in module_.anonymous_children.borrow().iter() {\n+        for (_, child_module) in module_.module_children.borrow().iter() {\n             errors.extend(self.resolve_imports_for_module_subtree(child_module));\n         }\n \n@@ -403,6 +391,23 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             module_.increment_outstanding_references_for(target, TypeNS);\n         }\n \n+        match (&value_result, &type_result) {\n+            (&Indeterminate, _) | (_, &Indeterminate) => return Indeterminate,\n+            (&Failed(_), &Failed(_)) => {\n+                let children = target_module.resolutions.borrow();\n+                let names = children.keys().map(|&(ref name, _)| name);\n+                let lev_suggestion = match find_best_match_for_name(names, &source.as_str(), None) {\n+                    Some(name) => format!(\". Did you mean to use `{}`?\", name),\n+                    None => \"\".to_owned(),\n+                };\n+                let msg = format!(\"There is no `{}` in `{}`{}\",\n+                                  source,\n+                                  module_to_string(target_module), lev_suggestion);\n+                return Failed(Some((directive.span, msg)));\n+            }\n+            _ => (),\n+        }\n+\n         match (&value_result, &type_result) {\n             (&Success(name_binding), _) if !name_binding.is_import() &&\n                                            directive.is_public &&\n@@ -437,23 +442,6 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             _ => {}\n         }\n \n-        match (&value_result, &type_result) {\n-            (&Indeterminate, _) | (_, &Indeterminate) => return Indeterminate,\n-            (&Failed(_), &Failed(_)) => {\n-                let children = target_module.children.borrow();\n-                let names = children.keys().map(|&(ref name, _)| name);\n-                let lev_suggestion = match find_best_match_for_name(names, &source.as_str(), None) {\n-                    Some(name) => format!(\". Did you mean to use `{}`?\", name),\n-                    None => \"\".to_owned(),\n-                };\n-                let msg = format!(\"There is no `{}` in `{}`{}\",\n-                                  source,\n-                                  module_to_string(target_module), lev_suggestion);\n-                return Failed(Some((directive.span, msg)));\n-            }\n-            _ => (),\n-        }\n-\n         for &(ns, result) in &[(ValueNS, &value_result), (TypeNS, &type_result)] {\n             if let Success(binding) = *result {\n                 if !binding.defined_with(DefModifiers::IMPORTABLE) {"}, {"sha": "28e969b21498a6cce2fbaa9b4b6e19cb174de748", "filename": "src/test/compile-fail/enum-and-module-in-same-scope.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4ce803837e8a414d20b17274aac5a2cbd06237bc/src%2Ftest%2Fcompile-fail%2Fenum-and-module-in-same-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ce803837e8a414d20b17274aac5a2cbd06237bc/src%2Ftest%2Fcompile-fail%2Fenum-and-module-in-same-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-and-module-in-same-scope.rs?ref=4ce803837e8a414d20b17274aac5a2cbd06237bc", "patch": "@@ -8,12 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-mod Foo {\n-    pub static X: isize = 42;\n+enum Foo {\n+    X\n }\n \n-enum Foo {  //~ ERROR duplicate definition of type or module `Foo`\n-    X\n+mod Foo { //~ ERROR duplicate definition of type or module `Foo`\n+    pub static X: isize = 42;\n+    fn f() { f() } // Check that this does not result in a resolution error\n }\n \n fn main() {}"}]}