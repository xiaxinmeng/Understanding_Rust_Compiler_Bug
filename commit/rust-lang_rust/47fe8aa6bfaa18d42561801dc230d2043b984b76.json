{"sha": "47fe8aa6bfaa18d42561801dc230d2043b984b76", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3ZmU4YWE2YmZhYTE4ZDQyNTYxODAxZGMyMzBkMjA0M2I5ODRiNzY=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-07-02T16:39:48Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-07-09T07:06:29Z"}, "message": "lexer: shuffle around some functions", "tree": {"sha": "4f07165421bc19c1a1150cbfe4eae9ffc93e23bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f07165421bc19c1a1150cbfe4eae9ffc93e23bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47fe8aa6bfaa18d42561801dc230d2043b984b76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47fe8aa6bfaa18d42561801dc230d2043b984b76", "html_url": "https://github.com/rust-lang/rust/commit/47fe8aa6bfaa18d42561801dc230d2043b984b76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47fe8aa6bfaa18d42561801dc230d2043b984b76/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f970e690f2ca7ddb7884b6b8752baf3771ad459", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f970e690f2ca7ddb7884b6b8752baf3771ad459", "html_url": "https://github.com/rust-lang/rust/commit/5f970e690f2ca7ddb7884b6b8752baf3771ad459"}], "stats": {"total": 199, "additions": 100, "deletions": 99}, "files": [{"sha": "f22e7af08564f1720af927afd4a0489e3b89a5fe", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 100, "deletions": 99, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/47fe8aa6bfaa18d42561801dc230d2043b984b76/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47fe8aa6bfaa18d42561801dc230d2043b984b76/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=47fe8aa6bfaa18d42561801dc230d2043b984b76", "patch": "@@ -969,108 +969,12 @@ impl<'a> StringReader<'a> {\n           'b' => {\n             self.bump();\n             return match self.curr {\n-                Some('\\'') => parse_byte(self),\n-                Some('\"') => parse_byte_string(self),\n-                Some('r') => parse_raw_byte_string(self),\n+                Some('\\'') => self.scan_byte(),\n+                Some('\"') => self.scan_byte_string(),\n+                Some('r') => self.scan_raw_byte_string(),\n                 _ => unreachable!()  // Should have been a token::IDENT above.\n             };\n \n-            fn parse_byte(self_: &mut StringReader) -> token::Token {\n-                self_.bump();\n-                let start = self_.last_pos;\n-\n-                // the eof will be picked up by the final `'` check below\n-                let mut c2 = self_.curr.unwrap_or('\\x00');\n-                self_.bump();\n-\n-                c2 = self_.scan_char_or_byte(start, c2, /* ascii_only = */ true, '\\'').unwrap();\n-                if !self_.curr_is('\\'') {\n-                    // Byte offsetting here is okay because the\n-                    // character before position `start` are an\n-                    // ascii single quote and ascii 'b'.\n-                    let last_pos = self_.last_pos;\n-                    self_.fatal_span_verbose(\n-                        start - BytePos(2), last_pos,\n-                        \"unterminated byte constant\".to_string());\n-                }\n-                self_.bump(); // advance curr past token\n-                return token::LIT_BYTE(c2 as u8);\n-            }\n-\n-            fn parse_byte_string(self_: &mut StringReader) -> token::Token {\n-                self_.bump();\n-                let start = self_.last_pos;\n-                let mut value = Vec::new();\n-                while !self_.curr_is('\"') {\n-                    if self_.is_eof() {\n-                        let last_pos = self_.last_pos;\n-                        self_.fatal_span_(start, last_pos,\n-                                          \"unterminated double quote byte string\");\n-                    }\n-\n-                    let ch_start = self_.last_pos;\n-                    let ch = self_.curr.unwrap();\n-                    self_.bump();\n-                    self_.scan_char_or_byte(ch_start, ch, /* ascii_only = */ true, '\"')\n-                        .map(|ch| value.push(ch as u8));\n-                }\n-                self_.bump();\n-                return token::LIT_BINARY(Rc::new(value));\n-            }\n-\n-            fn parse_raw_byte_string(self_: &mut StringReader) -> token::Token {\n-                let start_bpos = self_.last_pos;\n-                self_.bump();\n-                let mut hash_count = 0u;\n-                while self_.curr_is('#') {\n-                    self_.bump();\n-                    hash_count += 1;\n-                }\n-\n-                if self_.is_eof() {\n-                    let last_pos = self_.last_pos;\n-                    self_.fatal_span_(start_bpos, last_pos, \"unterminated raw string\");\n-                } else if !self_.curr_is('\"') {\n-                    let last_pos = self_.last_pos;\n-                    let ch = self_.curr.unwrap();\n-                    self_.fatal_span_char(start_bpos, last_pos,\n-                                    \"only `#` is allowed in raw string delimitation; \\\n-                                     found illegal character\",\n-                                    ch);\n-                }\n-                self_.bump();\n-                let content_start_bpos = self_.last_pos;\n-                let mut content_end_bpos;\n-                'outer: loop {\n-                    match self_.curr {\n-                        None => {\n-                            let last_pos = self_.last_pos;\n-                            self_.fatal_span_(start_bpos, last_pos, \"unterminated raw string\")\n-                        },\n-                        Some('\"') => {\n-                            content_end_bpos = self_.last_pos;\n-                            for _ in range(0, hash_count) {\n-                                self_.bump();\n-                                if !self_.curr_is('#') {\n-                                    continue 'outer;\n-                                }\n-                            }\n-                            break;\n-                        },\n-                        Some(c) => if c > '\\x7F' {\n-                            let last_pos = self_.last_pos;\n-                            self_.err_span_char(\n-                                last_pos, last_pos, \"raw byte string must be ASCII\", c);\n-                        }\n-                    }\n-                    self_.bump();\n-                }\n-                self_.bump();\n-                let bytes = self_.with_str_from_to(content_start_bpos,\n-                                                   content_end_bpos,\n-                                                   |s| s.as_bytes().to_owned());\n-                return token::LIT_BINARY_RAW(Rc::new(bytes), hash_count);\n-            }\n           }\n           '\"' => {\n             let mut accum_str = String::new();\n@@ -1221,6 +1125,103 @@ impl<'a> StringReader<'a> {\n      // consider shebangs comments, but not inner attributes\n      || (self.curr_is('#') && self.nextch_is('!') && !self.nextnextch_is('['))\n     }\n+\n+    fn scan_byte(&mut self) -> token::Token {\n+        self.bump();\n+        let start = self.last_pos;\n+\n+        // the eof will be picked up by the final `'` check below\n+        let mut c2 = self.curr.unwrap_or('\\x00');\n+        self.bump();\n+\n+        c2 = self.scan_char_or_byte(start, c2, /* ascii_only = */ true, '\\'').unwrap();\n+        if !self.curr_is('\\'') {\n+            // Byte offsetting here is okay because the\n+            // character before position `start` are an\n+            // ascii single quote and ascii 'b'.\n+            let last_pos = self.last_pos;\n+            self.fatal_span_verbose(\n+                start - BytePos(2), last_pos,\n+                \"unterminated byte constant\".to_string());\n+        }\n+        self.bump(); // advance curr past token\n+        return token::LIT_BYTE(c2 as u8);\n+    }\n+\n+    fn scan_byte_string(&mut self) -> token::Token {\n+        self.bump();\n+        let start = self.last_pos;\n+        let mut value = Vec::new();\n+        while !self.curr_is('\"') {\n+            if self.is_eof() {\n+                let last_pos = self.last_pos;\n+                self.fatal_span_(start, last_pos,\n+                                  \"unterminated double quote byte string\");\n+            }\n+\n+            let ch_start = self.last_pos;\n+            let ch = self.curr.unwrap();\n+            self.bump();\n+            self.scan_char_or_byte(ch_start, ch, /* ascii_only = */ true, '\"')\n+                .map(|ch| value.push(ch as u8));\n+        }\n+        self.bump();\n+        return token::LIT_BINARY(Rc::new(value));\n+    }\n+\n+    fn scan_raw_byte_string(&mut self) -> token::Token {\n+        let start_bpos = self.last_pos;\n+        self.bump();\n+        let mut hash_count = 0u;\n+        while self.curr_is('#') {\n+            self.bump();\n+            hash_count += 1;\n+        }\n+\n+        if self.is_eof() {\n+            let last_pos = self.last_pos;\n+            self.fatal_span_(start_bpos, last_pos, \"unterminated raw string\");\n+        } else if !self.curr_is('\"') {\n+            let last_pos = self.last_pos;\n+            let ch = self.curr.unwrap();\n+            self.fatal_span_char(start_bpos, last_pos,\n+                            \"only `#` is allowed in raw string delimitation; \\\n+                             found illegal character\",\n+                            ch);\n+        }\n+        self.bump();\n+        let content_start_bpos = self.last_pos;\n+        let mut content_end_bpos;\n+        'outer: loop {\n+            match self.curr {\n+                None => {\n+                    let last_pos = self.last_pos;\n+                    self.fatal_span_(start_bpos, last_pos, \"unterminated raw string\")\n+                },\n+                Some('\"') => {\n+                    content_end_bpos = self.last_pos;\n+                    for _ in range(0, hash_count) {\n+                        self.bump();\n+                        if !self.curr_is('#') {\n+                            continue 'outer;\n+                        }\n+                    }\n+                    break;\n+                },\n+                Some(c) => if c > '\\x7F' {\n+                    let last_pos = self.last_pos;\n+                    self.err_span_char(\n+                        last_pos, last_pos, \"raw byte string must be ASCII\", c);\n+                }\n+            }\n+            self.bump();\n+        }\n+        self.bump();\n+        let bytes = self.with_str_from_to(content_start_bpos,\n+                                           content_end_bpos,\n+                                           |s| s.as_bytes().to_owned());\n+        return token::LIT_BINARY_RAW(Rc::new(bytes), hash_count);\n+    }\n }\n \n pub fn is_whitespace(c: Option<char>) -> bool {"}]}