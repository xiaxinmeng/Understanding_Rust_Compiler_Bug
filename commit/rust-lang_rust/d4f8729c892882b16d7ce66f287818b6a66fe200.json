{"sha": "d4f8729c892882b16d7ce66f287818b6a66fe200", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0Zjg3MjljODkyODgyYjE2ZDdjZTY2ZjI4NzgxOGI2YTY2ZmUyMDA=", "commit": {"author": {"name": "Roxane", "email": "roxane.fruytier@hotmail.com", "date": "2021-02-19T00:02:07Z"}, "committer": {"name": "Roxane", "email": "roxane.fruytier@hotmail.com", "date": "2021-03-14T21:07:58Z"}, "message": "Delay use of Place in favor of PlaceBuilder", "tree": {"sha": "9977a86846fbfcb331a64aff853fb5e785b5b55d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9977a86846fbfcb331a64aff853fb5e785b5b55d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4f8729c892882b16d7ce66f287818b6a66fe200", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4f8729c892882b16d7ce66f287818b6a66fe200", "html_url": "https://github.com/rust-lang/rust/commit/d4f8729c892882b16d7ce66f287818b6a66fe200", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4f8729c892882b16d7ce66f287818b6a66fe200/comments", "author": {"login": "roxelo", "id": 12419401, "node_id": "MDQ6VXNlcjEyNDE5NDAx", "avatar_url": "https://avatars.githubusercontent.com/u/12419401?v=4", "gravatar_id": "", "url": "https://api.github.com/users/roxelo", "html_url": "https://github.com/roxelo", "followers_url": "https://api.github.com/users/roxelo/followers", "following_url": "https://api.github.com/users/roxelo/following{/other_user}", "gists_url": "https://api.github.com/users/roxelo/gists{/gist_id}", "starred_url": "https://api.github.com/users/roxelo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/roxelo/subscriptions", "organizations_url": "https://api.github.com/users/roxelo/orgs", "repos_url": "https://api.github.com/users/roxelo/repos", "events_url": "https://api.github.com/users/roxelo/events{/privacy}", "received_events_url": "https://api.github.com/users/roxelo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "roxelo", "id": 12419401, "node_id": "MDQ6VXNlcjEyNDE5NDAx", "avatar_url": "https://avatars.githubusercontent.com/u/12419401?v=4", "gravatar_id": "", "url": "https://api.github.com/users/roxelo", "html_url": "https://github.com/roxelo", "followers_url": "https://api.github.com/users/roxelo/followers", "following_url": "https://api.github.com/users/roxelo/following{/other_user}", "gists_url": "https://api.github.com/users/roxelo/gists{/gist_id}", "starred_url": "https://api.github.com/users/roxelo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/roxelo/subscriptions", "organizations_url": "https://api.github.com/users/roxelo/orgs", "repos_url": "https://api.github.com/users/roxelo/repos", "events_url": "https://api.github.com/users/roxelo/events{/privacy}", "received_events_url": "https://api.github.com/users/roxelo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec10b71d42ace3c3d57c3d44bc1007badcd58ee8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8", "html_url": "https://github.com/rust-lang/rust/commit/ec10b71d42ace3c3d57c3d44bc1007badcd58ee8"}], "stats": {"total": 215, "additions": 139, "deletions": 76}, "files": [{"sha": "ae4d6b56152c5d2eeac8367034f99bd720ff7dcc", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d4f8729c892882b16d7ce66f287818b6a66fe200/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4f8729c892882b16d7ce66f287818b6a66fe200/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=d4f8729c892882b16d7ce66f287818b6a66fe200", "patch": "@@ -94,6 +94,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         )\n                     );\n                 }\n+                // ROX:\n+                //\n+                // Where the handling of destructure patterns start\n+                //\n+                // let (a, b, c, _ ) = something\n+                //\n+                // (a, b, c, _) is the pattern\n+                // something is the initializer\n                 StmtKind::Let { remainder_scope, init_scope, pattern, initializer, lint_level } => {\n                     let ignores_expr_result = matches!(*pattern.kind, PatKind::Wild);\n                     this.block_context.push(BlockFrame::Statement { ignores_expr_result });\n@@ -125,6 +133,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                             ArmHasGuard(false),\n                                             Some((None, initializer_span)),\n                                         );\n+                                        // This is where we get into pattern handling of the let\n+                                        // statement\n                                         this.expr_into_pattern(block, pattern.clone(), init)\n                                     })\n                                 }"}, {"sha": "f819a638c7aa0fff8233be40a6a2508d2a667935", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d4f8729c892882b16d7ce66f287818b6a66fe200/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4f8729c892882b16d7ce66f287818b6a66fe200/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=d4f8729c892882b16d7ce66f287818b6a66fe200", "patch": "@@ -10,14 +10,15 @@ use rustc_middle::hir::place::ProjectionKind as HirProjectionKind;\n use rustc_middle::middle::region;\n use rustc_middle::mir::AssertKind::BoundsCheck;\n use rustc_middle::mir::*;\n+use rustc_middle::ty::AdtDef;\n use rustc_middle::ty::{self, CanonicalUserTypeAnnotation, Ty, TyCtxt, Variance};\n use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n \n use rustc_index::vec::Idx;\n \n /// The \"outermost\" place that holds this value.\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n crate enum PlaceBase {\n     /// Denotes the start of a `Place`.\n     Local(Local),\n@@ -67,7 +68,7 @@ crate enum PlaceBase {\n ///\n /// This is used internally when building a place for an expression like `a.b.c`. The fields `b`\n /// and `c` can be progressively pushed onto the place builder that is created when converting `a`.\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, PartialEq)]\n crate struct PlaceBuilder<'tcx> {\n     base: PlaceBase,\n     projection: Vec<PlaceElem<'tcx>>,\n@@ -292,6 +293,7 @@ impl<'tcx> PlaceBuilder<'tcx> {\n         }\n     }\n \n+    /// ROX: Function that will be called when we really do need a place\n     fn expect_upvars_resolved<'a>(\n         self,\n         tcx: TyCtxt<'tcx>,\n@@ -319,15 +321,22 @@ impl<'tcx> PlaceBuilder<'tcx> {\n         self.project(PlaceElem::Field(f, ty))\n     }\n \n-    fn deref(self) -> Self {\n+    crate fn deref(self) -> Self {\n         self.project(PlaceElem::Deref)\n     }\n \n+    crate fn downcast(self, adt_def: &'tcx AdtDef, variant_index: VariantIdx) -> Self {\n+        self.project(PlaceElem::Downcast(\n+            Some(adt_def.variants[variant_index].ident.name),\n+            variant_index,\n+        ))\n+    }\n+\n     fn index(self, index: Local) -> Self {\n         self.project(PlaceElem::Index(index))\n     }\n \n-    fn project(mut self, elem: PlaceElem<'tcx>) -> Self {\n+    crate fn project(mut self, elem: PlaceElem<'tcx>) -> Self {\n         self.projection.push(elem);\n         self\n     }\n@@ -367,6 +376,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         block.and(place_builder.into_place(self.tcx, self.typeck_results))\n     }\n \n+    // ROX: As place builder\n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n     /// intermediate `Place` values until we know the full set of projections.\n     crate fn as_place_builder(\n@@ -613,13 +623,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // The \"retagging\" transformation (for Stacked Borrows) relies on this.\n         let idx = unpack!(block = self.as_temp(block, temp_lifetime, index, Mutability::Not,));\n \n-        block = self.bounds_check(\n-            block,\n-            base_place.clone().into_place(self.tcx, self.typeck_results),\n-            idx,\n-            expr_span,\n-            source_info,\n-        );\n+        block = self.bounds_check(block, base_place.clone(), idx, expr_span, source_info);\n \n         if is_outermost_index {\n             self.read_fake_borrows(block, fake_borrow_temps, source_info)\n@@ -640,7 +644,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn bounds_check(\n         &mut self,\n         block: BasicBlock,\n-        slice: Place<'tcx>,\n+        slice: PlaceBuilder<'tcx>,\n         index: Local,\n         expr_span: Span,\n         source_info: SourceInfo,\n@@ -652,7 +656,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let lt = self.temp(bool_ty, expr_span);\n \n         // len = len(slice)\n-        self.cfg.push_assign(block, source_info, len, Rvalue::Len(slice));\n+        self.cfg.push_assign(\n+            block,\n+            source_info,\n+            len,\n+            Rvalue::Len(slice.clone().into_place(self.tcx, self.typeck_results)),\n+        );\n         // lt = idx < len\n         self.cfg.push_assign(\n             block,"}, {"sha": "e0ad34e08efd45a19fee2715f64fd82d25a383b0", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d4f8729c892882b16d7ce66f287818b6a66fe200/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4f8729c892882b16d7ce66f287818b6a66fe200/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=d4f8729c892882b16d7ce66f287818b6a66fe200", "patch": "@@ -280,6 +280,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let field_names: Vec<_> =\n                     (0..adt_def.variants[variant_index].fields.len()).map(Field::new).collect();\n \n+                // ROX: This is probably here the function record/struct update pattern is done.\n                 let fields: Vec<_> = if let Some(FruInfo { base, field_types }) = base {\n                     let place_builder = unpack!(block = this.as_place_builder(block, base));\n "}, {"sha": "539de80cab71cae30d19ae47e07183f47ae648f4", "filename": "compiler/rustc_mir_build/src/build/expr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4f8729c892882b16d7ce66f287818b6a66fe200/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4f8729c892882b16d7ce66f287818b6a66fe200/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fmod.rs?ref=d4f8729c892882b16d7ce66f287818b6a66fe200", "patch": "@@ -62,7 +62,7 @@\n \n mod as_constant;\n mod as_operand;\n-mod as_place;\n+pub mod as_place;\n mod as_rvalue;\n mod as_temp;\n mod category;"}, {"sha": "7285cf756234df1592142ce15d1704d547dbeca6", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 56, "deletions": 28, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/d4f8729c892882b16d7ce66f287818b6a66fe200/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4f8729c892882b16d7ce66f287818b6a66fe200/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=d4f8729c892882b16d7ce66f287818b6a66fe200", "patch": "@@ -1,10 +1,14 @@\n+// ROX: this folder contains all code for handling patterns, including exhaustiveness checking etc.\n+// We want to be careful ^^'\n+\n //! Code related to match expressions. These are sufficiently complex to\n //! warrant their own module and submodules. :) This main module includes the\n //! high-level algorithm, the submodules contain the details.\n //!\n //! This also includes code for pattern bindings in `let` statements and\n //! function parameters.\n \n+use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::scope::DropKind;\n use crate::build::ForGuard::{self, OutsideGuard, RefWithinGuard};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n@@ -96,7 +100,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let scrutinee_place =\n             unpack!(block = self.lower_scrutinee(block, scrutinee, scrutinee_span,));\n \n-        let mut arm_candidates = self.create_match_candidates(scrutinee_place, &arms);\n+        let mut arm_candidates = self.create_match_candidates(scrutinee_place.clone(), &arms);\n \n         let match_has_guard = arms.iter().any(|arm| arm.guard.is_some());\n         let mut candidates =\n@@ -121,8 +125,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         mut block: BasicBlock,\n         scrutinee: &Expr<'_, 'tcx>,\n         scrutinee_span: Span,\n-    ) -> BlockAnd<Place<'tcx>> {\n-        let scrutinee_place = unpack!(block = self.as_place(block, scrutinee));\n+    ) -> BlockAnd<PlaceBuilder<'tcx>> {\n+        let scrutinee_place_builder = unpack!(block = self.as_place_builder(block, scrutinee));\n+        let scrutinee_place =\n+            scrutinee_place_builder.clone().into_place(self.tcx, self.typeck_results);\n         // Matching on a `scrutinee_place` with an uninhabited type doesn't\n         // generate any memory reads by itself, and so if the place \"expression\"\n         // contains unsafe operations like raw pointer dereferences or union\n@@ -142,21 +148,21 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let source_info = self.source_info(scrutinee_span);\n         self.cfg.push_fake_read(block, source_info, cause_matched_place, scrutinee_place);\n \n-        block.and(scrutinee_place)\n+        block.and(scrutinee_place_builder)\n     }\n \n     /// Create the initial `Candidate`s for a `match` expression.\n     fn create_match_candidates<'pat>(\n         &mut self,\n-        scrutinee: Place<'tcx>,\n+        scrutinee: PlaceBuilder<'tcx>,\n         arms: &'pat [Arm<'pat, 'tcx>],\n     ) -> Vec<(&'pat Arm<'pat, 'tcx>, Candidate<'pat, 'tcx>)> {\n         // Assemble a list of candidates: there is one candidate per pattern,\n         // which means there may be more than one candidate *per arm*.\n         arms.iter()\n             .map(|arm| {\n                 let arm_has_guard = arm.guard.is_some();\n-                let arm_candidate = Candidate::new(scrutinee, &arm.pattern, arm_has_guard);\n+                let arm_candidate = Candidate::new(scrutinee.clone(), &arm.pattern, arm_has_guard);\n                 (arm, arm_candidate)\n             })\n             .collect()\n@@ -222,7 +228,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn lower_match_arms(\n         &mut self,\n         destination: Place<'tcx>,\n-        scrutinee_place: Place<'tcx>,\n+        scrutinee_place: PlaceBuilder<'tcx>,\n         scrutinee_span: Span,\n         arm_candidates: Vec<(&'_ Arm<'_, 'tcx>, Candidate<'_, 'tcx>)>,\n         outer_source_info: SourceInfo,\n@@ -241,7 +247,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         arm.span,\n                         &arm.pattern,\n                         ArmHasGuard(arm.guard.is_some()),\n-                        Some((Some(&scrutinee_place), scrutinee_span)),\n+                        Some((\n+                            Some(\n+                                &scrutinee_place.clone().into_place(this.tcx, this.typeck_results),\n+                            ),\n+                            scrutinee_span,\n+                        )),\n                     );\n \n                     let arm_block = this.bind_pattern(\n@@ -446,8 +457,17 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             _ => {\n-                let place = unpack!(block = self.as_place(block, initializer));\n-                self.place_into_pattern(block, irrefutable_pat, place, true)\n+                // Converts the destruct pattern into a place\n+                //\n+                // We don't want to convert to a place right away\n+                // because in case of such pattern inside a closure, the projections matching a\n+                // captured place might have not been applied.\n+                // [FIXME] Need to find where this is happening and make the necessary changes there once\n+                // Candidate is modified\n+                //\n+                // We want to use a place builder; Maybe use `as_place_builder`\n+                let place_builder = unpack!(block = self.as_place_builder(block, initializer));\n+                self.place_into_pattern(block, irrefutable_pat, place_builder, true)\n             }\n         }\n     }\n@@ -456,9 +476,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         block: BasicBlock,\n         irrefutable_pat: Pat<'tcx>,\n-        initializer: Place<'tcx>,\n+        initializer: PlaceBuilder<'tcx>,\n         set_match_place: bool,\n     ) -> BlockAnd<()> {\n+        let place = initializer.clone().into_place(self.tcx, self.typeck_results);\n         let mut candidate = Candidate::new(initializer, &irrefutable_pat, false);\n \n         let fake_borrow_temps =\n@@ -478,7 +499,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         VarBindingForm { opt_match_place: Some((ref mut match_place, _)), .. },\n                     )))) = self.local_decls[local].local_info\n                     {\n-                        *match_place = Some(initializer);\n+                        *match_place = Some(place);\n                     } else {\n                         bug!(\"Let binding to non-user variable.\")\n                     }\n@@ -717,7 +738,7 @@ struct Candidate<'pat, 'tcx> {\n }\n \n impl<'tcx, 'pat> Candidate<'pat, 'tcx> {\n-    fn new(place: Place<'tcx>, pattern: &'pat Pat<'tcx>, has_guard: bool) -> Self {\n+    fn new(place: PlaceBuilder<'tcx>, pattern: &'pat Pat<'tcx>, has_guard: bool) -> Self {\n         Candidate {\n             span: pattern.span,\n             has_guard,\n@@ -791,7 +812,7 @@ struct Ascription<'tcx> {\n #[derive(Clone, Debug)]\n crate struct MatchPair<'pat, 'tcx> {\n     // this place...\n-    place: Place<'tcx>,\n+    place: PlaceBuilder<'tcx>,\n \n     // ... must match this pattern.\n     pattern: &'pat Pat<'tcx>,\n@@ -1198,7 +1219,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         &mut otherwise,\n                         pats,\n                         or_span,\n-                        place,\n+                        place.clone(),\n                         fake_borrows,\n                     );\n                 });\n@@ -1224,12 +1245,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         otherwise: &mut Option<BasicBlock>,\n         pats: &'pat [Pat<'tcx>],\n         or_span: Span,\n-        place: Place<'tcx>,\n+        place: PlaceBuilder<'tcx>,\n         fake_borrows: &mut Option<FxHashSet<Place<'tcx>>>,\n     ) {\n         debug!(\"test_or_pattern:\\ncandidate={:#?}\\npats={:#?}\", candidate, pats);\n-        let mut or_candidates: Vec<_> =\n-            pats.iter().map(|pat| Candidate::new(place, pat, candidate.has_guard)).collect();\n+        let mut or_candidates: Vec<_> = pats\n+            .iter()\n+            .map(|pat| Candidate::new(place.clone(), pat, candidate.has_guard))\n+            .collect();\n         let mut or_candidate_refs: Vec<_> = or_candidates.iter_mut().collect();\n         let otherwise = if candidate.otherwise_block.is_some() {\n             &mut candidate.otherwise_block\n@@ -1412,7 +1435,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // extract the match-pair from the highest priority candidate\n         let match_pair = &candidates.first().unwrap().match_pairs[0];\n         let mut test = self.test(match_pair);\n-        let match_place = match_pair.place;\n+        let match_place = match_pair.place.clone();\n \n         // most of the time, the test to perform is simply a function\n         // of the main candidate; but for a test like SwitchInt, we\n@@ -1428,7 +1451,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n             TestKind::Switch { adt_def: _, ref mut variants } => {\n                 for candidate in candidates.iter() {\n-                    if !self.add_variants_to_switch(&match_place, candidate, variants) {\n+                    if !self.add_variants_to_switch(&match_place.clone(), candidate, variants) {\n                         break;\n                     }\n                 }\n@@ -1438,7 +1461,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         // Insert a Shallow borrow of any places that is switched on.\n         if let Some(fb) = fake_borrows {\n-            fb.insert(match_place);\n+            fb.insert(match_place.clone().into_place(self.tcx, self.typeck_results));\n         }\n \n         // perform the test, branching to one of N blocks. For each of\n@@ -1456,7 +1479,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // encounter a candidate where the test is not relevant; at\n         // that point, we stop sorting.\n         while let Some(candidate) = candidates.first_mut() {\n-            if let Some(idx) = self.sort_candidate(&match_place, &test, candidate) {\n+            if let Some(idx) = self.sort_candidate(&match_place.clone(), &test, candidate) {\n                 let (candidate, rest) = candidates.split_first_mut().unwrap();\n                 target_candidates[idx].push(candidate);\n                 candidates = rest;\n@@ -1519,7 +1542,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             target_blocks\n         };\n \n-        self.perform_test(block, match_place, &test, make_target_blocks);\n+        self.perform_test(block, match_place.clone(), &test, make_target_blocks);\n     }\n \n     /// Determine the fake borrows that are needed from a set of places that\n@@ -1753,11 +1776,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n                 Guard::IfLet(pat, scrutinee) => {\n                     let scrutinee_span = scrutinee.span;\n-                    let scrutinee_place =\n-                        unpack!(block = self.lower_scrutinee(block, scrutinee, scrutinee_span));\n-                    let mut guard_candidate = Candidate::new(scrutinee_place, &pat, false);\n+                    let scrutinee_place = unpack!(\n+                        block = self.lower_scrutinee(block, scrutinee.clone(), scrutinee_span)\n+                    );\n+                    let mut guard_candidate = Candidate::new(scrutinee_place.clone(), &pat, false);\n                     let wildcard = Pat::wildcard_from_ty(pat.ty);\n-                    let mut otherwise_candidate = Candidate::new(scrutinee_place, &wildcard, false);\n+                    let mut otherwise_candidate =\n+                        Candidate::new(scrutinee_place.clone(), &wildcard, false);\n                     let fake_borrow_temps = self.lower_match_tree(\n                         block,\n                         pat.span,\n@@ -1769,7 +1794,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         pat.span.to(arm_span.unwrap()),\n                         pat,\n                         ArmHasGuard(false),\n-                        Some((Some(&scrutinee_place), scrutinee.span)),\n+                        Some((\n+                            Some(&scrutinee_place.clone().into_place(tcx, self.typeck_results)),\n+                            scrutinee.span,\n+                        )),\n                     );\n                     let post_guard_block = self.bind_pattern(\n                         self.source_info(pat.span),"}, {"sha": "d9c1d4abf0700e424b3c3c4c9cd441acdad117da", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d4f8729c892882b16d7ce66f287818b6a66fe200/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4f8729c892882b16d7ce66f287818b6a66fe200/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=d4f8729c892882b16d7ce66f287818b6a66fe200", "patch": "@@ -12,11 +12,11 @@\n //! sort of test: for example, testing which variant an enum is, or\n //! testing a value against a constant.\n \n+use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::matches::{Ascription, Binding, Candidate, MatchPair};\n use crate::build::Builder;\n use crate::thir::{self, *};\n use rustc_hir::RangeEnd;\n-use rustc_middle::mir::Place;\n use rustc_middle::ty;\n use rustc_middle::ty::layout::IntegerExt;\n use rustc_target::abi::{Integer, Size};\n@@ -68,11 +68,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let match_pairs = mem::take(&mut candidate.match_pairs);\n \n             if let [MatchPair { pattern: Pat { kind: box PatKind::Or { pats }, .. }, place }] =\n-                *match_pairs\n+                &*match_pairs.clone()\n             {\n                 existing_bindings.extend_from_slice(&new_bindings);\n                 mem::swap(&mut candidate.bindings, &mut existing_bindings);\n-                candidate.subcandidates = self.create_or_subcandidates(candidate, place, pats);\n+                candidate.subcandidates =\n+                    self.create_or_subcandidates(candidate, place.clone(), pats);\n                 return true;\n             }\n \n@@ -125,12 +126,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn create_or_subcandidates<'pat>(\n         &mut self,\n         candidate: &Candidate<'pat, 'tcx>,\n-        place: Place<'tcx>,\n+        place: PlaceBuilder<'tcx>,\n         pats: &'pat [Pat<'tcx>],\n     ) -> Vec<Candidate<'pat, 'tcx>> {\n         pats.iter()\n             .map(|pat| {\n-                let mut candidate = Candidate::new(place, pat, candidate.has_guard);\n+                let mut candidate = Candidate::new(place.clone(), pat, candidate.has_guard);\n                 self.simplify_candidate(&mut candidate);\n                 candidate\n             })\n@@ -148,6 +149,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         candidate: &mut Candidate<'pat, 'tcx>,\n     ) -> Result<(), MatchPair<'pat, 'tcx>> {\n         let tcx = self.tcx;\n+        // Generate place to be used in Ascription\n+        // Generate place to be used in Binding\n+        let place = match_pair.place.clone().into_place(tcx, self.typeck_results);\n         match *match_pair.pattern.kind {\n             PatKind::AscribeUserType {\n                 ref subpattern,\n@@ -158,7 +162,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 candidate.ascriptions.push(Ascription {\n                     span: user_ty_span,\n                     user_ty,\n-                    source: match_pair.place,\n+                    source: place,\n                     variance,\n                 });\n \n@@ -177,7 +181,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     name,\n                     mutability,\n                     span: match_pair.pattern.span,\n-                    source: match_pair.place,\n+                    source: place,\n                     var_id: var,\n                     var_ty: ty,\n                     binding_mode: mode,\n@@ -264,8 +268,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }) && (adt_def.did.is_local()\n                     || !adt_def.is_variant_list_non_exhaustive());\n                 if irrefutable {\n-                    let place = tcx.mk_place_downcast(match_pair.place, adt_def, variant_index);\n-                    candidate.match_pairs.extend(self.field_match_pairs(place, subpatterns));\n+                    let place_builder = match_pair.place.downcast(adt_def, variant_index);\n+                    candidate\n+                        .match_pairs\n+                        .extend(self.field_match_pairs(place_builder, subpatterns));\n                     Ok(())\n                 } else {\n                     Err(match_pair)\n@@ -290,8 +296,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             PatKind::Deref { ref subpattern } => {\n-                let place = tcx.mk_place_deref(match_pair.place);\n-                candidate.match_pairs.push(MatchPair::new(place, subpattern));\n+                let place_builder = match_pair.place.deref();\n+                candidate.match_pairs.push(MatchPair::new(place_builder, subpattern));\n                 Ok(())\n             }\n "}, {"sha": "b804cd4574fa7eb27bdada6e2d83f666a7a3adf7", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d4f8729c892882b16d7ce66f287818b6a66fe200/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4f8729c892882b16d7ce66f287818b6a66fe200/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=d4f8729c892882b16d7ce66f287818b6a66fe200", "patch": "@@ -5,6 +5,7 @@\n // identify what tests are needed, perform the tests, and then filter\n // the candidates based on the result.\n \n+use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::matches::{Candidate, MatchPair, Test, TestKind};\n use crate::build::Builder;\n use crate::thir::pattern::compare_const_vals;\n@@ -81,7 +82,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     pub(super) fn add_cases_to_switch<'pat>(\n         &mut self,\n-        test_place: &Place<'tcx>,\n+        test_place: &PlaceBuilder<'tcx>,\n         candidate: &Candidate<'pat, 'tcx>,\n         switch_ty: Ty<'tcx>,\n         options: &mut FxIndexMap<&'tcx ty::Const<'tcx>, u128>,\n@@ -123,7 +124,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     pub(super) fn add_variants_to_switch<'pat>(\n         &mut self,\n-        test_place: &Place<'tcx>,\n+        test_place: &PlaceBuilder<'tcx>,\n         candidate: &Candidate<'pat, 'tcx>,\n         variants: &mut BitSet<VariantIdx>,\n     ) -> bool {\n@@ -151,10 +152,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub(super) fn perform_test(\n         &mut self,\n         block: BasicBlock,\n-        place: Place<'tcx>,\n+        place_builder: PlaceBuilder<'tcx>,\n         test: &Test<'tcx>,\n         make_target_blocks: impl FnOnce(&mut Self) -> Vec<BasicBlock>,\n     ) {\n+        let place = place_builder.clone().into_place(self.tcx, self.typeck_results);\n         debug!(\n             \"perform_test({:?}, {:?}: {:?}, {:?})\",\n             block,\n@@ -481,7 +483,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// tighter match code if we do something a bit different.\n     pub(super) fn sort_candidate<'pat>(\n         &mut self,\n-        test_place: &Place<'tcx>,\n+        test_place: &PlaceBuilder<'tcx>,\n         test: &Test<'tcx>,\n         candidate: &mut Candidate<'pat, 'tcx>,\n     ) -> Option<usize> {\n@@ -728,7 +730,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         candidate: &mut Candidate<'pat, 'tcx>,\n     ) {\n         let match_pair = candidate.match_pairs.remove(match_pair_index);\n-        let tcx = self.tcx;\n \n         // So, if we have a match-pattern like `x @ Enum::Variant(P1, P2)`,\n         // we want to create a set of derived match-patterns like\n@@ -737,10 +738,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             Some(adt_def.variants[variant_index].ident.name),\n             variant_index,\n         );\n-        let downcast_place = tcx.mk_place_elem(match_pair.place, elem); // `(x as Variant)`\n+        let downcast_place = match_pair.place.project(elem); // `(x as Variant)`\n         let consequent_match_pairs = subpatterns.iter().map(|subpattern| {\n             // e.g., `(x as Variant).0`\n-            let place = tcx.mk_place_field(downcast_place, subpattern.field, subpattern.pattern.ty);\n+            let place = downcast_place.clone().field(subpattern.field, subpattern.pattern.ty);\n             // e.g., `(x as Variant).0 @ P1`\n             MatchPair::new(place, &subpattern.pattern)\n         });"}, {"sha": "d49a00a566053751bbdd8c550b004edc96f60f62", "filename": "compiler/rustc_mir_build/src/build/matches/util.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d4f8729c892882b16d7ce66f287818b6a66fe200/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4f8729c892882b16d7ce66f287818b6a66fe200/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs?ref=d4f8729c892882b16d7ce66f287818b6a66fe200", "patch": "@@ -1,3 +1,4 @@\n+use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::matches::MatchPair;\n use crate::build::Builder;\n use crate::thir::*;\n@@ -9,13 +10,13 @@ use std::convert::TryInto;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn field_match_pairs<'pat>(\n         &mut self,\n-        place: Place<'tcx>,\n+        place: PlaceBuilder<'tcx>,\n         subpatterns: &'pat [FieldPat<'tcx>],\n     ) -> Vec<MatchPair<'pat, 'tcx>> {\n         subpatterns\n             .iter()\n             .map(|fieldpat| {\n-                let place = self.tcx.mk_place_field(place, fieldpat.field, fieldpat.pattern.ty);\n+                let place = place.clone().field(fieldpat.field, fieldpat.pattern.ty);\n                 MatchPair::new(place, &fieldpat.pattern)\n             })\n             .collect()\n@@ -24,34 +25,37 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     crate fn prefix_slice_suffix<'pat>(\n         &mut self,\n         match_pairs: &mut SmallVec<[MatchPair<'pat, 'tcx>; 1]>,\n-        place: &Place<'tcx>,\n+        place: &PlaceBuilder<'tcx>,\n         prefix: &'pat [Pat<'tcx>],\n         opt_slice: Option<&'pat Pat<'tcx>>,\n         suffix: &'pat [Pat<'tcx>],\n     ) {\n         let tcx = self.tcx;\n-        let (min_length, exact_size) = match place.ty(&self.local_decls, tcx).ty.kind() {\n+        let (min_length, exact_size) = match place\n+            .clone()\n+            .into_place(tcx, self.typeck_results)\n+            .ty(&self.local_decls, tcx)\n+            .ty\n+            .kind()\n+        {\n             ty::Array(_, length) => (length.eval_usize(tcx, self.param_env), true),\n             _ => ((prefix.len() + suffix.len()).try_into().unwrap(), false),\n         };\n \n         match_pairs.extend(prefix.iter().enumerate().map(|(idx, subpattern)| {\n             let elem =\n                 ProjectionElem::ConstantIndex { offset: idx as u64, min_length, from_end: false };\n-            let place = tcx.mk_place_elem(*place, elem);\n+            let place = place.clone().project(elem);\n             MatchPair::new(place, subpattern)\n         }));\n \n         if let Some(subslice_pat) = opt_slice {\n             let suffix_len = suffix.len() as u64;\n-            let subslice = tcx.mk_place_elem(\n-                *place,\n-                ProjectionElem::Subslice {\n-                    from: prefix.len() as u64,\n-                    to: if exact_size { min_length - suffix_len } else { suffix_len },\n-                    from_end: !exact_size,\n-                },\n-            );\n+            let subslice = place.clone().project(ProjectionElem::Subslice {\n+                from: prefix.len() as u64,\n+                to: if exact_size { min_length - suffix_len } else { suffix_len },\n+                from_end: !exact_size,\n+            });\n             match_pairs.push(MatchPair::new(subslice, subslice_pat));\n         }\n \n@@ -62,7 +66,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 min_length,\n                 from_end: !exact_size,\n             };\n-            let place = tcx.mk_place_elem(*place, elem);\n+            let place = place.clone().project(elem);\n             MatchPair::new(place, subpattern)\n         }));\n     }\n@@ -91,7 +95,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n }\n \n impl<'pat, 'tcx> MatchPair<'pat, 'tcx> {\n-    crate fn new(place: Place<'tcx>, pattern: &'pat Pat<'tcx>) -> MatchPair<'pat, 'tcx> {\n+    crate fn new(place: PlaceBuilder<'tcx>, pattern: &'pat Pat<'tcx>) -> MatchPair<'pat, 'tcx> {\n         MatchPair { place, pattern }\n     }\n }"}, {"sha": "4bc497f5ce29c269162072891bea87232a3ab238", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4f8729c892882b16d7ce66f287818b6a66fe200/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4f8729c892882b16d7ce66f287818b6a66fe200/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=d4f8729c892882b16d7ce66f287818b6a66fe200", "patch": "@@ -1,4 +1,5 @@\n use crate::build;\n+use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::scope::DropKind;\n use crate::thir::{build_thir, Arena, BindingMode, Expr, LintLevel, Pat, PatKind};\n use rustc_attr::{self as attr, UnwindAttr};\n@@ -1004,7 +1005,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             matches::ArmHasGuard(false),\n                             Some((Some(&place), span)),\n                         );\n-                        unpack!(block = self.place_into_pattern(block, pattern, place, false));\n+                        let place_builder = PlaceBuilder::from(local);\n+                        unpack!(\n+                            block = self.place_into_pattern(block, pattern, place_builder, false)\n+                        );\n                     }\n                 }\n                 self.source_scope = original_source_scope;"}]}