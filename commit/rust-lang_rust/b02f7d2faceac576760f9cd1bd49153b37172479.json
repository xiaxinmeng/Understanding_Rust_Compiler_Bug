{"sha": "b02f7d2faceac576760f9cd1bd49153b37172479", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwMmY3ZDJmYWNlYWM1NzY3NjBmOWNkMWJkNDkxNTNiMzcxNzI0Nzk=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-03-25T10:10:09Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-04-01T00:56:07Z"}, "message": "rustc::middle::const_eval : add overflow-checking for {+, -, *}.\n\nThe overflow-checking attempts to accommodate early evaluation where\nwe do not have type information yet.\n\nAlso, add fixme note about something that has been bothering me.", "tree": {"sha": "0795f11037cedf18697cf5a403f0f4f60a3c2875", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0795f11037cedf18697cf5a403f0f4f60a3c2875"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b02f7d2faceac576760f9cd1bd49153b37172479", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b02f7d2faceac576760f9cd1bd49153b37172479", "html_url": "https://github.com/rust-lang/rust/commit/b02f7d2faceac576760f9cd1bd49153b37172479", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b02f7d2faceac576760f9cd1bd49153b37172479/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e93e386fd228176aeb1100bfdf961bdae2b51b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e93e386fd228176aeb1100bfdf961bdae2b51b9", "html_url": "https://github.com/rust-lang/rust/commit/2e93e386fd228176aeb1100bfdf961bdae2b51b9"}], "stats": {"total": 378, "additions": 297, "deletions": 81}, "files": [{"sha": "e3e5efc53c7decdca8253aab72db0ada53beea16", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 297, "deletions": 81, "changes": 378, "blob_url": "https://github.com/rust-lang/rust/blob/b02f7d2faceac576760f9cd1bd49153b37172479/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b02f7d2faceac576760f9cd1bd49153b37172479/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=b02f7d2faceac576760f9cd1bd49153b37172479", "patch": "@@ -13,6 +13,8 @@\n \n pub use self::const_val::*;\n \n+use self::ErrKind::*;\n+\n use metadata::csearch;\n use middle::{astencode, def};\n use middle::pat_util::def_to_path;\n@@ -27,6 +29,7 @@ use syntax::{ast_map, ast_util, codemap};\n \n use std::borrow::{Cow, IntoCow};\n use std::num::wrapping::OverflowingOps;\n+use std::num::ToPrimitive;\n use std::cmp::Ordering;\n use std::collections::hash_map::Entry::Vacant;\n use std::{i8, i16, i32, i64};\n@@ -234,6 +237,7 @@ pub enum ErrKind {\n     NotOnStruct,\n     NotOnTuple,\n \n+    NegateWithOverflow(i64),\n     AddiWithOverflow(i64, i64),\n     SubiWithOverflow(i64, i64),\n     MuliWithOverflow(i64, i64),\n@@ -244,6 +248,8 @@ pub enum ErrKind {\n     DivideWithOverflow,\n     ModuloByZero,\n     ModuloWithOverflow,\n+    ShiftLeftWithOverflow,\n+    ShiftRightWithOverflow,\n     MissingStructField,\n     NonConstPath,\n     ExpectedConstTuple,\n@@ -257,6 +263,7 @@ pub enum ErrKind {\n impl ConstEvalErr {\n     pub fn description(&self) -> Cow<str> {\n         use self::ErrKind::*;\n+\n         match self.kind {\n             CannotCast => \"can't cast this type\".into_cow(),\n             CannotCastTo(s) => format!(\"can't cast this type to {}\", s).into_cow(),\n@@ -275,6 +282,7 @@ impl ConstEvalErr {\n             NotOnStruct => \"not on struct\".into_cow(),\n             NotOnTuple => \"not on tuple\".into_cow(),\n \n+            NegateWithOverflow(..) => \"attempted to negate with overflow\".into_cow(),\n             AddiWithOverflow(..) => \"attempted to add with overflow\".into_cow(),\n             SubiWithOverflow(..) => \"attempted to sub with overflow\".into_cow(),\n             MuliWithOverflow(..) => \"attempted to mul with overflow\".into_cow(),\n@@ -285,6 +293,8 @@ impl ConstEvalErr {\n             DivideWithOverflow   => \"attempted to divide with overflow\".into_cow(),\n             ModuloByZero         => \"attempted remainder with a divisor of zero\".into_cow(),\n             ModuloWithOverflow   => \"attempted remainder with overflow\".into_cow(),\n+            ShiftLeftWithOverflow => \"attempted left shift with overflow\".into_cow(),\n+            ShiftRightWithOverflow => \"attempted right shift with overflow\".into_cow(),\n             MissingStructField  => \"nonexistent struct field\".into_cow(),\n             NonConstPath        => \"non-constant path in constant expr\".into_cow(),\n             ExpectedConstTuple => \"expected constant tuple\".into_cow(),\n@@ -297,57 +307,294 @@ impl ConstEvalErr {\n     }\n }\n \n+pub type EvalResult = Result<const_val, ConstEvalErr>;\n+pub type CastResult = Result<const_val, ErrKind>;\n+\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum IntTy { I8, I16, I32, I64 }\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum UintTy { U8, U16, U32, U64 }\n+\n+impl IntTy {\n+    pub fn from(tcx: &ty::ctxt, t: ast::IntTy) -> IntTy {\n+        let t = if let ast::TyIs = t {\n+            tcx.sess.target.int_type\n+        } else {\n+            t\n+        };\n+        match t {\n+            ast::TyIs => unreachable!(),\n+            ast::TyI8  => IntTy::I8,\n+            ast::TyI16 => IntTy::I16,\n+            ast::TyI32 => IntTy::I32,\n+            ast::TyI64 => IntTy::I64,\n+        }\n+    }\n+}\n+\n+impl UintTy {\n+    pub fn from(tcx: &ty::ctxt, t: ast::UintTy) -> UintTy {\n+        let t = if let ast::TyUs = t {\n+            tcx.sess.target.uint_type\n+        } else {\n+            t\n+        };\n+        match t {\n+            ast::TyUs => unreachable!(),\n+            ast::TyU8  => UintTy::U8,\n+            ast::TyU16 => UintTy::U16,\n+            ast::TyU32 => UintTy::U32,\n+            ast::TyU64 => UintTy::U64,\n+        }\n+    }\n+}\n+\n macro_rules! signal {\n-    ($e:expr, $ctor:ident) => {\n-        return Err(ConstEvalErr { span: $e.span, kind: ErrKind::$ctor })\n+    ($e:expr, $exn:expr) => {\n+        return Err(ConstEvalErr { span: $e.span, kind: $exn })\n+    }\n+}\n+\n+// The const_{int,uint}_checked_{neg,add,sub,mul,div,shl,shr} family\n+// of functions catch and signal overflow errors during constant\n+// evaluation.\n+//\n+// They all take the operator's arguments (`a` and `b` if binary), the\n+// overall expression (`e`) and, if available, whole expression's\n+// concrete type (`opt_ety`).\n+//\n+// If the whole expression's concrete type is None, then this is a\n+// constant evaluation happening before type check (e.g. in the check\n+// to confirm that a pattern range's left-side is not greater than its\n+// right-side). We do not do arithmetic modulo the type's bitwidth in\n+// such a case; we just do 64-bit arithmetic and assume that later\n+// passes will do it again with the type information, and thus do the\n+// overflow checks then.\n+\n+pub fn const_int_checked_neg<'a>(\n+    a: i64, e: &'a Expr, opt_ety: Option<IntTy>) -> EvalResult {\n+\n+    let (min,max) = match opt_ety {\n+        // (-i8::MIN is itself not an i8, etc, but this is an easy way\n+        // to allow literals to pass the check. Of course that does\n+        // not work for i64::MIN.)\n+        Some(IntTy::I8) =>  (-(i8::MAX as i64), -(i8::MIN as i64)),\n+        Some(IntTy::I16) => (-(i16::MAX as i64), -(i16::MIN as i64)),\n+        Some(IntTy::I32) => (-(i32::MAX as i64), -(i32::MIN as i64)),\n+        None | Some(IntTy::I64) => (-i64::MAX, -(i64::MIN+1)),\n     };\n \n-    ($e:expr, $ctor:ident($($arg:expr),*)) => {\n-        return Err(ConstEvalErr { span: $e.span, kind: ErrKind::$ctor($($arg),*) })\n+    let oflo = a < min || a > max;\n+    if oflo {\n+        signal!(e, NegateWithOverflow(a));\n+    } else {\n+        Ok(const_int(-a))\n+    }\n+}\n+\n+pub fn const_uint_checked_neg<'a>(\n+    a: u64, _e: &'a Expr, _opt_ety: Option<UintTy>) -> EvalResult {\n+    // This always succeeds, and by definition, returns `(!a)+1`.\n+    Ok(const_uint(-a))\n+}\n+\n+macro_rules! overflow_checking_body {\n+    ($a:ident, $b:ident, $ety:ident, $overflowing_op:ident,\n+     lhs: $to_8_lhs:ident $to_16_lhs:ident $to_32_lhs:ident,\n+     rhs: $to_8_rhs:ident $to_16_rhs:ident $to_32_rhs:ident $to_64_rhs:ident,\n+     $EnumTy:ident $T8: ident $T16: ident $T32: ident $T64: ident,\n+     $result_type: ident) => { {\n+        let (a,b,opt_ety) = ($a,$b,$ety);\n+        match opt_ety {\n+            Some($EnumTy::$T8) => match (a.$to_8_lhs(), b.$to_8_rhs()) {\n+                (Some(a), Some(b)) => {\n+                    let (a, oflo) = a.$overflowing_op(b);\n+                    (a as $result_type, oflo)\n+                }\n+                (None, _) | (_, None) => (0, true)\n+            },\n+            Some($EnumTy::$T16) => match (a.$to_16_lhs(), b.$to_16_rhs()) {\n+                (Some(a), Some(b)) => {\n+                    let (a, oflo) = a.$overflowing_op(b);\n+                    (a as $result_type, oflo)\n+                }\n+                (None, _) | (_, None) => (0, true)\n+            },\n+            Some($EnumTy::$T32) => match (a.$to_32_lhs(), b.$to_32_rhs()) {\n+                (Some(a), Some(b)) => {\n+                    let (a, oflo) = a.$overflowing_op(b);\n+                    (a as $result_type, oflo)\n+                }\n+                (None, _) | (_, None) => (0, true)\n+            },\n+            None | Some($EnumTy::$T64) => match b.$to_64_rhs() {\n+                Some(b) => a.$overflowing_op(b),\n+                None => (0, true),\n+            }\n+        }\n+    } }\n+}\n+\n+macro_rules! int_arith_body {\n+    ($a:ident, $b:ident, $ety:ident, $overflowing_op:ident) => {\n+        overflow_checking_body!(\n+            $a, $b, $ety, $overflowing_op,\n+            lhs: to_i8 to_i16 to_i32,\n+            rhs: to_i8 to_i16 to_i32 to_i64, IntTy I8 I16 I32 I64, i64)\n     }\n }\n \n-fn checked_add_int(e: &Expr, a: i64, b: i64) -> Result<const_val, ConstEvalErr> {\n-    let (ret, oflo) = a.overflowing_add(b);\n-    if !oflo { Ok(const_int(ret)) } else { signal!(e, AddiWithOverflow(a, b)) }\n+macro_rules! uint_arith_body {\n+    ($a:ident, $b:ident, $ety:ident, $overflowing_op:ident) => {\n+        overflow_checking_body!(\n+            $a, $b, $ety, $overflowing_op,\n+            lhs: to_u8 to_u16 to_u32,\n+            rhs: to_u8 to_u16 to_u32 to_u64, UintTy U8 U16 U32 U64, u64)\n+    }\n }\n-fn checked_sub_int(e: &Expr, a: i64, b: i64) -> Result<const_val, ConstEvalErr> {\n-    let (ret, oflo) = a.overflowing_sub(b);\n-    if !oflo { Ok(const_int(ret)) } else { signal!(e, SubiWithOverflow(a, b)) }\n+\n+macro_rules! int_shift_body {\n+    ($a:ident, $b:ident, $ety:ident, $overflowing_op:ident) => {\n+        overflow_checking_body!(\n+            $a, $b, $ety, $overflowing_op,\n+            lhs: to_i8 to_i16 to_i32,\n+            rhs: to_u32 to_u32 to_u32 to_u32, IntTy I8 I16 I32 I64, i64)\n+    }\n }\n-fn checked_mul_int(e: &Expr, a: i64, b: i64) -> Result<const_val, ConstEvalErr> {\n-    let (ret, oflo) = a.overflowing_mul(b);\n-    if !oflo { Ok(const_int(ret)) } else { signal!(e, MuliWithOverflow(a, b)) }\n+\n+macro_rules! uint_shift_body {\n+    ($a:ident, $b:ident, $ety:ident, $overflowing_op:ident) => {\n+        overflow_checking_body!(\n+            $a, $b, $ety, $overflowing_op,\n+            lhs: to_u8 to_u16 to_u32,\n+            rhs: to_u32 to_u32 to_u32 to_u32, UintTy U8 U16 U32 U64, u64)\n+    }\n }\n \n-fn checked_add_uint(e: &Expr, a: u64, b: u64) -> Result<const_val, ConstEvalErr> {\n-    let (ret, oflo) = a.overflowing_add(b);\n-    if !oflo { Ok(const_uint(ret)) } else { signal!(e, AdduWithOverflow(a, b)) }\n+macro_rules! pub_fn_checked_op {\n+    {$fn_name:ident ($a:ident : $a_ty:ty, $b:ident : $b_ty:ty,.. $WhichTy:ident) {\n+        $ret_oflo_body:ident $overflowing_op:ident\n+            $const_ty:ident $signal_exn:expr\n+    }} => {\n+        pub fn $fn_name<'a>($a: $a_ty,\n+                            $b: $b_ty,\n+                            e: &'a Expr,\n+                            opt_ety: Option<$WhichTy>) -> EvalResult {\n+            let (ret, oflo) = $ret_oflo_body!($a, $b, opt_ety, $overflowing_op);\n+            if !oflo { Ok($const_ty(ret)) } else { signal!(e, $signal_exn) }\n+        }\n+    }\n }\n-fn checked_sub_uint(e: &Expr, a: u64, b: u64) -> Result<const_val, ConstEvalErr> {\n-    let (ret, oflo) = a.overflowing_sub(b);\n-    if !oflo { Ok(const_uint(ret)) } else { signal!(e, SubuWithOverflow(a, b)) }\n+\n+pub_fn_checked_op!{ const_int_checked_add(a: i64, b: i64,.. IntTy) {\n+           int_arith_body overflowing_add const_int AddiWithOverflow(a, b)\n+}}\n+\n+pub_fn_checked_op!{ const_int_checked_sub(a: i64, b: i64,.. IntTy) {\n+           int_arith_body overflowing_sub const_int SubiWithOverflow(a, b)\n+}}\n+\n+pub_fn_checked_op!{ const_int_checked_mul(a: i64, b: i64,.. IntTy) {\n+           int_arith_body overflowing_mul const_int MuliWithOverflow(a, b)\n+}}\n+\n+pub fn const_int_checked_div<'a>(\n+    a: i64, b: i64, e: &'a Expr, opt_ety: Option<IntTy>) -> EvalResult {\n+    if b == 0 { signal!(e, DivideByZero); }\n+    let (ret, oflo) = int_arith_body!(a, b, opt_ety, overflowing_div);\n+    if !oflo { Ok(const_int(ret)) } else { signal!(e, DivideWithOverflow) }\n }\n-fn checked_mul_uint(e: &Expr, a: u64, b: u64) -> Result<const_val, ConstEvalErr> {\n-    let (ret, oflo) = a.overflowing_mul(b);\n-    if !oflo { Ok(const_uint(ret)) } else { signal!(e, MuluWithOverflow(a, b)) }\n+\n+pub fn const_int_checked_rem<'a>(\n+    a: i64, b: i64, e: &'a Expr, opt_ety: Option<IntTy>) -> EvalResult {\n+    if b == 0 { signal!(e, ModuloByZero); }\n+    let (ret, oflo) = int_arith_body!(a, b, opt_ety, overflowing_rem);\n+    if !oflo { Ok(const_int(ret)) } else { signal!(e, ModuloWithOverflow) }\n }\n \n+pub_fn_checked_op!{ const_int_checked_shl(a: i64, b: i64,.. IntTy) {\n+           int_shift_body overflowing_shl const_int ShiftLeftWithOverflow\n+}}\n+\n+pub_fn_checked_op!{ const_int_checked_shl_via_uint(a: i64, b: u64,.. IntTy) {\n+           int_shift_body overflowing_shl const_int ShiftLeftWithOverflow\n+}}\n+\n+pub_fn_checked_op!{ const_int_checked_shr(a: i64, b: i64,.. IntTy) {\n+           int_shift_body overflowing_shr const_int ShiftRightWithOverflow\n+}}\n+\n+pub_fn_checked_op!{ const_int_checked_shr_via_uint(a: i64, b: u64,.. IntTy) {\n+           int_shift_body overflowing_shr const_int ShiftRightWithOverflow\n+}}\n+\n+pub_fn_checked_op!{ const_uint_checked_add(a: u64, b: u64,.. UintTy) {\n+           uint_arith_body overflowing_add const_uint AdduWithOverflow(a, b)\n+}}\n+\n+pub_fn_checked_op!{ const_uint_checked_sub(a: u64, b: u64,.. UintTy) {\n+           uint_arith_body overflowing_sub const_uint SubuWithOverflow(a, b)\n+}}\n+\n+pub_fn_checked_op!{ const_uint_checked_mul(a: u64, b: u64,.. UintTy) {\n+           uint_arith_body overflowing_mul const_uint MuluWithOverflow(a, b)\n+}}\n+\n+pub fn const_uint_checked_div<'a>(\n+    a: u64, b: u64, e: &'a Expr, opt_ety: Option<UintTy>) -> EvalResult {\n+    if b == 0 { signal!(e, DivideByZero); }\n+    let (ret, oflo) = uint_arith_body!(a, b, opt_ety, overflowing_div);\n+    if !oflo { Ok(const_uint(ret)) } else { signal!(e, DivideWithOverflow) }\n+}\n+\n+pub fn const_uint_checked_rem<'a>(\n+    a: u64, b: u64, e: &'a Expr, opt_ety: Option<UintTy>) -> EvalResult {\n+    if b == 0 { signal!(e, ModuloByZero); }\n+    let (ret, oflo) = uint_arith_body!(a, b, opt_ety, overflowing_rem);\n+    if !oflo { Ok(const_uint(ret)) } else { signal!(e, ModuloWithOverflow) }\n+}\n+\n+pub_fn_checked_op!{ const_uint_checked_shl(a: u64, b: u64,.. UintTy) {\n+           uint_shift_body overflowing_shl const_uint ShiftLeftWithOverflow\n+}}\n+\n+pub_fn_checked_op!{ const_uint_checked_shl_via_int(a: u64, b: i64,.. UintTy) {\n+           uint_shift_body overflowing_shl const_uint ShiftLeftWithOverflow\n+}}\n+\n+pub_fn_checked_op!{ const_uint_checked_shr(a: u64, b: u64,.. UintTy) {\n+           uint_shift_body overflowing_shr const_uint ShiftRightWithOverflow\n+}}\n+\n+pub_fn_checked_op!{ const_uint_checked_shr_via_int(a: u64, b: i64,.. UintTy) {\n+           uint_shift_body overflowing_shr const_uint ShiftRightWithOverflow\n+}}\n \n pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      e: &Expr,\n-                                     ty_hint: Option<Ty<'tcx>>)\n-                                     -> Result<const_val, ConstEvalErr> {\n+                                     ty_hint: Option<Ty<'tcx>>) -> EvalResult {\n     fn fromb(b: bool) -> const_val { const_int(b as i64) }\n \n     let ety = ty_hint.or_else(|| ty::expr_ty_opt(tcx, e));\n \n+    // If type of expression itself is int or uint, normalize in these\n+    // bindings so that isize/usize is mapped to a type with an\n+    // inherently known bitwidth.\n+    let expr_int_type = ety.and_then(|ty| {\n+        if let ty::ty_int(t) = ty.sty {\n+            Some(IntTy::from(tcx, t)) } else { None }\n+    });\n+    let expr_uint_type = ety.and_then(|ty| {\n+        if let ty::ty_uint(t) = ty.sty {\n+            Some(UintTy::from(tcx, t)) } else { None }\n+    });\n+\n     let result = match e.node {\n       ast::ExprUnary(ast::UnNeg, ref inner) => {\n         match try!(eval_const_expr_partial(tcx, &**inner, ety)) {\n           const_float(f) => const_float(-f),\n-          const_int(i) => const_int(-i),\n-          const_uint(i) => const_uint(-i),\n+          const_int(n) =>  try!(const_int_checked_neg(n, e, expr_int_type)),\n+          const_uint(n) => try!(const_uint_checked_neg(n, e, expr_uint_type)),\n           const_str(_) => signal!(e, NegateOnString),\n           const_bool(_) => signal!(e, NegateOnBoolean),\n           const_binary(_) => signal!(e, NegateOnBinary),\n@@ -391,51 +638,17 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n             }\n           }\n           (const_int(a), const_int(b)) => {\n-            let is_a_min_value = || {\n-                let int_ty = match ty::expr_ty_opt(tcx, e).map(|ty| &ty.sty) {\n-                    Some(&ty::ty_int(int_ty)) => int_ty,\n-                    _ => return false\n-                };\n-                let int_ty = if let ast::TyIs = int_ty {\n-                    tcx.sess.target.int_type\n-                } else {\n-                    int_ty\n-                };\n-                match int_ty {\n-                    ast::TyI8 => (a as i8) == i8::MIN,\n-                    ast::TyI16 =>  (a as i16) == i16::MIN,\n-                    ast::TyI32 =>  (a as i32) == i32::MIN,\n-                    ast::TyI64 =>  (a as i64) == i64::MIN,\n-                    ast::TyIs => unreachable!()\n-                }\n-            };\n             match op.node {\n-              ast::BiAdd => try!(checked_add_int(e, a, b)),\n-              ast::BiSub => try!(checked_sub_int(e, a, b)),\n-              ast::BiMul => try!(checked_mul_int(e, a, b)),\n-              ast::BiDiv => {\n-                  if b == 0 {\n-                      signal!(e, DivideByZero);\n-                  } else if b == -1 && is_a_min_value() {\n-                      signal!(e, DivideWithOverflow);\n-                  } else {\n-                      const_int(a / b)\n-                  }\n-              }\n-              ast::BiRem => {\n-                  if b == 0 {\n-                      signal!(e, ModuloByZero)\n-                  } else if b == -1 && is_a_min_value() {\n-                      signal!(e, ModuloWithOverflow)\n-                  } else {\n-                      const_int(a % b)\n-                  }\n-              }\n+              ast::BiAdd => try!(const_int_checked_add(a,b,e,expr_int_type)),\n+              ast::BiSub => try!(const_int_checked_sub(a,b,e,expr_int_type)),\n+              ast::BiMul => try!(const_int_checked_mul(a,b,e,expr_int_type)),\n+              ast::BiDiv => try!(const_int_checked_div(a,b,e,expr_int_type)),\n+              ast::BiRem => try!(const_int_checked_rem(a,b,e,expr_int_type)),\n               ast::BiAnd | ast::BiBitAnd => const_int(a & b),\n               ast::BiOr | ast::BiBitOr => const_int(a | b),\n               ast::BiBitXor => const_int(a ^ b),\n-              ast::BiShl => const_int(a << b as usize),\n-              ast::BiShr => const_int(a >> b as usize),\n+              ast::BiShl => try!(const_int_checked_shl(a,b,e,expr_int_type)),\n+              ast::BiShr => try!(const_int_checked_shr(a,b,e,expr_int_type)),\n               ast::BiEq => fromb(a == b),\n               ast::BiLt => fromb(a < b),\n               ast::BiLe => fromb(a <= b),\n@@ -446,18 +659,16 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n           }\n           (const_uint(a), const_uint(b)) => {\n             match op.node {\n-              ast::BiAdd => try!(checked_add_uint(e, a, b)),\n-              ast::BiSub => try!(checked_sub_uint(e, a, b)),\n-              ast::BiMul => try!(checked_mul_uint(e, a, b)),\n-              ast::BiDiv if b == 0 => signal!(e, DivideByZero),\n-              ast::BiDiv => const_uint(a / b),\n-              ast::BiRem if b == 0 => signal!(e, ModuloByZero),\n-              ast::BiRem => const_uint(a % b),\n+              ast::BiAdd => try!(const_uint_checked_add(a,b,e,expr_uint_type)),\n+              ast::BiSub => try!(const_uint_checked_sub(a,b,e,expr_uint_type)),\n+              ast::BiMul => try!(const_uint_checked_mul(a,b,e,expr_uint_type)),\n+              ast::BiDiv => try!(const_uint_checked_div(a,b,e,expr_uint_type)),\n+              ast::BiRem => try!(const_uint_checked_rem(a,b,e,expr_uint_type)),\n               ast::BiAnd | ast::BiBitAnd => const_uint(a & b),\n               ast::BiOr | ast::BiBitOr => const_uint(a | b),\n               ast::BiBitXor => const_uint(a ^ b),\n-              ast::BiShl => const_uint(a << b as usize),\n-              ast::BiShr => const_uint(a >> b as usize),\n+              ast::BiShl => try!(const_uint_checked_shl(a,b,e,expr_uint_type)),\n+              ast::BiShr => try!(const_uint_checked_shr(a,b,e,expr_uint_type)),\n               ast::BiEq => fromb(a == b),\n               ast::BiLt => fromb(a < b),\n               ast::BiLe => fromb(a <= b),\n@@ -469,15 +680,15 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n           // shifts can have any integral type as their rhs\n           (const_int(a), const_uint(b)) => {\n             match op.node {\n-              ast::BiShl => const_int(a << b as usize),\n-              ast::BiShr => const_int(a >> b as usize),\n+              ast::BiShl => try!(const_int_checked_shl_via_uint(a,b,e,expr_int_type)),\n+              ast::BiShr => try!(const_int_checked_shr_via_uint(a,b,e,expr_int_type)),\n               _ => signal!(e, InvalidOpForIntUint(op.node)),\n             }\n           }\n           (const_uint(a), const_int(b)) => {\n             match op.node {\n-              ast::BiShl => const_uint(a << b as usize),\n-              ast::BiShr => const_uint(a >> b as usize),\n+              ast::BiShl => try!(const_uint_checked_shl_via_int(a,b,e,expr_uint_type)),\n+              ast::BiShr => try!(const_uint_checked_shr_via_int(a,b,e,expr_uint_type)),\n               _ => signal!(e, InvalidOpForUintInt(op.node)),\n             }\n           }\n@@ -506,7 +717,12 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     tcx.sess.span_fatal(target_ty.span,\n                                         \"target type not found for const cast\")\n                 });\n+\n         // Prefer known type to noop, but always have a type hint.\n+        //\n+        // FIXME (#23833): the type-hint can cause problems,\n+        // e.g. `(i8::MAX + 1_i8) as u32` feeds in `u32` as result\n+        // type to the sum, and thus no overflow is signaled.\n         let base_hint = ty::expr_ty_opt(tcx, &**base).unwrap_or(ety);\n         let val = try!(eval_const_expr_partial(tcx, &**base, Some(base_hint)));\n         match cast_const(tcx, val, ety) {\n@@ -607,7 +823,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n     Ok(result)\n }\n \n-fn cast_const<'tcx>(tcx: &ty::ctxt<'tcx>, val: const_val, ty: Ty) -> Result<const_val, ErrKind> {\n+fn cast_const<'tcx>(tcx: &ty::ctxt<'tcx>, val: const_val, ty: Ty) -> CastResult {\n     macro_rules! convert_val {\n         ($intermediate_ty:ty, $const_type:ident, $target_ty:ty) => {\n             match val {"}]}