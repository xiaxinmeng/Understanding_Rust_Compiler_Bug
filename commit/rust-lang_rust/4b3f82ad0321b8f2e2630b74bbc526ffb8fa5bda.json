{"sha": "4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda", "node_id": "C_kwDOAAsO6NoAKDRiM2Y4MmFkMDMyMWI4ZjJlMjYzMGI3NGJiYzUyNmZmYjhmYTViZGE", "commit": {"author": {"name": "Will Crichton", "email": "wcrichto@cs.stanford.edu", "date": "2021-05-09T23:22:22Z"}, "committer": {"name": "Will Crichton", "email": "wcrichto@cs.stanford.edu", "date": "2021-10-07T02:44:47Z"}, "message": "Add updated support for example-analyzer\n\nMove rendering of examples into\n\nFinalize design\n\nCleanup, rename found -> scraped\n\nSofter yellow\n\nClean up dead code\n\nDocument scrape_examples\n\nMore simplification and documentation\n\nRemove extra css\n\nTest", "tree": {"sha": "4d10d3906b55b93f95d813d1e859ef92592712a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d10d3906b55b93f95d813d1e859ef92592712a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda", "html_url": "https://github.com/rust-lang/rust/commit/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda/comments", "author": {"login": "willcrichton", "id": 663326, "node_id": "MDQ6VXNlcjY2MzMyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/663326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willcrichton", "html_url": "https://github.com/willcrichton", "followers_url": "https://api.github.com/users/willcrichton/followers", "following_url": "https://api.github.com/users/willcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/willcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/willcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willcrichton/subscriptions", "organizations_url": "https://api.github.com/users/willcrichton/orgs", "repos_url": "https://api.github.com/users/willcrichton/repos", "events_url": "https://api.github.com/users/willcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/willcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "willcrichton", "id": 663326, "node_id": "MDQ6VXNlcjY2MzMyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/663326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willcrichton", "html_url": "https://github.com/willcrichton", "followers_url": "https://api.github.com/users/willcrichton/followers", "following_url": "https://api.github.com/users/willcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/willcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/willcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willcrichton/subscriptions", "organizations_url": "https://api.github.com/users/willcrichton/orgs", "repos_url": "https://api.github.com/users/willcrichton/repos", "events_url": "https://api.github.com/users/willcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/willcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0eabf25b90396dead0b2a1aaa275af18a1ae6008", "url": "https://api.github.com/repos/rust-lang/rust/commits/0eabf25b90396dead0b2a1aaa275af18a1ae6008", "html_url": "https://github.com/rust-lang/rust/commit/0eabf25b90396dead0b2a1aaa275af18a1ae6008"}], "stats": {"total": 630, "additions": 609, "deletions": 21}, "files": [{"sha": "09622d721f7f050efac641b59bc3924707778e4f", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda", "patch": "@@ -235,6 +235,7 @@ fn build_external_function(cx: &mut DocContext<'_>, did: DefId) -> clean::Functi\n         decl,\n         generics,\n         header: hir::FnHeader { unsafety: sig.unsafety(), abi: sig.abi(), constness, asyncness },\n+        call_locations: None,\n     }\n }\n "}, {"sha": "e2b1ff4547ba5c4bcece095b7e48863dc6c2a9d3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda", "patch": "@@ -801,7 +801,10 @@ impl<'a> Clean<Function> for (&'a hir::FnSig<'a>, &'a hir::Generics<'a>, hir::Bo\n     fn clean(&self, cx: &mut DocContext<'_>) -> Function {\n         let (generics, decl) =\n             enter_impl_trait(cx, |cx| (self.1.clean(cx), (&*self.0.decl, self.2).clean(cx)));\n-        Function { decl, generics, header: self.0.header }\n+        let mut function = Function { decl, generics, header: self.0.header, call_locations: None };\n+        let def_id = self.2.hir_id.owner.to_def_id();\n+        function.load_call_locations(def_id, cx);\n+        function\n     }\n }\n \n@@ -933,12 +936,14 @@ impl Clean<Item> for hir::TraitItem<'_> {\n                     let (generics, decl) = enter_impl_trait(cx, |cx| {\n                         (self.generics.clean(cx), (&*sig.decl, &names[..]).clean(cx))\n                     });\n-                    let mut t = Function { header: sig.header, decl, generics };\n+                    let mut t =\n+                        Function { header: sig.header, decl, generics, call_locations: None };\n                     if t.header.constness == hir::Constness::Const\n                         && is_unstable_const_fn(cx.tcx, local_did).is_some()\n                     {\n                         t.header.constness = hir::Constness::NotConst;\n                     }\n+                    t.load_call_locations(self.def_id.to_def_id(), cx);\n                     TyMethodItem(t)\n                 }\n                 hir::TraitItemKind::Type(ref bounds, ref default) => {\n@@ -1057,21 +1062,21 @@ impl Clean<Item> for ty::AssocItem {\n                         ty::ImplContainer(_) => Some(self.defaultness),\n                         ty::TraitContainer(_) => None,\n                     };\n-                    MethodItem(\n-                        Function {\n-                            generics,\n-                            decl,\n-                            header: hir::FnHeader {\n-                                unsafety: sig.unsafety(),\n-                                abi: sig.abi(),\n-                                constness,\n-                                asyncness,\n-                            },\n+                    let mut function = Function {\n+                        generics,\n+                        decl,\n+                        header: hir::FnHeader {\n+                            unsafety: sig.unsafety(),\n+                            abi: sig.abi(),\n+                            constness,\n+                            asyncness,\n                         },\n-                        defaultness,\n-                    )\n+                        call_locations: None,\n+                    };\n+                    function.load_call_locations(self.def_id, cx);\n+                    MethodItem(function, defaultness)\n                 } else {\n-                    TyMethodItem(Function {\n+                    let mut function = Function {\n                         generics,\n                         decl,\n                         header: hir::FnHeader {\n@@ -1080,7 +1085,10 @@ impl Clean<Item> for ty::AssocItem {\n                             constness: hir::Constness::NotConst,\n                             asyncness: hir::IsAsync::NotAsync,\n                         },\n-                    })\n+                        call_locations: None,\n+                    };\n+                    function.load_call_locations(self.def_id, cx);\n+                    TyMethodItem(function)\n                 }\n             }\n             ty::AssocKind::Type => {\n@@ -2098,6 +2106,7 @@ impl Clean<Item> for (&hir::ForeignItem<'_>, Option<Symbol>) {\n                             constness: hir::Constness::NotConst,\n                             asyncness: hir::IsAsync::NotAsync,\n                         },\n+                        call_locations: None,\n                     })\n                 }\n                 hir::ForeignItemKind::Static(ref ty, mutability) => {"}, {"sha": "2e0be44d932244b384ca208065539d9f33a817a8", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda", "patch": "@@ -42,6 +42,7 @@ use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n use crate::html::render::cache::ExternalLocation;\n use crate::html::render::Context;\n+use crate::scrape_examples::FnCallLocations;\n \n use self::FnRetTy::*;\n use self::ItemKind::*;\n@@ -1254,6 +1255,17 @@ crate struct Function {\n     crate decl: FnDecl,\n     crate generics: Generics,\n     crate header: hir::FnHeader,\n+    crate call_locations: Option<FnCallLocations>,\n+}\n+\n+impl Function {\n+    crate fn load_call_locations(&mut self, def_id: hir::def_id::DefId, cx: &DocContext<'_>) {\n+        if let Some(call_locations) = cx.render_options.call_locations.as_ref() {\n+            let key = cx.tcx.def_path(def_id).to_string_no_crate_verbose();\n+            self.call_locations = call_locations.get(&key).cloned();\n+            debug!(\"call_locations: {} -- {:?}\", key, self.call_locations);\n+        }\n+    }\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]"}, {"sha": "f34f773ea56dc602fb0640161fa2bfabe6c9c174", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda", "patch": "@@ -25,6 +25,7 @@ use crate::html::render::StylePath;\n use crate::html::static_files;\n use crate::opts;\n use crate::passes::{self, Condition, DefaultPassOption};\n+use crate::scrape_examples::AllCallLocations;\n use crate::theme;\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n@@ -158,6 +159,8 @@ crate struct Options {\n     crate json_unused_externs: bool,\n     /// Whether to skip capturing stdout and stderr of tests.\n     crate nocapture: bool,\n+\n+    crate scrape_examples: Vec<String>,\n }\n \n impl fmt::Debug for Options {\n@@ -280,6 +283,8 @@ crate struct RenderOptions {\n     crate emit: Vec<EmitType>,\n     /// If `true`, HTML source pages will generate links for items to their definition.\n     crate generate_link_to_definition: bool,\n+    crate call_locations: Option<AllCallLocations>,\n+    crate repository_url: Option<String>,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -671,6 +676,9 @@ impl Options {\n             return Err(1);\n         }\n \n+        let repository_url = matches.opt_str(\"repository-url\");\n+        let scrape_examples = matches.opt_strs(\"scrape-examples\");\n+\n         let (lint_opts, describe_lints, lint_cap) = get_cmd_lint_options(matches, error_format);\n \n         Ok(Options {\n@@ -737,10 +745,13 @@ impl Options {\n                 ),\n                 emit,\n                 generate_link_to_definition,\n+                call_locations: None,\n+                repository_url,\n             },\n             crate_name,\n             output_format,\n             json_unused_externs,\n+            scrape_examples,\n         })\n     }\n "}, {"sha": "49bf760c29cc5622d0b139ee112498e0b236b7e2", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda", "patch": "@@ -124,6 +124,7 @@ crate struct SharedContext<'tcx> {\n     crate span_correspondance_map: FxHashMap<rustc_span::Span, LinkFromSrc>,\n     /// The [`Cache`] used during rendering.\n     crate cache: Cache,\n+    pub(super) repository_url: Option<String>,\n }\n \n impl SharedContext<'_> {\n@@ -140,7 +141,11 @@ impl SharedContext<'_> {\n     /// Returns the `collapsed_doc_value` of the given item if this is the main crate, otherwise\n     /// returns the `doc_value`.\n     crate fn maybe_collapsed_doc_value<'a>(&self, item: &'a clean::Item) -> Option<String> {\n-        if self.collapsed { item.collapsed_doc_value() } else { item.doc_value() }\n+        if self.collapsed {\n+            item.collapsed_doc_value()\n+        } else {\n+            item.doc_value()\n+        }\n     }\n \n     crate fn edition(&self) -> Edition {\n@@ -389,6 +394,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             generate_redirect_map,\n             show_type_layout,\n             generate_link_to_definition,\n+            repository_url,\n             ..\n         } = options;\n \n@@ -480,6 +486,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             templates,\n             span_correspondance_map: matches,\n             cache,\n+            repository_url,\n         };\n \n         // Add the default themes to the `Vec` of stylepaths"}, {"sha": "0fb7723b68bf1b466370dc0d581bb153e379161a", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda", "patch": "@@ -39,6 +39,7 @@ crate use span_map::{collect_spans_and_sources, LinkFromSrc};\n use std::collections::VecDeque;\n use std::default::Default;\n use std::fmt;\n+use std::fs;\n use std::path::PathBuf;\n use std::str;\n use std::string::ToString;\n@@ -68,6 +69,8 @@ use crate::html::format::{\n     print_generic_bounds, print_where_clause, Buffer, HrefError, PrintWithSpace,\n };\n use crate::html::markdown::{HeadingOffset, Markdown, MarkdownHtml, MarkdownSummaryLine};\n+use crate::html::sources;\n+use crate::scrape_examples::FnCallLocations;\n \n /// A pair of name and its optional document.\n crate type NameDoc = (String, Option<String>);\n@@ -584,6 +587,13 @@ fn document_full_inner(\n             render_markdown(w, cx, &s, item.links(cx), heading_offset);\n         }\n     }\n+\n+    match &*item.kind {\n+        clean::ItemKind::FunctionItem(f) | clean::ItemKind::MethodItem(f, _) => {\n+            render_call_locations(w, cx, &f.call_locations);\n+        }\n+        _ => {}\n+    }\n }\n \n /// Add extra information about an item such as:\n@@ -2440,3 +2450,88 @@ fn collect_paths_for_type(first_ty: clean::Type, cache: &Cache) -> Vec<String> {\n     }\n     out\n }\n+\n+fn render_call_locations(\n+    w: &mut Buffer,\n+    cx: &Context<'_>,\n+    call_locations: &Option<FnCallLocations>,\n+) {\n+    let call_locations = match call_locations.as_ref() {\n+        Some(call_locations) => call_locations,\n+        None => {\n+            return;\n+        }\n+    };\n+\n+    let filtered_locations: Vec<_> = call_locations\n+        .iter()\n+        .filter_map(|(file, locs)| {\n+            // TODO(wcrichto): file I/O should be cached\n+            let mut contents = match fs::read_to_string(&file) {\n+                Ok(contents) => contents,\n+                Err(e) => {\n+                    eprintln!(\"Failed to read file {}\", e);\n+                    return None;\n+                }\n+            };\n+\n+            // Remove the utf-8 BOM if any\n+            if contents.starts_with('\\u{feff}') {\n+                contents.drain(..3);\n+            }\n+\n+            Some((file, contents, locs))\n+        })\n+        .collect();\n+\n+    let n_examples = filtered_locations.len();\n+    if n_examples == 0 {\n+        return;\n+    }\n+\n+    let id = cx.id_map.borrow_mut().derive(\"scraped-examples\");\n+    write!(\n+        w,\n+        r##\"<div class=\"docblock scraped-example-list\">\n+          <h1 id=\"scraped-examples\" class=\"small-section-header\">\n+             <a href=\"#{}\">Uses found in <code>examples/</code></a>\n+          </h1>\"##,\n+        id\n+    );\n+\n+    let write_example = |w: &mut Buffer, (file, contents, locs): (&String, String, _)| {\n+        let ex_title = match cx.shared.repository_url.as_ref() {\n+            Some(url) => format!(\n+                r#\"<a href=\"{url}/{file}\" target=\"_blank\">{file}</a>\"#,\n+                file = file,\n+                url = url\n+            ),\n+            None => file.clone(),\n+        };\n+        let edition = cx.shared.edition();\n+        write!(\n+            w,\n+            r#\"<div class=\"scraped-example\" data-code=\"{code}\" data-locs=\"{locations}\">\n+           <strong>{title}</strong>\n+           <div class=\"code-wrapper\">\"#,\n+            code = contents.replace(\"\\\"\", \"&quot;\"),\n+            locations = serde_json::to_string(&locs).unwrap(),\n+            title = ex_title,\n+        );\n+        write!(w, r#\"<span class=\"prev\">&pr;</span> <span class=\"next\">&sc;</span>\"#);\n+        write!(w, r#\"<span class=\"expand\">&varr;</span>\"#);\n+        sources::print_src(w, &contents, edition);\n+        write!(w, \"</div></div>\");\n+    };\n+\n+    let mut it = filtered_locations.into_iter();\n+    write_example(w, it.next().unwrap());\n+\n+    if n_examples > 1 {\n+        write!(w, r#\"<div class=\"more-scraped-examples hidden\">\"#);\n+        it.for_each(|ex| write_example(w, ex));\n+        write!(w, \"</div>\");\n+    }\n+\n+    write!(w, \"</div>\");\n+}"}, {"sha": "d6dead152051d82cec531f2d2d033d73a62293db", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda", "patch": "@@ -243,7 +243,7 @@ where\n \n /// Wrapper struct to render the source code of a file. This will do things like\n /// adding line numbers to the left-hand side.\n-fn print_src(\n+crate fn print_src(\n     buf: &mut Buffer,\n     s: &str,\n     edition: Edition,"}, {"sha": "ca8db4530f3ff5c08ed926ba50133507d92e59b4", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda", "patch": "@@ -1970,3 +1970,110 @@ details.undocumented[open] > summary::before {\n \t\tmargin-left: 12px;\n \t}\n }\n+\n+/* This part is for the new \"examples\" components */\n+\n+.scraped-example:not(.expanded) .code-wrapper pre.line-numbers, .scraped-example:not(.expanded) .code-wrapper .example-wrap pre.rust {\n+\toverflow: hidden;\n+\theight: 240px;\n+}\n+\n+.scraped-example .code-wrapper .prev {\n+\tposition: absolute;\n+\ttop: 0.25em;\n+\tright: 2.25em;\n+\tz-index: 100;\n+\tcursor: pointer;\n+}\n+\n+.scraped-example .code-wrapper .next {\n+\tposition: absolute;\n+\ttop: 0.25em;\n+\tright: 1.25em;\n+\tz-index: 100;\n+\tcursor: pointer;\n+}\n+\n+.scraped-example .code-wrapper .expand {\n+\tposition: absolute;\n+\ttop: 0.25em;\n+\tright: 0.25em;\n+\tz-index: 100;\n+\tcursor: pointer;\n+}\n+\n+.scraped-example .code-wrapper {\n+\tposition: relative;\n+\tdisplay: flex;\n+\tflex-direction: row;\n+\tflex-wrap: wrap;\n+\twidth: 100%;\n+}\n+\n+.scraped-example:not(.expanded) .code-wrapper:before {\n+\tcontent: \" \";\n+\twidth: 100%;\n+\theight: 20px;\n+\tposition: absolute;\n+\tz-index: 100;\n+\ttop: 0;\n+\tbackground: linear-gradient(to bottom, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0));\n+}\n+\n+.scraped-example:not(.expanded) .code-wrapper:after {\n+\tcontent: \" \";\n+\twidth: 100%;\n+\theight: 20px;\n+\tposition: absolute;\n+\tz-index: 100;\n+\tbottom: 0;\n+\tbackground: linear-gradient(to top, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0));\n+}\n+\n+.scraped-example:not(.expanded) .code-wrapper {\n+\toverflow: hidden;\n+\theight: 240px;\n+}\n+\n+.scraped-example .code-wrapper .line-numbers {\n+\tmargin: 0;\n+\tpadding: 14px 0;\n+}\n+\n+.scraped-example .code-wrapper .line-numbers span {\n+\tpadding: 0 14px;\n+}\n+\n+.scraped-example .code-wrapper .example-wrap {\n+\tflex: 1;\n+\toverflow-x: auto;\n+\toverflow-y: hidden;\n+\tmargin-bottom: 0;\n+}\n+\n+.scraped-example .code-wrapper .example-wrap pre.rust {\n+\toverflow-x: inherit;\n+\twidth: inherit;\n+\toverflow-y: hidden;\n+}\n+\n+.scraped-example .line-numbers span.highlight {\n+\tbackground: #f6fdb0;\n+}\n+\n+.scraped-example .example-wrap .rust span.highlight {\n+\tbackground: #f6fdb0;\n+}\n+\n+.more-scraped-examples {\n+\tpadding-left: 10px;\n+\tborder-left: 1px solid #ccc;\n+}\n+\n+.toggle-examples .collapse-toggle {\n+\tposition: relative;\n+}\n+\n+.toggle-examples a {\n+\tcolor: #999 !important; // FIXME(wcrichto): why is important needed\n+}"}, {"sha": "5ac00ff244ab2e6ee735aa92e9f945eadd305079", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda", "patch": "@@ -979,6 +979,202 @@ function hideThemeButtonState() {\n     onHashChange(null);\n     window.addEventListener(\"hashchange\", onHashChange);\n     searchState.setup();\n+\n+    /////// EXAMPLE ANALYZER\n+\n+    // Merge the full set of [from, to] offsets into a minimal set of non-overlapping\n+    // [from, to] offsets.\n+    // NB: This is such a archetypal software engineering interview question that\n+    // I can't believe I actually had to write it. Yes, it's O(N) in the input length --\n+    // but it does assume a sorted input!\n+    function distinctRegions(locs) {\n+        var start = -1;\n+        var end = -1;\n+        var output = [];\n+        for (var i = 0; i < locs.length; i++) {\n+            var loc = locs[i];\n+            if (loc[0] > end) {\n+                if (end > 0) {\n+                    output.push([start, end]);\n+                }\n+                start = loc[0];\n+                end = loc[1];\n+            } else {\n+                end = Math.max(end, loc[1]);\n+            }\n+        }\n+        if (end > 0) {\n+            output.push([start, end]);\n+        }\n+        return output;\n+    }\n+\n+    function convertLocsStartsToLineOffsets(code, locs) {\n+        locs = distinctRegions(locs.slice(0).sort(function (a, b) {\n+            return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];\n+        })); // sort by start; use end if start is equal.\n+        var codeLines = code.split(\"\\n\");\n+        var lineIndex = 0;\n+        var totalOffset = 0;\n+        var output = [];\n+\n+        while (locs.length > 0 && lineIndex < codeLines.length) {\n+            var lineLength = codeLines[lineIndex].length + 1; // +1 here and later is due to omitted \\n\n+            while (locs.length > 0 && totalOffset + lineLength > locs[0][0]) {\n+                var endIndex = lineIndex;\n+                var charsRemaining = locs[0][1] - totalOffset;\n+                while (endIndex < codeLines.length && charsRemaining > codeLines[endIndex].length + 1) {\n+                    charsRemaining -= codeLines[endIndex].length + 1;\n+                    endIndex += 1;\n+                }\n+                output.push({\n+                    from: [lineIndex, locs[0][0] - totalOffset],\n+                    to: [endIndex, charsRemaining]\n+                });\n+                locs.shift();\n+            }\n+            lineIndex++;\n+            totalOffset += lineLength;\n+        }\n+        return output;\n+    }\n+\n+    // inserts str into html, *but* calculates idx by eliding anything in html that's not in raw.\n+    // ideally this would work by walking the element tree...but this is good enough for now.\n+    function insertStrAtRawIndex(raw, html, idx, str) {\n+        if (idx > raw.length) {\n+            return html;\n+        }\n+        if (idx == raw.length) {\n+            return html + str;\n+        }\n+        var rawIdx = 0;\n+        var htmlIdx = 0;\n+        while (rawIdx < idx && rawIdx < raw.length) {\n+            while (raw[rawIdx] !== html[htmlIdx] && htmlIdx < html.length) {\n+                htmlIdx++;\n+            }\n+            rawIdx++;\n+            htmlIdx++;\n+        }\n+        return html.substring(0, htmlIdx) + str + html.substr(htmlIdx);\n+    }\n+\n+    // Scroll code block to put the given code location in the middle of the viewer\n+    function scrollToLoc(elt, loc) {\n+        var wrapper = elt.querySelector(\".code-wrapper\");\n+        var halfHeight = wrapper.offsetHeight / 2;\n+        var lines = elt.querySelector('.line-numbers');\n+        var offsetMid = (lines.children[loc.from[0]].offsetTop + lines.children[loc.to[0]].offsetTop) / 2;\n+        var scrollOffset = offsetMid - halfHeight;\n+        lines.scrollTo(0, scrollOffset);\n+        elt.querySelector(\".rust\").scrollTo(0, scrollOffset);\n+    }\n+\n+    function updateScrapedExample(example) {\n+        var code = example.attributes.getNamedItem(\"data-code\").textContent;\n+        var codeLines = code.split(\"\\n\");\n+        var locs = JSON.parse(example.attributes.getNamedItem(\"data-locs\").textContent);\n+        locs = convertLocsStartsToLineOffsets(code, locs);\n+\n+        // Add call-site highlights to code listings\n+        var litParent = example.querySelector('.example-wrap pre.rust');\n+        var litHtml = litParent.innerHTML.split(\"\\n\");\n+        onEach(locs, function (loc) {\n+            for (var i = loc.from[0]; i < loc.to[0] + 1; i++) {\n+                addClass(example.querySelector('.line-numbers').children[i], \"highlight\");\n+            }\n+            litHtml[loc.to[0]] = insertStrAtRawIndex(\n+                codeLines[loc.to[0]],\n+                litHtml[loc.to[0]],\n+                loc.to[1],\n+                \"</span>\");\n+            litHtml[loc.from[0]] = insertStrAtRawIndex(\n+                codeLines[loc.from[0]],\n+                litHtml[loc.from[0]],\n+                loc.from[1],\n+                '<span class=\"highlight\" data-loc=\"' + JSON.stringify(loc).replace(/\"/g, \"&quot;\") + '\">');\n+        }, true); // do this backwards to avoid shifting later offsets\n+        litParent.innerHTML = litHtml.join('\\n');\n+\n+        // Toggle through list of examples in a given file\n+        var locIndex = 0;\n+        if (locs.length > 1) {\n+            example.querySelector('.prev')\n+                .addEventListener('click', function () {\n+                    locIndex = (locIndex - 1 + locs.length) % locs.length;\n+                    scrollToLoc(example, locs[locIndex]);\n+                });\n+            example.querySelector('.next')\n+                .addEventListener('click', function () {\n+                    locIndex = (locIndex + 1) % locs.length;\n+                    scrollToLoc(example, locs[locIndex]);\n+                });\n+        } else {\n+            example.querySelector('.prev').remove();\n+            example.querySelector('.next').remove();\n+        }\n+\n+        // Show full code on expansion\n+        example.querySelector('.expand').addEventListener('click', function () {\n+            if (hasClass(example, \"expanded\")) {\n+                removeClass(example, \"expanded\");\n+                scrollToLoc(example, locs[0]);\n+            } else {\n+                addClass(example, \"expanded\");\n+            }\n+        });\n+\n+        // Start with the first example in view\n+        scrollToLoc(example, locs[0]);\n+    }\n+\n+    function updateScrapedExamples() {\n+        onEach(document.getElementsByClassName('scraped-example-list'), function (exampleSet) {\n+            updateScrapedExample(exampleSet.querySelector(\".small-section-header + .scraped-example\"));\n+        });\n+\n+        onEach(document.getElementsByClassName(\"more-scraped-examples\"), function (more) {\n+            var toggle = createSimpleToggle(true);\n+            var label = \"More examples\";\n+            var wrapper = createToggle(toggle, label, 14, \"toggle-examples\", false);\n+            more.parentNode.insertBefore(wrapper, more);\n+            var examples_init = false;\n+\n+            // Show additional examples on click\n+            wrapper.onclick = function () {\n+                if (hasClass(this, \"collapsed\")) {\n+                    removeClass(this, \"collapsed\");\n+                    onEachLazy(this.parentNode.getElementsByClassName(\"hidden\"), function (x) {\n+                        if (hasClass(x, \"content\") === false) {\n+                            removeClass(x, \"hidden\");\n+                            addClass(x, \"x\")\n+                        }\n+                    }, true);\n+                    this.querySelector('.toggle-label').innerHTML = \"Hide examples\";\n+                    this.querySelector('.inner').innerHTML = labelForToggleButton(false);\n+                    if (!examples_init) {\n+                        examples_init = true;\n+                        onEach(more.getElementsByClassName('scraped-example'), updateScrapedExample);\n+                    }\n+                } else {\n+                    addClass(this, \"collapsed\");\n+                    onEachLazy(this.parentNode.getElementsByClassName(\"x\"), function (x) {\n+                        if (hasClass(x, \"content\") === false) {\n+                            addClass(x, \"hidden\");\n+                            removeClass(x, \"x\")\n+                        }\n+                    }, true);\n+                    this.querySelector('.toggle-label').innerHTML = label;\n+                    this.querySelector('.inner').innerHTML = labelForToggleButton(true);\n+                }\n+            };\n+        });\n+    }\n+\n+    var start = Date.now();\n+    updateScrapedExamples();\n+    console.log(\"updated examples took\", Date.now() - start, \"ms\");\n }());\n \n (function () {"}, {"sha": "866514d7c9b5b3851681a5d83d8559b8db8b420c", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda", "patch": "@@ -289,7 +289,7 @@ crate fn from_fn_header(header: &rustc_hir::FnHeader) -> HashSet<Qualifiers> {\n \n impl FromWithTcx<clean::Function> for Function {\n     fn from_tcx(function: clean::Function, tcx: TyCtxt<'_>) -> Self {\n-        let clean::Function { decl, generics, header } = function;\n+        let clean::Function { decl, generics, header, call_locations: _ } = function;\n         Function {\n             decl: decl.into_tcx(tcx),\n             generics: generics.into_tcx(tcx),\n@@ -530,7 +530,7 @@ crate fn from_function_method(\n     has_body: bool,\n     tcx: TyCtxt<'_>,\n ) -> Method {\n-    let clean::Function { header, decl, generics } = function;\n+    let clean::Function { header, decl, generics, call_locations: _ } = function;\n     Method {\n         decl: decl.into_tcx(tcx),\n         generics: generics.into_tcx(tcx),"}, {"sha": "df0e309c94a0c4858c4352617c83cd4d28fb703f", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda", "patch": "@@ -119,6 +119,7 @@ mod json;\n crate mod lint;\n mod markdown;\n mod passes;\n+mod scrape_examples;\n mod theme;\n mod visit_ast;\n mod visit_lib;\n@@ -618,6 +619,8 @@ fn opts() -> Vec<RustcOptGroup> {\n                 \"Make the identifiers in the HTML source code pages navigable\",\n             )\n         }),\n+        unstable(\"scrape-examples\", |o| o.optmulti(\"\", \"scrape-examples\", \"\", \"\")),\n+        unstable(\"repository-url\", |o| o.optopt(\"\", \"repository-url\", \"\", \"TODO\")),\n     ]\n }\n \n@@ -697,7 +700,7 @@ fn run_renderer<'tcx, T: formats::FormatRenderer<'tcx>>(\n     }\n }\n \n-fn main_options(options: config::Options) -> MainResult {\n+fn main_options(mut options: config::Options) -> MainResult {\n     let diag = core::new_handler(options.error_format, None, &options.debugging_opts);\n \n     match (options.should_test, options.markdown_input()) {\n@@ -712,6 +715,15 @@ fn main_options(options: config::Options) -> MainResult {\n         (false, false) => {}\n     }\n \n+    if options.scrape_examples.len() > 0 {\n+        if let Some(crate_name) = &options.crate_name {\n+            options.render_options.call_locations =\n+                Some(scrape_examples::scrape(&options.scrape_examples, crate_name)?);\n+        } else {\n+            // raise an error?\n+        }\n+    }\n+\n     // need to move these items separately because we lose them by the time the closure is called,\n     // but we can't create the Handler ahead of time because it's not Send\n     let show_coverage = options.show_coverage;"}, {"sha": "da076f87a9c04c65302af04752a91525aaeb8621", "filename": "src/librustdoc/scrape_examples.rs", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda/src%2Flibrustdoc%2Fscrape_examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda/src%2Flibrustdoc%2Fscrape_examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fscrape_examples.rs?ref=4b3f82ad0321b8f2e2630b74bbc526ffb8fa5bda", "patch": "@@ -0,0 +1,138 @@\n+//! This module analyzes provided crates to find examples of uses for items in the\n+//! current crate being documented.\n+\n+use rayon::prelude::*;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::{\n+    self as hir,\n+    intravisit::{self, Visitor},\n+};\n+use rustc_interface::interface;\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::ty::{TyCtxt, TyKind};\n+use rustc_span::symbol::Symbol;\n+\n+crate type FnCallLocations = FxHashMap<String, Vec<(usize, usize)>>;\n+crate type AllCallLocations = FxHashMap<String, FnCallLocations>;\n+\n+/// Visitor for traversing a crate and finding instances of function calls.\n+struct FindCalls<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    map: Map<'tcx>,\n+\n+    /// Workspace-relative path to the root of the crate. Used to remember\n+    /// which example a particular call came from.\n+    file_name: String,\n+\n+    /// Name of the crate being documented, to filter out calls to irrelevant\n+    /// functions.\n+    krate: Symbol,\n+\n+    /// Data structure to accumulate call sites across all examples.\n+    calls: &'a mut AllCallLocations,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for FindCalls<'a, 'tcx>\n+where\n+    'tcx: 'a,\n+{\n+    type Map = Map<'tcx>;\n+\n+    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+        intravisit::NestedVisitorMap::OnlyBodies(self.map)\n+    }\n+\n+    fn visit_expr(&mut self, ex: &'tcx hir::Expr<'tcx>) {\n+        intravisit::walk_expr(self, ex);\n+\n+        // Get type of function if expression is a function call\n+        let types = self.tcx.typeck(ex.hir_id.owner);\n+        let (ty, span) = match ex.kind {\n+            hir::ExprKind::Call(f, _) => (types.node_type(f.hir_id), ex.span),\n+            hir::ExprKind::MethodCall(_, _, _, span) => {\n+                let types = self.tcx.typeck(ex.hir_id.owner);\n+                let def_id = types.type_dependent_def_id(ex.hir_id).unwrap();\n+                (self.tcx.type_of(def_id), span)\n+            }\n+            _ => {\n+                return;\n+            }\n+        };\n+\n+        // Save call site if the function resovles to a concrete definition\n+        if let TyKind::FnDef(def_id, _) = ty.kind() {\n+            if self.tcx.crate_name(def_id.krate) == self.krate {\n+                let key = self.tcx.def_path(*def_id).to_string_no_crate_verbose();\n+                let entries = self.calls.entry(key).or_insert_with(FxHashMap::default);\n+                entries\n+                    .entry(self.file_name.clone())\n+                    .or_insert_with(Vec::new)\n+                    .push((span.lo().0 as usize, span.hi().0 as usize));\n+            }\n+        }\n+    }\n+}\n+\n+struct Callbacks {\n+    calls: AllCallLocations,\n+    krate: String,\n+    file_name: String,\n+}\n+\n+impl rustc_driver::Callbacks for Callbacks {\n+    fn after_analysis<'tcx>(\n+        &mut self,\n+        _compiler: &rustc_interface::interface::Compiler,\n+        queries: &'tcx rustc_interface::Queries<'tcx>,\n+    ) -> rustc_driver::Compilation {\n+        queries.global_ctxt().unwrap().take().enter(|tcx| {\n+            let mut finder = FindCalls {\n+                calls: &mut self.calls,\n+                tcx,\n+                map: tcx.hir(),\n+                file_name: self.file_name.clone(),\n+                krate: Symbol::intern(&self.krate),\n+            };\n+            tcx.hir().krate().visit_all_item_likes(&mut finder.as_deep_visitor());\n+        });\n+\n+        rustc_driver::Compilation::Stop\n+    }\n+}\n+\n+/// Executes rustc on each example and collects call locations into a single structure.\n+///\n+/// # Arguments:\n+/// * `examples` is an array of invocations to rustc, generated by Cargo.\n+/// * `krate` is the name of the crate being documented.\n+pub fn scrape(examples: &[String], krate: &str) -> interface::Result<AllCallLocations> {\n+    // Scrape each crate in parallel\n+    // TODO(wcrichto): do we need optional support for no rayon?\n+    let maps = examples\n+        .par_iter()\n+        .map(|example| {\n+            // TODO(wcrichto): is there a more robust way to get arguments than split(\" \")?\n+            let mut args = example.split(\" \").map(|s| s.to_owned()).collect::<Vec<_>>();\n+            let file_name = args[0].clone();\n+            args.insert(0, \"_\".to_string());\n+\n+            // TODO(wcrichto): is there any setup / cleanup that needs to be performed\n+            // here upon the invocation of rustc_driver?\n+            debug!(\"Scraping examples from krate {} with args:\\n{:?}\", krate, args);\n+            let mut callbacks =\n+                Callbacks { calls: FxHashMap::default(), file_name, krate: krate.to_string() };\n+            rustc_driver::RunCompiler::new(&args, &mut callbacks).run()?;\n+            Ok(callbacks.calls)\n+        })\n+        .collect::<interface::Result<Vec<_>>>()?;\n+\n+    // Merge the call locations into a single result\n+    let mut all_map = FxHashMap::default();\n+    for map in maps {\n+        for (function, calls) in map.into_iter() {\n+            all_map.entry(function).or_insert_with(FxHashMap::default).extend(calls.into_iter());\n+        }\n+    }\n+\n+    Ok(all_map)\n+}"}]}