{"sha": "1a1e6b85f6f0976aad5bf3bd6aec7403163c62cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhMWU2Yjg1ZjZmMDk3NmFhZDViZjNiZDZhZWM3NDAzMTYzYzYyY2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-11T10:33:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-11T10:33:02Z"}, "message": "Auto merge of #28338 - erickt:str-cmp, r=bluss\n\nllvm seems to be having some trouble optimizing the iterator-based string comparsion method into some equivalent to memcmp. This explicitly calls out to the memcmp intrinisic in order to allow llvm to generate better code. In some manual benchmarking, this memcmp-based approach is 20 times faster than the iterator approach.", "tree": {"sha": "9247c0728d475d9120e77ca64619053d22df8c20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9247c0728d475d9120e77ca64619053d22df8c20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a1e6b85f6f0976aad5bf3bd6aec7403163c62cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a1e6b85f6f0976aad5bf3bd6aec7403163c62cc", "html_url": "https://github.com/rust-lang/rust/commit/1a1e6b85f6f0976aad5bf3bd6aec7403163c62cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a1e6b85f6f0976aad5bf3bd6aec7403163c62cc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "883b5cf9a92ba5a1fa76e40955c16ccc22d79c5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/883b5cf9a92ba5a1fa76e40955c16ccc22d79c5d", "html_url": "https://github.com/rust-lang/rust/commit/883b5cf9a92ba5a1fa76e40955c16ccc22d79c5d"}, {"sha": "fbd91a732b73dd73b4da8940bc32c4a7d5e6251b", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbd91a732b73dd73b4da8940bc32c4a7d5e6251b", "html_url": "https://github.com/rust-lang/rust/commit/fbd91a732b73dd73b4da8940bc32c4a7d5e6251b"}], "stats": {"total": 35, "additions": 20, "deletions": 15}, "files": [{"sha": "139f589e6c5799b7259a36aa39924051defff65e", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1a1e6b85f6f0976aad5bf3bd6aec7403163c62cc/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a1e6b85f6f0976aad5bf3bd6aec7403163c62cc/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=1a1e6b85f6f0976aad5bf3bd6aec7403163c62cc", "patch": "@@ -896,14 +896,18 @@ Section: Comparing strings\n #[lang = \"str_eq\"]\n #[inline]\n fn eq_slice(a: &str, b: &str) -> bool {\n+    a.len() == b.len() && unsafe { cmp_slice(a, b, a.len()) == 0 }\n+}\n+\n+/// Bytewise slice comparison.\n+/// NOTE: This uses the system's memcmp, which is currently dramatically\n+/// faster than comparing each byte in a loop.\n+#[inline]\n+unsafe fn cmp_slice(a: &str, b: &str, len: usize) -> i32 {\n     // NOTE: In theory n should be libc::size_t and not usize, but libc is not available here\n     #[allow(improper_ctypes)]\n     extern { fn memcmp(s1: *const i8, s2: *const i8, n: usize) -> i32; }\n-    a.len() == b.len() && unsafe {\n-        memcmp(a.as_ptr() as *const i8,\n-               b.as_ptr() as *const i8,\n-               a.len()) == 0\n-    }\n+    memcmp(a.as_ptr() as *const i8, b.as_ptr() as *const i8, len)\n }\n \n /*\n@@ -1039,8 +1043,8 @@ Section: Trait implementations\n */\n \n mod traits {\n-    use cmp::{Ordering, Ord, PartialEq, PartialOrd, Eq};\n-    use cmp::Ordering::{Less, Equal, Greater};\n+    use cmp::{self, Ordering, Ord, PartialEq, PartialOrd, Eq};\n+    use cmp::Ordering::{Less, Greater};\n     use iter::Iterator;\n     use option::Option;\n     use option::Option::Some;\n@@ -1051,15 +1055,16 @@ mod traits {\n     impl Ord for str {\n         #[inline]\n         fn cmp(&self, other: &str) -> Ordering {\n-            for (s_b, o_b) in self.bytes().zip(other.bytes()) {\n-                match s_b.cmp(&o_b) {\n-                    Greater => return Greater,\n-                    Less => return Less,\n-                    Equal => ()\n-                }\n+            let cmp = unsafe {\n+                super::cmp_slice(self, other, cmp::min(self.len(), other.len()))\n+            };\n+            if cmp == 0 {\n+                self.len().cmp(&other.len())\n+            } else if cmp < 0 {\n+                Less\n+            } else {\n+                Greater\n             }\n-\n-            self.len().cmp(&other.len())\n         }\n     }\n "}]}