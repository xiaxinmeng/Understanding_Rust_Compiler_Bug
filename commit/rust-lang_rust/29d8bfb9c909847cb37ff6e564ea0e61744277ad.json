{"sha": "29d8bfb9c909847cb37ff6e564ea0e61744277ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5ZDhiZmI5YzkwOTg0N2NiMzdmZjZlNTY0ZWEwZTYxNzQ0Mjc3YWQ=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-02T14:26:06Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-02T14:26:06Z"}, "message": "Merge #404\n\n404: Move FileSymbol to ra_analysis r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "53e4d51b9a80330e3ebb53959ed2a2a67a605fbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53e4d51b9a80330e3ebb53959ed2a2a67a605fbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29d8bfb9c909847cb37ff6e564ea0e61744277ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29d8bfb9c909847cb37ff6e564ea0e61744277ad", "html_url": "https://github.com/rust-lang/rust/commit/29d8bfb9c909847cb37ff6e564ea0e61744277ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29d8bfb9c909847cb37ff6e564ea0e61744277ad/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "afa972e78d2d81598c02b742ab84d70c88208300", "url": "https://api.github.com/repos/rust-lang/rust/commits/afa972e78d2d81598c02b742ab84d70c88208300", "html_url": "https://github.com/rust-lang/rust/commit/afa972e78d2d81598c02b742ab84d70c88208300"}, {"sha": "76910639e6930d1d76ec0a5d7c11219e073b73be", "url": "https://api.github.com/repos/rust-lang/rust/commits/76910639e6930d1d76ec0a5d7c11219e073b73be", "html_url": "https://github.com/rust-lang/rust/commit/76910639e6930d1d76ec0a5d7c11219e073b73be"}], "stats": {"total": 627, "additions": 329, "deletions": 298}, "files": [{"sha": "8071554a7021634a652d759f07b7c2c7d28a6944", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/29d8bfb9c909847cb37ff6e564ea0e61744277ad/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29d8bfb9c909847cb37ff6e564ea0e61744277ad/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=29d8bfb9c909847cb37ff6e564ea0e61744277ad", "patch": "@@ -10,7 +10,7 @@ use hir::{\n     self, FnSignatureInfo, Problem, source_binder,\n };\n use ra_db::{FilesDatabase, SourceRoot, SourceRootId, SyntaxDatabase};\n-use ra_editor::{self, FileSymbol, find_node_at_offset, LineIndex, LocalEdit, Severity};\n+use ra_editor::{self, find_node_at_offset, LineIndex, LocalEdit, Severity};\n use ra_syntax::{\n     algo::find_covering_node,\n     ast::{self, ArgListOwner, Expr, FnDef, NameOwner},\n@@ -21,11 +21,11 @@ use ra_syntax::{\n \n use crate::{\n     AnalysisChange,\n-    Cancelable,\n+    Cancelable, NavigationTarget,\n     completion::{CompletionItem, completions},\n     CrateId, db, Diagnostic, FileId, FilePosition, FileRange, FileSystemEdit,\n     Query, ReferenceResolution, RootChange, SourceChange, SourceFileEdit,\n-    symbol_index::{LibrarySymbolsQuery, SymbolIndex, SymbolsDatabase},\n+    symbol_index::{LibrarySymbolsQuery, SymbolIndex, SymbolsDatabase, FileSymbol},\n };\n \n #[derive(Debug, Default)]\n@@ -205,7 +205,7 @@ impl AnalysisImpl {\n \n     /// This returns `Vec` because a module may be included from several places. We\n     /// don't handle this case yet though, so the Vec has length at most one.\n-    pub fn parent_module(&self, position: FilePosition) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n+    pub fn parent_module(&self, position: FilePosition) -> Cancelable<Vec<NavigationTarget>> {\n         let descr = match source_binder::module_from_position(&*self.db, position)? {\n             None => return Ok(Vec::new()),\n             Some(it) => it,\n@@ -216,12 +216,12 @@ impl AnalysisImpl {\n         };\n         let decl = decl.borrowed();\n         let decl_name = decl.name().unwrap();\n-        let sym = FileSymbol {\n+        let symbol = FileSymbol {\n             name: decl_name.text(),\n             node_range: decl_name.syntax().range(),\n             kind: MODULE,\n         };\n-        Ok(vec![(file_id, sym)])\n+        Ok(vec![NavigationTarget { file_id, symbol }])\n     }\n     /// Returns `Vec` for the same reason as `parent_module`\n     pub fn crate_for(&self, file_id: FileId) -> Cancelable<Vec<CrateId>> {\n@@ -355,9 +355,9 @@ impl AnalysisImpl {\n             Ok(Some((binding, descr)))\n         }\n     }\n-    pub fn doc_text_for(&self, file_id: FileId, symbol: FileSymbol) -> Cancelable<Option<String>> {\n-        let file = self.db.source_file(file_id);\n-        let result = match (symbol.description(&file), symbol.docs(&file)) {\n+    pub fn doc_text_for(&self, nav: NavigationTarget) -> Cancelable<Option<String>> {\n+        let file = self.db.source_file(nav.file_id);\n+        let result = match (nav.symbol.description(&file), nav.symbol.docs(&file)) {\n             (Some(desc), Some(docs)) => {\n                 Some(\"```rust\\n\".to_string() + &*desc + \"\\n```\\n\\n\" + &*docs)\n             }"}, {"sha": "9576453ab43c088d5a41f0aca987ec246a6d44e6", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 38, "deletions": 11, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/29d8bfb9c909847cb37ff6e564ea0e61744277ad/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29d8bfb9c909847cb37ff6e564ea0e61744277ad/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=29d8bfb9c909847cb37ff6e564ea0e61744277ad", "patch": "@@ -23,22 +23,22 @@ mod syntax_highlighting;\n use std::{fmt, sync::Arc};\n \n use rustc_hash::FxHashMap;\n-use ra_syntax::{SourceFileNode, TextRange, TextUnit};\n+use ra_syntax::{SourceFileNode, TextRange, TextUnit, SmolStr, SyntaxKind};\n use ra_text_edit::TextEdit;\n use rayon::prelude::*;\n use relative_path::RelativePathBuf;\n \n use crate::{\n     imp::{AnalysisHostImpl, AnalysisImpl},\n-    symbol_index::SymbolIndex,\n+    symbol_index::{SymbolIndex, FileSymbol},\n };\n \n pub use crate::{\n     completion::{CompletionItem, CompletionItemKind, InsertText},\n-    runnables::{Runnable, RunnableKind}\n+    runnables::{Runnable, RunnableKind},\n };\n pub use ra_editor::{\n-    FileSymbol, Fold, FoldKind, HighlightedRange, LineIndex, StructureNode, Severity\n+    Fold, FoldKind, HighlightedRange, LineIndex, StructureNode, Severity\n };\n pub use hir::FnSignatureInfo;\n \n@@ -242,6 +242,27 @@ impl Query {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct NavigationTarget {\n+    file_id: FileId,\n+    symbol: FileSymbol,\n+}\n+\n+impl NavigationTarget {\n+    pub fn name(&self) -> SmolStr {\n+        self.symbol.name.clone()\n+    }\n+    pub fn kind(&self) -> SyntaxKind {\n+        self.symbol.kind\n+    }\n+    pub fn file_id(&self) -> FileId {\n+        self.file_id\n+    }\n+    pub fn range(&self) -> TextRange {\n+        self.symbol.node_range\n+    }\n+}\n+\n /// Result of \"goto def\" query.\n #[derive(Debug)]\n pub struct ReferenceResolution {\n@@ -250,7 +271,7 @@ pub struct ReferenceResolution {\n     /// client where the reference was.\n     pub reference_range: TextRange,\n     /// What this reference resolves to.\n-    pub resolves_to: Vec<(FileId, FileSymbol)>,\n+    pub resolves_to: Vec<NavigationTarget>,\n }\n \n impl ReferenceResolution {\n@@ -262,7 +283,7 @@ impl ReferenceResolution {\n     }\n \n     fn add_resolution(&mut self, file_id: FileId, symbol: FileSymbol) {\n-        self.resolves_to.push((file_id, symbol))\n+        self.resolves_to.push(NavigationTarget { file_id, symbol })\n     }\n }\n \n@@ -320,8 +341,14 @@ impl Analysis {\n         let file = self.imp.file_syntax(file_id);\n         ra_editor::folding_ranges(&file)\n     }\n-    pub fn symbol_search(&self, query: Query) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n-        self.imp.world_symbols(query)\n+    pub fn symbol_search(&self, query: Query) -> Cancelable<Vec<NavigationTarget>> {\n+        let res = self\n+            .imp\n+            .world_symbols(query)?\n+            .into_iter()\n+            .map(|(file_id, symbol)| NavigationTarget { file_id, symbol })\n+            .collect();\n+        Ok(res)\n     }\n     pub fn approximately_resolve_symbol(\n         &self,\n@@ -332,10 +359,10 @@ impl Analysis {\n     pub fn find_all_refs(&self, position: FilePosition) -> Cancelable<Vec<(FileId, TextRange)>> {\n         self.imp.find_all_refs(position)\n     }\n-    pub fn doc_text_for(&self, file_id: FileId, symbol: FileSymbol) -> Cancelable<Option<String>> {\n-        self.imp.doc_text_for(file_id, symbol)\n+    pub fn doc_text_for(&self, nav: NavigationTarget) -> Cancelable<Option<String>> {\n+        self.imp.doc_text_for(nav)\n     }\n-    pub fn parent_module(&self, position: FilePosition) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n+    pub fn parent_module(&self, position: FilePosition) -> Cancelable<Vec<NavigationTarget>> {\n         self.imp.parent_module(position)\n     }\n     pub fn module_path(&self, position: FilePosition) -> Cancelable<Option<String>> {"}, {"sha": "56a84a85089b0718ab19c9f48ee940b985fda968", "filename": "crates/ra_analysis/src/symbol_index.rs", "status": "modified", "additions": 119, "deletions": 4, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/29d8bfb9c909847cb37ff6e564ea0e61744277ad/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29d8bfb9c909847cb37ff6e564ea0e61744277ad/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs?ref=29d8bfb9c909847cb37ff6e564ea0e61744277ad", "patch": "@@ -4,10 +4,11 @@ use std::{\n };\n \n use fst::{self, Streamer};\n-use ra_editor::{self, FileSymbol};\n use ra_syntax::{\n-    SourceFileNode,\n+    AstNode, SyntaxNodeRef, SourceFileNode, SmolStr, TextRange,\n+    algo::visit::{visitor, Visitor},\n     SyntaxKind::{self, *},\n+    ast::{self, NameOwner, DocCommentsOwner},\n };\n use ra_db::{SyntaxDatabase, SourceRootId};\n use rayon::prelude::*;\n@@ -65,8 +66,9 @@ impl SymbolIndex {\n     ) -> SymbolIndex {\n         let mut symbols = files\n             .flat_map(|(file_id, file)| {\n-                ra_editor::file_symbols(&file)\n-                    .into_iter()\n+                file.syntax()\n+                    .descendants()\n+                    .filter_map(to_symbol)\n                     .map(move |symbol| (symbol.name.as_str().to_lowercase(), (file_id, symbol)))\n                     .collect::<Vec<_>>()\n             })\n@@ -121,3 +123,116 @@ fn is_type(kind: SyntaxKind) -> bool {\n         _ => false,\n     }\n }\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub(crate) struct FileSymbol {\n+    pub(crate) name: SmolStr,\n+    pub(crate) node_range: TextRange,\n+    pub(crate) kind: SyntaxKind,\n+}\n+\n+impl FileSymbol {\n+    pub(crate) fn docs(&self, file: &SourceFileNode) -> Option<String> {\n+        file.syntax()\n+            .descendants()\n+            .filter(|node| node.kind() == self.kind && node.range() == self.node_range)\n+            .filter_map(|node: SyntaxNodeRef| {\n+                fn doc_comments<'a, N: DocCommentsOwner<'a>>(node: N) -> Option<String> {\n+                    let comments = node.doc_comment_text();\n+                    if comments.is_empty() {\n+                        None\n+                    } else {\n+                        Some(comments)\n+                    }\n+                }\n+\n+                visitor()\n+                    .visit(doc_comments::<ast::FnDef>)\n+                    .visit(doc_comments::<ast::StructDef>)\n+                    .visit(doc_comments::<ast::EnumDef>)\n+                    .visit(doc_comments::<ast::TraitDef>)\n+                    .visit(doc_comments::<ast::Module>)\n+                    .visit(doc_comments::<ast::TypeDef>)\n+                    .visit(doc_comments::<ast::ConstDef>)\n+                    .visit(doc_comments::<ast::StaticDef>)\n+                    .accept(node)?\n+            })\n+            .nth(0)\n+    }\n+    /// Get a description of this node.\n+    ///\n+    /// e.g. `struct Name`, `enum Name`, `fn Name`\n+    pub(crate) fn description(&self, file: &SourceFileNode) -> Option<String> {\n+        // TODO: After type inference is done, add type information to improve the output\n+        file.syntax()\n+            .descendants()\n+            .filter(|node| node.kind() == self.kind && node.range() == self.node_range)\n+            .filter_map(|node: SyntaxNodeRef| {\n+                // TODO: Refactor to be have less repetition\n+                visitor()\n+                    .visit(|node: ast::FnDef| {\n+                        let mut string = \"fn \".to_string();\n+                        node.name()?.syntax().text().push_to(&mut string);\n+                        Some(string)\n+                    })\n+                    .visit(|node: ast::StructDef| {\n+                        let mut string = \"struct \".to_string();\n+                        node.name()?.syntax().text().push_to(&mut string);\n+                        Some(string)\n+                    })\n+                    .visit(|node: ast::EnumDef| {\n+                        let mut string = \"enum \".to_string();\n+                        node.name()?.syntax().text().push_to(&mut string);\n+                        Some(string)\n+                    })\n+                    .visit(|node: ast::TraitDef| {\n+                        let mut string = \"trait \".to_string();\n+                        node.name()?.syntax().text().push_to(&mut string);\n+                        Some(string)\n+                    })\n+                    .visit(|node: ast::Module| {\n+                        let mut string = \"mod \".to_string();\n+                        node.name()?.syntax().text().push_to(&mut string);\n+                        Some(string)\n+                    })\n+                    .visit(|node: ast::TypeDef| {\n+                        let mut string = \"type \".to_string();\n+                        node.name()?.syntax().text().push_to(&mut string);\n+                        Some(string)\n+                    })\n+                    .visit(|node: ast::ConstDef| {\n+                        let mut string = \"const \".to_string();\n+                        node.name()?.syntax().text().push_to(&mut string);\n+                        Some(string)\n+                    })\n+                    .visit(|node: ast::StaticDef| {\n+                        let mut string = \"static \".to_string();\n+                        node.name()?.syntax().text().push_to(&mut string);\n+                        Some(string)\n+                    })\n+                    .accept(node)?\n+            })\n+            .nth(0)\n+    }\n+}\n+\n+fn to_symbol(node: SyntaxNodeRef) -> Option<FileSymbol> {\n+    fn decl<'a, N: NameOwner<'a>>(node: N) -> Option<FileSymbol> {\n+        let name = node.name()?;\n+        Some(FileSymbol {\n+            name: name.text(),\n+            node_range: node.syntax().range(),\n+            kind: node.syntax().kind(),\n+        })\n+    }\n+    visitor()\n+        .visit(decl::<ast::FnDef>)\n+        .visit(decl::<ast::StructDef>)\n+        .visit(decl::<ast::EnumDef>)\n+        .visit(decl::<ast::TraitDef>)\n+        .visit(decl::<ast::Module>)\n+        .visit(decl::<ast::TypeDef>)\n+        .visit(decl::<ast::ConstDef>)\n+        .visit(decl::<ast::StaticDef>)\n+        .accept(node)?\n+}"}, {"sha": "845fff3c6d22c5b0bd2f92e3e9dcdaa9dfa38d68", "filename": "crates/ra_analysis/tests/tests.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/29d8bfb9c909847cb37ff6e564ea0e61744277ad/crates%2Fra_analysis%2Ftests%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29d8bfb9c909847cb37ff6e564ea0e61744277ad/crates%2Fra_analysis%2Ftests%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Ftests%2Ftests.rs?ref=29d8bfb9c909847cb37ff6e564ea0e61744277ad", "patch": "@@ -25,7 +25,7 @@ fn approximate_resolve_works_in_items() {\n     assert_eq_dbg(\n         r#\"ReferenceResolution {\n             reference_range: [23; 26),\n-            resolves_to: [(FileId(1), FileSymbol { name: \"Foo\", node_range: [0; 11), kind: STRUCT_DEF })]\n+            resolves_to: [NavigationTarget { file_id: FileId(1), symbol: FileSymbol { name: \"Foo\", node_range: [0; 11), kind: STRUCT_DEF } }]\n         }\"#,\n         &symbols,\n     );\n@@ -46,7 +46,7 @@ fn test_resolve_module() {\n     assert_eq_dbg(\n         r#\"ReferenceResolution {\n             reference_range: [4; 7),\n-            resolves_to: [(FileId(2), FileSymbol { name: \"foo\", node_range: [0; 0), kind: MODULE })]\n+            resolves_to: [NavigationTarget { file_id: FileId(2), symbol: FileSymbol { name: \"foo\", node_range: [0; 0), kind: MODULE } }]\n         }\"#,\n         &symbols,\n     );\n@@ -64,7 +64,7 @@ fn test_resolve_module() {\n     assert_eq_dbg(\n         r#\"ReferenceResolution {\n             reference_range: [4; 7),\n-            resolves_to: [(FileId(2), FileSymbol { name: \"foo\", node_range: [0; 0), kind: MODULE })]\n+            resolves_to: [NavigationTarget { file_id: FileId(2), symbol: FileSymbol { name: \"foo\", node_range: [0; 0), kind: MODULE } }]\n         }\"#,\n         &symbols,\n     );\n@@ -107,7 +107,7 @@ fn test_resolve_parent_module() {\n     );\n     let symbols = analysis.parent_module(pos).unwrap();\n     assert_eq_dbg(\n-        r#\"[(FileId(1), FileSymbol { name: \"foo\", node_range: [4; 7), kind: MODULE })]\"#,\n+        r#\"[NavigationTarget { file_id: FileId(1), symbol: FileSymbol { name: \"foo\", node_range: [4; 7), kind: MODULE } }]\"#,\n         &symbols,\n     );\n }\n@@ -126,7 +126,7 @@ fn test_resolve_parent_module_for_inline() {\n     );\n     let symbols = analysis.parent_module(pos).unwrap();\n     assert_eq_dbg(\n-        r#\"[(FileId(1), FileSymbol { name: \"bar\", node_range: [18; 21), kind: MODULE })]\"#,\n+        r#\"[NavigationTarget { file_id: FileId(1), symbol: FileSymbol { name: \"bar\", node_range: [18; 21), kind: MODULE } }]\"#,\n         &symbols,\n     );\n }"}, {"sha": "bfc745e58c355f4c630b546c14a95eaa0b39606d", "filename": "crates/ra_editor/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29d8bfb9c909847cb37ff6e564ea0e61744277ad/crates%2Fra_editor%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29d8bfb9c909847cb37ff6e564ea0e61744277ad/crates%2Fra_editor%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Flib.rs?ref=29d8bfb9c909847cb37ff6e564ea0e61744277ad", "patch": "@@ -3,7 +3,7 @@ mod extend_selection;\n mod folding_ranges;\n mod line_index;\n mod line_index_utils;\n-mod symbols;\n+mod structure;\n #[cfg(test)]\n mod test_utils;\n mod typing;\n@@ -15,7 +15,7 @@ pub use self::{\n     folding_ranges::{folding_ranges, Fold, FoldKind},\n     line_index::{LineCol, LineIndex},\n     line_index_utils::translate_offset_with_edit,\n-    symbols::{file_structure, file_symbols, FileSymbol, StructureNode},\n+    structure::{file_structure, StructureNode},\n     typing::{join_lines, on_enter, on_eq_typed},\n     diagnostics::diagnostics\n };"}, {"sha": "2292b1ddf0f6699bf5e21a1febe5dac6c4ef3389", "filename": "crates/ra_editor/src/structure.rs", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/29d8bfb9c909847cb37ff6e564ea0e61744277ad/crates%2Fra_editor%2Fsrc%2Fstructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29d8bfb9c909847cb37ff6e564ea0e61744277ad/crates%2Fra_editor%2Fsrc%2Fstructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fstructure.rs?ref=29d8bfb9c909847cb37ff6e564ea0e61744277ad", "patch": "@@ -0,0 +1,129 @@\n+use crate::TextRange;\n+\n+use ra_syntax::{\n+    algo::visit::{visitor, Visitor},\n+    ast::{self, NameOwner},\n+    AstNode, SourceFileNode, SyntaxKind, SyntaxNodeRef, WalkEvent,\n+};\n+\n+#[derive(Debug, Clone)]\n+pub struct StructureNode {\n+    pub parent: Option<usize>,\n+    pub label: String,\n+    pub navigation_range: TextRange,\n+    pub node_range: TextRange,\n+    pub kind: SyntaxKind,\n+}\n+\n+pub fn file_structure(file: &SourceFileNode) -> Vec<StructureNode> {\n+    let mut res = Vec::new();\n+    let mut stack = Vec::new();\n+\n+    for event in file.syntax().preorder() {\n+        match event {\n+            WalkEvent::Enter(node) => {\n+                if let Some(mut symbol) = structure_node(node) {\n+                    symbol.parent = stack.last().map(|&n| n);\n+                    stack.push(res.len());\n+                    res.push(symbol);\n+                }\n+            }\n+            WalkEvent::Leave(node) => {\n+                if structure_node(node).is_some() {\n+                    stack.pop().unwrap();\n+                }\n+            }\n+        }\n+    }\n+    res\n+}\n+\n+fn structure_node(node: SyntaxNodeRef) -> Option<StructureNode> {\n+    fn decl<'a, N: NameOwner<'a>>(node: N) -> Option<StructureNode> {\n+        let name = node.name()?;\n+        Some(StructureNode {\n+            parent: None,\n+            label: name.text().to_string(),\n+            navigation_range: name.syntax().range(),\n+            node_range: node.syntax().range(),\n+            kind: node.syntax().kind(),\n+        })\n+    }\n+\n+    visitor()\n+        .visit(decl::<ast::FnDef>)\n+        .visit(decl::<ast::StructDef>)\n+        .visit(decl::<ast::NamedFieldDef>)\n+        .visit(decl::<ast::EnumDef>)\n+        .visit(decl::<ast::TraitDef>)\n+        .visit(decl::<ast::Module>)\n+        .visit(decl::<ast::TypeDef>)\n+        .visit(decl::<ast::ConstDef>)\n+        .visit(decl::<ast::StaticDef>)\n+        .visit(|im: ast::ImplItem| {\n+            let target_type = im.target_type()?;\n+            let target_trait = im.target_trait();\n+            let label = match target_trait {\n+                None => format!(\"impl {}\", target_type.syntax().text()),\n+                Some(t) => format!(\n+                    \"impl {} for {}\",\n+                    t.syntax().text(),\n+                    target_type.syntax().text(),\n+                ),\n+            };\n+\n+            let node = StructureNode {\n+                parent: None,\n+                label,\n+                navigation_range: target_type.syntax().range(),\n+                node_range: im.syntax().range(),\n+                kind: im.syntax().kind(),\n+            };\n+            Some(node)\n+        })\n+        .accept(node)?\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use test_utils::assert_eq_dbg;\n+\n+    #[test]\n+    fn test_file_structure() {\n+        let file = SourceFileNode::parse(\n+            r#\"\n+struct Foo {\n+    x: i32\n+}\n+\n+mod m {\n+    fn bar() {}\n+}\n+\n+enum E { X, Y(i32) }\n+type T = ();\n+static S: i32 = 92;\n+const C: i32 = 92;\n+\n+impl E {}\n+\n+impl fmt::Debug for E {}\n+\"#,\n+        );\n+        let structure = file_structure(&file);\n+        assert_eq_dbg(\n+            r#\"[StructureNode { parent: None, label: \"Foo\", navigation_range: [8; 11), node_range: [1; 26), kind: STRUCT_DEF },\n+                StructureNode { parent: Some(0), label: \"x\", navigation_range: [18; 19), node_range: [18; 24), kind: NAMED_FIELD_DEF },\n+                StructureNode { parent: None, label: \"m\", navigation_range: [32; 33), node_range: [28; 53), kind: MODULE },\n+                StructureNode { parent: Some(2), label: \"bar\", navigation_range: [43; 46), node_range: [40; 51), kind: FN_DEF },\n+                StructureNode { parent: None, label: \"E\", navigation_range: [60; 61), node_range: [55; 75), kind: ENUM_DEF },\n+                StructureNode { parent: None, label: \"T\", navigation_range: [81; 82), node_range: [76; 88), kind: TYPE_DEF },\n+                StructureNode { parent: None, label: \"S\", navigation_range: [96; 97), node_range: [89; 108), kind: STATIC_DEF },\n+                StructureNode { parent: None, label: \"C\", navigation_range: [115; 116), node_range: [109; 127), kind: CONST_DEF },\n+                StructureNode { parent: None, label: \"impl E\", navigation_range: [134; 135), node_range: [129; 138), kind: IMPL_ITEM },\n+                StructureNode { parent: None, label: \"impl fmt::Debug for E\", navigation_range: [160; 161), node_range: [140; 164), kind: IMPL_ITEM }]\"#,\n+            &structure,\n+        )\n+    }\n+}"}, {"sha": "9e25decfbc311c6544c55c99aedcaeaba32b08cb", "filename": "crates/ra_editor/src/symbols.rs", "status": "removed", "additions": 0, "deletions": 246, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_editor%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa972e78d2d81598c02b742ab84d70c88208300/crates%2Fra_editor%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fsymbols.rs?ref=afa972e78d2d81598c02b742ab84d70c88208300", "patch": "@@ -1,246 +0,0 @@\n-use crate::TextRange;\n-\n-use ra_syntax::{\n-    algo::visit::{visitor, Visitor},\n-    ast::{self, DocCommentsOwner, NameOwner},\n-    AstNode, SourceFileNode, SmolStr, SyntaxKind, SyntaxNodeRef, WalkEvent,\n-};\n-\n-#[derive(Debug, Clone)]\n-pub struct StructureNode {\n-    pub parent: Option<usize>,\n-    pub label: String,\n-    pub navigation_range: TextRange,\n-    pub node_range: TextRange,\n-    pub kind: SyntaxKind,\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct FileSymbol {\n-    pub name: SmolStr,\n-    pub node_range: TextRange,\n-    pub kind: SyntaxKind,\n-}\n-\n-impl FileSymbol {\n-    pub fn docs(&self, file: &SourceFileNode) -> Option<String> {\n-        file.syntax()\n-            .descendants()\n-            .filter(|node| node.kind() == self.kind && node.range() == self.node_range)\n-            .filter_map(|node: SyntaxNodeRef| {\n-                fn doc_comments<'a, N: DocCommentsOwner<'a>>(node: N) -> Option<String> {\n-                    let comments = node.doc_comment_text();\n-                    if comments.is_empty() {\n-                        None\n-                    } else {\n-                        Some(comments)\n-                    }\n-                }\n-\n-                visitor()\n-                    .visit(doc_comments::<ast::FnDef>)\n-                    .visit(doc_comments::<ast::StructDef>)\n-                    .visit(doc_comments::<ast::EnumDef>)\n-                    .visit(doc_comments::<ast::TraitDef>)\n-                    .visit(doc_comments::<ast::Module>)\n-                    .visit(doc_comments::<ast::TypeDef>)\n-                    .visit(doc_comments::<ast::ConstDef>)\n-                    .visit(doc_comments::<ast::StaticDef>)\n-                    .accept(node)?\n-            })\n-            .nth(0)\n-    }\n-    /// Get a description of this node.\n-    ///\n-    /// e.g. `struct Name`, `enum Name`, `fn Name`\n-    pub fn description(&self, file: &SourceFileNode) -> Option<String> {\n-        // TODO: After type inference is done, add type information to improve the output\n-        file.syntax()\n-            .descendants()\n-            .filter(|node| node.kind() == self.kind && node.range() == self.node_range)\n-            .filter_map(|node: SyntaxNodeRef| {\n-                // TODO: Refactor to be have less repetition\n-                visitor()\n-                    .visit(|node: ast::FnDef| {\n-                        let mut string = \"fn \".to_string();\n-                        node.name()?.syntax().text().push_to(&mut string);\n-                        Some(string)\n-                    })\n-                    .visit(|node: ast::StructDef| {\n-                        let mut string = \"struct \".to_string();\n-                        node.name()?.syntax().text().push_to(&mut string);\n-                        Some(string)\n-                    })\n-                    .visit(|node: ast::EnumDef| {\n-                        let mut string = \"enum \".to_string();\n-                        node.name()?.syntax().text().push_to(&mut string);\n-                        Some(string)\n-                    })\n-                    .visit(|node: ast::TraitDef| {\n-                        let mut string = \"trait \".to_string();\n-                        node.name()?.syntax().text().push_to(&mut string);\n-                        Some(string)\n-                    })\n-                    .visit(|node: ast::Module| {\n-                        let mut string = \"mod \".to_string();\n-                        node.name()?.syntax().text().push_to(&mut string);\n-                        Some(string)\n-                    })\n-                    .visit(|node: ast::TypeDef| {\n-                        let mut string = \"type \".to_string();\n-                        node.name()?.syntax().text().push_to(&mut string);\n-                        Some(string)\n-                    })\n-                    .visit(|node: ast::ConstDef| {\n-                        let mut string = \"const \".to_string();\n-                        node.name()?.syntax().text().push_to(&mut string);\n-                        Some(string)\n-                    })\n-                    .visit(|node: ast::StaticDef| {\n-                        let mut string = \"static \".to_string();\n-                        node.name()?.syntax().text().push_to(&mut string);\n-                        Some(string)\n-                    })\n-                    .accept(node)?\n-            })\n-            .nth(0)\n-    }\n-}\n-\n-pub fn file_symbols(file: &SourceFileNode) -> Vec<FileSymbol> {\n-    file.syntax().descendants().filter_map(to_symbol).collect()\n-}\n-\n-fn to_symbol(node: SyntaxNodeRef) -> Option<FileSymbol> {\n-    fn decl<'a, N: NameOwner<'a>>(node: N) -> Option<FileSymbol> {\n-        let name = node.name()?;\n-        Some(FileSymbol {\n-            name: name.text(),\n-            node_range: node.syntax().range(),\n-            kind: node.syntax().kind(),\n-        })\n-    }\n-    visitor()\n-        .visit(decl::<ast::FnDef>)\n-        .visit(decl::<ast::StructDef>)\n-        .visit(decl::<ast::EnumDef>)\n-        .visit(decl::<ast::TraitDef>)\n-        .visit(decl::<ast::Module>)\n-        .visit(decl::<ast::TypeDef>)\n-        .visit(decl::<ast::ConstDef>)\n-        .visit(decl::<ast::StaticDef>)\n-        .accept(node)?\n-}\n-\n-pub fn file_structure(file: &SourceFileNode) -> Vec<StructureNode> {\n-    let mut res = Vec::new();\n-    let mut stack = Vec::new();\n-\n-    for event in file.syntax().preorder() {\n-        match event {\n-            WalkEvent::Enter(node) => {\n-                if let Some(mut symbol) = structure_node(node) {\n-                    symbol.parent = stack.last().map(|&n| n);\n-                    stack.push(res.len());\n-                    res.push(symbol);\n-                }\n-            }\n-            WalkEvent::Leave(node) => {\n-                if structure_node(node).is_some() {\n-                    stack.pop().unwrap();\n-                }\n-            }\n-        }\n-    }\n-    res\n-}\n-\n-fn structure_node(node: SyntaxNodeRef) -> Option<StructureNode> {\n-    fn decl<'a, N: NameOwner<'a>>(node: N) -> Option<StructureNode> {\n-        let name = node.name()?;\n-        Some(StructureNode {\n-            parent: None,\n-            label: name.text().to_string(),\n-            navigation_range: name.syntax().range(),\n-            node_range: node.syntax().range(),\n-            kind: node.syntax().kind(),\n-        })\n-    }\n-\n-    visitor()\n-        .visit(decl::<ast::FnDef>)\n-        .visit(decl::<ast::StructDef>)\n-        .visit(decl::<ast::NamedFieldDef>)\n-        .visit(decl::<ast::EnumDef>)\n-        .visit(decl::<ast::TraitDef>)\n-        .visit(decl::<ast::Module>)\n-        .visit(decl::<ast::TypeDef>)\n-        .visit(decl::<ast::ConstDef>)\n-        .visit(decl::<ast::StaticDef>)\n-        .visit(|im: ast::ImplItem| {\n-            let target_type = im.target_type()?;\n-            let target_trait = im.target_trait();\n-            let label = match target_trait {\n-                None => format!(\"impl {}\", target_type.syntax().text()),\n-                Some(t) => format!(\n-                    \"impl {} for {}\",\n-                    t.syntax().text(),\n-                    target_type.syntax().text(),\n-                ),\n-            };\n-\n-            let node = StructureNode {\n-                parent: None,\n-                label,\n-                navigation_range: target_type.syntax().range(),\n-                node_range: im.syntax().range(),\n-                kind: im.syntax().kind(),\n-            };\n-            Some(node)\n-        })\n-        .accept(node)?\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use test_utils::assert_eq_dbg;\n-\n-    #[test]\n-    fn test_file_structure() {\n-        let file = SourceFileNode::parse(\n-            r#\"\n-struct Foo {\n-    x: i32\n-}\n-\n-mod m {\n-    fn bar() {}\n-}\n-\n-enum E { X, Y(i32) }\n-type T = ();\n-static S: i32 = 92;\n-const C: i32 = 92;\n-\n-impl E {}\n-\n-impl fmt::Debug for E {}\n-\"#,\n-        );\n-        let symbols = file_structure(&file);\n-        assert_eq_dbg(\n-            r#\"[StructureNode { parent: None, label: \"Foo\", navigation_range: [8; 11), node_range: [1; 26), kind: STRUCT_DEF },\n-                StructureNode { parent: Some(0), label: \"x\", navigation_range: [18; 19), node_range: [18; 24), kind: NAMED_FIELD_DEF },\n-                StructureNode { parent: None, label: \"m\", navigation_range: [32; 33), node_range: [28; 53), kind: MODULE },\n-                StructureNode { parent: Some(2), label: \"bar\", navigation_range: [43; 46), node_range: [40; 51), kind: FN_DEF },\n-                StructureNode { parent: None, label: \"E\", navigation_range: [60; 61), node_range: [55; 75), kind: ENUM_DEF },\n-                StructureNode { parent: None, label: \"T\", navigation_range: [81; 82), node_range: [76; 88), kind: TYPE_DEF },\n-                StructureNode { parent: None, label: \"S\", navigation_range: [96; 97), node_range: [89; 108), kind: STATIC_DEF },\n-                StructureNode { parent: None, label: \"C\", navigation_range: [115; 116), node_range: [109; 127), kind: CONST_DEF },\n-                StructureNode { parent: None, label: \"impl E\", navigation_range: [134; 135), node_range: [129; 138), kind: IMPL_ITEM },\n-                StructureNode { parent: None, label: \"impl fmt::Debug for E\", navigation_range: [160; 161), node_range: [140; 164), kind: IMPL_ITEM }]\"#,\n-            &symbols,\n-        )\n-    }\n-}"}, {"sha": "1107ffc8b976b5983a054a27e2af9589536455d0", "filename": "crates/ra_lsp_server/src/conv.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/29d8bfb9c909847cb37ff6e564ea0e61744277ad/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29d8bfb9c909847cb37ff6e564ea0e61744277ad/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs?ref=29d8bfb9c909847cb37ff6e564ea0e61744277ad", "patch": "@@ -2,7 +2,7 @@ use languageserver_types::{\n     self, Location, Position, Range, SymbolKind, TextDocumentEdit, TextDocumentIdentifier,\n     TextDocumentItem, TextDocumentPositionParams, Url, VersionedTextDocumentIdentifier, InsertTextFormat,\n };\n-use ra_analysis::{FileId, FileSystemEdit, SourceChange, SourceFileEdit, FilePosition,FileRange,  CompletionItem, CompletionItemKind, InsertText};\n+use ra_analysis::{FileId, FileSystemEdit, SourceChange, SourceFileEdit, FilePosition,FileRange,  CompletionItem, CompletionItemKind, InsertText, NavigationTarget};\n use ra_editor::{LineCol, LineIndex, translate_offset_with_edit};\n use ra_text_edit::{AtomTextEdit, TextEdit};\n use ra_syntax::{SyntaxKind, TextRange, TextUnit};\n@@ -322,6 +322,15 @@ impl TryConvWith for FileSystemEdit {\n     }\n }\n \n+impl TryConvWith for &NavigationTarget {\n+    type Ctx = ServerWorld;\n+    type Output = Location;\n+    fn try_conv_with(self, world: &ServerWorld) -> Result<Location> {\n+        let line_index = world.analysis().file_line_index(self.file_id());\n+        to_location(self.file_id(), self.range(), &world, &line_index)\n+    }\n+}\n+\n pub fn to_location(\n     file_id: FileId,\n     range: TextRange,"}, {"sha": "26b6c7d8a53528e3c280e694fa26c41c020ede92", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/29d8bfb9c909847cb37ff6e564ea0e61744277ad/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29d8bfb9c909847cb37ff6e564ea0e61744277ad/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=29d8bfb9c909847cb37ff6e564ea0e61744277ad", "patch": "@@ -188,12 +188,11 @@ pub fn handle_workspace_symbol(\n \n     fn exec_query(world: &ServerWorld, query: Query) -> Result<Vec<SymbolInformation>> {\n         let mut res = Vec::new();\n-        for (file_id, symbol) in world.analysis().symbol_search(query)? {\n-            let line_index = world.analysis().file_line_index(file_id);\n+        for nav in world.analysis().symbol_search(query)? {\n             let info = SymbolInformation {\n-                name: symbol.name.to_string(),\n-                kind: symbol.kind.conv(),\n-                location: to_location(file_id, symbol.node_range, world, &line_index)?,\n+                name: nav.name().into(),\n+                kind: nav.kind().conv(),\n+                location: nav.try_conv_with(world)?,\n                 container_name: None,\n                 deprecated: None,\n             };\n@@ -212,12 +211,11 @@ pub fn handle_goto_definition(\n         None => return Ok(None),\n         Some(it) => it,\n     };\n-    let mut res = Vec::new();\n-    for (file_id, symbol) in rr.resolves_to {\n-        let line_index = world.analysis().file_line_index(file_id);\n-        let location = to_location(file_id, symbol.node_range, &world, &line_index)?;\n-        res.push(location)\n-    }\n+    let res = rr\n+        .resolves_to\n+        .into_iter()\n+        .map(|nav| nav.try_conv_with(&world))\n+        .collect::<Result<Vec<_>>>()?;\n     Ok(Some(req::GotoDefinitionResponse::Array(res)))\n }\n \n@@ -226,13 +224,12 @@ pub fn handle_parent_module(\n     params: req::TextDocumentPositionParams,\n ) -> Result<Vec<Location>> {\n     let position = params.try_conv_with(&world)?;\n-    let mut res = Vec::new();\n-    for (file_id, symbol) in world.analysis().parent_module(position)? {\n-        let line_index = world.analysis().file_line_index(file_id);\n-        let location = to_location(file_id, symbol.node_range, &world, &line_index)?;\n-        res.push(location);\n-    }\n-    Ok(res)\n+    world\n+        .analysis()\n+        .parent_module(position)?\n+        .into_iter()\n+        .map(|nav| nav.try_conv_with(&world))\n+        .collect::<Result<Vec<_>>>()\n }\n \n pub fn handle_runnables(\n@@ -517,8 +514,8 @@ pub fn handle_hover(\n         Some(it) => it,\n     };\n     let mut result = Vec::new();\n-    for (file_id, symbol) in rr.resolves_to {\n-        if let Some(docs) = world.analysis().doc_text_for(file_id, symbol)? {\n+    for nav in rr.resolves_to {\n+        if let Some(docs) = world.analysis().doc_text_for(nav)? {\n             result.push(docs);\n         }\n     }"}]}