{"sha": "98e791e7e135ef6526ca97c33fcf8cd0db50320f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4ZTc5MWU3ZTEzNWVmNjUyNmNhOTdjMzNmY2Y4Y2QwZGI1MDMyMGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-09T15:42:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-09T15:42:26Z"}, "message": "Auto merge of #45741 - oli-obk:refactor_suggestions, r=estebank\n\nRefactor internal suggestion API\n\n~~The only functional change is that whitespace, which is suggested to be added, also gets `^^^^` under it. An example is shown in the tests (the only test that changed).~~\n\nContinuation of #41876\n\nr? @nagisa\n\nthe changes are probably best viewed [without whitespace](https://github.com/rust-lang/rust/pull/45741/files?w=1)", "tree": {"sha": "930bf2cdb7ced0ea9712a220de491d880f96c610", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/930bf2cdb7ced0ea9712a220de491d880f96c610"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98e791e7e135ef6526ca97c33fcf8cd0db50320f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98e791e7e135ef6526ca97c33fcf8cd0db50320f", "html_url": "https://github.com/rust-lang/rust/commit/98e791e7e135ef6526ca97c33fcf8cd0db50320f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98e791e7e135ef6526ca97c33fcf8cd0db50320f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd9ecfdfd01c0954172a002cc806174a077b9e3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd9ecfdfd01c0954172a002cc806174a077b9e3d", "html_url": "https://github.com/rust-lang/rust/commit/fd9ecfdfd01c0954172a002cc806174a077b9e3d"}, {"sha": "dfe218ac970f93aa93dc566156c2a54693110208", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfe218ac970f93aa93dc566156c2a54693110208", "html_url": "https://github.com/rust-lang/rust/commit/dfe218ac970f93aa93dc566156c2a54693110208"}], "stats": {"total": 234, "additions": 112, "deletions": 122}, "files": [{"sha": "c7e9c8268f0b32d977cf5c33afdde49a1d253901", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/98e791e7e135ef6526ca97c33fcf8cd0db50320f/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e791e7e135ef6526ca97c33fcf8cd0db50320f/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=98e791e7e135ef6526ca97c33fcf8cd0db50320f", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use CodeSuggestion;\n+use SubstitutionPart;\n use Substitution;\n use Level;\n use RenderSpan;\n@@ -217,9 +218,11 @@ impl Diagnostic {\n     /// See `CodeSuggestion` for more information.\n     pub fn span_suggestion_short(&mut self, sp: Span, msg: &str, suggestion: String) -> &mut Self {\n         self.suggestions.push(CodeSuggestion {\n-            substitution_parts: vec![Substitution {\n-                span: sp,\n-                substitutions: vec![suggestion],\n+            substitutions: vec![Substitution {\n+                parts: vec![SubstitutionPart {\n+                    snippet: suggestion,\n+                    span: sp,\n+                }],\n             }],\n             msg: msg.to_owned(),\n             show_code_when_inline: false,\n@@ -245,9 +248,11 @@ impl Diagnostic {\n     /// See `CodeSuggestion` for more information.\n     pub fn span_suggestion(&mut self, sp: Span, msg: &str, suggestion: String) -> &mut Self {\n         self.suggestions.push(CodeSuggestion {\n-            substitution_parts: vec![Substitution {\n-                span: sp,\n-                substitutions: vec![suggestion],\n+            substitutions: vec![Substitution {\n+                parts: vec![SubstitutionPart {\n+                    snippet: suggestion,\n+                    span: sp,\n+                }],\n             }],\n             msg: msg.to_owned(),\n             show_code_when_inline: true,\n@@ -258,10 +263,12 @@ impl Diagnostic {\n     /// Prints out a message with multiple suggested edits of the code.\n     pub fn span_suggestions(&mut self, sp: Span, msg: &str, suggestions: Vec<String>) -> &mut Self {\n         self.suggestions.push(CodeSuggestion {\n-            substitution_parts: vec![Substitution {\n-                span: sp,\n-                substitutions: suggestions,\n-            }],\n+            substitutions: suggestions.into_iter().map(|snippet| Substitution {\n+                parts: vec![SubstitutionPart {\n+                    snippet,\n+                    span: sp,\n+                }],\n+            }).collect(),\n             msg: msg.to_owned(),\n             show_code_when_inline: true,\n         });"}, {"sha": "0e39f29204d1e2cf8a0b69aa75f6fc39728addc2", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/98e791e7e135ef6526ca97c33fcf8cd0db50320f/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e791e7e135ef6526ca97c33fcf8cd0db50320f/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=98e791e7e135ef6526ca97c33fcf8cd0db50320f", "patch": "@@ -38,23 +38,23 @@ impl Emitter for EmitterWriter {\n \n         if let Some((sugg, rest)) = db.suggestions.split_first() {\n             if rest.is_empty() &&\n-               // don't display multipart suggestions as labels\n-               sugg.substitution_parts.len() == 1 &&\n                // don't display multi-suggestions as labels\n-               sugg.substitutions() == 1 &&\n+               sugg.substitutions.len() == 1 &&\n+               // don't display multipart suggestions as labels\n+               sugg.substitutions[0].parts.len() == 1 &&\n                // don't display long messages as labels\n                sugg.msg.split_whitespace().count() < 10 &&\n                // don't display multiline suggestions as labels\n-               sugg.substitution_parts[0].substitutions[0].find('\\n').is_none() {\n-                let substitution = &sugg.substitution_parts[0].substitutions[0];\n+               !sugg.substitutions[0].parts[0].snippet.contains('\\n') {\n+                let substitution = &sugg.substitutions[0].parts[0].snippet;\n                 let msg = if substitution.len() == 0 || !sugg.show_code_when_inline {\n                     // This substitution is only removal or we explicitly don't want to show the\n                     // code inline, don't show it\n                     format!(\"help: {}\", sugg.msg)\n                 } else {\n                     format!(\"help: {}: `{}`\", sugg.msg, substitution)\n                 };\n-                primary_span.push_span_label(sugg.substitution_spans().next().unwrap(), msg);\n+                primary_span.push_span_label(sugg.substitutions[0].parts[0].span, msg);\n             } else {\n                 // if there are multiple suggestions, print them all in full\n                 // to be consistent. We could try to figure out if we can\n@@ -1098,14 +1098,10 @@ impl EmitterWriter {\n                                -> io::Result<()> {\n         use std::borrow::Borrow;\n \n-        let primary_sub = &suggestion.substitution_parts[0];\n         if let Some(ref cm) = self.cm {\n             let mut buffer = StyledBuffer::new();\n \n-            let lines = cm.span_to_lines(primary_sub.span).unwrap();\n-\n-            assert!(!lines.lines.is_empty());\n-\n+            // Render the suggestion message\n             buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n             buffer.append(0, \": \", Style::HeaderMsg);\n             self.msg_to_buffer(&mut buffer,\n@@ -1114,14 +1110,22 @@ impl EmitterWriter {\n                                \"suggestion\",\n                                Some(Style::HeaderMsg));\n \n+            // Render the replacements for each suggestion\n             let suggestions = suggestion.splice_lines(cm.borrow());\n-            let span_start_pos = cm.lookup_char_pos(primary_sub.span.lo());\n-            let line_start = span_start_pos.line;\n-            draw_col_separator_no_space(&mut buffer, 1, max_line_num_len + 1);\n+\n             let mut row_num = 2;\n-            for (&(ref complete, show_underline), ref sub) in suggestions\n-                    .iter().zip(primary_sub.substitutions.iter()).take(MAX_SUGGESTIONS)\n-            {\n+            for &(ref complete, ref parts) in suggestions.iter().take(MAX_SUGGESTIONS) {\n+                let show_underline = parts.len() == 1\n+                    && complete.lines().count() == 1\n+                    && parts[0].snippet.trim() != complete.trim();\n+\n+                let lines = cm.span_to_lines(parts[0].span).unwrap();\n+\n+                assert!(!lines.lines.is_empty());\n+\n+                let span_start_pos = cm.lookup_char_pos(parts[0].span.lo());\n+                let line_start = span_start_pos.line;\n+                draw_col_separator_no_space(&mut buffer, 1, max_line_num_len + 1);\n                 let mut line_pos = 0;\n                 // Only show underline if there's a single suggestion and it is a single line\n                 let mut lines = complete.lines();\n@@ -1136,21 +1140,22 @@ impl EmitterWriter {\n                     buffer.append(row_num, line, Style::NoStyle);\n                     line_pos += 1;\n                     row_num += 1;\n-                    // Only show an underline in the suggestions if the suggestion is not the\n-                    // entirety of the code being shown and the displayed code is not multiline.\n-                    if show_underline {\n-                        draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n-                        let sub_len = sub.trim_right().len();\n-                        let underline_start = span_start_pos.col.0;\n-                        let underline_end = span_start_pos.col.0 + sub_len;\n-                        for p in underline_start..underline_end {\n-                            buffer.putc(row_num,\n-                                        max_line_num_len + 3 + p,\n-                                        '^',\n-                                        Style::UnderlinePrimary);\n-                        }\n-                        row_num += 1;\n+                }\n+                // Only show an underline in the suggestions if the suggestion is not the\n+                // entirety of the code being shown and the displayed code is not multiline.\n+                if show_underline {\n+                    draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n+                    let start = parts[0].snippet.len() - parts[0].snippet.trim_left().len();\n+                    let sub_len = parts[0].snippet.trim().len();\n+                    let underline_start = span_start_pos.col.0 + start;\n+                    let underline_end = span_start_pos.col.0 + sub_len;\n+                    for p in underline_start..underline_end {\n+                        buffer.putc(row_num,\n+                                    max_line_num_len + 3 + p,\n+                                    '^',\n+                                    Style::UnderlinePrimary);\n                     }\n+                    row_num += 1;\n                 }\n \n                 // if we elided some lines, add an ellipsis"}, {"sha": "7bf64d2432571ae8fc02f0b2c95177d1ebd8a9fa", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 55, "deletions": 77, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/98e791e7e135ef6526ca97c33fcf8cd0db50320f/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e791e7e135ef6526ca97c33fcf8cd0db50320f/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=98e791e7e135ef6526ca97c33fcf8cd0db50320f", "patch": "@@ -76,26 +76,34 @@ pub struct CodeSuggestion {\n     ///\n     /// ```\n     /// vec![\n-    ///     (0..3, vec![\"a\", \"x\"]),\n-    ///     (4..7, vec![\"b\", \"y\"]),\n+    ///     Substitution { parts: vec![(0..3, \"a\"), (4..7, \"b\")] },\n+    ///     Substitution { parts: vec![(0..3, \"x\"), (4..7, \"y\")] },\n     /// ]\n     /// ```\n     ///\n     /// or by replacing the entire span:\n     ///\n     /// ```\n-    /// vec![(0..7, vec![\"a.b\", \"x.y\"])]\n+    /// vec![\n+    ///     Substitution { parts: vec![(0..7, \"a.b\")] },\n+    ///     Substitution { parts: vec![(0..7, \"x.y\")] },\n+    /// ]\n     /// ```\n-    pub substitution_parts: Vec<Substitution>,\n+    pub substitutions: Vec<Substitution>,\n     pub msg: String,\n     pub show_code_when_inline: bool,\n }\n \n #[derive(Clone, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n /// See the docs on `CodeSuggestion::substitutions`\n pub struct Substitution {\n+    pub parts: Vec<SubstitutionPart>,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+pub struct SubstitutionPart {\n     pub span: Span,\n-    pub substitutions: Vec<String>,\n+    pub snippet: String,\n }\n \n pub trait CodeMapper {\n@@ -109,18 +117,8 @@ pub trait CodeMapper {\n }\n \n impl CodeSuggestion {\n-    /// Returns the number of substitutions\n-    fn substitutions(&self) -> usize {\n-        self.substitution_parts[0].substitutions.len()\n-    }\n-\n-    /// Returns the number of substitutions\n-    fn substitution_spans<'a>(&'a self) -> impl Iterator<Item = Span> + 'a {\n-        self.substitution_parts.iter().map(|sub| sub.span)\n-    }\n-\n-    /// Returns the assembled code suggestions and wether they should be shown with an underline.\n-    pub fn splice_lines(&self, cm: &CodeMapper) -> Vec<(String, bool)> {\n+    /// Returns the assembled code suggestions and whether they should be shown with an underline.\n+    pub fn splice_lines(&self, cm: &CodeMapper) -> Vec<(String, Vec<SubstitutionPart>)> {\n         use syntax_pos::{CharPos, Loc, Pos};\n \n         fn push_trailing(buf: &mut String,\n@@ -142,60 +140,42 @@ impl CodeSuggestion {\n             }\n         }\n \n-        if self.substitution_parts.is_empty() {\n-            return vec![(String::new(), false)];\n-        }\n-\n-        let mut primary_spans: Vec<_> = self.substitution_parts\n-            .iter()\n-            .map(|sub| (sub.span, &sub.substitutions))\n-            .collect();\n-\n-        // Assumption: all spans are in the same file, and all spans\n-        // are disjoint. Sort in ascending order.\n-        primary_spans.sort_by_key(|sp| sp.0.lo());\n-\n-        // Find the bounding span.\n-        let lo = primary_spans.iter().map(|sp| sp.0.lo()).min().unwrap();\n-        let hi = primary_spans.iter().map(|sp| sp.0.hi()).min().unwrap();\n-        let bounding_span = Span::new(lo, hi, NO_EXPANSION);\n-        let lines = cm.span_to_lines(bounding_span).unwrap();\n-        assert!(!lines.lines.is_empty());\n-\n-        // To build up the result, we do this for each span:\n-        // - push the line segment trailing the previous span\n-        //   (at the beginning a \"phantom\" span pointing at the start of the line)\n-        // - push lines between the previous and current span (if any)\n-        // - if the previous and current span are not on the same line\n-        //   push the line segment leading up to the current span\n-        // - splice in the span substitution\n-        //\n-        // Finally push the trailing line segment of the last span\n-        let fm = &lines.file;\n-        let mut prev_hi = cm.lookup_char_pos(bounding_span.lo());\n-        prev_hi.col = CharPos::from_usize(0);\n-\n-        let mut prev_line = fm.get_line(lines.lines[0].line_index);\n-        let mut bufs = vec![(String::new(), false); self.substitutions()];\n-\n-        for (sp, substitutes) in primary_spans {\n-            let cur_lo = cm.lookup_char_pos(sp.lo());\n-            for (&mut (ref mut buf, ref mut underline), substitute) in bufs.iter_mut()\n-                                                                           .zip(substitutes) {\n+        assert!(!self.substitutions.is_empty());\n+\n+        self.substitutions.iter().cloned().map(|mut substitution| {\n+            // Assumption: all spans are in the same file, and all spans\n+            // are disjoint. Sort in ascending order.\n+            substitution.parts.sort_by_key(|part| part.span.lo());\n+\n+            // Find the bounding span.\n+            let lo = substitution.parts.iter().map(|part| part.span.lo()).min().unwrap();\n+            let hi = substitution.parts.iter().map(|part| part.span.hi()).min().unwrap();\n+            let bounding_span = Span::new(lo, hi, NO_EXPANSION);\n+            let lines = cm.span_to_lines(bounding_span).unwrap();\n+            assert!(!lines.lines.is_empty());\n+\n+            // To build up the result, we do this for each span:\n+            // - push the line segment trailing the previous span\n+            //   (at the beginning a \"phantom\" span pointing at the start of the line)\n+            // - push lines between the previous and current span (if any)\n+            // - if the previous and current span are not on the same line\n+            //   push the line segment leading up to the current span\n+            // - splice in the span substitution\n+            //\n+            // Finally push the trailing line segment of the last span\n+            let fm = &lines.file;\n+            let mut prev_hi = cm.lookup_char_pos(bounding_span.lo());\n+            prev_hi.col = CharPos::from_usize(0);\n+\n+            let mut prev_line = fm.get_line(lines.lines[0].line_index);\n+            let mut buf = String::new();\n+\n+            for part in &substitution.parts {\n+                let cur_lo = cm.lookup_char_pos(part.span.lo());\n                 if prev_hi.line == cur_lo.line {\n-                    push_trailing(buf, prev_line.as_ref(), &prev_hi, Some(&cur_lo));\n-\n-                    // Only show an underline in the suggestions if the suggestion is not the\n-                    // entirety of the code being shown and the displayed code is not multiline.\n-                    if prev_line.as_ref().unwrap().trim().len() > 0\n-                        && !substitute.ends_with('\\n')\n-                        && substitute.lines().count() == 1\n-                    {\n-                        *underline = true;\n-                    }\n+                    push_trailing(&mut buf, prev_line.as_ref(), &prev_hi, Some(&cur_lo));\n                 } else {\n-                    *underline = false;\n-                    push_trailing(buf, prev_line.as_ref(), &prev_hi, None);\n+                    push_trailing(&mut buf, prev_line.as_ref(), &prev_hi, None);\n                     // push lines between the previous and current span (if any)\n                     for idx in prev_hi.line..(cur_lo.line - 1) {\n                         if let Some(line) = fm.get_line(idx) {\n@@ -207,22 +187,20 @@ impl CodeSuggestion {\n                         buf.push_str(&cur_line[..cur_lo.col.to_usize()]);\n                     }\n                 }\n-                buf.push_str(substitute);\n+                buf.push_str(&part.snippet);\n+                prev_hi = cm.lookup_char_pos(part.span.hi());\n+                prev_line = fm.get_line(prev_hi.line - 1);\n             }\n-            prev_hi = cm.lookup_char_pos(sp.hi());\n-            prev_line = fm.get_line(prev_hi.line - 1);\n-        }\n-        for &mut (ref mut buf, _) in &mut bufs {\n             // if the replacement already ends with a newline, don't print the next line\n             if !buf.ends_with('\\n') {\n-                push_trailing(buf, prev_line.as_ref(), &prev_hi, None);\n+                push_trailing(&mut buf, prev_line.as_ref(), &prev_hi, None);\n             }\n             // remove trailing newlines\n             while buf.ends_with('\\n') {\n                 buf.pop();\n             }\n-        }\n-        bufs\n+            (buf, substitution.parts)\n+        }).collect()\n     }\n }\n "}, {"sha": "6564046ffe68f69d3720e683e8e0d863cb4267b7", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/98e791e7e135ef6526ca97c33fcf8cd0db50320f/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e791e7e135ef6526ca97c33fcf8cd0db50320f/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=98e791e7e135ef6526ca97c33fcf8cd0db50320f", "patch": "@@ -284,17 +284,17 @@ impl DiagnosticSpan {\n \n     fn from_suggestion(suggestion: &CodeSuggestion, je: &JsonEmitter)\n                        -> Vec<DiagnosticSpan> {\n-        suggestion.substitution_parts\n+        suggestion.substitutions\n                       .iter()\n                       .flat_map(|substitution| {\n-                          substitution.substitutions.iter().map(move |suggestion| {\n+                          substitution.parts.iter().map(move |suggestion| {\n                               let span_label = SpanLabel {\n-                                  span: substitution.span,\n+                                  span: suggestion.span,\n                                   is_primary: true,\n                                   label: None,\n                               };\n                               DiagnosticSpan::from_span_label(span_label,\n-                                                              Some(suggestion),\n+                                                              Some(&suggestion.snippet),\n                                                               je)\n                           })\n                       })"}]}