{"sha": "7b3e10c751ba79344591763bc205986b425dc445", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiM2UxMGM3NTFiYTc5MzQ0NTkxNzYzYmMyMDU5ODZiNDI1ZGM0NDU=", "commit": {"author": {"name": "hyd-dev", "email": "yd-huang@outlook.com", "date": "2021-05-21T12:40:36Z"}, "committer": {"name": "hyd-dev", "email": "yd-huang@outlook.com", "date": "2021-05-22T20:20:53Z"}, "message": "const-eval: disallow unwinding across functions that `!fn_can_unwind()`", "tree": {"sha": "b9276cbb3312bc84eccd00188a2fc231a2b77e55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9276cbb3312bc84eccd00188a2fc231a2b77e55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b3e10c751ba79344591763bc205986b425dc445", "comment_count": 0, "verification": {"verified": false, "reason": "no_user", "signature": "-----BEGIN PGP SIGNATURE-----\n\niIsEABYIADMWIQRJ2jPMDdiQ+U4U42Z0+n/VuNoUuAUCYKlnpRUceWQtaHVhbmdA\nb3V0bG9vay5jb20ACgkQdPp/1bjaFLgoqwD/b3KYHFnRTuDDlynxlur1lm6aqfZk\nJv7wlEEs0MLgeE8BAPtVvhEvCbT1KGly1zxFX2Os/1LUMSJLBGDM11qbRloA\n=bBZi\n-----END PGP SIGNATURE-----", "payload": "tree b9276cbb3312bc84eccd00188a2fc231a2b77e55\nparent ed20e1e533f70644bc583b3c4e4f85426b98bb4d\nauthor hyd-dev <yd-huang@outlook.com> 1621600836 +0800\ncommitter hyd-dev <yd-huang@outlook.com> 1621714853 +0800\n\nconst-eval: disallow unwinding across functions that `!fn_can_unwind()`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b3e10c751ba79344591763bc205986b425dc445", "html_url": "https://github.com/rust-lang/rust/commit/7b3e10c751ba79344591763bc205986b425dc445", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b3e10c751ba79344591763bc205986b425dc445/comments", "author": null, "committer": null, "parents": [{"sha": "ed20e1e533f70644bc583b3c4e4f85426b98bb4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed20e1e533f70644bc583b3c4e4f85426b98bb4d", "html_url": "https://github.com/rust-lang/rust/commit/ed20e1e533f70644bc583b3c4e4f85426b98bb4d"}], "stats": {"total": 153, "additions": 108, "deletions": 45}, "files": [{"sha": "03a026500d70259c0db2ae0620362e532253427d", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 41, "deletions": 34, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/7b3e10c751ba79344591763bc205986b425dc445/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3e10c751ba79344591763bc205986b425dc445/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=7b3e10c751ba79344591763bc205986b425dc445", "patch": "@@ -2579,7 +2579,7 @@ where\n     fn adjust_for_abi(&mut self, cx: &C, abi: SpecAbi);\n }\n \n-fn fn_can_unwind(\n+pub fn fn_can_unwind(\n     panic_strategy: PanicStrategy,\n     codegen_fn_attr_flags: CodegenFnAttrFlags,\n     call_conv: Conv,\n@@ -2641,6 +2641,43 @@ fn fn_can_unwind(\n     }\n }\n \n+pub fn conv_from_spec_abi(tcx: TyCtxt<'_>, abi: SpecAbi) -> Conv {\n+    use rustc_target::spec::abi::Abi::*;\n+    match tcx.sess.target.adjust_abi(abi) {\n+        RustIntrinsic | PlatformIntrinsic | Rust | RustCall => Conv::Rust,\n+\n+        // It's the ABI's job to select this, not ours.\n+        System { .. } => bug!(\"system abi should be selected elsewhere\"),\n+        EfiApi => bug!(\"eficall abi should be selected elsewhere\"),\n+\n+        Stdcall { .. } => Conv::X86Stdcall,\n+        Fastcall => Conv::X86Fastcall,\n+        Vectorcall => Conv::X86VectorCall,\n+        Thiscall { .. } => Conv::X86ThisCall,\n+        C { .. } => Conv::C,\n+        Unadjusted => Conv::C,\n+        Win64 => Conv::X86_64Win64,\n+        SysV64 => Conv::X86_64SysV,\n+        Aapcs => Conv::ArmAapcs,\n+        CCmseNonSecureCall => Conv::CCmseNonSecureCall,\n+        PtxKernel => Conv::PtxKernel,\n+        Msp430Interrupt => Conv::Msp430Intr,\n+        X86Interrupt => Conv::X86Intr,\n+        AmdGpuKernel => Conv::AmdGpuKernel,\n+        AvrInterrupt => Conv::AvrInterrupt,\n+        AvrNonBlockingInterrupt => Conv::AvrNonBlockingInterrupt,\n+        Wasm => Conv::C,\n+\n+        // These API constants ought to be more specific...\n+        Cdecl => Conv::C,\n+    }\n+}\n+\n+pub fn fn_ptr_codegen_fn_attr_flags() -> CodegenFnAttrFlags {\n+    // Assume that fn pointers may always unwind\n+    CodegenFnAttrFlags::UNWIND\n+}\n+\n impl<'tcx, C> FnAbiExt<'tcx, C> for call::FnAbi<'tcx, Ty<'tcx>>\n where\n     C: LayoutOf<Ty = Ty<'tcx>, TyAndLayout = TyAndLayout<'tcx>>\n@@ -2650,10 +2687,7 @@ where\n         + HasParamEnv<'tcx>,\n {\n     fn of_fn_ptr(cx: &C, sig: ty::PolyFnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n-        // Assume that fn pointers may always unwind\n-        let codegen_fn_attr_flags = CodegenFnAttrFlags::UNWIND;\n-\n-        call::FnAbi::new_internal(cx, sig, extra_args, None, codegen_fn_attr_flags, false)\n+        call::FnAbi::new_internal(cx, sig, extra_args, None, fn_ptr_codegen_fn_attr_flags(), false)\n     }\n \n     fn of_instance(cx: &C, instance: ty::Instance<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n@@ -2689,35 +2723,7 @@ where\n \n         let sig = cx.tcx().normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), sig);\n \n-        use rustc_target::spec::abi::Abi::*;\n-        let conv = match cx.tcx().sess.target.adjust_abi(sig.abi) {\n-            RustIntrinsic | PlatformIntrinsic | Rust | RustCall => Conv::Rust,\n-\n-            // It's the ABI's job to select this, not ours.\n-            System { .. } => bug!(\"system abi should be selected elsewhere\"),\n-            EfiApi => bug!(\"eficall abi should be selected elsewhere\"),\n-\n-            Stdcall { .. } => Conv::X86Stdcall,\n-            Fastcall => Conv::X86Fastcall,\n-            Vectorcall => Conv::X86VectorCall,\n-            Thiscall { .. } => Conv::X86ThisCall,\n-            C { .. } => Conv::C,\n-            Unadjusted => Conv::C,\n-            Win64 => Conv::X86_64Win64,\n-            SysV64 => Conv::X86_64SysV,\n-            Aapcs => Conv::ArmAapcs,\n-            CCmseNonSecureCall => Conv::CCmseNonSecureCall,\n-            PtxKernel => Conv::PtxKernel,\n-            Msp430Interrupt => Conv::Msp430Intr,\n-            X86Interrupt => Conv::X86Intr,\n-            AmdGpuKernel => Conv::AmdGpuKernel,\n-            AvrInterrupt => Conv::AvrInterrupt,\n-            AvrNonBlockingInterrupt => Conv::AvrNonBlockingInterrupt,\n-            Wasm => Conv::C,\n-\n-            // These API constants ought to be more specific...\n-            Cdecl => Conv::C,\n-        };\n+        let conv = conv_from_spec_abi(cx.tcx(), sig.abi);\n \n         let mut inputs = sig.inputs();\n         let extra_args = if sig.abi == RustCall {\n@@ -2753,6 +2759,7 @@ where\n             target.os == \"linux\" && target.arch == \"sparc64\" && target_env_gnu_like;\n         let linux_powerpc_gnu_like =\n             target.os == \"linux\" && target.arch == \"powerpc\" && target_env_gnu_like;\n+        use SpecAbi::*;\n         let rust_abi = matches!(sig.abi, RustIntrinsic | PlatformIntrinsic | Rust | RustCall);\n \n         // Handle safe Rust thin and fat pointers."}, {"sha": "78d9c7f44f9b6f50dfb285ac2547371eb9da46c8", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7b3e10c751ba79344591763bc205986b425dc445/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3e10c751ba79344591763bc205986b425dc445/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=7b3e10c751ba79344591763bc205986b425dc445", "patch": "@@ -134,14 +134,23 @@ pub struct FrameInfo<'tcx> {\n     pub lint_root: Option<hir::HirId>,\n }\n \n+/// Unwind information.\n+#[derive(Clone, Copy, Eq, PartialEq, Debug, HashStable)]\n+pub enum StackPopUnwind {\n+    /// The cleanup block.\n+    Cleanup(Option<mir::BasicBlock>),\n+    /// Unwinding is not allowed (UB).\n+    NotAllowed,\n+}\n+\n #[derive(Clone, Eq, PartialEq, Debug, HashStable)] // Miri debug-prints these\n pub enum StackPopCleanup {\n     /// Jump to the next block in the caller, or cause UB if None (that's a function\n     /// that may never return). Also store layout of return place so\n     /// we can validate it at that layout.\n     /// `ret` stores the block we jump to on a normal return, while `unwind`\n     /// stores the block used for cleanup during unwinding.\n-    Goto { ret: Option<mir::BasicBlock>, unwind: Option<mir::BasicBlock> },\n+    Goto { ret: Option<mir::BasicBlock>, unwind: StackPopUnwind },\n     /// Just do nothing: Used by Main and for the `box_alloc` hook in miri.\n     /// `cleanup` says whether locals are deallocated. Static computation\n     /// wants them leaked to intern what they need (and just throw away\n@@ -807,9 +816,29 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // In that case, we return early. We also avoid validation in that case,\n         // because this is CTFE and the final value will be thoroughly validated anyway.\n         let (cleanup, next_block) = match frame.return_to_block {\n-            StackPopCleanup::Goto { ret, unwind } => {\n-                (true, Some(if unwinding { unwind } else { ret }))\n-            }\n+            StackPopCleanup::Goto { ret, unwind } => (\n+                true,\n+                Some(if unwinding {\n+                    let def_id = frame.body.source.def_id();\n+                    match unwind {\n+                        StackPopUnwind::Cleanup(unwind)\n+                            // `fn_sig()` can't be used on closures, but closures always have\n+                            // \"rust-call\" ABI, which always allows unwinding anyway.\n+                            if self.tcx.is_closure(def_id) || self.fn_can_unwind(\n+                                self.tcx.codegen_fn_attrs(def_id).flags,\n+                                self.tcx.fn_sig(def_id).abi(),\n+                            ) =>\n+                        {\n+                            unwind\n+                        }\n+                        _ => {\n+                            throw_ub_format!(\"unwind past a frame that does not allow unwinding\")\n+                        }\n+                    }\n+                } else {\n+                    ret\n+                }),\n+            ),\n             StackPopCleanup::None { cleanup, .. } => (cleanup, None),\n         };\n "}, {"sha": "2b9fe56599715b6fd87db2f9104242b507d485f0", "filename": "compiler/rustc_mir/src/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b3e10c751ba79344591763bc205986b425dc445/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3e10c751ba79344591763bc205986b425dc445/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmod.rs?ref=7b3e10c751ba79344591763bc205986b425dc445", "patch": "@@ -18,7 +18,9 @@ mod visitor;\n \n pub use rustc_middle::mir::interpret::*; // have all the `interpret` symbols in one place: here\n \n-pub use self::eval_context::{Frame, FrameInfo, InterpCx, LocalState, LocalValue, StackPopCleanup};\n+pub use self::eval_context::{\n+    Frame, FrameInfo, InterpCx, LocalState, LocalValue, StackPopCleanup, StackPopUnwind,\n+};\n pub use self::intern::{intern_const_alloc_recursive, InternKind};\n pub use self::machine::{compile_time_machine, AllocMap, Machine, MayLeak, StackPopJump};\n pub use self::memory::{AllocCheck, AllocRef, AllocRefMut, FnVal, Memory, MemoryKind};"}, {"sha": "cd172c87eb1644124e6ff2fdccb73fc608e70003", "filename": "compiler/rustc_mir/src/interpret/terminator.rs", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7b3e10c751ba79344591763bc205986b425dc445/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b3e10c751ba79344591763bc205986b425dc445/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs?ref=7b3e10c751ba79344591763bc205986b425dc445", "patch": "@@ -1,7 +1,8 @@\n use std::borrow::Cow;\n use std::convert::TryFrom;\n \n-use rustc_middle::ty::layout::TyAndLayout;\n+use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n+use rustc_middle::ty::layout::{self, TyAndLayout};\n use rustc_middle::ty::Instance;\n use rustc_middle::{\n     mir,\n@@ -12,9 +13,19 @@ use rustc_target::spec::abi::Abi;\n \n use super::{\n     FnVal, ImmTy, InterpCx, InterpResult, MPlaceTy, Machine, OpTy, PlaceTy, StackPopCleanup,\n+    StackPopUnwind,\n };\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+    pub(super) fn fn_can_unwind(&self, attrs: CodegenFnAttrFlags, abi: Abi) -> bool {\n+        layout::fn_can_unwind(\n+            self.tcx.sess.panic_strategy(),\n+            attrs,\n+            layout::conv_from_spec_abi(*self.tcx, abi),\n+            abi,\n+        )\n+    }\n+\n     pub(super) fn eval_terminator(\n         &mut self,\n         terminator: &mir::Terminator<'tcx>,\n@@ -58,12 +69,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let old_stack = self.frame_idx();\n                 let old_loc = self.frame().loc;\n                 let func = self.eval_operand(func, None)?;\n-                let (fn_val, abi) = match *func.layout.ty.kind() {\n+                let (fn_val, abi, can_unwind) = match *func.layout.ty.kind() {\n                     ty::FnPtr(sig) => {\n                         let caller_abi = sig.abi();\n                         let fn_ptr = self.read_scalar(&func)?.check_init()?;\n                         let fn_val = self.memory.get_fn(fn_ptr)?;\n-                        (fn_val, caller_abi)\n+                        (\n+                            fn_val,\n+                            caller_abi,\n+                            self.fn_can_unwind(layout::fn_ptr_codegen_fn_attr_flags(), caller_abi),\n+                        )\n                     }\n                     ty::FnDef(def_id, substs) => {\n                         let sig = func.layout.ty.fn_sig(*self.tcx);\n@@ -72,6 +87,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                                 self.resolve(ty::WithOptConstParam::unknown(def_id), substs)?,\n                             ),\n                             sig.abi(),\n+                            self.fn_can_unwind(self.tcx.codegen_fn_attrs(def_id).flags, sig.abi()),\n                         )\n                     }\n                     _ => span_bug!(\n@@ -89,7 +105,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                     None => None,\n                 };\n-                self.eval_fn_call(fn_val, abi, &args[..], ret, *cleanup)?;\n+                self.eval_fn_call(fn_val, abi, &args[..], ret, *cleanup, can_unwind)?;\n                 // Sanity-check that `eval_fn_call` either pushed a new frame or\n                 // did a jump to another block.\n                 if self.frame_idx() == old_stack && self.frame().loc == old_loc {\n@@ -220,6 +236,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         args: &[OpTy<'tcx, M::PointerTag>],\n         ret: Option<(&PlaceTy<'tcx, M::PointerTag>, mir::BasicBlock)>,\n         unwind: Option<mir::BasicBlock>,\n+        can_unwind: bool,\n     ) -> InterpResult<'tcx> {\n         trace!(\"eval_fn_call: {:#?}\", fn_val);\n \n@@ -287,7 +304,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     instance,\n                     body,\n                     ret.map(|p| p.0),\n-                    StackPopCleanup::Goto { ret: ret.map(|p| p.1), unwind },\n+                    StackPopCleanup::Goto {\n+                        ret: ret.map(|p| p.1),\n+                        unwind: if can_unwind {\n+                            StackPopUnwind::Cleanup(unwind)\n+                        } else {\n+                            StackPopUnwind::NotAllowed\n+                        },\n+                    },\n                 )?;\n \n                 // If an error is raised here, pop the frame again to get an accurate backtrace.\n@@ -432,7 +456,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     OpTy::from(ImmTy::from_immediate(receiver_place.ptr.into(), this_receiver_ptr));\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n-                self.eval_fn_call(drop_fn, caller_abi, &args, ret, unwind)\n+                self.eval_fn_call(drop_fn, caller_abi, &args, ret, unwind, can_unwind)\n             }\n         }\n     }\n@@ -472,6 +496,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             &[arg.into()],\n             Some((&dest.into(), target)),\n             unwind,\n+            true,\n         )\n     }\n }"}]}