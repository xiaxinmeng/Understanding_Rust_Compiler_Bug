{"sha": "0ec1533054102e22a3318d08d6d42b3f2d583cea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlYzE1MzMwNTQxMDJlMjJhMzMxOGQwOGQ2ZDQyYjNmMmQ1ODNjZWE=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-06-11T02:38:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-06-11T02:38:26Z"}, "message": "Merge pull request #2779 from thibaultdelor/stableApi\n\nImprove end lines handling", "tree": {"sha": "371c063cbeeae2eda32fc2dbc749af676ed76c13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/371c063cbeeae2eda32fc2dbc749af676ed76c13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ec1533054102e22a3318d08d6d42b3f2d583cea", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbHeCiCRBK7hj4Ov3rIwAAdHIIAGApVBEdggf6yuFLB+AlT9yz\nmDM+/pTXzbZVxKGE0nR1pN8Ro+Yhz1s+pCAXP6myPl9HLYPBwMuyAva0zGIZbqUV\nrBeN/Bq3MdKG5LQn5cw1R7f3LD50yOXbGPLeDRjn5Dc4lkHUivY+Z3RqljeVyFgF\nJErn6YcnGOKFY2DaCIzKzVHAcOHcsEfZghtAVwCDqQpWSSOZd6DPMZtsPr8vGUOP\ndHRe17APoHnkFEwJtcLSYjarv0ze8p0d6/qxVKYesg0hV8v2avbuzvPPT+ygxEmK\nr/c35Co4XOIoSa75AExGiUq6XIBhMTPt2XacJ9CSkymbg0GBv1dr8NmQnT/ZnU0=\n=XNSo\n-----END PGP SIGNATURE-----\n", "payload": "tree 371c063cbeeae2eda32fc2dbc749af676ed76c13\nparent 46d145b54ea1cb3545ec8ad707931e01ffdb016b\nparent 6b00b8b302ba2e0a0946739ebe279d17f43f589b\nauthor Seiichi Uchida <seuchida@gmail.com> 1528684706 +0900\ncommitter GitHub <noreply@github.com> 1528684706 +0900\n\nMerge pull request #2779 from thibaultdelor/stableApi\n\nImprove end lines handling"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ec1533054102e22a3318d08d6d42b3f2d583cea", "html_url": "https://github.com/rust-lang/rust/commit/0ec1533054102e22a3318d08d6d42b3f2d583cea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ec1533054102e22a3318d08d6d42b3f2d583cea/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46d145b54ea1cb3545ec8ad707931e01ffdb016b", "url": "https://api.github.com/repos/rust-lang/rust/commits/46d145b54ea1cb3545ec8ad707931e01ffdb016b", "html_url": "https://github.com/rust-lang/rust/commit/46d145b54ea1cb3545ec8ad707931e01ffdb016b"}, {"sha": "6b00b8b302ba2e0a0946739ebe279d17f43f589b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b00b8b302ba2e0a0946739ebe279d17f43f589b", "html_url": "https://github.com/rust-lang/rust/commit/6b00b8b302ba2e0a0946739ebe279d17f43f589b"}], "stats": {"total": 193, "additions": 78, "deletions": 115}, "files": [{"sha": "507e85f2086f9f6a1c30b242f40385eb50ad8243", "filename": "src/filemap.rs", "status": "modified", "additions": 36, "deletions": 101, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/0ec1533054102e22a3318d08d6d42b3f2d583cea/src%2Ffilemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec1533054102e22a3318d08d6d42b3f2d583cea/src%2Ffilemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffilemap.rs?ref=0ec1533054102e22a3318d08d6d42b3f2d583cea", "patch": "@@ -10,13 +10,12 @@\n \n // TODO: add tests\n \n-use std::fs::{self, File};\n-use std::io::{self, BufWriter, Read, Write};\n-use std::path::Path;\n+use std::fs;\n+use std::io::{self, Write};\n \n use checkstyle::output_checkstyle_file;\n-use config::{Config, EmitMode, FileName, NewlineStyle, Verbosity};\n-use rustfmt_diff::{make_diff, output_modified, print_diff, Mismatch};\n+use config::{Config, EmitMode, FileName, Verbosity};\n+use rustfmt_diff::{make_diff, output_modified, print_diff};\n \n #[cfg(test)]\n use FileRecord;\n@@ -48,72 +47,15 @@ where\n     Ok(())\n }\n \n-// Prints all newlines either as `\\n` or as `\\r\\n`.\n-pub fn write_system_newlines<T>(writer: T, text: &str, config: &Config) -> Result<(), io::Error>\n-where\n-    T: Write,\n-{\n-    // Buffer output, since we're writing a since char at a time.\n-    let mut writer = BufWriter::new(writer);\n-\n-    let style = if config.newline_style() == NewlineStyle::Native {\n-        if cfg!(windows) {\n-            NewlineStyle::Windows\n-        } else {\n-            NewlineStyle::Unix\n-        }\n-    } else {\n-        config.newline_style()\n-    };\n-\n-    match style {\n-        NewlineStyle::Unix => write!(writer, \"{}\", text),\n-        NewlineStyle::Windows => {\n-            for c in text.chars() {\n-                match c {\n-                    '\\n' => write!(writer, \"\\r\\n\")?,\n-                    '\\r' => continue,\n-                    c => write!(writer, \"{}\", c)?,\n-                }\n-            }\n-            Ok(())\n-        }\n-        NewlineStyle::Native => unreachable!(),\n-    }\n-}\n-\n pub fn write_file<T>(\n-    text: &str,\n+    formatted_text: &str,\n     filename: &FileName,\n     out: &mut T,\n     config: &Config,\n ) -> Result<bool, io::Error>\n where\n     T: Write,\n {\n-    fn source_and_formatted_text(\n-        text: &str,\n-        filename: &Path,\n-        config: &Config,\n-    ) -> Result<(String, String), io::Error> {\n-        let mut f = File::open(filename)?;\n-        let mut ori_text = String::new();\n-        f.read_to_string(&mut ori_text)?;\n-        let mut v = Vec::new();\n-        write_system_newlines(&mut v, text, config)?;\n-        let fmt_text = String::from_utf8(v).unwrap();\n-        Ok((ori_text, fmt_text))\n-    }\n-\n-    fn create_diff(\n-        filename: &Path,\n-        text: &str,\n-        config: &Config,\n-    ) -> Result<Vec<Mismatch>, io::Error> {\n-        let (ori, fmt) = source_and_formatted_text(text, filename, config)?;\n-        Ok(make_diff(&ori, &fmt, 3))\n-    }\n-\n     let filename_to_path = || match *filename {\n         FileName::Real(ref path) => path,\n         _ => panic!(\"cannot format `{}` and emit to files\", filename),\n@@ -122,65 +64,58 @@ where\n     match config.emit_mode() {\n         EmitMode::Files if config.make_backup() => {\n             let filename = filename_to_path();\n-            if let Ok((ori, fmt)) = source_and_formatted_text(text, filename, config) {\n-                if fmt != ori {\n-                    // Do a little dance to make writing safer - write to a temp file\n-                    // rename the original to a .bk, then rename the temp file to the\n-                    // original.\n-                    let tmp_name = filename.with_extension(\"tmp\");\n-                    let bk_name = filename.with_extension(\"bk\");\n-                    {\n-                        // Write text to temp file\n-                        let tmp_file = File::create(&tmp_name)?;\n-                        write_system_newlines(tmp_file, text, config)?;\n-                    }\n-\n-                    fs::rename(filename, bk_name)?;\n-                    fs::rename(tmp_name, filename)?;\n-                }\n+            let ori = fs::read_to_string(filename)?;\n+            if ori != formatted_text {\n+                // Do a little dance to make writing safer - write to a temp file\n+                // rename the original to a .bk, then rename the temp file to the\n+                // original.\n+                let tmp_name = filename.with_extension(\"tmp\");\n+                let bk_name = filename.with_extension(\"bk\");\n+\n+                fs::write(&tmp_name, formatted_text)?;\n+                fs::rename(filename, bk_name)?;\n+                fs::rename(tmp_name, filename)?;\n             }\n         }\n         EmitMode::Files => {\n             // Write text directly over original file if there is a diff.\n             let filename = filename_to_path();\n-            let (source, formatted) = source_and_formatted_text(text, filename, config)?;\n-            if source != formatted {\n-                let file = File::create(filename)?;\n-                write_system_newlines(file, text, config)?;\n+            let ori = fs::read_to_string(filename)?;\n+            if ori != formatted_text {\n+                fs::write(filename, formatted_text)?;\n             }\n         }\n         EmitMode::Stdout | EmitMode::Coverage => {\n             if config.verbose() != Verbosity::Quiet {\n                 println!(\"{}:\\n\", filename);\n             }\n-            write_system_newlines(out, text, config)?;\n+            write!(out, \"{}\", formatted_text)?;\n         }\n         EmitMode::ModifiedLines => {\n             let filename = filename_to_path();\n-            if let Ok((ori, fmt)) = source_and_formatted_text(text, filename, config) {\n-                let mismatch = make_diff(&ori, &fmt, 0);\n-                let has_diff = !mismatch.is_empty();\n-                output_modified(out, mismatch);\n-                return Ok(has_diff);\n-            }\n+            let ori = fs::read_to_string(filename)?;\n+            let mismatch = make_diff(&ori, formatted_text, 0);\n+            let has_diff = !mismatch.is_empty();\n+            output_modified(out, mismatch);\n+            return Ok(has_diff);\n         }\n         EmitMode::Checkstyle => {\n             let filename = filename_to_path();\n-            let diff = create_diff(filename, text, config)?;\n+            let ori = fs::read_to_string(filename)?;\n+            let diff = make_diff(&ori, formatted_text, 3);\n             output_checkstyle_file(out, filename, diff)?;\n         }\n         EmitMode::Diff => {\n             let filename = filename_to_path();\n-            if let Ok((ori, fmt)) = source_and_formatted_text(text, filename, config) {\n-                let mismatch = make_diff(&ori, &fmt, 3);\n-                let has_diff = !mismatch.is_empty();\n-                print_diff(\n-                    mismatch,\n-                    |line_num| format!(\"Diff in {} at line {}:\", filename.display(), line_num),\n-                    config,\n-                );\n-                return Ok(has_diff);\n-            }\n+            let ori = fs::read_to_string(filename)?;\n+            let mismatch = make_diff(&ori, formatted_text, 3);\n+            let has_diff = !mismatch.is_empty();\n+            print_diff(\n+                mismatch,\n+                |line_num| format!(\"Diff in {} at line {}:\", filename.display(), line_num),\n+                config,\n+            );\n+            return Ok(has_diff);\n         }\n     }\n "}, {"sha": "7c33a01953be43863c130a04fa442b737571c979", "filename": "src/lib.rs", "status": "modified", "additions": 39, "deletions": 5, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0ec1533054102e22a3318d08d6d42b3f2d583cea/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec1533054102e22a3318d08d6d42b3f2d583cea/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=0ec1533054102e22a3318d08d6d42b3f2d583cea", "patch": "@@ -60,7 +60,8 @@ use visitor::{FmtVisitor, SnippetProvider};\n pub use checkstyle::{footer as checkstyle_footer, header as checkstyle_header};\n pub use config::summary::Summary;\n pub use config::{\n-    load_config, CliOptions, Color, Config, EmitMode, FileLines, FileName, Range, Verbosity,\n+    load_config, CliOptions, Color, Config, EmitMode, FileLines, FileName, NewlineStyle, Range,\n+    Verbosity,\n };\n \n #[macro_use]\n@@ -132,6 +133,9 @@ pub enum ErrorKind {\n     /// An io error during reading or writing.\n     #[fail(display = \"io error: {}\", _0)]\n     IoError(io::Error),\n+    /// Parse error occured when parsing the Input.\n+    #[fail(display = \"parse error\")]\n+    ParseError,\n     /// The user mandated a version and the current version of Rustfmt does not\n     /// satisfy that requirement.\n     #[fail(display = \"Version mismatch\")]\n@@ -172,9 +176,10 @@ impl FormattingError {\n     }\n     fn msg_prefix(&self) -> &str {\n         match self.kind {\n-            ErrorKind::LineOverflow(..) | ErrorKind::TrailingWhitespace | ErrorKind::IoError(_) => {\n-                \"internal error:\"\n-            }\n+            ErrorKind::LineOverflow(..)\n+            | ErrorKind::TrailingWhitespace\n+            | ErrorKind::IoError(_)\n+            | ErrorKind::ParseError => \"internal error:\",\n             ErrorKind::LicenseCheck | ErrorKind::BadAttr | ErrorKind::VersionMismatch => \"error:\",\n             ErrorKind::BadIssue(_) | ErrorKind::DeprecatedAttr => \"warning:\",\n         }\n@@ -832,7 +837,7 @@ fn format_input_inner<T: Write>(\n                 ParseError::Recovered => {}\n             }\n             summary.add_parsing_error();\n-            return Ok((summary, FileMap::new(), FormatReport::new()));\n+            return Err((ErrorKind::ParseError, summary));\n         }\n     };\n \n@@ -861,6 +866,7 @@ fn format_input_inner<T: Write>(\n             filemap::append_newline(file);\n \n             format_lines(file, file_name, skipped_range, config, report);\n+            replace_with_system_newlines(file, config);\n \n             if let Some(ref mut out) = out {\n                 return filemap::write_file(file, file_name, out, config);\n@@ -913,6 +919,34 @@ fn format_input_inner<T: Write>(\n     }\n }\n \n+pub fn replace_with_system_newlines(text: &mut String, config: &Config) -> () {\n+    let style = if config.newline_style() == NewlineStyle::Native {\n+        if cfg!(windows) {\n+            NewlineStyle::Windows\n+        } else {\n+            NewlineStyle::Unix\n+        }\n+    } else {\n+        config.newline_style()\n+    };\n+\n+    match style {\n+        NewlineStyle::Unix => return,\n+        NewlineStyle::Windows => {\n+            let mut transformed = String::with_capacity(text.capacity());\n+            for c in text.chars() {\n+                match c {\n+                    '\\n' => transformed.push_str(\"\\r\\n\"),\n+                    '\\r' => continue,\n+                    c => transformed.push(c),\n+                }\n+            }\n+            *text = transformed;\n+        }\n+        NewlineStyle::Native => unreachable!(),\n+    }\n+}\n+\n /// A single span of changed lines, with 0 or more removed lines\n /// and a vector of 0 or more inserted lines.\n #[derive(Debug, PartialEq, Eq)]"}, {"sha": "fdbe1e6856e66c6856095354a034b4fc77a4efd1", "filename": "src/test/mod.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0ec1533054102e22a3318d08d6d42b3f2d583cea/src%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec1533054102e22a3318d08d6d42b3f2d583cea/src%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmod.rs?ref=0ec1533054102e22a3318d08d6d42b3f2d583cea", "patch": "@@ -22,7 +22,6 @@ use std::str::Chars;\n \n use config::summary::Summary;\n use config::{Color, Config, ReportTactic};\n-use filemap::write_system_newlines;\n use rustfmt_diff::*;\n use *;\n \n@@ -401,14 +400,9 @@ fn idempotent_check(\n     }\n \n     let mut write_result = HashMap::new();\n-    for &(ref filename, ref text) in &file_map {\n-        let mut v = Vec::new();\n-        // Won't panic, as we're not doing any IO.\n-        write_system_newlines(&mut v, text, &config).unwrap();\n-        // Won't panic, we are writing correct utf8.\n-        let one_result = String::from_utf8(v).unwrap();\n-        if let FileName::Real(ref filename) = *filename {\n-            write_result.insert(filename.to_owned(), one_result);\n+    for (filename, text) in file_map {\n+        if let FileName::Real(ref filename) = filename {\n+            write_result.insert(filename.to_owned(), text);\n         }\n     }\n "}]}