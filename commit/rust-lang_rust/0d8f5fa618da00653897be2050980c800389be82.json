{"sha": "0d8f5fa618da00653897be2050980c800389be82", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkOGY1ZmE2MThkYTAwNjUzODk3YmUyMDUwOTgwYzgwMDM4OWJlODI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-07T04:25:36Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-07T15:17:32Z"}, "message": "core: Move Option::expect to libstd from libcore\n\nSee #14008 for more details", "tree": {"sha": "d88105c495c8df50a0226e06ea1179bac1126896", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d88105c495c8df50a0226e06ea1179bac1126896"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d8f5fa618da00653897be2050980c800389be82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d8f5fa618da00653897be2050980c800389be82", "html_url": "https://github.com/rust-lang/rust/commit/0d8f5fa618da00653897be2050980c800389be82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d8f5fa618da00653897be2050980c800389be82/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a974413dcce8a5a9f1df3d58503c63b8f5b556a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a974413dcce8a5a9f1df3d58503c63b8f5b556a", "html_url": "https://github.com/rust-lang/rust/commit/4a974413dcce8a5a9f1df3d58503c63b8f5b556a"}], "stats": {"total": 210, "additions": 177, "deletions": 33}, "files": [{"sha": "c6884a8002f799a06f17efe7d9dbe52e8ce2280a", "filename": "src/libcore/option.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0d8f5fa618da00653897be2050980c800389be82/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8f5fa618da00653897be2050980c800389be82/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=0d8f5fa618da00653897be2050980c800389be82", "patch": "@@ -230,30 +230,6 @@ impl<T> Option<T> {\n     // Getting to contained values\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Unwraps an option, yielding the content of a `Some`\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the value is a `None` with a custom failure message provided by `msg`.\n-    #[inline]\n-    #[cfg(not(test))]\n-    pub fn expect(self, msg: &str) -> T {\n-        match self {\n-            Some(val) => val,\n-            None => fail!(msg),\n-        }\n-    }\n-\n-    // FIXME: once std::fmt is in libcore, this extra variant should not be\n-    //        necessary.\n-    #[cfg(test)]\n-    pub fn expect(self, msg: &str) -> T {\n-        match self {\n-            Some(val) => val,\n-            None => fail!(\"{}\", msg),\n-        }\n-    }\n-\n     /// Moves a value out of an option type and returns it, consuming the `Option`.\n     ///\n     /// # Failure"}, {"sha": "50447f0c5b375cb1e7a5591780106186cbce1e82", "filename": "src/libcore/should_not_exist.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0d8f5fa618da00653897be2050980c800389be82/src%2Flibcore%2Fshould_not_exist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8f5fa618da00653897be2050980c800389be82/src%2Flibcore%2Fshould_not_exist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fshould_not_exist.rs?ref=0d8f5fa618da00653897be2050980c800389be82", "patch": "@@ -34,7 +34,7 @@ extern {\n }\n \n unsafe fn alloc(cap: uint) -> *mut Vec<()> {\n-    let cap = cap.checked_add(&mem::size_of::<Vec<()>>()).expect(\"cap overflow\");\n+    let cap = cap.checked_add(&mem::size_of::<Vec<()>>()).unwrap();\n     let ret = malloc(cap) as *mut Vec<()>;\n     if ret.is_null() {\n         intrinsics::abort();\n@@ -94,7 +94,7 @@ impl FromIterator<char> for ~str {\n                 let amt = ch.encode_utf8(tmp);\n \n                 if len + amt > cap {\n-                    cap = cap.checked_mul(&2).expect(\"cap overflow\");\n+                    cap = cap.checked_mul(&2).unwrap();\n                     if cap < len + amt {\n                         cap = len + amt;\n                     }\n@@ -124,7 +124,7 @@ impl FromIterator<char> for ~str {\n impl<'a> Add<&'a str,~str> for &'a str {\n     #[inline]\n     fn add(&self, rhs: & &'a str) -> ~str {\n-        let amt = self.len().checked_add(&rhs.len()).expect(\"len overflow\");\n+        let amt = self.len().checked_add(&rhs.len()).unwrap();\n         unsafe {\n             let ptr = alloc(amt) as *mut Vec<u8>;\n             let base = &mut (*ptr).data as *mut _;\n@@ -155,15 +155,15 @@ impl<A> FromIterator<A> for ~[A] {\n     fn from_iter<T: Iterator<A>>(mut iterator: T) -> ~[A] {\n         let (lower, _) = iterator.size_hint();\n         let cap = if lower == 0 {16} else {lower};\n-        let mut cap = cap.checked_mul(&mem::size_of::<A>()).expect(\"cap overflow\");\n+        let mut cap = cap.checked_mul(&mem::size_of::<A>()).unwrap();\n         let mut len = 0;\n \n         unsafe {\n             let mut ptr = alloc(cap) as *mut Vec<A>;\n             let mut ret = cast::transmute(ptr);\n             for elt in iterator {\n                 if len * mem::size_of::<A>() >= cap {\n-                    cap = cap.checked_mul(&2).expect(\"cap overflow\");\n+                    cap = cap.checked_mul(&2).unwrap();\n                     let ptr2 = alloc(cap) as *mut Vec<A>;\n                     ptr::copy_nonoverlapping_memory(&mut (*ptr2).data,\n                                                     &(*ptr).data,"}, {"sha": "5565918ef854f5dfff0624e61e23d49e4af8d007", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d8f5fa618da00653897be2050980c800389be82/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8f5fa618da00653897be2050980c800389be82/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=0d8f5fa618da00653897be2050980c800389be82", "patch": "@@ -21,6 +21,7 @@ use comm::Receiver;\n use io::IoResult;\n use kinds::Send;\n use owned::Box;\n+use option::Expect;\n use rt::rtio::{IoFactory, LocalIo, RtioTimer};\n \n /// A synchronous timer object"}, {"sha": "abcc1f099b4a470f3c227b334ab1298bda932d0e", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d8f5fa618da00653897be2050980c800389be82/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8f5fa618da00653897be2050980c800389be82/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=0d8f5fa618da00653897be2050980c800389be82", "patch": "@@ -149,7 +149,6 @@ pub use core::default;\n pub use core::intrinsics;\n pub use core::iter;\n pub use core::mem;\n-pub use core::option;\n pub use core::ptr;\n pub use core::raw;\n pub use core::tuple;\n@@ -221,7 +220,7 @@ pub mod hash;\n /* Common data structures */\n \n pub mod result;\n-\n+pub mod option;\n \n /* Tasks and communication */\n "}, {"sha": "17249f567e5387441f8e553a9d194838ad5453f9", "filename": "src/libstd/option.rs", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/0d8f5fa618da00653897be2050980c800389be82/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8f5fa618da00653897be2050980c800389be82/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=0d8f5fa618da00653897be2050980c800389be82", "patch": "@@ -0,0 +1,167 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Optional values\n+//!\n+//! Type `Option` represents an optional value: every `Option`\n+//! is either `Some` and contains a value, or `None`, and\n+//! does not. `Option` types are very common in Rust code, as\n+//! they have a number of uses:\n+//!\n+//! * Initial values\n+//! * Return values for functions that are not defined\n+//!   over their entire input range (partial functions)\n+//! * Return value for otherwise reporting simple errors, where `None` is\n+//!   returned on error\n+//! * Optional struct fields\n+//! * Struct fields that can be loaned or \"taken\"\n+//! * Optional function arguments\n+//! * Nullable pointers\n+//! * Swapping things out of difficult situations\n+//!\n+//! Options are commonly paired with pattern matching to query the presence\n+//! of a value and take action, always accounting for the `None` case.\n+//!\n+//! ```\n+//! # // FIXME This is not the greatest first example\n+//! // cow_says contains the word \"moo\"\n+//! let cow_says = Some(\"moo\");\n+//! // dog_says does not contain a value\n+//! let dog_says: Option<&str> = None;\n+//!\n+//! // Pattern match to retrieve the value\n+//! match (cow_says, dog_says) {\n+//!     (Some(cow_words), Some(dog_words)) => {\n+//!         println!(\"Cow says {} and dog says {}!\", cow_words, dog_words);\n+//!     }\n+//!     (Some(cow_words), None) => println!(\"Cow says {}\", cow_words),\n+//!     (None, Some(dog_words)) => println!(\"Dog says {}\", dog_words),\n+//!     (None, None) => println!(\"Cow and dog are suspiciously silent\")\n+//! }\n+//! ```\n+//!\n+//\n+// FIXME: Show how `Option` is used in practice, with lots of methods\n+//\n+//! # Options and pointers (\"nullable\" pointers)\n+//!\n+//! Rust's pointer types must always point to a valid location; there are\n+//! no \"null\" pointers. Instead, Rust has *optional* pointers, like\n+//! the optional owned box, `Option<~T>`.\n+//!\n+//! The following example uses `Option` to create an optional box of\n+//! `int`. Notice that in order to use the inner `int` value first the\n+//! `check_optional` function needs to use pattern matching to\n+//! determine whether the box has a value (i.e. it is `Some(...)`) or\n+//! not (`None`).\n+//!\n+//! ```\n+//! let optional: Option<~int> = None;\n+//! check_optional(&optional);\n+//!\n+//! let optional: Option<~int> = Some(~9000);\n+//! check_optional(&optional);\n+//!\n+//! fn check_optional(optional: &Option<~int>) {\n+//!     match *optional {\n+//!         Some(ref p) => println!(\"have value {}\", p),\n+//!         None => println!(\"have no value\")\n+//!     }\n+//! }\n+//! ```\n+//!\n+//! This usage of `Option` to create safe nullable pointers is so\n+//! common that Rust does special optimizations to make the\n+//! representation of `Option<~T>` a single pointer. Optional pointers\n+//! in Rust are stored as efficiently as any other pointer type.\n+//!\n+//! # Examples\n+//!\n+//! Basic pattern matching on `Option`:\n+//!\n+//! ```\n+//! let msg = Some(\"howdy\");\n+//!\n+//! // Take a reference to the contained string\n+//! match msg {\n+//!     Some(ref m) => println!(\"{}\", *m),\n+//!     None => ()\n+//! }\n+//!\n+//! // Remove the contained string, destroying the Option\n+//! let unwrapped_msg = match msg {\n+//!     Some(m) => m,\n+//!     None => \"default message\"\n+//! };\n+//! ```\n+//!\n+//! Initialize a result to `None` before a loop:\n+//!\n+//! ```\n+//! enum Kingdom { Plant(uint, &'static str), Animal(uint, &'static str) }\n+//!\n+//! // A list of data to search through.\n+//! let all_the_big_things = [\n+//!     Plant(250, \"redwood\"),\n+//!     Plant(230, \"noble fir\"),\n+//!     Plant(229, \"sugar pine\"),\n+//!     Animal(25, \"blue whale\"),\n+//!     Animal(19, \"fin whale\"),\n+//!     Animal(15, \"north pacific right whale\"),\n+//! ];\n+//!\n+//! // We're going to search for the name of the biggest animal,\n+//! // but to start with we've just got `None`.\n+//! let mut name_of_biggest_animal = None;\n+//! let mut size_of_biggest_animal = 0;\n+//! for big_thing in all_the_big_things.iter() {\n+//!     match *big_thing {\n+//!         Animal(size, name) if size > size_of_biggest_animal => {\n+//!             // Now we've found the name of some big animal\n+//!             size_of_biggest_animal = size;\n+//!             name_of_biggest_animal = Some(name);\n+//!         }\n+//!         Animal(..) | Plant(..) => ()\n+//!     }\n+//! }\n+//!\n+//! match name_of_biggest_animal {\n+//!     Some(name) => println!(\"the biggest animal is {}\", name),\n+//!     None => println!(\"there are no animals :(\")\n+//! }\n+//! ```\n+\n+use any::Any;\n+use kinds::Send;\n+\n+pub use core::option::{Option, Some, None, Item, collect};\n+\n+/// Extension trait for the `Option` type to add an `expect` method\n+\n+// FIXME(#14008) should this trait even exist?\n+pub trait Expect<T> {\n+    /// Unwraps an option, yielding the content of a `Some`\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the value is a `None` with a custom failure message provided by\n+    /// `msg`.\n+    fn expect<M: Any + Send>(self, m: M) -> T;\n+}\n+\n+impl<T> Expect<T> for Option<T> {\n+    #[inline]\n+    fn expect<M: Any + Send>(self, msg: M) -> T {\n+        match self {\n+            Some(val) => val,\n+            None => fail!(msg),\n+        }\n+    }\n+}"}, {"sha": "6cd9e96496fe0ae85fb3557435cd3df7cffe3e91", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d8f5fa618da00653897be2050980c800389be82/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8f5fa618da00653897be2050980c800389be82/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=0d8f5fa618da00653897be2050980c800389be82", "patch": "@@ -65,6 +65,7 @@ pub use iter::{OrdIterator, MutableDoubleEndedIterator, ExactSize};\n pub use num::{Num, NumCast, CheckedAdd, CheckedSub, CheckedMul};\n pub use num::{Signed, Unsigned};\n pub use num::{Primitive, Int, Float, ToPrimitive, FromPrimitive};\n+pub use option::Expect;\n pub use owned::Box;\n pub use path::{GenericPath, Path, PosixPath, WindowsPath};\n pub use ptr::RawPtr;"}, {"sha": "708c42030ab7e1d6bcca6dd38f252cd7b8e22c7f", "filename": "src/libstd/rt/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d8f5fa618da00653897be2050980c800389be82/src%2Flibstd%2Frt%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8f5fa618da00653897be2050980c800389be82/src%2Flibstd%2Frt%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fenv.rs?ref=0d8f5fa618da00653897be2050980c800389be82", "patch": "@@ -11,7 +11,7 @@\n //! Runtime environment settings\n \n use from_str::from_str;\n-use option::{Some, None};\n+use option::{Some, None, Expect};\n use os;\n \n // Note that these are all accessed without any synchronization."}, {"sha": "af146b96e505a1c3128baed38c241ec21b7c6435", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d8f5fa618da00653897be2050980c800389be82/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8f5fa618da00653897be2050980c800389be82/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=0d8f5fa618da00653897be2050980c800389be82", "patch": "@@ -23,7 +23,7 @@ use mem;\n use num;\n use num::{CheckedMul, CheckedAdd};\n use ops::Drop;\n-use option::{None, Option, Some};\n+use option::{None, Option, Some, Expect};\n use ptr::RawPtr;\n use ptr;\n use rt::global_heap::{malloc_raw, realloc_raw};"}]}