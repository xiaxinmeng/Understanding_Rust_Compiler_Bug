{"sha": "33d5da1ee400e4b1b85a6a3f0c552ce68c665500", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzZDVkYTFlZTQwMGU0YjFiODVhNmEzZjBjNTUyY2U2OGM2NjU1MDA=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2018-02-23T15:25:03Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2018-03-06T08:47:43Z"}, "message": "Clean up handling of symbol export information.", "tree": {"sha": "83cf73b9016fa5df1db3362c68004451d8be8d40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83cf73b9016fa5df1db3362c68004451d8be8d40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33d5da1ee400e4b1b85a6a3f0c552ce68c665500", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33d5da1ee400e4b1b85a6a3f0c552ce68c665500", "html_url": "https://github.com/rust-lang/rust/commit/33d5da1ee400e4b1b85a6a3f0c552ce68c665500", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33d5da1ee400e4b1b85a6a3f0c552ce68c665500/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5ee01143b5a94fbc0fee8d4b3e7830946ef0a3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5ee01143b5a94fbc0fee8d4b3e7830946ef0a3a", "html_url": "https://github.com/rust-lang/rust/commit/e5ee01143b5a94fbc0fee8d4b3e7830946ef0a3a"}], "stats": {"total": 440, "additions": 231, "deletions": 209}, "files": [{"sha": "5dbe2ef516cf7c2ab7406f0832b02a2e3d9d3027", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/33d5da1ee400e4b1b85a6a3f0c552ce68c665500/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33d5da1ee400e4b1b85a6a3f0c552ce68c665500/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=33d5da1ee400e4b1b85a6a3f0c552ce68c665500", "patch": "@@ -32,7 +32,6 @@ use ich;\n use ty::{self, TyCtxt};\n use session::{Session, CrateDisambiguator};\n use session::search_paths::PathKind;\n-use util::nodemap::NodeSet;\n \n use std::any::Any;\n use std::collections::BTreeMap;\n@@ -258,8 +257,7 @@ pub trait CrateStore {\n     // utility functions\n     fn encode_metadata<'a, 'tcx>(&self,\n                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 link_meta: &LinkMeta,\n-                                 reachable: &NodeSet)\n+                                 link_meta: &LinkMeta)\n                                  -> EncodedMetadata;\n     fn metadata_encoding_version(&self) -> &[u8];\n }\n@@ -342,8 +340,7 @@ impl CrateStore for DummyCrateStore {\n     fn extern_mod_stmt_cnum_untracked(&self, emod_id: ast::NodeId) -> Option<CrateNum> { None }\n     fn encode_metadata<'a, 'tcx>(&self,\n                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 link_meta: &LinkMeta,\n-                                 reachable: &NodeSet)\n+                                 link_meta: &LinkMeta)\n                                  -> EncodedMetadata {\n         bug!(\"encode_metadata\")\n     }"}, {"sha": "aac6b3dc08a785f65d67074be0b5c1d74bd913f0", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33d5da1ee400e4b1b85a6a3f0c552ce68c665500/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33d5da1ee400e4b1b85a6a3f0c552ce68c665500/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=33d5da1ee400e4b1b85a6a3f0c552ce68c665500", "patch": "@@ -46,7 +46,7 @@ use ty::layout::{LayoutDetails, TargetDataLayout};\n use ty::maps;\n use ty::steal::Steal;\n use ty::BindingMode;\n-use util::nodemap::{NodeMap, NodeSet, DefIdSet, ItemLocalMap};\n+use util::nodemap::{NodeMap, DefIdSet, ItemLocalMap};\n use util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n use rustc_data_structures::stable_hasher::{HashStable, hash_stable_hashmap,\n@@ -1417,10 +1417,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n-    pub fn encode_metadata(self, link_meta: &LinkMeta, reachable: &NodeSet)\n+    pub fn encode_metadata(self, link_meta: &LinkMeta)\n         -> EncodedMetadata\n     {\n-        self.cstore.encode_metadata(self, link_meta, reachable)\n+        self.cstore.encode_metadata(self, link_meta)\n     }\n }\n "}, {"sha": "00862816d57b4f261183f03f0bad9d855a61b1e1", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/33d5da1ee400e4b1b85a6a3f0c552ce68c665500/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33d5da1ee400e4b1b85a6a3f0c552ce68c665500/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=33d5da1ee400e4b1b85a6a3f0c552ce68c665500", "patch": "@@ -27,7 +27,7 @@ use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE, CRATE_DEF_INDEX};\n use rustc::hir::map::{DefKey, DefPath, DefPathHash};\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::hir::map::definitions::DefPathTable;\n-use rustc::util::nodemap::{NodeSet, DefIdMap};\n+use rustc::util::nodemap::DefIdMap;\n \n use std::any::Any;\n use rustc_data_structures::sync::Lrc;\n@@ -517,11 +517,10 @@ impl CrateStore for cstore::CStore {\n \n     fn encode_metadata<'a, 'tcx>(&self,\n                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 link_meta: &LinkMeta,\n-                                 reachable: &NodeSet)\n+                                 link_meta: &LinkMeta)\n                                  -> EncodedMetadata\n     {\n-        encoder::encode_metadata(tcx, link_meta, reachable)\n+        encoder::encode_metadata(tcx, link_meta)\n     }\n \n     fn metadata_encoding_version(&self) -> &[u8]"}, {"sha": "c649cf62dc5d3c1e2a57cf0b83cf1d5a31fae057", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/33d5da1ee400e4b1b85a6a3f0c552ce68c665500/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33d5da1ee400e4b1b85a6a3f0c552ce68c665500/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=33d5da1ee400e4b1b85a6a3f0c552ce68c665500", "patch": "@@ -27,7 +27,7 @@ use rustc::ty::{self, Ty, TyCtxt, ReprOptions};\n use rustc::ty::codec::{self as ty_codec, TyEncoder};\n \n use rustc::session::config::{self, CrateTypeProcMacro};\n-use rustc::util::nodemap::{FxHashMap, NodeSet};\n+use rustc::util::nodemap::{FxHashMap, DefIdSet};\n \n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_serialize::{Encodable, Encoder, SpecializedEncoder, opaque};\n@@ -53,7 +53,6 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     opaque: opaque::Encoder<'a>,\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     link_meta: &'a LinkMeta,\n-    reachable_non_generics: &'a NodeSet,\n \n     lazy_state: LazyState,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n@@ -395,9 +394,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         // Encode exported symbols info.\n         i = self.position();\n+        let reachable_non_generics = self.tcx.reachable_non_generics(LOCAL_CRATE);\n         let reachable_non_generics = self.tracked(\n             IsolatedEncoder::encode_reachable_non_generics,\n-            self.reachable_non_generics);\n+            &reachable_non_generics);\n         let reachable_non_generics_bytes = self.position() - i;\n \n         // Encode and index the items.\n@@ -1389,11 +1389,12 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     // symbol associated with them (they weren't translated) or if they're an FFI\n     // definition (as that's not defined in this crate).\n     fn encode_reachable_non_generics(&mut self,\n-                                     reachable_non_generics: &NodeSet)\n+                                     reachable_non_generics: &DefIdSet)\n                                      -> LazySeq<DefIndex> {\n-        let tcx = self.tcx;\n-        self.lazy_seq(reachable_non_generics.iter()\n-                                            .map(|&id| tcx.hir.local_def_id(id).index))\n+        self.lazy_seq(reachable_non_generics.iter().map(|def_id| {\n+            debug_assert!(def_id.is_local());\n+            def_id.index\n+        }))\n     }\n \n     fn encode_dylib_dependency_formats(&mut self, _: ()) -> LazySeq<Option<LinkagePreference>> {\n@@ -1666,8 +1667,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'a, 'tcx> {\n // generated regardless of trailing bytes that end up in it.\n \n pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 link_meta: &LinkMeta,\n-                                 reachable_non_generics: &NodeSet)\n+                                 link_meta: &LinkMeta)\n                                  -> EncodedMetadata\n {\n     let mut cursor = Cursor::new(vec![]);\n@@ -1681,7 +1681,6 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             opaque: opaque::Encoder::new(&mut cursor),\n             tcx,\n             link_meta,\n-            reachable_non_generics,\n             lazy_state: LazyState::NoNode,\n             type_shorthands: Default::default(),\n             predicate_shorthands: Default::default(),"}, {"sha": "74f7a6e8d9cddb41cb4b10ca95544b4e9d892c31", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 207, "deletions": 124, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/33d5da1ee400e4b1b85a6a3f0c552ce68c665500/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33d5da1ee400e4b1b85a6a3f0c552ce68c665500/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=33d5da1ee400e4b1b85a6a3f0c552ce68c665500", "patch": "@@ -11,15 +11,15 @@\n use rustc_data_structures::sync::Lrc;\n use std::sync::Arc;\n \n-use base;\n use monomorphize::Instance;\n+use rustc::hir;\n use rustc::hir::def_id::CrateNum;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc::session::config;\n use rustc::ty::TyCtxt;\n use rustc::ty::maps::Providers;\n-use rustc::util::nodemap::FxHashMap;\n+use rustc::util::nodemap::{FxHashMap, DefIdSet};\n use rustc_allocator::ALLOCATOR_METHODS;\n use syntax::attr;\n \n@@ -60,145 +60,228 @@ pub fn crates_export_threshold(crate_types: &[config::CrateType])\n     }\n }\n \n-pub fn provide(providers: &mut Providers) {\n-    providers.reachable_non_generics = |tcx, cnum| {\n-        let export_threshold = threshold(tcx);\n-        Lrc::new(tcx.exported_symbols(cnum)\n-            .iter()\n-            .filter_map(|&(_, id, level)| {\n-                id.and_then(|id| {\n-                    if level.is_below_threshold(export_threshold) {\n-                        Some(id)\n+fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                             cnum: CrateNum)\n+                                             -> Lrc<DefIdSet>\n+{\n+    assert_eq!(cnum, LOCAL_CRATE);\n+\n+    if !tcx.sess.opts.output_types.should_trans() {\n+        return Lrc::new(DefIdSet())\n+    }\n+\n+    let export_threshold = threshold(tcx);\n+\n+    // We already collect all potentially reachable non-generic items for\n+    // `exported_symbols`. Now we just filter them down to what is actually\n+    // exported for the given crate we are compiling.\n+    let reachable_non_generics = tcx\n+        .exported_symbols(LOCAL_CRATE)\n+        .iter()\n+        .filter_map(|&(_, opt_def_id, level)| {\n+            if let Some(def_id) = opt_def_id {\n+                if level.is_below_threshold(export_threshold) {\n+                    return Some(def_id)\n+                }\n+            }\n+\n+            None\n+        })\n+        .collect();\n+\n+    Lrc::new(reachable_non_generics)\n+}\n+\n+fn is_reachable_non_generic_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                               def_id: DefId)\n+                                               -> bool {\n+    tcx.reachable_non_generics(def_id.krate).contains(&def_id)\n+}\n+\n+fn exported_symbols_provider_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                             cnum: CrateNum)\n+                                             -> Arc<Vec<(String,\n+                                                         Option<DefId>,\n+                                                         SymbolExportLevel)>>\n+{\n+    assert_eq!(cnum, LOCAL_CRATE);\n+\n+    if !tcx.sess.opts.output_types.should_trans() {\n+        return Arc::new(vec![])\n+    }\n+\n+    let mut reachable_non_generics: DefIdSet = tcx.reachable_set(LOCAL_CRATE).0\n+        .iter()\n+        .filter_map(|&node_id| {\n+            // We want to ignore some FFI functions that are not exposed from\n+            // this crate. Reachable FFI functions can be lumped into two\n+            // categories:\n+            //\n+            // 1. Those that are included statically via a static library\n+            // 2. Those included otherwise (e.g. dynamically or via a framework)\n+            //\n+            // Although our LLVM module is not literally emitting code for the\n+            // statically included symbols, it's an export of our library which\n+            // needs to be passed on to the linker and encoded in the metadata.\n+            //\n+            // As a result, if this id is an FFI item (foreign item) then we only\n+            // let it through if it's included statically.\n+            match tcx.hir.get(node_id) {\n+                hir::map::NodeForeignItem(..) => {\n+                    let def_id = tcx.hir.local_def_id(node_id);\n+                    if tcx.is_statically_included_foreign_item(def_id) {\n+                        Some(def_id)\n                     } else {\n                         None\n                     }\n-                })\n-            })\n-            .collect())\n-    };\n-\n-    providers.is_reachable_non_generic = |tcx, id| {\n-        tcx.reachable_non_generics(id.krate).contains(&id)\n-    };\n-\n-    providers.exported_symbols = |tcx, cnum| {\n-        assert_eq!(cnum, LOCAL_CRATE);\n-        let local_exported_symbols = base::find_exported_symbols(tcx);\n-\n-        let mut local_crate: Vec<_> = local_exported_symbols\n-            .iter()\n-            .map(|&node_id| {\n-                tcx.hir.local_def_id(node_id)\n-            })\n-            .map(|def_id| {\n-                let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n-                let export_level = export_level(tcx, def_id);\n-                debug!(\"EXPORTED SYMBOL (local): {} ({:?})\", name, export_level);\n-                (str::to_owned(&name), Some(def_id), export_level)\n-            })\n-            .collect();\n-\n-        if let Some(_) = *tcx.sess.entry_fn.borrow() {\n-            local_crate.push((\"main\".to_string(),\n-                              None,\n-                              SymbolExportLevel::C));\n-        }\n+                }\n \n-        if tcx.sess.allocator_kind.get().is_some() {\n-            for method in ALLOCATOR_METHODS {\n-                local_crate.push((format!(\"__rust_{}\", method.name),\n-                                  None,\n-                                  SymbolExportLevel::Rust));\n+                // Only consider nodes that actually have exported symbols.\n+                hir::map::NodeItem(&hir::Item {\n+                    node: hir::ItemStatic(..),\n+                    ..\n+                }) |\n+                hir::map::NodeItem(&hir::Item {\n+                    node: hir::ItemFn(..), ..\n+                }) |\n+                hir::map::NodeImplItem(&hir::ImplItem {\n+                    node: hir::ImplItemKind::Method(..),\n+                    ..\n+                }) => {\n+                    let def_id = tcx.hir.local_def_id(node_id);\n+                    let generics = tcx.generics_of(def_id);\n+                    if (generics.parent_types == 0 && generics.types.is_empty()) &&\n+                        // Functions marked with #[inline] are only ever translated\n+                        // with \"internal\" linkage and are never exported.\n+                        !Instance::mono(tcx, def_id).def.requires_local(tcx) {\n+                        Some(def_id)\n+                    } else {\n+                        None\n+                    }\n+                }\n+\n+                _ => None\n             }\n-        }\n+        })\n+        .collect();\n \n-        if let Some(id) = tcx.sess.derive_registrar_fn.get() {\n-            let def_id = tcx.hir.local_def_id(id);\n-            let disambiguator = tcx.sess.local_crate_disambiguator();\n-            let registrar = tcx.sess.generate_derive_registrar_symbol(disambiguator);\n-            local_crate.push((registrar, Some(def_id), SymbolExportLevel::C));\n-        }\n+    if let Some(id) = tcx.sess.derive_registrar_fn.get() {\n+        reachable_non_generics.insert(tcx.hir.local_def_id(id));\n+    }\n+\n+    if let Some(id) = tcx.sess.plugin_registrar_fn.get() {\n+        reachable_non_generics.insert(tcx.hir.local_def_id(id));\n+    }\n+\n+    let mut symbols: Vec<_> = reachable_non_generics\n+        .iter()\n+        .map(|&def_id| {\n+            let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n+            let export_level = tcx.symbol_export_level(def_id);\n+            debug!(\"EXPORTED SYMBOL (local): {} ({:?})\", name, export_level);\n+            (str::to_owned(&name), Some(def_id), export_level)\n+        })\n+        .collect();\n+\n+    if let Some(_) = *tcx.sess.entry_fn.borrow() {\n+        symbols.push((\"main\".to_string(), None, SymbolExportLevel::C));\n+    }\n \n-        if tcx.sess.crate_types.borrow().contains(&config::CrateTypeDylib) {\n-            local_crate.push((metadata_symbol_name(tcx),\n-                              None,\n-                              SymbolExportLevel::Rust));\n+    if tcx.sess.allocator_kind.get().is_some() {\n+        for method in ALLOCATOR_METHODS {\n+            symbols.push((format!(\"__rust_{}\", method.name),\n+                          None,\n+                          SymbolExportLevel::Rust));\n         }\n+    }\n \n-        // Sort so we get a stable incr. comp. hash.\n-        local_crate.sort_unstable_by(|&(ref name1, ..), &(ref name2, ..)| {\n-            name1.cmp(name2)\n-        });\n+    if tcx.sess.crate_types.borrow().contains(&config::CrateTypeDylib) {\n+        symbols.push((metadata_symbol_name(tcx),\n+                      None,\n+                      SymbolExportLevel::Rust));\n+    }\n \n-        Arc::new(local_crate)\n-    };\n+    // Sort so we get a stable incr. comp. hash.\n+    symbols.sort_unstable_by(|&(ref name1, ..), &(ref name2, ..)| {\n+        name1.cmp(name2)\n+    });\n \n-    providers.symbol_export_level = export_level;\n+    Arc::new(symbols)\n }\n \n-pub fn provide_extern(providers: &mut Providers) {\n-    providers.exported_symbols = |tcx, cnum| {\n-        // If this crate is a plugin and/or a custom derive crate, then\n-        // we're not even going to link those in so we skip those crates.\n-        if tcx.plugin_registrar_fn(cnum).is_some() ||\n-           tcx.derive_registrar_fn(cnum).is_some() {\n-            return Arc::new(Vec::new())\n-        }\n+pub fn provide(providers: &mut Providers) {\n+    providers.reachable_non_generics = reachable_non_generics_provider;\n+    providers.is_reachable_non_generic = is_reachable_non_generic_provider;\n+    providers.exported_symbols = exported_symbols_provider_local;\n+    providers.symbol_export_level = symbol_export_level_provider;\n+}\n \n-        // Check to see if this crate is a \"special runtime crate\". These\n-        // crates, implementation details of the standard library, typically\n-        // have a bunch of `pub extern` and `#[no_mangle]` functions as the\n-        // ABI between them. We don't want their symbols to have a `C`\n-        // export level, however, as they're just implementation details.\n-        // Down below we'll hardwire all of the symbols to the `Rust` export\n-        // level instead.\n-        let special_runtime_crate =\n-            tcx.is_panic_runtime(cnum) || tcx.is_compiler_builtins(cnum);\n-\n-        let mut crate_exports: Vec<_> = tcx\n-            .reachable_non_generics(cnum)\n-            .iter()\n-            .map(|&def_id| {\n-                let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n-                let export_level = if special_runtime_crate {\n-                    // We can probably do better here by just ensuring that\n-                    // it has hidden visibility rather than public\n-                    // visibility, as this is primarily here to ensure it's\n-                    // not stripped during LTO.\n-                    //\n-                    // In general though we won't link right if these\n-                    // symbols are stripped, and LTO currently strips them.\n-                    if &*name == \"rust_eh_personality\" ||\n-                       &*name == \"rust_eh_register_frames\" ||\n-                       &*name == \"rust_eh_unregister_frames\" {\n-                        SymbolExportLevel::C\n-                    } else {\n-                        SymbolExportLevel::Rust\n-                    }\n+fn exported_symbols_provider_extern<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                              cnum: CrateNum)\n+                                              -> Arc<Vec<(String,\n+                                                          Option<DefId>,\n+                                                          SymbolExportLevel)>>\n+{\n+    // If this crate is a plugin and/or a custom derive crate, then\n+    // we're not even going to link those in so we skip those crates.\n+    if tcx.plugin_registrar_fn(cnum).is_some() ||\n+       tcx.derive_registrar_fn(cnum).is_some() {\n+        return Arc::new(Vec::new())\n+    }\n+\n+    // Check to see if this crate is a \"special runtime crate\". These\n+    // crates, implementation details of the standard library, typically\n+    // have a bunch of `pub extern` and `#[no_mangle]` functions as the\n+    // ABI between them. We don't want their symbols to have a `C`\n+    // export level, however, as they're just implementation details.\n+    // Down below we'll hardwire all of the symbols to the `Rust` export\n+    // level instead.\n+    let special_runtime_crate =\n+        tcx.is_panic_runtime(cnum) || tcx.is_compiler_builtins(cnum);\n+\n+    let mut crate_exports: Vec<_> = tcx\n+        .reachable_non_generics(cnum)\n+        .iter()\n+        .map(|&def_id| {\n+            let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n+            let export_level = if special_runtime_crate {\n+                // We can probably do better here by just ensuring that\n+                // it has hidden visibility rather than public\n+                // visibility, as this is primarily here to ensure it's\n+                // not stripped during LTO.\n+                //\n+                // In general though we won't link right if these\n+                // symbols are stripped, and LTO currently strips them.\n+                if &*name == \"rust_eh_personality\" ||\n+                   &*name == \"rust_eh_register_frames\" ||\n+                   &*name == \"rust_eh_unregister_frames\" {\n+                    SymbolExportLevel::C\n                 } else {\n-                    export_level(tcx, def_id)\n-                };\n-                debug!(\"EXPORTED SYMBOL (re-export): {} ({:?})\", name, export_level);\n-                (str::to_owned(&name), Some(def_id), export_level)\n-            })\n-            .collect();\n-\n-        // Sort so we get a stable incr. comp. hash.\n-        crate_exports.sort_unstable_by(|&(ref name1, ..), &(ref name2, ..)| {\n-            name1.cmp(name2)\n-        });\n-\n-        Arc::new(crate_exports)\n-    };\n-\n-    providers.is_reachable_non_generic = |tcx, id| {\n-        tcx.reachable_non_generics(id.krate).contains(&id)\n-    };\n-\n-    providers.symbol_export_level = export_level;\n+                    SymbolExportLevel::Rust\n+                }\n+            } else {\n+                tcx.symbol_export_level(def_id)\n+            };\n+            debug!(\"EXPORTED SYMBOL (re-export): {} ({:?})\", name, export_level);\n+            (str::to_owned(&name), Some(def_id), export_level)\n+        })\n+        .collect();\n+\n+    // Sort so we get a stable incr. comp. hash.\n+    crate_exports.sort_unstable_by(|&(ref name1, ..), &(ref name2, ..)| {\n+        name1.cmp(name2)\n+    });\n+\n+    Arc::new(crate_exports)\n+}\n+\n+pub fn provide_extern(providers: &mut Providers) {\n+    providers.exported_symbols = exported_symbols_provider_extern;\n+    providers.is_reachable_non_generic = is_reachable_non_generic_provider;\n+    providers.symbol_export_level = symbol_export_level_provider;\n }\n \n-fn export_level(tcx: TyCtxt, sym_def_id: DefId) -> SymbolExportLevel {\n+fn symbol_export_level_provider(tcx: TyCtxt, sym_def_id: DefId) -> SymbolExportLevel {\n     // We export anything that's not mangled at the \"C\" layer as it probably has\n     // to do with ABI concerns. We do not, however, apply such treatment to\n     // special symbols in the standard library for various plumbing between"}, {"sha": "b559cc963257103e6c609200d6b2896457d6047c", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/33d5da1ee400e4b1b85a6a3f0c552ce68c665500/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33d5da1ee400e4b1b85a6a3f0c552ce68c665500/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=33d5da1ee400e4b1b85a6a3f0c552ce68c665500", "patch": "@@ -70,7 +70,7 @@ use time_graph;\n use trans_item::{MonoItem, BaseMonoItemExt, MonoItemExt, DefPathBasedNames};\n use type_::Type;\n use type_of::LayoutLlvmExt;\n-use rustc::util::nodemap::{NodeSet, FxHashMap, FxHashSet, DefIdSet};\n+use rustc::util::nodemap::{FxHashMap, FxHashSet, DefIdSet};\n use CrateInfo;\n \n use std::any::Any;\n@@ -89,7 +89,7 @@ use syntax::ast;\n \n use mir::operand::OperandValue;\n \n-pub use rustc_trans_utils::{find_exported_symbols, check_for_rustc_errors_attr};\n+pub use rustc_trans_utils::check_for_rustc_errors_attr;\n pub use rustc_mir::monomorphize::item::linkage_by_name;\n \n pub struct StatRecorder<'a, 'tcx: 'a> {\n@@ -606,8 +606,7 @@ fn contains_null(s: &str) -> bool {\n \n fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n                             llmod_id: &str,\n-                            link_meta: &LinkMeta,\n-                            exported_symbols: &NodeSet)\n+                            link_meta: &LinkMeta)\n                             -> (ContextRef, ModuleRef, EncodedMetadata) {\n     use std::io::Write;\n     use flate2::Compression;\n@@ -643,7 +642,7 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n                 EncodedMetadata::new());\n     }\n \n-    let metadata = tcx.encode_metadata(link_meta, exported_symbols);\n+    let metadata = tcx.encode_metadata(link_meta);\n     if kind == MetadataKind::Uncompressed {\n         return (metadata_llcx, metadata_llmod, metadata);\n     }\n@@ -718,13 +717,12 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let crate_hash = tcx.crate_hash(LOCAL_CRATE);\n     let link_meta = link::build_link_meta(crate_hash);\n-    let exported_symbol_node_ids = find_exported_symbols(tcx);\n \n     // Translate the metadata.\n     let llmod_id = \"metadata\";\n     let (metadata_llcx, metadata_llmod, metadata) =\n         time(tcx.sess.time_passes(), \"write metadata\", || {\n-            write_metadata(tcx, llmod_id, &link_meta, &exported_symbol_node_ids)\n+            write_metadata(tcx, llmod_id, &link_meta)\n         });\n \n     let metadata_module = ModuleTranslation {"}, {"sha": "d636a5f2e64b732cf43c8ff8666974e116308866", "filename": "src/librustc_trans_utils/lib.rs", "status": "modified", "additions": 1, "deletions": 54, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/33d5da1ee400e4b1b85a6a3f0c552ce68c665500/src%2Flibrustc_trans_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33d5da1ee400e4b1b85a6a3f0c552ce68c665500/src%2Flibrustc_trans_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Flib.rs?ref=33d5da1ee400e4b1b85a6a3f0c552ce68c665500", "patch": "@@ -44,11 +44,7 @@ extern crate rustc_data_structures;\n \n pub extern crate rustc as __rustc;\n \n-use rustc::ty::{TyCtxt, Instance};\n-use rustc::hir;\n-use rustc::hir::def_id::LOCAL_CRATE;\n-use rustc::hir::map as hir_map;\n-use rustc::util::nodemap::NodeSet;\n+use rustc::ty::TyCtxt;\n \n pub mod diagnostics;\n pub mod link;\n@@ -70,53 +66,4 @@ pub fn check_for_rustc_errors_attr(tcx: TyCtxt) {\n     }\n }\n \n-/// The context provided lists a set of reachable ids as calculated by\n-/// middle::reachable, but this contains far more ids and symbols than we're\n-/// actually exposing from the object file. This function will filter the set in\n-/// the context to the set of ids which correspond to symbols that are exposed\n-/// from the object file being generated.\n-///\n-/// This list is later used by linkers to determine the set of symbols needed to\n-/// be exposed from a dynamic library and it's also encoded into the metadata.\n-pub fn find_exported_symbols<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> NodeSet {\n-    tcx.reachable_set(LOCAL_CRATE).0.iter().cloned().filter(|&id| {\n-        // Next, we want to ignore some FFI functions that are not exposed from\n-        // this crate. Reachable FFI functions can be lumped into two\n-        // categories:\n-        //\n-        // 1. Those that are included statically via a static library\n-        // 2. Those included otherwise (e.g. dynamically or via a framework)\n-        //\n-        // Although our LLVM module is not literally emitting code for the\n-        // statically included symbols, it's an export of our library which\n-        // needs to be passed on to the linker and encoded in the metadata.\n-        //\n-        // As a result, if this id is an FFI item (foreign item) then we only\n-        // let it through if it's included statically.\n-        match tcx.hir.get(id) {\n-            hir_map::NodeForeignItem(..) => {\n-                let def_id = tcx.hir.local_def_id(id);\n-                tcx.is_statically_included_foreign_item(def_id)\n-            }\n-\n-            // Only consider nodes that actually have exported symbols.\n-            hir_map::NodeItem(&hir::Item {\n-                node: hir::ItemStatic(..), .. }) |\n-            hir_map::NodeItem(&hir::Item {\n-                node: hir::ItemFn(..), .. }) |\n-            hir_map::NodeImplItem(&hir::ImplItem {\n-                node: hir::ImplItemKind::Method(..), .. }) => {\n-                let def_id = tcx.hir.local_def_id(id);\n-                let generics = tcx.generics_of(def_id);\n-                (generics.parent_types == 0 && generics.types.is_empty()) &&\n-                // Functions marked with #[inline] are only ever translated\n-                // with \"internal\" linkage and are never exported.\n-                !Instance::mono(tcx, def_id).def.requires_local(tcx)\n-            }\n-\n-            _ => false\n-        }\n-    }).collect()\n-}\n-\n __build_diagnostic_array! { librustc_trans_utils, DIAGNOSTICS }"}, {"sha": "7b2cbe140aebfbe288a6207630b6c126388fc71f", "filename": "src/librustc_trans_utils/trans_crate.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/33d5da1ee400e4b1b85a6a3f0c552ce68c665500/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33d5da1ee400e4b1b85a6a3f0c552ce68c665500/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Ftrans_crate.rs?ref=33d5da1ee400e4b1b85a6a3f0c552ce68c665500", "patch": "@@ -247,8 +247,7 @@ impl TransCrate for MetadataOnlyTransCrate {\n         tcx.sess.abort_if_errors();\n \n         let link_meta = build_link_meta(tcx.crate_hash(LOCAL_CRATE));\n-        let exported_symbols = ::find_exported_symbols(tcx);\n-        let metadata = tcx.encode_metadata(&link_meta, &exported_symbols);\n+        let metadata = tcx.encode_metadata(&link_meta);\n \n         box OngoingCrateTranslation {\n             metadata: metadata,"}]}