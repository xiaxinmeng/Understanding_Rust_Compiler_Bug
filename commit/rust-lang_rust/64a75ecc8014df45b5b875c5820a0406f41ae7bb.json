{"sha": "64a75ecc8014df45b5b875c5820a0406f41ae7bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0YTc1ZWNjODAxNGRmNDViNWI4NzVjNTgyMGEwNDA2ZjQxYWU3YmI=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-05-22T08:28:46Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-05-24T18:49:37Z"}, "message": "change `Value::Bytes` to `Value::Bits`", "tree": {"sha": "3e0a0813fffb2461ae27a48ca0c773d641ccf0bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e0a0813fffb2461ae27a48ca0c773d641ccf0bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64a75ecc8014df45b5b875c5820a0406f41ae7bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64a75ecc8014df45b5b875c5820a0406f41ae7bb", "html_url": "https://github.com/rust-lang/rust/commit/64a75ecc8014df45b5b875c5820a0406f41ae7bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64a75ecc8014df45b5b875c5820a0406f41ae7bb/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bbf2fd7159e5be5aee8d5c4e11f855862283d26", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bbf2fd7159e5be5aee8d5c4e11f855862283d26", "html_url": "https://github.com/rust-lang/rust/commit/3bbf2fd7159e5be5aee8d5c4e11f855862283d26"}], "stats": {"total": 717, "additions": 436, "deletions": 281}, "files": [{"sha": "43c9fc0b8fd3676ea22fc0dc975681c0d0d3b0c4", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=64a75ecc8014df45b5b875c5820a0406f41ae7bb", "patch": "@@ -473,11 +473,24 @@ impl_stable_hash_for!(enum ::syntax::ast::Mutability {\n     Mutable\n });\n \n-impl_stable_hash_for!(enum mir::interpret::Scalar {\n-    Bytes(b),\n-    Ptr(p),\n-    Undef\n-});\n+\n+impl<'a> HashStable<StableHashingContext<'a>>\n+for ::mir::interpret::Scalar {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use mir::interpret::Scalar::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            Bits { bits, defined } => {\n+                bits.hash_stable(hcx, hasher);\n+                defined.hash_stable(hcx, hasher);\n+            },\n+            Ptr(ptr) => ptr.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n \n impl_stable_hash_for!(struct ty::Const<'tcx> {\n     ty,"}, {"sha": "9a9c351f39e16f269e467f069b2e17ff0bc047a4", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 72, "deletions": 88, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=64a75ecc8014df45b5b875c5820a0406f41ae7bb", "patch": "@@ -51,19 +51,13 @@ impl<'tcx> ConstValue<'tcx> {\n     }\n \n     #[inline]\n-    pub fn to_bits(&self) -> Option<u128> {\n-        match self.to_primval() {\n-            Some(Scalar::Bytes(val)) => Some(val),\n-            _ => None,\n-        }\n+    pub fn to_bits(&self, size: Size) -> Option<u128> {\n+        self.to_primval()?.to_bits(size).ok()\n     }\n \n     #[inline]\n     pub fn to_ptr(&self) -> Option<Pointer> {\n-        match self.to_primval() {\n-            Some(Scalar::Ptr(ptr)) => Some(ptr),\n-            _ => None,\n-        }\n+        self.to_primval()?.to_ptr().ok()\n     }\n }\n \n@@ -93,56 +87,85 @@ impl<'tcx> ty::TypeFoldable<'tcx> for Value {\n }\n \n impl<'tcx> Scalar {\n-    pub fn ptr_null() -> Self {\n-        Scalar::Bytes(0)\n+    pub fn ptr_null<C: HasDataLayout>(cx: C) -> Self {\n+        Scalar::Bits {\n+            bits: 0,\n+            defined: cx.data_layout().pointer_size.bits() as u8,\n+    }\n     }\n \n     pub fn ptr_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n         match self {\n-            Scalar::Bytes(b) => {\n-                assert_eq!(b as u64 as u128, b);\n-                Ok(Scalar::Bytes(layout.signed_offset(b as u64, i)? as u128))\n+            Scalar::Bits { bits, defined } => {\n+                let pointer_size = layout.pointer_size.bits() as u8;\n+                if defined < pointer_size {\n+                    err!(ReadUndefBytes)\n+                } else {\n+                    Ok(Scalar::Bits {\n+                        bits: layout.signed_offset(bits as u64, i)? as u128,\n+                        defined: pointer_size,\n+                    })\n+            }\n             }\n             Scalar::Ptr(ptr) => ptr.signed_offset(i, layout).map(Scalar::Ptr),\n-            Scalar::Undef => err!(ReadUndefBytes),\n         }\n     }\n \n     pub fn ptr_offset<C: HasDataLayout>(self, i: Size, cx: C) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n         match self {\n-            Scalar::Bytes(b) => {\n-                assert_eq!(b as u64 as u128, b);\n-                Ok(Scalar::Bytes(layout.offset(b as u64, i.bytes())? as u128))\n+            Scalar::Bits { bits, defined } => {\n+                let pointer_size = layout.pointer_size.bits() as u8;\n+                if defined < pointer_size {\n+                    err!(ReadUndefBytes)\n+                } else {\n+                    Ok(Scalar::Bits {\n+                        bits: layout.offset(bits as u64, i.bytes())? as u128,\n+                        defined: pointer_size,\n+                    })\n+            }\n             }\n             Scalar::Ptr(ptr) => ptr.offset(i, layout).map(Scalar::Ptr),\n-            Scalar::Undef => err!(ReadUndefBytes),\n         }\n     }\n \n     pub fn ptr_wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n         match self {\n-            Scalar::Bytes(b) => {\n-                assert_eq!(b as u64 as u128, b);\n-                Ok(Scalar::Bytes(layout.wrapping_signed_offset(b as u64, i) as u128))\n+            Scalar::Bits { bits, defined } => {\n+                let pointer_size = layout.pointer_size.bits() as u8;\n+                if defined < pointer_size {\n+                    err!(ReadUndefBytes)\n+                } else {\n+                    Ok(Scalar::Bits {\n+                        bits: layout.wrapping_signed_offset(bits as u64, i) as u128,\n+                        defined: pointer_size,\n+                    })\n+            }\n             }\n             Scalar::Ptr(ptr) => Ok(Scalar::Ptr(ptr.wrapping_signed_offset(i, layout))),\n-            Scalar::Undef => err!(ReadUndefBytes),\n         }\n     }\n \n-    pub fn is_null(self) -> EvalResult<'tcx, bool> {\n+    pub fn is_null_ptr<C: HasDataLayout>(self, cx: C) -> EvalResult<'tcx, bool> {\n         match self {\n-            Scalar::Bytes(b) => Ok(b == 0),\n+            Scalar::Bits {\n+                bits, defined,\n+            } => if defined < cx.data_layout().pointer_size.bits() as u8 {\n+                err!(ReadUndefBytes)\n+            } else {\n+                Ok(bits == 0)\n+            },\n             Scalar::Ptr(_) => Ok(false),\n-            Scalar::Undef => err!(ReadUndefBytes),\n         }\n     }\n \n-    pub fn to_value_with_len(self, len: u64) -> Value {\n-        Value::ScalarPair(self, Scalar::from_u128(len as u128))\n+    pub fn to_value_with_len<C: HasDataLayout>(self, len: u64, cx: C) -> Value {\n+        Value::ScalarPair(self, Scalar::Bits {\n+            bits: len as u128,\n+            defined: cx.data_layout().pointer_size.bits() as u8,\n+        })\n     }\n \n     pub fn to_value_with_vtable(self, vtable: Pointer) -> Value {\n@@ -163,20 +186,20 @@ impl From<Pointer> for Scalar {\n /// A `Scalar` represents an immediate, primitive value existing outside of a\n /// `memory::Allocation`. It is in many ways like a small chunk of a `Allocation`, up to 8 bytes in\n /// size. Like a range of bytes in an `Allocation`, a `Scalar` can either represent the raw bytes\n-/// of a simple value, a pointer into another `Allocation`, or be undefined.\n+/// of a simple value or a pointer into another `Allocation`\n #[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n pub enum Scalar {\n     /// The raw bytes of a simple value.\n-    Bytes(u128),\n+    Bits {\n+        /// number of bits that are valid and may be read\n+        defined: u8,\n+        bits: u128,\n+    },\n \n     /// A pointer into an `Allocation`. An `Allocation` in the `memory` module has a list of\n     /// relocations, but a `Scalar` is only large enough to contain one, so we just represent the\n     /// relocation and its associated offset together as a `Pointer` here.\n     Ptr(Pointer),\n-\n-    /// An undefined `Scalar`, for representing values that aren't safe to examine, but are safe\n-    /// to copy around, just like undefined bytes in an `Allocation`.\n-    Undef,\n }\n \n #[derive(Clone, Copy, Debug, PartialEq)]\n@@ -190,41 +213,38 @@ pub enum ScalarKind {\n }\n \n impl<'tcx> Scalar {\n-    pub fn from_u128(n: u128) -> Self {\n-        Scalar::Bytes(n)\n-    }\n-\n-    pub fn from_i128(n: i128) -> Self {\n-        Scalar::Bytes(n as u128)\n+    pub fn undef() -> Self {\n+        Scalar::Bits { bits: 0, defined: 0 }\n     }\n \n     pub fn from_bool(b: bool) -> Self {\n-        Scalar::Bytes(b as u128)\n+        // FIXME: can we make defined `1`?\n+        Scalar::Bits { bits: b as u128, defined: 8 }\n     }\n \n     pub fn from_char(c: char) -> Self {\n-        Scalar::Bytes(c as u128)\n+        Scalar::Bits { bits: c as u128, defined: 32 }\n     }\n \n-    pub fn to_bytes(self) -> EvalResult<'tcx, u128> {\n+    pub fn to_bits(self, size: Size) -> EvalResult<'tcx, u128> {\n         match self {\n-            Scalar::Bytes(b) => Ok(b),\n+            Scalar::Bits { defined: 0, .. } => err!(ReadUndefBytes),\n+            Scalar::Bits { bits, defined } if size.bits() <= defined as u64 => Ok(bits),\n+            Scalar::Bits { .. } => err!(ReadUndefBytes),\n             Scalar::Ptr(_) => err!(ReadPointerAsBytes),\n-            Scalar::Undef => err!(ReadUndefBytes),\n         }\n     }\n \n     pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n         match self {\n-            Scalar::Bytes(_) => err!(ReadBytesAsPointer),\n+            Scalar::Bits {..} => err!(ReadBytesAsPointer),\n             Scalar::Ptr(p) => Ok(p),\n-            Scalar::Undef => err!(ReadUndefBytes),\n         }\n     }\n \n-    pub fn is_bytes(self) -> bool {\n+    pub fn is_bits(self) -> bool {\n         match self {\n-            Scalar::Bytes(_) => true,\n+            Scalar::Bits { .. } => true,\n             _ => false,\n         }\n     }\n@@ -236,46 +256,10 @@ impl<'tcx> Scalar {\n         }\n     }\n \n-    pub fn is_undef(self) -> bool {\n-        match self {\n-            Scalar::Undef => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn to_u128(self) -> EvalResult<'tcx, u128> {\n-        self.to_bytes()\n-    }\n-\n-    pub fn to_u64(self) -> EvalResult<'tcx, u64> {\n-        self.to_bytes().map(|b| {\n-            assert_eq!(b as u64 as u128, b);\n-            b as u64\n-        })\n-    }\n-\n-    pub fn to_i32(self) -> EvalResult<'tcx, i32> {\n-        self.to_bytes().map(|b| {\n-            assert_eq!(b as i32 as u128, b);\n-            b as i32\n-        })\n-    }\n-\n-    pub fn to_i128(self) -> EvalResult<'tcx, i128> {\n-        self.to_bytes().map(|b| b as i128)\n-    }\n-\n-    pub fn to_i64(self) -> EvalResult<'tcx, i64> {\n-        self.to_bytes().map(|b| {\n-            assert_eq!(b as i64 as u128, b);\n-            b as i64\n-        })\n-    }\n-\n     pub fn to_bool(self) -> EvalResult<'tcx, bool> {\n-        match self.to_bytes()? {\n-            0 => Ok(false),\n-            1 => Ok(true),\n+        match self {\n+            Scalar::Bits { bits: 0, defined: 8 } => Ok(false),\n+            Scalar::Bits { bits: 1, defined: 8 } => Ok(true),\n             _ => err!(InvalidBool),\n         }\n     }"}, {"sha": "a177b9055c5cf1d333f3e7239fa702a1618877fc", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=64a75ecc8014df45b5b875c5820a0406f41ae7bb", "patch": "@@ -1149,11 +1149,13 @@ impl<'tcx> TerminatorKind<'tcx> {\n             Return | Resume | Abort | Unreachable | GeneratorDrop => vec![],\n             Goto { .. } => vec![\"\".into()],\n             SwitchInt { ref values, switch_ty, .. } => {\n+                let size = ty::tls::with(|tcx| switch_ty.scalar_size(tcx));\n+                let size = size.map_or(0, |size| size.bytes()) as u8;\n                 values.iter()\n                       .map(|&u| {\n                           let mut s = String::new();\n                           print_miri_value(\n-                              Value::Scalar(Scalar::Bytes(u)),\n+                              Value::Scalar(Scalar::Bits { bits: u, defined: size }),\n                               switch_ty,\n                               &mut s,\n                           ).unwrap();\n@@ -1893,19 +1895,22 @@ pub fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ty::Const) -> fmt::Resul\n pub fn print_miri_value<W: Write>(value: Value, ty: Ty, f: &mut W) -> fmt::Result {\n     use ty::TypeVariants::*;\n     match (value, &ty.sty) {\n-        (Value::Scalar(Scalar::Bytes(0)), &TyBool) => write!(f, \"false\"),\n-        (Value::Scalar(Scalar::Bytes(1)), &TyBool) => write!(f, \"true\"),\n-        (Value::Scalar(Scalar::Bytes(bits)), &TyFloat(ast::FloatTy::F32)) =>\n+        (Value::Scalar(Scalar::Bits { bits: 0, defined: 8 }), &TyBool) => write!(f, \"false\"),\n+        (Value::Scalar(Scalar::Bits { bits: 1, defined: 8 }), &TyBool) => write!(f, \"true\"),\n+        (Value::Scalar(Scalar::Bits { bits, defined: 32 }), &TyFloat(ast::FloatTy::F32)) =>\n             write!(f, \"{}f32\", Single::from_bits(bits)),\n-        (Value::Scalar(Scalar::Bytes(bits)), &TyFloat(ast::FloatTy::F64)) =>\n+        (Value::Scalar(Scalar::Bits { bits, defined: 64 }), &TyFloat(ast::FloatTy::F64)) =>\n             write!(f, \"{}f64\", Double::from_bits(bits)),\n-        (Value::Scalar(Scalar::Bytes(n)), &TyUint(ui)) => write!(f, \"{:?}{}\", n, ui),\n-        (Value::Scalar(Scalar::Bytes(n)), &TyInt(i)) => write!(f, \"{:?}{}\", n as i128, i),\n-        (Value::Scalar(Scalar::Bytes(n)), &TyChar) =>\n-            write!(f, \"{:?}\", ::std::char::from_u32(n as u32).unwrap()),\n-        (Value::Scalar(Scalar::Undef), &TyFnDef(did, _)) =>\n+        (Value::Scalar(Scalar::Bits { bits, .. }), &TyUint(ui)) => write!(f, \"{:?}{}\", bits, ui),\n+        (Value::Scalar(Scalar::Bits { bits, defined }), &TyInt(i)) => {\n+            let amt = 128 - defined;\n+            write!(f, \"{:?}{}\", ((bits as i128) << amt) >> amt, i)\n+        },\n+        (Value::Scalar(Scalar::Bits { bits, defined: 32 }), &TyChar) =>\n+            write!(f, \"{:?}\", ::std::char::from_u32(bits as u32).unwrap()),\n+        (Value::Scalar(Scalar::Bits { defined: 0, .. }), &TyFnDef(did, _)) =>\n             write!(f, \"{}\", item_path_str(did)),\n-        (Value::ScalarPair(Scalar::Ptr(ptr), Scalar::Bytes(len)),\n+        (Value::ScalarPair(Scalar::Ptr(ptr), Scalar::Bits { bits: len, .. }),\n          &TyRef(_, &ty::TyS { sty: TyStr, .. }, _)) => {\n             ty::tls::with(|tcx| {\n                 match tcx.alloc_map.lock().get(ptr.alloc_id) {"}, {"sha": "3802735b85b1ed4a4c24cc55efa7304bab1ec81d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=64a75ecc8014df45b5b875c5820a0406f41ae7bb", "patch": "@@ -1982,7 +1982,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         match tcx.const_eval(param_env.and(cid)) {\n             Ok(val) => {\n                 // FIXME: Find the right type and use it instead of `val.ty` here\n-                if let Some(b) = val.assert_bits(val.ty) {\n+                if let Some(b) = val.assert_bits(tcx, val.ty) {\n                     trace!(\"discriminants: {} ({:?})\", b, repr_type);\n                     Some(Discr {\n                         val: b,"}, {"sha": "411c86d7cca57535fcc7a7facedc66325372d745", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=64a75ecc8014df45b5b875c5820a0406f41ae7bb", "patch": "@@ -17,15 +17,17 @@ use middle::region;\n use rustc_data_structures::indexed_vec::Idx;\n use ty::subst::{Substs, Subst, Kind, UnpackedKind};\n use ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n-use ty::{Slice, TyS};\n+use ty::{Slice, TyS, layout};\n use util::captures::Captures;\n use mir::interpret::{Scalar, Pointer, Value, ConstValue};\n+use rustc_target::abi::{Size, HasDataLayout};\n \n use std::iter;\n use std::cmp::Ordering;\n use rustc_target::spec::abi;\n use syntax::ast::{self, Name};\n use syntax::symbol::{keywords, InternedString};\n+use syntax::attr;\n \n use serialize;\n \n@@ -1755,6 +1757,23 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             _ => bug!(\"cannot convert type `{:?}` to a closure kind\", self),\n         }\n     }\n+\n+    /// If this type is a scalar, compute its size without\n+    /// going through `tcx.layout_of`\n+    pub fn scalar_size<C: HasDataLayout>(\n+        &self,\n+        cx: C,\n+    ) -> Option<Size> {\n+        let ty = match self.sty {\n+            ty::TyBool => return Some(Size::from_bytes(1)),\n+            ty::TyChar => return Some(Size::from_bytes(4)),\n+            ty::TyInt(ity) => attr::IntType::SignedInt(ity),\n+            ty::TyUint(uty) => attr::IntType::UnsignedInt(uty),\n+            _ => return None,\n+        };\n+        use ty::layout::IntegerExt;\n+        Some(layout::Integer::from_attr(cx, ty).size())\n+    }\n }\n \n /// Typed constant value.\n@@ -1820,15 +1839,18 @@ impl<'tcx> Const<'tcx> {\n     #[inline]\n     pub fn from_bits(\n         tcx: TyCtxt<'_, '_, 'tcx>,\n-        val: u128,\n+        bits: u128,\n         ty: Ty<'tcx>,\n     ) -> &'tcx Self {\n-        Self::from_primval(tcx, Scalar::Bytes(val), ty)\n+        let defined = ty.scalar_size(tcx).unwrap_or_else(|| {\n+            panic!(\"non-scalar type in from_bits: {:?}\", ty)\n+        }).bits() as u8;\n+        Self::from_primval(tcx, Scalar::Bits { bits, defined }, ty)\n     }\n \n     #[inline]\n     pub fn zero_sized(tcx: TyCtxt<'_, '_, 'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n-        Self::from_primval(tcx, Scalar::Undef, ty)\n+        Self::from_primval(tcx, Scalar::undef(), ty)\n     }\n \n     #[inline]\n@@ -1842,12 +1864,13 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n-    pub fn to_bits(&self, ty: Ty<'_>) -> Option<u128> {\n+    pub fn to_bits<C: HasDataLayout>(&self, cx: C, ty: Ty<'tcx>) -> Option<u128> {\n         if self.ty != ty {\n             return None;\n         }\n+        let size = ty.scalar_size(cx)?;\n         match self.val {\n-            ConstVal::Value(val) => val.to_bits(),\n+            ConstVal::Value(val) => val.to_bits(size),\n             _ => None,\n         }\n     }\n@@ -1877,17 +1900,18 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n-    pub fn assert_bits(&self, ty: Ty<'_>) -> Option<u128> {\n+    pub fn assert_bits<C: HasDataLayout>(&self, cx: C, ty: Ty<'tcx>) -> Option<u128> {\n         assert_eq!(self.ty, ty);\n+        let size = ty.scalar_size(cx)?;\n         match self.val {\n-            ConstVal::Value(val) => val.to_bits(),\n+            ConstVal::Value(val) => val.to_bits(size),\n             _ => None,\n         }\n     }\n \n     #[inline]\n     pub fn assert_bool(&self, tcx: TyCtxt<'_, '_, '_>) -> Option<bool> {\n-        self.assert_bits(tcx.types.bool).and_then(|v| match v {\n+        self.assert_bits(tcx, tcx.types.bool).and_then(|v| match v {\n             0 => Some(false),\n             1 => Some(true),\n             _ => None,\n@@ -1896,12 +1920,12 @@ impl<'tcx> Const<'tcx> {\n \n     #[inline]\n     pub fn assert_usize(&self, tcx: TyCtxt<'_, '_, '_>) -> Option<u64> {\n-        self.assert_bits(tcx.types.usize).map(|v| v as u64)\n+        self.assert_bits(tcx, tcx.types.usize).map(|v| v as u64)\n     }\n \n     #[inline]\n-    pub fn unwrap_bits(&self, ty: Ty<'_>) -> u128 {\n-        match self.assert_bits(ty) {\n+    pub fn unwrap_bits(&self, tcx: TyCtxt<'_, '_, '_>, ty: Ty<'tcx>) -> u128 {\n+        match self.assert_bits(tcx, ty) {\n             Some(val) => val,\n             None => bug!(\"expected bits of {}, got {:#?}\", ty, self),\n         }"}, {"sha": "fc3733f13985a4d0ecbe2b0057828af28170281f", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=64a75ecc8014df45b5b875c5820a0406f41ae7bb", "patch": "@@ -32,11 +32,13 @@ pub fn primval_to_llvm(cx: &CodegenCx,\n                        cv: Scalar,\n                        layout: &layout::Scalar,\n                        llty: Type) -> ValueRef {\n-    let bits = if layout.is_bool() { 1 } else { layout.value.size(cx).bits() };\n+    let bitsize = if layout.is_bool() { 1 } else { layout.value.size(cx).bits() };\n     match cv {\n-        Scalar::Undef => C_undef(Type::ix(cx, bits)),\n-        Scalar::Bytes(b) => {\n-            let llval = C_uint_big(Type::ix(cx, bits), b);\n+        Scalar::Bits { defined, .. } if (defined as u64) < bitsize || defined == 0 => {\n+            C_undef(Type::ix(cx, bitsize))\n+        },\n+        Scalar::Bits { bits, .. } => {\n+            let llval = C_uint_big(Type::ix(cx, bitsize), bits);\n             if layout.value == layout::Pointer {\n                 unsafe { llvm::LLVMConstIntToPtr(llval, llty.to_ref()) }\n             } else {"}, {"sha": "c054d038353f04d168bd3ace2e6c2d1a3da24c6f", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=64a75ecc8014df45b5b875c5820a0406f41ae7bb", "patch": "@@ -374,7 +374,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     // Helper to get a `-1` value of the appropriate type\n     fn neg_1_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n-        let bits = self.hir.integer_bit_width(ty);\n+        let bits = ty.scalar_size(self.hir.tcx()).expect(\"neg_1_literal expects integers\").bits();\n         let n = (!0u128) >> (128 - bits);\n         let literal = Literal::Value {\n             value: ty::Const::from_bits(self.hir.tcx(), n, ty)\n@@ -386,7 +386,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     // Helper to get the minimum value of the appropriate type\n     fn minval_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n         assert!(ty.is_signed());\n-        let bits = self.hir.integer_bit_width(ty);\n+        let bits = ty.scalar_size(self.hir.tcx()).expect(\"minval_literal expects integers\").bits();\n         let n = 1 << (bits - 1);\n         let literal = Literal::Value {\n             value: ty::Const::from_bits(self.hir.tcx(), n, ty)"}, {"sha": "471b6defdc9e62fe3364e611176fb6e29cb3d7b7", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=64a75ecc8014df45b5b875c5820a0406f41ae7bb", "patch": "@@ -124,7 +124,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             PatternKind::Constant { value } => {\n                 indices.entry(value)\n                        .or_insert_with(|| {\n-                           options.push(value.unwrap_bits(switch_ty));\n+                           options.push(value.unwrap_bits(self.hir.tcx(), switch_ty));\n                            options.len() - 1\n                        });\n                 true"}, {"sha": "26cf669fd8e32f329ef404ae9311b9bf8cfa69c2", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=64a75ecc8014df45b5b875c5820a0406f41ae7bb", "patch": "@@ -52,15 +52,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     // Returns a zero literal operand for the appropriate type, works for\n     // bool, char and integers.\n     pub fn zero_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n-        match ty.sty {\n-            ty::TyBool |\n-            ty::TyChar |\n-            ty::TyUint(_) |\n-            ty::TyInt(_) => {}\n-            _ => {\n-                span_bug!(span, \"Invalid type for zero_literal: `{:?}`\", ty)\n-            }\n-        }\n         let literal = Literal::Value {\n             value: ty::Const::from_bits(self.hir.tcx(), 0, ty)\n         };"}, {"sha": "71cf983d7a11b7a8d92a3504eb394f74d17ce617", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=64a75ecc8014df45b5b875c5820a0406f41ae7bb", "patch": "@@ -614,7 +614,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                 let idx = adt_def.variant_index_with_id(variant_id);\n                                 let (d, o) = adt_def.discriminant_def_for_variant(idx);\n                                 use rustc::ty::util::IntTypeExt;\n-                                let ty = adt_def.repr.discr_type().to_ty(cx.tcx());\n+                                let ty = adt_def.repr.discr_type();\n+                                let ty = ty.to_ty(cx.tcx());\n                                 Some((d, o, ty))\n                             }\n                             _ => None,"}, {"sha": "4d78925e806d3735e0d12016c7faef58a2801b51", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=64a75ecc8014df45b5b875c5820a0406f41ae7bb", "patch": "@@ -21,9 +21,8 @@ use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::middle::region;\n use rustc::infer::InferCtxt;\n-use rustc::ty::layout::IntegerExt;\n use rustc::ty::subst::Subst;\n-use rustc::ty::{self, Ty, TyCtxt, layout};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::{Kind, Substs};\n use syntax::ast::{self, LitKind};\n use syntax::attr;\n@@ -139,18 +138,6 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn integer_bit_width(\n-        &self,\n-        ty: Ty,\n-    ) -> u64 {\n-        let ty = match ty.sty {\n-            ty::TyInt(ity) => attr::IntType::SignedInt(ity),\n-            ty::TyUint(uty) => attr::IntType::UnsignedInt(uty),\n-            _ => bug!(\"{} is not an integer\", ty),\n-        };\n-        layout::Integer::from_attr(self.tcx, ty).size().bits()\n-    }\n-\n     // FIXME: Combine with rustc_mir::hair::pattern::lit_to_const\n     pub fn const_eval_literal(\n         &mut self,\n@@ -169,12 +156,15 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         };\n \n         let clamp = |n| {\n-            let size = self.integer_bit_width(ty);\n+            let size = ty.scalar_size(self.tcx).expect(\"const_eval_lit::clamp expects ints\").bits();\n             trace!(\"clamp {} with size {} and amt {}\", n, size, 128 - size);\n             let amt = 128 - size;\n             let result = (n << amt) >> amt;\n             trace!(\"clamp result: {}\", result);\n-            result\n+            ConstValue::Scalar(Scalar::Bits {\n+                bits: result,\n+                defined: size as u8,\n+            })\n         };\n \n         use rustc::mir::interpret::*;\n@@ -184,21 +174,26 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                 let id = self.tcx.allocate_bytes(s.as_bytes());\n                 ConstValue::ScalarPair(\n                     Scalar::Ptr(id.into()),\n-                    Scalar::from_u128(s.len() as u128),\n+                    Scalar::Bits {\n+                        bits: s.len() as u128,\n+                        defined: self.tcx.data_layout.pointer_size.bits() as u8,\n+                    }\n                 )\n             },\n             LitKind::ByteStr(ref data) => {\n                 let id = self.tcx.allocate_bytes(data);\n                 ConstValue::Scalar(Scalar::Ptr(id.into()))\n             },\n-            LitKind::Byte(n) => ConstValue::Scalar(Scalar::Bytes(n as u128)),\n+            LitKind::Byte(n) => ConstValue::Scalar(Scalar::Bits {\n+                bits: n as u128,\n+                defined: 8,\n+            }),\n             LitKind::Int(n, _) if neg => {\n                 let n = n as i128;\n                 let n = n.overflowing_neg().0;\n-                let n = clamp(n as u128);\n-                ConstValue::Scalar(Scalar::Bytes(n))\n+                clamp(n as u128)\n             },\n-            LitKind::Int(n, _) => ConstValue::Scalar(Scalar::Bytes(clamp(n))),\n+            LitKind::Int(n, _) => clamp(n),\n             LitKind::Float(n, fty) => {\n                 parse_float(n, fty)\n             }\n@@ -209,8 +204,14 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                 };\n                 parse_float(n, fty)\n             }\n-            LitKind::Bool(b) => ConstValue::Scalar(Scalar::Bytes(b as u128)),\n-            LitKind::Char(c) => ConstValue::Scalar(Scalar::Bytes(c as u128)),\n+            LitKind::Bool(b) => ConstValue::Scalar(Scalar::Bits {\n+                bits: b as u128,\n+                defined: 8,\n+            }),\n+            LitKind::Char(c) => ConstValue::Scalar(Scalar::Bits {\n+                bits: c as u128,\n+                defined: 32,\n+            }),\n         };\n         Literal::Value {\n             value: ty::Const::from_const_value(self.tcx, lit, ty)"}, {"sha": "d916e8661252b93b8b6a83b1e4c0111698df7623", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=64a75ecc8014df45b5b875c5820a0406f41ae7bb", "patch": "@@ -958,7 +958,7 @@ fn slice_pat_covered_by_constructor<'tcx>(\n     {\n         match pat.kind {\n             box PatternKind::Constant { value } => {\n-                let b = value.unwrap_bits(pat.ty);\n+                let b = value.unwrap_bits(tcx, pat.ty);\n                 assert_eq!(b as u8 as u128, b);\n                 if b as u8 != *ch {\n                     return Ok(false);"}, {"sha": "d813133b272b499c629f3c96c4c3b71d49cc0ccc", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=64a75ecc8014df45b5b875c5820a0406f41ae7bb", "patch": "@@ -1057,7 +1057,7 @@ pub fn compare_const_vals<'a, 'tcx>(\n \n     // FIXME: This should use assert_bits(ty) instead of use_bits\n     // but triggers possibly bugs due to mismatching of arrays and slices\n-    if let (Some(a), Some(b)) = (a.to_bits(ty), b.to_bits(ty)) {\n+    if let (Some(a), Some(b)) = (a.to_bits(tcx, ty), b.to_bits(tcx, ty)) {\n         use ::rustc_apfloat::Float;\n         return match ty.sty {\n             ty::TyFloat(ast::FloatTy::F32) => {\n@@ -1130,20 +1130,26 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n             let id = tcx.allocate_bytes(s.as_bytes());\n             ConstValue::ScalarPair(\n                 Scalar::Ptr(id.into()),\n-                Scalar::from_u128(s.len() as u128),\n+                Scalar::Bits {\n+                    bits: s.len() as u128,\n+                    defined: tcx.data_layout.pointer_size.bits() as u8,\n+                },\n             )\n         },\n         LitKind::ByteStr(ref data) => {\n             let id = tcx.allocate_bytes(data);\n             ConstValue::Scalar(Scalar::Ptr(id.into()))\n         },\n-        LitKind::Byte(n) => ConstValue::Scalar(Scalar::Bytes(n as u128)),\n+        LitKind::Byte(n) => ConstValue::Scalar(Scalar::Bits {\n+            bits: n as u128,\n+            defined: 8,\n+        }),\n         LitKind::Int(n, _) => {\n             enum Int {\n                 Signed(IntTy),\n                 Unsigned(UintTy),\n             }\n-            let ty = match ty.sty {\n+            let ity = match ty.sty {\n                 ty::TyInt(IntTy::Isize) => Int::Signed(tcx.sess.target.isize_ty),\n                 ty::TyInt(other) => Int::Signed(other),\n                 ty::TyUint(UintTy::Usize) => Int::Unsigned(tcx.sess.target.usize_ty),\n@@ -1152,7 +1158,7 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n             };\n             // This converts from LitKind::Int (which is sign extended) to\n             // Scalar::Bytes (which is zero extended)\n-            let n = match ty {\n+            let n = match ity {\n                 // FIXME(oli-obk): are these casts correct?\n                 Int::Signed(IntTy::I8) if neg =>\n                     (n as i8).overflowing_neg().0 as u8 as u128,\n@@ -1171,7 +1177,10 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n                 Int::Signed(IntTy::I128)| Int::Unsigned(UintTy::U128) => n,\n                 _ => bug!(),\n             };\n-            ConstValue::Scalar(Scalar::Bytes(n))\n+            ConstValue::Scalar(Scalar::Bits {\n+                bits: n,\n+                defined: ty.scalar_size(tcx).unwrap().bits() as u8,\n+            })\n         },\n         LitKind::Float(n, fty) => {\n             parse_float(n, fty, neg)?\n@@ -1183,8 +1192,14 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n             };\n             parse_float(n, fty, neg)?\n         }\n-        LitKind::Bool(b) => ConstValue::Scalar(Scalar::Bytes(b as u128)),\n-        LitKind::Char(c) => ConstValue::Scalar(Scalar::Bytes(c as u128)),\n+        LitKind::Bool(b) => ConstValue::Scalar(Scalar::Bits {\n+            bits: b as u128,\n+            defined: 8,\n+        }),\n+        LitKind::Char(c) => ConstValue::Scalar(Scalar::Bits {\n+            bits: c as u128,\n+            defined: 32,\n+        }),\n     };\n     Ok(ty::Const::from_const_value(tcx, lit, ty))\n }\n@@ -1197,7 +1212,7 @@ pub fn parse_float<'tcx>(\n     let num = num.as_str();\n     use rustc_apfloat::ieee::{Single, Double};\n     use rustc_apfloat::Float;\n-    let bits = match fty {\n+    let (bits, defined) = match fty {\n         ast::FloatTy::F32 => {\n             num.parse::<f32>().map_err(|_| ())?;\n             let mut f = num.parse::<Single>().unwrap_or_else(|e| {\n@@ -1206,7 +1221,7 @@ pub fn parse_float<'tcx>(\n             if neg {\n                 f = -f;\n             }\n-            f.to_bits()\n+            (f.to_bits(), 32)\n         }\n         ast::FloatTy::F64 => {\n             num.parse::<f64>().map_err(|_| ())?;\n@@ -1216,9 +1231,9 @@ pub fn parse_float<'tcx>(\n             if neg {\n                 f = -f;\n             }\n-            f.to_bits()\n+            (f.to_bits(), 64)\n         }\n     };\n \n-    Ok(ConstValue::Scalar(Scalar::Bytes(bits)))\n+    Ok(ConstValue::Scalar(Scalar::Bits { bits, defined }))\n }"}, {"sha": "6c0a26e1f23bf15c8580fd4d20f271200fae7278", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 62, "deletions": 18, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=64a75ecc8014df45b5b875c5820a0406f41ae7bb", "patch": "@@ -18,12 +18,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         trace!(\"Casting {:?}: {:?} to {:?}\", val, src_ty, dest_ty);\n \n         match val {\n-            Scalar::Undef => Ok(Scalar::Undef),\n+            Scalar::Bits { defined: 0, .. } => Ok(val),\n             Scalar::Ptr(ptr) => self.cast_from_ptr(ptr, dest_ty),\n-            Scalar::Bytes(b) => {\n+            Scalar::Bits { bits, .. } => {\n+                // TODO(oli-obk): impl scalar_size for floats and check defined bits here\n                 match src_ty.sty {\n-                    TyFloat(fty) => self.cast_from_float(b, fty, dest_ty),\n-                    _ => self.cast_from_int(b, src_ty, dest_ty),\n+                    TyFloat(fty) => self.cast_from_float(bits, fty, dest_ty),\n+                    _ => self.cast_from_int(bits, src_ty, dest_ty),\n                 }\n             }\n         }\n@@ -46,20 +47,38 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         match dest_ty.sty {\n             TyInt(_) | TyUint(_) => {\n                 let v = self.truncate(v, dest_ty)?;\n-                Ok(Scalar::Bytes(v))\n+                Ok(Scalar::Bits {\n+                    bits: v,\n+                    defined: dest_ty.scalar_size(self.tcx.tcx).unwrap().bits() as u8,\n+                })\n             }\n \n-            TyFloat(FloatTy::F32) if signed => Ok(Scalar::Bytes(Single::from_i128(v as i128).value.to_bits())),\n-            TyFloat(FloatTy::F64) if signed => Ok(Scalar::Bytes(Double::from_i128(v as i128).value.to_bits())),\n-            TyFloat(FloatTy::F32) => Ok(Scalar::Bytes(Single::from_u128(v).value.to_bits())),\n-            TyFloat(FloatTy::F64) => Ok(Scalar::Bytes(Double::from_u128(v).value.to_bits())),\n+            TyFloat(FloatTy::F32) if signed => Ok(Scalar::Bits {\n+                bits: Single::from_i128(v as i128).value.to_bits(),\n+                defined: 32,\n+            }),\n+            TyFloat(FloatTy::F64) if signed => Ok(Scalar::Bits {\n+                bits: Double::from_i128(v as i128).value.to_bits(),\n+                defined: 64,\n+            }),\n+            TyFloat(FloatTy::F32) => Ok(Scalar::Bits {\n+                bits: Single::from_u128(v).value.to_bits(),\n+                defined: 32,\n+            }),\n+            TyFloat(FloatTy::F64) => Ok(Scalar::Bits {\n+                bits: Double::from_u128(v).value.to_bits(),\n+                defined: 64,\n+            }),\n \n-            TyChar if v as u8 as u128 == v => Ok(Scalar::Bytes(v)),\n+            TyChar if v as u8 as u128 == v => Ok(Scalar::Bits { bits: v, defined: 32 }),\n             TyChar => err!(InvalidChar(v)),\n \n             // No alignment check needed for raw pointers.  But we have to truncate to target ptr size.\n             TyRawPtr(_) => {\n-                Ok(Scalar::Bytes(self.memory.truncate_to_ptr(v).0 as u128))\n+                Ok(Scalar::Bits {\n+                    bits: self.memory.truncate_to_ptr(v).0 as u128,\n+                    defined: self.memory.pointer_size().bits() as u8,\n+                })\n             },\n \n             // Casts to bool are not permitted by rustc, no need to handle them here.\n@@ -75,28 +94,53 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             TyUint(t) => {\n                 let width = t.bit_width().unwrap_or(self.memory.pointer_size().bytes() as usize * 8);\n                 match fty {\n-                    FloatTy::F32 => Ok(Scalar::Bytes(Single::from_bits(bits).to_u128(width).value)),\n-                    FloatTy::F64 => Ok(Scalar::Bytes(Double::from_bits(bits).to_u128(width).value)),\n+                    FloatTy::F32 => Ok(Scalar::Bits {\n+                        bits: Single::from_bits(bits).to_u128(width).value,\n+                        defined: 32,\n+                    }),\n+                    FloatTy::F64 => Ok(Scalar::Bits {\n+                        bits: Double::from_bits(bits).to_u128(width).value,\n+                        defined: 64,\n+                    }),\n                 }\n             },\n             // float -> int\n             TyInt(t) => {\n                 let width = t.bit_width().unwrap_or(self.memory.pointer_size().bytes() as usize * 8);\n                 match fty {\n-                    FloatTy::F32 => Ok(Scalar::from_i128(Single::from_bits(bits).to_i128(width).value)),\n-                    FloatTy::F64 => Ok(Scalar::from_i128(Double::from_bits(bits).to_i128(width).value)),\n+                    FloatTy::F32 => Ok(Scalar::Bits {\n+                        bits: Single::from_bits(bits).to_i128(width).value as u128,\n+                        defined: 32,\n+                    }),\n+                    FloatTy::F64 => Ok(Scalar::Bits {\n+                        bits: Double::from_bits(bits).to_i128(width).value as u128,\n+                        defined: 64,\n+                    }),\n                 }\n             },\n             // f64 -> f32\n             TyFloat(FloatTy::F32) if fty == FloatTy::F64 => {\n-                Ok(Scalar::Bytes(Single::to_bits(Double::from_bits(bits).convert(&mut false).value)))\n+                Ok(Scalar::Bits {\n+                    bits: Single::to_bits(Double::from_bits(bits).convert(&mut false).value),\n+                    defined: 32,\n+                })\n             },\n             // f32 -> f64\n             TyFloat(FloatTy::F64) if fty == FloatTy::F32 => {\n-                Ok(Scalar::Bytes(Double::to_bits(Single::from_bits(bits).convert(&mut false).value)))\n+                Ok(Scalar::Bits {\n+                    bits: Double::to_bits(Single::from_bits(bits).convert(&mut false).value),\n+                    defined: 64,\n+                })\n             },\n             // identity cast\n-            TyFloat(_) => Ok(Scalar::Bytes(bits)),\n+            TyFloat(FloatTy:: F64) => Ok(Scalar::Bits {\n+                bits,\n+                defined: 64,\n+            }),\n+            TyFloat(FloatTy:: F32) => Ok(Scalar::Bits {\n+                bits,\n+                defined: 32,\n+            }),\n             _ => err!(Unimplemented(format!(\"float to {:?} cast\", dest_ty))),\n         }\n     }"}, {"sha": "14de0e14cd417662654c7b586bd2c91f58c7f554", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=64a75ecc8014df45b5b875c5820a0406f41ae7bb", "patch": "@@ -100,7 +100,7 @@ pub fn value_to_const_value<'tcx>(\n ) -> &'tcx ty::Const<'tcx> {\n     let layout = ecx.tcx.layout_of(ty::ParamEnv::reveal_all().and(ty)).unwrap();\n     match (val, &layout.abi) {\n-        (Value::Scalar(Scalar::Undef), _) if layout.is_zst() => {},\n+        (Value::Scalar(Scalar::Bits { defined: 0, ..}), _) if layout.is_zst() => {},\n         (Value::ByRef(..), _) |\n         (Value::Scalar(_), &layout::Abi::Scalar(_)) |\n         (Value::ScalarPair(..), &layout::Abi::ScalarPair(..)) => {},\n@@ -319,20 +319,31 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n             \"min_align_of\" => {\n                 let elem_ty = substs.type_at(0);\n                 let elem_align = ecx.layout_of(elem_ty)?.align.abi();\n-                let align_val = Scalar::from_u128(elem_align as u128);\n+                let align_val = Scalar::Bits {\n+                    bits: elem_align as u128,\n+                    defined: dest_layout.size.bits() as u8,\n+                };\n                 ecx.write_primval(dest, align_val, dest_layout.ty)?;\n             }\n \n             \"size_of\" => {\n                 let ty = substs.type_at(0);\n                 let size = ecx.layout_of(ty)?.size.bytes() as u128;\n-                ecx.write_primval(dest, Scalar::from_u128(size), dest_layout.ty)?;\n+                let size_val = Scalar::Bits {\n+                    bits: size,\n+                    defined: dest_layout.size.bits() as u8,\n+                };\n+                ecx.write_primval(dest, size_val, dest_layout.ty)?;\n             }\n \n             \"type_id\" => {\n                 let ty = substs.type_at(0);\n                 let type_id = ecx.tcx.type_id_hash(ty) as u128;\n-                ecx.write_primval(dest, Scalar::from_u128(type_id), dest_layout.ty)?;\n+                let id_val = Scalar::Bits {\n+                    bits: type_id,\n+                    defined: dest_layout.size.bits() as u8,\n+                };\n+                ecx.write_primval(dest, id_val, dest_layout.ty)?;\n             }\n \n             name => return Err(ConstEvalError::NeedsRfc(format!(\"calling intrinsic `{}`\", name)).into()),\n@@ -354,7 +365,7 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n         right: Scalar,\n         _right_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, Option<(Scalar, bool)>> {\n-        if left.is_bytes() && right.is_bytes() {\n+        if left.is_bits() && right.is_bits() {\n             Ok(None)\n         } else {\n             Err("}, {"sha": "5e03e759af987f0a7377823dc538b610ef294f34", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 57, "deletions": 30, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=64a75ecc8014df45b5b875c5820a0406f41ae7bb", "patch": "@@ -232,7 +232,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         let ptr = self.memory.allocate_bytes(s.as_bytes());\n         Ok(Value::ScalarPair(\n             Scalar::Ptr(ptr),\n-            Scalar::from_u128(s.len() as u128),\n+            Scalar::Bits {\n+                bits: s.len() as u128,\n+                defined: self.tcx.data_layout.pointer_size.bits() as u8,\n+            },\n         ))\n     }\n \n@@ -408,7 +411,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         ::log_settings::settings().indentation += 1;\n \n         let locals = if mir.local_decls.len() > 1 {\n-            let mut locals = IndexVec::from_elem(Some(Value::Scalar(Scalar::Undef)), &mir.local_decls);\n+            let mut locals = IndexVec::from_elem(Some(Value::Scalar(Scalar::undef())), &mir.local_decls);\n             match self.tcx.describe_def(instance.def_id()) {\n                 // statics and constants don't have `Storage*` statements, no need to look for them\n                 Some(Def::Static(..)) | Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => {},\n@@ -606,9 +609,13 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let src = self.eval_place(place)?;\n                 let ty = self.place_ty(place);\n                 let (_, len) = src.elem_ty_and_len(ty, self.tcx.tcx);\n+                let defined = self.memory.pointer_size().bits() as u8;\n                 self.write_primval(\n                     dest,\n-                    Scalar::from_u128(len as u128),\n+                    Scalar::Bits {\n+                        bits: len as u128,\n+                        defined,\n+                    },\n                     dest_ty,\n                 )?;\n             }\n@@ -621,7 +628,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n                 let val = match extra {\n                     PlaceExtra::None => ptr.to_value(),\n-                    PlaceExtra::Length(len) => ptr.to_value_with_len(len),\n+                    PlaceExtra::Length(len) => ptr.to_value_with_len(len, self.tcx.tcx),\n                     PlaceExtra::Vtable(vtable) => ptr.to_value_with_vtable(vtable),\n                     PlaceExtra::DowncastVariant(..) => {\n                         bug!(\"attempted to take a reference to an enum downcast place\")\n@@ -644,9 +651,13 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let layout = self.layout_of(ty)?;\n                 assert!(!layout.is_unsized(),\n                         \"SizeOf nullary MIR operator called for unsized type\");\n+                let defined = self.memory.pointer_size().bits() as u8;\n                 self.write_primval(\n                     dest,\n-                    Scalar::from_u128(layout.size.bytes() as u128),\n+                    Scalar::Bits {\n+                        bits: layout.size.bytes() as u128,\n+                        defined,\n+                    },\n                     dest_ty,\n                 )?;\n             }\n@@ -694,9 +705,16 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                                         let discr_val = def\n                                             .discriminant_for_variant(*self.tcx, index)\n                                             .val;\n+                                        let defined = dest_ty\n+                                                    .scalar_size(self.tcx.tcx)\n+                                                    .expect(\"can only cast variants to ints\")\n+                                                    .bits() as u8;\n                                         return self.write_primval(\n                                             dest,\n-                                            Scalar::Bytes(discr_val),\n+                                            Scalar::Bits {\n+                                                bits: discr_val,\n+                                                defined,\n+                                            },\n                                             dest_ty);\n                                     }\n                                 }\n@@ -780,7 +798,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let ty = self.place_ty(place);\n                 let place = self.eval_place(place)?;\n                 let discr_val = self.read_discriminant_value(place, ty)?;\n-                self.write_primval(dest, Scalar::Bytes(discr_val), dest_ty)?;\n+                let defined = ty.scalar_size(self.tcx.tcx).expect(\"discriminant must be scalar\").bits() as u8;\n+                self.write_primval(dest, Scalar::Bits {\n+                    bits: discr_val,\n+                    defined,\n+                }, dest_ty)?;\n             }\n         }\n \n@@ -910,7 +932,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             // FIXME: should we catch invalid discriminants here?\n             layout::Variants::Tagged { .. } => {\n                 if discr.ty.is_signed() {\n-                    let i = raw_discr.to_bytes()? as i128;\n+                    let i = raw_discr.to_bits(discr.size)? as i128;\n                     // going from layout tag type to typeck discriminant type\n                     // requires first sign extending with the layout discriminant\n                     let amt = 128 - discr.size.bits();\n@@ -925,7 +947,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     let truncatee = sexted as u128;\n                     (truncatee << amt) >> amt\n                 } else {\n-                    raw_discr.to_bytes()?\n+                    raw_discr.to_bits(discr.size)?\n                 }\n             },\n             layout::Variants::NicheFilling {\n@@ -942,7 +964,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                         assert!(variants_start == variants_end);\n                         dataful_variant as u128\n                     },\n-                    Scalar::Bytes(raw_discr) => {\n+                    Scalar::Bits { bits: raw_discr, defined } => {\n+                        if defined < discr.size.bits() as u8 {\n+                            return err!(ReadUndefBytes);\n+                        }\n                         let discr = raw_discr.wrapping_sub(niche_start)\n                             .wrapping_add(variants_start);\n                         if variants_start <= discr && discr <= variants_end {\n@@ -951,7 +976,6 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                             dataful_variant as u128\n                         }\n                     },\n-                    Scalar::Undef => return err!(ReadUndefBytes),\n                 }\n             }\n         };\n@@ -990,7 +1014,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let discr_val = (discr_val << amt) >> amt;\n \n                 let (discr_dest, tag) = self.place_field(dest, mir::Field::new(0), layout)?;\n-                self.write_primval(discr_dest, Scalar::Bytes(discr_val), tag.ty)?;\n+                self.write_primval(discr_dest, Scalar::Bits {\n+                    bits: discr_val,\n+                    defined: size as u8,\n+                }, tag.ty)?;\n             }\n             layout::Variants::NicheFilling {\n                 dataful_variant,\n@@ -1003,7 +1030,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                         self.place_field(dest, mir::Field::new(0), layout)?;\n                     let niche_value = ((variant_index - niche_variants.start()) as u128)\n                         .wrapping_add(niche_start);\n-                    self.write_primval(niche_dest, Scalar::Bytes(niche_value), niche.ty)?;\n+                    self.write_primval(niche_dest, Scalar::Bits {\n+                        bits: niche_value,\n+                        defined: niche.size.bits() as u8,\n+                    }, niche.ty)?;\n                 }\n             }\n         }\n@@ -1216,8 +1246,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                         layout::Primitive::Int(_, signed) => signed,\n                         _ => false,\n                     },\n-                    _ if primval.is_undef() => false,\n-                    _ => bug!(\"write_value_to_ptr: invalid ByVal layout: {:#?}\", layout)\n+                    _ => match primval {\n+                        Scalar::Bits { defined: 0, .. } => false,\n+                        _ => bug!(\"write_value_to_ptr: invalid ByVal layout: {:#?}\", layout),\n+                    }\n                 };\n                 self.memory.write_primval(dest, dest_align, primval, layout.size, signed)\n             }\n@@ -1308,10 +1340,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n     fn ensure_valid_value(&self, val: Scalar, ty: Ty<'tcx>) -> EvalResult<'tcx> {\n         match ty.sty {\n-            ty::TyBool if val.to_bytes()? > 1 => err!(InvalidBool),\n+            ty::TyBool => val.to_bool().map(|_| ()),\n \n-            ty::TyChar if ::std::char::from_u32(val.to_bytes()? as u32).is_none() => {\n-                err!(InvalidChar(val.to_bytes()? as u32 as u128))\n+            ty::TyChar if ::std::char::from_u32(val.to_bits(Size::from_bytes(4))? as u32).is_none() => {\n+                err!(InvalidChar(val.to_bits(Size::from_bytes(4))? as u32 as u128))\n             }\n \n             _ => Ok(()),\n@@ -1347,8 +1379,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     let len = self\n                         .memory\n                         .read_ptr_sized(extra, ptr_align)?\n-                        .to_bytes()?;\n-                    Ok(p.to_value_with_len(len as u64))\n+                        .to_bits(ptr_size)?;\n+                    Ok(p.to_value_with_len(len as u64, self.tcx.tcx))\n                 },\n                 _ => bug!(\"unsized primval ptr read from {:?}\", pointee_ty),\n             }\n@@ -1363,15 +1395,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     ) -> EvalResult<'tcx> {\n         match ty.sty {\n             ty::TyBool => {\n-                let val = self.memory.read_primval(ptr, ptr_align, Size::from_bytes(1))?;\n-                match val {\n-                    Scalar::Bytes(0) | Scalar::Bytes(1) => (),\n-                    // TODO: This seems a little overeager, should reading at bool type already be insta-UB?\n-                    _ => return err!(InvalidBool),\n-                }\n+                self.memory.read_primval(ptr, ptr_align, Size::from_bytes(1))?.to_bool()?;\n             }\n             ty::TyChar => {\n-                let c = self.memory.read_primval(ptr, ptr_align, Size::from_bytes(4))?.to_bytes()? as u32;\n+                let c = self.memory.read_primval(ptr, ptr_align, Size::from_bytes(4))?.to_bits(Size::from_bytes(4))? as u32;\n                 match ::std::char::from_u32(c) {\n                     Some(..) => (),\n                     None => return err!(InvalidChar(c as u128)),\n@@ -1418,7 +1445,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         self.memory.check_align(ptr, ptr_align)?;\n \n         if layout.size.bytes() == 0 {\n-            return Ok(Some(Value::Scalar(Scalar::Undef)));\n+            return Ok(Some(Value::Scalar(Scalar::undef())));\n         }\n \n         let ptr = ptr.to_ptr()?;\n@@ -1482,7 +1509,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let ptr = self.into_ptr(src)?;\n                 // u64 cast is from usize to u64, which is always good\n                 let valty = ValTy {\n-                    value: ptr.to_value_with_len(length.unwrap_usize(self.tcx.tcx)),\n+                    value: ptr.to_value_with_len(length.unwrap_usize(self.tcx.tcx), self.tcx.tcx),\n                     ty: dest_ty,\n                 };\n                 self.write_value(valty, dest)\n@@ -1796,7 +1823,7 @@ impl<'mir, 'tcx> Frame<'mir, 'tcx> {\n         trace!(\"{:?} is now live\", local);\n \n         // StorageLive *always* kills the value that's currently stored\n-        mem::replace(&mut self.locals[local], Some(Value::Scalar(Scalar::Undef)))\n+        mem::replace(&mut self.locals[local], Some(Value::Scalar(Scalar::undef())))\n     }\n \n     /// Returns the old value of the local"}, {"sha": "e0a12e5e9a407099885ca76267d07c4ec0ec1f5d", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=64a75ecc8014df45b5b875c5820a0406f41ae7bb", "patch": "@@ -232,15 +232,18 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                 let alloc = self.get(ptr.alloc_id)?;\n                 (ptr.offset.bytes(), alloc.align)\n             }\n-            Scalar::Bytes(bytes) => {\n-                let v = ((bytes as u128) % (1 << self.pointer_size().bytes())) as u64;\n+            Scalar::Bits { bits, defined } => {\n+                if defined <= self.pointer_size().bits() as u8 {\n+                    return err!(ReadUndefBytes);\n+                }\n+                // FIXME: what on earth does this line do? docs or fix needed!\n+                let v = ((bits as u128) % (1 << self.pointer_size().bytes())) as u64;\n                 if v == 0 {\n                     return err!(InvalidNullPointerUsage);\n                 }\n                 // the base address if the \"integer allocation\" is 0 and hence always aligned\n                 (v, required_align)\n             }\n-            Scalar::Undef => return err!(ReadUndefBytes),\n         };\n         // Check alignment\n         if alloc_align.abi() < required_align.abi() {\n@@ -711,10 +714,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         // Undef check happens *after* we established that the alignment is correct.\n         // We must not return Ok() for unaligned pointers!\n         if self.check_defined(ptr, size).is_err() {\n-            return Ok(Scalar::Undef.into());\n+            return Ok(Scalar::undef().into());\n         }\n         // Now we do the actual reading\n-        let bytes = read_target_uint(endianness, bytes).unwrap();\n+        let bits = read_target_uint(endianness, bytes).unwrap();\n         // See if we got a pointer\n         if size != self.pointer_size() {\n             if self.relocations(ptr, size)?.len() != 0 {\n@@ -723,12 +726,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         } else {\n             let alloc = self.get(ptr.alloc_id)?;\n             match alloc.relocations.get(&ptr.offset) {\n-                Some(&alloc_id) => return Ok(Pointer::new(alloc_id, Size::from_bytes(bytes as u64)).into()),\n+                Some(&alloc_id) => return Ok(Pointer::new(alloc_id, Size::from_bytes(bits as u64)).into()),\n                 None => {},\n             }\n         }\n-        // We don't. Just return the bytes.\n-        Ok(Scalar::Bytes(bytes))\n+        // We don't. Just return the bits.\n+        Ok(Scalar::Bits {\n+            bits,\n+            defined: size.bits() as u8,\n+        })\n     }\n \n     pub fn read_ptr_sized(&self, ptr: Pointer, ptr_align: Align) -> EvalResult<'tcx, Scalar> {\n@@ -744,9 +750,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                 val.offset.bytes() as u128\n             }\n \n-            Scalar::Bytes(bytes) => bytes,\n+            Scalar::Bits { bits, defined } if defined >= size.bits() as u8 && defined != 0 => bits,\n \n-            Scalar::Undef => {\n+            Scalar::Bits { .. } => {\n                 self.check_align(ptr.into(), ptr_align)?;\n                 self.mark_definedness(ptr, size, false)?;\n                 return Ok(());\n@@ -951,7 +957,7 @@ pub trait HasMemory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n \n             Value::ScalarPair(ptr, vtable) => Ok((ptr.into(), vtable.to_ptr()?)),\n \n-            Value::Scalar(Scalar::Undef) => err!(ReadUndefBytes),\n+            Value::Scalar(Scalar::Bits { defined: 0, .. }) => err!(ReadUndefBytes),\n             _ => bug!(\"expected ptr and vtable, got {:?}\", value),\n         }\n     }\n@@ -967,15 +973,14 @@ pub trait HasMemory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n                 let len = mem.read_ptr_sized(\n                     ref_ptr.ptr_offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n                     align\n-                )?.to_bytes()? as u64;\n+                )?.to_bits(mem.pointer_size())? as u64;\n                 Ok((ptr, len))\n             }\n             Value::ScalarPair(ptr, val) => {\n-                let len = val.to_u128()?;\n-                assert_eq!(len as u64 as u128, len);\n+                let len = val.to_bits(self.memory().pointer_size())?;\n                 Ok((ptr.into(), len as u64))\n             }\n-            Value::Scalar(Scalar::Undef) => err!(ReadUndefBytes),\n+            Value::Scalar(Scalar::Bits { defined: 0, .. }) => err!(ReadUndefBytes),\n             Value::Scalar(_) => bug!(\"expected ptr and length, got {:?}\", value),\n         }\n     }"}, {"sha": "fff8da78dc14962ed41bf274ab8db7fe2048f95d", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 42, "deletions": 22, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=64a75ecc8014df45b5b875c5820a0406f41ae7bb", "patch": "@@ -79,11 +79,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             }\n         }\n \n-        // II: From now on, everything must be bytes, no pointers\n-        let l = left.to_bytes()?;\n-        let r = right.to_bytes()?;\n-\n         let left_layout = self.layout_of(left_ty)?;\n+        let right_layout = self.layout_of(right_ty)?;\n+\n+        // II: From now on, everything must be bytes, no pointers\n+        let l = left.to_bits(left_layout.size)?;\n+        let r = right.to_bits(right_layout.size)?;\n \n         // These ops can have an RHS with a different numeric type.\n         if right_kind.is_int() && (bin_op == Shl || bin_op == Shr) {\n@@ -110,7 +111,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 }\n             };\n             let truncated = self.truncate(result, left_ty)?;\n-            return Ok((Scalar::Bytes(truncated), oflo));\n+            return Ok((Scalar::Bits {\n+                bits: truncated,\n+                defined: size as u8,\n+            }, oflo));\n         }\n \n         if left_kind != right_kind {\n@@ -156,7 +160,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     Rem | Div => {\n                         // int_min / -1\n                         if r == -1 && l == (1 << (size - 1)) {\n-                            return Ok((Scalar::Bytes(l), true));\n+                            return Ok((Scalar::Bits { bits: l, defined: size as u8 }, true));\n                         }\n                     },\n                     _ => {},\n@@ -170,38 +174,47 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 }\n                 let result = result as u128;\n                 let truncated = self.truncate(result, left_ty)?;\n-                return Ok((Scalar::Bytes(truncated), oflo));\n+                return Ok((Scalar::Bits {\n+                    bits: truncated,\n+                    defined: size as u8,\n+                }, oflo));\n             }\n         }\n \n         if let ty::TyFloat(fty) = left_ty.sty {\n             macro_rules! float_math {\n-                ($ty:path) => {{\n+                ($ty:path, $bitsize:expr) => {{\n                     let l = <$ty>::from_bits(l);\n                     let r = <$ty>::from_bits(r);\n+                    let bitify = |res: ::rustc_apfloat::StatusAnd<$ty>| Scalar::Bits {\n+                        bits: res.value.to_bits(),\n+                        defined: $bitsize,\n+                    };\n                     let val = match bin_op {\n                         Eq => Scalar::from_bool(l == r),\n                         Ne => Scalar::from_bool(l != r),\n                         Lt => Scalar::from_bool(l < r),\n                         Le => Scalar::from_bool(l <= r),\n                         Gt => Scalar::from_bool(l > r),\n                         Ge => Scalar::from_bool(l >= r),\n-                        Add => Scalar::Bytes((l + r).value.to_bits()),\n-                        Sub => Scalar::Bytes((l - r).value.to_bits()),\n-                        Mul => Scalar::Bytes((l * r).value.to_bits()),\n-                        Div => Scalar::Bytes((l / r).value.to_bits()),\n-                        Rem => Scalar::Bytes((l % r).value.to_bits()),\n+                        Add => bitify(l + r),\n+                        Sub => bitify(l - r),\n+                        Mul => bitify(l * r),\n+                        Div => bitify(l / r),\n+                        Rem => bitify(l % r),\n                         _ => bug!(\"invalid float op: `{:?}`\", bin_op),\n                     };\n                     return Ok((val, false));\n                 }};\n             }\n             match fty {\n-                FloatTy::F32 => float_math!(Single),\n-                FloatTy::F64 => float_math!(Double),\n+                FloatTy::F32 => float_math!(Single, 32),\n+                FloatTy::F64 => float_math!(Double, 64),\n             }\n         }\n \n+        let bitsize = left_ty.scalar_size(self).expect(\"operator type must be scalar\").bits() as u8;\n+\n         // only ints left\n         let val = match bin_op {\n             Eq => Scalar::from_bool(l == r),\n@@ -212,9 +225,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             Gt => Scalar::from_bool(l > r),\n             Ge => Scalar::from_bool(l >= r),\n \n-            BitOr => Scalar::Bytes(l | r),\n-            BitAnd => Scalar::Bytes(l & r),\n-            BitXor => Scalar::Bytes(l ^ r),\n+            BitOr => Scalar::Bits { bits: l | r, defined: bitsize },\n+            BitAnd => Scalar::Bits { bits: l & r, defined: bitsize },\n+            BitXor => Scalar::Bits { bits: l ^ r, defined: bitsize },\n \n             Add | Sub | Mul | Rem | Div => {\n                 let op: fn(u128, u128) -> (u128, bool) = match bin_op {\n@@ -229,7 +242,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 };\n                 let (result, oflo) = op(l, r);\n                 let truncated = self.truncate(result, left_ty)?;\n-                return Ok((Scalar::Bytes(truncated), oflo || truncated != result));\n+                return Ok((Scalar::Bits {\n+                    bits: truncated,\n+                    defined: bitsize,\n+                }, oflo || truncated != result));\n             }\n \n             _ => {\n@@ -258,8 +274,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         use rustc_apfloat::ieee::{Single, Double};\n         use rustc_apfloat::Float;\n \n-        let bytes = val.to_bytes()?;\n-        let size = self.layout_of(ty)?.size.bits();\n+        let size = self.layout_of(ty)?.size;\n+        let bytes = val.to_bits(size)?;\n+        let size = size.bits();\n \n         let result_bytes = match (un_op, &ty.sty) {\n \n@@ -274,6 +291,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             (Neg, _) => (-(bytes as i128)) as u128,\n         };\n \n-        Ok(Scalar::Bytes(self.truncate(result_bytes, ty)?))\n+        Ok(Scalar::Bits {\n+            bits: self.truncate(result_bytes, ty)?,\n+            defined: size as u8,\n+        })\n     }\n }"}, {"sha": "1f4925a0ab2a91f0e17751071534c05c49091b22", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=64a75ecc8014df45b5b875c5820a0406f41ae7bb", "patch": "@@ -35,7 +35,7 @@ pub enum PlaceExtra {\n impl<'tcx> Place {\n     /// Produces a Place that will error if attempted to be read from\n     pub fn undef() -> Self {\n-        Self::from_primval_ptr(Scalar::Undef.into(), Align::from_bytes(1, 1).unwrap())\n+        Self::from_primval_ptr(Scalar::undef().into(), Align::from_bytes(1, 1).unwrap())\n     }\n \n     pub fn from_primval_ptr(ptr: Scalar, align: Align) -> Self {\n@@ -128,7 +128,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let field_index = field.index();\n         let field = base_layout.field(self, field_index)?;\n         if field.size.bytes() == 0 {\n-            return Ok(Some((Value::Scalar(Scalar::Undef), field.ty)))\n+            return Ok(Some((Value::Scalar(Scalar::undef()), field.ty)))\n         }\n         let offset = base_layout.fields.offset(field_index);\n         match base {\n@@ -387,8 +387,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             Index(local) => {\n                 let value = self.frame().get_local(local)?;\n                 let ty = self.tcx.types.usize;\n-                let n = self.value_to_primval(ValTy { value, ty })?.to_u64()?;\n-                self.place_index(base, base_ty, n)\n+                let n = self\n+                    .value_to_primval(ValTy { value, ty })?\n+                    .to_bits(self.tcx.data_layout.pointer_size)?;\n+                self.place_index(base, base_ty, n as u64)\n             }\n \n             ConstantIndex {"}, {"sha": "c0fafa7f83e22886d51217a0a6c1402debe58d1b", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=64a75ecc8014df45b5b875c5820a0406f41ae7bb", "patch": "@@ -28,7 +28,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 ptr,\n                 align: _,\n                 extra: PlaceExtra::Length(len),\n-            } => ptr.to_value_with_len(len),\n+            } => ptr.to_value_with_len(len, self.tcx.tcx),\n             Place::Ptr {\n                 ptr,\n                 align: _,"}, {"sha": "8493a0849df4d6cdd618805c02305d9b5beca121", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=64a75ecc8014df45b5b875c5820a0406f41ae7bb", "patch": "@@ -44,7 +44,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let mut target_block = targets[targets.len() - 1];\n \n                 for (index, &const_int) in values.iter().enumerate() {\n-                    if discr_prim.to_bytes()? == const_int {\n+                    if discr_prim.to_bits(discr_val.ty.scalar_size(self.tcx.tcx).expect(\"discr must be scalar\"))? == const_int {\n                         target_block = targets[index];\n                         break;\n                     }\n@@ -153,10 +153,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                         BoundsCheck { ref len, ref index } => {\n                             let len = self.eval_operand_to_primval(len)\n                                 .expect(\"can't eval len\")\n-                                .to_u64()?;\n+                                .to_bits(self.memory().pointer_size())? as u64;\n                             let index = self.eval_operand_to_primval(index)\n                                 .expect(\"can't eval index\")\n-                                .to_u64()?;\n+                                .to_bits(self.memory().pointer_size())? as u64;\n                             err!(BoundsCheck { len, index })\n                         }\n                         Overflow(op) => Err(Overflow(op).into()),\n@@ -359,7 +359,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                                             self.write_value(valty, dest)?;\n                                         }\n                                     }\n-                                    Value::Scalar(Scalar::Undef) => {}\n+                                    Value::Scalar(Scalar::Bits { defined: 0, .. }) => {}\n                                     other => {\n                                         trace!(\"{:#?}, {:#?}\", other, layout);\n                                         let mut layout = layout;"}, {"sha": "373a0b0d0bfedb75ffa80057d1ccbead6d870257", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=64a75ecc8014df45b5b875c5820a0406f41ae7bb", "patch": "@@ -38,9 +38,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         self.memory.write_ptr_sized_unsigned(vtable, ptr_align, drop.into())?;\n \n         let size_ptr = vtable.offset(ptr_size, &self)?;\n-        self.memory.write_ptr_sized_unsigned(size_ptr, ptr_align, Scalar::Bytes(size as u128))?;\n+        self.memory.write_ptr_sized_unsigned(size_ptr, ptr_align, Scalar::Bits {\n+            bits: size as u128,\n+            defined: ptr_size.bits() as u8,\n+        })?;\n         let align_ptr = vtable.offset(ptr_size * 2, &self)?;\n-        self.memory.write_ptr_sized_unsigned(align_ptr, ptr_align, Scalar::Bytes(align as u128))?;\n+        self.memory.write_ptr_sized_unsigned(align_ptr, ptr_align, Scalar::Bits {\n+            bits: align as u128,\n+            defined: ptr_size.bits() as u8,\n+        })?;\n \n         for (i, method) in methods.iter().enumerate() {\n             if let Some((def_id, substs)) = *method {\n@@ -65,9 +71,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, Option<ty::Instance<'tcx>>> {\n         // we don't care about the pointee type, we just want a pointer\n         let pointer_align = self.tcx.data_layout.pointer_align;\n+        let pointer_size = self.tcx.data_layout.pointer_size.bits() as u8;\n         match self.read_ptr(vtable, pointer_align, self.tcx.mk_nil_ptr())? {\n             // some values don't need to call a drop impl, so the value is null\n-            Value::Scalar(Scalar::Bytes(0)) => Ok(None),\n+            Value::Scalar(Scalar::Bits { bits: 0, defined} ) if defined == pointer_size => Ok(None),\n             Value::Scalar(Scalar::Ptr(drop_fn)) => self.memory.get_fn(drop_fn).map(Some),\n             _ => err!(ReadBytesAsPointer),\n         }\n@@ -79,11 +86,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, (Size, Align)> {\n         let pointer_size = self.memory.pointer_size();\n         let pointer_align = self.tcx.data_layout.pointer_align;\n-        let size = self.memory.read_ptr_sized(vtable.offset(pointer_size, self)?, pointer_align)?.to_bytes()? as u64;\n+        let size = self.memory.read_ptr_sized(vtable.offset(pointer_size, self)?, pointer_align)?.to_bits(pointer_size)? as u64;\n         let align = self.memory.read_ptr_sized(\n             vtable.offset(pointer_size * 2, self)?,\n             pointer_align\n-        )?.to_bytes()? as u64;\n+        )?.to_bits(pointer_size)? as u64;\n         Ok((Size::from_bytes(size), Align::from_bytes(align, align).unwrap()))\n     }\n }"}, {"sha": "d9d9104c93928aa8506f0e7075fc615833cc8dbf", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=64a75ecc8014df45b5b875c5820a0406f41ae7bb", "patch": "@@ -283,7 +283,10 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n             Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n                 let param_env = self.tcx.param_env(self.source.def_id);\n                 type_size_of(self.tcx, param_env, ty).map(|n| (\n-                    Value::Scalar(Scalar::Bytes(n as u128)),\n+                    Value::Scalar(Scalar::Bits {\n+                        bits: n as u128,\n+                        defined: self.tcx.data_layout.pointer_size.bits() as u8,\n+                    }),\n                     self.tcx.types.usize,\n                     span,\n                 ))\n@@ -326,10 +329,10 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                     this.ecx.value_to_primval(ValTy { value: right.0, ty: right.1 })\n                 })?;\n                 if op == BinOp::Shr || op == BinOp::Shl {\n-                    let param_env = self.tcx.param_env(self.source.def_id);\n                     let left_ty = left.ty(self.mir, self.tcx);\n-                    let bits = self.tcx.layout_of(param_env.and(left_ty)).unwrap().size.bits();\n-                    if r.to_bytes().ok().map_or(false, |b| b >= bits as u128) {\n+                    let left_bits = left_ty.scalar_size(self.tcx).unwrap().bits();\n+                    let right_size = right.1.scalar_size(self.tcx).unwrap();\n+                    if r.to_bits(right_size).ok().map_or(false, |b| b >= left_bits as u128) {\n                         let scope_info = match self.mir.visibility_scope_info {\n                             ClearCrossCrate::Set(ref data) => data,\n                             ClearCrossCrate::Clear => return None,\n@@ -520,14 +523,14 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                         BoundsCheck { ref len, ref index } => {\n                             let len = self.eval_operand(len).expect(\"len must be const\");\n                             let len = match len.0 {\n-                                Value::Scalar(Scalar::Bytes(n)) => n,\n+                                Value::Scalar(Scalar::Bits { bits, ..}) => bits,\n                                 _ => bug!(\"const len not primitive: {:?}\", len),\n                             };\n                             let index = self\n                                 .eval_operand(index)\n                                 .expect(\"index must be const\");\n                             let index = match index.0 {\n-                                Value::Scalar(Scalar::Bytes(n)) => n,\n+                                Value::Scalar(Scalar::Bits { bits, .. }) => bits,\n                                 _ => bug!(\"const index not primitive: {:?}\", index),\n                             };\n                             format!("}, {"sha": "ce2f5b0fe6ad01f39a8e51a41808cf367b633a74", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64a75ecc8014df45b5b875c5820a0406f41ae7bb/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=64a75ecc8014df45b5b875c5820a0406f41ae7bb", "patch": "@@ -39,7 +39,7 @@ impl MirPass for SimplifyBranches {\n                 TerminatorKind::SwitchInt { discr: Operand::Constant(box Constant {\n                     literal: Literal::Value { ref value }, ..\n                 }), switch_ty, ref values, ref targets, .. } => {\n-                    if let Some(constint) = value.assert_bits(switch_ty) {\n+                    if let Some(constint) = value.assert_bits(tcx, switch_ty) {\n                         let (otherwise, targets) = targets.split_last().unwrap();\n                         let mut ret = TerminatorKind::Goto { target: *otherwise };\n                         for (&v, t) in values.iter().zip(targets.iter()) {"}]}