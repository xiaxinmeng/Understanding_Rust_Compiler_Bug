{"sha": "2733b189ac60cea541fbf80e5839e5027ffc9fbf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3MzNiMTg5YWM2MGNlYTU0MWZiZjgwZTU4MzllNTAyN2ZmYzlmYmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-05T21:26:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-05T21:26:44Z"}, "message": "auto merge of #9250 : erickt/rust/num, r=erickt\n\nThis PR solves one of the pain points with c-style enums. Simplifies writing a fn to convert from an int/uint to an enum. It does this through a `#[deriving(FromPrimitive)]` syntax extension.\r\n\r\nBefore this is committed though, we need to discuss if `ToPrimitive`/`FromPrimitive` has the right design (cc #4819). I've changed all the `.to_int()` and `from_int()` style functions to return `Option<int>` so we can handle partial functions. For this PR though only enums and `extra::num::bigint::*` take advantage of returning None for unrepresentable values. In the long run it'd be better if `i64.to_i8()` returned `None` if the value was too large, but I'll save this for a future PR.\r\n\r\nCloses #3868.", "tree": {"sha": "b9fcc58a2f736f292eb32de9553843c99f91f32d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9fcc58a2f736f292eb32de9553843c99f91f32d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2733b189ac60cea541fbf80e5839e5027ffc9fbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2733b189ac60cea541fbf80e5839e5027ffc9fbf", "html_url": "https://github.com/rust-lang/rust/commit/2733b189ac60cea541fbf80e5839e5027ffc9fbf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2733b189ac60cea541fbf80e5839e5027ffc9fbf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c388be8d1988a966ef62c545b996b9da0f71e93", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c388be8d1988a966ef62c545b996b9da0f71e93", "html_url": "https://github.com/rust-lang/rust/commit/0c388be8d1988a966ef62c545b996b9da0f71e93"}, {"sha": "0e8ad4d8a2f23206c723137d765027a7acd97837", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e8ad4d8a2f23206c723137d765027a7acd97837", "html_url": "https://github.com/rust-lang/rust/commit/0e8ad4d8a2f23206c723137d765027a7acd97837"}], "stats": {"total": 2030, "additions": 1634, "deletions": 396}, "files": [{"sha": "56d116804f53e7e6222afb62e44d5d9b828fd1a7", "filename": "doc/rust.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2733b189ac60cea541fbf80e5839e5027ffc9fbf/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/2733b189ac60cea541fbf80e5839e5027ffc9fbf/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=2733b189ac60cea541fbf80e5839e5027ffc9fbf", "patch": "@@ -1775,6 +1775,7 @@ Supported traits for `deriving` are:\n   `obj.to_str()` has similar output as `fmt!(\"%?\", obj)`, but it differs in that\n   each constituent field of the type must also implement `ToStr` and will have\n   `field.to_str()` invoked to build up the result.\n+* `FromPrimitive`, to create an instance from a numeric primitve.\n \n ### Stability\n One can indicate the stability of an API using the following attributes:"}, {"sha": "8604674ea12204c15bfb30253ed2be6b31802d68", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 486, "deletions": 281, "changes": 767, "blob_url": "https://github.com/rust-lang/rust/blob/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=2733b189ac60cea541fbf80e5839e5027ffc9fbf", "patch": "@@ -20,12 +20,13 @@ A `BigInt` is a combination of `BigUint` and `Sign`.\n #[allow(non_uppercase_statics)];\n \n use std::cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n-use std::int;\n use std::num;\n-use std::num::{IntConvertible, Zero, One, ToStrRadix, FromStrRadix, Orderable};\n+use std::num::{Zero, One, ToStrRadix, FromStrRadix, Orderable};\n+use std::num::{ToPrimitive, FromPrimitive};\n use std::rand::Rng;\n use std::str;\n use std::uint;\n+use std::{i64, u64};\n use std::vec;\n \n /**\n@@ -500,18 +501,152 @@ impl Integer for BigUint {\n     fn is_odd(&self) -> bool { !self.is_even() }\n }\n \n-impl IntConvertible for BigUint {\n+impl ToPrimitive for BigUint {\n     #[inline]\n-    fn to_int(&self) -> int {\n-        self.to_int_opt().expect(\"BigUint conversion would overflow int\")\n+    fn to_i64(&self) -> Option<i64> {\n+        do self.to_u64().and_then |n| {\n+            // If top bit of u64 is set, it's too large to convert to i64.\n+            if n >> 63 == 0 {\n+                Some(n as i64)\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+\n+    #[cfg(target_word_size = \"32\")]\n+    #[inline]\n+    fn to_u64(&self) -> Option<u64> {\n+        match self.data {\n+            [] => {\n+                Some(0)\n+            }\n+            [n0] => {\n+                Some(n0 as u64)\n+            }\n+            [n0, n1] => {\n+                Some(BigDigit::to_uint(n1, n0) as u64)\n+            }\n+            [n0, n1, n2] => {\n+                let n_lo = BigDigit::to_uint(n1, n0) as u64;\n+                let n_hi = n2 as u64;\n+                Some((n_hi << 32) + n_lo)\n+            }\n+            [n0, n1, n2, n3] => {\n+                let n_lo = BigDigit::to_uint(n1, n0) as u64;\n+                let n_hi = BigDigit::to_uint(n3, n2) as u64;\n+                Some((n_hi << 32) + n_lo)\n+            }\n+            _ => None\n+        }\n+    }\n+\n+    #[cfg(target_word_size = \"64\")]\n+    #[inline]\n+    fn to_u64(&self) -> Option<u64> {\n+        match self.data {\n+            [] => {\n+                Some(0)\n+            }\n+            [n0] => {\n+                Some(n0 as u64)\n+            }\n+            [n0, n1] => {\n+                Some(BigDigit::to_uint(n1, n0) as u64)\n+            }\n+            _ => None\n+        }\n+    }\n+}\n+\n+impl FromPrimitive for BigUint {\n+    #[inline]\n+    fn from_i64(n: i64) -> Option<BigUint> {\n+        if (n > 0) {\n+            FromPrimitive::from_u64(n as u64)\n+        } else if (n == 0) {\n+            Some(Zero::zero())\n+        } else {\n+            None\n+        }\n     }\n \n+    #[cfg(target_word_size = \"32\")]\n     #[inline]\n-    fn from_int(n: int) -> BigUint {\n-        if (n < 0) { Zero::zero() } else { BigUint::from_uint(n as uint) }\n+    fn from_u64(n: u64) -> Option<BigUint> {\n+        let n_lo = (n & 0x0000_0000_FFFF_FFFF) as uint;\n+        let n_hi = (n >> 32) as uint;\n+\n+        let n = match (BigDigit::from_uint(n_hi), BigDigit::from_uint(n_lo)) {\n+            ((0,  0),  (0,  0))  => Zero::zero(),\n+            ((0,  0),  (0,  n0)) => BigUint::new(~[n0]),\n+            ((0,  0),  (n1, n0)) => BigUint::new(~[n0, n1]),\n+            ((0,  n2), (n1, n0)) => BigUint::new(~[n0, n1, n2]),\n+            ((n3, n2), (n1, n0)) => BigUint::new(~[n0, n1, n2, n3]),\n+        };\n+        Some(n)\n+    }\n+\n+    #[cfg(target_word_size = \"64\")]\n+    #[inline]\n+    fn from_u64(n: u64) -> Option<BigUint> {\n+        let n = match BigDigit::from_uint(n as uint) {\n+            (0,  0)  => Zero::zero(),\n+            (0,  n0) => BigUint::new(~[n0]),\n+            (n1, n0) => BigUint::new(~[n0, n1])\n+        };\n+        Some(n)\n     }\n }\n \n+/// A generic trait for converting a value to a `BigUint`.\n+pub trait ToBigUint {\n+    /// Converts the value of `self` to a `BigUint`.\n+    fn to_biguint(&self) -> Option<BigUint>;\n+}\n+\n+impl ToBigUint for BigInt {\n+    #[inline]\n+    fn to_biguint(&self) -> Option<BigUint> {\n+        if self.sign == Plus {\n+            Some(self.data.clone())\n+        } else if self.sign == Zero {\n+            Some(Zero::zero())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl ToBigUint for BigUint {\n+    #[inline]\n+    fn to_biguint(&self) -> Option<BigUint> {\n+        Some(self.clone())\n+    }\n+}\n+\n+macro_rules! impl_to_biguint(\n+    ($T:ty, $from_ty:path) => {\n+        impl ToBigUint for $T {\n+            #[inline]\n+            fn to_biguint(&self) -> Option<BigUint> {\n+                $from_ty(*self)\n+            }\n+        }\n+    }\n+)\n+\n+impl_to_biguint!(int,  FromPrimitive::from_int)\n+impl_to_biguint!(i8,   FromPrimitive::from_i8)\n+impl_to_biguint!(i16,  FromPrimitive::from_i16)\n+impl_to_biguint!(i32,  FromPrimitive::from_i32)\n+impl_to_biguint!(i64,  FromPrimitive::from_i64)\n+impl_to_biguint!(uint, FromPrimitive::from_uint)\n+impl_to_biguint!(u8,   FromPrimitive::from_u8)\n+impl_to_biguint!(u16,  FromPrimitive::from_u16)\n+impl_to_biguint!(u32,  FromPrimitive::from_u32)\n+impl_to_biguint!(u64,  FromPrimitive::from_u64)\n+\n impl ToStrRadix for BigUint {\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         assert!(1 < radix && radix <= 16);\n@@ -522,16 +657,16 @@ impl ToStrRadix for BigUint {\n         return fill_concat(convert_base((*self).clone(), base), radix, max_len);\n \n         fn convert_base(n: BigUint, base: uint) -> ~[BigDigit] {\n-            let divider    = BigUint::from_uint(base);\n+            let divider    = FromPrimitive::from_uint(base).unwrap();\n             let mut result = ~[];\n             let mut m      = n;\n             while m > divider {\n                 let (d, m0) = m.div_mod_floor(&divider);\n-                result.push(m0.to_uint() as BigDigit);\n+                result.push(m0.to_uint().unwrap() as BigDigit);\n                 m = d;\n             }\n             if !m.is_zero() {\n-                result.push(m.to_uint() as BigDigit);\n+                result.push(m.to_uint().unwrap() as BigDigit);\n             }\n             return result;\n         }\n@@ -571,38 +706,39 @@ impl BigUint {\n         return BigUint { data: v };\n     }\n \n-    /// Creates and initializes a `BigUint`.\n-    #[inline]\n-    pub fn from_uint(n: uint) -> BigUint {\n-        match BigDigit::from_uint(n) {\n-            (0,  0)  => Zero::zero(),\n-            (0,  n0) => BigUint::new(~[n0]),\n-            (n1, n0) => BigUint::new(~[n0, n1])\n-        }\n-    }\n-\n     /// Creates and initializes a `BigUint`.\n     #[inline]\n     pub fn from_slice(slice: &[BigDigit]) -> BigUint {\n         return BigUint::new(slice.to_owned());\n     }\n \n     /// Creates and initializes a `BigUint`.\n-    pub fn parse_bytes(buf: &[u8], radix: uint)\n-        -> Option<BigUint> {\n+    pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<BigUint> {\n         let (base, unit_len) = get_radix_base(radix);\n-        let base_num: BigUint = BigUint::from_uint(base);\n+        let base_num = match FromPrimitive::from_uint(base) {\n+            Some(base_num) => base_num,\n+            None => { return None; }\n+        };\n \n         let mut end             = buf.len();\n         let mut n: BigUint      = Zero::zero();\n         let mut power: BigUint  = One::one();\n         loop {\n             let start = num::max(end, unit_len) - unit_len;\n             match uint::parse_bytes(buf.slice(start, end), radix) {\n-                // FIXME(#6102): Assignment operator for BigInt causes ICE\n-                // Some(d) => n += BigUint::from_uint(d) * power,\n-                Some(d) => n = n + BigUint::from_uint(d) * power,\n-                None    => return None\n+                Some(d) => {\n+                    let d: Option<BigUint> = FromPrimitive::from_uint(d);\n+                    match d {\n+                        Some(d) => {\n+                            // FIXME(#6102): Assignment operator for BigInt\n+                            // causes ICE:\n+                            // n += d * power;\n+                            n = n + d * power;\n+                        }\n+                        None => { return None; }\n+                    }\n+                }\n+                None => { return None; }\n             }\n             if end <= unit_len {\n                 return Some(n);\n@@ -614,44 +750,6 @@ impl BigUint {\n         }\n     }\n \n-\n-    /// Converts this `BigUint` into a `uint`, failing if the conversion\n-    /// would overflow.\n-    #[inline]\n-    pub fn to_uint(&self) -> uint {\n-        self.to_uint_opt().expect(\"BigUint conversion would overflow uint\")\n-    }\n-\n-    /// Converts this `BigUint` into a `uint`, unless it would overflow.\n-    #[inline]\n-    pub fn to_uint_opt(&self) -> Option<uint> {\n-        match self.data.len() {\n-            0 => Some(0),\n-            1 => Some(self.data[0] as uint),\n-            2 => Some(BigDigit::to_uint(self.data[1], self.data[0])),\n-            _ => None\n-        }\n-    }\n-\n-    /// Converts this `BigUint` into an `int`, unless it would overflow.\n-    pub fn to_int_opt(&self) -> Option<int> {\n-        self.to_uint_opt().and_then(|n| {\n-            // If top bit of uint is set, it's too large to convert to\n-            // int.\n-            if (n >> (2*BigDigit::bits - 1) != 0) {\n-                None\n-            } else {\n-                Some(n as int)\n-            }\n-        })\n-    }\n-\n-    /// Converts this `BigUint` into a `BigInt`.\n-    #[inline]\n-    pub fn to_bigint(&self) -> BigInt {\n-        BigInt::from_biguint(Plus, self.clone())\n-    }\n-\n     #[inline]\n     fn shl_unit(&self, n_unit: uint) -> BigUint {\n         if n_unit == 0 || self.is_zero() { return (*self).clone(); }\n@@ -706,30 +804,6 @@ impl BigUint {\n     }\n }\n \n-#[cfg(target_word_size = \"64\")]\n-#[inline]\n-fn get_radix_base(radix: uint) -> (uint, uint) {\n-    assert!(1 < radix && radix <= 16);\n-    match radix {\n-        2  => (4294967296, 32),\n-        3  => (3486784401, 20),\n-        4  => (4294967296, 16),\n-        5  => (1220703125, 13),\n-        6  => (2176782336, 12),\n-        7  => (1977326743, 11),\n-        8  => (1073741824, 10),\n-        9  => (3486784401, 10),\n-        10 => (1000000000, 9),\n-        11 => (2357947691, 9),\n-        12 => (429981696,  8),\n-        13 => (815730721,  8),\n-        14 => (1475789056, 8),\n-        15 => (2562890625, 8),\n-        16 => (4294967296, 8),\n-        _  => fail2!()\n-    }\n-}\n-\n #[cfg(target_word_size = \"32\")]\n #[inline]\n fn get_radix_base(radix: uint) -> (uint, uint) {\n@@ -754,6 +828,30 @@ fn get_radix_base(radix: uint) -> (uint, uint) {\n     }\n }\n \n+#[cfg(target_word_size = \"64\")]\n+#[inline]\n+fn get_radix_base(radix: uint) -> (uint, uint) {\n+    assert!(1 < radix && radix <= 16);\n+    match radix {\n+        2  => (4294967296, 32),\n+        3  => (3486784401, 20),\n+        4  => (4294967296, 16),\n+        5  => (1220703125, 13),\n+        6  => (2176782336, 12),\n+        7  => (1977326743, 11),\n+        8  => (1073741824, 10),\n+        9  => (3486784401, 10),\n+        10 => (1000000000, 9),\n+        11 => (2357947691, 9),\n+        12 => (429981696,  8),\n+        13 => (815730721,  8),\n+        14 => (1475789056, 8),\n+        15 => (2562890625, 8),\n+        16 => (4294967296, 8),\n+        _  => fail2!()\n+    }\n+}\n+\n /// A Sign is a `BigInt`'s composing element.\n #[deriving(Eq, Clone)]\n pub enum Sign { Minus, Zero, Plus }\n@@ -1077,26 +1175,111 @@ impl Integer for BigInt {\n     fn is_odd(&self) -> bool { self.data.is_odd() }\n }\n \n-impl IntConvertible for BigInt {\n+impl ToPrimitive for BigInt {\n+    #[inline]\n+    fn to_i64(&self) -> Option<i64> {\n+        match self.sign {\n+            Plus  => self.data.to_i64(),\n+            Zero  => Some(0),\n+            Minus => {\n+                do self.data.to_u64().and_then |n| {\n+                    let m: u64 = 1 << 63;\n+                    if n < m {\n+                        Some(-(n as i64))\n+                    } else if n == m {\n+                        Some(i64::min_value)\n+                    } else {\n+                        None\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     #[inline]\n-    fn to_int(&self) -> int {\n-        self.to_int_opt().expect(\"BigInt conversion would overflow int\")\n+    fn to_u64(&self) -> Option<u64> {\n+        match self.sign {\n+            Plus => self.data.to_u64(),\n+            Zero => Some(0),\n+            Minus => None\n+        }\n     }\n+}\n \n+impl FromPrimitive for BigInt {\n     #[inline]\n-    fn from_int(n: int) -> BigInt {\n+    fn from_i64(n: i64) -> Option<BigInt> {\n         if n > 0 {\n-           return BigInt::from_biguint(Plus,  BigUint::from_uint(n as uint));\n+            do FromPrimitive::from_u64(n as u64).and_then |n| {\n+                Some(BigInt::from_biguint(Plus, n))\n+            }\n+        } else if n < 0 {\n+            do FromPrimitive::from_u64(u64::max_value - (n as u64) + 1).and_then |n| {\n+                Some(BigInt::from_biguint(Minus, n))\n+            }\n+        } else {\n+            Some(Zero::zero())\n         }\n-        if n < 0 {\n-            return BigInt::from_biguint(\n-                Minus, BigUint::from_uint(uint::max_value - (n as uint) + 1)\n-            );\n+    }\n+\n+    #[inline]\n+    fn from_u64(n: u64) -> Option<BigInt> {\n+        if n == 0 {\n+            Some(Zero::zero())\n+        } else {\n+            do FromPrimitive::from_u64(n).and_then |n| {\n+                Some(BigInt::from_biguint(Plus, n))\n+            }\n         }\n-        return Zero::zero();\n     }\n }\n \n+/// A generic trait for converting a value to a `BigInt`.\n+pub trait ToBigInt {\n+    /// Converts the value of `self` to a `BigInt`.\n+    fn to_bigint(&self) -> Option<BigInt>;\n+}\n+\n+impl ToBigInt for BigInt {\n+    #[inline]\n+    fn to_bigint(&self) -> Option<BigInt> {\n+        Some(self.clone())\n+    }\n+}\n+\n+impl ToBigInt for BigUint {\n+    #[inline]\n+    fn to_bigint(&self) -> Option<BigInt> {\n+        if self.is_zero() {\n+            Some(Zero::zero())\n+        } else {\n+            Some(BigInt { sign: Plus, data: self.clone() })\n+        }\n+    }\n+}\n+\n+macro_rules! impl_to_bigint(\n+    ($T:ty, $from_ty:path) => {\n+        impl ToBigInt for $T {\n+            #[inline]\n+            fn to_bigint(&self) -> Option<BigInt> {\n+                $from_ty(*self)\n+            }\n+        }\n+    }\n+)\n+\n+impl_to_bigint!(int,  FromPrimitive::from_int)\n+impl_to_bigint!(i8,   FromPrimitive::from_i8)\n+impl_to_bigint!(i16,  FromPrimitive::from_i16)\n+impl_to_bigint!(i32,  FromPrimitive::from_i32)\n+impl_to_bigint!(i64,  FromPrimitive::from_i64)\n+impl_to_bigint!(uint, FromPrimitive::from_uint)\n+impl_to_bigint!(u8,   FromPrimitive::from_u8)\n+impl_to_bigint!(u16,  FromPrimitive::from_u16)\n+impl_to_bigint!(u32,  FromPrimitive::from_u32)\n+impl_to_bigint!(u64,  FromPrimitive::from_u64)\n+\n impl ToStrRadix for BigInt {\n     #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n@@ -1196,8 +1379,8 @@ impl<R: Rng> RandBigInt for R {\n                         ubound: &BigInt)\n                         -> BigInt {\n         assert!(*lbound < *ubound);\n-        let delta = (*ubound - *lbound).to_biguint();\n-        return *lbound + self.gen_biguint_below(&delta).to_bigint();\n+        let delta = (*ubound - *lbound).to_biguint().unwrap();\n+        return *lbound + self.gen_biguint_below(&delta).to_bigint().unwrap();\n     }\n }\n \n@@ -1217,13 +1400,6 @@ impl BigInt {\n         return BigInt { sign: sign, data: data };\n     }\n \n-    /// Creates and initializes a `BigInt`.\n-    #[inline]\n-    pub fn from_uint(n: uint) -> BigInt {\n-        if n == 0 { return Zero::zero(); }\n-        return BigInt::from_biguint(Plus, BigUint::from_uint(n));\n-    }\n-\n     /// Creates and initializes a `BigInt`.\n     #[inline]\n     pub fn from_slice(sign: Sign, slice: &[BigDigit]) -> BigInt {\n@@ -1244,51 +1420,9 @@ impl BigInt {\n             .map_move(|bu| BigInt::from_biguint(sign, bu));\n     }\n \n-    /// Converts this `BigInt` into a `uint`, failing if the conversion\n-    /// would overflow.\n-    #[inline]\n-    pub fn to_uint(&self) -> uint {\n-        self.to_uint_opt().expect(\"BigInt conversion would overflow uint\")\n-    }\n-\n-    /// Converts this `BigInt` into a `uint`, unless it would overflow.\n-    #[inline]\n-    pub fn to_uint_opt(&self) -> Option<uint> {\n-        match self.sign {\n-            Plus => self.data.to_uint_opt(),\n-            Zero => Some(0),\n-            Minus => None\n-        }\n-    }\n-\n-    /// Converts this `BigInt` into an `int`, unless it would overflow.\n-    pub fn to_int_opt(&self) -> Option<int> {\n-        match self.sign {\n-            Plus  => self.data.to_int_opt(),\n-            Zero  => Some(0),\n-            Minus => self.data.to_uint_opt().and_then(|n| {\n-                let m: uint = 1 << (2*BigDigit::bits-1);\n-                if (n > m) {\n-                    None\n-                } else if (n == m) {\n-                    Some(int::min_value)\n-                } else {\n-                    Some(-(n as int))\n-                }\n-            })\n-        }\n-    }\n-\n-    /// Converts this `BigInt` into a `BigUint`, failing if BigInt is\n-    /// negative.\n-    #[inline]\n-    pub fn to_biguint(&self) -> BigUint {\n-        self.to_biguint_opt().expect(\"negative BigInt cannot convert to BigUint\")\n-    }\n-\n     /// Converts this `BigInt` into a `BigUint`, if it's not negative.\n     #[inline]\n-    pub fn to_biguint_opt(&self) -> Option<BigUint> {\n+    pub fn to_biguint(&self) -> Option<BigUint> {\n         match self.sign {\n             Plus => Some(self.data.clone()),\n             Zero => Some(Zero::zero()),\n@@ -1299,15 +1433,15 @@ impl BigInt {\n \n #[cfg(test)]\n mod biguint_tests {\n-\n     use super::*;\n \n     use std::cmp::{Less, Equal, Greater};\n-    use std::int;\n-    use std::num::{IntConvertible, Zero, One, FromStrRadix};\n+    use std::i64;\n+    use std::num::{Zero, One, FromStrRadix};\n+    use std::num::{ToPrimitive, FromPrimitive};\n     use std::rand::{task_rng};\n     use std::str;\n-    use std::uint;\n+    use std::u64;\n     use std::vec;\n \n     #[test]\n@@ -1479,49 +1613,117 @@ mod biguint_tests {\n               \"88887777666655554444333322221111\");\n     }\n \n+    #[cfg(target_word_size = \"32\")]\n+    #[test]\n+    fn test_convert_i64() {\n+        fn check(b1: BigUint, i: i64) {\n+            let b2: BigUint = FromPrimitive::from_i64(i).unwrap();\n+            assert!(b1 == b2);\n+            assert!(b1.to_i64().unwrap() == i);\n+        }\n+\n+        check(Zero::zero(), 0);\n+        check(One::one(), 1);\n+        check(i64::max_value.to_biguint().unwrap(), i64::max_value);\n+\n+        check(BigUint::new(~[                   ]), 0);\n+        check(BigUint::new(~[ 1                 ]), (1 << (0*BigDigit::bits)));\n+        check(BigUint::new(~[-1                 ]), (1 << (1*BigDigit::bits)) - 1);\n+        check(BigUint::new(~[ 0,  1             ]), (1 << (1*BigDigit::bits)));\n+        check(BigUint::new(~[-1, -1             ]), (1 << (2*BigDigit::bits)) - 1);\n+        check(BigUint::new(~[ 0,  0,  1         ]), (1 << (2*BigDigit::bits)));\n+        check(BigUint::new(~[-1, -1, -1         ]), (1 << (3*BigDigit::bits)) - 1);\n+        check(BigUint::new(~[ 0,  0,  0,  1     ]), (1 << (3*BigDigit::bits)));\n+        check(BigUint::new(~[-1, -1, -1, -1 >> 1]), i64::max_value);\n+\n+        assert_eq!(i64::min_value.to_biguint(), None);\n+        assert_eq!(BigUint::new(~[-1, -1, -1, -1    ]).to_i64(), None);\n+        assert_eq!(BigUint::new(~[ 0,  0,  0,  0,  1]).to_i64(), None);\n+        assert_eq!(BigUint::new(~[-1, -1, -1, -1, -1]).to_i64(), None);\n+    }\n+\n+    #[cfg(target_word_size = \"64\")]\n     #[test]\n-    fn test_convert_int() {\n-        fn check(v: ~[BigDigit], i: int) {\n-            let b = BigUint::new(v);\n-            assert!(b == IntConvertible::from_int(i));\n-            assert!(b.to_int() == i);\n+    fn test_convert_i64() {\n+        fn check(b1: BigUint, i: i64) {\n+            let b2: BigUint = FromPrimitive::from_i64(i).unwrap();\n+            assert!(b1 == b2);\n+            assert!(b1.to_i64().unwrap() == i);\n         }\n \n-        check(~[], 0);\n-        check(~[1], 1);\n-        check(~[-1], (uint::max_value >> BigDigit::bits) as int);\n-        check(~[ 0,  1], ((uint::max_value >> BigDigit::bits) + 1) as int);\n-        check(~[-1, -1 >> 1], int::max_value);\n+        check(Zero::zero(), 0);\n+        check(One::one(), 1);\n+        check(i64::max_value.to_biguint().unwrap(), i64::max_value);\n \n-        assert_eq!(BigUint::new(~[0, -1]).to_int_opt(), None);\n-        assert_eq!(BigUint::new(~[0, 0, 1]).to_int_opt(), None);\n-        assert_eq!(BigUint::new(~[0, 0, -1]).to_int_opt(), None);\n+        check(BigUint::new(~[           ]), 0);\n+        check(BigUint::new(~[ 1         ]), (1 << (0*BigDigit::bits)));\n+        check(BigUint::new(~[-1         ]), (1 << (1*BigDigit::bits)) - 1);\n+        check(BigUint::new(~[ 0,  1     ]), (1 << (1*BigDigit::bits)));\n+        check(BigUint::new(~[-1, -1 >> 1]), i64::max_value);\n+\n+        assert_eq!(i64::min_value.to_biguint(), None);\n+        assert_eq!(BigUint::new(~[-1, -1    ]).to_i64(), None);\n+        assert_eq!(BigUint::new(~[ 0,  0,  1]).to_i64(), None);\n+        assert_eq!(BigUint::new(~[-1, -1, -1]).to_i64(), None);\n     }\n \n+    #[cfg(target_word_size = \"32\")]\n     #[test]\n-    fn test_convert_uint() {\n-        fn check(v: ~[BigDigit], u: uint) {\n-            let b = BigUint::new(v);\n-            assert!(b == BigUint::from_uint(u));\n-            assert!(b.to_uint() == u);\n+    fn test_convert_u64() {\n+        fn check(b1: BigUint, u: u64) {\n+            let b2: BigUint = FromPrimitive::from_u64(u).unwrap();\n+            assert!(b1 == b2);\n+            assert!(b1.to_u64().unwrap() == u);\n         }\n \n-        check(~[], 0);\n-        check(~[ 1], 1);\n-        check(~[-1], uint::max_value >> BigDigit::bits);\n-        check(~[ 0,  1], (uint::max_value >> BigDigit::bits) + 1);\n-        check(~[ 0, -1], uint::max_value << BigDigit::bits);\n-        check(~[-1, -1], uint::max_value);\n+        check(Zero::zero(), 0);\n+        check(One::one(), 1);\n+        check(u64::min_value.to_biguint().unwrap(), u64::min_value);\n+        check(u64::max_value.to_biguint().unwrap(), u64::max_value);\n+\n+        check(BigUint::new(~[              ]), 0);\n+        check(BigUint::new(~[ 1            ]), (1 << (0*BigDigit::bits)));\n+        check(BigUint::new(~[-1            ]), (1 << (1*BigDigit::bits)) - 1);\n+        check(BigUint::new(~[ 0,  1        ]), (1 << (1*BigDigit::bits)));\n+        check(BigUint::new(~[-1, -1        ]), (1 << (2*BigDigit::bits)) - 1);\n+        check(BigUint::new(~[ 0,  0,  1    ]), (1 << (2*BigDigit::bits)));\n+        check(BigUint::new(~[-1, -1, -1    ]), (1 << (3*BigDigit::bits)) - 1);\n+        check(BigUint::new(~[ 0,  0,  0,  1]), (1 << (3*BigDigit::bits)));\n+        check(BigUint::new(~[-1, -1, -1, -1]), u64::max_value);\n \n-        assert_eq!(BigUint::new(~[0, 0, 1]).to_uint_opt(), None);\n-        assert_eq!(BigUint::new(~[0, 0, -1]).to_uint_opt(), None);\n+        assert_eq!(BigUint::new(~[ 0,  0,  0,  0,  1]).to_u64(), None);\n+        assert_eq!(BigUint::new(~[-1, -1, -1, -1, -1]).to_u64(), None);\n+    }\n+\n+    #[cfg(target_word_size = \"64\")]\n+    #[test]\n+    fn test_convert_u64() {\n+        fn check(b1: BigUint, u: u64) {\n+            let b2: BigUint = FromPrimitive::from_u64(u).unwrap();\n+            assert!(b1 == b2);\n+            assert!(b1.to_u64().unwrap() == u);\n+        }\n+\n+        check(Zero::zero(), 0);\n+        check(One::one(), 1);\n+        check(u64::min_value.to_biguint().unwrap(), u64::min_value);\n+        check(u64::max_value.to_biguint().unwrap(), u64::max_value);\n+\n+        check(BigUint::new(~[      ]), 0);\n+        check(BigUint::new(~[ 1    ]), (1 << (0*BigDigit::bits)));\n+        check(BigUint::new(~[-1    ]), (1 << (1*BigDigit::bits)) - 1);\n+        check(BigUint::new(~[ 0,  1]), (1 << (1*BigDigit::bits)));\n+        check(BigUint::new(~[-1, -1]), u64::max_value);\n+\n+        assert_eq!(BigUint::new(~[ 0,  0,  1]).to_u64(), None);\n+        assert_eq!(BigUint::new(~[-1, -1, -1]).to_u64(), None);\n     }\n \n     #[test]\n     fn test_convert_to_bigint() {\n         fn check(n: BigUint, ans: BigInt) {\n-            assert_eq!(n.to_bigint(), ans);\n-            assert_eq!(n.to_bigint().to_biguint(), n);\n+            assert_eq!(n.to_bigint().unwrap(), ans);\n+            assert_eq!(n.to_bigint().unwrap().to_biguint().unwrap(), n);\n         }\n         check(Zero::zero(), Zero::zero());\n         check(BigUint::new(~[1,2,3]),\n@@ -1660,9 +1862,9 @@ mod biguint_tests {\n     #[test]\n     fn test_gcd() {\n         fn check(a: uint, b: uint, c: uint) {\n-            let big_a = BigUint::from_uint(a);\n-            let big_b = BigUint::from_uint(b);\n-            let big_c = BigUint::from_uint(c);\n+            let big_a: BigUint = FromPrimitive::from_uint(a).unwrap();\n+            let big_b: BigUint = FromPrimitive::from_uint(b).unwrap();\n+            let big_c: BigUint = FromPrimitive::from_uint(c).unwrap();\n \n             assert_eq!(big_a.gcd(&big_b), big_c);\n         }\n@@ -1677,9 +1879,9 @@ mod biguint_tests {\n     #[test]\n     fn test_lcm() {\n         fn check(a: uint, b: uint, c: uint) {\n-            let big_a = BigUint::from_uint(a);\n-            let big_b = BigUint::from_uint(b);\n-            let big_c = BigUint::from_uint(c);\n+            let big_a: BigUint = FromPrimitive::from_uint(a).unwrap();\n+            let big_b: BigUint = FromPrimitive::from_uint(b).unwrap();\n+            let big_c: BigUint = FromPrimitive::from_uint(c).unwrap();\n \n             assert_eq!(big_a.lcm(&big_b), big_c);\n         }\n@@ -1694,20 +1896,18 @@ mod biguint_tests {\n \n     #[test]\n     fn test_is_even() {\n-        let one: Option<BigUint> = FromStr::from_str(\"1\");\n-        let two: Option<BigUint> = FromStr::from_str(\"2\");\n-        let thousand: Option<BigUint> = FromStr::from_str(\"1000\");\n-        let big: Option<BigUint> =\n-            FromStr::from_str(\"1000000000000000000000\");\n-        let bigger: Option<BigUint> =\n-            FromStr::from_str(\"1000000000000000000001\");\n-        assert!(one.unwrap().is_odd());\n-        assert!(two.unwrap().is_even());\n-        assert!(thousand.unwrap().is_even());\n-        assert!(big.unwrap().is_even());\n-        assert!(bigger.unwrap().is_odd());\n-        assert!((BigUint::from_uint(1) << 64).is_even());\n-        assert!(((BigUint::from_uint(1) << 64) + BigUint::from_uint(1)).is_odd());\n+        let one: BigUint = FromStr::from_str(\"1\").unwrap();\n+        let two: BigUint = FromStr::from_str(\"2\").unwrap();\n+        let thousand: BigUint = FromStr::from_str(\"1000\").unwrap();\n+        let big: BigUint = FromStr::from_str(\"1000000000000000000000\").unwrap();\n+        let bigger: BigUint = FromStr::from_str(\"1000000000000000000001\").unwrap();\n+        assert!(one.is_odd());\n+        assert!(two.is_even());\n+        assert!(thousand.is_even());\n+        assert!(big.is_even());\n+        assert!(bigger.is_odd());\n+        assert!((one << 64).is_even());\n+        assert!(((one << 64) + one).is_odd());\n     }\n \n     fn to_str_pairs() -> ~[ (BigUint, ~[(uint, ~str)]) ] {\n@@ -1805,8 +2005,8 @@ mod biguint_tests {\n             let mut f: BigUint = One::one();\n             for i in range(2, n + 1) {\n                 // FIXME(#6102): Assignment operator for BigInt causes ICE\n-                // f *= BigUint::from_uint(i);\n-                f = f * BigUint::from_uint(i);\n+                // f *= FromPrimitive::from_uint(i);\n+                f = f * FromPrimitive::from_uint(i).unwrap();\n             }\n             return f;\n         }\n@@ -1828,9 +2028,12 @@ mod biguint_tests {\n     #[test]\n     fn test_bits() {\n         assert_eq!(BigUint::new(~[0,0,0,0]).bits(), 0);\n-        assert_eq!(BigUint::from_uint(0).bits(), 0);\n-        assert_eq!(BigUint::from_uint(1).bits(), 1);\n-        assert_eq!(BigUint::from_uint(3).bits(), 2);\n+        let n: BigUint = FromPrimitive::from_uint(0).unwrap();\n+        assert_eq!(n.bits(), 0);\n+        let n: BigUint = FromPrimitive::from_uint(1).unwrap();\n+        assert_eq!(n.bits(), 1);\n+        let n: BigUint = FromPrimitive::from_uint(3).unwrap();\n+        assert_eq!(n.bits(), 2);\n         let n: BigUint = FromStrRadix::from_str_radix(\"4000000000\", 16).unwrap();\n         assert_eq!(n.bits(), 39);\n         let one: BigUint = One::one();\n@@ -1849,13 +2052,13 @@ mod biguint_tests {\n         let mut rng = task_rng();\n \n         do 10.times {\n-            assert_eq!(rng.gen_bigint_range(&BigInt::from_uint(236),\n-                                            &BigInt::from_uint(237)),\n-                       BigInt::from_uint(236));\n+            assert_eq!(rng.gen_bigint_range(&FromPrimitive::from_uint(236).unwrap(),\n+                                            &FromPrimitive::from_uint(237).unwrap()),\n+                       FromPrimitive::from_uint(236).unwrap());\n         }\n \n-        let l = BigUint::from_uint(403469000 + 2352);\n-        let u = BigUint::from_uint(403469000 + 3513);\n+        let l = FromPrimitive::from_uint(403469000 + 2352).unwrap();\n+        let u = FromPrimitive::from_uint(403469000 + 3513).unwrap();\n         do 1000.times {\n             let n: BigUint = rng.gen_biguint_below(&u);\n             assert!(n < u);\n@@ -1869,16 +2072,16 @@ mod biguint_tests {\n     #[test]\n     #[should_fail]\n     fn test_zero_rand_range() {\n-        task_rng().gen_biguint_range(&BigUint::from_uint(54),\n-                                     &BigUint::from_uint(54));\n+        task_rng().gen_biguint_range(&FromPrimitive::from_uint(54).unwrap(),\n+                                     &FromPrimitive::from_uint(54).unwrap());\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_negative_rand_range() {\n         let mut rng = task_rng();\n-        let l = BigUint::from_uint(2352);\n-        let u = BigUint::from_uint(3513);\n+        let l = FromPrimitive::from_uint(2352).unwrap();\n+        let u = FromPrimitive::from_uint(3513).unwrap();\n         // Switching u and l should fail:\n         let _n: BigUint = rng.gen_biguint_range(&u, &l);\n     }\n@@ -1889,16 +2092,17 @@ mod bigint_tests {\n     use super::*;\n \n     use std::cmp::{Less, Equal, Greater};\n-    use std::int;\n-    use std::num::{IntConvertible, Zero, One, FromStrRadix};\n+    use std::i64;\n+    use std::num::{Zero, One, FromStrRadix};\n+    use std::num::{ToPrimitive, FromPrimitive};\n     use std::rand::{task_rng};\n-    use std::uint;\n+    use std::u64;\n \n     #[test]\n     fn test_from_biguint() {\n         fn check(inp_s: Sign, inp_n: uint, ans_s: Sign, ans_n: uint) {\n-            let inp = BigInt::from_biguint(inp_s, BigUint::from_uint(inp_n));\n-            let ans = BigInt { sign: ans_s, data: BigUint::from_uint(ans_n)};\n+            let inp = BigInt::from_biguint(inp_s, FromPrimitive::from_uint(inp_n).unwrap());\n+            let ans = BigInt { sign: ans_s, data: FromPrimitive::from_uint(ans_n).unwrap()};\n             assert_eq!(inp, ans);\n         }\n         check(Plus, 1, Plus, 1);\n@@ -1951,62 +2155,62 @@ mod bigint_tests {\n     }\n \n     #[test]\n-    fn test_convert_int() {\n-        fn check(b: BigInt, i: int) {\n-            assert!(b == IntConvertible::from_int(i));\n-            assert!(b.to_int() == i);\n+    fn test_convert_i64() {\n+        fn check(b1: BigInt, i: i64) {\n+            let b2: BigInt = FromPrimitive::from_i64(i).unwrap();\n+            assert!(b1 == b2);\n+            assert!(b1.to_i64().unwrap() == i);\n         }\n \n         check(Zero::zero(), 0);\n         check(One::one(), 1);\n-        check(BigInt::from_biguint(\n-            Plus, BigUint::from_uint(int::max_value as uint)\n-        ), int::max_value);\n-\n-        assert_eq!(BigInt::from_biguint(\n-            Plus, BigUint::from_uint(int::max_value as uint + 1)\n-        ).to_int_opt(), None);\n-        assert_eq!(BigInt::from_biguint(\n-            Plus, BigUint::new(~[1, 2, 3])\n-        ).to_int_opt(), None);\n-\n-        check(BigInt::from_biguint(\n-            Minus, BigUint::new(~[0, 1<<(BigDigit::bits-1)])\n-        ), int::min_value);\n-        assert_eq!(BigInt::from_biguint(\n-            Minus, BigUint::new(~[1, 1<<(BigDigit::bits-1)])\n-        ).to_int_opt(), None);\n-        assert_eq!(BigInt::from_biguint(\n-            Minus, BigUint::new(~[1, 2, 3])).to_int_opt(), None);\n+        check(i64::min_value.to_bigint().unwrap(), i64::min_value);\n+        check(i64::max_value.to_bigint().unwrap(), i64::max_value);\n+\n+        assert_eq!(\n+            (i64::max_value as u64 + 1).to_bigint().unwrap().to_i64(),\n+            None);\n+\n+        assert_eq!(\n+            BigInt::from_biguint(Plus,  BigUint::new(~[1, 2, 3, 4, 5])).to_i64(),\n+            None);\n+\n+        assert_eq!(\n+            BigInt::from_biguint(Minus, BigUint::new(~[1, 0, 0, 1<<(BigDigit::bits-1)])).to_i64(),\n+            None);\n+\n+        assert_eq!(\n+            BigInt::from_biguint(Minus, BigUint::new(~[1, 2, 3, 4, 5])).to_i64(),\n+            None);\n     }\n \n     #[test]\n-    fn test_convert_uint() {\n-        fn check(b: BigInt, u: uint) {\n-            assert!(b == BigInt::from_uint(u));\n-            assert!(b.to_uint() == u);\n+    fn test_convert_u64() {\n+        fn check(b1: BigInt, u: u64) {\n+            let b2: BigInt = FromPrimitive::from_u64(u).unwrap();\n+            assert!(b1 == b2);\n+            assert!(b1.to_u64().unwrap() == u);\n         }\n \n         check(Zero::zero(), 0);\n         check(One::one(), 1);\n+        check(u64::min_value.to_bigint().unwrap(), u64::min_value);\n+        check(u64::max_value.to_bigint().unwrap(), u64::max_value);\n \n-        check(\n-            BigInt::from_biguint(Plus, BigUint::from_uint(uint::max_value)),\n-            uint::max_value);\n-        assert_eq!(BigInt::from_biguint(\n-            Plus, BigUint::new(~[1, 2, 3])).to_uint_opt(), None);\n+        assert_eq!(\n+            BigInt::from_biguint(Plus, BigUint::new(~[1, 2, 3, 4, 5])).to_u64(),\n+            None);\n \n-        assert_eq!(BigInt::from_biguint(\n-            Minus, BigUint::from_uint(uint::max_value)).to_uint_opt(), None);\n-        assert_eq!(BigInt::from_biguint(\n-            Minus, BigUint::new(~[1, 2, 3])).to_uint_opt(), None);\n+        let max_value: BigUint = FromPrimitive::from_u64(u64::max_value).unwrap();\n+        assert_eq!(BigInt::from_biguint(Minus, max_value).to_u64(), None);\n+        assert_eq!(BigInt::from_biguint(Minus, BigUint::new(~[1, 2, 3, 4, 5])).to_u64(), None);\n     }\n \n     #[test]\n     fn test_convert_to_biguint() {\n         fn check(n: BigInt, ans_1: BigUint) {\n-            assert_eq!(n.to_biguint(), ans_1);\n-            assert_eq!(n.to_biguint().to_bigint(), n);\n+            assert_eq!(n.to_biguint().unwrap(), ans_1);\n+            assert_eq!(n.to_biguint().unwrap().to_bigint().unwrap(), n);\n         }\n         let zero: BigInt = Zero::zero();\n         let unsigned_zero: BigUint = Zero::zero();\n@@ -2017,7 +2221,7 @@ mod bigint_tests {\n         check(zero, unsigned_zero);\n         check(positive, BigUint::new(~[1,2,3]));\n \n-        assert_eq!(negative.to_biguint_opt(), None);\n+        assert_eq!(negative.to_biguint(), None);\n     }\n \n     static sum_triples: &'static [(&'static [BigDigit],\n@@ -2233,9 +2437,9 @@ mod bigint_tests {\n     #[test]\n     fn test_gcd() {\n         fn check(a: int, b: int, c: int) {\n-            let big_a: BigInt = IntConvertible::from_int(a);\n-            let big_b: BigInt = IntConvertible::from_int(b);\n-            let big_c: BigInt = IntConvertible::from_int(c);\n+            let big_a: BigInt = FromPrimitive::from_int(a).unwrap();\n+            let big_b: BigInt = FromPrimitive::from_int(b).unwrap();\n+            let big_c: BigInt = FromPrimitive::from_int(c).unwrap();\n \n             assert_eq!(big_a.gcd(&big_b), big_c);\n         }\n@@ -2253,9 +2457,9 @@ mod bigint_tests {\n     #[test]\n     fn test_lcm() {\n         fn check(a: int, b: int, c: int) {\n-            let big_a: BigInt = IntConvertible::from_int(a);\n-            let big_b: BigInt = IntConvertible::from_int(b);\n-            let big_c: BigInt = IntConvertible::from_int(c);\n+            let big_a: BigInt = FromPrimitive::from_int(a).unwrap();\n+            let big_b: BigInt = FromPrimitive::from_int(b).unwrap();\n+            let big_c: BigInt = FromPrimitive::from_int(c).unwrap();\n \n             assert_eq!(big_a.lcm(&big_b), big_c);\n         }\n@@ -2282,13 +2486,14 @@ mod bigint_tests {\n         let zero: BigInt = Zero::zero();\n         assert_eq!(one.abs_sub(&zero), one);\n         let one: BigInt = One::one();\n-        assert_eq!(one.abs_sub(&-one), IntConvertible::from_int(2));\n+        let two: BigInt = FromPrimitive::from_int(2).unwrap();\n+        assert_eq!(one.abs_sub(&-one), two);\n     }\n \n     #[test]\n     fn test_to_str_radix() {\n         fn check(n: int, ans: &str) {\n-            let n: BigInt = IntConvertible::from_int(n);\n+            let n: BigInt = FromPrimitive::from_int(n).unwrap();\n             assert!(ans == n.to_str_radix(10));\n         }\n         check(10, \"10\");\n@@ -2303,7 +2508,7 @@ mod bigint_tests {\n     fn test_from_str_radix() {\n         fn check(s: &str, ans: Option<int>) {\n             let ans = ans.map_move(|n| {\n-                let x: BigInt = IntConvertible::from_int(n);\n+                let x: BigInt = FromPrimitive::from_int(n).unwrap();\n                 x\n             });\n             assert_eq!(FromStrRadix::from_str_radix(s, 10), ans);\n@@ -2339,9 +2544,9 @@ mod bigint_tests {\n         let mut rng = task_rng();\n \n         do 10.times {\n-            assert_eq!(rng.gen_bigint_range(&BigInt::from_uint(236),\n-                                            &BigInt::from_uint(237)),\n-                       BigInt::from_uint(236));\n+            assert_eq!(rng.gen_bigint_range(&FromPrimitive::from_uint(236).unwrap(),\n+                                            &FromPrimitive::from_uint(237).unwrap()),\n+                       FromPrimitive::from_uint(236).unwrap());\n         }\n \n         fn check(l: BigInt, u: BigInt) {\n@@ -2352,8 +2557,8 @@ mod bigint_tests {\n                 assert!(n < u);\n             }\n         }\n-        let l = BigInt::from_uint(403469000 + 2352);\n-        let u = BigInt::from_uint(403469000 + 3513);\n+        let l: BigInt = FromPrimitive::from_uint(403469000 + 2352).unwrap();\n+        let u: BigInt = FromPrimitive::from_uint(403469000 + 3513).unwrap();\n         check( l.clone(),  u.clone());\n         check(-l.clone(),  u.clone());\n         check(-u.clone(), -l.clone());\n@@ -2362,16 +2567,16 @@ mod bigint_tests {\n     #[test]\n     #[should_fail]\n     fn test_zero_rand_range() {\n-        task_rng().gen_bigint_range(&IntConvertible::from_int(54),\n-                                    &IntConvertible::from_int(54));\n+        task_rng().gen_bigint_range(&FromPrimitive::from_int(54).unwrap(),\n+                                    &FromPrimitive::from_int(54).unwrap());\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_negative_rand_range() {\n         let mut rng = task_rng();\n-        let l = BigInt::from_uint(2352);\n-        let u = BigInt::from_uint(3513);\n+        let l = FromPrimitive::from_uint(2352).unwrap();\n+        let u = FromPrimitive::from_uint(3513).unwrap();\n         // Switching u and l should fail:\n         let _n: BigInt = rng.gen_bigint_range(&u, &l);\n     }\n@@ -2381,13 +2586,13 @@ mod bigint_tests {\n mod bench {\n     use super::*;\n     use std::{iter, util};\n-    use std::num::{Zero, One};\n+    use std::num::{FromPrimitive, Zero, One};\n     use extra::test::BenchHarness;\n \n     fn factorial(n: uint) -> BigUint {\n         let mut f: BigUint = One::one();\n         for i in iter::range_inclusive(1, n) {\n-            f = f * BigUint::from_uint(i);\n+            f = f * FromPrimitive::from_uint(i).unwrap();\n         }\n         f\n     }"}, {"sha": "a8dfdfbfd0018d8d118d014296ecbb6c890c29b8", "filename": "src/libextra/num/rational.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibextra%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibextra%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Frational.rs?ref=2733b189ac60cea541fbf80e5839e5027ffc9fbf", "patch": "@@ -306,7 +306,7 @@ impl<T: FromStrRadix + Clone + Integer + Ord>\n mod test {\n \n     use super::*;\n-    use std::num::{Zero,One,FromStrRadix,IntConvertible};\n+    use std::num::{Zero,One,FromStrRadix,FromPrimitive};\n     use std::from_str::FromStr;\n \n     pub static _0 : Rational = Ratio { numer: 0, denom: 1};\n@@ -318,8 +318,8 @@ mod test {\n \n     pub fn to_big(n: Rational) -> BigRational {\n         Ratio::new(\n-            IntConvertible::from_int(n.numer),\n-            IntConvertible::from_int(n.denom)\n+            FromPrimitive::from_int(n.numer).unwrap(),\n+            FromPrimitive::from_int(n.denom).unwrap()\n         )\n     }\n "}, {"sha": "52695100b3ee755baef9aaf4a422640fc78086da", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=2733b189ac60cea541fbf80e5839e5027ffc9fbf", "patch": "@@ -107,7 +107,7 @@ use std::hashmap::HashMap;\n use std::libc::{c_uint, c_ulonglong, c_longlong};\n use std::ptr;\n use std::vec;\n-use syntax::codemap::Span;\n+use syntax::codemap::{Span, Pos};\n use syntax::{ast, codemap, ast_util, ast_map, opt_vec, visit};\n use syntax::parse::token;\n use syntax::parse::token::special_idents;"}, {"sha": "d5219ed0867483ab39d581755d727884e7236e9b", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=2733b189ac60cea541fbf80e5839e5027ffc9fbf", "patch": "@@ -26,7 +26,7 @@ use middle::ty;\n use middle::typeck;\n use syntax::abi::AbiSet;\n use syntax::ast_map;\n-use syntax::codemap::Span;\n+use syntax::codemap::{Span, Pos};\n use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::{ast, ast_util};"}, {"sha": "2b4a636e1ad94927c64397d39d68d7660cf5ae70", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=2733b189ac60cea541fbf80e5839e5027ffc9fbf", "patch": "@@ -590,6 +590,9 @@ impl Primitive for f32 {\n \n     #[inline]\n     fn bytes(_: Option<f32>) -> uint { Primitive::bits(Some(0f32)) / 8 }\n+\n+    #[inline]\n+    fn is_signed(_: Option<f32>) -> bool { true }\n }\n \n impl Float for f32 {"}, {"sha": "d4442e5b34fabcdf671eadefc984941891495d00", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=2733b189ac60cea541fbf80e5839e5027ffc9fbf", "patch": "@@ -638,6 +638,9 @@ impl Primitive for f64 {\n \n     #[inline]\n     fn bytes(_: Option<f64>) -> uint { Primitive::bits(Some(0f64)) / 8 }\n+\n+    #[inline]\n+    fn is_signed(_: Option<f64>) -> bool { true }\n }\n \n impl Float for f64 {"}, {"sha": "7fae567809b012c2f315d0de8b67e6e7dc5c906d", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=2733b189ac60cea541fbf80e5839e5027ffc9fbf", "patch": "@@ -380,6 +380,9 @@ impl Primitive for $T {\n \n     #[inline]\n     fn bytes(_: Option<$T>) -> uint { bits / 8 }\n+\n+    #[inline]\n+    fn is_signed(_: Option<$T>) -> bool { true }\n }\n \n // String conversion functions and impl str -> num"}, {"sha": "fde1928f4a3221a3f5a66300a1cb2dda8dbdcd0d", "filename": "src/libstd/num/num.rs", "status": "modified", "additions": 869, "deletions": 84, "changes": 953, "blob_url": "https://github.com/rust-lang/rust/blob/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibstd%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibstd%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fnum.rs?ref=2733b189ac60cea541fbf80e5839e5027ffc9fbf", "patch": "@@ -32,11 +32,6 @@ pub trait Num: Eq + Zero + One\n              + Div<Self,Self>\n              + Rem<Self,Self> {}\n \n-pub trait IntConvertible {\n-    fn to_int(&self) -> int;\n-    fn from_int(n: int) -> Self;\n-}\n-\n pub trait Orderable: Ord {\n     // These should be methods on `Ord`, with overridable default implementations. We don't want\n     // to encumber all implementors of Ord by requiring them to implement these functions, but at\n@@ -291,6 +286,7 @@ pub trait Primitive: Clone\n     // FIXME (#8888): Removing `unused_self` requires #8888 to be fixed.\n     fn bits(unused_self: Option<Self>) -> uint;\n     fn bytes(unused_self: Option<Self>) -> uint;\n+    fn is_signed(unused_self: Option<Self>) -> bool;\n }\n \n /// A collection of traits relevant to primitive signed and unsigned integers\n@@ -353,6 +349,448 @@ pub trait Float: Real\n #[inline(always)] pub fn ln_1p<T: Float>(value: T) -> T { value.ln_1p() }\n #[inline(always)] pub fn mul_add<T: Float>(a: T, b: T, c: T) -> T { a.mul_add(b, c) }\n \n+/// A generic trait for converting a value to a number.\n+pub trait ToPrimitive {\n+    /// Converts the value of `self` to an `int`.\n+    #[inline]\n+    fn to_int(&self) -> Option<int> {\n+        self.to_i64().and_then(|x| x.to_int())\n+    }\n+\n+    /// Converts the value of `self` to an `i8`.\n+    #[inline]\n+    fn to_i8(&self) -> Option<i8> {\n+        self.to_i64().and_then(|x| x.to_i8())\n+    }\n+\n+    /// Converts the value of `self` to an `i16`.\n+    #[inline]\n+    fn to_i16(&self) -> Option<i16> {\n+        self.to_i64().and_then(|x| x.to_i16())\n+    }\n+\n+    /// Converts the value of `self` to an `i32`.\n+    #[inline]\n+    fn to_i32(&self) -> Option<i32> {\n+        self.to_i64().and_then(|x| x.to_i32())\n+    }\n+\n+    /// Converts the value of `self` to an `i64`.\n+    fn to_i64(&self) -> Option<i64>;\n+\n+    /// Converts the value of `self` to an `uint`.\n+    #[inline]\n+    fn to_uint(&self) -> Option<uint> {\n+        self.to_u64().and_then(|x| x.to_uint())\n+    }\n+\n+    /// Converts the value of `self` to an `u8`.\n+    #[inline]\n+    fn to_u8(&self) -> Option<u8> {\n+        self.to_u64().and_then(|x| x.to_u8())\n+    }\n+\n+    /// Converts the value of `self` to an `u16`.\n+    #[inline]\n+    fn to_u16(&self) -> Option<u16> {\n+        self.to_u64().and_then(|x| x.to_u16())\n+    }\n+\n+    /// Converts the value of `self` to an `u32`.\n+    #[inline]\n+    fn to_u32(&self) -> Option<u32> {\n+        self.to_u64().and_then(|x| x.to_u32())\n+    }\n+\n+    /// Converts the value of `self` to an `u64`.\n+    #[inline]\n+    fn to_u64(&self) -> Option<u64> {\n+        self.to_u64().and_then(|x| x.to_u64())\n+    }\n+\n+    /// Converts the value of `self` to an `f32`.\n+    #[inline]\n+    fn to_f32(&self) -> Option<f32> {\n+        self.to_f64().and_then(|x| x.to_f32())\n+    }\n+\n+    /// Converts the value of `self` to an `f64`.\n+    #[inline]\n+    fn to_f64(&self) -> Option<f64> {\n+        self.to_i64().and_then(|x| x.to_f64())\n+    }\n+}\n+\n+macro_rules! impl_to_primitive_int_to_int(\n+    ($SrcT:ty, $DstT:ty) => (\n+        {\n+            if Primitive::bits(None::<$SrcT>) <= Primitive::bits(None::<$DstT>) {\n+                Some(*self as $DstT)\n+            } else {\n+                let n = *self as i64;\n+                let min_value: $DstT = Bounded::min_value();\n+                let max_value: $DstT = Bounded::max_value();\n+                if min_value as i64 <= n && n <= max_value as i64 {\n+                    Some(*self as $DstT)\n+                } else {\n+                    None\n+                }\n+            }\n+        }\n+    )\n+)\n+\n+macro_rules! impl_to_primitive_int_to_uint(\n+    ($SrcT:ty, $DstT:ty) => (\n+        {\n+            let zero: $SrcT = Zero::zero();\n+            let max_value: $DstT = Bounded::max_value();\n+            if zero <= *self && *self as u64 <= max_value as u64 {\n+                Some(*self as $DstT)\n+            } else {\n+                None\n+            }\n+        }\n+    )\n+)\n+\n+macro_rules! impl_to_primitive_int(\n+    ($T:ty) => (\n+        impl ToPrimitive for $T {\n+            #[inline]\n+            fn to_int(&self) -> Option<int> { impl_to_primitive_int_to_int!($T, int) }\n+            #[inline]\n+            fn to_i8(&self) -> Option<i8> { impl_to_primitive_int_to_int!($T, i8) }\n+            #[inline]\n+            fn to_i16(&self) -> Option<i16> { impl_to_primitive_int_to_int!($T, i16) }\n+            #[inline]\n+            fn to_i32(&self) -> Option<i32> { impl_to_primitive_int_to_int!($T, i32) }\n+            #[inline]\n+            fn to_i64(&self) -> Option<i64> { impl_to_primitive_int_to_int!($T, i64) }\n+\n+            #[inline]\n+            fn to_uint(&self) -> Option<uint> { impl_to_primitive_int_to_uint!($T, uint) }\n+            #[inline]\n+            fn to_u8(&self) -> Option<u8> { impl_to_primitive_int_to_uint!($T, u8) }\n+            #[inline]\n+            fn to_u16(&self) -> Option<u16> { impl_to_primitive_int_to_uint!($T, u16) }\n+            #[inline]\n+            fn to_u32(&self) -> Option<u32> { impl_to_primitive_int_to_uint!($T, u32) }\n+            #[inline]\n+            fn to_u64(&self) -> Option<u64> { impl_to_primitive_int_to_uint!($T, u64) }\n+\n+            #[inline]\n+            fn to_f32(&self) -> Option<f32> { Some(*self as f32) }\n+            #[inline]\n+            fn to_f64(&self) -> Option<f64> { Some(*self as f64) }\n+        }\n+    )\n+)\n+\n+impl_to_primitive_int!(int)\n+impl_to_primitive_int!(i8)\n+impl_to_primitive_int!(i16)\n+impl_to_primitive_int!(i32)\n+impl_to_primitive_int!(i64)\n+\n+macro_rules! impl_to_primitive_uint_to_int(\n+    ($DstT:ty) => (\n+        {\n+            let max_value: $DstT = Bounded::max_value();\n+            if *self as u64 <= max_value as u64 {\n+                Some(*self as $DstT)\n+            } else {\n+                None\n+            }\n+        }\n+    )\n+)\n+\n+macro_rules! impl_to_primitive_uint_to_uint(\n+    ($SrcT:ty, $DstT:ty) => (\n+        {\n+            if Primitive::bits(None::<$SrcT>) <= Primitive::bits(None::<$DstT>) {\n+                Some(*self as $DstT)\n+            } else {\n+                let zero: $SrcT = Zero::zero();\n+                let max_value: $DstT = Bounded::max_value();\n+                if zero <= *self && *self as u64 <= max_value as u64 {\n+                    Some(*self as $DstT)\n+                } else {\n+                    None\n+                }\n+            }\n+        }\n+    )\n+)\n+\n+macro_rules! impl_to_primitive_uint(\n+    ($T:ty) => (\n+        impl ToPrimitive for $T {\n+            #[inline]\n+            fn to_int(&self) -> Option<int> { impl_to_primitive_uint_to_int!(int) }\n+            #[inline]\n+            fn to_i8(&self) -> Option<i8> { impl_to_primitive_uint_to_int!(i8) }\n+            #[inline]\n+            fn to_i16(&self) -> Option<i16> { impl_to_primitive_uint_to_int!(i16) }\n+            #[inline]\n+            fn to_i32(&self) -> Option<i32> { impl_to_primitive_uint_to_int!(i32) }\n+            #[inline]\n+            fn to_i64(&self) -> Option<i64> { impl_to_primitive_uint_to_int!(i64) }\n+\n+            #[inline]\n+            fn to_uint(&self) -> Option<uint> { impl_to_primitive_uint_to_uint!($T, uint) }\n+            #[inline]\n+            fn to_u8(&self) -> Option<u8> { impl_to_primitive_uint_to_uint!($T, u8) }\n+            #[inline]\n+            fn to_u16(&self) -> Option<u16> { impl_to_primitive_uint_to_uint!($T, u16) }\n+            #[inline]\n+            fn to_u32(&self) -> Option<u32> { impl_to_primitive_uint_to_uint!($T, u32) }\n+            #[inline]\n+            fn to_u64(&self) -> Option<u64> { impl_to_primitive_uint_to_uint!($T, u64) }\n+\n+            #[inline]\n+            fn to_f32(&self) -> Option<f32> { Some(*self as f32) }\n+            #[inline]\n+            fn to_f64(&self) -> Option<f64> { Some(*self as f64) }\n+        }\n+    )\n+)\n+\n+impl_to_primitive_uint!(uint)\n+impl_to_primitive_uint!(u8)\n+impl_to_primitive_uint!(u16)\n+impl_to_primitive_uint!(u32)\n+impl_to_primitive_uint!(u64)\n+\n+macro_rules! impl_to_primitive_float_to_float(\n+    ($SrcT:ty, $DstT:ty) => (\n+        if Primitive::bits(None::<$SrcT>) <= Primitive::bits(None::<$DstT>) {\n+            Some(*self as $DstT)\n+        } else {\n+            let n = *self as f64;\n+            let min_value: $SrcT = Bounded::min_value();\n+            let max_value: $SrcT = Bounded::max_value();\n+            if min_value as f64 <= n && n <= max_value as f64 {\n+                Some(*self as $DstT)\n+            } else {\n+                None\n+            }\n+        }\n+    )\n+)\n+\n+macro_rules! impl_to_primitive_float(\n+    ($T:ty) => (\n+        impl ToPrimitive for $T {\n+            #[inline]\n+            fn to_int(&self) -> Option<int> { Some(*self as int) }\n+            #[inline]\n+            fn to_i8(&self) -> Option<i8> { Some(*self as i8) }\n+            #[inline]\n+            fn to_i16(&self) -> Option<i16> { Some(*self as i16) }\n+            #[inline]\n+            fn to_i32(&self) -> Option<i32> { Some(*self as i32) }\n+            #[inline]\n+            fn to_i64(&self) -> Option<i64> { Some(*self as i64) }\n+\n+            #[inline]\n+            fn to_uint(&self) -> Option<uint> { Some(*self as uint) }\n+            #[inline]\n+            fn to_u8(&self) -> Option<u8> { Some(*self as u8) }\n+            #[inline]\n+            fn to_u16(&self) -> Option<u16> { Some(*self as u16) }\n+            #[inline]\n+            fn to_u32(&self) -> Option<u32> { Some(*self as u32) }\n+            #[inline]\n+            fn to_u64(&self) -> Option<u64> { Some(*self as u64) }\n+\n+            #[inline]\n+            fn to_f32(&self) -> Option<f32> { impl_to_primitive_float_to_float!($T, f32) }\n+            #[inline]\n+            fn to_f64(&self) -> Option<f64> { impl_to_primitive_float_to_float!($T, f64) }\n+        }\n+    )\n+)\n+\n+impl_to_primitive_float!(f32)\n+impl_to_primitive_float!(f64)\n+\n+/// A generic trait for converting a number to a value.\n+pub trait FromPrimitive {\n+    /// Convert an `int` to return an optional value of this type. If the\n+    /// value cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_int(n: int) -> Option<Self> {\n+        FromPrimitive::from_i64(n as i64)\n+    }\n+\n+    /// Convert an `i8` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_i8(n: i8) -> Option<Self> {\n+        FromPrimitive::from_i64(n as i64)\n+    }\n+\n+    /// Convert an `i16` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_i16(n: i16) -> Option<Self> {\n+        FromPrimitive::from_i64(n as i64)\n+    }\n+\n+    /// Convert an `i32` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_i32(n: i32) -> Option<Self> {\n+        FromPrimitive::from_i64(n as i64)\n+    }\n+\n+    /// Convert an `i64` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    fn from_i64(n: i64) -> Option<Self>;\n+\n+    /// Convert an `uint` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_uint(n: uint) -> Option<Self> {\n+        FromPrimitive::from_u64(n as u64)\n+    }\n+\n+    /// Convert an `u8` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_u8(n: u8) -> Option<Self> {\n+        FromPrimitive::from_u64(n as u64)\n+    }\n+\n+    /// Convert an `u16` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_u16(n: u16) -> Option<Self> {\n+        FromPrimitive::from_u64(n as u64)\n+    }\n+\n+    /// Convert an `u32` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_u32(n: u32) -> Option<Self> {\n+        FromPrimitive::from_u64(n as u64)\n+    }\n+\n+    /// Convert an `u64` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    fn from_u64(n: u64) -> Option<Self>;\n+\n+    /// Convert a `f32` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_f32(n: f32) -> Option<Self> {\n+        FromPrimitive::from_f64(n as f64)\n+    }\n+\n+    /// Convert a `f64` to return an optional value of this type. If the\n+    /// type cannot be represented by this value, the `None` is returned.\n+    #[inline]\n+    fn from_f64(n: f64) -> Option<Self> {\n+        FromPrimitive::from_i64(n as i64)\n+    }\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_int`.\n+pub fn from_int<A: FromPrimitive>(n: int) -> Option<A> {\n+    FromPrimitive::from_int(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_i8`.\n+pub fn from_i8<A: FromPrimitive>(n: i8) -> Option<A> {\n+    FromPrimitive::from_i8(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_i16`.\n+pub fn from_i16<A: FromPrimitive>(n: i16) -> Option<A> {\n+    FromPrimitive::from_i16(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_i32`.\n+pub fn from_i32<A: FromPrimitive>(n: i32) -> Option<A> {\n+    FromPrimitive::from_i32(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_i64`.\n+pub fn from_i64<A: FromPrimitive>(n: i64) -> Option<A> {\n+    FromPrimitive::from_i64(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_uint`.\n+pub fn from_uint<A: FromPrimitive>(n: uint) -> Option<A> {\n+    FromPrimitive::from_uint(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_u8`.\n+pub fn from_u8<A: FromPrimitive>(n: u8) -> Option<A> {\n+    FromPrimitive::from_u8(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_u16`.\n+pub fn from_u16<A: FromPrimitive>(n: u16) -> Option<A> {\n+    FromPrimitive::from_u16(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_u32`.\n+pub fn from_u32<A: FromPrimitive>(n: u32) -> Option<A> {\n+    FromPrimitive::from_u32(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_u64`.\n+pub fn from_u64<A: FromPrimitive>(n: u64) -> Option<A> {\n+    FromPrimitive::from_u64(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_f32`.\n+pub fn from_f32<A: FromPrimitive>(n: f32) -> Option<A> {\n+    FromPrimitive::from_f32(n)\n+}\n+\n+/// A utility function that just calls `FromPrimitive::from_f64`.\n+pub fn from_f64<A: FromPrimitive>(n: f64) -> Option<A> {\n+    FromPrimitive::from_f64(n)\n+}\n+\n+macro_rules! impl_from_primitive(\n+    ($T:ty, $to_ty:expr) => (\n+        impl FromPrimitive for $T {\n+            #[inline] fn from_int(n: int) -> Option<$T> { $to_ty }\n+            #[inline] fn from_i8(n: i8) -> Option<$T> { $to_ty }\n+            #[inline] fn from_i16(n: i16) -> Option<$T> { $to_ty }\n+            #[inline] fn from_i32(n: i32) -> Option<$T> { $to_ty }\n+            #[inline] fn from_i64(n: i64) -> Option<$T> { $to_ty }\n+\n+            #[inline] fn from_uint(n: uint) -> Option<$T> { $to_ty }\n+            #[inline] fn from_u8(n: u8) -> Option<$T> { $to_ty }\n+            #[inline] fn from_u16(n: u16) -> Option<$T> { $to_ty }\n+            #[inline] fn from_u32(n: u32) -> Option<$T> { $to_ty }\n+            #[inline] fn from_u64(n: u64) -> Option<$T> { $to_ty }\n+\n+            #[inline] fn from_f32(n: f32) -> Option<$T> { $to_ty }\n+            #[inline] fn from_f64(n: f64) -> Option<$T> { $to_ty }\n+        }\n+    )\n+)\n+\n+impl_from_primitive!(int, n.to_int())\n+impl_from_primitive!(i8, n.to_i8())\n+impl_from_primitive!(i16, n.to_i16())\n+impl_from_primitive!(i32, n.to_i32())\n+impl_from_primitive!(i64, n.to_i64())\n+impl_from_primitive!(uint, n.to_uint())\n+impl_from_primitive!(u8, n.to_u8())\n+impl_from_primitive!(u16, n.to_u16())\n+impl_from_primitive!(u32, n.to_u32())\n+impl_from_primitive!(u64, n.to_u64())\n+impl_from_primitive!(f32, n.to_f32())\n+impl_from_primitive!(f64, n.to_f64())\n+\n /// Cast from one machine scalar to another\n ///\n /// # Example\n@@ -363,54 +801,24 @@ pub trait Float: Real\n /// ```\n ///\n #[inline]\n-pub fn cast<T:NumCast,U:NumCast>(n: T) -> U {\n+pub fn cast<T: NumCast,U: NumCast>(n: T) -> Option<U> {\n     NumCast::from(n)\n }\n \n /// An interface for casting between machine scalars\n-pub trait NumCast {\n-    fn from<T:NumCast>(n: T) -> Self;\n-\n-    fn to_u8(&self) -> u8;\n-    fn to_u16(&self) -> u16;\n-    fn to_u32(&self) -> u32;\n-    fn to_u64(&self) -> u64;\n-    fn to_uint(&self) -> uint;\n-\n-    fn to_i8(&self) -> i8;\n-    fn to_i16(&self) -> i16;\n-    fn to_i32(&self) -> i32;\n-    fn to_i64(&self) -> i64;\n-    fn to_int(&self) -> int;\n-\n-    fn to_f32(&self) -> f32;\n-    fn to_f64(&self) -> f64;\n+pub trait NumCast: ToPrimitive {\n+    fn from<T: ToPrimitive>(n: T) -> Option<Self>;\n }\n \n macro_rules! impl_num_cast(\n     ($T:ty, $conv:ident) => (\n         impl NumCast for $T {\n             #[inline]\n-            fn from<N:NumCast>(n: N) -> $T {\n+            fn from<N: ToPrimitive>(n: N) -> Option<$T> {\n                 // `$conv` could be generated using `concat_idents!`, but that\n                 // macro seems to be broken at the moment\n                 n.$conv()\n             }\n-\n-            #[inline] fn to_u8(&self)    -> u8    { *self as u8    }\n-            #[inline] fn to_u16(&self)   -> u16   { *self as u16   }\n-            #[inline] fn to_u32(&self)   -> u32   { *self as u32   }\n-            #[inline] fn to_u64(&self)   -> u64   { *self as u64   }\n-            #[inline] fn to_uint(&self)  -> uint  { *self as uint  }\n-\n-            #[inline] fn to_i8(&self)    -> i8    { *self as i8    }\n-            #[inline] fn to_i16(&self)   -> i16   { *self as i16   }\n-            #[inline] fn to_i32(&self)   -> i32   { *self as i32   }\n-            #[inline] fn to_i64(&self)   -> i64   { *self as i64   }\n-            #[inline] fn to_int(&self)   -> int   { *self as int   }\n-\n-            #[inline] fn to_f32(&self)   -> f32   { *self as f32   }\n-            #[inline] fn to_f64(&self)   -> f64   { *self as f64   }\n         }\n     )\n )\n@@ -461,7 +869,7 @@ pub fn pow_with_uint<T:NumCast+One+Zero+Div<T,T>+Mul<T,T>>(radix: uint, pow: uin\n     if radix == 0u { return _0; }\n     let mut my_pow     = pow;\n     let mut total      = _1;\n-    let mut multiplier = cast(radix);\n+    let mut multiplier = cast(radix).unwrap();\n     while (my_pow > 0u) {\n         if my_pow % 2u == 1u {\n             total = total * multiplier;\n@@ -543,11 +951,11 @@ pub trait CheckedDiv: Div<Self, Self> {\n /// Helper function for testing numeric operations\n #[cfg(test)]\n pub fn test_num<T:Num + NumCast>(ten: T, two: T) {\n-    assert_eq!(ten.add(&two),  cast(12));\n-    assert_eq!(ten.sub(&two),  cast(8));\n-    assert_eq!(ten.mul(&two),  cast(20));\n-    assert_eq!(ten.div(&two),  cast(5));\n-    assert_eq!(ten.rem(&two),  cast(0));\n+    assert_eq!(ten.add(&two),  cast(12).unwrap());\n+    assert_eq!(ten.sub(&two),  cast(8).unwrap());\n+    assert_eq!(ten.mul(&two),  cast(20).unwrap());\n+    assert_eq!(ten.div(&two),  cast(5).unwrap());\n+    assert_eq!(ten.rem(&two),  cast(0).unwrap());\n \n     assert_eq!(ten.add(&two),  ten + two);\n     assert_eq!(ten.sub(&two),  ten - two);\n@@ -559,51 +967,60 @@ pub fn test_num<T:Num + NumCast>(ten: T, two: T) {\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n-    use uint;\n     use super::*;\n+    use i8;\n+    use i16;\n+    use i32;\n+    use i64;\n+    use int;\n+    use u8;\n+    use u16;\n+    use u32;\n+    use u64;\n+    use uint;\n \n     macro_rules! test_cast_20(\n         ($_20:expr) => ({\n             let _20 = $_20;\n \n-            assert_eq!(20u,   _20.to_uint());\n-            assert_eq!(20u8,  _20.to_u8());\n-            assert_eq!(20u16, _20.to_u16());\n-            assert_eq!(20u32, _20.to_u32());\n-            assert_eq!(20u64, _20.to_u64());\n-            assert_eq!(20i,   _20.to_int());\n-            assert_eq!(20i8,  _20.to_i8());\n-            assert_eq!(20i16, _20.to_i16());\n-            assert_eq!(20i32, _20.to_i32());\n-            assert_eq!(20i64, _20.to_i64());\n-            assert_eq!(20f32, _20.to_f32());\n-            assert_eq!(20f64, _20.to_f64());\n-\n-            assert_eq!(_20, NumCast::from(20u));\n-            assert_eq!(_20, NumCast::from(20u8));\n-            assert_eq!(_20, NumCast::from(20u16));\n-            assert_eq!(_20, NumCast::from(20u32));\n-            assert_eq!(_20, NumCast::from(20u64));\n-            assert_eq!(_20, NumCast::from(20i));\n-            assert_eq!(_20, NumCast::from(20i8));\n-            assert_eq!(_20, NumCast::from(20i16));\n-            assert_eq!(_20, NumCast::from(20i32));\n-            assert_eq!(_20, NumCast::from(20i64));\n-            assert_eq!(_20, NumCast::from(20f32));\n-            assert_eq!(_20, NumCast::from(20f64));\n-\n-            assert_eq!(_20, cast(20u));\n-            assert_eq!(_20, cast(20u8));\n-            assert_eq!(_20, cast(20u16));\n-            assert_eq!(_20, cast(20u32));\n-            assert_eq!(_20, cast(20u64));\n-            assert_eq!(_20, cast(20i));\n-            assert_eq!(_20, cast(20i8));\n-            assert_eq!(_20, cast(20i16));\n-            assert_eq!(_20, cast(20i32));\n-            assert_eq!(_20, cast(20i64));\n-            assert_eq!(_20, cast(20f32));\n-            assert_eq!(_20, cast(20f64));\n+            assert_eq!(20u,   _20.to_uint().unwrap());\n+            assert_eq!(20u8,  _20.to_u8().unwrap());\n+            assert_eq!(20u16, _20.to_u16().unwrap());\n+            assert_eq!(20u32, _20.to_u32().unwrap());\n+            assert_eq!(20u64, _20.to_u64().unwrap());\n+            assert_eq!(20i,   _20.to_int().unwrap());\n+            assert_eq!(20i8,  _20.to_i8().unwrap());\n+            assert_eq!(20i16, _20.to_i16().unwrap());\n+            assert_eq!(20i32, _20.to_i32().unwrap());\n+            assert_eq!(20i64, _20.to_i64().unwrap());\n+            assert_eq!(20f32, _20.to_f32().unwrap());\n+            assert_eq!(20f64, _20.to_f64().unwrap());\n+\n+            assert_eq!(_20, NumCast::from(20u).unwrap());\n+            assert_eq!(_20, NumCast::from(20u8).unwrap());\n+            assert_eq!(_20, NumCast::from(20u16).unwrap());\n+            assert_eq!(_20, NumCast::from(20u32).unwrap());\n+            assert_eq!(_20, NumCast::from(20u64).unwrap());\n+            assert_eq!(_20, NumCast::from(20i).unwrap());\n+            assert_eq!(_20, NumCast::from(20i8).unwrap());\n+            assert_eq!(_20, NumCast::from(20i16).unwrap());\n+            assert_eq!(_20, NumCast::from(20i32).unwrap());\n+            assert_eq!(_20, NumCast::from(20i64).unwrap());\n+            assert_eq!(_20, NumCast::from(20f32).unwrap());\n+            assert_eq!(_20, NumCast::from(20f64).unwrap());\n+\n+            assert_eq!(_20, cast(20u).unwrap());\n+            assert_eq!(_20, cast(20u8).unwrap());\n+            assert_eq!(_20, cast(20u16).unwrap());\n+            assert_eq!(_20, cast(20u32).unwrap());\n+            assert_eq!(_20, cast(20u64).unwrap());\n+            assert_eq!(_20, cast(20i).unwrap());\n+            assert_eq!(_20, cast(20i8).unwrap());\n+            assert_eq!(_20, cast(20i16).unwrap());\n+            assert_eq!(_20, cast(20i32).unwrap());\n+            assert_eq!(_20, cast(20i64).unwrap());\n+            assert_eq!(_20, cast(20f32).unwrap());\n+            assert_eq!(_20, cast(20f64).unwrap());\n         })\n     )\n \n@@ -620,6 +1037,374 @@ mod tests {\n     #[test] fn test_f32_cast()   { test_cast_20!(20f32) }\n     #[test] fn test_f64_cast()   { test_cast_20!(20f64) }\n \n+    #[test]\n+    fn test_cast_range_int_min() {\n+        assert_eq!(int::min_value.to_int(),  Some(int::min_value as int));\n+        assert_eq!(int::min_value.to_i8(),   None);\n+        assert_eq!(int::min_value.to_i16(),  None);\n+        // int::min_value.to_i32() is word-size specific\n+        assert_eq!(int::min_value.to_i64(),  Some(int::min_value as i64));\n+        assert_eq!(int::min_value.to_uint(), None);\n+        assert_eq!(int::min_value.to_u8(),   None);\n+        assert_eq!(int::min_value.to_u16(),  None);\n+        assert_eq!(int::min_value.to_u32(),  None);\n+        assert_eq!(int::min_value.to_u64(),  None);\n+\n+        #[cfg(target_word_size = \"32\")]\n+        fn check_word_size() {\n+            assert_eq!(int::min_value.to_i32(), Some(int::min_value as i32));\n+        }\n+\n+        #[cfg(target_word_size = \"64\")]\n+        fn check_word_size() {\n+            assert_eq!(int::min_value.to_i32(), None);\n+        }\n+\n+        check_word_size();\n+    }\n+\n+    #[test]\n+    fn test_cast_range_i8_min() {\n+        assert_eq!(i8::min_value.to_int(),  Some(i8::min_value as int));\n+        assert_eq!(i8::min_value.to_i8(),   Some(i8::min_value as i8));\n+        assert_eq!(i8::min_value.to_i16(),  Some(i8::min_value as i16));\n+        assert_eq!(i8::min_value.to_i32(),  Some(i8::min_value as i32));\n+        assert_eq!(i8::min_value.to_i64(),  Some(i8::min_value as i64));\n+        assert_eq!(i8::min_value.to_uint(), None);\n+        assert_eq!(i8::min_value.to_u8(),   None);\n+        assert_eq!(i8::min_value.to_u16(),  None);\n+        assert_eq!(i8::min_value.to_u32(),  None);\n+        assert_eq!(i8::min_value.to_u64(),  None);\n+    }\n+\n+    #[test]\n+    fn test_cast_range_i16_min() {\n+        assert_eq!(i16::min_value.to_int(),  Some(i16::min_value as int));\n+        assert_eq!(i16::min_value.to_i8(),   None);\n+        assert_eq!(i16::min_value.to_i16(),  Some(i16::min_value as i16));\n+        assert_eq!(i16::min_value.to_i32(),  Some(i16::min_value as i32));\n+        assert_eq!(i16::min_value.to_i64(),  Some(i16::min_value as i64));\n+        assert_eq!(i16::min_value.to_uint(), None);\n+        assert_eq!(i16::min_value.to_u8(),   None);\n+        assert_eq!(i16::min_value.to_u16(),  None);\n+        assert_eq!(i16::min_value.to_u32(),  None);\n+        assert_eq!(i16::min_value.to_u64(),  None);\n+    }\n+\n+    #[test]\n+    fn test_cast_range_i32_min() {\n+        assert_eq!(i32::min_value.to_int(),  Some(i32::min_value as int));\n+        assert_eq!(i32::min_value.to_i8(),   None);\n+        assert_eq!(i32::min_value.to_i16(),  None);\n+        assert_eq!(i32::min_value.to_i32(),  Some(i32::min_value as i32));\n+        assert_eq!(i32::min_value.to_i64(),  Some(i32::min_value as i64));\n+        assert_eq!(i32::min_value.to_uint(), None);\n+        assert_eq!(i32::min_value.to_u8(),   None);\n+        assert_eq!(i32::min_value.to_u16(),  None);\n+        assert_eq!(i32::min_value.to_u32(),  None);\n+        assert_eq!(i32::min_value.to_u64(),  None);\n+    }\n+\n+    #[test]\n+    fn test_cast_range_i64_min() {\n+        // i64::min_value.to_int() is word-size specific\n+        assert_eq!(i64::min_value.to_i8(),   None);\n+        assert_eq!(i64::min_value.to_i16(),  None);\n+        assert_eq!(i64::min_value.to_i32(),  None);\n+        assert_eq!(i64::min_value.to_i64(),  Some(i64::min_value as i64));\n+        assert_eq!(i64::min_value.to_uint(), None);\n+        assert_eq!(i64::min_value.to_u8(),   None);\n+        assert_eq!(i64::min_value.to_u16(),  None);\n+        assert_eq!(i64::min_value.to_u32(),  None);\n+        assert_eq!(i64::min_value.to_u64(),  None);\n+\n+        #[cfg(target_word_size = \"32\")]\n+        fn check_word_size() {\n+            assert_eq!(i64::min_value.to_int(), None);\n+        }\n+\n+        #[cfg(target_word_size = \"64\")]\n+        fn check_word_size() {\n+            assert_eq!(i64::min_value.to_int(), Some(i64::min_value as int));\n+        }\n+\n+        check_word_size();\n+    }\n+\n+    #[test]\n+    fn test_cast_range_int_max() {\n+        assert_eq!(int::max_value.to_int(),  Some(int::max_value as int));\n+        assert_eq!(int::max_value.to_i8(),   None);\n+        assert_eq!(int::max_value.to_i16(),  None);\n+        // int::max_value.to_i32() is word-size specific\n+        assert_eq!(int::max_value.to_i64(),  Some(int::max_value as i64));\n+        assert_eq!(int::max_value.to_u8(),   None);\n+        assert_eq!(int::max_value.to_u16(),  None);\n+        // int::max_value.to_u32() is word-size specific\n+        assert_eq!(int::max_value.to_u64(),  Some(int::max_value as u64));\n+\n+        #[cfg(target_word_size = \"32\")]\n+        fn check_word_size() {\n+            assert_eq!(int::max_value.to_i32(), Some(int::max_value as i32));\n+            assert_eq!(int::max_value.to_u32(), Some(int::max_value as u32));\n+        }\n+\n+        #[cfg(target_word_size = \"64\")]\n+        fn check_word_size() {\n+            assert_eq!(int::max_value.to_i32(), None);\n+            assert_eq!(int::max_value.to_u32(), None);\n+        }\n+\n+        check_word_size();\n+    }\n+\n+    #[test]\n+    fn test_cast_range_i8_max() {\n+        assert_eq!(i8::max_value.to_int(),  Some(i8::max_value as int));\n+        assert_eq!(i8::max_value.to_i8(),   Some(i8::max_value as i8));\n+        assert_eq!(i8::max_value.to_i16(),  Some(i8::max_value as i16));\n+        assert_eq!(i8::max_value.to_i32(),  Some(i8::max_value as i32));\n+        assert_eq!(i8::max_value.to_i64(),  Some(i8::max_value as i64));\n+        assert_eq!(i8::max_value.to_uint(), Some(i8::max_value as uint));\n+        assert_eq!(i8::max_value.to_u8(),   Some(i8::max_value as u8));\n+        assert_eq!(i8::max_value.to_u16(),  Some(i8::max_value as u16));\n+        assert_eq!(i8::max_value.to_u32(),  Some(i8::max_value as u32));\n+        assert_eq!(i8::max_value.to_u64(),  Some(i8::max_value as u64));\n+    }\n+\n+    #[test]\n+    fn test_cast_range_i16_max() {\n+        assert_eq!(i16::max_value.to_int(),  Some(i16::max_value as int));\n+        assert_eq!(i16::max_value.to_i8(),   None);\n+        assert_eq!(i16::max_value.to_i16(),  Some(i16::max_value as i16));\n+        assert_eq!(i16::max_value.to_i32(),  Some(i16::max_value as i32));\n+        assert_eq!(i16::max_value.to_i64(),  Some(i16::max_value as i64));\n+        assert_eq!(i16::max_value.to_uint(), Some(i16::max_value as uint));\n+        assert_eq!(i16::max_value.to_u8(),   None);\n+        assert_eq!(i16::max_value.to_u16(),  Some(i16::max_value as u16));\n+        assert_eq!(i16::max_value.to_u32(),  Some(i16::max_value as u32));\n+        assert_eq!(i16::max_value.to_u64(),  Some(i16::max_value as u64));\n+    }\n+\n+    #[test]\n+    fn test_cast_range_i32_max() {\n+        assert_eq!(i32::max_value.to_int(),  Some(i32::max_value as int));\n+        assert_eq!(i32::max_value.to_i8(),   None);\n+        assert_eq!(i32::max_value.to_i16(),  None);\n+        assert_eq!(i32::max_value.to_i32(),  Some(i32::max_value as i32));\n+        assert_eq!(i32::max_value.to_i64(),  Some(i32::max_value as i64));\n+        assert_eq!(i32::max_value.to_uint(), Some(i32::max_value as uint));\n+        assert_eq!(i32::max_value.to_u8(),   None);\n+        assert_eq!(i32::max_value.to_u16(),  None);\n+        assert_eq!(i32::max_value.to_u32(),  Some(i32::max_value as u32));\n+        assert_eq!(i32::max_value.to_u64(),  Some(i32::max_value as u64));\n+    }\n+\n+    #[test]\n+    fn test_cast_range_i64_max() {\n+        // i64::max_value.to_int() is word-size specific\n+        assert_eq!(i64::max_value.to_i8(),   None);\n+        assert_eq!(i64::max_value.to_i16(),  None);\n+        assert_eq!(i64::max_value.to_i32(),  None);\n+        assert_eq!(i64::max_value.to_i64(),  Some(i64::max_value as i64));\n+        // i64::max_value.to_uint() is word-size specific\n+        assert_eq!(i64::max_value.to_u8(),   None);\n+        assert_eq!(i64::max_value.to_u16(),  None);\n+        assert_eq!(i64::max_value.to_u32(),  None);\n+        assert_eq!(i64::max_value.to_u64(),  Some(i64::max_value as u64));\n+\n+        #[cfg(target_word_size = \"32\")]\n+        fn check_word_size() {\n+            assert_eq!(i64::max_value.to_int(),  None);\n+            assert_eq!(i64::max_value.to_uint(), None);\n+        }\n+\n+        #[cfg(target_word_size = \"64\")]\n+        fn check_word_size() {\n+            assert_eq!(i64::max_value.to_int(),  Some(i64::max_value as int));\n+            assert_eq!(i64::max_value.to_uint(), Some(i64::max_value as uint));\n+        }\n+\n+        check_word_size();\n+    }\n+\n+    #[test]\n+    fn test_cast_range_uint_min() {\n+        assert_eq!(uint::min_value.to_int(),  Some(uint::min_value as int));\n+        assert_eq!(uint::min_value.to_i8(),   Some(uint::min_value as i8));\n+        assert_eq!(uint::min_value.to_i16(),  Some(uint::min_value as i16));\n+        assert_eq!(uint::min_value.to_i32(),  Some(uint::min_value as i32));\n+        assert_eq!(uint::min_value.to_i64(),  Some(uint::min_value as i64));\n+        assert_eq!(uint::min_value.to_uint(), Some(uint::min_value as uint));\n+        assert_eq!(uint::min_value.to_u8(),   Some(uint::min_value as u8));\n+        assert_eq!(uint::min_value.to_u16(),  Some(uint::min_value as u16));\n+        assert_eq!(uint::min_value.to_u32(),  Some(uint::min_value as u32));\n+        assert_eq!(uint::min_value.to_u64(),  Some(uint::min_value as u64));\n+    }\n+\n+    #[test]\n+    fn test_cast_range_u8_min() {\n+        assert_eq!(u8::min_value.to_int(),  Some(u8::min_value as int));\n+        assert_eq!(u8::min_value.to_i8(),   Some(u8::min_value as i8));\n+        assert_eq!(u8::min_value.to_i16(),  Some(u8::min_value as i16));\n+        assert_eq!(u8::min_value.to_i32(),  Some(u8::min_value as i32));\n+        assert_eq!(u8::min_value.to_i64(),  Some(u8::min_value as i64));\n+        assert_eq!(u8::min_value.to_uint(), Some(u8::min_value as uint));\n+        assert_eq!(u8::min_value.to_u8(),   Some(u8::min_value as u8));\n+        assert_eq!(u8::min_value.to_u16(),  Some(u8::min_value as u16));\n+        assert_eq!(u8::min_value.to_u32(),  Some(u8::min_value as u32));\n+        assert_eq!(u8::min_value.to_u64(),  Some(u8::min_value as u64));\n+    }\n+\n+    #[test]\n+    fn test_cast_range_u16_min() {\n+        assert_eq!(u16::min_value.to_int(),  Some(u16::min_value as int));\n+        assert_eq!(u16::min_value.to_i8(),   Some(u16::min_value as i8));\n+        assert_eq!(u16::min_value.to_i16(),  Some(u16::min_value as i16));\n+        assert_eq!(u16::min_value.to_i32(),  Some(u16::min_value as i32));\n+        assert_eq!(u16::min_value.to_i64(),  Some(u16::min_value as i64));\n+        assert_eq!(u16::min_value.to_uint(), Some(u16::min_value as uint));\n+        assert_eq!(u16::min_value.to_u8(),   Some(u16::min_value as u8));\n+        assert_eq!(u16::min_value.to_u16(),  Some(u16::min_value as u16));\n+        assert_eq!(u16::min_value.to_u32(),  Some(u16::min_value as u32));\n+        assert_eq!(u16::min_value.to_u64(),  Some(u16::min_value as u64));\n+    }\n+\n+    #[test]\n+    fn test_cast_range_u32_min() {\n+        assert_eq!(u32::min_value.to_int(),  Some(u32::min_value as int));\n+        assert_eq!(u32::min_value.to_i8(),   Some(u32::min_value as i8));\n+        assert_eq!(u32::min_value.to_i16(),  Some(u32::min_value as i16));\n+        assert_eq!(u32::min_value.to_i32(),  Some(u32::min_value as i32));\n+        assert_eq!(u32::min_value.to_i64(),  Some(u32::min_value as i64));\n+        assert_eq!(u32::min_value.to_uint(), Some(u32::min_value as uint));\n+        assert_eq!(u32::min_value.to_u8(),   Some(u32::min_value as u8));\n+        assert_eq!(u32::min_value.to_u16(),  Some(u32::min_value as u16));\n+        assert_eq!(u32::min_value.to_u32(),  Some(u32::min_value as u32));\n+        assert_eq!(u32::min_value.to_u64(),  Some(u32::min_value as u64));\n+    }\n+\n+    #[test]\n+    fn test_cast_range_u64_min() {\n+        assert_eq!(u64::min_value.to_int(),  Some(u64::min_value as int));\n+        assert_eq!(u64::min_value.to_i8(),   Some(u64::min_value as i8));\n+        assert_eq!(u64::min_value.to_i16(),  Some(u64::min_value as i16));\n+        assert_eq!(u64::min_value.to_i32(),  Some(u64::min_value as i32));\n+        assert_eq!(u64::min_value.to_i64(),  Some(u64::min_value as i64));\n+        assert_eq!(u64::min_value.to_uint(), Some(u64::min_value as uint));\n+        assert_eq!(u64::min_value.to_u8(),   Some(u64::min_value as u8));\n+        assert_eq!(u64::min_value.to_u16(),  Some(u64::min_value as u16));\n+        assert_eq!(u64::min_value.to_u32(),  Some(u64::min_value as u32));\n+        assert_eq!(u64::min_value.to_u64(),  Some(u64::min_value as u64));\n+    }\n+\n+    #[test]\n+    fn test_cast_range_uint_max() {\n+        assert_eq!(uint::max_value.to_int(),  None);\n+        assert_eq!(uint::max_value.to_i8(),   None);\n+        assert_eq!(uint::max_value.to_i16(),  None);\n+        assert_eq!(uint::max_value.to_i32(),  None);\n+        // uint::max_value.to_i64() is word-size specific\n+        assert_eq!(uint::max_value.to_u8(),   None);\n+        assert_eq!(uint::max_value.to_u16(),  None);\n+        // uint::max_value.to_u32() is word-size specific\n+        assert_eq!(uint::max_value.to_u64(),  Some(uint::max_value as u64));\n+\n+        #[cfg(target_word_size = \"32\")]\n+        fn check_word_size() {\n+            assert_eq!(uint::max_value.to_u32(), Some(uint::max_value as u32));\n+            assert_eq!(uint::max_value.to_i64(), Some(uint::max_value as i64));\n+        }\n+\n+        #[cfg(target_word_size = \"64\")]\n+        fn check_word_size() {\n+            assert_eq!(uint::max_value.to_u32(), None);\n+            assert_eq!(uint::max_value.to_i64(), None);\n+        }\n+\n+        check_word_size();\n+    }\n+\n+    #[test]\n+    fn test_cast_range_u8_max() {\n+        assert_eq!(u8::max_value.to_int(),  Some(u8::max_value as int));\n+        assert_eq!(u8::max_value.to_i8(),   None);\n+        assert_eq!(u8::max_value.to_i16(),  Some(u8::max_value as i16));\n+        assert_eq!(u8::max_value.to_i32(),  Some(u8::max_value as i32));\n+        assert_eq!(u8::max_value.to_i64(),  Some(u8::max_value as i64));\n+        assert_eq!(u8::max_value.to_uint(), Some(u8::max_value as uint));\n+        assert_eq!(u8::max_value.to_u8(),   Some(u8::max_value as u8));\n+        assert_eq!(u8::max_value.to_u16(),  Some(u8::max_value as u16));\n+        assert_eq!(u8::max_value.to_u32(),  Some(u8::max_value as u32));\n+        assert_eq!(u8::max_value.to_u64(),  Some(u8::max_value as u64));\n+    }\n+\n+    #[test]\n+    fn test_cast_range_u16_max() {\n+        assert_eq!(u16::max_value.to_int(),  Some(u16::max_value as int));\n+        assert_eq!(u16::max_value.to_i8(),   None);\n+        assert_eq!(u16::max_value.to_i16(),  None);\n+        assert_eq!(u16::max_value.to_i32(),  Some(u16::max_value as i32));\n+        assert_eq!(u16::max_value.to_i64(),  Some(u16::max_value as i64));\n+        assert_eq!(u16::max_value.to_uint(), Some(u16::max_value as uint));\n+        assert_eq!(u16::max_value.to_u8(),   None);\n+        assert_eq!(u16::max_value.to_u16(),  Some(u16::max_value as u16));\n+        assert_eq!(u16::max_value.to_u32(),  Some(u16::max_value as u32));\n+        assert_eq!(u16::max_value.to_u64(),  Some(u16::max_value as u64));\n+    }\n+\n+    #[test]\n+    fn test_cast_range_u32_max() {\n+        // u32::max_value.to_int() is word-size specific\n+        assert_eq!(u32::max_value.to_i8(),   None);\n+        assert_eq!(u32::max_value.to_i16(),  None);\n+        assert_eq!(u32::max_value.to_i32(),  None);\n+        assert_eq!(u32::max_value.to_i64(),  Some(u32::max_value as i64));\n+        assert_eq!(u32::max_value.to_uint(), Some(u32::max_value as uint));\n+        assert_eq!(u32::max_value.to_u8(),   None);\n+        assert_eq!(u32::max_value.to_u16(),  None);\n+        assert_eq!(u32::max_value.to_u32(),  Some(u32::max_value as u32));\n+        assert_eq!(u32::max_value.to_u64(),  Some(u32::max_value as u64));\n+\n+        #[cfg(target_word_size = \"32\")]\n+        fn check_word_size() {\n+            assert_eq!(u32::max_value.to_int(),  None);\n+        }\n+\n+        #[cfg(target_word_size = \"64\")]\n+        fn check_word_size() {\n+            assert_eq!(u32::max_value.to_int(),  Some(u32::max_value as int));\n+        }\n+\n+        check_word_size();\n+    }\n+\n+    #[test]\n+    fn test_cast_range_u64_max() {\n+        assert_eq!(u64::max_value.to_int(),  None);\n+        assert_eq!(u64::max_value.to_i8(),   None);\n+        assert_eq!(u64::max_value.to_i16(),  None);\n+        assert_eq!(u64::max_value.to_i32(),  None);\n+        assert_eq!(u64::max_value.to_i64(),  None);\n+        // u64::max_value.to_uint() is word-size specific\n+        assert_eq!(u64::max_value.to_u8(),   None);\n+        assert_eq!(u64::max_value.to_u16(),  None);\n+        assert_eq!(u64::max_value.to_u32(),  None);\n+        assert_eq!(u64::max_value.to_u64(),  Some(u64::max_value as u64));\n+\n+        #[cfg(target_word_size = \"32\")]\n+        fn check_word_size() {\n+            assert_eq!(u64::max_value.to_uint(), None);\n+        }\n+\n+        #[cfg(target_word_size = \"64\")]\n+        fn check_word_size() {\n+            assert_eq!(u64::max_value.to_uint(), Some(u64::max_value as uint));\n+        }\n+\n+        check_word_size();\n+    }\n+\n     #[test]\n     fn test_saturating_add_uint() {\n         use uint::max_value;"}, {"sha": "0f253a26ccf1eeae30e9e0a6998585b091910704", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=2733b189ac60cea541fbf80e5839e5027ffc9fbf", "patch": "@@ -140,7 +140,7 @@ pub fn int_to_str_bytes_common<T:NumCast+Zero+Eq+Ord+Integer+\n     let _0: T = Zero::zero();\n \n     let neg = num < _0;\n-    let radix_gen: T = cast(radix);\n+    let radix_gen: T = cast(radix).unwrap();\n \n     let mut deccum = num;\n     // This is just for integral types, the largest of which is a u64. The\n@@ -163,7 +163,7 @@ pub fn int_to_str_bytes_common<T:NumCast+Zero+Eq+Ord+Integer+\n         } else {\n             current_digit_signed\n         };\n-        buf[cur] = match current_digit.to_u8() {\n+        buf[cur] = match current_digit.to_u8().unwrap() {\n             i @ 0..9 => '0' as u8 + i,\n             i        => 'a' as u8 + (i - 10),\n         };\n@@ -247,7 +247,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n \n     let neg = num < _0 || (negative_zero && _1 / num == Float::neg_infinity());\n     let mut buf: ~[u8] = ~[];\n-    let radix_gen: T   = cast(radix as int);\n+    let radix_gen: T   = cast(radix as int).unwrap();\n \n     // First emit the non-fractional part, looping at least once to make\n     // sure at least a `0` gets emitted.\n@@ -265,7 +265,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n         deccum = deccum / radix_gen;\n         deccum = deccum.trunc();\n \n-        buf.push(char::from_digit(current_digit.to_int() as uint, radix)\n+        buf.push(char::from_digit(current_digit.to_int().unwrap() as uint, radix)\n              .unwrap() as u8);\n \n         // No more digits to calculate for the non-fractional part -> break\n@@ -322,7 +322,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n             let current_digit = deccum.trunc().abs();\n \n             buf.push(char::from_digit(\n-                current_digit.to_int() as uint, radix).unwrap() as u8);\n+                current_digit.to_int().unwrap() as uint, radix).unwrap() as u8);\n \n             // Decrease the deccumulator one fractional digit at a time\n             deccum = deccum.fract();\n@@ -492,7 +492,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Div<T,T>+\n \n     let _0: T = Zero::zero();\n     let _1: T = One::one();\n-    let radix_gen: T = cast(radix as int);\n+    let radix_gen: T = cast(radix as int).unwrap();\n \n     let len = buf.len();\n \n@@ -543,9 +543,9 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Div<T,T>+\n \n                 // add/subtract current digit depending on sign\n                 if accum_positive {\n-                    accum = accum + cast(digit as int);\n+                    accum = accum + cast(digit as int).unwrap();\n                 } else {\n-                    accum = accum - cast(digit as int);\n+                    accum = accum - cast(digit as int).unwrap();\n                 }\n \n                 // Detect overflow by comparing to last value, except\n@@ -556,11 +556,11 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Div<T,T>+\n \n                     // Detect overflow by reversing the shift-and-add proccess\n                     if accum_positive &&\n-                        (last_accum != ((accum - cast(digit as int))/radix_gen.clone())) {\n+                        (last_accum != ((accum - cast(digit as int).unwrap())/radix_gen.clone())) {\n                         return NumStrConv::inf();\n                     }\n                     if !accum_positive &&\n-                        (last_accum != ((accum + cast(digit as int))/radix_gen.clone())) {\n+                        (last_accum != ((accum + cast(digit as int).unwrap())/radix_gen.clone())) {\n                         return NumStrConv::neg_inf();\n                     }\n                 }\n@@ -596,7 +596,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Div<T,T>+\n                     // Decrease power one order of magnitude\n                     power = power / radix_gen;\n \n-                    let digit_t: T = cast(digit);\n+                    let digit_t: T = cast(digit).unwrap();\n \n                     // add/subtract current digit depending on sign\n                     if accum_positive {\n@@ -654,9 +654,9 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Div<T,T>+\n         match exp {\n             Some(exp_pow) => {\n                 multiplier = if exp_pow < 0 {\n-                    _1 / pow_with_uint::<T>(base, (-exp_pow.to_int()) as uint)\n+                    _1 / pow_with_uint::<T>(base, (-exp_pow.to_int().unwrap()) as uint)\n                 } else {\n-                    pow_with_uint::<T>(base, exp_pow.to_int() as uint)\n+                    pow_with_uint::<T>(base, exp_pow.to_int().unwrap() as uint)\n                 }\n             }\n             None => return None // invalid exponent -> invalid number"}, {"sha": "f52feced67c77a91d7fee4d3388830016b6db05b", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=2733b189ac60cea541fbf80e5839e5027ffc9fbf", "patch": "@@ -306,6 +306,9 @@ impl Primitive for $T {\n \n     #[inline]\n     fn bytes(_: Option<$T>) -> uint { bits / 8 }\n+\n+    #[inline]\n+    fn is_signed(_: Option<$T>) -> bool { false }\n }\n \n impl BitCount for $T {"}, {"sha": "273a01c18113c4261e7d3905217e1fad508c266c", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=2733b189ac60cea541fbf80e5839e5027ffc9fbf", "patch": "@@ -59,7 +59,7 @@ pub use num::{Orderable, Signed, Unsigned, Round};\n pub use num::{Algebraic, Trigonometric, Exponential, Hyperbolic};\n pub use num::{Integer, Fractional, Real, RealExt};\n pub use num::{Bitwise, BitCount, Bounded};\n-pub use num::{Primitive, Int, Float, ToStrRadix};\n+pub use num::{Primitive, Int, Float, ToStrRadix, ToPrimitive, FromPrimitive};\n pub use path::GenericPath;\n pub use path::Path;\n pub use path::PosixPath;"}, {"sha": "70bcb0f7170754cea0a76b842004ed229b3fc443", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=2733b189ac60cea541fbf80e5839e5027ffc9fbf", "patch": "@@ -317,12 +317,12 @@ pub trait Rng {\n     /// ```\n     fn gen_integer_range<T: Rand + Int>(&mut self, low: T, high: T) -> T {\n         assert!(low < high, \"RNG.gen_integer_range called with low >= high\");\n-        let range = (high - low).to_u64();\n+        let range = (high - low).to_u64().unwrap();\n         let accept_zone = u64::max_value - u64::max_value % range;\n         loop {\n             let rand = self.gen::<u64>();\n             if rand < accept_zone {\n-                return low + NumCast::from(rand % range);\n+                return low + NumCast::from(rand % range).unwrap();\n             }\n         }\n     }"}, {"sha": "65a6572fa5e997c104cc1c5d5789baaae04ee24f", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=2733b189ac60cea541fbf80e5839e5027ffc9fbf", "patch": "@@ -113,6 +113,7 @@ pub trait AstBuilder {\n                         expr: @ast::Expr, ident: ast::Ident,\n                         args: ~[@ast::Expr]) -> @ast::Expr;\n     fn expr_block(&self, b: ast::Block) -> @ast::Expr;\n+    fn expr_cast(&self, sp: Span, expr: @ast::Expr, ty: ast::Ty) -> @ast::Expr;\n \n     fn field_imm(&self, span: Span, name: Ident, e: @ast::Expr) -> ast::Field;\n     fn expr_struct(&self, span: Span, path: ast::Path, fields: ~[ast::Field]) -> @ast::Expr;\n@@ -132,6 +133,10 @@ pub trait AstBuilder {\n     fn expr_str(&self, sp: Span, s: @str) -> @ast::Expr;\n     fn expr_str_uniq(&self, sp: Span, s: @str) -> @ast::Expr;\n \n+    fn expr_some(&self, sp: Span, expr: @ast::Expr) -> @ast::Expr;\n+    fn expr_none(&self, sp: Span) -> @ast::Expr;\n+\n+    fn expr_fail(&self, span: Span, msg: @str) -> @ast::Expr;\n     fn expr_unreachable(&self, span: Span) -> @ast::Expr;\n \n     fn pat(&self, span: Span, pat: ast::Pat_) -> @ast::Pat;\n@@ -564,7 +569,30 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n \n-    fn expr_unreachable(&self, span: Span) -> @ast::Expr {\n+    fn expr_cast(&self, sp: Span, expr: @ast::Expr, ty: ast::Ty) -> @ast::Expr {\n+        self.expr(sp, ast::ExprCast(expr, ty))\n+    }\n+\n+\n+    fn expr_some(&self, sp: Span, expr: @ast::Expr) -> @ast::Expr {\n+        let some = ~[\n+            self.ident_of(\"std\"),\n+            self.ident_of(\"option\"),\n+            self.ident_of(\"Some\"),\n+        ];\n+        self.expr_call_global(sp, some, ~[expr])\n+    }\n+\n+    fn expr_none(&self, sp: Span) -> @ast::Expr {\n+        let none = self.path_global(sp, ~[\n+            self.ident_of(\"std\"),\n+            self.ident_of(\"option\"),\n+            self.ident_of(\"None\"),\n+        ]);\n+        self.expr_path(none)\n+    }\n+\n+    fn expr_fail(&self, span: Span, msg: @str) -> @ast::Expr {\n         let loc = self.codemap().lookup_char_pos(span.lo);\n         self.expr_call_global(\n             span,\n@@ -575,12 +603,16 @@ impl AstBuilder for @ExtCtxt {\n                 self.ident_of(\"fail_with\"),\n             ],\n             ~[\n-                self.expr_str(span, @\"internal error: entered unreachable code\"),\n+                self.expr_str(span, msg),\n                 self.expr_str(span, loc.file.name),\n                 self.expr_uint(span, loc.line),\n             ])\n     }\n \n+    fn expr_unreachable(&self, span: Span) -> @ast::Expr {\n+        self.expr_fail(span, @\"internal error: entered unreachable code\")\n+    }\n+\n \n     fn pat(&self, span: Span, pat: ast::Pat_) -> @ast::Pat {\n         @ast::Pat { id: ast::DUMMY_NODE_ID, node: pat, span: span }"}, {"sha": "b3fd4f920d88f9645ec5d34ed41adb198f3a7db1", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=2733b189ac60cea541fbf80e5839e5027ffc9fbf", "patch": "@@ -1151,6 +1151,7 @@ pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n              enum_nonmatch_f,\n              cx, span, substructure)\n }\n+\n /// cs_binop with binop == and\n #[inline]\n pub fn cs_and(enum_nonmatch_f: EnumNonMatchFunc,"}, {"sha": "3e65f7bdefbc51a22e0f840f934044beb0da1844", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=2733b189ac60cea541fbf80e5839e5027ffc9fbf", "patch": "@@ -32,6 +32,7 @@ pub mod rand;\n pub mod to_str;\n pub mod zero;\n pub mod default;\n+pub mod primitive;\n \n #[path=\"cmp/eq.rs\"]\n pub mod eq;\n@@ -97,9 +98,12 @@ pub fn expand_meta_deriving(cx: @ExtCtxt,\n                             \"Rand\" => expand!(rand::expand_deriving_rand),\n \n                             \"ToStr\" => expand!(to_str::expand_deriving_to_str),\n+\n                             \"Zero\" => expand!(zero::expand_deriving_zero),\n                             \"Default\" => expand!(default::expand_deriving_default),\n \n+                            \"FromPrimitive\" => expand!(primitive::expand_deriving_from_primitive),\n+\n                             ref tname => {\n                                 cx.span_err(titem.span, format!(\"unknown \\\n                                     `deriving` trait: `{}`\", *tname));"}, {"sha": "38c30def1d19d750c837c5b8d27fac41ce39cacd", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=2733b189ac60cea541fbf80e5839e5027ffc9fbf", "patch": "@@ -0,0 +1,127 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ast::{MetaItem, item, Expr};\n+use ast;\n+use codemap::Span;\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n+use ext::deriving::generic::*;\n+\n+pub fn expand_deriving_from_primitive(cx: @ExtCtxt,\n+                                      span: Span,\n+                                      mitem: @MetaItem,\n+                                      in_items: ~[@item]) -> ~[@item] {\n+    let trait_def = TraitDef {\n+        path: Path::new(~[\"std\", \"num\", \"FromPrimitive\"]),\n+        additional_bounds: ~[],\n+        generics: LifetimeBounds::empty(),\n+        methods: ~[\n+            MethodDef {\n+                name: \"from_i64\",\n+                generics: LifetimeBounds::empty(),\n+                explicit_self: None,\n+                args: ~[\n+                    Literal(Path::new(~[\"i64\"])),\n+                ],\n+                ret_ty: Literal(Path::new_(~[\"std\", \"option\", \"Option\"],\n+                                           None,\n+                                           ~[~Self],\n+                                           true)),\n+                const_nonmatching: false,\n+                combine_substructure: |c, s, sub| cs_from(\"i64\", c, s, sub),\n+            },\n+            MethodDef {\n+                name: \"from_u64\",\n+                generics: LifetimeBounds::empty(),\n+                explicit_self: None,\n+                args: ~[\n+                    Literal(Path::new(~[\"u64\"])),\n+                ],\n+                ret_ty: Literal(Path::new_(~[\"std\", \"option\", \"Option\"],\n+                                           None,\n+                                           ~[~Self],\n+                                           true)),\n+                const_nonmatching: false,\n+                combine_substructure: |c, s, sub| cs_from(\"u64\", c, s, sub),\n+            },\n+        ]\n+    };\n+\n+    trait_def.expand(cx, span, mitem, in_items)\n+}\n+\n+fn cs_from(name: &str, cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+    let n = match substr.nonself_args {\n+        [n] => n,\n+        _ => cx.span_bug(span, \"Incorrect number of arguments in `deriving(FromPrimitive)`\")\n+    };\n+\n+    match *substr.fields {\n+        StaticStruct(*) => {\n+            cx.span_err(span, \"`FromPrimitive` cannot be derived for structs\");\n+            return cx.expr_fail(span, @\"\");\n+        }\n+        StaticEnum(enum_def, _) => {\n+            if enum_def.variants.is_empty() {\n+                cx.span_err(span, \"`FromPrimitive` cannot be derived for enums with no variants\");\n+                return cx.expr_fail(span, @\"\");\n+            }\n+\n+            let mut arms = ~[];\n+\n+            for variant in enum_def.variants.iter() {\n+                match variant.node.kind {\n+                    ast::tuple_variant_kind(ref args) => {\n+                        if !args.is_empty() {\n+                            cx.span_err(span, \"`FromPrimitive` cannot be derived for \\\n+                                               enum variants with arguments\");\n+                            return cx.expr_fail(span, @\"\");\n+                        }\n+\n+                        // expr for `$n == $variant as $name`\n+                        let variant = cx.expr_ident(span, variant.node.name);\n+                        let ty = cx.ty_ident(span, cx.ident_of(name));\n+                        let cast = cx.expr_cast(span, variant, ty);\n+                        let guard = cx.expr_binary(span, ast::BiEq, n, cast);\n+\n+                        // expr for `Some($variant)`\n+                        let body = cx.expr_some(span, variant);\n+\n+                        // arm for `_ if $guard => $body`\n+                        let arm = ast::Arm {\n+                            pats: ~[cx.pat_wild(span)],\n+                            guard: Some(guard),\n+                            body: cx.block_expr(body),\n+                        };\n+\n+                        arms.push(arm);\n+                    }\n+                    ast::struct_variant_kind(_) => {\n+                        cx.span_err(span, \"`FromPrimitive` cannot be derived for enums \\\n+                                           with struct variants\");\n+                        return cx.expr_fail(span, @\"\");\n+                    }\n+                }\n+            }\n+\n+            // arm for `_ => None`\n+            let arm = ast::Arm {\n+                pats: ~[cx.pat_wild(span)],\n+                guard: None,\n+                body: cx.block_expr(cx.expr_none(span)),\n+            };\n+            arms.push(arm);\n+\n+            cx.expr_match(span, n, arms)\n+        }\n+        _ => cx.bug(\"expected StaticEnum in deriving(FromPrimitive)\")\n+    }\n+}"}, {"sha": "1af0193ca4789e43e640b737373372545995d924", "filename": "src/test/compile-fail/deriving-primitive.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Ftest%2Fcompile-fail%2Fderiving-primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Ftest%2Fcompile-fail%2Fderiving-primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-primitive.rs?ref=2733b189ac60cea541fbf80e5839e5027ffc9fbf", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::num::FromPrimitive;\n+use std::int;\n+\n+#[deriving(FromPrimitive)]\n+struct A { x: int }\n+//~^^ ERROR `FromPrimitive` cannot be derived for structs\n+//~^^^ ERROR `FromPrimitive` cannot be derived for structs\n+\n+#[deriving(FromPrimitive)]\n+struct B(int);\n+//~^^ ERROR `FromPrimitive` cannot be derived for structs\n+//~^^^ ERROR `FromPrimitive` cannot be derived for structs\n+\n+#[deriving(FromPrimitive)]\n+enum C { Foo(int), Bar(uint) }\n+//~^^ ERROR `FromPrimitive` cannot be derived for enum variants with arguments\n+//~^^^ ERROR `FromPrimitive` cannot be derived for enum variants with arguments\n+\n+#[deriving(FromPrimitive)]\n+enum D { Baz { x: int } }\n+//~^^ ERROR `FromPrimitive` cannot be derived for enums with struct variants\n+//~^^^ ERROR `FromPrimitive` cannot be derived for enums with struct variants\n+\n+pub fn main() {}"}, {"sha": "f82d77b28eae97128eb21d72a6b21a53fbe4337c", "filename": "src/test/run-pass/deriving-primitive.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Ftest%2Frun-pass%2Fderiving-primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Ftest%2Frun-pass%2Fderiving-primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-primitive.rs?ref=2733b189ac60cea541fbf80e5839e5027ffc9fbf", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::num::FromPrimitive;\n+use std::int;\n+\n+#[deriving(Eq, FromPrimitive)]\n+enum A {\n+    Foo = int::max_value,\n+    Bar = 1,\n+    Baz = 3,\n+    Qux,\n+}\n+\n+pub fn main() {\n+    let x: Option<A> = FromPrimitive::from_int(int::max_value);\n+    assert_eq!(x, Some(Foo));\n+\n+    let x: Option<A> = FromPrimitive::from_int(1);\n+    assert_eq!(x, Some(Bar));\n+\n+    let x: Option<A> = FromPrimitive::from_int(3);\n+    assert_eq!(x, Some(Baz));\n+\n+    let x: Option<A> = FromPrimitive::from_int(4);\n+    assert_eq!(x, Some(Qux));\n+\n+    let x: Option<A> = FromPrimitive::from_int(5);\n+    assert_eq!(x, None);\n+}"}, {"sha": "1422f93e612af593b4952161779d660f86bcfa85", "filename": "src/test/run-pass/numeric-method-autoexport.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnumeric-method-autoexport.rs?ref=2733b189ac60cea541fbf80e5839e5027ffc9fbf", "patch": "@@ -36,6 +36,6 @@ pub fn main() {\n \n // floats\n     // num\n-    assert_eq!(10f32.to_int(), 10);\n-    assert_eq!(10f64.to_int(), 10);\n+    assert_eq!(10f32.to_int().unwrap(), 10);\n+    assert_eq!(10f64.to_int().unwrap(), 10);\n }"}, {"sha": "8d3c258558e1830121679f1e0d3be9b0daac0b1f", "filename": "src/test/run-pass/trait-inheritance-num.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num.rs?ref=2733b189ac60cea541fbf80e5839e5027ffc9fbf", "patch": "@@ -19,7 +19,7 @@ pub trait NumExt: Num + NumCast + Eq + Ord {}\n \n pub trait FloatExt: NumExt + ApproxEq<Self> {}\n \n-fn greater_than_one<T:NumExt>(n: &T) -> bool { *n > NumCast::from(1) }\n-fn greater_than_one_float<T:FloatExt>(n: &T) -> bool { *n > NumCast::from(1) }\n+fn greater_than_one<T:NumExt>(n: &T) -> bool { *n > NumCast::from(1).unwrap() }\n+fn greater_than_one_float<T:FloatExt>(n: &T) -> bool { *n > NumCast::from(1).unwrap() }\n \n pub fn main() {}"}, {"sha": "46efac84907f2707471ec424741d3df97946de5e", "filename": "src/test/run-pass/trait-inheritance-num0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num0.rs?ref=2733b189ac60cea541fbf80e5839e5027ffc9fbf", "patch": "@@ -22,7 +22,7 @@ trait Num {\n pub trait NumExt: Num + NumCast { }\n \n fn greater_than_one<T:NumExt>(n: &T) -> bool {\n-    n.gt(&NumCast::from(1))\n+    n.gt(&NumCast::from(1).unwrap())\n }\n \n pub fn main() {}"}, {"sha": "28abae175cdfb6a97ecd749fd6463f0df222ba8c", "filename": "src/test/run-pass/trait-inheritance-num1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num1.rs?ref=2733b189ac60cea541fbf80e5839e5027ffc9fbf", "patch": "@@ -14,7 +14,7 @@ use std::num::NumCast;\n pub trait NumExt: Num + NumCast + Ord { }\n \n fn greater_than_one<T:NumExt>(n: &T) -> bool {\n-    *n > NumCast::from(1)\n+    *n > NumCast::from(1).unwrap()\n }\n \n pub fn main() {}"}, {"sha": "7909f01591228a4f99ae35f90acbdca95781293e", "filename": "src/test/run-pass/trait-inheritance-num3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num3.rs?ref=2733b189ac60cea541fbf80e5839e5027ffc9fbf", "patch": "@@ -16,7 +16,7 @@ pub trait NumExt: Eq + Ord + Num + NumCast {}\n impl NumExt for f32 {}\n \n fn num_eq_one<T:NumExt>(n: T) {\n-    println!(\"{}\", n == NumCast::from(1))\n+    println!(\"{}\", n == NumCast::from(1).unwrap())\n }\n \n pub fn main() {"}, {"sha": "0310dde2a6d3beb68074dbb1640b255688c6ae9a", "filename": "src/test/run-pass/trait-inheritance-num5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2733b189ac60cea541fbf80e5839e5027ffc9fbf/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-num5.rs?ref=2733b189ac60cea541fbf80e5839e5027ffc9fbf", "patch": "@@ -17,7 +17,7 @@ impl NumExt for f32 {}\n impl NumExt for int {}\n \n fn num_eq_one<T:NumExt>() -> T {\n-    NumCast::from(1)\n+    NumCast::from(1).unwrap()\n }\n \n pub fn main() {"}]}