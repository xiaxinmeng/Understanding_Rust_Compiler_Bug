{"sha": "57fac56cb51d1a8ca0f6d76f869ccbb0a67b0f45", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3ZmFjNTZjYjUxZDFhOGNhMGY2ZDc2Zjg2OWNjYmIwYTY3YjBmNDU=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-07-12T03:56:19Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-07-13T04:50:35Z"}, "message": "Start a best-effort warning cycle.", "tree": {"sha": "7e8a057437d2774e71c4a58cb3c923423d8ff0e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e8a057437d2774e71c4a58cb3c923423d8ff0e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57fac56cb51d1a8ca0f6d76f869ccbb0a67b0f45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57fac56cb51d1a8ca0f6d76f869ccbb0a67b0f45", "html_url": "https://github.com/rust-lang/rust/commit/57fac56cb51d1a8ca0f6d76f869ccbb0a67b0f45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57fac56cb51d1a8ca0f6d76f869ccbb0a67b0f45/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1b850d3041e5c36dc133c22b59319b179f5ddc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1b850d3041e5c36dc133c22b59319b179f5ddc6", "html_url": "https://github.com/rust-lang/rust/commit/c1b850d3041e5c36dc133c22b59319b179f5ddc6"}], "stats": {"total": 65, "additions": 59, "deletions": 6}, "files": [{"sha": "db12ef24f7149fd95fd3ab362af7606ff517793b", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57fac56cb51d1a8ca0f6d76f869ccbb0a67b0f45/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57fac56cb51d1a8ca0f6d76f869ccbb0a67b0f45/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=57fac56cb51d1a8ca0f6d76f869ccbb0a67b0f45", "patch": "@@ -123,7 +123,7 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n             let mut parser = self.parser.borrow_mut();\n             match parser.token {\n                 token::Eof => break,\n-                _ => match parser.parse_full_stmt() {\n+                _ => match parser.parse_full_stmt(true) {\n                     Ok(maybe_stmt) => match maybe_stmt {\n                         Some(stmt) => ret.push(stmt),\n                         None => (),"}, {"sha": "c6374e59c1bc4b0e9a525e6b96b59ab99e799007", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 36, "deletions": 5, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/57fac56cb51d1a8ca0f6d76f869ccbb0a67b0f45/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57fac56cb51d1a8ca0f6d76f869ccbb0a67b0f45/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=57fac56cb51d1a8ca0f6d76f869ccbb0a67b0f45", "patch": "@@ -4044,7 +4044,7 @@ impl<'a> Parser<'a> {\n         let mut stmts = vec![];\n \n         while !self.eat(&token::CloseDelim(token::Brace)) {\n-            if let Some(stmt) = self.parse_full_stmt()? {\n+            if let Some(stmt) = self.parse_full_stmt(false)? {\n                 stmts.push(stmt);\n             } else if self.token == token::Eof {\n                 break;\n@@ -4064,7 +4064,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse a statement, including the trailing semicolon.\n     /// This parses expression statements that begin with macros correctly (c.f. `parse_stmt`).\n-    pub fn parse_full_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n+    pub fn parse_full_stmt(&mut self, macro_expanded: bool) -> PResult<'a, Option<Stmt>> {\n         let mut stmt = match self.parse_stmt_() {\n             Some(stmt) => stmt,\n             None => return Ok(None),\n@@ -4075,6 +4075,23 @@ impl<'a> Parser<'a> {\n                self.token == token::Semi || self.token == token::Eof {\n                 stmt.node = StmtKind::Mac(mac);\n             } else {\n+                // We used to incorrectly stop parsing macro-expanded statements here.\n+                // If the next token will be an error anyway but could have parsed with the\n+                // earlier behavior, stop parsing here and emit a warning to avoid breakage.\n+                if macro_expanded && self.token.can_begin_expr() && match self.token {\n+                    // These tokens can continue an expression, so we can't stop parsing and warn.\n+                    token::OpenDelim(token::Paren) | token::OpenDelim(token::Bracket) |\n+                    token::BinOp(token::Minus) | token::BinOp(token::Star) |\n+                    token::BinOp(token::And) | token::BinOp(token::Or) |\n+                    token::AndAnd | token::OrOr |\n+                    token::DotDot | token::DotDotDot => false,\n+                    _ => true,\n+                } {\n+                    self.warn_missing_semicolon();\n+                    stmt.node = StmtKind::Mac(mac);\n+                    return Ok(Some(stmt));\n+                }\n+\n                 let (mac, _style, attrs) = mac.unwrap();\n                 let e = self.mk_mac_expr(stmt.span.lo, stmt.span.hi, mac.node, ThinVec::new());\n                 let e = self.parse_dot_or_call_expr_with(e, stmt.span.lo, attrs)?;\n@@ -4083,11 +4100,12 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        stmt = self.handle_trailing_semicolon(stmt)?;\n+        stmt = self.handle_trailing_semicolon(stmt, macro_expanded)?;\n         Ok(Some(stmt))\n     }\n \n-    fn handle_trailing_semicolon(&mut self, mut stmt: Stmt) -> PResult<'a, Stmt> {\n+    fn handle_trailing_semicolon(&mut self, mut stmt: Stmt, macro_expanded: bool)\n+                                 -> PResult<'a, Stmt> {\n         match stmt.node {\n             StmtKind::Expr(ref expr) if self.token != token::Eof => {\n                 // expression without semicolon\n@@ -4102,7 +4120,12 @@ impl<'a> Parser<'a> {\n                 }\n             }\n             StmtKind::Local(..) => {\n-                self.expect_one_of(&[token::Semi], &[])?;\n+                // We used to incorrectly allow a macro-expanded let statement to lack a semicolon.\n+                if macro_expanded && self.token != token::Semi {\n+                    self.warn_missing_semicolon();\n+                } else {\n+                    self.expect_one_of(&[token::Semi], &[])?;\n+                }\n             }\n             _ => {}\n         }\n@@ -4115,6 +4138,14 @@ impl<'a> Parser<'a> {\n         Ok(stmt)\n     }\n \n+    fn warn_missing_semicolon(&self) {\n+        self.diagnostic().struct_span_warn(self.span, {\n+            &format!(\"expected `;`, found `{}`\", self.this_token_to_string())\n+        }).note({\n+            \"This was erroneously allowed and will become a hard error in a future release\"\n+        }).emit();\n+    }\n+\n     // Parses a sequence of bounds if a `:` is found,\n     // otherwise returns empty list.\n     fn parse_colon_then_ty_param_bounds(&mut self,"}, {"sha": "bbc958b87a571724e93134e4d1599e3c116a0817", "filename": "src/test/compile-fail/missing-semicolon-warning.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/57fac56cb51d1a8ca0f6d76f869ccbb0a67b0f45/src%2Ftest%2Fcompile-fail%2Fmissing-semicolon-warning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57fac56cb51d1a8ca0f6d76f869ccbb0a67b0f45/src%2Ftest%2Fcompile-fail%2Fmissing-semicolon-warning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-semicolon-warning.rs?ref=57fac56cb51d1a8ca0f6d76f869ccbb0a67b0f45", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![allow(unused)]\n+\n+macro_rules! m {\n+    ($($e1:expr),*; $($e2:expr),*) => {\n+        $( let x = $e1 )*; //~ WARN expected `;`\n+        $( println!(\"{}\", $e2) )*; //~ WARN expected `;`\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() { m!(0, 0; 0, 0); } //~ ERROR compilation successful"}]}