{"sha": "31e0e12e6986ca369e9e27fa713c40b174c4d573", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxZTBlMTJlNjk4NmNhMzY5ZTllMjdmYTcxM2M0MGIxNzRjNGQ1NzM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-11T03:41:48Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-11T03:41:48Z"}, "message": "Add support for undetermined macro invocations.", "tree": {"sha": "058816a4575cbfffab8d139e77aab7504fff9c0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/058816a4575cbfffab8d139e77aab7504fff9c0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31e0e12e6986ca369e9e27fa713c40b174c4d573", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31e0e12e6986ca369e9e27fa713c40b174c4d573", "html_url": "https://github.com/rust-lang/rust/commit/31e0e12e6986ca369e9e27fa713c40b174c4d573", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31e0e12e6986ca369e9e27fa713c40b174c4d573/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5281ef681195828173d4fe516b653ba0f9e9fbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5281ef681195828173d4fe516b653ba0f9e9fbc", "html_url": "https://github.com/rust-lang/rust/commit/d5281ef681195828173d4fe516b653ba0f9e9fbc"}], "stats": {"total": 62, "additions": 44, "deletions": 18}, "files": [{"sha": "ca0958e085af0bbedd4c5e14196f061d393c9cb2", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/31e0e12e6986ca369e9e27fa713c40b174c4d573/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e0e12e6986ca369e9e27fa713c40b174c4d573/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=31e0e12e6986ca369e9e27fa713c40b174c4d573", "patch": "@@ -17,7 +17,7 @@ use std::cell::Cell;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::errors::DiagnosticBuilder;\n-use syntax::ext::base::{self, MultiModifier, MultiDecorator, MultiItemModifier};\n+use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator, MultiItemModifier};\n use syntax::ext::base::{NormalTT, SyntaxExtension};\n use syntax::ext::expand::{Expansion, Invocation, InvocationKind};\n use syntax::ext::hygiene::Mark;\n@@ -173,15 +173,16 @@ impl<'a> base::Resolver for Resolver<'a> {\n         None\n     }\n \n-    fn resolve_invoc(&mut self, scope: Mark, invoc: &Invocation) -> Option<Rc<SyntaxExtension>> {\n+    fn resolve_invoc(&mut self, scope: Mark, invoc: &Invocation, _force: bool)\n+                     -> Result<Rc<SyntaxExtension>, Determinacy> {\n         let (name, span) = match invoc.kind {\n             InvocationKind::Bang { ref mac, .. } => {\n                 let path = &mac.node.path;\n                 if path.segments.len() > 1 || path.global ||\n                    !path.segments[0].parameters.is_empty() {\n                     self.session.span_err(path.span,\n                                           \"expected macro name without module separators\");\n-                    return None;\n+                    return Err(Determinacy::Determined);\n                 }\n                 (path.segments[0].identifier.name, path.span)\n             }\n@@ -192,12 +193,12 @@ impl<'a> base::Resolver for Resolver<'a> {\n         if let LegacyScope::Expansion(parent) = invocation.legacy_scope.get() {\n             invocation.legacy_scope.set(LegacyScope::simplify_expansion(parent));\n         }\n-        self.resolve_macro_name(invocation.legacy_scope.get(), name, true).or_else(|| {\n+        self.resolve_macro_name(invocation.legacy_scope.get(), name, true).ok_or_else(|| {\n             let mut err =\n                 self.session.struct_span_err(span, &format!(\"macro undefined: '{}!'\", name));\n             self.suggest_macro_name(&name.as_str(), &mut err);\n             err.emit();\n-            None\n+            Determinacy::Determined\n         })\n     }\n "}, {"sha": "a72a660a5c4113169e615a58d6b8e29460a111e5", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31e0e12e6986ca369e9e27fa713c40b174c4d573/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e0e12e6986ca369e9e27fa713c40b174c4d573/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=31e0e12e6986ca369e9e27fa713c40b174c4d573", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use self::Determinacy::*;\n use self::ImportDirectiveSubclass::*;\n \n use Module;\n@@ -26,6 +25,7 @@ use rustc::lint::builtin::PRIVATE_IN_PUBLIC;\n use rustc::hir::def::*;\n \n use syntax::ast::{NodeId, Name};\n+use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n \n@@ -37,12 +37,6 @@ impl<'a> Resolver<'a> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub enum Determinacy {\n-    Determined,\n-    Undetermined,\n-}\n-\n /// Contains data for specific types of import directives.\n #[derive(Clone, Debug)]\n pub enum ImportDirectiveSubclass<'a> {"}, {"sha": "f7c88073c9d405425e431db0f0110d156ffc6ca6", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/31e0e12e6986ca369e9e27fa713c40b174c4d573/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e0e12e6986ca369e9e27fa713c40b174c4d573/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=31e0e12e6986ca369e9e27fa713c40b174c4d573", "patch": "@@ -522,10 +522,17 @@ pub trait Resolver {\n     fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>);\n \n     fn find_attr_invoc(&mut self, attrs: &mut Vec<Attribute>) -> Option<Attribute>;\n-    fn resolve_invoc(&mut self, scope: Mark, invoc: &Invocation) -> Option<Rc<SyntaxExtension>>;\n+    fn resolve_invoc(&mut self, scope: Mark, invoc: &Invocation, force: bool)\n+                     -> Result<Rc<SyntaxExtension>, Determinacy>;\n     fn resolve_derive_mode(&mut self, ident: ast::Ident) -> Option<Rc<MultiItemModifier>>;\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub enum Determinacy {\n+    Determined,\n+    Undetermined,\n+}\n+\n pub struct DummyResolver;\n \n impl Resolver for DummyResolver {\n@@ -539,8 +546,9 @@ impl Resolver for DummyResolver {\n \n     fn find_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>) -> Option<Attribute> { None }\n     fn resolve_derive_mode(&mut self, _ident: ast::Ident) -> Option<Rc<MultiItemModifier>> { None }\n-    fn resolve_invoc(&mut self, _scope: Mark, _invoc: &Invocation) -> Option<Rc<SyntaxExtension>> {\n-        None\n+    fn resolve_invoc(&mut self, _scope: Mark, _invoc: &Invocation, _force: bool)\n+                     -> Result<Rc<SyntaxExtension>, Determinacy> {\n+        Err(Determinacy::Determined)\n     }\n }\n "}, {"sha": "363ceebf0f4750e23b75ac0aa2d58c3d79b285c8", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/31e0e12e6986ca369e9e27fa713c40b174c4d573/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e0e12e6986ca369e9e27fa713c40b174c4d573/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=31e0e12e6986ca369e9e27fa713c40b174c4d573", "patch": "@@ -225,13 +225,36 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         invocations.reverse();\n \n         let mut expansions = Vec::new();\n-        while let Some(invoc) = invocations.pop() {\n+        let mut undetermined_invocations = Vec::new();\n+        let (mut progress, mut force) = (false, !self.monotonic);\n+        loop {\n+            let invoc = if let Some(invoc) = invocations.pop() {\n+                invoc\n+            } else if undetermined_invocations.is_empty() {\n+                break\n+            } else {\n+                invocations = mem::replace(&mut undetermined_invocations, Vec::new());\n+                force = !mem::replace(&mut progress, false);\n+                continue\n+            };\n+\n+            let scope =\n+                if self.monotonic { invoc.expansion_data.mark } else { orig_expansion_data.mark };\n+            let ext = match self.cx.resolver.resolve_invoc(scope, &invoc, force) {\n+                Ok(ext) => Some(ext),\n+                Err(Determinacy::Determined) => None,\n+                Err(Determinacy::Undetermined) => {\n+                    undetermined_invocations.push(invoc);\n+                    continue\n+                }\n+            };\n+\n+            progress = true;\n             let ExpansionData { depth, mark, .. } = invoc.expansion_data;\n             self.cx.current_expansion = invoc.expansion_data.clone();\n \n-            let scope = if self.monotonic { mark } else { orig_expansion_data.mark };\n             self.cx.current_expansion.mark = scope;\n-            let expansion = match self.cx.resolver.resolve_invoc(scope, &invoc) {\n+            let expansion = match ext {\n                 Some(ext) => self.expand_invoc(invoc, ext),\n                 None => invoc.expansion_kind.dummy(invoc.span()),\n             };"}]}