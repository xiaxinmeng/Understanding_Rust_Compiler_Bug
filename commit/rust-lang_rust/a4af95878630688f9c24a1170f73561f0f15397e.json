{"sha": "a4af95878630688f9c24a1170f73561f0f15397e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0YWY5NTg3ODYzMDY4OGY5YzI0YTExNzBmNzM1NjFmMGYxNTM5N2U=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-09-20T01:50:30Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-09-22T16:53:52Z"}, "message": "Use Names in HIR Items", "tree": {"sha": "c458b09b68b7fffacc3d4464a00b2f41ccecc6ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c458b09b68b7fffacc3d4464a00b2f41ccecc6ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4af95878630688f9c24a1170f73561f0f15397e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4af95878630688f9c24a1170f73561f0f15397e", "html_url": "https://github.com/rust-lang/rust/commit/a4af95878630688f9c24a1170f73561f0f15397e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4af95878630688f9c24a1170f73561f0f15397e/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae77dbb835ba3df8742c4e5bdc3f8d5e3d98c6f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae77dbb835ba3df8742c4e5bdc3f8d5e3d98c6f0", "html_url": "https://github.com/rust-lang/rust/commit/ae77dbb835ba3df8742c4e5bdc3f8d5e3d98c6f0"}], "stats": {"total": 411, "additions": 206, "deletions": 205}, "files": [{"sha": "7d4809d457c80c37e9739f38e8a3db2a066fd6d9", "filename": "src/librustc/front/map/blocks.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc%2Ffront%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc%2Ffront%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fblocks.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -26,7 +26,7 @@ pub use self::Code::*;\n use front::map::{self, Node};\n use syntax::abi;\n use rustc_front::hir::{Block, FnDecl};\n-use syntax::ast::{NodeId, Ident};\n+use syntax::ast::{Name, NodeId};\n use rustc_front::hir as ast;\n use syntax::codemap::Span;\n use rustc_front::visit::FnKind;\n@@ -107,7 +107,7 @@ impl<'a> Code<'a> {\n /// These are all the components one can extract from a fn item for\n /// use when implementing FnLikeNode operations.\n struct ItemFnParts<'a> {\n-    ident:    Ident,\n+    name:     Name,\n     decl:     &'a ast::FnDecl,\n     unsafety: ast::Unsafety,\n     constness: ast::Constness,\n@@ -189,21 +189,21 @@ impl<'a> FnLikeNode<'a> {\n \n     pub fn kind(self) -> FnKind<'a> {\n         let item = |p: ItemFnParts<'a>| -> FnKind<'a> {\n-            FnKind::ItemFn(p.ident.name, p.generics, p.unsafety, p.constness, p.abi, p.vis)\n+            FnKind::ItemFn(p.name, p.generics, p.unsafety, p.constness, p.abi, p.vis)\n         };\n         let closure = |_: ClosureParts| {\n             FnKind::Closure\n         };\n-        let method = |_, ident: Ident, sig: &'a ast::MethodSig, vis, _, _| {\n-            FnKind::Method(ident.name, sig, vis)\n+        let method = |_, name: Name, sig: &'a ast::MethodSig, vis, _, _| {\n+            FnKind::Method(name, sig, vis)\n         };\n         self.handle(item, method, closure)\n     }\n \n     fn handle<A, I, M, C>(self, item_fn: I, method: M, closure: C) -> A where\n         I: FnOnce(ItemFnParts<'a>) -> A,\n         M: FnOnce(NodeId,\n-                  Ident,\n+                  Name,\n                   &'a ast::MethodSig,\n                   Option<ast::Visibility>,\n                   &'a ast::Block,\n@@ -216,7 +216,7 @@ impl<'a> FnLikeNode<'a> {\n                 ast::ItemFn(ref decl, unsafety, constness, abi, ref generics, ref block) =>\n                     item_fn(ItemFnParts {\n                         id: i.id,\n-                        ident: i.ident,\n+                        name: i.name,\n                         decl: &**decl,\n                         unsafety: unsafety,\n                         body: &**block,\n@@ -230,14 +230,14 @@ impl<'a> FnLikeNode<'a> {\n             },\n             map::NodeTraitItem(ti) => match ti.node {\n                 ast::MethodTraitItem(ref sig, Some(ref body)) => {\n-                    method(ti.id, ti.ident, sig, None, body, ti.span)\n+                    method(ti.id, ti.name, sig, None, body, ti.span)\n                 }\n                 _ => panic!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n             map::NodeImplItem(ii) => {\n                 match ii.node {\n                     ast::MethodImplItem(ref sig, ref body) => {\n-                        method(ii.id, ii.ident, sig, Some(ii.vis), body, ii.span)\n+                        method(ii.id, ii.name, sig, Some(ii.vis), body, ii.span)\n                     }\n                     _ => {\n                         panic!(\"impl method FnLikeNode that is not fn-like\")"}, {"sha": "dd420ae28845a78d24eda674c29e3bb531020760", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -17,7 +17,7 @@ use metadata::inline::InlinedItem as II;\n use middle::def_id::DefId;\n \n use syntax::abi;\n-use syntax::ast::{self, Name, NodeId, Ident, CRATE_NODE_ID, DUMMY_NODE_ID};\n+use syntax::ast::{self, Name, NodeId, CRATE_NODE_ID, DUMMY_NODE_ID};\n use syntax::codemap::{Span, Spanned};\n use syntax::parse::token;\n \n@@ -475,14 +475,14 @@ impl<'ast> Map<'ast> {\n             NodeItem(item) => {\n                 match item.node {\n                     ItemMod(_) | ItemForeignMod(_) => {\n-                        PathMod(item.ident.name)\n+                        PathMod(item.name)\n                     }\n-                    _ => PathName(item.ident.name)\n+                    _ => PathName(item.name)\n                 }\n             }\n-            NodeForeignItem(i) => PathName(i.ident.name),\n-            NodeImplItem(ii) => PathName(ii.ident.name),\n-            NodeTraitItem(ti) => PathName(ti.ident.name),\n+            NodeForeignItem(i) => PathName(i.name),\n+            NodeImplItem(ii) => PathName(ii.name),\n+            NodeTraitItem(ti) => PathName(ti.name),\n             NodeVariant(v) => PathName(v.node.name.name),\n             NodeLifetime(lt) => PathName(lt.name),\n             _ => panic!(\"no path elem for {:?}\", node)\n@@ -499,9 +499,9 @@ impl<'ast> Map<'ast> {\n         self.with_path(id, |path| path_to_string(path))\n     }\n \n-    fn path_to_str_with_ident(&self, id: NodeId, i: Ident) -> String {\n+    fn path_to_str_with_name(&self, id: NodeId, name: Name) -> String {\n         self.with_path(id, |path| {\n-            path_to_string(path.chain(Some(PathName(i.name))))\n+            path_to_string(path.chain(Some(PathName(name))))\n         })\n     }\n \n@@ -652,7 +652,7 @@ impl<'a, 'ast> NodesMatchingSuffix<'a, 'ast> {\n                 match map.find(id) {\n                     None => return None,\n                     Some(NodeItem(item)) if item_is_mod(&*item) =>\n-                        return Some((id, item.ident.name)),\n+                        return Some((id, item.name)),\n                     _ => {}\n                 }\n                 let parent = map.get_parent(id);\n@@ -708,11 +708,11 @@ trait Named {\n \n impl<T:Named> Named for Spanned<T> { fn name(&self) -> Name { self.node.name() } }\n \n-impl Named for Item { fn name(&self) -> Name { self.ident.name } }\n-impl Named for ForeignItem { fn name(&self) -> Name { self.ident.name } }\n+impl Named for Item { fn name(&self) -> Name { self.name } }\n+impl Named for ForeignItem { fn name(&self) -> Name { self.name } }\n impl Named for Variant_ { fn name(&self) -> Name { self.name.name } }\n-impl Named for TraitItem { fn name(&self) -> Name { self.ident.name } }\n-impl Named for ImplItem { fn name(&self) -> Name { self.ident.name } }\n+impl Named for TraitItem { fn name(&self) -> Name { self.name } }\n+impl Named for ImplItem { fn name(&self) -> Name { self.name } }\n \n pub trait FoldOps {\n     fn new_id(&self, id: NodeId) -> NodeId {\n@@ -1040,7 +1040,7 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n \n     match map.find(id) {\n         Some(NodeItem(item)) => {\n-            let path_str = map.path_to_str_with_ident(id, item.ident);\n+            let path_str = map.path_to_str_with_name(id, item.name);\n             let item_str = match item.node {\n                 ItemExternCrate(..) => \"extern crate\",\n                 ItemUse(..) => \"use\",\n@@ -1059,25 +1059,25 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n             format!(\"{} {}{}\", item_str, path_str, id_str)\n         }\n         Some(NodeForeignItem(item)) => {\n-            let path_str = map.path_to_str_with_ident(id, item.ident);\n+            let path_str = map.path_to_str_with_name(id, item.name);\n             format!(\"foreign item {}{}\", path_str, id_str)\n         }\n         Some(NodeImplItem(ii)) => {\n             match ii.node {\n                 ConstImplItem(..) => {\n                     format!(\"assoc const {} in {}{}\",\n-                            ii.ident,\n+                            ii.name,\n                             map.path_to_string(id),\n                             id_str)\n                 }\n                 MethodImplItem(..) => {\n                     format!(\"method {} in {}{}\",\n-                            ii.ident,\n+                            ii.name,\n                             map.path_to_string(id), id_str)\n                 }\n                 TypeImplItem(_) => {\n                     format!(\"assoc type {} in {}{}\",\n-                            ii.ident,\n+                            ii.name,\n                             map.path_to_string(id),\n                             id_str)\n                 }\n@@ -1092,7 +1092,7 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n \n             format!(\"{} {} in {}{}\",\n                     kind,\n-                    ti.ident,\n+                    ti.name,\n                     map.path_to_string(id),\n                     id_str)\n         }"}, {"sha": "8a879815980361d2e99dcf2ce85f80f55f918877", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -201,17 +201,17 @@ impl<'a> CrateReader<'a> {\n         match i.node {\n             hir::ItemExternCrate(ref path_opt) => {\n                 debug!(\"resolving extern crate stmt. ident: {} path_opt: {:?}\",\n-                       i.ident, path_opt);\n+                       i.name, path_opt);\n                 let name = match *path_opt {\n                     Some(name) => {\n                         validate_crate_name(Some(self.sess), &name.as_str(),\n                                             Some(i.span));\n                         name.to_string()\n                     }\n-                    None => i.ident.to_string(),\n+                    None => i.name.to_string(),\n                 };\n                 Some(CrateInfo {\n-                    ident: i.ident.to_string(),\n+                    ident: i.name.to_string(),\n                     name: name,\n                     id: i.id,\n                     should_link: should_link_hir(i),"}, {"sha": "92a2c32c59445ff5dd598d6e8b2a94025ff5d4cd", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -426,16 +426,16 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n         // encoded metadata for static methods relative to Bar,\n         // but not yet for Foo.\n         //\n-        if path_differs || item.ident.name != exp.name {\n+        if path_differs || item.name != exp.name {\n             if !encode_reexported_static_base_methods(ecx, rbml_w, exp) {\n                 if encode_reexported_static_trait_methods(ecx, rbml_w, exp) {\n                     debug!(\"(encode reexported static methods) {} [trait]\",\n-                           item.ident.name);\n+                           item.name);\n                 }\n             }\n             else {\n                 debug!(\"(encode reexported static methods) {} [base]\",\n-                       item.ident.name);\n+                       item.name);\n             }\n         }\n     }\n@@ -520,7 +520,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n         });\n \n         if let hir::ItemImpl(..) = item.node {\n-            let (ident, did) = (item.ident, item.id);\n+            let (ident, did) = (item.name, item.id);\n             debug!(\"(encoding info for module) ... encoding impl {} ({}/{})\",\n                    ident,\n                    did, ecx.tcx.map.node_to_string(did));\n@@ -1014,7 +1014,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         }\n         encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n         encode_symbol(ecx, rbml_w, item.id);\n-        encode_name(rbml_w, item.ident.name);\n+        encode_name(rbml_w, item.name);\n         encode_path(rbml_w, path);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n@@ -1027,7 +1027,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, 'C');\n         encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n-        encode_name(rbml_w, item.ident.name);\n+        encode_name(rbml_w, item.name);\n         encode_path(rbml_w, path);\n         encode_attributes(rbml_w, &item.attrs);\n         encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n@@ -1042,7 +1042,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_family(rbml_w, FN_FAMILY);\n         let tps_len = generics.ty_params.len();\n         encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n-        encode_name(rbml_w, item.ident.name);\n+        encode_name(rbml_w, item.name);\n         encode_path(rbml_w, path);\n         encode_attributes(rbml_w, &item.attrs);\n         let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n@@ -1066,15 +1066,15 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                             &item.attrs,\n                             item.id,\n                             path,\n-                            item.ident.name,\n+                            item.name,\n                             item.vis);\n       }\n       hir::ItemForeignMod(ref fm) => {\n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, 'n');\n-        encode_name(rbml_w, item.ident.name);\n+        encode_name(rbml_w, item.name);\n         encode_path(rbml_w, path);\n \n         // Encode all the items in this module.\n@@ -1092,7 +1092,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, 'y');\n         encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n-        encode_name(rbml_w, item.ident.name);\n+        encode_name(rbml_w, item.name);\n         encode_path(rbml_w, path);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n@@ -1106,7 +1106,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_family(rbml_w, 't');\n         encode_item_variances(rbml_w, ecx, item.id);\n         encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n-        encode_name(rbml_w, item.ident.name);\n+        encode_name(rbml_w, item.name);\n         encode_attributes(rbml_w, &item.attrs);\n         encode_repr_attrs(rbml_w, ecx, &item.attrs);\n         for v in &enum_definition.variants {\n@@ -1146,7 +1146,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n \n         encode_item_variances(rbml_w, ecx, item.id);\n-        encode_name(rbml_w, item.ident.name);\n+        encode_name(rbml_w, item.name);\n         encode_attributes(rbml_w, &item.attrs);\n         encode_path(rbml_w, path.clone());\n         encode_stability(rbml_w, stab);\n@@ -1168,7 +1168,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // If this is a tuple-like struct, encode the type of the constructor.\n         match struct_def.ctor_id {\n             Some(ctor_id) => {\n-                encode_info_for_struct_ctor(ecx, rbml_w, item.ident.name,\n+                encode_info_for_struct_ctor(ecx, rbml_w, item.name,\n                                             ctor_id, index, def_id.node);\n             }\n             None => {}\n@@ -1179,7 +1179,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n           rbml_w.start_tag(tag_items_data_item);\n           encode_def_id(rbml_w, def_id);\n           encode_family(rbml_w, 'd');\n-          encode_name(rbml_w, item.ident.name);\n+          encode_name(rbml_w, item.name);\n           encode_unsafety(rbml_w, unsafety);\n \n           let trait_ref = tcx.impl_trait_ref(DefId::local(item.id)).unwrap();\n@@ -1197,7 +1197,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_def_id(rbml_w, def_id);\n         encode_family(rbml_w, 'i');\n         encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n-        encode_name(rbml_w, item.ident.name);\n+        encode_name(rbml_w, item.name);\n         encode_attributes(rbml_w, &item.attrs);\n         encode_unsafety(rbml_w, unsafety);\n         encode_polarity(rbml_w, polarity);\n@@ -1306,7 +1306,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_predicates(rbml_w, ecx, &tcx.lookup_super_predicates(def_id),\n                           tag_item_super_predicates);\n         encode_trait_ref(rbml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n-        encode_name(rbml_w, item.ident.name);\n+        encode_name(rbml_w, item.name);\n         encode_attributes(rbml_w, &item.attrs);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n@@ -1483,7 +1483,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n       hir::ForeignItemFn(ref fndecl, _) => {\n         encode_family(rbml_w, FN_FAMILY);\n         encode_bounds_and_type_for_item(rbml_w, ecx, nitem.id);\n-        encode_name(rbml_w, nitem.ident.name);\n+        encode_name(rbml_w, nitem.name);\n         if abi == abi::RustIntrinsic || abi == abi::PlatformIntrinsic {\n             encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(nitem));\n         }\n@@ -1504,7 +1504,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         let stab = stability::lookup(ecx.tcx, DefId::local(nitem.id));\n         encode_stability(rbml_w, stab);\n         encode_symbol(ecx, rbml_w, nitem.id);\n-        encode_name(rbml_w, nitem.ident.name);\n+        encode_name(rbml_w, nitem.name);\n       }\n     }\n     encode_path(rbml_w, path);\n@@ -1528,7 +1528,7 @@ fn my_visit_foreign_item(ni: &hir::ForeignItem,\n                          index: &mut Vec<IndexEntry>) {\n     debug!(\"writing foreign item {}::{}\",\n             ecx.tcx.map.path_to_string(ni.id),\n-            ni.ident);\n+            ni.name);\n \n     let abi = ecx.tcx.map.get_foreign_abi(ni.id);\n     ecx.tcx.map.with_path(ni.id, |path| {"}, {"sha": "270734a21e23977240fe6f2ac2d572d8945782ec", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -155,16 +155,16 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n         let raw_ii = decode_ast(ast_doc);\n         let ii = ast_map::map_decoded_item(&dcx.tcx.map, path, raw_ii, dcx);\n \n-        let ident = match *ii {\n-            InlinedItem::Item(ref i) => i.ident,\n-            InlinedItem::Foreign(ref i) => i.ident,\n-            InlinedItem::TraitItem(_, ref ti) => ti.ident,\n-            InlinedItem::ImplItem(_, ref ii) => ii.ident\n+        let name = match *ii {\n+            InlinedItem::Item(ref i) => i.name,\n+            InlinedItem::Foreign(ref i) => i.name,\n+            InlinedItem::TraitItem(_, ref ti) => ti.name,\n+            InlinedItem::ImplItem(_, ref ii) => ii.name\n         };\n-        debug!(\"Fn named: {}\", ident);\n+        debug!(\"Fn named: {}\", name);\n         debug!(\"< Decoded inlined fn: {}::{}\",\n                path_as_str.unwrap(),\n-               ident);\n+               name);\n         region::resolve_inlined_item(&tcx.sess, &tcx.region_maps, ii);\n         decode_side_tables(dcx, ast_doc);\n         match *ii {"}, {"sha": "ae9f0108610912b8196f883d993c32115141fbd2", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -1109,7 +1109,7 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n     match selection {\n         traits::VtableImpl(ref impl_data) => {\n             match tcx.associated_consts(impl_data.impl_def_id)\n-                     .iter().find(|ic| ic.name == ti.ident.name) {\n+                     .iter().find(|ic| ic.name == ti.name) {\n                 Some(ic) => lookup_const_by_id(tcx, ic.def_id, None),\n                 None => match ti.node {\n                     hir::ConstTraitItem(_, Some(ref expr)) => Some(&*expr),"}, {"sha": "3a7ba8229809306b059f8a0923bffd283506f95a", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -520,7 +520,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n             self.warn_dead_code(\n                 item.id,\n                 item.span,\n-                item.ident.name,\n+                item.name,\n                 item.node.descriptive_variant()\n             );\n         } else {\n@@ -541,7 +541,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, fi: &hir::ForeignItem) {\n         if !self.symbol_is_live(fi.id, None) {\n-            self.warn_dead_code(fi.id, fi.span, fi.ident.name, fi.node.descriptive_variant());\n+            self.warn_dead_code(fi.id, fi.span, fi.name, fi.node.descriptive_variant());\n         }\n         visit::walk_foreign_item(self, fi);\n     }\n@@ -560,14 +560,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n             hir::ConstImplItem(_, ref expr) => {\n                 if !self.symbol_is_live(impl_item.id, None) {\n                     self.warn_dead_code(impl_item.id, impl_item.span,\n-                                        impl_item.ident.name, \"associated const\");\n+                                        impl_item.name, \"associated const\");\n                 }\n                 visit::walk_expr(self, expr)\n             }\n             hir::MethodImplItem(_, ref body) => {\n                 if !self.symbol_is_live(impl_item.id, None) {\n                     self.warn_dead_code(impl_item.id, impl_item.span,\n-                                        impl_item.ident.name, \"method\");\n+                                        impl_item.name, \"method\");\n                 }\n                 visit::walk_block(self, body)\n             }"}, {"sha": "4b45aedd47640c9dfb69026e5a6572b0af792966", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -85,7 +85,7 @@ fn entry_point_type(item: &Item, depth: usize) -> EntryPointType {\n                 EntryPointType::Start\n             } else if attr::contains_name(&item.attrs, \"main\") {\n                 EntryPointType::MainAttr\n-            } else if item.ident.name == \"main\" {\n+            } else if item.name == \"main\" {\n                 if depth == 1 {\n                     // This is a top-level function so can be 'main'\n                     EntryPointType::MainNamed"}, {"sha": "2b2f4e6d84e4821492f92b4d075652f012246e45", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -284,7 +284,7 @@ trait ErrorReportingHelpers<'tcx> {\n                                 decl: &hir::FnDecl,\n                                 unsafety: hir::Unsafety,\n                                 constness: hir::Constness,\n-                                ident: ast::Ident,\n+                                name: ast::Name,\n                                 opt_explicit_self: Option<&hir::ExplicitSelf_>,\n                                 generics: &hir::Generics,\n                                 span: Span);\n@@ -978,7 +978,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     match item.node {\n                         hir::ItemFn(ref fn_decl, unsafety, constness, _, ref gen, _) => {\n                             Some((fn_decl, gen, unsafety, constness,\n-                                  item.ident, None, item.span))\n+                                  item.name, None, item.span))\n                         },\n                         _ => None\n                     }\n@@ -990,7 +990,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                   &sig.generics,\n                                   sig.unsafety,\n                                   sig.constness,\n-                                  item.ident,\n+                                  item.name,\n                                   Some(&sig.explicit_self.node),\n                                   item.span))\n                         }\n@@ -1004,7 +1004,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                   &sig.generics,\n                                   sig.unsafety,\n                                   sig.constness,\n-                                  item.ident,\n+                                  item.name,\n                                   Some(&sig.explicit_self.node),\n                                   item.span))\n                         }\n@@ -1576,11 +1576,11 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                                 decl: &hir::FnDecl,\n                                 unsafety: hir::Unsafety,\n                                 constness: hir::Constness,\n-                                ident: ast::Ident,\n+                                name: ast::Name,\n                                 opt_explicit_self: Option<&hir::ExplicitSelf_>,\n                                 generics: &hir::Generics,\n                                 span: Span) {\n-        let suggested_fn = pprust::fun_to_string(decl, unsafety, constness, ident,\n+        let suggested_fn = pprust::fun_to_string(decl, unsafety, constness, name,\n                                                  opt_explicit_self, generics);\n         let msg = format!(\"consider using an explicit lifetime \\\n                            parameter as shown: {}\", suggested_fn);"}, {"sha": "be199212750438339ba61ea54b052f5b9c3f2f2d", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -336,7 +336,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n         // When compiling with --test we don't enforce stability on the\n         // compiler-generated test module, demarcated with `DUMMY_SP` plus the\n         // name `__test`\n-        if item.span == DUMMY_SP && item.ident.name == \"__test\" { return }\n+        if item.span == DUMMY_SP && item.name == \"__test\" { return }\n \n         check_item(self.tcx, item, true,\n                    &mut |id, sp, stab| self.check(id, sp, stab));\n@@ -393,7 +393,7 @@ pub fn check_item(tcx: &ty::ctxt, item: &hir::Item, warn_about_defns: bool,\n \n             for impl_item in impl_items {\n                 let item = trait_items.iter().find(|item| {\n-                    item.name() == impl_item.ident.name\n+                    item.name() == impl_item.name\n                 }).unwrap();\n                 if warn_about_defns {\n                     maybe_do_stability_check(tcx, item.def_id(), impl_item.span, cb);"}, {"sha": "cf98b1bd8fda2b32df1b65615813e668545285d4", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -195,7 +195,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                       -> Option<ast::NodeId> {\n             assert!(idx < names.len());\n             for item in &m.items {\n-                if item.ident.to_string() == names[idx] {\n+                if item.name.to_string() == names[idx] {\n                     return search(this, &**item, idx+1, names);\n                 }\n             }"}, {"sha": "f0b4e5328b57c5eec587b6c02e1bf26e3406f699", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -837,9 +837,9 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n \n pub fn noop_fold_trait_item<T: Folder>(i: P<TraitItem>, folder: &mut T)\n                                        -> SmallVector<P<TraitItem>> {\n-    SmallVector::one(i.map(|TraitItem {id, ident, attrs, node, span}| TraitItem {\n+    SmallVector::one(i.map(|TraitItem {id, name, attrs, node, span}| TraitItem {\n         id: folder.new_id(id),\n-        ident: fold_ident(folder, ident),\n+        name: folder.fold_name(name),\n         attrs: fold_attrs(attrs, folder),\n         node: match node {\n             ConstTraitItem(ty, default) => {\n@@ -861,9 +861,9 @@ pub fn noop_fold_trait_item<T: Folder>(i: P<TraitItem>, folder: &mut T)\n \n pub fn noop_fold_impl_item<T: Folder>(i: P<ImplItem>, folder: &mut T)\n                                       -> SmallVector<P<ImplItem>> {\n-    SmallVector::one(i.map(|ImplItem {id, ident, attrs, node, vis, span}| ImplItem {\n+    SmallVector::one(i.map(|ImplItem {id, name, attrs, node, vis, span}| ImplItem {\n         id: folder.new_id(id),\n-        ident: fold_ident(folder, ident),\n+        name: folder.fold_name(name),\n         attrs: fold_attrs(attrs, folder),\n         vis: vis,\n         node: match node  {\n@@ -892,7 +892,7 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, span, exported_m\n     let config = folder.fold_meta_items(config);\n \n     let mut items = folder.fold_item(P(hir::Item {\n-        ident: token::special_idents::invalid,\n+        name: token::special_idents::invalid.name,\n         attrs: attrs,\n         id: DUMMY_NODE_ID,\n         vis: hir::Public,\n@@ -932,7 +932,7 @@ pub fn noop_fold_item<T: Folder>(i: P<Item>, folder: &mut T) -> SmallVector<P<It\n }\n \n // fold one item into exactly one item\n-pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span}: Item,\n+pub fn noop_fold_item_simple<T: Folder>(Item {id, name, attrs, node, vis, span}: Item,\n                                         folder: &mut T) -> Item {\n     let id = folder.new_id(id);\n     let node = folder.fold_item_underscore(node);\n@@ -947,7 +947,7 @@ pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span}\n \n     Item {\n         id: id,\n-        ident: fold_ident(folder, ident),\n+        name: folder.fold_name(name),\n         attrs: fold_attrs(attrs, folder),\n         node: node,\n         vis: vis,\n@@ -956,9 +956,9 @@ pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span}\n }\n \n pub fn noop_fold_foreign_item<T: Folder>(ni: P<ForeignItem>, folder: &mut T) -> P<ForeignItem> {\n-    ni.map(|ForeignItem {id, ident, attrs, node, span, vis}| ForeignItem {\n+    ni.map(|ForeignItem {id, name, attrs, node, span, vis}| ForeignItem {\n         id: folder.new_id(id),\n-        ident: fold_ident(folder, ident),\n+        name: folder.fold_name(name),\n         attrs: fold_attrs(attrs, folder),\n         node: match node {\n             ForeignItemFn(fdec, generics) => {"}, {"sha": "7997ac7ea102f2177d6e21d516f2bf291bdb7668", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -770,7 +770,7 @@ pub struct MethodSig {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TraitItem {\n     pub id: NodeId,\n-    pub ident: Ident,\n+    pub name: Name,\n     pub attrs: Vec<Attribute>,\n     pub node: TraitItem_,\n     pub span: Span,\n@@ -786,7 +786,7 @@ pub enum TraitItem_ {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ImplItem {\n     pub id: NodeId,\n-    pub ident: Ident,\n+    pub name: Name,\n     pub vis: Visibility,\n     pub attrs: Vec<Attribute>,\n     pub node: ImplItem_,\n@@ -1190,7 +1190,7 @@ pub struct StructDef {\n /// The name might be a dummy name in case of anonymous items\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Item {\n-    pub ident: Ident,\n+    pub name: Name,\n     pub attrs: Vec<Attribute>,\n     pub id: NodeId,\n     pub node: Item_,\n@@ -1264,7 +1264,7 @@ impl Item_ {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ForeignItem {\n-    pub ident: Ident,\n+    pub name: Name,\n     pub attrs: Vec<Attribute>,\n     pub node: ForeignItem_,\n     pub id: NodeId,"}, {"sha": "92a77131bda27b5e6f17f52d05226d7918c7f3fa", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -466,7 +466,7 @@ pub fn lower_item_underscore(i: &Item_) -> hir::Item_ {\n pub fn lower_trait_item(i: &TraitItem) -> P<hir::TraitItem> {\n     P(hir::TraitItem {\n             id: i.id,\n-            ident: i.ident,\n+            name: i.ident.name,\n             attrs: i.attrs.clone(),\n             node: match i.node {\n             ConstTraitItem(ref ty, ref default) => {\n@@ -489,7 +489,7 @@ pub fn lower_trait_item(i: &TraitItem) -> P<hir::TraitItem> {\n pub fn lower_impl_item(i: &ImplItem) -> P<hir::ImplItem> {\n     P(hir::ImplItem {\n             id: i.id,\n-            ident: i.ident,\n+            name: i.ident.name,\n             attrs: i.attrs.clone(),\n             vis: lower_visibility(i.vis),\n             node: match i.node  {\n@@ -546,7 +546,7 @@ pub fn lower_item_simple(i: &Item) -> hir::Item {\n \n     hir::Item {\n         id: i.id,\n-        ident: i.ident,\n+        name: i.ident.name,\n         attrs: i.attrs.clone(),\n         node: node,\n         vis: lower_visibility(i.vis),\n@@ -557,7 +557,7 @@ pub fn lower_item_simple(i: &Item) -> hir::Item {\n pub fn lower_foreign_item(i: &ForeignItem) -> P<hir::ForeignItem> {\n     P(hir::ForeignItem {\n             id: i.id,\n-            ident: i.ident,\n+            name: i.ident.name,\n             attrs: i.attrs.clone(),\n             node: match i.node {\n             ForeignItemFn(ref fdec, ref generics) => {"}, {"sha": "ba944bfd9883b945cc7765ac740c6764c3456433", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -271,7 +271,7 @@ pub fn ident_to_string(id: &ast::Ident) -> String {\n pub fn fun_to_string(decl: &hir::FnDecl,\n                      unsafety: hir::Unsafety,\n                      constness: hir::Constness,\n-                     name: ast::Ident,\n+                     name: ast::Name,\n                      opt_explicit_self: Option<&hir::ExplicitSelf_>,\n                      generics: &hir::Generics)\n                      -> String {\n@@ -557,7 +557,7 @@ impl<'a> State<'a> {\n                 try!(self.head(\"\"));\n                 try!(self.print_fn(decl, hir::Unsafety::Normal,\n                                    hir::Constness::NotConst,\n-                                   abi::Rust, Some(item.ident),\n+                                   abi::Rust, Some(item.name),\n                                    generics, None, item.vis));\n                 try!(self.end()); // end head-ibox\n                 try!(word(&mut self.s, \";\"));\n@@ -569,7 +569,7 @@ impl<'a> State<'a> {\n                 if m {\n                     try!(self.word_space(\"mut\"));\n                 }\n-                try!(self.print_ident(item.ident));\n+                try!(self.print_name(item.name));\n                 try!(self.word_space(\":\"));\n                 try!(self.print_type(&**t));\n                 try!(word(&mut self.s, \";\"));\n@@ -580,15 +580,15 @@ impl<'a> State<'a> {\n     }\n \n     fn print_associated_const(&mut self,\n-                              ident: ast::Ident,\n+                              name: ast::Name,\n                               ty: &hir::Ty,\n                               default: Option<&hir::Expr>,\n                               vis: hir::Visibility)\n                               -> io::Result<()>\n     {\n         try!(word(&mut self.s, &visibility_qualified(vis, \"\")));\n         try!(self.word_space(\"const\"));\n-        try!(self.print_ident(ident));\n+        try!(self.print_name(name));\n         try!(self.word_space(\":\"));\n         try!(self.print_type(ty));\n         if let Some(expr) = default {\n@@ -600,12 +600,12 @@ impl<'a> State<'a> {\n     }\n \n     fn print_associated_type(&mut self,\n-                             ident: ast::Ident,\n+                             name: ast::Name,\n                              bounds: Option<&hir::TyParamBounds>,\n                              ty: Option<&hir::Ty>)\n                              -> io::Result<()> {\n         try!(self.word_space(\"type\"));\n-        try!(self.print_ident(ident));\n+        try!(self.print_name(name));\n         if let Some(bounds) = bounds {\n             try!(self.print_bounds(\":\", bounds));\n         }\n@@ -638,7 +638,7 @@ impl<'a> State<'a> {\n                     try!(word(&mut self.s, \"as\"));\n                     try!(space(&mut self.s));\n                 }\n-                try!(self.print_ident(item.ident));\n+                try!(self.print_name(item.name));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end inner head-block\n                 try!(self.end()); // end outer head-block\n@@ -657,7 +657,7 @@ impl<'a> State<'a> {\n                 if m == hir::MutMutable {\n                     try!(self.word_space(\"mut\"));\n                 }\n-                try!(self.print_ident(item.ident));\n+                try!(self.print_name(item.name));\n                 try!(self.word_space(\":\"));\n                 try!(self.print_type(&**ty));\n                 try!(space(&mut self.s));\n@@ -671,7 +671,7 @@ impl<'a> State<'a> {\n             hir::ItemConst(ref ty, ref expr) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n                                                     \"const\")));\n-                try!(self.print_ident(item.ident));\n+                try!(self.print_name(item.name));\n                 try!(self.word_space(\":\"));\n                 try!(self.print_type(&**ty));\n                 try!(space(&mut self.s));\n@@ -689,7 +689,7 @@ impl<'a> State<'a> {\n                     unsafety,\n                     constness,\n                     abi,\n-                    Some(item.ident),\n+                    Some(item.name),\n                     typarams,\n                     None,\n                     item.vis\n@@ -700,7 +700,7 @@ impl<'a> State<'a> {\n             hir::ItemMod(ref _mod) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n                                                     \"mod\")));\n-                try!(self.print_ident(item.ident));\n+                try!(self.print_name(item.name));\n                 try!(self.nbsp());\n                 try!(self.bopen());\n                 try!(self.print_mod(_mod, &item.attrs));\n@@ -717,7 +717,7 @@ impl<'a> State<'a> {\n                 try!(self.ibox(indent_unit));\n                 try!(self.ibox(0));\n                 try!(self.word_nbsp(&visibility_qualified(item.vis, \"type\")));\n-                try!(self.print_ident(item.ident));\n+                try!(self.print_name(item.name));\n                 try!(self.print_generics(params));\n                 try!(self.end()); // end the inner ibox\n \n@@ -732,14 +732,14 @@ impl<'a> State<'a> {\n                 try!(self.print_enum_def(\n                     enum_definition,\n                     params,\n-                    item.ident,\n+                    item.name,\n                     item.span,\n                     item.vis\n                 ));\n             }\n             hir::ItemStruct(ref struct_def, ref generics) => {\n                 try!(self.head(&visibility_qualified(item.vis,\"struct\")));\n-                try!(self.print_struct(&**struct_def, generics, item.ident, item.span));\n+                try!(self.print_struct(&**struct_def, generics, item.name, item.span));\n             }\n \n             hir::ItemDefaultImpl(unsafety, ref trait_ref) => {\n@@ -802,7 +802,7 @@ impl<'a> State<'a> {\n                 try!(self.print_visibility(item.vis));\n                 try!(self.print_unsafety(unsafety));\n                 try!(self.word_nbsp(\"trait\"));\n-                try!(self.print_ident(item.ident));\n+                try!(self.print_name(item.name));\n                 try!(self.print_generics(generics));\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n                 for b in bounds.iter() {\n@@ -853,11 +853,11 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_enum_def(&mut self, enum_definition: &hir::EnumDef,\n-                          generics: &hir::Generics, ident: ast::Ident,\n+                          generics: &hir::Generics, name: ast::Name,\n                           span: codemap::Span,\n                           visibility: hir::Visibility) -> io::Result<()> {\n         try!(self.head(&visibility_qualified(visibility, \"enum\")));\n-        try!(self.print_ident(ident));\n+        try!(self.print_name(name));\n         try!(self.print_generics(generics));\n         try!(self.print_where_clause(&generics.where_clause));\n         try!(space(&mut self.s));\n@@ -891,9 +891,9 @@ impl<'a> State<'a> {\n     pub fn print_struct(&mut self,\n                         struct_def: &hir::StructDef,\n                         generics: &hir::Generics,\n-                        ident: ast::Ident,\n+                        name: ast::Name,\n                         span: codemap::Span) -> io::Result<()> {\n-        try!(self.print_ident(ident));\n+        try!(self.print_name(name));\n         try!(self.print_generics(generics));\n         if ::util::struct_def_is_tuple_like(struct_def) {\n             if !struct_def.fields.is_empty() {\n@@ -958,7 +958,7 @@ impl<'a> State<'a> {\n             hir::StructVariantKind(ref struct_def) => {\n                 try!(self.head(\"\"));\n                 let generics = ::util::empty_generics();\n-                try!(self.print_struct(&**struct_def, &generics, v.node.name, v.span));\n+                try!(self.print_struct(&**struct_def, &generics, v.node.name.name, v.span));\n             }\n         }\n         match v.node.disr_expr {\n@@ -972,15 +972,15 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_method_sig(&mut self,\n-                            ident: ast::Ident,\n+                            name: ast::Name,\n                             m: &hir::MethodSig,\n                             vis: hir::Visibility)\n                             -> io::Result<()> {\n         self.print_fn(&m.decl,\n                       m.unsafety,\n                       m.constness,\n                       m.abi,\n-                      Some(ident),\n+                      Some(name),\n                       &m.generics,\n                       Some(&m.explicit_self.node),\n                       vis)\n@@ -994,15 +994,15 @@ impl<'a> State<'a> {\n         try!(self.print_outer_attributes(&ti.attrs));\n         match ti.node {\n             hir::ConstTraitItem(ref ty, ref default) => {\n-                try!(self.print_associated_const(ti.ident, &ty,\n+                try!(self.print_associated_const(ti.name, &ty,\n                                                  default.as_ref().map(|expr| &**expr),\n                                                  hir::Inherited));\n             }\n             hir::MethodTraitItem(ref sig, ref body) => {\n                 if body.is_some() {\n                     try!(self.head(\"\"));\n                 }\n-                try!(self.print_method_sig(ti.ident, sig, hir::Inherited));\n+                try!(self.print_method_sig(ti.name, sig, hir::Inherited));\n                 if let Some(ref body) = *body {\n                     try!(self.nbsp());\n                     try!(self.print_block_with_attrs(body, &ti.attrs));\n@@ -1011,7 +1011,7 @@ impl<'a> State<'a> {\n                 }\n             }\n             hir::TypeTraitItem(ref bounds, ref default) => {\n-                try!(self.print_associated_type(ti.ident, Some(bounds),\n+                try!(self.print_associated_type(ti.name, Some(bounds),\n                                                 default.as_ref().map(|ty| &**ty)));\n             }\n         }\n@@ -1025,16 +1025,16 @@ impl<'a> State<'a> {\n         try!(self.print_outer_attributes(&ii.attrs));\n         match ii.node {\n             hir::ConstImplItem(ref ty, ref expr) => {\n-                try!(self.print_associated_const(ii.ident, &ty, Some(&expr), ii.vis));\n+                try!(self.print_associated_const(ii.name, &ty, Some(&expr), ii.vis));\n             }\n             hir::MethodImplItem(ref sig, ref body) => {\n                 try!(self.head(\"\"));\n-                try!(self.print_method_sig(ii.ident, sig, ii.vis));\n+                try!(self.print_method_sig(ii.name, sig, ii.vis));\n                 try!(self.nbsp());\n                 try!(self.print_block_with_attrs(body, &ii.attrs));\n             }\n             hir::TypeImplItem(ref ty) => {\n-                try!(self.print_associated_type(ii.ident, None, Some(ty)));\n+                try!(self.print_associated_type(ii.name, None, Some(ty)));\n             }\n         }\n         self.ann.post(self, NodeSubItem(ii.id))\n@@ -1928,15 +1928,15 @@ impl<'a> State<'a> {\n                     unsafety: hir::Unsafety,\n                     constness: hir::Constness,\n                     abi: abi::Abi,\n-                    name: Option<ast::Ident>,\n+                    name: Option<ast::Name>,\n                     generics: &hir::Generics,\n                     opt_explicit_self: Option<&hir::ExplicitSelf_>,\n                     vis: hir::Visibility) -> io::Result<()> {\n         try!(self.print_fn_header_info(unsafety, constness, abi, vis));\n \n         if let Some(name) = name {\n             try!(self.nbsp());\n-            try!(self.print_ident(name));\n+            try!(self.print_name(name));\n         }\n         try!(self.print_generics(generics));\n         try!(self.print_fn_args_and_ret(decl, opt_explicit_self));\n@@ -2299,7 +2299,7 @@ impl<'a> State<'a> {\n                            unsafety,\n                            hir::Constness::NotConst,\n                            abi,\n-                           name,\n+                           name.map(|x| x.name),\n                            &generics,\n                            opt_explicit_self,\n                            hir::Inherited));"}, {"sha": "9f254b6840c16df19507b2c7060e9855edd63bc7", "filename": "src/librustc_front/visit.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_front%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_front%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fvisit.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -198,7 +198,7 @@ pub fn walk_trait_ref<'v,V>(visitor: &mut V,\n }\n \n pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n-    visitor.visit_name(item.span, item.ident.name);\n+    visitor.visit_name(item.span, item.name);\n     match item.node {\n         ItemExternCrate(..) => {}\n         ItemUse(ref vp) => {\n@@ -227,7 +227,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_expr(&**expr);\n         }\n         ItemFn(ref declaration, unsafety, constness, abi, ref generics, ref body) => {\n-            visitor.visit_fn(FnKind::ItemFn(item.ident.name, generics, unsafety,\n+            visitor.visit_fn(FnKind::ItemFn(item.name, generics, unsafety,\n                                             constness, abi, item.vis),\n                              &**declaration,\n                              &**body,\n@@ -271,7 +271,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n         ItemStruct(ref struct_definition, ref generics) => {\n             visitor.visit_generics(generics);\n             visitor.visit_struct_def(&**struct_definition,\n-                                     item.ident.name,\n+                                     item.name,\n                                      generics,\n                                      item.id)\n         }\n@@ -503,7 +503,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n \n pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V,\n                                              foreign_item: &'v ForeignItem) {\n-    visitor.visit_name(foreign_item.span, foreign_item.ident.name);\n+    visitor.visit_name(foreign_item.span, foreign_item.name);\n \n     match foreign_item.node {\n         ForeignItemFn(ref function_declaration, ref generics) => {\n@@ -611,7 +611,7 @@ pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n }\n \n pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem) {\n-    visitor.visit_name(trait_item.span, trait_item.ident.name);\n+    visitor.visit_name(trait_item.span, trait_item.name);\n     for attr in &trait_item.attrs {\n         visitor.visit_attribute(attr);\n     }\n@@ -628,7 +628,7 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n             walk_fn_decl(visitor, &sig.decl);\n         }\n         MethodTraitItem(ref sig, Some(ref body)) => {\n-            visitor.visit_fn(FnKind::Method(trait_item.ident.name, sig, None), &sig.decl,\n+            visitor.visit_fn(FnKind::Method(trait_item.name, sig, None), &sig.decl,\n                              body, trait_item.span, trait_item.id);\n         }\n         TypeTraitItem(ref bounds, ref default) => {\n@@ -639,7 +639,7 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n }\n \n pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem) {\n-    visitor.visit_name(impl_item.span, impl_item.ident.name);\n+    visitor.visit_name(impl_item.span, impl_item.name);\n     for attr in &impl_item.attrs {\n         visitor.visit_attribute(attr);\n     }\n@@ -649,8 +649,8 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n             visitor.visit_expr(expr);\n         }\n         MethodImplItem(ref sig, ref body) => {\n-            visitor.visit_fn(FnKind::Method(impl_item.ident.name, sig, Some(impl_item.vis)),\n-                             &sig.decl, body, impl_item.span, impl_item.id);\n+            visitor.visit_fn(FnKind::Method(impl_item.name, sig, Some(impl_item.vis)), &sig.decl,\n+                             body, impl_item.span, impl_item.id);\n         }\n         TypeImplItem(ref ty) => {\n             visitor.visit_ty(ty);"}, {"sha": "d2b3f6fc3cc588777ec2beac6ef94deccfc8f038", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -1731,15 +1731,15 @@ impl LateLintPass for InvalidNoMangleItems {\n                 if attr::contains_name(&it.attrs, \"no_mangle\") &&\n                        !cx.exported_items.contains(&it.id) {\n                     let msg = format!(\"function {} is marked #[no_mangle], but not exported\",\n-                                      it.ident);\n+                                      it.name);\n                     cx.span_lint(PRIVATE_NO_MANGLE_FNS, it.span, &msg);\n                 }\n             },\n             hir::ItemStatic(..) => {\n                 if attr::contains_name(&it.attrs, \"no_mangle\") &&\n                        !cx.exported_items.contains(&it.id) {\n                     let msg = format!(\"static {} is marked #[no_mangle], but not exported\",\n-                                      it.ident);\n+                                      it.name);\n                     cx.span_lint(PRIVATE_NO_MANGLE_STATICS, it.span, &msg);\n                 }\n             },"}, {"sha": "b16d6baa73f745be75f06ea58925c8011139087f", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -683,7 +683,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             hir::ItemEnum(..) => \"enum\",\n             _ => return Some((err_span, err_msg, None))\n         };\n-        let msg = format!(\"{} `{}` is private\", desc, item.ident);\n+        let msg = format!(\"{} `{}` is private\", desc, item.name);\n         Some((err_span, err_msg, Some((span, msg))))\n     }\n "}, {"sha": "304eae970c6d1acf5d8e5e9f277cb8b50b4815b1", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -263,7 +263,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n     /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(&mut self, item: &Item, parent: &Rc<Module>) -> Rc<Module> {\n-        let name = item.ident.name;\n+        let name = item.name;\n         let sp = item.span;\n         let is_public = item.vis == hir::Public;\n         let modifiers = if is_public {\n@@ -539,7 +539,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                 // Add the names of all the items to the trait info.\n                 for trait_item in items {\n-                    let name_bindings = self.add_child(trait_item.ident.name,\n+                    let name_bindings = self.add_child(trait_item.name,\n                                         &module_parent,\n                                         ForbidDuplicateTypesAndValues,\n                                         trait_item.span);\n@@ -563,7 +563,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                         }\n                     }\n \n-                    self.trait_item_map.insert((trait_item.ident.name, def_id),\n+                    self.trait_item_map.insert((trait_item.name, def_id),\n                                                DefId::local(trait_item.id));\n                 }\n \n@@ -606,7 +606,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     fn build_reduced_graph_for_foreign_item(&mut self,\n                                             foreign_item: &ForeignItem,\n                                             parent: &Rc<Module>) {\n-        let name = foreign_item.ident.name;\n+        let name = foreign_item.name;\n         let is_public = foreign_item.vis == hir::Public;\n         let modifiers = if is_public {\n             DefModifiers::PUBLIC"}, {"sha": "ce56c1548fa49f658a95377af2c80edc600bedb9", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -1258,7 +1258,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn get_trait_name(&self, did: DefId) -> Name {\n         if did.is_local() {\n-            self.ast_map.expect_item(did.node).ident.name\n+            self.ast_map.expect_item(did.node).name\n         } else {\n             csearch::get_trait_name(&self.session.cstore, did)\n         }\n@@ -2109,7 +2109,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn resolve_item(&mut self, item: &Item) {\n-        let name = item.ident.name;\n+        let name = item.name;\n \n         debug!(\"(resolving item) resolving {}\",\n                name);\n@@ -2184,7 +2184,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     });\n                                 }\n                                 hir::TypeTraitItem(..) => {\n-                                    this.check_if_primitive_type_name(trait_item.ident.name,\n+                                    this.check_if_primitive_type_name(trait_item.name,\n                                                                       trait_item.span);\n                                     this.with_type_parameter_rib(NoTypeParameters, |this| {\n                                         visit::walk_trait_item(this, trait_item)\n@@ -2486,7 +2486,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 ConstImplItem(..) => {\n                                     // If this is a trait impl, ensure the const\n                                     // exists in trait\n-                                    this.check_trait_item(impl_item.ident.name,\n+                                    this.check_trait_item(impl_item.name,\n                                                           impl_item.span,\n                                         |n, s| ResolutionError::ConstNotMemberOfTrait(n, s));\n                                     this.with_constant_rib(|this| {\n@@ -2496,7 +2496,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 MethodImplItem(ref sig, _) => {\n                                     // If this is a trait impl, ensure the method\n                                     // exists in trait\n-                                    this.check_trait_item(impl_item.ident.name,\n+                                    this.check_trait_item(impl_item.name,\n                                                           impl_item.span,\n                                         |n, s| ResolutionError::MethodNotMemberOfTrait(n, s));\n \n@@ -2513,7 +2513,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 TypeImplItem(ref ty) => {\n                                     // If this is a trait impl, ensure the type\n                                     // exists in trait\n-                                    this.check_trait_item(impl_item.ident.name,\n+                                    this.check_trait_item(impl_item.name,\n                                                           impl_item.span,\n                                         |n, s| ResolutionError::TypeNotMemberOfTrait(n, s));\n "}, {"sha": "dd0c06c9142e60b62af197a1626dc032e21c294d", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -2099,7 +2099,7 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n       }\n       hir::ItemImpl(_, _, ref generics, _, _, ref impl_items) => {\n         meth::trans_impl(ccx,\n-                         item.ident,\n+                         item.name,\n                          &impl_items[..],\n                          generics,\n                          item.id);"}, {"sha": "fa2c476f6133b120f94c9c96b94bd01eca8533c2", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -1858,8 +1858,8 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     let (name, span) = match var_item {\n         hir_map::NodeItem(item) => {\n             match item.node {\n-                hir::ItemStatic(..) => (item.ident.name, item.span),\n-                hir::ItemConst(..) => (item.ident.name, item.span),\n+                hir::ItemStatic(..) => (item.name, item.span),\n+                hir::ItemConst(..) => (item.name, item.span),\n                 _ => {\n                     cx.sess()\n                       .span_bug(item.span,"}, {"sha": "c7bf7f67f7a052bcc1b7225495d57cca0c6f0c7f", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -242,7 +242,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             match item.node {\n                 hir::ItemFn(ref fn_decl, _, _, _, ref generics, ref top_level_block) => {\n-                    (item.ident.name, fn_decl, generics, top_level_block, item.span, true)\n+                    (item.name, fn_decl, generics, top_level_block, item.span, true)\n                 }\n                 _ => {\n                     cx.sess().span_bug(item.span,\n@@ -257,7 +257,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         return FunctionDebugContext::FunctionWithoutDebugInfo;\n                     }\n \n-                    (impl_item.ident.name,\n+                    (impl_item.name,\n                      &sig.decl,\n                      &sig.generics,\n                      body,\n@@ -296,7 +296,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         return FunctionDebugContext::FunctionWithoutDebugInfo;\n                     }\n \n-                    (trait_item.ident.name,\n+                    (trait_item.name,\n                      &sig.decl,\n                      &sig.generics,\n                      body,"}, {"sha": "0310a8a6041065c8676465f6455c52119d9065ab", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -908,7 +908,7 @@ pub fn link_name(i: &hir::ForeignItem) -> InternedString {\n         Some(ln) => ln.clone(),\n         None => match weak_lang_items::link_name(&i.attrs) {\n             Some(name) => name,\n-            None => i.ident.name.as_str(),\n+            None => i.name.as_str(),\n         }\n     }\n }"}, {"sha": "605c27e0caa33644e624d333d0b892a1c23ef5fe", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -50,7 +50,7 @@ use syntax::codemap::Span;\n use std::cmp::Ordering;\n \n pub fn get_simple_intrinsic(ccx: &CrateContext, item: &hir::ForeignItem) -> Option<ValueRef> {\n-    let name = match &*item.ident.name.as_str() {\n+    let name = match &*item.name.as_str() {\n         \"sqrtf32\" => \"llvm.sqrt.f32\",\n         \"sqrtf64\" => \"llvm.sqrt.f64\",\n         \"powif32\" => \"llvm.powi.f32\",\n@@ -185,7 +185,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         _ => panic!(\"expected bare_fn in trans_intrinsic_call\")\n     };\n     let foreign_item = tcx.map.expect_foreign_item(node);\n-    let name = foreign_item.ident.name.as_str();\n+    let name = foreign_item.name.as_str();\n \n     // For `transmute` we can just trans the input expr directly into dest\n     if name == \"transmute\" {\n@@ -931,7 +931,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, _) => {\n             let intr = match Intrinsic::find(tcx, &name) {\n                 Some(intr) => intr,\n-                None => ccx.sess().span_bug(foreign_item.span, \"unknown intrinsic\"),\n+                None => ccx.sess().span_bug(foreign_item.span,\n+                                            &format!(\"unknown intrinsic '{}'\", name)),\n             };\n             fn one<T>(x: Vec<T>) -> T {\n                 assert_eq!(x.len(), 1);"}, {"sha": "6dcc60dc96276b90431cb4c63a25aaad9f5df048", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -53,7 +53,7 @@ const VTABLE_OFFSET: usize = 3;\n /// be generated once they are invoked with specific type parameters,\n /// see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n pub fn trans_impl(ccx: &CrateContext,\n-                  name: ast::Ident,\n+                  name: ast::Name,\n                   impl_items: &[P<hir::ImplItem>],\n                   generics: &hir::Generics,\n                   id: ast::NodeId) {"}, {"sha": "6f093cabac627f25768213aaea2b9c4aabcb209f", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -1313,7 +1313,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         match tcx.map.expect_item(trait_did.node).node {\n             hir::ItemTrait(_, _, _, ref trait_items) => {\n                 let item = trait_items.iter()\n-                                      .find(|i| i.ident.name == assoc_name)\n+                                      .find(|i| i.name == assoc_name)\n                                       .expect(\"missing associated type\");\n                 DefId::local(item.id)\n             }"}, {"sha": "8a114473e3c620e328131c31bf767879c98c6d37", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -73,7 +73,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n     }\n \n     let tcx = ccx.tcx;\n-    let name = it.ident.name.as_str();\n+    let name = it.name.as_str();\n     let (n_tps, inputs, output) = if name.starts_with(\"atomic_\") {\n         let split : Vec<&str> = name.split('_').collect();\n         assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n@@ -367,7 +367,7 @@ pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n     let tcx = ccx.tcx;\n     let i_ty = tcx.lookup_item_type(DefId::local(it.id));\n     let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n-    let name = it.ident.name.as_str();\n+    let name = it.name.as_str();\n \n     let (n_tps, inputs, output) = match &*name {\n         \"simd_eq\" | \"simd_ne\" | \"simd_lt\" | \"simd_le\" | \"simd_gt\" | \"simd_ge\" => {"}, {"sha": "8cb556473ad0c264290de1d7b7e19faf76a27054", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -698,7 +698,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n       }\n       hir::ItemFn(..) => {} // entirely within check_item_body\n       hir::ItemImpl(_, _, _, _, _, ref impl_items) => {\n-          debug!(\"ItemImpl {} with id {}\", it.ident, it.id);\n+          debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n           match ccx.tcx.impl_trait_ref(DefId::local(it.id)) {\n               Some(impl_trait_ref) => {\n                 check_impl_items_against_trait(ccx,\n@@ -761,7 +761,7 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n         check_bare_fn(ccx, &**decl, &**body, it.id, it.span, fn_pty.ty, param_env);\n       }\n       hir::ItemImpl(_, _, _, _, _, ref impl_items) => {\n-        debug!(\"ItemImpl {} with id {}\", it.ident, it.id);\n+        debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n \n         let impl_pty = ccx.tcx.lookup_item_type(DefId::local(it.id));\n \n@@ -845,7 +845,7 @@ fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 span_err!(ccx.tcx.sess, attr.span, E0230,\n                                                  \"there is no type parameter \\\n                                                           {} on trait {}\",\n-                                                           s, item.ident);\n+                                                           s, item.name);\n                             }\n                         },\n                         // `{:1}` and `{}` are not to be used\n@@ -988,7 +988,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 let is_implemented = impl_items.iter().any(|ii| {\n                     match ii.node {\n                         hir::ConstImplItem(..) => {\n-                            ii.ident.name == associated_const.name\n+                            ii.name == associated_const.name\n                         }\n                         _ => false,\n                     }\n@@ -1009,7 +1009,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     impl_items.iter().any(|ii| {\n                         match ii.node {\n                             hir::MethodImplItem(..) => {\n-                                ii.ident.name == trait_method.name\n+                                ii.name == trait_method.name\n                             }\n                             _ => false,\n                         }\n@@ -1028,7 +1028,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 let is_implemented = impl_items.iter().any(|ii| {\n                     match ii.node {\n                         hir::TypeImplItem(_) => {\n-                            ii.ident.name == associated_type.name\n+                            ii.name == associated_type.name\n                         }\n                         _ => false,\n                     }\n@@ -1058,7 +1058,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         span_err!(tcx.sess, invalidator.span, E0399,\n                   \"the following trait items need to be reimplemented \\\n                    as `{}` was overridden: `{}`\",\n-                  invalidator.ident,\n+                  invalidator.name,\n                   invalidated_items.iter()\n                                    .map(|name| name.to_string())\n                                    .collect::<Vec<_>>().join(\"`, `\"))"}, {"sha": "228f1f0fe445b287e96a2d70bbe80947984a3fb2", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -149,7 +149,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         if let Some(trait_ref) = self.crate_context.tcx.impl_trait_ref(impl_did) {\n             debug!(\"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n                    trait_ref,\n-                   item.ident);\n+                   item.name);\n \n             enforce_trait_manually_implementable(self.crate_context.tcx,\n                                                  item.span,"}, {"sha": "81c4732d20d5909427d35830d018b2a8b5248556", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -577,7 +577,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             container: ImplOrTraitItemContainer,\n                             sig: &hir::MethodSig,\n                             id: ast::NodeId,\n-                            ident: ast::Ident,\n+                            name: ast::Name,\n                             vis: hir::Visibility,\n                             untransformed_rcvr_ty: Ty<'tcx>,\n                             rcvr_ty_generics: &ty::Generics<'tcx>,\n@@ -592,7 +592,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                               sig, untransformed_rcvr_ty);\n \n     let def_id = DefId::local(id);\n-    let ty_method = ty::Method::new(ident.name,\n+    let ty_method = ty::Method::new(name,\n                                     ty_generics,\n                                     ty_generic_predicates,\n                                     fty,\n@@ -605,7 +605,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let fty = ccx.tcx.mk_fn(Some(def_id),\n                             ccx.tcx.mk_bare_fn(ty_method.fty.clone()));\n     debug!(\"method {} (id {}) has type {:?}\",\n-            ident, id, fty);\n+            name, id, fty);\n     ccx.tcx.register_item_type(def_id, TypeScheme {\n         generics: ty_method.generics.clone(),\n         ty: fty\n@@ -643,7 +643,7 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                       container: ImplOrTraitItemContainer,\n-                                      ident: ast::Ident,\n+                                      name: ast::Name,\n                                       id: ast::NodeId,\n                                       vis: hir::Visibility,\n                                       ty: ty::Ty<'tcx>,\n@@ -656,7 +656,7 @@ fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let default_id = default.map(|expr| DefId::local(expr.id));\n \n     let associated_const = Rc::new(ty::AssociatedConst {\n-        name: ident.name,\n+        name: name,\n         vis: vis,\n         def_id: DefId::local(id),\n         container: container,\n@@ -669,13 +669,13 @@ fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                      container: ImplOrTraitItemContainer,\n-                                     ident: ast::Ident,\n+                                     name: ast::Name,\n                                      id: ast::NodeId,\n                                      vis: hir::Visibility,\n                                      ty: Option<Ty<'tcx>>)\n {\n     let associated_type = Rc::new(ty::AssociatedType {\n-        name: ident.name,\n+        name: name,\n         vis: vis,\n         ty: ty,\n         def_id: DefId::local(id),\n@@ -691,7 +691,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n                                  untransformed_rcvr_ty: Ty<'tcx>,\n                                  rcvr_ty_generics: &ty::Generics<'tcx>,\n                                  rcvr_ty_predicates: &ty::GenericPredicates<'tcx>)\n-    where I: Iterator<Item=(&'i hir::MethodSig, ast::NodeId, ast::Ident, hir::Visibility, Span)>\n+    where I: Iterator<Item=(&'i hir::MethodSig, ast::NodeId, ast::Name, hir::Visibility, Span)>\n {\n     debug!(\"convert_methods(untransformed_rcvr_ty={:?}, rcvr_ty_generics={:?}, \\\n                             rcvr_ty_predicates={:?})\",\n@@ -743,7 +743,7 @@ fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n \n fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n     let tcx = ccx.tcx;\n-    debug!(\"convert: item {} with id {}\", it.ident, it.id);\n+    debug!(\"convert: item {} with id {}\", it.name, it.id);\n     match it.node {\n         // These don't define types.\n         hir::ItemExternCrate(_) | hir::ItemUse(_) |\n@@ -823,7 +823,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                     hir::TypeImplItem(_) => &mut seen_type_items,\n                     _                    => &mut seen_value_items,\n                 };\n-                if !seen_items.insert(impl_item.ident.name) {\n+                if !seen_items.insert(impl_item.name) {\n                     let desc = match impl_item.node {\n                         hir::ConstImplItem(_, _) => \"associated constant\",\n                         hir::TypeImplItem(_) => \"associated type\",\n@@ -846,7 +846,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                                ty: ty,\n                                            });\n                     convert_associated_const(ccx, ImplContainer(DefId::local(it.id)),\n-                                             impl_item.ident, impl_item.id,\n+                                             impl_item.name, impl_item.id,\n                                              impl_item.vis.inherit_from(parent_visibility),\n                                              ty, Some(&*expr));\n                 }\n@@ -863,7 +863,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                     let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, ty);\n \n                     convert_associated_type(ccx, ImplContainer(DefId::local(it.id)),\n-                                            impl_item.ident, impl_item.id, impl_item.vis,\n+                                            impl_item.name, impl_item.id, impl_item.vis,\n                                             Some(typ));\n                 }\n             }\n@@ -875,7 +875,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                     // { fn foo(); }` is public, but private in `impl { fn\n                     // foo(); }`).\n                     let method_vis = ii.vis.inherit_from(parent_visibility);\n-                    Some((sig, ii.id, ii.ident, method_vis, ii.span))\n+                    Some((sig, ii.id, ii.name, method_vis, ii.span))\n                 } else {\n                     None\n                 }\n@@ -925,7 +925,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                                    ty: ty,\n                                                });\n                         convert_associated_const(ccx, TraitContainer(DefId::local(it.id)),\n-                                                 trait_item.ident, trait_item.id,\n+                                                 trait_item.name, trait_item.id,\n                                                  hir::Public, ty, default.as_ref().map(|d| &**d));\n                     }\n                     _ => {}\n@@ -941,7 +941,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                         });\n \n                         convert_associated_type(ccx, TraitContainer(DefId::local(it.id)),\n-                                                trait_item.ident, trait_item.id, hir::Public,\n+                                                trait_item.name, trait_item.id, hir::Public,\n                                                 typ);\n                     }\n                     _ => {}\n@@ -953,7 +953,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                     hir::MethodTraitItem(ref sig, _) => sig,\n                     _ => return None,\n                 };\n-                Some((sig, ti.id, ti.ident, hir::Inherited, ti.span))\n+                Some((sig, ti.id, ti.name, hir::Inherited, ti.span))\n             });\n \n             // Run convert_methods on the trait methods.\n@@ -1135,7 +1135,7 @@ fn convert_struct_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n     tcx.intern_adt_def(\n         did,\n         ty::AdtKind::Struct,\n-        vec![convert_struct_variant(tcx, did, it.ident.name, 0, def)]\n+        vec![convert_struct_variant(tcx, did, it.name, 0, def)]\n     )\n }\n \n@@ -1369,7 +1369,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let associated_type_names: Vec<_> = items.iter().filter_map(|trait_item| {\n         match trait_item.node {\n-            hir::TypeTraitItem(..) => Some(trait_item.ident.name),\n+            hir::TypeTraitItem(..) => Some(trait_item.name),\n             _ => None,\n         }\n     }).collect();\n@@ -1444,7 +1444,7 @@ fn trait_defines_associated_type_named(ccx: &CrateCtxt,\n \n     trait_items.iter().any(|trait_item| {\n         match trait_item.node {\n-            hir::TypeTraitItem(..) => trait_item.ident.name == assoc_name,\n+            hir::TypeTraitItem(..) => trait_item.name == assoc_name,\n             _ => false,\n         }\n     })\n@@ -1511,7 +1511,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n             };\n \n             let assoc_ty = ccx.tcx.mk_projection(self_trait_ref,\n-                                                 trait_item.ident.name);\n+                                                 trait_item.name);\n \n             let bounds = compute_bounds(&ccx.icx(&(ast_generics, trait_predicates)),\n                                         assoc_ty,"}, {"sha": "51f1b4b7157ad2ce181f1e29e3e274b6b72b9cee", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -1257,7 +1257,7 @@ impl Clean<Item> for hir::TraitItem {\n             }\n         };\n         Item {\n-            name: Some(self.ident.clean(cx)),\n+            name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n             def_id: DefId::local(self.id),\n@@ -1290,7 +1290,7 @@ impl Clean<Item> for hir::ImplItem {\n             }, true),\n         };\n         Item {\n-            name: Some(self.ident.clean(cx)),\n+            name: Some(self.name.clean(cx)),\n             source: self.span.clean(cx),\n             attrs: self.attrs.clean(cx),\n             def_id: DefId::local(self.id),\n@@ -2484,7 +2484,7 @@ impl Clean<Item> for hir::ForeignItem {\n             }\n         };\n         Item {\n-            name: Some(self.ident.clean(cx)),\n+            name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n             def_id: DefId::local(self.id),"}, {"sha": "c090bcfe01006d6f79d4ea4126efb1d9b00bb666", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -17,13 +17,13 @@ use syntax;\n use syntax::codemap::Span;\n use syntax::abi;\n use syntax::ast;\n-use syntax::ast::{Ident, NodeId};\n+use syntax::ast::{Ident, Name, NodeId};\n use syntax::attr;\n use syntax::ptr::P;\n use rustc_front::hir;\n \n pub struct Module {\n-    pub name: Option<Ident>,\n+    pub name: Option<Name>,\n     pub attrs: Vec<ast::Attribute>,\n     pub where_outer: Span,\n     pub where_inner: Span,\n@@ -48,7 +48,7 @@ pub struct Module {\n }\n \n impl Module {\n-    pub fn new(name: Option<Ident>) -> Module {\n+    pub fn new(name: Option<Name>) -> Module {\n         Module {\n             name       : name,\n             id: 0,\n@@ -98,7 +98,7 @@ pub struct Struct {\n     pub stab: Option<attr::Stability>,\n     pub id: NodeId,\n     pub struct_type: StructType,\n-    pub name: Ident,\n+    pub name: Name,\n     pub generics: hir::Generics,\n     pub attrs: Vec<ast::Attribute>,\n     pub fields: Vec<hir::StructField>,\n@@ -113,7 +113,7 @@ pub struct Enum {\n     pub attrs: Vec<ast::Attribute>,\n     pub id: NodeId,\n     pub whence: Span,\n-    pub name: Ident,\n+    pub name: Name,\n }\n \n pub struct Variant {\n@@ -129,7 +129,7 @@ pub struct Function {\n     pub decl: hir::FnDecl,\n     pub attrs: Vec<ast::Attribute>,\n     pub id: NodeId,\n-    pub name: Ident,\n+    pub name: Name,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub unsafety: hir::Unsafety,\n@@ -142,7 +142,7 @@ pub struct Function {\n pub struct Typedef {\n     pub ty: P<hir::Ty>,\n     pub gen: hir::Generics,\n-    pub name: Ident,\n+    pub name: Name,\n     pub id: ast::NodeId,\n     pub attrs: Vec<ast::Attribute>,\n     pub whence: Span,\n@@ -155,7 +155,7 @@ pub struct Static {\n     pub type_: P<hir::Ty>,\n     pub mutability: hir::Mutability,\n     pub expr: P<hir::Expr>,\n-    pub name: Ident,\n+    pub name: Name,\n     pub attrs: Vec<ast::Attribute>,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n@@ -166,7 +166,7 @@ pub struct Static {\n pub struct Constant {\n     pub type_: P<hir::Ty>,\n     pub expr: P<hir::Expr>,\n-    pub name: Ident,\n+    pub name: Name,\n     pub attrs: Vec<ast::Attribute>,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n@@ -176,7 +176,7 @@ pub struct Constant {\n \n pub struct Trait {\n     pub unsafety: hir::Unsafety,\n-    pub name: Ident,\n+    pub name: Name,\n     pub items: Vec<P<hir::TraitItem>>, //should be TraitItem\n     pub generics: hir::Generics,\n     pub bounds: Vec<hir::TyParamBound>,\n@@ -219,7 +219,7 @@ pub struct Macro {\n }\n \n pub struct ExternCrate {\n-    pub name: Ident,\n+    pub name: Name,\n     pub path: Option<String>,\n     pub vis: hir::Visibility,\n     pub attrs: Vec<ast::Attribute>,"}, {"sha": "cb22e3b41c71fa5265ad731841f322474840a219", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -83,7 +83,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     pub fn visit_struct_def(&mut self, item: &hir::Item,\n-                            name: ast::Ident, sd: &hir::StructDef,\n+                            name: ast::Name, sd: &hir::StructDef,\n                             generics: &hir::Generics) -> Struct {\n         debug!(\"Visiting struct\");\n         let struct_type = struct_type_from_def(&*sd);\n@@ -101,7 +101,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     pub fn visit_enum_def(&mut self, it: &hir::Item,\n-                          name: ast::Ident, def: &hir::EnumDef,\n+                          name: ast::Name, def: &hir::EnumDef,\n                           params: &hir::Generics) -> Enum {\n         debug!(\"Visiting enum\");\n         Enum {\n@@ -124,7 +124,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     pub fn visit_fn(&mut self, item: &hir::Item,\n-                    name: ast::Ident, fd: &hir::FnDecl,\n+                    name: ast::Name, fd: &hir::FnDecl,\n                     unsafety: &hir::Unsafety,\n                     constness: hir::Constness,\n                     abi: &abi::Abi,\n@@ -148,7 +148,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     pub fn visit_mod_contents(&mut self, span: Span, attrs: Vec<ast::Attribute> ,\n                               vis: hir::Visibility, id: ast::NodeId,\n                               m: &hir::Mod,\n-                              name: Option<ast::Ident>) -> Module {\n+                              name: Option<ast::Name>) -> Module {\n         let mut om = Module::new(name);\n         om.where_outer = span;\n         om.where_inner = m.inner;\n@@ -243,7 +243,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     pub fn visit_item(&mut self, item: &hir::Item,\n                       renamed: Option<ast::Ident>, om: &mut Module) {\n         debug!(\"Visiting item {:?}\", item);\n-        let name = renamed.unwrap_or(item.ident);\n+        let name = renamed.map_or(item.name, |x| x.name);\n         match item.node {\n             hir::ItemExternCrate(ref p) => {\n                 let path = match *p {"}, {"sha": "81bd76211c3f854b8f8de5ef70e25ede3863f603", "filename": "src/test/auxiliary/lint_group_plugin_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a4af95878630688f9c24a1170f73561f0f15397e/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4af95878630688f9c24a1170f73561f0f15397e/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs?ref=a4af95878630688f9c24a1170f73561f0f15397e", "patch": "@@ -37,7 +37,7 @@ impl LintPass for Pass {\n \n impl LateLintPass for Pass {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n-        match &*it.ident.name.as_str() {\n+        match &*it.name.as_str() {\n             \"lintme\" => cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\"),\n             \"pleaselintme\" => cx.span_lint(PLEASE_LINT, it.span, \"item is named 'pleaselintme'\"),\n             _ => {}"}]}