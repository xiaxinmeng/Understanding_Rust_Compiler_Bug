{"sha": "1c3c54a6effc99f21db3df597a6e4a3531c25a86", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjM2M1NGE2ZWZmYzk5ZjIxZGIzZGY1OTdhNmU0YTM1MzFjMjVhODY=", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-05-04T13:43:15Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-05-04T13:43:20Z"}, "message": "SpanlessHash Pat", "tree": {"sha": "84e8576d9165e25e9d36aa6ba606116248b957a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84e8576d9165e25e9d36aa6ba606116248b957a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c3c54a6effc99f21db3df597a6e4a3531c25a86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c3c54a6effc99f21db3df597a6e4a3531c25a86", "html_url": "https://github.com/rust-lang/rust/commit/1c3c54a6effc99f21db3df597a6e4a3531c25a86", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c3c54a6effc99f21db3df597a6e4a3531c25a86/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e3160ca0bfa9e96ab81a0812a79ec41ad535d14", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e3160ca0bfa9e96ab81a0812a79ec41ad535d14", "html_url": "https://github.com/rust-lang/rust/commit/5e3160ca0bfa9e96ab81a0812a79ec41ad535d14"}], "stats": {"total": 93, "additions": 78, "deletions": 15}, "files": [{"sha": "3b01158acd91f972a634b652afeebd6e28a3f7cb", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 78, "deletions": 15, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/1c3c54a6effc99f21db3df597a6e4a3531c25a86/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c3c54a6effc99f21db3df597a6e4a3531c25a86/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=1c3c54a6effc99f21db3df597a6e4a3531c25a86", "patch": "@@ -713,7 +713,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 self.hash_expr(e);\n \n                 for arm in arms {\n-                    // TODO: arm.pat?\n+                    self.hash_pat(arm.pat);\n                     if let Some(ref e) = arm.guard {\n                         self.hash_guard(e);\n                     }\n@@ -791,6 +791,72 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n         // self.maybe_typeck_results.unwrap().qpath_res(p, id).hash(&mut self.s);\n     }\n \n+    pub fn hash_pat(&mut self, pat: &Pat<'_>) {\n+        std::mem::discriminant(&pat.kind).hash(&mut self.s);\n+        match pat.kind {\n+            PatKind::Binding(ann, _, _, pat) => {\n+                ann.hash_stable(&mut self.cx.tcx.get_stable_hashing_context(), &mut self.s);\n+                if let Some(pat) = pat {\n+                    self.hash_pat(pat);\n+                }\n+            },\n+            PatKind::Box(pat) => self.hash_pat(pat),\n+            PatKind::Lit(expr) => self.hash_expr(expr),\n+            PatKind::Or(pats) => {\n+                for pat in pats {\n+                    self.hash_pat(pat);\n+                }\n+            },\n+            PatKind::Path(ref qpath) => self.hash_qpath(qpath),\n+            PatKind::Range(s, e, i) => {\n+                if let Some(s) = s {\n+                    self.hash_expr(s);\n+                }\n+                if let Some(e) = e {\n+                    self.hash_expr(e);\n+                }\n+                i.hash_stable(&mut self.cx.tcx.get_stable_hashing_context(), &mut self.s);\n+            },\n+            PatKind::Ref(pat, m) => {\n+                self.hash_pat(pat);\n+                m.hash(&mut self.s);\n+            },\n+            PatKind::Slice(l, m, r) => {\n+                for pat in l {\n+                    self.hash_pat(pat);\n+                }\n+                if let Some(pat) = m {\n+                    self.hash_pat(pat);\n+                }\n+                for pat in r {\n+                    self.hash_pat(pat);\n+                }\n+            },\n+            PatKind::Struct(ref qpath, fields, e) => {\n+                self.hash_qpath(qpath);\n+                for f in fields {\n+                    self.hash_name(f.ident.name);\n+                    self.hash_pat(f.pat);\n+                }\n+                e.hash(&mut self.s)\n+            },\n+            PatKind::Tuple(pats, e) => {\n+                for pat in pats {\n+                    self.hash_pat(pat);\n+                }\n+                e.hash(&mut self.s);\n+            },\n+            PatKind::TupleStruct(ref qpath, pats, e) => {\n+                self.hash_qpath(qpath);\n+                for pat in pats {\n+                    self.hash_pat(pat);\n+                }\n+                e.hash(&mut self.s);\n+            },\n+            PatKind::Wild => {},\n+        }\n+    }\n+\n     pub fn hash_path(&mut self, path: &Path<'_>) {\n         match path.res {\n             // constant hash since equality is dependant on inter-expression context\n@@ -808,6 +874,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n \n         match &b.kind {\n             StmtKind::Local(local) => {\n+                self.hash_pat(local.pat);\n                 if let Some(ref init) = local.init {\n                     self.hash_expr(init);\n                 }\n@@ -827,7 +894,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n         }\n     }\n \n-    pub fn hash_lifetime(&mut self, lifetime: &Lifetime) {\n+    pub fn hash_lifetime(&mut self, lifetime: Lifetime) {\n         std::mem::discriminant(&lifetime.name).hash(&mut self.s);\n         if let LifetimeName::Param(ref name) = lifetime.name {\n             std::mem::discriminant(name).hash(&mut self.s);\n@@ -844,24 +911,20 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n     }\n \n     pub fn hash_ty(&mut self, ty: &Ty<'_>) {\n-        self.hash_tykind(&ty.kind);\n-    }\n-\n-    pub fn hash_tykind(&mut self, ty: &TyKind<'_>) {\n-        std::mem::discriminant(ty).hash(&mut self.s);\n-        match ty {\n+        std::mem::discriminant(&ty.kind).hash(&mut self.s);\n+        match ty.kind {\n             TyKind::Slice(ty) => {\n                 self.hash_ty(ty);\n             },\n             TyKind::Array(ty, anon_const) => {\n                 self.hash_ty(ty);\n                 self.hash_body(anon_const.body);\n             },\n-            TyKind::Ptr(mut_ty) => {\n+            TyKind::Ptr(ref mut_ty) => {\n                 self.hash_ty(&mut_ty.ty);\n                 mut_ty.mutbl.hash(&mut self.s);\n             },\n-            TyKind::Rptr(lifetime, mut_ty) => {\n+            TyKind::Rptr(lifetime, ref mut_ty) => {\n                 self.hash_lifetime(lifetime);\n                 self.hash_ty(&mut_ty.ty);\n                 mut_ty.mutbl.hash(&mut self.s);\n@@ -883,11 +946,11 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 bfn.decl.c_variadic.hash(&mut self.s);\n             },\n             TyKind::Tup(ty_list) => {\n-                for ty in *ty_list {\n+                for ty in ty_list {\n                     self.hash_ty(ty);\n                 }\n             },\n-            TyKind::Path(qpath) => match qpath {\n+            TyKind::Path(ref qpath) => match qpath {\n                 QPath::Resolved(ref maybe_ty, ref path) => {\n                     if let Some(ref ty) = maybe_ty {\n                         self.hash_ty(ty);\n@@ -927,9 +990,9 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n \n     fn hash_generic_args(&mut self, arg_list: &[GenericArg<'_>]) {\n         for arg in arg_list {\n-            match arg {\n-                GenericArg::Lifetime(ref l) => self.hash_lifetime(l),\n-                GenericArg::Type(ref ty) => self.hash_ty(&ty),\n+            match *arg {\n+                GenericArg::Lifetime(l) => self.hash_lifetime(l),\n+                GenericArg::Type(ref ty) => self.hash_ty(ty),\n                 GenericArg::Const(ref ca) => self.hash_body(ca.value.body),\n             }\n         }"}]}