{"sha": "459ffc2adc74f5e8b64a76f5670edb419b9f65da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1OWZmYzJhZGM3NGY1ZThiNjRhNzZmNTY3MGVkYjQxOWI5ZjY1ZGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-17T01:16:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-17T01:16:19Z"}, "message": "auto merge of #15652 : nick29581/rust/vec_index, r=acrichto", "tree": {"sha": "a36a4ad39999f7374f2b914c1f7070fc4c97d631", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a36a4ad39999f7374f2b914c1f7070fc4c97d631"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/459ffc2adc74f5e8b64a76f5670edb419b9f65da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/459ffc2adc74f5e8b64a76f5670edb419b9f65da", "html_url": "https://github.com/rust-lang/rust/commit/459ffc2adc74f5e8b64a76f5670edb419b9f65da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/459ffc2adc74f5e8b64a76f5670edb419b9f65da/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3adccda4e0a90e4163c261d6b9ab4de7cfd0ccb", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3adccda4e0a90e4163c261d6b9ab4de7cfd0ccb", "html_url": "https://github.com/rust-lang/rust/commit/d3adccda4e0a90e4163c261d6b9ab4de7cfd0ccb"}, {"sha": "aa760a849ee9f4d6817c81aad25fdc7990e894ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa760a849ee9f4d6817c81aad25fdc7990e894ed", "html_url": "https://github.com/rust-lang/rust/commit/aa760a849ee9f4d6817c81aad25fdc7990e894ed"}], "stats": {"total": 207, "additions": 119, "deletions": 88}, "files": [{"sha": "583d9249b35476a72f59346dac2e8f544e94f1e5", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=459ffc2adc74f5e8b64a76f5670edb419b9f65da", "patch": "@@ -89,9 +89,9 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n           optflag(\"h\", \"help\", \"show this message\"));\n \n     assert!(!args.is_empty());\n-    let argv0 = (*args.get(0)).clone();\n+    let argv0 = args[0].clone();\n     let args_ = args.tail();\n-    if args.get(1).as_slice() == \"-h\" || args.get(1).as_slice() == \"--help\" {\n+    if args[1].as_slice() == \"-h\" || args[1].as_slice() == \"--help\" {\n         let message = format!(\"Usage: {} [OPTIONS] [TESTNAME...]\", argv0);\n         println!(\"{}\", getopts::usage(message.as_slice(), groups.as_slice()));\n         println!(\"\");\n@@ -116,7 +116,7 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n     }\n \n     let filter = if !matches.free.is_empty() {\n-        let s = matches.free.get(0).as_slice();\n+        let s = matches.free[0].as_slice();\n         match regex::Regex::new(s) {\n             Ok(re) => Some(re),\n             Err(e) => {"}, {"sha": "c3ac40e8f08d41d03238ec3ad3e0017203460e37", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=459ffc2adc74f5e8b64a76f5670edb419b9f65da", "patch": "@@ -167,7 +167,7 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n         let proc_res = print_source(config,\n                                     props,\n                                     testfile,\n-                                    (*srcs.get(round)).to_string(),\n+                                    srcs[round].to_string(),\n                                     \"normal\");\n \n         if !proc_res.status.success() {\n@@ -187,9 +187,9 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n             let s = File::open(&filepath).read_to_end().unwrap();\n             String::from_utf8(s).unwrap()\n         }\n-        None => { (*srcs.get(srcs.len() - 2u)).clone() }\n+        None => { srcs[srcs.len() - 2u].clone() }\n     };\n-    let mut actual = (*srcs.get(srcs.len() - 1u)).clone();\n+    let mut actual = srcs[srcs.len() - 1u].clone();\n \n     if props.pp_exact.is_some() {\n         // Now we have to care about line endings\n@@ -209,7 +209,7 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n     if props.no_pretty_expanded { return }\n \n     // additionally, run `--pretty expanded` and try to build it.\n-    let proc_res = print_source(config, props, testfile, (*srcs.get(round)).clone(), \"expanded\");\n+    let proc_res = print_source(config, props, testfile, srcs[round].clone(), \"expanded\");\n     if !proc_res.status.success() {\n         fatal_proc_rec(\"pretty-printing (expanded) failed\", &proc_res);\n     }\n@@ -702,7 +702,7 @@ fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[String])\n             let mut rest = line.trim();\n             let mut first = true;\n             let mut failed = false;\n-            for frag in check_fragments.get(i).iter() {\n+            for frag in check_fragments[i].iter() {\n                 let found = if first {\n                     if rest.starts_with(frag.as_slice()) {\n                         Some(0)\n@@ -752,7 +752,7 @@ fn check_error_patterns(props: &TestProps,\n     }\n \n     let mut next_err_idx = 0u;\n-    let mut next_err_pat = props.error_patterns.get(next_err_idx);\n+    let mut next_err_pat = &props.error_patterns[next_err_idx];\n     let mut done = false;\n     let output_to_check = if props.check_stdout {\n         format!(\"{}{}\", proc_res.stdout, proc_res.stderr)\n@@ -761,14 +761,14 @@ fn check_error_patterns(props: &TestProps,\n     };\n     for line in output_to_check.as_slice().lines() {\n         if line.contains(next_err_pat.as_slice()) {\n-            debug!(\"found error pattern {}\", *next_err_pat);\n+            debug!(\"found error pattern {}\", next_err_pat);\n             next_err_idx += 1u;\n             if next_err_idx == props.error_patterns.len() {\n                 debug!(\"found all error patterns\");\n                 done = true;\n                 break;\n             }\n-            next_err_pat = props.error_patterns.get(next_err_idx);\n+            next_err_pat = &props.error_patterns[next_err_idx];\n         }\n     }\n     if done { return; }\n@@ -847,13 +847,13 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n     for line in proc_res.stderr.as_slice().lines() {\n         let mut was_expected = false;\n         for (i, ee) in expected_errors.iter().enumerate() {\n-            if !*found_flags.get(i) {\n+            if !found_flags[i] {\n                 debug!(\"prefix={} ee.kind={} ee.msg={} line={}\",\n-                       prefixes.get(i).as_slice(),\n+                       prefixes[i].as_slice(),\n                        ee.kind,\n                        ee.msg,\n                        line);\n-                if prefix_matches(line, prefixes.get(i).as_slice()) &&\n+                if prefix_matches(line, prefixes[i].as_slice()) &&\n                     line.contains(ee.kind.as_slice()) &&\n                     line.contains(ee.msg.as_slice()) {\n                     *found_flags.get_mut(i) = true;\n@@ -877,7 +877,7 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n \n     for (i, &flag) in found_flags.iter().enumerate() {\n         if !flag {\n-            let ee = expected_errors.get(i);\n+            let ee = &expected_errors[i];\n             fatal_proc_rec(format!(\"expected {} on line {} not found: {}\",\n                                   ee.kind, ee.line, ee.msg).as_slice(),\n                           proc_res);"}, {"sha": "7dcf8486181ed2bf064136e0e5e3b5614b70ffa1", "filename": "src/doc/intro.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=459ffc2adc74f5e8b64a76f5670edb419b9f65da", "patch": "@@ -205,7 +205,7 @@ fn main() {\n \n     spawn(proc() {\n         let numbers = rx.recv();\n-        println!(\"{}\", *numbers.get(0));\n+        println!(\"{}\", numbers[0]);\n     })\n }\n ```\n@@ -244,19 +244,19 @@ fn main() {\n \n     spawn(proc() {\n         let numbers = rx.recv();\n-        println!(\"{}\", numbers.get(0));\n+        println!(\"{}\", numbers[0]);\n     });\n \n     // Try to print a number from the original task\n-    println!(\"{}\", *numbers.get(0));\n+    println!(\"{}\", numbers[0]);\n }\n ```\n \n The compiler will produce an error indicating that the value is no longer in scope:\n \n ```text\n concurrency.rs:12:20: 12:27 error: use of moved value: 'numbers'\n-concurrency.rs:12     println!(\"{}\", numbers.get(0));\n+concurrency.rs:12     println!(\"{}\", numbers[0]);\n                                      ^~~~~~~\n ```\n \n@@ -276,7 +276,7 @@ fn main() {\n \n         spawn(proc() {\n             let numbers = rx.recv();\n-            println!(\"{:d}\", *numbers.get(num as uint));\n+            println!(\"{:d}\", numbers[num as uint]);\n         })\n     }\n }\n@@ -309,7 +309,7 @@ fn main() {\n \n         spawn(proc() {\n             let numbers = rx.recv();\n-            println!(\"{:d}\", *numbers.get(num as uint));\n+            println!(\"{:d}\", (*numbers)[num as uint]);\n         })\n     }\n }\n@@ -364,7 +364,7 @@ fn main() {\n             // See: https://github.com/rust-lang/rust/issues/6515\n             *numbers.get_mut(num as uint) = *numbers.get_mut(num as uint) + 1;\n \n-            println!(\"{}\", *numbers.get(num as uint));\n+            println!(\"{}\", (*numbers)[num as uint]);\n \n             // When `numbers` goes out of scope the lock is dropped\n         })"}, {"sha": "e0f0bbd6c9f2ba02797b2edf8044afe8470c361b", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=459ffc2adc74f5e8b64a76f5670edb419b9f65da", "patch": "@@ -2427,7 +2427,7 @@ as in this version of `print_all` that copies elements.\n fn print_all<T: Printable + Clone>(printable_things: Vec<T>) {\n     let mut i = 0;\n     while i < printable_things.len() {\n-        let copy_of_thing = printable_things.get(i).clone();\n+        let copy_of_thing = printable_things[i].clone();\n         copy_of_thing.print();\n         i += 1;\n     }"}, {"sha": "23c31ee9906416b16d89eaa0fc9ab5ed92938a93", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=459ffc2adc74f5e8b64a76f5670edb419b9f65da", "patch": "@@ -42,7 +42,7 @@ pub static PTR_MARKER: u8 = 0;\n /// vec.push(2i);\n ///\n /// assert_eq!(vec.len(), 2);\n-/// assert_eq!(vec.get(0), &1);\n+/// assert_eq!(vec[0], 1);\n ///\n /// assert_eq!(vec.pop(), Some(2));\n /// assert_eq!(vec.len(), 1);\n@@ -363,6 +363,21 @@ impl<T:Clone> Clone for Vec<T> {\n     }\n }\n \n+impl<T> Index<uint,T> for Vec<T> {\n+    #[inline]\n+    fn index<'a>(&'a self, index: &uint) -> &'a T {\n+        self.get(*index)\n+    }\n+}\n+\n+// FIXME(#12825) Indexing will always try IndexMut first and that causes issues.\n+/*impl<T> IndexMut<uint,T> for Vec<T> {\n+    #[inline]\n+    fn index_mut<'a>(&'a mut self, index: &uint) -> &'a mut T {\n+        self.get_mut(*index)\n+    }\n+}*/\n+\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n     fn from_iter<I:Iterator<T>>(mut iterator: I) -> Vec<T> {\n@@ -731,9 +746,12 @@ impl<T> Vec<T> {\n     /// # Example\n     ///\n     /// ```rust\n+    /// #![allow(deprecated)]\n+    ///\n     /// let vec = vec!(1i, 2, 3);\n     /// assert!(vec.get(1) == &2);\n     /// ```\n+    #[deprecated=\"prefer using indexing, e.g., vec[0]\"]\n     #[inline]\n     pub fn get<'a>(&'a self, index: uint) -> &'a T {\n         &self.as_slice()[index]\n@@ -1847,6 +1865,19 @@ mod tests {\n         v.truncate(0);\n     }\n \n+    #[test]\n+    fn test_index() {\n+        let vec = vec!(1i, 2, 3);\n+        assert!(vec[1] == 2);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_index_out_of_bounds() {\n+        let vec = vec!(1i, 2, 3);\n+        let _ = vec[3];\n+    }\n+\n     #[bench]\n     fn bench_new(b: &mut Bencher) {\n         b.iter(|| {"}, {"sha": "b72cc43b28c60c3485684c5875a64a1c9eac6184", "filename": "src/libdebug/repr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibdebug%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibdebug%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Frepr.rs?ref=459ffc2adc74f5e8b64a76f5670edb419b9f65da", "patch": "@@ -466,7 +466,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n                                 _offset: uint,\n                                 inner: *const TyDesc)\n                                 -> bool {\n-        match *self.var_stk.get(self.var_stk.len() - 1) {\n+        match self.var_stk[self.var_stk.len() - 1] {\n             Matched => {\n                 if i != 0 {\n                     try!(self, self.writer.write(\", \".as_bytes()));\n@@ -484,7 +484,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n                                 _disr_val: Disr,\n                                 n_fields: uint,\n                                 _name: &str) -> bool {\n-        match *self.var_stk.get(self.var_stk.len() - 1) {\n+        match self.var_stk[self.var_stk.len() - 1] {\n             Matched => {\n                 if n_fields > 0 {\n                     try!(self, self.writer.write([')' as u8]));"}, {"sha": "bf39fd566e52d200ea2ff367ca4796e7312f1575", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=459ffc2adc74f5e8b64a76f5670edb419b9f65da", "patch": "@@ -51,7 +51,7 @@\n //! fn main() {\n //!     let args: Vec<String> = os::args();\n //!\n-//!     let program = args.get(0).clone();\n+//!     let program = args[0].clone();\n //!\n //!     let opts = [\n //!         optopt(\"o\", \"\", \"set output file name\", \"NAME\"),\n@@ -67,7 +67,7 @@\n //!     }\n //!     let output = matches.opt_str(\"o\");\n //!     let input = if !matches.free.is_empty() {\n-//!         (*matches.free.get(0)).clone()\n+//!         matches.free[0].clone()\n //!     } else {\n //!         print_usage(program.as_slice(), opts);\n //!         return;\n@@ -275,7 +275,7 @@ impl OptGroup {\n impl Matches {\n     fn opt_vals(&self, nm: &str) -> Vec<Optval> {\n         match find_opt(self.opts.as_slice(), Name::from_str(nm)) {\n-            Some(id) => (*self.vals.get(id)).clone(),\n+            Some(id) => self.vals[id].clone(),\n             None => fail!(\"No option '{}' defined\", nm)\n         }\n     }\n@@ -285,7 +285,7 @@ impl Matches {\n         if vals.is_empty() {\n             None\n         } else {\n-            Some((*vals.get(0)).clone())\n+            Some(vals[0].clone())\n         }\n     }\n \n@@ -304,7 +304,7 @@ impl Matches {\n         for nm in names.iter() {\n             match find_opt(self.opts.as_slice(),\n                            Name::from_str(nm.as_slice())) {\n-                Some(id) if !self.vals.get(id).is_empty() => return true,\n+                Some(id) if !self.vals[id].is_empty() => return true,\n                 _ => (),\n             };\n         }\n@@ -344,8 +344,8 @@ impl Matches {\n         if vals.is_empty() {\n             return None::<String>;\n         }\n-        match vals.get(0) {\n-            &Val(ref s) => Some((*s).clone()),\n+        match vals[0] {\n+            Val(ref s) => Some((*s).clone()),\n             _ => None\n         }\n     }\n@@ -361,8 +361,8 @@ impl Matches {\n         if vals.is_empty() {\n             return None;\n         }\n-        match vals.get(0) {\n-            &Val(ref s) => Some((*s).clone()),\n+        match vals[0] {\n+            Val(ref s) => Some((*s).clone()),\n             _ => Some(def.to_string())\n         }\n     }\n@@ -560,8 +560,8 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                     names = vec!(Long(tail.to_string()));\n                 } else {\n                     names =\n-                        vec!(Long((*tail_eq.get(0)).to_string()));\n-                    i_arg = Some((*tail_eq.get(1)).to_string());\n+                        vec!(Long(tail_eq[0].to_string()));\n+                    i_arg = Some(tail_eq[1].to_string());\n                 }\n             } else {\n                 let mut j = 1;\n@@ -583,7 +583,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                       None => {\n                         let arg_follows =\n                             last_valid_opt_id.is_some() &&\n-                            match opts.get(last_valid_opt_id.unwrap())\n+                            match opts[last_valid_opt_id.unwrap()]\n                               .hasarg {\n \n                               Yes | Maybe => true,\n@@ -609,7 +609,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                   Some(id) => id,\n                   None => return Err(UnrecognizedOption(nm.to_string()))\n                 };\n-                match opts.get(optid).hasarg {\n+                match opts[optid].hasarg {\n                   No => {\n                     if !i_arg.is_none() {\n                         return Err(UnexpectedArgument(nm.to_string()));\n@@ -646,16 +646,16 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n     }\n     i = 0u;\n     while i < n_opts {\n-        let n = vals.get(i).len();\n-        let occ = opts.get(i).occur;\n+        let n = vals[i].len();\n+        let occ = opts[i].occur;\n         if occ == Req {\n             if n == 0 {\n-                return Err(OptionMissing(opts.get(i).name.to_string()));\n+                return Err(OptionMissing(opts[i].name.to_string()));\n             }\n         }\n         if occ != Multi {\n             if n > 1 {\n-                return Err(OptionDuplicated(opts.get(i).name.to_string()));\n+                return Err(OptionDuplicated(opts[i].name.to_string()));\n             }\n         }\n         i += 1;"}, {"sha": "d539283f0a717a8b544d562bead76c06f636603f", "filename": "src/libglob/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=459ffc2adc74f5e8b64a76f5670edb419b9f65da", "patch": "@@ -154,7 +154,7 @@ impl Iterator<Path> for Paths {\n                 if self.require_dir && !path.is_dir() { continue; }\n                 return Some(path);\n             }\n-            let ref pattern = *self.dir_patterns.get(idx);\n+            let ref pattern = self.dir_patterns[idx];\n \n             if pattern.matches_with(match path.filename_str() {\n                 // this ugly match needs to go here to avoid a borrowck error\n@@ -250,21 +250,21 @@ impl Pattern {\n         let mut i = 0;\n \n         while i < chars.len() {\n-            match *chars.get(i) {\n+            match chars[i] {\n                 '?' => {\n                     tokens.push(AnyChar);\n                     i += 1;\n                 }\n                 '*' => {\n                     // *, **, ***, ****, ... are all equivalent\n-                    while i < chars.len() && *chars.get(i) == '*' {\n+                    while i < chars.len() && chars[i] == '*' {\n                         i += 1;\n                     }\n                     tokens.push(AnySequence);\n                 }\n                 '[' => {\n \n-                    if i <= chars.len() - 4 && *chars.get(i + 1) == '!' {\n+                    if i <= chars.len() - 4 && chars[i + 1] == '!' {\n                         match chars.slice_from(i + 3).position_elem(&']') {\n                             None => (),\n                             Some(j) => {\n@@ -276,7 +276,7 @@ impl Pattern {\n                             }\n                         }\n                     }\n-                    else if i <= chars.len() - 3 && *chars.get(i + 1) != '!' {\n+                    else if i <= chars.len() - 3 && chars[i + 1] != '!' {\n                         match chars.slice_from(i + 2).position_elem(&']') {\n                             None => (),\n                             Some(j) => {\n@@ -507,7 +507,7 @@ fn fill_todo(todo: &mut Vec<(Path, uint)>, patterns: &[Pattern], idx: uint, path\n                     // the current and parent directory respectively requires that\n                     // the pattern has a leading dot, even if the `MatchOptions` field\n                     // `require_literal_leading_dot` is not set.\n-                    if pattern.tokens.len() > 0 && pattern.tokens.get(0) == &Char('.') {\n+                    if pattern.tokens.len() > 0 && pattern.tokens[0] == Char('.') {\n                         for &special in [\".\", \"..\"].iter() {\n                             if pattern.matches_with(special, options) {\n                                 add(todo, path.join(special));"}, {"sha": "24698d09f56e53d782556aa343b0fd0f7e823d11", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=459ffc2adc74f5e8b64a76f5670edb419b9f65da", "patch": "@@ -168,7 +168,7 @@ impl<'a> dot::Labeller<'a, Nd, Ed<'a>> for Graph {\n         dot::Id::new(format!(\"N{}\", n))\n     }\n     fn node_label<'a>(&'a self, n: &Nd) -> dot::LabelText<'a> {\n-        dot::LabelStr(str::Slice(self.nodes.get(*n).as_slice()))\n+        dot::LabelStr(str::Slice(self.nodes[*n].as_slice()))\n     }\n     fn edge_label<'a>(&'a self, _: &Ed) -> dot::LabelText<'a> {\n         dot::LabelStr(str::Slice(\"&sube;\"))\n@@ -225,7 +225,7 @@ impl<'a> dot::Labeller<'a, Nd<'a>, Ed<'a>> for Graph {\n     }\n     fn node_label<'a>(&'a self, n: &Nd<'a>) -> dot::LabelText<'a> {\n         let &(i, _) = n;\n-        dot::LabelStr(str::Slice(self.nodes.get(i).as_slice()))\n+        dot::LabelStr(str::Slice(self.nodes[i].as_slice()))\n     }\n     fn edge_label<'a>(&'a self, _: &Ed<'a>) -> dot::LabelText<'a> {\n         dot::LabelStr(str::Slice(\"&sube;\"))\n@@ -238,8 +238,8 @@ impl<'a> dot::GraphWalk<'a, Nd<'a>, Ed<'a>> for Graph {\n     }\n     fn edges(&'a self) -> dot::Edges<'a,Ed<'a>> {\n         self.edges.iter()\n-            .map(|&(i,j)|((i, self.nodes.get(i).as_slice()),\n-                          (j, self.nodes.get(j).as_slice())))\n+            .map(|&(i,j)|((i, self.nodes[i].as_slice()),\n+                          (j, self.nodes[j].as_slice())))\n             .collect()\n     }\n     fn source(&self, e: &Ed<'a>) -> Nd<'a> { let &(s,_) = e; s }"}, {"sha": "d53fed7aa80fc897ab39f9ab64c58d45b2ae5fe2", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=459ffc2adc74f5e8b64a76f5670edb419b9f65da", "patch": "@@ -235,7 +235,7 @@ impl<'a> Parser<'a> {\n                     // left paren, let's grab the old flags and see if we\n                     // need a capture.\n                     let (cap, cap_name, oldflags) = {\n-                        let paren = self.stack.get(altfrom-1);\n+                        let paren = &self.stack[altfrom-1];\n                         (paren.capture(), paren.capture_name(), paren.flags())\n                     };\n                     try!(self.alternate(altfrom));\n@@ -464,7 +464,7 @@ impl<'a> Parser<'a> {\n                 Some(i) => i,\n                 None => return None,\n             };\n-        if *self.chars.get(closer-1) != ':' {\n+        if self.chars[closer-1] != ':' {\n             return None\n         }\n         if closer - self.chari <= 3 {\n@@ -519,7 +519,7 @@ impl<'a> Parser<'a> {\n             max = Some(min);\n         } else {\n             let pieces: Vec<&str> = inner.as_slice().splitn(',', 1).collect();\n-            let (smin, smax) = (*pieces.get(0), *pieces.get(1));\n+            let (smin, smax) = (pieces[0], pieces[1]);\n             if smin.len() == 0 {\n                 return self.err(\"Max repetitions cannot be specified \\\n                                     without min repetitions.\")\n@@ -931,15 +931,15 @@ impl<'a> Parser<'a> {\n         if self.chari + offset >= self.chars.len() {\n             return None\n         }\n-        Some(*self.chars.get(self.chari + offset))\n+        Some(self.chars[self.chari + offset])\n     }\n \n     fn peek_is(&self, offset: uint, is: char) -> bool {\n         self.peek(offset) == Some(is)\n     }\n \n     fn cur(&self) -> char {\n-        *self.chars.get(self.chari)\n+        self.chars[self.chari]\n     }\n \n     fn slice(&self, start: uint, end: uint) -> String {"}, {"sha": "8e4145b2a3198973b69ade6d83e8f6067323a78f", "filename": "src/libregex/re.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=459ffc2adc74f5e8b64a76f5670edb419b9f65da", "patch": "@@ -207,7 +207,7 @@ impl Regex {\n     pub fn find(&self, text: &str) -> Option<(uint, uint)> {\n         let caps = exec(self, Location, text);\n         if has_match(&caps) {\n-            Some((caps.get(0).unwrap(), caps.get(1).unwrap()))\n+            Some((caps[0].unwrap(), caps[1].unwrap()))\n         } else {\n             None\n         }\n@@ -699,11 +699,11 @@ impl<'t> Captures<'t> {\n     /// original string matched.\n     pub fn pos(&self, i: uint) -> Option<(uint, uint)> {\n         let (s, e) = (i * 2, i * 2 + 1);\n-        if e >= self.locs.len() || self.locs.get(s).is_none() {\n+        if e >= self.locs.len() || self.locs[s].is_none() {\n             // VM guarantees that each pair of locations are both Some or None.\n             return None\n         }\n-        Some((self.locs.get(s).unwrap(), self.locs.get(e).unwrap()))\n+        Some((self.locs[s].unwrap(), self.locs[e].unwrap()))\n     }\n \n     /// Returns the matched string for the capture group `i`.\n@@ -851,7 +851,7 @@ impl<'r, 't> Iterator<Captures<'t>> for FindCaptures<'r, 't> {\n             if !has_match(&caps) {\n                 return None\n             } else {\n-                (caps.get(0).unwrap(), caps.get(1).unwrap())\n+                (caps[0].unwrap(), caps[1].unwrap())\n             };\n \n         // Don't accept empty matches immediately following a match.\n@@ -893,7 +893,7 @@ impl<'r, 't> Iterator<(uint, uint)> for FindMatches<'r, 't> {\n             if !has_match(&caps) {\n                 return None\n             } else {\n-                (caps.get(0).unwrap(), caps.get(1).unwrap())\n+                (caps[0].unwrap(), caps[1].unwrap())\n             };\n \n         // Don't accept empty matches immediately following a match.\n@@ -922,5 +922,5 @@ fn exec_slice(re: &Regex, which: MatchKind,\n \n #[inline]\n fn has_match(caps: &CaptureLocs) -> bool {\n-    caps.len() >= 2 && caps.get(0).is_some() && caps.get(1).is_some()\n+    caps.len() >= 2 && caps[0].is_some() && caps[1].is_some()\n }"}, {"sha": "b37000df02dbec436e2c862fbb26c711efbbca28", "filename": "src/libregex/vm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibregex%2Fvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibregex%2Fvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fvm.rs?ref=459ffc2adc74f5e8b64a76f5670edb419b9f65da", "patch": "@@ -123,7 +123,7 @@ impl<'r, 't> Nfa<'r, 't> {\n         // Make sure multi-line mode isn't enabled for it, otherwise we can't\n         // drop the initial .*?\n         let prefix_anchor =\n-            match *self.prog.insts.get(1) {\n+            match self.prog.insts[1] {\n                 EmptyBegin(flags) if flags & FLAG_MULTI == 0 => true,\n                 _ => false,\n             };\n@@ -192,7 +192,7 @@ impl<'r, 't> Nfa<'r, 't> {\n     fn step(&self, groups: &mut [Option<uint>], nlist: &mut Threads,\n             caps: &mut [Option<uint>], pc: uint)\n            -> StepState {\n-        match *self.prog.insts.get(pc) {\n+        match self.prog.insts[pc] {\n             Match => {\n                 match self.which {\n                     Exists => {\n@@ -259,7 +259,7 @@ impl<'r, 't> Nfa<'r, 't> {\n         //\n         // We make a minor optimization by indicating that the state is \"empty\"\n         // so that its capture groups are not filled in.\n-        match *self.prog.insts.get(pc) {\n+        match self.prog.insts[pc] {\n             EmptyBegin(flags) => {\n                 let multi = flags & FLAG_MULTI > 0;\n                 nlist.add(pc, groups, true);\n@@ -481,8 +481,8 @@ impl Threads {\n \n     #[inline]\n     fn contains(&self, pc: uint) -> bool {\n-        let s = *self.sparse.get(pc);\n-        s < self.size && self.queue.get(s).pc == pc\n+        let s = self.sparse[pc];\n+        s < self.size && self.queue[s].pc == pc\n     }\n \n     #[inline]\n@@ -492,7 +492,7 @@ impl Threads {\n \n     #[inline]\n     fn pc(&self, i: uint) -> uint {\n-        self.queue.get(i).pc\n+        self.queue[i].pc\n     }\n \n     #[inline]"}, {"sha": "54053d215dc3bb11910794eccb11c03fdc7be040", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=459ffc2adc74f5e8b64a76f5670edb419b9f65da", "patch": "@@ -999,7 +999,7 @@ impl Clean<Item> for ty::Method {\n                 };\n                 let s = match s {\n                     ast::SelfRegion(..) => {\n-                        match ty::get(*self.fty.sig.inputs.get(0)).sty {\n+                        match ty::get(self.fty.sig.inputs[0]).sty {\n                             ty::ty_rptr(r, mt) => {\n                                 SelfBorrowed(r.clean(), mt.mutbl.clean())\n                             }"}, {"sha": "f64a75c559e9bdfaefddcd273bc4658b86e4b3ab", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=459ffc2adc74f5e8b64a76f5670edb419b9f65da", "patch": "@@ -210,7 +210,7 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n     let loc = current_location_key.get().unwrap();\n     let cache = cache_key.get().unwrap();\n     let abs_root = root(&**cache, loc.as_slice());\n-    let rel_root = match path.segments.get(0).name.as_slice() {\n+    let rel_root = match path.segments[0].name.as_slice() {\n         \"self\" => Some(\"./\".to_string()),\n         _ => None,\n     };"}, {"sha": "eed058878e0820f9c41f1ffb51803e58710588fd", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=459ffc2adc74f5e8b64a76f5670edb419b9f65da", "patch": "@@ -551,7 +551,7 @@ fn write_shared(cx: &Context,\n         }\n         mydst.push(format!(\"{}.{}.js\",\n                            remote_item_type.to_static_str(),\n-                           *remote_path.get(remote_path.len() - 1)));\n+                           remote_path[remote_path.len() - 1]));\n         let all_implementors = try!(collect(&mydst, krate.name.as_slice(),\n                                             \"implementors\"));\n "}, {"sha": "245dc9a0a34e5cbef07bb60834c86814109357f0", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=459ffc2adc74f5e8b64a76f5670edb419b9f65da", "patch": "@@ -167,7 +167,7 @@ pub fn main_args(args: &[String]) -> int {\n         println!(\"only one input file may be specified\");\n         return 1;\n     }\n-    let input = matches.free.get(0).as_slice();\n+    let input = matches.free[0].as_slice();\n \n     let libs = matches.opt_strs(\"L\").iter().map(|s| Path::new(s.as_slice())).collect();\n "}, {"sha": "f9bc59888ae3b9704f09668929799afc3b24403c", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=459ffc2adc74f5e8b64a76f5670edb419b9f65da", "patch": "@@ -75,7 +75,7 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches,\n                          \"invalid markdown file: expecting initial line with `% ...TITLE...`\");\n         return 5;\n     }\n-    let title = metadata.get(0).as_slice();\n+    let title = metadata[0].as_slice();\n \n     reset_headers();\n "}, {"sha": "cc5bc5cb7c170de7265e18f3ab14bc8ad234e937", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=459ffc2adc74f5e8b64a76f5670edb419b9f65da", "patch": "@@ -339,7 +339,7 @@ pub fn unindent(s: &str) -> String {\n     });\n \n     if lines.len() >= 1 {\n-        let mut unindented = vec![ lines.get(0).trim().to_string() ];\n+        let mut unindented = vec![ lines[0].trim().to_string() ];\n         unindented.push_all(lines.tail().iter().map(|&line| {\n             if line.is_whitespace() {\n                 line.to_string()"}, {"sha": "eedc39eb2dc1f0096c0d44389ca5f1172a7349c0", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=459ffc2adc74f5e8b64a76f5670edb419b9f65da", "patch": "@@ -1015,7 +1015,7 @@ impl Stack {\n     /// lower indices are at the bottom of the stack while higher indices are\n     /// at the top.\n     pub fn get<'l>(&'l self, idx: uint) -> StackElement<'l> {\n-        match *self.stack.get(idx) {\n+        match self.stack[idx] {\n             InternalIndex(i) => { Index(i) }\n             InternalKey(start, size) => {\n                 Key(str::from_utf8("}, {"sha": "7343838f19e6156d536ca764de216964b0df4a20", "filename": "src/libsync/mpmc_bounded_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibsync%2Fmpmc_bounded_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibsync%2Fmpmc_bounded_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmpmc_bounded_queue.rs?ref=459ffc2adc74f5e8b64a76f5670edb419b9f65da", "patch": "@@ -90,7 +90,7 @@ impl<T: Send> State<T> {\n         let mask = self.mask;\n         let mut pos = self.enqueue_pos.load(Relaxed);\n         loop {\n-            let node = self.buffer.get(pos & mask);\n+            let node = &self.buffer[pos & mask];\n             let seq = unsafe { (*node.get()).sequence.load(Acquire) };\n             let diff: int = seq as int - pos as int;\n \n@@ -118,7 +118,7 @@ impl<T: Send> State<T> {\n         let mask = self.mask;\n         let mut pos = self.dequeue_pos.load(Relaxed);\n         loop {\n-            let node = self.buffer.get(pos & mask);\n+            let node = &self.buffer[pos & mask];\n             let seq = unsafe { (*node.get()).sequence.load(Acquire) };\n             let diff: int = seq as int - (pos + 1) as int;\n             if diff == 0 {"}, {"sha": "d056566bb9a97908a61b134f1fe80cabe1c802c0", "filename": "src/libsync/raw.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibsync%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibsync%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fraw.rs?ref=459ffc2adc74f5e8b64a76f5670edb419b9f65da", "patch": "@@ -243,7 +243,7 @@ impl<'a> Condvar<'a> {\n                     }\n                     // Create waiter nobe, and enqueue ourself to\n                     // be woken up by a signaller.\n-                    wait_end = Some(state.blocked.get(condvar_id).wait_end());\n+                    wait_end = Some(state.blocked[condvar_id].wait_end());\n                 } else {\n                     out_of_bounds = Some(state.blocked.len());\n                 }\n@@ -281,7 +281,7 @@ impl<'a> Condvar<'a> {\n             let mut result = false;\n             self.sem.with(|state| {\n                 if condvar_id < state.blocked.len() {\n-                    result = state.blocked.get(condvar_id).signal();\n+                    result = state.blocked[condvar_id].signal();\n                 } else {\n                     out_of_bounds = Some(state.blocked.len());\n                 }"}, {"sha": "db76e78d1617c89b065bd2436bf68dba90f30670", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=459ffc2adc74f5e8b64a76f5670edb419b9f65da", "patch": "@@ -512,13 +512,13 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n             assert!(!s.is_empty(), \"string conversion produced empty result\");\n             match op {\n                 FormatDigit => {\n-                    if flags.space && !(*s.get(0) == '-' as u8 ||\n-                                        *s.get(0) == '+' as u8) {\n+                    if flags.space && !(s[0] == '-' as u8 ||\n+                                        s[0] == '+' as u8) {\n                         s.unshift(' ' as u8);\n                     }\n                 }\n                 FormatOctal => {\n-                    if flags.alternate && *s.get(0) != '0' as u8 {\n+                    if flags.alternate && s[0] != '0' as u8 {\n                         s.unshift('0' as u8);\n                     }\n                 }"}, {"sha": "15c5fa6b75a5ab6492b6f36681e2d25eb32feab9", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=459ffc2adc74f5e8b64a76f5670edb419b9f65da", "patch": "@@ -373,7 +373,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n     if matches.opt_present(\"h\") { usage(args[0].as_slice()); return None; }\n \n     let filter = if matches.free.len() > 0 {\n-        let s = matches.free.get(0).as_slice();\n+        let s = matches.free[0].as_slice();\n         match Regex::new(s) {\n             Ok(re) => Some(re),\n             Err(e) => return Some(Err(format!(\"could not parse /{}/: {}\", s, e)))"}, {"sha": "d8f628e2196f5780197e445dea9d45ac852c0420", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=459ffc2adc74f5e8b64a76f5670edb419b9f65da", "patch": "@@ -175,7 +175,7 @@ impl<'a,T: FloatMath + FromPrimitive> Stats<T> for &'a [T] {\n             // This inner loop applies `hi`/`lo` summation to each\n             // partial so that the list of partial sums remains exact.\n             for i in range(0, partials.len()) {\n-                let mut y = *partials.get(i);\n+                let mut y = partials[i];\n                 if num::abs(x) < num::abs(y) {\n                     mem::swap(&mut x, &mut y);\n                 }"}, {"sha": "aa13ae82e76d9758000a36c3daed2a11272c13c9", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/459ffc2adc74f5e8b64a76f5670edb419b9f65da/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=459ffc2adc74f5e8b64a76f5670edb419b9f65da", "patch": "@@ -398,8 +398,8 @@ impl Uuid {\n         match group_lens.len() {\n             // Single group, no hyphens\n             1 => {\n-                if *group_lens.get(0) != 32 {\n-                    return Err(ErrorInvalidLength(*group_lens.get(0)));\n+                if group_lens[0] != 32 {\n+                    return Err(ErrorInvalidLength(group_lens[0]));\n                 }\n             },\n             // Five groups, hyphens in between each"}]}