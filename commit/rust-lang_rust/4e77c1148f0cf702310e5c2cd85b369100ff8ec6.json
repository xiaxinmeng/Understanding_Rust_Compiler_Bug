{"sha": "4e77c1148f0cf702310e5c2cd85b369100ff8ec6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlNzdjMTE0OGYwY2Y3MDIzMTBlNWMyY2Q4NWIzNjkxMDBmZjhlYzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-16T13:51:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-16T13:51:32Z"}, "message": "auto merge of #10966 : michaelwoerister/rust/prelude2, r=cmr\n\nThis PR improves the stepping experience in GDB. It contains some fine tuning of line information and makes *rustc* produce nearly the same IR/DWARF as Clang. The focus of the changes is function prologue handling which has caused some problems in the past (https://github.com/mozilla/rust/issues/9641).\r\n\r\nIt seems that GDB does not properly handle function prologues when the function uses segmented stacks, i.e. it does not recognize that the `__morestack` check is part of the prologue. When setting a breakpoint like `break foo` it will set the break point before the arguments of `foo()` have been loaded and still contain bogus values. For function with the #[no_split_stack] attribute this problem has never occurred for me so I'm pretty sure that segmented stacks are the cause of the problem. @jdm mentioned that segmented stack won't be completely abandoned after all. I'd be grateful if you could tell me about what the future might bring in this regard (@brson, @cmr).\r\n\r\nAnyway, this PR should alleviate this problem at least in the case when setting breakpoints using line numbers and also make it less confusing when setting them via function names because then GDB will break *before* the first statement where one could conceivably argue that arguments need not be initialized yet.\r\n\r\nAlso, a koala: :koala:\r\n\r\nCheers,\r\nMichael", "tree": {"sha": "dd7d008884af774da7cf69f424c3f271fa4adae4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd7d008884af774da7cf69f424c3f271fa4adae4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e77c1148f0cf702310e5c2cd85b369100ff8ec6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e77c1148f0cf702310e5c2cd85b369100ff8ec6", "html_url": "https://github.com/rust-lang/rust/commit/4e77c1148f0cf702310e5c2cd85b369100ff8ec6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e77c1148f0cf702310e5c2cd85b369100ff8ec6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b424974531b0ade62e6a26cce038abf5dac0723", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b424974531b0ade62e6a26cce038abf5dac0723", "html_url": "https://github.com/rust-lang/rust/commit/7b424974531b0ade62e6a26cce038abf5dac0723"}, {"sha": "9384de77bbc8edf5e7c7c1a84e79cd29588cdee9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9384de77bbc8edf5e7c7c1a84e79cd29588cdee9", "html_url": "https://github.com/rust-lang/rust/commit/9384de77bbc8edf5e7c7c1a84e79cd29588cdee9"}], "stats": {"total": 611, "additions": 584, "deletions": 27}, "files": [{"sha": "745c9a2a29a7debe027478e46746d99180ba3f83", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e77c1148f0cf702310e5c2cd85b369100ff8ec6/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e77c1148f0cf702310e5c2cd85b369100ff8ec6/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=4e77c1148f0cf702310e5c2cd85b369100ff8ec6", "patch": "@@ -220,6 +220,7 @@ use util::common::indenter;\n use util::ppaux::{Repr, vec_map_to_str};\n \n use std::hashmap::HashMap;\n+use std::ptr;\n use std::vec;\n use syntax::ast;\n use syntax::ast::Ident;\n@@ -2046,7 +2047,10 @@ pub fn store_arg(mut bcx: @mut Block,\n     // Debug information (the llvm.dbg.declare intrinsic to be precise) always expects to get an\n     // alloca, which only is the case on the general path, so lets disable the optimized path when\n     // debug info is enabled.\n-    let fast_path = !bcx.ccx().sess.opts.extra_debuginfo && simple_identifier(pat).is_some();\n+    let arg_is_alloca = unsafe { llvm::LLVMIsAAllocaInst(llval) != ptr::null() };\n+\n+    let fast_path = (arg_is_alloca || !bcx.ccx().sess.opts.extra_debuginfo)\n+                    && simple_identifier(pat).is_some();\n \n     if fast_path {\n         // Optimized path for `x: T` case. This just adopts"}, {"sha": "abb3e22edb72dd6b59b5b695e22f8292665ba990", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4e77c1148f0cf702310e5c2cd85b369100ff8ec6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e77c1148f0cf702310e5c2cd85b369100ff8ec6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=4e77c1148f0cf702310e5c2cd85b369100ff8ec6", "patch": "@@ -875,8 +875,11 @@ pub fn trans_external_path(ccx: &mut CrateContext, did: ast::DefId, t: ty::t) ->\n     }\n }\n \n-pub fn invoke(bcx: @mut Block, llfn: ValueRef, llargs: ~[ValueRef],\n-              attributes: &[(uint, lib::llvm::Attribute)])\n+pub fn invoke(bcx: @mut Block,\n+              llfn: ValueRef,\n+              llargs: ~[ValueRef],\n+              attributes: &[(uint, lib::llvm::Attribute)],\n+              call_info: Option<NodeInfo>)\n            -> (ValueRef, @mut Block) {\n     let _icx = push_ctxt(\"invoke_\");\n     if bcx.unreachable {\n@@ -899,11 +902,18 @@ pub fn invoke(bcx: @mut Block, llfn: ValueRef, llargs: ~[ValueRef],\n             }\n         }\n         let normal_bcx = sub_block(bcx, \"normal return\");\n+        let landing_pad = get_landing_pad(bcx);\n+\n+        match call_info {\n+            Some(info) => debuginfo::set_source_location(bcx.fcx, info.id, info.span),\n+            None => debuginfo::clear_source_location(bcx.fcx)\n+        };\n+\n         let llresult = Invoke(bcx,\n                               llfn,\n                               llargs,\n                               normal_bcx.llbb,\n-                              get_landing_pad(bcx),\n+                              landing_pad,\n                               attributes);\n         return (llresult, normal_bcx);\n     } else {\n@@ -913,6 +923,12 @@ pub fn invoke(bcx: @mut Block, llfn: ValueRef, llargs: ~[ValueRef],\n                 debug!(\"arg: {}\", llarg);\n             }\n         }\n+\n+        match call_info {\n+            Some(info) => debuginfo::set_source_location(bcx.fcx, info.id, info.span),\n+            None => debuginfo::clear_source_location(bcx.fcx)\n+        };\n+\n         let llresult = Call(bcx, llfn, llargs, attributes);\n         return (llresult, bcx);\n     }\n@@ -1551,6 +1567,7 @@ pub fn alloca_maybe_zeroed(cx: @mut Block, ty: Type, name: &str, zero: bool) ->\n             return llvm::LLVMGetUndef(ty.ptr_to().to_ref());\n         }\n     }\n+    debuginfo::clear_source_location(cx.fcx);\n     let p = Alloca(cx, ty, name);\n     if zero {\n         let b = cx.fcx.ccx.builder();\n@@ -1567,6 +1584,7 @@ pub fn arrayalloca(cx: @mut Block, ty: Type, v: ValueRef) -> ValueRef {\n             return llvm::LLVMGetUndef(ty.to_ref());\n         }\n     }\n+    debuginfo::clear_source_location(cx.fcx);\n     return ArrayAlloca(cx, ty, v);\n }\n \n@@ -1810,6 +1828,7 @@ pub fn finish_fn(fcx: @mut FunctionContext, last_bcx: @mut Block) {\n         None => last_bcx\n     };\n     build_return_block(fcx, ret_cx);\n+    debuginfo::clear_source_location(fcx);\n     fcx.cleanup();\n }\n "}, {"sha": "db193b9200ae12cf0883f50bd493647dff6cbb67", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e77c1148f0cf702310e5c2cd85b369100ff8ec6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e77c1148f0cf702310e5c2cd85b369100ff8ec6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=4e77c1148f0cf702310e5c2cd85b369100ff8ec6", "patch": "@@ -697,7 +697,7 @@ pub fn trans_call_inner(in_cx: @mut Block,\n             }\n \n             // Invoke the actual rust fn and update bcx/llresult.\n-            let (llret, b) = base::invoke(bcx, llfn, llargs, attrs);\n+            let (llret, b) = base::invoke(bcx, llfn, llargs, attrs, call_info);\n             bcx = b;\n             llresult = llret;\n "}, {"sha": "0783d5b418f2166d8953629e2050ea2b0773527c", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 61, "deletions": 19, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/4e77c1148f0cf702310e5c2cd85b369100ff8ec6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e77c1148f0cf702310e5c2cd85b369100ff8ec6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=4e77c1148f0cf702310e5c2cd85b369100ff8ec6", "patch": "@@ -85,6 +85,43 @@ continuation, storing all state needed to continue traversal at the type members\n been registered with the cache. (This implementation approach might be a tad over-engineered and\n may change in the future)\n \n+\n+## Source Locations and Line Information\n+In addition to data type descriptions the debugging information must also allow to map machine code\n+locations back to source code locations in order to be useful. This functionality is also handled in\n+this module. The following functions allow to control source mappings:\n+\n++ set_source_location()\n++ clear_source_location()\n++ start_emitting_source_locations()\n+\n+`set_source_location()` allows to set the current source location. All IR instructions created after\n+a call to this function will be linked to the given source location, until another location is\n+specified with `set_source_location()` or the source location is cleared with\n+`clear_source_location()`. In the later case, subsequent IR instruction will not be linked to any\n+source location. As you can see, this is a stateful API (mimicking the one in LLVM), so be careful\n+with source locations set by previous calls. It's probably best to not rely on any specific state\n+being present at a given point in code.\n+\n+One topic that deserves some extra attention is *function prologues*. At the beginning of a\n+function's machine code there are typically a few instructions for loading argument values into\n+allocas and checking if there's enough stack space for the function to execute. This *prologue* is\n+not visible in the source code and LLVM puts a special PROLOGUE END marker into the line table at\n+the first non-prologue instruction of the function. In order to find out where the prologue ends,\n+LLVM looks for the first instruction in the function body that is linked to a source location. So,\n+when generating prologue instructions we have to make sure that we don't emit source location\n+information until the 'real' function body begins. For this reason, source location emission is\n+disabled by default for any new function being translated and is only activated after a call to the\n+third function from the list above, `start_emitting_source_locations()`. This function should be\n+called right before regularly starting to translate the top-level block of the given function.\n+\n+There is one exception to the above rule: `llvm.dbg.declare` instruction must be linked to the\n+source location of the variable being declared. For function parameters these `llvm.dbg.declare`\n+instructions typically occur in the middle of the prologue, however, they are ignored by LLVM's\n+prologue detection. The `create_argument_metadata()` and related functions take care of linking the\n+`llvm.dbg.declare` instructions to the correct source locations even while source location emission\n+is still disabled, so there is no need to do anything special with source location handling here.\n+\n */\n \n \n@@ -651,7 +688,16 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n         (function_name.clone(), file_metadata)\n     };\n \n-    let scope_line = get_scope_line(cx, top_level_block, loc.line);\n+    // Clang sets this parameter to the opening brace of the function's block, so let's do this too.\n+    let scope_line = span_start(cx, top_level_block.span).line;\n+\n+    // The is_local_to_unit flag indicates whether a function is local to the current compilation\n+    // unit (i.e. if it is *static* in the C-sense). The *reachable* set should provide a good\n+    // approximation of this, as it contains everything that might leak out of the current crate\n+    // (by being externally visible or by being inlined into something externally visible). It might\n+    // better to use the `exported_items` set from `driver::CrateAnalysis` in the future, but (atm)\n+    // this set is not available in the translation pass.\n+    let is_local_to_unit = !cx.reachable.contains(&fn_ast_id);\n \n     let fn_metadata = function_name.with_c_str(|function_name| {\n                           linkage_name.with_c_str(|linkage_name| {\n@@ -664,7 +710,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n                     file_metadata,\n                     loc.line as c_uint,\n                     function_type_metadata,\n-                    false,\n+                    is_local_to_unit,\n                     true,\n                     scope_line as c_uint,\n                     FlagPrototyped as c_uint,\n@@ -687,6 +733,9 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n     let arg_pats = fn_decl.inputs.map(|arg_ref| arg_ref.pat);\n     populate_scope_map(cx, arg_pats, top_level_block, fn_metadata, &mut fn_debug_context.scope_map);\n \n+    // Clear the debug location so we don't assign them in the function prelude\n+    set_debug_location(cx, UnknownLocation);\n+\n     return FunctionDebugContext(fn_debug_context);\n \n     fn get_function_signature(cx: &mut CrateContext,\n@@ -837,21 +886,6 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n \n         return create_DIArray(DIB(cx), template_params);\n     }\n-\n-    fn get_scope_line(cx: &CrateContext,\n-                      top_level_block: &ast::Block,\n-                      default: uint)\n-                   -> uint {\n-        match *top_level_block {\n-            ast::Block { stmts: ref statements, .. } if statements.len() > 0 => {\n-                span_start(cx, statements[0].span).line\n-            }\n-            ast::Block { expr: Some(@ref expr), .. } => {\n-                span_start(cx, expr.span).line\n-            }\n-            _ => default\n-        }\n-    }\n }\n \n //=-------------------------------------------------------------------------------------------------\n@@ -2128,7 +2162,8 @@ fn set_debug_location(cx: &mut CrateContext, debug_location: DebugLocation) {\n     let metadata_node;\n \n     match debug_location {\n-        KnownLocation { scope, line, col } => {\n+        KnownLocation { scope, line, .. } => {\n+            let col = 0; // Always set the column to zero like Clang and GCC\n             debug!(\"setting debug location to {} {}\", line, col);\n             let elements = [C_i32(line as i32), C_i32(col as i32), scope, ptr::null()];\n             unsafe {\n@@ -2244,7 +2279,14 @@ fn populate_scope_map(cx: &mut CrateContext,\n         })\n     }\n \n-    walk_block(cx, fn_entry_block, &mut scope_stack, scope_map);\n+    // Clang creates a separate scope for function bodies, so let's do this too\n+    with_new_scope(cx,\n+                   fn_entry_block.span,\n+                   &mut scope_stack,\n+                   scope_map,\n+                   |cx, scope_stack, scope_map| {\n+        walk_block(cx, fn_entry_block, scope_stack, scope_map);\n+    });\n \n     // local helper functions for walking the AST.\n     fn with_new_scope(cx: &mut CrateContext,"}, {"sha": "acbe2d13d12d0744ef78acb9a0c8f9936902d621", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e77c1148f0cf702310e5c2cd85b369100ff8ec6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e77c1148f0cf702310e5c2cd85b369100ff8ec6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=4e77c1148f0cf702310e5c2cd85b369100ff8ec6", "patch": "@@ -429,7 +429,7 @@ pub fn trans_struct_drop(bcx: @mut Block, t: ty::t, v0: ValueRef, dtor_did: ast:\n             add_clean(bcx, llfld_a, fld.mt.ty);\n         }\n \n-        let (_, bcx) = invoke(bcx, dtor_addr, args, []);\n+        let (_, bcx) = invoke(bcx, dtor_addr, args, [], None);\n         bcx\n     })\n }"}, {"sha": "0e48b5db7ce780c8fd749dfd11c47f405a98fc8f", "filename": "src/test/debug-info/basic-types-metadata.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4e77c1148f0cf702310e5c2cd85b369100ff8ec6/src%2Ftest%2Fdebug-info%2Fbasic-types-metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e77c1148f0cf702310e5c2cd85b369100ff8ec6/src%2Ftest%2Fdebug-info%2Fbasic-types-metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fbasic-types-metadata.rs?ref=4e77c1148f0cf702310e5c2cd85b369100ff8ec6", "patch": "@@ -45,8 +45,7 @@\n // debugger:whatis f64\n // check:type = f64\n // debugger:info functions _yyy\n-// check:[...]\n-// check:![...]_yyy()();\n+// check:[...]![...]_yyy()();\n // debugger:detach\n // debugger:quit\n "}, {"sha": "e0a4afd4bdfddf8e3d825c8119b3734bb2d7a133", "filename": "src/test/debug-info/function-arg-initialization.rs", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/4e77c1148f0cf702310e5c2cd85b369100ff8ec6/src%2Ftest%2Fdebug-info%2Ffunction-arg-initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e77c1148f0cf702310e5c2cd85b369100ff8ec6/src%2Ftest%2Fdebug-info%2Ffunction-arg-initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Ffunction-arg-initialization.rs?ref=4e77c1148f0cf702310e5c2cd85b369100ff8ec6", "patch": "@@ -0,0 +1,244 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-android: FIXME(#10381)\n+\n+// This test case checks if function arguments already have the correct value when breaking at the\n+// first line of the function, that is if the function prologue has already been executed at the\n+// first line. Note that because of the __morestack part of the prologue GDB incorrectly breaks at\n+// before the arguments have been properly loaded when setting the breakpoint via the function name.\n+// Therefore the setup here sets them using line numbers (so be careful when changing this file).\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:set print pretty off\n+// debugger:break function-arg-initialization.rs:139\n+// debugger:break function-arg-initialization.rs:154\n+// debugger:break function-arg-initialization.rs:158\n+// debugger:break function-arg-initialization.rs:162\n+// debugger:break function-arg-initialization.rs:166\n+// debugger:break function-arg-initialization.rs:170\n+// debugger:break function-arg-initialization.rs:174\n+// debugger:break function-arg-initialization.rs:178\n+// debugger:break function-arg-initialization.rs:182\n+// debugger:break function-arg-initialization.rs:190\n+// debugger:break function-arg-initialization.rs:197\n+\n+\n+// debugger:run\n+\n+// IMMEDIATE ARGS\n+// debugger:print a\n+// check:$1 = 1\n+// debugger:print b\n+// check:$2 = true\n+// debugger:print c\n+// check:$3 = 2.5\n+// debugger:continue\n+\n+// NON IMMEDIATE ARGS\n+// debugger:print a\n+// check:$4 = {a = 3, b = 4, c = 5, d = 6, e = 7, f = 8, g = 9, h = 10}\n+// debugger:print b\n+// check:$5 = {a = 11, b = 12, c = 13, d = 14, e = 15, f = 16, g = 17, h = 18}\n+// debugger:continue\n+\n+// BINDING\n+// debugger:print a\n+// check:$6 = 19\n+// debugger:print b\n+// check:$7 = 20\n+// debugger:print c\n+// check:$8 = 21.5\n+// debugger:continue\n+\n+// ASSIGNMENT\n+// debugger:print a\n+// check:$9 = 22\n+// debugger:print b\n+// check:$10 = 23\n+// debugger:print c\n+// check:$11 = 24.5\n+// debugger:continue\n+\n+// FUNCTION CALL\n+// debugger:print x\n+// check:$12 = 25\n+// debugger:print y\n+// check:$13 = 26\n+// debugger:print z\n+// check:$14 = 27.5\n+// debugger:continue\n+\n+// EXPR\n+// debugger:print x\n+// check:$15 = 28\n+// debugger:print y\n+// check:$16 = 29\n+// debugger:print z\n+// check:$17 = 30.5\n+// debugger:continue\n+\n+// RETURN EXPR\n+// debugger:print x\n+// check:$18 = 31\n+// debugger:print y\n+// check:$19 = 32\n+// debugger:print z\n+// check:$20 = 33.5\n+// debugger:continue\n+\n+// ARITHMETIC EXPR\n+// debugger:print x\n+// check:$21 = 34\n+// debugger:print y\n+// check:$22 = 35\n+// debugger:print z\n+// check:$23 = 36.5\n+// debugger:continue\n+\n+// IF EXPR\n+// debugger:print x\n+// check:$24 = 37\n+// debugger:print y\n+// check:$25 = 38\n+// debugger:print z\n+// check:$26 = 39.5\n+// debugger:continue\n+\n+// WHILE EXPR\n+// debugger:print x\n+// check:$27 = 40\n+// debugger:print y\n+// check:$28 = 41\n+// debugger:print z\n+// check:$29 = 42\n+// debugger:continue\n+\n+// LOOP EXPR\n+// debugger:print x\n+// check:$30 = 43\n+// debugger:print y\n+// check:$31 = 44\n+// debugger:print z\n+// check:$32 = 45\n+// debugger:continue\n+\n+#[allow(unused_variable)];\n+\n+\n+\n+\n+fn immediate_args(a: int, b: bool, c: f64) {\n+    ()\n+}\n+\n+struct BigStruct {\n+    a: u64,\n+    b: u64,\n+    c: u64,\n+    d: u64,\n+    e: u64,\n+    f: u64,\n+    g: u64,\n+    h: u64\n+}\n+\n+fn non_immediate_args(a: BigStruct, b: BigStruct) {\n+    ()\n+}\n+\n+fn binding(a: i64, b: u64, c: f64) {\n+    let x = 0;\n+}\n+\n+fn assignment(mut a: u64, b: u64, c: f64) {\n+    a = b;\n+}\n+\n+fn function_call(x: u64, y: u64, z: f64) {\n+    print(\"Hi!\")\n+}\n+\n+fn identifier(x: u64, y: u64, z: f64) -> u64 {\n+    x\n+}\n+\n+fn return_expr(x: u64, y: u64, z: f64) -> u64 {\n+    return x;\n+}\n+\n+fn arithmetic_expr(x: u64, y: u64, z: f64) -> u64 {\n+    x + y\n+}\n+\n+fn if_expr(x: u64, y: u64, z: f64) -> u64 {\n+    if x + y < 1000 {\n+        x\n+    } else {\n+        y\n+    }\n+}\n+\n+fn while_expr(mut x: u64, y: u64, z: u64) -> u64 {\n+    while x + y < 1000 {\n+        x += z\n+    }\n+    return x;\n+}\n+\n+fn loop_expr(mut x: u64, y: u64, z: u64) -> u64 {\n+    loop {\n+        x += z;\n+\n+        if x + y > 1000 {\n+            return x;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    immediate_args(1, true, 2.5);\n+\n+    non_immediate_args(\n+        BigStruct {\n+            a: 3,\n+            b: 4,\n+            c: 5,\n+            d: 6,\n+            e: 7,\n+            f: 8,\n+            g: 9,\n+            h: 10\n+        },\n+        BigStruct {\n+            a: 11,\n+            b: 12,\n+            c: 13,\n+            d: 14,\n+            e: 15,\n+            f: 16,\n+            g: 17,\n+            h: 18\n+        }\n+    );\n+\n+    binding(19, 20, 21.5);\n+    assignment(22, 23, 24.5);\n+    function_call(25, 26, 27.5);\n+    identifier(28, 29, 30.5);\n+    return_expr(31, 32, 33.5);\n+    arithmetic_expr(34, 35, 36.5);\n+    if_expr(37, 38, 39.5);\n+    while_expr(40, 41, 42);\n+    loop_expr(43, 44, 45);\n+}\n+\n+\n+"}, {"sha": "b0528744cff7ca8739b00f9398e22c2200a64769", "filename": "src/test/debug-info/function-prologue-stepping-no-split-stack.rs", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/4e77c1148f0cf702310e5c2cd85b369100ff8ec6/src%2Ftest%2Fdebug-info%2Ffunction-prologue-stepping-no-split-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e77c1148f0cf702310e5c2cd85b369100ff8ec6/src%2Ftest%2Fdebug-info%2Ffunction-prologue-stepping-no-split-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Ffunction-prologue-stepping-no-split-stack.rs?ref=4e77c1148f0cf702310e5c2cd85b369100ff8ec6", "patch": "@@ -0,0 +1,249 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-android: FIXME(#10381)\n+\n+// This test case checks if function arguments already have the correct value when breaking at the\n+// beginning of a function. Functions with the #[no_split_stack] attribute have the same prologue as\n+// regular C functions compiled with GCC or Clang and therefore are better handled by GDB. As a\n+// consequence, and as opposed to regular Rust functions, we can set the breakpoints via the\n+// function name (and don't have to fall back on using line numbers).\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:set print pretty off\n+// debugger:rbreak immediate_args\n+// debugger:rbreak binding\n+// debugger:rbreak assignment\n+// debugger:rbreak function_call\n+// debugger:rbreak identifier\n+// debugger:rbreak return_expr\n+// debugger:rbreak arithmetic_expr\n+// debugger:rbreak if_expr\n+// debugger:rbreak while_expr\n+// debugger:rbreak loop_expr\n+// debugger:run\n+\n+// IMMEDIATE ARGS\n+// debugger:print a\n+// check:$1 = 1\n+// debugger:print b\n+// check:$2 = true\n+// debugger:print c\n+// check:$3 = 2.5\n+// debugger:continue\n+\n+// NON IMMEDIATE ARGS\n+// debugger:print a\n+// check:$4 = {a = 3, b = 4, c = 5, d = 6, e = 7, f = 8, g = 9, h = 10}\n+// debugger:print b\n+// check:$5 = {a = 11, b = 12, c = 13, d = 14, e = 15, f = 16, g = 17, h = 18}\n+// debugger:continue\n+\n+// BINDING\n+// debugger:print a\n+// check:$6 = 19\n+// debugger:print b\n+// check:$7 = 20\n+// debugger:print c\n+// check:$8 = 21.5\n+// debugger:continue\n+\n+// ASSIGNMENT\n+// debugger:print a\n+// check:$9 = 22\n+// debugger:print b\n+// check:$10 = 23\n+// debugger:print c\n+// check:$11 = 24.5\n+// debugger:continue\n+\n+// FUNCTION CALL\n+// debugger:print x\n+// check:$12 = 25\n+// debugger:print y\n+// check:$13 = 26\n+// debugger:print z\n+// check:$14 = 27.5\n+// debugger:continue\n+\n+// EXPR\n+// debugger:print x\n+// check:$15 = 28\n+// debugger:print y\n+// check:$16 = 29\n+// debugger:print z\n+// check:$17 = 30.5\n+// debugger:continue\n+\n+// RETURN EXPR\n+// debugger:print x\n+// check:$18 = 31\n+// debugger:print y\n+// check:$19 = 32\n+// debugger:print z\n+// check:$20 = 33.5\n+// debugger:continue\n+\n+// ARITHMETIC EXPR\n+// debugger:print x\n+// check:$21 = 34\n+// debugger:print y\n+// check:$22 = 35\n+// debugger:print z\n+// check:$23 = 36.5\n+// debugger:continue\n+\n+// IF EXPR\n+// debugger:print x\n+// check:$24 = 37\n+// debugger:print y\n+// check:$25 = 38\n+// debugger:print z\n+// check:$26 = 39.5\n+// debugger:continue\n+\n+// WHILE EXPR\n+// debugger:print x\n+// check:$27 = 40\n+// debugger:print y\n+// check:$28 = 41\n+// debugger:print z\n+// check:$29 = 42\n+// debugger:continue\n+\n+// LOOP EXPR\n+// debugger:print x\n+// check:$30 = 43\n+// debugger:print y\n+// check:$31 = 44\n+// debugger:print z\n+// check:$32 = 45\n+// debugger:continue\n+\n+#[allow(unused_variable)];\n+\n+#[no_split_stack]\n+fn immediate_args(a: int, b: bool, c: f64) {\n+    ()\n+}\n+\n+struct BigStruct {\n+    a: u64,\n+    b: u64,\n+    c: u64,\n+    d: u64,\n+    e: u64,\n+    f: u64,\n+    g: u64,\n+    h: u64\n+}\n+\n+#[no_split_stack]\n+fn non_immediate_args(a: BigStruct, b: BigStruct) {\n+    ()\n+}\n+\n+#[no_split_stack]\n+fn binding(a: i64, b: u64, c: f64) {\n+    let x = 0;\n+}\n+\n+#[no_split_stack]\n+fn assignment(mut a: u64, b: u64, c: f64) {\n+    a = b;\n+}\n+\n+#[no_split_stack]\n+fn function_call(x: u64, y: u64, z: f64) {\n+    print(\"Hi!\")\n+}\n+\n+#[no_split_stack]\n+fn identifier(x: u64, y: u64, z: f64) -> u64 {\n+    x\n+}\n+\n+#[no_split_stack]\n+fn return_expr(x: u64, y: u64, z: f64) -> u64 {\n+    return x;\n+}\n+\n+#[no_split_stack]\n+fn arithmetic_expr(x: u64, y: u64, z: f64) -> u64 {\n+    x + y\n+}\n+\n+#[no_split_stack]\n+fn if_expr(x: u64, y: u64, z: f64) -> u64 {\n+    if x + y < 1000 {\n+        x\n+    } else {\n+        y\n+    }\n+}\n+\n+#[no_split_stack]\n+fn while_expr(mut x: u64, y: u64, z: u64) -> u64 {\n+    while x + y < 1000 {\n+        x += z\n+    }\n+    return x;\n+}\n+\n+#[no_split_stack]\n+fn loop_expr(mut x: u64, y: u64, z: u64) -> u64 {\n+    loop {\n+        x += z;\n+\n+        if x + y > 1000 {\n+            return x;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    immediate_args(1, true, 2.5);\n+\n+    non_immediate_args(\n+        BigStruct {\n+            a: 3,\n+            b: 4,\n+            c: 5,\n+            d: 6,\n+            e: 7,\n+            f: 8,\n+            g: 9,\n+            h: 10\n+        },\n+        BigStruct {\n+            a: 11,\n+            b: 12,\n+            c: 13,\n+            d: 14,\n+            e: 15,\n+            f: 16,\n+            g: 17,\n+            h: 18\n+        }\n+    );\n+\n+    binding(19, 20, 21.5);\n+    assignment(22, 23, 24.5);\n+    function_call(25, 26, 27.5);\n+    identifier(28, 29, 30.5);\n+    return_expr(31, 32, 33.5);\n+    arithmetic_expr(34, 35, 36.5);\n+    if_expr(37, 38, 39.5);\n+    while_expr(40, 41, 42);\n+    loop_expr(43, 44, 45);\n+}\n+\n+\n+"}]}