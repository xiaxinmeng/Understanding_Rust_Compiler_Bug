{"sha": "bb8111069ed38455d915f7f8f0e050bb3c3720cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiODExMTA2OWVkMzg0NTVkOTE1ZjdmOGYwZTA1MGJiM2MzNzIwY2Y=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-09-29T16:28:39Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-18T13:21:20Z"}, "message": "Destructure byte array constants to array patterns instead of keeping them opaque", "tree": {"sha": "77aefa0b4086968fca6c8837cac208c1808331d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77aefa0b4086968fca6c8837cac208c1808331d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb8111069ed38455d915f7f8f0e050bb3c3720cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb8111069ed38455d915f7f8f0e050bb3c3720cf", "html_url": "https://github.com/rust-lang/rust/commit/bb8111069ed38455d915f7f8f0e050bb3c3720cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb8111069ed38455d915f7f8f0e050bb3c3720cf/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b37d941a29d91afbfa06afcb63f702ee7b810d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b37d941a29d91afbfa06afcb63f702ee7b810d6", "html_url": "https://github.com/rust-lang/rust/commit/3b37d941a29d91afbfa06afcb63f702ee7b810d6"}], "stats": {"total": 47, "additions": 13, "deletions": 34}, "files": [{"sha": "b657f25f1edb1fdfa222e2031f8e85b6f5fbc569", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bb8111069ed38455d915f7f8f0e050bb3c3720cf/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8111069ed38455d915f7f8f0e050bb3c3720cf/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=bb8111069ed38455d915f7f8f0e050bb3c3720cf", "patch": "@@ -304,12 +304,11 @@ use std::iter::{FromIterator, IntoIterator};\n use std::ops::RangeInclusive;\n \n crate fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pat<'tcx>) -> Pat<'tcx> {\n-    LiteralExpander { tcx: cx.tcx, param_env: cx.param_env }.fold_pattern(&pat)\n+    LiteralExpander { tcx: cx.tcx }.fold_pattern(&pat)\n }\n \n struct LiteralExpander<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n }\n \n impl<'tcx> LiteralExpander<'tcx> {\n@@ -328,40 +327,17 @@ impl<'tcx> LiteralExpander<'tcx> {\n     ) -> ConstValue<'tcx> {\n         debug!(\"fold_const_value_deref {:?} {:?} {:?}\", val, rty, crty);\n         match (val, &crty.kind(), &rty.kind()) {\n-            // the easy case, deref a reference\n-            (ConstValue::Scalar(p), x, y) if x == y => {\n-                match p {\n-                    Scalar::Ptr(p) => {\n-                        let alloc = self.tcx.global_alloc(p.alloc_id).unwrap_memory();\n-                        ConstValue::ByRef { alloc, offset: p.offset }\n-                    }\n-                    Scalar::Raw { .. } => {\n-                        let layout = self.tcx.layout_of(self.param_env.and(rty)).unwrap();\n-                        if layout.is_zst() {\n-                            // Deref of a reference to a ZST is a nop.\n-                            ConstValue::Scalar(Scalar::zst())\n-                        } else {\n-                            // FIXME(oli-obk): this is reachable for `const FOO: &&&u32 = &&&42;`\n-                            bug!(\"cannot deref {:#?}, {} -> {}\", val, crty, rty);\n-                        }\n-                    }\n-                }\n-            }\n             // unsize array to slice if pattern is array but match value or other patterns are slice\n             (ConstValue::Scalar(Scalar::Ptr(p)), ty::Array(t, n), ty::Slice(u)) => {\n                 assert_eq!(t, u);\n+                assert_eq!(p.offset, Size::ZERO);\n                 ConstValue::Slice {\n                     data: self.tcx.global_alloc(p.alloc_id).unwrap_memory(),\n-                    start: p.offset.bytes().try_into().unwrap(),\n+                    start: 0,\n                     end: n.eval_usize(self.tcx, ty::ParamEnv::empty()).try_into().unwrap(),\n                 }\n             }\n-            // fat pointers stay the same\n-            (ConstValue::Slice { .. }, _, _)\n-            | (_, ty::Slice(_), ty::Slice(_))\n-            | (_, ty::Str, ty::Str) => val,\n-            // FIXME(oli-obk): this is reachable for `const FOO: &&&u32 = &&&42;` being used\n-            _ => bug!(\"cannot deref {:#?}, {} -> {}\", val, crty, rty),\n+            _ => val,\n         }\n     }\n }"}, {"sha": "32b9b0a2d3b142f162ef615d0f55accab0902cf1", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bb8111069ed38455d915f7f8f0e050bb3c3720cf/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8111069ed38455d915f7f8f0e050bb3c3720cf/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=bb8111069ed38455d915f7f8f0e050bb3c3720cf", "patch": "@@ -390,11 +390,14 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 ty::Slice(elem_ty) if elem_ty == tcx.types.u8 => PatKind::Constant { value: cv },\n                 // `b\"foo\"` produces a `&[u8; 3]`, but you can't use constants of array type when\n                 // matching against references, you can only use byte string literals.\n-                // FIXME: clean this up, likely by permitting array patterns when matching on slices\n-                ty::Array(elem_ty, _) if elem_ty == tcx.types.u8 => PatKind::Constant { value: cv },\n+                // The typechecker has a special case for byte string literals, by treating them\n+                // as slices. This means we turn `&[T; N]` constants into slice patterns, which\n+                // has no negative effects on pattern matching, even if we're actually matching on\n+                // arrays.\n+                ty::Array(..) |\n                 // Cannot merge this with the catch all branch below, because the `const_deref`\n-                // changes the type from slice to array, and slice patterns behave differently from\n-                // array patterns.\n+                // changes the type from slice to array, we need to keep the original type in the\n+                // pattern.\n                 ty::Slice(..) => {\n                     let old = self.behind_reference.replace(true);\n                     let array = tcx.deref_const(self.param_env.and(cv));"}, {"sha": "7968f9713ff2272552e57f07f83501e0b7739953", "filename": "src/test/ui/pattern/usefulness/match-byte-array-patterns-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb8111069ed38455d915f7f8f0e050bb3c3720cf/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bb8111069ed38455d915f7f8f0e050bb3c3720cf/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr?ref=bb8111069ed38455d915f7f8f0e050bb3c3720cf", "patch": "@@ -7,11 +7,11 @@ LL |     match buf {\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[u8; 4]`\n \n-error[E0004]: non-exhaustive patterns: `&[]`, `&[_]`, `&[_, _]` and 2 more not covered\n+error[E0004]: non-exhaustive patterns: `&[0_u8..=64_u8, _, _, _]` and `&[66_u8..=u8::MAX, _, _, _]` not covered\n   --> $DIR/match-byte-array-patterns-2.rs:10:11\n    |\n LL |     match buf {\n-   |           ^^^ patterns `&[]`, `&[_]`, `&[_, _]` and 2 more not covered\n+   |           ^^^ patterns `&[0_u8..=64_u8, _, _, _]` and `&[66_u8..=u8::MAX, _, _, _]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[u8]`"}]}