{"sha": "6832f75f0b3c149ff9943851d354e2ee203516c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4MzJmNzVmMGIzYzE0OWZmOTk0Mzg1MWQzNTRlMmVlMjAzNTE2YzE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-29T01:15:39Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-29T01:39:34Z"}, "message": "Support attaching attributes to modules via the crate file. Issue #487", "tree": {"sha": "6668f85418ae39c3e53c8a1e844680a6270d4a7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6668f85418ae39c3e53c8a1e844680a6270d4a7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6832f75f0b3c149ff9943851d354e2ee203516c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6832f75f0b3c149ff9943851d354e2ee203516c1", "html_url": "https://github.com/rust-lang/rust/commit/6832f75f0b3c149ff9943851d354e2ee203516c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6832f75f0b3c149ff9943851d354e2ee203516c1/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74f8eb51aee808182b841dc862e14511044b4b20", "url": "https://api.github.com/repos/rust-lang/rust/commits/74f8eb51aee808182b841dc862e14511044b4b20", "html_url": "https://github.com/rust-lang/rust/commit/74f8eb51aee808182b841dc862e14511044b4b20"}], "stats": {"total": 108, "additions": 66, "deletions": 42}, "files": [{"sha": "1f4981c809a80da4740645c3691a1ef223887034", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6832f75f0b3c149ff9943851d354e2ee203516c1/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6832f75f0b3c149ff9943851d354e2ee203516c1/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=6832f75f0b3c149ff9943851d354e2ee203516c1", "patch": "@@ -89,8 +89,9 @@ tag crate_directive_ {\n     // and redirected to the use of const stmt_decls inside\n     // crate directive blocks.\n     cdir_let(ident, @expr, vec[@crate_directive]);\n-    cdir_src_mod(ident, option::t[filename]);\n-    cdir_dir_mod(ident, option::t[filename], vec[@crate_directive]);\n+    cdir_src_mod(ident, option::t[filename], vec[attribute]);\n+    cdir_dir_mod(ident, option::t[filename],\n+                 vec[@crate_directive], vec[attribute]);\n     cdir_view_item(@view_item);\n     cdir_syntax(path);\n     cdir_auth(path, _auth);"}, {"sha": "ce08daf5c5087f07dbfe6ab271db97c37f0a5992", "filename": "src/comp/front/eval.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6832f75f0b3c149ff9943851d354e2ee203516c1/src%2Fcomp%2Ffront%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6832f75f0b3c149ff9943851d354e2ee203516c1/src%2Fcomp%2Ffront%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Feval.rs?ref=6832f75f0b3c149ff9943851d354e2ee203516c1", "patch": "@@ -279,7 +279,7 @@ fn eval_crate_directive(ctx cx, env e, @ast::crate_directive cdir, str prefix,\n         case (ast::cdir_expr(?x)) {\n             eval_crate_directive_expr(cx, e, x, prefix, view_items, items);\n         }\n-        case (ast::cdir_src_mod(?id, ?file_opt)) {\n+        case (ast::cdir_src_mod(?id, ?file_opt, ?attrs)) {\n             auto file_path = id + \".rs\";\n             alt (file_opt) {\n                 case (some(?f)) { file_path = f; }\n@@ -291,23 +291,25 @@ fn eval_crate_directive(ctx cx, env e, @ast::crate_directive cdir, str prefix,\n                 new_parser(cx.sess, e, full_path, cx.chpos,\n                            cx.next_id);\n             auto inner_attrs = parse_inner_attrs_and_next(p0);\n+            auto mod_attrs = attrs + inner_attrs._0;\n             auto first_item_outer_attrs = inner_attrs._1;\n             auto m0 = parse_mod_items(p0, token::EOF, first_item_outer_attrs);\n \n             auto i = front::parser::mk_item(p0, cdir.span.lo, cdir.span.hi,\n-                                            id, ast::item_mod(m0), []);\n+                                            id, ast::item_mod(m0),\n+                                            mod_attrs);\n             // Thread defids and chpos through the parsers\n             cx.chpos = p0.get_chpos();\n             cx.next_id = p0.next_id();\n             vec::push[@ast::item](items, i);\n         }\n-        case (ast::cdir_dir_mod(?id, ?dir_opt, ?cdirs)) {\n+        case (ast::cdir_dir_mod(?id, ?dir_opt, ?cdirs, ?attrs)) {\n             auto path = id;\n             alt (dir_opt) { case (some(?d)) { path = d; } case (none) { } }\n             auto full_path = prefix + std::fs::path_sep() + path;\n             auto m0 = eval_crate_directives_to_mod(cx, e, cdirs, full_path);\n             auto i = @rec(ident=id,\n-                          attrs=[],\n+                          attrs=attrs,\n                           id=cx.next_id,\n                           node=ast::item_mod(m0),\n                           span=cdir.span);"}, {"sha": "5a8781793999319bd3b17cd979577ab888d60868", "filename": "src/comp/front/fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6832f75f0b3c149ff9943851d354e2ee203516c1/src%2Fcomp%2Ffront%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6832f75f0b3c149ff9943851d354e2ee203516c1/src%2Fcomp%2Ffront%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ffold.rs?ref=6832f75f0b3c149ff9943851d354e2ee203516c1", "patch": "@@ -143,12 +143,12 @@ fn noop_fold_crate_directive(&crate_directive_ cd, ast_fold fld)\n             cdir_let(fld.fold_ident(id), fld.fold_expr(e),\n                      map(fld.fold_crate_directive, cds))\n                 }\n-        case(cdir_src_mod(?id,?fname)) { \n-            cdir_src_mod(fld.fold_ident(id), fname)\n+        case(cdir_src_mod(?id,?fname,?attrs)) { \n+            cdir_src_mod(fld.fold_ident(id), fname, attrs)\n                 }\n-        case(cdir_dir_mod(?id,?fname,?cds)) {\n+        case(cdir_dir_mod(?id,?fname,?cds,?attrs)) {\n             cdir_dir_mod(fld.fold_ident(id),fname,\n-                         map(fld.fold_crate_directive, cds))\n+                         map(fld.fold_crate_directive, cds), attrs)\n                 }\n         case(cdir_view_item(?vi)) { \n             cdir_view_item(fld.fold_view_item(vi))"}, {"sha": "60c91d7932e23e6c2fb9129225da0a654aa2b35d", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 44, "deletions": 27, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6832f75f0b3c149ff9943851d354e2ee203516c1/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6832f75f0b3c149ff9943851d354e2ee203516c1/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=6832f75f0b3c149ff9943851d354e2ee203516c1", "patch": "@@ -1488,7 +1488,7 @@ fn parse_stmt(&parser p) -> @ast::stmt {\n }\n \n fn parse_crate_stmt(&parser p) -> @ast::stmt {\n-    auto cdir = parse_crate_directive(p);\n+    auto cdir = parse_crate_directive(p, []);\n     ret @spanned(cdir.span.lo, cdir.span.hi,\n                  ast::stmt_crate_directive(@cdir));\n }\n@@ -2141,15 +2141,6 @@ fn parse_inner_attrs_and_next(&parser p) -> tup(vec[ast::attribute],\n     ret tup(inner_attrs, next_outer_attrs);\n }\n \n-fn parse_inner_attrs(&parser p) -> vec[ast::attribute] {\n-    auto attrs_and_next = parse_inner_attrs_and_next(p);\n-    if (vec::len(attrs_and_next._1) > 0u) {\n-        ret p.fatal(\"expected crate directive but found \" +\n-                  token::to_str(p.get_reader(), p.peek()));\n-    }\n-    ret attrs_and_next._0;\n-}\n-\n fn parse_meta_item(&parser p) -> @ast::meta_item {\n     auto lo = p.get_lo_pos();\n     auto ident = parse_ident(p);\n@@ -2350,16 +2341,18 @@ fn parse_str(&parser p) -> ast::ident {\n // Each crate file is a sequence of directives.\n //\n // Each directive imperatively extends its environment with 0 or more items.\n-fn parse_crate_directive(&parser p) -> ast::crate_directive {\n+fn parse_crate_directive(&parser p, vec[ast::attribute] first_outer_attr)\n+    -> ast::crate_directive {\n+\n+    // Collect the next attributes\n+    auto outer_attrs = first_outer_attr\n+        + parse_outer_attributes(p);\n+    // In a crate file outer attributes are only going to apply to mods\n+    auto expect_mod = vec::len(outer_attrs) > 0u;\n+\n     auto lo = p.get_lo_pos();\n-    if (eat_word(p, \"auth\")) {\n-        auto n = parse_path(p);\n-        expect(p, token::EQ);\n-        auto a = parse_auth(p);\n-        auto hi = p.get_hi_pos();\n-        expect(p, token::SEMI);\n-        ret spanned(lo, hi, ast::cdir_auth(n, a));\n-    } else if (eat_word(p, \"mod\")) {\n+    if (expect_mod || is_word(p, \"mod\")) {\n+        expect_word(p, \"mod\");\n         auto id = parse_ident(p);\n         auto file_opt =\n             alt (p.peek()) {\n@@ -2375,27 +2368,40 @@ fn parse_crate_directive(&parser p) -> ast::crate_directive {\n                  token::SEMI) {\n                 auto hi = p.get_hi_pos();\n                 p.bump();\n-                ret spanned(lo, hi, ast::cdir_src_mod(id, file_opt));\n+                ret spanned(lo, hi, ast::cdir_src_mod(id, file_opt,\n+                                                      outer_attrs));\n             }\n             case (\n                  // mod x = \"foo_dir\" { ...directives... }\n                  token::LBRACE) {\n                 p.bump();\n-                auto cdirs = parse_crate_directives(p, token::RBRACE);\n+                auto inner_attrs = parse_inner_attrs_and_next(p);\n+                auto mod_attrs = outer_attrs + inner_attrs._0;\n+                auto next_outer_attr = inner_attrs._1;\n+                auto cdirs = parse_crate_directives(p, token::RBRACE,\n+                                                    next_outer_attr);\n                 auto hi = p.get_hi_pos();\n                 expect(p, token::RBRACE);\n-                ret spanned(lo, hi, ast::cdir_dir_mod(id, file_opt, cdirs));\n+                ret spanned(lo, hi, ast::cdir_dir_mod(id, file_opt, cdirs,\n+                                                      mod_attrs));\n             }\n             case (?t) { unexpected(p, t); }\n         }\n+    } else if (eat_word(p, \"auth\")) {\n+        auto n = parse_path(p);\n+        expect(p, token::EQ);\n+        auto a = parse_auth(p);\n+        auto hi = p.get_hi_pos();\n+        expect(p, token::SEMI);\n+        ret spanned(lo, hi, ast::cdir_auth(n, a));\n     } else if (eat_word(p, \"let\")) {\n         expect(p, token::LPAREN);\n         auto id = parse_value_ident(p);\n         expect(p, token::EQ);\n         auto x = parse_expr(p);\n         expect(p, token::RPAREN);\n         expect(p, token::LBRACE);\n-        auto v = parse_crate_directives(p, token::RBRACE);\n+        auto v = parse_crate_directives(p, token::RBRACE, []);\n         auto hi = p.get_hi_pos();\n         expect(p, token::RBRACE);\n         ret spanned(lo, hi, ast::cdir_let(id, x, v));\n@@ -2409,11 +2415,20 @@ fn parse_crate_directive(&parser p) -> ast::crate_directive {\n     fail;\n }\n \n-fn parse_crate_directives(&parser p, token::token term) ->\n+fn parse_crate_directives(&parser p, token::token term,\n+                          vec[ast::attribute] first_outer_attr) ->\n    vec[@ast::crate_directive] {\n+\n+    // This is pretty ugly. If we have an outer attribute then we can't accept\n+    // seeing the terminator next, so if we do see it then fail the same way\n+    // parse_crate_directive would\n+    if (vec::len(first_outer_attr) > 0u && p.peek() == term) {\n+        expect_word(p, \"mod\");\n+    }\n+\n     let vec[@ast::crate_directive] cdirs = [];\n     while (p.peek() != term) {\n-        auto cdir = @parse_crate_directive(p);\n+        auto cdir = @parse_crate_directive(p, first_outer_attr);\n         vec::push(cdirs, cdir);\n     }\n     ret cdirs;\n@@ -2422,8 +2437,10 @@ fn parse_crate_directives(&parser p, token::token term) ->\n fn parse_crate_from_crate_file(&parser p) -> @ast::crate {\n     auto lo = p.get_lo_pos();\n     auto prefix = std::fs::dirname(p.get_filemap().name);\n-    auto crate_attrs = parse_inner_attrs(p);\n-    auto cdirs = parse_crate_directives(p, token::EOF);\n+    auto leading_attrs = parse_inner_attrs_and_next(p);\n+    auto crate_attrs = leading_attrs._0;\n+    auto first_cdir_attr = leading_attrs._1;\n+    auto cdirs = parse_crate_directives(p, token::EOF, first_cdir_attr);\n     let vec[str] deps = [];\n     auto cx =\n         @rec(p=p,"}, {"sha": "fccfd05d67b24598817a95e676cf4600a443732e", "filename": "src/comp/middle/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6832f75f0b3c149ff9943851d354e2ee203516c1/src%2Fcomp%2Fmiddle%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6832f75f0b3c149ff9943851d354e2ee203516c1/src%2Fcomp%2Fmiddle%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fvisit.rs?ref=6832f75f0b3c149ff9943851d354e2ee203516c1", "patch": "@@ -66,8 +66,8 @@ fn visit_crate_directive[E](&@crate_directive cd, &E e, &vt[E] v) {\n                 visit_crate_directive(cdir, e, v);\n             }\n         }\n-        case (cdir_src_mod(_, _)) { }\n-        case (cdir_dir_mod(_, _, ?cdirs)) {\n+        case (cdir_src_mod(_, _, _)) { }\n+        case (cdir_dir_mod(_, _, ?cdirs, _)) {\n             for (@crate_directive cdir in cdirs) {\n                 visit_crate_directive(cdir, e, v);\n             }"}, {"sha": "91c5008480e60e27d4d960c4bed56dc740bca657", "filename": "src/comp/middle/walk.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6832f75f0b3c149ff9943851d354e2ee203516c1/src%2Fcomp%2Fmiddle%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6832f75f0b3c149ff9943851d354e2ee203516c1/src%2Fcomp%2Fmiddle%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fwalk.rs?ref=6832f75f0b3c149ff9943851d354e2ee203516c1", "patch": "@@ -59,8 +59,8 @@ fn walk_crate_directive(&ast_visitor v, @ast::crate_directive cd) {\n                 walk_crate_directive(v, cdir);\n             }\n         }\n-        case (ast::cdir_src_mod(_, _)) { }\n-        case (ast::cdir_dir_mod(_, _, ?cdirs)) {\n+        case (ast::cdir_src_mod(_, _, _)) { }\n+        case (ast::cdir_dir_mod(_, _, ?cdirs, _)) {\n             for (@ast::crate_directive cdir in cdirs) {\n                 walk_crate_directive(v, cdir);\n             }"}, {"sha": "3ae634139fac923e73843beac0bc22b9a29f4c76", "filename": "src/test/compile-fail/attr-bad-crate-attr.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6832f75f0b3c149ff9943851d354e2ee203516c1/src%2Ftest%2Fcompile-fail%2Fattr-bad-crate-attr.rc", "raw_url": "https://github.com/rust-lang/rust/raw/6832f75f0b3c149ff9943851d354e2ee203516c1/src%2Ftest%2Fcompile-fail%2Fattr-bad-crate-attr.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-bad-crate-attr.rc?ref=6832f75f0b3c149ff9943851d354e2ee203516c1", "patch": "@@ -1,5 +1,5 @@\n // xfail-stage0\n-// error-pattern: expected crate directive\n+// error-pattern: expecting mod\n \n #[attr = \"val\"];\n #[attr = \"val\"] // Unterminated"}, {"sha": "5c95af16672428845ce0b2c7e127d948ba302963", "filename": "src/test/run-pass/crate-attributes.rc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6832f75f0b3c149ff9943851d354e2ee203516c1/src%2Ftest%2Frun-pass%2Fcrate-attributes.rc", "raw_url": "https://github.com/rust-lang/rust/raw/6832f75f0b3c149ff9943851d354e2ee203516c1/src%2Ftest%2Frun-pass%2Fcrate-attributes.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrate-attributes.rc?ref=6832f75f0b3c149ff9943851d354e2ee203516c1", "patch": "@@ -1,6 +1,10 @@\n #[name = \"crate-attributes\"];\n #[vers = \"1.0\"];\n \n+#[attr1]\n mod m = \"crate-attributes-src\" {\n+  #[attr_inner];\n+\n+  #[attr2]\n   mod foo;\n }"}]}