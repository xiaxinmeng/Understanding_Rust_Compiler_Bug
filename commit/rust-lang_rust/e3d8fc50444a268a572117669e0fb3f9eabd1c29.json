{"sha": "e3d8fc50444a268a572117669e0fb3f9eabd1c29", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzZDhmYzUwNDQ0YTI2OGE1NzIxMTc2NjllMGZiM2Y5ZWFiZDFjMjk=", "commit": {"author": {"name": "Eric Huss", "email": "eric@huss.org", "date": "2018-04-26T22:27:31Z"}, "committer": {"name": "Eric Huss", "email": "eric@huss.org", "date": "2018-05-17T05:25:20Z"}, "message": "compiletest: Run revisions as independent tests.\n\n- The output of each test is now in its own directory.\n- \"auxiliary\" output is now under the respective test directory.\n- `stage_id` removed from filenames, and instead placed in the stamp file as a hash.  This helps keep path lengths down for Windows.\n\nIn brief, the new layout looks like this:\n```\n<build_base>/<relative_dir>/<testname>.<revision>.<mode>/\n    stamp\n    <testname>.err\n    <testname>.out\n    a (binary)\n    auxiliary/lib<auxname>.dylib\n    auxiliary/<auxname>/<auxname>.err\n    auxiliary/<auxname>/<auxname>.out\n```\n(revision and mode are optional)", "tree": {"sha": "a4ecc98604448d591b1aa71e9fa3cc6a31834c82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4ecc98604448d591b1aa71e9fa3cc6a31834c82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3d8fc50444a268a572117669e0fb3f9eabd1c29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3d8fc50444a268a572117669e0fb3f9eabd1c29", "html_url": "https://github.com/rust-lang/rust/commit/e3d8fc50444a268a572117669e0fb3f9eabd1c29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3d8fc50444a268a572117669e0fb3f9eabd1c29/comments", "author": {"login": "ehuss", "id": 43198, "node_id": "MDQ6VXNlcjQzMTk4", "avatar_url": "https://avatars.githubusercontent.com/u/43198?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ehuss", "html_url": "https://github.com/ehuss", "followers_url": "https://api.github.com/users/ehuss/followers", "following_url": "https://api.github.com/users/ehuss/following{/other_user}", "gists_url": "https://api.github.com/users/ehuss/gists{/gist_id}", "starred_url": "https://api.github.com/users/ehuss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ehuss/subscriptions", "organizations_url": "https://api.github.com/users/ehuss/orgs", "repos_url": "https://api.github.com/users/ehuss/repos", "events_url": "https://api.github.com/users/ehuss/events{/privacy}", "received_events_url": "https://api.github.com/users/ehuss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ehuss", "id": 43198, "node_id": "MDQ6VXNlcjQzMTk4", "avatar_url": "https://avatars.githubusercontent.com/u/43198?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ehuss", "html_url": "https://github.com/ehuss", "followers_url": "https://api.github.com/users/ehuss/followers", "following_url": "https://api.github.com/users/ehuss/following{/other_user}", "gists_url": "https://api.github.com/users/ehuss/gists{/gist_id}", "starred_url": "https://api.github.com/users/ehuss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ehuss/subscriptions", "organizations_url": "https://api.github.com/users/ehuss/orgs", "repos_url": "https://api.github.com/users/ehuss/repos", "events_url": "https://api.github.com/users/ehuss/events{/privacy}", "received_events_url": "https://api.github.com/users/ehuss/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24384340548e9af2ce85f9dd91858cac30166fee", "url": "https://api.github.com/repos/rust-lang/rust/commits/24384340548e9af2ce85f9dd91858cac30166fee", "html_url": "https://github.com/rust-lang/rust/commit/24384340548e9af2ce85f9dd91858cac30166fee"}], "stats": {"total": 402, "additions": 234, "deletions": 168}, "files": [{"sha": "86f555620eeb9f033b8d88c0b90341038b68c6af", "filename": "src/test/ui-fulldeps/update-references.sh", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e3d8fc50444a268a572117669e0fb3f9eabd1c29/src%2Ftest%2Fui-fulldeps%2Fupdate-references.sh", "raw_url": "https://github.com/rust-lang/rust/raw/e3d8fc50444a268a572117669e0fb3f9eabd1c29/src%2Ftest%2Fui-fulldeps%2Fupdate-references.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fupdate-references.sh?ref=e3d8fc50444a268a572117669e0fb3f9eabd1c29", "patch": "@@ -31,18 +31,17 @@ MYDIR=$(dirname $0)\n BUILD_DIR=\"$1\"\n shift\n \n+shopt -s nullglob\n+\n while [[ \"$1\" != \"\" ]]; do\n-    STDERR_NAME=\"${1/%.rs/.stderr}\"\n-    STDOUT_NAME=\"${1/%.rs/.stdout}\"\n+    for EXT in \"stderr\" \"stdout\"; do\n+        for OUT_NAME in $BUILD_DIR/${1%.rs}*/*$EXT; do\n+            OUT_BASE=`basename \"$OUT_NAME\"`\n+            if ! (diff $OUT_NAME $MYDIR/$OUT_BASE >& /dev/null); then\n+                echo updating $MYDIR/$OUT_BASE\n+                cp $OUT_NAME $MYDIR\n+            fi\n+        done\n+    done\n     shift\n-    if [ -f $BUILD_DIR/$STDOUT_NAME ] && \\\n-           ! (diff $BUILD_DIR/$STDOUT_NAME $MYDIR/$STDOUT_NAME >& /dev/null); then\n-        echo updating $MYDIR/$STDOUT_NAME\n-        cp $BUILD_DIR/$STDOUT_NAME $MYDIR/$STDOUT_NAME\n-    fi\n-    if [ -f $BUILD_DIR/$STDERR_NAME ] && \\\n-           ! (diff $BUILD_DIR/$STDERR_NAME $MYDIR/$STDERR_NAME >& /dev/null); then\n-        echo updating $MYDIR/$STDERR_NAME\n-        cp $BUILD_DIR/$STDERR_NAME $MYDIR/$STDERR_NAME\n-    fi\n done"}, {"sha": "f3c5997fc3f5309dfb4cffc753b3f2cdee73f6fd", "filename": "src/test/ui/update-references.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3d8fc50444a268a572117669e0fb3f9eabd1c29/src%2Ftest%2Fui%2Fupdate-references.sh", "raw_url": "https://github.com/rust-lang/rust/raw/e3d8fc50444a268a572117669e0fb3f9eabd1c29/src%2Ftest%2Fui%2Fupdate-references.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fupdate-references.sh?ref=e3d8fc50444a268a572117669e0fb3f9eabd1c29", "patch": "@@ -35,7 +35,7 @@ shopt -s nullglob\n \n while [[ \"$1\" != \"\" ]]; do\n     for EXT in \"stderr\" \"stdout\" \"fixed\"; do\n-        for OUT_NAME in $BUILD_DIR/${1%.rs}.*$EXT; do\n+        for OUT_NAME in $BUILD_DIR/${1%.rs}*/*$EXT; do\n             OUT_DIR=`dirname \"$1\"`\n             OUT_BASE=`basename \"$OUT_NAME\"`\n             if ! (diff $OUT_NAME $MYDIR/$OUT_DIR/$OUT_BASE >& /dev/null); then"}, {"sha": "812e9c5f39d87f9142eae517dd46ee893c21888c", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e3d8fc50444a268a572117669e0fb3f9eabd1c29/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3d8fc50444a268a572117669e0fb3f9eabd1c29/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=e3d8fc50444a268a572117669e0fb3f9eabd1c29", "patch": "@@ -10,10 +10,11 @@\n pub use self::Mode::*;\n \n use std::fmt;\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n use std::str::FromStr;\n \n use test::ColorConfig;\n+use util::PathBufExt;\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n pub enum Mode {\n@@ -245,10 +246,9 @@ pub struct Config {\n     pub nodejs: Option<String>,\n }\n \n-#[derive(Clone)]\n+#[derive(Debug, Clone)]\n pub struct TestPaths {\n     pub file: PathBuf,         // e.g., compile-test/foo/bar/baz.rs\n-    pub base: PathBuf,         // e.g., compile-test, auxiliary\n     pub relative_dir: PathBuf, // e.g., foo/bar\n }\n \n@@ -278,3 +278,38 @@ pub const UI_EXTENSIONS: &[&str] = &[UI_STDERR, UI_STDOUT, UI_FIXED];\n pub const UI_STDERR: &str = \"stderr\";\n pub const UI_STDOUT: &str = \"stdout\";\n pub const UI_FIXED: &str = \"fixed\";\n+\n+/// Absolute path to the directory where all output for all tests in the given\n+/// `relative_dir` group should reside. Example:\n+///   /path/to/build/host-triple/test/ui/relative/\n+/// This is created early when tests are collected to avoid race conditions.\n+pub fn output_relative_path(config: &Config, relative_dir: &Path) -> PathBuf {\n+    config.build_base.join(relative_dir)\n+}\n+\n+/// Generates a unique name for the test, such as `testname.revision.mode`.\n+pub fn output_testname_unique(\n+    config: &Config,\n+    testpaths: &TestPaths,\n+    revision: Option<&str>,\n+) -> PathBuf {\n+    let mode = config.compare_mode.as_ref().map_or(\"\", |m| m.to_str());\n+    PathBuf::from(&testpaths.file.file_stem().unwrap())\n+        .with_extra_extension(revision.unwrap_or(\"\"))\n+        .with_extra_extension(mode)\n+}\n+\n+/// Absolute path to the directory where all output for the given\n+/// test/revision should reside.  Example:\n+///   /path/to/build/host-triple/test/ui/relative/testname.revision.mode/\n+pub fn output_base_dir(config: &Config, testpaths: &TestPaths, revision: Option<&str>) -> PathBuf {\n+    output_relative_path(config, &testpaths.relative_dir)\n+        .join(output_testname_unique(config, testpaths, revision))\n+}\n+\n+/// Absolute path to the base filename used as output for the given\n+/// test/revision.  Example:\n+///   /path/to/build/host-triple/test/ui/relative/testname.revision.mode/testname\n+pub fn output_base_name(config: &Config, testpaths: &TestPaths, revision: Option<&str>) -> PathBuf {\n+    output_base_dir(config, testpaths, revision).join(testpaths.file.file_stem().unwrap())\n+}"}, {"sha": "42a2cdfa55b5ad9ee78a913d1195402ecd54b7be", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 81, "deletions": 65, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/e3d8fc50444a268a572117669e0fb3f9eabd1c29/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3d8fc50444a268a572117669e0fb3f9eabd1c29/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=e3d8fc50444a268a572117669e0fb3f9eabd1c29", "patch": "@@ -32,15 +32,15 @@ extern crate test;\n extern crate rustfix;\n \n use common::CompareMode;\n-use common::{expected_output_path, UI_EXTENSIONS};\n+use common::{expected_output_path, output_base_dir, output_relative_path, UI_EXTENSIONS};\n use common::{Config, TestPaths};\n use common::{DebugInfoGdb, DebugInfoLldb, Mode, Pretty};\n use filetime::FileTime;\n use getopts::Options;\n use std::env;\n use std::ffi::OsString;\n use std::fs;\n-use std::io;\n+use std::io::{self, Read};\n use std::path::{Path, PathBuf};\n use std::process::Command;\n use test::ColorConfig;\n@@ -552,10 +552,9 @@ fn collect_tests_from_dir(\n         if name == *\"Makefile\" && config.mode == Mode::RunMake {\n             let paths = TestPaths {\n                 file: dir.to_path_buf(),\n-                base: base.to_path_buf(),\n                 relative_dir: relative_dir_path.parent().unwrap().to_path_buf(),\n             };\n-            tests.push(make_test(config, &paths));\n+            tests.extend(make_test(config, &paths));\n             return Ok(());\n         }\n     }\n@@ -566,7 +565,7 @@ fn collect_tests_from_dir(\n     // sequential loop because otherwise, if we do it in the\n     // tests themselves, they race for the privilege of\n     // creating the directories and sometimes fail randomly.\n-    let build_dir = config.build_base.join(&relative_dir_path);\n+    let build_dir = output_relative_path(config, relative_dir_path);\n     fs::create_dir_all(&build_dir).unwrap();\n \n     // Add each `.rs` file as a test, and recurse further on any\n@@ -580,21 +579,12 @@ fn collect_tests_from_dir(\n             debug!(\"found test file: {:?}\", file_path.display());\n             let paths = TestPaths {\n                 file: file_path,\n-                base: base.to_path_buf(),\n                 relative_dir: relative_dir_path.to_path_buf(),\n             };\n-            tests.push(make_test(config, &paths))\n+            tests.extend(make_test(config, &paths))\n         } else if file_path.is_dir() {\n             let relative_file_path = relative_dir_path.join(file.file_name());\n-            if &file_name == \"auxiliary\" {\n-                // `aux` directories contain other crates used for\n-                // cross-crate tests. Don't search them for tests, but\n-                // do create a directory in the build dir for them,\n-                // since we will dump intermediate output in there\n-                // sometimes.\n-                let build_dir = config.build_base.join(&relative_file_path);\n-                fs::create_dir_all(&build_dir).unwrap();\n-            } else {\n+            if &file_name != \"auxiliary\" {\n                 debug!(\"found directory: {:?}\", file_path.display());\n                 collect_tests_from_dir(config, base, &file_path, &relative_file_path, tests)?;\n             }\n@@ -617,7 +607,7 @@ pub fn is_test(file_name: &OsString) -> bool {\n     !invalid_prefixes.iter().any(|p| file_name.starts_with(p))\n }\n \n-pub fn make_test(config: &Config, testpaths: &TestPaths) -> test::TestDescAndFn {\n+pub fn make_test(config: &Config, testpaths: &TestPaths) -> Vec<test::TestDescAndFn> {\n     let early_props = if config.mode == Mode::RunMake {\n         // Allow `ignore` directives to be in the Makefile.\n         EarlyProps::from_file(config, &testpaths.file.join(\"Makefile\"))\n@@ -637,46 +627,68 @@ pub fn make_test(config: &Config, testpaths: &TestPaths) -> test::TestDescAndFn\n         },\n     };\n \n-    // Debugging emscripten code doesn't make sense today\n-    let ignore = early_props.ignore || !up_to_date(config, testpaths, &early_props)\n-        || (config.mode == DebugInfoGdb || config.mode == DebugInfoLldb)\n-            && config.target.contains(\"emscripten\");\n-\n-    test::TestDescAndFn {\n-        desc: test::TestDesc {\n-            name: make_test_name(config, testpaths),\n-            ignore,\n-            should_panic,\n-            allow_fail: false,\n-        },\n-        testfn: make_test_closure(config, testpaths),\n-    }\n+    // Incremental tests are special, they inherently cannot be run in parallel.\n+    // `runtest::run` will be responsible for iterating over revisions.\n+    let revisions = if early_props.revisions.is_empty() || config.mode == Mode::Incremental {\n+        vec![None]\n+    } else {\n+        early_props.revisions.iter().map(|r| Some(r)).collect()\n+    };\n+    revisions\n+        .into_iter()\n+        .map(|revision| {\n+            // Debugging emscripten code doesn't make sense today\n+            let ignore = early_props.ignore\n+                || !up_to_date(\n+                    config,\n+                    testpaths,\n+                    &early_props,\n+                    revision.map(|s| s.as_str()),\n+                )\n+                || (config.mode == DebugInfoGdb || config.mode == DebugInfoLldb)\n+                    && config.target.contains(\"emscripten\");\n+            test::TestDescAndFn {\n+                desc: test::TestDesc {\n+                    name: make_test_name(config, testpaths, revision),\n+                    ignore,\n+                    should_panic,\n+                    allow_fail: false,\n+                },\n+                testfn: make_test_closure(config, testpaths, revision),\n+            }\n+        })\n+        .collect()\n }\n \n-fn stamp(config: &Config, testpaths: &TestPaths) -> PathBuf {\n-    let mode_suffix = match config.compare_mode {\n-        Some(ref mode) => format!(\"-{}\", mode.to_str()),\n-        None => format!(\"\"),\n-    };\n-    let stamp_name = format!(\n-        \"{}-{}{}.stamp\",\n-        testpaths.file.file_name().unwrap().to_str().unwrap(),\n-        config.stage_id,\n-        mode_suffix\n-    );\n-    config\n-        .build_base\n-        .canonicalize()\n-        .unwrap_or_else(|_| config.build_base.clone())\n-        .join(&testpaths.relative_dir)\n-        .join(stamp_name)\n+fn stamp(config: &Config, testpaths: &TestPaths, revision: Option<&str>) -> PathBuf {\n+    output_base_dir(config, testpaths, revision).join(\"stamp\")\n }\n \n-fn up_to_date(config: &Config, testpaths: &TestPaths, props: &EarlyProps) -> bool {\n+fn up_to_date(\n+    config: &Config,\n+    testpaths: &TestPaths,\n+    props: &EarlyProps,\n+    revision: Option<&str>,\n+) -> bool {\n+    let stamp_name = stamp(config, testpaths, revision);\n+    // Check hash.\n+    let mut f = match fs::File::open(&stamp_name) {\n+        Ok(f) => f,\n+        Err(_) => return true,\n+    };\n+    let mut contents = String::new();\n+    f.read_to_string(&mut contents)\n+        .expect(\"Can't read stamp contents\");\n+    let expected_hash = runtest::compute_stamp_hash(config);\n+    if contents != expected_hash {\n+        return true;\n+    }\n+\n+    // Check timestamps.\n     let rust_src_dir = config\n         .find_rust_src_root()\n         .expect(\"Could not find Rust source root\");\n-    let stamp = mtime(&stamp(config, testpaths));\n+    let stamp = mtime(&stamp_name);\n     let mut inputs = vec![mtime(&testpaths.file), mtime(&config.rustc_path)];\n     for aux in props.aux.iter() {\n         inputs.push(mtime(&testpaths\n@@ -714,16 +726,8 @@ fn up_to_date(config: &Config, testpaths: &TestPaths, props: &EarlyProps) -> boo\n \n     // UI test files.\n     for extension in UI_EXTENSIONS {\n-        for revision in &props.revisions {\n-            let path =\n-                &expected_output_path(testpaths, Some(revision), &config.compare_mode, extension);\n-            inputs.push(mtime(path));\n-        }\n-\n-        if props.revisions.is_empty() {\n-            let path = &expected_output_path(testpaths, None, &config.compare_mode, extension);\n-            inputs.push(mtime(path));\n-        }\n+        let path = &expected_output_path(testpaths, revision, &config.compare_mode, extension);\n+        inputs.push(mtime(path));\n     }\n \n     inputs.iter().any(|input| *input > stamp)\n@@ -735,7 +739,11 @@ fn mtime(path: &Path) -> FileTime {\n         .unwrap_or_else(|_| FileTime::zero())\n }\n \n-pub fn make_test_name(config: &Config, testpaths: &TestPaths) -> test::TestName {\n+fn make_test_name(\n+    config: &Config,\n+    testpaths: &TestPaths,\n+    revision: Option<&String>,\n+) -> test::TestName {\n     // Convert a complete path to something like\n     //\n     //    run-pass/foo/bar/baz.rs\n@@ -747,17 +755,25 @@ pub fn make_test_name(config: &Config, testpaths: &TestPaths) -> test::TestName\n         None => format!(\"\"),\n     };\n     test::DynTestName(format!(\n-        \"[{}{}] {}\",\n+        \"[{}{}] {}{}\",\n         config.mode,\n         mode_suffix,\n-        path.display()\n+        path.display(),\n+        revision.map_or(\"\".to_string(), |rev| format!(\"#{}\", rev))\n     ))\n }\n \n-pub fn make_test_closure(config: &Config, testpaths: &TestPaths) -> test::TestFn {\n+fn make_test_closure(\n+    config: &Config,\n+    testpaths: &TestPaths,\n+    revision: Option<&String>,\n+) -> test::TestFn {\n     let config = config.clone();\n     let testpaths = testpaths.clone();\n-    test::DynTestFn(Box::new(move || runtest::run(config, &testpaths)))\n+    let revision = revision.cloned();\n+    test::DynTestFn(Box::new(move || {\n+        runtest::run(config, &testpaths, revision.as_ref().map(|s| s.as_str()))\n+    }))\n }\n \n /// Returns (Path to GDB, GDB Version, GDB has Rust Support)"}, {"sha": "2a76113460fc72351d98e16dfda513841e139d05", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 80, "deletions": 86, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/e3d8fc50444a268a572117669e0fb3f9eabd1c29/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3d8fc50444a268a572117669e0fb3f9eabd1c29/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=e3d8fc50444a268a572117669e0fb3f9eabd1c29", "patch": "@@ -10,6 +10,7 @@\n \n use common::CompareMode;\n use common::{expected_output_path, UI_STDERR, UI_STDOUT, UI_FIXED};\n+use common::{output_base_dir, output_base_name, output_testname_unique};\n use common::{Codegen, CodegenUnits, DebugInfoGdb, DebugInfoLldb, Rustdoc};\n use common::{CompileFail, ParseFail, Pretty, RunFail, RunPass, RunPassValgrind};\n use common::{Config, TestPaths};\n@@ -21,15 +22,15 @@ use header::TestProps;\n use json;\n use regex::Regex;\n use rustfix::{apply_suggestions, get_suggestions_from_json};\n-use util::logv;\n+use util::{logv, PathBufExt};\n \n-use std::collections::HashMap;\n-use std::collections::HashSet;\n-use std::collections::VecDeque;\n+use std::collections::{HashMap, HashSet, VecDeque};\n+use std::collections::hash_map::DefaultHasher;\n use std::env;\n-use std::ffi::{OsStr, OsString};\n+use std::ffi::OsString;\n use std::fmt;\n use std::fs::{self, create_dir_all, File};\n+use std::hash::{Hash, Hasher};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n use std::path::{Path, PathBuf};\n@@ -106,26 +107,6 @@ impl Mismatch {\n     }\n }\n \n-trait PathBufExt {\n-    /// Append an extension to the path, even if it already has one.\n-    fn with_extra_extension<S: AsRef<OsStr>>(&self, extension: S) -> PathBuf;\n-}\n-\n-impl PathBufExt for PathBuf {\n-    fn with_extra_extension<S: AsRef<OsStr>>(&self, extension: S) -> PathBuf {\n-        if extension.as_ref().len() == 0 {\n-            self.clone()\n-        } else {\n-            let mut fname = self.file_name().unwrap().to_os_string();\n-            if !extension.as_ref().to_str().unwrap().starts_with(\".\") {\n-                fname.push(\".\");\n-            }\n-            fname.push(extension);\n-            self.with_file_name(fname)\n-        }\n-    }\n-}\n-\n // Produces a diff between the expected output and actual output.\n pub fn make_diff(expected: &str, actual: &str, context_size: usize) -> Vec<Mismatch> {\n     let mut line_number = 1;\n@@ -186,7 +167,7 @@ pub fn make_diff(expected: &str, actual: &str, context_size: usize) -> Vec<Misma\n     results\n }\n \n-pub fn run(config: Config, testpaths: &TestPaths) {\n+pub fn run(config: Config, testpaths: &TestPaths, revision: Option<&str>) {\n     match &*config.target {\n         \"arm-linux-androideabi\" | \"armv7-linux-androideabi\" | \"aarch64-linux-android\" => {\n             if !config.adb_device_status {\n@@ -207,20 +188,25 @@ pub fn run(config: Config, testpaths: &TestPaths) {\n         print!(\"\\n\\n\");\n     }\n     debug!(\"running {:?}\", testpaths.file.display());\n-    let base_props = TestProps::from_file(&testpaths.file, None, &config);\n+    let props = TestProps::from_file(&testpaths.file, revision, &config);\n \n-    let base_cx = TestCx {\n+    let cx = TestCx {\n         config: &config,\n-        props: &base_props,\n+        props: &props,\n         testpaths,\n-        revision: None,\n+        revision: revision,\n     };\n-    base_cx.init_all();\n+    create_dir_all(&cx.output_base_dir()).unwrap();\n \n-    if base_props.revisions.is_empty() {\n-        base_cx.run_revision()\n-    } else {\n-        for revision in &base_props.revisions {\n+    if config.mode == Incremental {\n+        // Incremental tests are special because they cannot be run in\n+        // parallel.\n+        assert!(\n+            !props.revisions.is_empty(),\n+            \"Incremental tests require revisions.\"\n+        );\n+        cx.init_incremental_test();\n+        for revision in &props.revisions {\n             let revision_props = TestProps::from_file(&testpaths.file, Some(revision), &config);\n             let rev_cx = TestCx {\n                 config: &config,\n@@ -230,11 +216,17 @@ pub fn run(config: Config, testpaths: &TestPaths) {\n             };\n             rev_cx.run_revision();\n         }\n+    } else {\n+        cx.run_revision();\n     }\n \n-    base_cx.complete_all();\n+    cx.create_stamp();\n+}\n \n-    File::create(::stamp(&config, testpaths)).unwrap();\n+pub fn compute_stamp_hash(config: &Config) -> String {\n+    let mut hash = DefaultHasher::new();\n+    config.stage_id.hash(&mut hash);\n+    format!(\"{:x}\", hash.finish())\n }\n \n struct TestCx<'test> {\n@@ -251,14 +243,6 @@ struct DebuggerCommands {\n }\n \n impl<'test> TestCx<'test> {\n-    /// invoked once before any revisions have been processed\n-    fn init_all(&self) {\n-        assert!(self.revision.is_none(), \"init_all invoked for a revision\");\n-        if let Incremental = self.config.mode {\n-            self.init_incremental_test()\n-        }\n-    }\n-\n     /// Code executed for each revision in turn (or, if there are no\n     /// revisions, exactly once, with revision == None).\n     fn run_revision(&self) {\n@@ -280,11 +264,6 @@ impl<'test> TestCx<'test> {\n         }\n     }\n \n-    /// Invoked after all revisions have executed.\n-    fn complete_all(&self) {\n-        assert!(self.revision.is_none(), \"init_all invoked for a revision\");\n-    }\n-\n     fn check_if_test_should_compile(&self, proc_res: &ProcRes) {\n         if self.props.compile_pass {\n             if !proc_res.status.success() {\n@@ -1361,6 +1340,8 @@ impl<'test> TestCx<'test> {\n                     testpaths: &aux_testpaths,\n                     revision: self.revision,\n                 };\n+                // Create the directory for the stdout/stderr files.\n+                create_dir_all(aux_cx.output_base_dir()).unwrap();\n                 let auxres = aux_cx.document(out_dir);\n                 if !auxres.status.success() {\n                     return auxres;\n@@ -1445,7 +1426,7 @@ impl<'test> TestCx<'test> {\n                 let mut program = Command::new(&prog);\n                 program\n                     .args(args)\n-                    .current_dir(&self.output_base_name().parent().unwrap())\n+                    .current_dir(&self.output_base_dir())\n                     .envs(env.clone());\n                 self.compose_and_run(\n                     program,\n@@ -1483,9 +1464,9 @@ impl<'test> TestCx<'test> {\n \n         TestPaths {\n             file: test_ab,\n-            base: self.testpaths.base.clone(),\n             relative_dir: self.testpaths\n                 .relative_dir\n+                .join(self.output_testname_unique())\n                 .join(\"auxiliary\")\n                 .join(rel_ab)\n                 .parent()\n@@ -1506,17 +1487,15 @@ impl<'test> TestCx<'test> {\n             let aux_props =\n                 self.props\n                     .from_aux_file(&aux_testpaths.file, self.revision, self.config);\n-            let aux_output = {\n-                let f = self.make_lib_name(&self.testpaths.file);\n-                let parent = f.parent().unwrap();\n-                TargetLocation::ThisDirectory(parent.to_path_buf())\n-            };\n+            let aux_output = TargetLocation::ThisDirectory(self.aux_output_dir_name());\n             let aux_cx = TestCx {\n                 config: self.config,\n                 props: &aux_props,\n                 testpaths: &aux_testpaths,\n                 revision: self.revision,\n             };\n+            // Create the directory for the stdout/stderr files.\n+            create_dir_all(aux_cx.output_base_dir()).unwrap();\n             let mut aux_rustc = aux_cx.make_compile_args(&aux_testpaths.file, aux_output);\n \n             let crate_type = if aux_props.no_prefer_dynamic {\n@@ -1642,7 +1621,8 @@ impl<'test> TestCx<'test> {\n                 .clone()\n                 .expect(\"no rustdoc built yet\"))\n         };\n-        rustc.arg(input_file).arg(\"-L\").arg(&self.config.build_base);\n+        // FIXME Why is -L here?\n+        rustc.arg(input_file);//.arg(\"-L\").arg(&self.config.build_base);\n \n         // Optionally prevent default --target if specified in test compile-flags.\n         let custom_target = self.props\n@@ -1767,15 +1747,12 @@ impl<'test> TestCx<'test> {\n         rustc\n     }\n \n-    fn make_lib_name(&self, auxfile: &Path) -> PathBuf {\n-        // what we return here is not particularly important, as it\n-        // happens; rustc ignores everything except for the directory.\n-        let auxname = self.output_testname(auxfile);\n-        self.aux_output_dir_name().join(&auxname)\n-    }\n-\n     fn make_exe_name(&self) -> PathBuf {\n-        let mut f = self.output_base_name_stage();\n+        // Using a single letter here to keep the path length down for\n+        // Windows.  Some test names get very long.  rustc creates `rcgu`\n+        // files with the module name appended to it which can more than\n+        // double the length.\n+        let mut f = self.output_base_dir().join(\"a\");\n         // FIXME: This is using the host architecture exe suffix, not target!\n         if self.config.target.contains(\"emscripten\") {\n             f = f.with_extra_extension(\"js\");\n@@ -1885,34 +1862,47 @@ impl<'test> TestCx<'test> {\n             .unwrap();\n     }\n \n+    /// Create a filename for output with the given extension.  Example:\n+    ///   /.../testname.revision.mode/testname.extension\n     fn make_out_name(&self, extension: &str) -> PathBuf {\n         self.output_base_name().with_extension(extension)\n     }\n \n+    /// Directory where auxiliary files are written.  Example:\n+    ///   /.../testname.revision.mode/auxiliary/\n     fn aux_output_dir_name(&self) -> PathBuf {\n-        self.output_base_name_stage()\n+        self.output_base_dir()\n+            .join(\"auxiliary\")\n             .with_extra_extension(self.config.mode.disambiguator())\n-            .with_extra_extension(\".aux\")\n     }\n \n-    fn output_testname(&self, filepath: &Path) -> PathBuf {\n-        PathBuf::from(filepath.file_stem().unwrap())\n+    /// Generates a unique name for the test, such as `testname.revision.mode`.\n+    fn output_testname_unique(&self) -> PathBuf {\n+        output_testname_unique(self.config, self.testpaths, self.safe_revision())\n     }\n \n-    /// Given a test path like `compile-fail/foo/bar.rs` returns a name like\n-    /// `/path/to/build/<triple>/test/compile-fail/foo/bar`.\n-    fn output_base_name(&self) -> PathBuf {\n-        let dir = self.config.build_base.join(&self.testpaths.relative_dir);\n+    /// The revision, ignored for Incremental since it wants all revisions in\n+    /// the same directory.\n+    fn safe_revision(&self) -> Option<&str> {\n+        if self.config.mode == Incremental {\n+            None\n+        } else {\n+            self.revision\n+        }\n+    }\n \n-        // Note: The directory `dir` is created during `collect_tests_from_dir`\n-        dir.join(&self.output_testname(&self.testpaths.file))\n+    /// Absolute path to the directory where all output for the given\n+    /// test/revision should reside.  Example:\n+    ///   /path/to/build/host-triple/test/ui/relative/testname.revision.mode/\n+    fn output_base_dir(&self) -> PathBuf {\n+        output_base_dir(self.config, self.testpaths, self.safe_revision())\n     }\n \n-    /// Same as `output_base_name`, but includes the stage ID as an extension,\n-    /// such as: `.../compile-fail/foo/bar.stage1-<triple>`\n-    fn output_base_name_stage(&self) -> PathBuf {\n-        self.output_base_name()\n-            .with_extension(&self.config.stage_id)\n+    /// Absolute path to the base filename used as output for the given\n+    /// test/revision.  Example:\n+    ///   /.../relative/testname.revision.mode/testname\n+    fn output_base_name(&self) -> PathBuf {\n+        output_base_name(self.config, self.testpaths, self.safe_revision())\n     }\n \n     fn maybe_dump_to_stdout(&self, out: &str, err: &str) {\n@@ -1987,8 +1977,7 @@ impl<'test> TestCx<'test> {\n     fn compile_test_and_save_ir(&self) -> ProcRes {\n         let aux_dir = self.aux_output_dir_name();\n \n-        let output_file =\n-            TargetLocation::ThisDirectory(self.output_base_name().parent().unwrap().to_path_buf());\n+        let output_file = TargetLocation::ThisDirectory(self.output_base_dir());\n         let mut rustc = self.make_compile_args(&self.testpaths.file, output_file);\n         rustc.arg(\"-L\").arg(aux_dir).arg(\"--emit=llvm-ir\");\n \n@@ -2037,7 +2026,7 @@ impl<'test> TestCx<'test> {\n     fn run_rustdoc_test(&self) {\n         assert!(self.revision.is_none(), \"revisions not relevant here\");\n \n-        let out_dir = self.output_base_name_stage();\n+        let out_dir = self.output_base_dir();\n         let _ = fs::remove_dir_all(&out_dir);\n         create_dir_all(&out_dir).unwrap();\n \n@@ -2365,7 +2354,7 @@ impl<'test> TestCx<'test> {\n     fn run_incremental_test(&self) {\n         // Basic plan for a test incremental/foo/bar.rs:\n         // - load list of revisions rpass1, cfail2, rpass3\n-        //   - each should begin with `rpass`, `cfail`, or `cfail`\n+        //   - each should begin with `rpass`, `cfail`, or `rfail`\n         //   - if `rpass`, expect compile and execution to succeed\n         //   - if `cfail`, expect compilation to fail\n         //   - if `rfail`, expect execution to fail\n@@ -2438,7 +2427,7 @@ impl<'test> TestCx<'test> {\n             .unwrap();\n         let src_root = cwd.join(&src_root);\n \n-        let tmpdir = cwd.join(self.output_base_name_stage());\n+        let tmpdir = cwd.join(self.output_base_name());\n         if tmpdir.exists() {\n             self.aggressive_rm_rf(&tmpdir).unwrap();\n         }\n@@ -2982,6 +2971,11 @@ impl<'test> TestCx<'test> {\n         println!(\"Actual {} saved to {}\", kind, output_file.display());\n         1\n     }\n+\n+    fn create_stamp(&self) {\n+        let mut f = File::create(::stamp(&self.config, self.testpaths, self.revision)).unwrap();\n+        f.write_all(compute_stamp_hash(&self.config).as_bytes()).unwrap();\n+    }\n }\n \n struct ProcArgs {"}, {"sha": "91e7399f1f492288cc5184d006fc850074b6abc6", "filename": "src/tools/compiletest/src/util.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e3d8fc50444a268a572117669e0fb3f9eabd1c29/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3d8fc50444a268a572117669e0fb3f9eabd1c29/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs?ref=e3d8fc50444a268a572117669e0fb3f9eabd1c29", "patch": "@@ -8,8 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use common::Config;\n+use std::ffi::OsStr;\n use std::env;\n+use std::path::PathBuf;\n+use common::Config;\n \n /// Conversion table from triple OS name to Rust SYSNAME\n const OS_TABLE: &'static [(&'static str, &'static str)] = &[\n@@ -128,3 +130,23 @@ pub fn logv(config: &Config, s: String) {\n         println!(\"{}\", s);\n     }\n }\n+\n+pub trait PathBufExt {\n+    /// Append an extension to the path, even if it already has one.\n+    fn with_extra_extension<S: AsRef<OsStr>>(&self, extension: S) -> PathBuf;\n+}\n+\n+impl PathBufExt for PathBuf {\n+    fn with_extra_extension<S: AsRef<OsStr>>(&self, extension: S) -> PathBuf {\n+        if extension.as_ref().len() == 0 {\n+            self.clone()\n+        } else {\n+            let mut fname = self.file_name().unwrap().to_os_string();\n+            if !extension.as_ref().to_str().unwrap().starts_with(\".\") {\n+                fname.push(\".\");\n+            }\n+            fname.push(extension);\n+            self.with_file_name(fname)\n+        }\n+    }\n+}"}]}