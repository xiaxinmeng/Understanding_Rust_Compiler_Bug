{"sha": "8e65a46268d681a6359400ebdc81b5fe204bb93b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlNjVhNDYyNjhkNjgxYTYzNTk0MDBlYmRjODFiNWZlMjA0YmI5M2I=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2018-07-22T20:10:10Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2018-07-31T23:55:12Z"}, "message": "Cleanup highlighting code\n\nRemoves some unused code and de-publicizes structs", "tree": {"sha": "d3cfcb99a4f87053a6580312cbc391684f8cb227", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3cfcb99a4f87053a6580312cbc391684f8cb227"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e65a46268d681a6359400ebdc81b5fe204bb93b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e65a46268d681a6359400ebdc81b5fe204bb93b", "html_url": "https://github.com/rust-lang/rust/commit/8e65a46268d681a6359400ebdc81b5fe204bb93b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e65a46268d681a6359400ebdc81b5fe204bb93b/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bea518d3a792d9c8df508b0af83ceb857ce75b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bea518d3a792d9c8df508b0af83ceb857ce75b7", "html_url": "https://github.com/rust-lang/rust/commit/7bea518d3a792d9c8df508b0af83ceb857ce75b7"}], "stats": {"total": 65, "additions": 23, "deletions": 42}, "files": [{"sha": "8a7aa3c13a95155d5f12dfea79d3e901326c2668", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 22, "deletions": 38, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8e65a46268d681a6359400ebdc81b5fe204bb93b/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e65a46268d681a6359400ebdc81b5fe204bb93b/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=8e65a46268d681a6359400ebdc81b5fe204bb93b", "patch": "@@ -13,12 +13,7 @@\n //! This module uses libsyntax's lexer to provide token-based highlighting for\n //! the HTML documentation generated by rustdoc.\n //!\n-//! If you just want to syntax highlighting for a Rust program, then you can use\n-//! the `render_inner_with_highlighting` or `render_with_highlighting`\n-//! functions. For more advanced use cases (if you want to supply your own css\n-//! classes or control how the HTML is generated, or even generate something\n-//! other then HTML), then you should implement the `Writer` trait and use a\n-//! `Classifier`.\n+//! Use the `render_with_highlighting` to highlight some rust code.\n \n use html::escape::Escape;\n \n@@ -33,7 +28,7 @@ use syntax::parse;\n use syntax_pos::{Span, FileName};\n \n /// Highlights `src`, returning the HTML output.\n-pub fn render_with_highlighting(src: &str, class: Option<&str>, id: Option<&str>,\n+pub fn render_with_highlighting(src: &str, class: Option<&str>,\n                                 extension: Option<&str>,\n                                 tooltip: Option<(&str, &str)>) -> String {\n     debug!(\"highlighting: ================\\n{}\\n==============\", src);\n@@ -46,7 +41,7 @@ pub fn render_with_highlighting(src: &str, class: Option<&str>, id: Option<&str>\n                      class='tooltiptext'>{}</span></div></div>\",\n                class, tooltip).unwrap();\n     }\n-    write_header(class, id, &mut out).unwrap();\n+    write_header(class, &mut out).unwrap();\n \n     let mut classifier = Classifier::new(lexer::StringReader::new(&sess, fm, None), sess.codemap());\n     if let Err(_) = classifier.write_source(&mut out) {\n@@ -63,7 +58,7 @@ pub fn render_with_highlighting(src: &str, class: Option<&str>, id: Option<&str>\n /// Processes a program (nested in the internal `lexer`), classifying strings of\n /// text by highlighting category (`Class`). Calls out to a `Writer` to write\n /// each span of text in sequence.\n-pub struct Classifier<'a> {\n+struct Classifier<'a> {\n     lexer: lexer::StringReader<'a>,\n     codemap: &'a CodeMap,\n \n@@ -75,7 +70,7 @@ pub struct Classifier<'a> {\n \n /// How a span of text is classified. Mostly corresponds to token kinds.\n #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n-pub enum Class {\n+enum Class {\n     None,\n     Comment,\n     DocComment,\n@@ -103,19 +98,17 @@ pub enum Class {\n /// The classifier will call into the `Writer` implementation as it finds spans\n /// of text to highlight. Exactly how that text should be highlighted is up to\n /// the implementation.\n-pub trait Writer {\n+trait Writer {\n     /// Called when we start processing a span of text that should be highlighted.\n     /// The `Class` argument specifies how it should be highlighted.\n     fn enter_span(&mut self, _: Class) -> io::Result<()>;\n \n     /// Called at the end of a span of highlighted text.\n     fn exit_span(&mut self) -> io::Result<()>;\n \n-    /// Called for a span of text, usually, but not always, a single token. If\n-    /// the string of text (`T`) does correspond to a token, then the token will\n-    /// also be passed. If the text should be highlighted differently from the\n-    /// surrounding text, then the `Class` argument will be a value other than\n-    /// `None`.\n+    /// Called for a span of text.  If the text should be highlighted differently from the\n+    /// surrounding text, then the `Class` argument will be a value other than `None`.\n+    ///\n     /// The following sequences of callbacks are equivalent:\n     /// ```plain\n     ///     enter_span(Foo), string(\"text\", None), exit_span()\n@@ -125,8 +118,7 @@ pub trait Writer {\n     /// more flexible.\n     fn string<T: Display>(&mut self,\n                           text: T,\n-                          klass: Class,\n-                          tok: Option<&TokenAndSpan>)\n+                          klass: Class)\n                           -> io::Result<()>;\n }\n \n@@ -135,8 +127,7 @@ pub trait Writer {\n impl<U: Write> Writer for U {\n     fn string<T: Display>(&mut self,\n                           text: T,\n-                          klass: Class,\n-                          _tas: Option<&TokenAndSpan>)\n+                          klass: Class)\n                           -> io::Result<()> {\n         match klass {\n             Class::None => write!(self, \"{}\", text),\n@@ -154,7 +145,7 @@ impl<U: Write> Writer for U {\n }\n \n impl<'a> Classifier<'a> {\n-    pub fn new(lexer: lexer::StringReader<'a>, codemap: &'a CodeMap) -> Classifier<'a> {\n+    fn new(lexer: lexer::StringReader<'a>, codemap: &'a CodeMap) -> Classifier<'a> {\n         Classifier {\n             lexer,\n             codemap,\n@@ -186,7 +177,7 @@ impl<'a> Classifier<'a> {\n     /// is used. All source code emission is done as slices from the source map,\n     /// not from the tokens themselves, in order to stay true to the original\n     /// source.\n-    pub fn write_source<W: Writer>(&mut self,\n+    fn write_source<W: Writer>(&mut self,\n                                    out: &mut W)\n                                    -> io::Result<()> {\n         loop {\n@@ -208,7 +199,7 @@ impl<'a> Classifier<'a> {\n                               -> io::Result<()> {\n         let klass = match tas.tok {\n             token::Shebang(s) => {\n-                out.string(Escape(&s.as_str()), Class::None, Some(&tas))?;\n+                out.string(Escape(&s.as_str()), Class::None)?;\n                 return Ok(());\n             },\n \n@@ -272,8 +263,8 @@ impl<'a> Classifier<'a> {\n                         self.in_attribute = true;\n                         out.enter_span(Class::Attribute)?;\n                     }\n-                    out.string(\"#\", Class::None, None)?;\n-                    out.string(\"!\", Class::None, None)?;\n+                    out.string(\"#\", Class::None)?;\n+                    out.string(\"!\", Class::None)?;\n                     return Ok(());\n                 }\n \n@@ -282,13 +273,13 @@ impl<'a> Classifier<'a> {\n                     self.in_attribute = true;\n                     out.enter_span(Class::Attribute)?;\n                 }\n-                out.string(\"#\", Class::None, None)?;\n+                out.string(\"#\", Class::None)?;\n                 return Ok(());\n             }\n             token::CloseDelim(token::Bracket) => {\n                 if self.in_attribute {\n                     self.in_attribute = false;\n-                    out.string(\"]\", Class::None, None)?;\n+                    out.string(\"]\", Class::None)?;\n                     out.exit_span()?;\n                     return Ok(());\n                 } else {\n@@ -344,7 +335,7 @@ impl<'a> Classifier<'a> {\n \n         // Anything that didn't return above is the simple case where we the\n         // class just spans a single token, so we can use the `string` method.\n-        out.string(Escape(&self.snip(tas.sp)), klass, Some(&tas))\n+        out.string(Escape(&self.snip(tas.sp)), klass)\n     }\n \n     // Helper function to get a snippet from the codemap.\n@@ -355,7 +346,7 @@ impl<'a> Classifier<'a> {\n \n impl Class {\n     /// Returns the css class expected by rustdoc for each `Class`.\n-    pub fn rustdoc_class(self) -> &'static str {\n+    fn rustdoc_class(self) -> &'static str {\n         match self {\n             Class::None => \"\",\n             Class::Comment => \"comment\",\n@@ -379,15 +370,8 @@ impl Class {\n     }\n }\n \n-fn write_header(class: Option<&str>,\n-                id: Option<&str>,\n-                out: &mut dyn Write)\n-                -> io::Result<()> {\n-    write!(out, \"<pre \")?;\n-    if let Some(id) = id {\n-        write!(out, \"id='{}' \", id)?;\n-    }\n-    write!(out, \"class=\\\"rust {}\\\">\\n\", class.unwrap_or(\"\"))\n+fn write_header(class: Option<&str>, out: &mut Write) -> io::Result<()> {\n+    write!(out, \"<pre class=\\\"rust {}\\\">\\n\", class.unwrap_or(\"\"))\n }\n \n fn write_footer(out: &mut dyn Write) -> io::Result<()> {"}, {"sha": "b22e239e20a0eeaf166b3b34935ceb6eaaed5655", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8e65a46268d681a6359400ebdc81b5fe204bb93b/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e65a46268d681a6359400ebdc81b5fe204bb93b/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=8e65a46268d681a6359400ebdc81b5fe204bb93b", "patch": "@@ -247,7 +247,6 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n                                       if ignore { \" ignore\" }\n                                       else if compile_fail { \" compile_fail\" }\n                                       else { \"\" })),\n-                        None,\n                         playground_button.as_ref().map(String::as_str),\n                         tooltip));\n             Some(Event::Html(s.into()))"}, {"sha": "c2978a62489a0d86bd787212f9abc144d2d4dc81", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e65a46268d681a6359400ebdc81b5fe204bb93b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e65a46268d681a6359400ebdc81b5fe204bb93b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=8e65a46268d681a6359400ebdc81b5fe204bb93b", "patch": "@@ -2239,7 +2239,6 @@ fn render_assoc_const_value(item: &clean::Item) -> String {\n                 None,\n                 None,\n                 None,\n-                None,\n             )\n         }\n         _ => String::new(),\n@@ -4551,7 +4550,7 @@ impl<'a> fmt::Display for Source<'a> {\n         }\n         write!(fmt, \"</pre>\")?;\n         write!(fmt, \"{}\",\n-               highlight::render_with_highlighting(s, None, None, None, None))?;\n+               highlight::render_with_highlighting(s, None, None, None))?;\n         Ok(())\n     }\n }\n@@ -4562,7 +4561,6 @@ fn item_macro(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         w.write_str(&highlight::render_with_highlighting(&t.source,\n                                                          Some(\"macro\"),\n                                                          None,\n-                                                         None,\n                                                          None))\n     })?;\n     document(w, cx, it)"}]}