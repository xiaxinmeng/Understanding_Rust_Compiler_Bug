{"sha": "82f2c08200dabfecf82ad7eecd3bc6ff246bda5c", "node_id": "C_kwDOAAsO6NoAKDgyZjJjMDgyMDBkYWJmZWNmODJhZDdlZWNkM2JjNmZmMjQ2YmRhNWM", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-08-01T11:22:50Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-08-07T07:50:08Z"}, "message": "fix wrong suggestions for boxed trait objects instead of impl trait", "tree": {"sha": "7d5e1eed31063fdf93ded1591978c20eab1bb82a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d5e1eed31063fdf93ded1591978c20eab1bb82a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82f2c08200dabfecf82ad7eecd3bc6ff246bda5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82f2c08200dabfecf82ad7eecd3bc6ff246bda5c", "html_url": "https://github.com/rust-lang/rust/commit/82f2c08200dabfecf82ad7eecd3bc6ff246bda5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82f2c08200dabfecf82ad7eecd3bc6ff246bda5c/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc43bd60c08eed7a714bb4726c8c511c1e6b3332", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc43bd60c08eed7a714bb4726c8c511c1e6b3332", "html_url": "https://github.com/rust-lang/rust/commit/fc43bd60c08eed7a714bb4726c8c511c1e6b3332"}], "stats": {"total": 153, "additions": 122, "deletions": 31}, "files": [{"sha": "2d50412007d909b493571c7d774bc4c82b729dd0", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 33, "deletions": 26, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/82f2c08200dabfecf82ad7eecd3bc6ff246bda5c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82f2c08200dabfecf82ad7eecd3bc6ff246bda5c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=82f2c08200dabfecf82ad7eecd3bc6ff246bda5c", "patch": "@@ -94,7 +94,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let arm_ty = self.check_expr_with_expectation(&arm.body, expected);\n             all_arms_diverge &= self.diverges.get();\n \n-            let opt_suggest_box_span = self.opt_suggest_box_span(arm_ty, orig_expected);\n+            let opt_suggest_box_span = prior_arm.and_then(|(_, prior_arm_ty, _)| {\n+                self.opt_suggest_box_span(prior_arm_ty, arm_ty, orig_expected)\n+            });\n \n             let (arm_block_id, arm_span) = if let hir::ExprKind::Block(blk, _) = arm.body.kind {\n                 (Some(blk.hir_id), self.find_block_span(blk))\n@@ -473,43 +475,48 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // provide a structured suggestion in that case.\n     pub(crate) fn opt_suggest_box_span(\n         &self,\n-        outer_ty: Ty<'tcx>,\n+        first_ty: Ty<'tcx>,\n+        second_ty: Ty<'tcx>,\n         orig_expected: Expectation<'tcx>,\n     ) -> Option<Span> {\n         match orig_expected {\n             Expectation::ExpectHasType(expected)\n                 if self.in_tail_expr\n                     && self.return_type_has_opaque\n-                    && self.can_coerce(outer_ty, expected) =>\n+                    && self.can_coerce(first_ty, expected)\n+                    && self.can_coerce(second_ty, expected) =>\n             {\n                 let obligations = self.fulfillment_cx.borrow().pending_obligations();\n                 let mut suggest_box = !obligations.is_empty();\n-                for o in obligations {\n-                    match o.predicate.kind().skip_binder() {\n-                        ty::PredicateKind::Trait(t) => {\n-                            let pred =\n-                                ty::Binder::dummy(ty::PredicateKind::Trait(ty::TraitPredicate {\n-                                    trait_ref: ty::TraitRef {\n-                                        def_id: t.def_id(),\n-                                        substs: self.tcx.mk_substs_trait(outer_ty, &[]),\n+                'outer: for o in obligations {\n+                    for outer_ty in &[first_ty, second_ty] {\n+                        match o.predicate.kind().skip_binder() {\n+                            ty::PredicateKind::Trait(t) => {\n+                                let pred = ty::Binder::dummy(ty::PredicateKind::Trait(\n+                                    ty::TraitPredicate {\n+                                        trait_ref: ty::TraitRef {\n+                                            def_id: t.def_id(),\n+                                            substs: self.tcx.mk_substs_trait(*outer_ty, &[]),\n+                                        },\n+                                        constness: t.constness,\n+                                        polarity: t.polarity,\n                                     },\n-                                    constness: t.constness,\n-                                    polarity: t.polarity,\n-                                }));\n-                            let obl = Obligation::new(\n-                                o.cause.clone(),\n-                                self.param_env,\n-                                pred.to_predicate(self.tcx),\n-                            );\n-                            suggest_box &= self.predicate_must_hold_modulo_regions(&obl);\n-                            if !suggest_box {\n-                                // We've encountered some obligation that didn't hold, so the\n-                                // return expression can't just be boxed. We don't need to\n-                                // evaluate the rest of the obligations.\n-                                break;\n+                                ));\n+                                let obl = Obligation::new(\n+                                    o.cause.clone(),\n+                                    self.param_env,\n+                                    pred.to_predicate(self.tcx),\n+                                );\n+                                suggest_box &= self.predicate_must_hold_modulo_regions(&obl);\n+                                if !suggest_box {\n+                                    // We've encountered some obligation that didn't hold, so the\n+                                    // return expression can't just be boxed. We don't need to\n+                                    // evaluate the rest of the obligations.\n+                                    break 'outer;\n+                                }\n                             }\n+                            _ => {}\n                         }\n-                        _ => {}\n                     }\n                 }\n                 // If all the obligations hold (or there are no obligations) the tail expression"}, {"sha": "6d61f3dbb41c5abddf7c995be344fdf6918d8013", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82f2c08200dabfecf82ad7eecd3bc6ff246bda5c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82f2c08200dabfecf82ad7eecd3bc6ff246bda5c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=82f2c08200dabfecf82ad7eecd3bc6ff246bda5c", "patch": "@@ -1002,7 +1002,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let else_ty = self.check_expr_with_expectation(else_expr, expected);\n             let else_diverges = self.diverges.get();\n \n-            let opt_suggest_box_span = self.opt_suggest_box_span(else_ty, orig_expected);\n+            let opt_suggest_box_span = self.opt_suggest_box_span(then_ty, else_ty, orig_expected);\n             let if_cause = self.if_cause(\n                 sp,\n                 cond_expr.span,"}, {"sha": "d302dc99bd8aa1e47cece81fb939dd0128370e52", "filename": "src/test/ui/mismatched_types/do-not-suggest-boxed-trait-objects-instead-of-impl-trait.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/82f2c08200dabfecf82ad7eecd3bc6ff246bda5c/src%2Ftest%2Fui%2Fmismatched_types%2Fdo-not-suggest-boxed-trait-objects-instead-of-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82f2c08200dabfecf82ad7eecd3bc6ff246bda5c/src%2Ftest%2Fui%2Fmismatched_types%2Fdo-not-suggest-boxed-trait-objects-instead-of-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fdo-not-suggest-boxed-trait-objects-instead-of-impl-trait.rs?ref=82f2c08200dabfecf82ad7eecd3bc6ff246bda5c", "patch": "@@ -0,0 +1,23 @@\n+struct S;\n+struct Y;\n+\n+trait Trait {}\n+\n+impl Trait for Y {}\n+\n+fn foo() -> impl Trait {\n+    if true {\n+        S\n+    } else {\n+        Y //~ ERROR `if` and `else` have incompatible types\n+    }\n+}\n+\n+fn bar() -> impl Trait {\n+    match true {\n+        true => S,\n+        false => Y, //~ ERROR `match` arms have incompatible types\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "2f814445bbadfed8f69e2b8571f0fa65801c89d8", "filename": "src/test/ui/mismatched_types/do-not-suggest-boxed-trait-objects-instead-of-impl-trait.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/82f2c08200dabfecf82ad7eecd3bc6ff246bda5c/src%2Ftest%2Fui%2Fmismatched_types%2Fdo-not-suggest-boxed-trait-objects-instead-of-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/82f2c08200dabfecf82ad7eecd3bc6ff246bda5c/src%2Ftest%2Fui%2Fmismatched_types%2Fdo-not-suggest-boxed-trait-objects-instead-of-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fdo-not-suggest-boxed-trait-objects-instead-of-impl-trait.stderr?ref=82f2c08200dabfecf82ad7eecd3bc6ff246bda5c", "patch": "@@ -0,0 +1,26 @@\n+error[E0308]: `if` and `else` have incompatible types\n+  --> $DIR/do-not-suggest-boxed-trait-objects-instead-of-impl-trait.rs:12:9\n+   |\n+LL | /     if true {\n+LL | |         S\n+   | |         - expected because of this\n+LL | |     } else {\n+LL | |         Y\n+   | |         ^ expected struct `S`, found struct `Y`\n+LL | |     }\n+   | |_____- `if` and `else` have incompatible types\n+\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/do-not-suggest-boxed-trait-objects-instead-of-impl-trait.rs:19:18\n+   |\n+LL | /     match true {\n+LL | |         true => S,\n+   | |                 - this is found to be of type `S`\n+LL | |         false => Y,\n+   | |                  ^ expected struct `S`, found struct `Y`\n+LL | |     }\n+   | |_____- `match` arms have incompatible types\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "f30feaed055740e1be7e06453636558118f64eb6", "filename": "src/test/ui/mismatched_types/suggest-boxed-trait-objects-instead-of-impl-trait.fixed", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/82f2c08200dabfecf82ad7eecd3bc6ff246bda5c/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-boxed-trait-objects-instead-of-impl-trait.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/82f2c08200dabfecf82ad7eecd3bc6ff246bda5c/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-boxed-trait-objects-instead-of-impl-trait.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-boxed-trait-objects-instead-of-impl-trait.fixed?ref=82f2c08200dabfecf82ad7eecd3bc6ff246bda5c", "patch": "@@ -10,12 +10,19 @@ trait Trait {}\n impl Trait for S {}\n impl Trait for Y {}\n \n-fn baz() -> Box<dyn Trait> {\n+fn foo() -> Box<dyn Trait> {\n     if true {\n         Box::new(S)\n     } else {\n         Box::new(Y) //~ ERROR `if` and `else` have incompatible types\n     }\n }\n \n+fn bar() -> Box<dyn Trait> {\n+    match true {\n+        true => Box::new(S),\n+        false => Box::new(Y), //~ ERROR `match` arms have incompatible types\n+    }\n+}\n+\n fn main() {}"}, {"sha": "2bd8146e289d9e448e0bac3bff3c465971ee7ef7", "filename": "src/test/ui/mismatched_types/suggest-boxed-trait-objects-instead-of-impl-trait.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/82f2c08200dabfecf82ad7eecd3bc6ff246bda5c/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-boxed-trait-objects-instead-of-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82f2c08200dabfecf82ad7eecd3bc6ff246bda5c/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-boxed-trait-objects-instead-of-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-boxed-trait-objects-instead-of-impl-trait.rs?ref=82f2c08200dabfecf82ad7eecd3bc6ff246bda5c", "patch": "@@ -10,12 +10,19 @@ trait Trait {}\n impl Trait for S {}\n impl Trait for Y {}\n \n-fn baz() -> impl Trait {\n+fn foo() -> impl Trait {\n     if true {\n         S\n     } else {\n         Y //~ ERROR `if` and `else` have incompatible types\n     }\n }\n \n+fn bar() -> impl Trait {\n+    match true {\n+        true => S,\n+        false => Y, //~ ERROR `match` arms have incompatible types\n+    }\n+}\n+\n fn main() {}"}, {"sha": "f58b9c3ec16de528c6d986cd2ac8c0fb9b7acd2c", "filename": "src/test/ui/mismatched_types/suggest-boxed-trait-objects-instead-of-impl-trait.stderr", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/82f2c08200dabfecf82ad7eecd3bc6ff246bda5c/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-boxed-trait-objects-instead-of-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/82f2c08200dabfecf82ad7eecd3bc6ff246bda5c/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-boxed-trait-objects-instead-of-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-boxed-trait-objects-instead-of-impl-trait.stderr?ref=82f2c08200dabfecf82ad7eecd3bc6ff246bda5c", "patch": "@@ -12,7 +12,7 @@ LL | |     }\n    |\n help: you could change the return type to be a boxed trait object\n    |\n-LL | fn baz() -> Box<dyn Trait> {\n+LL | fn foo() -> Box<dyn Trait> {\n    |             ~~~~~~~      +\n help: if you change the return type to expect trait objects, box the returned expressions\n    |\n@@ -21,6 +21,27 @@ LL |     } else {\n LL ~         Box::new(Y)\n    |\n \n-error: aborting due to previous error\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/suggest-boxed-trait-objects-instead-of-impl-trait.rs:24:18\n+   |\n+LL | /     match true {\n+LL | |         true => S,\n+   | |                 - this is found to be of type `S`\n+LL | |         false => Y,\n+   | |                  ^ expected struct `S`, found struct `Y`\n+LL | |     }\n+   | |_____- `match` arms have incompatible types\n+   |\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn bar() -> Box<dyn Trait> {\n+   |             ~~~~~~~      +\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL ~         true => Box::new(S),\n+LL ~         false => Box::new(Y),\n+   |\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}]}