{"sha": "6e2715074ed9712a5796ea4f66d9e59713ead06f", "node_id": "C_kwDOAAsO6NoAKDZlMjcxNTA3NGVkOTcxMmE1Nzk2ZWE0ZjY2ZDllNTk3MTNlYWQwNmY", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-08-01T13:26:59Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-08-01T13:32:19Z"}, "message": "move layout sanity check to its own file", "tree": {"sha": "8d02d140c20bf34b49ec54a627ca8a6c0b1dab13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d02d140c20bf34b49ec54a627ca8a6c0b1dab13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e2715074ed9712a5796ea4f66d9e59713ead06f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e2715074ed9712a5796ea4f66d9e59713ead06f", "html_url": "https://github.com/rust-lang/rust/commit/6e2715074ed9712a5796ea4f66d9e59713ead06f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e2715074ed9712a5796ea4f66d9e59713ead06f/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2e419762eb82b82f768b2ddc72d1f49c618879e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2e419762eb82b82f768b2ddc72d1f49c618879e", "html_url": "https://github.com/rust-lang/rust/commit/c2e419762eb82b82f768b2ddc72d1f49c618879e"}], "stats": {"total": 594, "additions": 304, "deletions": 290}, "files": [{"sha": "f5505590168d2927dd1fb8ffaa3b6830e2cb1e60", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 4, "deletions": 290, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/6e2715074ed9712a5796ea4f66d9e59713ead06f/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2715074ed9712a5796ea4f66d9e59713ead06f/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=6e2715074ed9712a5796ea4f66d9e59713ead06f", "patch": "@@ -2,7 +2,10 @@ use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use crate::mir::{GeneratorLayout, GeneratorSavedLocal};\n use crate::ty::normalize_erasing_regions::NormalizationError;\n use crate::ty::subst::Subst;\n-use crate::ty::{self, subst::SubstsRef, EarlyBinder, ReprOptions, Ty, TyCtxt, TypeVisitable};\n+use crate::ty::{\n+    self, layout_sanity_check::sanity_check_layout, subst::SubstsRef, EarlyBinder, ReprOptions, Ty,\n+    TyCtxt, TypeVisitable,\n+};\n use rustc_ast as ast;\n use rustc_attr as attr;\n use rustc_hir as hir;\n@@ -221,295 +224,6 @@ impl<'tcx> fmt::Display for LayoutError<'tcx> {\n     }\n }\n \n-/// Enforce some basic invariants on layouts.\n-fn sanity_check_layout<'tcx>(cx: &LayoutCx<'tcx, TyCtxt<'tcx>>, layout: &TyAndLayout<'tcx>) {\n-    // Type-level uninhabitedness should always imply ABI uninhabitedness.\n-    if cx.tcx.conservative_is_privately_uninhabited(cx.param_env.and(layout.ty)) {\n-        assert!(layout.abi.is_uninhabited());\n-    }\n-\n-    if layout.size.bytes() % layout.align.abi.bytes() != 0 {\n-        bug!(\"size is not a multiple of align, in the following layout:\\n{layout:#?}\");\n-    }\n-\n-    if cfg!(debug_assertions) {\n-        /// Yields non-1-ZST fields of the type\n-        fn non_zst_fields<'tcx, 'a>(\n-            cx: &'a LayoutCx<'tcx, TyCtxt<'tcx>>,\n-            layout: &'a TyAndLayout<'tcx>,\n-        ) -> impl Iterator<Item = (Size, TyAndLayout<'tcx>)> + 'a {\n-            (0..layout.layout.fields().count()).filter_map(|i| {\n-                let field = layout.field(cx, i);\n-                // Also checking `align == 1` here leads to test failures in\n-                // `layout/zero-sized-array-union.rs`, where a type has a zero-size field with\n-                // alignment 4 that still gets ignored during layout computation (which is okay\n-                // since other fields already force alignment 4).\n-                let zst = field.is_zst();\n-                (!zst).then(|| (layout.fields.offset(i), field))\n-            })\n-        }\n-\n-        fn skip_newtypes<'tcx>(\n-            cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n-            layout: &TyAndLayout<'tcx>,\n-        ) -> TyAndLayout<'tcx> {\n-            if matches!(layout.layout.variants(), Variants::Multiple { .. }) {\n-                // Definitely not a newtype of anything.\n-                return *layout;\n-            }\n-            let mut fields = non_zst_fields(cx, layout);\n-            let Some(first) = fields.next() else {\n-                // No fields here, so this could be a primitive or enum -- either way it's not a newtype around a thing\n-                return *layout\n-            };\n-            if fields.next().is_none() {\n-                let (offset, first) = first;\n-                if offset == Size::ZERO && first.layout.size() == layout.size {\n-                    // This is a newtype, so keep recursing.\n-                    // FIXME(RalfJung): I don't think it would be correct to do any checks for\n-                    // alignment here, so we don't. Is that correct?\n-                    return skip_newtypes(cx, &first);\n-                }\n-            }\n-            // No more newtypes here.\n-            *layout\n-        }\n-\n-        fn check_layout_abi<'tcx>(cx: &LayoutCx<'tcx, TyCtxt<'tcx>>, layout: &TyAndLayout<'tcx>) {\n-            match layout.layout.abi() {\n-                Abi::Scalar(scalar) => {\n-                    // No padding in scalars.\n-                    let size = scalar.size(cx);\n-                    let align = scalar.align(cx).abi;\n-                    assert_eq!(\n-                        layout.layout.size(),\n-                        size,\n-                        \"size mismatch between ABI and layout in {layout:#?}\"\n-                    );\n-                    assert_eq!(\n-                        layout.layout.align().abi,\n-                        align,\n-                        \"alignment mismatch between ABI and layout in {layout:#?}\"\n-                    );\n-                    // Check that this matches the underlying field.\n-                    let inner = skip_newtypes(cx, layout);\n-                    assert!(\n-                        matches!(inner.layout.abi(), Abi::Scalar(_)),\n-                        \"`Scalar` type {} is newtype around non-`Scalar` type {}\",\n-                        layout.ty,\n-                        inner.ty\n-                    );\n-                    match inner.layout.fields() {\n-                        FieldsShape::Primitive => {\n-                            // Fine.\n-                        }\n-                        FieldsShape::Arbitrary { .. } => {\n-                            // Should be an enum, the only field is the discriminant.\n-                            assert!(\n-                                inner.ty.is_enum(),\n-                                \"`Scalar` layout for non-primitive non-enum type {}\",\n-                                inner.ty\n-                            );\n-                            assert_eq!(\n-                                inner.layout.fields().count(),\n-                                1,\n-                                \"`Scalar` layout for multiple-field type in {inner:#?}\",\n-                            );\n-                            let offset = inner.layout.fields().offset(0);\n-                            let field = inner.field(cx, 0);\n-                            // The field should be at the right offset, and match the `scalar` layout.\n-                            assert_eq!(\n-                                offset,\n-                                Size::ZERO,\n-                                \"`Scalar` field at non-0 offset in {inner:#?}\",\n-                            );\n-                            assert_eq!(\n-                                field.size, size,\n-                                \"`Scalar` field with bad size in {inner:#?}\",\n-                            );\n-                            assert_eq!(\n-                                field.align.abi, align,\n-                                \"`Scalar` field with bad align in {inner:#?}\",\n-                            );\n-                            assert!(\n-                                matches!(field.abi, Abi::Scalar(_)),\n-                                \"`Scalar` field with bad ABI in {inner:#?}\",\n-                            );\n-                        }\n-                        _ => {\n-                            panic!(\"`Scalar` layout for non-primitive non-enum type {}\", inner.ty);\n-                        }\n-                    }\n-                }\n-                Abi::ScalarPair(scalar1, scalar2) => {\n-                    // Sanity-check scalar pairs. These are a bit more flexible and support\n-                    // padding, but we can at least ensure both fields actually fit into the layout\n-                    // and the alignment requirement has not been weakened.\n-                    let size1 = scalar1.size(cx);\n-                    let align1 = scalar1.align(cx).abi;\n-                    let size2 = scalar2.size(cx);\n-                    let align2 = scalar2.align(cx).abi;\n-                    assert!(\n-                        layout.layout.align().abi >= cmp::max(align1, align2),\n-                        \"alignment mismatch between ABI and layout in {layout:#?}\",\n-                    );\n-                    let field2_offset = size1.align_to(align2);\n-                    assert!(\n-                        layout.layout.size() >= field2_offset + size2,\n-                        \"size mismatch between ABI and layout in {layout:#?}\"\n-                    );\n-                    // Check that the underlying pair of fields matches.\n-                    let inner = skip_newtypes(cx, layout);\n-                    assert!(\n-                        matches!(inner.layout.abi(), Abi::ScalarPair(..)),\n-                        \"`ScalarPair` type {} is newtype around non-`ScalarPair` type {}\",\n-                        layout.ty,\n-                        inner.ty\n-                    );\n-                    if matches!(inner.layout.variants(), Variants::Multiple { .. }) {\n-                        // FIXME: ScalarPair for enums is enormously complicated and it is very hard\n-                        // to check anything about them.\n-                        return;\n-                    }\n-                    match inner.layout.fields() {\n-                        FieldsShape::Arbitrary { .. } => {\n-                            // Checked below.\n-                        }\n-                        FieldsShape::Union(..) => {\n-                            // FIXME: I guess we could also check something here? Like, look at all fields?\n-                            return;\n-                        }\n-                        _ => {\n-                            panic!(\"`ScalarPair` layout with unexpected field shape in {inner:#?}\");\n-                        }\n-                    }\n-                    let mut fields = non_zst_fields(cx, &inner);\n-                    let (offset1, field1) = fields.next().unwrap_or_else(|| {\n-                        panic!(\"`ScalarPair` layout for type with not even one non-ZST field: {inner:#?}\")\n-                    });\n-                    let (offset2, field2) = fields.next().unwrap_or_else(|| {\n-                        panic!(\"`ScalarPair` layout for type with less than two non-ZST fields: {inner:#?}\")\n-                    });\n-                    assert!(\n-                        fields.next().is_none(),\n-                        \"`ScalarPair` layout for type with at least three non-ZST fields: {inner:#?}\"\n-                    );\n-                    // The fields might be in opposite order.\n-                    let (offset1, field1, offset2, field2) = if offset1 <= offset2 {\n-                        (offset1, field1, offset2, field2)\n-                    } else {\n-                        (offset2, field2, offset1, field1)\n-                    };\n-                    // The fields should be at the right offset, and match the `scalar` layout.\n-                    assert_eq!(\n-                        offset1,\n-                        Size::ZERO,\n-                        \"`ScalarPair` first field at non-0 offset in {inner:#?}\",\n-                    );\n-                    assert_eq!(\n-                        field1.size, size1,\n-                        \"`ScalarPair` first field with bad size in {inner:#?}\",\n-                    );\n-                    assert_eq!(\n-                        field1.align.abi, align1,\n-                        \"`ScalarPair` first field with bad align in {inner:#?}\",\n-                    );\n-                    assert!(\n-                        matches!(field1.abi, Abi::Scalar(_)),\n-                        \"`ScalarPair` first field with bad ABI in {inner:#?}\",\n-                    );\n-                    assert_eq!(\n-                        offset2, field2_offset,\n-                        \"`ScalarPair` second field at bad offset in {inner:#?}\",\n-                    );\n-                    assert_eq!(\n-                        field2.size, size2,\n-                        \"`ScalarPair` second field with bad size in {inner:#?}\",\n-                    );\n-                    assert_eq!(\n-                        field2.align.abi, align2,\n-                        \"`ScalarPair` second field with bad align in {inner:#?}\",\n-                    );\n-                    assert!(\n-                        matches!(field2.abi, Abi::Scalar(_)),\n-                        \"`ScalarPair` second field with bad ABI in {inner:#?}\",\n-                    );\n-                }\n-                Abi::Vector { count, element } => {\n-                    // No padding in vectors. Alignment can be strengthened, though.\n-                    assert!(\n-                        layout.layout.align().abi >= element.align(cx).abi,\n-                        \"alignment mismatch between ABI and layout in {layout:#?}\"\n-                    );\n-                    let size = element.size(cx) * count;\n-                    assert_eq!(\n-                        layout.layout.size(),\n-                        size.align_to(cx.data_layout().vector_align(size).abi),\n-                        \"size mismatch between ABI and layout in {layout:#?}\"\n-                    );\n-                }\n-                Abi::Uninhabited | Abi::Aggregate { .. } => {} // Nothing to check.\n-            }\n-        }\n-\n-        check_layout_abi(cx, layout);\n-\n-        if let Variants::Multiple { variants, .. } = &layout.variants {\n-            for variant in variants.iter() {\n-                // No nested \"multiple\".\n-                assert!(matches!(variant.variants(), Variants::Single { .. }));\n-                // Variants should have the same or a smaller size as the full thing,\n-                // and same for alignment.\n-                if variant.size() > layout.size {\n-                    bug!(\n-                        \"Type with size {} bytes has variant with size {} bytes: {layout:#?}\",\n-                        layout.size.bytes(),\n-                        variant.size().bytes(),\n-                    )\n-                }\n-                if variant.align().abi > layout.align.abi {\n-                    bug!(\n-                        \"Type with alignment {} bytes has variant with alignment {} bytes: {layout:#?}\",\n-                        layout.align.abi.bytes(),\n-                        variant.align().abi.bytes(),\n-                    )\n-                }\n-                // Skip empty variants.\n-                if variant.size() == Size::ZERO\n-                    || variant.fields().count() == 0\n-                    || variant.abi().is_uninhabited()\n-                {\n-                    // These are never actually accessed anyway, so we can skip the coherence check\n-                    // for them. They also fail that check, since they have\n-                    // `Aggregate`/`Uninhbaited` ABI even when the main type is\n-                    // `Scalar`/`ScalarPair`. (Note that sometimes, variants with fields have size\n-                    // 0, and sometimes, variants without fields have non-0 size.)\n-                    continue;\n-                }\n-                // The top-level ABI and the ABI of the variants should be coherent.\n-                let scalar_coherent = |s1: Scalar, s2: Scalar| {\n-                    s1.size(cx) == s2.size(cx) && s1.align(cx) == s2.align(cx)\n-                };\n-                let abi_coherent = match (layout.abi, variant.abi()) {\n-                    (Abi::Scalar(s1), Abi::Scalar(s2)) => scalar_coherent(s1, s2),\n-                    (Abi::ScalarPair(a1, b1), Abi::ScalarPair(a2, b2)) => {\n-                        scalar_coherent(a1, a2) && scalar_coherent(b1, b2)\n-                    }\n-                    (Abi::Uninhabited, _) => true,\n-                    (Abi::Aggregate { .. }, _) => true,\n-                    _ => false,\n-                };\n-                if !abi_coherent {\n-                    bug!(\n-                        \"Variant ABI is incompatible with top-level ABI:\\nvariant={:#?}\\nTop-level: {layout:#?}\",\n-                        variant\n-                    );\n-                }\n-            }\n-        }\n-    }\n-}\n-\n #[instrument(skip(tcx, query), level = \"debug\")]\n fn layout_of<'tcx>(\n     tcx: TyCtxt<'tcx>,"}, {"sha": "95bc81517da03b03eec4746af198526f4b28d6df", "filename": "compiler/rustc_middle/src/ty/layout_sanity_check.rs", "status": "added", "additions": 299, "deletions": 0, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/6e2715074ed9712a5796ea4f66d9e59713ead06f/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout_sanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2715074ed9712a5796ea4f66d9e59713ead06f/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout_sanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout_sanity_check.rs?ref=6e2715074ed9712a5796ea4f66d9e59713ead06f", "patch": "@@ -0,0 +1,299 @@\n+use crate::ty::{\n+    layout::{LayoutCx, TyAndLayout},\n+    TyCtxt,\n+};\n+use rustc_target::abi::*;\n+\n+use std::cmp;\n+\n+/// Enforce some basic invariants on layouts.\n+pub(super) fn sanity_check_layout<'tcx>(\n+    cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n+    layout: &TyAndLayout<'tcx>,\n+) {\n+    // Type-level uninhabitedness should always imply ABI uninhabitedness.\n+    if cx.tcx.conservative_is_privately_uninhabited(cx.param_env.and(layout.ty)) {\n+        assert!(layout.abi.is_uninhabited());\n+    }\n+\n+    if layout.size.bytes() % layout.align.abi.bytes() != 0 {\n+        bug!(\"size is not a multiple of align, in the following layout:\\n{layout:#?}\");\n+    }\n+\n+    if cfg!(debug_assertions) {\n+        /// Yields non-1-ZST fields of the type\n+        fn non_zst_fields<'tcx, 'a>(\n+            cx: &'a LayoutCx<'tcx, TyCtxt<'tcx>>,\n+            layout: &'a TyAndLayout<'tcx>,\n+        ) -> impl Iterator<Item = (Size, TyAndLayout<'tcx>)> + 'a {\n+            (0..layout.layout.fields().count()).filter_map(|i| {\n+                let field = layout.field(cx, i);\n+                // Also checking `align == 1` here leads to test failures in\n+                // `layout/zero-sized-array-union.rs`, where a type has a zero-size field with\n+                // alignment 4 that still gets ignored during layout computation (which is okay\n+                // since other fields already force alignment 4).\n+                let zst = field.is_zst();\n+                (!zst).then(|| (layout.fields.offset(i), field))\n+            })\n+        }\n+\n+        fn skip_newtypes<'tcx>(\n+            cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n+            layout: &TyAndLayout<'tcx>,\n+        ) -> TyAndLayout<'tcx> {\n+            if matches!(layout.layout.variants(), Variants::Multiple { .. }) {\n+                // Definitely not a newtype of anything.\n+                return *layout;\n+            }\n+            let mut fields = non_zst_fields(cx, layout);\n+            let Some(first) = fields.next() else {\n+                // No fields here, so this could be a primitive or enum -- either way it's not a newtype around a thing\n+                return *layout\n+            };\n+            if fields.next().is_none() {\n+                let (offset, first) = first;\n+                if offset == Size::ZERO && first.layout.size() == layout.size {\n+                    // This is a newtype, so keep recursing.\n+                    // FIXME(RalfJung): I don't think it would be correct to do any checks for\n+                    // alignment here, so we don't. Is that correct?\n+                    return skip_newtypes(cx, &first);\n+                }\n+            }\n+            // No more newtypes here.\n+            *layout\n+        }\n+\n+        fn check_layout_abi<'tcx>(cx: &LayoutCx<'tcx, TyCtxt<'tcx>>, layout: &TyAndLayout<'tcx>) {\n+            match layout.layout.abi() {\n+                Abi::Scalar(scalar) => {\n+                    // No padding in scalars.\n+                    let size = scalar.size(cx);\n+                    let align = scalar.align(cx).abi;\n+                    assert_eq!(\n+                        layout.layout.size(),\n+                        size,\n+                        \"size mismatch between ABI and layout in {layout:#?}\"\n+                    );\n+                    assert_eq!(\n+                        layout.layout.align().abi,\n+                        align,\n+                        \"alignment mismatch between ABI and layout in {layout:#?}\"\n+                    );\n+                    // Check that this matches the underlying field.\n+                    let inner = skip_newtypes(cx, layout);\n+                    assert!(\n+                        matches!(inner.layout.abi(), Abi::Scalar(_)),\n+                        \"`Scalar` type {} is newtype around non-`Scalar` type {}\",\n+                        layout.ty,\n+                        inner.ty\n+                    );\n+                    match inner.layout.fields() {\n+                        FieldsShape::Primitive => {\n+                            // Fine.\n+                        }\n+                        FieldsShape::Arbitrary { .. } => {\n+                            // Should be an enum, the only field is the discriminant.\n+                            assert!(\n+                                inner.ty.is_enum(),\n+                                \"`Scalar` layout for non-primitive non-enum type {}\",\n+                                inner.ty\n+                            );\n+                            assert_eq!(\n+                                inner.layout.fields().count(),\n+                                1,\n+                                \"`Scalar` layout for multiple-field type in {inner:#?}\",\n+                            );\n+                            let offset = inner.layout.fields().offset(0);\n+                            let field = inner.field(cx, 0);\n+                            // The field should be at the right offset, and match the `scalar` layout.\n+                            assert_eq!(\n+                                offset,\n+                                Size::ZERO,\n+                                \"`Scalar` field at non-0 offset in {inner:#?}\",\n+                            );\n+                            assert_eq!(\n+                                field.size, size,\n+                                \"`Scalar` field with bad size in {inner:#?}\",\n+                            );\n+                            assert_eq!(\n+                                field.align.abi, align,\n+                                \"`Scalar` field with bad align in {inner:#?}\",\n+                            );\n+                            assert!(\n+                                matches!(field.abi, Abi::Scalar(_)),\n+                                \"`Scalar` field with bad ABI in {inner:#?}\",\n+                            );\n+                        }\n+                        _ => {\n+                            panic!(\"`Scalar` layout for non-primitive non-enum type {}\", inner.ty);\n+                        }\n+                    }\n+                }\n+                Abi::ScalarPair(scalar1, scalar2) => {\n+                    // Sanity-check scalar pairs. These are a bit more flexible and support\n+                    // padding, but we can at least ensure both fields actually fit into the layout\n+                    // and the alignment requirement has not been weakened.\n+                    let size1 = scalar1.size(cx);\n+                    let align1 = scalar1.align(cx).abi;\n+                    let size2 = scalar2.size(cx);\n+                    let align2 = scalar2.align(cx).abi;\n+                    assert!(\n+                        layout.layout.align().abi >= cmp::max(align1, align2),\n+                        \"alignment mismatch between ABI and layout in {layout:#?}\",\n+                    );\n+                    let field2_offset = size1.align_to(align2);\n+                    assert!(\n+                        layout.layout.size() >= field2_offset + size2,\n+                        \"size mismatch between ABI and layout in {layout:#?}\"\n+                    );\n+                    // Check that the underlying pair of fields matches.\n+                    let inner = skip_newtypes(cx, layout);\n+                    assert!(\n+                        matches!(inner.layout.abi(), Abi::ScalarPair(..)),\n+                        \"`ScalarPair` type {} is newtype around non-`ScalarPair` type {}\",\n+                        layout.ty,\n+                        inner.ty\n+                    );\n+                    if matches!(inner.layout.variants(), Variants::Multiple { .. }) {\n+                        // FIXME: ScalarPair for enums is enormously complicated and it is very hard\n+                        // to check anything about them.\n+                        return;\n+                    }\n+                    match inner.layout.fields() {\n+                        FieldsShape::Arbitrary { .. } => {\n+                            // Checked below.\n+                        }\n+                        FieldsShape::Union(..) => {\n+                            // FIXME: I guess we could also check something here? Like, look at all fields?\n+                            return;\n+                        }\n+                        _ => {\n+                            panic!(\"`ScalarPair` layout with unexpected field shape in {inner:#?}\");\n+                        }\n+                    }\n+                    let mut fields = non_zst_fields(cx, &inner);\n+                    let (offset1, field1) = fields.next().unwrap_or_else(|| {\n+                        panic!(\"`ScalarPair` layout for type with not even one non-ZST field: {inner:#?}\")\n+                    });\n+                    let (offset2, field2) = fields.next().unwrap_or_else(|| {\n+                        panic!(\"`ScalarPair` layout for type with less than two non-ZST fields: {inner:#?}\")\n+                    });\n+                    assert!(\n+                        fields.next().is_none(),\n+                        \"`ScalarPair` layout for type with at least three non-ZST fields: {inner:#?}\"\n+                    );\n+                    // The fields might be in opposite order.\n+                    let (offset1, field1, offset2, field2) = if offset1 <= offset2 {\n+                        (offset1, field1, offset2, field2)\n+                    } else {\n+                        (offset2, field2, offset1, field1)\n+                    };\n+                    // The fields should be at the right offset, and match the `scalar` layout.\n+                    assert_eq!(\n+                        offset1,\n+                        Size::ZERO,\n+                        \"`ScalarPair` first field at non-0 offset in {inner:#?}\",\n+                    );\n+                    assert_eq!(\n+                        field1.size, size1,\n+                        \"`ScalarPair` first field with bad size in {inner:#?}\",\n+                    );\n+                    assert_eq!(\n+                        field1.align.abi, align1,\n+                        \"`ScalarPair` first field with bad align in {inner:#?}\",\n+                    );\n+                    assert!(\n+                        matches!(field1.abi, Abi::Scalar(_)),\n+                        \"`ScalarPair` first field with bad ABI in {inner:#?}\",\n+                    );\n+                    assert_eq!(\n+                        offset2, field2_offset,\n+                        \"`ScalarPair` second field at bad offset in {inner:#?}\",\n+                    );\n+                    assert_eq!(\n+                        field2.size, size2,\n+                        \"`ScalarPair` second field with bad size in {inner:#?}\",\n+                    );\n+                    assert_eq!(\n+                        field2.align.abi, align2,\n+                        \"`ScalarPair` second field with bad align in {inner:#?}\",\n+                    );\n+                    assert!(\n+                        matches!(field2.abi, Abi::Scalar(_)),\n+                        \"`ScalarPair` second field with bad ABI in {inner:#?}\",\n+                    );\n+                }\n+                Abi::Vector { count, element } => {\n+                    // No padding in vectors. Alignment can be strengthened, though.\n+                    assert!(\n+                        layout.layout.align().abi >= element.align(cx).abi,\n+                        \"alignment mismatch between ABI and layout in {layout:#?}\"\n+                    );\n+                    let size = element.size(cx) * count;\n+                    assert_eq!(\n+                        layout.layout.size(),\n+                        size.align_to(cx.data_layout().vector_align(size).abi),\n+                        \"size mismatch between ABI and layout in {layout:#?}\"\n+                    );\n+                }\n+                Abi::Uninhabited | Abi::Aggregate { .. } => {} // Nothing to check.\n+            }\n+        }\n+\n+        check_layout_abi(cx, layout);\n+\n+        if let Variants::Multiple { variants, .. } = &layout.variants {\n+            for variant in variants.iter() {\n+                // No nested \"multiple\".\n+                assert!(matches!(variant.variants(), Variants::Single { .. }));\n+                // Variants should have the same or a smaller size as the full thing,\n+                // and same for alignment.\n+                if variant.size() > layout.size {\n+                    bug!(\n+                        \"Type with size {} bytes has variant with size {} bytes: {layout:#?}\",\n+                        layout.size.bytes(),\n+                        variant.size().bytes(),\n+                    )\n+                }\n+                if variant.align().abi > layout.align.abi {\n+                    bug!(\n+                        \"Type with alignment {} bytes has variant with alignment {} bytes: {layout:#?}\",\n+                        layout.align.abi.bytes(),\n+                        variant.align().abi.bytes(),\n+                    )\n+                }\n+                // Skip empty variants.\n+                if variant.size() == Size::ZERO\n+                    || variant.fields().count() == 0\n+                    || variant.abi().is_uninhabited()\n+                {\n+                    // These are never actually accessed anyway, so we can skip the coherence check\n+                    // for them. They also fail that check, since they have\n+                    // `Aggregate`/`Uninhbaited` ABI even when the main type is\n+                    // `Scalar`/`ScalarPair`. (Note that sometimes, variants with fields have size\n+                    // 0, and sometimes, variants without fields have non-0 size.)\n+                    continue;\n+                }\n+                // The top-level ABI and the ABI of the variants should be coherent.\n+                let scalar_coherent = |s1: Scalar, s2: Scalar| {\n+                    s1.size(cx) == s2.size(cx) && s1.align(cx) == s2.align(cx)\n+                };\n+                let abi_coherent = match (layout.abi, variant.abi()) {\n+                    (Abi::Scalar(s1), Abi::Scalar(s2)) => scalar_coherent(s1, s2),\n+                    (Abi::ScalarPair(a1, b1), Abi::ScalarPair(a2, b2)) => {\n+                        scalar_coherent(a1, a2) && scalar_coherent(b1, b2)\n+                    }\n+                    (Abi::Uninhabited, _) => true,\n+                    (Abi::Aggregate { .. }, _) => true,\n+                    _ => false,\n+                };\n+                if !abi_coherent {\n+                    bug!(\n+                        \"Variant ABI is incompatible with top-level ABI:\\nvariant={:#?}\\nTop-level: {layout:#?}\",\n+                        variant\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "fc4cc20119c9ec3833f9773b20bfaf9dfc5f2db1", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6e2715074ed9712a5796ea4f66d9e59713ead06f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2715074ed9712a5796ea4f66d9e59713ead06f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=6e2715074ed9712a5796ea4f66d9e59713ead06f", "patch": "@@ -124,6 +124,7 @@ mod erase_regions;\n mod generics;\n mod impls_ty;\n mod instance;\n+mod layout_sanity_check;\n mod list;\n mod parameterized;\n mod rvalue_scopes;"}]}