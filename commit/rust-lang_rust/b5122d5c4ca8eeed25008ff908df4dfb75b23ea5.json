{"sha": "b5122d5c4ca8eeed25008ff908df4dfb75b23ea5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1MTIyZDVjNGNhOGVlZWQyNTAwOGZmOTA4ZGY0ZGZiNzViMjNlYTU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-03T01:02:41Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-11T01:14:58Z"}, "message": "rustc: Always refer to TyCtxt as tcx.", "tree": {"sha": "e5c1718d0099d99112236774d4f2f675a47b61fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5c1718d0099d99112236774d4f2f675a47b61fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5122d5c4ca8eeed25008ff908df4dfb75b23ea5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5122d5c4ca8eeed25008ff908df4dfb75b23ea5", "html_url": "https://github.com/rust-lang/rust/commit/b5122d5c4ca8eeed25008ff908df4dfb75b23ea5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5122d5c4ca8eeed25008ff908df4dfb75b23ea5/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6dbb0e86aec11050480beb76eade6fb805010ba7", "url": "https://api.github.com/repos/rust-lang/rust/commits/6dbb0e86aec11050480beb76eade6fb805010ba7", "html_url": "https://github.com/rust-lang/rust/commit/6dbb0e86aec11050480beb76eade6fb805010ba7"}], "stats": {"total": 286, "additions": 143, "deletions": 143}, "files": [{"sha": "1247c156a096967478982717f157d866b06ae333", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5122d5c4ca8eeed25008ff908df4dfb75b23ea5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5122d5c4ca8eeed25008ff908df4dfb75b23ea5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=b5122d5c4ca8eeed25008ff908df4dfb75b23ea5", "patch": "@@ -169,8 +169,8 @@ enum LiveNodeKind {\n     ExitNode\n }\n \n-fn live_node_kind_to_string(lnk: LiveNodeKind, cx: &TyCtxt) -> String {\n-    let cm = cx.sess.codemap();\n+fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: &TyCtxt) -> String {\n+    let cm = tcx.sess.codemap();\n     match lnk {\n         FreeVarNode(s) => {\n             format!(\"Free var node [{}]\", cm.span_to_string(s))"}, {"sha": "7510bd07251f11003bf4af43440184bb47db43a1", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b5122d5c4ca8eeed25008ff908df4dfb75b23ea5/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5122d5c4ca8eeed25008ff908df4dfb75b23ea5/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=b5122d5c4ca8eeed25008ff908df4dfb75b23ea5", "patch": "@@ -138,7 +138,7 @@ pub enum CustomCoerceUnsized {\n \n impl<'tcx> ty::TyS<'tcx> {\n     /// See `expr_ty_adjusted`\n-    pub fn adjust<F>(&'tcx self, cx: &TyCtxt<'tcx>,\n+    pub fn adjust<F>(&'tcx self, tcx: &TyCtxt<'tcx>,\n                      span: Span,\n                      expr_id: ast::NodeId,\n                      adjustment: Option<&AutoAdjustment<'tcx>>,\n@@ -156,7 +156,7 @@ impl<'tcx> ty::TyS<'tcx> {\n                     AdjustReifyFnPointer => {\n                         match self.sty {\n                             ty::TyFnDef(_, _, b) => {\n-                                cx.mk_ty(ty::TyFnPtr(b))\n+                                tcx.mk_ty(ty::TyFnPtr(b))\n                             }\n                             _ => {\n                                 bug!(\"AdjustReifyFnPointer adjustment on non-fn-item: {:?}\",\n@@ -167,7 +167,7 @@ impl<'tcx> ty::TyS<'tcx> {\n \n                     AdjustUnsafeFnPointer => {\n                         match self.sty {\n-                            ty::TyFnPtr(b) => cx.safe_to_unsafe_fn_ty(b),\n+                            ty::TyFnPtr(b) => tcx.safe_to_unsafe_fn_ty(b),\n                             ref b => {\n                                 bug!(\"AdjustUnsafeFnPointer adjustment on non-fn-ptr: {:?}\",\n                                      b);\n@@ -177,7 +177,7 @@ impl<'tcx> ty::TyS<'tcx> {\n \n                     AdjustMutToConstPointer => {\n                         match self.sty {\n-                            ty::TyRawPtr(mt) => cx.mk_ptr(ty::TypeAndMut {\n+                            ty::TyRawPtr(mt) => tcx.mk_ptr(ty::TypeAndMut {\n                                 ty: mt.ty,\n                                 mutbl: hir::MutImmutable\n                             }),\n@@ -194,7 +194,7 @@ impl<'tcx> ty::TyS<'tcx> {\n                         if !adjusted_ty.references_error() {\n                             for i in 0..adj.autoderefs {\n                                 adjusted_ty =\n-                                    adjusted_ty.adjust_for_autoderef(cx,\n+                                    adjusted_ty.adjust_for_autoderef(tcx,\n                                                                      expr_id,\n                                                                      span,\n                                                                      i as u32,\n@@ -205,7 +205,7 @@ impl<'tcx> ty::TyS<'tcx> {\n                         if let Some(target) = adj.unsize {\n                             target\n                         } else {\n-                            adjusted_ty.adjust_for_autoref(cx, adj.autoref)\n+                            adjusted_ty.adjust_for_autoref(tcx, adj.autoref)\n                         }\n                     }\n                 }\n@@ -215,7 +215,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     }\n \n     pub fn adjust_for_autoderef<F>(&'tcx self,\n-                                   cx: &TyCtxt<'tcx>,\n+                                   tcx: &TyCtxt<'tcx>,\n                                    expr_id: ast::NodeId,\n                                    expr_span: Span,\n                                    autoderef: u32, // how many autoderefs so far?\n@@ -228,7 +228,7 @@ impl<'tcx> ty::TyS<'tcx> {\n         if let Some(method_ty) = method_type(method_call) {\n             // Method calls always have all late-bound regions\n             // fully instantiated.\n-            let fn_ret = cx.no_late_bound_regions(&method_ty.fn_ret()).unwrap();\n+            let fn_ret = tcx.no_late_bound_regions(&method_ty.fn_ret()).unwrap();\n             adjusted_ty = fn_ret.unwrap();\n         }\n         match adjusted_ty.builtin_deref(true, NoPreference) {\n@@ -243,16 +243,16 @@ impl<'tcx> ty::TyS<'tcx> {\n         }\n     }\n \n-    pub fn adjust_for_autoref(&'tcx self, cx: &TyCtxt<'tcx>,\n+    pub fn adjust_for_autoref(&'tcx self, tcx: &TyCtxt<'tcx>,\n                               autoref: Option<AutoRef<'tcx>>)\n                               -> Ty<'tcx> {\n         match autoref {\n             None => self,\n             Some(AutoPtr(r, m)) => {\n-                cx.mk_ref(r, TypeAndMut { ty: self, mutbl: m })\n+                tcx.mk_ref(r, TypeAndMut { ty: self, mutbl: m })\n             }\n             Some(AutoUnsafe(m)) => {\n-                cx.mk_ptr(TypeAndMut { ty: self, mutbl: m })\n+                tcx.mk_ptr(TypeAndMut { ty: self, mutbl: m })\n             }\n         }\n     }"}, {"sha": "cae7f4d6444d392b635bd32a2044dff41666a531", "filename": "src/librustc/ty/contents.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b5122d5c4ca8eeed25008ff908df4dfb75b23ea5/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5122d5c4ca8eeed25008ff908df4dfb75b23ea5/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=b5122d5c4ca8eeed25008ff908df4dfb75b23ea5", "patch": "@@ -140,14 +140,14 @@ impl fmt::Debug for TypeContents {\n }\n \n impl<'tcx> ty::TyS<'tcx> {\n-    pub fn type_contents(&'tcx self, cx: &TyCtxt<'tcx>) -> TypeContents {\n-        return cx.tc_cache.memoize(self, || tc_ty(cx, self, &mut FnvHashMap()));\n+    pub fn type_contents(&'tcx self, tcx: &TyCtxt<'tcx>) -> TypeContents {\n+        return tcx.tc_cache.memoize(self, || tc_ty(tcx, self, &mut FnvHashMap()));\n \n-        fn tc_ty<'tcx>(cx: &TyCtxt<'tcx>,\n+        fn tc_ty<'tcx>(tcx: &TyCtxt<'tcx>,\n                        ty: Ty<'tcx>,\n                        cache: &mut FnvHashMap<Ty<'tcx>, TypeContents>) -> TypeContents\n         {\n-            // Subtle: Note that we are *not* using cx.tc_cache here but rather a\n+            // Subtle: Note that we are *not* using tcx.tc_cache here but rather a\n             // private cache for this walk.  This is needed in the case of cyclic\n             // types like:\n             //\n@@ -163,7 +163,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             // The problem is, as we are doing the computation, we will also\n             // compute an *intermediate* contents for, e.g., Option<List> of\n             // TC::None.  This is ok during the computation of List itself, but if\n-            // we stored this intermediate value into cx.tc_cache, then later\n+            // we stored this intermediate value into tcx.tc_cache, then later\n             // requests for the contents of Option<List> would also yield TC::None\n             // which is incorrect.  This value was computed based on the crutch\n             // value for the type contents of list.  The correct value is\n@@ -172,7 +172,7 @@ impl<'tcx> ty::TyS<'tcx> {\n                 Some(tc) => { return *tc; }\n                 None => {}\n             }\n-            match cx.tc_cache.borrow().get(&ty) {    // Must check both caches!\n+            match tcx.tc_cache.borrow().get(&ty) {    // Must check both caches!\n                 Some(tc) => { return *tc; }\n                 None => {}\n             }\n@@ -192,7 +192,7 @@ impl<'tcx> ty::TyS<'tcx> {\n                 }\n \n                 ty::TyBox(typ) => {\n-                    tc_ty(cx, typ, cache).owned_pointer()\n+                    tc_ty(tcx, typ, cache).owned_pointer()\n                 }\n \n                 ty::TyTrait(_) => {\n@@ -208,36 +208,36 @@ impl<'tcx> ty::TyS<'tcx> {\n                 }\n \n                 ty::TyArray(ty, _) => {\n-                    tc_ty(cx, ty, cache)\n+                    tc_ty(tcx, ty, cache)\n                 }\n \n                 ty::TySlice(ty) => {\n-                    tc_ty(cx, ty, cache)\n+                    tc_ty(tcx, ty, cache)\n                 }\n                 ty::TyStr => TC::None,\n \n                 ty::TyClosure(_, ref substs) => {\n-                    TypeContents::union(&substs.upvar_tys, |ty| tc_ty(cx, &ty, cache))\n+                    TypeContents::union(&substs.upvar_tys, |ty| tc_ty(tcx, &ty, cache))\n                 }\n \n                 ty::TyTuple(ref tys) => {\n                     TypeContents::union(&tys[..],\n-                                        |ty| tc_ty(cx, *ty, cache))\n+                                        |ty| tc_ty(tcx, *ty, cache))\n                 }\n \n                 ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n                     let mut res =\n                         TypeContents::union(&def.variants, |v| {\n                             TypeContents::union(&v.fields, |f| {\n-                                tc_ty(cx, f.ty(cx, substs), cache)\n+                                tc_ty(tcx, f.ty(tcx, substs), cache)\n                             })\n                         });\n \n                     if def.has_dtor() {\n                         res = res | TC::OwnsDtor;\n                     }\n \n-                    apply_lang_items(cx, def.did, res)\n+                    apply_lang_items(tcx, def.did, res)\n                 }\n \n                 ty::TyProjection(..) |\n@@ -255,9 +255,9 @@ impl<'tcx> ty::TyS<'tcx> {\n             result\n         }\n \n-        fn apply_lang_items(cx: &TyCtxt, did: DefId, tc: TypeContents)\n+        fn apply_lang_items(tcx: &TyCtxt, did: DefId, tc: TypeContents)\n                             -> TypeContents {\n-            if Some(did) == cx.lang_items.unsafe_cell_type() {\n+            if Some(did) == tcx.lang_items.unsafe_cell_type() {\n                 tc | TC::InteriorUnsafe\n             } else {\n                 tc"}, {"sha": "9dc61e513b52446b128b6eea1402071cc07ec227", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b5122d5c4ca8eeed25008ff908df4dfb75b23ea5/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5122d5c4ca8eeed25008ff908df4dfb75b23ea5/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=b5122d5c4ca8eeed25008ff908df4dfb75b23ea5", "patch": "@@ -211,13 +211,13 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n }\n \n impl<'tcx> ty::TyS<'tcx> {\n-    fn sort_string(&self, cx: &TyCtxt) -> String {\n+    fn sort_string(&self, tcx: &TyCtxt) -> String {\n         match self.sty {\n             ty::TyBool | ty::TyChar | ty::TyInt(_) |\n             ty::TyUint(_) | ty::TyFloat(_) | ty::TyStr => self.to_string(),\n             ty::TyTuple(ref tys) if tys.is_empty() => self.to_string(),\n \n-            ty::TyEnum(def, _) => format!(\"enum `{}`\", cx.item_path_str(def.did)),\n+            ty::TyEnum(def, _) => format!(\"enum `{}`\", tcx.item_path_str(def.did)),\n             ty::TyBox(_) => \"box\".to_string(),\n             ty::TyArray(_, n) => format!(\"array of {} elements\", n),\n             ty::TySlice(_) => \"slice\".to_string(),\n@@ -226,10 +226,10 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::TyFnDef(..) => format!(\"fn item\"),\n             ty::TyFnPtr(_) => \"fn pointer\".to_string(),\n             ty::TyTrait(ref inner) => {\n-                format!(\"trait {}\", cx.item_path_str(inner.principal_def_id()))\n+                format!(\"trait {}\", tcx.item_path_str(inner.principal_def_id()))\n             }\n             ty::TyStruct(def, _) => {\n-                format!(\"struct `{}`\", cx.item_path_str(def.did))\n+                format!(\"struct `{}`\", tcx.item_path_str(def.did))\n             }\n             ty::TyClosure(..) => \"closure\".to_string(),\n             ty::TyTuple(_) => \"tuple\".to_string(),"}, {"sha": "59fd6263c859b34703776710161dedf251e1f44d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 79, "deletions": 79, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/b5122d5c4ca8eeed25008ff908df4dfb75b23ea5/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5122d5c4ca8eeed25008ff908df4dfb75b23ea5/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=b5122d5c4ca8eeed25008ff908df4dfb75b23ea5", "patch": "@@ -1262,42 +1262,42 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n     }\n \n     /// Construct a parameter environment given an item, impl item, or trait item\n-    pub fn for_item(cx: &'a TyCtxt<'tcx>, id: NodeId) -> ParameterEnvironment<'a, 'tcx> {\n-        match cx.map.find(id) {\n+    pub fn for_item(tcx: &'a TyCtxt<'tcx>, id: NodeId) -> ParameterEnvironment<'a, 'tcx> {\n+        match tcx.map.find(id) {\n             Some(ast_map::NodeImplItem(ref impl_item)) => {\n                 match impl_item.node {\n                     hir::ImplItemKind::Type(_) => {\n                         // associated types don't have their own entry (for some reason),\n                         // so for now just grab environment for the impl\n-                        let impl_id = cx.map.get_parent(id);\n-                        let impl_def_id = cx.map.local_def_id(impl_id);\n-                        let scheme = cx.lookup_item_type(impl_def_id);\n-                        let predicates = cx.lookup_predicates(impl_def_id);\n-                        cx.construct_parameter_environment(impl_item.span,\n-                                                           &scheme.generics,\n-                                                           &predicates,\n-                                                           cx.region_maps.item_extent(id))\n+                        let impl_id = tcx.map.get_parent(id);\n+                        let impl_def_id = tcx.map.local_def_id(impl_id);\n+                        let scheme = tcx.lookup_item_type(impl_def_id);\n+                        let predicates = tcx.lookup_predicates(impl_def_id);\n+                        tcx.construct_parameter_environment(impl_item.span,\n+                                                            &scheme.generics,\n+                                                            &predicates,\n+                                                            tcx.region_maps.item_extent(id))\n                     }\n                     hir::ImplItemKind::Const(_, _) => {\n-                        let def_id = cx.map.local_def_id(id);\n-                        let scheme = cx.lookup_item_type(def_id);\n-                        let predicates = cx.lookup_predicates(def_id);\n-                        cx.construct_parameter_environment(impl_item.span,\n-                                                           &scheme.generics,\n-                                                           &predicates,\n-                                                           cx.region_maps.item_extent(id))\n+                        let def_id = tcx.map.local_def_id(id);\n+                        let scheme = tcx.lookup_item_type(def_id);\n+                        let predicates = tcx.lookup_predicates(def_id);\n+                        tcx.construct_parameter_environment(impl_item.span,\n+                                                            &scheme.generics,\n+                                                            &predicates,\n+                                                            tcx.region_maps.item_extent(id))\n                     }\n                     hir::ImplItemKind::Method(_, ref body) => {\n-                        let method_def_id = cx.map.local_def_id(id);\n-                        match cx.impl_or_trait_item(method_def_id) {\n+                        let method_def_id = tcx.map.local_def_id(id);\n+                        match tcx.impl_or_trait_item(method_def_id) {\n                             MethodTraitItem(ref method_ty) => {\n                                 let method_generics = &method_ty.generics;\n                                 let method_bounds = &method_ty.predicates;\n-                                cx.construct_parameter_environment(\n+                                tcx.construct_parameter_environment(\n                                     impl_item.span,\n                                     method_generics,\n                                     method_bounds,\n-                                    cx.region_maps.call_site_extent(id, body.id))\n+                                    tcx.region_maps.call_site_extent(id, body.id))\n                             }\n                             _ => {\n                                 bug!(\"ParameterEnvironment::for_item(): \\\n@@ -1312,41 +1312,41 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                     hir::TypeTraitItem(..) => {\n                         // associated types don't have their own entry (for some reason),\n                         // so for now just grab environment for the trait\n-                        let trait_id = cx.map.get_parent(id);\n-                        let trait_def_id = cx.map.local_def_id(trait_id);\n-                        let trait_def = cx.lookup_trait_def(trait_def_id);\n-                        let predicates = cx.lookup_predicates(trait_def_id);\n-                        cx.construct_parameter_environment(trait_item.span,\n-                                                           &trait_def.generics,\n-                                                           &predicates,\n-                                                           cx.region_maps.item_extent(id))\n+                        let trait_id = tcx.map.get_parent(id);\n+                        let trait_def_id = tcx.map.local_def_id(trait_id);\n+                        let trait_def = tcx.lookup_trait_def(trait_def_id);\n+                        let predicates = tcx.lookup_predicates(trait_def_id);\n+                        tcx.construct_parameter_environment(trait_item.span,\n+                                                            &trait_def.generics,\n+                                                            &predicates,\n+                                                            tcx.region_maps.item_extent(id))\n                     }\n                     hir::ConstTraitItem(..) => {\n-                        let def_id = cx.map.local_def_id(id);\n-                        let scheme = cx.lookup_item_type(def_id);\n-                        let predicates = cx.lookup_predicates(def_id);\n-                        cx.construct_parameter_environment(trait_item.span,\n-                                                           &scheme.generics,\n-                                                           &predicates,\n-                                                           cx.region_maps.item_extent(id))\n+                        let def_id = tcx.map.local_def_id(id);\n+                        let scheme = tcx.lookup_item_type(def_id);\n+                        let predicates = tcx.lookup_predicates(def_id);\n+                        tcx.construct_parameter_environment(trait_item.span,\n+                                                            &scheme.generics,\n+                                                            &predicates,\n+                                                            tcx.region_maps.item_extent(id))\n                     }\n                     hir::MethodTraitItem(_, ref body) => {\n                         // Use call-site for extent (unless this is a\n                         // trait method with no default; then fallback\n                         // to the method id).\n-                        let method_def_id = cx.map.local_def_id(id);\n-                        match cx.impl_or_trait_item(method_def_id) {\n+                        let method_def_id = tcx.map.local_def_id(id);\n+                        match tcx.impl_or_trait_item(method_def_id) {\n                             MethodTraitItem(ref method_ty) => {\n                                 let method_generics = &method_ty.generics;\n                                 let method_bounds = &method_ty.predicates;\n                                 let extent = if let Some(ref body) = *body {\n                                     // default impl: use call_site extent as free_id_outlive bound.\n-                                    cx.region_maps.call_site_extent(id, body.id)\n+                                    tcx.region_maps.call_site_extent(id, body.id)\n                                 } else {\n                                     // no default impl: use item extent as free_id_outlive bound.\n-                                    cx.region_maps.item_extent(id)\n+                                    tcx.region_maps.item_extent(id)\n                                 };\n-                                cx.construct_parameter_environment(\n+                                tcx.construct_parameter_environment(\n                                     trait_item.span,\n                                     method_generics,\n                                     method_bounds,\n@@ -1365,38 +1365,38 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                 match item.node {\n                     hir::ItemFn(_, _, _, _, _, ref body) => {\n                         // We assume this is a function.\n-                        let fn_def_id = cx.map.local_def_id(id);\n-                        let fn_scheme = cx.lookup_item_type(fn_def_id);\n-                        let fn_predicates = cx.lookup_predicates(fn_def_id);\n-\n-                        cx.construct_parameter_environment(item.span,\n-                                                           &fn_scheme.generics,\n-                                                           &fn_predicates,\n-                                                           cx.region_maps.call_site_extent(id,\n-                                                                                           body.id))\n+                        let fn_def_id = tcx.map.local_def_id(id);\n+                        let fn_scheme = tcx.lookup_item_type(fn_def_id);\n+                        let fn_predicates = tcx.lookup_predicates(fn_def_id);\n+\n+                        tcx.construct_parameter_environment(\n+                            item.span,\n+                            &fn_scheme.generics,\n+                            &fn_predicates,\n+                            tcx.region_maps.call_site_extent(id, body.id))\n                     }\n                     hir::ItemEnum(..) |\n                     hir::ItemStruct(..) |\n                     hir::ItemTy(..) |\n                     hir::ItemImpl(..) |\n                     hir::ItemConst(..) |\n                     hir::ItemStatic(..) => {\n-                        let def_id = cx.map.local_def_id(id);\n-                        let scheme = cx.lookup_item_type(def_id);\n-                        let predicates = cx.lookup_predicates(def_id);\n-                        cx.construct_parameter_environment(item.span,\n-                                                           &scheme.generics,\n-                                                           &predicates,\n-                                                           cx.region_maps.item_extent(id))\n+                        let def_id = tcx.map.local_def_id(id);\n+                        let scheme = tcx.lookup_item_type(def_id);\n+                        let predicates = tcx.lookup_predicates(def_id);\n+                        tcx.construct_parameter_environment(item.span,\n+                                                            &scheme.generics,\n+                                                            &predicates,\n+                                                            tcx.region_maps.item_extent(id))\n                     }\n                     hir::ItemTrait(..) => {\n-                        let def_id = cx.map.local_def_id(id);\n-                        let trait_def = cx.lookup_trait_def(def_id);\n-                        let predicates = cx.lookup_predicates(def_id);\n-                        cx.construct_parameter_environment(item.span,\n-                                                           &trait_def.generics,\n-                                                           &predicates,\n-                                                           cx.region_maps.item_extent(id))\n+                        let def_id = tcx.map.local_def_id(id);\n+                        let trait_def = tcx.lookup_trait_def(def_id);\n+                        let predicates = tcx.lookup_predicates(def_id);\n+                        tcx.construct_parameter_environment(item.span,\n+                                                            &trait_def.generics,\n+                                                            &predicates,\n+                                                            tcx.region_maps.item_extent(id))\n                     }\n                     _ => {\n                         span_bug!(item.span,\n@@ -1408,21 +1408,21 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n             }\n             Some(ast_map::NodeExpr(..)) => {\n                 // This is a convenience to allow closures to work.\n-                ParameterEnvironment::for_item(cx, cx.map.get_parent(id))\n+                ParameterEnvironment::for_item(tcx, tcx.map.get_parent(id))\n             }\n             Some(ast_map::NodeForeignItem(item)) => {\n-                let def_id = cx.map.local_def_id(id);\n-                let scheme = cx.lookup_item_type(def_id);\n-                let predicates = cx.lookup_predicates(def_id);\n-                cx.construct_parameter_environment(item.span,\n-                                                   &scheme.generics,\n-                                                   &predicates,\n-                                                   ROOT_CODE_EXTENT)\n+                let def_id = tcx.map.local_def_id(id);\n+                let scheme = tcx.lookup_item_type(def_id);\n+                let predicates = tcx.lookup_predicates(def_id);\n+                tcx.construct_parameter_environment(item.span,\n+                                                    &scheme.generics,\n+                                                    &predicates,\n+                                                    ROOT_CODE_EXTENT)\n             }\n             _ => {\n                 bug!(\"ParameterEnvironment::from_item(): \\\n                       `{}` is not an item\",\n-                     cx.map.node_to_string(id))\n+                     tcx.map.node_to_string(id))\n             }\n         }\n     }\n@@ -1996,19 +1996,19 @@ pub enum ClosureKind {\n }\n \n impl ClosureKind {\n-    pub fn trait_did(&self, cx: &TyCtxt) -> DefId {\n+    pub fn trait_did(&self, tcx: &TyCtxt) -> DefId {\n         let result = match *self {\n-            ClosureKind::Fn => cx.lang_items.require(FnTraitLangItem),\n+            ClosureKind::Fn => tcx.lang_items.require(FnTraitLangItem),\n             ClosureKind::FnMut => {\n-                cx.lang_items.require(FnMutTraitLangItem)\n+                tcx.lang_items.require(FnMutTraitLangItem)\n             }\n             ClosureKind::FnOnce => {\n-                cx.lang_items.require(FnOnceTraitLangItem)\n+                tcx.lang_items.require(FnOnceTraitLangItem)\n             }\n         };\n         match result {\n             Ok(trait_did) => trait_did,\n-            Err(err) => cx.sess.fatal(&err[..]),\n+            Err(err) => tcx.sess.fatal(&err[..]),\n         }\n     }\n \n@@ -2092,7 +2092,7 @@ impl LvaluePreference {\n }\n \n /// Helper for looking things up in the various maps that are populated during\n-/// typeck::collect (e.g., `cx.impl_or_trait_items`, `cx.tcache`, etc).  All of\n+/// typeck::collect (e.g., `tcx.impl_or_trait_items`, `tcx.tcache`, etc).  All of\n /// these share the pattern that if the id is local, it should have been loaded\n /// into the map by the `typeck::collect` phase.  If the def-id is external,\n /// then we have to go consult the crate loading code (and cache the result for"}, {"sha": "600ffc3da66529097fa421bffd3b3d213e54c7a4", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b5122d5c4ca8eeed25008ff908df4dfb75b23ea5/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5122d5c4ca8eeed25008ff908df4dfb75b23ea5/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=b5122d5c4ca8eeed25008ff908df4dfb75b23ea5", "patch": "@@ -974,18 +974,18 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn sequence_element_type(&self, cx: &TyCtxt<'tcx>) -> Ty<'tcx> {\n+    pub fn sequence_element_type(&self, tcx: &TyCtxt<'tcx>) -> Ty<'tcx> {\n         match self.sty {\n             TyArray(ty, _) | TySlice(ty) => ty,\n-            TyStr => cx.mk_mach_uint(ast::UintTy::U8),\n+            TyStr => tcx.mk_mach_uint(ast::UintTy::U8),\n             _ => bug!(\"sequence_element_type called on non-sequence value: {}\", self),\n         }\n     }\n \n-    pub fn simd_type(&self, cx: &TyCtxt<'tcx>) -> Ty<'tcx> {\n+    pub fn simd_type(&self, tcx: &TyCtxt<'tcx>) -> Ty<'tcx> {\n         match self.sty {\n             TyStruct(def, substs) => {\n-                def.struct_variant().fields[0].ty(cx, substs)\n+                def.struct_variant().fields[0].ty(tcx, substs)\n             }\n             _ => bug!(\"simd_type called on invalid type\")\n         }"}, {"sha": "fa95dea50a43605f15146f1f646f28609d1a7944", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b5122d5c4ca8eeed25008ff908df4dfb75b23ea5/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5122d5c4ca8eeed25008ff908df4dfb75b23ea5/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=b5122d5c4ca8eeed25008ff908df4dfb75b23ea5", "patch": "@@ -32,25 +32,25 @@ use syntax::codemap::Span;\n use hir;\n \n pub trait IntTypeExt {\n-    fn to_ty<'tcx>(&self, cx: &TyCtxt<'tcx>) -> Ty<'tcx>;\n+    fn to_ty<'tcx>(&self, tcx: &TyCtxt<'tcx>) -> Ty<'tcx>;\n     fn disr_incr(&self, val: Disr) -> Option<Disr>;\n     fn assert_ty_matches(&self, val: Disr);\n     fn initial_discriminant(&self, tcx: &TyCtxt) -> Disr;\n }\n \n impl IntTypeExt for attr::IntType {\n-    fn to_ty<'tcx>(&self, cx: &TyCtxt<'tcx>) -> Ty<'tcx> {\n+    fn to_ty<'tcx>(&self, tcx: &TyCtxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n-            SignedInt(ast::IntTy::I8)      => cx.types.i8,\n-            SignedInt(ast::IntTy::I16)     => cx.types.i16,\n-            SignedInt(ast::IntTy::I32)     => cx.types.i32,\n-            SignedInt(ast::IntTy::I64)     => cx.types.i64,\n-            SignedInt(ast::IntTy::Is)   => cx.types.isize,\n-            UnsignedInt(ast::UintTy::U8)    => cx.types.u8,\n-            UnsignedInt(ast::UintTy::U16)   => cx.types.u16,\n-            UnsignedInt(ast::UintTy::U32)   => cx.types.u32,\n-            UnsignedInt(ast::UintTy::U64)   => cx.types.u64,\n-            UnsignedInt(ast::UintTy::Us) => cx.types.usize,\n+            SignedInt(ast::IntTy::I8)      => tcx.types.i8,\n+            SignedInt(ast::IntTy::I16)     => tcx.types.i16,\n+            SignedInt(ast::IntTy::I32)     => tcx.types.i32,\n+            SignedInt(ast::IntTy::I64)     => tcx.types.i64,\n+            SignedInt(ast::IntTy::Is)   => tcx.types.isize,\n+            UnsignedInt(ast::UintTy::U8)    => tcx.types.u8,\n+            UnsignedInt(ast::UintTy::U16)   => tcx.types.u16,\n+            UnsignedInt(ast::UintTy::U32)   => tcx.types.u32,\n+            UnsignedInt(ast::UintTy::U64)   => tcx.types.u64,\n+            UnsignedInt(ast::UintTy::Us) => tcx.types.usize,\n         }\n     }\n \n@@ -620,35 +620,35 @@ impl<'tcx> ty::TyS<'tcx> {\n \n     /// Check whether a type is representable. This means it cannot contain unboxed\n     /// structural recursion. This check is needed for structs and enums.\n-    pub fn is_representable(&'tcx self, cx: &TyCtxt<'tcx>, sp: Span) -> Representability {\n+    pub fn is_representable(&'tcx self, tcx: &TyCtxt<'tcx>, sp: Span) -> Representability {\n \n         // Iterate until something non-representable is found\n-        fn find_nonrepresentable<'tcx, It: Iterator<Item=Ty<'tcx>>>(cx: &TyCtxt<'tcx>,\n+        fn find_nonrepresentable<'tcx, It: Iterator<Item=Ty<'tcx>>>(tcx: &TyCtxt<'tcx>,\n                                                                     sp: Span,\n                                                                     seen: &mut Vec<Ty<'tcx>>,\n                                                                     iter: It)\n                                                                     -> Representability {\n             iter.fold(Representability::Representable,\n-                      |r, ty| cmp::max(r, is_type_structurally_recursive(cx, sp, seen, ty)))\n+                      |r, ty| cmp::max(r, is_type_structurally_recursive(tcx, sp, seen, ty)))\n         }\n \n-        fn are_inner_types_recursive<'tcx>(cx: &TyCtxt<'tcx>, sp: Span,\n+        fn are_inner_types_recursive<'tcx>(tcx: &TyCtxt<'tcx>, sp: Span,\n                                            seen: &mut Vec<Ty<'tcx>>, ty: Ty<'tcx>)\n                                            -> Representability {\n             match ty.sty {\n                 TyTuple(ref ts) => {\n-                    find_nonrepresentable(cx, sp, seen, ts.iter().cloned())\n+                    find_nonrepresentable(tcx, sp, seen, ts.iter().cloned())\n                 }\n                 // Fixed-length vectors.\n                 // FIXME(#11924) Behavior undecided for zero-length vectors.\n                 TyArray(ty, _) => {\n-                    is_type_structurally_recursive(cx, sp, seen, ty)\n+                    is_type_structurally_recursive(tcx, sp, seen, ty)\n                 }\n                 TyStruct(def, substs) | TyEnum(def, substs) => {\n-                    find_nonrepresentable(cx,\n+                    find_nonrepresentable(tcx,\n                                           sp,\n                                           seen,\n-                                          def.all_fields().map(|f| f.ty(cx, substs)))\n+                                          def.all_fields().map(|f| f.ty(tcx, substs)))\n                 }\n                 TyClosure(..) => {\n                     // this check is run on type definitions, so we don't expect\n@@ -691,7 +691,7 @@ impl<'tcx> ty::TyS<'tcx> {\n \n         // Does the type `ty` directly (without indirection through a pointer)\n         // contain any types on stack `seen`?\n-        fn is_type_structurally_recursive<'tcx>(cx: &TyCtxt<'tcx>,\n+        fn is_type_structurally_recursive<'tcx>(tcx: &TyCtxt<'tcx>,\n                                                 sp: Span,\n                                                 seen: &mut Vec<Ty<'tcx>>,\n                                                 ty: Ty<'tcx>) -> Representability {\n@@ -746,13 +746,13 @@ impl<'tcx> ty::TyS<'tcx> {\n                     // For structs and enums, track all previously seen types by pushing them\n                     // onto the 'seen' stack.\n                     seen.push(ty);\n-                    let out = are_inner_types_recursive(cx, sp, seen, ty);\n+                    let out = are_inner_types_recursive(tcx, sp, seen, ty);\n                     seen.pop();\n                     out\n                 }\n                 _ => {\n                     // No need to push in other cases.\n-                    are_inner_types_recursive(cx, sp, seen, ty)\n+                    are_inner_types_recursive(tcx, sp, seen, ty)\n                 }\n             }\n         }\n@@ -763,7 +763,7 @@ impl<'tcx> ty::TyS<'tcx> {\n         // contains a different, structurally recursive type, maintain a stack\n         // of seen types and check recursion for each of them (issues #3008, #3779).\n         let mut seen: Vec<Ty> = Vec::new();\n-        let r = is_type_structurally_recursive(cx, sp, &mut seen, self);\n+        let r = is_type_structurally_recursive(tcx, sp, &mut seen, self);\n         debug!(\"is_type_representable: {:?} is {:?}\", self, r);\n         r\n     }"}, {"sha": "0902c7497fecd34416015d11b45ed059ae084cfa", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5122d5c4ca8eeed25008ff908df4dfb75b23ea5/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5122d5c4ca8eeed25008ff908df4dfb75b23ea5/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=b5122d5c4ca8eeed25008ff908df4dfb75b23ea5", "patch": "@@ -62,12 +62,12 @@ pub fn type_is_sized<'tcx>(tcx: &TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     ty.is_sized(&tcx.empty_parameter_environment(), DUMMY_SP)\n }\n \n-pub fn type_is_fat_ptr<'tcx>(cx: &TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n+pub fn type_is_fat_ptr<'tcx>(tcx: &TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n         ty::TyRawPtr(ty::TypeAndMut{ty, ..}) |\n         ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n         ty::TyBox(ty) => {\n-            !type_is_sized(cx, ty)\n+            !type_is_sized(tcx, ty)\n         }\n         _ => {\n             false"}, {"sha": "2fff091f20c0a08a77b3f24697bff9b5d8efd824", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5122d5c4ca8eeed25008ff908df4dfb75b23ea5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5122d5c4ca8eeed25008ff908df4dfb75b23ea5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b5122d5c4ca8eeed25008ff908df4dfb75b23ea5", "patch": "@@ -4791,7 +4791,7 @@ pub fn structurally_resolved_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n }\n \n // Returns true if b contains a break that can exit from b\n-pub fn may_break(cx: &TyCtxt, id: ast::NodeId, b: &hir::Block) -> bool {\n+pub fn may_break(tcx: &TyCtxt, id: ast::NodeId, b: &hir::Block) -> bool {\n     // First: is there an unlabeled break immediately\n     // inside the loop?\n     (loop_query(&b, |e| {\n@@ -4804,7 +4804,7 @@ pub fn may_break(cx: &TyCtxt, id: ast::NodeId, b: &hir::Block) -> bool {\n     // <id> nested anywhere inside the loop?\n     (block_query(b, |e| {\n         if let hir::ExprBreak(Some(_)) = e.node {\n-            lookup_full_def(cx, e.span, e.id) == Def::Label(id)\n+            lookup_full_def(tcx, e.span, e.id) == Def::Label(id)\n         } else {\n             false\n         }"}]}