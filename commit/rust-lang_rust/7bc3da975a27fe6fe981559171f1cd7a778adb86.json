{"sha": "7bc3da975a27fe6fe981559171f1cd7a778adb86", "node_id": "C_kwDOAAsO6NoAKDdiYzNkYTk3NWEyN2ZlNmZlOTgxNTU5MTcxZjFjZDdhNzc4YWRiODY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-29T17:57:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-29T17:57:25Z"}, "message": "Auto merge of #10647 - y21:while_pop_unwrap, r=llogiq\n\nnew lint: `manual_while_let_some`\n\nThis PR implements the lint I suggested [on zulip](https://rust-lang.zulipchat.com/#narrow/stream/257328-clippy/topic/lint.20on.20while.20pop.20unwrap).\nIt looks for while loops like these:\n```rs\nlet mut numbers = vec![0, 1, 2];\nwhile !numbers.is_empty() {\n  let number = numbers.pop().unwrap();\n  // use `number`\n}\n```\nand suggests replacing it with a while-let loop, like this:\n```rs\nlet mut numbers = vec![0, 1, 2];\nwhile let Some(number) = numbers.pop() {\n  // use `number`\n}\n```\n... which is more concise and idiomatic.\n\nIt only looks for `Vec::pop()` calls in the first statement of the loop body in an attempt to not trigger FPs (as pop might only be called conditionally).\n\nchangelog: new lint [`manual_while_let_some`]", "tree": {"sha": "bb436c0f1c7f1535428a7bc0926c03e54049f4a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb436c0f1c7f1535428a7bc0926c03e54049f4a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bc3da975a27fe6fe981559171f1cd7a778adb86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bc3da975a27fe6fe981559171f1cd7a778adb86", "html_url": "https://github.com/rust-lang/rust/commit/7bc3da975a27fe6fe981559171f1cd7a778adb86", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bc3da975a27fe6fe981559171f1cd7a778adb86/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3594d55439410b9426a4eb81b125b750b1dea36d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3594d55439410b9426a4eb81b125b750b1dea36d", "html_url": "https://github.com/rust-lang/rust/commit/3594d55439410b9426a4eb81b125b750b1dea36d"}, {"sha": "9613ea85c65c8c4f75b443e061739c82f75e317d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9613ea85c65c8c4f75b443e061739c82f75e317d", "html_url": "https://github.com/rust-lang/rust/commit/9613ea85c65c8c4f75b443e061739c82f75e317d"}], "stats": {"total": 432, "additions": 428, "deletions": 4}, "files": [{"sha": "d1e98a93940d6abdbc7c7023e0bcc8cc67e07cab", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7bc3da975a27fe6fe981559171f1cd7a778adb86/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/7bc3da975a27fe6fe981559171f1cd7a778adb86/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=7bc3da975a27fe6fe981559171f1cd7a778adb86", "patch": "@@ -4797,6 +4797,7 @@ Released 2018-09-13\n [`manual_strip`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_strip\n [`manual_swap`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_swap\n [`manual_unwrap_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_unwrap_or\n+[`manual_while_let_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_while_let_some\n [`many_single_char_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#many_single_char_names\n [`map_clone`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_clone\n [`map_collect_result_unit`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_collect_result_unit"}, {"sha": "44e725be710e037d733c9062db6387c1534f4205", "filename": "clippy_lints/src/declared_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7bc3da975a27fe6fe981559171f1cd7a778adb86/clippy_lints%2Fsrc%2Fdeclared_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc3da975a27fe6fe981559171f1cd7a778adb86/clippy_lints%2Fsrc%2Fdeclared_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdeclared_lints.rs?ref=7bc3da975a27fe6fe981559171f1cd7a778adb86", "patch": "@@ -249,6 +249,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::loops::MANUAL_FIND_INFO,\n     crate::loops::MANUAL_FLATTEN_INFO,\n     crate::loops::MANUAL_MEMCPY_INFO,\n+    crate::loops::MANUAL_WHILE_LET_SOME_INFO,\n     crate::loops::MISSING_SPIN_LOOP_INFO,\n     crate::loops::MUT_RANGE_BOUND_INFO,\n     crate::loops::NEEDLESS_RANGE_LOOP_INFO,"}, {"sha": "cb9c84be4c7a695fbd481f088cc218b4db4dece0", "filename": "clippy_lints/src/loops/manual_while_let_some.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/7bc3da975a27fe6fe981559171f1cd7a778adb86/clippy_lints%2Fsrc%2Floops%2Fmanual_while_let_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc3da975a27fe6fe981559171f1cd7a778adb86/clippy_lints%2Fsrc%2Floops%2Fmanual_while_let_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_while_let_some.rs?ref=7bc3da975a27fe6fe981559171f1cd7a778adb86", "patch": "@@ -0,0 +1,110 @@\n+use clippy_utils::{\n+    diagnostics::{multispan_sugg_with_applicability, span_lint_and_then},\n+    match_def_path, paths,\n+    source::snippet,\n+    SpanlessEq,\n+};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, Pat, Stmt, StmtKind, UnOp};\n+use rustc_lint::LateContext;\n+use rustc_span::Span;\n+use std::borrow::Cow;\n+\n+use super::MANUAL_WHILE_LET_SOME;\n+\n+/// The kind of statement that the `pop()` call appeared in.\n+///\n+/// Depending on whether the value was assigned to a variable or not changes what pattern\n+/// we use for the suggestion.\n+#[derive(Copy, Clone)]\n+enum PopStmt<'hir> {\n+    /// `x.pop().unwrap()` was and assigned to a variable.\n+    /// The pattern of this local variable will be used and the local statement\n+    /// is deleted in the suggestion.\n+    Local(&'hir Pat<'hir>),\n+    /// `x.pop().unwrap()` appeared in an arbitrary expression and was not assigned to a variable.\n+    /// The suggestion will use some placeholder identifier and the `x.pop().unwrap()` expression\n+    /// is replaced with that identifier.\n+    Anonymous,\n+}\n+\n+fn report_lint(cx: &LateContext<'_>, pop_span: Span, pop_stmt_kind: PopStmt<'_>, loop_span: Span, receiver_span: Span) {\n+    span_lint_and_then(\n+        cx,\n+        MANUAL_WHILE_LET_SOME,\n+        pop_span,\n+        \"you seem to be trying to pop elements from a `Vec` in a loop\",\n+        |diag| {\n+            let (pat, pop_replacement) = match pop_stmt_kind {\n+                PopStmt::Local(pat) => (snippet(cx, pat.span, \"..\"), String::new()),\n+                PopStmt::Anonymous => (Cow::Borrowed(\"element\"), \"element\".into()),\n+            };\n+\n+            let loop_replacement = format!(\"while let Some({}) = {}.pop()\", pat, snippet(cx, receiver_span, \"..\"));\n+            multispan_sugg_with_applicability(\n+                diag,\n+                \"consider using a `while..let` loop\",\n+                Applicability::MachineApplicable,\n+                [(loop_span, loop_replacement), (pop_span, pop_replacement)],\n+            );\n+        },\n+    );\n+}\n+\n+fn match_method_call(cx: &LateContext<'_>, expr: &Expr<'_>, method: &[&str]) -> bool {\n+    if let ExprKind::MethodCall(..) = expr.kind\n+        && let Some(id) = cx.typeck_results().type_dependent_def_id(expr.hir_id)\n+    {\n+        match_def_path(cx, id, method)\n+    } else {\n+        false\n+    }\n+}\n+\n+fn is_vec_pop_unwrap(cx: &LateContext<'_>, expr: &Expr<'_>, is_empty_recv: &Expr<'_>) -> bool {\n+    if (match_method_call(cx, expr, &paths::OPTION_UNWRAP) || match_method_call(cx, expr, &paths::OPTION_EXPECT))\n+        && let ExprKind::MethodCall(_, unwrap_recv, ..) = expr.kind\n+        && match_method_call(cx, unwrap_recv, &paths::VEC_POP)\n+        && let ExprKind::MethodCall(_, pop_recv, ..) = unwrap_recv.kind\n+    {\n+        // make sure they're the same `Vec`\n+        SpanlessEq::new(cx).eq_expr(pop_recv, is_empty_recv)\n+    } else {\n+        false\n+    }\n+}\n+\n+fn check_local(cx: &LateContext<'_>, stmt: &Stmt<'_>, is_empty_recv: &Expr<'_>, loop_span: Span) {\n+    if let StmtKind::Local(local) = stmt.kind\n+        && let Some(init) = local.init\n+        && is_vec_pop_unwrap(cx, init, is_empty_recv)\n+    {\n+        report_lint(cx, stmt.span, PopStmt::Local(local.pat), loop_span, is_empty_recv.span);\n+    }\n+}\n+\n+fn check_call_arguments(cx: &LateContext<'_>, stmt: &Stmt<'_>, is_empty_recv: &Expr<'_>, loop_span: Span) {\n+    if let StmtKind::Semi(expr) | StmtKind::Expr(expr) = stmt.kind {\n+        if let ExprKind::MethodCall(.., args, _) | ExprKind::Call(_, args) = expr.kind {\n+            let offending_arg = args\n+                .iter()\n+                .find_map(|arg| is_vec_pop_unwrap(cx, arg, is_empty_recv).then_some(arg.span));\n+\n+            if let Some(offending_arg) = offending_arg {\n+                report_lint(cx, offending_arg, PopStmt::Anonymous, loop_span, is_empty_recv.span);\n+            }\n+        }\n+    }\n+}\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, full_cond: &'tcx Expr<'_>, body: &'tcx Expr<'_>, loop_span: Span) {\n+    if let ExprKind::Unary(UnOp::Not, cond) = full_cond.kind\n+        && let ExprKind::MethodCall(_, is_empty_recv, _, _) = cond.kind\n+        && match_method_call(cx, cond, &paths::VEC_IS_EMPTY)\n+        && let ExprKind::Block(body, _) = body.kind\n+        && let Some(stmt) = body.stmts.first()\n+    {\n+        check_local(cx, stmt, is_empty_recv, loop_span);\n+        check_call_arguments(cx, stmt, is_empty_recv, loop_span);\n+    }\n+}"}, {"sha": "f83ad388a742fc4d5916f4bc216de4d4b6c1f724", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7bc3da975a27fe6fe981559171f1cd7a778adb86/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc3da975a27fe6fe981559171f1cd7a778adb86/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=7bc3da975a27fe6fe981559171f1cd7a778adb86", "patch": "@@ -7,6 +7,7 @@ mod iter_next_loop;\n mod manual_find;\n mod manual_flatten;\n mod manual_memcpy;\n+mod manual_while_let_some;\n mod missing_spin_loop;\n mod mut_range_bound;\n mod needless_range_loop;\n@@ -575,6 +576,36 @@ declare_clippy_lint! {\n     \"manual implementation of `Iterator::find`\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Looks for loops that check for emptiness of a `Vec` in the condition and pop an element\n+    /// in the body as a separate operation.\n+    ///\n+    /// ### Why is this bad?\n+    /// Such loops can be written in a more idiomatic way by using a while-let loop and directly\n+    /// pattern matching on the return value of `Vec::pop()`.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let mut numbers = vec![1, 2, 3, 4, 5];\n+    /// while !numbers.is_empty() {\n+    ///     let number = numbers.pop().unwrap();\n+    ///     // use `number`\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let mut numbers = vec![1, 2, 3, 4, 5];\n+    /// while let Some(number) = numbers.pop() {\n+    ///     // use `number`\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.70.0\"]\n+    pub MANUAL_WHILE_LET_SOME,\n+    style,\n+    \"checking for emptiness of a `Vec` in the loop condition and popping an element in the body\"\n+}\n+\n declare_lint_pass!(Loops => [\n     MANUAL_MEMCPY,\n     MANUAL_FLATTEN,\n@@ -594,6 +625,7 @@ declare_lint_pass!(Loops => [\n     SINGLE_ELEMENT_LOOP,\n     MISSING_SPIN_LOOP,\n     MANUAL_FIND,\n+    MANUAL_WHILE_LET_SOME\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Loops {\n@@ -640,9 +672,10 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n \n         while_let_on_iterator::check(cx, expr);\n \n-        if let Some(higher::While { condition, body }) = higher::While::hir(expr) {\n+        if let Some(higher::While { condition, body, span }) = higher::While::hir(expr) {\n             while_immutable_condition::check(cx, condition, body);\n             missing_spin_loop::check(cx, condition, body);\n+            manual_while_let_some::check(cx, condition, body, span);\n         }\n     }\n }"}, {"sha": "108077b9d1588420d3cbeacc7f2e9d8be075d571", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc3da975a27fe6fe981559171f1cd7a778adb86/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc3da975a27fe6fe981559171f1cd7a778adb86/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=7bc3da975a27fe6fe981559171f1cd7a778adb86", "patch": "@@ -333,7 +333,7 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n \n     #[allow(clippy::too_many_lines)]\n     fn expr(&self, expr: &Binding<&hir::Expr<'_>>) {\n-        if let Some(higher::While { condition, body }) = higher::While::hir(expr.value) {\n+        if let Some(higher::While { condition, body, .. }) = higher::While::hir(expr.value) {\n             bind!(self, condition, body);\n             chain!(\n                 self,"}, {"sha": "a61e4c380886d3401267bfbc7bf94479a00c5a0c", "filename": "clippy_utils/src/higher.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bc3da975a27fe6fe981559171f1cd7a778adb86/clippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc3da975a27fe6fe981559171f1cd7a778adb86/clippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhigher.rs?ref=7bc3da975a27fe6fe981559171f1cd7a778adb86", "patch": "@@ -311,6 +311,8 @@ pub struct While<'hir> {\n     pub condition: &'hir Expr<'hir>,\n     /// `while` loop body\n     pub body: &'hir Expr<'hir>,\n+    /// Span of the loop header\n+    pub span: Span,\n }\n \n impl<'hir> While<'hir> {\n@@ -336,10 +338,10 @@ impl<'hir> While<'hir> {\n             },\n             _,\n             LoopSource::While,\n-            _,\n+            span,\n         ) = expr.kind\n         {\n-            return Some(Self { condition, body });\n+            return Some(Self { condition, body, span });\n         }\n         None\n     }"}, {"sha": "0f0792fdaa963f366061124a3bf309bee63892ec", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bc3da975a27fe6fe981559171f1cd7a778adb86/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc3da975a27fe6fe981559171f1cd7a778adb86/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=7bc3da975a27fe6fe981559171f1cd7a778adb86", "patch": "@@ -159,3 +159,7 @@ pub const WEAK_RC: [&str; 3] = [\"alloc\", \"rc\", \"Weak\"];\n pub const PTR_NON_NULL: [&str; 4] = [\"core\", \"ptr\", \"non_null\", \"NonNull\"];\n pub const INSTANT_NOW: [&str; 4] = [\"std\", \"time\", \"Instant\", \"now\"];\n pub const INSTANT: [&str; 3] = [\"std\", \"time\", \"Instant\"];\n+pub const VEC_IS_EMPTY: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"is_empty\"];\n+pub const VEC_POP: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"pop\"];\n+pub const OPTION_UNWRAP: [&str; 4] = [\"core\", \"option\", \"Option\", \"unwrap\"];\n+pub const OPTION_EXPECT: [&str; 4] = [\"core\", \"option\", \"Option\", \"expect\"];"}, {"sha": "8b610919536c0fc26a827b8c722d71bb078de434", "filename": "tests/ui/manual_while_let_some.fixed", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/7bc3da975a27fe6fe981559171f1cd7a778adb86/tests%2Fui%2Fmanual_while_let_some.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7bc3da975a27fe6fe981559171f1cd7a778adb86/tests%2Fui%2Fmanual_while_let_some.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_while_let_some.fixed?ref=7bc3da975a27fe6fe981559171f1cd7a778adb86", "patch": "@@ -0,0 +1,93 @@\n+//@run-rustfix\n+\n+#![allow(unused)]\n+#![warn(clippy::manual_while_let_some)]\n+\n+struct VecInStruct {\n+    numbers: Vec<i32>,\n+    unrelated: String,\n+}\n+\n+struct Foo {\n+    a: i32,\n+    b: i32,\n+}\n+\n+fn accept_i32(_: i32) {}\n+fn accept_optional_i32(_: Option<i32>) {}\n+fn accept_i32_tuple(_: (i32, i32)) {}\n+\n+fn main() {\n+    let mut numbers = vec![1, 2, 3, 4, 5];\n+    while let Some(number) = numbers.pop() {\n+        \n+    }\n+\n+    let mut val = VecInStruct {\n+        numbers: vec![1, 2, 3, 4, 5],\n+        unrelated: String::new(),\n+    };\n+    while let Some(number) = val.numbers.pop() {\n+        \n+    }\n+\n+    while let Some(element) = numbers.pop() {\n+        accept_i32(element);\n+    }\n+\n+    while let Some(element) = numbers.pop() {\n+        accept_i32(element);\n+    }\n+\n+    // This should not warn. It \"conditionally\" pops elements.\n+    while !numbers.is_empty() {\n+        if true {\n+            accept_i32(numbers.pop().unwrap());\n+        }\n+    }\n+\n+    // This should also not warn. It conditionally pops elements.\n+    while !numbers.is_empty() {\n+        if false {\n+            continue;\n+        }\n+        accept_i32(numbers.pop().unwrap());\n+    }\n+\n+    // This should not warn. It pops elements, but does not unwrap it.\n+    // Might handle the Option in some other arbitrary way.\n+    while !numbers.is_empty() {\n+        accept_optional_i32(numbers.pop());\n+    }\n+\n+    let unrelated_vec: Vec<String> = Vec::new();\n+    // This should not warn. It pops elements from a different vector.\n+    while !unrelated_vec.is_empty() {\n+        accept_i32(numbers.pop().unwrap());\n+    }\n+\n+    macro_rules! generate_loop {\n+        () => {\n+            while !numbers.is_empty() {\n+                accept_i32(numbers.pop().unwrap());\n+            }\n+        };\n+    }\n+    // Do not warn if the loop comes from a macro.\n+    generate_loop!();\n+\n+    // Try other kinds of patterns\n+    let mut numbers = vec![(0, 0), (1, 1), (2, 2)];\n+    while let Some((a, b)) = numbers.pop() {\n+        \n+    }\n+\n+    while let Some(element) = numbers.pop() {\n+        accept_i32_tuple(element);\n+    }\n+\n+    let mut results = vec![Foo { a: 1, b: 2 }, Foo { a: 3, b: 4 }];\n+    while let Some(Foo { a, b }) = results.pop() {\n+        \n+    }\n+}"}, {"sha": "85a0a084a424ff8d7624b712dc2c049c70142111", "filename": "tests/ui/manual_while_let_some.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/7bc3da975a27fe6fe981559171f1cd7a778adb86/tests%2Fui%2Fmanual_while_let_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc3da975a27fe6fe981559171f1cd7a778adb86/tests%2Fui%2Fmanual_while_let_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_while_let_some.rs?ref=7bc3da975a27fe6fe981559171f1cd7a778adb86", "patch": "@@ -0,0 +1,93 @@\n+//@run-rustfix\n+\n+#![allow(unused)]\n+#![warn(clippy::manual_while_let_some)]\n+\n+struct VecInStruct {\n+    numbers: Vec<i32>,\n+    unrelated: String,\n+}\n+\n+struct Foo {\n+    a: i32,\n+    b: i32,\n+}\n+\n+fn accept_i32(_: i32) {}\n+fn accept_optional_i32(_: Option<i32>) {}\n+fn accept_i32_tuple(_: (i32, i32)) {}\n+\n+fn main() {\n+    let mut numbers = vec![1, 2, 3, 4, 5];\n+    while !numbers.is_empty() {\n+        let number = numbers.pop().unwrap();\n+    }\n+\n+    let mut val = VecInStruct {\n+        numbers: vec![1, 2, 3, 4, 5],\n+        unrelated: String::new(),\n+    };\n+    while !val.numbers.is_empty() {\n+        let number = val.numbers.pop().unwrap();\n+    }\n+\n+    while !numbers.is_empty() {\n+        accept_i32(numbers.pop().unwrap());\n+    }\n+\n+    while !numbers.is_empty() {\n+        accept_i32(numbers.pop().expect(\"\"));\n+    }\n+\n+    // This should not warn. It \"conditionally\" pops elements.\n+    while !numbers.is_empty() {\n+        if true {\n+            accept_i32(numbers.pop().unwrap());\n+        }\n+    }\n+\n+    // This should also not warn. It conditionally pops elements.\n+    while !numbers.is_empty() {\n+        if false {\n+            continue;\n+        }\n+        accept_i32(numbers.pop().unwrap());\n+    }\n+\n+    // This should not warn. It pops elements, but does not unwrap it.\n+    // Might handle the Option in some other arbitrary way.\n+    while !numbers.is_empty() {\n+        accept_optional_i32(numbers.pop());\n+    }\n+\n+    let unrelated_vec: Vec<String> = Vec::new();\n+    // This should not warn. It pops elements from a different vector.\n+    while !unrelated_vec.is_empty() {\n+        accept_i32(numbers.pop().unwrap());\n+    }\n+\n+    macro_rules! generate_loop {\n+        () => {\n+            while !numbers.is_empty() {\n+                accept_i32(numbers.pop().unwrap());\n+            }\n+        };\n+    }\n+    // Do not warn if the loop comes from a macro.\n+    generate_loop!();\n+\n+    // Try other kinds of patterns\n+    let mut numbers = vec![(0, 0), (1, 1), (2, 2)];\n+    while !numbers.is_empty() {\n+        let (a, b) = numbers.pop().unwrap();\n+    }\n+\n+    while !numbers.is_empty() {\n+        accept_i32_tuple(numbers.pop().unwrap());\n+    }\n+\n+    let mut results = vec![Foo { a: 1, b: 2 }, Foo { a: 3, b: 4 }];\n+    while !results.is_empty() {\n+        let Foo { a, b } = results.pop().unwrap();\n+    }\n+}"}, {"sha": "633fe05c49b840c62c03045c1003822edcd020fb", "filename": "tests/ui/manual_while_let_some.stderr", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/7bc3da975a27fe6fe981559171f1cd7a778adb86/tests%2Fui%2Fmanual_while_let_some.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7bc3da975a27fe6fe981559171f1cd7a778adb86/tests%2Fui%2Fmanual_while_let_some.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_while_let_some.stderr?ref=7bc3da975a27fe6fe981559171f1cd7a778adb86", "patch": "@@ -0,0 +1,87 @@\n+error: you seem to be trying to pop elements from a `Vec` in a loop\n+  --> $DIR/manual_while_let_some.rs:23:9\n+   |\n+LL |         let number = numbers.pop().unwrap();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::manual-while-let-some` implied by `-D warnings`\n+help: consider using a `while..let` loop\n+   |\n+LL ~     while let Some(number) = numbers.pop() {\n+LL ~         \n+   |\n+\n+error: you seem to be trying to pop elements from a `Vec` in a loop\n+  --> $DIR/manual_while_let_some.rs:31:9\n+   |\n+LL |         let number = val.numbers.pop().unwrap();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider using a `while..let` loop\n+   |\n+LL ~     while let Some(number) = val.numbers.pop() {\n+LL ~         \n+   |\n+\n+error: you seem to be trying to pop elements from a `Vec` in a loop\n+  --> $DIR/manual_while_let_some.rs:35:20\n+   |\n+LL |         accept_i32(numbers.pop().unwrap());\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider using a `while..let` loop\n+   |\n+LL ~     while let Some(element) = numbers.pop() {\n+LL ~         accept_i32(element);\n+   |\n+\n+error: you seem to be trying to pop elements from a `Vec` in a loop\n+  --> $DIR/manual_while_let_some.rs:39:20\n+   |\n+LL |         accept_i32(numbers.pop().expect(\"\"));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider using a `while..let` loop\n+   |\n+LL ~     while let Some(element) = numbers.pop() {\n+LL ~         accept_i32(element);\n+   |\n+\n+error: you seem to be trying to pop elements from a `Vec` in a loop\n+  --> $DIR/manual_while_let_some.rs:82:9\n+   |\n+LL |         let (a, b) = numbers.pop().unwrap();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider using a `while..let` loop\n+   |\n+LL ~     while let Some((a, b)) = numbers.pop() {\n+LL ~         \n+   |\n+\n+error: you seem to be trying to pop elements from a `Vec` in a loop\n+  --> $DIR/manual_while_let_some.rs:86:26\n+   |\n+LL |         accept_i32_tuple(numbers.pop().unwrap());\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider using a `while..let` loop\n+   |\n+LL ~     while let Some(element) = numbers.pop() {\n+LL ~         accept_i32_tuple(element);\n+   |\n+\n+error: you seem to be trying to pop elements from a `Vec` in a loop\n+  --> $DIR/manual_while_let_some.rs:91:9\n+   |\n+LL |         let Foo { a, b } = results.pop().unwrap();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider using a `while..let` loop\n+   |\n+LL ~     while let Some(Foo { a, b }) = results.pop() {\n+LL ~         \n+   |\n+\n+error: aborting due to 7 previous errors\n+"}]}