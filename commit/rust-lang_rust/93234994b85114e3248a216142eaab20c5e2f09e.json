{"sha": "93234994b85114e3248a216142eaab20c5e2f09e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzMjM0OTk0Yjg1MTE0ZTMyNDhhMjE2MTQyZWFhYjIwYzVlMmYwOWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-19T15:52:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-19T15:52:58Z"}, "message": "Auto merge of #57755 - Centril:rollup, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #57486 (Simplify `TokenStream` some more)\n - #57502 (make trait-aliases work across crates)\n - #57598 (Add missing unpretty option help message)\n - #57649 (privacy: Account for associated existential types)\n - #57659 (Fix release manifest generation)\n - #57699 (add applicability to remaining suggestions)\n - #57719 (Tweak `expand_node`)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "eca4e8e2fd328188435bd8911b99a5acc2f75c2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eca4e8e2fd328188435bd8911b99a5acc2f75c2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93234994b85114e3248a216142eaab20c5e2f09e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93234994b85114e3248a216142eaab20c5e2f09e", "html_url": "https://github.com/rust-lang/rust/commit/93234994b85114e3248a216142eaab20c5e2f09e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93234994b85114e3248a216142eaab20c5e2f09e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "286ac62939e26d56103dc1d7ddf5113650c5e42f", "url": "https://api.github.com/repos/rust-lang/rust/commits/286ac62939e26d56103dc1d7ddf5113650c5e42f", "html_url": "https://github.com/rust-lang/rust/commit/286ac62939e26d56103dc1d7ddf5113650c5e42f"}, {"sha": "92fecfbd6066c84d6cfbae2db77f8fd0c7235893", "url": "https://api.github.com/repos/rust-lang/rust/commits/92fecfbd6066c84d6cfbae2db77f8fd0c7235893", "html_url": "https://github.com/rust-lang/rust/commit/92fecfbd6066c84d6cfbae2db77f8fd0c7235893"}], "stats": {"total": 785, "additions": 477, "deletions": 308}, "files": [{"sha": "c9b4b2bb997178184d8a5dc8eaa5f2620f103cab", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -120,10 +120,10 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         let def_data = match i.node {\n             ItemKind::Impl(..) => DefPathData::Impl,\n             ItemKind::Trait(..) => DefPathData::Trait(i.ident.as_interned_str()),\n+            ItemKind::TraitAlias(..) => DefPathData::TraitAlias(i.ident.as_interned_str()),\n             ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Union(..) |\n-            ItemKind::TraitAlias(..) | ItemKind::Existential(..) |\n-            ItemKind::ExternCrate(..) | ItemKind::ForeignMod(..) | ItemKind::Ty(..) =>\n-                DefPathData::TypeNs(i.ident.as_interned_str()),\n+            ItemKind::Existential(..) | ItemKind::ExternCrate(..) | ItemKind::ForeignMod(..) |\n+            ItemKind::Ty(..) => DefPathData::TypeNs(i.ident.as_interned_str()),\n             ItemKind::Mod(..) if i.ident == keywords::Invalid.ident() => {\n                 return visit::walk_item(self, i);\n             }"}, {"sha": "1b7445199475c4ccaf215afc2336fad9681148c9", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -373,7 +373,9 @@ pub enum DefPathData {\n     /// GlobalMetaData identifies a piece of crate metadata that is global to\n     /// a whole crate (as opposed to just one item). GlobalMetaData components\n     /// are only supposed to show up right below the crate root.\n-    GlobalMetaData(InternedString)\n+    GlobalMetaData(InternedString),\n+    /// A trait alias.\n+    TraitAlias(InternedString),\n }\n \n #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug,\n@@ -615,6 +617,7 @@ impl DefPathData {\n         match *self {\n             TypeNs(name) |\n             Trait(name) |\n+            TraitAlias(name) |\n             AssocTypeInTrait(name) |\n             AssocTypeInImpl(name) |\n             AssocExistentialInImpl(name) |\n@@ -642,6 +645,7 @@ impl DefPathData {\n         let s = match *self {\n             TypeNs(name) |\n             Trait(name) |\n+            TraitAlias(name) |\n             AssocTypeInTrait(name) |\n             AssocTypeInImpl(name) |\n             AssocExistentialInImpl(name) |"}, {"sha": "4fc50bce272fa0a8a49e863ae844003f0227c9a8", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -10,6 +10,7 @@ pub use self::PrimTy::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n \n+use errors::FatalError;\n use hir::def::Def;\n use hir::def_id::{DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX};\n use util::nodemap::{NodeMap, FxHashSet};\n@@ -2055,6 +2056,20 @@ pub struct TraitRef {\n     pub hir_ref_id: HirId,\n }\n \n+impl TraitRef {\n+    /// Get the `DefId` of the referenced trait. It _must_ actually be a trait or trait alias.\n+    pub fn trait_def_id(&self) -> DefId {\n+        match self.path.def {\n+            Def::Trait(did) => did,\n+            Def::TraitAlias(did) => did,\n+            Def::Err => {\n+                FatalError.raise();\n+            }\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct PolyTraitRef {\n     /// The `'a` in `<'a> Foo<&'a T>`"}, {"sha": "de567183a3c05b14671f97009f8ed4b679a48c84", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -258,7 +258,7 @@ for tokenstream::TokenTree {\n             tokenstream::TokenTree::Delimited(span, delim, ref tts) => {\n                 span.hash_stable(hcx, hasher);\n                 std_hash::Hash::hash(&delim, hasher);\n-                for sub_tt in tts.stream().trees() {\n+                for sub_tt in tts.trees() {\n                     sub_tt.hash_stable(hcx, hasher);\n                 }\n             }"}, {"sha": "545192a1f211355135b2ddf9189791bc6a9fa027", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -186,34 +186,39 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n     }\n \n     fn expansion(&self, var_values: &mut LexicalRegionResolutions<'tcx>) {\n-        self.iterate_until_fixed_point(\"Expansion\", |constraint, origin| {\n-            debug!(\"expansion: constraint={:?} origin={:?}\", constraint, origin);\n-            match *constraint {\n+        self.iterate_until_fixed_point(\"Expansion\", |constraint| {\n+            debug!(\"expansion: constraint={:?}\", constraint);\n+            let (a_region, b_vid, b_data, retain) = match *constraint {\n                 Constraint::RegSubVar(a_region, b_vid) => {\n                     let b_data = var_values.value_mut(b_vid);\n-                    (self.expand_node(a_region, b_vid, b_data), false)\n+                    (a_region, b_vid, b_data, false)\n                 }\n                 Constraint::VarSubVar(a_vid, b_vid) => match *var_values.value(a_vid) {\n-                    VarValue::ErrorValue => (false, false),\n+                    VarValue::ErrorValue => return (false, false),\n                     VarValue::Value(a_region) => {\n-                        let b_node = var_values.value_mut(b_vid);\n-                        let changed = self.expand_node(a_region, b_vid, b_node);\n-                        let retain = match *b_node {\n+                        let b_data = var_values.value_mut(b_vid);\n+                        let retain = match *b_data {\n                             VarValue::Value(ReStatic) | VarValue::ErrorValue => false,\n                             _ => true\n                         };\n-                        (changed, retain)\n+                        (a_region, b_vid, b_data, retain)\n                     }\n                 },\n                 Constraint::RegSubReg(..) | Constraint::VarSubReg(..) => {\n                     // These constraints are checked after expansion\n                     // is done, in `collect_errors`.\n-                    (false, false)\n+                    return (false, false)\n                 }\n-            }\n+            };\n+\n+            let changed = self.expand_node(a_region, b_vid, b_data);\n+            (changed, retain)\n         })\n     }\n \n+    // This function is very hot in some workloads. There's a single callsite\n+    // so always inlining is ok even though it's large.\n+    #[inline(always)]\n     fn expand_node(\n         &self,\n         a_region: Region<'tcx>,\n@@ -722,18 +727,17 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n     }\n \n     fn iterate_until_fixed_point<F>(&self, tag: &str, mut body: F)\n-    where\n-        F: FnMut(&Constraint<'tcx>, &SubregionOrigin<'tcx>) -> (bool, bool),\n+        where F: FnMut(&Constraint<'tcx>) -> (bool, bool),\n     {\n-        let mut constraints: SmallVec<[_; 16]> = self.data.constraints.iter().collect();\n+        let mut constraints: SmallVec<[_; 16]> = self.data.constraints.keys().collect();\n         let mut iteration = 0;\n         let mut changed = true;\n         while changed {\n             changed = false;\n             iteration += 1;\n             debug!(\"---- {} Iteration {}{}\", \"#\", tag, iteration);\n-            constraints.retain(|(constraint, origin)| {\n-                let (edge_changed, retain) = body(constraint, origin);\n+            constraints.retain(|constraint| {\n+                let (edge_changed, retain) = body(constraint);\n                 if edge_changed {\n                     debug!(\"Updated due to constraint {:?}\", constraint);\n                     changed = true;"}, {"sha": "cdbef568a6005012eda2742af76e05312092e59c", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -1353,10 +1353,15 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n     unpretty: Option<String> = (None, parse_unpretty, [UNTRACKED],\n         \"Present the input source, unstable (and less-pretty) variants;\n         valid types are any of the types for `--pretty`, as well as:\n+        `expanded`, `expanded,identified`,\n+        `expanded,hygiene` (with internal representations),\n         `flowgraph=<nodeid>` (graphviz formatted flowgraph for node),\n+        `flowgraph,unlabelled=<nodeid>` (unlabelled graphviz formatted flowgraph for node),\n         `everybody_loops` (all function bodies replaced with `loop {}`),\n-        `hir` (the HIR), `hir,identified`, or\n-        `hir,typed` (HIR with types for each node).\"),\n+        `hir` (the HIR), `hir,identified`,\n+        `hir,typed` (HIR with types for each node),\n+        `hir-tree` (dump the raw HIR),\n+        `mir` (the MIR), or `mir-cfg` (graphviz formatted MIR)\"),\n     run_dsymutil: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"run `dsymutil` and delete intermediate object files\"),\n     ui_testing: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "9a0610f45dec2053ebe81d1b8c44a998c1fdb553", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -2198,7 +2198,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         let def_id = obligation.predicate.def_id();\n \n-        if ty::is_trait_alias(self.tcx(), def_id) {\n+        if self.tcx().is_trait_alias(def_id) {\n             candidates.vec.push(TraitAliasCandidate(def_id.clone()));\n         }\n "}, {"sha": "9328de4f6a0a15347913a486a3875852f9297b3c", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -311,6 +311,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             data @ DefPathData::Misc |\n             data @ DefPathData::TypeNs(..) |\n             data @ DefPathData::Trait(..) |\n+            data @ DefPathData::TraitAlias(..) |\n             data @ DefPathData::AssocTypeInTrait(..) |\n             data @ DefPathData::AssocTypeInImpl(..) |\n             data @ DefPathData::AssocExistentialInImpl(..) |"}, {"sha": "dd315cf42ce7e78a42801d71d16db690a5d84780", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -3170,18 +3170,6 @@ pub fn is_impl_trait_defn(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> Option<DefI\n     None\n }\n \n-/// Returns `true` if `def_id` is a trait alias.\n-pub fn is_trait_alias(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> bool {\n-    if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n-        if let Node::Item(item) = tcx.hir().get(node_id) {\n-            if let hir::ItemKind::TraitAlias(..) = item.node {\n-                return true;\n-            }\n-        }\n-    }\n-    false\n-}\n-\n /// See `ParamEnv` struct definition for details.\n fn param_env<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        def_id: DefId)"}, {"sha": "75fc0f716a2f6424319dc91d720bd0f3354a9a87", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -526,6 +526,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// True if `def_id` refers to a trait alias (i.e., `trait Foo = ...;`).\n+    pub fn is_trait_alias(self, def_id: DefId) -> bool {\n+        if let DefPathData::TraitAlias(_) = self.def_key(def_id).disambiguated_data.data {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n     /// True if this def-id refers to the implicit constructor for\n     /// a tuple struct like `struct Foo(u32)`.\n     pub fn is_struct_constructor(self, def_id: DefId) -> bool {"}, {"sha": "51e9192cd290d107d0f7d1f1ab12c2469b8f04a1", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -409,6 +409,7 @@ impl PrintContext {\n                     DefPathData::AssocTypeInImpl(_) |\n                     DefPathData::AssocExistentialInImpl(_) |\n                     DefPathData::Trait(_) |\n+                    DefPathData::TraitAlias(_) |\n                     DefPathData::Impl |\n                     DefPathData::TypeNs(_) => {\n                         break;"}, {"sha": "d980c5a3d29c3e77f58bb8f0c72d198650c02587", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -123,7 +123,8 @@ pub fn parse_pretty(sess: &Session,\n                 sess.fatal(&format!(\"argument to `unpretty` must be one of `normal`, \\\n                                      `expanded`, `flowgraph[,unlabelled]=<nodeid>`, \\\n                                      `identified`, `expanded,identified`, `everybody_loops`, \\\n-                                     `hir`, `hir,identified`, `hir,typed`, or `mir`; got {}\",\n+                                     `hir`, `hir,identified`, `hir,typed`, `hir-tree`, \\\n+                                     `mir` or `mir-cfg`; got {}\",\n                                     name));\n             } else {\n                 sess.fatal(&format!(\"argument to `pretty` must be one of `normal`, `expanded`, \\"}, {"sha": "736cca6bd64af3b6399623e4b054e4b333bff7aa", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 56, "deletions": 34, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -33,7 +33,11 @@ pub struct DiagnosticBuilder<'a> {\n /// it easy to declare such methods on the builder.\n macro_rules! forward {\n     // Forward pattern for &self -> &Self\n-    (pub fn $n:ident(&self, $($name:ident: $ty:ty),* $(,)*) -> &Self) => {\n+    (\n+        $(#[$attrs:meta])*\n+        pub fn $n:ident(&self, $($name:ident: $ty:ty),* $(,)*) -> &Self\n+    ) => {\n+        $(#[$attrs])*\n         pub fn $n(&self, $($name: $ty),*) -> &Self {\n             #[allow(deprecated)]\n             self.diagnostic.$n($($name),*);\n@@ -42,7 +46,11 @@ macro_rules! forward {\n     };\n \n     // Forward pattern for &mut self -> &mut Self\n-    (pub fn $n:ident(&mut self, $($name:ident: $ty:ty),* $(,)*) -> &mut Self) => {\n+    (\n+        $(#[$attrs:meta])*\n+        pub fn $n:ident(&mut self, $($name:ident: $ty:ty),* $(,)*) -> &mut Self\n+    ) => {\n+        $(#[$attrs])*\n         pub fn $n(&mut self, $($name: $ty),*) -> &mut Self {\n             #[allow(deprecated)]\n             self.diagnostic.$n($($name),*);\n@@ -52,10 +60,15 @@ macro_rules! forward {\n \n     // Forward pattern for &mut self -> &mut Self, with S: Into<MultiSpan>\n     // type parameter. No obvious way to make this more generic.\n-    (pub fn $n:ident<S: Into<MultiSpan>>(\n-                    &mut self,\n-                    $($name:ident: $ty:ty),*\n-                    $(,)*) -> &mut Self) => {\n+    (\n+        $(#[$attrs:meta])*\n+        pub fn $n:ident<S: Into<MultiSpan>>(\n+            &mut self,\n+            $($name:ident: $ty:ty),*\n+            $(,)*\n+        ) -> &mut Self\n+    ) => {\n+        $(#[$attrs])*\n         pub fn $n<S: Into<MultiSpan>>(&mut self, $($name: $ty),*) -> &mut Self {\n             #[allow(deprecated)]\n             self.diagnostic.$n($($name),*);\n@@ -177,34 +190,43 @@ impl<'a> DiagnosticBuilder<'a> {\n                                                   msg: &str,\n                                                   ) -> &mut Self);\n \n-    #[deprecated(note = \"Use `span_suggestion_short_with_applicability`\")]\n-    forward!(pub fn span_suggestion_short(\n-                                      &mut self,\n-                                      sp: Span,\n-                                      msg: &str,\n-                                      suggestion: String,\n-                                      ) -> &mut Self);\n-\n-    #[deprecated(note = \"Use `multipart_suggestion_with_applicability`\")]\n-    forward!(pub fn multipart_suggestion(\n-        &mut self,\n-        msg: &str,\n-        suggestion: Vec<(Span, String)>,\n-    ) -> &mut Self);\n-\n-    #[deprecated(note = \"Use `span_suggestion_with_applicability`\")]\n-    forward!(pub fn span_suggestion(&mut self,\n-                                    sp: Span,\n-                                    msg: &str,\n-                                    suggestion: String,\n-                                    ) -> &mut Self);\n-\n-    #[deprecated(note = \"Use `span_suggestions_with_applicability`\")]\n-    forward!(pub fn span_suggestions(&mut self,\n-                                     sp: Span,\n-                                     msg: &str,\n-                                     suggestions: Vec<String>,\n-                                     ) -> &mut Self);\n+    forward!(\n+        #[deprecated(note = \"Use `span_suggestion_short_with_applicability`\")]\n+        pub fn span_suggestion_short(\n+            &mut self,\n+            sp: Span,\n+            msg: &str,\n+            suggestion: String,\n+        ) -> &mut Self\n+    );\n+\n+    forward!(\n+        #[deprecated(note = \"Use `multipart_suggestion_with_applicability`\")]\n+        pub fn multipart_suggestion(\n+            &mut self,\n+            msg: &str,\n+            suggestion: Vec<(Span, String)>,\n+        ) -> &mut Self\n+    );\n+\n+    forward!(\n+        #[deprecated(note = \"Use `span_suggestion_with_applicability`\")]\n+        pub fn span_suggestion(\n+            &mut self,\n+            sp: Span,\n+            msg: &str,\n+            suggestion: String,\n+        ) -> &mut Self\n+    );\n+\n+    forward!(\n+        #[deprecated(note = \"Use `span_suggestions_with_applicability`\")]\n+        pub fn span_suggestions(&mut self,\n+            sp: Span,\n+            msg: &str,\n+            suggestions: Vec<String>,\n+        ) -> &mut Self\n+    );\n \n     pub fn multipart_suggestion_with_applicability(&mut self,\n                                               msg: &str,"}, {"sha": "f6c381ff74cc9e42d7db24193bf8a31772d56df8", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -1474,7 +1474,7 @@ impl KeywordIdents {\n                     _ => {},\n                 }\n                 TokenTree::Delimited(_, _, tts) => {\n-                    self.check_tokens(cx, tts.stream())\n+                    self.check_tokens(cx, tts)\n                 },\n             }\n         }"}, {"sha": "1f07e8f478b5a05ef9803711aa6cf5fd6081b198", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -418,6 +418,7 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::Mod(_) => Def::Mod(did),\n             EntryKind::Variant(_) => Def::Variant(did),\n             EntryKind::Trait(_) => Def::Trait(did),\n+            EntryKind::TraitAlias(_) => Def::TraitAlias(did),\n             EntryKind::Enum(..) => Def::Enum(did),\n             EntryKind::MacroDef(_) => Def::Macro(did, MacroKind::Bang),\n             EntryKind::ForeignType => Def::ForeignTy(did),\n@@ -520,17 +521,26 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_trait_def(&self, item_id: DefIndex, sess: &Session) -> ty::TraitDef {\n-        let data = match self.entry(item_id).kind {\n-            EntryKind::Trait(data) => data.decode((self, sess)),\n-            _ => bug!(),\n-        };\n-\n-        ty::TraitDef::new(self.local_def_id(item_id),\n-                          data.unsafety,\n-                          data.paren_sugar,\n-                          data.has_auto_impl,\n-                          data.is_marker,\n-                          self.def_path_table.def_path_hash(item_id))\n+        match self.entry(item_id).kind {\n+            EntryKind::Trait(data) => {\n+                let data = data.decode((self, sess));\n+                ty::TraitDef::new(self.local_def_id(item_id),\n+                                  data.unsafety,\n+                                  data.paren_sugar,\n+                                  data.has_auto_impl,\n+                                  data.is_marker,\n+                                  self.def_path_table.def_path_hash(item_id))\n+            },\n+            EntryKind::TraitAlias(_) => {\n+                ty::TraitDef::new(self.local_def_id(item_id),\n+                                  hir::Unsafety::Normal,\n+                                  false,\n+                                  false,\n+                                  false,\n+                                  self.def_path_table.def_path_hash(item_id))\n+            },\n+            _ => bug!(\"def-index does not refer to trait or trait alias\"),\n+        }\n     }\n \n     fn get_variant(&self,\n@@ -615,10 +625,13 @@ impl<'a, 'tcx> CrateMetadata {\n                                 item_id: DefIndex,\n                                 tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                 -> ty::GenericPredicates<'tcx> {\n-        match self.entry(item_id).kind {\n-            EntryKind::Trait(data) => data.decode(self).super_predicates.decode((self, tcx)),\n-            _ => bug!(),\n-        }\n+        let super_predicates = match self.entry(item_id).kind {\n+            EntryKind::Trait(data) => data.decode(self).super_predicates,\n+            EntryKind::TraitAlias(data) => data.decode(self).super_predicates,\n+            _ => bug!(\"def-index does not refer to trait or trait alias\"),\n+        };\n+\n+        super_predicates.decode((self, tcx))\n     }\n \n     pub fn get_generics(&self,\n@@ -1014,7 +1027,8 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n         def_key.parent.and_then(|parent_index| {\n             match self.entry(parent_index).kind {\n-                EntryKind::Trait(_) => Some(self.local_def_id(parent_index)),\n+                EntryKind::Trait(_) |\n+                EntryKind::TraitAlias(_) => Some(self.local_def_id(parent_index)),\n                 _ => None,\n             }\n         })"}, {"sha": "afb0218501d1877481f3a0e1b0e51a7c646b2e16", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -1128,8 +1128,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n                 EntryKind::Impl(self.lazy(&data))\n             }\n-            hir::ItemKind::Trait(..) |\n-            hir::ItemKind::TraitAlias(..) => {\n+            hir::ItemKind::Trait(..) => {\n                 let trait_def = tcx.trait_def(def_id);\n                 let data = TraitData {\n                     unsafety: trait_def.unsafety,\n@@ -1141,6 +1140,13 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n                 EntryKind::Trait(self.lazy(&data))\n             }\n+            hir::ItemKind::TraitAlias(..) => {\n+                let data = TraitAliasData {\n+                    super_predicates: self.lazy(&tcx.super_predicates_of(def_id)),\n+                };\n+\n+                EntryKind::TraitAlias(self.lazy(&data))\n+            }\n             hir::ItemKind::ExternCrate(_) |\n             hir::ItemKind::Use(..) => bug!(\"cannot encode info for item {:?}\", item),\n         };\n@@ -1214,6 +1220,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 hir::ItemKind::Impl(..) |\n                 hir::ItemKind::Existential(..) |\n                 hir::ItemKind::Trait(..) => Some(self.encode_generics(def_id)),\n+                hir::ItemKind::TraitAlias(..) => Some(self.encode_generics(def_id)),\n                 _ => None,\n             },\n             predicates: match item.node {\n@@ -1226,7 +1233,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 hir::ItemKind::Union(..) |\n                 hir::ItemKind::Impl(..) |\n                 hir::ItemKind::Existential(..) |\n-                hir::ItemKind::Trait(..) => Some(self.encode_predicates(def_id)),\n+                hir::ItemKind::Trait(..) |\n+                hir::ItemKind::TraitAlias(..) => Some(self.encode_predicates(def_id)),\n                 _ => None,\n             },\n \n@@ -1236,7 +1244,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             // hack. (No reason not to expand it in the future if\n             // necessary.)\n             predicates_defined_on: match item.node {\n-                hir::ItemKind::Trait(..) => Some(self.encode_predicates_defined_on(def_id)),\n+                hir::ItemKind::Trait(..) |\n+                hir::ItemKind::TraitAlias(..) => Some(self.encode_predicates_defined_on(def_id)),\n                 _ => None, // not *wrong* for other kinds of items, but not needed\n             },\n "}, {"sha": "f3ff9747625f5b68724701049c5f6a660f347869", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -316,6 +316,7 @@ pub enum EntryKind<'tcx> {\n     AssociatedType(AssociatedContainer),\n     AssociatedExistential(AssociatedContainer),\n     AssociatedConst(AssociatedContainer, ConstQualif, Lazy<RenderedConst>),\n+    TraitAlias(Lazy<TraitAliasData<'tcx>>),\n }\n \n impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for EntryKind<'gcx> {\n@@ -370,6 +371,9 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for EntryKind<'gcx> {\n             EntryKind::Trait(ref trait_data) => {\n                 trait_data.hash_stable(hcx, hasher);\n             }\n+            EntryKind::TraitAlias(ref trait_alias_data) => {\n+                trait_alias_data.hash_stable(hcx, hasher);\n+            }\n             EntryKind::Impl(ref impl_data) => {\n                 impl_data.hash_stable(hcx, hasher);\n             }\n@@ -474,6 +478,15 @@ impl_stable_hash_for!(struct TraitData<'tcx> {\n     super_predicates\n });\n \n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct TraitAliasData<'tcx> {\n+    pub super_predicates: Lazy<ty::GenericPredicates<'tcx>>,\n+}\n+\n+impl_stable_hash_for!(struct TraitAliasData<'tcx> {\n+    super_predicates\n+});\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ImplData<'tcx> {\n     pub polarity: hir::ImplPolarity,"}, {"sha": "dcbb9ff4a757628580a0495e6bc22a6e89a8a6bb", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -13,7 +13,7 @@ extern crate rustc_typeck;\n extern crate syntax_pos;\n extern crate rustc_data_structures;\n \n-use rustc::hir::{self, Node, PatKind};\n+use rustc::hir::{self, Node, PatKind, AssociatedItemKind};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefId};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n@@ -548,7 +548,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                         let mut reach = self.reach(trait_item_ref.id.node_id, item_level);\n                         reach.generics().predicates();\n \n-                        if trait_item_ref.kind == hir::AssociatedItemKind::Type &&\n+                        if trait_item_ref.kind == AssociatedItemKind::Type &&\n                            !trait_item_ref.defaultness.has_value() {\n                             // No type to visit.\n                         } else {\n@@ -1343,11 +1343,11 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                         if self.item_is_public(&impl_item_ref.id.node_id, &impl_item_ref.vis) {\n                             let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                             match impl_item_ref.kind {\n-                                hir::AssociatedItemKind::Const => {\n+                                AssociatedItemKind::Const => {\n                                     found_pub_static = true;\n                                     intravisit::walk_impl_item(self, impl_item);\n                                 }\n-                                hir::AssociatedItemKind::Method { has_self: false } => {\n+                                AssociatedItemKind::Method { has_self: false } => {\n                                     found_pub_static = true;\n                                     intravisit::walk_impl_item(self, impl_item);\n                                 }\n@@ -1568,6 +1568,24 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n             in_assoc_ty: false,\n         }\n     }\n+\n+    fn check_trait_or_impl_item(&self, node_id: ast::NodeId, assoc_item_kind: AssociatedItemKind,\n+                                defaultness: hir::Defaultness, vis: ty::Visibility) {\n+        let mut check = self.check(node_id, vis);\n+\n+        let (check_ty, is_assoc_ty) = match assoc_item_kind {\n+            AssociatedItemKind::Const | AssociatedItemKind::Method { .. } => (true, false),\n+            AssociatedItemKind::Type => (defaultness.has_value(), true),\n+            // `ty()` for existential types is the underlying type,\n+            // it's not a part of interface, so we skip it.\n+            AssociatedItemKind::Existential => (false, true),\n+        };\n+        check.in_assoc_ty = is_assoc_ty;\n+        check.generics().predicates();\n+        if check_ty {\n+            check.ty();\n+        }\n+    }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n@@ -1602,16 +1620,8 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                 self.check(item.id, item_visibility).generics().predicates();\n \n                 for trait_item_ref in trait_item_refs {\n-                    let mut check = self.check(trait_item_ref.id.node_id, item_visibility);\n-                    check.in_assoc_ty = trait_item_ref.kind == hir::AssociatedItemKind::Type;\n-                    check.generics().predicates();\n-\n-                    if trait_item_ref.kind == hir::AssociatedItemKind::Type &&\n-                       !trait_item_ref.defaultness.has_value() {\n-                        // No type to visit.\n-                    } else {\n-                        check.ty();\n-                    }\n+                    self.check_trait_or_impl_item(trait_item_ref.id.node_id, trait_item_ref.kind,\n+                                                  trait_item_ref.defaultness, item_visibility);\n                 }\n             }\n             hir::ItemKind::TraitAlias(..) => {\n@@ -1657,9 +1667,8 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                     } else {\n                         impl_vis\n                     };\n-                    let mut check = self.check(impl_item.id, impl_item_vis);\n-                    check.in_assoc_ty = impl_item_ref.kind == hir::AssociatedItemKind::Type;\n-                    check.generics().predicates().ty();\n+                    self.check_trait_or_impl_item(impl_item_ref.id.node_id, impl_item_ref.kind,\n+                                                  impl_item_ref.defaultness, impl_item_vis);\n                 }\n             }\n         }"}, {"sha": "35616cc03a936bdbbb03b51202db33340f0930b4", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -21,6 +21,8 @@ use std::cell::Cell;\n use std::ptr;\n use rustc_data_structures::sync::Lrc;\n \n+use errors::Applicability;\n+\n use syntax::ast::{Name, Ident};\n use syntax::attr;\n \n@@ -345,7 +347,12 @@ impl<'a> Resolver<'a> {\n                 let module = if orig_name.is_none() && ident.name == keywords::SelfLower.name() {\n                     self.session\n                         .struct_span_err(item.span, \"`extern crate self;` requires renaming\")\n-                        .span_suggestion(item.span, \"try\", \"extern crate self as name;\".into())\n+                        .span_suggestion_with_applicability(\n+                            item.span,\n+                            \"try\",\n+                            \"extern crate self as name;\".into(),\n+                            Applicability::HasPlaceholders,\n+                        )\n                         .emit();\n                     return;\n                 } else if orig_name == Some(keywords::SelfLower.name()) {\n@@ -673,6 +680,9 @@ impl<'a> Resolver<'a> {\n                 }\n                 module.populated.set(true);\n             }\n+            Def::TraitAlias(..) => {\n+                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, expansion));\n+            }\n             Def::Struct(..) | Def::Union(..) => {\n                 self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, expansion));\n "}, {"sha": "1cd44042c1de9811383b59f1f51420345fad32a5", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -4866,8 +4866,13 @@ impl<'a> Resolver<'a> {\n                 } else if ident.span.rust_2018() {\n                     let msg = \"relative paths are not supported in visibilities on 2018 edition\";\n                     self.session.struct_span_err(ident.span, msg)\n-                                .span_suggestion(path.span, \"try\", format!(\"crate::{}\", path))\n-                                .emit();\n+                        .span_suggestion_with_applicability(\n+                            path.span,\n+                            \"try\",\n+                            format!(\"crate::{}\", path),\n+                            Applicability::MaybeIncorrect,\n+                        )\n+                        .emit();\n                     return ty::Visibility::Public;\n                 } else {\n                     let ctxt = ident.span.ctxt();"}, {"sha": "9bdef3051e58934403ec63e0be1712fff71fdda2", "filename": "src/librustc_traits/lowering/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -158,7 +158,8 @@ crate fn program_clauses_for<'a, 'tcx>(\n     def_id: DefId,\n ) -> Clauses<'tcx> {\n     match tcx.def_key(def_id).disambiguated_data.data {\n-        DefPathData::Trait(_) => program_clauses_for_trait(tcx, def_id),\n+        DefPathData::Trait(_) |\n+        DefPathData::TraitAlias(_) => program_clauses_for_trait(tcx, def_id),\n         DefPathData::Impl => program_clauses_for_impl(tcx, def_id),\n         DefPathData::AssocTypeInImpl(..) => program_clauses_for_associated_type_value(tcx, def_id),\n         DefPathData::AssocTypeInTrait(..) => program_clauses_for_associated_type_def(tcx, def_id),"}, {"sha": "e89506aaf99f9232bc0a103c0339f63fb99f84d3", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -2,7 +2,7 @@\n //! The main routine here is `ast_ty_to_ty()`; each use is parameterized by an\n //! instance of `AstConv`.\n \n-use errors::{Applicability, FatalError, DiagnosticId};\n+use errors::{Applicability, DiagnosticId};\n use hir::{self, GenericArg, GenericArgs};\n use hir::def::Def;\n use hir::def_id::DefId;\n@@ -690,35 +690,21 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     {\n         self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n \n-        let trait_def_id = self.trait_def_id(trait_ref);\n         self.ast_path_to_mono_trait_ref(trait_ref.path.span,\n-                                        trait_def_id,\n+                                        trait_ref.trait_def_id(),\n                                         self_ty,\n                                         trait_ref.path.segments.last().unwrap())\n     }\n \n-    /// Get the `DefId` of the given trait ref. It _must_ actually be a trait.\n-    fn trait_def_id(&self, trait_ref: &hir::TraitRef) -> DefId {\n-        let path = &trait_ref.path;\n-        match path.def {\n-            Def::Trait(trait_def_id) => trait_def_id,\n-            Def::TraitAlias(alias_def_id) => alias_def_id,\n-            Def::Err => {\n-                FatalError.raise();\n-            }\n-            _ => unreachable!(),\n-        }\n-    }\n-\n-    /// The given trait ref must actually be a trait.\n+    /// The given trait-ref must actually be a trait.\n     pub(super) fn instantiate_poly_trait_ref_inner(&self,\n         trait_ref: &hir::TraitRef,\n         self_ty: Ty<'tcx>,\n         poly_projections: &mut Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>,\n         speculative: bool)\n         -> (ty::PolyTraitRef<'tcx>, Option<Vec<Span>>)\n     {\n-        let trait_def_id = self.trait_def_id(trait_ref);\n+        let trait_def_id = trait_ref.trait_def_id();\n \n         debug!(\"instantiate_poly_trait_ref({:?}, def_id={:?})\", trait_ref, trait_def_id);\n "}, {"sha": "47f258e1aea7478d77cb28b8004bfbbf34225ced", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -1,5 +1,6 @@\n use check::{FnCtxt, Expectation, Diverges, Needs};\n use check::coercion::CoerceMany;\n+use errors::Applicability;\n use rustc::hir::{self, PatKind};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n@@ -989,7 +990,13 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                     let suggested_name =\n                         find_best_match_for_name(input, &ident.as_str(), None);\n                     if let Some(suggested_name) = suggested_name {\n-                        err.span_suggestion(*span, \"did you mean\", suggested_name.to_string());\n+                        err.span_suggestion_with_applicability(\n+                            *span,\n+                            \"did you mean\",\n+                            suggested_name.to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+\n                         // we don't want to throw `E0027` in case we have thrown `E0026` for them\n                         unmentioned_fields.retain(|&x| x.as_str() != suggested_name.as_str());\n                     }"}, {"sha": "93f14a2ea6f647b26ee4836b556c20cdad8eeb9b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -715,7 +715,7 @@ fn super_predicates_of<'a, 'tcx>(\n     // In the case of trait aliases, however, we include all bounds in the where clause,\n     // so e.g., `trait Foo = where u32: PartialEq<Self>` would include `u32: PartialEq<Self>`\n     // as one of its \"superpredicates\".\n-    let is_trait_alias = ty::is_trait_alias(tcx, trait_def_id);\n+    let is_trait_alias = tcx.is_trait_alias(trait_def_id);\n     let superbounds2 = icx.type_parameter_bounds_in_generics(\n         generics, item.id, self_param_ty, OnlySelfBounds(!is_trait_alias));\n "}, {"sha": "bbcaaacbab52337380f17da188adaa78bc520346", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -15,7 +15,7 @@ use rustc_target::spec::abi::Abi;\n use source_map::{dummy_spanned, respan, Spanned};\n use symbol::{keywords, Symbol};\n use syntax_pos::{Span, DUMMY_SP};\n-use tokenstream::{ThinTokenStream, TokenStream};\n+use tokenstream::TokenStream;\n use ThinVec;\n \n use rustc_data_structures::fx::FxHashSet;\n@@ -1216,7 +1216,7 @@ pub type Mac = Spanned<Mac_>;\n pub struct Mac_ {\n     pub path: Path,\n     pub delim: MacDelimiter,\n-    pub tts: ThinTokenStream,\n+    pub tts: TokenStream,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n@@ -1228,13 +1228,13 @@ pub enum MacDelimiter {\n \n impl Mac_ {\n     pub fn stream(&self) -> TokenStream {\n-        self.tts.stream()\n+        self.tts.clone()\n     }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct MacroDef {\n-    pub tokens: ThinTokenStream,\n+    pub tokens: TokenStream,\n     pub legacy: bool,\n }\n "}, {"sha": "f6d7590a7945e8ac06446be882e6a63665cc9999", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -570,7 +570,7 @@ impl MetaItemKind {\n             }\n             Some(TokenTree::Delimited(_, delim, ref tts)) if delim == token::Paren => {\n                 tokens.next();\n-                tts.stream()\n+                tts.clone()\n             }\n             _ => return Some(MetaItemKind::Word),\n         };"}, {"sha": "c01e7f538b90d209bda9ae208c1c849e2795eec2", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -748,7 +748,7 @@ fn statements_mk_tt(cx: &ExtCtxt, tt: &TokenTree, quoted: bool) -> Vec<ast::Stmt\n         },\n         TokenTree::Delimited(span, delim, ref tts) => {\n             let mut stmts = statements_mk_tt(cx, &TokenTree::open_tt(span.open, delim), false);\n-            stmts.extend(statements_mk_tts(cx, tts.stream()));\n+            stmts.extend(statements_mk_tts(cx, tts.clone()));\n             stmts.extend(statements_mk_tt(cx, &TokenTree::close_tt(span.close, delim), false));\n             stmts\n         }"}, {"sha": "a4c3b38f691edd635c640a7ea57c3bde4e968fe7", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -598,7 +598,7 @@ pub fn noop_fold_tt<T: Folder>(tt: TokenTree, fld: &mut T) -> TokenTree {\n         TokenTree::Delimited(span, delim, tts) => TokenTree::Delimited(\n             DelimSpan::from_pair(fld.new_span(span.open), fld.new_span(span.close)),\n             delim,\n-            fld.fold_tts(tts.stream()).into(),\n+            fld.fold_tts(tts).into(),\n         ),\n     }\n }"}, {"sha": "ddb350faa546bf65022de7698b469590cc0291a8", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -817,7 +817,7 @@ mod tests {\n                 )\n                 if name_macro_rules.name == \"macro_rules\"\n                 && name_zip.name == \"zip\" => {\n-                    let tts = &macro_tts.stream().trees().collect::<Vec<_>>();\n+                    let tts = &macro_tts.trees().collect::<Vec<_>>();\n                     match (tts.len(), tts.get(0), tts.get(1), tts.get(2)) {\n                         (\n                             3,\n@@ -826,7 +826,7 @@ mod tests {\n                             Some(&TokenTree::Delimited(_, second_delim, ref second_tts)),\n                         )\n                         if macro_delim == token::Paren => {\n-                            let tts = &first_tts.stream().trees().collect::<Vec<_>>();\n+                            let tts = &first_tts.trees().collect::<Vec<_>>();\n                             match (tts.len(), tts.get(0), tts.get(1)) {\n                                 (\n                                     2,\n@@ -836,7 +836,7 @@ mod tests {\n                                 if first_delim == token::Paren && ident.name == \"a\" => {},\n                                 _ => panic!(\"value 3: {:?} {:?}\", first_delim, first_tts),\n                             }\n-                            let tts = &second_tts.stream().trees().collect::<Vec<_>>();\n+                            let tts = &second_tts.trees().collect::<Vec<_>>();\n                             match (tts.len(), tts.get(0), tts.get(1)) {\n                                 (\n                                     2,"}, {"sha": "7e15b23127655ee5883451685b3754e5a5aeeb3c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -46,7 +46,7 @@ use print::pprust;\n use ptr::P;\n use parse::PResult;\n use ThinVec;\n-use tokenstream::{self, DelimSpan, ThinTokenStream, TokenTree, TokenStream};\n+use tokenstream::{self, DelimSpan, TokenTree, TokenStream, TreeAndJoint};\n use symbol::{Symbol, keywords};\n \n use std::borrow::Cow;\n@@ -280,17 +280,17 @@ struct TokenCursorFrame {\n /// on the parser.\n #[derive(Clone)]\n enum LastToken {\n-    Collecting(Vec<TokenStream>),\n-    Was(Option<TokenStream>),\n+    Collecting(Vec<TreeAndJoint>),\n+    Was(Option<TreeAndJoint>),\n }\n \n impl TokenCursorFrame {\n-    fn new(sp: DelimSpan, delim: DelimToken, tts: &ThinTokenStream) -> Self {\n+    fn new(sp: DelimSpan, delim: DelimToken, tts: &TokenStream) -> Self {\n         TokenCursorFrame {\n             delim: delim,\n             span: sp,\n             open_delim: delim == token::NoDelim,\n-            tree_cursor: tts.stream().into_trees(),\n+            tree_cursor: tts.clone().into_trees(),\n             close_delim: delim == token::NoDelim,\n             last_token: LastToken::Was(None),\n         }\n@@ -2330,7 +2330,7 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    fn expect_delimited_token_tree(&mut self) -> PResult<'a, (MacDelimiter, ThinTokenStream)> {\n+    fn expect_delimited_token_tree(&mut self) -> PResult<'a, (MacDelimiter, TokenStream)> {\n         let delim = match self.token {\n             token::OpenDelim(delim) => delim,\n             _ => {\n@@ -2350,7 +2350,7 @@ impl<'a> Parser<'a> {\n             token::Brace => MacDelimiter::Brace,\n             token::NoDelim => self.bug(\"unexpected no delimiter\"),\n         };\n-        Ok((delim, tts.stream().into()))\n+        Ok((delim, tts.into()))\n     }\n \n     /// At the bottom (top?) of the precedence hierarchy,\n@@ -4063,12 +4063,13 @@ impl<'a> Parser<'a> {\n \n         if let Some(mut err) = delayed_err {\n             if let Some(etc_span) = etc_span {\n-                err.multipart_suggestion(\n+                err.multipart_suggestion_with_applicability(\n                     \"move the `..` to the end of the field list\",\n                     vec![\n                         (etc_span, String::new()),\n                         (self.span, format!(\"{}.. }}\", if ate_comma { \"\" } else { \", \" })),\n                     ],\n+                    Applicability::MachineApplicable,\n                 );\n             }\n             err.emit();\n@@ -4641,7 +4642,7 @@ impl<'a> Parser<'a> {\n                 let ident = self.parse_ident()?;\n                 let tokens = if self.check(&token::OpenDelim(token::Brace)) {\n                     match self.parse_token_tree() {\n-                        TokenTree::Delimited(_, _, tts) => tts.stream(),\n+                        TokenTree::Delimited(_, _, tts) => tts,\n                         _ => unreachable!(),\n                     }\n                 } else if self.check(&token::OpenDelim(token::Paren)) {\n@@ -6904,7 +6905,11 @@ impl<'a> Parser<'a> {\n \n             let mut err = self.struct_span_err(fixed_name_sp, error_msg);\n             err.span_label(fixed_name_sp, \"dash-separated idents are not valid\");\n-            err.multipart_suggestion(suggestion_msg, replacement);\n+            err.multipart_suggestion_with_applicability(\n+                suggestion_msg,\n+                replacement,\n+                Applicability::MachineApplicable,\n+            );\n             err.emit();\n         }\n         Ok(ident)\n@@ -7757,7 +7762,7 @@ impl<'a> Parser<'a> {\n             &mut self.token_cursor.stack[prev].last_token\n         };\n \n-        // Pull our the toekns that we've collected from the call to `f` above\n+        // Pull out the tokens that we've collected from the call to `f` above.\n         let mut collected_tokens = match *last_token {\n             LastToken::Collecting(ref mut v) => mem::replace(v, Vec::new()),\n             LastToken::Was(_) => panic!(\"our vector went away?\"),\n@@ -7776,10 +7781,9 @@ impl<'a> Parser<'a> {\n         // call. In that case we need to record all the tokens we collected in\n         // our parent list as well. To do that we push a clone of our stream\n         // onto the previous list.\n-        let stream = collected_tokens.into_iter().collect::<TokenStream>();\n         match prev_collecting {\n             Some(mut list) => {\n-                list.push(stream.clone());\n+                list.extend(collected_tokens.iter().cloned());\n                 list.extend(extra_token);\n                 *last_token = LastToken::Collecting(list);\n             }\n@@ -7788,7 +7792,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        Ok((ret?, stream))\n+        Ok((ret?, TokenStream::new(collected_tokens)))\n     }\n \n     pub fn parse_item(&mut self) -> PResult<'a, Option<P<Item>>> {"}, {"sha": "c53594032a00aefb006bd2dc9ead3eaf7ac61485", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -807,7 +807,7 @@ pub trait PrintState<'a> {\n             TokenTree::Delimited(_, delim, tts) => {\n                 self.writer().word(token_to_string(&token::OpenDelim(delim)))?;\n                 self.writer().space()?;\n-                self.print_tts(tts.stream())?;\n+                self.print_tts(tts)?;\n                 self.writer().space()?;\n                 self.writer().word(token_to_string(&token::CloseDelim(delim)))\n             },"}, {"sha": "f5d2d6f18ee87916f4a63d976fc3ebd2e533164c", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 53, "deletions": 142, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -41,7 +41,7 @@ pub enum TokenTree {\n     /// A single token\n     Token(Span, token::Token),\n     /// A delimited sequence of token trees\n-    Delimited(DelimSpan, DelimToken, ThinTokenStream),\n+    Delimited(DelimSpan, DelimToken, TokenStream),\n }\n \n impl TokenTree {\n@@ -62,8 +62,7 @@ impl TokenTree {\n             (&TokenTree::Token(_, ref tk), &TokenTree::Token(_, ref tk2)) => tk == tk2,\n             (&TokenTree::Delimited(_, delim, ref tts),\n              &TokenTree::Delimited(_, delim2, ref tts2)) => {\n-                delim == delim2 &&\n-                tts.stream().eq_unspanned(&tts2.stream())\n+                delim == delim2 && tts.eq_unspanned(&tts2)\n             }\n             (_, _) => false,\n         }\n@@ -81,8 +80,7 @@ impl TokenTree {\n             }\n             (&TokenTree::Delimited(_, delim, ref tts),\n              &TokenTree::Delimited(_, delim2, ref tts2)) => {\n-                delim == delim2 &&\n-                tts.stream().probably_equal_for_proc_macro(&tts2.stream())\n+                delim == delim2 && tts.probably_equal_for_proc_macro(&tts2)\n             }\n             (_, _) => false,\n         }\n@@ -113,7 +111,7 @@ impl TokenTree {\n     }\n \n     pub fn joint(self) -> TokenStream {\n-        TokenStream::Tree(self, Joint)\n+        TokenStream::new(vec![(self, Joint)])\n     }\n \n     /// Returns the opening delimiter as a token tree.\n@@ -143,18 +141,19 @@ impl TokenTree {\n /// The goal is for procedural macros to work with `TokenStream`s and `TokenTree`s\n /// instead of a representation of the abstract syntax tree.\n /// Today's `TokenTree`s can still contain AST via `Token::Interpolated` for back-compat.\n+///\n+/// The use of `Option` is an optimization that avoids the need for an\n+/// allocation when the stream is empty. However, it is not guaranteed that an\n+/// empty stream is represented with `None`; it may be represented as a `Some`\n+/// around an empty `Vec`.\n #[derive(Clone, Debug)]\n-pub enum TokenStream {\n-    Empty,\n-    Tree(TokenTree, IsJoint),\n-    Stream(Lrc<Vec<TreeAndJoint>>),\n-}\n+pub struct TokenStream(Option<Lrc<Vec<TreeAndJoint>>>);\n \n pub type TreeAndJoint = (TokenTree, IsJoint);\n \n // `TokenStream` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-static_assert!(MEM_SIZE_OF_TOKEN_STREAM: mem::size_of::<TokenStream>() == 32);\n+static_assert!(MEM_SIZE_OF_TOKEN_STREAM: mem::size_of::<TokenStream>() == 8);\n \n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum IsJoint {\n@@ -169,7 +168,7 @@ impl TokenStream {\n     /// separating the two arguments with a comma for diagnostic suggestions.\n     pub(crate) fn add_comma(&self) -> Option<(TokenStream, Span)> {\n         // Used to suggest if a user writes `foo!(a b);`\n-        if let TokenStream::Stream(ref stream) = self {\n+        if let Some(ref stream) = self.0 {\n             let mut suggestion = None;\n             let mut iter = stream.iter().enumerate().peekable();\n             while let Some((pos, ts)) = iter.next() {\n@@ -201,7 +200,7 @@ impl TokenStream {\n \n impl From<TokenTree> for TokenStream {\n     fn from(tree: TokenTree) -> TokenStream {\n-        TokenStream::Tree(tree, NonJoint)\n+        TokenStream::new(vec![(tree, NonJoint)])\n     }\n }\n \n@@ -233,21 +232,21 @@ impl PartialEq<TokenStream> for TokenStream {\n \n impl TokenStream {\n     pub fn len(&self) -> usize {\n-        if let TokenStream::Stream(ref slice) = self {\n+        if let Some(ref slice) = self.0 {\n             slice.len()\n         } else {\n             0\n         }\n     }\n \n     pub fn empty() -> TokenStream {\n-        TokenStream::Empty\n+        TokenStream(None)\n     }\n \n     pub fn is_empty(&self) -> bool {\n-        match self {\n-            TokenStream::Empty => true,\n-            _ => false,\n+        match self.0 {\n+            None => true,\n+            Some(ref stream) => stream.is_empty(),\n         }\n     }\n \n@@ -258,33 +257,26 @@ impl TokenStream {\n             _ => {\n                 let mut vec = vec![];\n                 for stream in streams {\n-                    match stream {\n-                        TokenStream::Empty => {},\n-                        TokenStream::Tree(tree, is_joint) => vec.push((tree, is_joint)),\n-                        TokenStream::Stream(stream2) => vec.extend(stream2.iter().cloned()),\n+                    match stream.0 {\n+                        None => {},\n+                        Some(stream2) => vec.extend(stream2.iter().cloned()),\n                     }\n                 }\n                 TokenStream::new(vec)\n             }\n         }\n     }\n \n-    pub fn new(mut streams: Vec<TreeAndJoint>) -> TokenStream {\n+    pub fn new(streams: Vec<TreeAndJoint>) -> TokenStream {\n         match streams.len() {\n-            0 => TokenStream::empty(),\n-            1 => {\n-                let (tree, is_joint) = streams.pop().unwrap();\n-                TokenStream::Tree(tree, is_joint)\n-            }\n-            _ => TokenStream::Stream(Lrc::new(streams)),\n+            0 => TokenStream(None),\n+            _ => TokenStream(Some(Lrc::new(streams))),\n         }\n     }\n \n     pub fn append_to_tree_and_joint_vec(self, vec: &mut Vec<TreeAndJoint>) {\n-        match self {\n-            TokenStream::Empty => {}\n-            TokenStream::Tree(tree, is_joint) => vec.push((tree, is_joint)),\n-            TokenStream::Stream(stream) => vec.extend(stream.iter().cloned()),\n+        if let Some(stream) = self.0 {\n+            vec.extend(stream.iter().cloned());\n         }\n     }\n \n@@ -349,51 +341,36 @@ impl TokenStream {\n     }\n \n     pub fn map_enumerated<F: FnMut(usize, TokenTree) -> TokenTree>(self, mut f: F) -> TokenStream {\n-        match self {\n-            TokenStream::Empty => TokenStream::Empty,\n-            TokenStream::Tree(tree, is_joint) => TokenStream::Tree(f(0, tree), is_joint),\n-            TokenStream::Stream(stream) => TokenStream::Stream(Lrc::new(\n+        TokenStream(self.0.map(|stream| {\n+            Lrc::new(\n                 stream\n                     .iter()\n                     .enumerate()\n                     .map(|(i, (tree, is_joint))| (f(i, tree.clone()), *is_joint))\n-                    .collect()\n-            )),\n-        }\n+                    .collect())\n+        }))\n     }\n \n     pub fn map<F: FnMut(TokenTree) -> TokenTree>(self, mut f: F) -> TokenStream {\n-        match self {\n-            TokenStream::Empty => TokenStream::Empty,\n-            TokenStream::Tree(tree, is_joint) => TokenStream::Tree(f(tree), is_joint),\n-            TokenStream::Stream(stream) => TokenStream::Stream(Lrc::new(\n+        TokenStream(self.0.map(|stream| {\n+            Lrc::new(\n                 stream\n                     .iter()\n                     .map(|(tree, is_joint)| (f(tree.clone()), *is_joint))\n-                    .collect()\n-            )),\n-        }\n+                    .collect())\n+        }))\n     }\n \n-    fn first_tree_and_joint(&self) -> Option<(TokenTree, IsJoint)> {\n-        match self {\n-            TokenStream::Empty => None,\n-            TokenStream::Tree(ref tree, is_joint) => Some((tree.clone(), *is_joint)),\n-            TokenStream::Stream(ref stream) => Some(stream.first().unwrap().clone())\n-        }\n+    fn first_tree_and_joint(&self) -> Option<TreeAndJoint> {\n+        self.0.as_ref().map(|stream| {\n+            stream.first().unwrap().clone()\n+        })\n     }\n \n     fn last_tree_if_joint(&self) -> Option<TokenTree> {\n-        match self {\n-            TokenStream::Empty => None,\n-            TokenStream::Tree(ref tree, is_joint) => {\n-                if *is_joint == Joint {\n-                    Some(tree.clone())\n-                } else {\n-                    None\n-                }\n-            }\n-            TokenStream::Stream(ref stream) => {\n+        match self.0 {\n+            None => None,\n+            Some(ref stream) => {\n                 if let (tree, Joint) = stream.last().unwrap() {\n                     Some(tree.clone())\n                 } else {\n@@ -422,7 +399,7 @@ impl TokenStreamBuilder {\n                     self.push_all_but_last_tree(&last_stream);\n                     let glued_span = last_span.to(span);\n                     let glued_tt = TokenTree::Token(glued_span, glued_tok);\n-                    let glued_tokenstream = TokenStream::Tree(glued_tt, is_joint);\n+                    let glued_tokenstream = TokenStream::new(vec![(glued_tt, is_joint)]);\n                     self.0.push(glued_tokenstream);\n                     self.push_all_but_first_tree(&stream);\n                     return\n@@ -437,23 +414,21 @@ impl TokenStreamBuilder {\n     }\n \n     fn push_all_but_last_tree(&mut self, stream: &TokenStream) {\n-        if let TokenStream::Stream(ref streams) = stream {\n+        if let Some(ref streams) = stream.0 {\n             let len = streams.len();\n             match len {\n                 1 => {}\n-                2 => self.0.push(TokenStream::Tree(streams[0].0.clone(), streams[0].1)),\n-                _ => self.0.push(TokenStream::Stream(Lrc::new(streams[0 .. len - 1].to_vec()))),\n+                _ => self.0.push(TokenStream(Some(Lrc::new(streams[0 .. len - 1].to_vec())))),\n             }\n         }\n     }\n \n     fn push_all_but_first_tree(&mut self, stream: &TokenStream) {\n-        if let TokenStream::Stream(ref streams) = stream {\n+        if let Some(ref streams) = stream.0 {\n             let len = streams.len();\n             match len {\n                 1 => {}\n-                2 => self.0.push(TokenStream::Tree(streams[1].0.clone(), streams[1].1)),\n-                _ => self.0.push(TokenStream::Stream(Lrc::new(streams[1 .. len].to_vec()))),\n+                _ => self.0.push(TokenStream(Some(Lrc::new(streams[1 .. len].to_vec())))),\n             }\n         }\n     }\n@@ -479,17 +454,9 @@ impl Cursor {\n     }\n \n     pub fn next_with_joint(&mut self) -> Option<TreeAndJoint> {\n-        match self.stream {\n-            TokenStream::Empty => None,\n-            TokenStream::Tree(ref tree, ref is_joint) => {\n-                if self.index == 0 {\n-                    self.index = 1;\n-                    Some((tree.clone(), *is_joint))\n-                } else {\n-                    None\n-                }\n-            }\n-            TokenStream::Stream(ref stream) => {\n+        match self.stream.0 {\n+            None => None,\n+            Some(ref stream) => {\n                 if self.index < stream.len() {\n                     self.index += 1;\n                     Some(stream[self.index - 1].clone())\n@@ -505,63 +472,19 @@ impl Cursor {\n             return;\n         }\n         let index = self.index;\n-        let stream = mem::replace(&mut self.stream, TokenStream::Empty);\n+        let stream = mem::replace(&mut self.stream, TokenStream(None));\n         *self = TokenStream::from_streams(vec![stream, new_stream]).into_trees();\n         self.index = index;\n     }\n \n     pub fn look_ahead(&self, n: usize) -> Option<TokenTree> {\n-        match self.stream {\n-            TokenStream::Empty => None,\n-            TokenStream::Tree(ref tree, _) => {\n-                if n == 0 && self.index == 0 {\n-                    Some(tree.clone())\n-                } else {\n-                    None\n-                }\n-            }\n-            TokenStream::Stream(ref stream) =>\n-                stream[self.index ..].get(n).map(|(tree, _)| tree.clone()),\n+        match self.stream.0 {\n+            None => None,\n+            Some(ref stream) => stream[self.index ..].get(n).map(|(tree, _)| tree.clone()),\n         }\n     }\n }\n \n-/// The `TokenStream` type is large enough to represent a single `TokenTree` without allocation.\n-/// `ThinTokenStream` is smaller, but needs to allocate to represent a single `TokenTree`.\n-/// We must use `ThinTokenStream` in `TokenTree::Delimited` to avoid infinite size due to recursion.\n-#[derive(Debug, Clone)]\n-pub struct ThinTokenStream(Option<Lrc<Vec<TreeAndJoint>>>);\n-\n-impl ThinTokenStream {\n-    pub fn stream(&self) -> TokenStream {\n-        self.clone().into()\n-    }\n-}\n-\n-impl From<TokenStream> for ThinTokenStream {\n-    fn from(stream: TokenStream) -> ThinTokenStream {\n-        ThinTokenStream(match stream {\n-            TokenStream::Empty => None,\n-            TokenStream::Tree(tree, is_joint) => Some(Lrc::new(vec![(tree, is_joint)])),\n-            TokenStream::Stream(stream) => Some(stream),\n-        })\n-    }\n-}\n-\n-impl From<ThinTokenStream> for TokenStream {\n-    fn from(stream: ThinTokenStream) -> TokenStream {\n-        stream.0.map(TokenStream::Stream).unwrap_or_else(TokenStream::empty)\n-    }\n-}\n-\n-impl Eq for ThinTokenStream {}\n-\n-impl PartialEq<ThinTokenStream> for ThinTokenStream {\n-    fn eq(&self, other: &ThinTokenStream) -> bool {\n-        TokenStream::from(self.clone()) == TokenStream::from(other.clone())\n-    }\n-}\n-\n impl fmt::Display for TokenStream {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write_str(&pprust::tokens_to_string(self.clone()))\n@@ -580,18 +503,6 @@ impl Decodable for TokenStream {\n     }\n }\n \n-impl Encodable for ThinTokenStream {\n-    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), E::Error> {\n-        TokenStream::from(self.clone()).encode(encoder)\n-    }\n-}\n-\n-impl Decodable for ThinTokenStream {\n-    fn decode<D: Decoder>(decoder: &mut D) -> Result<ThinTokenStream, D::Error> {\n-        TokenStream::decode(decoder).map(Into::into)\n-    }\n-}\n-\n #[derive(Debug, Copy, Clone, PartialEq, RustcEncodable, RustcDecodable)]\n pub struct DelimSpan {\n     pub open: Span,"}, {"sha": "8cbd47ca70fded321d9eb95b2863d2e1327f6fdf", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -832,7 +832,7 @@ pub fn walk_attribute<'a, V: Visitor<'a>>(visitor: &mut V, attr: &'a Attribute)\n pub fn walk_tt<'a, V: Visitor<'a>>(visitor: &mut V, tt: TokenTree) {\n     match tt {\n         TokenTree::Token(_, tok) => visitor.visit_token(tok),\n-        TokenTree::Delimited(_, _, tts) => visitor.visit_tts(tts.stream()),\n+        TokenTree::Delimited(_, _, tts) => visitor.visit_tts(tts),\n     }\n }\n "}, {"sha": "7de9b9343a8faceb33609b220290e37dc5ca9b92", "filename": "src/libsyntax_ext/proc_macro_server.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_server.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -269,7 +269,7 @@ impl ToInternal<TokenStream> for TokenTree<Group, Punct, Ident, Literal> {\n         };\n \n         let tree = tokenstream::TokenTree::Token(span, token);\n-        TokenStream::Tree(tree, if joint { Joint } else { NonJoint })\n+        TokenStream::new(vec![(tree, if joint { Joint } else { NonJoint })])\n     }\n }\n "}, {"sha": "e2f3996927b7f8b93d850c779fd4fe83f78833cc", "filename": "src/test/ui/issues/issue-56488.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Ftest%2Fui%2Fissues%2Fissue-56488.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Ftest%2Fui%2Fissues%2Fissue-56488.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-56488.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -0,0 +1,13 @@\n+// run-pass\n+\n+#![feature(trait_alias)]\n+\n+mod alpha {\n+    pub trait A {}\n+    pub trait C = A;\n+}\n+\n+#[allow(unused_imports)]\n+use alpha::C;\n+\n+fn main() {}"}, {"sha": "0d18965ee73387b6ae1715785235c2d1233f8423", "filename": "src/test/ui/lint/lint-incoherent-auto-trait-objects.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Ftest%2Fui%2Flint%2Flint-incoherent-auto-trait-objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Ftest%2Fui%2Flint%2Flint-incoherent-auto-trait-objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-incoherent-auto-trait-objects.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -0,0 +1,21 @@\n+// ignore-tidy-linelength\n+\n+trait Foo {}\n+\n+impl Foo for dyn Send {}\n+\n+impl Foo for dyn Send + Send {}\n+//~^ ERROR conflicting implementations\n+//~| hard error\n+\n+impl Foo for dyn Send + Sync {}\n+\n+impl Foo for dyn Sync + Send {}\n+//~^ ERROR conflicting implementations\n+//~| hard error\n+\n+impl Foo for dyn Send + Sync + Send {}\n+//~^ ERROR conflicting implementations\n+//~| hard error\n+\n+fn main() {}"}, {"sha": "928c92ef9165531c2beb0c723b1431cd6830113f", "filename": "src/test/ui/lint/lint-incoherent-auto-trait-objects.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Ftest%2Fui%2Flint%2Flint-incoherent-auto-trait-objects.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Ftest%2Fui%2Flint%2Flint-incoherent-auto-trait-objects.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-incoherent-auto-trait-objects.stderr?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -0,0 +1,39 @@\n+error: conflicting implementations of trait `Foo` for type `(dyn std::marker::Send + 'static)`: (E0119)\n+  --> $DIR/lint-incoherent-auto-trait-objects.rs:7:1\n+   |\n+LL | impl Foo for dyn Send {}\n+   | --------------------- first implementation here\n+LL | \n+LL | impl Foo for dyn Send + Send {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `(dyn std::marker::Send + 'static)`\n+   |\n+   = note: #[deny(order_dependent_trait_objects)] on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #56484 <https://github.com/rust-lang/rust/issues/56484>\n+\n+error: conflicting implementations of trait `Foo` for type `(dyn std::marker::Send + std::marker::Sync + 'static)`: (E0119)\n+  --> $DIR/lint-incoherent-auto-trait-objects.rs:13:1\n+   |\n+LL | impl Foo for dyn Send + Sync {}\n+   | ---------------------------- first implementation here\n+LL | \n+LL | impl Foo for dyn Sync + Send {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `(dyn std::marker::Send + std::marker::Sync + 'static)`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #56484 <https://github.com/rust-lang/rust/issues/56484>\n+\n+error: conflicting implementations of trait `Foo` for type `(dyn std::marker::Send + std::marker::Sync + 'static)`: (E0119)\n+  --> $DIR/lint-incoherent-auto-trait-objects.rs:17:1\n+   |\n+LL | impl Foo for dyn Sync + Send {}\n+   | ---------------------------- first implementation here\n+...\n+LL | impl Foo for dyn Send + Sync + Send {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `(dyn std::marker::Send + std::marker::Sync + 'static)`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #56484 <https://github.com/rust-lang/rust/issues/56484>\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "81d23959fd4adc4256aef2b7fe7ab3e273c7ea8e", "filename": "src/test/ui/privacy/private-in-public-assoc-ty.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-assoc-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-assoc-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-assoc-ty.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -1,7 +1,7 @@\n // Private types and traits are not allowed in interfaces of associated types.\n // This test also ensures that the checks are performed even inside private modules.\n \n-#![feature(associated_type_defaults)]\n+#![feature(associated_type_defaults, existential_type)]\n \n mod m {\n     struct Priv;\n@@ -23,10 +23,17 @@ mod m {\n \n         type Alias4 = Priv;\n         //~^ ERROR private type `m::Priv` in public interface\n+\n+        type Exist;\n+        fn infer_exist() -> Self::Exist;\n     }\n     impl PubTr for u8 {\n         type Alias1 = Priv;\n         //~^ ERROR private type `m::Priv` in public interface\n+\n+        existential type Exist: PrivTr;\n+        //~^ ERROR private trait `m::PrivTr` in public interface\n+        fn infer_exist() -> Self::Exist { Priv }\n     }\n }\n "}, {"sha": "0e5dab1a08c37083024ea26fc8b286c04730a7df", "filename": "src/test/ui/privacy/private-in-public-assoc-ty.stderr", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-assoc-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-assoc-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-assoc-ty.stderr?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -6,7 +6,7 @@ LL | |         //~^ WARN private trait `m::PrivTr` in public interface\n LL | |         //~| WARN this was previously accepted\n LL | |         //~| WARN private type `m::Priv` in public interface\n ...  |\n-LL | |         //~^ ERROR private type `m::Priv` in public interface\n+LL | |         fn infer_exist() -> Self::Exist;\n LL | |     }\n    | |_____^\n    |\n@@ -22,7 +22,7 @@ LL | |         //~^ WARN private trait `m::PrivTr` in public interface\n LL | |         //~| WARN this was previously accepted\n LL | |         //~| WARN private type `m::Priv` in public interface\n ...  |\n-LL | |         //~^ ERROR private type `m::Priv` in public interface\n+LL | |         fn infer_exist() -> Self::Exist;\n LL | |     }\n    | |_____^\n    |\n@@ -39,14 +39,24 @@ LL |         type Alias4 = Priv;\n    |         ^^^^^^^^^^^^^^^^^^^ can't leak private type\n \n error[E0446]: private type `m::Priv` in public interface\n-  --> $DIR/private-in-public-assoc-ty.rs:28:9\n+  --> $DIR/private-in-public-assoc-ty.rs:31:9\n    |\n LL |     struct Priv;\n    |     - `m::Priv` declared as private\n ...\n LL |         type Alias1 = Priv;\n    |         ^^^^^^^^^^^^^^^^^^^ can't leak private type\n \n-error: aborting due to 2 previous errors\n+error[E0445]: private trait `m::PrivTr` in public interface\n+  --> $DIR/private-in-public-assoc-ty.rs:34:9\n+   |\n+LL |     trait PrivTr {}\n+   |     - `m::PrivTr` declared as private\n+...\n+LL |         existential type Exist: PrivTr;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n+\n+error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0446`.\n+Some errors occurred: E0445, E0446.\n+For more information about an error, try `rustc --explain E0445`."}, {"sha": "61c6130e47019550cdba73b0dc163f41073446d4", "filename": "src/test/ui/privacy/private-in-public-existential.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-existential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-existential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-existential.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -12,4 +12,14 @@ fn check() -> Pub {\n     Priv\n }\n \n+pub trait Trait {\n+    type Pub: Default;\n+    fn method() -> Self::Pub;\n+}\n+\n+impl Trait for u8 {\n+    existential type Pub: Default;\n+    fn method() -> Self::Pub { Priv }\n+}\n+\n fn main() {}"}, {"sha": "9e56b87e088133d6e632ec47f25b066698297922", "filename": "src/test/ui/traits/auxiliary/trait_alias.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Ftest%2Fui%2Ftraits%2Fauxiliary%2Ftrait_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Ftest%2Fui%2Ftraits%2Fauxiliary%2Ftrait_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fauxiliary%2Ftrait_alias.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -0,0 +1,3 @@\n+#![feature(trait_alias)]\n+\n+pub trait SendSync = Send + Sync;"}, {"sha": "259fc4fa5d1ce9ef2ce92eeb1df727027bd290dd", "filename": "src/test/ui/traits/trait-alias-cross-crate.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-cross-crate.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -0,0 +1,17 @@\n+// aux-build:trait_alias.rs\n+\n+#![feature(trait_alias)]\n+\n+extern crate trait_alias;\n+\n+use std::rc::Rc;\n+use trait_alias::SendSync;\n+\n+fn use_alias<T: SendSync>() {}\n+\n+fn main() {\n+    use_alias::<u32>();\n+    use_alias::<Rc<u32>>();\n+    //~^ ERROR `std::rc::Rc<u32>` cannot be sent between threads safely [E0277]\n+    //~^^ ERROR `std::rc::Rc<u32>` cannot be shared between threads safely [E0277]\n+}"}, {"sha": "972d213ac8f8f30a79de429403850aa998dfbeb9", "filename": "src/test/ui/traits/trait-alias-cross-crate.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-cross-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-cross-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-cross-crate.stderr?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -0,0 +1,29 @@\n+error[E0277]: `std::rc::Rc<u32>` cannot be sent between threads safely\n+  --> $DIR/trait-alias-cross-crate.rs:14:5\n+   |\n+LL |     use_alias::<Rc<u32>>();\n+   |     ^^^^^^^^^^^^^^^^^^^^ `std::rc::Rc<u32>` cannot be sent between threads safely\n+   |\n+   = help: the trait `std::marker::Send` is not implemented for `std::rc::Rc<u32>`\n+note: required by `use_alias`\n+  --> $DIR/trait-alias-cross-crate.rs:10:1\n+   |\n+LL | fn use_alias<T: SendSync>() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: `std::rc::Rc<u32>` cannot be shared between threads safely\n+  --> $DIR/trait-alias-cross-crate.rs:14:5\n+   |\n+LL |     use_alias::<Rc<u32>>();\n+   |     ^^^^^^^^^^^^^^^^^^^^ `std::rc::Rc<u32>` cannot be shared between threads safely\n+   |\n+   = help: the trait `std::marker::Sync` is not implemented for `std::rc::Rc<u32>`\n+note: required by `use_alias`\n+  --> $DIR/trait-alias-cross-crate.rs:10:1\n+   |\n+LL | fn use_alias<T: SendSync>() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "4ca285b9b1db1fe6acc5f200184dee32c353ebd9", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/93234994b85114e3248a216142eaab20c5e2f09e/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93234994b85114e3248a216142eaab20c5e2f09e/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=93234994b85114e3248a216142eaab20c5e2f09e", "patch": "@@ -95,6 +95,7 @@ static TARGETS: &'static [&'static str] = &[\n     \"wasm32-unknown-unknown\",\n     \"x86_64-apple-darwin\",\n     \"x86_64-apple-ios\",\n+    \"x86_64-fortanix-unknown-sgx\",\n     \"x86_64-fuchsia\",\n     \"x86_64-linux-android\",\n     \"x86_64-pc-windows-gnu\","}]}