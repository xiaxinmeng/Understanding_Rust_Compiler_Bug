{"sha": "fd6e4e41b7608c6fcdd34aedfc2d88b27b1ada05", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkNmU0ZTQxYjc2MDhjNmZjZGQzNGFlZGZjMmQ4OGIyN2IxYWRhMDU=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2021-03-18T07:22:04Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2021-03-18T16:47:53Z"}, "message": "BTree: no longer search arrays twice to check Ord", "tree": {"sha": "b4b735a7c0d1c81c7074648c39be682b2b80073a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4b735a7c0d1c81c7074648c39be682b2b80073a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd6e4e41b7608c6fcdd34aedfc2d88b27b1ada05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd6e4e41b7608c6fcdd34aedfc2d88b27b1ada05", "html_url": "https://github.com/rust-lang/rust/commit/fd6e4e41b7608c6fcdd34aedfc2d88b27b1ada05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd6e4e41b7608c6fcdd34aedfc2d88b27b1ada05/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33d22f84000eca68397ba50d5481cfb11ce35145", "url": "https://api.github.com/repos/rust-lang/rust/commits/33d22f84000eca68397ba50d5481cfb11ce35145", "html_url": "https://github.com/rust-lang/rust/commit/33d22f84000eca68397ba50d5481cfb11ce35145"}], "stats": {"total": 60, "additions": 27, "deletions": 33}, "files": [{"sha": "622983996aa08651edb6c36a82f5b868a4152e2b", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd6e4e41b7608c6fcdd34aedfc2d88b27b1ada05/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd6e4e41b7608c6fcdd34aedfc2d88b27b1ada05/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=fd6e4e41b7608c6fcdd34aedfc2d88b27b1ada05", "patch": "@@ -1018,9 +1018,6 @@ impl<K, V> BTreeMap<K, V> {\n     ///\n     /// Panics if range `start > end`.\n     /// Panics if range `start == end` and both bounds are `Excluded`.\n-    /// May panic if the [`Ord`] implementation of type `T` is ill-defined,\n-    /// either because it does not form a total order or because it does not\n-    /// correspond to the [`Ord`] implementation of type `K`.\n     ///\n     /// # Examples\n     ///\n@@ -1064,9 +1061,6 @@ impl<K, V> BTreeMap<K, V> {\n     ///\n     /// Panics if range `start > end`.\n     /// Panics if range `start == end` and both bounds are `Excluded`.\n-    /// May panic if the [`Ord`] implementation of type `T` is ill-defined,\n-    /// either because it does not form a total order or because it does not\n-    /// correspond to the [`Ord`] implementation of type `K`.\n     ///\n     /// # Examples\n     ///"}, {"sha": "3a74b6a6fa85c8f29d366769df6b37ce1b30a2c0", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd6e4e41b7608c6fcdd34aedfc2d88b27b1ada05/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd6e4e41b7608c6fcdd34aedfc2d88b27b1ada05/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=fd6e4e41b7608c6fcdd34aedfc2d88b27b1ada05", "patch": "@@ -776,7 +776,6 @@ fn test_range_backwards_4() {\n }\n \n #[test]\n-#[should_panic]\n fn test_range_finding_ill_order_in_map() {\n     let mut map = BTreeMap::new();\n     map.insert(Cyclic3::B, ());\n@@ -789,7 +788,6 @@ fn test_range_finding_ill_order_in_map() {\n }\n \n #[test]\n-#[should_panic]\n fn test_range_finding_ill_order_in_range_ord() {\n     // Has proper order the first time asked, then flips around.\n     struct EvilTwin(i32);"}, {"sha": "62a048e61c6beed305c15f0967f5be23c1a5d632", "filename": "library/alloc/src/collections/btree/search.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fd6e4e41b7608c6fcdd34aedfc2d88b27b1ada05/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd6e4e41b7608c6fcdd34aedfc2d88b27b1ada05/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs?ref=fd6e4e41b7608c6fcdd34aedfc2d88b27b1ada05", "patch": "@@ -76,9 +76,7 @@ impl<BorrowType: marker::BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Lea\n     /// If not found, returns an `Err` with the leaf edge matching the entire\n     /// range.\n     ///\n-    /// As a diagnostic service, panics if the range specifies impossible bounds\n-    /// or if it witnesses that the `Ord` implementation of `Q` violates total\n-    /// order or is inconsistent with the `Ord` implementation of `K`.\n+    /// As a diagnostic service, panics if the range specifies impossible bounds.\n     ///\n     /// The result is meaningful only if the tree is ordered by key.\n     pub fn search_tree_for_bifurcation<'r, Q: ?Sized, R>(\n@@ -118,14 +116,8 @@ impl<BorrowType: marker::BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Lea\n         let mut upper_bound = SearchBound::from_range(end);\n         loop {\n             let (lower_edge_idx, lower_child_bound) = self.find_lower_bound_index(lower_bound);\n-            let (upper_edge_idx, upper_child_bound) = self.find_upper_bound_index(upper_bound);\n-            if lower_edge_idx > upper_edge_idx {\n-                // Since we already checked the range bounds, this can only\n-                // happen if `Q: Ord` does not implement a total order or does\n-                // not correspond to the `K: Ord` implementation that is used\n-                // while populating the tree.\n-                panic!(\"Ord is ill-defined in BTreeMap range\")\n-            }\n+            let (upper_edge_idx, upper_child_bound) =\n+                unsafe { self.find_upper_bound_index(upper_bound, lower_edge_idx) };\n             if lower_edge_idx < upper_edge_idx {\n                 return Ok((\n                     self,\n@@ -135,6 +127,7 @@ impl<BorrowType: marker::BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Lea\n                     upper_child_bound,\n                 ));\n             }\n+            debug_assert_eq!(lower_edge_idx, upper_edge_idx);\n             let common_edge = unsafe { Handle::new_edge(self, lower_edge_idx) };\n             match common_edge.force() {\n                 Leaf(common_edge) => return Err(common_edge),\n@@ -174,7 +167,7 @@ impl<BorrowType: marker::BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Lea\n         Q: ?Sized + Ord,\n         K: Borrow<Q>,\n     {\n-        let (edge_idx, bound) = self.find_upper_bound_index(bound);\n+        let (edge_idx, bound) = unsafe { self.find_upper_bound_index(bound, 0) };\n         let edge = unsafe { Handle::new_edge(self, edge_idx) };\n         (edge, bound)\n     }\n@@ -193,29 +186,33 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         Q: Ord,\n         K: Borrow<Q>,\n     {\n-        match self.find_key_index(key) {\n+        match unsafe { self.find_key_index(key, 0) } {\n             IndexResult::KV(idx) => Found(unsafe { Handle::new_kv(self, idx) }),\n             IndexResult::Edge(idx) => GoDown(unsafe { Handle::new_edge(self, idx) }),\n         }\n     }\n \n     /// Returns either the KV index in the node at which the key (or an equivalent)\n-    /// exists, or the edge index where the key belongs.\n+    /// exists, or the edge index where the key belongs, starting from a particular index.\n     ///\n     /// The result is meaningful only if the tree is ordered by key, like the tree\n     /// in a `BTreeMap` is.\n-    fn find_key_index<Q: ?Sized>(&self, key: &Q) -> IndexResult\n+    ///\n+    /// # Safety\n+    /// `start_index` must be a valid edge index for the node.\n+    unsafe fn find_key_index<Q: ?Sized>(&self, key: &Q, start_index: usize) -> IndexResult\n     where\n         Q: Ord,\n         K: Borrow<Q>,\n     {\n         let node = self.reborrow();\n         let keys = node.keys();\n-        for (i, k) in keys.iter().enumerate() {\n+        debug_assert!(start_index <= keys.len());\n+        for (offset, k) in unsafe { keys.get_unchecked(start_index..) }.iter().enumerate() {\n             match key.cmp(k.borrow()) {\n                 Ordering::Greater => {}\n-                Ordering::Equal => return IndexResult::KV(i),\n-                Ordering::Less => return IndexResult::Edge(i),\n+                Ordering::Equal => return IndexResult::KV(start_index + offset),\n+                Ordering::Less => return IndexResult::Edge(start_index + offset),\n             }\n         }\n         IndexResult::Edge(keys.len())\n@@ -235,11 +232,11 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         K: Borrow<Q>,\n     {\n         match bound {\n-            Included(key) => match self.find_key_index(key) {\n+            Included(key) => match unsafe { self.find_key_index(key, 0) } {\n                 IndexResult::KV(idx) => (idx, AllExcluded),\n                 IndexResult::Edge(idx) => (idx, bound),\n             },\n-            Excluded(key) => match self.find_key_index(key) {\n+            Excluded(key) => match unsafe { self.find_key_index(key, 0) } {\n                 IndexResult::KV(idx) => (idx + 1, AllIncluded),\n                 IndexResult::Edge(idx) => (idx, bound),\n             },\n@@ -248,26 +245,31 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         }\n     }\n \n-    /// Clone of `find_lower_bound_index` for the upper bound.\n-    fn find_upper_bound_index<'r, Q>(\n+    /// Mirror image of `find_lower_bound_index` for the upper bound,\n+    /// with an additional parameter to skip part of the key array.\n+    ///\n+    /// # Safety\n+    /// `start_index` must be a valid edge index for the node.\n+    unsafe fn find_upper_bound_index<'r, Q>(\n         &self,\n         bound: SearchBound<&'r Q>,\n+        start_index: usize,\n     ) -> (usize, SearchBound<&'r Q>)\n     where\n         Q: ?Sized + Ord,\n         K: Borrow<Q>,\n     {\n         match bound {\n-            Included(key) => match self.find_key_index(key) {\n+            Included(key) => match unsafe { self.find_key_index(key, start_index) } {\n                 IndexResult::KV(idx) => (idx + 1, AllExcluded),\n                 IndexResult::Edge(idx) => (idx, bound),\n             },\n-            Excluded(key) => match self.find_key_index(key) {\n+            Excluded(key) => match unsafe { self.find_key_index(key, start_index) } {\n                 IndexResult::KV(idx) => (idx, AllIncluded),\n                 IndexResult::Edge(idx) => (idx, bound),\n             },\n             AllIncluded => (self.len(), AllIncluded),\n-            AllExcluded => (0, AllExcluded),\n+            AllExcluded => (start_index, AllExcluded),\n         }\n     }\n }"}]}