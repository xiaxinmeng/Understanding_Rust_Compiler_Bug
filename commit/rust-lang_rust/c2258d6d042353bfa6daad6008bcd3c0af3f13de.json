{"sha": "c2258d6d042353bfa6daad6008bcd3c0af3f13de", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyMjU4ZDZkMDQyMzUzYmZhNmRhYWQ2MDA4YmNkM2MwYWYzZjEzZGU=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-04-08T04:25:22Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-04-10T04:42:17Z"}, "message": "Optimise Iterator::{max, max_by, min, min_by}.\n\nThe main change in this patch is removing the use of `Option` inside the\ninner loops of those functions to avoid comparisons where one branch\nwill only trigger on the first pass through the loop.\n\nThe included benchmarks go from:\n\n    test bench_max    ... bench:       372 ns/iter (+/- 118)\n    test bench_max_by ... bench:       428 ns/iter (+/- 33)\n    test bench_max_by2 ... bench:      7128 ns/iter (+/- 326)\n\nto:\n\n    test bench_max    ... bench:       317 ns/iter (+/- 64)\n    test bench_max_by ... bench:       356 ns/iter (+/- 270)\n    test bench_max_by2 ... bench:      1387 ns/iter (+/- 183)\n\nProblem noticed in http://www.reddit.com/r/rust/comments/31syce/using_iterators_to_find_the_index_of_the_min_or/", "tree": {"sha": "fcba6d8badc0d442aea89d98f8b3470b26df2b60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fcba6d8badc0d442aea89d98f8b3470b26df2b60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2258d6d042353bfa6daad6008bcd3c0af3f13de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2258d6d042353bfa6daad6008bcd3c0af3f13de", "html_url": "https://github.com/rust-lang/rust/commit/c2258d6d042353bfa6daad6008bcd3c0af3f13de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2258d6d042353bfa6daad6008bcd3c0af3f13de/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9146bf8ba0bdf98a46c4656899e54802e96ac0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9146bf8ba0bdf98a46c4656899e54802e96ac0c", "html_url": "https://github.com/rust-lang/rust/commit/d9146bf8ba0bdf98a46c4656899e54802e96ac0c"}], "stats": {"total": 124, "additions": 88, "deletions": 36}, "files": [{"sha": "8feae0bfb09eb46c25d7f31f48f498f1eadf6684", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 57, "deletions": 36, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/c2258d6d042353bfa6daad6008bcd3c0af3f13de/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2258d6d042353bfa6daad6008bcd3c0af3f13de/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=c2258d6d042353bfa6daad6008bcd3c0af3f13de", "patch": "@@ -743,12 +743,12 @@ pub trait Iterator {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn max(self) -> Option<Self::Item> where Self: Sized, Self::Item: Ord\n     {\n-        self.fold(None, |max, y| {\n-            match max {\n-                None    => Some(y),\n-                Some(x) => Some(cmp::max(x, y))\n-            }\n-        })\n+        select_fold1(self,\n+                     |_| (),\n+                     // switch to y even if it is only equal, to preserve\n+                     // stability.\n+                     |_, x, _, y| *x <= *y)\n+            .map(|(_, x)| x)\n     }\n \n     /// Consumes the entire iterator to return the minimum element.\n@@ -766,12 +766,12 @@ pub trait Iterator {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn min(self) -> Option<Self::Item> where Self: Sized, Self::Item: Ord\n     {\n-        self.fold(None, |min, y| {\n-            match min {\n-                None    => Some(y),\n-                Some(x) => Some(cmp::min(x, y))\n-            }\n-        })\n+        select_fold1(self,\n+                     |_| (),\n+                     // only switch to y if it is strictly smaller, to\n+                     // preserve stability.\n+                     |_, x, _, y| *x > *y)\n+            .map(|(_, x)| x)\n     }\n \n     /// `min_max` finds the minimum and maximum elements in the iterator.\n@@ -869,21 +869,16 @@ pub trait Iterator {\n     #[inline]\n     #[unstable(feature = \"core\",\n                reason = \"may want to produce an Ordering directly; see #15311\")]\n-    fn max_by<B: Ord, F>(self, mut f: F) -> Option<Self::Item> where\n+    fn max_by<B: Ord, F>(self, f: F) -> Option<Self::Item> where\n         Self: Sized,\n         F: FnMut(&Self::Item) -> B,\n     {\n-        self.fold(None, |max: Option<(Self::Item, B)>, y| {\n-            let y_val = f(&y);\n-            match max {\n-                None             => Some((y, y_val)),\n-                Some((x, x_val)) => if y_val >= x_val {\n-                    Some((y, y_val))\n-                } else {\n-                    Some((x, x_val))\n-                }\n-            }\n-        }).map(|(x, _)| x)\n+        select_fold1(self,\n+                     f,\n+                     // switch to y even if it is only equal, to preserve\n+                     // stability.\n+                     |x_p, _, y_p, _| x_p <= y_p)\n+            .map(|(_, x)| x)\n     }\n \n     /// Return the element that gives the minimum value from the\n@@ -903,21 +898,16 @@ pub trait Iterator {\n     #[inline]\n     #[unstable(feature = \"core\",\n                reason = \"may want to produce an Ordering directly; see #15311\")]\n-    fn min_by<B: Ord, F>(self, mut f: F) -> Option<Self::Item> where\n+    fn min_by<B: Ord, F>(self, f: F) -> Option<Self::Item> where\n         Self: Sized,\n         F: FnMut(&Self::Item) -> B,\n     {\n-        self.fold(None, |min: Option<(Self::Item, B)>, y| {\n-            let y_val = f(&y);\n-            match min {\n-                None             => Some((y, y_val)),\n-                Some((x, x_val)) => if x_val <= y_val {\n-                    Some((x, x_val))\n-                } else {\n-                    Some((y, y_val))\n-                }\n-            }\n-        }).map(|(x, _)| x)\n+        select_fold1(self,\n+                     f,\n+                     // only switch to y if it is strictly smaller, to\n+                     // preserve stability.\n+                     |x_p, _, y_p, _| x_p > y_p)\n+            .map(|(_, x)| x)\n     }\n \n     /// Change the direction of the iterator\n@@ -1024,6 +1014,37 @@ pub trait Iterator {\n     }\n }\n \n+/// Select an element from an iterator based on the given projection\n+/// and \"comparison\" function.\n+///\n+/// This is an idiosyncratic helper to try to factor out the\n+/// commonalities of {max,min}{,_by}. In particular, this avoids\n+/// having to implement optimisations several times.\n+#[inline]\n+fn select_fold1<I,B, FProj, FCmp>(mut it: I,\n+                                  mut f_proj: FProj,\n+                                  mut f_cmp: FCmp) -> Option<(B, I::Item)>\n+    where I: Iterator,\n+          FProj: FnMut(&I::Item) -> B,\n+          FCmp: FnMut(&B, &I::Item, &B, &I::Item) -> bool\n+{\n+    // start with the first element as our selection. This avoids\n+    // having to use `Option`s inside the loop, translating to a\n+    // sizeable performance gain (6x in one case).\n+    it.next().map(|mut sel| {\n+        let mut sel_p = f_proj(&sel);\n+\n+        for x in it {\n+            let x_p = f_proj(&x);\n+            if f_cmp(&sel_p,  &sel, &x_p, &x) {\n+                sel = x;\n+                sel_p = x_p;\n+            }\n+        }\n+        (sel_p, sel)\n+    })\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, I: Iterator + ?Sized> Iterator for &'a mut I {\n     type Item = I::Item;"}, {"sha": "ef050d46e1f53dfd811ca3e0c252a846b5578b74", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c2258d6d042353bfa6daad6008bcd3c0af3f13de/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2258d6d042353bfa6daad6008bcd3c0af3f13de/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=c2258d6d042353bfa6daad6008bcd3c0af3f13de", "patch": "@@ -901,3 +901,34 @@ fn bench_multiple_take(b: &mut Bencher) {\n         }\n     });\n }\n+\n+fn scatter(x: i32) -> i32 { (x * 31) % 127 }\n+\n+#[bench]\n+fn bench_max_by(b: &mut Bencher) {\n+    b.iter(|| {\n+        let it = 0..100;\n+        it.max_by(|&x| scatter(x))\n+    })\n+}\n+\n+// http://www.reddit.com/r/rust/comments/31syce/using_iterators_to_find_the_index_of_the_min_or/\n+#[bench]\n+fn bench_max_by2(b: &mut Bencher) {\n+    fn max_index_iter(array: &[i32]) -> usize {\n+        array.iter().enumerate().max_by(|&(_, item)| item).unwrap().0\n+    }\n+\n+    let mut data = vec![0i32; 1638];\n+    data[514] = 9999;\n+\n+    b.iter(|| max_index_iter(&data));\n+}\n+\n+#[bench]\n+fn bench_max(b: &mut Bencher) {\n+    b.iter(|| {\n+        let it = 0..100;\n+        it.map(scatter).max()\n+    })\n+}"}]}