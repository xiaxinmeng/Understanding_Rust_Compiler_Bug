{"sha": "b709a7ebc53f9c61890590233ee4defc5b9b5c2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3MDlhN2ViYzUzZjljNjE4OTA1OTAyMzNlZTRkZWZjNWI5YjVjMmM=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-11-06T02:52:42Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-11-06T02:52:42Z"}, "message": "save-analysis: fix bugs in method chains\n\nUse the span we save in the PathSegment for a method call, rather than searching for it in the text.\n\nFixes https://github.com/nrc/rls-analysis/issues/111", "tree": {"sha": "7a7c9f28e4e4ded04d5cd7c82800a4a750090970", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a7c9f28e4e4ded04d5cd7c82800a4a750090970"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b709a7ebc53f9c61890590233ee4defc5b9b5c2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b709a7ebc53f9c61890590233ee4defc5b9b5c2c", "html_url": "https://github.com/rust-lang/rust/commit/b709a7ebc53f9c61890590233ee4defc5b9b5c2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b709a7ebc53f9c61890590233ee4defc5b9b5c2c/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "099f96472fb89dd03c8c01f5a9b68b7e5e25a23c", "url": "https://api.github.com/repos/rust-lang/rust/commits/099f96472fb89dd03c8c01f5a9b68b7e5e25a23c", "html_url": "https://github.com/rust-lang/rust/commit/099f96472fb89dd03c8c01f5a9b68b7e5e25a23c"}], "stats": {"total": 77, "additions": 20, "deletions": 57}, "files": [{"sha": "d190ae1431fd80db73e78f9d15c27645a924f7d2", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b709a7ebc53f9c61890590233ee4defc5b9b5c2c/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b709a7ebc53f9c61890590233ee4defc5b9b5c2c/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=b709a7ebc53f9c61890590233ee4defc5b9b5c2c", "patch": "@@ -878,6 +878,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                            ex: &'l ast::Expr,\n                            seg: &'l ast::PathSegment,\n                            args: &'l [P<ast::Expr>]) {\n+        debug!(\"process_method_call {:?} {:?}\", ex, ex.span);\n         if let Some(mcd) = self.save_ctxt.get_expr_data(ex) {\n             down_cast_data!(mcd, RefData, ex.span);\n             if !generated_code(ex.span) {"}, {"sha": "edb51ae59e1b56c8b431893212f0e0fd87aa9693", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b709a7ebc53f9c61890590233ee4defc5b9b5c2c/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b709a7ebc53f9c61890590233ee4defc5b9b5c2c/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=b709a7ebc53f9c61890590233ee4defc5b9b5c2c", "patch": "@@ -546,16 +546,16 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     }\n                 }\n             }\n-            ast::ExprKind::MethodCall(..) => {\n+            ast::ExprKind::MethodCall(ref seg, ..) => {\n                 let expr_hir_id = self.tcx.hir.definitions().node_to_hir_id(expr.id);\n                 let method_id = self.tables.type_dependent_defs()[expr_hir_id].def_id();\n                 let (def_id, decl_id) = match self.tcx.associated_item(method_id).container {\n                     ty::ImplContainer(_) => (Some(method_id), None),\n                     ty::TraitContainer(_) => (None, Some(method_id)),\n                 };\n-                let sub_span = self.span_utils.sub_span_for_meth_name(expr.span);\n-                filter!(self.span_utils, sub_span, expr.span, None);\n-                let span = self.span_from_span(sub_span.unwrap());\n+                let sub_span = seg.span;\n+                filter!(self.span_utils, Some(sub_span), expr.span, None);\n+                let span = self.span_from_span(sub_span);\n                 Some(Data::RefData(Ref {\n                     kind: RefKind::Function,\n                     span,\n@@ -627,13 +627,18 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             false\n         }\n \n+        if path.segments.is_empty() {\n+            return None;\n+        }\n+\n         let def = self.get_path_def(id);\n-        let sub_span = self.span_utils.span_for_last_ident(path.span);\n-        filter!(self.span_utils, sub_span, path.span, None);\n+        let last_seg = &path.segments[path.segments.len() - 1];\n+        let sub_span = last_seg.span;\n+        filter!(self.span_utils, Some(sub_span), path.span, None);\n         match def {\n             HirDef::Upvar(id, ..) |\n             HirDef::Local(id) => {\n-                let span = self.span_from_span(sub_span.unwrap());\n+                let span = self.span_from_span(sub_span);\n                 Some(Ref {\n                     kind: RefKind::Variable,\n                     span,\n@@ -644,7 +649,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             HirDef::Const(..) |\n             HirDef::AssociatedConst(..) |\n             HirDef::VariantCtor(..) => {\n-                let span = self.span_from_span(sub_span.unwrap());\n+                let span = self.span_from_span(sub_span);\n                 Some(Ref {\n                     kind: RefKind::Variable,\n                     span,\n@@ -670,7 +675,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             HirDef::AssociatedTy(def_id) |\n             HirDef::Trait(def_id) |\n             HirDef::TyParam(def_id) => {\n-                let span = self.span_from_span(sub_span.unwrap());\n+                let span = self.span_from_span(sub_span);\n                 Some(Ref {\n                     kind: RefKind::Type,\n                     span,\n@@ -681,7 +686,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 // This is a reference to a tuple struct where the def_id points\n                 // to an invisible constructor function. That is not a very useful\n                 // def, so adjust to point to the tuple struct itself.\n-                let span = self.span_from_span(sub_span.unwrap());\n+                let span = self.span_from_span(sub_span);\n                 let parent_def_id = self.tcx.parent_def_id(def_id).unwrap();\n                 Some(Ref {\n                     kind: RefKind::Type,\n@@ -690,8 +695,6 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 })\n             }\n             HirDef::Method(decl_id) => {\n-                let sub_span = self.span_utils.sub_span_for_meth_name(path.span);\n-                filter!(self.span_utils, sub_span, path.span, None);\n                 let def_id = if decl_id.is_local() {\n                     let ti = self.tcx.associated_item(decl_id);\n                     self.tcx.associated_items(ti.container.id())\n@@ -700,23 +703,23 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 } else {\n                     None\n                 };\n-                let span = self.span_from_span(sub_span.unwrap());\n+                let span = self.span_from_span(sub_span);\n                 Some(Ref {\n                     kind: RefKind::Function,\n                     span,\n                     ref_id: id_from_def_id(def_id.unwrap_or(decl_id)),\n                 })\n             }\n             HirDef::Fn(def_id) => {\n-                let span = self.span_from_span(sub_span.unwrap());\n+                let span = self.span_from_span(sub_span);\n                 Some(Ref {\n                     kind: RefKind::Function,\n                     span,\n                     ref_id: id_from_def_id(def_id),\n                 })\n             }\n             HirDef::Mod(def_id) => {\n-                let span = self.span_from_span(sub_span.unwrap());\n+                let span = self.span_from_span(sub_span);\n                 Some(Ref {\n                     kind: RefKind::Mod,\n                     span,"}, {"sha": "5bfb4d1b3b20389546be7f1fba6538b64fe5165f", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 1, "deletions": 42, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b709a7ebc53f9c61890590233ee4defc5b9b5c2c/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b709a7ebc53f9c61890590233ee4defc5b9b5c2c/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=b709a7ebc53f9c61890590233ee4defc5b9b5c2c", "patch": "@@ -103,47 +103,6 @@ impl<'a> SpanUtils<'a> {\n         }\n     }\n \n-    // Return the span for the last ident before a `(` or `<` or '::<' and outside any\n-    // any brackets, or the last span.\n-    pub fn sub_span_for_meth_name(&self, span: Span) -> Option<Span> {\n-        let mut toks = self.retokenise_span(span);\n-        let mut prev = toks.real_token();\n-        let mut result = None;\n-        let mut bracket_count = 0;\n-        let mut prev_span = None;\n-        while prev.tok != token::Eof {\n-            prev_span = None;\n-            let mut next = toks.real_token();\n-\n-            if (next.tok == token::OpenDelim(token::Paren) || next.tok == token::Lt) &&\n-               bracket_count == 0 && prev.tok.is_ident() {\n-                result = Some(prev.sp);\n-            }\n-\n-            if bracket_count == 0 && next.tok == token::ModSep {\n-                let old = prev;\n-                prev = next;\n-                next = toks.real_token();\n-                if next.tok == token::Lt && old.tok.is_ident() {\n-                    result = Some(old.sp);\n-                }\n-            }\n-\n-            bracket_count += match prev.tok {\n-                token::OpenDelim(token::Paren) | token::Lt => 1,\n-                token::CloseDelim(token::Paren) | token::Gt => -1,\n-                token::BinOp(token::Shr) => -2,\n-                _ => 0,\n-            };\n-\n-            if prev.tok.is_ident() && bracket_count == 0 {\n-                prev_span = Some(prev.sp);\n-            }\n-            prev = next;\n-        }\n-        result.or(prev_span)\n-    }\n-\n     // Return the span for the last ident before a `<` and outside any\n     // angle brackets, or the last span.\n     pub fn sub_span_for_type_name(&self, span: Span) -> Option<Span> {\n@@ -330,7 +289,7 @@ impl<'a> SpanUtils<'a> {\n }\n \n macro_rules! filter {\n-    ($util: expr, $span: ident, $parent: expr, None) => {\n+    ($util: expr, $span: expr, $parent: expr, None) => {\n         if $util.filter_generated($span, $parent) {\n             return None;\n         }"}]}