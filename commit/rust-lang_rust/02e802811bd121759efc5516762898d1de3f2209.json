{"sha": "02e802811bd121759efc5516762898d1de3f2209", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyZTgwMjgxMWJkMTIxNzU5ZWZjNTUxNjc2Mjg5OGQxZGUzZjIyMDk=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-06-20T04:18:43Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-07-25T08:20:45Z"}, "message": "implement stub validity check for basic types (bool, int, float); acquire locks for references", "tree": {"sha": "13bba811df231078d276b584285288deec1a71e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13bba811df231078d276b584285288deec1a71e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02e802811bd121759efc5516762898d1de3f2209", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAll2/10ACgkQpp+NIls6\n19mnJhAAquNF9j+d/kirBGKo7fbAVbvJBtV8aKPRGniV/F2JFYBxpz/6idJATN9A\nHb3yX5ea5R69+20yu1JlBx1udBNXEz9qA6U14PcDzBFpjrojDWGhnPWa9inn7VNR\ne5gbiinFaCrtVog9yXR5SBABP5mE0wV+g7NKS6xosH/sGxrYNWPV036hMtf9ItTZ\nBj1SAEGTV/P//uf596L3WOZtFcaap5hggJsWEOxwgXoDCi5IEZqUoMLWfGuLGvfr\nyQG5hZyTrH0MR9LnGmc1/OSFmj+iGR575S0xMxKpQS4LRvJh6xTa/JIHNAjq2h79\nn2z3REFAGwe9AQ3f2iEiuC3iOrq+n+QW1Z986WMsiDozvtf2N1vWnxgDIFOZqOeG\nUMDk8Nssc/Un4ikNnYiOzdTaV1CZmmfQdW7WknmiV4gUZScRKaBRfAr9OIOHg1hn\n7YzlojWawSCJwIKueVcWsgucz2OGAtEDaYUELJXdXnvBpcw+2Hb+1Rf5vlPST4w3\nif+ttzOwGHgspfDJQFjUeXBj273xnjVCb1NYYZvj6om3oCY0GXWKHHfwebG30w9n\nVLmaKuCRS6XtJjwMEZY84KM4ZYC1FJZGjsbbA4ThpsbV+Q5jQFfBGCuaAdDsJ8ZP\nx/PpKfDYIKgyfkuIYu6GAdgfOo1NMHRdskoPFygJSQpLZzgI+LE=\n=V0o1\n-----END PGP SIGNATURE-----", "payload": "tree 13bba811df231078d276b584285288deec1a71e1\nparent edc6ce30d540f114ed73d3936b349d732f94d1ef\nauthor Ralf Jung <post@ralfj.de> 1497932323 -0700\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1500970845 +0200\n\nimplement stub validity check for basic types (bool, int, float); acquire locks for references\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02e802811bd121759efc5516762898d1de3f2209", "html_url": "https://github.com/rust-lang/rust/commit/02e802811bd121759efc5516762898d1de3f2209", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02e802811bd121759efc5516762898d1de3f2209/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "edc6ce30d540f114ed73d3936b349d732f94d1ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/edc6ce30d540f114ed73d3936b349d732f94d1ef", "html_url": "https://github.com/rust-lang/rust/commit/edc6ce30d540f114ed73d3936b349d732f94d1ef"}], "stats": {"total": 140, "additions": 112, "deletions": 28}, "files": [{"sha": "ee80b151e689c1bbf299d1e4aea8a7061e96097e", "filename": "src/librustc_mir/interpret/lvalue.rs", "status": "modified", "additions": 90, "deletions": 22, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/02e802811bd121759efc5516762898d1de3f2209/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e802811bd121759efc5516762898d1de3f2209/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs?ref=02e802811bd121759efc5516762898d1de3f2209", "patch": "@@ -1,13 +1,14 @@\n+use rustc::hir::Mutability as TyMutability;\n use rustc::mir;\n use rustc::ty::layout::{Size, Align};\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, Ty, TypeAndMut};\n use rustc_data_structures::indexed_vec::Idx;\n use syntax::ast::Mutability;\n \n use error::{EvalError, EvalResult};\n use eval_context::EvalContext;\n-use memory::MemoryPointer;\n-use value::{PrimVal, Value, Pointer};\n+use memory::{MemoryPointer, AccessKind};\n+use value::{PrimVal, Pointer, Value};\n \n #[derive(Copy, Clone, Debug)]\n pub enum Lvalue<'tcx> {\n@@ -349,6 +350,32 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(Lvalue::Ptr { ptr, extra, aligned: aligned && !packed })\n     }\n \n+    fn val_to_lvalue(&mut self, val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+        Ok(match self.tcx.struct_tail(ty).sty {\n+            ty::TyDynamic(..) => {\n+                let (ptr, vtable) = val.into_ptr_vtable_pair(&mut self.memory)?;\n+                Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable), aligned: true }\n+            },\n+            ty::TyStr | ty::TySlice(_) => {\n+                let (ptr, len) = val.into_slice(&mut self.memory)?;\n+                Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len), aligned: true }\n+            },\n+            _ => Lvalue::Ptr { ptr: val.into_ptr(&mut self.memory)?, extra: LvalueExtra::None, aligned: true },\n+        })\n+    }\n+\n+    fn lvalue_index(&mut self, base: Lvalue<'tcx>, outer_ty: Ty<'tcx>, n: u64) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+        // Taking the outer type here may seem odd; it's needed because for array types, the outer type gives away the length.\n+        let base = self.force_allocation(base)?;\n+        let (base_ptr, _, aligned) = base.to_ptr_extra_aligned();\n+\n+        let (elem_ty, len) = base.elem_ty_and_len(outer_ty);\n+        let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n+        assert!(n < len, \"Tried to access element {} of array/slice with length {}\", n, len);\n+        let ptr = base_ptr.offset(n * elem_size, self.memory.layout)?;\n+        Ok(Lvalue::Ptr { ptr, extra: LvalueExtra::None, aligned })\n+    }\n+\n     fn eval_lvalue_projection(\n         &mut self,\n         base: Lvalue<'tcx>,\n@@ -388,32 +415,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 trace!(\"deref to {} on {:?}\", pointee_type, val);\n \n-                match self.tcx.struct_tail(pointee_type).sty {\n-                    ty::TyDynamic(..) => {\n-                        let (ptr, vtable) = val.into_ptr_vtable_pair(&mut self.memory)?;\n-                        (ptr, LvalueExtra::Vtable(vtable), true)\n-                    },\n-                    ty::TyStr | ty::TySlice(_) => {\n-                        let (ptr, len) = val.into_slice(&mut self.memory)?;\n-                        (ptr, LvalueExtra::Length(len), true)\n-                    },\n-                    _ => (val.into_ptr(&mut self.memory)?, LvalueExtra::None, true),\n-                }\n+                return self.val_to_lvalue(val, pointee_type);\n             }\n \n             Index(ref operand) => {\n                 // FIXME(solson)\n-                let base = self.force_allocation(base)?;\n-                let (base_ptr, _, aligned) = base.to_ptr_extra_aligned();\n-\n-                let (elem_ty, len) = base.elem_ty_and_len(base_ty);\n-                let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n                 let n_ptr = self.eval_operand(operand)?;\n                 let usize = self.tcx.types.usize;\n                 let n = self.value_to_primval(n_ptr, usize)?.to_u64()?;\n-                assert!(n < len, \"Tried to access element {} of array/slice with length {}\", n, len);\n-                let ptr = base_ptr.offset(n * elem_size, &self)?;\n-                (ptr, LvalueExtra::None, aligned)\n+                return self.lvalue_index(base, base_ty, n);\n             }\n \n             ConstantIndex { offset, min_length, from_end } => {\n@@ -456,3 +466,61 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.monomorphize(lvalue.ty(self.mir(), self.tcx).to_ty(self.tcx), self.substs())\n     }\n }\n+\n+// Validity checks\n+impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+    pub(super) fn acquire_valid(&mut self, lvalue: Lvalue<'tcx>, ty: Ty<'tcx>, outer_mutbl: TyMutability) -> EvalResult<'tcx> {\n+        use rustc::ty::TypeVariants::*;\n+        use rustc::ty::RegionKind::*;\n+        use self::TyMutability::*;\n+\n+        trace!(\"Validating {:?} at type {}, outer mutability {:?}\", lvalue, ty, outer_mutbl);\n+        match ty.sty {\n+            TyChar | TyInt(_) | TyUint(_) | TyRawPtr(_) => {\n+                // TODO: Make sure these are not undef.\n+                // We could do a bounds-check and other sanity checks on the lvalue, but it would be a bug in miri for this to ever fail.\n+                Ok(())\n+            }\n+            TyBool | TyFloat(_) | TyStr => {\n+                // TODO: Check if these are valid bool/float/UTF-8, respectively (and in particular, not undef).\n+                Ok(())\n+            }\n+            TyRef(region, TypeAndMut { ty: pointee_ty, mutbl }) => {\n+                // Acquire lock\n+                let val = self.read_lvalue(lvalue)?;\n+                let (len, _) = self.size_and_align_of_dst(pointee_ty, val)?;\n+                let ptr = val.into_ptr(&mut self.memory)?.to_ptr()?;\n+                let combined_mutbl = match outer_mutbl { MutMutable => mutbl, MutImmutable => MutImmutable };\n+                let access = match combined_mutbl { MutMutable => AccessKind::Write, MutImmutable => AccessKind::Read };\n+                let region = match *region {\n+                    ReScope(extent) => Some(extent),\n+                    _ => None,\n+                };\n+                self.memory.acquire_lock(ptr, len, region, access)?;\n+\n+                // Recurse\n+                let pointee_lvalue = self.val_to_lvalue(val, pointee_ty)?;\n+                self.acquire_valid(pointee_lvalue, pointee_ty, combined_mutbl)\n+            }\n+            TySlice(elem_ty) => {\n+                let len = match lvalue {\n+                    Lvalue::Ptr { extra: LvalueExtra::Length(len), .. } => len,\n+                    _ => bug!(\"acquire_valid of a TySlice given non-slice lvalue: {:?}\", lvalue),\n+                };\n+                for i in 0..len {\n+                    let inner_lvalue = self.lvalue_index(lvalue, ty, i)?;\n+                    self.acquire_valid(inner_lvalue, elem_ty, outer_mutbl)?;\n+                }\n+                Ok(())\n+            }\n+            TyFnPtr(_sig) => {\n+                // TODO: The function names here could need some improvement.\n+                let ptr = self.read_lvalue(lvalue)?.into_ptr(&mut self.memory)?.to_ptr()?;\n+                self.memory.get_fn(ptr)?;\n+                // TODO: Check if the signature matches (should be the same check as what terminator/mod.rs already does on call?).\n+                Ok(())\n+            }\n+            _ => unimplemented!(\"Unimplemented type encountered when checking validity.\")\n+        }\n+    }\n+}"}, {"sha": "e7ed1c002cd5bb4084dd243da18fec4a6d00f24c", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/02e802811bd121759efc5516762898d1de3f2209/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e802811bd121759efc5516762898d1de3f2209/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=02e802811bd121759efc5516762898d1de3f2209", "patch": "@@ -76,9 +76,9 @@ pub enum AccessKind {\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub struct DynamicLifetime {\n-    frame: usize,\n-    region: Option<CodeExtent>, // \"None\" indicates \"until the function ends\"\n+struct DynamicLifetime {\n+    pub frame: usize,\n+    pub region: Option<CodeExtent>, // \"None\" indicates \"until the function ends\"\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -524,6 +524,10 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     /// Acquire the lock for the given lifetime\n     pub(crate) fn acquire_lock(&mut self, ptr: MemoryPointer, len: u64, region: Option<CodeExtent>, kind: AccessKind) -> EvalResult<'tcx> {\n+        trace!(\"Acquiring {:?} lock at {:?}, size {}\", kind, ptr, len);\n+        if len == 0 {\n+            return Ok(());\n+        }\n         self.check_bounds(ptr.offset(len, self.layout)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         self.check_locks(ptr, len, kind)?; // make sure we have the access we are acquiring\n         let lifetime = DynamicLifetime { frame: self.cur_frame, region };\n@@ -534,6 +538,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     /// Release a lock prematurely\n     pub(crate) fn release_lock_until(&mut self, ptr: MemoryPointer, len: u64, release_until: Option<CodeExtent>) -> EvalResult<'tcx> {\n+        // TODO: More tracing.\n         // Make sure there are no read locks and no *other* write locks here\n         if let Err(_) = self.check_locks(ptr, len, AccessKind::Write) {\n             return Err(EvalError::InvalidMemoryLockRelease { ptr, len });\n@@ -559,6 +564,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     pub(crate) fn locks_lifetime_ended(&mut self, ending_region: Option<CodeExtent>) {\n+        // TODO: More tracing.\n         let cur_frame = self.cur_frame;\n         let has_ended =  |lock: &LockInfo| -> bool {\n             if lock.lifetime.frame != cur_frame {"}, {"sha": "9f3fae569eb71f0725d04043b19f95f90114ce13", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/02e802811bd121759efc5516762898d1de3f2209/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e802811bd121759efc5516762898d1de3f2209/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=02e802811bd121759efc5516762898d1de3f2209", "patch": "@@ -5,7 +5,7 @@\n use rustc::hir::def_id::DefId;\n use rustc::hir;\n use rustc::mir::visit::{Visitor, LvalueContext};\n-use rustc::mir;\n+use rustc::mir::{self, ValidationOp};\n use rustc::traits::Reveal;\n use rustc::ty::layout::Layout;\n use rustc::ty::{subst, self};\n@@ -130,8 +130,18 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.deallocate_local(old_val)?;\n             }\n \n-            // Validity checks.  Not yet implemented.\n-            Validate(_, _) => {}\n+            // Validity checks.\n+            Validate(ref op, ref lvalues) => {\n+                match *op {\n+                    ValidationOp::Acquire => {\n+                        for operand in lvalues {\n+                            let lvalue = self.eval_lvalue(&operand.lval)?;\n+                            self.acquire_valid(lvalue, operand.ty, hir::MutMutable)?;\n+                        }\n+                    }\n+                    _ => { /* not yet implemented */ }\n+                }\n+            }\n \n             // Just a borrowck thing\n             EndRegion(..) => {}"}]}