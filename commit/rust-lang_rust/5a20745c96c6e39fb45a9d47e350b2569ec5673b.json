{"sha": "5a20745c96c6e39fb45a9d47e350b2569ec5673b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhMjA3NDVjOTZjNmUzOWZiNDVhOWQ0N2UzNTBiMjU2OWVjNTY3M2I=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-22T13:32:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-22T13:32:17Z"}, "message": "Rollup merge of #62799 - RalfJung:uninit-array, r=Centril\n\nuse const array repeat expressions for uninit_array\n\nWith a first implementation of https://github.com/rust-lang/rust/issues/49147 having landed, we can make this macro nicer and phase it out with the next bootstrap bump.\n\nHowever, to make this work, we have to mark `MaybeUninit::uninit()` as promotable. I do feel uneasy about promoting stuff involving uninitialized memory, but OTOH no *operation* on `MaybeUninit` is promotable, so maybe this is okay?\n\nr? @oli-obk @eddyb", "tree": {"sha": "810bfac3c62b4226910fa5498a9ca9a7964116ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/810bfac3c62b4226910fa5498a9ca9a7964116ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a20745c96c6e39fb45a9d47e350b2569ec5673b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdNbrhCRBK7hj4Ov3rIwAAdHIIAHxFQp7XZUEK/VbRn+5pvlmp\nqvhbWBc0OSlDdcdRaHVpVfMFnpNeLTvUIgx/jaOeQV4lOwl+94f0tqG+vulyBunr\nHf3L0Q5qduIiTRj7E3776QV/kXKu5p8go/12HY8elM+d+1fvq87dVs7rRxxJ8Yff\n4sL0/P/0RqaJv4MTS77UEmTZMQ2s2WjAAjGZ57W9DRhZWUbNVDf8jmgFS6PIgdoq\n4afxbEvpYT8+C/VuRuEk/qj4lY/SBArG0UBDWOTiU4Z+pA/zd8yCBi8m+udL+a/B\nbesUM3c5KTcT94gYE6sKNGq1tv5Z80jFSzC8zQJRtMyq6amuYvw2AFl+DqDeKPo=\n=eFnE\n-----END PGP SIGNATURE-----\n", "payload": "tree 810bfac3c62b4226910fa5498a9ca9a7964116ff\nparent 7dafdd21b1581b1992408a0688a8566938f60587\nparent f3abbf71035e469fce6db37bdb444ce3e50e870f\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1563802337 +0200\ncommitter GitHub <noreply@github.com> 1563802337 +0200\n\nRollup merge of #62799 - RalfJung:uninit-array, r=Centril\n\nuse const array repeat expressions for uninit_array\n\nWith a first implementation of https://github.com/rust-lang/rust/issues/49147 having landed, we can make this macro nicer and phase it out with the next bootstrap bump.\n\nHowever, to make this work, we have to mark `MaybeUninit::uninit()` as promotable. I do feel uneasy about promoting stuff involving uninitialized memory, but OTOH no *operation* on `MaybeUninit` is promotable, so maybe this is okay?\n\nr? @oli-obk @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a20745c96c6e39fb45a9d47e350b2569ec5673b", "html_url": "https://github.com/rust-lang/rust/commit/5a20745c96c6e39fb45a9d47e350b2569ec5673b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a20745c96c6e39fb45a9d47e350b2569ec5673b/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7dafdd21b1581b1992408a0688a8566938f60587", "url": "https://api.github.com/repos/rust-lang/rust/commits/7dafdd21b1581b1992408a0688a8566938f60587", "html_url": "https://github.com/rust-lang/rust/commit/7dafdd21b1581b1992408a0688a8566938f60587"}, {"sha": "f3abbf71035e469fce6db37bdb444ce3e50e870f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3abbf71035e469fce6db37bdb444ce3e50e870f", "html_url": "https://github.com/rust-lang/rust/commit/f3abbf71035e469fce6db37bdb444ce3e50e870f"}], "stats": {"total": 44, "additions": 34, "deletions": 10}, "files": [{"sha": "e067096f0c780ccc9c5294dbe9fbb45471d47dab", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a20745c96c6e39fb45a9d47e350b2569ec5673b/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a20745c96c6e39fb45a9d47e350b2569ec5673b/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=5a20745c96c6e39fb45a9d47e350b2569ec5673b", "patch": "@@ -106,8 +106,8 @@ impl<K, V> LeafNode<K, V> {\n         LeafNode {\n             // As a general policy, we leave fields uninitialized if they can be, as this should\n             // be both slightly faster and easier to track in Valgrind.\n-            keys: uninitialized_array![_; CAPACITY],\n-            vals: uninitialized_array![_; CAPACITY],\n+            keys: uninit_array![_; CAPACITY],\n+            vals: uninit_array![_; CAPACITY],\n             parent: ptr::null(),\n             parent_idx: MaybeUninit::uninit(),\n             len: 0\n@@ -159,7 +159,7 @@ impl<K, V> InternalNode<K, V> {\n     unsafe fn new() -> Self {\n         InternalNode {\n             data: LeafNode::new(),\n-            edges: uninitialized_array![_; 2*B],\n+            edges: uninit_array![_; 2*B],\n         }\n     }\n }"}, {"sha": "dbc1f3b47c80dc0dc36da2c46de85c695ad83c37", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a20745c96c6e39fb45a9d47e350b2569ec5673b/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a20745c96c6e39fb45a9d47e350b2569ec5673b/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=5a20745c96c6e39fb45a9d47e350b2569ec5673b", "patch": "@@ -77,13 +77,15 @@\n #![feature(box_syntax)]\n #![feature(cfg_target_has_atomic)]\n #![feature(coerce_unsized)]\n+#![cfg_attr(not(bootstrap), feature(const_in_array_repeat_expressions))]\n #![feature(dispatch_from_dyn)]\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n #![feature(fmt_internals)]\n #![feature(fn_traits)]\n #![feature(fundamental)]\n+#![feature(internal_uninit_const)]\n #![feature(lang_items)]\n #![feature(libc)]\n #![feature(nll)]"}, {"sha": "3b5c9fbff250ae1e654e156e38b36950f489e69d", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a20745c96c6e39fb45a9d47e350b2569ec5673b/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a20745c96c6e39fb45a9d47e350b2569ec5673b/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=5a20745c96c6e39fb45a9d47e350b2569ec5673b", "patch": "@@ -51,7 +51,7 @@ trait GenericRadix {\n         // characters for a base 2 number.\n         let zero = T::zero();\n         let is_nonnegative = x >= zero;\n-        let mut buf = uninitialized_array![u8; 128];\n+        let mut buf = [MaybeUninit::<u8>::uninit(); 128];\n         let mut curr = buf.len();\n         let base = T::from_u8(Self::BASE);\n         if is_nonnegative {\n@@ -189,7 +189,7 @@ static DEC_DIGITS_LUT: &[u8; 200] =\n macro_rules! impl_Display {\n     ($($t:ident),* as $u:ident via $conv_fn:ident named $name:ident) => {\n         fn $name(mut n: $u, is_nonnegative: bool, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            let mut buf = uninitialized_array![u8; 39];\n+            let mut buf = [MaybeUninit::<u8>::uninit(); 39];\n             let mut curr = buf.len() as isize;\n             let buf_ptr = MaybeUninit::first_ptr_mut(&mut buf);\n             let lut_ptr = DEC_DIGITS_LUT.as_ptr();"}, {"sha": "296bb43f9fad4d8ff7b8f65a1004dafe61ffa4e2", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5a20745c96c6e39fb45a9d47e350b2569ec5673b/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a20745c96c6e39fb45a9d47e350b2569ec5673b/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=5a20745c96c6e39fb45a9d47e350b2569ec5673b", "patch": "@@ -626,20 +626,37 @@ macro_rules! todo {\n /// Creates an array of [`MaybeUninit`].\n ///\n /// This macro constructs an uninitialized array of the type `[MaybeUninit<K>; N]`.\n+/// It exists solely because bootstrap does not yet support const array-init expressions.\n ///\n /// [`MaybeUninit`]: mem/union.MaybeUninit.html\n+// FIXME: Remove both versions of this macro once bootstrap is 1.38.\n #[macro_export]\n #[unstable(feature = \"maybe_uninit_array\", issue = \"53491\")]\n-macro_rules! uninitialized_array {\n+#[cfg(bootstrap)]\n+macro_rules! uninit_array {\n     // This `assume_init` is safe because an array of `MaybeUninit` does not\n     // require initialization.\n-    // FIXME(#49147): Could be replaced by an array initializer, once those can\n-    // be any const expression.\n     ($t:ty; $size:expr) => (unsafe {\n         MaybeUninit::<[MaybeUninit<$t>; $size]>::uninit().assume_init()\n     });\n }\n \n+/// Creates an array of [`MaybeUninit`].\n+///\n+/// This macro constructs an uninitialized array of the type `[MaybeUninit<K>; N]`.\n+/// It exists solely because bootstrap does not yet support const array-init expressions.\n+///\n+/// [`MaybeUninit`]: mem/union.MaybeUninit.html\n+// FIXME: Just inline this version of the macro once bootstrap is 1.38.\n+#[macro_export]\n+#[unstable(feature = \"maybe_uninit_array\", issue = \"53491\")]\n+#[cfg(not(bootstrap))]\n+macro_rules! uninit_array {\n+    ($t:ty; $size:expr) => (\n+        [MaybeUninit::<$t>::UNINIT; $size]\n+    );\n+}\n+\n /// Built-in macros to the compiler itself.\n ///\n /// These macros do not have any corresponding definition with a `macro_rules!`"}, {"sha": "2e88db8df11634f3ea30c78340a2d12fb2722137", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a20745c96c6e39fb45a9d47e350b2569ec5673b/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a20745c96c6e39fb45a9d47e350b2569ec5673b/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=5a20745c96c6e39fb45a9d47e350b2569ec5673b", "patch": "@@ -252,6 +252,11 @@ impl<T> MaybeUninit<T> {\n         MaybeUninit { uninit: () }\n     }\n \n+    /// A promotable constant, equivalent to `uninit()`.\n+    #[unstable(feature = \"internal_uninit_const\", issue = \"0\",\n+        reason = \"hack to work around promotability\")]\n+    pub const UNINIT: Self = Self::uninit();\n+\n     /// Creates a new `MaybeUninit<T>` in an uninitialized state, with the memory being\n     /// filled with `0` bytes. It depends on `T` whether that already makes for\n     /// proper initialization. For example, `MaybeUninit<usize>::zeroed()` is initialized,"}, {"sha": "2f2170f7ff14ce7860d3b219f7e55ce0e2a7365b", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a20745c96c6e39fb45a9d47e350b2569ec5673b/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a20745c96c6e39fb45a9d47e350b2569ec5673b/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=5a20745c96c6e39fb45a9d47e350b2569ec5673b", "patch": "@@ -216,14 +216,14 @@ fn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\n     let mut block_l = BLOCK;\n     let mut start_l = ptr::null_mut();\n     let mut end_l = ptr::null_mut();\n-    let mut offsets_l: [MaybeUninit<u8>; BLOCK] = uninitialized_array![u8; BLOCK];\n+    let mut offsets_l = [MaybeUninit::<u8>::uninit(); BLOCK];\n \n     // The current block on the right side (from `r.sub(block_r)` to `r`).\n     let mut r = unsafe { l.add(v.len()) };\n     let mut block_r = BLOCK;\n     let mut start_r = ptr::null_mut();\n     let mut end_r = ptr::null_mut();\n-    let mut offsets_r: [MaybeUninit<u8>; BLOCK] = uninitialized_array![u8; BLOCK];\n+    let mut offsets_r = [MaybeUninit::<u8>::uninit(); BLOCK];\n \n     // FIXME: When we get VLAs, try creating one array of length `min(v.len(), 2 * BLOCK)` rather\n     // than two fixed-size arrays of length `BLOCK`. VLAs might be more cache-efficient."}]}