{"sha": "272bbfb857650e0d3d05dd83a5ce1a522c94b4bd", "node_id": "C_kwDOAAsO6NoAKDI3MmJiZmI4NTc2NTBlMGQzZDA1ZGQ4M2E1Y2UxYTUyMmM5NGI0YmQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-08T21:24:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-08T21:24:54Z"}, "message": "Auto merge of #9386 - smoelius:further-enhance-needless-borrow, r=Jarcho\n\nFurther enhance `needless_borrow`, mildly refactor `redundant_clone`\n\nThis PR does the following:\n* Moves some code from `redundant_clone` into a new `clippy_utils` module called `mir`, and wraps that code in a function called `dropped_without_further_use`.\n* Relaxes the \"is copyable\" condition condition from #9136 by also suggesting to remove borrows from values dropped without further use. The changes involve the just mentioned function.\n* Separates `redundant_clone` into modules.\n\nStrictly speaking, the last bullet is independent of the others. `redundant_clone` is somewhat hairy, IMO. Separating it into modules makes it slightly less so, by helping to delineate what depends upon what.\n\nI've tried to break everything up into digestible commits.\n\nr? `@Jarcho`\n\n(`@Jarcho` I hope you don't mind.)\n\nchangelog: continuation of #9136", "tree": {"sha": "ff6f3b941d23a479ff99eab4f44ae373cfa24d5c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff6f3b941d23a479ff99eab4f44ae373cfa24d5c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd", "html_url": "https://github.com/rust-lang/rust/commit/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "292e313259f422c8f4c31ecaedcc14058e8f4f8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/292e313259f422c8f4c31ecaedcc14058e8f4f8b", "html_url": "https://github.com/rust-lang/rust/commit/292e313259f422c8f4c31ecaedcc14058e8f4f8b"}, {"sha": "9cc8da222b3893bc13bc13c8827e93f8ea246854", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cc8da222b3893bc13bc13c8827e93f8ea246854", "html_url": "https://github.com/rust-lang/rust/commit/9cc8da222b3893bc13bc13c8827e93f8ea246854"}], "stats": {"total": 1383, "additions": 879, "deletions": 504}, "files": [{"sha": "535c25e69f1bb1df546fbf84ebd8bd2d3984329c", "filename": "clippy_dev/src/serve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_dev%2Fsrc%2Fserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_dev%2Fsrc%2Fserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fserve.rs?ref=272bbfb857650e0d3d05dd83a5ce1a522c94b4bd", "patch": "@@ -49,7 +49,7 @@ fn mtime(path: impl AsRef<Path>) -> SystemTime {\n             .into_iter()\n             .flatten()\n             .flatten()\n-            .map(|entry| mtime(&entry.path()))\n+            .map(|entry| mtime(entry.path()))\n             .max()\n             .unwrap_or(SystemTime::UNIX_EPOCH)\n     } else {"}, {"sha": "8d1bfacd1dc304b2906c6a0d7c4aa5ae94530f35", "filename": "clippy_dev/src/update_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fupdate_lints.rs?ref=272bbfb857650e0d3d05dd83a5ce1a522c94b4bd", "patch": "@@ -128,7 +128,7 @@ fn generate_lint_files(\n     for (lint_group, lints) in Lint::by_lint_group(usable_lints.into_iter().chain(internal_lints)) {\n         let content = gen_lint_group_list(&lint_group, lints.iter());\n         process_file(\n-            &format!(\"clippy_lints/src/lib.register_{lint_group}.rs\"),\n+            format!(\"clippy_lints/src/lib.register_{lint_group}.rs\"),\n             update_mode,\n             &content,\n         );"}, {"sha": "45ee2fce4e470216ddff8be8e97481932e6d5b60", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 84, "deletions": 15, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=272bbfb857650e0d3d05dd83a5ce1a522c94b4bd", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_hir_and_then};\n+use clippy_utils::mir::{enclosing_mir, expr_local, local_assignments, used_exactly_once, PossibleBorrowerMap};\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::sugg::has_enclosing_paren;\n use clippy_utils::ty::{expr_sig, is_copy, peel_mid_ty_refs, ty_sig, variant_of_res};\n@@ -11,13 +12,16 @@ use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_ty, Visitor};\n use rustc_hir::{\n-    self as hir, def_id::DefId, BindingAnnotation, Body, BodyId, BorrowKind, Closure, Expr, ExprKind, FnRetTy,\n-    GenericArg, HirId, ImplItem, ImplItemKind, Item, ItemKind, Local, MatchSource, Mutability, Node, Pat, PatKind,\n-    Path, QPath, TraitItem, TraitItemKind, TyKind, UnOp,\n+    self as hir,\n+    def_id::{DefId, LocalDefId},\n+    BindingAnnotation, Body, BodyId, BorrowKind, Closure, Expr, ExprKind, FnRetTy, GenericArg, HirId, ImplItem,\n+    ImplItemKind, Item, ItemKind, Local, MatchSource, Mutability, Node, Pat, PatKind, Path, QPath, TraitItem,\n+    TraitItemKind, TyKind, UnOp,\n };\n use rustc_index::bit_set::BitSet;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::mir::{Rvalue, StatementKind};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::{\n     self, Binder, BoundVariableKind, EarlyBinder, FnSig, GenericArgKind, List, ParamTy, PredicateKind,\n@@ -141,15 +145,15 @@ declare_clippy_lint! {\n     \"dereferencing when the compiler would automatically dereference\"\n }\n \n-impl_lint_pass!(Dereferencing => [\n+impl_lint_pass!(Dereferencing<'_> => [\n     EXPLICIT_DEREF_METHODS,\n     NEEDLESS_BORROW,\n     REF_BINDING_TO_REFERENCE,\n     EXPLICIT_AUTO_DEREF,\n ]);\n \n #[derive(Default)]\n-pub struct Dereferencing {\n+pub struct Dereferencing<'tcx> {\n     state: Option<(State, StateData)>,\n \n     // While parsing a `deref` method call in ufcs form, the path to the function is itself an\n@@ -170,11 +174,16 @@ pub struct Dereferencing {\n     /// e.g. `m!(x) | Foo::Bar(ref x)`\n     ref_locals: FxIndexMap<HirId, Option<RefPat>>,\n \n+    /// Stack of (body owner, `PossibleBorrowerMap`) pairs. Used by\n+    /// `needless_borrow_impl_arg_position` to determine when a borrowed expression can instead\n+    /// be moved.\n+    possible_borrowers: Vec<(LocalDefId, PossibleBorrowerMap<'tcx, 'tcx>)>,\n+\n     // `IntoIterator` for arrays requires Rust 1.53.\n     msrv: Option<RustcVersion>,\n }\n \n-impl Dereferencing {\n+impl<'tcx> Dereferencing<'tcx> {\n     #[must_use]\n     pub fn new(msrv: Option<RustcVersion>) -> Self {\n         Self {\n@@ -244,7 +253,7 @@ struct RefPat {\n     hir_id: HirId,\n }\n \n-impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n+impl<'tcx> LateLintPass<'tcx> for Dereferencing<'tcx> {\n     #[expect(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // Skip path expressions from deref calls. e.g. `Deref::deref(e)`\n@@ -278,7 +287,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n         match (self.state.take(), kind) {\n             (None, kind) => {\n                 let expr_ty = typeck.expr_ty(expr);\n-                let (position, adjustments) = walk_parents(cx, expr, self.msrv);\n+                let (position, adjustments) = walk_parents(cx, &mut self.possible_borrowers, expr, self.msrv);\n                 match kind {\n                     RefOp::Deref => {\n                         if let Position::FieldAccess {\n@@ -550,6 +559,12 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n     }\n \n     fn check_body_post(&mut self, cx: &LateContext<'tcx>, body: &'tcx Body<'_>) {\n+        if self.possible_borrowers.last().map_or(false, |&(local_def_id, _)| {\n+            local_def_id == cx.tcx.hir().body_owner_def_id(body.id())\n+        }) {\n+            self.possible_borrowers.pop();\n+        }\n+\n         if Some(body.id()) == self.current_body {\n             for pat in self.ref_locals.drain(..).filter_map(|(_, x)| x) {\n                 let replacements = pat.replacements;\n@@ -682,6 +697,7 @@ impl Position {\n #[expect(clippy::too_many_lines)]\n fn walk_parents<'tcx>(\n     cx: &LateContext<'tcx>,\n+    possible_borrowers: &mut Vec<(LocalDefId, PossibleBorrowerMap<'tcx, 'tcx>)>,\n     e: &'tcx Expr<'_>,\n     msrv: Option<RustcVersion>,\n ) -> (Position, &'tcx [Adjustment<'tcx>]) {\n@@ -796,7 +812,16 @@ fn walk_parents<'tcx>(\n                             Some(hir_ty) => binding_ty_auto_deref_stability(cx, hir_ty, precedence, ty.bound_vars()),\n                             None => {\n                                 if let ty::Param(param_ty) = ty.skip_binder().kind() {\n-                                    needless_borrow_impl_arg_position(cx, parent, i, *param_ty, e, precedence, msrv)\n+                                    needless_borrow_impl_arg_position(\n+                                        cx,\n+                                        possible_borrowers,\n+                                        parent,\n+                                        i,\n+                                        *param_ty,\n+                                        e,\n+                                        precedence,\n+                                        msrv,\n+                                    )\n                                 } else {\n                                     ty_auto_deref_stability(cx, cx.tcx.erase_late_bound_regions(ty), precedence)\n                                         .position_for_arg()\n@@ -844,7 +869,16 @@ fn walk_parents<'tcx>(\n                     args.iter().position(|arg| arg.hir_id == child_id).map(|i| {\n                         let ty = cx.tcx.fn_sig(id).skip_binder().inputs()[i + 1];\n                         if let ty::Param(param_ty) = ty.kind() {\n-                            needless_borrow_impl_arg_position(cx, parent, i + 1, *param_ty, e, precedence, msrv)\n+                            needless_borrow_impl_arg_position(\n+                                cx,\n+                                possible_borrowers,\n+                                parent,\n+                                i + 1,\n+                                *param_ty,\n+                                e,\n+                                precedence,\n+                                msrv,\n+                            )\n                         } else {\n                             ty_auto_deref_stability(\n                                 cx,\n@@ -1018,8 +1052,10 @@ fn ty_contains_infer(ty: &hir::Ty<'_>) -> bool {\n // If the conditions are met, returns `Some(Position::ImplArg(..))`; otherwise, returns `None`.\n //   The \"is copyable\" condition is to avoid the case where removing the `&` means `e` would have to\n // be moved, but it cannot be.\n+#[expect(clippy::too_many_arguments)]\n fn needless_borrow_impl_arg_position<'tcx>(\n     cx: &LateContext<'tcx>,\n+    possible_borrowers: &mut Vec<(LocalDefId, PossibleBorrowerMap<'tcx, 'tcx>)>,\n     parent: &Expr<'tcx>,\n     arg_index: usize,\n     param_ty: ParamTy,\n@@ -1082,10 +1118,13 @@ fn needless_borrow_impl_arg_position<'tcx>(\n     // elements are modified each time `check_referent` is called.\n     let mut substs_with_referent_ty = substs_with_expr_ty.to_vec();\n \n-    let mut check_referent = |referent| {\n+    let mut check_reference_and_referent = |reference, referent| {\n         let referent_ty = cx.typeck_results().expr_ty(referent);\n \n-        if !is_copy(cx, referent_ty) {\n+        if !is_copy(cx, referent_ty)\n+            && (referent_ty.has_significant_drop(cx.tcx, cx.param_env)\n+                || !referent_used_exactly_once(cx, possible_borrowers, reference))\n+        {\n             return false;\n         }\n \n@@ -1127,7 +1166,7 @@ fn needless_borrow_impl_arg_position<'tcx>(\n \n     let mut needless_borrow = false;\n     while let ExprKind::AddrOf(_, _, referent) = expr.kind {\n-        if !check_referent(referent) {\n+        if !check_reference_and_referent(expr, referent) {\n             break;\n         }\n         expr = referent;\n@@ -1155,6 +1194,36 @@ fn has_ref_mut_self_method(cx: &LateContext<'_>, trait_def_id: DefId) -> bool {\n         })\n }\n \n+fn referent_used_exactly_once<'a, 'tcx>(\n+    cx: &'a LateContext<'tcx>,\n+    possible_borrowers: &mut Vec<(LocalDefId, PossibleBorrowerMap<'tcx, 'tcx>)>,\n+    reference: &Expr<'tcx>,\n+) -> bool {\n+    let mir = enclosing_mir(cx.tcx, reference.hir_id);\n+    if let Some(local) = expr_local(cx.tcx, reference)\n+        && let [location] = *local_assignments(mir, local).as_slice()\n+        && let StatementKind::Assign(box (_, Rvalue::Ref(_, _, place))) =\n+            mir.basic_blocks[location.block].statements[location.statement_index].kind\n+        && !place.has_deref()\n+    {\n+        let body_owner_local_def_id = cx.tcx.hir().enclosing_body_owner(reference.hir_id);\n+        if possible_borrowers\n+            .last()\n+            .map_or(true, |&(local_def_id, _)| local_def_id != body_owner_local_def_id)\n+        {\n+            possible_borrowers.push((body_owner_local_def_id, PossibleBorrowerMap::new(cx, mir)));\n+        }\n+        let possible_borrower = &mut possible_borrowers.last_mut().unwrap().1;\n+        // If `only_borrowers` were used here, the `copyable_iterator::warn` test would fail. The reason is\n+        // that `PossibleBorrowerVisitor::visit_terminator` considers `place.local` a possible borrower of\n+        // itself. See the comment in that method for an explanation as to why.\n+        possible_borrower.bounded_borrowers(&[local], &[local, place.local], place.local, location)\n+            && used_exactly_once(mir, place.local).unwrap_or(false)\n+    } else {\n+        false\n+    }\n+}\n+\n // Iteratively replaces `param_ty` with `new_ty` in `substs`, and similarly for each resulting\n // projected type that is a type parameter. Returns `false` if replacing the types would have an\n // effect on the function signature beyond substituting `new_ty` for `param_ty`.\n@@ -1439,8 +1508,8 @@ fn report<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data\n     }\n }\n \n-impl Dereferencing {\n-    fn check_local_usage<'tcx>(&mut self, cx: &LateContext<'tcx>, e: &Expr<'tcx>, local: HirId) {\n+impl<'tcx> Dereferencing<'tcx> {\n+    fn check_local_usage(&mut self, cx: &LateContext<'tcx>, e: &Expr<'tcx>, local: HirId) {\n         if let Some(outer_pat) = self.ref_locals.get_mut(&local) {\n             if let Some(pat) = outer_pat {\n                 // Check for auto-deref"}, {"sha": "ebb0f14fef52805fd66531280163a13c5ba7a105", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=272bbfb857650e0d3d05dd83a5ce1a522c94b4bd", "patch": "@@ -38,7 +38,6 @@ extern crate rustc_infer;\n extern crate rustc_lexer;\n extern crate rustc_lint;\n extern crate rustc_middle;\n-extern crate rustc_mir_dataflow;\n extern crate rustc_parse;\n extern crate rustc_session;\n extern crate rustc_span;\n@@ -418,7 +417,7 @@ pub fn register_pre_expansion_lints(store: &mut rustc_lint::LintStore, sess: &Se\n \n     let msrv = conf.msrv.as_ref().and_then(|s| {\n         parse_msrv(s, None, None).or_else(|| {\n-            sess.err(&format!(\n+            sess.err(format!(\n                 \"error reading Clippy's configuration file. `{s}` is not a valid Rust version\"\n             ));\n             None\n@@ -434,7 +433,7 @@ fn read_msrv(conf: &Conf, sess: &Session) -> Option<RustcVersion> {\n         .and_then(|v| parse_msrv(&v, None, None));\n     let clippy_msrv = conf.msrv.as_ref().and_then(|s| {\n         parse_msrv(s, None, None).or_else(|| {\n-            sess.err(&format!(\n+            sess.err(format!(\n                 \"error reading Clippy's configuration file. `{s}` is not a valid Rust version\"\n             ));\n             None\n@@ -445,7 +444,7 @@ fn read_msrv(conf: &Conf, sess: &Session) -> Option<RustcVersion> {\n         if let Some(clippy_msrv) = clippy_msrv {\n             // if both files have an msrv, let's compare them and emit a warning if they differ\n             if clippy_msrv != cargo_msrv {\n-                sess.warn(&format!(\n+                sess.warn(format!(\n                     \"the MSRV in `clippy.toml` and `Cargo.toml` differ; using `{clippy_msrv}` from `clippy.toml`\"\n                 ));\n             }\n@@ -474,7 +473,7 @@ pub fn read_conf(sess: &Session) -> Conf {\n     let TryConf { conf, errors, warnings } = utils::conf::read(&file_name);\n     // all conf errors are non-fatal, we just use the default conf in case of error\n     for error in errors {\n-        sess.err(&format!(\n+        sess.err(format!(\n             \"error reading Clippy's configuration file `{}`: {}\",\n             file_name.display(),\n             format_error(error)"}, {"sha": "6c909e5ed73ea6b5faac116b6ca5bb657a3cc21f", "filename": "clippy_lints/src/nonstandard_macro_braces.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_lints%2Fsrc%2Fnonstandard_macro_braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_lints%2Fsrc%2Fnonstandard_macro_braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnonstandard_macro_braces.rs?ref=272bbfb857650e0d3d05dd83a5ce1a522c94b4bd", "patch": "@@ -266,7 +266,7 @@ impl<'de> Deserialize<'de> for MacroMatcher {\n                         .iter()\n                         .find(|b| b.0 == brace)\n                         .map(|(o, c)| ((*o).to_owned(), (*c).to_owned()))\n-                        .ok_or_else(|| de::Error::custom(&format!(\"expected one of `(`, `{{`, `[` found `{brace}`\")))?,\n+                        .ok_or_else(|| de::Error::custom(format!(\"expected one of `(`, `{{`, `[` found `{brace}`\")))?,\n                 })\n             }\n         }"}, {"sha": "aedbe08e3e46e2e340c0263cc7766f4ab9c50c81", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 35, "deletions": 419, "changes": 454, "blob_url": "https://github.com/rust-lang/rust/blob/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=272bbfb857650e0d3d05dd83a5ce1a522c94b4bd", "patch": "@@ -1,25 +1,18 @@\n use clippy_utils::diagnostics::{span_lint_hir, span_lint_hir_and_then};\n+use clippy_utils::mir::{visit_local_usage, LocalUsage, PossibleBorrowerMap};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::{has_drop, is_copy, is_type_diagnostic_item, walk_ptrs_ty_depth};\n use clippy_utils::{fn_has_unsatisfiable_preds, match_def_path, paths};\n use if_chain::if_chain;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{def_id, Body, FnDecl, HirId};\n-use rustc_index::bit_set::{BitSet, HybridBitSet};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::mir::{\n-    self, traversal,\n-    visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor as _},\n-    Mutability,\n-};\n-use rustc_middle::ty::{self, visit::TypeVisitor, Ty};\n-use rustc_mir_dataflow::{Analysis, AnalysisDomain, CallReturnPlaces, GenKill, GenKillAnalysis, ResultsCursor};\n+use rustc_middle::mir;\n+use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::{BytePos, Span};\n use rustc_span::sym;\n-use std::ops::ControlFlow;\n \n macro_rules! unwrap_or_continue {\n     ($x:expr) => {\n@@ -89,21 +82,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n \n         let mir = cx.tcx.optimized_mir(def_id.to_def_id());\n \n-        let possible_origin = {\n-            let mut vis = PossibleOriginVisitor::new(mir);\n-            vis.visit_body(mir);\n-            vis.into_map(cx)\n-        };\n-        let maybe_storage_live_result = MaybeStorageLive\n-            .into_engine(cx.tcx, mir)\n-            .pass_name(\"redundant_clone\")\n-            .iterate_to_fixpoint()\n-            .into_results_cursor(mir);\n-        let mut possible_borrower = {\n-            let mut vis = PossibleBorrowerVisitor::new(cx, mir, possible_origin);\n-            vis.visit_body(mir);\n-            vis.into_map(cx, maybe_storage_live_result)\n-        };\n+        let mut possible_borrower = PossibleBorrowerMap::new(cx, mir);\n \n         for (bb, bbdata) in mir.basic_blocks.iter_enumerated() {\n             let terminator = bbdata.terminator();\n@@ -374,403 +353,40 @@ struct CloneUsage {\n     /// Whether the clone value is mutated.\n     clone_consumed_or_mutated: bool,\n }\n-fn visit_clone_usage(cloned: mir::Local, clone: mir::Local, mir: &mir::Body<'_>, bb: mir::BasicBlock) -> CloneUsage {\n-    struct V {\n-        cloned: mir::Local,\n-        clone: mir::Local,\n-        result: CloneUsage,\n-    }\n-    impl<'tcx> mir::visit::Visitor<'tcx> for V {\n-        fn visit_basic_block_data(&mut self, block: mir::BasicBlock, data: &mir::BasicBlockData<'tcx>) {\n-            let statements = &data.statements;\n-            for (statement_index, statement) in statements.iter().enumerate() {\n-                self.visit_statement(statement, mir::Location { block, statement_index });\n-            }\n-\n-            self.visit_terminator(\n-                data.terminator(),\n-                mir::Location {\n-                    block,\n-                    statement_index: statements.len(),\n-                },\n-            );\n-        }\n-\n-        fn visit_place(&mut self, place: &mir::Place<'tcx>, ctx: PlaceContext, loc: mir::Location) {\n-            let local = place.local;\n-\n-            if local == self.cloned\n-                && !matches!(\n-                    ctx,\n-                    PlaceContext::MutatingUse(MutatingUseContext::Drop) | PlaceContext::NonUse(_)\n-                )\n-            {\n-                self.result.cloned_used = true;\n-                self.result.cloned_consume_or_mutate_loc = self.result.cloned_consume_or_mutate_loc.or_else(|| {\n-                    matches!(\n-                        ctx,\n-                        PlaceContext::NonMutatingUse(NonMutatingUseContext::Move)\n-                            | PlaceContext::MutatingUse(MutatingUseContext::Borrow)\n-                    )\n-                    .then(|| loc)\n-                });\n-            } else if local == self.clone {\n-                match ctx {\n-                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Move)\n-                    | PlaceContext::MutatingUse(MutatingUseContext::Borrow) => {\n-                        self.result.clone_consumed_or_mutated = true;\n-                    },\n-                    _ => {},\n-                }\n-            }\n-        }\n-    }\n-\n-    let init = CloneUsage {\n-        cloned_used: false,\n-        cloned_consume_or_mutate_loc: None,\n-        // Consider non-temporary clones consumed.\n-        // TODO: Actually check for mutation of non-temporaries.\n-        clone_consumed_or_mutated: mir.local_kind(clone) != mir::LocalKind::Temp,\n-    };\n-    traversal::ReversePostorder::new(mir, bb)\n-        .skip(1)\n-        .fold(init, |usage, (tbb, tdata)| {\n-            // Short-circuit\n-            if (usage.cloned_used && usage.clone_consumed_or_mutated) ||\n-                // Give up on loops\n-                tdata.terminator().successors().any(|s| s == bb)\n-            {\n-                return CloneUsage {\n-                    cloned_used: true,\n-                    clone_consumed_or_mutated: true,\n-                    ..usage\n-                };\n-            }\n-\n-            let mut v = V {\n-                cloned,\n-                clone,\n-                result: usage,\n-            };\n-            v.visit_basic_block_data(tbb, tdata);\n-            v.result\n-        })\n-}\n-\n-/// Determines liveness of each local purely based on `StorageLive`/`Dead`.\n-#[derive(Copy, Clone)]\n-struct MaybeStorageLive;\n-\n-impl<'tcx> AnalysisDomain<'tcx> for MaybeStorageLive {\n-    type Domain = BitSet<mir::Local>;\n-    const NAME: &'static str = \"maybe_storage_live\";\n-\n-    fn bottom_value(&self, body: &mir::Body<'tcx>) -> Self::Domain {\n-        // bottom = dead\n-        BitSet::new_empty(body.local_decls.len())\n-    }\n-\n-    fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut Self::Domain) {\n-        for arg in body.args_iter() {\n-            state.insert(arg);\n-        }\n-    }\n-}\n-\n-impl<'tcx> GenKillAnalysis<'tcx> for MaybeStorageLive {\n-    type Idx = mir::Local;\n-\n-    fn statement_effect(&self, trans: &mut impl GenKill<Self::Idx>, stmt: &mir::Statement<'tcx>, _: mir::Location) {\n-        match stmt.kind {\n-            mir::StatementKind::StorageLive(l) => trans.gen(l),\n-            mir::StatementKind::StorageDead(l) => trans.kill(l),\n-            _ => (),\n-        }\n-    }\n-\n-    fn terminator_effect(\n-        &self,\n-        _trans: &mut impl GenKill<Self::Idx>,\n-        _terminator: &mir::Terminator<'tcx>,\n-        _loc: mir::Location,\n-    ) {\n-    }\n-\n-    fn call_return_effect(\n-        &self,\n-        _trans: &mut impl GenKill<Self::Idx>,\n-        _block: mir::BasicBlock,\n-        _return_places: CallReturnPlaces<'_, 'tcx>,\n-    ) {\n-        // Nothing to do when a call returns successfully\n-    }\n-}\n-\n-/// Collects the possible borrowers of each local.\n-/// For example, `b = &a; c = &a;` will make `b` and (transitively) `c`\n-/// possible borrowers of `a`.\n-struct PossibleBorrowerVisitor<'a, 'tcx> {\n-    possible_borrower: TransitiveRelation,\n-    body: &'a mir::Body<'tcx>,\n-    cx: &'a LateContext<'tcx>,\n-    possible_origin: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n-}\n-\n-impl<'a, 'tcx> PossibleBorrowerVisitor<'a, 'tcx> {\n-    fn new(\n-        cx: &'a LateContext<'tcx>,\n-        body: &'a mir::Body<'tcx>,\n-        possible_origin: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n-    ) -> Self {\n-        Self {\n-            possible_borrower: TransitiveRelation::default(),\n-            cx,\n-            body,\n-            possible_origin,\n-        }\n-    }\n-\n-    fn into_map(\n-        self,\n-        cx: &LateContext<'tcx>,\n-        maybe_live: ResultsCursor<'tcx, 'tcx, MaybeStorageLive>,\n-    ) -> PossibleBorrowerMap<'a, 'tcx> {\n-        let mut map = FxHashMap::default();\n-        for row in (1..self.body.local_decls.len()).map(mir::Local::from_usize) {\n-            if is_copy(cx, self.body.local_decls[row].ty) {\n-                continue;\n-            }\n-\n-            let mut borrowers = self.possible_borrower.reachable_from(row, self.body.local_decls.len());\n-            borrowers.remove(mir::Local::from_usize(0));\n-            if !borrowers.is_empty() {\n-                map.insert(row, borrowers);\n-            }\n-        }\n-\n-        let bs = BitSet::new_empty(self.body.local_decls.len());\n-        PossibleBorrowerMap {\n-            map,\n-            maybe_live,\n-            bitset: (bs.clone(), bs),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleBorrowerVisitor<'a, 'tcx> {\n-    fn visit_assign(&mut self, place: &mir::Place<'tcx>, rvalue: &mir::Rvalue<'_>, _location: mir::Location) {\n-        let lhs = place.local;\n-        match rvalue {\n-            mir::Rvalue::Ref(_, _, borrowed) => {\n-                self.possible_borrower.add(borrowed.local, lhs);\n-            },\n-            other => {\n-                if ContainsRegion\n-                    .visit_ty(place.ty(&self.body.local_decls, self.cx.tcx).ty)\n-                    .is_continue()\n-                {\n-                    return;\n-                }\n-                rvalue_locals(other, |rhs| {\n-                    if lhs != rhs {\n-                        self.possible_borrower.add(rhs, lhs);\n-                    }\n-                });\n-            },\n-        }\n-    }\n-\n-    fn visit_terminator(&mut self, terminator: &mir::Terminator<'_>, _loc: mir::Location) {\n-        if let mir::TerminatorKind::Call {\n-            args,\n-            destination: mir::Place { local: dest, .. },\n-            ..\n-        } = &terminator.kind\n-        {\n-            // TODO add doc\n-            // If the call returns something with lifetimes,\n-            // let's conservatively assume the returned value contains lifetime of all the arguments.\n-            // For example, given `let y: Foo<'a> = foo(x)`, `y` is considered to be a possible borrower of `x`.\n-\n-            let mut immutable_borrowers = vec![];\n-            let mut mutable_borrowers = vec![];\n-\n-            for op in args {\n-                match op {\n-                    mir::Operand::Copy(p) | mir::Operand::Move(p) => {\n-                        if let ty::Ref(_, _, Mutability::Mut) = self.body.local_decls[p.local].ty.kind() {\n-                            mutable_borrowers.push(p.local);\n-                        } else {\n-                            immutable_borrowers.push(p.local);\n-                        }\n-                    },\n-                    mir::Operand::Constant(..) => (),\n-                }\n-            }\n-\n-            let mut mutable_variables: Vec<mir::Local> = mutable_borrowers\n-                .iter()\n-                .filter_map(|r| self.possible_origin.get(r))\n-                .flat_map(HybridBitSet::iter)\n-                .collect();\n-\n-            if ContainsRegion.visit_ty(self.body.local_decls[*dest].ty).is_break() {\n-                mutable_variables.push(*dest);\n-            }\n-\n-            for y in mutable_variables {\n-                for x in &immutable_borrowers {\n-                    self.possible_borrower.add(*x, y);\n-                }\n-                for x in &mutable_borrowers {\n-                    self.possible_borrower.add(*x, y);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-/// Collect possible borrowed for every `&mut` local.\n-/// For example, `_1 = &mut _2` generate _1: {_2,...}\n-/// Known Problems: not sure all borrowed are tracked\n-struct PossibleOriginVisitor<'a, 'tcx> {\n-    possible_origin: TransitiveRelation,\n-    body: &'a mir::Body<'tcx>,\n-}\n-\n-impl<'a, 'tcx> PossibleOriginVisitor<'a, 'tcx> {\n-    fn new(body: &'a mir::Body<'tcx>) -> Self {\n-        Self {\n-            possible_origin: TransitiveRelation::default(),\n-            body,\n-        }\n-    }\n-\n-    fn into_map(self, cx: &LateContext<'tcx>) -> FxHashMap<mir::Local, HybridBitSet<mir::Local>> {\n-        let mut map = FxHashMap::default();\n-        for row in (1..self.body.local_decls.len()).map(mir::Local::from_usize) {\n-            if is_copy(cx, self.body.local_decls[row].ty) {\n-                continue;\n-            }\n-\n-            let mut borrowers = self.possible_origin.reachable_from(row, self.body.local_decls.len());\n-            borrowers.remove(mir::Local::from_usize(0));\n-            if !borrowers.is_empty() {\n-                map.insert(row, borrowers);\n-            }\n-        }\n-        map\n-    }\n-}\n-\n-impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleOriginVisitor<'a, 'tcx> {\n-    fn visit_assign(&mut self, place: &mir::Place<'tcx>, rvalue: &mir::Rvalue<'_>, _location: mir::Location) {\n-        let lhs = place.local;\n-        match rvalue {\n-            // Only consider `&mut`, which can modify origin place\n-            mir::Rvalue::Ref(_, rustc_middle::mir::BorrowKind::Mut { .. }, borrowed) |\n-            // _2: &mut _;\n-            // _3 = move _2\n-            mir::Rvalue::Use(mir::Operand::Move(borrowed))  |\n-            // _3 = move _2 as &mut _;\n-            mir::Rvalue::Cast(_, mir::Operand::Move(borrowed), _)\n-                => {\n-                self.possible_origin.add(lhs, borrowed.local);\n-            },\n-            _ => {},\n-        }\n-    }\n-}\n-\n-struct ContainsRegion;\n-\n-impl TypeVisitor<'_> for ContainsRegion {\n-    type BreakTy = ();\n-\n-    fn visit_region(&mut self, _: ty::Region<'_>) -> ControlFlow<Self::BreakTy> {\n-        ControlFlow::BREAK\n-    }\n-}\n-\n-fn rvalue_locals(rvalue: &mir::Rvalue<'_>, mut visit: impl FnMut(mir::Local)) {\n-    use rustc_middle::mir::Rvalue::{Aggregate, BinaryOp, Cast, CheckedBinaryOp, Repeat, UnaryOp, Use};\n-\n-    let mut visit_op = |op: &mir::Operand<'_>| match op {\n-        mir::Operand::Copy(p) | mir::Operand::Move(p) => visit(p.local),\n-        mir::Operand::Constant(..) => (),\n-    };\n \n-    match rvalue {\n-        Use(op) | Repeat(op, _) | Cast(_, op, _) | UnaryOp(_, op) => visit_op(op),\n-        Aggregate(_, ops) => ops.iter().for_each(visit_op),\n-        BinaryOp(_, box (lhs, rhs)) | CheckedBinaryOp(_, box (lhs, rhs)) => {\n-            visit_op(lhs);\n-            visit_op(rhs);\n+fn visit_clone_usage(cloned: mir::Local, clone: mir::Local, mir: &mir::Body<'_>, bb: mir::BasicBlock) -> CloneUsage {\n+    if let Some((\n+        LocalUsage {\n+            local_use_locs: cloned_use_locs,\n+            local_consume_or_mutate_locs: cloned_consume_or_mutate_locs,\n         },\n-        _ => (),\n-    }\n-}\n-\n-/// Result of `PossibleBorrowerVisitor`.\n-struct PossibleBorrowerMap<'a, 'tcx> {\n-    /// Mapping `Local -> its possible borrowers`\n-    map: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n-    maybe_live: ResultsCursor<'a, 'tcx, MaybeStorageLive>,\n-    // Caches to avoid allocation of `BitSet` on every query\n-    bitset: (BitSet<mir::Local>, BitSet<mir::Local>),\n-}\n-\n-impl PossibleBorrowerMap<'_, '_> {\n-    /// Returns true if the set of borrowers of `borrowed` living at `at` matches with `borrowers`.\n-    fn only_borrowers(&mut self, borrowers: &[mir::Local], borrowed: mir::Local, at: mir::Location) -> bool {\n-        self.maybe_live.seek_after_primary_effect(at);\n-\n-        self.bitset.0.clear();\n-        let maybe_live = &mut self.maybe_live;\n-        if let Some(bitset) = self.map.get(&borrowed) {\n-            for b in bitset.iter().filter(move |b| maybe_live.contains(*b)) {\n-                self.bitset.0.insert(b);\n-            }\n-        } else {\n-            return false;\n-        }\n-\n-        self.bitset.1.clear();\n-        for b in borrowers {\n-            self.bitset.1.insert(*b);\n+        LocalUsage {\n+            local_use_locs: _,\n+            local_consume_or_mutate_locs: clone_consume_or_mutate_locs,\n+        },\n+    )) = visit_local_usage(\n+        &[cloned, clone],\n+        mir,\n+        mir::Location {\n+            block: bb,\n+            statement_index: mir.basic_blocks[bb].statements.len(),\n+        },\n+    )\n+    .map(|mut vec| (vec.remove(0), vec.remove(0)))\n+    {\n+        CloneUsage {\n+            cloned_used: !cloned_use_locs.is_empty(),\n+            cloned_consume_or_mutate_loc: cloned_consume_or_mutate_locs.first().copied(),\n+            // Consider non-temporary clones consumed.\n+            // TODO: Actually check for mutation of non-temporaries.\n+            clone_consumed_or_mutated: mir.local_kind(clone) != mir::LocalKind::Temp\n+                || !clone_consume_or_mutate_locs.is_empty(),\n         }\n-\n-        self.bitset.0 == self.bitset.1\n-    }\n-\n-    fn local_is_alive_at(&mut self, local: mir::Local, at: mir::Location) -> bool {\n-        self.maybe_live.seek_after_primary_effect(at);\n-        self.maybe_live.contains(local)\n-    }\n-}\n-\n-#[derive(Default)]\n-struct TransitiveRelation {\n-    relations: FxHashMap<mir::Local, Vec<mir::Local>>,\n-}\n-impl TransitiveRelation {\n-    fn add(&mut self, a: mir::Local, b: mir::Local) {\n-        self.relations.entry(a).or_default().push(b);\n-    }\n-\n-    fn reachable_from(&self, a: mir::Local, domain_size: usize) -> HybridBitSet<mir::Local> {\n-        let mut seen = HybridBitSet::new_empty(domain_size);\n-        let mut stack = vec![a];\n-        while let Some(u) = stack.pop() {\n-            if let Some(edges) = self.relations.get(&u) {\n-                for &v in edges {\n-                    if seen.insert(v) {\n-                        stack.push(v);\n-                    }\n-                }\n-            }\n+    } else {\n+        CloneUsage {\n+            cloned_used: true,\n+            cloned_consume_or_mutate_loc: None,\n+            clone_consumed_or_mutated: true,\n         }\n-        seen\n     }\n }"}, {"sha": "cd8575c90e86caaad333ab8f76ecce98d82b3ae8", "filename": "clippy_utils/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_utils%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_utils%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fattrs.rs?ref=272bbfb857650e0d3d05dd83a5ce1a522c94b4bd", "patch": "@@ -136,7 +136,7 @@ pub fn get_unique_inner_attr(sess: &Session, attrs: &[ast::Attribute], name: &'s\n                     .emit();\n             },\n             ast::AttrStyle::Outer => {\n-                sess.span_err(attr.span, &format!(\"`{name}` cannot be an outer attribute\"));\n+                sess.span_err(attr.span, format!(\"`{name}` cannot be an outer attribute\"));\n             },\n         }\n     }"}, {"sha": "dbe75b43cb2405cc259ac6f03d1d6ff3a7a90f2c", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=272bbfb857650e0d3d05dd83a5ce1a522c94b4bd", "patch": "@@ -25,10 +25,12 @@ extern crate rustc_data_structures;\n extern crate rustc_errors;\n extern crate rustc_hir;\n extern crate rustc_hir_analysis;\n+extern crate rustc_index;\n extern crate rustc_infer;\n extern crate rustc_lexer;\n extern crate rustc_lint;\n extern crate rustc_middle;\n+extern crate rustc_mir_dataflow;\n extern crate rustc_parse_format;\n extern crate rustc_session;\n extern crate rustc_span;\n@@ -48,6 +50,7 @@ pub mod eager_or_lazy;\n pub mod higher;\n mod hir_utils;\n pub mod macros;\n+pub mod mir;\n pub mod msrvs;\n pub mod numeric_literal;\n pub mod paths;\n@@ -122,7 +125,7 @@ pub fn parse_msrv(msrv: &str, sess: Option<&Session>, span: Option<Span>) -> Opt\n         return Some(version);\n     } else if let Some(sess) = sess {\n         if let Some(span) = span {\n-            sess.span_err(span, &format!(\"`{msrv}` is not a valid Rust version\"));\n+            sess.span_err(span, format!(\"`{msrv}` is not a valid Rust version\"));\n         }\n     }\n     None"}, {"sha": "d262b335d99d3adf782a59eaa02f88c84db50908", "filename": "clippy_utils/src/mir/maybe_storage_live.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_utils%2Fsrc%2Fmir%2Fmaybe_storage_live.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_utils%2Fsrc%2Fmir%2Fmaybe_storage_live.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmir%2Fmaybe_storage_live.rs?ref=272bbfb857650e0d3d05dd83a5ce1a522c94b4bd", "patch": "@@ -0,0 +1,52 @@\n+use rustc_index::bit_set::BitSet;\n+use rustc_middle::mir;\n+use rustc_mir_dataflow::{AnalysisDomain, CallReturnPlaces, GenKill, GenKillAnalysis};\n+\n+/// Determines liveness of each local purely based on `StorageLive`/`Dead`.\n+#[derive(Copy, Clone)]\n+pub(super) struct MaybeStorageLive;\n+\n+impl<'tcx> AnalysisDomain<'tcx> for MaybeStorageLive {\n+    type Domain = BitSet<mir::Local>;\n+    const NAME: &'static str = \"maybe_storage_live\";\n+\n+    fn bottom_value(&self, body: &mir::Body<'tcx>) -> Self::Domain {\n+        // bottom = dead\n+        BitSet::new_empty(body.local_decls.len())\n+    }\n+\n+    fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut Self::Domain) {\n+        for arg in body.args_iter() {\n+            state.insert(arg);\n+        }\n+    }\n+}\n+\n+impl<'tcx> GenKillAnalysis<'tcx> for MaybeStorageLive {\n+    type Idx = mir::Local;\n+\n+    fn statement_effect(&self, trans: &mut impl GenKill<Self::Idx>, stmt: &mir::Statement<'tcx>, _: mir::Location) {\n+        match stmt.kind {\n+            mir::StatementKind::StorageLive(l) => trans.gen(l),\n+            mir::StatementKind::StorageDead(l) => trans.kill(l),\n+            _ => (),\n+        }\n+    }\n+\n+    fn terminator_effect(\n+        &self,\n+        _trans: &mut impl GenKill<Self::Idx>,\n+        _terminator: &mir::Terminator<'tcx>,\n+        _loc: mir::Location,\n+    ) {\n+    }\n+\n+    fn call_return_effect(\n+        &self,\n+        _trans: &mut impl GenKill<Self::Idx>,\n+        _block: mir::BasicBlock,\n+        _return_places: CallReturnPlaces<'_, 'tcx>,\n+    ) {\n+        // Nothing to do when a call returns successfully\n+    }\n+}"}, {"sha": "c8aa6f3e595df4123462e752e771ade784227713", "filename": "clippy_utils/src/mir/mod.rs", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_utils%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_utils%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmir%2Fmod.rs?ref=272bbfb857650e0d3d05dd83a5ce1a522c94b4bd", "patch": "@@ -0,0 +1,165 @@\n+use rustc_hir::{Expr, HirId};\n+use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor};\n+use rustc_middle::mir::{\n+    traversal, Body, InlineAsmOperand, Local, Location, Place, StatementKind, TerminatorKind, START_BLOCK,\n+};\n+use rustc_middle::ty::TyCtxt;\n+\n+mod maybe_storage_live;\n+\n+mod possible_borrower;\n+pub use possible_borrower::PossibleBorrowerMap;\n+\n+mod possible_origin;\n+\n+mod transitive_relation;\n+\n+#[derive(Clone, Debug, Default)]\n+pub struct LocalUsage {\n+    /// The locations where the local is used, if any.\n+    pub local_use_locs: Vec<Location>,\n+    /// The locations where the local is consumed or mutated, if any.\n+    pub local_consume_or_mutate_locs: Vec<Location>,\n+}\n+\n+pub fn visit_local_usage(locals: &[Local], mir: &Body<'_>, location: Location) -> Option<Vec<LocalUsage>> {\n+    let init = vec![\n+        LocalUsage {\n+            local_use_locs: Vec::new(),\n+            local_consume_or_mutate_locs: Vec::new(),\n+        };\n+        locals.len()\n+    ];\n+\n+    traversal::ReversePostorder::new(mir, location.block).try_fold(init, |usage, (tbb, tdata)| {\n+        // Give up on loops\n+        if tdata.terminator().successors().any(|s| s == location.block) {\n+            return None;\n+        }\n+\n+        let mut v = V {\n+            locals,\n+            location,\n+            results: usage,\n+        };\n+        v.visit_basic_block_data(tbb, tdata);\n+        Some(v.results)\n+    })\n+}\n+\n+struct V<'a> {\n+    locals: &'a [Local],\n+    location: Location,\n+    results: Vec<LocalUsage>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for V<'a> {\n+    fn visit_place(&mut self, place: &Place<'tcx>, ctx: PlaceContext, loc: Location) {\n+        if loc.block == self.location.block && loc.statement_index <= self.location.statement_index {\n+            return;\n+        }\n+\n+        let local = place.local;\n+\n+        for (i, self_local) in self.locals.iter().enumerate() {\n+            if local == *self_local {\n+                if !matches!(\n+                    ctx,\n+                    PlaceContext::MutatingUse(MutatingUseContext::Drop) | PlaceContext::NonUse(_)\n+                ) {\n+                    self.results[i].local_use_locs.push(loc);\n+                }\n+                if matches!(\n+                    ctx,\n+                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Move)\n+                        | PlaceContext::MutatingUse(MutatingUseContext::Borrow)\n+                ) {\n+                    self.results[i].local_consume_or_mutate_locs.push(loc);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Convenience wrapper around `visit_local_usage`.\n+pub fn used_exactly_once(mir: &rustc_middle::mir::Body<'_>, local: rustc_middle::mir::Local) -> Option<bool> {\n+    visit_local_usage(\n+        &[local],\n+        mir,\n+        Location {\n+            block: START_BLOCK,\n+            statement_index: 0,\n+        },\n+    )\n+    .map(|mut vec| {\n+        let LocalUsage { local_use_locs, .. } = vec.remove(0);\n+        local_use_locs\n+            .into_iter()\n+            .filter(|location| !is_local_assignment(mir, local, *location))\n+            .count()\n+            == 1\n+    })\n+}\n+\n+/// Returns the `mir::Body` containing the node associated with `hir_id`.\n+#[allow(clippy::module_name_repetitions)]\n+pub fn enclosing_mir(tcx: TyCtxt<'_>, hir_id: HirId) -> &Body<'_> {\n+    let body_owner_local_def_id = tcx.hir().enclosing_body_owner(hir_id);\n+    tcx.optimized_mir(body_owner_local_def_id.to_def_id())\n+}\n+\n+/// Tries to determine the `Local` corresponding to `expr`, if any.\n+/// This function is expensive and should be used sparingly.\n+pub fn expr_local(tcx: TyCtxt<'_>, expr: &Expr<'_>) -> Option<Local> {\n+    let mir = enclosing_mir(tcx, expr.hir_id);\n+    mir.local_decls.iter_enumerated().find_map(|(local, local_decl)| {\n+        if local_decl.source_info.span == expr.span {\n+            Some(local)\n+        } else {\n+            None\n+        }\n+    })\n+}\n+\n+/// Returns a vector of `mir::Location` where `local` is assigned. Each statement referred to has\n+/// kind `StatementKind::Assign`.\n+pub fn local_assignments(mir: &Body<'_>, local: Local) -> Vec<Location> {\n+    let mut locations = Vec::new();\n+    for (block, data) in mir.basic_blocks.iter_enumerated() {\n+        for statement_index in 0..=data.statements.len() {\n+            let location = Location { block, statement_index };\n+            if is_local_assignment(mir, local, location) {\n+                locations.push(location);\n+            }\n+        }\n+    }\n+    locations\n+}\n+\n+// `is_local_assignment` is based on `is_place_assignment`:\n+// https://github.com/rust-lang/rust/blob/b7413511dc85ec01ef4b91785f86614589ac6103/compiler/rustc_middle/src/mir/visit.rs#L1350\n+fn is_local_assignment(mir: &Body<'_>, local: Local, location: Location) -> bool {\n+    let Location { block, statement_index } = location;\n+    let basic_block = &mir.basic_blocks[block];\n+    if statement_index < basic_block.statements.len() {\n+        let statement = &basic_block.statements[statement_index];\n+        if let StatementKind::Assign(box (place, _)) = statement.kind {\n+            place.as_local() == Some(local)\n+        } else {\n+            false\n+        }\n+    } else {\n+        let terminator = basic_block.terminator();\n+        match &terminator.kind {\n+            TerminatorKind::Call { destination, .. } => destination.as_local() == Some(local),\n+            TerminatorKind::InlineAsm { operands, .. } => operands.iter().any(|operand| {\n+                if let InlineAsmOperand::Out { place: Some(place), .. } = operand {\n+                    place.as_local() == Some(local)\n+                } else {\n+                    false\n+                }\n+            }),\n+            _ => false,\n+        }\n+    }\n+}"}, {"sha": "25717bf3d2fee5329bffe8128ed66a95acdf3904", "filename": "clippy_utils/src/mir/possible_borrower.rs", "status": "added", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_utils%2Fsrc%2Fmir%2Fpossible_borrower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_utils%2Fsrc%2Fmir%2Fpossible_borrower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmir%2Fpossible_borrower.rs?ref=272bbfb857650e0d3d05dd83a5ce1a522c94b4bd", "patch": "@@ -0,0 +1,241 @@\n+use super::{\n+    maybe_storage_live::MaybeStorageLive, possible_origin::PossibleOriginVisitor,\n+    transitive_relation::TransitiveRelation,\n+};\n+use crate::ty::is_copy;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_index::bit_set::{BitSet, HybridBitSet};\n+use rustc_lint::LateContext;\n+use rustc_middle::mir::{self, visit::Visitor as _, Mutability};\n+use rustc_middle::ty::{self, visit::TypeVisitor};\n+use rustc_mir_dataflow::{Analysis, ResultsCursor};\n+use std::ops::ControlFlow;\n+\n+/// Collects the possible borrowers of each local.\n+/// For example, `b = &a; c = &a;` will make `b` and (transitively) `c`\n+/// possible borrowers of `a`.\n+#[allow(clippy::module_name_repetitions)]\n+struct PossibleBorrowerVisitor<'a, 'b, 'tcx> {\n+    possible_borrower: TransitiveRelation,\n+    body: &'b mir::Body<'tcx>,\n+    cx: &'a LateContext<'tcx>,\n+    possible_origin: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n+}\n+\n+impl<'a, 'b, 'tcx> PossibleBorrowerVisitor<'a, 'b, 'tcx> {\n+    fn new(\n+        cx: &'a LateContext<'tcx>,\n+        body: &'b mir::Body<'tcx>,\n+        possible_origin: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n+    ) -> Self {\n+        Self {\n+            possible_borrower: TransitiveRelation::default(),\n+            cx,\n+            body,\n+            possible_origin,\n+        }\n+    }\n+\n+    fn into_map(\n+        self,\n+        cx: &'a LateContext<'tcx>,\n+        maybe_live: ResultsCursor<'b, 'tcx, MaybeStorageLive>,\n+    ) -> PossibleBorrowerMap<'b, 'tcx> {\n+        let mut map = FxHashMap::default();\n+        for row in (1..self.body.local_decls.len()).map(mir::Local::from_usize) {\n+            if is_copy(cx, self.body.local_decls[row].ty) {\n+                continue;\n+            }\n+\n+            let mut borrowers = self.possible_borrower.reachable_from(row, self.body.local_decls.len());\n+            borrowers.remove(mir::Local::from_usize(0));\n+            if !borrowers.is_empty() {\n+                map.insert(row, borrowers);\n+            }\n+        }\n+\n+        let bs = BitSet::new_empty(self.body.local_decls.len());\n+        PossibleBorrowerMap {\n+            map,\n+            maybe_live,\n+            bitset: (bs.clone(), bs),\n+        }\n+    }\n+}\n+\n+impl<'a, 'b, 'tcx> mir::visit::Visitor<'tcx> for PossibleBorrowerVisitor<'a, 'b, 'tcx> {\n+    fn visit_assign(&mut self, place: &mir::Place<'tcx>, rvalue: &mir::Rvalue<'_>, _location: mir::Location) {\n+        let lhs = place.local;\n+        match rvalue {\n+            mir::Rvalue::Ref(_, _, borrowed) => {\n+                self.possible_borrower.add(borrowed.local, lhs);\n+            },\n+            other => {\n+                if ContainsRegion\n+                    .visit_ty(place.ty(&self.body.local_decls, self.cx.tcx).ty)\n+                    .is_continue()\n+                {\n+                    return;\n+                }\n+                rvalue_locals(other, |rhs| {\n+                    if lhs != rhs {\n+                        self.possible_borrower.add(rhs, lhs);\n+                    }\n+                });\n+            },\n+        }\n+    }\n+\n+    fn visit_terminator(&mut self, terminator: &mir::Terminator<'_>, _loc: mir::Location) {\n+        if let mir::TerminatorKind::Call {\n+            args,\n+            destination: mir::Place { local: dest, .. },\n+            ..\n+        } = &terminator.kind\n+        {\n+            // TODO add doc\n+            // If the call returns something with lifetimes,\n+            // let's conservatively assume the returned value contains lifetime of all the arguments.\n+            // For example, given `let y: Foo<'a> = foo(x)`, `y` is considered to be a possible borrower of `x`.\n+\n+            let mut immutable_borrowers = vec![];\n+            let mut mutable_borrowers = vec![];\n+\n+            for op in args {\n+                match op {\n+                    mir::Operand::Copy(p) | mir::Operand::Move(p) => {\n+                        if let ty::Ref(_, _, Mutability::Mut) = self.body.local_decls[p.local].ty.kind() {\n+                            mutable_borrowers.push(p.local);\n+                        } else {\n+                            immutable_borrowers.push(p.local);\n+                        }\n+                    },\n+                    mir::Operand::Constant(..) => (),\n+                }\n+            }\n+\n+            let mut mutable_variables: Vec<mir::Local> = mutable_borrowers\n+                .iter()\n+                .filter_map(|r| self.possible_origin.get(r))\n+                .flat_map(HybridBitSet::iter)\n+                .collect();\n+\n+            if ContainsRegion.visit_ty(self.body.local_decls[*dest].ty).is_break() {\n+                mutable_variables.push(*dest);\n+            }\n+\n+            for y in mutable_variables {\n+                for x in &immutable_borrowers {\n+                    self.possible_borrower.add(*x, y);\n+                }\n+                for x in &mutable_borrowers {\n+                    self.possible_borrower.add(*x, y);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+struct ContainsRegion;\n+\n+impl TypeVisitor<'_> for ContainsRegion {\n+    type BreakTy = ();\n+\n+    fn visit_region(&mut self, _: ty::Region<'_>) -> ControlFlow<Self::BreakTy> {\n+        ControlFlow::BREAK\n+    }\n+}\n+\n+fn rvalue_locals(rvalue: &mir::Rvalue<'_>, mut visit: impl FnMut(mir::Local)) {\n+    use rustc_middle::mir::Rvalue::{Aggregate, BinaryOp, Cast, CheckedBinaryOp, Repeat, UnaryOp, Use};\n+\n+    let mut visit_op = |op: &mir::Operand<'_>| match op {\n+        mir::Operand::Copy(p) | mir::Operand::Move(p) => visit(p.local),\n+        mir::Operand::Constant(..) => (),\n+    };\n+\n+    match rvalue {\n+        Use(op) | Repeat(op, _) | Cast(_, op, _) | UnaryOp(_, op) => visit_op(op),\n+        Aggregate(_, ops) => ops.iter().for_each(visit_op),\n+        BinaryOp(_, box (lhs, rhs)) | CheckedBinaryOp(_, box (lhs, rhs)) => {\n+            visit_op(lhs);\n+            visit_op(rhs);\n+        },\n+        _ => (),\n+    }\n+}\n+\n+/// Result of `PossibleBorrowerVisitor`.\n+#[allow(clippy::module_name_repetitions)]\n+pub struct PossibleBorrowerMap<'b, 'tcx> {\n+    /// Mapping `Local -> its possible borrowers`\n+    pub map: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n+    maybe_live: ResultsCursor<'b, 'tcx, MaybeStorageLive>,\n+    // Caches to avoid allocation of `BitSet` on every query\n+    pub bitset: (BitSet<mir::Local>, BitSet<mir::Local>),\n+}\n+\n+impl<'a, 'b, 'tcx> PossibleBorrowerMap<'b, 'tcx> {\n+    pub fn new(cx: &'a LateContext<'tcx>, mir: &'b mir::Body<'tcx>) -> Self {\n+        let possible_origin = {\n+            let mut vis = PossibleOriginVisitor::new(mir);\n+            vis.visit_body(mir);\n+            vis.into_map(cx)\n+        };\n+        let maybe_storage_live_result = MaybeStorageLive\n+            .into_engine(cx.tcx, mir)\n+            .pass_name(\"redundant_clone\")\n+            .iterate_to_fixpoint()\n+            .into_results_cursor(mir);\n+        let mut vis = PossibleBorrowerVisitor::new(cx, mir, possible_origin);\n+        vis.visit_body(mir);\n+        vis.into_map(cx, maybe_storage_live_result)\n+    }\n+\n+    /// Returns true if the set of borrowers of `borrowed` living at `at` matches with `borrowers`.\n+    pub fn only_borrowers(&mut self, borrowers: &[mir::Local], borrowed: mir::Local, at: mir::Location) -> bool {\n+        self.bounded_borrowers(borrowers, borrowers, borrowed, at)\n+    }\n+\n+    /// Returns true if the set of borrowers of `borrowed` living at `at` includes at least `below`\n+    /// but no more than `above`.\n+    pub fn bounded_borrowers(\n+        &mut self,\n+        below: &[mir::Local],\n+        above: &[mir::Local],\n+        borrowed: mir::Local,\n+        at: mir::Location,\n+    ) -> bool {\n+        self.maybe_live.seek_after_primary_effect(at);\n+\n+        self.bitset.0.clear();\n+        let maybe_live = &mut self.maybe_live;\n+        if let Some(bitset) = self.map.get(&borrowed) {\n+            for b in bitset.iter().filter(move |b| maybe_live.contains(*b)) {\n+                self.bitset.0.insert(b);\n+            }\n+        } else {\n+            return false;\n+        }\n+\n+        self.bitset.1.clear();\n+        for b in below {\n+            self.bitset.1.insert(*b);\n+        }\n+\n+        if !self.bitset.0.superset(&self.bitset.1) {\n+            return false;\n+        }\n+\n+        for b in above {\n+            self.bitset.0.remove(*b);\n+        }\n+\n+        self.bitset.0.is_empty()\n+    }\n+\n+    pub fn local_is_alive_at(&mut self, local: mir::Local, at: mir::Location) -> bool {\n+        self.maybe_live.seek_after_primary_effect(at);\n+        self.maybe_live.contains(local)\n+    }\n+}"}, {"sha": "8e7513d740ab397e3172f23bf31bbfec264009eb", "filename": "clippy_utils/src/mir/possible_origin.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_utils%2Fsrc%2Fmir%2Fpossible_origin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_utils%2Fsrc%2Fmir%2Fpossible_origin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmir%2Fpossible_origin.rs?ref=272bbfb857650e0d3d05dd83a5ce1a522c94b4bd", "patch": "@@ -0,0 +1,59 @@\n+use super::transitive_relation::TransitiveRelation;\n+use crate::ty::is_copy;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_index::bit_set::HybridBitSet;\n+use rustc_lint::LateContext;\n+use rustc_middle::mir;\n+\n+/// Collect possible borrowed for every `&mut` local.\n+/// For example, `_1 = &mut _2` generate _1: {_2,...}\n+/// Known Problems: not sure all borrowed are tracked\n+#[allow(clippy::module_name_repetitions)]\n+pub(super) struct PossibleOriginVisitor<'a, 'tcx> {\n+    possible_origin: TransitiveRelation,\n+    body: &'a mir::Body<'tcx>,\n+}\n+\n+impl<'a, 'tcx> PossibleOriginVisitor<'a, 'tcx> {\n+    pub fn new(body: &'a mir::Body<'tcx>) -> Self {\n+        Self {\n+            possible_origin: TransitiveRelation::default(),\n+            body,\n+        }\n+    }\n+\n+    pub fn into_map(self, cx: &LateContext<'tcx>) -> FxHashMap<mir::Local, HybridBitSet<mir::Local>> {\n+        let mut map = FxHashMap::default();\n+        for row in (1..self.body.local_decls.len()).map(mir::Local::from_usize) {\n+            if is_copy(cx, self.body.local_decls[row].ty) {\n+                continue;\n+            }\n+\n+            let mut borrowers = self.possible_origin.reachable_from(row, self.body.local_decls.len());\n+            borrowers.remove(mir::Local::from_usize(0));\n+            if !borrowers.is_empty() {\n+                map.insert(row, borrowers);\n+            }\n+        }\n+        map\n+    }\n+}\n+\n+impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleOriginVisitor<'a, 'tcx> {\n+    fn visit_assign(&mut self, place: &mir::Place<'tcx>, rvalue: &mir::Rvalue<'_>, _location: mir::Location) {\n+        let lhs = place.local;\n+        match rvalue {\n+            // Only consider `&mut`, which can modify origin place\n+            mir::Rvalue::Ref(_, rustc_middle::mir::BorrowKind::Mut { .. }, borrowed) |\n+            // _2: &mut _;\n+            // _3 = move _2\n+            mir::Rvalue::Use(mir::Operand::Move(borrowed))  |\n+            // _3 = move _2 as &mut _;\n+            mir::Rvalue::Cast(_, mir::Operand::Move(borrowed), _)\n+                => {\n+                self.possible_origin.add(lhs, borrowed.local);\n+            },\n+            _ => {},\n+        }\n+    }\n+}"}, {"sha": "7fe2960739fa252d0843cb7b9604198bdd442d41", "filename": "clippy_utils/src/mir/transitive_relation.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_utils%2Fsrc%2Fmir%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_utils%2Fsrc%2Fmir%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmir%2Ftransitive_relation.rs?ref=272bbfb857650e0d3d05dd83a5ce1a522c94b4bd", "patch": "@@ -0,0 +1,29 @@\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_index::bit_set::HybridBitSet;\n+use rustc_middle::mir;\n+\n+#[derive(Default)]\n+pub(super) struct TransitiveRelation {\n+    relations: FxHashMap<mir::Local, Vec<mir::Local>>,\n+}\n+\n+impl TransitiveRelation {\n+    pub fn add(&mut self, a: mir::Local, b: mir::Local) {\n+        self.relations.entry(a).or_default().push(b);\n+    }\n+\n+    pub fn reachable_from(&self, a: mir::Local, domain_size: usize) -> HybridBitSet<mir::Local> {\n+        let mut seen = HybridBitSet::new_empty(domain_size);\n+        let mut stack = vec![a];\n+        while let Some(u) = stack.pop() {\n+            if let Some(edges) = self.relations.get(&u) {\n+                for &v in edges {\n+                    if seen.insert(v) {\n+                        stack.push(v);\n+                    }\n+                }\n+            }\n+        }\n+        seen\n+    }\n+}"}, {"sha": "78adc45365439fb0d30eef29f335ca8024c219af", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=272bbfb857650e0d3d05dd83a5ce1a522c94b4bd", "patch": "@@ -119,17 +119,11 @@ pub const RANGE_ARGUMENT_TRAIT: [&str; 3] = [\"core\", \"ops\", \"RangeBounds\"];\n pub const RC_PTR_EQ: [&str; 4] = [\"alloc\", \"rc\", \"Rc\", \"ptr_eq\"];\n pub const REFCELL_REF: [&str; 3] = [\"core\", \"cell\", \"Ref\"];\n pub const REFCELL_REFMUT: [&str; 3] = [\"core\", \"cell\", \"RefMut\"];\n-#[expect(clippy::invalid_paths)] // internal lints do not know about all external crates\n pub const REGEX_BUILDER_NEW: [&str; 5] = [\"regex\", \"re_builder\", \"unicode\", \"RegexBuilder\", \"new\"];\n-#[expect(clippy::invalid_paths)] // internal lints do not know about all external crates\n pub const REGEX_BYTES_BUILDER_NEW: [&str; 5] = [\"regex\", \"re_builder\", \"bytes\", \"RegexBuilder\", \"new\"];\n-#[expect(clippy::invalid_paths)] // internal lints do not know about all external crates\n pub const REGEX_BYTES_NEW: [&str; 4] = [\"regex\", \"re_bytes\", \"Regex\", \"new\"];\n-#[expect(clippy::invalid_paths)] // internal lints do not know about all external crates\n pub const REGEX_BYTES_SET_NEW: [&str; 5] = [\"regex\", \"re_set\", \"bytes\", \"RegexSet\", \"new\"];\n-#[expect(clippy::invalid_paths)] // internal lints do not know about all external crates\n pub const REGEX_NEW: [&str; 4] = [\"regex\", \"re_unicode\", \"Regex\", \"new\"];\n-#[expect(clippy::invalid_paths)] // internal lints do not know about all external crates\n pub const REGEX_SET_NEW: [&str; 5] = [\"regex\", \"re_set\", \"unicode\", \"RegexSet\", \"new\"];\n /// Preferably use the diagnostic item `sym::Result` where possible\n pub const RESULT: [&str; 3] = [\"core\", \"result\", \"Result\"];"}, {"sha": "95b20d7f02427a9e4c5a6f319f3e90307cfd8724", "filename": "lintcheck/src/main.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/lintcheck%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/lintcheck%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Fsrc%2Fmain.rs?ref=272bbfb857650e0d3d05dd83a5ce1a522c94b4bd", "patch": "@@ -345,7 +345,7 @@ impl Crate {\n                 clippy_args.push(opt);\n             }\n         } else {\n-            clippy_args.extend(&[\"-Wclippy::pedantic\", \"-Wclippy::cargo\"])\n+            clippy_args.extend([\"-Wclippy::pedantic\", \"-Wclippy::cargo\"])\n         }\n \n         if lint_filter.is_empty() {\n@@ -457,15 +457,11 @@ fn build_clippy() {\n /// Read a `lintcheck_crates.toml` file\n fn read_crates(toml_path: &Path) -> (Vec<CrateSource>, RecursiveOptions) {\n     let toml_content: String =\n-        std::fs::read_to_string(&toml_path).unwrap_or_else(|_| panic!(\"Failed to read {}\", toml_path.display()));\n+        std::fs::read_to_string(toml_path).unwrap_or_else(|_| panic!(\"Failed to read {}\", toml_path.display()));\n     let crate_list: SourceList =\n         toml::from_str(&toml_content).unwrap_or_else(|e| panic!(\"Failed to parse {}: \\n{}\", toml_path.display(), e));\n     // parse the hashmap of the toml file into a list of crates\n-    let tomlcrates: Vec<TomlCrate> = crate_list\n-        .crates\n-        .into_iter()\n-        .map(|(_cratename, tomlcrate)| tomlcrate)\n-        .collect();\n+    let tomlcrates: Vec<TomlCrate> = crate_list.crates.into_values().collect();\n \n     // flatten TomlCrates into CrateSources (one TomlCrates may represent several versions of a crate =>\n     // multiple Cratesources)\n@@ -602,10 +598,10 @@ fn main() {\n     ) {\n         let shared_target_dir = \"target/lintcheck/shared_target_dir\";\n         // if we get an Err here, the shared target dir probably does simply not exist\n-        if let Ok(metadata) = std::fs::metadata(&shared_target_dir) {\n+        if let Ok(metadata) = std::fs::metadata(shared_target_dir) {\n             if metadata.is_dir() {\n                 println!(\"Clippy is newer than lint check logs, clearing lintcheck shared target dir...\");\n-                std::fs::remove_dir_all(&shared_target_dir)\n+                std::fs::remove_dir_all(shared_target_dir)\n                     .expect(\"failed to remove target/lintcheck/shared_target_dir\");\n             }\n         }\n@@ -779,7 +775,7 @@ fn read_stats_from_file(file_path: &Path) -> HashMap<String, usize> {\n fn print_stats(old_stats: HashMap<String, usize>, new_stats: HashMap<&String, usize>, lint_filter: &Vec<String>) {\n     let same_in_both_hashmaps = old_stats\n         .iter()\n-        .filter(|(old_key, old_val)| new_stats.get::<&String>(&old_key) == Some(old_val))\n+        .filter(|(old_key, old_val)| new_stats.get::<&String>(old_key) == Some(old_val))\n         .map(|(k, v)| (k.to_string(), *v))\n         .collect::<Vec<(String, usize)>>();\n \n@@ -797,24 +793,24 @@ fn print_stats(old_stats: HashMap<String, usize>, new_stats: HashMap<&String, us\n     // list all new counts  (key is in new stats but not in old stats)\n     new_stats_deduped\n         .iter()\n-        .filter(|(new_key, _)| old_stats_deduped.get::<str>(&new_key).is_none())\n+        .filter(|(new_key, _)| old_stats_deduped.get::<str>(new_key).is_none())\n         .for_each(|(new_key, new_value)| {\n             println!(\"{} 0 => {}\", new_key, new_value);\n         });\n \n     // list all changed counts (key is in both maps but value differs)\n     new_stats_deduped\n         .iter()\n-        .filter(|(new_key, _new_val)| old_stats_deduped.get::<str>(&new_key).is_some())\n+        .filter(|(new_key, _new_val)| old_stats_deduped.get::<str>(new_key).is_some())\n         .for_each(|(new_key, new_val)| {\n-            let old_val = old_stats_deduped.get::<str>(&new_key).unwrap();\n+            let old_val = old_stats_deduped.get::<str>(new_key).unwrap();\n             println!(\"{} {} => {}\", new_key, old_val, new_val);\n         });\n \n     // list all gone counts (key is in old status but not in new stats)\n     old_stats_deduped\n         .iter()\n-        .filter(|(old_key, _)| new_stats_deduped.get::<&String>(&old_key).is_none())\n+        .filter(|(old_key, _)| new_stats_deduped.get::<&String>(old_key).is_none())\n         .filter(|(old_key, _)| lint_filter.is_empty() || lint_filter.contains(old_key))\n         .for_each(|(old_key, old_value)| {\n             println!(\"{} {} => 0\", old_key, old_value);\n@@ -832,12 +828,12 @@ fn create_dirs(krate_download_dir: &Path, extract_dir: &Path) {\n             panic!(\"cannot create lintcheck target dir\");\n         }\n     });\n-    std::fs::create_dir(&krate_download_dir).unwrap_or_else(|err| {\n+    std::fs::create_dir(krate_download_dir).unwrap_or_else(|err| {\n         if err.kind() != ErrorKind::AlreadyExists {\n             panic!(\"cannot create crate download dir\");\n         }\n     });\n-    std::fs::create_dir(&extract_dir).unwrap_or_else(|err| {\n+    std::fs::create_dir(extract_dir).unwrap_or_else(|err| {\n         if err.kind() != ErrorKind::AlreadyExists {\n             panic!(\"cannot create crate extraction dir\");\n         }\n@@ -863,7 +859,7 @@ fn lintcheck_test() {\n         \"lintcheck/test_sources.toml\",\n     ];\n     let status = std::process::Command::new(\"cargo\")\n-        .args(&args)\n+        .args(args)\n         .current_dir(\"..\") // repo root\n         .status();\n     //.output();"}, {"sha": "c10ee969c014620b996dafa32d94367d10db825a", "filename": "tests/compile-test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=272bbfb857650e0d3d05dd83a5ce1a522c94b4bd", "patch": "@@ -283,7 +283,7 @@ fn run_ui_cargo() {\n                 env::set_current_dir(&src_path)?;\n \n                 let cargo_toml_path = case.path().join(\"Cargo.toml\");\n-                let cargo_content = fs::read(&cargo_toml_path)?;\n+                let cargo_content = fs::read(cargo_toml_path)?;\n                 let cargo_parsed: toml::Value = toml::from_str(\n                     std::str::from_utf8(&cargo_content).expect(\"`Cargo.toml` is not a valid utf-8 file!\"),\n                 )"}, {"sha": "340e89d2db1d2c25d97f14fd242ede26de1bb2eb", "filename": "tests/ui/needless_borrow.fixed", "status": "modified", "additions": 60, "deletions": 2, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/tests%2Fui%2Fneedless_borrow.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/tests%2Fui%2Fneedless_borrow.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.fixed?ref=272bbfb857650e0d3d05dd83a5ce1a522c94b4bd", "patch": "@@ -3,7 +3,11 @@\n \n #[warn(clippy::all, clippy::needless_borrow)]\n #[allow(unused_variables)]\n-#[allow(clippy::uninlined_format_args, clippy::unnecessary_mut_passed)]\n+#[allow(\n+    clippy::uninlined_format_args,\n+    clippy::unnecessary_mut_passed,\n+    clippy::unnecessary_to_owned\n+)]\n fn main() {\n     let a = 5;\n     let ref_a = &a;\n@@ -134,6 +138,7 @@ fn main() {\n     multiple_constraints([[\"\"]]);\n     multiple_constraints_normalizes_to_same(X, X);\n     let _ = Some(\"\").unwrap_or(\"\");\n+    let _ = std::fs::write(\"x\", \"\".to_string());\n \n     only_sized(&\"\"); // Don't lint. `Sized` is only bound\n     let _ = std::any::Any::type_id(&\"\"); // Don't lint. `Any` is only bound\n@@ -276,8 +281,9 @@ mod copyable_iterator {\n     fn dont_warn(mut x: Iter) {\n         takes_iter(&mut x);\n     }\n+    #[allow(unused_mut)]\n     fn warn(mut x: &mut Iter) {\n-        takes_iter(&mut x)\n+        takes_iter(x)\n     }\n }\n \n@@ -327,3 +333,55 @@ fn issue9383() {\n         ManuallyDrop::drop(&mut ocean.coral);\n     }\n }\n+\n+#[allow(dead_code)]\n+fn closure_test() {\n+    let env = \"env\".to_owned();\n+    let arg = \"arg\".to_owned();\n+    let f = |arg| {\n+        let loc = \"loc\".to_owned();\n+        let _ = std::fs::write(\"x\", &env); // Don't lint. In environment\n+        let _ = std::fs::write(\"x\", arg);\n+        let _ = std::fs::write(\"x\", loc);\n+    };\n+    let _ = std::fs::write(\"x\", &env); // Don't lint. Borrowed by `f`\n+    f(arg);\n+}\n+\n+#[allow(dead_code)]\n+mod significant_drop {\n+    #[derive(Debug)]\n+    struct X;\n+\n+    #[derive(Debug)]\n+    struct Y;\n+\n+    impl Drop for Y {\n+        fn drop(&mut self) {}\n+    }\n+\n+    fn foo(x: X, y: Y) {\n+        debug(x);\n+        debug(&y); // Don't lint. Has significant drop\n+    }\n+\n+    fn debug(_: impl std::fmt::Debug) {}\n+}\n+\n+#[allow(dead_code)]\n+mod used_exactly_once {\n+    fn foo(x: String) {\n+        use_x(x);\n+    }\n+    fn use_x(_: impl AsRef<str>) {}\n+}\n+\n+#[allow(dead_code)]\n+mod used_more_than_once {\n+    fn foo(x: String) {\n+        use_x(&x);\n+        use_x_again(&x);\n+    }\n+    fn use_x(_: impl AsRef<str>) {}\n+    fn use_x_again(_: impl AsRef<str>) {}\n+}"}, {"sha": "c93711ac8e28490feb37a078d14f66da07e904a7", "filename": "tests/ui/needless_borrow.rs", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/tests%2Fui%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/tests%2Fui%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.rs?ref=272bbfb857650e0d3d05dd83a5ce1a522c94b4bd", "patch": "@@ -3,7 +3,11 @@\n \n #[warn(clippy::all, clippy::needless_borrow)]\n #[allow(unused_variables)]\n-#[allow(clippy::uninlined_format_args, clippy::unnecessary_mut_passed)]\n+#[allow(\n+    clippy::uninlined_format_args,\n+    clippy::unnecessary_mut_passed,\n+    clippy::unnecessary_to_owned\n+)]\n fn main() {\n     let a = 5;\n     let ref_a = &a;\n@@ -134,6 +138,7 @@ fn main() {\n     multiple_constraints(&[[\"\"]]);\n     multiple_constraints_normalizes_to_same(&X, X);\n     let _ = Some(\"\").unwrap_or(&\"\");\n+    let _ = std::fs::write(\"x\", &\"\".to_string());\n \n     only_sized(&\"\"); // Don't lint. `Sized` is only bound\n     let _ = std::any::Any::type_id(&\"\"); // Don't lint. `Any` is only bound\n@@ -276,6 +281,7 @@ mod copyable_iterator {\n     fn dont_warn(mut x: Iter) {\n         takes_iter(&mut x);\n     }\n+    #[allow(unused_mut)]\n     fn warn(mut x: &mut Iter) {\n         takes_iter(&mut x)\n     }\n@@ -327,3 +333,55 @@ fn issue9383() {\n         ManuallyDrop::drop(&mut ocean.coral);\n     }\n }\n+\n+#[allow(dead_code)]\n+fn closure_test() {\n+    let env = \"env\".to_owned();\n+    let arg = \"arg\".to_owned();\n+    let f = |arg| {\n+        let loc = \"loc\".to_owned();\n+        let _ = std::fs::write(\"x\", &env); // Don't lint. In environment\n+        let _ = std::fs::write(\"x\", &arg);\n+        let _ = std::fs::write(\"x\", &loc);\n+    };\n+    let _ = std::fs::write(\"x\", &env); // Don't lint. Borrowed by `f`\n+    f(arg);\n+}\n+\n+#[allow(dead_code)]\n+mod significant_drop {\n+    #[derive(Debug)]\n+    struct X;\n+\n+    #[derive(Debug)]\n+    struct Y;\n+\n+    impl Drop for Y {\n+        fn drop(&mut self) {}\n+    }\n+\n+    fn foo(x: X, y: Y) {\n+        debug(&x);\n+        debug(&y); // Don't lint. Has significant drop\n+    }\n+\n+    fn debug(_: impl std::fmt::Debug) {}\n+}\n+\n+#[allow(dead_code)]\n+mod used_exactly_once {\n+    fn foo(x: String) {\n+        use_x(&x);\n+    }\n+    fn use_x(_: impl AsRef<str>) {}\n+}\n+\n+#[allow(dead_code)]\n+mod used_more_than_once {\n+    fn foo(x: String) {\n+        use_x(&x);\n+        use_x_again(&x);\n+    }\n+    fn use_x(_: impl AsRef<str>) {}\n+    fn use_x_again(_: impl AsRef<str>) {}\n+}"}, {"sha": "8b593268bec2112b82b70c268d4c5d1ffafa9127", "filename": "tests/ui/needless_borrow.stderr", "status": "modified", "additions": 66, "deletions": 30, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/tests%2Fui%2Fneedless_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/tests%2Fui%2Fneedless_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.stderr?ref=272bbfb857650e0d3d05dd83a5ce1a522c94b4bd", "patch": "@@ -1,178 +1,214 @@\n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:11:15\n+  --> $DIR/needless_borrow.rs:15:15\n    |\n LL |     let _ = x(&&a); // warn\n    |               ^^^ help: change this to: `&a`\n    |\n    = note: `-D clippy::needless-borrow` implied by `-D warnings`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:15:13\n+  --> $DIR/needless_borrow.rs:19:13\n    |\n LL |     mut_ref(&mut &mut b); // warn\n    |             ^^^^^^^^^^^ help: change this to: `&mut b`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:27:13\n+  --> $DIR/needless_borrow.rs:31:13\n    |\n LL |             &&a\n    |             ^^^ help: change this to: `&a`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:29:15\n+  --> $DIR/needless_borrow.rs:33:15\n    |\n LL |         46 => &&a,\n    |               ^^^ help: change this to: `&a`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:35:27\n+  --> $DIR/needless_borrow.rs:39:27\n    |\n LL |                     break &ref_a;\n    |                           ^^^^^^ help: change this to: `ref_a`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:42:15\n+  --> $DIR/needless_borrow.rs:46:15\n    |\n LL |     let _ = x(&&&a);\n    |               ^^^^ help: change this to: `&a`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:43:15\n+  --> $DIR/needless_borrow.rs:47:15\n    |\n LL |     let _ = x(&mut &&a);\n    |               ^^^^^^^^ help: change this to: `&a`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:44:15\n+  --> $DIR/needless_borrow.rs:48:15\n    |\n LL |     let _ = x(&&&mut b);\n    |               ^^^^^^^^ help: change this to: `&mut b`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:45:15\n+  --> $DIR/needless_borrow.rs:49:15\n    |\n LL |     let _ = x(&&ref_a);\n    |               ^^^^^^^ help: change this to: `ref_a`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:48:11\n+  --> $DIR/needless_borrow.rs:52:11\n    |\n LL |         x(&b);\n    |           ^^ help: change this to: `b`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:55:13\n+  --> $DIR/needless_borrow.rs:59:13\n    |\n LL |     mut_ref(&mut x);\n    |             ^^^^^^ help: change this to: `x`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:56:13\n+  --> $DIR/needless_borrow.rs:60:13\n    |\n LL |     mut_ref(&mut &mut x);\n    |             ^^^^^^^^^^^ help: change this to: `x`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:57:23\n+  --> $DIR/needless_borrow.rs:61:23\n    |\n LL |     let y: &mut i32 = &mut x;\n    |                       ^^^^^^ help: change this to: `x`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:58:23\n+  --> $DIR/needless_borrow.rs:62:23\n    |\n LL |     let y: &mut i32 = &mut &mut x;\n    |                       ^^^^^^^^^^^ help: change this to: `x`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:67:14\n+  --> $DIR/needless_borrow.rs:71:14\n    |\n LL |         0 => &mut x,\n    |              ^^^^^^ help: change this to: `x`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:73:14\n+  --> $DIR/needless_borrow.rs:77:14\n    |\n LL |         0 => &mut x,\n    |              ^^^^^^ help: change this to: `x`\n \n error: this expression borrows a value the compiler would automatically borrow\n-  --> $DIR/needless_borrow.rs:85:13\n+  --> $DIR/needless_borrow.rs:89:13\n    |\n LL |     let _ = (&x).0;\n    |             ^^^^ help: change this to: `x`\n \n error: this expression borrows a value the compiler would automatically borrow\n-  --> $DIR/needless_borrow.rs:87:22\n+  --> $DIR/needless_borrow.rs:91:22\n    |\n LL |     let _ = unsafe { (&*x).0 };\n    |                      ^^^^^ help: change this to: `(*x)`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:97:5\n+  --> $DIR/needless_borrow.rs:101:5\n    |\n LL |     (&&()).foo();\n    |     ^^^^^^ help: change this to: `(&())`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:106:5\n+  --> $DIR/needless_borrow.rs:110:5\n    |\n LL |     (&&5).foo();\n    |     ^^^^^ help: change this to: `(&5)`\n \n error: the borrowed expression implements the required traits\n-  --> $DIR/needless_borrow.rs:131:51\n+  --> $DIR/needless_borrow.rs:135:51\n    |\n LL |     let _ = std::process::Command::new(\"ls\").args(&[\"-a\", \"-l\"]).status().unwrap();\n    |                                                   ^^^^^^^^^^^^^ help: change this to: `[\"-a\", \"-l\"]`\n \n error: the borrowed expression implements the required traits\n-  --> $DIR/needless_borrow.rs:132:44\n+  --> $DIR/needless_borrow.rs:136:44\n    |\n LL |     let _ = std::path::Path::new(\".\").join(&&\".\");\n    |                                            ^^^^^ help: change this to: `\".\"`\n \n error: the borrowed expression implements the required traits\n-  --> $DIR/needless_borrow.rs:133:23\n+  --> $DIR/needless_borrow.rs:137:23\n    |\n LL |     deref_target_is_x(&X);\n    |                       ^^ help: change this to: `X`\n \n error: the borrowed expression implements the required traits\n-  --> $DIR/needless_borrow.rs:134:26\n+  --> $DIR/needless_borrow.rs:138:26\n    |\n LL |     multiple_constraints(&[[\"\"]]);\n    |                          ^^^^^^^ help: change this to: `[[\"\"]]`\n \n error: the borrowed expression implements the required traits\n-  --> $DIR/needless_borrow.rs:135:45\n+  --> $DIR/needless_borrow.rs:139:45\n    |\n LL |     multiple_constraints_normalizes_to_same(&X, X);\n    |                                             ^^ help: change this to: `X`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:136:32\n+  --> $DIR/needless_borrow.rs:140:32\n    |\n LL |     let _ = Some(\"\").unwrap_or(&\"\");\n    |                                ^^^ help: change this to: `\"\"`\n \n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:141:33\n+   |\n+LL |     let _ = std::fs::write(\"x\", &\"\".to_string());\n+   |                                 ^^^^^^^^^^^^^^^ help: change this to: `\"\".to_string()`\n+\n error: this expression borrows a value the compiler would automatically borrow\n-  --> $DIR/needless_borrow.rs:187:13\n+  --> $DIR/needless_borrow.rs:192:13\n    |\n LL |             (&self.f)()\n    |             ^^^^^^^^^ help: change this to: `(self.f)`\n \n error: this expression borrows a value the compiler would automatically borrow\n-  --> $DIR/needless_borrow.rs:196:13\n+  --> $DIR/needless_borrow.rs:201:13\n    |\n LL |             (&mut self.f)()\n    |             ^^^^^^^^^^^^^ help: change this to: `(self.f)`\n \n error: the borrowed expression implements the required traits\n-  --> $DIR/needless_borrow.rs:298:55\n+  --> $DIR/needless_borrow.rs:286:20\n+   |\n+LL |         takes_iter(&mut x)\n+   |                    ^^^^^^ help: change this to: `x`\n+\n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:304:55\n    |\n LL |         let _ = std::process::Command::new(\"ls\").args(&[\"-a\", \"-l\"]).status().unwrap();\n    |                                                       ^^^^^^^^^^^^^ help: change this to: `[\"-a\", \"-l\"]`\n \n-error: aborting due to 29 previous errors\n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:344:37\n+   |\n+LL |         let _ = std::fs::write(\"x\", &arg);\n+   |                                     ^^^^ help: change this to: `arg`\n+\n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:345:37\n+   |\n+LL |         let _ = std::fs::write(\"x\", &loc);\n+   |                                     ^^^^ help: change this to: `loc`\n+\n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:364:15\n+   |\n+LL |         debug(&x);\n+   |               ^^ help: change this to: `x`\n+\n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:374:15\n+   |\n+LL |         use_x(&x);\n+   |               ^^ help: change this to: `x`\n+\n+error: aborting due to 35 previous errors\n "}, {"sha": "fe09aad06bc84d792c10d99a04e8fdd37f05bdbd", "filename": "tests/ui/unnecessary_to_owned.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/tests%2Fui%2Funnecessary_to_owned.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/tests%2Fui%2Funnecessary_to_owned.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_to_owned.fixed?ref=272bbfb857650e0d3d05dd83a5ce1a522c94b4bd", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(clippy::ptr_arg)]\n+#![allow(clippy::needless_borrow, clippy::ptr_arg)]\n #![warn(clippy::unnecessary_to_owned)]\n #![feature(custom_inner_attributes)]\n "}, {"sha": "3de6d0903c0f1d0e083fa5de7fc89cfc331fe1a1", "filename": "tests/ui/unnecessary_to_owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/tests%2Fui%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/tests%2Fui%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_to_owned.rs?ref=272bbfb857650e0d3d05dd83a5ce1a522c94b4bd", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(clippy::ptr_arg)]\n+#![allow(clippy::needless_borrow, clippy::ptr_arg)]\n #![warn(clippy::unnecessary_to_owned)]\n #![feature(custom_inner_attributes)]\n "}, {"sha": "a6d8d0307ce536900c51a6986b034afc2690fa74", "filename": "tests/versioncheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/tests%2Fversioncheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/272bbfb857650e0d3d05dd83a5ce1a522c94b4bd/tests%2Fversioncheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fversioncheck.rs?ref=272bbfb857650e0d3d05dd83a5ce1a522c94b4bd", "patch": "@@ -48,7 +48,7 @@ fn check_that_clippy_has_the_same_major_version_as_rustc() {\n     // `RUSTC_REAL` if Clippy is build in the Rust repo with `./x.py`.\n     let rustc = std::env::var(\"RUSTC_REAL\").unwrap_or_else(|_| \"rustc\".to_string());\n     let rustc_version = String::from_utf8(\n-        std::process::Command::new(&rustc)\n+        std::process::Command::new(rustc)\n             .arg(\"--version\")\n             .output()\n             .expect(\"failed to run `rustc --version`\")"}]}