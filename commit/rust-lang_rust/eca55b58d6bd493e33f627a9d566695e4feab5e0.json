{"sha": "eca55b58d6bd493e33f627a9d566695e4feab5e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjYTU1YjU4ZDZiZDQ5M2UzM2Y2MjdhOWQ1NjY2OTVlNGZlYWI1ZTA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-06-18T12:52:23Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-07-02T16:25:22Z"}, "message": "rename to \"member constraints\"", "tree": {"sha": "6b049efff515cf64a96c145dbe88c7a42869ea87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b049efff515cf64a96c145dbe88c7a42869ea87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eca55b58d6bd493e33f627a9d566695e4feab5e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eca55b58d6bd493e33f627a9d566695e4feab5e0", "html_url": "https://github.com/rust-lang/rust/commit/eca55b58d6bd493e33f627a9d566695e4feab5e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eca55b58d6bd493e33f627a9d566695e4feab5e0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e39f66a859160668504b43d6664a01df86147b42", "url": "https://api.github.com/repos/rust-lang/rust/commits/e39f66a859160668504b43d6664a01df86147b42", "html_url": "https://github.com/rust-lang/rust/commit/e39f66a859160668504b43d6664a01df86147b42"}], "stats": {"total": 536, "additions": 275, "deletions": 261}, "files": [{"sha": "b508f91e01ebb22905053676a4c7ba5a33419547", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=eca55b58d6bd493e33f627a9d566695e4feab5e0", "patch": "@@ -23,7 +23,7 @@\n \n use crate::infer::{InferCtxt, RegionVariableOrigin, TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{ConstVariableOrigin, ConstVariableOriginKind};\n-use crate::infer::region_constraints::PickConstraint;\n+use crate::infer::region_constraints::MemberConstraint;\n use crate::mir::interpret::ConstValue;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_macros::HashStable;\n@@ -198,14 +198,14 @@ pub struct QueryResponse<'tcx, R> {\n #[derive(Clone, Debug, Default, HashStable)]\n pub struct QueryRegionConstraints<'tcx> {\n     pub outlives: Vec<QueryOutlivesConstraint<'tcx>>,\n-    pub pick_constraints: Vec<PickConstraint<'tcx>>,\n+    pub member_constraints: Vec<MemberConstraint<'tcx>>,\n }\n \n impl QueryRegionConstraints<'_> {\n     /// Represents an empty (trivially true) set of region\n     /// constraints.\n     pub fn is_empty(&self) -> bool {\n-        self.outlives.is_empty() && self.pick_constraints.is_empty()\n+        self.outlives.is_empty() && self.member_constraints.is_empty()\n     }\n }\n \n@@ -558,14 +558,14 @@ BraceStructLiftImpl! {\n \n BraceStructTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for QueryRegionConstraints<'tcx> {\n-        outlives, pick_constraints\n+        outlives, member_constraints\n     }\n }\n \n BraceStructLiftImpl! {\n     impl<'a, 'tcx> Lift<'tcx> for QueryRegionConstraints<'a> {\n         type Lifted = QueryRegionConstraints<'tcx>;\n-        outlives, pick_constraints\n+        outlives, member_constraints\n     }\n }\n "}, {"sha": "79c5538626be191f80eba1c5671db8b8f56892fd", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=eca55b58d6bd493e33f627a9d566695e4feab5e0", "patch": "@@ -351,9 +351,9 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             })\n         );\n \n-        // ...also include the query pick constraints.\n-        output_query_region_constraints.pick_constraints.extend(\n-            query_response.value.region_constraints.pick_constraints.iter().map(|p_c| {\n+        // ...also include the query member constraints.\n+        output_query_region_constraints.member_constraints.extend(\n+            query_response.value.region_constraints.member_constraints.iter().map(|p_c| {\n                 substitute_value(self.tcx, &result_subst, p_c)\n             })\n         );\n@@ -663,7 +663,7 @@ pub fn make_query_region_constraints<'tcx>(\n         constraints,\n         verifys,\n         givens,\n-        pick_constraints,\n+        member_constraints,\n     } = region_constraints;\n \n     assert!(verifys.is_empty());\n@@ -694,5 +694,5 @@ pub fn make_query_region_constraints<'tcx>(\n         )\n         .collect();\n \n-    QueryRegionConstraints { outlives, pick_constraints: pick_constraints.clone() }\n+    QueryRegionConstraints { outlives, member_constraints: member_constraints.clone() }\n }"}, {"sha": "cbfb048c064a2c2e4d3b91d72c632bf1cfb9f402", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=eca55b58d6bd493e33f627a9d566695e4feab5e0", "patch": "@@ -377,20 +377,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         }\n                     }\n \n-                    RegionResolutionError::PickConstraintFailure {\n+                    RegionResolutionError::MemberConstraintFailure {\n                         opaque_type_def_id,\n                         hidden_ty,\n-                        pick_region,\n+                        member_region,\n                         span: _,\n-                        option_regions: _,\n+                        choice_regions: _,\n                     } => {\n                         let hidden_ty = self.resolve_vars_if_possible(&hidden_ty);\n                         opaque_types::unexpected_hidden_region_diagnostic(\n                             self.tcx,\n                             Some(region_scope_tree),\n                             opaque_type_def_id,\n                             hidden_ty,\n-                            pick_region,\n+                            member_region,\n                         ).emit();\n                     }\n                 }\n@@ -430,7 +430,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             RegionResolutionError::GenericBoundFailure(..) => true,\n             RegionResolutionError::ConcreteFailure(..)\n                 | RegionResolutionError::SubSupConflict(..)\n-                | RegionResolutionError::PickConstraintFailure { .. } => false,\n+                | RegionResolutionError::MemberConstraintFailure { .. } => false,\n         };\n \n         let mut errors = if errors.iter().all(|e| is_bound_failure(e)) {\n@@ -448,7 +448,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             RegionResolutionError::ConcreteFailure(ref sro, _, _) => sro.span(),\n             RegionResolutionError::GenericBoundFailure(ref sro, _, _) => sro.span(),\n             RegionResolutionError::SubSupConflict(_, ref rvo, _, _, _, _) => rvo.span(),\n-            RegionResolutionError::PickConstraintFailure { span, .. } => span,\n+            RegionResolutionError::MemberConstraintFailure { span, .. } => span,\n         });\n         errors\n     }"}, {"sha": "c718badf6e0630094522a573426410c37cc7e414", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 47, "deletions": 42, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=eca55b58d6bd493e33f627a9d566695e4feab5e0", "patch": "@@ -3,7 +3,7 @@\n use crate::hir::def_id::DefId;\n use crate::infer::region_constraints::Constraint;\n use crate::infer::region_constraints::GenericKind;\n-use crate::infer::region_constraints::PickConstraint;\n+use crate::infer::region_constraints::MemberConstraint;\n use crate::infer::region_constraints::RegionConstraintData;\n use crate::infer::region_constraints::VarInfos;\n use crate::infer::region_constraints::VerifyBound;\n@@ -84,15 +84,15 @@ pub enum RegionResolutionError<'tcx> {\n         Region<'tcx>,\n     ),\n \n-    /// Indicates a failure of a `PickConstraint`. These arise during\n+    /// Indicates a failure of a `MemberConstraint`. These arise during\n     /// impl trait processing explicitly -- basically, the impl trait's hidden type\n     /// included some region that it was not supposed to.\n-    PickConstraintFailure {\n+    MemberConstraintFailure {\n         span: Span,\n         opaque_type_def_id: DefId,\n         hidden_ty: Ty<'tcx>,\n-        pick_region: Region<'tcx>,\n-        option_regions: Vec<Region<'tcx>>,\n+        member_region: Region<'tcx>,\n+        choice_regions: Vec<Region<'tcx>>,\n     },\n }\n \n@@ -133,7 +133,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         self.expand_givens(&graph);\n         loop {\n             self.expansion(&mut var_data);\n-            if !self.enforce_pick_constraints(&graph, &mut var_data) {\n+            if !self.enforce_member_constraints(&graph, &mut var_data) {\n                 break;\n             }\n         }\n@@ -197,16 +197,16 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n     }\n \n-    /// Enforce all pick constraints and return true if anything\n-    /// changed. See `enforce_pick_constraint` for more details.\n-    fn enforce_pick_constraints(\n+    /// Enforce all member constraints and return true if anything\n+    /// changed. See `enforce_member_constraint` for more details.\n+    fn enforce_member_constraints(\n         &self,\n         graph: &RegionGraph<'tcx>,\n         var_values: &mut LexicalRegionResolutions<'tcx>,\n     ) -> bool {\n         let mut any_changed = false;\n-        for pick_constraint in &self.data.pick_constraints {\n-            if self.enforce_pick_constraint(graph, pick_constraint, var_values) {\n+        for member_constraint in &self.data.member_constraints {\n+            if self.enforce_member_constraint(graph, member_constraint, var_values) {\n                 any_changed = true;\n             }\n         }\n@@ -230,39 +230,44 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     ///\n     /// From that list, we look for a *minimal* option `'o_min`. If we\n     /// find one, then we can enforce that `'r: 'o_min`.\n-    fn enforce_pick_constraint(\n+    fn enforce_member_constraint(\n         &self,\n         graph: &RegionGraph<'tcx>,\n-        pick_constraint: &PickConstraint<'tcx>,\n+        member_constraint: &MemberConstraint<'tcx>,\n         var_values: &mut LexicalRegionResolutions<'tcx>,\n     ) -> bool {\n-        debug!(\"enforce_pick_constraint(pick_constraint={:#?})\", pick_constraint);\n+        debug!(\"enforce_member_constraint(member_constraint={:#?})\", member_constraint);\n \n         // the constraint is some inference variable (`vid`) which\n         // must be equal to one of the options\n-        let pick_vid = match pick_constraint.pick_region {\n+        let member_vid = match member_constraint.member_region {\n             ty::ReVar(vid) => *vid,\n             _ => return false,\n         };\n \n         // The current value of `vid` is a lower bound LB -- i.e., we\n         // know that `LB <= vid` must be true.\n-        let pick_lower_bound: ty::Region<'tcx> = match var_values.value(pick_vid) {\n+        let member_lower_bound: ty::Region<'tcx> = match var_values.value(member_vid) {\n             VarValue::ErrorValue => return false,\n             VarValue::Value(r) => r,\n         };\n \n         // find all the \"upper bounds\" -- that is, each region `b` such that\n         // `r0 <= b` must hold.\n-        let (pick_upper_bounds, _) = self.collect_concrete_regions(graph, pick_vid, OUTGOING, None);\n+        let (member_upper_bounds, _) = self.collect_concrete_regions(\n+            graph,\n+            member_vid,\n+            OUTGOING,\n+            None,\n+        );\n \n-        // get an iterator over the *available options* -- that is,\n-        // each constraint regions `o` where `lb <= o` and `o <= ub` for all the\n+        // get an iterator over the *available choice* -- that is,\n+        // each choice region `c` where `lb <= c` and `c <= ub` for all the\n         // upper bounds `ub`.\n-        debug!(\"enforce_pick_constraint: upper_bounds={:#?}\", pick_upper_bounds);\n-        let mut options = pick_constraint.option_regions.iter().filter(|option| {\n-            self.sub_concrete_regions(pick_lower_bound, option)\n-                && pick_upper_bounds\n+        debug!(\"enforce_member_constraint: upper_bounds={:#?}\", member_upper_bounds);\n+        let mut options = member_constraint.choice_regions.iter().filter(|option| {\n+            self.sub_concrete_regions(member_lower_bound, option)\n+                && member_upper_bounds\n                     .iter()\n                     .all(|upper_bound| self.sub_concrete_regions(option, upper_bound.region))\n         });\n@@ -274,23 +279,23 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             Some(&r) => r,\n             None => return false,\n         };\n-        debug!(\"enforce_pick_constraint: least_choice={:?}\", least_choice);\n+        debug!(\"enforce_member_constraint: least_choice={:?}\", least_choice);\n         for &option in options {\n-            debug!(\"enforce_pick_constraint: option={:?}\", option);\n+            debug!(\"enforce_member_constraint: option={:?}\", option);\n             if !self.sub_concrete_regions(least_choice, option) {\n                 if self.sub_concrete_regions(option, least_choice) {\n-                    debug!(\"enforce_pick_constraint: new least choice\");\n+                    debug!(\"enforce_member_constraint: new least choice\");\n                     least_choice = option;\n                 } else {\n-                    debug!(\"enforce_pick_constraint: no least choice\");\n+                    debug!(\"enforce_member_constraint: no least choice\");\n                     return false;\n                 }\n             }\n         }\n \n-        debug!(\"enforce_pick_constraint: final least choice = {:?}\", least_choice);\n-        if least_choice != pick_lower_bound {\n-            *var_values.value_mut(pick_vid) = VarValue::Value(least_choice);\n+        debug!(\"enforce_member_constraint: final least choice = {:?}\", least_choice);\n+        if least_choice != member_lower_bound {\n+            *var_values.value_mut(member_vid) = VarValue::Value(least_choice);\n             true\n         } else {\n             false\n@@ -547,20 +552,20 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             }\n         }\n \n-        for pick_constraint in &self.data.pick_constraints {\n-            let pick_region = var_data.normalize(self.tcx(), pick_constraint.pick_region);\n-            let option_regions = pick_constraint\n-                .option_regions\n+        for member_constraint in &self.data.member_constraints {\n+            let member_region = var_data.normalize(self.tcx(), member_constraint.member_region);\n+            let choice_regions = member_constraint\n+                .choice_regions\n                 .iter()\n-                .map(|&option_region| var_data.normalize(self.tcx(), option_region));\n-            if !option_regions.clone().any(|option_region| pick_region == option_region) {\n-                let span = self.tcx().def_span(pick_constraint.opaque_type_def_id);\n-                errors.push(RegionResolutionError::PickConstraintFailure {\n+                .map(|&choice_region| var_data.normalize(self.tcx(), choice_region));\n+            if !choice_regions.clone().any(|choice_region| member_region == choice_region) {\n+                let span = self.tcx().def_span(member_constraint.opaque_type_def_id);\n+                errors.push(RegionResolutionError::MemberConstraintFailure {\n                     span,\n-                    opaque_type_def_id: pick_constraint.opaque_type_def_id,\n-                    hidden_ty: pick_constraint.hidden_ty,\n-                    pick_region,\n-                    option_regions: option_regions.collect(),\n+                    opaque_type_def_id: member_constraint.opaque_type_def_id,\n+                    hidden_ty: member_constraint.hidden_ty,\n+                    member_region,\n+                    choice_regions: choice_regions.collect(),\n                 });\n             }\n         }"}, {"sha": "663acd67dcd839b147f5e4b3a7fc263a70e0a0af", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=eca55b58d6bd493e33f627a9d566695e4feab5e0", "patch": "@@ -907,17 +907,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     /// Require that the region `r` be equal to one of the regions in\n     /// the set `regions`.\n-    pub fn pick_constraint(\n+    pub fn member_constraint(\n         &self,\n         opaque_type_def_id: DefId,\n         definition_span: Span,\n         hidden_ty: Ty<'tcx>,\n         region: ty::Region<'tcx>,\n         in_regions: &Lrc<Vec<ty::Region<'tcx>>>,\n     ) {\n-        debug!(\"pick_constraint({:?} <: {:?})\", region, in_regions);\n+        debug!(\"member_constraint({:?} <: {:?})\", region, in_regions);\n         self.borrow_region_constraints()\n-            .pick_constraint(opaque_type_def_id, definition_span, hidden_ty, region, in_regions);\n+            .member_constraint(opaque_type_def_id, definition_span, hidden_ty, region, in_regions);\n     }\n \n     pub fn subtype_predicate("}, {"sha": "2e35aefa88ae6a0d45a5cb8b1a47230d67c9946d", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=eca55b58d6bd493e33f627a9d566695e4feab5e0", "patch": "@@ -393,7 +393,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         // we will create a \"in bound\" like `'r in\n                         // ['a, 'b, 'c]`, where `'a..'c` are the\n                         // regions that appear in the impl trait.\n-                        return self.generate_pick_constraint(\n+                        return self.generate_member_constraint(\n                             concrete_ty,\n                             abstract_type_generics,\n                             opaque_defn,\n@@ -418,17 +418,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// related, we would generate a constraint `'r in ['a, 'b,\n     /// 'static]` for each region `'r` that appears in the hidden type\n     /// (i.e., it must be equal to `'a`, `'b`, or `'static`).\n-    fn generate_pick_constraint(\n+    fn generate_member_constraint(\n         &self,\n         concrete_ty: Ty<'tcx>,\n         abstract_type_generics: &ty::Generics,\n         opaque_defn: &OpaqueTypeDecl<'tcx>,\n         opaque_type_def_id: DefId,\n     ) {\n-        // Create the set of option regions: each region in the hidden\n+        // Create the set of choice regions: each region in the hidden\n         // type can be equal to any of the region parameters of the\n         // opaque type definition.\n-        let option_regions: Lrc<Vec<ty::Region<'tcx>>> = Lrc::new(\n+        let choice_regions: Lrc<Vec<ty::Region<'tcx>>> = Lrc::new(\n             abstract_type_generics\n                 .params\n                 .iter()\n@@ -443,12 +443,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n             tcx: self.tcx,\n-            op: |r| self.pick_constraint(\n+            op: |r| self.member_constraint(\n                 opaque_type_def_id,\n                 opaque_defn.definition_span,\n                 concrete_ty,\n                 r,\n-                &option_regions,\n+                &choice_regions,\n             ),\n         });\n     }"}, {"sha": "06365890607637bdd940bd7f79abe87bc725da2c", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=eca55b58d6bd493e33f627a9d566695e4feab5e0", "patch": "@@ -81,10 +81,10 @@ pub struct RegionConstraintData<'tcx> {\n     /// be a region variable (or neither, as it happens).\n     pub constraints: BTreeMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,\n \n-    /// Constraints of the form `pick R0 from [R1, ..., Rn]`, meaning that\n+    /// Constraints of the form `R0 member of [R1, ..., Rn]`, meaning that\n     /// `R0` must be equal to one of the regions `R1..Rn`. These occur\n     /// with `impl Trait` quite frequently.\n-    pub pick_constraints: Vec<PickConstraint<'tcx>>,\n+    pub member_constraints: Vec<MemberConstraint<'tcx>>,\n \n     /// A \"verify\" is something that we need to verify after inference\n     /// is done, but which does not directly affect inference in any\n@@ -145,40 +145,40 @@ impl Constraint<'_> {\n     }\n }\n \n-/// Requires that `region` must be equal to one of the regions in `option_regions`.\n+/// Requires that `region` must be equal to one of the regions in `choice_regions`.\n /// We often denote this using the syntax:\n ///\n /// ```\n-/// pick R0 from [O1..On]\n+/// R0 member of [O1..On]\n /// ```\n #[derive(Debug, Clone, HashStable)]\n-pub struct PickConstraint<'tcx> {\n+pub struct MemberConstraint<'tcx> {\n     /// the def-id of the opaque type causing this constraint: used for error reporting\n     pub opaque_type_def_id: DefId,\n \n     /// the span where the hidden type was instantiated\n     pub definition_span: Span,\n \n-    /// the hidden type in which `pick_region` appears: used for error reporting\n+    /// the hidden type in which `member_region` appears: used for error reporting\n     pub hidden_ty: Ty<'tcx>,\n \n     /// the region R0\n-    pub pick_region: Region<'tcx>,\n+    pub member_region: Region<'tcx>,\n \n     /// the options O1..On\n-    pub option_regions: Lrc<Vec<Region<'tcx>>>,\n+    pub choice_regions: Lrc<Vec<Region<'tcx>>>,\n }\n \n BraceStructTypeFoldableImpl! {\n-    impl<'tcx> TypeFoldable<'tcx> for PickConstraint<'tcx> {\n-        opaque_type_def_id, definition_span, hidden_ty, pick_region, option_regions\n+    impl<'tcx> TypeFoldable<'tcx> for MemberConstraint<'tcx> {\n+        opaque_type_def_id, definition_span, hidden_ty, member_region, choice_regions\n     }\n }\n \n BraceStructLiftImpl! {\n-    impl<'a, 'tcx> Lift<'tcx> for PickConstraint<'a> {\n-        type Lifted = PickConstraint<'tcx>;\n-        opaque_type_def_id, definition_span, hidden_ty, pick_region, option_regions\n+    impl<'a, 'tcx> Lift<'tcx> for MemberConstraint<'a> {\n+        type Lifted = MemberConstraint<'tcx>;\n+        opaque_type_def_id, definition_span, hidden_ty, member_region, choice_regions\n     }\n }\n \n@@ -688,26 +688,26 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         }\n     }\n \n-    pub fn pick_constraint(\n+    pub fn member_constraint(\n         &mut self,\n         opaque_type_def_id: DefId,\n         definition_span: Span,\n         hidden_ty: Ty<'tcx>,\n-        pick_region: ty::Region<'tcx>,\n-        option_regions: &Lrc<Vec<ty::Region<'tcx>>>,\n+        member_region: ty::Region<'tcx>,\n+        choice_regions: &Lrc<Vec<ty::Region<'tcx>>>,\n     ) {\n-        debug!(\"pick_constraint({:?} in {:#?})\", pick_region, option_regions);\n+        debug!(\"member_constraint({:?} in {:#?})\", member_region, choice_regions);\n \n-        if option_regions.iter().any(|&r| r == pick_region) {\n+        if choice_regions.iter().any(|&r| r == member_region) {\n             return;\n         }\n \n-        self.data.pick_constraints.push(PickConstraint {\n+        self.data.member_constraints.push(MemberConstraint {\n             opaque_type_def_id,\n             definition_span,\n             hidden_ty,\n-            pick_region,\n-            option_regions: option_regions.clone()\n+            member_region,\n+            choice_regions: choice_regions.clone()\n         });\n \n     }\n@@ -975,12 +975,12 @@ impl<'tcx> RegionConstraintData<'tcx> {\n     pub fn is_empty(&self) -> bool {\n         let RegionConstraintData {\n             constraints,\n-            pick_constraints,\n+            member_constraints,\n             verifys,\n             givens,\n         } = self;\n         constraints.is_empty() &&\n-            pick_constraints.is_empty() &&\n+            member_constraints.is_empty() &&\n             verifys.is_empty() &&\n             givens.is_empty()\n     }"}, {"sha": "f1749d39d6e4131c12706ae70943c4d40cdb8839", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=eca55b58d6bd493e33f627a9d566695e4feab5e0", "patch": "@@ -349,7 +349,7 @@ impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>, C: Lift<'tcx>> Lift<'tcx> for (A, B, C)\n         tcx.lift(&self.0).and_then(|a| {\n             tcx.lift(&self.1).and_then(|b| tcx.lift(&self.2).map(|c| (a, b, c)))\n         })\n-    }\n+   }\n }\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Option<T> {"}, {"sha": "eb63e0de195e5d6692d56ad9e94d9edb4514ab3e", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=eca55b58d6bd493e33f627a9d566695e4feab5e0", "patch": "@@ -37,7 +37,7 @@ crate mod type_check;\n mod universal_regions;\n \n mod constraints;\n-mod pick_constraints;\n+mod member_constraints;\n \n use self::facts::AllFacts;\n use self::region_infer::RegionInferenceContext;\n@@ -130,7 +130,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         placeholder_index_to_region: _,\n         mut liveness_constraints,\n         outlives_constraints,\n-        pick_constraints,\n+        member_constraints,\n         closure_bounds_mapping,\n         type_tests,\n     } = constraints;\n@@ -152,7 +152,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         universal_region_relations,\n         body,\n         outlives_constraints,\n-        pick_constraints,\n+        member_constraints,\n         closure_bounds_mapping,\n         type_tests,\n         liveness_constraints,"}, {"sha": "43212ffddf3a5be2a4afd475d5a25d37d92bf0bd", "filename": "src/librustc_mir/borrow_check/nll/pick_constraints.rs", "status": "modified", "additions": 61, "deletions": 58, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fpick_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fpick_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fpick_constraints.rs?ref=eca55b58d6bd493e33f627a9d566695e4feab5e0", "patch": "@@ -1,36 +1,36 @@\n use crate::rustc::ty::{self, Ty};\n use rustc::hir::def_id::DefId;\n-use rustc::infer::region_constraints::PickConstraint;\n+use rustc::infer::region_constraints::MemberConstraint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use std::hash::Hash;\n use std::ops::Index;\n use syntax_pos::Span;\n \n-/// Compactly stores a set of `pick R0 in [R1...Rn]` constraints,\n+/// Compactly stores a set of `R0 member of [R1...Rn]` constraints,\n /// indexed by the region R0.\n-crate struct PickConstraintSet<'tcx, R>\n+crate struct MemberConstraintSet<'tcx, R>\n where\n     R: Copy + Hash + Eq,\n {\n-    /// Stores the first \"pick\" constraint for a given R0. This is an\n+    /// Stores the first \"member\" constraint for a given R0. This is an\n     /// index into the `constraints` vector below.\n-    first_constraints: FxHashMap<R, NllPickConstraintIndex>,\n+    first_constraints: FxHashMap<R, NllMemberConstraintIndex>,\n \n-    /// Stores the data about each `pick R0 from [R1..Rn]` constraint.\n+    /// Stores the data about each `R0 member of [R1..Rn]` constraint.\n     /// These are organized into a linked list, so each constraint\n     /// contains the index of the next constraint with the same R0.\n-    constraints: IndexVec<NllPickConstraintIndex, NllPickConstraint<'tcx>>,\n+    constraints: IndexVec<NllMemberConstraintIndex, NllMemberConstraint<'tcx>>,\n \n     /// Stores the `R1..Rn` regions for *all* sets. For any given\n     /// constraint, we keep two indices so that we can pull out a\n     /// slice.\n-    option_regions: Vec<ty::RegionVid>,\n+    choice_regions: Vec<ty::RegionVid>,\n }\n \n-/// Represents a `pick R0 in [R1..Rn]` constraint\n-crate struct NllPickConstraint<'tcx> {\n-    next_constraint: Option<NllPickConstraintIndex>,\n+/// Represents a `R0 member of [R1..Rn]` constraint\n+crate struct NllMemberConstraint<'tcx> {\n+    next_constraint: Option<NllMemberConstraintIndex>,\n \n     /// The opaque type whose hidden type is being inferred. (Used in error reporting.)\n     crate opaque_type_def_id: DefId,\n@@ -42,67 +42,70 @@ crate struct NllPickConstraint<'tcx> {\n     crate hidden_ty: Ty<'tcx>,\n \n     /// The region R0.\n-    crate pick_region_vid: ty::RegionVid,\n+    crate member_region_vid: ty::RegionVid,\n \n-    /// Index of `R1` in `option_regions` vector from `PickConstraintSet`.\n+    /// Index of `R1` in `choice_regions` vector from `MemberConstraintSet`.\n     start_index: usize,\n \n-    /// Index of `Rn` in `option_regions` vector from `PickConstraintSet`.\n+    /// Index of `Rn` in `choice_regions` vector from `MemberConstraintSet`.\n     end_index: usize,\n }\n \n newtype_index! {\n-    crate struct NllPickConstraintIndex {\n-        DEBUG_FORMAT = \"PickConstraintIndex({})\"\n+    crate struct NllMemberConstraintIndex {\n+        DEBUG_FORMAT = \"MemberConstraintIndex({})\"\n     }\n }\n \n-impl Default for PickConstraintSet<'tcx, ty::RegionVid> {\n+impl Default for MemberConstraintSet<'tcx, ty::RegionVid> {\n     fn default() -> Self {\n         Self {\n             first_constraints: Default::default(),\n             constraints: Default::default(),\n-            option_regions: Default::default(),\n+            choice_regions: Default::default(),\n         }\n     }\n }\n \n-impl<'tcx> PickConstraintSet<'tcx, ty::RegionVid> {\n+impl<'tcx> MemberConstraintSet<'tcx, ty::RegionVid> {\n     crate fn push_constraint(\n         &mut self,\n-        p_c: &PickConstraint<'tcx>,\n+        m_c: &MemberConstraint<'tcx>,\n         mut to_region_vid: impl FnMut(ty::Region<'tcx>) -> ty::RegionVid,\n     ) {\n-        debug!(\"push_constraint(p_c={:?})\", p_c);\n-        let pick_region_vid: ty::RegionVid = to_region_vid(p_c.pick_region);\n-        let next_constraint = self.first_constraints.get(&pick_region_vid).cloned();\n-        let start_index = self.option_regions.len();\n-        let end_index = start_index + p_c.option_regions.len();\n-        debug!(\"push_constraint: pick_region_vid={:?}\", pick_region_vid);\n-        let constraint_index = self.constraints.push(NllPickConstraint {\n+        debug!(\"push_constraint(m_c={:?})\", m_c);\n+        let member_region_vid: ty::RegionVid = to_region_vid(m_c.member_region);\n+        let next_constraint = self.first_constraints.get(&member_region_vid).cloned();\n+        let start_index = self.choice_regions.len();\n+        let end_index = start_index + m_c.choice_regions.len();\n+        debug!(\"push_constraint: member_region_vid={:?}\", member_region_vid);\n+        let constraint_index = self.constraints.push(NllMemberConstraint {\n             next_constraint,\n-            pick_region_vid,\n-            opaque_type_def_id: p_c.opaque_type_def_id,\n-            definition_span: p_c.definition_span,\n-            hidden_ty: p_c.hidden_ty,\n+            member_region_vid,\n+            opaque_type_def_id: m_c.opaque_type_def_id,\n+            definition_span: m_c.definition_span,\n+            hidden_ty: m_c.hidden_ty,\n             start_index,\n             end_index,\n         });\n-        self.first_constraints.insert(pick_region_vid, constraint_index);\n-        self.option_regions.extend(p_c.option_regions.iter().map(|&r| to_region_vid(r)));\n+        self.first_constraints.insert(member_region_vid, constraint_index);\n+        self.choice_regions.extend(m_c.choice_regions.iter().map(|&r| to_region_vid(r)));\n     }\n }\n \n-impl<'tcx, R1> PickConstraintSet<'tcx, R1>\n+impl<'tcx, R1> MemberConstraintSet<'tcx, R1>\n where\n     R1: Copy + Hash + Eq,\n {\n-    /// Remap the \"pick region\" key using `map_fn`, producing a new\n+    /// Remap the \"member region\" key using `map_fn`, producing a new\n     /// pick-constraint set.  This is used in the NLL code to map from\n     /// the original `RegionVid` to an scc index. In some cases, we\n     /// may have multiple R1 values mapping to the same R2 key -- that\n     /// is ok, the two sets will be merged.\n-    crate fn into_mapped<R2>(self, mut map_fn: impl FnMut(R1) -> R2) -> PickConstraintSet<'tcx, R2>\n+    crate fn into_mapped<R2>(\n+        self,\n+        mut map_fn: impl FnMut(R1) -> R2,\n+    ) -> MemberConstraintSet<'tcx, R2>\n     where\n         R2: Copy + Hash + Eq,\n     {\n@@ -116,7 +119,7 @@ where\n         // link from one list to point at the othe other (see\n         // `append_list`).\n \n-        let PickConstraintSet { first_constraints, mut constraints, option_regions } = self;\n+        let MemberConstraintSet { first_constraints, mut constraints, choice_regions } = self;\n \n         let mut first_constraints2 = FxHashMap::default();\n         first_constraints2.reserve(first_constraints.len());\n@@ -129,33 +132,33 @@ where\n             first_constraints2.insert(r2, start1);\n         }\n \n-        PickConstraintSet {\n+        MemberConstraintSet {\n             first_constraints: first_constraints2,\n             constraints,\n-            option_regions,\n+            choice_regions,\n         }\n     }\n }\n \n-impl<'tcx, R> PickConstraintSet<'tcx, R>\n+impl<'tcx, R> MemberConstraintSet<'tcx, R>\n where\n     R: Copy + Hash + Eq,\n {\n     crate fn all_indices(\n         &self,\n-    ) -> impl Iterator<Item = NllPickConstraintIndex> {\n+    ) -> impl Iterator<Item = NllMemberConstraintIndex> {\n         self.constraints.indices()\n     }\n \n     /// Iterate down the constraint indices associated with a given\n-    /// peek-region.  You can then use `option_regions` and other\n+    /// peek-region.  You can then use `choice_regions` and other\n     /// methods to access data.\n     crate fn indices(\n         &self,\n-        pick_region_vid: R,\n-    ) -> impl Iterator<Item = NllPickConstraintIndex> + '_ {\n-        let mut next = self.first_constraints.get(&pick_region_vid).cloned();\n-        std::iter::from_fn(move || -> Option<NllPickConstraintIndex> {\n+        member_region_vid: R,\n+    ) -> impl Iterator<Item = NllMemberConstraintIndex> + '_ {\n+        let mut next = self.first_constraints.get(&member_region_vid).cloned();\n+        std::iter::from_fn(move || -> Option<NllMemberConstraintIndex> {\n             if let Some(current) = next {\n                 next = self.constraints[current].next_constraint;\n                 Some(current)\n@@ -165,25 +168,25 @@ where\n         })\n     }\n \n-    /// Returns the \"option regions\" for a given pick constraint. This is the R1..Rn from\n-    /// a constraint like:\n+    /// Returns the \"choice regions\" for a given member\n+    /// constraint. This is the R1..Rn from a constraint like:\n     ///\n     /// ```\n-    /// pick R0 in [R1..Rn]\n+    /// R0 member of [R1..Rn]\n     /// ```\n-    crate fn option_regions(&self, pci: NllPickConstraintIndex) -> &[ty::RegionVid] {\n-        let NllPickConstraint { start_index, end_index, .. } = &self.constraints[pci];\n-        &self.option_regions[*start_index..*end_index]\n+    crate fn choice_regions(&self, pci: NllMemberConstraintIndex) -> &[ty::RegionVid] {\n+        let NllMemberConstraint { start_index, end_index, .. } = &self.constraints[pci];\n+        &self.choice_regions[*start_index..*end_index]\n     }\n }\n \n-impl<'tcx, R> Index<NllPickConstraintIndex> for PickConstraintSet<'tcx, R>\n+impl<'tcx, R> Index<NllMemberConstraintIndex> for MemberConstraintSet<'tcx, R>\n where\n     R: Copy + Hash + Eq,\n {\n-    type Output = NllPickConstraint<'tcx>;\n+    type Output = NllMemberConstraint<'tcx>;\n \n-    fn index(&self, i: NllPickConstraintIndex) -> &NllPickConstraint<'tcx> {\n+    fn index(&self, i: NllMemberConstraintIndex) -> &NllMemberConstraint<'tcx> {\n         &self.constraints[i]\n     }\n }\n@@ -205,9 +208,9 @@ where\n /// target_list: A -> B -> C -> D -> E -> F -> (None)\n /// ```\n fn append_list(\n-    constraints: &mut IndexVec<NllPickConstraintIndex, NllPickConstraint<'_>>,\n-    target_list: NllPickConstraintIndex,\n-    source_list: NllPickConstraintIndex,\n+    constraints: &mut IndexVec<NllMemberConstraintIndex, NllMemberConstraint<'_>>,\n+    target_list: NllMemberConstraintIndex,\n+    source_list: NllMemberConstraintIndex,\n ) {\n     let mut p = target_list;\n     loop {"}, {"sha": "b3649b2179fff2fbbd69bb977c042ecdb905b5f4", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=eca55b58d6bd493e33f627a9d566695e4feab5e0", "patch": "@@ -1,5 +1,5 @@\n use crate::borrow_check::nll::constraints::OutlivesConstraint;\n-use crate::borrow_check::nll::region_infer::AppliedPickConstraint;\n+use crate::borrow_check::nll::region_infer::AppliedMemberConstraint;\n use crate::borrow_check::nll::region_infer::RegionInferenceContext;\n use crate::borrow_check::nll::type_check::Locations;\n use crate::borrow_check::nll::universal_regions::DefiningTy;\n@@ -224,13 +224,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // But pick-constraints can also give rise to `'r: 'x`\n             // edges that were not part of the graph initially, so\n             // watch out for those.\n-            let outgoing_edges_from_picks = self.applied_pick_constraints(r)\n+            let outgoing_edges_from_picks = self.applied_member_constraints(r)\n                 .iter()\n-                .map(|&AppliedPickConstraint { best_option, pick_constraint_index, .. }| {\n-                    let p_c = &self.pick_constraints[pick_constraint_index];\n+                .map(|&AppliedMemberConstraint { min_choice, member_constraint_index, .. }| {\n+                    let p_c = &self.member_constraints[member_constraint_index];\n                     OutlivesConstraint {\n                         sup: r,\n-                        sub: best_option,\n+                        sub: min_choice,\n                         locations: Locations::All(p_c.definition_span),\n                         category: ConstraintCategory::OpaqueType,\n                     }"}, {"sha": "78f6e731ce2442e476b72db873d21fa8c5b71a28", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 97, "deletions": 94, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=eca55b58d6bd493e33f627a9d566695e4feab5e0", "patch": "@@ -3,7 +3,7 @@ use crate::borrow_check::nll::constraints::graph::NormalConstraintGraph;\n use crate::borrow_check::nll::constraints::{\n     ConstraintSccIndex, OutlivesConstraint, OutlivesConstraintSet,\n };\n-use crate::borrow_check::nll::pick_constraints::{PickConstraintSet, NllPickConstraintIndex};\n+use crate::borrow_check::nll::member_constraints::{MemberConstraintSet, NllMemberConstraintIndex};\n use crate::borrow_check::nll::region_infer::values::{\n     PlaceholderIndices, RegionElement, ToElementIndex,\n };\n@@ -72,14 +72,14 @@ pub struct RegionInferenceContext<'tcx> {\n     /// exists if `B: A`. Computed lazilly.\n     rev_constraint_graph: Option<Rc<VecGraph<ConstraintSccIndex>>>,\n \n-    /// The \"pick R0 from [R1..Rn]\" constraints, indexed by SCC.\n-    pick_constraints: Rc<PickConstraintSet<'tcx, ConstraintSccIndex>>,\n+    /// The \"R0 member of [R1..Rn]\" constraints, indexed by SCC.\n+    member_constraints: Rc<MemberConstraintSet<'tcx, ConstraintSccIndex>>,\n \n     /// Records the pick-constraints that we applied to each scc.\n     /// This is useful for error reporting. Once constraint\n     /// propagation is done, this vector is sorted according to\n-    /// `pick_region_scc`.\n-    pick_constraints_applied: Vec<AppliedPickConstraint>,\n+    /// `member_region_scc`.\n+    member_constraints_applied: Vec<AppliedMemberConstraint>,\n \n     /// Map closure bounds to a `Span` that should be used for error reporting.\n     closure_bounds_mapping:\n@@ -116,30 +116,30 @@ pub struct RegionInferenceContext<'tcx> {\n     universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n }\n \n-/// Each time that `apply_pick_constraint` is successful, it appends\n-/// one of these structs to the `pick_constraints_applied` field.\n+/// Each time that `apply_member_constraint` is successful, it appends\n+/// one of these structs to the `member_constraints_applied` field.\n /// This is used in error reporting to trace out what happened.\n ///\n-/// The way that `apply_pick_constraint` works is that it effectively\n+/// The way that `apply_member_constraint` works is that it effectively\n /// adds a new lower bound to the SCC it is analyzing: so you wind up\n /// with `'R: 'O` where `'R` is the pick-region and `'O` is the\n /// minimal viable option.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]\n-struct AppliedPickConstraint {\n-    /// The SCC that was affected. (The \"pick region\".)\n+struct AppliedMemberConstraint {\n+    /// The SCC that was affected. (The \"member region\".)\n     ///\n-    /// The vector if `AppliedPickConstraint` elements is kept sorted\n+    /// The vector if `AppliedMemberConstraint` elements is kept sorted\n     /// by this field.\n-    pick_region_scc: ConstraintSccIndex,\n+    member_region_scc: ConstraintSccIndex,\n \n-    /// The \"best option\" that `apply_pick_constraint` found -- this was\n-    /// added as an \"ad-hoc\" lower-bound to `pick_region_scc`.\n-    best_option: ty::RegionVid,\n+    /// The \"best option\" that `apply_member_constraint` found -- this was\n+    /// added as an \"ad-hoc\" lower-bound to `member_region_scc`.\n+    min_choice: ty::RegionVid,\n \n-    /// The \"pick constraint index\" -- we can find out details about\n+    /// The \"member constraint index\" -- we can find out details about\n     /// the constraint from\n-    /// `set.pick_constraints[pick_constraint_index]`.\n-    pick_constraint_index: NllPickConstraintIndex,\n+    /// `set.member_constraints[member_constraint_index]`.\n+    member_constraint_index: NllMemberConstraintIndex,\n }\n \n struct RegionDefinition<'tcx> {\n@@ -234,7 +234,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n         _body: &Body<'tcx>,\n         outlives_constraints: OutlivesConstraintSet,\n-        pick_constraints_in: PickConstraintSet<'tcx, RegionVid>,\n+        member_constraints_in: MemberConstraintSet<'tcx, RegionVid>,\n         closure_bounds_mapping: FxHashMap<\n             Location,\n             FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>,\n@@ -266,7 +266,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let scc_representatives = Self::compute_scc_representatives(&constraint_sccs, &definitions);\n \n-        let pick_constraints = Rc::new(pick_constraints_in.into_mapped(|r| constraint_sccs.scc(r)));\n+        let member_constraints =\n+            Rc::new(member_constraints_in.into_mapped(|r| constraint_sccs.scc(r)));\n \n         let mut result = Self {\n             definitions,\n@@ -275,8 +276,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             constraint_graph,\n             constraint_sccs,\n             rev_constraint_graph: None,\n-            pick_constraints,\n-            pick_constraints_applied: Vec::new(),\n+            member_constraints,\n+            member_constraints_applied: Vec::new(),\n             closure_bounds_mapping,\n             scc_universes,\n             scc_representatives,\n@@ -447,12 +448,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     /// Once region solving has completed, this function will return\n     /// the pick-constraints that were applied to the value of a given\n-    /// region `r`. See `AppliedPickConstraint`.\n-    fn applied_pick_constraints(&self, r: impl ToRegionVid) -> &[AppliedPickConstraint] {\n+    /// region `r`. See `AppliedMemberConstraint`.\n+    fn applied_member_constraints(&self, r: impl ToRegionVid) -> &[AppliedMemberConstraint] {\n         let scc = self.constraint_sccs.scc(r.to_region_vid());\n         binary_search_util::binary_search_slice(\n-            &self.pick_constraints_applied,\n-            |applied| applied.pick_region_scc,\n+            &self.member_constraints_applied,\n+            |applied| applied.member_region_scc,\n             &scc,\n         )\n     }\n@@ -511,7 +512,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             errors_buffer,\n         );\n \n-        self.check_pick_constraints(infcx, mir_def_id, errors_buffer);\n+        self.check_member_constraints(infcx, mir_def_id, errors_buffer);\n \n         let outlives_requirements = outlives_requirements.unwrap_or(vec![]);\n \n@@ -548,9 +549,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             self.propagate_constraint_sccs_if_new(scc_index, visited);\n         }\n \n-        // Sort the applied pick constraints so we can binary search\n+        // Sort the applied member constraints so we can binary search\n         // through them later.\n-        self.pick_constraints_applied.sort_by_key(|applied| applied.pick_region_scc);\n+        self.member_constraints_applied.sort_by_key(|applied| applied.member_region_scc);\n     }\n \n     /// Computes the value of the SCC `scc_a` if it has not already\n@@ -597,13 +598,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         }\n \n-        // Now take pick constraints into account\n-        let pick_constraints = self.pick_constraints.clone();\n-        for p_c_i in pick_constraints.indices(scc_a) {\n-            self.apply_pick_constraint(\n+        // Now take member constraints into account\n+        let member_constraints = self.member_constraints.clone();\n+        for m_c_i in member_constraints.indices(scc_a) {\n+            self.apply_member_constraint(\n                 scc_a,\n-                p_c_i,\n-                pick_constraints.option_regions(p_c_i),\n+                m_c_i,\n+                member_constraints.choice_regions(m_c_i),\n             );\n         }\n \n@@ -614,9 +615,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n     }\n \n-    /// Invoked for each `pick R0 from [R1..Rn]` constraint.\n+    /// Invoked for each `member R0 of [R1..Rn]` constraint.\n     ///\n-    /// `scc` is the SCC containing R0, and `option_regions` are the\n+    /// `scc` is the SCC containing R0, and `choice_regions` are the\n     /// `R1..Rn` regions -- they are always known to be universal\n     /// regions (and if that's not true, we just don't attempt to\n     /// enforce the constraint).\n@@ -625,34 +626,34 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// is considered a *lower bound*.  If possible, we will modify\n     /// the constraint to set it equal to one of the option regions.\n     /// If we make any changes, returns true, else false.\n-    fn apply_pick_constraint(\n+    fn apply_member_constraint(\n         &mut self,\n         scc: ConstraintSccIndex,\n-        pick_constraint_index: NllPickConstraintIndex,\n-        option_regions: &[ty::RegionVid],\n+        member_constraint_index: NllMemberConstraintIndex,\n+        choice_regions: &[ty::RegionVid],\n     ) -> bool {\n-        debug!(\"apply_pick_constraint(scc={:?}, option_regions={:#?})\", scc, option_regions,);\n+        debug!(\"apply_member_constraint(scc={:?}, choice_regions={:#?})\", scc, choice_regions,);\n \n         if let Some(uh_oh) =\n-            option_regions.iter().find(|&&r| !self.universal_regions.is_universal_region(r))\n+            choice_regions.iter().find(|&&r| !self.universal_regions.is_universal_region(r))\n         {\n             // FIXME(#61773): This case can only occur with\n             // `impl_trait_in_bindings`, I believe, and we are just\n             // opting not to handle it for now. See #61773 for\n             // details.\n             bug!(\n-                \"pick constraint for `{:?}` has an option region `{:?}` \\\n+                \"member constraint for `{:?}` has an option region `{:?}` \\\n                  that is not a universal region\",\n-                self.pick_constraints[pick_constraint_index].opaque_type_def_id,\n+                self.member_constraints[member_constraint_index].opaque_type_def_id,\n                 uh_oh,\n             );\n         }\n \n         // Create a mutable vector of the options. We'll try to winnow\n         // them down.\n-        let mut option_regions: Vec<ty::RegionVid> = option_regions.to_vec();\n+        let mut choice_regions: Vec<ty::RegionVid> = choice_regions.to_vec();\n \n-        // The 'pick-region' in a pick-constraint is part of the\n+        // The 'member region' in a member constraint is part of the\n         // hidden type, which must be in the root universe. Therefore,\n         // it cannot have any placeholders in its value.\n         assert!(self.scc_universes[scc] == ty::UniverseIndex::ROOT);\n@@ -665,35 +666,37 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         // The existing value for `scc` is a lower-bound. This will\n         // consist of some set {P} + {LB} of points {P} and\n-        // lower-bound free regions {LB}. As each option region O is a\n+        // lower-bound free regions {LB}. As each choice region O is a\n         // free region, it will outlive the points. But we can only\n         // consider the option O if O: LB.\n-        option_regions.retain(|&o_r| {\n+        choice_regions.retain(|&o_r| {\n             self.scc_values\n                 .universal_regions_outlived_by(scc)\n                 .all(|lb| self.universal_region_relations.outlives(o_r, lb))\n         });\n-        debug!(\"apply_pick_constraint: after lb, option_regions={:?}\", option_regions);\n+        debug!(\"apply_member_constraint: after lb, choice_regions={:?}\", choice_regions);\n \n-        // Now find all the *upper bounds* -- that is, each UB is a free\n-        // region that must outlive pick region R0 (`UB: R0`). Therefore,\n-        // we need only keep an option O if `UB: O` for all UB.\n-        if option_regions.len() > 1 {\n+        // Now find all the *upper bounds* -- that is, each UB is a\n+        // free region that must outlive the member region R0 (`UB:\n+        // R0`). Therefore, we need only keep an option O if `UB: O`\n+        // for all UB.\n+        if choice_regions.len() > 1 {\n             let universal_region_relations = self.universal_region_relations.clone();\n             for ub in self.upper_bounds(scc) {\n-                debug!(\"apply_pick_constraint: ub={:?}\", ub);\n-                option_regions.retain(|&o_r| universal_region_relations.outlives(ub, o_r));\n+                debug!(\"apply_member_constraint: ub={:?}\", ub);\n+                choice_regions.retain(|&o_r| universal_region_relations.outlives(ub, o_r));\n             }\n-            debug!(\"apply_pick_constraint: after ub, option_regions={:?}\", option_regions);\n+            debug!(\"apply_member_constraint: after ub, choice_regions={:?}\", choice_regions);\n         }\n \n         // If we ruled everything out, we're done.\n-        if option_regions.is_empty() {\n+        if choice_regions.is_empty() {\n             return false;\n         }\n \n-        // Otherwise, we need to find the minimum option, if any, and take that.\n-        debug!(\"apply_pick_constraint: option_regions remaining are {:#?}\", option_regions);\n+        // Otherwise, we need to find the minimum remaining choice, if\n+        // any, and take that.\n+        debug!(\"apply_member_constraint: choice_regions remaining are {:#?}\", choice_regions);\n         let min = |r1: ty::RegionVid, r2: ty::RegionVid| -> Option<ty::RegionVid> {\n             let r1_outlives_r2 = self.universal_region_relations.outlives(r1, r2);\n             let r2_outlives_r1 = self.universal_region_relations.outlives(r2, r1);\n@@ -707,35 +710,35 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 None\n             }\n         };\n-        let mut best_option = option_regions[0];\n-        for &other_option in &option_regions[1..] {\n+        let mut min_choice = choice_regions[0];\n+        for &other_option in &choice_regions[1..] {\n             debug!(\n-                \"apply_pick_constraint: best_option={:?} other_option={:?}\",\n-                best_option, other_option,\n+                \"apply_member_constraint: min_choice={:?} other_option={:?}\",\n+                min_choice, other_option,\n             );\n-            match min(best_option, other_option) {\n-                Some(m) => best_option = m,\n+            match min(min_choice, other_option) {\n+                Some(m) => min_choice = m,\n                 None => {\n                     debug!(\n-                        \"apply_pick_constraint: {:?} and {:?} are incomparable --> no best choice\",\n-                        best_option, other_option,\n+                        \"apply_member_constraint: {:?} and {:?} are incomparable; no min choice\",\n+                        min_choice, other_option,\n                     );\n                     return false;\n                 }\n             }\n         }\n \n-        let best_option_scc = self.constraint_sccs.scc(best_option);\n+        let min_choice_scc = self.constraint_sccs.scc(min_choice);\n         debug!(\n-            \"apply_pick_constraint: best_choice={:?} best_option_scc={:?}\",\n-            best_option,\n-            best_option_scc,\n+            \"apply_member_constraint: min_choice={:?} best_choice_scc={:?}\",\n+            min_choice,\n+            min_choice_scc,\n         );\n-        if self.scc_values.add_region(scc, best_option_scc) {\n-            self.pick_constraints_applied.push(AppliedPickConstraint {\n-                pick_region_scc: scc,\n-                best_option,\n-                pick_constraint_index,\n+        if self.scc_values.add_region(scc, min_choice_scc) {\n+            self.member_constraints_applied.push(AppliedMemberConstraint {\n+                member_region_scc: scc,\n+                min_choice,\n+                member_constraint_index,\n             });\n \n             true\n@@ -1542,42 +1545,42 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         diag.emit();\n     }\n \n-    fn check_pick_constraints(\n+    fn check_member_constraints(\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n         mir_def_id: DefId,\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) {\n-        let pick_constraints = self.pick_constraints.clone();\n-        for p_c_i in pick_constraints.all_indices() {\n-            debug!(\"check_pick_constraint(p_c_i={:?})\", p_c_i);\n-            let p_c = &pick_constraints[p_c_i];\n-            let pick_region_vid = p_c.pick_region_vid;\n+        let member_constraints = self.member_constraints.clone();\n+        for m_c_i in member_constraints.all_indices() {\n+            debug!(\"check_member_constraint(m_c_i={:?})\", m_c_i);\n+            let m_c = &member_constraints[m_c_i];\n+            let member_region_vid = m_c.member_region_vid;\n             debug!(\n-                \"check_pick_constraint: pick_region_vid={:?} with value {}\",\n-                pick_region_vid,\n-                self.region_value_str(pick_region_vid),\n+                \"check_member_constraint: member_region_vid={:?} with value {}\",\n+                member_region_vid,\n+                self.region_value_str(member_region_vid),\n             );\n-            let option_regions = pick_constraints.option_regions(p_c_i);\n-            debug!(\"check_pick_constraint: option_regions={:?}\", option_regions);\n+            let choice_regions = member_constraints.choice_regions(m_c_i);\n+            debug!(\"check_member_constraint: choice_regions={:?}\", choice_regions);\n \n             // did the pick-region wind up equal to any of the option regions?\n-            if let Some(o) = option_regions.iter().find(|&&o_r| {\n-                self.eval_equal(o_r, p_c.pick_region_vid)\n+            if let Some(o) = choice_regions.iter().find(|&&o_r| {\n+                self.eval_equal(o_r, m_c.member_region_vid)\n             }) {\n-                debug!(\"check_pick_constraint: evaluated as equal to {:?}\", o);\n+                debug!(\"check_member_constraint: evaluated as equal to {:?}\", o);\n                 continue;\n             }\n \n             // if not, report an error\n             let region_scope_tree = &infcx.tcx.region_scope_tree(mir_def_id);\n-            let pick_region = infcx.tcx.mk_region(ty::ReVar(pick_region_vid));\n+            let member_region = infcx.tcx.mk_region(ty::ReVar(member_region_vid));\n             opaque_types::unexpected_hidden_region_diagnostic(\n                 infcx.tcx,\n                 Some(region_scope_tree),\n-                p_c.opaque_type_def_id,\n-                p_c.hidden_ty,\n-                pick_region,\n+                m_c.opaque_type_def_id,\n+                m_c.hidden_ty,\n+                member_region,\n             )\n             .buffer(errors_buffer);\n         }"}, {"sha": "8de014522dea76ed302922d7f77baf84da1fc47e", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=eca55b58d6bd493e33f627a9d566695e4feab5e0", "patch": "@@ -53,20 +53,23 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n     pub(super) fn convert_all(&mut self, query_constraints: &QueryRegionConstraints<'tcx>) {\n         debug!(\"convert_all(query_constraints={:#?})\", query_constraints);\n \n-        let QueryRegionConstraints { outlives, pick_constraints } = query_constraints;\n+        let QueryRegionConstraints { outlives, member_constraints } = query_constraints;\n \n         // Annoying: to invoke `self.to_region_vid`, we need access to\n         // `self.constraints`, but we also want to be mutating\n-        // `self.pick_constraints`. For now, just swap out the value\n+        // `self.member_constraints`. For now, just swap out the value\n         // we want and replace at the end.\n-        let mut tmp = std::mem::replace(&mut self.constraints.pick_constraints, Default::default());\n-        for pick_constraint in pick_constraints {\n+        let mut tmp = std::mem::replace(\n+            &mut self.constraints.member_constraints,\n+            Default::default(),\n+        );\n+        for member_constraint in member_constraints {\n             tmp.push_constraint(\n-                pick_constraint,\n+                member_constraint,\n                 |r| self.to_region_vid(r),\n             );\n         }\n-        self.constraints.pick_constraints = tmp;\n+        self.constraints.member_constraints = tmp;\n \n         for query_constraint in outlives {\n             self.convert(query_constraint);"}, {"sha": "2cdd1363cdf963f392d188f6c4fc0d8241c5b160", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eca55b58d6bd493e33f627a9d566695e4feab5e0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=eca55b58d6bd493e33f627a9d566695e4feab5e0", "patch": "@@ -5,7 +5,7 @@\n use crate::borrow_check::borrow_set::BorrowSet;\n use crate::borrow_check::location::LocationTable;\n use crate::borrow_check::nll::constraints::{OutlivesConstraintSet, OutlivesConstraint};\n-use crate::borrow_check::nll::pick_constraints::PickConstraintSet;\n+use crate::borrow_check::nll::member_constraints::MemberConstraintSet;\n use crate::borrow_check::nll::facts::AllFacts;\n use crate::borrow_check::nll::region_infer::values::LivenessValues;\n use crate::borrow_check::nll::region_infer::values::PlaceholderIndex;\n@@ -129,7 +129,7 @@ pub(crate) fn type_check<'tcx>(\n         placeholder_index_to_region: IndexVec::default(),\n         liveness_constraints: LivenessValues::new(elements.clone()),\n         outlives_constraints: OutlivesConstraintSet::default(),\n-        pick_constraints: PickConstraintSet::default(),\n+        member_constraints: MemberConstraintSet::default(),\n         closure_bounds_mapping: Default::default(),\n         type_tests: Vec::default(),\n     };\n@@ -889,7 +889,7 @@ crate struct MirTypeckRegionConstraints<'tcx> {\n \n     crate outlives_constraints: OutlivesConstraintSet,\n \n-    crate pick_constraints: PickConstraintSet<'tcx, RegionVid>,\n+    crate member_constraints: MemberConstraintSet<'tcx, RegionVid>,\n \n     crate closure_bounds_mapping:\n         FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>>,\n@@ -2525,7 +2525,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 // constraints only come from `-> impl Trait` and\n                 // friends which don't appear (thus far...) in\n                 // closures.\n-                pick_constraints: vec![],\n+                member_constraints: vec![],\n             };\n \n             let bounds_mapping = closure_constraints"}]}