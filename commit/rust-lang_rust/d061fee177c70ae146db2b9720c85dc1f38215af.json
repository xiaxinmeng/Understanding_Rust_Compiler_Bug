{"sha": "d061fee177c70ae146db2b9720c85dc1f38215af", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwNjFmZWUxNzdjNzBhZTE0NmRiMmI5NzIwYzg1ZGMxZjM4MjE1YWY=", "commit": {"author": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2020-09-29T00:34:27Z"}, "committer": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2020-09-30T07:57:35Z"}, "message": "Stable hashing: add comments and tests concerning platform-independence\n\nSipHasher128 implements short_write in an endian-independent way, yet\nits write_xxx Hasher trait methods undo this endian-independence by byte\nswapping the integer inputs on big-endian hardware. StableHasher then\nadds endian-independence back by also byte-swapping on big-endian\nhardware prior to invoking SipHasher128.\n\nThis double swap may have the appearance of being a no-op, but is in\nfact by design. In particular, we really do want SipHasher128 to be\nplatform-dependent, in order to be consistent with the libstd SipHasher.\nTry to clarify this intent. Also, add and update a couple of unit tests.", "tree": {"sha": "8091284d09715d640701de43d3907f2546047f0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8091284d09715d640701de43d3907f2546047f0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d061fee177c70ae146db2b9720c85dc1f38215af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d061fee177c70ae146db2b9720c85dc1f38215af", "html_url": "https://github.com/rust-lang/rust/commit/d061fee177c70ae146db2b9720c85dc1f38215af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d061fee177c70ae146db2b9720c85dc1f38215af/comments", "author": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc2daaae610b5515438b551a2f3706196a997f35", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc2daaae610b5515438b551a2f3706196a997f35", "html_url": "https://github.com/rust-lang/rust/commit/fc2daaae610b5515438b551a2f3706196a997f35"}], "stats": {"total": 160, "additions": 142, "deletions": 18}, "files": [{"sha": "2c4eff618c6854c838ff0ae2a30a8dc9d3d25206", "filename": "compiler/rustc_data_structures/src/sip128.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d061fee177c70ae146db2b9720c85dc1f38215af/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d061fee177c70ae146db2b9720c85dc1f38215af/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs?ref=d061fee177c70ae146db2b9720c85dc1f38215af", "patch": "@@ -125,15 +125,28 @@ impl SipHasher128 {\n \n     // A specialized write function for values with size <= 8.\n     //\n-    // The hashing of multi-byte integers depends on endianness. E.g.:\n+    // The input must be zero-extended to 64-bits by the caller. This extension\n+    // isn't hashed, but the implementation requires it for correctness.\n+    //\n+    // This function, given the same integer size and value, has the same effect\n+    // on both little- and big-endian hardware. It operates on values without\n+    // depending on their sequence in memory, so is independent of endianness.\n+    //\n+    // However, we want SipHasher128 to be platform-dependent, in order to be\n+    // consistent with the platform-dependent SipHasher in libstd. In other\n+    // words, we want:\n+    //\n     // - little-endian: `write_u32(0xDDCCBBAA)` == `write([0xAA, 0xBB, 0xCC, 0xDD])`\n     // - big-endian:    `write_u32(0xDDCCBBAA)` == `write([0xDD, 0xCC, 0xBB, 0xAA])`\n     //\n-    // This function does the right thing for little-endian hardware. On\n-    // big-endian hardware `x` must be byte-swapped first to give the right\n-    // behaviour. After any byte-swapping, the input must be zero-extended to\n-    // 64-bits. The caller is responsible for the byte-swapping and\n-    // zero-extension.\n+    // Therefore, in order to produce endian-dependent results, SipHasher128's\n+    // `write_xxx` Hasher trait methods byte-swap `x` prior to zero-extending.\n+    //\n+    // If clients of SipHasher128 itself want platform-independent results, they\n+    // *also* must byte-swap integer inputs before invoking the `write_xxx`\n+    // methods on big-endian hardware (that is, two byte-swaps must occur--one\n+    // in the client, and one in SipHasher128). Additionally, they must extend\n+    // `usize` and `isize` types to 64 bits on 32-bit systems.\n     #[inline]\n     fn short_write<T>(&mut self, _x: T, x: u64) {\n         let size = mem::size_of::<T>();"}, {"sha": "2e2274a7b775e94df3ddbc81fd320cf6a2eddf3c", "filename": "compiler/rustc_data_structures/src/sip128/tests.rs", "status": "modified", "additions": 45, "deletions": 11, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d061fee177c70ae146db2b9720c85dc1f38215af/compiler%2Frustc_data_structures%2Fsrc%2Fsip128%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d061fee177c70ae146db2b9720c85dc1f38215af/compiler%2Frustc_data_structures%2Fsrc%2Fsip128%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsip128%2Ftests.rs?ref=d061fee177c70ae146db2b9720c85dc1f38215af", "patch": "@@ -1,7 +1,6 @@\n use super::*;\n \n use std::hash::{Hash, Hasher};\n-use std::{mem, slice};\n \n // Hash just the bytes of the slice, without length prefix\n struct Bytes<'a>(&'a [u8]);\n@@ -399,20 +398,55 @@ fn test_hash_no_concat_alias() {\n }\n \n #[test]\n-fn test_write_short_works() {\n-    let test_usize = 0xd0c0b0a0usize;\n+fn test_short_write_works() {\n+    let test_u8 = 0xFF_u8;\n+    let test_u16 = 0x1122_u16;\n+    let test_u32 = 0x22334455_u32;\n+    let test_u64 = 0x33445566_778899AA_u64;\n+    let test_u128 = 0x11223344_55667788_99AABBCC_DDEEFF77_u128;\n+    let test_usize = 0xD0C0B0A0_usize;\n+\n+    let test_i8 = -1_i8;\n+    let test_i16 = -2_i16;\n+    let test_i32 = -3_i32;\n+    let test_i64 = -4_i64;\n+    let test_i128 = -5_i128;\n+    let test_isize = -6_isize;\n+\n     let mut h1 = SipHasher128::new_with_keys(0, 0);\n-    h1.write_usize(test_usize);\n     h1.write(b\"bytes\");\n     h1.write(b\"string\");\n-    h1.write_u8(0xFFu8);\n-    h1.write_u8(0x01u8);\n+    h1.write_u8(test_u8);\n+    h1.write_u16(test_u16);\n+    h1.write_u32(test_u32);\n+    h1.write_u64(test_u64);\n+    h1.write_u128(test_u128);\n+    h1.write_usize(test_usize);\n+    h1.write_i8(test_i8);\n+    h1.write_i16(test_i16);\n+    h1.write_i32(test_i32);\n+    h1.write_i64(test_i64);\n+    h1.write_i128(test_i128);\n+    h1.write_isize(test_isize);\n+\n     let mut h2 = SipHasher128::new_with_keys(0, 0);\n-    h2.write(unsafe {\n-        slice::from_raw_parts(&test_usize as *const _ as *const u8, mem::size_of::<usize>())\n-    });\n     h2.write(b\"bytes\");\n     h2.write(b\"string\");\n-    h2.write(&[0xFFu8, 0x01u8]);\n-    assert_eq!(h1.finish128(), h2.finish128());\n+    h2.write(&test_u8.to_ne_bytes());\n+    h2.write(&test_u16.to_ne_bytes());\n+    h2.write(&test_u32.to_ne_bytes());\n+    h2.write(&test_u64.to_ne_bytes());\n+    h2.write(&test_u128.to_ne_bytes());\n+    h2.write(&test_usize.to_ne_bytes());\n+    h2.write(&test_i8.to_ne_bytes());\n+    h2.write(&test_i16.to_ne_bytes());\n+    h2.write(&test_i32.to_ne_bytes());\n+    h2.write(&test_i64.to_ne_bytes());\n+    h2.write(&test_i128.to_ne_bytes());\n+    h2.write(&test_isize.to_ne_bytes());\n+\n+    let h1_hash = h1.finish128();\n+    let h2_hash = h2.finish128();\n+\n+    assert_eq!(h1_hash, h2_hash);\n }"}, {"sha": "68875b3fbde9b39d265bd2cb3c2cc2e976feba0a", "filename": "compiler/rustc_data_structures/src/stable_hasher.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d061fee177c70ae146db2b9720c85dc1f38215af/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d061fee177c70ae146db2b9720c85dc1f38215af/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs?ref=d061fee177c70ae146db2b9720c85dc1f38215af", "patch": "@@ -5,6 +5,9 @@ use smallvec::SmallVec;\n use std::hash::{BuildHasher, Hash, Hasher};\n use std::mem;\n \n+#[cfg(test)]\n+mod tests;\n+\n /// When hashing something that ends up affecting properties like symbol names,\n /// we want these symbol names to be calculated independently of other factors\n /// like what architecture you're compiling *from*.\n@@ -129,7 +132,8 @@ impl Hasher for StableHasher {\n     fn write_isize(&mut self, i: isize) {\n         // Always treat isize as i64 so we get the same results on 32 and 64 bit\n         // platforms. This is important for symbol hashes when cross compiling,\n-        // for example.\n+        // for example. Sign extending here is preferable as it means that the\n+        // same negative number hashes the same on both 32 and 64 bit platforms.\n         self.state.write_i64((i as i64).to_le());\n     }\n }"}, {"sha": "cd6ff96a555f4785a4b47f53f4dff2fc20fd414c", "filename": "compiler/rustc_data_structures/src/stable_hasher/tests.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/d061fee177c70ae146db2b9720c85dc1f38215af/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d061fee177c70ae146db2b9720c85dc1f38215af/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs?ref=d061fee177c70ae146db2b9720c85dc1f38215af", "patch": "@@ -0,0 +1,73 @@\n+use super::*;\n+\n+// The tests below compare the computed hashes to particular expected values\n+// in order to test that we produce the same results on different platforms,\n+// regardless of endianness and `usize` and `isize` size differences (this\n+// of course assumes we run these tests on platforms that differ in those\n+// ways). The expected values depend on the hashing algorithm used, so they\n+// need to be updated whenever StableHasher changes its hashing algorithm.\n+\n+#[test]\n+fn test_hash_integers() {\n+    // Test that integers are handled consistently across platforms.\n+    let test_u8 = 0xAB_u8;\n+    let test_u16 = 0xFFEE_u16;\n+    let test_u32 = 0x445577AA_u32;\n+    let test_u64 = 0x01234567_13243546_u64;\n+    let test_u128 = 0x22114433_66557788_99AACCBB_EEDDFF77_u128;\n+    let test_usize = 0xD0C0B0A0_usize;\n+\n+    let test_i8 = -100_i8;\n+    let test_i16 = -200_i16;\n+    let test_i32 = -300_i32;\n+    let test_i64 = -400_i64;\n+    let test_i128 = -500_i128;\n+    let test_isize = -600_isize;\n+\n+    let mut h = StableHasher::new();\n+    test_u8.hash(&mut h);\n+    test_u16.hash(&mut h);\n+    test_u32.hash(&mut h);\n+    test_u64.hash(&mut h);\n+    test_u128.hash(&mut h);\n+    test_usize.hash(&mut h);\n+    test_i8.hash(&mut h);\n+    test_i16.hash(&mut h);\n+    test_i32.hash(&mut h);\n+    test_i64.hash(&mut h);\n+    test_i128.hash(&mut h);\n+    test_isize.hash(&mut h);\n+\n+    // This depends on the hashing algorithm. See note at top of file.\n+    let expected = (2736651863462566372, 8121090595289675650);\n+\n+    assert_eq!(h.finalize(), expected);\n+}\n+\n+#[test]\n+fn test_hash_usize() {\n+    // Test that usize specifically is handled consistently across platforms.\n+    let test_usize = 0xABCDEF01_usize;\n+\n+    let mut h = StableHasher::new();\n+    test_usize.hash(&mut h);\n+\n+    // This depends on the hashing algorithm. See note at top of file.\n+    let expected = (5798740672699530587, 11186240177685111648);\n+\n+    assert_eq!(h.finalize(), expected);\n+}\n+\n+#[test]\n+fn test_hash_isize() {\n+    // Test that isize specifically is handled consistently across platforms.\n+    let test_isize = -7_isize;\n+\n+    let mut h = StableHasher::new();\n+    test_isize.hash(&mut h);\n+\n+    // This depends on the hashing algorithm. See note at top of file.\n+    let expected = (14721296605626097289, 11385941877786388409);\n+\n+    assert_eq!(h.finalize(), expected);\n+}"}]}