{"sha": "c0abe6999318a508a725eea7a01c6f3b5244c944", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwYWJlNjk5OTMxOGE1MDhhNzI1ZWVhN2EwMWM2ZjNiNTI0NGM5NDQ=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-24T20:45:49Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-24T21:27:34Z"}, "message": "task.rs remove old builder interface", "tree": {"sha": "d7874193251c4eefe606a339362ff9d205f7a326", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7874193251c4eefe606a339362ff9d205f7a326"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0abe6999318a508a725eea7a01c6f3b5244c944", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0abe6999318a508a725eea7a01c6f3b5244c944", "html_url": "https://github.com/rust-lang/rust/commit/c0abe6999318a508a725eea7a01c6f3b5244c944", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0abe6999318a508a725eea7a01c6f3b5244c944/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be3a71a1aa36173ce2cd521f811d8010029aa46f", "url": "https://api.github.com/repos/rust-lang/rust/commits/be3a71a1aa36173ce2cd521f811d8010029aa46f", "html_url": "https://github.com/rust-lang/rust/commit/be3a71a1aa36173ce2cd521f811d8010029aa46f"}], "stats": {"total": 250, "additions": 59, "deletions": 191}, "files": [{"sha": "4ab4a7ff7ea7d88db0d4e07ea711e6146e2aec62", "filename": "src/libcore/task.rs", "status": "modified", "additions": 59, "deletions": 191, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/c0abe6999318a508a725eea7a01c6f3b5244c944/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0abe6999318a508a725eea7a01c6f3b5244c944/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=c0abe6999318a508a725eea7a01c6f3b5244c944", "patch": "@@ -34,7 +34,6 @@ export notification;\n export sched_mode;\n export sched_opts;\n export task_opts;\n-export builder;\n export task_builder;\n \n export default_task_opts;\n@@ -184,14 +183,6 @@ type task_opts = {\n // when you try to reuse the builder to spawn a new task. We'll just\n // sidestep that whole issue by making builders uncopyable and making\n // the run function move them in.\n-enum builder {\n-  builder_({\n-        mut opts: task_opts,\n-        mut gen_body: fn@(+fn~()) -> fn~(),\n-        can_not_copy: option<comm::port<()>>\n-    })\n-}\n-\n class dummy { let x: (); new() { self.x = (); } drop { } }\n \n // FIXME (#2585): Replace the 'consumed' bit with move mode on self\n@@ -262,8 +253,26 @@ impl task_builder for task_builder {\n         })\n     }\n \n-    /// Configure a future result notification for this task.\n+    /**\n+     * Get a future representing the exit status of the task.\n+     *\n+     * Taking the value of the future will block until the child task\n+     * terminates. The future-receiving callback specified will be called\n+     * *before* the task is spawned; as such, do not invoke .get() within the\n+     * closure; rather, store it in an outer variable/list for later use.\n+     *\n+     * Note that the future returning by this function is only useful for\n+     * obtaining the value of the next task to be spawning with the\n+     * builder. If additional tasks are spawned with the same builder\n+     * then a new result future must be obtained prior to spawning each\n+     * task.\n+     */\n     fn future_result(blk: fn(-future::future<task_result>)) -> task_builder {\n+        // FIXME (#1087, #1857): Once linked failure and notification are\n+        // handled in the library, I can imagine implementing this by just\n+        // registering an arbitrary number of task::on_exit handlers and\n+        // sending out messages.\n+\n         // Construct the future and give it to the caller.\n         let po = comm::port::<notification>();\n         let ch = comm::chan(po);\n@@ -290,6 +299,19 @@ impl task_builder for task_builder {\n             with *self.consume()\n         })\n     }\n+\n+    /**\n+     * Add a wrapper to the body of the spawned task.\n+     *\n+     * Before the task is spawned it is passed through a 'body generator'\n+     * function that may perform local setup operations as well as wrap\n+     * the task body in remote setup operations. With this the behavior\n+     * of tasks can be extended in simple ways.\n+     *\n+     * This function augments the current body generator with a new body\n+     * generator by applying the task body which results from the\n+     * existing body generator to the new body generator.\n+     */\n     fn add_wrapper(wrapper: fn@(+fn~()) -> fn~()) -> task_builder {\n         let prev_gen_body = self.gen_body;\n         task_builder({\n@@ -299,7 +321,18 @@ impl task_builder for task_builder {\n         })\n     }\n \n-    /// Run the task.\n+    /**\n+     * Creates and exucutes a new child task\n+     *\n+     * Sets up a new task with its own call stack and schedules it to run\n+     * the provided unique closure. The task has the properties and behavior\n+     * specified by the task_builder.\n+     *\n+     * # Failure\n+     *\n+     * When spawning into a new scheduler, the number of threads requested\n+     * must be greater than zero.\n+     */\n     fn spawn(+f: fn~()) {\n         let x = self.consume();\n         spawn_raw(x.opts, x.gen_body(f));\n@@ -313,7 +346,18 @@ impl task_builder for task_builder {\n             f(option::unwrap(my_arg))\n         }\n     }\n-    /// Runs a task with a listening port, returning the associated channel.\n+\n+    /**\n+     * Runs a new task while providing a channel from the parent to the child\n+     *\n+     * Sets up a communication channel from the current task to the new\n+     * child task, passes the port to child's body, and returns a channel\n+     * linked to the port to the parent.\n+     *\n+     * This encapsulates some boilerplate handshaking logic that would\n+     * otherwise be required to establish communication from the parent\n+     * to the child.\n+     */\n     fn spawn_listener<A: send>(+f: fn~(comm::port<A>)) -> comm::chan<A> {\n         let setup_po = comm::port();\n         let setup_ch = comm::chan(setup_po);\n@@ -346,182 +390,6 @@ fn default_task_opts() -> task_opts {\n     }\n }\n \n-fn builder() -> builder {\n-    //! Construct a builder\n-\n-    let body_identity = fn@(+body: fn~()) -> fn~() { body };\n-\n-    builder_({\n-        mut opts: default_task_opts(),\n-        mut gen_body: body_identity,\n-        can_not_copy: none\n-    })\n-}\n-\n-fn get_opts(builder: builder) -> task_opts {\n-    //! Get the task_opts associated with a builder\n-\n-    builder.opts\n-}\n-\n-fn set_opts(builder: builder, opts: task_opts) {\n-    /*!\n-     * Set the task_opts associated with a builder\n-     *\n-     * To update a single option use a pattern like the following:\n-     *\n-     *     set_opts(builder, {\n-     *         linked: false\n-     *         with get_opts(builder)\n-     *     });\n-     */\n-\n-    builder.opts = opts;\n-}\n-\n-fn set_sched_mode(builder: builder, mode: sched_mode) {\n-    set_opts(builder, {\n-        sched: some({\n-            mode: mode,\n-            foreign_stack_size: none\n-        })\n-        with get_opts(builder)\n-    });\n-}\n-\n-fn add_wrapper(builder: builder, gen_body: fn@(+fn~()) -> fn~()) {\n-    /*!\n-     * Add a wrapper to the body of the spawned task.\n-     *\n-     * Before the task is spawned it is passed through a 'body generator'\n-     * function that may perform local setup operations as well as wrap\n-     * the task body in remote setup operations. With this the behavior\n-     * of tasks can be extended in simple ways.\n-     *\n-     * This function augments the current body generator with a new body\n-     * generator by applying the task body which results from the\n-     * existing body generator to the new body generator.\n-     */\n-\n-    let prev_gen_body = builder.gen_body;\n-    builder.gen_body = fn@(+body: fn~()) -> fn~() {\n-        gen_body(prev_gen_body(body))\n-    };\n-}\n-\n-fn run(-builder: builder, +f: fn~()) {\n-    /*!\n-     * Creates and exucutes a new child task\n-     *\n-     * Sets up a new task with its own call stack and schedules it to run\n-     * the provided unique closure. The task has the properties and behavior\n-     * specified by `builder`.\n-     *\n-     * # Failure\n-     *\n-     * When spawning into a new scheduler, the number of threads requested\n-     * must be greater than zero.\n-     */\n-\n-    let body = builder.gen_body(f);\n-    spawn_raw(builder.opts, body);\n-}\n-\n-\n-/* Builder convenience functions */\n-\n-fn future_result(builder: builder) -> future::future<task_result> {\n-    /*!\n-     * Get a future representing the exit status of the task.\n-     *\n-     * Taking the value of the future will block until the child task\n-     * terminates.\n-     *\n-     * Note that the future returning by this function is only useful for\n-     * obtaining the value of the next task to be spawning with the\n-     * builder. If additional tasks are spawned with the same builder\n-     * then a new result future must be obtained prior to spawning each\n-     * task.\n-     */\n-\n-    // FIXME (#1087, #1857): Once linked failure and notification are\n-    // handled in the library, I can imagine implementing this by just\n-    // registering an arbitrary number of task::on_exit handlers and\n-    // sending out messages.\n-\n-    let po = comm::port();\n-    let ch = comm::chan(po);\n-\n-    set_opts(builder, {\n-        notify_chan: some(ch)\n-        with get_opts(builder)\n-    });\n-\n-    do future::from_fn {\n-        alt comm::recv(po) {\n-          exit(_, result) { result }\n-        }\n-    }\n-}\n-\n-fn unsupervise(builder: builder) {\n-    //! Configures the new task to not propagate failure to its parent\n-\n-    set_opts(builder, {\n-        linked: false\n-        with get_opts(builder)\n-    });\n-}\n-\n-fn run_with<A:send>(-builder: builder,\n-                    +arg: A,\n-                    +f: fn~(+A)) {\n-\n-    /*!\n-     * Runs a task, while transfering ownership of one argument to the\n-     * child.\n-     *\n-     * This is useful for transfering ownership of noncopyables to\n-     * another task.\n-     *\n-     */\n-\n-    let arg = ~mut some(arg);\n-    do run(builder) {\n-        let mut my_arg = none;\n-        my_arg <-> *arg;\n-        f(option::unwrap(my_arg))\n-    }\n-}\n-\n-fn run_listener<A:send>(-builder: builder,\n-                        +f: fn~(comm::port<A>)) -> comm::chan<A> {\n-    /*!\n-     * Runs a new task while providing a channel from the parent to the child\n-     *\n-     * Sets up a communication channel from the current task to the new\n-     * child task, passes the port to child's body, and returns a channel\n-     * linked to the port to the parent.\n-     *\n-     * This encapsulates some boilerplate handshaking logic that would\n-     * otherwise be required to establish communication from the parent\n-     * to the child.\n-     */\n-\n-    let setup_po = comm::port();\n-    let setup_ch = comm::chan(setup_po);\n-\n-    do run(builder) {\n-        let po = comm::port();\n-        let mut ch = comm::chan(po);\n-        comm::send(setup_ch, ch);\n-        f(po);\n-    }\n-\n-    comm::recv(setup_po)\n-}\n-\n-\n /* Spawn convenience functions */\n \n fn spawn(+f: fn~()) {\n@@ -531,7 +399,7 @@ fn spawn(+f: fn~()) {\n      * Sets up a new task with its own call stack and schedules it to run\n      * the provided unique closure.\n      *\n-     * This function is equivalent to `run(new_builder(), f)`.\n+     * This function is equivalent to `task().spawn(f)`.\n      */\n \n     task().spawn(f)\n@@ -563,7 +431,7 @@ fn spawn_with<A:send>(+arg: A, +f: fn~(+A)) {\n      * This is useful for transfering ownership of noncopyables to\n      * another task.\n      *\n-     * This function is equivalent to `run_with(builder(), arg, f)`.\n+     * This function is equivalent to `task().spawn_with(arg, f)`.\n      */\n \n     task().spawn_with(arg, f)\n@@ -592,7 +460,7 @@ fn spawn_listener<A:send>(+f: fn~(comm::port<A>)) -> comm::chan<A> {\n      *     };\n      *     // Likewise, the parent has both a 'po' and 'ch'\n      *\n-     * This function is equivalent to `run_listener(builder(), f)`.\n+     * This function is equivalent to `task().spawn_listener(f)`.\n      */\n \n     task().spawn_listener(f)"}]}