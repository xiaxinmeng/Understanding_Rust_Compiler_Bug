{"sha": "2aec4e882c6136ff34d931043fb16bd35abedc3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhZWM0ZTg4MmM2MTM2ZmYzNGQ5MzEwNDNmYjE2YmQzNWFiZWRjM2U=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2018-07-26T15:18:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-07-26T15:18:30Z"}, "message": "Rollup merge of #52649 - estebank:fmt-span, r=oli-obk\n\nPoint spans to inner elements of format strings\n\n- Point at missing positional specifiers in string literal\n```\nerror: invalid reference to positional arguments 3, 4 and 5 (there are 3 arguments)\n  --> $DIR/ifmt-bad-arg.rs:34:38\n   |\nLL |     format!(\"{name} {value} {} {} {} {} {} {}\", 0, name=1, value=2);\n   |                                      ^^ ^^ ^^\n   |\n   = note: positional arguments are zero-based\n```\n\n- Point at named formatting specifier in string literal\n```\nerror: there is no argument named `foo`\n  --> $DIR/ifmt-bad-arg.rs:37:17\n   |\nLL |     format!(\"{} {foo} {} {bar} {}\", 1, 2, 3);\n   |                 ^^^^^\n```\n\n- Update label for formatting string in \"multiple unused formatting arguments\" to be more correct\n```\nerror: multiple unused formatting arguments\n  --> $DIR/ifmt-bad-arg.rs:42:17\n   |\nLL |     format!(\"\", 1, 2);               //~ ERROR: multiple unused formatting arguments\n   |             --  ^  ^\n   |             |\n   |             multiple missing formatting specifiers\n```\n\n- When using `printf` string formatting, provide a structured suggestion instead of a note\n```\nerror: multiple unused formatting arguments\n  --> $DIR/format-foreign.rs:12:30\n   |\nLL |     println!(\"%.*3$s %s!/n\", \"Hello,\", \"World\", 4); //~ ERROR multiple unused formatting arguments\n   |              --------------  ^^^^^^^^  ^^^^^^^  ^\n   |              |\n   |              multiple missing formatting specifiers\n   |\n   = note: printf formatting not supported; see the documentation for `std::fmt`\nhelp: format specifiers in Rust are written using `{}`\n   |\nLL |     println!(\"{:.2$} {}!/n\", \"Hello,\", \"World\", 4); //~ ERROR multiple unused formatting arguments\n   |               ^^^^^^ ^^\n```", "tree": {"sha": "e0f5623aadc727d05f8e28de9250be4389d84efe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0f5623aadc727d05f8e28de9250be4389d84efe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2aec4e882c6136ff34d931043fb16bd35abedc3e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbWeZGCRBK7hj4Ov3rIwAAdHIIAIrfpGu0qrNPUMTdk2pMNNx+\n0yuFFMaOpuwr+nkHi7UdpJuXwKOXUorgcpPN3bKfHsuuh69gK9UaAgZSXhcVm8of\nrylEs/7ASyd6AmBJ1lKFVJ6hHHuKCCMiaqogGA2RGjBE8nPUSWXSfvF+y7aRyrLM\n35mzrbGCljHsZk+7HG9qBDabqjUqXhP8fDRMyS1mr9N8XA6aAqTnWWOsxy/8th5q\nodzPPNoYbgDmMGwoFeofOqrWNLQq4XDeU7ti35w2W0WS8F4tugu9yc8A2MTcubIA\nbVTn1YTnZqHST/G5s9m5G4s+YDRbkyw+SObYPS4tezm/m9zhIgtY3lFyFf/Ex6w=\n=Jt2h\n-----END PGP SIGNATURE-----\n", "payload": "tree e0f5623aadc727d05f8e28de9250be4389d84efe\nparent 662fb069fd45d44c5828c335690598d712226325\nparent 9a893cc2b82ac6259aead1319758404b80b8a959\nauthor Mark Rousskov <mark.simulacrum@gmail.com> 1532618310 -0600\ncommitter GitHub <noreply@github.com> 1532618310 -0600\n\nRollup merge of #52649 - estebank:fmt-span, r=oli-obk\n\nPoint spans to inner elements of format strings\n\n- Point at missing positional specifiers in string literal\n```\nerror: invalid reference to positional arguments 3, 4 and 5 (there are 3 arguments)\n  --> $DIR/ifmt-bad-arg.rs:34:38\n   |\nLL |     format!(\"{name} {value} {} {} {} {} {} {}\", 0, name=1, value=2);\n   |                                      ^^ ^^ ^^\n   |\n   = note: positional arguments are zero-based\n```\n\n- Point at named formatting specifier in string literal\n```\nerror: there is no argument named `foo`\n  --> $DIR/ifmt-bad-arg.rs:37:17\n   |\nLL |     format!(\"{} {foo} {} {bar} {}\", 1, 2, 3);\n   |                 ^^^^^\n```\n\n- Update label for formatting string in \"multiple unused formatting arguments\" to be more correct\n```\nerror: multiple unused formatting arguments\n  --> $DIR/ifmt-bad-arg.rs:42:17\n   |\nLL |     format!(\"\", 1, 2);               //~ ERROR: multiple unused formatting arguments\n   |             --  ^  ^\n   |             |\n   |             multiple missing formatting specifiers\n```\n\n- When using `printf` string formatting, provide a structured suggestion instead of a note\n```\nerror: multiple unused formatting arguments\n  --> $DIR/format-foreign.rs:12:30\n   |\nLL |     println!(\"%.*3$s %s!/n\", \"Hello,\", \"World\", 4); //~ ERROR multiple unused formatting arguments\n   |              --------------  ^^^^^^^^  ^^^^^^^  ^\n   |              |\n   |              multiple missing formatting specifiers\n   |\n   = note: printf formatting not supported; see the documentation for `std::fmt`\nhelp: format specifiers in Rust are written using `{}`\n   |\nLL |     println!(\"{:.2$} {}!/n\", \"Hello,\", \"World\", 4); //~ ERROR multiple unused formatting arguments\n   |               ^^^^^^ ^^\n```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2aec4e882c6136ff34d931043fb16bd35abedc3e", "html_url": "https://github.com/rust-lang/rust/commit/2aec4e882c6136ff34d931043fb16bd35abedc3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2aec4e882c6136ff34d931043fb16bd35abedc3e/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "662fb069fd45d44c5828c335690598d712226325", "url": "https://api.github.com/repos/rust-lang/rust/commits/662fb069fd45d44c5828c335690598d712226325", "html_url": "https://github.com/rust-lang/rust/commit/662fb069fd45d44c5828c335690598d712226325"}, {"sha": "9a893cc2b82ac6259aead1319758404b80b8a959", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a893cc2b82ac6259aead1319758404b80b8a959", "html_url": "https://github.com/rust-lang/rust/commit/9a893cc2b82ac6259aead1319758404b80b8a959"}], "stats": {"total": 610, "additions": 494, "deletions": 116}, "files": [{"sha": "30a3bbdc58e988b4c85326c774f318aa1428b39e", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2aec4e882c6136ff34d931043fb16bd35abedc3e/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aec4e882c6136ff34d931043fb16bd35abedc3e/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=2aec4e882c6136ff34d931043fb16bd35abedc3e", "patch": "@@ -154,6 +154,8 @@ pub struct Parser<'a> {\n     style: Option<usize>,\n     /// How many newlines have been seen in the string so far, to adjust the error spans\n     seen_newlines: usize,\n+    /// Start and end byte offset of every successfuly parsed argument\n+    pub arg_places: Vec<(usize, usize)>,\n }\n \n impl<'a> Iterator for Parser<'a> {\n@@ -168,9 +170,13 @@ impl<'a> Iterator for Parser<'a> {\n                     if self.consume('{') {\n                         Some(String(self.string(pos + 1)))\n                     } else {\n-                        let ret = Some(NextArgument(self.argument()));\n-                        self.must_consume('}');\n-                        ret\n+                        let mut arg = self.argument();\n+                        if let Some(arg_pos) = self.must_consume('}').map(|end| {\n+                            (pos + raw + 1, end + raw + 2)\n+                        }) {\n+                            self.arg_places.push(arg_pos);\n+                        }\n+                        Some(NextArgument(arg))\n                     }\n                 }\n                 '}' => {\n@@ -211,6 +217,7 @@ impl<'a> Parser<'a> {\n             curarg: 0,\n             style,\n             seen_newlines: 0,\n+            arg_places: vec![],\n         }\n     }\n \n@@ -271,20 +278,22 @@ impl<'a> Parser<'a> {\n \n     /// Forces consumption of the specified character. If the character is not\n     /// found, an error is emitted.\n-    fn must_consume(&mut self, c: char) {\n+    fn must_consume(&mut self, c: char) -> Option<usize> {\n         self.ws();\n         let raw = self.style.unwrap_or(0);\n \n         let padding = raw + self.seen_newlines;\n         if let Some(&(pos, maybe)) = self.cur.peek() {\n             if c == maybe {\n                 self.cur.next();\n+                Some(pos)\n             } else {\n                 let pos = pos + padding + 1;\n                 self.err(format!(\"expected `{:?}`, found `{:?}`\", c, maybe),\n                          format!(\"expected `{}`\", c),\n                          pos,\n                          pos);\n+                None\n             }\n         } else {\n             let msg = format!(\"expected `{:?}` but string was terminated\", c);\n@@ -302,6 +311,7 @@ impl<'a> Parser<'a> {\n             } else {\n                 self.err(msg, format!(\"expected `{:?}`\", c), pos, pos);\n             }\n+            None\n         }\n     }\n "}, {"sha": "98de3d80b1e1f354ab2827b19b6a1f168637e2a5", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 148, "deletions": 71, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/2aec4e882c6136ff34d931043fb16bd35abedc3e/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aec4e882c6136ff34d931043fb16bd35abedc3e/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=2aec4e882c6136ff34d931043fb16bd35abedc3e", "patch": "@@ -14,18 +14,18 @@ use self::Position::*;\n use fmt_macros as parse;\n \n use syntax::ast;\n-use syntax::ext::base::*;\n use syntax::ext::base;\n+use syntax::ext::base::*;\n use syntax::ext::build::AstBuilder;\n use syntax::feature_gate;\n use syntax::parse::token;\n use syntax::ptr::P;\n use syntax::symbol::Symbol;\n-use syntax_pos::{Span, DUMMY_SP};\n use syntax::tokenstream;\n+use syntax_pos::{MultiSpan, Span, DUMMY_SP};\n \n-use std::collections::{HashMap, HashSet};\n use std::collections::hash_map::Entry;\n+use std::collections::{HashMap, HashSet};\n \n #[derive(PartialEq)]\n enum ArgumentType {\n@@ -111,8 +111,14 @@ struct Context<'a, 'b: 'a> {\n     /// still existed in this phase of processing.\n     /// Used only for `all_pieces_simple` tracking in `build_piece`.\n     curarg: usize,\n-    /// Keep track of invalid references to positional arguments\n-    invalid_refs: Vec<usize>,\n+    /// Current piece being evaluated, used for error reporting.\n+    curpiece: usize,\n+    /// Keep track of invalid references to positional arguments.\n+    invalid_refs: Vec<(usize, usize)>,\n+    /// Spans of all the formatting arguments, in order.\n+    arg_spans: Vec<Span>,\n+    /// Wether this formatting string is a literal or it comes from a macro.\n+    is_literal: bool,\n }\n \n /// Parses the arguments from the given list of tokens, returning None\n@@ -155,15 +161,20 @@ fn parse_args(ecx: &mut ExtCtxt,\n                     i\n                 }\n                 _ if named => {\n-                    ecx.span_err(p.span,\n-                                 \"expected ident, positional arguments \\\n-                                 cannot follow named arguments\");\n+                    ecx.span_err(\n+                        p.span,\n+                        \"expected ident, positional arguments cannot follow named arguments\",\n+                    );\n                     return None;\n                 }\n                 _ => {\n-                    ecx.span_err(p.span,\n-                                 &format!(\"expected ident for named argument, found `{}`\",\n-                                          p.this_token_to_string()));\n+                    ecx.span_err(\n+                        p.span,\n+                        &format!(\n+                            \"expected ident for named argument, found `{}`\",\n+                            p.this_token_to_string()\n+                        ),\n+                    );\n                     return None;\n                 }\n             };\n@@ -235,6 +246,7 @@ impl<'a, 'b> Context<'a, 'b> {\n \n                 let ty = Placeholder(arg.format.ty.to_string());\n                 self.verify_arg_type(pos, ty);\n+                self.curpiece += 1;\n             }\n         }\n     }\n@@ -266,29 +278,59 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// format string.\n     fn report_invalid_references(&self, numbered_position_args: bool) {\n         let mut e;\n-        let mut refs: Vec<String> = self.invalid_refs\n-                                        .iter()\n-                                        .map(|r| r.to_string())\n-                                        .collect();\n+        let sp = if self.is_literal {\n+            MultiSpan::from_spans(self.arg_spans.clone())\n+        } else {\n+            MultiSpan::from_span(self.fmtsp)\n+        };\n+        let mut refs: Vec<_> = self\n+            .invalid_refs\n+            .iter()\n+            .map(|(r, pos)| (r.to_string(), self.arg_spans.get(*pos)))\n+            .collect();\n \n         if self.names.is_empty() && !numbered_position_args {\n-            e = self.ecx.mut_span_err(self.fmtsp,\n-                &format!(\"{} positional argument{} in format string, but {}\",\n+            e = self.ecx.mut_span_err(\n+                sp,\n+                &format!(\n+                    \"{} positional argument{} in format string, but {}\",\n                          self.pieces.len(),\n                          if self.pieces.len() > 1 { \"s\" } else { \"\" },\n-                         self.describe_num_args()));\n+                    self.describe_num_args()\n+                ),\n+            );\n         } else {\n-            let arg_list = match refs.len() {\n-                1 => format!(\"argument {}\", refs.pop().unwrap()),\n-                _ => format!(\"arguments {head} and {tail}\",\n-                             tail=refs.pop().unwrap(),\n-                             head=refs.join(\", \"))\n+            let (arg_list, mut sp) = match refs.len() {\n+                1 => {\n+                    let (reg, pos) = refs.pop().unwrap();\n+                    (\n+                        format!(\"argument {}\", reg),\n+                        MultiSpan::from_span(*pos.unwrap_or(&self.fmtsp)),\n+                    )\n+                }\n+                _ => {\n+                    let pos =\n+                        MultiSpan::from_spans(refs.iter().map(|(_, p)| *p.unwrap()).collect());\n+                    let mut refs: Vec<String> = refs.iter().map(|(s, _)| s.to_owned()).collect();\n+                    let reg = refs.pop().unwrap();\n+                    (\n+                        format!(\n+                            \"arguments {head} and {tail}\",\n+                            tail = reg,\n+                            head = refs.join(\", \")\n+                        ),\n+                        pos,\n+                    )\n+                }\n             };\n+            if !self.is_literal {\n+                sp = MultiSpan::from_span(self.fmtsp);\n+            }\n \n-            e = self.ecx.mut_span_err(self.fmtsp,\n+            e = self.ecx.mut_span_err(sp,\n                 &format!(\"invalid reference to positional {} ({})\",\n-                        arg_list,\n-                        self.describe_num_args()));\n+                         arg_list,\n+                         self.describe_num_args()));\n             e.note(\"positional arguments are zero-based\");\n         };\n \n@@ -301,7 +343,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         match arg {\n             Exact(arg) => {\n                 if self.args.len() <= arg {\n-                    self.invalid_refs.push(arg);\n+                    self.invalid_refs.push((arg, self.curpiece));\n                     return;\n                 }\n                 match ty {\n@@ -337,7 +379,13 @@ impl<'a, 'b> Context<'a, 'b> {\n                     Some(e) => *e,\n                     None => {\n                         let msg = format!(\"there is no argument named `{}`\", name);\n-                        self.ecx.span_err(self.fmtsp, &msg[..]);\n+                        let sp = if self.is_literal {\n+                            *self.arg_spans.get(self.curpiece).unwrap_or(&self.fmtsp)\n+                        } else {\n+                            self.fmtsp\n+                        };\n+                        let mut err = self.ecx.struct_span_err(sp, &msg[..]);\n+                        err.emit();\n                         return;\n                     }\n                 };\n@@ -505,33 +553,27 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let prec = self.build_count(arg.format.precision);\n                 let width = self.build_count(arg.format.width);\n                 let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"FormatSpec\"));\n-                let fmt =\n-                    self.ecx.expr_struct(sp,\n+                let fmt = self.ecx.expr_struct(\n+                    sp,\n                                          path,\n-                                         vec![self.ecx\n-                                                  .field_imm(sp, self.ecx.ident_of(\"fill\"), fill),\n-                                              self.ecx.field_imm(sp,\n-                                                                 self.ecx.ident_of(\"align\"),\n-                                                                 align),\n-                                              self.ecx.field_imm(sp,\n-                                                                 self.ecx.ident_of(\"flags\"),\n-                                                                 flags),\n-                                              self.ecx.field_imm(sp,\n-                                                                 self.ecx.ident_of(\"precision\"),\n-                                                                 prec),\n-                                              self.ecx.field_imm(sp,\n-                                                                 self.ecx.ident_of(\"width\"),\n-                                                                 width)]);\n+                    vec![\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"fill\"), fill),\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"align\"), align),\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"flags\"), flags),\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"precision\"), prec),\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"width\"), width),\n+                    ],\n+                );\n \n                 let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"Argument\"));\n-                Some(self.ecx.expr_struct(sp,\n+                Some(self.ecx.expr_struct(\n+                    sp,\n                                           path,\n-                                          vec![self.ecx.field_imm(sp,\n-                                                                  self.ecx.ident_of(\"position\"),\n-                                                                  pos),\n-                                               self.ecx.field_imm(sp,\n-                                                                  self.ecx.ident_of(\"format\"),\n-                                                                  fmt)]))\n+                    vec![\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"position\"), pos),\n+                        self.ecx.field_imm(sp, self.ecx.ident_of(\"format\"), fmt),\n+                    ],\n+                ))\n             }\n         }\n     }\n@@ -544,9 +586,9 @@ impl<'a, 'b> Context<'a, 'b> {\n         let mut pats = Vec::new();\n         let mut heads = Vec::new();\n \n-        let names_pos: Vec<_> = (0..self.args.len()).map(|i| {\n-            self.ecx.ident_of(&format!(\"arg{}\", i)).gensym()\n-        }).collect();\n+        let names_pos: Vec<_> = (0..self.args.len())\n+            .map(|i| self.ecx.ident_of(&format!(\"arg{}\", i)).gensym())\n+            .collect();\n \n         // First, build up the static array which will become our precompiled\n         // format \"string\"\n@@ -690,10 +732,11 @@ pub fn expand_format_args<'cx>(ecx: &'cx mut ExtCtxt,\n     }\n }\n \n-pub fn expand_format_args_nl<'cx>(ecx: &'cx mut ExtCtxt,\n-                                  mut sp: Span,\n-                                  tts: &[tokenstream::TokenTree])\n-                                  -> Box<dyn base::MacResult + 'cx> {\n+pub fn expand_format_args_nl<'cx>(\n+    ecx: &'cx mut ExtCtxt,\n+    mut sp: Span,\n+    tts: &[tokenstream::TokenTree],\n+) -> Box<dyn base::MacResult + 'cx> {\n     //if !ecx.ecfg.enable_allow_internal_unstable() {\n \n     // For some reason, the only one that actually works for `println` is the first check\n@@ -744,7 +787,6 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n             let sugg_fmt = match args.len() {\n                 0 => \"{}\".to_string(),\n                 _ => format!(\"{}{{}}\", \"{} \".repeat(args.len())),\n-\n             };\n             err.span_suggestion(\n                 fmt_sp.shrink_to_lo(),\n@@ -753,7 +795,11 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n             );\n             err.emit();\n             return DummyResult::raw_expr(sp);\n-        },\n+        }\n+    };\n+    let is_literal = match ecx.codemap().span_to_snippet(fmt_sp) {\n+        Ok(ref s) if s.starts_with(\"\\\"\") || s.starts_with(\"r#\") => true,\n+        _ => false,\n     };\n \n     let mut cx = Context {\n@@ -763,6 +809,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n         arg_unique_types,\n         names,\n         curarg: 0,\n+        curpiece: 0,\n         arg_index_map: Vec::new(),\n         count_args: Vec::new(),\n         count_positions: HashMap::new(),\n@@ -775,6 +822,8 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n         macsp,\n         fmtsp: fmt.span,\n         invalid_refs: Vec::new(),\n+        arg_spans: Vec::new(),\n+        is_literal,\n     };\n \n     let fmt_str = &*fmt.node.0.as_str();\n@@ -783,12 +832,22 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n         ast::StrStyle::Raw(raw) => Some(raw as usize),\n     };\n     let mut parser = parse::Parser::new(fmt_str, str_style);\n+    let mut unverified_pieces = vec![];\n     let mut pieces = vec![];\n \n-    while let Some(mut piece) = parser.next() {\n+    while let Some(piece) = parser.next() {\n         if !parser.errors.is_empty() {\n             break;\n         }\n+        unverified_pieces.push(piece);\n+    }\n+\n+    cx.arg_spans = parser.arg_places.iter()\n+        .map(|&(start, end)| fmt.span.from_inner_byte_pos(start, end))\n+        .collect();\n+\n+    // This needs to happen *after* the Parser has consumed all pieces to create all the spans\n+    for mut piece in unverified_pieces {\n         cx.verify_piece(&piece);\n         cx.resolve_name_inplace(&mut piece);\n         pieces.push(piece);\n@@ -856,24 +915,27 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n             errs.push((cx.args[i].span, msg));\n         }\n     }\n-    if errs.len() > 0 {\n-        let args_used = cx.arg_types.len() - errs.len();\n-        let args_unused = errs.len();\n+    let errs_len = errs.len();\n+    if errs_len > 0 {\n+        let args_used = cx.arg_types.len() - errs_len;\n+        let args_unused = errs_len;\n \n         let mut diag = {\n-            if errs.len() == 1 {\n+            if errs_len == 1 {\n                 let (sp, msg) = errs.into_iter().next().unwrap();\n                 cx.ecx.struct_span_err(sp, msg)\n             } else {\n                 let mut diag = cx.ecx.struct_span_err(\n                     errs.iter().map(|&(sp, _)| sp).collect::<Vec<Span>>(),\n-                    \"multiple unused formatting arguments\"\n+                    \"multiple unused formatting arguments\",\n                 );\n-                diag.span_label(cx.fmtsp, \"multiple missing formatting arguments\");\n+                diag.span_label(cx.fmtsp, \"multiple missing formatting specifiers\");\n                 diag\n             }\n         };\n \n+        // Used to ensure we only report translations for *one* kind of foreign format.\n+        let mut found_foreign = false;\n         // Decide if we want to look for foreign formatting directives.\n         if args_used < args_unused {\n             use super::format_foreign as foreign;\n@@ -882,13 +944,11 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n             // with `%d should be written as {}` over and over again.\n             let mut explained = HashSet::new();\n \n-            // Used to ensure we only report translations for *one* kind of foreign format.\n-            let mut found_foreign = false;\n-\n             macro_rules! check_foreign {\n                 ($kind:ident) => {{\n                     let mut show_doc_note = false;\n \n+                    let mut suggestions = vec![];\n                     for sub in foreign::$kind::iter_subs(fmt_str) {\n                         let trn = match sub.translate() {\n                             Some(trn) => trn,\n@@ -897,6 +957,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n                             None => continue,\n                         };\n \n+                        let pos = sub.position();\n                         let sub = String::from(sub.as_str());\n                         if explained.contains(&sub) {\n                             continue;\n@@ -908,7 +969,14 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n                             show_doc_note = true;\n                         }\n \n-                        diag.help(&format!(\"`{}` should be written as `{}`\", sub, trn));\n+                        if let Some((start, end)) = pos {\n+                            // account for `\"` and account for raw strings `r#`\n+                            let padding = str_style.map(|i| i + 2).unwrap_or(1);\n+                            let sp = fmt_sp.from_inner_byte_pos(start + padding, end + padding);\n+                            suggestions.push((sp, trn));\n+                        } else {\n+                            diag.help(&format!(\"`{}` should be written as `{}`\", sub, trn));\n+                        }\n                     }\n \n                     if show_doc_note {\n@@ -917,6 +985,12 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n                             \" formatting not supported; see the documentation for `std::fmt`\",\n                         ));\n                     }\n+                    if suggestions.len() > 0 {\n+                        diag.multipart_suggestion(\n+                            \"format specifiers use curly braces\",\n+                            suggestions,\n+                        );\n+                    }\n                 }};\n             }\n \n@@ -925,6 +999,9 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n                 check_foreign!(shell);\n             }\n         }\n+        if !found_foreign && errs_len == 1 {\n+            diag.span_label(cx.fmtsp, \"formatting specifier missing\");\n+        }\n \n         diag.emit();\n     }"}, {"sha": "23a37ca34853c6ad39586a3c2e26422038ca645e", "filename": "src/libsyntax_ext/format_foreign.rs", "status": "modified", "additions": 74, "deletions": 28, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/2aec4e882c6136ff34d931043fb16bd35abedc3e/src%2Flibsyntax_ext%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aec4e882c6136ff34d931043fb16bd35abedc3e/src%2Flibsyntax_ext%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat_foreign.rs?ref=2aec4e882c6136ff34d931043fb16bd35abedc3e", "patch": "@@ -14,7 +14,7 @@ pub mod printf {\n     /// Represents a single `printf`-style substitution.\n     #[derive(Clone, PartialEq, Debug)]\n     pub enum Substitution<'a> {\n-        /// A formatted output substitution.\n+        /// A formatted output substitution with its internal byte offset.\n         Format(Format<'a>),\n         /// A literal `%%` escape.\n         Escape,\n@@ -28,6 +28,23 @@ pub mod printf {\n             }\n         }\n \n+        pub fn position(&self) -> Option<(usize, usize)> {\n+            match *self {\n+                Substitution::Format(ref fmt) => Some(fmt.position),\n+                _ => None,\n+            }\n+        }\n+\n+        pub fn set_position(&mut self, start: usize, end: usize) {\n+            match self {\n+                Substitution::Format(ref mut fmt) => {\n+                    fmt.position = (start, end);\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+\n         /// Translate this substitution into an equivalent Rust formatting directive.\n         ///\n         /// This ignores cases where the substitution does not have an exact equivalent, or where\n@@ -57,6 +74,8 @@ pub mod printf {\n         pub length: Option<&'a str>,\n         /// Type of parameter being converted.\n         pub type_: &'a str,\n+        /// Byte offset for the start and end of this formatting directive.\n+        pub position: (usize, usize),\n     }\n \n     impl<'a> Format<'a> {\n@@ -257,19 +276,28 @@ pub mod printf {\n     pub fn iter_subs(s: &str) -> Substitutions {\n         Substitutions {\n             s,\n+            pos: 0,\n         }\n     }\n \n     /// Iterator over substitutions in a string.\n     pub struct Substitutions<'a> {\n         s: &'a str,\n+        pos: usize,\n     }\n \n     impl<'a> Iterator for Substitutions<'a> {\n         type Item = Substitution<'a>;\n         fn next(&mut self) -> Option<Self::Item> {\n-            let (sub, tail) = parse_next_substitution(self.s)?;\n+            let (mut sub, tail) = parse_next_substitution(self.s)?;\n             self.s = tail;\n+            match sub {\n+                Substitution::Format(_) => if let Some((start, end)) = sub.position() {\n+                    sub.set_position(start + self.pos, end + self.pos);\n+                    self.pos += end;\n+                }\n+                Substitution::Escape => self.pos += 2,\n+            }\n             Some(sub)\n         }\n \n@@ -301,7 +329,7 @@ pub mod printf {\n                 _ => {/* fall-through */},\n             }\n \n-            Cur::new_at_start(&s[start..])\n+            Cur::new_at(&s[..], start)\n         };\n \n         // This is meant to be a translation of the following regex:\n@@ -355,6 +383,7 @@ pub mod printf {\n                     precision: None,\n                     length: None,\n                     type_: at.slice_between(next).unwrap(),\n+                    position: (start.at, next.at),\n                 }),\n                 next.slice_after()\n             ));\n@@ -541,6 +570,7 @@ pub mod printf {\n         drop(next);\n \n         end = at;\n+        let position = (start.at, end.at);\n \n         let f = Format {\n             span: start.slice_between(end).unwrap(),\n@@ -550,6 +580,7 @@ pub mod printf {\n             precision,\n             length,\n             type_,\n+            position,\n         };\n         Some((Substitution::Format(f), end.slice_after()))\n     }\n@@ -616,6 +647,7 @@ pub mod printf {\n                 ($in_:expr, {\n                     $param:expr, $flags:expr,\n                     $width:expr, $prec:expr, $len:expr, $type_:expr,\n+                    $pos:expr,\n                 }) => {\n                     assert_eq!(\n                         pns(concat!($in_, \"!\")),\n@@ -628,6 +660,7 @@ pub mod printf {\n                                 precision: $prec,\n                                 length: $len,\n                                 type_: $type_,\n+                                position: $pos,\n                             }),\n                             \"!\"\n                         ))\n@@ -636,53 +669,53 @@ pub mod printf {\n             }\n \n             assert_pns_eq_sub!(\"%!\",\n-                { None, \"\", None, None, None, \"!\", });\n+                { None, \"\", None, None, None, \"!\", (0, 2), });\n             assert_pns_eq_sub!(\"%c\",\n-                { None, \"\", None, None, None, \"c\", });\n+                { None, \"\", None, None, None, \"c\", (0, 2), });\n             assert_pns_eq_sub!(\"%s\",\n-                { None, \"\", None, None, None, \"s\", });\n+                { None, \"\", None, None, None, \"s\", (0, 2), });\n             assert_pns_eq_sub!(\"%06d\",\n-                { None, \"0\", Some(N::Num(6)), None, None, \"d\", });\n+                { None, \"0\", Some(N::Num(6)), None, None, \"d\", (0, 4), });\n             assert_pns_eq_sub!(\"%4.2f\",\n-                { None, \"\", Some(N::Num(4)), Some(N::Num(2)), None, \"f\", });\n+                { None, \"\", Some(N::Num(4)), Some(N::Num(2)), None, \"f\", (0, 5), });\n             assert_pns_eq_sub!(\"%#x\",\n-                { None, \"#\", None, None, None, \"x\", });\n+                { None, \"#\", None, None, None, \"x\", (0, 3), });\n             assert_pns_eq_sub!(\"%-10s\",\n-                { None, \"-\", Some(N::Num(10)), None, None, \"s\", });\n+                { None, \"-\", Some(N::Num(10)), None, None, \"s\", (0, 5), });\n             assert_pns_eq_sub!(\"%*s\",\n-                { None, \"\", Some(N::Next), None, None, \"s\", });\n+                { None, \"\", Some(N::Next), None, None, \"s\", (0, 3), });\n             assert_pns_eq_sub!(\"%-10.*s\",\n-                { None, \"-\", Some(N::Num(10)), Some(N::Next), None, \"s\", });\n+                { None, \"-\", Some(N::Num(10)), Some(N::Next), None, \"s\", (0, 7), });\n             assert_pns_eq_sub!(\"%-*.*s\",\n-                { None, \"-\", Some(N::Next), Some(N::Next), None, \"s\", });\n+                { None, \"-\", Some(N::Next), Some(N::Next), None, \"s\", (0, 6), });\n             assert_pns_eq_sub!(\"%.6i\",\n-                { None, \"\", None, Some(N::Num(6)), None, \"i\", });\n+                { None, \"\", None, Some(N::Num(6)), None, \"i\", (0, 4), });\n             assert_pns_eq_sub!(\"%+i\",\n-                { None, \"+\", None, None, None, \"i\", });\n+                { None, \"+\", None, None, None, \"i\", (0, 3), });\n             assert_pns_eq_sub!(\"%08X\",\n-                { None, \"0\", Some(N::Num(8)), None, None, \"X\", });\n+                { None, \"0\", Some(N::Num(8)), None, None, \"X\", (0, 4), });\n             assert_pns_eq_sub!(\"%lu\",\n-                { None, \"\", None, None, Some(\"l\"), \"u\", });\n+                { None, \"\", None, None, Some(\"l\"), \"u\", (0, 3), });\n             assert_pns_eq_sub!(\"%Iu\",\n-                { None, \"\", None, None, Some(\"I\"), \"u\", });\n+                { None, \"\", None, None, Some(\"I\"), \"u\", (0, 3), });\n             assert_pns_eq_sub!(\"%I32u\",\n-                { None, \"\", None, None, Some(\"I32\"), \"u\", });\n+                { None, \"\", None, None, Some(\"I32\"), \"u\", (0, 5), });\n             assert_pns_eq_sub!(\"%I64u\",\n-                { None, \"\", None, None, Some(\"I64\"), \"u\", });\n+                { None, \"\", None, None, Some(\"I64\"), \"u\", (0, 5), });\n             assert_pns_eq_sub!(\"%'d\",\n-                { None, \"'\", None, None, None, \"d\", });\n+                { None, \"'\", None, None, None, \"d\", (0, 3), });\n             assert_pns_eq_sub!(\"%10s\",\n-                { None, \"\", Some(N::Num(10)), None, None, \"s\", });\n+                { None, \"\", Some(N::Num(10)), None, None, \"s\", (0, 4), });\n             assert_pns_eq_sub!(\"%-10.10s\",\n-                { None, \"-\", Some(N::Num(10)), Some(N::Num(10)), None, \"s\", });\n+                { None, \"-\", Some(N::Num(10)), Some(N::Num(10)), None, \"s\", (0, 8), });\n             assert_pns_eq_sub!(\"%1$d\",\n-                { Some(1), \"\", None, None, None, \"d\", });\n+                { Some(1), \"\", None, None, None, \"d\", (0, 4), });\n             assert_pns_eq_sub!(\"%2$.*3$d\",\n-                { Some(2), \"\", None, Some(N::Arg(3)), None, \"d\", });\n+                { Some(2), \"\", None, Some(N::Arg(3)), None, \"d\", (0, 8), });\n             assert_pns_eq_sub!(\"%1$*2$.*3$d\",\n-                { Some(1), \"\", Some(N::Arg(2)), Some(N::Arg(3)), None, \"d\", });\n+                { Some(1), \"\", Some(N::Arg(2)), Some(N::Arg(3)), None, \"d\", (0, 11), });\n             assert_pns_eq_sub!(\"%-8ld\",\n-                { None, \"-\", Some(N::Num(8)), None, Some(\"l\"), \"d\", });\n+                { None, \"-\", Some(N::Num(8)), None, Some(\"l\"), \"d\", (0, 5), });\n         }\n \n         #[test]\n@@ -755,6 +788,12 @@ pub mod shell {\n             }\n         }\n \n+        pub fn position(&self) -> Option<(usize, usize)> {\n+            match *self {\n+                _ => None,\n+            }\n+        }\n+\n         pub fn translate(&self) -> Option<String> {\n             match *self {\n                 Substitution::Ordinal(n) => Some(format!(\"{{{}}}\", n)),\n@@ -918,7 +957,7 @@ mod strcursor {\n \n     pub struct StrCursor<'a> {\n         s: &'a str,\n-        at: usize,\n+        pub at: usize,\n     }\n \n     impl<'a> StrCursor<'a> {\n@@ -929,6 +968,13 @@ mod strcursor {\n             }\n         }\n \n+        pub fn new_at(s: &'a str, at: usize) -> StrCursor<'a> {\n+            StrCursor {\n+                s,\n+                at,\n+            }\n+        }\n+\n         pub fn at_next_cp(mut self) -> Option<StrCursor<'a>> {\n             match self.try_seek_right_cp() {\n                 true => Some(self),"}, {"sha": "bbd75f30d6cb13ca69a05af3d2319dafc4133c03", "filename": "src/test/ui/ifmt-bad-arg.rs", "status": "renamed", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2aec4e882c6136ff34d931043fb16bd35abedc3e/src%2Ftest%2Fui%2Fifmt-bad-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aec4e882c6136ff34d931043fb16bd35abedc3e/src%2Ftest%2Fui%2Fifmt-bad-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fifmt-bad-arg.rs?ref=2aec4e882c6136ff34d931043fb16bd35abedc3e", "patch": "@@ -64,4 +64,11 @@ fn main() {\n     format!(\"foo }\"); //~ ERROR: unmatched `}` found\n \n     format!(\"foo %s baz\", \"bar\"); //~ ERROR: argument never used\n+\n+    format!(r##\"\n+\n+        {foo}\n+\n+    \"##);\n+    //~^^^ ERROR: there is no argument named `foo`\n }", "previous_filename": "src/test/compile-fail/ifmt-bad-arg.rs"}, {"sha": "c8fd8bad19ba54402f1f3176ef4280ab4004288a", "filename": "src/test/ui/ifmt-bad-arg.stderr", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/2aec4e882c6136ff34d931043fb16bd35abedc3e/src%2Ftest%2Fui%2Fifmt-bad-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2aec4e882c6136ff34d931043fb16bd35abedc3e/src%2Ftest%2Fui%2Fifmt-bad-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fifmt-bad-arg.stderr?ref=2aec4e882c6136ff34d931043fb16bd35abedc3e", "patch": "@@ -0,0 +1,208 @@\n+error: 1 positional argument in format string, but no arguments were given\n+  --> $DIR/ifmt-bad-arg.rs:16:14\n+   |\n+LL |     format!(\"{}\");\n+   |              ^^\n+\n+error: invalid reference to positional argument 1 (there is 1 argument)\n+  --> $DIR/ifmt-bad-arg.rs:19:14\n+   |\n+LL |     format!(\"{1}\", 1);\n+   |              ^^^\n+   |\n+   = note: positional arguments are zero-based\n+\n+error: argument never used\n+  --> $DIR/ifmt-bad-arg.rs:19:20\n+   |\n+LL |     format!(\"{1}\", 1);\n+   |             -----  ^\n+   |             |\n+   |             formatting specifier missing\n+\n+error: 2 positional arguments in format string, but no arguments were given\n+  --> $DIR/ifmt-bad-arg.rs:23:14\n+   |\n+LL |     format!(\"{} {}\");\n+   |              ^^ ^^\n+\n+error: invalid reference to positional argument 1 (there is 1 argument)\n+  --> $DIR/ifmt-bad-arg.rs:26:18\n+   |\n+LL |     format!(\"{0} {1}\", 1);\n+   |                  ^^^\n+   |\n+   = note: positional arguments are zero-based\n+\n+error: invalid reference to positional argument 2 (there are 2 arguments)\n+  --> $DIR/ifmt-bad-arg.rs:29:22\n+   |\n+LL |     format!(\"{0} {1} {2}\", 1, 2);\n+   |                      ^^^\n+   |\n+   = note: positional arguments are zero-based\n+\n+error: invalid reference to positional argument 2 (there are 2 arguments)\n+  --> $DIR/ifmt-bad-arg.rs:32:28\n+   |\n+LL |     format!(\"{} {value} {} {}\", 1, value=2);\n+   |                            ^^\n+   |\n+   = note: positional arguments are zero-based\n+\n+error: invalid reference to positional arguments 3, 4 and 5 (there are 3 arguments)\n+  --> $DIR/ifmt-bad-arg.rs:34:38\n+   |\n+LL |     format!(\"{name} {value} {} {} {} {} {} {}\", 0, name=1, value=2);\n+   |                                      ^^ ^^ ^^\n+   |\n+   = note: positional arguments are zero-based\n+\n+error: there is no argument named `foo`\n+  --> $DIR/ifmt-bad-arg.rs:37:17\n+   |\n+LL |     format!(\"{} {foo} {} {bar} {}\", 1, 2, 3);\n+   |                 ^^^^^\n+\n+error: there is no argument named `bar`\n+  --> $DIR/ifmt-bad-arg.rs:37:26\n+   |\n+LL |     format!(\"{} {foo} {} {bar} {}\", 1, 2, 3);\n+   |                          ^^^^^\n+\n+error: there is no argument named `foo`\n+  --> $DIR/ifmt-bad-arg.rs:41:14\n+   |\n+LL |     format!(\"{foo}\");                //~ ERROR: no argument named `foo`\n+   |              ^^^^^\n+\n+error: multiple unused formatting arguments\n+  --> $DIR/ifmt-bad-arg.rs:42:17\n+   |\n+LL |     format!(\"\", 1, 2);               //~ ERROR: multiple unused formatting arguments\n+   |             --  ^  ^\n+   |             |\n+   |             multiple missing formatting specifiers\n+\n+error: argument never used\n+  --> $DIR/ifmt-bad-arg.rs:43:22\n+   |\n+LL |     format!(\"{}\", 1, 2);             //~ ERROR: argument never used\n+   |             ----     ^\n+   |             |\n+   |             formatting specifier missing\n+\n+error: argument never used\n+  --> $DIR/ifmt-bad-arg.rs:44:20\n+   |\n+LL |     format!(\"{1}\", 1, 2);            //~ ERROR: argument never used\n+   |             -----  ^\n+   |             |\n+   |             formatting specifier missing\n+\n+error: named argument never used\n+  --> $DIR/ifmt-bad-arg.rs:45:26\n+   |\n+LL |     format!(\"{}\", 1, foo=2);         //~ ERROR: named argument never used\n+   |             ----         ^\n+   |             |\n+   |             formatting specifier missing\n+\n+error: argument never used\n+  --> $DIR/ifmt-bad-arg.rs:46:22\n+   |\n+LL |     format!(\"{foo}\", 1, foo=2);      //~ ERROR: argument never used\n+   |             -------  ^\n+   |             |\n+   |             formatting specifier missing\n+\n+error: named argument never used\n+  --> $DIR/ifmt-bad-arg.rs:47:21\n+   |\n+LL |     format!(\"\", foo=2);              //~ ERROR: named argument never used\n+   |             --      ^\n+   |             |\n+   |             formatting specifier missing\n+\n+error: multiple unused formatting arguments\n+  --> $DIR/ifmt-bad-arg.rs:48:32\n+   |\n+LL |     format!(\"{} {}\", 1, 2, foo=1, bar=2);  //~ ERROR: multiple unused formatting arguments\n+   |             -------            ^      ^\n+   |             |\n+   |             multiple missing formatting specifiers\n+\n+error: duplicate argument named `foo`\n+  --> $DIR/ifmt-bad-arg.rs:50:33\n+   |\n+LL |     format!(\"{foo}\", foo=1, foo=2);  //~ ERROR: duplicate argument\n+   |                                 ^\n+   |\n+note: previously here\n+  --> $DIR/ifmt-bad-arg.rs:50:26\n+   |\n+LL |     format!(\"{foo}\", foo=1, foo=2);  //~ ERROR: duplicate argument\n+   |                          ^\n+\n+error: expected ident, positional arguments cannot follow named arguments\n+  --> $DIR/ifmt-bad-arg.rs:51:24\n+   |\n+LL |     format!(\"\", foo=1, 2);           //~ ERROR: positional arguments cannot follow\n+   |                        ^\n+\n+error: there is no argument named `valueb`\n+  --> $DIR/ifmt-bad-arg.rs:55:23\n+   |\n+LL |     format!(\"{valuea} {valueb}\", valuea=5, valuec=7);\n+   |                       ^^^^^^^^\n+\n+error: named argument never used\n+  --> $DIR/ifmt-bad-arg.rs:55:51\n+   |\n+LL |     format!(\"{valuea} {valueb}\", valuea=5, valuec=7);\n+   |             -------------------                   ^\n+   |             |\n+   |             formatting specifier missing\n+\n+error: invalid format string: expected `'}'` but string was terminated\n+  --> $DIR/ifmt-bad-arg.rs:61:15\n+   |\n+LL |     format!(\"{\"); //~ ERROR: expected `'}'` but string was terminated\n+   |               ^ expected `'}'` in format string\n+   |\n+   = note: if you intended to print `{`, you can escape it using `{{`\n+\n+error: invalid format string: unmatched `}` found\n+  --> $DIR/ifmt-bad-arg.rs:63:18\n+   |\n+LL |     format!(\"foo } bar\"); //~ ERROR: unmatched `}` found\n+   |                  ^ unmatched `}` in format string\n+   |\n+   = note: if you intended to print `}`, you can escape it using `}}`\n+\n+error: invalid format string: unmatched `}` found\n+  --> $DIR/ifmt-bad-arg.rs:64:18\n+   |\n+LL |     format!(\"foo }\"); //~ ERROR: unmatched `}` found\n+   |                  ^ unmatched `}` in format string\n+   |\n+   = note: if you intended to print `}`, you can escape it using `}}`\n+\n+error: argument never used\n+  --> $DIR/ifmt-bad-arg.rs:66:27\n+   |\n+LL |     format!(\"foo %s baz\", \"bar\"); //~ ERROR: argument never used\n+   |                  --       ^^^^^\n+   |                  |\n+   |                  help: format specifiers use curly braces: `{}`\n+   |\n+   = note: printf formatting not supported; see the documentation for `std::fmt`\n+\n+error: there is no argument named `foo`\n+  --> $DIR/ifmt-bad-arg.rs:70:9\n+   |\n+LL |         {foo}\n+   |         ^^^^^\n+\n+error: aborting due to 27 previous errors\n+"}, {"sha": "33401424c9ada42cce9be51c6bc30d09e617e7fb", "filename": "src/test/ui/macros/format-foreign.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2aec4e882c6136ff34d931043fb16bd35abedc3e/src%2Ftest%2Fui%2Fmacros%2Fformat-foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aec4e882c6136ff34d931043fb16bd35abedc3e/src%2Ftest%2Fui%2Fmacros%2Fformat-foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fformat-foreign.rs?ref=2aec4e882c6136ff34d931043fb16bd35abedc3e", "patch": "@@ -11,6 +11,11 @@\n fn main() {\n     println!(\"%.*3$s %s!\\n\", \"Hello,\", \"World\", 4); //~ ERROR multiple unused formatting arguments\n     println!(\"%1$*2$.*3$f\", 123.456); //~ ERROR never used\n+    println!(r###\"%.*3$s\n+        %s!\\n\n+\"###, \"Hello,\", \"World\", 4);\n+    //~^ ERROR multiple unused formatting arguments\n+    // correctly account for raw strings in inline suggestions\n \n     // This should *not* produce hints, on the basis that there's equally as\n     // many \"correct\" format specifiers.  It's *probably* just an actual typo."}, {"sha": "5e76c0a322e51b941296762b1e793191c4112ba8", "filename": "src/test/ui/macros/format-foreign.stderr", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2aec4e882c6136ff34d931043fb16bd35abedc3e/src%2Ftest%2Fui%2Fmacros%2Fformat-foreign.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2aec4e882c6136ff34d931043fb16bd35abedc3e/src%2Ftest%2Fui%2Fmacros%2Fformat-foreign.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fformat-foreign.stderr?ref=2aec4e882c6136ff34d931043fb16bd35abedc3e", "patch": "@@ -4,35 +4,58 @@ error: multiple unused formatting arguments\n LL |     println!(\"%.*3$s %s!/n\", \"Hello,\", \"World\", 4); //~ ERROR multiple unused formatting arguments\n    |              --------------  ^^^^^^^^  ^^^^^^^  ^\n    |              |\n-   |              multiple missing formatting arguments\n+   |              multiple missing formatting specifiers\n    |\n-   = help: `%.*3$s` should be written as `{:.2$}`\n-   = help: `%s` should be written as `{}`\n    = note: printf formatting not supported; see the documentation for `std::fmt`\n+help: format specifiers use curly braces\n+   |\n+LL |     println!(\"{:.2$} {}!/n\", \"Hello,\", \"World\", 4); //~ ERROR multiple unused formatting arguments\n+   |               ^^^^^^ ^^\n \n error: argument never used\n   --> $DIR/format-foreign.rs:13:29\n    |\n LL |     println!(\"%1$*2$.*3$f\", 123.456); //~ ERROR never used\n-   |                             ^^^^^^^\n+   |               -----------   ^^^^^^^\n+   |               |\n+   |               help: format specifiers use curly braces: `{0:1$.2$}`\n    |\n-   = help: `%1$*2$.*3$f` should be written as `{0:1$.2$}`\n    = note: printf formatting not supported; see the documentation for `std::fmt`\n \n+error: multiple unused formatting arguments\n+  --> $DIR/format-foreign.rs:16:7\n+   |\n+LL |       println!(r###\"%.*3$s\n+   |  ______________-\n+LL | |         %s!/n\n+LL | | \"###, \"Hello,\", \"World\", 4);\n+   | |    -  ^^^^^^^^  ^^^^^^^  ^\n+   | |____|\n+   |      multiple missing formatting specifiers\n+   |\n+   = note: printf formatting not supported; see the documentation for `std::fmt`\n+help: format specifiers use curly braces\n+   |\n+LL |     println!(r###\"{:.2$}\n+LL |         {}!/n\n+   |\n+\n error: argument never used\n-  --> $DIR/format-foreign.rs:17:30\n+  --> $DIR/format-foreign.rs:22:30\n    |\n LL |     println!(\"{} %f\", \"one\", 2.0); //~ ERROR never used\n-   |                              ^^^\n+   |              -------         ^^^\n+   |              |\n+   |              formatting specifier missing\n \n error: named argument never used\n-  --> $DIR/format-foreign.rs:19:39\n+  --> $DIR/format-foreign.rs:24:39\n    |\n LL |     println!(\"Hi there, $NAME.\", NAME=\"Tim\"); //~ ERROR never used\n    |                                       ^^^^^\n    |\n    = help: `$NAME` should be written as `{NAME}`\n    = note: shell formatting not supported; see the documentation for `std::fmt`\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 5 previous errors\n "}, {"sha": "81171a1ed01de5dfe035f8ab353e727ba8b2300a", "filename": "src/test/ui/macros/format-unused-lables.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2aec4e882c6136ff34d931043fb16bd35abedc3e/src%2Ftest%2Fui%2Fmacros%2Fformat-unused-lables.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2aec4e882c6136ff34d931043fb16bd35abedc3e/src%2Ftest%2Fui%2Fmacros%2Fformat-unused-lables.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fformat-unused-lables.stderr?ref=2aec4e882c6136ff34d931043fb16bd35abedc3e", "patch": "@@ -4,13 +4,13 @@ error: multiple unused formatting arguments\n LL |     println!(\"Test\", 123, 456, 789);\n    |              ------  ^^^  ^^^  ^^^\n    |              |\n-   |              multiple missing formatting arguments\n+   |              multiple missing formatting specifiers\n \n error: multiple unused formatting arguments\n   --> $DIR/format-unused-lables.rs:16:9\n    |\n LL |     println!(\"Test2\",\n-   |              ------- multiple missing formatting arguments\n+   |              ------- multiple missing formatting specifiers\n LL |         123,  //~ ERROR multiple unused formatting arguments\n    |         ^^^\n LL |         456,\n@@ -22,13 +22,15 @@ error: named argument never used\n   --> $DIR/format-unused-lables.rs:21:35\n    |\n LL |     println!(\"Some stuff\", UNUSED=\"args\"); //~ ERROR named argument never used\n-   |                                   ^^^^^^\n+   |              ------------         ^^^^^^\n+   |              |\n+   |              formatting specifier missing\n \n error: multiple unused formatting arguments\n   --> $DIR/format-unused-lables.rs:24:9\n    |\n LL |     println!(\"Some more $STUFF\",\n-   |              ------------------ multiple missing formatting arguments\n+   |              ------------------ multiple missing formatting specifiers\n LL |         \"woo!\",  //~ ERROR multiple unused formatting arguments\n    |         ^^^^^^\n LL |             STUFF="}]}