{"sha": "dbf6abf6bfd0bf2ac17c648d5e2c1edb68099e60", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiZjZhYmY2YmZkMGJmMmFjMTdjNjQ4ZDVlMmMxZWRiNjgwOTllNjA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-30T18:01:39Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-31T22:01:48Z"}, "message": "std: Camel case net modules", "tree": {"sha": "c90e82aa0e2c45af2e4e0d746f56bb1b9a6a1c19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c90e82aa0e2c45af2e4e0d746f56bb1b9a6a1c19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbf6abf6bfd0bf2ac17c648d5e2c1edb68099e60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbf6abf6bfd0bf2ac17c648d5e2c1edb68099e60", "html_url": "https://github.com/rust-lang/rust/commit/dbf6abf6bfd0bf2ac17c648d5e2c1edb68099e60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbf6abf6bfd0bf2ac17c648d5e2c1edb68099e60/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7", "html_url": "https://github.com/rust-lang/rust/commit/afc1ccd282a132eb3206a21a5a0ac8fe4b1c24c7"}], "stats": {"total": 508, "additions": 256, "deletions": 252}, "files": [{"sha": "a2bccef57e5cf11d0bc6b0ec6629641913218f0c", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/dbf6abf6bfd0bf2ac17c648d5e2c1edb68099e60/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbf6abf6bfd0bf2ac17c648d5e2c1edb68099e60/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=dbf6abf6bfd0bf2ac17c648d5e2c1edb68099e60", "patch": "@@ -21,21 +21,21 @@ import get_data_for_req = uv::ll::get_data_for_req;\n import ll = uv::ll;\n import comm = core::comm;\n \n-export ip_addr, parse_addr_err;\n+export IpAddr, parse_addr_err;\n export format_addr;\n export v4, v6;\n export get_addr;\n-export ipv4, ipv6;\n+export Ipv4, Ipv6;\n \n /// An IP address\n-enum ip_addr {\n+enum IpAddr {\n     /// An IPv4 address\n-    ipv4(sockaddr_in),\n-    ipv6(sockaddr_in6)\n+    Ipv4(sockaddr_in),\n+    Ipv6(sockaddr_in6)\n }\n \n /// Human-friendly feedback on why a parse_addr attempt failed\n-type parse_addr_err = {\n+type ParseAddrErr = {\n     err_msg: ~str\n };\n \n@@ -46,16 +46,16 @@ type parse_addr_err = {\n  *\n  * * ip - a `std::net::ip::ip_addr`\n  */\n-fn format_addr(ip: ip_addr) -> ~str {\n+fn format_addr(ip: IpAddr) -> ~str {\n     match ip {\n-      ipv4(addr) =>  unsafe {\n+      Ipv4(addr) =>  unsafe {\n         let result = uv_ip4_name(&addr);\n         if result == ~\"\" {\n             fail ~\"failed to convert inner sockaddr_in address to str\"\n         }\n         result\n       },\n-      ipv6(addr) => unsafe {\n+      Ipv6(addr) => unsafe {\n         let result = uv_ip6_name(&addr);\n         if result == ~\"\" {\n             fail ~\"failed to convert inner sockaddr_in address to str\"\n@@ -66,8 +66,8 @@ fn format_addr(ip: ip_addr) -> ~str {\n }\n \n /// Represents errors returned from `net::ip::get_addr()`\n-enum ip_get_addr_err {\n-    get_addr_unknown_error\n+enum IpGetAddrErr {\n+    GetAddrUnknownError\n }\n \n /**\n@@ -85,13 +85,13 @@ enum ip_get_addr_err {\n  * object in the case of failure\n  */\n fn get_addr(++node: ~str, iotask: iotask)\n-        -> result::Result<~[ip_addr], ip_get_addr_err> {\n+        -> result::Result<~[IpAddr], IpGetAddrErr> {\n     do core::comm::listen |output_ch| {\n         do str::as_buf(node) |node_ptr, len| unsafe {\n             log(debug, fmt!(\"slice len %?\", len));\n             let handle = create_uv_getaddrinfo_t();\n             let handle_ptr = ptr::addr_of(handle);\n-            let handle_data: get_addr_data = {\n+            let handle_data: GetAddrData = {\n                 output_ch: output_ch\n             };\n             let handle_data_ptr = ptr::addr_of(handle_data);\n@@ -108,7 +108,7 @@ fn get_addr(++node: ~str, iotask: iotask)\n                     set_data_for_req(handle_ptr, handle_data_ptr);\n                   }\n                   _ => {\n-                    output_ch.send(result::Err(get_addr_unknown_error));\n+                    output_ch.send(result::Err(GetAddrUnknownError));\n                   }\n                 }\n             };\n@@ -133,27 +133,27 @@ mod v4 {\n      *\n      * * an `ip_addr` of the `ipv4` variant\n      */\n-    fn parse_addr(ip: ~str) -> ip_addr {\n+    fn parse_addr(ip: ~str) -> IpAddr {\n         match try_parse_addr(ip) {\n           result::Ok(addr) => copy(addr),\n           result::Err(err_data) => fail err_data.err_msg\n         }\n     }\n     // the simple, old style numberic representation of\n     // ipv4\n-    type ipv4_rep = { a: u8, b: u8, c: u8, d:u8 };\n+    type Ipv4Rep = { a: u8, b: u8, c: u8, d:u8 };\n \n-    trait as_unsafe_u32 {\n+    trait AsUnsafeU32 {\n         unsafe fn as_u32() -> u32;\n     }\n \n-    impl ipv4_rep: as_unsafe_u32 {\n+    impl Ipv4Rep: AsUnsafeU32 {\n         // this is pretty dastardly, i know\n         unsafe fn as_u32() -> u32 {\n             *((ptr::addr_of(self)) as *u32)\n         }\n     }\n-    fn parse_to_ipv4_rep(ip: ~str) -> result::Result<ipv4_rep, ~str> {\n+    fn parse_to_ipv4_rep(ip: ~str) -> result::Result<Ipv4Rep, ~str> {\n         let parts = vec::map(str::split_char(ip, '.'), |s| {\n             match uint::from_str(s) {\n               Some(n) if n <= 255u => n,\n@@ -171,7 +171,7 @@ mod v4 {\n                         c: parts[2] as u8, d: parts[3] as u8})\n         }\n     }\n-    fn try_parse_addr(ip: ~str) -> result::Result<ip_addr,parse_addr_err> {\n+    fn try_parse_addr(ip: ~str) -> result::Result<IpAddr,ParseAddrErr> {\n         unsafe {\n             let INADDR_NONE = ll::get_INADDR_NONE();\n             let ip_rep_result = parse_to_ipv4_rep(ip);\n@@ -198,7 +198,7 @@ mod v4 {\n                     {err_msg: ~\"uv_ip4_name produced invalid result.\"})\n             }\n             else {\n-                result::Ok(ipv4(copy(new_addr)))\n+                result::Ok(Ipv4(copy(new_addr)))\n             }\n         }\n     }\n@@ -219,13 +219,13 @@ mod v6 {\n      *\n      * * an `ip_addr` of the `ipv6` variant\n      */\n-    fn parse_addr(ip: ~str) -> ip_addr {\n+    fn parse_addr(ip: ~str) -> IpAddr {\n         match try_parse_addr(ip) {\n           result::Ok(addr) => copy(addr),\n           result::Err(err_data) => fail err_data.err_msg\n         }\n     }\n-    fn try_parse_addr(ip: ~str) -> result::Result<ip_addr,parse_addr_err> {\n+    fn try_parse_addr(ip: ~str) -> result::Result<IpAddr,ParseAddrErr> {\n         unsafe {\n             // need to figure out how to establish a parse failure..\n             let new_addr = uv_ip6_addr(ip, 22);\n@@ -239,40 +239,40 @@ mod v6 {\n                                            ip)})\n             }\n             else {\n-                result::Ok(ipv6(new_addr))\n+                result::Ok(Ipv6(new_addr))\n             }\n         }\n     }\n }\n \n-type get_addr_data = {\n-    output_ch: comm::Chan<result::Result<~[ip_addr],ip_get_addr_err>>\n+type GetAddrData = {\n+    output_ch: comm::Chan<result::Result<~[IpAddr],IpGetAddrErr>>\n };\n \n extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n                      res: *addrinfo) unsafe {\n     log(debug, ~\"in get_addr_cb\");\n     let handle_data = get_data_for_req(handle) as\n-        *get_addr_data;\n+        *GetAddrData;\n     if status == 0i32 {\n         if res != (ptr::null::<addrinfo>()) {\n             let mut out_vec = ~[];\n             log(debug, fmt!(\"initial addrinfo: %?\", res));\n             let mut curr_addr = res;\n             loop {\n                 let new_ip_addr = if ll::is_ipv4_addrinfo(curr_addr) {\n-                    ipv4(copy((\n+                    Ipv4(copy((\n                         *ll::addrinfo_as_sockaddr_in(curr_addr))))\n                 }\n                 else if ll::is_ipv6_addrinfo(curr_addr) {\n-                    ipv6(copy((\n+                    Ipv6(copy((\n                         *ll::addrinfo_as_sockaddr_in6(curr_addr))))\n                 }\n                 else {\n                     log(debug, ~\"curr_addr is not of family AF_INET or \"+\n                         ~\"AF_INET6. Error.\");\n                     (*handle_data).output_ch.send(\n-                        result::Err(get_addr_unknown_error));\n+                        result::Err(GetAddrUnknownError));\n                     break;\n                 };\n                 out_vec += ~[new_ip_addr];\n@@ -294,13 +294,13 @@ extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n         else {\n             log(debug, ~\"addrinfo pointer is NULL\");\n             (*handle_data).output_ch.send(\n-                result::Err(get_addr_unknown_error));\n+                result::Err(GetAddrUnknownError));\n         }\n     }\n     else {\n         log(debug, ~\"status != 0 error in get_addr_cb\");\n         (*handle_data).output_ch.send(\n-            result::Err(get_addr_unknown_error));\n+            result::Err(GetAddrUnknownError));\n     }\n     if res != (ptr::null::<addrinfo>()) {\n         uv_freeaddrinfo(res);\n@@ -365,8 +365,8 @@ mod test {\n                         localhost_name, vec::len(results)));\n         for vec::each(results) |r| {\n             let ipv_prefix = match r {\n-              ipv4(_) => ~\"IPv4\",\n-              ipv6(_) => ~\"IPv6\"\n+              Ipv4(_) => ~\"IPv4\",\n+              Ipv6(_) => ~\"IPv6\"\n             };\n             log(debug, fmt!(\"test_get_addr: result %s: '%s'\",\n                             ipv_prefix, format_addr(r)));"}, {"sha": "fa799ee3e31783ed0aa3fdc9423a54bcbb1edced", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 146, "deletions": 146, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/dbf6abf6bfd0bf2ac17c648d5e2c1edb68099e60/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbf6abf6bfd0bf2ac17c648d5e2c1edb68099e60/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=dbf6abf6bfd0bf2ac17c648d5e2c1edb68099e60", "patch": "@@ -12,11 +12,11 @@ import io::{Reader, ReaderUtil, Writer};\n import comm = core::comm;\n \n // tcp interfaces\n-export tcp_socket;\n+export TcpSocket;\n // buffered socket\n-export tcp_socket_buf, socket_buf;\n+export TcpSocketBuf, SocketBuf;\n // errors\n-export tcp_err_data, tcp_connect_err_data;\n+export TcpErrData, TcpConnectErrData;\n // operations on a tcp_socket\n export write, write_future, read_start, read_stop;\n // tcp server stuff\n@@ -38,9 +38,9 @@ extern mod rustrt {\n  * underlying libuv data structures when it goes out of scope. This is the\n  * data structure that is used for read/write operations over a TCP stream.\n  */\n-struct tcp_socket {\n-  let socket_data: @tcp_socket_data;\n-  new(socket_data: @tcp_socket_data) { self.socket_data = socket_data; }\n+struct TcpSocket {\n+  let socket_data: @TcpSocketData;\n+  new(socket_data: @TcpSocketData) { self.socket_data = socket_data; }\n   drop {\n     unsafe {\n         tear_down_socket_data(self.socket_data)\n@@ -54,31 +54,31 @@ struct tcp_socket {\n  * It is created with a call to `net::tcp::socket_buf()` and has impls that\n  * satisfy both the `io::reader` and `io::writer` traits.\n  */\n-struct tcp_socket_buf {\n-  let data: @tcp_buffered_socket_data;\n-  new(data: @tcp_buffered_socket_data) { self.data = data; }\n+struct TcpSocketBuf {\n+  let data: @TcpBufferedSocketData;\n+  new(data: @TcpBufferedSocketData) { self.data = data; }\n }\n \n /// Contains raw, string-based, error information returned from libuv\n-type tcp_err_data = {\n+type TcpErrData = {\n     err_name: ~str,\n     err_msg: ~str\n };\n /// Details returned as part of a `result::err` result from `tcp::listen`\n-enum tcp_listen_err_data {\n+enum TcpListenErrData {\n     /**\n      * Some unplanned-for error. The first and second fields correspond\n      * to libuv's `err_name` and `err_msg` fields, respectively.\n      */\n-    generic_listen_err(~str, ~str),\n+    GenericListenErr(~str, ~str),\n     /**\n      * Failed to bind to the requested IP/Port, because it is already in use.\n      *\n      * # Possible Causes\n      *\n      * * Attempting to bind to a port already bound to another listener\n      */\n-    address_in_use,\n+    AddressInUse,\n     /**\n      * Request to bind to an IP/Port was denied by the system.\n      *\n@@ -89,17 +89,17 @@ enum tcp_listen_err_data {\n      * * Attempting to bind, as a non-priv'd\n      *   user, to 'privileged' ports (< 1024) on *nix\n      */\n-    access_denied\n+    AccessDenied\n }\n /// Details returned as part of a `result::err` result from `tcp::connect`\n-enum tcp_connect_err_data {\n+enum TcpConnectErrData {\n     /**\n      * Some unplanned-for error. The first and second fields correspond\n      * to libuv's `err_name` and `err_msg` fields, respectively.\n      */\n-    generic_connect_err(~str, ~str),\n+    GenericConnectErr(~str, ~str),\n     /// Invalid IP or invalid port\n-    connection_refused\n+    ConnectionRefused\n }\n \n /**\n@@ -118,17 +118,17 @@ enum tcp_connect_err_data {\n  * the remote host. In the event of failure, a\n  * `net::tcp::tcp_connect_err_data` instance will be returned\n  */\n-fn connect(-input_ip: ip::ip_addr, port: uint,\n+fn connect(-input_ip: ip::IpAddr, port: uint,\n            iotask: IoTask)\n-    -> result::Result<tcp_socket, tcp_connect_err_data> unsafe {\n-    let result_po = core::comm::Port::<conn_attempt>();\n+    -> result::Result<TcpSocket, TcpConnectErrData> unsafe {\n+    let result_po = core::comm::Port::<ConnAttempt>();\n     let closed_signal_po = core::comm::Port::<()>();\n     let conn_data = {\n         result_ch: core::comm::Chan(result_po),\n         closed_signal_ch: core::comm::Chan(closed_signal_po)\n     };\n     let conn_data_ptr = ptr::addr_of(conn_data);\n-    let reader_po = core::comm::Port::<result::Result<~[u8], tcp_err_data>>();\n+    let reader_po = core::comm::Port::<result::Result<~[u8], TcpErrData>>();\n     let stream_handle_ptr = malloc_uv_tcp_t();\n     *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) = uv::ll::tcp_t();\n     let socket_data = @{\n@@ -157,7 +157,7 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n                 ptr::addr_of((*socket_data_ptr).connect_req);\n             let addr_str = ip::format_addr(input_ip);\n             let connect_result = match input_ip {\n-              ip::ipv4(addr) => {\n+              ip::Ipv4(addr) => {\n                 // have to \"recreate\" the sockaddr_in/6\n                 // since the ip_addr discards the port\n                 // info.. should probably add an additional\n@@ -171,7 +171,7 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n                     ptr::addr_of(in_addr),\n                     tcp_connect_on_connect_cb)\n               }\n-              ip::ipv6(addr) => {\n+              ip::Ipv6(addr) => {\n                 log(debug, fmt!(\"addr: %?\", addr));\n                 let in_addr = uv::ll::ip6_addr(addr_str, port as int);\n                 uv::ll::tcp_connect6(\n@@ -202,7 +202,7 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n                 // ip or somesuch\n                 let err_data = uv::ll::get_last_err_data(loop_ptr);\n                 core::comm::send((*conn_data_ptr).result_ch,\n-                           conn_failure(err_data.to_tcp_err()));\n+                           ConnFailure(err_data.to_tcp_err()));\n                 uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n                                                conn_data_ptr);\n                 uv::ll::close(stream_handle_ptr, stream_error_close_cb);\n@@ -213,24 +213,24 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n             // failure to create a tcp handle\n             let err_data = uv::ll::get_last_err_data(loop_ptr);\n             core::comm::send((*conn_data_ptr).result_ch,\n-                       conn_failure(err_data.to_tcp_err()));\n+                       ConnFailure(err_data.to_tcp_err()));\n           }\n         }\n     };\n     match core::comm::recv(result_po) {\n-      conn_success => {\n+      ConnSuccess => {\n         log(debug, ~\"tcp::connect - received success on result_po\");\n-        result::Ok(tcp_socket(socket_data))\n+        result::Ok(TcpSocket(socket_data))\n       }\n-      conn_failure(err_data) => {\n+      ConnFailure(err_data) => {\n         core::comm::recv(closed_signal_po);\n         log(debug, ~\"tcp::connect - received failure on result_po\");\n         // still have to free the malloc'd stream handle..\n         rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n                                            as *libc::c_void);\n         let tcp_conn_err = match err_data.err_name {\n-          ~\"ECONNREFUSED\" => connection_refused,\n-          _ => generic_connect_err(err_data.err_name, err_data.err_msg)\n+          ~\"ECONNREFUSED\" => ConnectionRefused,\n+          _ => GenericConnectErr(err_data.err_name, err_data.err_msg)\n         };\n         result::Err(tcp_conn_err)\n       }\n@@ -251,8 +251,8 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n  * A `result` object with a `nil` value as the `ok` variant, or a\n  * `tcp_err_data` value as the `err` variant\n  */\n-fn write(sock: tcp_socket, raw_write_data: ~[u8])\n-    -> result::Result<(), tcp_err_data> unsafe {\n+fn write(sock: TcpSocket, raw_write_data: ~[u8])\n+    -> result::Result<(), TcpErrData> unsafe {\n     let socket_data_ptr = ptr::addr_of(*(sock.socket_data));\n     write_common_impl(socket_data_ptr, raw_write_data)\n }\n@@ -288,8 +288,8 @@ fn write(sock: tcp_socket, raw_write_data: ~[u8])\n  * `result` object with a `nil` value as the `ok` variant, or a `tcp_err_data`\n  * value as the `err` variant\n  */\n-fn write_future(sock: tcp_socket, raw_write_data: ~[u8])\n-    -> future::Future<result::Result<(), tcp_err_data>> unsafe {\n+fn write_future(sock: TcpSocket, raw_write_data: ~[u8])\n+    -> future::Future<result::Result<(), TcpErrData>> unsafe {\n     let socket_data_ptr = ptr::addr_of(*(sock.socket_data));\n     do future_spawn {\n         let data_copy = copy(raw_write_data);\n@@ -312,9 +312,9 @@ fn write_future(sock: tcp_socket, raw_write_data: ~[u8])\n  * optionally, loop on) from until `read_stop` is called, or a\n  * `tcp_err_data` record\n  */\n-fn read_start(sock: tcp_socket)\n+fn read_start(sock: TcpSocket)\n     -> result::Result<comm::Port<\n-        result::Result<~[u8], tcp_err_data>>, tcp_err_data> unsafe {\n+        result::Result<~[u8], TcpErrData>>, TcpErrData> unsafe {\n     let socket_data = ptr::addr_of(*(sock.socket_data));\n     read_start_common_impl(socket_data)\n }\n@@ -326,9 +326,9 @@ fn read_start(sock: tcp_socket)\n  *\n  * * `sock` - a `net::tcp::tcp_socket` that you wish to stop reading on\n  */\n-fn read_stop(sock: tcp_socket,\n-             -read_port: comm::Port<result::Result<~[u8], tcp_err_data>>) ->\n-    result::Result<(), tcp_err_data> unsafe {\n+fn read_stop(sock: TcpSocket,\n+             -read_port: comm::Port<result::Result<~[u8], TcpErrData>>) ->\n+    result::Result<(), TcpErrData> unsafe {\n     log(debug, fmt!(\"taking the read_port out of commission %?\", read_port));\n     let socket_data = ptr::addr_of(*sock.socket_data);\n     read_stop_common_impl(socket_data)\n@@ -349,8 +349,8 @@ fn read_stop(sock: tcp_socket,\n  * * `timeout_msecs` - a `uint` value, in msecs, to wait before dropping the\n  * read attempt. Pass `0u` to wait indefinitely\n  */\n-fn read(sock: tcp_socket, timeout_msecs: uint)\n-    -> result::Result<~[u8],tcp_err_data> {\n+fn read(sock: TcpSocket, timeout_msecs: uint)\n+    -> result::Result<~[u8],TcpErrData> {\n     let socket_data = ptr::addr_of(*(sock.socket_data));\n     read_common_impl(socket_data, timeout_msecs)\n }\n@@ -384,8 +384,8 @@ fn read(sock: tcp_socket, timeout_msecs: uint)\n  * * `timeout_msecs` - a `uint` value, in msecs, to wait before dropping the\n  * read attempt. Pass `0u` to wait indefinitely\n  */\n-fn read_future(sock: tcp_socket, timeout_msecs: uint)\n-    -> future::Future<result::Result<~[u8],tcp_err_data>> {\n+fn read_future(sock: TcpSocket, timeout_msecs: uint)\n+    -> future::Future<result::Result<~[u8],TcpErrData>> {\n     let socket_data = ptr::addr_of(*(sock.socket_data));\n     do future_spawn {\n         read_common_impl(socket_data, timeout_msecs)\n@@ -461,13 +461,13 @@ fn read_future(sock: tcp_socket, timeout_msecs: uint)\n  * this function will return a `net::tcp::tcp_err_data` record\n  * as the `err` variant of a `result`.\n  */\n-fn accept(new_conn: tcp_new_connection)\n-    -> result::Result<tcp_socket, tcp_err_data> unsafe {\n+fn accept(new_conn: TcpNewConnection)\n+    -> result::Result<TcpSocket, TcpErrData> unsafe {\n \n     match new_conn{\n-      new_tcp_conn(server_handle_ptr) => {\n+      NewTcpConn(server_handle_ptr) => {\n         let server_data_ptr = uv::ll::get_data_for_uv_handle(\n-            server_handle_ptr) as *tcp_listen_fc_data;\n+            server_handle_ptr) as *TcpListenFcData;\n         let reader_po = core::comm::Port();\n         let iotask = (*server_data_ptr).iotask;\n         let stream_handle_ptr = malloc_uv_tcp_t();\n@@ -484,7 +484,7 @@ fn accept(new_conn: tcp_new_connection)\n         let client_stream_handle_ptr =\n             (*client_socket_data_ptr).stream_handle_ptr;\n \n-        let result_po = core::comm::Port::<Option<tcp_err_data>>();\n+        let result_po = core::comm::Port::<Option<TcpErrData>>();\n         let result_ch = core::comm::Chan(result_po);\n \n         // UNSAFE LIBUV INTERACTION BEGIN\n@@ -525,7 +525,7 @@ fn accept(new_conn: tcp_new_connection)\n         // UNSAFE LIBUV INTERACTION END\n         match core::comm::recv(result_po) {\n           Some(err_data) => result::Err(err_data),\n-          None => result::Ok(tcp_socket(client_socket_data))\n+          None => result::Ok(TcpSocket(client_socket_data))\n         }\n       }\n     }\n@@ -559,30 +559,30 @@ fn accept(new_conn: tcp_new_connection)\n  * successful/normal shutdown, and a `tcp_listen_err_data` enum in the event\n  * of listen exiting because of an error\n  */\n-fn listen(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n+fn listen(-host_ip: ip::IpAddr, port: uint, backlog: uint,\n           iotask: IoTask,\n-          on_establish_cb: fn~(comm::Chan<Option<tcp_err_data>>),\n-          +new_connect_cb: fn~(tcp_new_connection,\n-                               comm::Chan<Option<tcp_err_data>>))\n-    -> result::Result<(), tcp_listen_err_data> unsafe {\n+          on_establish_cb: fn~(comm::Chan<Option<TcpErrData>>),\n+          +new_connect_cb: fn~(TcpNewConnection,\n+                               comm::Chan<Option<TcpErrData>>))\n+    -> result::Result<(), TcpListenErrData> unsafe {\n     do listen_common(host_ip, port, backlog, iotask, on_establish_cb)\n         // on_connect_cb\n         |handle| unsafe {\n             let server_data_ptr = uv::ll::get_data_for_uv_handle(handle)\n-                as *tcp_listen_fc_data;\n-            let new_conn = new_tcp_conn(handle);\n+                as *TcpListenFcData;\n+            let new_conn = NewTcpConn(handle);\n             let kill_ch = (*server_data_ptr).kill_ch;\n             new_connect_cb(new_conn, kill_ch);\n     }\n }\n \n-fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n+fn listen_common(-host_ip: ip::IpAddr, port: uint, backlog: uint,\n           iotask: IoTask,\n-          on_establish_cb: fn~(comm::Chan<Option<tcp_err_data>>),\n+          on_establish_cb: fn~(comm::Chan<Option<TcpErrData>>),\n           -on_connect_cb: fn~(*uv::ll::uv_tcp_t))\n-    -> result::Result<(), tcp_listen_err_data> unsafe {\n+    -> result::Result<(), TcpListenErrData> unsafe {\n     let stream_closed_po = core::comm::Port::<()>();\n-    let kill_po = core::comm::Port::<Option<tcp_err_data>>();\n+    let kill_po = core::comm::Port::<Option<TcpErrData>>();\n     let kill_ch = core::comm::Chan(kill_po);\n     let server_stream = uv::ll::tcp_t();\n     let server_stream_ptr = ptr::addr_of(server_stream);\n@@ -612,13 +612,13 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n                     server_data_ptr);\n                 let addr_str = ip::format_addr(loc_ip);\n                 let bind_result = match loc_ip {\n-                  ip::ipv4(addr) => {\n+                  ip::Ipv4(addr) => {\n                     log(debug, fmt!(\"addr: %?\", addr));\n                     let in_addr = uv::ll::ip4_addr(addr_str, port as int);\n                     uv::ll::tcp_bind(server_stream_ptr,\n                                      ptr::addr_of(in_addr))\n                   }\n-                  ip::ipv6(addr) => {\n+                  ip::Ipv6(addr) => {\n                     log(debug, fmt!(\"addr: %?\", addr));\n                     let in_addr = uv::ll::ip6_addr(addr_str, port as int);\n                     uv::ll::tcp_bind6(server_stream_ptr,\n@@ -666,17 +666,17 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n         match err_data.err_name {\n           ~\"EACCES\" => {\n             log(debug, ~\"Got EACCES error\");\n-            result::Err(access_denied)\n+            result::Err(AccessDenied)\n           }\n           ~\"EADDRINUSE\" => {\n             log(debug, ~\"Got EADDRINUSE error\");\n-            result::Err(address_in_use)\n+            result::Err(AddressInUse)\n           }\n           _ => {\n             log(debug, fmt!(\"Got '%s' '%s' libuv error\",\n                             err_data.err_name, err_data.err_msg));\n             result::Err(\n-                generic_listen_err(err_data.err_name, err_data.err_msg))\n+                GenericListenErr(err_data.err_name, err_data.err_msg))\n           }\n         }\n       }\n@@ -692,7 +692,7 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n         stream_closed_po.recv();\n         match kill_result {\n           // some failure post bind/listen\n-          Some(err_data) => result::Err(generic_listen_err(err_data.err_name,\n+          Some(err_data) => result::Err(GenericListenErr(err_data.err_name,\n                                                            err_data.err_msg)),\n           // clean exit\n           None => result::Ok(())\n@@ -716,41 +716,41 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n  *\n  * A buffered wrapper that you can cast as an `io::reader` or `io::writer`\n  */\n-fn socket_buf(-sock: tcp_socket) -> tcp_socket_buf {\n-    tcp_socket_buf(@{ sock: sock, mut buf: ~[] })\n+fn socket_buf(-sock: TcpSocket) -> TcpSocketBuf {\n+    TcpSocketBuf(@{ sock: sock, mut buf: ~[] })\n }\n \n /// Convenience methods extending `net::tcp::tcp_socket`\n-impl tcp_socket {\n+impl TcpSocket {\n     fn read_start() -> result::Result<comm::Port<\n-        result::Result<~[u8], tcp_err_data>>, tcp_err_data> {\n+        result::Result<~[u8], TcpErrData>>, TcpErrData> {\n         read_start(self)\n     }\n     fn read_stop(-read_port:\n-                 comm::Port<result::Result<~[u8], tcp_err_data>>) ->\n-        result::Result<(), tcp_err_data> {\n+                 comm::Port<result::Result<~[u8], TcpErrData>>) ->\n+        result::Result<(), TcpErrData> {\n         read_stop(self, read_port)\n     }\n     fn read(timeout_msecs: uint) ->\n-        result::Result<~[u8], tcp_err_data> {\n+        result::Result<~[u8], TcpErrData> {\n         read(self, timeout_msecs)\n     }\n     fn read_future(timeout_msecs: uint) ->\n-        future::Future<result::Result<~[u8], tcp_err_data>> {\n+        future::Future<result::Result<~[u8], TcpErrData>> {\n         read_future(self, timeout_msecs)\n     }\n     fn write(raw_write_data: ~[u8])\n-        -> result::Result<(), tcp_err_data> {\n+        -> result::Result<(), TcpErrData> {\n         write(self, raw_write_data)\n     }\n     fn write_future(raw_write_data: ~[u8])\n-        -> future::Future<result::Result<(), tcp_err_data>> {\n+        -> future::Future<result::Result<(), TcpErrData>> {\n         write_future(self, raw_write_data)\n     }\n }\n \n /// Implementation of `io::reader` trait for a buffered `net::tcp::tcp_socket`\n-impl tcp_socket_buf: io::Reader {\n+impl TcpSocketBuf: io::Reader {\n     fn read(buf: &[mut u8], len: uint) -> uint {\n         // Loop until our buffer has enough data in it for us to read from.\n         while self.data.buf.len() < len {\n@@ -803,7 +803,7 @@ impl tcp_socket_buf: io::Reader {\n }\n \n /// Implementation of `io::reader` trait for a buffered `net::tcp::tcp_socket`\n-impl tcp_socket_buf: io::Writer {\n+impl TcpSocketBuf: io::Writer {\n     fn write(data: &[const u8]) unsafe {\n         let socket_data_ptr =\n             ptr::addr_of(*((*(self.data)).sock).socket_data);\n@@ -832,7 +832,7 @@ impl tcp_socket_buf: io::Writer {\n \n // INTERNAL API\n \n-fn tear_down_socket_data(socket_data: @tcp_socket_data) unsafe {\n+fn tear_down_socket_data(socket_data: @TcpSocketData) unsafe {\n     let closed_po = core::comm::Port::<()>();\n     let closed_ch = core::comm::Chan(closed_po);\n     let close_data = {\n@@ -855,8 +855,8 @@ fn tear_down_socket_data(socket_data: @tcp_socket_data) unsafe {\n }\n \n // shared implementation for tcp::read\n-fn read_common_impl(socket_data: *tcp_socket_data, timeout_msecs: uint)\n-    -> result::Result<~[u8],tcp_err_data> unsafe {\n+fn read_common_impl(socket_data: *TcpSocketData, timeout_msecs: uint)\n+    -> result::Result<~[u8],TcpErrData> unsafe {\n     log(debug, ~\"starting tcp::read\");\n     let iotask = (*socket_data).iotask;\n     let rs_result = read_start_common_impl(socket_data);\n@@ -893,10 +893,10 @@ fn read_common_impl(socket_data: *tcp_socket_data, timeout_msecs: uint)\n }\n \n // shared impl for read_stop\n-fn read_stop_common_impl(socket_data: *tcp_socket_data) ->\n-    result::Result<(), tcp_err_data> unsafe {\n+fn read_stop_common_impl(socket_data: *TcpSocketData) ->\n+    result::Result<(), TcpErrData> unsafe {\n     let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n-    let stop_po = core::comm::Port::<Option<tcp_err_data>>();\n+    let stop_po = core::comm::Port::<Option<TcpErrData>>();\n     let stop_ch = core::comm::Chan(stop_po);\n     do iotask::interact((*socket_data).iotask) |loop_ptr| unsafe {\n         log(debug, ~\"in interact cb for tcp::read_stop\");\n@@ -919,9 +919,9 @@ fn read_stop_common_impl(socket_data: *tcp_socket_data) ->\n }\n \n // shared impl for read_start\n-fn read_start_common_impl(socket_data: *tcp_socket_data)\n+fn read_start_common_impl(socket_data: *TcpSocketData)\n     -> result::Result<comm::Port<\n-        result::Result<~[u8], tcp_err_data>>, tcp_err_data> unsafe {\n+        result::Result<~[u8], TcpErrData>>, TcpErrData> unsafe {\n     let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n     let start_po = core::comm::Port::<Option<uv::ll::uv_err_data>>();\n     let start_ch = core::comm::Chan(start_po);\n@@ -951,17 +951,17 @@ fn read_start_common_impl(socket_data: *tcp_socket_data)\n // helper to convert a \"class\" vector of [u8] to a *[uv::ll::uv_buf_t]\n \n // shared implementation used by write and write_future\n-fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n+fn write_common_impl(socket_data_ptr: *TcpSocketData,\n                      raw_write_data: ~[u8])\n-    -> result::Result<(), tcp_err_data> unsafe {\n+    -> result::Result<(), TcpErrData> unsafe {\n     let write_req_ptr = ptr::addr_of((*socket_data_ptr).write_req);\n     let stream_handle_ptr =\n         (*socket_data_ptr).stream_handle_ptr;\n     let write_buf_vec =  ~[ uv::ll::buf_init(\n         vec::unsafe::to_ptr(raw_write_data),\n         vec::len(raw_write_data)) ];\n     let write_buf_vec_ptr = ptr::addr_of(write_buf_vec);\n-    let result_po = core::comm::Port::<tcp_write_result>();\n+    let result_po = core::comm::Port::<TcpWriteResult>();\n     let write_data = {\n         result_ch: core::comm::Chan(result_po)\n     };\n@@ -980,7 +980,7 @@ fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n             log(debug, ~\"error invoking uv_write()\");\n             let err_data = uv::ll::get_last_err_data(loop_ptr);\n             core::comm::send((*write_data_ptr).result_ch,\n-                       tcp_write_error(err_data.to_tcp_err()));\n+                       TcpWriteError(err_data.to_tcp_err()));\n           }\n         }\n     };\n@@ -989,34 +989,34 @@ fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n     // ownership of everything to the I/O task and let it deal with the\n     // aftermath, so we don't have to sit here blocking.\n     match core::comm::recv(result_po) {\n-      tcp_write_success => result::Ok(()),\n-      tcp_write_error(err_data) => result::Err(err_data.to_tcp_err())\n+      TcpWriteSuccess => result::Ok(()),\n+      TcpWriteError(err_data) => result::Err(err_data.to_tcp_err())\n     }\n }\n \n-enum tcp_new_connection {\n-    new_tcp_conn(*uv::ll::uv_tcp_t)\n+enum TcpNewConnection {\n+    NewTcpConn(*uv::ll::uv_tcp_t)\n }\n \n-type tcp_listen_fc_data = {\n+type TcpListenFcData = {\n     server_stream_ptr: *uv::ll::uv_tcp_t,\n     stream_closed_ch: comm::Chan<()>,\n-    kill_ch: comm::Chan<Option<tcp_err_data>>,\n+    kill_ch: comm::Chan<Option<TcpErrData>>,\n     on_connect_cb: fn~(*uv::ll::uv_tcp_t),\n     iotask: IoTask,\n     mut active: bool\n };\n \n extern fn tcp_lfc_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n     let server_data_ptr = uv::ll::get_data_for_uv_handle(\n-        handle) as *tcp_listen_fc_data;\n+        handle) as *TcpListenFcData;\n     core::comm::send((*server_data_ptr).stream_closed_ch, ());\n }\n \n extern fn tcp_lfc_on_connection_cb(handle: *uv::ll::uv_tcp_t,\n                                      status: libc::c_int) unsafe {\n     let server_data_ptr = uv::ll::get_data_for_uv_handle(handle)\n-        as *tcp_listen_fc_data;\n+        as *TcpListenFcData;\n     let kill_ch = (*server_data_ptr).kill_ch;\n     if (*server_data_ptr).active {\n         match status {\n@@ -1037,33 +1037,33 @@ fn malloc_uv_tcp_t() -> *uv::ll::uv_tcp_t unsafe {\n         rustrt::rust_uv_helper_uv_tcp_t_size()) as *uv::ll::uv_tcp_t\n }\n \n-enum tcp_connect_result {\n-    tcp_connected(tcp_socket),\n-    tcp_connect_error(tcp_err_data)\n+enum TcpConnectResult {\n+    TcpConnected(TcpSocket),\n+    TcpConnectError(TcpErrData)\n }\n \n-enum tcp_write_result {\n-    tcp_write_success,\n-    tcp_write_error(tcp_err_data)\n+enum TcpWriteResult {\n+    TcpWriteSuccess,\n+    TcpWriteError(TcpErrData)\n }\n \n-enum tcp_read_start_result {\n-    tcp_read_start_success(comm::Port<tcp_read_result>),\n-    tcp_read_start_error(tcp_err_data)\n+enum TcpReadStartResult {\n+    TcpReadStartSuccess(comm::Port<TcpReadResult>),\n+    TcpReadStartError(TcpErrData)\n }\n \n-enum tcp_read_result {\n-    tcp_read_data(~[u8]),\n-    tcp_read_done,\n-    tcp_read_err(tcp_err_data)\n+enum TcpReadResult {\n+    TcpReadData(~[u8]),\n+    TcpReadDone,\n+    TcpReadErr(TcpErrData)\n }\n \n-trait to_tcp_err {\n-    fn to_tcp_err() -> tcp_err_data;\n+trait ToTcpErr {\n+    fn to_tcp_err() -> TcpErrData;\n }\n \n-impl uv::ll::uv_err_data: to_tcp_err {\n-    fn to_tcp_err() -> tcp_err_data {\n+impl uv::ll::uv_err_data: ToTcpErr {\n+    fn to_tcp_err() -> TcpErrData {\n         { err_name: self.err_name, err_msg: self.err_msg }\n     }\n }\n@@ -1075,7 +1075,7 @@ extern fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n                     stream, nread));\n     let loop_ptr = uv::ll::get_loop_for_uv_handle(stream);\n     let socket_data_ptr = uv::ll::get_data_for_uv_handle(stream)\n-        as *tcp_socket_data;\n+        as *TcpSocketData;\n     match nread as int {\n       // incoming err.. probably eof\n       -1 => {\n@@ -1113,13 +1113,13 @@ extern fn on_alloc_cb(handle: *libc::c_void,\n     uv::ll::buf_init(char_ptr, suggested_size as uint)\n }\n \n-type tcp_socket_close_data = {\n+type TcpSocketCloseData = {\n     closed_ch: comm::Chan<()>\n };\n \n extern fn tcp_socket_dtor_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n     let data = uv::ll::get_data_for_uv_handle(handle)\n-        as *tcp_socket_close_data;\n+        as *TcpSocketCloseData;\n     let closed_ch = (*data).closed_ch;\n     core::comm::send(closed_ch, ());\n     log(debug, ~\"tcp_socket_dtor_close_cb exiting..\");\n@@ -1128,33 +1128,33 @@ extern fn tcp_socket_dtor_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n extern fn tcp_write_complete_cb(write_req: *uv::ll::uv_write_t,\n                               status: libc::c_int) unsafe {\n     let write_data_ptr = uv::ll::get_data_for_req(write_req)\n-        as *write_req_data;\n+        as *WriteReqData;\n     if status == 0i32 {\n         log(debug, ~\"successful write complete\");\n-        core::comm::send((*write_data_ptr).result_ch, tcp_write_success);\n+        core::comm::send((*write_data_ptr).result_ch, TcpWriteSuccess);\n     } else {\n         let stream_handle_ptr = uv::ll::get_stream_handle_from_write_req(\n             write_req);\n         let loop_ptr = uv::ll::get_loop_for_uv_handle(stream_handle_ptr);\n         let err_data = uv::ll::get_last_err_data(loop_ptr);\n         log(debug, ~\"failure to write\");\n         core::comm::send((*write_data_ptr).result_ch,\n-                         tcp_write_error(err_data));\n+                         TcpWriteError(err_data));\n     }\n }\n \n-type write_req_data = {\n-    result_ch: comm::Chan<tcp_write_result>\n+type WriteReqData = {\n+    result_ch: comm::Chan<TcpWriteResult>\n };\n \n-type connect_req_data = {\n-    result_ch: comm::Chan<conn_attempt>,\n+type ConnectReqData = {\n+    result_ch: comm::Chan<ConnAttempt>,\n     closed_signal_ch: comm::Chan<()>\n };\n \n extern fn stream_error_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n     let data = uv::ll::get_data_for_uv_handle(handle) as\n-        *connect_req_data;\n+        *ConnectReqData;\n     core::comm::send((*data).closed_signal_ch, ());\n     log(debug, fmt!(\"exiting steam_error_close_cb for %?\", handle));\n }\n@@ -1166,23 +1166,23 @@ extern fn tcp_connect_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n extern fn tcp_connect_on_connect_cb(connect_req_ptr: *uv::ll::uv_connect_t,\n                                    status: libc::c_int) unsafe {\n     let conn_data_ptr = (uv::ll::get_data_for_req(connect_req_ptr)\n-                      as *connect_req_data);\n+                      as *ConnectReqData);\n     let result_ch = (*conn_data_ptr).result_ch;\n     log(debug, fmt!(\"tcp_connect result_ch %?\", result_ch));\n     let tcp_stream_ptr =\n         uv::ll::get_stream_handle_from_connect_req(connect_req_ptr);\n     match status {\n       0i32 => {\n         log(debug, ~\"successful tcp connection!\");\n-        core::comm::send(result_ch, conn_success);\n+        core::comm::send(result_ch, ConnSuccess);\n       }\n       _ => {\n         log(debug, ~\"error in tcp_connect_on_connect_cb\");\n         let loop_ptr = uv::ll::get_loop_for_uv_handle(tcp_stream_ptr);\n         let err_data = uv::ll::get_last_err_data(loop_ptr);\n         log(debug, fmt!(\"err_data %? %?\", err_data.err_name,\n                         err_data.err_msg));\n-        core::comm::send(result_ch, conn_failure(err_data));\n+        core::comm::send(result_ch, ConnFailure(err_data));\n         uv::ll::set_data_for_uv_handle(tcp_stream_ptr,\n                                        conn_data_ptr);\n         uv::ll::close(tcp_stream_ptr, stream_error_close_cb);\n@@ -1191,22 +1191,22 @@ extern fn tcp_connect_on_connect_cb(connect_req_ptr: *uv::ll::uv_connect_t,\n     log(debug, ~\"leaving tcp_connect_on_connect_cb\");\n }\n \n-enum conn_attempt {\n-    conn_success,\n-    conn_failure(uv::ll::uv_err_data)\n+enum ConnAttempt {\n+    ConnSuccess,\n+    ConnFailure(uv::ll::uv_err_data)\n }\n \n-type tcp_socket_data = {\n-    reader_po: comm::Port<result::Result<~[u8], tcp_err_data>>,\n-    reader_ch: comm::Chan<result::Result<~[u8], tcp_err_data>>,\n+type TcpSocketData = {\n+    reader_po: comm::Port<result::Result<~[u8], TcpErrData>>,\n+    reader_ch: comm::Chan<result::Result<~[u8], TcpErrData>>,\n     stream_handle_ptr: *uv::ll::uv_tcp_t,\n     connect_req: uv::ll::uv_connect_t,\n     write_req: uv::ll::uv_write_t,\n     iotask: IoTask\n };\n \n-type tcp_buffered_socket_data = {\n-    sock: tcp_socket,\n+type TcpBufferedSocketData = {\n+    sock: TcpSocket,\n     mut buf: ~[u8]\n };\n \n@@ -1333,7 +1333,7 @@ mod test {\n                 hl_loop)\n         };\n         match actual_resp_result.get_err() {\n-          connection_refused => (),\n+          ConnectionRefused => (),\n           _ => fail ~\"unknown error.. expected connection_refused\"\n         }\n     }\n@@ -1379,7 +1379,7 @@ mod test {\n                 hl_loop)\n         };\n         match listen_err {\n-          address_in_use => {\n+          AddressInUse => {\n             assert true;\n           }\n           _ => {\n@@ -1398,7 +1398,7 @@ mod test {\n                             server_port,\n                             hl_loop);\n         match listen_err {\n-          access_denied => {\n+          AccessDenied => {\n             assert true;\n           }\n           _ => {\n@@ -1544,14 +1544,14 @@ mod test {\n         // err check on listen_result\n         if result::is_err(listen_result) {\n             match result::get_err(listen_result) {\n-              generic_listen_err(name, msg) => {\n+              GenericListenErr(name, msg) => {\n                 fail fmt!(\"SERVER: exited abnormally name %s msg %s\",\n                                 name, msg);\n               }\n-              access_denied => {\n+              AccessDenied => {\n                 fail ~\"SERVER: exited abnormally, got access denied..\";\n               }\n-              address_in_use => {\n+              AddressInUse => {\n                 fail ~\"SERVER: exited abnormally, got address in use...\";\n               }\n             }\n@@ -1562,7 +1562,7 @@ mod test {\n     }\n \n     fn run_tcp_test_server_fail(server_ip: ~str, server_port: uint,\n-                          iotask: IoTask) -> tcp_listen_err_data {\n+                          iotask: IoTask) -> TcpListenErrData {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n         let listen_result = listen(server_ip_addr, server_port, 128u, iotask,\n             // on_establish_cb -- called when listener is set up\n@@ -1586,7 +1586,7 @@ mod test {\n     fn run_tcp_test_client(server_ip: ~str, server_port: uint, resp: ~str,\n                           client_ch: comm::Chan<~str>,\n                           iotask: IoTask) -> result::Result<~str,\n-                                                    tcp_connect_err_data> {\n+                                                    TcpConnectErrData> {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n \n         log(debug, ~\"CLIENT: starting..\");\n@@ -1615,7 +1615,7 @@ mod test {\n         }\n     }\n \n-    fn tcp_write_single(sock: tcp_socket, val: ~[u8]) {\n+    fn tcp_write_single(sock: TcpSocket, val: ~[u8]) {\n         let write_result_future = sock.write_future(val);\n         let write_result = write_result_future.get();\n         if result::is_err(write_result) {"}, {"sha": "b1e1209cbb5cfaa733092ee77b62eac4e5f67ae1", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/dbf6abf6bfd0bf2ac17c648d5e2c1edb68099e60/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbf6abf6bfd0bf2ac17c648d5e2c1edb68099e60/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=dbf6abf6bfd0bf2ac17c648d5e2c1edb68099e60", "patch": "@@ -6,39 +6,39 @@ import map::{hashmap, str_hash};\n import io::{Reader, ReaderUtil};\n import dvec::DVec;\n \n-export url, userinfo, query;\n+export Url, userinfo, query;\n export from_str, to_str;\n export get_scheme;\n \n export encode, decode;\n export encode_component, decode_component;\n export encode_form_urlencoded, decode_form_urlencoded;\n \n-type url = {\n+type Url = {\n     scheme: ~str,\n-    user: Option<userinfo>,\n+    user: Option<UserInfo>,\n     host: ~str,\n     port: Option<~str>,\n     path: ~str,\n-    query: query,\n+    query: Query,\n     fragment: Option<~str>\n };\n \n-type userinfo = {\n+type UserInfo = {\n     user: ~str,\n     pass: Option<~str>\n };\n \n-type query = ~[(~str, ~str)];\n+type Query = ~[(~str, ~str)];\n \n-fn url(-scheme: ~str, -user: Option<userinfo>, -host: ~str,\n-       -port: Option<~str>, -path: ~str, -query: query,\n-       -fragment: Option<~str>) -> url {\n+fn url(-scheme: ~str, -user: Option<UserInfo>, -host: ~str,\n+       -port: Option<~str>, -path: ~str, -query: Query,\n+       -fragment: Option<~str>) -> Url {\n     { scheme: scheme, user: user, host: host, port: port,\n      path: path, query: query, fragment: fragment }\n }\n \n-fn userinfo(-user: ~str, -pass: Option<~str>) -> userinfo {\n+fn userinfo(-user: ~str, -pass: Option<~str>) -> UserInfo {\n     {user: user, pass: pass}\n }\n \n@@ -290,7 +290,7 @@ fn split_char_first(s: ~str, c: char) -> (~str, ~str) {\n     }\n }\n \n-fn userinfo_from_str(uinfo: ~str) -> userinfo {\n+fn userinfo_from_str(uinfo: ~str) -> UserInfo {\n     let (user, p) = split_char_first(uinfo, ':');\n     let pass = if str::len(p) == 0 {\n         option::None\n@@ -300,7 +300,7 @@ fn userinfo_from_str(uinfo: ~str) -> userinfo {\n     return userinfo(user, pass);\n }\n \n-fn userinfo_to_str(-userinfo: userinfo) -> ~str {\n+fn userinfo_to_str(-userinfo: UserInfo) -> ~str {\n     if option::is_some(userinfo.pass) {\n         return str::concat(~[copy userinfo.user, ~\":\",\n                           option::unwrap(copy userinfo.pass),\n@@ -310,14 +310,14 @@ fn userinfo_to_str(-userinfo: userinfo) -> ~str {\n     }\n }\n \n-impl userinfo : Eq {\n-    pure fn eq(&&other: userinfo) -> bool {\n+impl UserInfo : Eq {\n+    pure fn eq(&&other: UserInfo) -> bool {\n         self.user == other.user && self.pass == other.pass\n     }\n }\n \n-fn query_from_str(rawquery: ~str) -> query {\n-    let mut query: query = ~[];\n+fn query_from_str(rawquery: ~str) -> Query {\n+    let mut query: Query = ~[];\n     if str::len(rawquery) != 0 {\n         for str::split_char(rawquery, '&').each |p| {\n             let (k, v) = split_char_first(p, '=');\n@@ -327,7 +327,7 @@ fn query_from_str(rawquery: ~str) -> query {\n     return query;\n }\n \n-fn query_to_str(query: query) -> ~str {\n+fn query_to_str(query: Query) -> ~str {\n     let mut strvec = ~[];\n     for query.each |kv| {\n         let (k, v) = copy kv;\n@@ -363,47 +363,47 @@ fn get_scheme(rawurl: ~str) -> result::Result<(~str, ~str), @~str> {\n     return result::Err(@~\"url: Scheme must be terminated with a colon.\");\n }\n \n-enum input {\n-    digit, // all digits\n-    hex, // digits and letters a-f\n-    unreserved // all other legal characters\n+enum Input {\n+    Digit, // all digits\n+    Hex, // digits and letters a-f\n+    Unreserved // all other legal characters\n }\n \n-impl input: Eq {\n-    pure fn eq(&&other: input) -> bool {\n+impl Input: Eq {\n+    pure fn eq(&&other: Input) -> bool {\n         match (self, other) {\n-            (digit, digit) => true,\n-            (hex, hex) => true,\n-            (unreserved, unreserved) => true,\n-            (digit, _) => false,\n-            (hex, _) => false,\n-            (unreserved, _) => false\n+            (Digit, Digit) => true,\n+            (Hex, Hex) => true,\n+            (Unreserved, Unreserved) => true,\n+            (Digit, _) => false,\n+            (Hex, _) => false,\n+            (Unreserved, _) => false\n         }\n     }\n }\n \n // returns userinfo, host, port, and unparsed part, or an error\n fn get_authority(rawurl: ~str) ->\n-    result::Result<(Option<userinfo>, ~str, Option<~str>, ~str), @~str> {\n+    result::Result<(Option<UserInfo>, ~str, Option<~str>, ~str), @~str> {\n     if !str::starts_with(rawurl, ~\"//\") {\n         // there is no authority.\n         return result::Ok((option::None, ~\"\", option::None, copy rawurl));\n     }\n \n-    enum state {\n-        start, // starting state\n-        pass_host_port, // could be in user or port\n-        ip6_port, // either in ipv6 host or port\n-        ip6_host, // are in an ipv6 host\n-        in_host, // are in a host - may be ipv6, but don't know yet\n-        in_port // are in port\n+    enum State {\n+        Start, // starting state\n+        PassHostPort, // could be in user or port\n+        Ip6Port, // either in ipv6 host or port\n+        Ip6Host, // are in an ipv6 host\n+        InHost, // are in a host - may be ipv6, but don't know yet\n+        InPort // are in port\n     }\n \n     let len = str::len(rawurl);\n-    let mut st : state = start;\n-    let mut in : input = digit; // most restricted, start here.\n+    let mut st : State = Start;\n+    let mut in : Input = Digit; // most restricted, start here.\n \n-    let mut userinfo : Option<userinfo> = option::None;\n+    let mut userinfo : Option<UserInfo> = option::None;\n     let mut host : ~str = ~\"\";\n     let mut port : option::Option<~str> = option::None;\n \n@@ -417,13 +417,13 @@ fn get_authority(rawurl: ~str) ->\n         match c {\n           '0' to '9' => (),\n           'A' to 'F' | 'a' to 'f' => {\n-            if in == digit {\n-                in = hex;\n+            if in == Digit {\n+                in = Hex;\n             }\n           }\n           'G' to 'Z' | 'g' to 'z' | '-' | '.' | '_' | '~' | '%' |\n           '&' |'\\'' | '(' | ')' | '+' | '!' | '*' | ',' | ';' | '=' => {\n-            in = unreserved;\n+            in = Unreserved;\n           }\n           ':' | '@' | '?' | '#' | '/' => {\n             // separators, don't change anything\n@@ -438,62 +438,62 @@ fn get_authority(rawurl: ~str) ->\n           ':' => {\n             colon_count += 1;\n             match st {\n-              start => {\n+              Start => {\n                 pos = i;\n-                st = pass_host_port;\n+                st = PassHostPort;\n               }\n-              pass_host_port => {\n+              PassHostPort => {\n                 // multiple colons means ipv6 address.\n-                if in == unreserved {\n+                if in == Unreserved {\n                     return result::Err(\n                         @~\"Illegal characters in IPv6 address.\");\n                 }\n-                st = ip6_host;\n+                st = Ip6Host;\n               }\n-              in_host => {\n+              InHost => {\n                 pos = i;\n                 // can't be sure whether this is an ipv6 address or a port\n-                if in == unreserved {\n+                if in == Unreserved {\n                     return result::Err(@~\"Illegal characters in authority.\");\n                 }\n-                st = ip6_port;\n+                st = Ip6Port;\n               }\n-              ip6_port => {\n-                if in == unreserved {\n+              Ip6Port => {\n+                if in == Unreserved {\n                     return result::Err(@~\"Illegal characters in authority.\");\n                 }\n-                st = ip6_host;\n+                st = Ip6Host;\n               }\n-              ip6_host => {\n+              Ip6Host => {\n                 if colon_count > 7 {\n                     host = str::slice(rawurl, begin, i);\n                     pos = i;\n-                    st = in_port;\n+                    st = InPort;\n                 }\n               }\n               _ => {\n                 return result::Err(@~\"Invalid ':' in authority.\");\n               }\n             }\n-            in = digit; // reset input class\n+            in = Digit; // reset input class\n           }\n \n           '@' => {\n-            in = digit; // reset input class\n+            in = Digit; // reset input class\n             colon_count = 0; // reset count\n             match st {\n-              start => {\n+              Start => {\n                 let user = str::slice(rawurl, begin, i);\n                 userinfo = option::Some({user : user,\n                                          pass: option::None});\n-                st = in_host;\n+                st = InHost;\n               }\n-              pass_host_port => {\n+              PassHostPort => {\n                 let user = str::slice(rawurl, begin, pos);\n                 let pass = str::slice(rawurl, pos+1, i);\n                 userinfo = option::Some({user: user,\n                                          pass: option::Some(pass)});\n-                st = in_host;\n+                st = InHost;\n               }\n               _ => {\n                 return result::Err(@~\"Invalid '@' in authority.\");\n@@ -520,25 +520,25 @@ fn get_authority(rawurl: ~str) ->\n \n     // finish up\n     match st {\n-      start => {\n+      Start => {\n         if host_is_end_plus_one() {\n             host = str::slice(rawurl, begin, end+1);\n         } else {\n             host = str::slice(rawurl, begin, end);\n         }\n       }\n-      pass_host_port | ip6_port => {\n-        if in != digit {\n+      PassHostPort | Ip6Port => {\n+        if in != Digit {\n             return result::Err(@~\"Non-digit characters in port.\");\n         }\n         host = str::slice(rawurl, begin, pos);\n         port = option::Some(str::slice(rawurl, pos+1, end));\n       }\n-      ip6_host | in_host => {\n+      Ip6Host | InHost => {\n         host = str::slice(rawurl, begin, end);\n       }\n-      in_port => {\n-        if in != digit {\n+      InPort => {\n+        if in != Digit {\n             return result::Err(@~\"Non-digit characters in port.\");\n         }\n         port = option::Some(str::slice(rawurl, pos+1, end));\n@@ -584,7 +584,7 @@ fn get_path(rawurl: ~str, authority : bool) ->\n \n // returns the parsed query and the fragment, if present\n fn get_query_fragment(rawurl: ~str) ->\n-    result::Result<(query, Option<~str>), @~str> {\n+    result::Result<(Query, Option<~str>), @~str> {\n     if !str::starts_with(rawurl, ~\"?\") {\n         if str::starts_with(rawurl, ~\"#\") {\n             let f = decode_component(str::slice(rawurl,\n@@ -615,7 +615,7 @@ fn get_query_fragment(rawurl: ~str) ->\n  *\n  */\n \n-fn from_str(rawurl: ~str) -> result::Result<url, ~str> {\n+fn from_str(rawurl: ~str) -> result::Result<Url, ~str> {\n     // scheme\n     let mut schm = get_scheme(rawurl);\n     if result::is_err(schm) {\n@@ -664,7 +664,7 @@ fn from_str(rawurl: ~str) -> result::Result<url, ~str> {\n  * result in just \"http://somehost.com\".\n  *\n  */\n-fn to_str(url: url) -> ~str {\n+fn to_str(url: Url) -> ~str {\n     let user = if option::is_some(url.user) {\n       userinfo_to_str(option::unwrap(copy url.user))\n     } else {\n@@ -695,7 +695,7 @@ fn to_str(url: url) -> ~str {\n                       fragment]);\n }\n \n-impl url: to_str::ToStr {\n+impl Url: to_str::ToStr {\n     fn to_str() -> ~str {\n         to_str(self)\n     }"}, {"sha": "f8a61cda0de751f8cade57438249acc593d73996", "filename": "src/libstd/std.rc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbf6abf6bfd0bf2ac17c648d5e2c1edb68099e60/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/dbf6abf6bfd0bf2ac17c648d5e2c1edb68099e60/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=dbf6abf6bfd0bf2ac17c648d5e2c1edb68099e60", "patch": "@@ -30,9 +30,13 @@ export cell;\n \n // General io and system-services modules\n \n+#[warn(non_camel_case_types)]\n mod net;\n+#[warn(non_camel_case_types)]\n mod net_ip;\n+#[warn(non_camel_case_types)]\n mod net_tcp;\n+#[warn(non_camel_case_types)]\n mod net_url;\n \n // libuv modules"}]}