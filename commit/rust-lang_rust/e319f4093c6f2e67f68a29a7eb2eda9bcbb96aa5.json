{"sha": "e319f4093c6f2e67f68a29a7eb2eda9bcbb96aa5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzMTlmNDA5M2M2ZjJlNjdmNjhhMjlhN2ViMmVkYTliY2JiOTZhYTU=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-09-22T13:37:43Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-09-25T12:02:39Z"}, "message": "Remove now dead code.", "tree": {"sha": "75937c8d2adfa0464584143bdbbdf516d4c3c532", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75937c8d2adfa0464584143bdbbdf516d4c3c532"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e319f4093c6f2e67f68a29a7eb2eda9bcbb96aa5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e319f4093c6f2e67f68a29a7eb2eda9bcbb96aa5", "html_url": "https://github.com/rust-lang/rust/commit/e319f4093c6f2e67f68a29a7eb2eda9bcbb96aa5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e319f4093c6f2e67f68a29a7eb2eda9bcbb96aa5/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9d10c1628faea4b2b55a1d31b7ba7075edba018", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9d10c1628faea4b2b55a1d31b7ba7075edba018", "html_url": "https://github.com/rust-lang/rust/commit/d9d10c1628faea4b2b55a1d31b7ba7075edba018"}], "stats": {"total": 300, "additions": 1, "deletions": 299}, "files": [{"sha": "9e261d60248917ced17645bdabe13363e3048696", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 1, "deletions": 299, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/e319f4093c6f2e67f68a29a7eb2eda9bcbb96aa5/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e319f4093c6f2e67f68a29a7eb2eda9bcbb96aa5/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=e319f4093c6f2e67f68a29a7eb2eda9bcbb96aa5", "patch": "@@ -544,19 +544,6 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n             }\n         }\n     }\n-\n-    #[cfg(not_anymore)]\n-    fn borrow(&mut self,\n-              context: Context,\n-              location: Location,\n-              bk: BorrowKind,\n-              lvalue_span: (&Lvalue<'gcx>, Span),\n-              flow_state: &InProgress<'b, 'gcx>) {\n-        debug!(\"borrow location: {:?} lvalue: {:?} span: {:?}\",\n-               location, lvalue_span.0, lvalue_span.1);\n-        self.check_if_path_is_moved(context, lvalue_span, flow_state);\n-        self.check_for_conflicting_loans(context, location, bk, lvalue_span, flow_state);\n-    }\n }\n \n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n@@ -697,64 +684,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n             }\n         }\n     }\n-\n-    #[cfg(not_anymore)]\n-    fn check_for_conflicting_loans(&mut self,\n-                                   context: Context,\n-                                   _location: Location,\n-                                   _bk: BorrowKind,\n-                                   lvalue_span: (&Lvalue<'gcx>, Span),\n-                                   flow_state: &InProgress<'b, 'gcx>) {\n-        // NOTE FIXME: The analogous code in old borrowck\n-        // check_loans.rs is careful to iterate over every *issued*\n-        // loan, as opposed to just the in scope ones.\n-        //\n-        // (Or if you prefer, all the *other* iterations over loans\n-        // only consider loans that are in scope of some given\n-        // region::Scope)\n-        //\n-        // The (currently skeletal) code here does not encode such a\n-        // distinction, which means it is almost certainly over\n-        // looking something.\n-        //\n-        // (It is probably going to reject code that should be\n-        // accepted, I suspect, by treated issued-but-out-of-scope\n-        // loans as issued-and-in-scope, and thus causing them to\n-        // interfere with other loans.)\n-        //\n-        // However, I just want to get something running, especially\n-        // since I am trying to move into new territory with NLL, so\n-        // lets get this going first, and then address the issued vs\n-        // in-scope distinction later.\n-\n-        let state = &flow_state.borrows;\n-        let data = &state.base_results.operator().borrows();\n-\n-        debug!(\"check_for_conflicting_loans location: {:?}\", _location);\n-\n-        // does any loan generated here conflict with a previously issued loan?\n-        let mut loans_generated = 0;\n-        for (g, gen) in state.elems_generated().map(|g| (g, &data[g])) {\n-            loans_generated += 1;\n-            for (i, issued) in state.elems_incoming().map(|i| (i, &data[i])) {\n-                debug!(\"check_for_conflicting_loans gen: {:?} issued: {:?} conflicts: {}\",\n-                       (g, gen, self.base_path(&gen.lvalue),\n-                        self.restrictions(&gen.lvalue).collect::<Vec<_>>()),\n-                       (i, issued, self.base_path(&issued.lvalue),\n-                        self.restrictions(&issued.lvalue).collect::<Vec<_>>()),\n-                       self.conflicts_with(gen, issued));\n-                if self.conflicts_with(gen, issued) {\n-                    self.report_conflicting_borrow(context, lvalue_span, gen, issued);\n-                }\n-            }\n-        }\n-\n-        // MIR statically ensures each statement gens *at most one*\n-        // loan; mutual conflict (within a statement) can't arise.\n-        //\n-        // As safe-guard, assert that above property actually holds.\n-        assert!(loans_generated <= 1);\n-    } }\n+}\n \n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n     fn each_borrow_involving_path<F>(&mut self,\n@@ -954,194 +884,6 @@ mod prefixes {\n             }\n         }\n     }\n-    }\n-\n-#[cfg(not_anymore)]\n-mod restrictions {\n-    use super::MirBorrowckCtxt;\n-\n-    use rustc::hir;\n-    use rustc::ty::{self, TyCtxt};\n-    use rustc::mir::{Lvalue, Mir, ProjectionElem};\n-\n-    pub(super) struct Restrictions<'c, 'tcx: 'c> {\n-        mir: &'c Mir<'tcx>,\n-        tcx: TyCtxt<'c, 'tcx, 'tcx>,\n-        lvalue_stack: Vec<&'c Lvalue<'tcx>>,\n-    }\n-\n-    impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n-        pub(super) fn restrictions<'d>(&self,\n-                                       lvalue: &'d Lvalue<'gcx>)\n-                                       -> Restrictions<'d, 'gcx> where 'b: 'd\n-        {\n-            let lvalue_stack = if self.has_restrictions(lvalue) { vec![lvalue] } else { vec![] };\n-            Restrictions { lvalue_stack, mir: self.mir, tcx: self.tcx }\n-        }\n-\n-        fn has_restrictions(&self, lvalue: &Lvalue<'gcx>) -> bool {\n-            let mut cursor = lvalue;\n-            loop {\n-                let proj = match *cursor {\n-                    Lvalue::Local(_) => return true,\n-                    Lvalue::Static(_) => return false,\n-                    Lvalue::Projection(ref proj) => proj,\n-                };\n-                match proj.elem {\n-                    ProjectionElem::Index(..) |\n-                    ProjectionElem::ConstantIndex { .. } |\n-                    ProjectionElem::Downcast(..) |\n-                    ProjectionElem::Subslice { .. } |\n-                    ProjectionElem::Field(_/*field*/, _/*ty*/) => {\n-                        cursor = &proj.base;\n-                        continue;\n-                    }\n-                    ProjectionElem::Deref => {\n-                        let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n-                        match ty.sty {\n-                            ty::TyRawPtr(_) => {\n-                                return false;\n-                            }\n-                            ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n-                                // FIXME: do I need to check validity of\n-                                // region here though? (I think the original\n-                                // check_loans code did, like readme says)\n-                                return false;\n-                            }\n-                            ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n-                                cursor = &proj.base;\n-                                continue;\n-                            }\n-                            ty::TyAdt(..) if ty.is_box() => {\n-                                cursor = &proj.base;\n-                                continue;\n-                            }\n-                            _ => {\n-                                panic!(\"unknown type fed to Projection Deref.\");\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    impl<'c, 'tcx> Iterator for Restrictions<'c, 'tcx> {\n-        type Item = &'c Lvalue<'tcx>;\n-        fn next(&mut self) -> Option<Self::Item> {\n-            'pop: loop {\n-                let lvalue = match self.lvalue_stack.pop() {\n-                    None => return None,\n-                    Some(lvalue) => lvalue,\n-                };\n-\n-                // `lvalue` may not be a restriction itself, but may\n-                // hold one further down (e.g. we never return\n-                // downcasts here, but may return a base of a\n-                // downcast).\n-                //\n-                // Also, we need to enqueue any additional\n-                // subrestrictions that it implies, since we can only\n-                // return from from this call alone.\n-\n-                let mut cursor = lvalue;\n-                'cursor: loop {\n-                    let proj = match *cursor {\n-                        Lvalue::Local(_) => return Some(cursor), // search yielded this leaf\n-                        Lvalue::Static(_) => continue 'pop, // fruitless leaf; try next on stack\n-                        Lvalue::Projection(ref proj) => proj,\n-                    };\n-\n-                    match proj.elem {\n-                        ProjectionElem::Field(_/*field*/, _/*ty*/) => {\n-                            // FIXME: add union handling\n-                            self.lvalue_stack.push(&proj.base);\n-                            return Some(cursor);\n-                        }\n-                        ProjectionElem::Downcast(..) |\n-                        ProjectionElem::Subslice { .. } |\n-                        ProjectionElem::ConstantIndex { .. } |\n-                        ProjectionElem::Index(_) => {\n-                            cursor = &proj.base;\n-                            continue 'cursor;\n-                        }\n-                        ProjectionElem::Deref => {\n-                            // (handled below)\n-                        }\n-                    }\n-\n-                    assert_eq!(proj.elem, ProjectionElem::Deref);\n-\n-                    let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n-                    match ty.sty {\n-                        ty::TyRawPtr(_) => {\n-                            // borrowck ignores raw ptrs; treat analogous to imm borrow\n-                            continue 'pop;\n-                        }\n-                        // R-Deref-Imm-Borrowed\n-                        ty::TyRef(_/*rgn*/, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n-                            // immutably-borrowed referents do not\n-                            // have recursively-implied restrictions\n-                            // (because preventing actions on `*LV`\n-                            // does nothing about aliases like `*LV1`)\n-\n-                            // FIXME: do I need to check validity of\n-                            // `_r` here though? (I think the original\n-                            // check_loans code did, like the readme\n-                            // says)\n-\n-                            // (And do I *really* not have to\n-                            // recursively process the `base` as a\n-                            // further search here? Leaving this `if\n-                            // false` here as a hint to look at this\n-                            // again later.\n-                            //\n-                            // Ah, it might be because the\n-                            // restrictions are distinct from the path\n-                            // substructure. Note that there is a\n-                            // separate loop over the path\n-                            // substructure in fn\n-                            // each_borrow_involving_path, for better\n-                            // or for worse.\n-\n-                            if false {\n-                                cursor = &proj.base;\n-                                continue 'cursor;\n-                            } else {\n-                                continue 'pop;\n-                            }\n-                        }\n-\n-                        // R-Deref-Mut-Borrowed\n-                        ty::TyRef(_/*rgn*/, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n-                            // mutably-borrowed referents are\n-                            // themselves restricted.\n-\n-                            // FIXME: do I need to check validity of\n-                            // `_r` here though? (I think the original\n-                            // check_loans code did, like the readme\n-                            // says)\n-\n-                            // schedule base for future iteration.\n-                            self.lvalue_stack.push(&proj.base);\n-                            return Some(cursor); // search yielded interior node\n-                        }\n-\n-                        // R-Deref-Send-Pointer\n-                        ty::TyAdt(..) if ty.is_box() => {\n-                            // borrowing interior of a box implies that\n-                            // its base can no longer be mutated (o/w box\n-                            // storage would be freed)\n-                            self.lvalue_stack.push(&proj.base);\n-                            return Some(cursor); // search yielded interior node\n-                        }\n-\n-                        _ => panic!(\"unknown type fed to Projection Deref.\"),\n-                    }\n-                }\n-            }\n-        }\n-    }\n }\n \n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n@@ -1319,26 +1061,6 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n }\n \n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n-    // FIXME: needs to be able to express errors analogous to check_loans.rs\n-    #[cfg(not_anymore)]\n-    fn conflicts_with(&self, loan1: &BorrowData<'gcx>, loan2: &BorrowData<'gcx>) -> bool {\n-        if loan1.compatible_with(loan2.kind) { return false; }\n-\n-        let loan2_base_path = self.base_path(&loan2.lvalue);\n-        for restricted in self.restrictions(&loan1.lvalue) {\n-            if restricted != loan2_base_path { continue; }\n-            return true;\n-        }\n-\n-        let loan1_base_path = self.base_path(&loan1.lvalue);\n-        for restricted in self.restrictions(&loan2.lvalue) {\n-            if restricted != loan1_base_path { continue; }\n-            return true;\n-        }\n-\n-        return false;\n-    }\n-\n     // FIXME (#16118): function intended to allow the borrow checker\n     // to be less precise in its handling of Box while still allowing\n     // moves out of a Box. They should be removed when/if we stop\n@@ -1518,28 +1240,8 @@ impl<BD> FlowInProgress<BD> where BD: BitDenotation {\n         self.curr_state.subtract(&self.stmt_kill);\n     }\n \n-    #[allow(dead_code)]\n-    fn elems_generated(&self) -> indexed_set::Elems<BD::Idx> {\n-        let univ = self.base_results.sets().bits_per_block();\n-        self.stmt_gen.elems(univ)\n-    }\n-\n     fn elems_incoming(&self) -> indexed_set::Elems<BD::Idx> {\n         let univ = self.base_results.sets().bits_per_block();\n         self.curr_state.elems(univ)\n     }\n }\n-\n-impl<'tcx> BorrowData<'tcx> {\n-    #[allow(dead_code)]\n-    fn compatible_with(&self, bk: BorrowKind) -> bool {\n-        match (self.kind, bk) {\n-            (BorrowKind::Shared, BorrowKind::Shared) => true,\n-\n-            (BorrowKind::Mut, _) |\n-            (BorrowKind::Unique, _) |\n-            (_, BorrowKind::Mut) |\n-            (_, BorrowKind::Unique) => false,\n-        }\n-    }\n-}"}]}