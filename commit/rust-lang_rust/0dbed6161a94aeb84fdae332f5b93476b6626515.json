{"sha": "0dbed6161a94aeb84fdae332f5b93476b6626515", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkYmVkNjE2MWE5NGFlYjg0ZmRhZTMzMmY1YjkzNDc2YjY2MjY1MTU=", "commit": {"author": {"name": "Christiaan Dirkx", "email": "christiaan@dirkx.email", "date": "2021-03-12T20:32:44Z"}, "committer": {"name": "Christiaan Dirkx", "email": "christiaan@dirkx.email", "date": "2021-03-26T11:38:26Z"}, "message": "Rework `std::sys::windows::alloc`\n\nAdd documentation to the system functions and `SAFETY` comments.\nRefactored helper functions, fixing the correctness of `get_header`.", "tree": {"sha": "59581a3ef4be426df652c9964151b0f9b8403a22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59581a3ef4be426df652c9964151b0f9b8403a22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0dbed6161a94aeb84fdae332f5b93476b6626515", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0dbed6161a94aeb84fdae332f5b93476b6626515", "html_url": "https://github.com/rust-lang/rust/commit/0dbed6161a94aeb84fdae332f5b93476b6626515", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0dbed6161a94aeb84fdae332f5b93476b6626515/comments", "author": {"login": "CDirkx", "id": 11176562, "node_id": "MDQ6VXNlcjExMTc2NTYy", "avatar_url": "https://avatars.githubusercontent.com/u/11176562?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CDirkx", "html_url": "https://github.com/CDirkx", "followers_url": "https://api.github.com/users/CDirkx/followers", "following_url": "https://api.github.com/users/CDirkx/following{/other_user}", "gists_url": "https://api.github.com/users/CDirkx/gists{/gist_id}", "starred_url": "https://api.github.com/users/CDirkx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CDirkx/subscriptions", "organizations_url": "https://api.github.com/users/CDirkx/orgs", "repos_url": "https://api.github.com/users/CDirkx/repos", "events_url": "https://api.github.com/users/CDirkx/events{/privacy}", "received_events_url": "https://api.github.com/users/CDirkx/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CDirkx", "id": 11176562, "node_id": "MDQ6VXNlcjExMTc2NTYy", "avatar_url": "https://avatars.githubusercontent.com/u/11176562?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CDirkx", "html_url": "https://github.com/CDirkx", "followers_url": "https://api.github.com/users/CDirkx/followers", "following_url": "https://api.github.com/users/CDirkx/following{/other_user}", "gists_url": "https://api.github.com/users/CDirkx/gists{/gist_id}", "starred_url": "https://api.github.com/users/CDirkx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CDirkx/subscriptions", "organizations_url": "https://api.github.com/users/CDirkx/orgs", "repos_url": "https://api.github.com/users/CDirkx/repos", "events_url": "https://api.github.com/users/CDirkx/events{/privacy}", "received_events_url": "https://api.github.com/users/CDirkx/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db492ecd5ba6bd82205612cebb9034710653f0c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/db492ecd5ba6bd82205612cebb9034710653f0c2", "html_url": "https://github.com/rust-lang/rust/commit/db492ecd5ba6bd82205612cebb9034710653f0c2"}], "stats": {"total": 205, "additions": 173, "deletions": 32}, "files": [{"sha": "8ef256a06d4acc670439054efeaa6e0864cb4bcd", "filename": "library/std/src/sys/windows/alloc.rs", "status": "modified", "additions": 164, "deletions": 25, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/0dbed6161a94aeb84fdae332f5b93476b6626515/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbed6161a94aeb84fdae332f5b93476b6626515/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc.rs?ref=0dbed6161a94aeb84fdae332f5b93476b6626515", "patch": "@@ -1,61 +1,200 @@\n+#![deny(unsafe_op_in_unsafe_fn)]\n+\n use crate::alloc::{GlobalAlloc, Layout, System};\n+use crate::ptr;\n use crate::sys::c;\n use crate::sys_common::alloc::{realloc_fallback, MIN_ALIGN};\n \n-#[repr(C)]\n-struct Header(*mut u8);\n+#[cfg(test)]\n+mod tests;\n \n-unsafe fn get_header<'a>(ptr: *mut u8) -> &'a mut Header {\n-    &mut *(ptr as *mut Header).offset(-1)\n-}\n+// Heap memory management on Windows is done by using the system Heap API (heapapi.h)\n+// See https://docs.microsoft.com/windows/win32/api/heapapi/\n+\n+// Flag to indicate that the memory returned by `HeapAlloc` should be zeroed.\n+const HEAP_ZERO_MEMORY: c::DWORD = 0x00000008;\n+\n+extern \"system\" {\n+    // Get a handle to the default heap of the current process, or null if the operation fails.\n+    //\n+    // See https://docs.microsoft.com/windows/win32/api/heapapi/nf-heapapi-getprocessheap\n+    fn GetProcessHeap() -> c::HANDLE;\n+\n+    // Allocate a block of `dwBytes` bytes of memory from a given heap `hHeap`.\n+    // The allocated memory may be uninitialized, or zeroed if `dwFlags` is\n+    // set to `HEAP_ZERO_MEMORY`.\n+    //\n+    // Returns a pointer to the newly-allocated memory or null if the operation fails.\n+    // The returned pointer will be aligned to at least `MIN_ALIGN`.\n+    //\n+    // SAFETY:\n+    //  - `hHeap` must be a non-null handle returned by `GetProcessHeap`.\n+    //  - `dwFlags` must be set to either zero or `HEAP_ZERO_MEMORY`.\n+    //\n+    // Note that `dwBytes` is allowed to be zero, contrary to some other allocators.\n+    //\n+    // See https://docs.microsoft.com/windows/win32/api/heapapi/nf-heapapi-heapalloc\n+    fn HeapAlloc(hHeap: c::HANDLE, dwFlags: c::DWORD, dwBytes: c::SIZE_T) -> c::LPVOID;\n \n-unsafe fn align_ptr(ptr: *mut u8, align: usize) -> *mut u8 {\n-    let aligned = ptr.add(align - (ptr as usize & (align - 1)));\n-    *get_header(aligned) = Header(ptr);\n-    aligned\n+    // Reallocate a block of memory behind a given pointer `lpMem` from a given heap `hHeap`,\n+    // to a block of at least `dwBytes` bytes, either shrinking the block in place,\n+    // or allocating at a new location, copying memory, and freeing the original location.\n+    //\n+    // Returns a pointer to the reallocated memory or null if the operation fails.\n+    // The returned pointer will be aligned to at least `MIN_ALIGN`.\n+    // If the operation fails the given block will never have been freed.\n+    //\n+    // SAFETY:\n+    //  - `hHeap` must be a non-null handle returned by `GetProcessHeap`.\n+    //  - `dwFlags` must be set to zero.\n+    //  - `lpMem` must be a non-null pointer to an allocated block returned by `HeapAlloc` or\n+    //     `HeapReAlloc`, that has not already been freed.\n+    // If the block was successfully reallocated at a new location, pointers pointing to\n+    // the freed memory, such as `lpMem`, must not be dereferenced ever again.\n+    //\n+    // Note that `dwBytes` is allowed to be zero, contrary to some other allocators.\n+    //\n+    // See https://docs.microsoft.com/windows/win32/api/heapapi/nf-heapapi-heaprealloc\n+    fn HeapReAlloc(\n+        hHeap: c::HANDLE,\n+        dwFlags: c::DWORD,\n+        lpMem: c::LPVOID,\n+        dwBytes: c::SIZE_T,\n+    ) -> c::LPVOID;\n+\n+    // Free a block of memory behind a given pointer `lpMem` from a given heap `hHeap`.\n+    // Returns a nonzero value if the operation is successful, and zero if the operation fails.\n+    //\n+    // SAFETY:\n+    //  - `dwFlags` must be set to zero.\n+    //  - `lpMem` must be a pointer to an allocated block returned by `HeapAlloc` or `HeapReAlloc`,\n+    //     that has not already been freed.\n+    // If the block was successfully freed, pointers pointing to the freed memory, such as `lpMem`,\n+    // must not be dereferenced ever again.\n+    //\n+    // Note that both `hHeap` is allowed to be any value, and `lpMem` is allowed to be null,\n+    // both of which will not cause the operation to fail.\n+    //\n+    // See https://docs.microsoft.com/windows/win32/api/heapapi/nf-heapapi-heapfree\n+    fn HeapFree(hHeap: c::HANDLE, dwFlags: c::DWORD, lpMem: c::LPVOID) -> c::BOOL;\n }\n \n+// Header containing a pointer to the start of an allocated block.\n+// SAFETY: size and alignment must be <= `MIN_ALIGN`.\n+#[repr(C)]\n+struct Header(*mut u8);\n+\n+// Allocates a block of optionally zeroed memory for a given `layout`.\n+// Returns a pointer satisfying the guarantees of `System` about allocated pointers.\n #[inline]\n-unsafe fn allocate_with_flags(layout: Layout, flags: c::DWORD) -> *mut u8 {\n-    if layout.align() <= MIN_ALIGN {\n-        return c::HeapAlloc(c::GetProcessHeap(), flags, layout.size()) as *mut u8;\n+unsafe fn allocate(layout: Layout, zeroed: bool) -> *mut u8 {\n+    let heap = unsafe { GetProcessHeap() };\n+    if heap.is_null() {\n+        // Allocation has failed, could not get the current process heap.\n+        return ptr::null_mut();\n     }\n \n-    let size = layout.size() + layout.align();\n-    let ptr = c::HeapAlloc(c::GetProcessHeap(), flags, size);\n-    if ptr.is_null() { ptr as *mut u8 } else { align_ptr(ptr as *mut u8, layout.align()) }\n+    // Allocated memory will be either zeroed or uninitialized.\n+    let flags = if zeroed { HEAP_ZERO_MEMORY } else { 0 };\n+\n+    if layout.align() <= MIN_ALIGN {\n+        // SAFETY: `heap` is a non-null handle returned by `GetProcessHeap`.\n+        // The returned pointer points to the start of an allocated block.\n+        unsafe { HeapAlloc(heap, flags, layout.size()) as *mut u8 }\n+    } else {\n+        // Allocate extra padding in order to be able to satisfy the alignment.\n+        let total = layout.align() + layout.size();\n+\n+        // SAFETY: `heap` is a non-null handle returned by `GetProcessHeap`.\n+        let ptr = unsafe { HeapAlloc(heap, flags, total) as *mut u8 };\n+        if ptr.is_null() {\n+            // Allocation has failed.\n+            return ptr::null_mut();\n+        }\n+\n+        // Create a correctly aligned pointer offset from the start of the allocated block,\n+        // and write a header before it.\n+\n+        let offset = layout.align() - (ptr as usize & (layout.align() - 1));\n+        // SAFETY: `MIN_ALIGN` <= `offset` <= `layout.align()` and the size of the allocated\n+        // block is `layout.align() + layout.size()`. `aligned` will thus be a correctly aligned\n+        // pointer inside the allocated block with at least `layout.size()` bytes after it and at\n+        // least `MIN_ALIGN` bytes of padding before it.\n+        let aligned = unsafe { ptr.add(offset) };\n+        // SAFETY: Because the size and alignment of a header is <= `MIN_ALIGN` and `aligned`\n+        // is aligned to at least `MIN_ALIGN` and has at least `MIN_ALIGN` bytes of padding before\n+        // it, it is safe to write a header directly before it.\n+        unsafe { ptr::write((aligned as *mut Header).offset(-1), Header(ptr)) };\n+\n+        // SAFETY: The returned pointer does not point to the to the start of an allocated block,\n+        // but there is a header readable directly before it containing the location of the start\n+        // of the block.\n+        aligned\n+    }\n }\n \n+// All pointers returned by this allocator have, in addition to the guarantees of `GlobalAlloc`, the\n+// following properties:\n+//\n+// If the pointer was allocated or reallocated with a `layout` specifying an alignment <= `MIN_ALIGN`\n+// the pointer will be aligned to at least `MIN_ALIGN` and point to the start of the allocated block.\n+//\n+// If the pointer was allocated or reallocated with a `layout` specifying an alignment > `MIN_ALIGN`\n+// the pointer will be aligned to the specified alignment and not point to the start of the allocated block.\n+// Instead there will be a header readable directly before the returned pointer, containing the actual\n+// location of the start of the block.\n #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n unsafe impl GlobalAlloc for System {\n     #[inline]\n     unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-        allocate_with_flags(layout, 0)\n+        // SAFETY: pointers returned by `allocate` satisfy the guarantees of `System`\n+        unsafe { allocate(layout, false) }\n     }\n \n     #[inline]\n     unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n-        allocate_with_flags(layout, c::HEAP_ZERO_MEMORY)\n+        // SAFETY: pointers returned by `allocate` satisfy the guarantees of `System`\n+        unsafe { allocate(layout, true) }\n     }\n \n     #[inline]\n     unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n-        if layout.align() <= MIN_ALIGN {\n-            let err = c::HeapFree(c::GetProcessHeap(), 0, ptr as c::LPVOID);\n-            debug_assert!(err != 0, \"Failed to free heap memory: {}\", c::GetLastError());\n-        } else {\n-            let header = get_header(ptr);\n-            let err = c::HeapFree(c::GetProcessHeap(), 0, header.0 as c::LPVOID);\n+        let block = {\n+            if layout.align() <= MIN_ALIGN {\n+                ptr\n+            } else {\n+                // The location of the start of the block is stored in the padding before `ptr`.\n+\n+                // SAFETY: Because of the contract of `System`, `ptr` is guaranteed to be non-null\n+                // and have a header readable directly before it.\n+                unsafe { ptr::read((ptr as *mut Header).offset(-1)).0 }\n+            }\n+        };\n+\n+        // SAFETY: `block` is a pointer to the start of an allocated block.\n+        unsafe {\n+            let err = HeapFree(GetProcessHeap(), 0, block as c::LPVOID);\n             debug_assert!(err != 0, \"Failed to free heap memory: {}\", c::GetLastError());\n         }\n     }\n \n     #[inline]\n     unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n         if layout.align() <= MIN_ALIGN {\n-            c::HeapReAlloc(c::GetProcessHeap(), 0, ptr as c::LPVOID, new_size) as *mut u8\n+            let heap = unsafe { GetProcessHeap() };\n+            if heap.is_null() {\n+                // Reallocation has failed, could not get the current process heap.\n+                return ptr::null_mut();\n+            }\n+\n+            // SAFETY: `heap` is a non-null handle returned by `GetProcessHeap`,\n+            // `ptr` is a pointer to the start of an allocated block.\n+            // The returned pointer points to the start of an allocated block.\n+            unsafe { HeapReAlloc(heap, 0, ptr as c::LPVOID, new_size) as *mut u8 }\n         } else {\n-            realloc_fallback(self, ptr, layout, new_size)\n+            // SAFETY: `realloc_fallback` is implemented using `dealloc` and `alloc`, which will\n+            // correctly handle `ptr` and return a pointer satisfying the guarantees of `System`\n+            unsafe { realloc_fallback(self, ptr, layout, new_size) }\n         }\n     }\n }"}, {"sha": "674a3e1d92d175443147e8d223d7c4d57e4e2bd3", "filename": "library/std/src/sys/windows/alloc/tests.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0dbed6161a94aeb84fdae332f5b93476b6626515/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbed6161a94aeb84fdae332f5b93476b6626515/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc%2Ftests.rs?ref=0dbed6161a94aeb84fdae332f5b93476b6626515", "patch": "@@ -0,0 +1,9 @@\n+use super::{Header, MIN_ALIGN};\n+use crate::mem;\n+\n+#[test]\n+fn alloc_header() {\n+    // Header must fit in the padding before an aligned pointer\n+    assert!(mem::size_of::<Header>() <= MIN_ALIGN);\n+    assert!(mem::align_of::<Header>() <= MIN_ALIGN);\n+}"}, {"sha": "3e4176ef7f8fec9b5956c6350a9a8ae04e45201f", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0dbed6161a94aeb84fdae332f5b93476b6626515/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dbed6161a94aeb84fdae332f5b93476b6626515/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=0dbed6161a94aeb84fdae332f5b93476b6626515", "patch": "@@ -285,8 +285,6 @@ pub const FD_SETSIZE: usize = 64;\n \n pub const STACK_SIZE_PARAM_IS_A_RESERVATION: DWORD = 0x00010000;\n \n-pub const HEAP_ZERO_MEMORY: DWORD = 0x00000008;\n-\n pub const STATUS_SUCCESS: NTSTATUS = 0x00000000;\n \n #[repr(C)]\n@@ -1017,11 +1015,6 @@ extern \"system\" {\n         timeout: *const timeval,\n     ) -> c_int;\n \n-    pub fn GetProcessHeap() -> HANDLE;\n-    pub fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) -> LPVOID;\n-    pub fn HeapReAlloc(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID, dwBytes: SIZE_T) -> LPVOID;\n-    pub fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID) -> BOOL;\n-\n     // >= Vista / Server 2008\n     // https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsymboliclinkw\n     pub fn CreateSymbolicLinkW("}]}