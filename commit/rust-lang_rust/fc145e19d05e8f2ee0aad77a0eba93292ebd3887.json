{"sha": "fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjMTQ1ZTE5ZDA1ZThmMmVlMGFhZDc3YTBlYmE5MzI5MmViZDM4ODc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-23T00:28:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-23T00:28:05Z"}, "message": "Auto merge of #71445 - Dylan-DPC:rollup-31givp1, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #71256 (Lint must_use on mem::replace)\n - #71350 (Error code explanation extra check)\n - #71369 (allow wasm32 compilation of librustc_data_structures/profiling.rs)\n - #71400 (proc_macro::is_available())\n - #71440 (Implement `Copy` for `AllocErr`)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "1644d58fa36743ff3897969697e3f7bc7fd783f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1644d58fa36743ff3897969697e3f7bc7fd783f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "html_url": "https://github.com/rust-lang/rust/commit/fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db9b05aeb52b77d1eb780ee005979b63d093c214", "url": "https://api.github.com/repos/rust-lang/rust/commits/db9b05aeb52b77d1eb780ee005979b63d093c214", "html_url": "https://github.com/rust-lang/rust/commit/db9b05aeb52b77d1eb780ee005979b63d093c214"}, {"sha": "bb13aab8e570b8b062b494f3cbbf569ed6830c68", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb13aab8e570b8b062b494f3cbbf569ed6830c68", "html_url": "https://github.com/rust-lang/rust/commit/bb13aab8e570b8b062b494f3cbbf569ed6830c68"}], "stats": {"total": 474, "additions": 345, "deletions": 129}, "files": [{"sha": "86a6fa7f8ba3c82a6113225b03e7c4302ab2f3e9", "filename": "src/libcore/alloc/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibcore%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibcore%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Fmod.rs?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -18,7 +18,7 @@ use crate::ptr::{self, NonNull};\n /// something wrong when combining the given input arguments with this\n /// allocator.\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-#[derive(Clone, PartialEq, Eq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub struct AllocErr;\n \n // (we need this for downstream impl of trait Error)"}, {"sha": "549933ceeb6457f13813fbced35c37effe67a12f", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -709,6 +709,7 @@ unsafe impl<T: ?Sized> Freeze for &mut T {}\n /// So this, for example, can only be done on types implementing `Unpin`:\n ///\n /// ```rust\n+/// # #![allow(unused_must_use)]\n /// use std::mem;\n /// use std::pin::Pin;\n ///"}, {"sha": "3fa2b7a2d042c3e2755612e117d8b54411ed054c", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -808,6 +808,7 @@ pub fn take<T: Default>(dest: &mut T) -> T {\n /// [`Clone`]: ../../std/clone/trait.Clone.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[must_use = \"if you don't need the old value, you can just assign the new value directly\"]\n pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n     swap(dest, &mut src);\n     src"}, {"sha": "d2222d12623f9b8cd81778e2177cb7e4cc205c6d", "filename": "src/libproc_macro/bridge/client.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fclient.rs?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -290,6 +290,13 @@ impl BridgeState<'_> {\n }\n \n impl Bridge<'_> {\n+    pub(crate) fn is_available() -> bool {\n+        BridgeState::with(|state| match state {\n+            BridgeState::Connected(_) | BridgeState::InUse => true,\n+            BridgeState::NotConnected => false,\n+        })\n+    }\n+\n     fn enter<R>(self, f: impl FnOnce() -> R) -> R {\n         // Hide the default panic output within `proc_macro` expansions.\n         // NB. the server can't do this because it may use a different libstd."}, {"sha": "3cbe852de7b5a4722d6c0d7a91dbf972d613a9e5", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -45,6 +45,24 @@ use std::path::PathBuf;\n use std::str::FromStr;\n use std::{error, fmt, iter, mem};\n \n+/// Determines whether proc_macro has been made accessible to the currently\n+/// running program.\n+///\n+/// The proc_macro crate is only intended for use inside the implementation of\n+/// procedural macros. All the functions in this crate panic if invoked from\n+/// outside of a procedural macro, such as from a build script or unit test or\n+/// ordinary Rust binary.\n+///\n+/// With consideration for Rust libraries that are designed to support both\n+/// macro and non-macro use cases, `proc_macro::is_available()` provides a\n+/// non-panicking way to detect whether the infrastructure required to use the\n+/// API of proc_macro is presently available. Returns true if invoked from\n+/// inside of a procedural macro, false if invoked from any other binary.\n+#[unstable(feature = \"proc_macro_is_available\", issue = \"71436\")]\n+pub fn is_available() -> bool {\n+    bridge::Bridge::is_available()\n+}\n+\n /// The main type provided by this crate, representing an abstract stream of\n /// tokens, or, more specifically, a sequence of token trees.\n /// The type provide interfaces for iterating over those token trees and, conversely,"}, {"sha": "07d16c6483ec797cbec35e747dda60f9d277c343", "filename": "src/librustc_data_structures/profiling.rs", "status": "modified", "additions": 42, "deletions": 31, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_data_structures%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_data_structures%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fprofiling.rs?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -97,12 +97,17 @@ use std::time::{Duration, Instant};\n use measureme::{EventId, EventIdBuilder, SerializableString, StringId};\n use parking_lot::RwLock;\n \n-/// MmapSerializatioSink is faster on macOS and Linux\n-/// but FileSerializationSink is faster on Windows\n-#[cfg(not(windows))]\n-type SerializationSink = measureme::MmapSerializationSink;\n-#[cfg(windows)]\n-type SerializationSink = measureme::FileSerializationSink;\n+cfg_if! {\n+    if #[cfg(any(windows, target_os = \"wasi\"))] {\n+        /// FileSerializationSink is faster on Windows\n+        type SerializationSink = measureme::FileSerializationSink;\n+    } else if #[cfg(target_arch = \"wasm32\")] {\n+        type SerializationSink = measureme::ByteVecSink;\n+    } else {\n+        /// MmapSerializatioSink is faster on macOS and Linux\n+        type SerializationSink = measureme::MmapSerializationSink;\n+    }\n+}\n \n type Profiler = measureme::Profiler<SerializationSink>;\n \n@@ -602,31 +607,37 @@ pub fn duration_to_secs_str(dur: std::time::Duration) -> String {\n }\n \n // Memory reporting\n-#[cfg(unix)]\n-fn get_resident() -> Option<usize> {\n-    let field = 1;\n-    let contents = fs::read(\"/proc/self/statm\").ok()?;\n-    let contents = String::from_utf8(contents).ok()?;\n-    let s = contents.split_whitespace().nth(field)?;\n-    let npages = s.parse::<usize>().ok()?;\n-    Some(npages * 4096)\n-}\n-\n-#[cfg(windows)]\n-fn get_resident() -> Option<usize> {\n-    use std::mem::{self, MaybeUninit};\n-    use winapi::shared::minwindef::DWORD;\n-    use winapi::um::processthreadsapi::GetCurrentProcess;\n-    use winapi::um::psapi::{GetProcessMemoryInfo, PROCESS_MEMORY_COUNTERS};\n-\n-    let mut pmc = MaybeUninit::<PROCESS_MEMORY_COUNTERS>::uninit();\n-    match unsafe {\n-        GetProcessMemoryInfo(GetCurrentProcess(), pmc.as_mut_ptr(), mem::size_of_val(&pmc) as DWORD)\n-    } {\n-        0 => None,\n-        _ => {\n-            let pmc = unsafe { pmc.assume_init() };\n-            Some(pmc.WorkingSetSize as usize)\n+cfg_if! {\n+    if #[cfg(windows)] {\n+        fn get_resident() -> Option<usize> {\n+            use std::mem::{self, MaybeUninit};\n+            use winapi::shared::minwindef::DWORD;\n+            use winapi::um::processthreadsapi::GetCurrentProcess;\n+            use winapi::um::psapi::{GetProcessMemoryInfo, PROCESS_MEMORY_COUNTERS};\n+\n+            let mut pmc = MaybeUninit::<PROCESS_MEMORY_COUNTERS>::uninit();\n+            match unsafe {\n+                GetProcessMemoryInfo(GetCurrentProcess(), pmc.as_mut_ptr(), mem::size_of_val(&pmc) as DWORD)\n+            } {\n+                0 => None,\n+                _ => {\n+                    let pmc = unsafe { pmc.assume_init() };\n+                    Some(pmc.WorkingSetSize as usize)\n+                }\n+            }\n+        }\n+    } else if #[cfg(unix)] {\n+        fn get_resident() -> Option<usize> {\n+            let field = 1;\n+            let contents = fs::read(\"/proc/self/statm\").ok()?;\n+            let contents = String::from_utf8(contents).ok()?;\n+            let s = contents.split_whitespace().nth(field)?;\n+            let npages = s.parse::<usize>().ok()?;\n+            Some(npages * 4096)\n+        }\n+    } else {\n+        fn get_resident() -> Option<usize> {\n+            None\n         }\n     }\n }"}, {"sha": "e6906d72367d8faa346ff943faa9ff69e5f2c18b", "filename": "src/librustc_error_codes/error_codes/E0060.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0060.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0060.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0060.md?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -2,12 +2,14 @@ External C functions are allowed to be variadic. However, a variadic function\n takes a minimum number of arguments. For example, consider C's variadic `printf`\n function:\n \n-```\n+```compile_fail,E0060\n use std::os::raw::{c_char, c_int};\n \n extern \"C\" {\n     fn printf(_: *const c_char, ...) -> c_int;\n }\n+\n+unsafe { printf(); } // error!\n ```\n \n Using this declaration, it must be called with at least one argument, so"}, {"sha": "a270feaf58c17cb44cbfd9f0f08b1036ffb1b2df", "filename": "src/librustc_error_codes/error_codes/E0130.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0130.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0130.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0130.md?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -2,7 +2,7 @@ A pattern was declared as an argument in a foreign function declaration.\n \n Erroneous code example:\n \n-```compile_fail\n+```compile_fail,E0130\n extern {\n     fn foo((a, b): (u32, u32)); // error: patterns aren't allowed in foreign\n                                 //        function declarations"}, {"sha": "90f1e54287496fb7f32d90af946fd1673811c4db", "filename": "src/librustc_error_codes/error_codes/E0198.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0198.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0198.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0198.md?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -2,7 +2,7 @@ A negative implementation was marked as unsafe.\n \n Erroneous code example:\n \n-```compile_fail\n+```compile_fail,E0198\n struct Foo;\n \n unsafe impl !Clone for Foo { } // error!"}, {"sha": "afc61ec2e48ff87fc80b0c9733a3c8360f624ccc", "filename": "src/librustc_error_codes/error_codes/E0202.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0202.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0202.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0202.md?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -1,5 +1,15 @@\n Inherent associated types were part of [RFC 195] but are not yet implemented.\n See [the tracking issue][iss8995] for the status of this implementation.\n \n+Erroneous code example:\n+\n+```compile_fail,E0202\n+struct Foo;\n+\n+impl Foo {\n+    type Bar = isize; // error!\n+}\n+```\n+\n [RFC 195]: https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md\n [iss8995]: https://github.com/rust-lang/rust/issues/8995"}, {"sha": "cfb72e74319c1400816441e91bd69c7b66e703e7", "filename": "src/librustc_error_codes/error_codes/E0230.md", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0230.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0230.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0230.md?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -3,15 +3,11 @@ message for when a particular trait isn't implemented on a type placed in a\n position that needs that trait. For example, when the following code is\n compiled:\n \n-```compile_fail\n+```compile_fail,E0230\n #![feature(rustc_attrs)]\n \n-fn foo<T: Index<u8>>(x: T){}\n-\n-#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n-trait Index<Idx> { /* ... */ }\n-\n-foo(true); // `bool` does not implement `Index<u8>`\n+#[rustc_on_unimplemented = \"error on `{Self}` with params `<{A},{B}>`\"] // error\n+trait BadAnnotation<A> {}\n ```\n \n There will be an error about `bool` not implementing `Index<u8>`, followed by a"}, {"sha": "23a0a88ecdd9baf599d8fd58a05fd3f4544071ff", "filename": "src/librustc_error_codes/error_codes/E0231.md", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0231.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0231.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0231.md?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -3,15 +3,11 @@ message for when a particular trait isn't implemented on a type placed in a\n position that needs that trait. For example, when the following code is\n compiled:\n \n-```compile_fail\n+```compile_fail,E0231\n #![feature(rustc_attrs)]\n \n-fn foo<T: Index<u8>>(x: T){}\n-\n-#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n-trait Index<Idx> { /* ... */ }\n-\n-foo(true); // `bool` does not implement `Index<u8>`\n+#[rustc_on_unimplemented = \"error on `{Self}` with params `<{A},{}>`\"] // error!\n+trait BadAnnotation<A> {}\n ```\n \n there will be an error about `bool` not implementing `Index<u8>`, followed by a"}, {"sha": "b310caefa6e31165b4a3843a6c046868bd443c65", "filename": "src/librustc_error_codes/error_codes/E0232.md", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0232.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0232.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0232.md?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -3,15 +3,11 @@ message for when a particular trait isn't implemented on a type placed in a\n position that needs that trait. For example, when the following code is\n compiled:\n \n-```compile_fail\n+```compile_fail,E0232\n #![feature(rustc_attrs)]\n \n-fn foo<T: Index<u8>>(x: T){}\n-\n-#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n-trait Index<Idx> { /* ... */ }\n-\n-foo(true); // `bool` does not implement `Index<u8>`\n+#[rustc_on_unimplemented(lorem=\"\")] // error!\n+trait BadAnnotation {}\n ```\n \n there will be an error about `bool` not implementing `Index<u8>`, followed by a"}, {"sha": "1d7904b67ddb4b75f3142e4943f477903587ae69", "filename": "src/librustc_error_codes/error_codes/E0281.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0281.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0281.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0281.md?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -4,7 +4,7 @@ You tried to supply a type which doesn't implement some trait in a location\n which expected that trait. This error typically occurs when working with\n `Fn`-based types. Erroneous code example:\n \n-```compile-fail\n+```compile_fail\n fn foo<F: Fn(usize)>(x: F) { }\n \n fn main() {"}, {"sha": "d01fb0c9c4229427a140311d2165c54415435487", "filename": "src/librustc_error_codes/error_codes/E0364.md", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0364.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0364.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0364.md?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -3,27 +3,27 @@ attempted to `pub use` a type or value that was not itself public.\n \n Erroneous code example:\n \n-```compile_fail\n-mod foo {\n-    const X: u32 = 1;\n-}\n-\n-pub use foo::X;\n+```compile_fail,E0364\n+mod a {\n+    fn foo() {}\n \n-fn main() {}\n+    mod a {\n+        pub use super::foo; // error!\n+    }\n+}\n ```\n \n The solution to this problem is to ensure that the items that you are\n re-exporting are themselves marked with `pub`:\n \n ```\n-mod foo {\n-    pub const X: u32 = 1;\n-}\n-\n-pub use foo::X;\n+mod a {\n+    pub fn foo() {} // ok!\n \n-fn main() {}\n+    mod a {\n+        pub use super::foo;\n+    }\n+}\n ```\n \n See the [Use Declarations][use-declarations] section of the reference for"}, {"sha": "c6fe997f3dcfc8443d4b551b77f31229bd16a890", "filename": "src/librustc_error_codes/error_codes/E0378.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0378.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0378.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0378.md?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -3,7 +3,7 @@ or a newtype wrapper around a pointer.\n \n Erroneous code example:\n \n-```compile-fail,E0378\n+```compile_fail,E0378\n #![feature(dispatch_from_dyn)]\n use std::ops::DispatchFromDyn;\n "}, {"sha": "df7aa4f0a1e8dd3c3ff35d203701ba401dfc07e6", "filename": "src/librustc_error_codes/error_codes/E0590.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0590.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0590.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0590.md?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -3,7 +3,7 @@\n \n Example of erroneous code:\n \n-```compile_fail\n+```compile_fail,E0590\n while break {}\n ```\n "}, {"sha": "4646e37fb752632e69aa9e02e6479acee83b5a8e", "filename": "src/librustc_error_codes/error_codes/E0639.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0639.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0639.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0639.md?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -3,5 +3,17 @@ instantiated from outside of the defining crate as it has been marked\n as `non_exhaustive` and as such more fields/variants may be added in\n future that could cause adverse side effects for this code.\n \n+Erroneous code example:\n+\n+```ignore (it only works cross-crate)\n+#[non_exhaustive]\n+pub struct NormalStruct {\n+    pub first_field: u16,\n+    pub second_field: u16,\n+}\n+\n+let ns = NormalStruct { first_field: 640, second_field: 480 }; // error!\n+```\n+\n It is recommended that you look for a `new` function or equivalent in the\n crate's documentation."}, {"sha": "277643dfb1ab7d7ddffa4c2d861f590454c87976", "filename": "src/librustc_error_codes/error_codes/E0644.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0644.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0644.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0644.md?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -2,17 +2,17 @@ A closure or generator was constructed that references its own type.\n \n Erroneous example:\n \n-```compile-fail,E0644\n+```compile_fail,E0644\n fn fix<F>(f: &F)\n   where F: Fn(&F)\n {\n-  f(&f);\n+    f(&f);\n }\n \n fn main() {\n-  fix(&|y| {\n-    // Here, when `x` is called, the parameter `y` is equal to `x`.\n-  });\n+    fix(&|y| {\n+        // Here, when `x` is called, the parameter `y` is equal to `x`.\n+    });\n }\n ```\n "}, {"sha": "d821b9027f1363a6f9f86f14ec6c799e30db2c13", "filename": "src/librustc_error_codes/error_codes/E0658.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0658.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0658.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0658.md?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -2,7 +2,7 @@ An unstable feature was used.\n \n Erroneous code example:\n \n-```compile_fail,E658\n+```compile_fail,E0658\n #[repr(u128)] // error: use of unstable library feature 'repr128'\n enum Foo {\n     Bar(u64),"}, {"sha": "f078c441b342190c61b9dd4ab042a746718a8029", "filename": "src/librustc_error_codes/error_codes/E0669.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0669.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0669.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0669.md?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -1,5 +1,17 @@\n Cannot convert inline assembly operand to a single LLVM value.\n \n+Erroneous code example:\n+\n+```compile_fail,E0669\n+#![feature(llvm_asm)]\n+\n+fn main() {\n+    unsafe {\n+        llvm_asm!(\"\" :: \"r\"(\"\")); // error!\n+    }\n+}\n+```\n+\n This error usually happens when trying to pass in a value to an input inline\n assembly operand that is actually a pair of values. In particular, this can\n happen when trying to pass in a slice, for instance a `&str`. In Rust, these"}, {"sha": "3ba992a8476eda588872ef0ca9557a68afdc1754", "filename": "src/librustc_error_codes/error_codes/E0698.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0698.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0698.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0698.md?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -3,7 +3,7 @@ generator can be constructed.\n \n Erroneous code example:\n \n-```edition2018,compile-fail,E0698\n+```edition2018,compile_fail,E0698\n async fn bar<T>() -> () {}\n \n async fn foo() {"}, {"sha": "b1eb8b66ad682cf165a86d7323061340499669d9", "filename": "src/librustc_error_codes/error_codes/E0700.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0700.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0700.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0700.md?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -3,7 +3,7 @@ appear within the `impl Trait` itself.\n \n Erroneous code example:\n \n-```compile-fail,E0700\n+```compile_fail,E0700\n use std::cell::Cell;\n \n trait Trait<'a> { }"}, {"sha": "9287fc803d1de792ae03a81c932af0ad217933a1", "filename": "src/librustc_error_codes/error_codes/E0708.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0708.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0708.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0708.md?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -2,7 +2,7 @@\n \n Erroneous code example:\n \n-```compile_fail,edition2018\n+```compile_fail,edition2018,E0708\n #![feature(async_closure)]\n \n fn main() {"}, {"sha": "45d1cafa690624a0e49bf753cabfe4695d86e94d", "filename": "src/librustc_error_codes/error_codes/E0714.md", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0714.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0714.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0714.md?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -1,5 +1,19 @@\n A `#[marker]` trait contained an associated item.\n \n+Erroneous code example:\n+\n+```compile_fail,E0714\n+#![feature(marker_trait_attr)]\n+#![feature(associated_type_defaults)]\n+\n+#[marker]\n+trait MarkerConst {\n+    const N: usize; // error!\n+}\n+\n+fn main() {}\n+```\n+\n The items of marker traits cannot be overridden, so there's no need to have them\n when they cannot be changed per-type anyway.  If you wanted them for ergonomic\n reasons, consider making an extension trait instead."}, {"sha": "8f0022d9425471de4ef3357962e6f5620bdd9865", "filename": "src/librustc_error_codes/error_codes/E0715.md", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0715.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0715.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0715.md?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -1,5 +1,24 @@\n An `impl` for a `#[marker]` trait tried to override an associated item.\n \n+Erroneous code example:\n+\n+```compile_fail,E0715\n+#![feature(marker_trait_attr)]\n+\n+#[marker]\n+trait Marker {\n+    const N: usize = 0;\n+    fn do_something() {}\n+}\n+\n+struct OverrideConst;\n+impl Marker for OverrideConst { // error!\n+    const N: usize = 1;\n+}\n+\n+fn main() {}\n+```\n+\n Because marker traits are allowed to have multiple implementations for the same\n type, it's not allowed to override anything in those implementations, as it\n would be ambiguous which override should actually be used."}, {"sha": "be1b68e645d012ca3223c1627a8b5f3fe01d40ae", "filename": "src/librustc_error_codes/error_codes/E0727.md", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0727.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0727.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0727.md?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -2,25 +2,29 @@ A `yield` clause was used in an `async` context.\n \n Example of erroneous code:\n \n-```compile_fail\n+```compile_fail,E0727,edition2018\n #![feature(generators)]\n \n-let generator = || {\n-    async {\n-        yield;\n-    }\n-};\n+fn main() {\n+    let generator = || {\n+        async {\n+            yield;\n+        }\n+    };\n+}\n ```\n \n Here, the `yield` keyword is used in an `async` block,\n which is not yet supported.\n \n To fix this error, you have to move `yield` out of the `async` block:\n \n-```\n+```edition2018\n #![feature(generators)]\n \n-let generator = || {\n-    yield;\n-};\n+fn main() {\n+    let generator = || {\n+        yield;\n+    };\n+}\n ```"}, {"sha": "7347e6654c5b3acd99a55085d01791edebdd22b7", "filename": "src/librustc_error_codes/error_codes/E0732.md", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0732.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0732.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0732.md?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -1,5 +1,18 @@\n An `enum` with a discriminant must specify a `#[repr(inttype)]`.\n \n+Erroneous code example:\n+\n+```compile_fail,E0732\n+#![feature(arbitrary_enum_discriminant)]\n+\n+enum Enum { // error!\n+    Unit = 1,\n+    Tuple() = 2,\n+    Struct{} = 3,\n+}\n+# fn main() {}\n+```\n+\n A `#[repr(inttype)]` must be provided on an `enum` if it has a non-unit\n variant with a discriminant, or where there are both unit variants with\n discriminants and non-unit variants. This restriction ensures that there\n@@ -23,7 +36,9 @@ fn discriminant(v : &Enum) -> u8 {\n     unsafe { *(v as *const Enum as *const u8) }\n }\n \n-assert_eq!(3, discriminant(&Enum::Unit));\n-assert_eq!(2, discriminant(&Enum::Tuple(5)));\n-assert_eq!(1, discriminant(&Enum::Struct{a: 7, b: 11}));\n+fn main() {\n+    assert_eq!(3, discriminant(&Enum::Unit));\n+    assert_eq!(2, discriminant(&Enum::Tuple(5)));\n+    assert_eq!(1, discriminant(&Enum::Struct{a: 7, b: 11}));\n+}\n ```"}, {"sha": "37776785189643880ea89fd18f6f6af256ad22e6", "filename": "src/librustc_error_codes/error_codes/E0740.md", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0740.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0740.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0740.md?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -1 +1,16 @@\n A `union` cannot have fields with destructors.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0740\n+union Test {\n+    a: A, // error!\n+}\n+\n+#[derive(Debug)]\n+struct A(i32);\n+\n+impl Drop for A {\n+    fn drop(&mut self) { println!(\"A\"); }\n+}\n+```"}, {"sha": "56b947a8282edb585ee2416f4e96426e5478d7af", "filename": "src/librustc_error_codes/error_codes/E0744.md", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0744.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_error_codes%2Ferror_codes%2FE0744.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0744.md?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -3,16 +3,13 @@ Control-flow expressions are not allowed inside a const context.\n At the moment, `if` and `match`, as well as the looping constructs `for`,\n `while`, and `loop`, are forbidden inside a `const`, `static`, or `const fn`.\n \n-```compile_fail,E0658\n+```compile_fail,E0744\n const _: i32 = {\n     let mut x = 0;\n-    loop {\n-        x += 1;\n-        if x == 4 {\n-            break;\n-        }\n+\n+    for i in 0..4 { // error!\n+        x += i;\n     }\n-    x\n };\n ```\n "}, {"sha": "3f08fb79790fb2aa3f1525241ad57c24fc624390", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -547,8 +547,7 @@ impl<'a> Parser<'a> {\n                 // Rewind to before attempting to parse the type with generics, to recover\n                 // from situations like `x as usize < y` in which we first tried to parse\n                 // `usize < y` as a type with generic arguments.\n-                let parser_snapshot_after_type = self.clone();\n-                mem::replace(self, parser_snapshot_before_type);\n+                let parser_snapshot_after_type = mem::replace(self, parser_snapshot_before_type);\n \n                 match self.parse_path(PathStyle::Expr) {\n                     Ok(path) => {\n@@ -560,7 +559,7 @@ impl<'a> Parser<'a> {\n                                 // example because `parse_ty_no_plus` returns `Err` on keywords,\n                                 // but `parse_path` returns `Ok` on them due to error recovery.\n                                 // Return original error and parser state.\n-                                mem::replace(self, parser_snapshot_after_type);\n+                                *self = parser_snapshot_after_type;\n                                 return Err(type_err);\n                             }\n                         };\n@@ -601,7 +600,7 @@ impl<'a> Parser<'a> {\n                     Err(mut path_err) => {\n                         // Couldn't parse as a path, return original error and parser state.\n                         path_err.cancel();\n-                        mem::replace(self, parser_snapshot_after_type);\n+                        *self = parser_snapshot_after_type;\n                         return Err(type_err);\n                     }\n                 }"}, {"sha": "8e8f864728ce67463c925baad8cb2a6010271c23", "filename": "src/librustc_parse/parser/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -105,7 +105,7 @@ impl<'a> Parser<'a> {\n                     }\n                     Err(mut err) => {\n                         err.cancel();\n-                        std::mem::replace(self, snapshot);\n+                        *self = snapshot;\n                         break;\n                     }\n                 }"}, {"sha": "e9f5f2c0deafcc76d338a3ae8a3f919b220289e0", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -1650,7 +1650,7 @@ impl<'a> Parser<'a> {\n                 // Recover from attempting to parse the argument as a type without pattern.\n                 Err(mut err) => {\n                     err.cancel();\n-                    mem::replace(self, parser_snapshot_before_ty);\n+                    *self = parser_snapshot_before_ty;\n                     self.recover_arg_parse()?\n                 }\n             }"}, {"sha": "e5d0ab247aa46ed4a9bcf0d61f3af0df96f11582", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -163,8 +163,8 @@ impl<'a> Parser<'a> {\n                 Ok(ty) => (None, Some(ty)),\n                 Err(mut err) => {\n                     // Rewind to before attempting to parse the type and continue parsing.\n-                    let parser_snapshot_after_type = self.clone();\n-                    mem::replace(self, parser_snapshot_before_type);\n+                    let parser_snapshot_after_type =\n+                        mem::replace(self, parser_snapshot_before_type);\n                     if let Ok(snip) = self.span_to_snippet(pat.span) {\n                         err.span_label(pat.span, format!(\"while parsing the type for `{}`\", snip));\n                     }\n@@ -201,7 +201,7 @@ impl<'a> Parser<'a> {\n                 // Couldn't parse the type nor the initializer, only raise the type error and\n                 // return to the parser state before parsing the type as the initializer.\n                 // let x: <parse_error>;\n-                mem::replace(self, snapshot);\n+                *self = snapshot;\n                 return Err(ty_err);\n             }\n             (Err(err), None) => {"}, {"sha": "0d12bf08747fae3f88cac270dc504b1c14231289", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -26,7 +26,7 @@ use rustc_span::symbol::{kw, sym};\n use rustc_span::Span;\n use std::borrow::Cow;\n use std::cell::Cell;\n-use std::mem::{replace, take};\n+use std::mem::take;\n \n use log::debug;\n \n@@ -371,7 +371,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         self.with(Scope::Body { id: body.id(), s: self.scope }, |_, this| {\n             this.visit_body(body);\n         });\n-        replace(&mut self.labels_in_fn, saved);\n+        self.labels_in_fn = saved;\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {"}, {"sha": "094c468a6770e25f5d2bcc37e530d42b0cd08d3a", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -301,7 +301,7 @@ mod lazy {\n             // value (an aliasing violation). To avoid setting the \"I'm running a\n             // destructor\" flag we just use `mem::replace` which should sequence the\n             // operations a little differently and make this safe to call.\n-            mem::replace(&mut *ptr, Some(value));\n+            let _ = mem::replace(&mut *ptr, Some(value));\n \n             // After storing `Some` we want to get a reference to the contents of\n             // what we just stored. While we could use `unwrap` here and it should"}, {"sha": "19703904ece91923cde03c7a0b5321920edd03c3", "filename": "src/test/ui/imports/import-in-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Ftest%2Fui%2Fimports%2Fimport-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Ftest%2Fui%2Fimports%2Fimport-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fimport-in-block.rs?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -4,7 +4,7 @@\n pub fn main() {\n     use std::mem::replace;\n     let mut x = 5;\n-    replace(&mut x, 6);\n+    let _ = replace(&mut x, 6);\n     {\n         use std::mem::*;\n         let mut y = 6;"}, {"sha": "403cf970bcb0a52a49336c0ecf0dd2dcc2ff433a", "filename": "src/test/ui/issues/issue-23611-enum-swap-in-drop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Ftest%2Fui%2Fissues%2Fissue-23611-enum-swap-in-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Ftest%2Fui%2Fissues%2Fissue-23611-enum-swap-in-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23611-enum-swap-in-drop.rs?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -153,6 +153,7 @@ impl<'a> Drop for E<'a> {\n             }\n         };\n \n+        #[allow(unused_must_use)]\n         if do_drop {\n             mem::replace(self, E::A(GaspA(f_a, 0xA3A0, log, D::new(\"drop\", 6, log)), true));\n         }"}, {"sha": "0caf186db1d5fac483284bcb1435303ca0560378", "filename": "src/test/ui/proc-macro/auxiliary/is-available.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fis-available.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fis-available.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fis-available.rs?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -0,0 +1,14 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![feature(proc_macro_is_available)]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::{Literal, TokenStream, TokenTree};\n+\n+#[proc_macro]\n+pub fn from_inside_proc_macro(_input: TokenStream) -> TokenStream {\n+    proc_macro::is_available().to_string().parse().unwrap()\n+}"}, {"sha": "943d9fe797a6ec80ee30cd587dcb16a8850c6c8a", "filename": "src/test/ui/proc-macro/is-available.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Ftest%2Fui%2Fproc-macro%2Fis-available.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Ftest%2Fui%2Fproc-macro%2Fis-available.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fis-available.rs?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -0,0 +1,17 @@\n+// run-pass\n+\n+#![feature(proc_macro_hygiene, proc_macro_is_available)]\n+\n+extern crate proc_macro;\n+\n+// aux-build:is-available.rs\n+extern crate is_available;\n+\n+fn main() {\n+    let a = proc_macro::is_available();\n+    let b = is_available::from_inside_proc_macro!();\n+    let c = proc_macro::is_available();\n+    assert!(!a);\n+    assert!(b);\n+    assert!(!c);\n+}"}, {"sha": "243d41598f86c739dba3941f668a42e75e47f9f1", "filename": "src/tools/tidy/src/error_codes_check.rs", "status": "modified", "additions": 74, "deletions": 15, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc145e19d05e8f2ee0aad77a0eba93292ebd3887/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes_check.rs?ref=fc145e19d05e8f2ee0aad77a0eba93292ebd3887", "patch": "@@ -15,21 +15,57 @@ const WHITELIST: &[&str] = &[\n     \"E0727\", \"E0729\",\n ];\n \n+// Some error codes don't have any tests apparently...\n+const IGNORE_EXPLANATION_CHECK: &[&str] =\n+    &[\"E0570\", \"E0601\", \"E0602\", \"E0639\", \"E0729\", \"E0749\", \"E0750\", \"E0751\"];\n+\n fn check_error_code_explanation(\n     f: &str,\n     error_codes: &mut HashMap<String, bool>,\n     err_code: String,\n-) {\n+) -> bool {\n+    let mut invalid_compile_fail_format = false;\n+    let mut found_error_code = false;\n+\n     for line in f.lines() {\n         let s = line.trim();\n-        if s.starts_with(\"```\") && s.contains(\"compile_fail\") && s.contains('E') {\n-            error_codes.insert(err_code, true);\n-            return;\n+        if s.starts_with(\"```\") {\n+            if s.contains(\"compile_fail\") && s.contains('E') {\n+                if !found_error_code {\n+                    error_codes.insert(err_code.clone(), true);\n+                    found_error_code = true;\n+                }\n+            } else if s.contains(\"compile-fail\") {\n+                invalid_compile_fail_format = true;\n+            }\n         } else if s.starts_with(\"#### Note: this error code is no longer emitted by the compiler\") {\n-            error_codes.get_mut(&err_code).map(|x| *x = true);\n-            return;\n+            if !found_error_code {\n+                error_codes.get_mut(&err_code).map(|x| *x = true);\n+                found_error_code = true;\n+            }\n         }\n     }\n+    invalid_compile_fail_format\n+}\n+\n+fn check_if_error_code_is_test_in_explanation(f: &str, err_code: &String) -> bool {\n+    let mut can_be_ignored = false;\n+\n+    for line in f.lines() {\n+        let s = line.trim();\n+        if s.starts_with(\"#### Note: this error code is no longer emitted by the compiler\") {\n+            return true;\n+        }\n+        if s.starts_with(\"```\") {\n+            if s.contains(\"compile_fail\") && s.contains(err_code) {\n+                return true;\n+            } else if s.contains(\"(\") {\n+                // It's very likely that we can't actually make it fail compilation...\n+                can_be_ignored = true;\n+            }\n+        }\n+    }\n+    can_be_ignored\n }\n \n macro_rules! some_or_continue {\n@@ -41,7 +77,12 @@ macro_rules! some_or_continue {\n     };\n }\n \n-fn extract_error_codes(f: &str, error_codes: &mut HashMap<String, bool>, path: &Path) {\n+fn extract_error_codes(\n+    f: &str,\n+    error_codes: &mut HashMap<String, bool>,\n+    path: &Path,\n+    errors: &mut Vec<String>,\n+) {\n     let mut reached_no_explanation = false;\n \n     for line in f.lines() {\n@@ -55,10 +96,26 @@ fn extract_error_codes(f: &str, error_codes: &mut HashMap<String, bool>, path: &\n                 // Now we extract the tests from the markdown file!\n                 let md = some_or_continue!(s.splitn(2, \"include_str!(\\\"\").nth(1));\n                 let md_file_name = some_or_continue!(md.splitn(2, \"\\\")\").next());\n-                let path = some_or_continue!(path.parent()).join(md_file_name);\n+                let path = some_or_continue!(path.parent())\n+                    .join(md_file_name)\n+                    .canonicalize()\n+                    .expect(\"failed to canonicalize error explanation file path\");\n                 match read_to_string(&path) {\n                     Ok(content) => {\n-                        check_error_code_explanation(&content, error_codes, err_code);\n+                        if !IGNORE_EXPLANATION_CHECK.contains(&err_code.as_str())\n+                            && !check_if_error_code_is_test_in_explanation(&content, &err_code)\n+                        {\n+                            errors.push(format!(\n+                                \"`{}` doesn't use its own error code in compile_fail example\",\n+                                path.display(),\n+                            ));\n+                        }\n+                        if check_error_code_explanation(&content, error_codes, err_code) {\n+                            errors.push(format!(\n+                                \"`{}` uses invalid tag `compile-fail` instead of `compile_fail`\",\n+                                path.display(),\n+                            ));\n+                        }\n                     }\n                     Err(e) => {\n                         eprintln!(\"Couldn't read `{}`: {}\", path.display(), e);\n@@ -94,22 +151,24 @@ fn extract_error_codes_from_tests(f: &str, error_codes: &mut HashMap<String, boo\n }\n \n pub fn check(path: &Path, bad: &mut bool) {\n+    let mut errors = Vec::new();\n     println!(\"Checking which error codes lack tests...\");\n     let mut error_codes: HashMap<String, bool> = HashMap::new();\n     super::walk(path, &mut |path| super::filter_dirs(path), &mut |entry, contents| {\n         let file_name = entry.file_name();\n         if file_name == \"error_codes.rs\" {\n-            extract_error_codes(contents, &mut error_codes, entry.path());\n+            extract_error_codes(contents, &mut error_codes, entry.path(), &mut errors);\n         } else if entry.path().extension() == Some(OsStr::new(\"stderr\")) {\n             extract_error_codes_from_tests(contents, &mut error_codes);\n         }\n     });\n-    println!(\"Found {} error codes\", error_codes.len());\n+    if errors.is_empty() {\n+        println!(\"Found {} error codes\", error_codes.len());\n \n-    let mut errors = Vec::new();\n-    for (err_code, nb) in &error_codes {\n-        if !*nb && !WHITELIST.contains(&err_code.as_str()) {\n-            errors.push(format!(\"Error code {} needs to have at least one UI test!\", err_code));\n+        for (err_code, nb) in &error_codes {\n+            if !*nb && !WHITELIST.contains(&err_code.as_str()) {\n+                errors.push(format!(\"Error code {} needs to have at least one UI test!\", err_code));\n+            }\n         }\n     }\n     errors.sort();"}]}