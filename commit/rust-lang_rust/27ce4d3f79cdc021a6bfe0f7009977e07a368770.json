{"sha": "27ce4d3f79cdc021a6bfe0f7009977e07a368770", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3Y2U0ZDNmNzljZGMwMjFhNmJmZTBmNzAwOTk3N2UwN2EzNjg3NzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-02T23:56:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-02T23:56:49Z"}, "message": "auto merge of #11226 : pcwalton/rust/mutable-parser, r=pcwalton\n\nr? @alexcrichton", "tree": {"sha": "be234bc0f4afdca779c9043b935fe8ea1b4ece21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be234bc0f4afdca779c9043b935fe8ea1b4ece21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27ce4d3f79cdc021a6bfe0f7009977e07a368770", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27ce4d3f79cdc021a6bfe0f7009977e07a368770", "html_url": "https://github.com/rust-lang/rust/commit/27ce4d3f79cdc021a6bfe0f7009977e07a368770", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27ce4d3f79cdc021a6bfe0f7009977e07a368770/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e98a93ba991e2390b0068af72c5600b659cfb66", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e98a93ba991e2390b0068af72c5600b659cfb66", "html_url": "https://github.com/rust-lang/rust/commit/2e98a93ba991e2390b0068af72c5600b659cfb66"}, {"sha": "f3eee0ebada8e67dbba6574567456a9f1a946d28", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3eee0ebada8e67dbba6574567456a9f1a946d28", "html_url": "https://github.com/rust-lang/rust/commit/f3eee0ebada8e67dbba6574567456a9f1a946d28"}], "stats": {"total": 1728, "additions": 881, "deletions": 847}, "files": [{"sha": "0d78acadcae4b44f5f136ae5663b8f4b0775b24e", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=27ce4d3f79cdc021a6bfe0f7009977e07a368770", "patch": "@@ -39,9 +39,9 @@ fn next_state(s: State) -> Option<State> {\n \n pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n                -> base::MacResult {\n-    let p = parse::new_parser_from_tts(cx.parse_sess(),\n-                                       cx.cfg(),\n-                                       tts.to_owned());\n+    let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n+                                           cx.cfg(),\n+                                           tts.to_owned());\n \n     let mut asm = @\"\";\n     let mut asm_str_style = None;\n@@ -66,9 +66,9 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n                 asm_str_style = Some(style);\n             }\n             Outputs => {\n-                while *p.token != token::EOF &&\n-                      *p.token != token::COLON &&\n-                      *p.token != token::MOD_SEP {\n+                while p.token != token::EOF &&\n+                      p.token != token::COLON &&\n+                      p.token != token::MOD_SEP {\n \n                     if outputs.len() != 0 {\n                         p.eat(&token::COMMA);\n@@ -77,10 +77,10 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n                     let (constraint, _str_style) = p.parse_str();\n \n                     if constraint.starts_with(\"+\") {\n-                        cx.span_unimpl(*p.last_span,\n+                        cx.span_unimpl(p.last_span,\n                                        \"'+' (read+write) output operand constraint modifier\");\n                     } else if !constraint.starts_with(\"=\") {\n-                        cx.span_err(*p.last_span, \"output operand constraint lacks '='\");\n+                        cx.span_err(p.last_span, \"output operand constraint lacks '='\");\n                     }\n \n                     p.expect(&token::LPAREN);\n@@ -91,9 +91,9 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n                 }\n             }\n             Inputs => {\n-                while *p.token != token::EOF &&\n-                      *p.token != token::COLON &&\n-                      *p.token != token::MOD_SEP {\n+                while p.token != token::EOF &&\n+                      p.token != token::COLON &&\n+                      p.token != token::MOD_SEP {\n \n                     if inputs.len() != 0 {\n                         p.eat(&token::COMMA);\n@@ -102,9 +102,9 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n                     let (constraint, _str_style) = p.parse_str();\n \n                     if constraint.starts_with(\"=\") {\n-                        cx.span_err(*p.last_span, \"input operand constraint contains '='\");\n+                        cx.span_err(p.last_span, \"input operand constraint contains '='\");\n                     } else if constraint.starts_with(\"+\") {\n-                        cx.span_err(*p.last_span, \"input operand constraint contains '+'\");\n+                        cx.span_err(p.last_span, \"input operand constraint contains '+'\");\n                     }\n \n                     p.expect(&token::LPAREN);\n@@ -116,9 +116,9 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n             }\n             Clobbers => {\n                 let mut clobs = ~[];\n-                while *p.token != token::EOF &&\n-                      *p.token != token::COLON &&\n-                      *p.token != token::MOD_SEP {\n+                while p.token != token::EOF &&\n+                      p.token != token::COLON &&\n+                      p.token != token::MOD_SEP {\n \n                     if clobs.len() != 0 {\n                         p.eat(&token::COMMA);\n@@ -142,16 +142,16 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n                     dialect = ast::asm_intel;\n                 }\n \n-                if *p.token == token::COMMA {\n+                if p.token == token::COMMA {\n                     p.eat(&token::COMMA);\n                 }\n             }\n         }\n \n-        while *p.token == token::COLON   ||\n-              *p.token == token::MOD_SEP ||\n-              *p.token == token::EOF {\n-            state = if *p.token == token::COLON {\n+        while p.token == token::COLON   ||\n+              p.token == token::MOD_SEP ||\n+              p.token == token::EOF {\n+            state = if p.token == token::COLON {\n                 p.bump();\n                 match next_state(state) {\n                     Some(x) => x,\n@@ -160,7 +160,7 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n                         break\n                     }\n                 }\n-            } else if *p.token == token::MOD_SEP {\n+            } else if p.token == token::MOD_SEP {\n                 p.bump();\n                 let s = match next_state(state) {\n                     Some(x) => x,\n@@ -176,7 +176,7 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n                         break\n                     }\n                 }\n-            } else if *p.token == token::EOF {\n+            } else if p.token == token::EOF {\n                 continue_ = false;\n                 break;\n             } else {"}, {"sha": "a7a4e6416f9eb57a7e53687ccf1920e05675bc05", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=27ce4d3f79cdc021a6bfe0f7009977e07a368770", "patch": "@@ -442,11 +442,11 @@ pub fn get_single_str_from_tts(cx: &ExtCtxt,\n pub fn get_exprs_from_tts(cx: &ExtCtxt,\n                           sp: Span,\n                           tts: &[ast::token_tree]) -> ~[@ast::Expr] {\n-    let p = parse::new_parser_from_tts(cx.parse_sess(),\n-                                       cx.cfg(),\n-                                       tts.to_owned());\n+    let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n+                                           cx.cfg(),\n+                                           tts.to_owned());\n     let mut es = ~[];\n-    while *p.token != token::EOF {\n+    while p.token != token::EOF {\n         if es.len() != 0 && !p.eat(&token::COMMA) {\n             cx.span_fatal(sp, \"expected token: `,`\");\n         }"}, {"sha": "f3f44f4fa3f64e78ddedced0a78e6e6ca9525f17", "filename": "src/libsyntax/ext/cfg.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Fext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Fext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg.rs?ref=27ce4d3f79cdc021a6bfe0f7009977e07a368770", "patch": "@@ -26,11 +26,13 @@ use parse::token;\n use parse::attr::parser_attr;\n \n pub fn expand_cfg(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree]) -> base::MacResult {\n-    let p = parse::new_parser_from_tts(cx.parse_sess(), cx.cfg(), tts.to_owned());\n+    let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n+                                           cx.cfg(),\n+                                           tts.to_owned());\n \n     let mut cfgs = ~[];\n     // parse `cfg!(meta_item, meta_item(x,y), meta_item=\"foo\", ...)`\n-    while *p.token != token::EOF {\n+    while p.token != token::EOF {\n         cfgs.push(p.parse_meta_item());\n         if p.eat(&token::EOF) { break } // trailing comma is optional,.\n         p.expect(&token::COMMA);"}, {"sha": "8660b4c056091f8a254bdc69e8b6fff1cdef8582", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=27ce4d3f79cdc021a6bfe0f7009977e07a368770", "patch": "@@ -53,46 +53,46 @@ struct Context<'a> {\n impl<'a> Context<'a> {\n     /// Parses the arguments from the given list of tokens, returning None if\n     /// there's a parse error so we can continue parsing other format! expressions.\n-    fn parse_args(&mut self, sp: Span,\n-                  tts: &[ast::token_tree]) -> (@ast::Expr, Option<@ast::Expr>) {\n-        let p = rsparse::new_parser_from_tts(self.ecx.parse_sess(),\n-                                             self.ecx.cfg(),\n-                                             tts.to_owned());\n+    fn parse_args(&mut self, sp: Span, tts: &[ast::token_tree])\n+                  -> (@ast::Expr, Option<@ast::Expr>) {\n+        let mut p = rsparse::new_parser_from_tts(self.ecx.parse_sess(),\n+                                                 self.ecx.cfg(),\n+                                                 tts.to_owned());\n         // Parse the leading function expression (maybe a block, maybe a path)\n         let extra = p.parse_expr();\n         if !p.eat(&token::COMMA) {\n             self.ecx.span_err(sp, \"expected token: `,`\");\n             return (extra, None);\n         }\n \n-        if *p.token == token::EOF {\n+        if p.token == token::EOF {\n             self.ecx.span_err(sp, \"requires at least a format string argument\");\n             return (extra, None);\n         }\n         let fmtstr = p.parse_expr();\n         let mut named = false;\n-        while *p.token != token::EOF {\n+        while p.token != token::EOF {\n             if !p.eat(&token::COMMA) {\n                 self.ecx.span_err(sp, \"expected token: `,`\");\n                 return (extra, None);\n             }\n-            if *p.token == token::EOF { break } // accept trailing commas\n-            if named || (token::is_ident(p.token) &&\n+            if p.token == token::EOF { break } // accept trailing commas\n+            if named || (token::is_ident(&p.token) &&\n                          p.look_ahead(1, |t| *t == token::EQ)) {\n                 named = true;\n-                let ident = match *p.token {\n+                let ident = match p.token {\n                     token::IDENT(i, _) => {\n                         p.bump();\n                         i\n                     }\n                     _ if named => {\n-                        self.ecx.span_err(*p.span,\n+                        self.ecx.span_err(p.span,\n                                           \"expected ident, positional arguments \\\n                                            cannot follow named arguments\");\n                         return (extra, None);\n                     }\n                     _ => {\n-                        self.ecx.span_err(*p.span,\n+                        self.ecx.span_err(p.span,\n                                           format!(\"expected ident for named \\\n                                                 argument, but found `{}`\",\n                                                p.this_token_to_str()));"}, {"sha": "0f0793e03b7767b8fd3a38b4c0bdf1dd4f4e1829", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=27ce4d3f79cdc021a6bfe0f7009977e07a368770", "patch": "@@ -579,22 +579,18 @@ fn mk_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     ss\n }\n \n-fn expand_tts(cx: &ExtCtxt,\n-              sp: Span,\n-              tts: &[ast::token_tree]) -> (@ast::Expr, @ast::Expr) {\n-\n+fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+              -> (@ast::Expr, @ast::Expr) {\n     // NB: It appears that the main parser loses its mind if we consider\n     // $foo as a tt_nonterminal during the main parse, so we have to re-parse\n     // under quote_depth > 0. This is silly and should go away; the _guess_ is\n     // it has to do with transition away from supporting old-style macros, so\n     // try removing it when enough of them are gone.\n \n-    let p = parse::new_parser_from_tts(\n-        cx.parse_sess(),\n-        cx.cfg(),\n-        tts.to_owned()\n-    );\n-    *p.quote_depth += 1u;\n+    let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n+                                           cx.cfg(),\n+                                           tts.to_owned());\n+    p.quote_depth += 1u;\n \n     let cx_expr = p.parse_expr();\n     if !p.eat(&token::COMMA) {"}, {"sha": "11e7c1c8499a08b3afe4d56002d302768358c0c2", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=27ce4d3f79cdc021a6bfe0f7009977e07a368770", "patch": "@@ -81,9 +81,13 @@ pub fn expand_include(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include!\");\n     // The file will be added to the code map by the parser\n-    let p = parse::new_sub_parser_from_file(\n-        cx.parse_sess(), cx.cfg(),\n-        &res_rel_file(cx, sp, &Path::new(file)), sp);\n+    let mut p =\n+        parse::new_sub_parser_from_file(cx.parse_sess(),\n+                                        cx.cfg(),\n+                                        &res_rel_file(cx,\n+                                                      sp,\n+                                                      &Path::new(file)),\n+                                        sp);\n     base::MRExpr(p.parse_expr())\n }\n "}, {"sha": "34151377d7bdfb092b91f5d18d4325a13bda31fd", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=27ce4d3f79cdc021a6bfe0f7009977e07a368770", "patch": "@@ -26,7 +26,7 @@ pub fn expand_trace_macros(cx: &mut ExtCtxt,\n                                None,\n                                tt.to_owned());\n     let rdr = tt_rdr as @mut reader;\n-    let rust_parser = Parser(sess, cfg.clone(), rdr.dup());\n+    let mut rust_parser = Parser(sess, cfg.clone(), rdr.dup());\n \n     if rust_parser.is_keyword(keywords::True) {\n         cx.set_trace_macros(true);\n@@ -38,7 +38,7 @@ pub fn expand_trace_macros(cx: &mut ExtCtxt,\n \n     rust_parser.bump();\n \n-    let rust_parser = Parser(sess, cfg, rdr.dup());\n+    let mut rust_parser = Parser(sess, cfg, rdr.dup());\n     let result = rust_parser.parse_expr();\n     base::MRExpr(result)\n }"}, {"sha": "4d2923f391e454196b4f28cf04dd64eaa08b1666", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=27ce4d3f79cdc021a6bfe0f7009977e07a368770", "patch": "@@ -403,13 +403,13 @@ pub fn parse(\n                 }\n                 rdr.next_token();\n             } else /* bb_eis.len() == 1 */ {\n-                let rust_parser = Parser(sess, cfg.clone(), rdr.dup());\n+                let mut rust_parser = Parser(sess, cfg.clone(), rdr.dup());\n \n                 let mut ei = bb_eis.pop();\n                 match ei.elts[ei.idx].node {\n                   match_nonterminal(_, ref name, idx) => {\n                     ei.matches[idx].push(@matched_nonterminal(\n-                        parse_nt(&rust_parser, ident_to_str(name))));\n+                        parse_nt(&mut rust_parser, ident_to_str(name))));\n                     ei.idx += 1u;\n                   }\n                   _ => fail!()\n@@ -426,7 +426,7 @@ pub fn parse(\n     }\n }\n \n-pub fn parse_nt(p: &Parser, name: &str) -> nonterminal {\n+pub fn parse_nt(p: &mut Parser, name: &str) -> nonterminal {\n     match name {\n       \"item\" => match p.parse_item(~[]) {\n         Some(i) => token::nt_item(i),\n@@ -438,19 +438,21 @@ pub fn parse_nt(p: &Parser, name: &str) -> nonterminal {\n       \"expr\" => token::nt_expr(p.parse_expr()),\n       \"ty\" => token::nt_ty(p.parse_ty(false /* no need to disambiguate*/)),\n       // this could be handled like a token, since it is one\n-      \"ident\" => match *p.token {\n+      \"ident\" => match p.token {\n         token::IDENT(sn,b) => { p.bump(); token::nt_ident(~sn,b) }\n-        _ => p.fatal(~\"expected ident, found \"\n-                     + token::to_str(get_ident_interner(), p.token))\n+        _ => {\n+            let token_str = token::to_str(get_ident_interner(), &p.token);\n+            p.fatal(~\"expected ident, found \" + token_str)\n+        }\n       },\n       \"path\" => {\n         token::nt_path(~p.parse_path(LifetimeAndTypesWithoutColons).path)\n       }\n       \"attr\" => token::nt_attr(@p.parse_attribute(false)),\n       \"tt\" => {\n-        *p.quote_depth += 1u; //but in theory, non-quoted tts might be useful\n+        p.quote_depth += 1u; //but in theory, non-quoted tts might be useful\n         let res = token::nt_tt(@p.parse_token_tree());\n-        *p.quote_depth -= 1u;\n+        p.quote_depth -= 1u;\n         res\n       }\n       \"matchers\" => token::nt_matchers(p.parse_matchers()),"}, {"sha": "c9827fb54bd79bc0fdace2e93641dc50563e3cb6", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=27ce4d3f79cdc021a6bfe0f7009977e07a368770", "patch": "@@ -24,10 +24,11 @@ use parse::attr::parser_attr;\n use parse::token::{get_ident_interner, special_idents, gensym_ident, ident_to_str};\n use parse::token::{FAT_ARROW, SEMI, nt_matchers, nt_tt, EOF};\n use print;\n+use std::cell::RefCell;\n use util::small_vector::SmallVector;\n \n struct ParserAnyMacro {\n-    parser: @Parser,\n+    parser: RefCell<Parser>,\n }\n \n impl ParserAnyMacro {\n@@ -38,28 +39,36 @@ impl ParserAnyMacro {\n     /// fail!(); } )` doesn't get picked up by .parse_expr(), but it's\n     /// allowed to be there.\n     fn ensure_complete_parse(&self, allow_semi: bool) {\n-        if allow_semi && *self.parser.token == SEMI {\n-            self.parser.bump()\n+        let mut parser = self.parser.borrow_mut();\n+        if allow_semi && parser.get().token == SEMI {\n+            parser.get().bump()\n         }\n-        if *self.parser.token != EOF {\n-            let msg = format!(\"macro expansion ignores token `{}` and any following\",\n-                              self.parser.this_token_to_str());\n-            self.parser.span_err(*self.parser.span, msg);\n+        if parser.get().token != EOF {\n+            let token_str = parser.get().this_token_to_str();\n+            let msg = format!(\"macro expansion ignores token `{}` and any \\\n+                               following\",\n+                              token_str);\n+            let span = parser.get().span;\n+            parser.get().span_err(span, msg);\n         }\n     }\n }\n \n impl AnyMacro for ParserAnyMacro {\n     fn make_expr(&self) -> @ast::Expr {\n-        let ret = self.parser.parse_expr();\n+        let ret = {\n+            let mut parser = self.parser.borrow_mut();\n+            parser.get().parse_expr()\n+        };\n         self.ensure_complete_parse(true);\n         ret\n     }\n     fn make_items(&self) -> SmallVector<@ast::item> {\n         let mut ret = SmallVector::zero();\n         loop {\n-            let attrs = self.parser.parse_outer_attributes();\n-            match self.parser.parse_item(attrs) {\n+            let mut parser = self.parser.borrow_mut();\n+            let attrs = parser.get().parse_outer_attributes();\n+            match parser.get().parse_item(attrs) {\n                 Some(item) => ret.push(item),\n                 None => break\n             }\n@@ -68,8 +77,11 @@ impl AnyMacro for ParserAnyMacro {\n         ret\n     }\n     fn make_stmt(&self) -> @ast::Stmt {\n-        let attrs = self.parser.parse_outer_attributes();\n-        let ret = self.parser.parse_stmt(attrs);\n+        let ret = {\n+            let mut parser = self.parser.borrow_mut();\n+            let attrs = parser.get().parse_outer_attributes();\n+            parser.get().parse_stmt(attrs)\n+        };\n         self.ensure_complete_parse(true);\n         ret\n     }\n@@ -142,14 +154,14 @@ fn generic_extension(cx: &ExtCtxt,\n                 // rhs has holes ( `$id` and `$(...)` that need filled)\n                 let trncbr = new_tt_reader(s_d, Some(named_matches),\n                                            rhs);\n-                let p = @Parser(cx.parse_sess(),\n-                                cx.cfg(),\n-                                trncbr as @mut reader);\n+                let p = Parser(cx.parse_sess(),\n+                               cx.cfg(),\n+                               trncbr as @mut reader);\n \n                 // Let the context choose how to interpret the result.\n                 // Weird, but useful for X-macros.\n                 return MRAny(@ParserAnyMacro {\n-                    parser: p,\n+                    parser: RefCell::new(p),\n                 } as @AnyMacro)\n               }\n               failure(sp, ref msg) => if sp.lo >= best_fail_spot.lo {"}, {"sha": "c8ebc8036049875a59b265e026abd3a370e33ea9", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=27ce4d3f79cdc021a6bfe0f7009977e07a368770", "patch": "@@ -17,24 +17,23 @@ use parse::token::INTERPOLATED;\n \n // a parser that can parse attributes.\n pub trait parser_attr {\n-    fn parse_outer_attributes(&self) -> ~[ast::Attribute];\n-    fn parse_attribute(&self, permit_inner: bool) -> ast::Attribute;\n-    fn parse_inner_attrs_and_next(&self) ->\n-        (~[ast::Attribute], ~[ast::Attribute]);\n-    fn parse_meta_item(&self) -> @ast::MetaItem;\n-    fn parse_meta_seq(&self) -> ~[@ast::MetaItem];\n-    fn parse_optional_meta(&self) -> ~[@ast::MetaItem];\n+    fn parse_outer_attributes(&mut self) -> ~[ast::Attribute];\n+    fn parse_attribute(&mut self, permit_inner: bool) -> ast::Attribute;\n+    fn parse_inner_attrs_and_next(&mut self)\n+                                  -> (~[ast::Attribute], ~[ast::Attribute]);\n+    fn parse_meta_item(&mut self) -> @ast::MetaItem;\n+    fn parse_meta_seq(&mut self) -> ~[@ast::MetaItem];\n+    fn parse_optional_meta(&mut self) -> ~[@ast::MetaItem];\n }\n \n impl parser_attr for Parser {\n-\n     // Parse attributes that appear before an item\n-    fn parse_outer_attributes(&self) -> ~[ast::Attribute] {\n+    fn parse_outer_attributes(&mut self) -> ~[ast::Attribute] {\n         let mut attrs: ~[ast::Attribute] = ~[];\n         loop {\n             debug!(\"parse_outer_attributes: self.token={:?}\",\n                    self.token);\n-            match *self.token {\n+            match self.token {\n               token::INTERPOLATED(token::nt_attr(..)) => {\n                 attrs.push(self.parse_attribute(false));\n               }\n@@ -66,10 +65,10 @@ impl parser_attr for Parser {\n     //\n     // if permit_inner is true, then a trailing `;` indicates an inner\n     // attribute\n-    fn parse_attribute(&self, permit_inner: bool) -> ast::Attribute {\n+    fn parse_attribute(&mut self, permit_inner: bool) -> ast::Attribute {\n         debug!(\"parse_attributes: permit_inner={:?} self.token={:?}\",\n                permit_inner, self.token);\n-        let (span, value) = match *self.token {\n+        let (span, value) = match self.token {\n             INTERPOLATED(token::nt_attr(attr)) => {\n                 assert!(attr.node.style == ast::AttrOuter);\n                 self.bump();\n@@ -85,11 +84,12 @@ impl parser_attr for Parser {\n                 (mk_sp(lo, hi), meta_item)\n             }\n             _ => {\n+                let token_str = self.this_token_to_str();\n                 self.fatal(format!(\"expected `\\\\#` but found `{}`\",\n-                                   self.this_token_to_str()));\n+                                   token_str));\n             }\n         };\n-        let style = if permit_inner && *self.token == token::SEMI {\n+        let style = if permit_inner && self.token == token::SEMI {\n             self.bump();\n             ast::AttrInner\n         } else {\n@@ -115,12 +115,12 @@ impl parser_attr for Parser {\n     // matches inner_attrs* outer_attr?\n     // you can make the 'next' field an Option, but the result is going to be\n     // more useful as a vector.\n-    fn parse_inner_attrs_and_next(&self)\n+    fn parse_inner_attrs_and_next(&mut self)\n                                   -> (~[ast::Attribute], ~[ast::Attribute]) {\n         let mut inner_attrs: ~[ast::Attribute] = ~[];\n         let mut next_outer_attrs: ~[ast::Attribute] = ~[];\n         loop {\n-            let attr = match *self.token {\n+            let attr = match self.token {\n                 token::INTERPOLATED(token::nt_attr(..)) => {\n                     self.parse_attribute(true)\n                 }\n@@ -154,10 +154,11 @@ impl parser_attr for Parser {\n     // matches meta_item = IDENT\n     // | IDENT = lit\n     // | IDENT meta_seq\n-    fn parse_meta_item(&self) -> @ast::MetaItem {\n+    fn parse_meta_item(&mut self) -> @ast::MetaItem {\n         let lo = self.span.lo;\n-        let name = self.id_to_str(self.parse_ident());\n-        match *self.token {\n+        let ident = self.parse_ident();\n+        let name = self.id_to_str(ident);\n+        match self.token {\n             token::EQ => {\n                 self.bump();\n                 let lit = self.parse_lit();\n@@ -187,15 +188,15 @@ impl parser_attr for Parser {\n     }\n \n     // matches meta_seq = ( COMMASEP(meta_item) )\n-    fn parse_meta_seq(&self) -> ~[@ast::MetaItem] {\n+    fn parse_meta_seq(&mut self) -> ~[@ast::MetaItem] {\n         self.parse_seq(&token::LPAREN,\n                        &token::RPAREN,\n                        seq_sep_trailing_disallowed(token::COMMA),\n                        |p| p.parse_meta_item()).node\n     }\n \n-    fn parse_optional_meta(&self) -> ~[@ast::MetaItem] {\n-        match *self.token {\n+    fn parse_optional_meta(&mut self) -> ~[@ast::MetaItem] {\n+        match self.token {\n             token::LPAREN => self.parse_meta_seq(),\n             _ => ~[]\n         }"}, {"sha": "5a8444518aac9eb9479e1c7327236b2fdaa7ddae", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 22, "deletions": 37, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=27ce4d3f79cdc021a6bfe0f7009977e07a368770", "patch": "@@ -84,7 +84,7 @@ pub fn parse_crate_attrs_from_file(\n     cfg: ast::CrateConfig,\n     sess: @mut ParseSess\n ) -> ~[ast::Attribute] {\n-    let parser = new_parser_from_file(sess, cfg, input);\n+    let mut parser = new_parser_from_file(sess, cfg, input);\n     let (inner, _) = parser.parse_inner_attrs_and_next();\n     return inner;\n }\n@@ -95,10 +95,10 @@ pub fn parse_crate_from_source_str(\n     cfg: ast::CrateConfig,\n     sess: @mut ParseSess\n ) -> ast::Crate {\n-    let p = new_parser_from_source_str(sess,\n-                                       /*bad*/ cfg.clone(),\n-                                       name,\n-                                       source);\n+    let mut p = new_parser_from_source_str(sess,\n+                                           /*bad*/ cfg.clone(),\n+                                           name,\n+                                           source);\n     maybe_aborted(p.parse_crate_mod(),p)\n }\n \n@@ -108,10 +108,10 @@ pub fn parse_crate_attrs_from_source_str(\n     cfg: ast::CrateConfig,\n     sess: @mut ParseSess\n ) -> ~[ast::Attribute] {\n-    let p = new_parser_from_source_str(sess,\n-                                       /*bad*/ cfg.clone(),\n-                                       name,\n-                                       source);\n+    let mut p = new_parser_from_source_str(sess,\n+                                           /*bad*/ cfg.clone(),\n+                                           name,\n+                                           source);\n     let (inner, _) = maybe_aborted(p.parse_inner_attrs_and_next(),p);\n     return inner;\n }\n@@ -122,12 +122,7 @@ pub fn parse_expr_from_source_str(\n     cfg: ast::CrateConfig,\n     sess: @mut ParseSess\n ) -> @ast::Expr {\n-    let p = new_parser_from_source_str(\n-        sess,\n-        cfg,\n-        name,\n-        source\n-    );\n+    let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     maybe_aborted(p.parse_expr(), p)\n }\n \n@@ -138,12 +133,7 @@ pub fn parse_item_from_source_str(\n     attrs: ~[ast::Attribute],\n     sess: @mut ParseSess\n ) -> Option<@ast::item> {\n-    let p = new_parser_from_source_str(\n-        sess,\n-        cfg,\n-        name,\n-        source\n-    );\n+    let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     maybe_aborted(p.parse_item(attrs),p)\n }\n \n@@ -153,12 +143,7 @@ pub fn parse_meta_from_source_str(\n     cfg: ast::CrateConfig,\n     sess: @mut ParseSess\n ) -> @ast::MetaItem {\n-    let p = new_parser_from_source_str(\n-        sess,\n-        cfg,\n-        name,\n-        source\n-    );\n+    let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     maybe_aborted(p.parse_meta_item(),p)\n }\n \n@@ -169,7 +154,7 @@ pub fn parse_stmt_from_source_str(\n     attrs: ~[ast::Attribute],\n     sess: @mut ParseSess\n ) -> @ast::Stmt {\n-    let p = new_parser_from_source_str(\n+    let mut p = new_parser_from_source_str(\n         sess,\n         cfg,\n         name,\n@@ -184,13 +169,13 @@ pub fn parse_tts_from_source_str(\n     cfg: ast::CrateConfig,\n     sess: @mut ParseSess\n ) -> ~[ast::token_tree] {\n-    let p = new_parser_from_source_str(\n+    let mut p = new_parser_from_source_str(\n         sess,\n         cfg,\n         name,\n         source\n     );\n-    *p.quote_depth += 1u;\n+    p.quote_depth += 1u;\n     // right now this is re-creating the token trees from ... token trees.\n     maybe_aborted(p.parse_all_token_trees(),p)\n }\n@@ -201,15 +186,15 @@ pub fn parse_tts_from_source_str(\n // consumed all of the input before returning the function's\n // result.\n pub fn parse_from_source_str<T>(\n-                             f: |&Parser| -> T,\n+                             f: |&mut Parser| -> T,\n                              name: @str,\n                              ss: codemap::FileSubstr,\n                              source: @str,\n                              cfg: ast::CrateConfig,\n                              sess: @mut ParseSess)\n                              -> T {\n-    let p = new_parser_from_source_substr(sess, cfg, name, ss, source);\n-    let r = f(&p);\n+    let mut p = new_parser_from_source_substr(sess, cfg, name, ss, source);\n+    let r = f(&mut p);\n     if !p.reader.is_eof() {\n         p.reader.fatal(~\"expected end-of-string\");\n     }\n@@ -326,7 +311,7 @@ pub fn filemap_to_tts(sess: @mut ParseSess, filemap: @FileMap)\n     // parsing tt's probably shouldn't require a parser at all.\n     let cfg = ~[];\n     let srdr = lexer::new_string_reader(sess.span_diagnostic, filemap);\n-    let p1 = Parser(sess, cfg, srdr as @mut reader);\n+    let mut p1 = Parser(sess, cfg, srdr as @mut reader);\n     p1.parse_all_token_trees()\n }\n \n@@ -339,7 +324,7 @@ pub fn tts_to_parser(sess: @mut ParseSess,\n }\n \n // abort if necessary\n-pub fn maybe_aborted<T>(result : T, p: Parser) -> T {\n+pub fn maybe_aborted<T>(result: T, mut p: Parser) -> T {\n     p.abort_if_errors();\n     result\n }\n@@ -646,11 +631,11 @@ mod test {\n     }\n \n     fn parser_done(p: Parser){\n-        assert_eq!((*p.token).clone(), token::EOF);\n+        assert_eq!(p.token.clone(), token::EOF);\n     }\n \n     #[test] fn parse_ident_pat () {\n-        let parser = string_to_parser(@\"b\");\n+        let mut parser = string_to_parser(@\"b\");\n         assert_eq!(parser.parse_pat(),\n                    @ast::Pat{id: ast::DUMMY_NODE_ID,\n                              node: ast::PatIdent("}, {"sha": "824420e996620ecb41df48725534f304e547b290", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=27ce4d3f79cdc021a6bfe0f7009977e07a368770", "patch": "@@ -20,7 +20,6 @@ removed.\n use ast::{Expr, ExprLit, lit_nil};\n use codemap::{Span, respan};\n use parse::parser::Parser;\n-use parse::token::Token;\n use parse::token;\n \n use std::str;\n@@ -57,23 +56,22 @@ impl to_bytes::IterBytes for ObsoleteSyntax {\n \n pub trait ParserObsoleteMethods {\n     /// Reports an obsolete syntax non-fatal error.\n-    fn obsolete(&self, sp: Span, kind: ObsoleteSyntax);\n+    fn obsolete(&mut self, sp: Span, kind: ObsoleteSyntax);\n     // Reports an obsolete syntax non-fatal error, and returns\n     // a placeholder expression\n-    fn obsolete_expr(&self, sp: Span, kind: ObsoleteSyntax) -> @Expr;\n-    fn report(&self,\n+    fn obsolete_expr(&mut self, sp: Span, kind: ObsoleteSyntax) -> @Expr;\n+    fn report(&mut self,\n               sp: Span,\n               kind: ObsoleteSyntax,\n               kind_str: &str,\n               desc: &str);\n-    fn token_is_obsolete_ident(&self, ident: &str, token: &Token) -> bool;\n-    fn is_obsolete_ident(&self, ident: &str) -> bool;\n-    fn eat_obsolete_ident(&self, ident: &str) -> bool;\n+    fn is_obsolete_ident(&mut self, ident: &str) -> bool;\n+    fn eat_obsolete_ident(&mut self, ident: &str) -> bool;\n }\n \n impl ParserObsoleteMethods for Parser {\n     /// Reports an obsolete syntax non-fatal error.\n-    fn obsolete(&self, sp: Span, kind: ObsoleteSyntax) {\n+    fn obsolete(&mut self, sp: Span, kind: ObsoleteSyntax) {\n         let (kind_str, desc) = match kind {\n             ObsoleteSwap => (\n                 \"swap\",\n@@ -158,12 +156,12 @@ impl ParserObsoleteMethods for Parser {\n \n     // Reports an obsolete syntax non-fatal error, and returns\n     // a placeholder expression\n-    fn obsolete_expr(&self, sp: Span, kind: ObsoleteSyntax) -> @Expr {\n+    fn obsolete_expr(&mut self, sp: Span, kind: ObsoleteSyntax) -> @Expr {\n         self.obsolete(sp, kind);\n         self.mk_expr(sp.lo, sp.hi, ExprLit(@respan(sp, lit_nil)))\n     }\n \n-    fn report(&self,\n+    fn report(&mut self,\n               sp: Span,\n               kind: ObsoleteSyntax,\n               kind_str: &str,\n@@ -176,21 +174,16 @@ impl ParserObsoleteMethods for Parser {\n         }\n     }\n \n-    fn token_is_obsolete_ident(&self, ident: &str, token: &Token)\n-                                   -> bool {\n-        match *token {\n+    fn is_obsolete_ident(&mut self, ident: &str) -> bool {\n+        match self.token {\n             token::IDENT(sid, _) => {\n                 str::eq_slice(self.id_to_str(sid), ident)\n             }\n             _ => false\n         }\n     }\n \n-    fn is_obsolete_ident(&self, ident: &str) -> bool {\n-        self.token_is_obsolete_ident(ident, self.token)\n-    }\n-\n-    fn eat_obsolete_ident(&self, ident: &str) -> bool {\n+    fn eat_obsolete_ident(&mut self, ident: &str) -> bool {\n         if self.is_obsolete_ident(ident) {\n             self.bump();\n             true"}, {"sha": "2428710087fabb93de493e1ec8ab33ac706169e6", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 728, "deletions": 689, "changes": 1417, "blob_url": "https://github.com/rust-lang/rust/blob/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=27ce4d3f79cdc021a6bfe0f7009977e07a368770"}, {"sha": "01e050c1ffe4e4002fca404eddefaee2cf0fe52a", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27ce4d3f79cdc021a6bfe0f7009977e07a368770/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=27ce4d3f79cdc021a6bfe0f7009977e07a368770", "patch": "@@ -55,7 +55,7 @@ pub fn string_to_crate (source_str : @str) -> ast::Crate {\n \n // parse a string, return a crate and the ParseSess\n pub fn string_to_crate_and_sess (source_str : @str) -> (ast::Crate,@mut ParseSess) {\n-    let (p,ps) = string_to_parser_and_sess(source_str);\n+    let (mut p,ps) = string_to_parser_and_sess(source_str);\n     (p.parse_crate_mod(),ps)\n }\n "}]}