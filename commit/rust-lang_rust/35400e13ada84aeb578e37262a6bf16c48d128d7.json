{"sha": "35400e13ada84aeb578e37262a6bf16c48d128d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1NDAwZTEzYWRhODRhZWI1NzhlMzcyNjJhNmJmMTZjNDhkMTI4ZDc=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-03-11T04:34:17Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-03-11T04:34:17Z"}, "message": "Use loop instead of while(true) in libraries and compiler itself\n\nAnd remove spurious fails/unreachable() calls.", "tree": {"sha": "42dd7f9cf3d7260a2c2f39deb531ad05900ee380", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42dd7f9cf3d7260a2c2f39deb531ad05900ee380"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35400e13ada84aeb578e37262a6bf16c48d128d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35400e13ada84aeb578e37262a6bf16c48d128d7", "html_url": "https://github.com/rust-lang/rust/commit/35400e13ada84aeb578e37262a6bf16c48d128d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35400e13ada84aeb578e37262a6bf16c48d128d7/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98260a2a22ab693f2363c68339cf5bb9fca011ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/98260a2a22ab693f2363c68339cf5bb9fca011ab", "html_url": "https://github.com/rust-lang/rust/commit/98260a2a22ab693f2363c68339cf5bb9fca011ab"}], "stats": {"total": 185, "additions": 81, "deletions": 104}, "files": [{"sha": "174d62926f084434af9b6f14e267e3a40160199b", "filename": "src/libcore/int.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Flibcore%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Flibcore%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint.rs?ref=35400e13ada84aeb578e37262a6bf16c48d128d7", "patch": "@@ -64,16 +64,15 @@ fn parse_buf(buf: [u8], radix: uint) -> option<int> {\n         start = 1u;\n     }\n     let mut n = 0;\n-    while true {\n+    loop {\n         alt char::to_digit(buf[i] as char, radix) {\n           some(d) { n += (d as int) * power; }\n           none { ret none; }\n         }\n         power *= radix as int;\n         if i <= start { ret some(n); }\n         i -= 1u;\n-    }\n-    fail;\n+    };\n }\n \n #[doc = \"Parse a string to an int\"]"}, {"sha": "98bb98a0daaab610e86c58f2445eb050fea633d2", "filename": "src/libcore/u64.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Flibcore%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Flibcore%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fu64.rs?ref=35400e13ada84aeb578e37262a6bf16c48d128d7", "patch": "@@ -70,16 +70,15 @@ fn from_str(buf: str, radix: u64) -> option<u64> {\n     if str::len(buf) == 0u { ret none; }\n     let mut i = str::len(buf) - 1u;\n     let mut power = 1u64, n = 0u64;\n-    while true {\n+    loop {\n         alt char::to_digit(buf[i] as char, radix as uint) {\n           some(d) { n += d as u64 * power; }\n           none { ret none; }\n         }\n         power *= radix;\n         if i == 0u { ret some(n); }\n         i -= 1u;\n-    }\n-    fail;\n+    };\n }\n \n #[doc = \"Computes the bitwise complement\"]"}, {"sha": "88230bea09401f6bff25101e3670740982fb2ac2", "filename": "src/libcore/uint.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Flibcore%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Flibcore%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint.rs?ref=35400e13ada84aeb578e37262a6bf16c48d128d7", "patch": "@@ -133,16 +133,15 @@ fn parse_buf(buf: [u8], radix: uint) -> option<uint> {\n     let mut i = vec::len(buf) - 1u;\n     let mut power = 1u;\n     let mut n = 0u;\n-    while true {\n+    loop {\n         alt char::to_digit(buf[i] as char, radix) {\n           some(d) { n += d * power; }\n           none { ret none; }\n         }\n         power *= radix;\n         if i == 0u { ret some(n); }\n         i -= 1u;\n-    }\n-    fail;\n+    };\n }\n \n #[doc = \"Parse a string to an int\"]"}, {"sha": "246c7ee1d45d56d3a5df3baccece59cb846c77a7", "filename": "src/libstd/generic_os.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Flibstd%2Fgeneric_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Flibstd%2Fgeneric_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgeneric_os.rs?ref=35400e13ada84aeb578e37262a6bf16c48d128d7", "patch": "@@ -59,7 +59,7 @@ fn setenv(n: str, v: str) {\n #[cfg(target_os = \"win32\")]\n fn getenv(n: str) -> option<str> {\n     let nsize = 256u;\n-    while true {\n+    loop {\n         let v: [u8] = [];\n         vec::reserve(v, nsize);\n         let res =\n@@ -80,7 +80,6 @@ fn getenv(n: str) -> option<str> {\n             ret option::some(str::from_bytes(v)); // UTF-8 or fail\n         } else { nsize = res; }\n     }\n-    core::unreachable();\n }\n \n #[cfg(target_os = \"win32\")]"}, {"sha": "516aa25f05bde154a667c71d4980da5ec6cfe420", "filename": "src/libstd/io.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=35400e13ada84aeb578e37262a6bf16c48d128d7", "patch": "@@ -104,7 +104,7 @@ impl reader_util for reader {\n \n     fn read_line() -> str {\n         let buf: [u8] = [];\n-        while true {\n+        loop {\n             let ch = self.read_byte();\n             if ch == -1 || ch == 10 { break; }\n             buf += [ch as u8];\n@@ -114,7 +114,7 @@ impl reader_util for reader {\n \n     fn read_c_str() -> str {\n         let buf: [u8] = [];\n-        while true {\n+        loop {\n             let ch = self.read_byte();\n             if ch < 1 { break; } else { buf += [ch as u8]; }\n         }"}, {"sha": "ca3d9f8b4d75b613c2985bdc641c639ca419ff9e", "filename": "src/libstd/json.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=35400e13ada84aeb578e37262a6bf16c48d128d7", "patch": "@@ -383,23 +383,23 @@ impl parser for parser {\n             ret ok(list(values));\n         }\n \n-        while true {\n+        loop {\n             alt self.parse_value() {\n               ok(v) { vec::push(values, v); }\n               e { ret e; }\n             }\n \n             self.parse_whitespace();\n-            if self.eof() { break; }\n+            if self.eof() {\n+                ret self.error(\"EOF while parsing list\");\n+            }\n \n             alt self.ch {\n               ',' { self.bump(); }\n               ']' { self.bump(); ret ok(list(values)); }\n               _ { ret self.error(\"expecting ',' or ']'\"); }\n             }\n-        }\n-\n-        ret self.error(\"EOF while parsing list\");\n+        };\n     }\n \n     fn parse_object() -> result::t<json, error> {"}, {"sha": "9f4254f20c4f74fa20b9083ac567ff1e199037dc", "filename": "src/libstd/list.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=35400e13ada84aeb578e37262a6bf16c48d128d7", "patch": "@@ -43,27 +43,25 @@ is returned. If `f` matches no elements then none is returned.\n fn find<T: copy, U: copy>(ls: list<T>, f: fn(T) -> option<U>)\n     -> option<U> {\n     let ls = ls;\n-    while true {\n+    loop {\n         alt ls {\n           cons(hd, tl) {\n             alt f(hd) { none { ls = *tl; } some(rs) { ret some(rs); } }\n           }\n-          nil { break; }\n+          nil { ret none; }\n         }\n-    }\n-    ret none;\n+    };\n }\n \n #[doc = \"Returns true if a list contains an element with the given value\"]\n fn has<T: copy>(ls: list<T>, elt: T) -> bool {\n     let ls = ls;\n-    while true {\n+    loop {\n         alt ls {\n           cons(hd, tl) { if elt == hd { ret true; } else { ls = *tl; } }\n-          nil { break; }\n+          nil { ret false; }\n         }\n-    }\n-    ret false;\n+    };\n }\n \n #[doc = \"Returns true if the list is empty\"]\n@@ -113,7 +111,7 @@ fn iter<T>(l: list<T>, f: fn(T)) {\n       cons(hd, tl) {\n         f(hd);\n         let cur = tl;\n-        while true {\n+        loop {\n             alt *cur {\n               cons(hd, tl) {\n                 f(hd);"}, {"sha": "ded9e1ee208a17244bc827289106268d24b2188e", "filename": "src/libstd/map.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=35400e13ada84aeb578e37262a6bf16c48d128d7", "patch": "@@ -96,7 +96,7 @@ mod chained {\n         e_root: @entry<K,V>) -> search_result<K,V> {\n         let e0 = e_root;\n         let comp = 1u;   // for logging\n-        while true {\n+        loop {\n             alt e0.next {\n               absent {\n                 #debug(\"search_tbl: absent, comp %u, hash %u, idx %u\",\n@@ -115,8 +115,7 @@ mod chained {\n                 }\n               }\n             }\n-        }\n-        core::unreachable();\n+        };\n     }\n \n     fn search_tbl<K: copy, V: copy>(\n@@ -209,7 +208,7 @@ mod chained {\n     fn foreach_entry<K: copy, V: copy>(chain0: chain<K,V>,\n                                      blk: fn(@entry<K,V>)) {\n         let chain = chain0;\n-        while true {\n+        loop {\n             alt chain {\n               absent { ret; }\n               present(entry) {"}, {"sha": "9c6c1b29c2409d0073f25bc61e2d0e39d87c2bdc", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=35400e13ada84aeb578e37262a6bf16c48d128d7", "patch": "@@ -800,7 +800,7 @@ mod node {\n         let buf = vec::to_mut(vec::init_elt(byte_len(node), 0u8));\n         let offset = 0u;//Current position in the buffer\n         let it = leaf_iterator::start(node);\n-        while true {\n+        loop {\n             alt(leaf_iterator::next(it)) {\n               option::none { break; }\n               option::some(x) {\n@@ -862,7 +862,7 @@ mod node {\n         //1. Gather all leaves as a forest\n         let forest = [mutable];\n         let it = leaf_iterator::start(node);\n-        while true {\n+        loop {\n             alt (leaf_iterator::next(it)) {\n               option::none   { break; }\n               option::some(x) { forest += [mutable @leaf(x)]; }\n@@ -896,7 +896,7 @@ mod node {\n     fn sub_bytes(node: @node, byte_offset: uint, byte_len: uint) -> @node {\n         let node        = node;\n         let byte_offset = byte_offset;\n-        while true {\n+        loop {\n             if byte_offset == 0u && byte_len == node::byte_len(node) {\n                 ret node;\n             }\n@@ -932,8 +932,7 @@ mod node {\n                 }\n               }\n             }\n-        }\n-        core::unreachable();\n+        };\n     }\n \n     #[doc =\"\n@@ -958,7 +957,7 @@ mod node {\n     fn sub_chars(node: @node, char_offset: uint, char_len: uint) -> @node {\n         let node        = node;\n         let char_offset = char_offset;\n-        while true {\n+        loop {\n             alt(*node) {\n               node::leaf(x) {\n                 if char_offset == 0u && char_len == x.char_len {\n@@ -997,8 +996,7 @@ mod node {\n                 }\n               }\n             }\n-        }\n-        core::unreachable();\n+        };\n     }\n \n     fn concat2(left: @node, right: @node) -> @node {\n@@ -1066,7 +1064,7 @@ mod node {\n     \"]\n     fn loop_leaves(node: @node, it: fn(leaf) -> bool) -> bool{\n         let current = node;\n-        while true {\n+        loop {\n             alt(*current) {\n               leaf(x) {\n                 ret it(x);\n@@ -1079,8 +1077,7 @@ mod node {\n                 }\n               }\n             }\n-        }\n-        core::unreachable();\n+        };\n     }\n \n     #[doc =\"\n@@ -1103,7 +1100,7 @@ mod node {\n     fn char_at(node: @node, pos: uint) -> char {\n         let node    = node;\n         let pos     = pos;\n-        while true {\n+        loop {\n             alt *node {\n               leaf(x) {\n                 ret str::char_at(*x.content, pos);\n@@ -1114,8 +1111,7 @@ mod node {\n                        else { pos -= left_len; right };\n               }\n             }\n-        }\n-        core::unreachable();\n+        };\n     }\n \n     mod leaf_iterator {\n@@ -1139,7 +1135,7 @@ mod node {\n \n         fn next(it: t) -> option<leaf> {\n             if it.stackpos < 0 { ret option::none; }\n-            while true {\n+            loop {\n                 let current = it.stack[it.stackpos];\n                 it.stackpos -= 1;\n                 alt(*current) {\n@@ -1153,8 +1149,7 @@ mod node {\n                     ret option::some(x);\n                   }\n                 }\n-            }\n-            core::unreachable();\n+            };\n         }\n     }\n \n@@ -1182,7 +1177,7 @@ mod node {\n         }\n \n         fn next(it: t) -> option<char> {\n-            while true {\n+            loop {\n                 alt(get_current_or_next_leaf(it)) {\n                   option::none { ret option::none; }\n                   option::some(_) {\n@@ -1197,8 +1192,7 @@ mod node {\n                     }\n                   }\n                 }\n-            }\n-            core::unreachable();\n+            };\n         }\n \n         fn get_current_or_next_leaf(it: t) -> option<leaf> {\n@@ -1326,7 +1320,7 @@ mod tests {\n \n         let len = 0u;\n         let it  = iterator::char::start(r);\n-        while true {\n+        loop {\n             alt(node::char_iterator::next(it)) {\n               option::none { break; }\n               option::some(_) { len += 1u; }"}, {"sha": "6a78a23777e65ebe4d0c1fc6b5447cfd5c6a5d4e", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=35400e13ada84aeb578e37262a6bf16c48d128d7", "patch": "@@ -100,7 +100,7 @@ fn qsort3<T: copy>(compare_func_lt: le<T>, compare_func_eq: le<T>,\n     let j: int = right;\n     let p: int = i;\n     let q: int = j;\n-    while true {\n+    loop {\n         i += 1;\n         while compare_func_lt(copy arr[i], v) { i += 1; }\n         j -= 1;"}, {"sha": "37bb1e66f272febdaeb77f8de9f9fbae0162ff35", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=35400e13ada84aeb578e37262a6bf16c48d128d7", "patch": "@@ -96,7 +96,7 @@ fn parse_path(st: @pstate) -> @ast::path {\n     let idents: [ast::ident] = [];\n     fn is_last(c: char) -> bool { ret c == '(' || c == ':'; }\n     idents += [parse_ident_(st, is_last)];\n-    while true {\n+    loop {\n         alt peek(st) {\n           ':' { next(st); next(st); }\n           c {\n@@ -106,8 +106,7 @@ fn parse_path(st: @pstate) -> @ast::path {\n             } else { idents += [parse_ident_(st, is_last)]; }\n           }\n         }\n-    }\n-    fail \"parse_path: ill-formed path\";\n+    };\n }\n \n fn parse_constr_arg(st: @pstate) -> ast::fn_constr_arg {\n@@ -328,28 +327,26 @@ fn parse_def(st: @pstate, conv: conv_did) -> ast::def_id {\n \n fn parse_int(st: @pstate) -> int {\n     let n = 0;\n-    while true {\n+    loop {\n         let cur = peek(st);\n-        if cur < '0' || cur > '9' { break; }\n+        if cur < '0' || cur > '9' { ret n; }\n         st.pos = st.pos + 1u;\n         n *= 10;\n         n += (cur as int) - ('0' as int);\n-    }\n-    ret n;\n+    };\n }\n \n fn parse_hex(st: @pstate) -> uint {\n     let n = 0u;\n-    while true {\n+    loop {\n         let cur = peek(st);\n-        if (cur < '0' || cur > '9') && (cur < 'a' || cur > 'f') { break; }\n+        if (cur < '0' || cur > '9') && (cur < 'a' || cur > 'f') { ret n; }\n         st.pos = st.pos + 1u;\n         n *= 16u;\n         if '0' <= cur && cur <= '9' {\n             n += (cur as uint) - ('0' as uint);\n         } else { n += 10u + (cur as uint) - ('a' as uint); }\n-    }\n-    ret n;\n+    };\n }\n \n fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::fn_ty {\n@@ -405,7 +402,7 @@ fn parse_bounds_data(data: @[u8], start: uint,\n \n fn parse_bounds(st: @pstate, conv: conv_did) -> @[ty::param_bound] {\n     let bounds = [];\n-    while true {\n+    loop {\n         bounds += [alt check next(st) {\n           'S' { ty::bound_send }\n           'C' { ty::bound_copy }"}, {"sha": "126f24caeffc5acb09cb291b387723d0ed364a05", "filename": "src/rustc/middle/alias.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Frustc%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Frustc%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Falias.rs?ref=35400e13ada84aeb578e37262a6bf16c48d128d7", "patch": "@@ -661,16 +661,15 @@ fn unsafe_set(from: option<unsafe_ty>) -> [unsafe_ty] {\n fn find_invalid(id: node_id, lst: list<@invalid>)\n     -> option<@invalid> {\n     let cur = lst;\n-    while true {\n+    loop {\n         alt cur {\n-          list::nil { break; }\n+          list::nil { ret none; }\n           list::cons(head, tail) {\n             if head.node_id == id { ret some(head); }\n             cur = *tail;\n           }\n         }\n-    }\n-    ret none;\n+    };\n }\n \n fn join_invalid(a: list<@invalid>, b: list<@invalid>) -> list<@invalid> {"}, {"sha": "821b4a73402920b9bafc05a385f438dd73962433", "filename": "src/rustc/middle/mutbl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Frustc%2Fmiddle%2Fmutbl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Frustc%2Fmiddle%2Fmutbl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmutbl.rs?ref=35400e13ada84aeb578e37262a6bf16c48d128d7", "patch": "@@ -16,7 +16,7 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n    {ex: @expr, ds: @[deref]} {\n     fn maybe_auto_unbox(tcx: ty::ctxt, t: ty::t) -> {t: ty::t, ds: [deref]} {\n         let ds = [], t = t;\n-        while true {\n+        loop {\n             alt ty::get(t).struct {\n               ty::ty_box(mt) {\n                 ds += [@{mutbl: mt.mutbl == m_mutbl,\n@@ -49,7 +49,7 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n         ret {t: t, ds: ds};\n     }\n     let ds: [deref] = [], ex = ex;\n-    while true {\n+    loop {\n         alt copy ex.node {\n           expr_field(base, ident, _) {\n             let auto_unbox = maybe_auto_unbox(tcx, ty::expr_ty(tcx, base));"}, {"sha": "56d2cc973a01789a1ba962b3db4bea9e2c6b20fd", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=35400e13ada84aeb578e37262a6bf16c48d128d7", "patch": "@@ -677,7 +677,7 @@ fn follow_import(e: env, sc: scopes, path: [ident], sp: span) ->\n     let path_len = vec::len(path);\n     let dcur = lookup_in_scope_strict(e, sc, sp, path[0], ns_module);\n     let i = 1u;\n-    while true {\n+    loop {\n        alt dcur {\n           some(dcur_def) {\n             if i == path_len { break; }\n@@ -790,7 +790,7 @@ fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n           }\n           some(dcur_) {\n             let dcur = dcur_, i = 1u;\n-            while true {\n+            loop {\n                 if i == n_idents - 1u {\n                     let impls = [];\n                     find_impls_in_mod(e, dcur, impls, some(end_id));\n@@ -846,7 +846,7 @@ enum ctxt { in_mod(def), in_scope(scopes), }\n fn unresolved_err(e: env, cx: ctxt, sp: span, name: ident, kind: str) {\n     fn find_fn_or_mod_scope(sc: scopes) -> option<scope> {\n         let sc = sc;\n-        while true {\n+        loop {\n             alt sc {\n               cons(cur, rest) {\n                 alt cur {\n@@ -860,8 +860,7 @@ fn unresolved_err(e: env, cx: ctxt, sp: span, name: ident, kind: str) {\n               }\n               _ { ret none; }\n             }\n-        }\n-        core::unreachable()\n+        };\n     }\n     let path = name;\n     alt cx {\n@@ -1098,7 +1097,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n     // Used to determine whether self is in scope\n     let left_fn_level2 = false;\n     let sc = sc;\n-    while true {\n+    loop {\n         alt copy sc {\n           nil { ret none; }\n           cons(hd, tl) {\n@@ -1150,8 +1149,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n             sc = *tl;\n           }\n         }\n-    }\n-    e.sess.bug(\"reached unreachable code in lookup_in_scope\"); // sigh\n+    };\n }\n \n fn lookup_in_ty_params(e: env, name: ident, ty_params: [ast::ty_param])\n@@ -1766,7 +1764,7 @@ fn check_mod_name(e: env, name: ident, entries: list<mod_index_entry>) {\n     fn dup(e: env, sp: span, word: str, name: ident) {\n         e.sess.span_fatal(sp, \"duplicate definition of \" + word + name);\n     }\n-    while true {\n+    loop {\n         alt entries {\n           cons(entry, rest) {\n             if !is_none(lookup_in_mie(e, entry, ns_val(value_or_enum))) {"}, {"sha": "03749b86818c3942ee6bb9d47246c17e2274d91c", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=35400e13ada84aeb578e37262a6bf16c48d128d7", "patch": "@@ -1829,7 +1829,7 @@ fn autoderef(cx: block, v: ValueRef, t: ty::t) -> result_t {\n     let v1: ValueRef = v;\n     let t1: ty::t = t;\n     let ccx = cx.ccx();\n-    while true {\n+    loop {\n         alt ty::get(t1).struct {\n           ty::ty_box(mt) {\n             let body = GEPi(cx, v1, [0, abi::box_field_body]);\n@@ -2935,7 +2935,7 @@ fn invoke_(bcx: block, llfn: ValueRef, llargs: [ValueRef],\n fn get_landing_pad(bcx: block) -> BasicBlockRef {\n     fn in_lpad_scope_cx(bcx: block, f: fn(scope_info)) {\n         let bcx = bcx;\n-        while true {\n+        loop {\n             alt bcx.kind {\n               block_scope(info) {\n                 if info.cleanups.len() > 0u || bcx.parent == parent_none {\n@@ -3493,7 +3493,7 @@ fn trans_break_cont(bcx: block, to_end: bool)\n     -> block {\n     // Locate closest loop block, outputting cleanup as we go.\n     let unwind = bcx, target = bcx;\n-    while true {\n+    loop {\n         alt unwind.kind {\n           block_scope({is_loop: some({cnt, brk}), _}) {\n             target = if to_end {\n@@ -3748,7 +3748,7 @@ fn trans_block_cleanups(bcx: block, cleanup_cx: block) ->\n fn cleanup_and_leave(bcx: block, upto: option<BasicBlockRef>,\n                      leave: option<BasicBlockRef>) {\n     let cur = bcx, bcx = bcx;\n-    while true {\n+    loop {\n         alt cur.kind {\n           block_scope(info) if info.cleanups.len() > 0u {\n             for exists in info.cleanup_paths {"}, {"sha": "748a27999a08382fcded52acccd607a10fd4089e", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=35400e13ada84aeb578e37262a6bf16c48d128d7", "patch": "@@ -398,7 +398,7 @@ fn struct_elt(llstructty: TypeRef, n: uint) -> TypeRef unsafe {\n \n fn in_scope_cx(cx: block, f: fn(scope_info)) {\n     let cur = cx;\n-    while true {\n+    loop {\n         alt cur.kind {\n           block_scope(info) { f(info); ret; }\n           _ {}"}, {"sha": "076706b396b2f5e8e17044d66997cb6c20bdc89a", "filename": "src/rustc/syntax/parse/lexer.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Frustc%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Frustc%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fparse%2Flexer.rs?ref=35400e13ada84aeb578e37262a6bf16c48d128d7", "patch": "@@ -171,18 +171,17 @@ fn scan_exponent(rdr: reader) -> option<str> {\n \n fn scan_digits(rdr: reader, radix: uint) -> str {\n     let rslt = \"\";\n-    while true {\n+    loop {\n         let c = rdr.curr;\n         if c == '_' { rdr.bump(); cont; }\n         alt char::to_digit(c, radix) {\n           some(d) {\n             str::push_char(rslt, c);\n             rdr.bump();\n           }\n-          _ { break; }\n+          _ { ret rslt; }\n         }\n-    }\n-    ret rslt;\n+    };\n }\n \n fn scan_number(c: char, rdr: reader) -> token::token {\n@@ -711,7 +710,7 @@ fn gather_comments_and_literals(cm: codemap::codemap,\n     let literals: [lit] = [];\n     let first_read: bool = true;\n     while !rdr.is_eof() {\n-        while true {\n+        loop {\n             let code_to_the_left = !first_read;\n             consume_non_eol_whitespace(rdr);\n             if rdr.curr == '\\n' {"}, {"sha": "e1309fc264138bfbeb02957539da097ec124d78b", "filename": "src/rustc/syntax/parse/parser.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs?ref=35400e13ada84aeb578e37262a6bf16c48d128d7", "patch": "@@ -367,12 +367,11 @@ fn parse_constrs<T: copy>(pser: fn(parser) -> @ast::constr_general<T>,\n                          p: parser) ->\n    [@ast::constr_general<T>] {\n     let constrs: [@ast::constr_general<T>] = [];\n-    while true {\n+    loop {\n         let constr = pser(p);\n         constrs += [constr];\n-        if p.token == token::COMMA { p.bump(); } else { break; }\n-    }\n-    constrs\n+        if p.token == token::COMMA { p.bump(); } else { ret constrs; }\n+    };\n }\n \n fn parse_type_constraints(p: parser) -> [@ast::ty_constr] {\n@@ -1030,7 +1029,7 @@ fn parse_dot_or_call_expr_with(p: parser, e0: pexpr) -> pexpr {\n     let e = e0;\n     let lo = e.span.lo;\n     let hi = e.span.hi;\n-    while true {\n+    loop {\n         // expr.f\n         if eat(p, token::DOT) {\n             alt p.token {\n@@ -1310,7 +1309,7 @@ fn parse_capture_clause(p: parser) -> @ast::capture_clause {\n \n     fn eat_ident_list(p: parser) -> [@ast::capture_item] {\n         let res = [];\n-        while true {\n+        loop {\n             alt p.token {\n               token::IDENT(_, _) {\n                 let id = p.get_id();\n@@ -1324,8 +1323,7 @@ fn parse_capture_clause(p: parser) -> @ast::capture_clause {\n \n               _ { ret res; }\n             }\n-        }\n-        core::unreachable();\n+        };\n     }\n \n     let copies = [];\n@@ -1471,11 +1469,10 @@ fn parse_initializer(p: parser) -> option<ast::initializer> {\n \n fn parse_pats(p: parser) -> [@ast::pat] {\n     let pats = [];\n-    while true {\n+    loop {\n         pats += [parse_pat(p)];\n-        if p.token == token::BINOP(token::OR) { p.bump(); } else { break; }\n-    }\n-    ret pats;\n+        if p.token == token::BINOP(token::OR) { p.bump(); } else { ret pats; }\n+    };\n }\n \n fn parse_pat(p: parser) -> @ast::pat {"}, {"sha": "43f2c1b3db7095dc568f26bfc2ba513bf4c5d5fc", "filename": "src/rustc/syntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Frustc%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35400e13ada84aeb578e37262a6bf16c48d128d7/src%2Frustc%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fprint%2Fpprust.rs?ref=35400e13ada84aeb578e37262a6bf16c48d128d7", "patch": "@@ -1538,7 +1538,7 @@ fn print_remaining_comments(s: ps) {\n     // If there aren't any remaining comments, then we need to manually\n     // make sure there is a line break at the end.\n     if option::is_none(next_comment(s)) { hardbreak(s.s); }\n-    while true {\n+    loop {\n         alt next_comment(s) {\n           some(cmnt) { print_comment(s, cmnt); s.cur_cmnt += 1u; }\n           _ { break; }\n@@ -1610,7 +1610,7 @@ fn next_lit(s: ps, pos: uint) -> option<lexer::lit> {\n }\n \n fn maybe_print_comment(s: ps, pos: uint) {\n-    while true {\n+    loop {\n         alt next_comment(s) {\n           some(cmnt) {\n             if cmnt.pos < pos {"}]}