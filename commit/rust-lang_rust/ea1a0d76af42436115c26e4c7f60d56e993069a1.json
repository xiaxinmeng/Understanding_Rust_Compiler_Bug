{"sha": "ea1a0d76af42436115c26e4c7f60d56e993069a1", "node_id": "C_kwDOAAsO6NoAKGVhMWEwZDc2YWY0MjQzNjExNWMyNmU0YzdmNjBkNTZlOTkzMDY5YTE", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2023-05-06T00:09:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-05-06T00:09:32Z"}, "message": "Rollup merge of #111139 - fortanix:raoul/fix_mxcsr_configuration_dependent_timing, r=thomcc\n\nFix MXCSR configuration dependent timing\n\nDependent on the (potentially secret) data some vector instructions operate on, and the content in MXCSR, instruction retirement may be delayed by one cycle. This is a potential side channel.\n\nThis PR fixes this vulnerability for the `x86_64-fortanix-unknown-sgx` platform by loading MXCSR with `0x1fbf` through an `xrstor` instruction when the enclave is entered and executing an `lfence` immediately after. Other changes of the MXCSR happen only when the enclave is about to be exited and no vector instructions will be executed before it will actually do so. Users of EDP who change the MXCSR and do wish to defend against this side channel, will need to implement the software mitigation described [here](https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/best-practices/mxcsr-configuration-dependent-timing.html).\n\ncc: `@jethrogb` `@monokles`", "tree": {"sha": "356010c33512e1ecaaa9c2ed9833aff0e8d76087", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/356010c33512e1ecaaa9c2ed9833aff0e8d76087"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea1a0d76af42436115c26e4c7f60d56e993069a1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkVZq8CRBK7hj4Ov3rIwAAa4oIAIkflkOrnQFQtgb0hs0SqZWb\ncIfKDJrHBKb3j5Ffzo1efL/EDarN37bA8pTfuI9jbHF7vaZ8mohfQfVYb306hKJe\nkEn3s08ExLTnsdX8iYdIk2+2nTYk7/tyy3rOlRf3JF6m+8FhkxSzztqpqcjQ9QSX\nUoJmYTS9cf8Frykncq/DKworzWd/ATez4vpo6kcGnPBRdJ88FvfjfRgM3DRJyPBu\nE7sqj6dNcPOcXqJxZPd/dreR/wU7G9Amwemizzp3gKXvf1SsaaP6w0tBU0p/nQX/\nWgpJnZXeskkV6o4813Hb3bVvt+BSPjKlZIjq9Kn5UfGZUT1jmGeY6zRDdTY8Q28=\n=229b\n-----END PGP SIGNATURE-----\n", "payload": "tree 356010c33512e1ecaaa9c2ed9833aff0e8d76087\nparent 3d9a1de690c794fc72102d2de2324beeefe81322\nparent 97eab4db84715ebc475607e24dcdc65c6e0dd5d5\nauthor Yuki Okushi <jtitor@2k36.org> 1683331772 +0900\ncommitter GitHub <noreply@github.com> 1683331772 +0900\n\nRollup merge of #111139 - fortanix:raoul/fix_mxcsr_configuration_dependent_timing, r=thomcc\n\nFix MXCSR configuration dependent timing\n\nDependent on the (potentially secret) data some vector instructions operate on, and the content in MXCSR, instruction retirement may be delayed by one cycle. This is a potential side channel.\n\nThis PR fixes this vulnerability for the `x86_64-fortanix-unknown-sgx` platform by loading MXCSR with `0x1fbf` through an `xrstor` instruction when the enclave is entered and executing an `lfence` immediately after. Other changes of the MXCSR happen only when the enclave is about to be exited and no vector instructions will be executed before it will actually do so. Users of EDP who change the MXCSR and do wish to defend against this side channel, will need to implement the software mitigation described [here](https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/best-practices/mxcsr-configuration-dependent-timing.html).\n\ncc: `@jethrogb` `@monokles`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea1a0d76af42436115c26e4c7f60d56e993069a1", "html_url": "https://github.com/rust-lang/rust/commit/ea1a0d76af42436115c26e4c7f60d56e993069a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea1a0d76af42436115c26e4c7f60d56e993069a1/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d9a1de690c794fc72102d2de2324beeefe81322", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d9a1de690c794fc72102d2de2324beeefe81322", "html_url": "https://github.com/rust-lang/rust/commit/3d9a1de690c794fc72102d2de2324beeefe81322"}, {"sha": "97eab4db84715ebc475607e24dcdc65c6e0dd5d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/97eab4db84715ebc475607e24dcdc65c6e0dd5d5", "html_url": "https://github.com/rust-lang/rust/commit/97eab4db84715ebc475607e24dcdc65c6e0dd5d5"}], "stats": {"total": 6, "additions": 5, "deletions": 1}, "files": [{"sha": "8a063b65dac50357ba3002236f4b4c1cef23afee", "filename": "library/std/src/sys/sgx/abi/entry.S", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea1a0d76af42436115c26e4c7f60d56e993069a1/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fentry.S", "raw_url": "https://github.com/rust-lang/rust/raw/ea1a0d76af42436115c26e4c7f60d56e993069a1/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fentry.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fentry.S?ref=ea1a0d76af42436115c26e4c7f60d56e993069a1", "patch": "@@ -26,7 +26,7 @@ IMAGE_BASE:\n .Lxsave_clear:\n .org .+24\n .Lxsave_mxcsr:\n-    .short 0x1f80\n+    .short 0x1fbf\n \n /*  We can store a bunch of data in the gap between MXCSR and the XSAVE header */\n \n@@ -178,6 +178,7 @@ sgx_entry:\n     mov $-1, %rax\n     mov $-1, %rdx\n     xrstor .Lxsave_clear(%rip)\n+    lfence\n     mov %r10, %rdx\n \n /*  check if returning from usercall */\n@@ -311,6 +312,9 @@ usercall:\n     movq $0,%gs:tcsls_last_rsp\n /*  restore callee-saved state, cf. \"save\" above */\n     mov %r11,%rsp\n+    /* MCDT mitigation requires an lfence after ldmxcsr _before_ any of the affected  */\n+    /* vector instructions is used. We omit the lfence here as one is required before */\n+    /* the jmp instruction anyway. */\n     ldmxcsr (%rsp)\n     fldcw 4(%rsp)\n     add $8, %rsp"}]}