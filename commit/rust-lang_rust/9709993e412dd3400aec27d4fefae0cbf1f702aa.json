{"sha": "9709993e412dd3400aec27d4fefae0cbf1f702aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3MDk5OTNlNDEyZGQzNDAwYWVjMjdkNGZlZmFlMGNiZjFmNzAyYWE=", "commit": {"author": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-09T07:43:10Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-09T08:16:07Z"}, "message": "Move unnecessary_cast to its own module", "tree": {"sha": "94f891bf956a8ea3b5cf3829dca36a445d76f959", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94f891bf956a8ea3b5cf3829dca36a445d76f959"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9709993e412dd3400aec27d4fefae0cbf1f702aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9709993e412dd3400aec27d4fefae0cbf1f702aa", "html_url": "https://github.com/rust-lang/rust/commit/9709993e412dd3400aec27d4fefae0cbf1f702aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9709993e412dd3400aec27d4fefae0cbf1f702aa/comments", "author": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a383e034dc2f3d9cb53bd7164447fe7f3bfbf08c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a383e034dc2f3d9cb53bd7164447fe7f3bfbf08c", "html_url": "https://github.com/rust-lang/rust/commit/a383e034dc2f3d9cb53bd7164447fe7f3bfbf08c"}], "stats": {"total": 226, "additions": 128, "deletions": 98}, "files": [{"sha": "d8c7443650141fb4fd8cb2513611587a646a5d4a", "filename": "clippy_lints/src/casts/mod.rs", "status": "modified", "additions": 22, "deletions": 98, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/9709993e412dd3400aec27d4fefae0cbf1f702aa/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9709993e412dd3400aec27d4fefae0cbf1f702aa/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs?ref=9709993e412dd3400aec27d4fefae0cbf1f702aa", "patch": "@@ -3,26 +3,26 @@ mod cast_possible_truncation;\n mod cast_possible_wrap;\n mod cast_precision_loss;\n mod cast_sign_loss;\n+mod unnecessary_cast;\n mod utils;\n \n use std::borrow::Cow;\n \n use if_chain::if_chain;\n-use rustc_ast::{LitFloatType, LitIntType, LitKind};\n+use rustc_ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, GenericArg, Lit, MutTy, Mutability, TyKind, UnOp};\n+use rustc_hir::{Expr, ExprKind, GenericArg, MutTy, Mutability, TyKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, FloatTy, InferTy, Ty, TypeAndMut, UintTy};\n+use rustc_middle::ty::{self, Ty, TypeAndMut, UintTy};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol::sym;\n use rustc_target::abi::LayoutOf;\n \n use crate::utils::sugg::Sugg;\n use crate::utils::{\n-    is_hir_ty_cfg_dependant, meets_msrv, numeric_literal::NumericLiteral, snippet_opt, snippet_with_applicability,\n-    span_lint, span_lint_and_sugg, span_lint_and_then,\n+    is_hir_ty_cfg_dependant, meets_msrv, snippet_with_applicability, span_lint, span_lint_and_sugg, span_lint_and_then,\n };\n \n use utils::int_ty_to_nbits;\n@@ -284,72 +284,25 @@ fn is_c_void(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n     false\n }\n \n-/// Returns the mantissa bits wide of a fp type.\n-/// Will return 0 if the type is not a fp\n-fn fp_ty_mantissa_nbits(typ: Ty<'_>) -> u32 {\n-    match typ.kind() {\n-        ty::Float(FloatTy::F32) => 23,\n-        ty::Float(FloatTy::F64) | ty::Infer(InferTy::FloatVar(_)) => 52,\n-        _ => 0,\n-    }\n-}\n-\n impl<'tcx> LateLintPass<'tcx> for Casts {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if expr.span.from_expansion() {\n             return;\n         }\n-        if let ExprKind::Cast(ref ex, cast_to) = expr.kind {\n+        if let ExprKind::Cast(ref cast_expr, cast_to) = expr.kind {\n             if is_hir_ty_cfg_dependant(cx, cast_to) {\n                 return;\n             }\n-            let (cast_from, cast_to) = (cx.typeck_results().expr_ty(ex), cx.typeck_results().expr_ty(expr));\n-            lint_fn_to_numeric_cast(cx, expr, ex, cast_from, cast_to);\n-            if let Some(lit) = get_numeric_literal(ex) {\n-                let literal_str = snippet_opt(cx, ex.span).unwrap_or_default();\n-\n-                if_chain! {\n-                    if let LitKind::Int(n, _) = lit.node;\n-                    if let Some(src) = snippet_opt(cx, lit.span);\n-                    if cast_to.is_floating_point();\n-                    if let Some(num_lit) = NumericLiteral::from_lit_kind(&src, &lit.node);\n-                    let from_nbits = 128 - n.leading_zeros();\n-                    let to_nbits = fp_ty_mantissa_nbits(cast_to);\n-                    if from_nbits != 0 && to_nbits != 0 && from_nbits <= to_nbits && num_lit.is_decimal();\n-                    then {\n-                        let literal_str = if is_unary_neg(ex) { format!(\"-{}\", num_lit.integer) } else { num_lit.integer.into() };\n-                        show_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n-                        return;\n-                    }\n-                }\n-\n-                match lit.node {\n-                    LitKind::Int(_, LitIntType::Unsuffixed) if cast_to.is_integral() => {\n-                        show_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n-                    },\n-                    LitKind::Float(_, LitFloatType::Unsuffixed) if cast_to.is_floating_point() => {\n-                        show_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n-                    },\n-                    LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::Float(_, LitFloatType::Unsuffixed) => {},\n-                    _ => {\n-                        if cast_from.kind() == cast_to.kind() && !in_external_macro(cx.sess(), expr.span) {\n-                            span_lint(\n-                                cx,\n-                                UNNECESSARY_CAST,\n-                                expr.span,\n-                                &format!(\n-                                    \"casting to the same type is unnecessary (`{}` -> `{}`)\",\n-                                    cast_from, cast_to\n-                                ),\n-                            );\n-                        }\n-                    },\n-                }\n-            }\n-            if cast_from.is_numeric() && cast_to.is_numeric() && !in_external_macro(cx.sess(), expr.span) {\n-                lint_numeric_casts(cx, expr, ex, cast_from, cast_to);\n-            }\n+            let (cast_from, cast_to) = (\n+                cx.typeck_results().expr_ty(cast_expr),\n+                cx.typeck_results().expr_ty(expr),\n+            );\n \n+            if unnecessary_cast::check(cx, expr, cast_expr, cast_from, cast_to) {\n+                return;\n+            }\n+            lint_fn_to_numeric_cast(cx, expr, cast_expr, cast_from, cast_to);\n+            lint_numeric_casts(cx, expr, cast_expr, cast_from, cast_to);\n             lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n         } else if let ExprKind::MethodCall(method_path, _, args, _) = expr.kind {\n             if_chain! {\n@@ -368,49 +321,20 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n     }\n }\n \n-fn is_unary_neg(expr: &Expr<'_>) -> bool {\n-    matches!(expr.kind, ExprKind::Unary(UnOp::Neg, _))\n-}\n-\n-fn get_numeric_literal<'e>(expr: &'e Expr<'e>) -> Option<&'e Lit> {\n-    match expr.kind {\n-        ExprKind::Lit(ref lit) => Some(lit),\n-        ExprKind::Unary(UnOp::Neg, e) => {\n-            if let ExprKind::Lit(ref lit) = e.kind {\n-                Some(lit)\n-            } else {\n-                None\n-            }\n-        },\n-        _ => None,\n-    }\n-}\n-\n-fn show_unnecessary_cast(cx: &LateContext<'_>, expr: &Expr<'_>, literal_str: &str, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n-    let literal_kind_name = if cast_from.is_integral() { \"integer\" } else { \"float\" };\n-    span_lint_and_sugg(\n-        cx,\n-        UNNECESSARY_CAST,\n-        expr.span,\n-        &format!(\"casting {} literal to `{}` is unnecessary\", literal_kind_name, cast_to),\n-        \"try\",\n-        format!(\"{}_{}\", literal_str.trim_end_matches('.'), cast_to),\n-        Applicability::MachineApplicable,\n-    );\n-}\n-\n fn lint_numeric_casts<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &Expr<'tcx>,\n     cast_op: &Expr<'_>,\n     cast_from: Ty<'tcx>,\n     cast_to: Ty<'tcx>,\n ) {\n-    cast_possible_truncation::check(cx, expr, cast_from, cast_to);\n-    cast_possible_wrap::check(cx, expr, cast_from, cast_to);\n-    cast_precision_loss::check(cx, expr, cast_from, cast_to);\n-    cast_lossless::check(cx, expr, cast_op, cast_from, cast_to);\n-    cast_sign_loss::check(cx, expr, cast_op, cast_from, cast_to);\n+    if cast_from.is_numeric() && cast_to.is_numeric() && !in_external_macro(cx.sess(), expr.span) {\n+        cast_possible_truncation::check(cx, expr, cast_from, cast_to);\n+        cast_possible_wrap::check(cx, expr, cast_from, cast_to);\n+        cast_precision_loss::check(cx, expr, cast_from, cast_to);\n+        cast_lossless::check(cx, expr, cast_op, cast_from, cast_to);\n+        cast_sign_loss::check(cx, expr, cast_op, cast_from, cast_to);\n+    }\n }\n \n fn lint_cast_ptr_alignment<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, cast_from: Ty<'tcx>, cast_to: Ty<'tcx>) {"}, {"sha": "fa2a07ef1da0c098adb6374eec6594ee46f4a916", "filename": "clippy_lints/src/casts/unnecessary_cast.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/9709993e412dd3400aec27d4fefae0cbf1f702aa/clippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9709993e412dd3400aec27d4fefae0cbf1f702aa/clippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs?ref=9709993e412dd3400aec27d4fefae0cbf1f702aa", "patch": "@@ -0,0 +1,106 @@\n+use rustc_ast::{LitFloatType, LitIntType, LitKind};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, Lit, UnOp};\n+use rustc_lint::{LateContext, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty::{self, FloatTy, InferTy, Ty};\n+\n+use if_chain::if_chain;\n+\n+use crate::utils::{numeric_literal::NumericLiteral, snippet_opt, span_lint, span_lint_and_sugg};\n+\n+use super::UNNECESSARY_CAST;\n+\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    cast_expr: &Expr<'_>,\n+    cast_from: Ty<'_>,\n+    cast_to: Ty<'_>,\n+) -> bool {\n+    if let Some(lit) = get_numeric_literal(cast_expr) {\n+        let literal_str = snippet_opt(cx, cast_expr.span).unwrap_or_default();\n+\n+        if_chain! {\n+            if let LitKind::Int(n, _) = lit.node;\n+            if let Some(src) = snippet_opt(cx, lit.span);\n+            if cast_to.is_floating_point();\n+            if let Some(num_lit) = NumericLiteral::from_lit_kind(&src, &lit.node);\n+            let from_nbits = 128 - n.leading_zeros();\n+            let to_nbits = fp_ty_mantissa_nbits(cast_to);\n+            if from_nbits != 0 && to_nbits != 0 && from_nbits <= to_nbits && num_lit.is_decimal();\n+            then {\n+                let literal_str = if is_unary_neg(cast_expr) { format!(\"-{}\", num_lit.integer) } else { num_lit.integer.into() };\n+                lint_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n+                return true\n+            }\n+        }\n+\n+        match lit.node {\n+            LitKind::Int(_, LitIntType::Unsuffixed) if cast_to.is_integral() => {\n+                lint_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n+            },\n+            LitKind::Float(_, LitFloatType::Unsuffixed) if cast_to.is_floating_point() => {\n+                lint_unnecessary_cast(cx, expr, &literal_str, cast_from, cast_to);\n+            },\n+            LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::Float(_, LitFloatType::Unsuffixed) => {},\n+            _ => {\n+                if cast_from.kind() == cast_to.kind() && !in_external_macro(cx.sess(), expr.span) {\n+                    span_lint(\n+                        cx,\n+                        UNNECESSARY_CAST,\n+                        expr.span,\n+                        &format!(\n+                            \"casting to the same type is unnecessary (`{}` -> `{}`)\",\n+                            cast_from, cast_to\n+                        ),\n+                    );\n+                    return true;\n+                }\n+            },\n+        }\n+    }\n+\n+    false\n+}\n+\n+fn lint_unnecessary_cast(cx: &LateContext<'_>, expr: &Expr<'_>, literal_str: &str, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+    let literal_kind_name = if cast_from.is_integral() { \"integer\" } else { \"float\" };\n+    span_lint_and_sugg(\n+        cx,\n+        UNNECESSARY_CAST,\n+        expr.span,\n+        &format!(\"casting {} literal to `{}` is unnecessary\", literal_kind_name, cast_to),\n+        \"try\",\n+        format!(\"{}_{}\", literal_str.trim_end_matches('.'), cast_to),\n+        Applicability::MachineApplicable,\n+    );\n+}\n+\n+fn get_numeric_literal<'e>(expr: &'e Expr<'e>) -> Option<&'e Lit> {\n+    match expr.kind {\n+        ExprKind::Lit(ref lit) => Some(lit),\n+        ExprKind::Unary(UnOp::Neg, e) => {\n+            if let ExprKind::Lit(ref lit) = e.kind {\n+                Some(lit)\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    }\n+}\n+\n+/// Returns the mantissa bits wide of a fp type.\n+/// Will return 0 if the type is not a fp\n+fn fp_ty_mantissa_nbits(typ: Ty<'_>) -> u32 {\n+    match typ.kind() {\n+        ty::Float(FloatTy::F32) => 23,\n+        ty::Float(FloatTy::F64) | ty::Infer(InferTy::FloatVar(_)) => 52,\n+        _ => 0,\n+    }\n+}\n+\n+fn is_unary_neg(expr: &Expr<'_>) -> bool {\n+    matches!(expr.kind, ExprKind::Unary(UnOp::Neg, _))\n+}"}]}