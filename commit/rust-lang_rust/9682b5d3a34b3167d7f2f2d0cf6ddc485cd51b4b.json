{"sha": "9682b5d3a34b3167d7f2f2d0cf6ddc485cd51b4b", "node_id": "C_kwDOAAsO6NoAKDk2ODJiNWQzYTM0YjMxNjdkN2YyZjJkMGNmNmRkYzQ4NWNkNTFiNGI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-07T18:54:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-07T18:54:03Z"}, "message": "Auto merge of #101476 - ChrisDenton:BCryptRandom-fix, r=thomcc\n\nOpen a BCrypt algorithm handle\n\nFixes #101474, supplants #101456.\n\nReplaces use of a pseduo handle with manually opening a algorithm handle.\n\nMost interesting thing here is the atomics.\n\nr? `@thomcc`", "tree": {"sha": "d3c65dac6914a336a95bb333e3f7f635100bd583", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3c65dac6914a336a95bb333e3f7f635100bd583"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9682b5d3a34b3167d7f2f2d0cf6ddc485cd51b4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9682b5d3a34b3167d7f2f2d0cf6ddc485cd51b4b", "html_url": "https://github.com/rust-lang/rust/commit/9682b5d3a34b3167d7f2f2d0cf6ddc485cd51b4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9682b5d3a34b3167d7f2f2d0cf6ddc485cd51b4b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f91ca2878af792bc6969b97d78fe91b27739ac2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f91ca2878af792bc6969b97d78fe91b27739ac2d", "html_url": "https://github.com/rust-lang/rust/commit/f91ca2878af792bc6969b97d78fe91b27739ac2d"}, {"sha": "832c7af0ea93ec0d0dd121cf0988d82621582475", "url": "https://api.github.com/repos/rust-lang/rust/commits/832c7af0ea93ec0d0dd121cf0988d82621582475", "html_url": "https://github.com/rust-lang/rust/commit/832c7af0ea93ec0d0dd121cf0988d82621582475"}], "stats": {"total": 108, "additions": 88, "deletions": 20}, "files": [{"sha": "89d0ab59be89f3edcc15eba93163fd3a1485bcc4", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9682b5d3a34b3167d7f2f2d0cf6ddc485cd51b4b/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9682b5d3a34b3167d7f2f2d0cf6ddc485cd51b4b/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=9682b5d3a34b3167d7f2f2d0cf6ddc485cd51b4b", "patch": "@@ -66,6 +66,7 @@ pub type LPSYSTEM_INFO = *mut SYSTEM_INFO;\n pub type LPWSABUF = *mut WSABUF;\n pub type LPWSAOVERLAPPED = *mut c_void;\n pub type LPWSAOVERLAPPED_COMPLETION_ROUTINE = *mut c_void;\n+pub type BCRYPT_ALG_HANDLE = LPVOID;\n \n pub type PCONDITION_VARIABLE = *mut CONDITION_VARIABLE;\n pub type PLARGE_INTEGER = *mut c_longlong;\n@@ -278,14 +279,16 @@ pub const STATUS_INVALID_PARAMETER: NTSTATUS = 0xc000000d_u32 as _;\n pub const STATUS_PENDING: NTSTATUS = 0x103 as _;\n pub const STATUS_END_OF_FILE: NTSTATUS = 0xC0000011_u32 as _;\n pub const STATUS_NOT_IMPLEMENTED: NTSTATUS = 0xC0000002_u32 as _;\n+pub const STATUS_NOT_SUPPORTED: NTSTATUS = 0xC00000BB_u32 as _;\n \n // Equivalent to the `NT_SUCCESS` C preprocessor macro.\n // See: https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/using-ntstatus-values\n pub fn nt_success(status: NTSTATUS) -> bool {\n     status >= 0\n }\n \n-pub const BCRYPT_RNG_ALG_HANDLE: usize = 0x81;\n+// \"RNG\\0\"\n+pub const BCRYPT_RNG_ALGORITHM: &[u16] = &[b'R' as u16, b'N' as u16, b'G' as u16, 0];\n \n #[repr(C)]\n pub struct UNICODE_STRING {\n@@ -1229,11 +1232,18 @@ extern \"system\" {\n     // >= Vista / Server 2008\n     // https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptgenrandom\n     pub fn BCryptGenRandom(\n-        hAlgorithm: LPVOID,\n+        hAlgorithm: BCRYPT_ALG_HANDLE,\n         pBuffer: *mut u8,\n         cbBuffer: ULONG,\n         dwFlags: ULONG,\n     ) -> NTSTATUS;\n+    pub fn BCryptOpenAlgorithmProvider(\n+        phalgorithm: *mut BCRYPT_ALG_HANDLE,\n+        pszAlgId: LPCWSTR,\n+        pszimplementation: LPCWSTR,\n+        dwflags: ULONG,\n+    ) -> NTSTATUS;\n+    pub fn BCryptCloseAlgorithmProvider(hAlgorithm: BCRYPT_ALG_HANDLE, dwFlags: ULONG) -> NTSTATUS;\n }\n \n // Functions that aren't available on every version of Windows that we support,"}, {"sha": "d6cd8f80271620c1d619193d90a1bdfe4e75b097", "filename": "library/std/src/sys/windows/rand.rs", "status": "modified", "additions": 76, "deletions": 18, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/9682b5d3a34b3167d7f2f2d0cf6ddc485cd51b4b/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9682b5d3a34b3167d7f2f2d0cf6ddc485cd51b4b/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Frand.rs?ref=9682b5d3a34b3167d7f2f2d0cf6ddc485cd51b4b", "patch": "@@ -22,7 +22,6 @@\n //! [`RtlGenRandom`]: https://docs.microsoft.com/en-us/windows/win32/api/ntsecapi/nf-ntsecapi-rtlgenrandom\n //! [`BCryptGenRandom`]: https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptgenrandom\n //! [Pseudo-handle]: https://docs.microsoft.com/en-us/windows/win32/seccng/cng-algorithm-pseudo-handles\n-use crate::io;\n use crate::mem;\n use crate::ptr;\n use crate::sys::c;\n@@ -34,35 +33,94 @@ use crate::sys::c;\n /// [`HashMap`]: crate::collections::HashMap\n /// [`RandomState`]: crate::collections::hash_map::RandomState\n pub fn hashmap_random_keys() -> (u64, u64) {\n-    let mut v = (0, 0);\n-    let ret = unsafe {\n-        let size = mem::size_of_val(&v).try_into().unwrap();\n-        c::BCryptGenRandom(\n-            // BCRYPT_RNG_ALG_HANDLE is only supported in Windows 10+.\n-            // So for Windows 8.1 and Windows 7 we'll need a fallback when this fails.\n-            ptr::invalid_mut(c::BCRYPT_RNG_ALG_HANDLE),\n-            ptr::addr_of_mut!(v).cast(),\n-            size,\n-            0,\n-        )\n-    };\n-    if ret != 0 { fallback_rng() } else { v }\n+    Rng::open().and_then(|rng| rng.gen_random_keys()).unwrap_or_else(fallback_rng)\n+}\n+\n+struct Rng(c::BCRYPT_ALG_HANDLE);\n+impl Rng {\n+    #[cfg(miri)]\n+    fn open() -> Result<Self, c::NTSTATUS> {\n+        const BCRYPT_RNG_ALG_HANDLE: c::BCRYPT_ALG_HANDLE = ptr::invalid_mut(0x81);\n+        let _ = (\n+            c::BCryptOpenAlgorithmProvider,\n+            c::BCryptCloseAlgorithmProvider,\n+            c::BCRYPT_RNG_ALGORITHM,\n+            c::STATUS_NOT_SUPPORTED,\n+        );\n+        Ok(Self(BCRYPT_RNG_ALG_HANDLE))\n+    }\n+    #[cfg(not(miri))]\n+    // Open a handle to the RNG algorithm.\n+    fn open() -> Result<Self, c::NTSTATUS> {\n+        use crate::sync::atomic::AtomicPtr;\n+        use crate::sync::atomic::Ordering::{Acquire, Release};\n+        const ERROR_VALUE: c::LPVOID = ptr::invalid_mut(usize::MAX);\n+\n+        // An atomic is used so we don't need to reopen the handle every time.\n+        static HANDLE: AtomicPtr<crate::ffi::c_void> = AtomicPtr::new(ptr::null_mut());\n+\n+        let mut handle = HANDLE.load(Acquire);\n+        // We use a sentinel value to designate an error occurred last time.\n+        if handle == ERROR_VALUE {\n+            Err(c::STATUS_NOT_SUPPORTED)\n+        } else if handle.is_null() {\n+            let status = unsafe {\n+                c::BCryptOpenAlgorithmProvider(\n+                    &mut handle,\n+                    c::BCRYPT_RNG_ALGORITHM.as_ptr(),\n+                    ptr::null(),\n+                    0,\n+                )\n+            };\n+            if c::nt_success(status) {\n+                // If another thread opens a handle first then use that handle instead.\n+                let result = HANDLE.compare_exchange(ptr::null_mut(), handle, Release, Acquire);\n+                if let Err(previous_handle) = result {\n+                    // Close our handle and return the previous one.\n+                    unsafe { c::BCryptCloseAlgorithmProvider(handle, 0) };\n+                    handle = previous_handle;\n+                }\n+                Ok(Self(handle))\n+            } else {\n+                HANDLE.store(ERROR_VALUE, Release);\n+                Err(status)\n+            }\n+        } else {\n+            Ok(Self(handle))\n+        }\n+    }\n+\n+    fn gen_random_keys(self) -> Result<(u64, u64), c::NTSTATUS> {\n+        let mut v = (0, 0);\n+        let status = unsafe {\n+            let size = mem::size_of_val(&v).try_into().unwrap();\n+            c::BCryptGenRandom(self.0, ptr::addr_of_mut!(v).cast(), size, 0)\n+        };\n+        if c::nt_success(status) { Ok(v) } else { Err(status) }\n+    }\n }\n \n /// Generate random numbers using the fallback RNG function (RtlGenRandom)\n #[cfg(not(target_vendor = \"uwp\"))]\n #[inline(never)]\n-fn fallback_rng() -> (u64, u64) {\n+fn fallback_rng(rng_status: c::NTSTATUS) -> (u64, u64) {\n     let mut v = (0, 0);\n     let ret =\n         unsafe { c::RtlGenRandom(&mut v as *mut _ as *mut u8, mem::size_of_val(&v) as c::ULONG) };\n \n-    if ret != 0 { v } else { panic!(\"fallback RNG broken: {}\", io::Error::last_os_error()) }\n+    if ret != 0 {\n+        v\n+    } else {\n+        panic!(\n+            \"RNG broken: {rng_status:#x}, fallback RNG broken: {}\",\n+            crate::io::Error::last_os_error()\n+        )\n+    }\n }\n \n /// We can't use RtlGenRandom with UWP, so there is no fallback\n #[cfg(target_vendor = \"uwp\")]\n #[inline(never)]\n-fn fallback_rng() -> (u64, u64) {\n-    panic!(\"fallback RNG broken: RtlGenRandom() not supported on UWP\");\n+fn fallback_rng(rng_status: c::NTSTATUS) -> (u64, u64) {\n+    panic!(\"RNG broken: {rng_status:#x} fallback RNG broken: RtlGenRandom() not supported on UWP\");\n }"}]}