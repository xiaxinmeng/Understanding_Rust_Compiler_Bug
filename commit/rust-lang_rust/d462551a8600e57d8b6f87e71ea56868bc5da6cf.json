{"sha": "d462551a8600e57d8b6f87e71ea56868bc5da6cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0NjI1NTFhODYwMGU1N2Q4YjZmODdlNzFlYTU2ODY4YmM1ZGE2Y2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-01T01:04:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-01T01:04:31Z"}, "message": "Auto merge of #73706 - Aaron1011:fix/proc-macro-foreign-span, r=petrochenkov\n\nSerialize all foreign `SourceFile`s into proc-macro crate metadata\n\nNormally, we encode a `Span` that references a foreign `SourceFile` by\nencoding information about the foreign crate. When we decode this\n`Span`, we lookup the foreign crate in order to decode the `SourceFile`.\n\nHowever, this approach does not work for proc-macro crates. When we load\na proc-macro crate, we do not deserialzie any of its dependencies (since\na proc-macro crate can only export proc-macros). This means that we\ncannot serialize a reference to an upstream crate, since the associated\nmetadata will not be available when we try to deserialize it.\n\nThis commit modifies foreign span handling so that we treat all foreign\n`SourceFile`s as local `SourceFile`s when serializing a proc-macro.\nAll `SourceFile`s will be stored into the metadata of a proc-macro\ncrate, allowing us to cotinue to deserialize a proc-macro crate without\nneeding to load any of its dependencies.\n\nSince the number of foreign `SourceFile`s that we load during a\ncompilation session may be very large, we only serialize a `SourceFile`\nif we have also serialized a `Span` which requires it.", "tree": {"sha": "60b5aee3bec66ddb271cf8ee46233920332de4e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60b5aee3bec66ddb271cf8ee46233920332de4e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d462551a8600e57d8b6f87e71ea56868bc5da6cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d462551a8600e57d8b6f87e71ea56868bc5da6cf", "html_url": "https://github.com/rust-lang/rust/commit/d462551a8600e57d8b6f87e71ea56868bc5da6cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d462551a8600e57d8b6f87e71ea56868bc5da6cf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16957bd4d3a5377263f76ed74c572aad8e4b7e59", "url": "https://api.github.com/repos/rust-lang/rust/commits/16957bd4d3a5377263f76ed74c572aad8e4b7e59", "html_url": "https://github.com/rust-lang/rust/commit/16957bd4d3a5377263f76ed74c572aad8e4b7e59"}, {"sha": "37a48fa838e73f2c008bbbbd0db555f4852be354", "url": "https://api.github.com/repos/rust-lang/rust/commits/37a48fa838e73f2c008bbbbd0db555f4852be354", "html_url": "https://github.com/rust-lang/rust/commit/37a48fa838e73f2c008bbbbd0db555f4852be354"}], "stats": {"total": 269, "additions": 226, "deletions": 43}, "files": [{"sha": "1ac16e0d31193d3ccd8b55ced25ca52c19107659", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d462551a8600e57d8b6f87e71ea56868bc5da6cf/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d462551a8600e57d8b6f87e71ea56868bc5da6cf/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=d462551a8600e57d8b6f87e71ea56868bc5da6cf", "patch": "@@ -450,19 +450,17 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n         let imported_source_files = if tag == TAG_VALID_SPAN_LOCAL {\n             self.cdata().imported_source_files(sess)\n         } else {\n-            // FIXME: We don't decode dependencies of proc-macros.\n-            // Remove this once #69976 is merged\n+            // When we encode a proc-macro crate, all `Span`s should be encoded\n+            // with `TAG_VALID_SPAN_LOCAL`\n             if self.cdata().root.is_proc_macro_crate() {\n-                debug!(\n-                    \"SpecializedDecoder<Span>::specialized_decode: skipping span for proc-macro crate {:?}\",\n-                    self.cdata().cnum\n-                );\n                 // Decode `CrateNum` as u32 - using `CrateNum::decode` will ICE\n                 // since we don't have `cnum_map` populated.\n-                // This advances the decoder position so that we can continue\n-                // to read metadata.\n-                let _ = u32::decode(self)?;\n-                return Ok(DUMMY_SP);\n+                let cnum = u32::decode(self)?;\n+                panic!(\n+                    \"Decoding of crate {:?} tried to access proc-macro dep {:?}\",\n+                    self.cdata().root.name,\n+                    cnum\n+                );\n             }\n             // tag is TAG_VALID_SPAN_FOREIGN, checked by `debug_assert` above\n             let cnum = CrateNum::decode(self)?;\n@@ -990,8 +988,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                         DefKind::Macro(macro_kind(raw_macro)),\n                         self.local_def_id(def_index),\n                     );\n-                    let ident = Ident::from_str(raw_macro.name());\n-                    callback(Export { ident, res, vis: ty::Visibility::Public, span: DUMMY_SP });\n+                    let ident = self.item_ident(def_index, sess);\n+                    callback(Export {\n+                        ident,\n+                        res,\n+                        vis: ty::Visibility::Public,\n+                        span: self.get_span(def_index, sess),\n+                    });\n                 }\n             }\n             return;"}, {"sha": "fb4fee402abfb341b7de27d5e5263efba2673063", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 78, "deletions": 24, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/d462551a8600e57d8b6f87e71ea56868bc5da6cf/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d462551a8600e57d8b6f87e71ea56868bc5da6cf/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=d462551a8600e57d8b6f87e71ea56868bc5da6cf", "patch": "@@ -16,6 +16,7 @@ use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::itemlikevisit::{ItemLikeVisitor, ParItemLikeVisitor};\n use rustc_hir::lang_items;\n use rustc_hir::{AnonConst, GenericParamKind};\n+use rustc_index::bit_set::GrowableBitSet;\n use rustc_index::vec::Idx;\n use rustc_middle::hir::map::Map;\n use rustc_middle::middle::cstore::{EncodedMetadata, ForeignModule, LinkagePreference, NativeLib};\n@@ -51,7 +52,20 @@ struct EncodeContext<'tcx> {\n     interpret_allocs_inverse: Vec<interpret::AllocId>,\n \n     // This is used to speed up Span encoding.\n-    source_file_cache: Lrc<SourceFile>,\n+    // The `usize` is an index into the `MonotonicVec`\n+    // that stores the `SourceFile`\n+    source_file_cache: (Lrc<SourceFile>, usize),\n+    // The indices (into the `SourceMap`'s `MonotonicVec`)\n+    // of all of the `SourceFiles` that we need to serialize.\n+    // When we serialize a `Span`, we insert the index of its\n+    // `SourceFile` into the `GrowableBitSet`.\n+    //\n+    // This needs to be a `GrowableBitSet` and not a\n+    // regular `BitSet` because we may actually import new `SourceFiles`\n+    // during metadata encoding, due to executing a query\n+    // with a result containing a foreign `Span`.\n+    required_source_files: Option<GrowableBitSet<usize>>,\n+    is_proc_macro: bool,\n }\n \n macro_rules! encoder_methods {\n@@ -154,18 +168,23 @@ impl<'tcx> SpecializedEncoder<Span> for EncodeContext<'tcx> {\n         // The Span infrastructure should make sure that this invariant holds:\n         debug_assert!(span.lo <= span.hi);\n \n-        if !self.source_file_cache.contains(span.lo) {\n+        if !self.source_file_cache.0.contains(span.lo) {\n             let source_map = self.tcx.sess.source_map();\n             let source_file_index = source_map.lookup_source_file_idx(span.lo);\n-            self.source_file_cache = source_map.files()[source_file_index].clone();\n+            self.source_file_cache =\n+                (source_map.files()[source_file_index].clone(), source_file_index);\n         }\n \n-        if !self.source_file_cache.contains(span.hi) {\n+        if !self.source_file_cache.0.contains(span.hi) {\n             // Unfortunately, macro expansion still sometimes generates Spans\n             // that malformed in this way.\n             return TAG_INVALID_SPAN.encode(self);\n         }\n \n+        let source_files = self.required_source_files.as_mut().expect(\"Already encoded SourceMap!\");\n+        // Record the fact that we need to encode the data for this `SourceFile`\n+        source_files.insert(self.source_file_cache.1);\n+\n         // There are two possible cases here:\n         // 1. This span comes from a 'foreign' crate - e.g. some crate upstream of the\n         // crate we are writing metadata for. When the metadata for *this* crate gets\n@@ -176,7 +195,13 @@ impl<'tcx> SpecializedEncoder<Span> for EncodeContext<'tcx> {\n         // 2. This span comes from our own crate. No special hamdling is needed - we just\n         // write `TAG_VALID_SPAN_LOCAL` to let the deserializer know that it should use\n         // our own source map information.\n-        let (tag, lo, hi) = if self.source_file_cache.is_imported() {\n+        //\n+        // If we're a proc-macro crate, we always treat this as a local `Span`.\n+        // In `encode_source_map`, we serialize foreign `SourceFile`s into our metadata\n+        // if we're a proc-macro crate.\n+        // This allows us to avoid loading the dependencies of proc-macro crates: all of\n+        // the information we need to decode `Span`s is stored in the proc-macro crate.\n+        let (tag, lo, hi) = if self.source_file_cache.0.is_imported() && !self.is_proc_macro {\n             // To simplify deserialization, we 'rebase' this span onto the crate it originally came from\n             // (the crate that 'owns' the file it references. These rebased 'lo' and 'hi' values\n             // are relative to the source map information for the 'foreign' crate whose CrateNum\n@@ -188,13 +213,13 @@ impl<'tcx> SpecializedEncoder<Span> for EncodeContext<'tcx> {\n             // Span that can be used without any additional trouble.\n             let external_start_pos = {\n                 // Introduce a new scope so that we drop the 'lock()' temporary\n-                match &*self.source_file_cache.external_src.lock() {\n+                match &*self.source_file_cache.0.external_src.lock() {\n                     ExternalSource::Foreign { original_start_pos, .. } => *original_start_pos,\n                     src => panic!(\"Unexpected external source {:?}\", src),\n                 }\n             };\n-            let lo = (span.lo - self.source_file_cache.start_pos) + external_start_pos;\n-            let hi = (span.hi - self.source_file_cache.start_pos) + external_start_pos;\n+            let lo = (span.lo - self.source_file_cache.0.start_pos) + external_start_pos;\n+            let hi = (span.hi - self.source_file_cache.0.start_pos) + external_start_pos;\n \n             (TAG_VALID_SPAN_FOREIGN, lo, hi)\n         } else {\n@@ -212,7 +237,7 @@ impl<'tcx> SpecializedEncoder<Span> for EncodeContext<'tcx> {\n         if tag == TAG_VALID_SPAN_FOREIGN {\n             // This needs to be two lines to avoid holding the `self.source_file_cache`\n             // while calling `cnum.encode(self)`\n-            let cnum = self.source_file_cache.cnum;\n+            let cnum = self.source_file_cache.0.cnum;\n             cnum.encode(self)?;\n         }\n         Ok(())\n@@ -386,17 +411,24 @@ impl<'tcx> EncodeContext<'tcx> {\n         let all_source_files = source_map.files();\n \n         let (working_dir, _cwd_remapped) = self.tcx.sess.working_dir.clone();\n+        // By replacing the `Option` with `None`, we ensure that we can't\n+        // accidentally serialize any more `Span`s after the source map encoding\n+        // is done.\n+        let required_source_files = self.required_source_files.take().unwrap();\n \n         let adapted = all_source_files\n             .iter()\n-            .filter(|source_file| {\n-                // No need to re-export imported source_files, as any downstream\n-                // crate will import them from their original source.\n-                // FIXME(eddyb) the `Span` encoding should take that into account.\n-                !source_file.is_imported()\n+            .enumerate()\n+            .filter(|(idx, source_file)| {\n+                // Only serialize `SourceFile`s that were used\n+                // during the encoding of a `Span`\n+                required_source_files.contains(*idx) &&\n+                // Don't serialize imported `SourceFile`s, unless\n+                // we're in a proc-macro crate.\n+                (!source_file.is_imported() || self.is_proc_macro)\n             })\n-            .map(|source_file| {\n-                match source_file.name {\n+            .map(|(_, source_file)| {\n+                let mut adapted = match source_file.name {\n                     // This path of this SourceFile has been modified by\n                     // path-remapping, so we use it verbatim (and avoid\n                     // cloning the whole map in the process).\n@@ -419,15 +451,30 @@ impl<'tcx> EncodeContext<'tcx> {\n \n                     // expanded code, not from a file\n                     _ => source_file.clone(),\n+                };\n+\n+                // We're serializing this `SourceFile` into our crate metadata,\n+                // so mark it as coming from this crate.\n+                // This also ensures that we don't try to deserialize the\n+                // `CrateNum` for a proc-macro dependency - since proc macro\n+                // dependencies aren't loaded when we deserialize a proc-macro,\n+                // trying to remap the `CrateNum` would fail.\n+                if self.is_proc_macro {\n+                    Lrc::make_mut(&mut adapted).cnum = LOCAL_CRATE;\n                 }\n+                adapted\n             })\n             .collect::<Vec<_>>();\n \n         self.lazy(adapted.iter().map(|rc| &**rc))\n     }\n \n+    fn is_proc_macro(&self) -> bool {\n+        self.tcx.sess.crate_types().contains(&CrateType::ProcMacro)\n+    }\n+\n     fn encode_crate_root(&mut self) -> Lazy<CrateRoot<'tcx>> {\n-        let is_proc_macro = self.tcx.sess.crate_types().contains(&CrateType::ProcMacro);\n+        let is_proc_macro = self.is_proc_macro();\n \n         let mut i = self.position();\n \n@@ -458,11 +505,6 @@ impl<'tcx> EncodeContext<'tcx> {\n \n         let foreign_modules = self.encode_foreign_modules();\n \n-        // Encode source_map\n-        i = self.position();\n-        let source_map = self.encode_source_map();\n-        let source_map_bytes = self.position() - i;\n-\n         // Encode DefPathTable\n         i = self.position();\n         let def_path_table = self.encode_def_path_table();\n@@ -514,12 +556,19 @@ impl<'tcx> EncodeContext<'tcx> {\n         let proc_macro_data_bytes = self.position() - i;\n \n         // Encode exported symbols info. This is prefetched in `encode_metadata` so we encode\n-        // this last to give the prefetching as much time as possible to complete.\n+        // this late to give the prefetching as much time as possible to complete.\n         i = self.position();\n         let exported_symbols = self.tcx.exported_symbols(LOCAL_CRATE);\n         let exported_symbols = self.encode_exported_symbols(&exported_symbols);\n         let exported_symbols_bytes = self.position() - i;\n \n+        // Encode source_map. This needs to be done last,\n+        // since encoding `Span`s tells us which `SourceFiles` we actually\n+        // need to encode.\n+        i = self.position();\n+        let source_map = self.encode_source_map();\n+        let source_map_bytes = self.position() - i;\n+\n         let attrs = tcx.hir().krate_attrs();\n         let has_default_lib_allocator = attr::contains_name(&attrs, sym::default_lib_allocator);\n \n@@ -1854,17 +1903,22 @@ fn encode_metadata_impl(tcx: TyCtxt<'_>) -> EncodedMetadata {\n     // Will be filled with the root position after encoding everything.\n     encoder.emit_raw_bytes(&[0, 0, 0, 0]);\n \n+    let source_map_files = tcx.sess.source_map().files();\n+\n     let mut ecx = EncodeContext {\n         opaque: encoder,\n         tcx,\n         tables: Default::default(),\n         lazy_state: LazyState::NoNode,\n         type_shorthands: Default::default(),\n         predicate_shorthands: Default::default(),\n-        source_file_cache: tcx.sess.source_map().files()[0].clone(),\n+        source_file_cache: (source_map_files[0].clone(), 0),\n         interpret_allocs: Default::default(),\n         interpret_allocs_inverse: Default::default(),\n+        required_source_files: Some(GrowableBitSet::with_capacity(source_map_files.len())),\n+        is_proc_macro: tcx.sess.crate_types().contains(&CrateType::ProcMacro),\n     };\n+    drop(source_map_files);\n \n     // Encode the rustc version string in a predictable location.\n     rustc_version().encode(&mut ecx).unwrap();"}, {"sha": "8abc3784d6d2f003a1cab93feffbfb0a38c3d0f7", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d462551a8600e57d8b6f87e71ea56868bc5da6cf/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d462551a8600e57d8b6f87e71ea56868bc5da6cf/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=d462551a8600e57d8b6f87e71ea56868bc5da6cf", "patch": "@@ -192,7 +192,6 @@ crate struct CrateRoot<'tcx> {\n     diagnostic_items: Lazy<[(Symbol, DefIndex)]>,\n     native_libraries: Lazy<[NativeLib]>,\n     foreign_modules: Lazy<[ForeignModule]>,\n-    source_map: Lazy<[rustc_span::SourceFile]>,\n     def_path_table: Lazy<rustc_hir::definitions::DefPathTable>,\n     impls: Lazy<[TraitImpls]>,\n     interpret_alloc_index: Lazy<[u32]>,\n@@ -203,6 +202,7 @@ crate struct CrateRoot<'tcx> {\n     proc_macro_data: Option<Lazy<[DefIndex]>>,\n \n     exported_symbols: Lazy!([(ExportedSymbol<'tcx>, SymbolExportLevel)]),\n+    source_map: Lazy<[rustc_span::SourceFile]>,\n \n     compiler_builtins: bool,\n     needs_allocator: bool,"}, {"sha": "90f4cc09660806a5227e6dbf4b4230894c7b07cd", "filename": "src/librustc_span/hygiene.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d462551a8600e57d8b6f87e71ea56868bc5da6cf/src%2Flibrustc_span%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d462551a8600e57d8b6f87e71ea56868bc5da6cf/src%2Flibrustc_span%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fhygiene.rs?ref=d462551a8600e57d8b6f87e71ea56868bc5da6cf", "patch": "@@ -395,10 +395,11 @@ pub fn debug_hygiene_data(verbose: bool) -> String {\n             data.expn_data.iter().enumerate().for_each(|(id, expn_info)| {\n                 let expn_info = expn_info.as_ref().expect(\"no expansion data for an expansion ID\");\n                 s.push_str(&format!(\n-                    \"\\n{}: parent: {:?}, call_site_ctxt: {:?}, kind: {:?}\",\n+                    \"\\n{}: parent: {:?}, call_site_ctxt: {:?}, def_site_ctxt: {:?}, kind: {:?}\",\n                     id,\n                     expn_info.parent,\n                     expn_info.call_site.ctxt(),\n+                    expn_info.def_site.ctxt(),\n                     expn_info.kind,\n                 ));\n             });"}, {"sha": "e062c7766e7dcc2774b49c424e8251d6ff0c6ab8", "filename": "src/librustc_span/source_map.rs", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d462551a8600e57d8b6f87e71ea56868bc5da6cf/src%2Flibrustc_span%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d462551a8600e57d8b6f87e71ea56868bc5da6cf/src%2Flibrustc_span%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsource_map.rs?ref=d462551a8600e57d8b6f87e71ea56868bc5da6cf", "patch": "@@ -40,6 +40,41 @@ pub fn original_sp(sp: Span, enclosing_sp: Span) -> Span {\n     }\n }\n \n+pub mod monotonic {\n+    use std::ops::{Deref, DerefMut};\n+\n+    /// A `MonotonicVec` is a `Vec` which can only be grown.\n+    /// Once inserted, an element can never be removed or swapped,\n+    /// guaranteeing that any indices into a `MonotonicVec` are stable\n+    // This is declared in its own module to ensure that the private\n+    // field is inaccessible\n+    pub struct MonotonicVec<T>(Vec<T>);\n+    impl<T> MonotonicVec<T> {\n+        pub fn new(val: Vec<T>) -> MonotonicVec<T> {\n+            MonotonicVec(val)\n+        }\n+\n+        pub fn push(&mut self, val: T) {\n+            self.0.push(val);\n+        }\n+    }\n+\n+    impl<T> Default for MonotonicVec<T> {\n+        fn default() -> Self {\n+            MonotonicVec::new(vec![])\n+        }\n+    }\n+\n+    impl<T> Deref for MonotonicVec<T> {\n+        type Target = Vec<T>;\n+        fn deref(&self) -> &Self::Target {\n+            &self.0\n+        }\n+    }\n+\n+    impl<T> !DerefMut for MonotonicVec<T> {}\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, HashStable_Generic)]\n pub struct Spanned<T> {\n     pub node: T,\n@@ -125,7 +160,7 @@ impl StableSourceFileId {\n \n #[derive(Default)]\n pub(super) struct SourceMapFiles {\n-    source_files: Vec<Lrc<SourceFile>>,\n+    source_files: monotonic::MonotonicVec<Lrc<SourceFile>>,\n     stable_id_to_source_file: FxHashMap<StableSourceFileId, Lrc<SourceFile>>,\n }\n \n@@ -199,7 +234,9 @@ impl SourceMap {\n         Ok(bytes)\n     }\n \n-    pub fn files(&self) -> MappedLockGuard<'_, Vec<Lrc<SourceFile>>> {\n+    // By returning a `MonotonicVec`, we ensure that consumers cannot invalidate\n+    // any existing indices pointing into `files`.\n+    pub fn files(&self) -> MappedLockGuard<'_, monotonic::MonotonicVec<Lrc<SourceFile>>> {\n         LockGuard::map(self.files.borrow(), |files| &mut files.source_files)\n     }\n \n@@ -912,6 +949,8 @@ impl SourceMap {\n     }\n \n     // Returns the index of the `SourceFile` (in `self.files`) that contains `pos`.\n+    // This index is guaranteed to be valid for the lifetime of this `SourceMap`,\n+    // since `source_files` is a `MonotonicVec`\n     pub fn lookup_source_file_idx(&self, pos: BytePos) -> usize {\n         self.files\n             .borrow()"}, {"sha": "81164030d8eefbbfdd30719761603426177ef8b2", "filename": "src/test/ui/hygiene/unpretty-debug.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d462551a8600e57d8b6f87e71ea56868bc5da6cf/src%2Ftest%2Fui%2Fhygiene%2Funpretty-debug.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/d462551a8600e57d8b6f87e71ea56868bc5da6cf/src%2Ftest%2Fui%2Fhygiene%2Funpretty-debug.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Funpretty-debug.stdout?ref=d462551a8600e57d8b6f87e71ea56868bc5da6cf", "patch": "@@ -16,8 +16,8 @@ fn y /* 0#0 */() { }\n \n /*\n Expansions:\n-0: parent: ExpnId(0), call_site_ctxt: #0, kind: Root\n-1: parent: ExpnId(0), call_site_ctxt: #0, kind: Macro(Bang, \"foo\")\n+0: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: Root\n+1: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Bang, \"foo\")\n \n SyntaxContexts:\n #0: parent: #0, outer_mark: (ExpnId(0), Opaque)"}, {"sha": "2c21221fbb0f5b436b554a8500766656fc47e6eb", "filename": "src/test/ui/proc-macro/auxiliary/make-macro.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d462551a8600e57d8b6f87e71ea56868bc5da6cf/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fmake-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d462551a8600e57d8b6f87e71ea56868bc5da6cf/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fmake-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fmake-macro.rs?ref=d462551a8600e57d8b6f87e71ea56868bc5da6cf", "patch": "@@ -0,0 +1,12 @@\n+// force-host\n+\n+#[macro_export]\n+macro_rules! make_it {\n+    ($name:ident) => {\n+        #[proc_macro]\n+        pub fn $name(input: TokenStream) -> TokenStream {\n+            println!(\"Def site: {:?}\", Span::def_site());\n+            input\n+        }\n+    };\n+}"}, {"sha": "5265c6533b4799fec444b01543b432b71f53375c", "filename": "src/test/ui/proc-macro/auxiliary/meta-macro.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d462551a8600e57d8b6f87e71ea56868bc5da6cf/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fmeta-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d462551a8600e57d8b6f87e71ea56868bc5da6cf/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fmeta-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fmeta-macro.rs?ref=d462551a8600e57d8b6f87e71ea56868bc5da6cf", "patch": "@@ -0,0 +1,12 @@\n+// force-host\n+// no-prefer-dynamic\n+// edition:2018\n+\n+#![feature(proc_macro_def_site)]\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+extern crate make_macro;\n+use proc_macro::{TokenStream, Span};\n+\n+make_macro::make_it!(print_def_site);"}, {"sha": "5b969549a117ccd76246aa414a41458534968506", "filename": "src/test/ui/proc-macro/disappearing-resolution.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d462551a8600e57d8b6f87e71ea56868bc5da6cf/src%2Ftest%2Fui%2Fproc-macro%2Fdisappearing-resolution.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d462551a8600e57d8b6f87e71ea56868bc5da6cf/src%2Ftest%2Fui%2Fproc-macro%2Fdisappearing-resolution.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdisappearing-resolution.stderr?ref=d462551a8600e57d8b6f87e71ea56868bc5da6cf", "patch": "@@ -10,11 +10,16 @@ error[E0603]: derive macro import `Empty` is private\n LL | use m::Empty;\n    |        ^^^^^ private derive macro import\n    |\n-note: the derive macro import `Empty` is defined here\n+note: the derive macro import `Empty` is defined here...\n   --> $DIR/disappearing-resolution.rs:9:9\n    |\n LL |     use test_macros::Empty;\n    |         ^^^^^^^^^^^^^^^^^^\n+note: ...and refers to the derive macro `Empty` which is defined here\n+  --> $DIR/auxiliary/test-macros.rs:25:1\n+   |\n+LL | pub fn empty_derive(_: TokenStream) -> TokenStream {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ consider importing it directly\n \n error: aborting due to 2 previous errors\n "}, {"sha": "449377aed993e87dd302213e55722fe422950ea3", "filename": "src/test/ui/proc-macro/meta-macro-hygiene.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d462551a8600e57d8b6f87e71ea56868bc5da6cf/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d462551a8600e57d8b6f87e71ea56868bc5da6cf/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.rs?ref=d462551a8600e57d8b6f87e71ea56868bc5da6cf", "patch": "@@ -0,0 +1,13 @@\n+// aux-build:make-macro.rs\n+// aux-build:meta-macro.rs\n+// edition:2018\n+// compile-flags: -Z span-debug -Z unpretty=expanded,hygiene\n+// check-pass\n+// normalize-stdout-test \"\\d+#\" -> \"0#\"\n+// ^ We don't care about symbol ids, so set them all to 0\n+// in the stdout\n+extern crate meta_macro;\n+\n+fn main() {\n+    meta_macro::print_def_site!();\n+}"}, {"sha": "daca40eda90065586706980f76dcc2590fc618b2", "filename": "src/test/ui/proc-macro/meta-macro-hygiene.stdout", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d462551a8600e57d8b6f87e71ea56868bc5da6cf/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/d462551a8600e57d8b6f87e71ea56868bc5da6cf/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro-hygiene.stdout?ref=d462551a8600e57d8b6f87e71ea56868bc5da6cf", "patch": "@@ -0,0 +1,32 @@\n+Def site: $DIR/auxiliary/make-macro.rs:7:9: 10:10 (#3)\n+#![feature /* 0#0 */(prelude_import)]\n+#[prelude_import /* 0#1 */]\n+use std /* 0#1 */::prelude /* 0#1 */::v1 /* 0#1 */::*;\n+#[macro_use /* 0#1 */]\n+extern crate std /* 0#1 */;\n+// aux-build:make-macro.rs\n+// aux-build:meta-macro.rs\n+// edition:2018\n+// compile-flags: -Z span-debug -Z unpretty=expanded,hygiene\n+// check-pass\n+// normalize-stdout-test \"\\d+#\" -> \"0#\"\n+// ^ We don't care about symbol ids, so set them all to 0\n+// in the stdout\n+extern crate meta_macro /* 0#0 */;\n+\n+fn main /* 0#0 */() { }\n+\n+/*\n+Expansions:\n+0: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: Root\n+1: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: AstPass(StdImports)\n+2: parent: ExpnId(0), call_site_ctxt: #0, def_site_ctxt: #0, kind: Macro(Bang, \"meta_macro::print_def_site\")\n+\n+SyntaxContexts:\n+#0: parent: #0, outer_mark: (ExpnId(0), Opaque)\n+#1: parent: #0, outer_mark: (ExpnId(1), Opaque)\n+#2: parent: #0, outer_mark: (ExpnId(1), Transparent)\n+#3: parent: #0, outer_mark: (ExpnId(2), Opaque)\n+#4: parent: #0, outer_mark: (ExpnId(2), Transparent)\n+#5: parent: #0, outer_mark: (ExpnId(2), SemiTransparent)\n+*/"}, {"sha": "dbfde9e113f37747eb4bc434b0913d1a039a73ff", "filename": "src/test/ui/proc-macro/meta-macro.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d462551a8600e57d8b6f87e71ea56868bc5da6cf/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d462551a8600e57d8b6f87e71ea56868bc5da6cf/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro.rs?ref=d462551a8600e57d8b6f87e71ea56868bc5da6cf", "patch": "@@ -0,0 +1,11 @@\n+// aux-build:make-macro.rs\n+// aux-build:meta-macro.rs\n+// edition:2018\n+// compile-flags: -Z span-debug\n+// run-pass\n+\n+extern crate meta_macro;\n+\n+fn main() {\n+    meta_macro::print_def_site!();\n+}"}, {"sha": "fa79f72137f64e2c8ca9ebaecfc7057b15da8c9c", "filename": "src/test/ui/proc-macro/meta-macro.stdout", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d462551a8600e57d8b6f87e71ea56868bc5da6cf/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/d462551a8600e57d8b6f87e71ea56868bc5da6cf/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-macro.stdout?ref=d462551a8600e57d8b6f87e71ea56868bc5da6cf", "patch": "@@ -0,0 +1 @@\n+Def site: $DIR/auxiliary/make-macro.rs:7:9: 10:10 (#3)"}]}