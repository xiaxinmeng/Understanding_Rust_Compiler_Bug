{"sha": "efc7f82bc44926c864c52caca8764816ab9150dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmYzdmODJiYzQ0OTI2Yzg2NGM1MmNhY2E4NzY0ODE2YWI5MTUwZGQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-03-09T01:44:37Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-03-13T20:59:37Z"}, "message": "Revamp foreign code not to consider the Rust modes.  This requires\nadjusting a few foreign functions that were declared with by-ref\nmode.  This also allows us to remove by-val mode in the near future.\n\nWith copy mode, though, we have to be careful because Rust will implicitly pass\nsomethings by pointer but this may not be the C ABI rules.  For example, rust\nwill pass a struct Foo as a Foo*.  So I added some code into the adapters to\nfix this (though the C ABI rules may put the pointer back, oh well).\n\nThis patch also includes a lint mode for the use of by-ref mode\nin foreign functions as the semantics of this have changed.", "tree": {"sha": "c2d0cb8d8e8260c58e5b12d51218d935a83462d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2d0cb8d8e8260c58e5b12d51218d935a83462d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efc7f82bc44926c864c52caca8764816ab9150dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efc7f82bc44926c864c52caca8764816ab9150dd", "html_url": "https://github.com/rust-lang/rust/commit/efc7f82bc44926c864c52caca8764816ab9150dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efc7f82bc44926c864c52caca8764816ab9150dd/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d8ddff52a60d3785052f1e0a231cb95c98fdc24", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d8ddff52a60d3785052f1e0a231cb95c98fdc24", "html_url": "https://github.com/rust-lang/rust/commit/4d8ddff52a60d3785052f1e0a231cb95c98fdc24"}], "stats": {"total": 653, "additions": 492, "deletions": 161}, "files": [{"sha": "be1d86c9cf741ec616eab097cbf1c24297edca4d", "filename": "src/libcore/rt/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Flibcore%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Flibcore%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fthread.rs?ref=efc7f82bc44926c864c52caca8764816ab9150dd", "patch": "@@ -22,7 +22,7 @@ struct Thread {\n impl Thread {\n     static fn start(main: ~fn()) -> Thread {\n         fn substart(main: &fn()) -> *raw_thread {\n-            unsafe { rust_raw_thread_start(main) }\n+            unsafe { rust_raw_thread_start(&main) }\n         }\n         let raw = substart(main);\n         Thread {\n@@ -39,6 +39,6 @@ impl Drop for Thread {\n }\n \n extern {\n-    pub unsafe fn rust_raw_thread_start(f: &fn()) -> *raw_thread;\n+    pub unsafe fn rust_raw_thread_start(f: &(&fn())) -> *raw_thread;\n     pub unsafe fn rust_raw_thread_join_delete(thread: *raw_thread);\n }"}, {"sha": "9b6dcc312347abe54d76c27161d567afbe7a8403", "filename": "src/libcore/unstable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Flibcore%2Funstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Flibcore%2Funstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable.rs?ref=efc7f82bc44926c864c52caca8764816ab9150dd", "patch": "@@ -47,7 +47,7 @@ mod rustrt {\n         pub unsafe fn rust_lock_little_lock(lock: rust_little_lock);\n         pub unsafe fn rust_unlock_little_lock(lock: rust_little_lock);\n \n-        pub unsafe fn rust_raw_thread_start(f: &fn()) -> *raw_thread;\n+        pub unsafe fn rust_raw_thread_start(f: &(&fn())) -> *raw_thread;\n         pub unsafe fn rust_raw_thread_join_delete(thread: *raw_thread);\n     }\n }\n@@ -72,7 +72,7 @@ pub fn run_in_bare_thread(f: ~fn()) {\n             let closure: &fn() = || {\n                 f()\n             };\n-            let thread = rustrt::rust_raw_thread_start(closure);\n+            let thread = rustrt::rust_raw_thread_start(&closure);\n             rustrt::rust_raw_thread_join_delete(thread);\n             chan.send(());\n         }"}, {"sha": "23eb6743b9fa818005c4c213c6e26081bbaa2f68", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=efc7f82bc44926c864c52caca8764816ab9150dd", "patch": "@@ -1443,7 +1443,7 @@ pub mod llvm {\n         /** Prepares inline assembly. */\n         pub unsafe fn LLVMInlineAsm(Ty: TypeRef, AsmString: *c_char,\n                                     Constraints: *c_char, SideEffects: Bool,\n-                                    AlignStack: Bool, Dialect: AsmDialect)\n+                                    AlignStack: Bool, Dialect: c_uint)\n                                  -> ValueRef;\n     }\n }"}, {"sha": "47ec756fe0ee59d0908c1579104e57f488bba7bd", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=efc7f82bc44926c864c52caca8764816ab9150dd", "patch": "@@ -78,6 +78,7 @@ pub enum lint {\n     deprecated_self,\n     deprecated_mutable_fields,\n     deprecated_drop,\n+    foreign_mode,\n \n     managed_heap_memory,\n     owned_heap_memory,\n@@ -182,6 +183,13 @@ pub fn get_lint_dict() -> LintDict {\n             default: warn\n          }),\n \n+        (@~\"foreign_mode\",\n+         @LintSpec {\n+            lint: foreign_mode,\n+            desc: \"warn about deprecated uses of modes in foreign fns\",\n+            default: warn\n+         }),\n+\n         (@~\"deprecated_pattern\",\n          @LintSpec {\n             lint: deprecated_pattern,\n@@ -753,6 +761,20 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n \n     fn check_foreign_fn(cx: ty::ctxt, fn_id: ast::node_id,\n                         decl: &ast::fn_decl) {\n+        // warn about `&&` mode on foreign functions, both because it is\n+        // deprecated and because its semantics have changed recently:\n+        for decl.inputs.eachi |i, arg| {\n+            match ty::resolved_mode(cx, arg.mode) {\n+                ast::by_val | ast::by_copy => {}\n+                ast::by_ref => {\n+                    cx.sess.span_lint(\n+                        foreign_mode, fn_id, fn_id, arg.ty.span,\n+                        fmt!(\"foreign function uses `&&` mode \\\n+                              on argument %u\", i));\n+                }\n+            }\n+        }\n+\n         let tys = vec::map(decl.inputs, |a| a.ty );\n         for vec::each(vec::append_one(tys, decl.output)) |ty| {\n             match ty.node {\n@@ -785,7 +807,7 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n       if attr::foreign_abi(it.attrs) !=\n             either::Right(ast::foreign_abi_rust_intrinsic) => {\n         for nmod.items.each |ni| {\n-            match /*bad*/copy ni.node {\n+            match ni.node {\n               ast::foreign_item_fn(ref decl, _, _) => {\n                 check_foreign_fn(cx, it.id, decl);\n               }"}, {"sha": "850ea908e74ee0a6d23adbce5ebf0fe448e12e12", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=efc7f82bc44926c864c52caca8764816ab9150dd", "patch": "@@ -885,7 +885,7 @@ pub fn InlineAsmCall(cx: block, asm: *c_char, cons: *c_char,\n \n         let llfty = T_fn(~[], T_void());\n         let v = llvm::LLVMInlineAsm(llfty, asm, cons, volatile,\n-                                    alignstack, dia);\n+                                    alignstack, dia as c_uint);\n \n         Call(cx, v, ~[])\n     }"}, {"sha": "5052ce07671154dead8eb625a2988ce88909a939", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=efc7f82bc44926c864c52caca8764816ab9150dd", "patch": "@@ -757,7 +757,7 @@ pub fn trans_arg_expr(bcx: block,\n \n         if formal_ty.ty != arg_datum.ty {\n             // this could happen due to e.g. subtyping\n-            let llformal_ty = type_of::type_of_explicit_arg(ccx, formal_ty);\n+            let llformal_ty = type_of::type_of_explicit_arg(ccx, &formal_ty);\n             debug!(\"casting actual type (%s) to match formal (%s)\",\n                    bcx.val_str(val), bcx.llty_str(llformal_ty));\n             val = PointerCast(bcx, val, llformal_ty);"}, {"sha": "fde1de5b63f21d9ff319c9cbae950b862ec03a67", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 249, "deletions": 124, "changes": 373, "blob_url": "https://github.com/rust-lang/rust/blob/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=efc7f82bc44926c864c52caca8764816ab9150dd", "patch": "@@ -58,59 +58,90 @@ pub fn link_name(ccx: @CrateContext, i: @ast::foreign_item) -> @~str {\n     }\n }\n \n-struct c_stack_tys {\n-    arg_tys: ~[TypeRef],\n-    ret_ty: TypeRef,\n+struct ShimTypes {\n+    fn_sig: ty::FnSig,\n+\n+    /// LLVM types that will appear on the foreign function\n+    llsig: LlvmSignature,\n+\n+    /// True if there is a return value (not bottom, not unit)\n     ret_def: bool,\n+\n+    /// Type of the struct we will use to shuttle values back and forth.\n+    /// This is always derived from the llsig.\n     bundle_ty: TypeRef,\n+\n+    /// Type of the shim function itself.\n     shim_fn_ty: TypeRef,\n+\n+    /// Adapter object for handling native ABI rules (trust me, you\n+    /// don't want to know).\n     fn_ty: cabi::FnType\n }\n \n-fn c_arg_and_ret_lltys(ccx: @CrateContext,\n-                       id: ast::node_id) -> (~[TypeRef], TypeRef, ty::t) {\n-    match ty::get(ty::node_id_to_type(ccx.tcx, id)).sty {\n-        ty::ty_bare_fn(ref fn_ty) => {\n-            let llargtys = type_of_explicit_args(ccx, fn_ty.sig.inputs);\n-            let llretty = type_of::type_of(ccx, fn_ty.sig.output);\n-            (llargtys, llretty, fn_ty.sig.output)\n-        }\n-        _ => ccx.sess.bug(~\"c_arg_and_ret_lltys called on non-function type\")\n-    }\n+struct LlvmSignature {\n+    llarg_tys: ~[TypeRef],\n+    llret_ty: TypeRef,\n }\n \n-fn c_stack_tys(ccx: @CrateContext,\n-               id: ast::node_id) -> @c_stack_tys {\n-    let (llargtys, llretty, ret_ty) = c_arg_and_ret_lltys(ccx, id);\n-    // XXX: Bad copy.\n-    let bundle_ty = T_struct(vec::append_one(copy llargtys, T_ptr(llretty)));\n-    let ret_def = !ty::type_is_bot(ret_ty) && !ty::type_is_nil(ret_ty);\n-    let fn_ty = abi_info(ccx.sess.targ_cfg.arch).\n-                    compute_info(llargtys, llretty, ret_def);\n-    return @c_stack_tys {\n-        arg_tys: llargtys,\n-        ret_ty: llretty,\n+fn foreign_signature(ccx: @CrateContext,\n+                     fn_sig: &ty::FnSig) -> LlvmSignature {\n+    /*!\n+     * The ForeignSignature is the LLVM types of the arguments/return type\n+     * of a function.  Note that these LLVM types are not quite the same\n+     * as the LLVM types would be for a native Rust function because foreign\n+     * functions just plain ignore modes.  They also don't pass aggregate\n+     * values by pointer like we do.\n+     */\n+\n+    let llarg_tys = fn_sig.inputs.map(|arg| type_of(ccx, arg.ty));\n+    let llret_ty = type_of::type_of(ccx, fn_sig.output);\n+    LlvmSignature {llarg_tys: llarg_tys, llret_ty: llret_ty}\n+}\n+\n+fn shim_types(ccx: @CrateContext, id: ast::node_id) -> ShimTypes {\n+    let fn_sig = match ty::get(ty::node_id_to_type(ccx.tcx, id)).sty {\n+        ty::ty_bare_fn(ref fn_ty) => copy fn_ty.sig,\n+        _ => ccx.sess.bug(~\"c_arg_and_ret_lltys called on non-function type\")\n+    };\n+    let llsig = foreign_signature(ccx, &fn_sig);\n+    let bundle_ty = T_struct(vec::append_one(copy llsig.llarg_tys,\n+                                             T_ptr(llsig.llret_ty)));\n+    let ret_def =\n+        !ty::type_is_bot(fn_sig.output) &&\n+        !ty::type_is_nil(fn_sig.output);\n+    let fn_ty =\n+        abi_info(ccx.sess.targ_cfg.arch).compute_info(\n+            llsig.llarg_tys,\n+            llsig.llret_ty,\n+            ret_def);\n+    ShimTypes {\n+        fn_sig: fn_sig,\n+        llsig: llsig,\n         ret_def: ret_def,\n         bundle_ty: bundle_ty,\n         shim_fn_ty: T_fn(~[T_ptr(bundle_ty)], T_void()),\n         fn_ty: fn_ty\n-    };\n+    }\n }\n \n-type shim_arg_builder = &self/fn(bcx: block, tys: @c_stack_tys,\n-                                 llargbundle: ValueRef) -> ~[ValueRef];\n+type shim_arg_builder<'self> =\n+    &'self fn(bcx: block, tys: &ShimTypes,\n+              llargbundle: ValueRef) -> ~[ValueRef];\n \n-type shim_ret_builder = &self/fn(bcx: block, tys: @c_stack_tys,\n-                                 llargbundle: ValueRef, llretval: ValueRef);\n+type shim_ret_builder<'self> =\n+    &'self fn(bcx: block, tys: &ShimTypes,\n+              llargbundle: ValueRef,\n+              llretval: ValueRef);\n \n fn build_shim_fn_(ccx: @CrateContext,\n                   +shim_name: ~str,\n                   llbasefn: ValueRef,\n-                  tys: @c_stack_tys,\n+                  tys: &ShimTypes,\n                   cc: lib::llvm::CallConv,\n                   arg_builder: shim_arg_builder,\n-                  ret_builder: shim_ret_builder) -> ValueRef {\n-\n+                  ret_builder: shim_ret_builder) -> ValueRef\n+{\n     let llshimfn = decl_internal_cdecl_fn(\n         ccx.llmod, shim_name, tys.shim_fn_ty);\n \n@@ -122,8 +153,7 @@ fn build_shim_fn_(ccx: @CrateContext,\n     let llargvals = arg_builder(bcx, tys, llargbundle);\n \n     // Create the call itself and store the return value:\n-    let llretval = CallWithConv(bcx, llbasefn,\n-                                llargvals, cc); // r\n+    let llretval = CallWithConv(bcx, llbasefn, llargvals, cc);\n \n     ret_builder(bcx, tys, llargbundle, llretval);\n \n@@ -133,21 +163,22 @@ fn build_shim_fn_(ccx: @CrateContext,\n     return llshimfn;\n }\n \n-type wrap_arg_builder = &self/fn(bcx: block, tys: @c_stack_tys,\n-                                 llwrapfn: ValueRef,\n-                                 llargbundle: ValueRef);\n+type wrap_arg_builder<'self> =\n+    &'self fn(bcx: block, tys: &ShimTypes,\n+              llwrapfn: ValueRef, llargbundle: ValueRef);\n \n-type wrap_ret_builder = &self/fn(bcx: block, tys: @c_stack_tys,\n-                                 llargbundle: ValueRef);\n+type wrap_ret_builder<'self> =\n+    &'self fn(bcx: block, tys: &ShimTypes,\n+              llargbundle: ValueRef);\n \n fn build_wrap_fn_(ccx: @CrateContext,\n-                  tys: @c_stack_tys,\n+                  tys: &ShimTypes,\n                   llshimfn: ValueRef,\n                   llwrapfn: ValueRef,\n                   shim_upcall: ValueRef,\n                   arg_builder: wrap_arg_builder,\n-                  ret_builder: wrap_ret_builder) {\n-\n+                  ret_builder: wrap_ret_builder)\n+{\n     let _icx = ccx.insn_ctxt(\"foreign::build_wrap_fn_\");\n     let fcx = new_fn_ctxt(ccx, ~[], llwrapfn, None);\n     let bcx = top_scope_block(fcx, None);\n@@ -199,36 +230,83 @@ fn build_wrap_fn_(ccx: @CrateContext,\n //         F(args->z, args->x, args->y);\n //     }\n //\n-// Note: on i386, the layout of the args struct is generally the same as the\n-// desired layout of the arguments on the C stack.  Therefore, we could use\n-// upcall_alloc_c_stack() to allocate the `args` structure and switch the\n-// stack pointer appropriately to avoid a round of copies.  (In fact, the shim\n-// function itself is unnecessary). We used to do this, in fact, and will\n-// perhaps do so in the future.\n+// Note: on i386, the layout of the args struct is generally the same\n+// as the desired layout of the arguments on the C stack.  Therefore,\n+// we could use upcall_alloc_c_stack() to allocate the `args`\n+// structure and switch the stack pointer appropriately to avoid a\n+// round of copies.  (In fact, the shim function itself is\n+// unnecessary). We used to do this, in fact, and will perhaps do so\n+// in the future.\n pub fn trans_foreign_mod(ccx: @CrateContext,\n                          foreign_mod: &ast::foreign_mod,\n-                         abi: ast::foreign_abi) {\n-\n+                         abi: ast::foreign_abi)\n+{\n     let _icx = ccx.insn_ctxt(\"foreign::trans_foreign_mod\");\n \n+    let mut cc = match abi {\n+        ast::foreign_abi_rust_intrinsic |\n+        ast::foreign_abi_cdecl => lib::llvm::CCallConv,\n+        ast::foreign_abi_stdcall => lib::llvm::X86StdcallCallConv\n+    };\n+\n+    for vec::each(foreign_mod.items) |foreign_item| {\n+        match foreign_item.node {\n+            ast::foreign_item_fn(*) => {\n+                let id = foreign_item.id;\n+                if abi != ast::foreign_abi_rust_intrinsic {\n+                    let llwrapfn = get_item_val(ccx, id);\n+                    let tys = shim_types(ccx, id);\n+                    if attr::attrs_contains_name(\n+                        foreign_item.attrs, \"rust_stack\")\n+                    {\n+                        build_direct_fn(ccx, llwrapfn, *foreign_item,\n+                                        &tys, cc);\n+                    } else {\n+                        let llshimfn = build_shim_fn(ccx, *foreign_item,\n+                                                     &tys, cc);\n+                        build_wrap_fn(ccx, &tys, llshimfn, llwrapfn);\n+                    }\n+                } else {\n+                    // Intrinsics are emitted by monomorphic fn\n+                }\n+            }\n+            ast::foreign_item_const(*) => {\n+                let ident = ccx.sess.parse_sess.interner.get(\n+                    foreign_item.ident);\n+                ccx.item_symbols.insert(foreign_item.id, copy *ident);\n+            }\n+        }\n+    }\n+\n     fn build_shim_fn(ccx: @CrateContext,\n                      foreign_item: @ast::foreign_item,\n-                     tys: @c_stack_tys,\n-                     cc: lib::llvm::CallConv) -> ValueRef {\n+                     tys: &ShimTypes,\n+                     cc: lib::llvm::CallConv) -> ValueRef\n+    {\n+        /*!\n+         *\n+         * Build S, from comment above:\n+         *\n+         *     void S(struct { X x; Y y; Z *z; } *args) {\n+         *         F(args->z, args->x, args->y);\n+         *     }\n+         */\n \n         let _icx = ccx.insn_ctxt(\"foreign::build_shim_fn\");\n \n-        fn build_args(bcx: block, tys: @c_stack_tys,\n+        fn build_args(bcx: block, tys: &ShimTypes,\n                       llargbundle: ValueRef) -> ~[ValueRef] {\n             let _icx = bcx.insn_ctxt(\"foreign::shim::build_args\");\n-            return tys.fn_ty.build_shim_args(bcx, tys.arg_tys, llargbundle);\n+            tys.fn_ty.build_shim_args(\n+                bcx, tys.llsig.llarg_tys, llargbundle)\n         }\n \n-        fn build_ret(bcx: block, tys: @c_stack_tys,\n+        fn build_ret(bcx: block, tys: &ShimTypes,\n                      llargbundle: ValueRef, llretval: ValueRef)  {\n             let _icx = bcx.insn_ctxt(\"foreign::shim::build_ret\");\n-            tys.fn_ty.build_shim_ret(bcx, tys.arg_tys, tys.ret_def,\n-                                     llargbundle, llretval);\n+            tys.fn_ty.build_shim_ret(\n+                bcx, tys.llsig.llarg_tys,\n+                tys.ret_def, llargbundle, llretval);\n         }\n \n         let lname = link_name(ccx, foreign_item);\n@@ -239,7 +317,7 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n                            build_args, build_ret);\n     }\n \n-    fn base_fn(ccx: @CrateContext, lname: &str, tys: @c_stack_tys,\n+    fn base_fn(ccx: @CrateContext, lname: &str, tys: &ShimTypes,\n                cc: lib::llvm::CallConv) -> ValueRef {\n         // Declare the \"prototype\" for the base function F:\n         do tys.fn_ty.decl_fn |fnty| {\n@@ -250,7 +328,7 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n     // FIXME (#2535): this is very shaky and probably gets ABIs wrong all\n     // over the place\n     fn build_direct_fn(ccx: @CrateContext, decl: ValueRef,\n-                       item: @ast::foreign_item, tys: @c_stack_tys,\n+                       item: @ast::foreign_item, tys: &ShimTypes,\n                        cc: lib::llvm::CallConv) {\n         let fcx = new_fn_ctxt(ccx, ~[], decl, None);\n         let bcx = top_scope_block(fcx, None), lltop = bcx.llbb;\n@@ -269,66 +347,55 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n     }\n \n     fn build_wrap_fn(ccx: @CrateContext,\n-                     tys: @c_stack_tys,\n+                     tys: &ShimTypes,\n                      llshimfn: ValueRef,\n                      llwrapfn: ValueRef) {\n+        /*!\n+         *\n+         * Build W, from comment above:\n+         *\n+         *     void W(Z* dest, void *env, X x, Y y) {\n+         *         struct { X x; Y y; Z *z; } args = { x, y, z };\n+         *         call_on_c_stack_shim(S, &args);\n+         *     }\n+         *\n+         * One thing we have to be very careful of is to\n+         * account for the Rust modes.\n+         */\n \n         let _icx = ccx.insn_ctxt(\"foreign::build_wrap_fn\");\n \n-        fn build_args(bcx: block, tys: @c_stack_tys,\n+        build_wrap_fn_(ccx, tys, llshimfn, llwrapfn,\n+                       ccx.upcalls.call_shim_on_c_stack,\n+                       build_args, build_ret);\n+\n+        fn build_args(bcx: block, tys: &ShimTypes,\n                       llwrapfn: ValueRef, llargbundle: ValueRef) {\n             let _icx = bcx.insn_ctxt(\"foreign::wrap::build_args\");\n-            let mut i = 0u;\n-            let n = vec::len(tys.arg_tys);\n+            let ccx = bcx.ccx();\n+            let n = vec::len(tys.llsig.llarg_tys);\n             let implicit_args = first_real_arg; // return + env\n-            while i < n {\n-                let llargval = get_param(llwrapfn, i + implicit_args);\n+            for uint::range(0, n) |i| {\n+                let mut llargval = get_param(llwrapfn, i + implicit_args);\n+\n+                // In some cases, Rust will pass a pointer which the\n+                // native C type doesn't have.  In that case, just\n+                // load the value from the pointer.\n+                if type_of::arg_is_indirect(ccx, &tys.fn_sig.inputs[i]) {\n+                    llargval = Load(bcx, llargval);\n+                }\n+\n                 store_inbounds(bcx, llargval, llargbundle, ~[0u, i]);\n-                i += 1u;\n             }\n             let llretptr = get_param(llwrapfn, 0u);\n             store_inbounds(bcx, llretptr, llargbundle, ~[0u, n]);\n         }\n \n-        fn build_ret(bcx: block, _tys: @c_stack_tys,\n+        fn build_ret(bcx: block, _tys: &ShimTypes,\n                      _llargbundle: ValueRef) {\n             let _icx = bcx.insn_ctxt(\"foreign::wrap::build_ret\");\n             RetVoid(bcx);\n         }\n-\n-        build_wrap_fn_(ccx, tys, llshimfn, llwrapfn,\n-                       ccx.upcalls.call_shim_on_c_stack,\n-                       build_args, build_ret);\n-    }\n-\n-    let mut cc = match abi {\n-      ast::foreign_abi_rust_intrinsic |\n-      ast::foreign_abi_cdecl => lib::llvm::CCallConv,\n-      ast::foreign_abi_stdcall => lib::llvm::X86StdcallCallConv\n-    };\n-\n-    for vec::each(foreign_mod.items) |foreign_item| {\n-      match foreign_item.node {\n-        ast::foreign_item_fn(*) => {\n-          let id = foreign_item.id;\n-          if abi != ast::foreign_abi_rust_intrinsic {\n-              let llwrapfn = get_item_val(ccx, id);\n-              let tys = c_stack_tys(ccx, id);\n-              if attr::attrs_contains_name(foreign_item.attrs, \"rust_stack\") {\n-                  build_direct_fn(ccx, llwrapfn, *foreign_item, tys, cc);\n-              } else {\n-                  let llshimfn = build_shim_fn(ccx, *foreign_item, tys, cc);\n-                  build_wrap_fn(ccx, tys, llshimfn, llwrapfn);\n-              }\n-          } else {\n-              // Intrinsics are emitted by monomorphic fn\n-          }\n-        }\n-        ast::foreign_item_const(*) => {\n-            let ident = ccx.sess.parse_sess.interner.get(foreign_item.ident);\n-            ccx.item_symbols.insert(foreign_item.id, copy *ident);\n-        }\n-      }\n     }\n }\n \n@@ -842,6 +909,32 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n     finish_fn(fcx, lltop);\n }\n \n+/**\n+ * Translates a \"crust\" fn, meaning a Rust fn that can be called\n+ * from C code.  In this case, we have to perform some adaptation\n+ * to (1) switch back to the Rust stack and (2) adapt the C calling\n+ * convention to our own.\n+ *\n+ * Example: Given a crust fn F(x: X, y: Y) -> Z, we generate a\n+ * Rust function R as normal:\n+ *\n+ *    void R(Z* dest, void *env, X x, Y y) {...}\n+ *\n+ * and then we generate a wrapper function W that looks like:\n+ *\n+ *    Z W(X x, Y y) {\n+ *        struct { X x; Y y; Z *z; } args = { x, y, z };\n+ *        call_on_c_stack_shim(S, &args);\n+ *    }\n+ *\n+ * Note that the wrapper follows the foreign (typically \"C\") ABI.\n+ * The wrapper is the actual \"value\" of the foreign fn.  Finally,\n+ * we generate a shim function S that looks like:\n+ *\n+ *     void S(struct { X x; Y y; Z *z; } *args) {\n+ *         R(args->z, NULL, args->x, args->y);\n+ *     }\n+ */\n pub fn trans_foreign_fn(ccx: @CrateContext,\n                         +path: ast_map::path,\n                         decl: &ast::fn_decl,\n@@ -867,28 +960,51 @@ pub fn trans_foreign_fn(ccx: @CrateContext,\n     }\n \n     fn build_shim_fn(ccx: @CrateContext, +path: ast_map::path,\n-                     llrustfn: ValueRef, tys: @c_stack_tys) -> ValueRef {\n+                     llrustfn: ValueRef, tys: &ShimTypes) -> ValueRef {\n+        /*!\n+         *\n+         * Generate the shim S:\n+         *\n+         *     void S(struct { X x; Y y; Z *z; } *args) {\n+         *         R(args->z, NULL, &args->x, args->y);\n+         *     }\n+         *\n+         * One complication is that we must adapt to the Rust\n+         * calling convention, which introduces indirection\n+         * in some cases.  To demonstrate this, I wrote one of the\n+         * entries above as `&args->x`, because presumably `X` is\n+         * one of those types that is passed by pointer in Rust.\n+         */\n+\n         let _icx = ccx.insn_ctxt(\"foreign::foreign::build_shim_fn\");\n \n-        fn build_args(bcx: block, tys: @c_stack_tys,\n+        fn build_args(bcx: block, tys: &ShimTypes,\n                       llargbundle: ValueRef) -> ~[ValueRef] {\n             let _icx = bcx.insn_ctxt(\"foreign::extern::shim::build_args\");\n+            let ccx = bcx.ccx();\n             let mut llargvals = ~[];\n             let mut i = 0u;\n-            let n = vec::len(tys.arg_tys);\n+            let n = tys.fn_sig.inputs.len();\n             let llretptr = load_inbounds(bcx, llargbundle, ~[0u, n]);\n             llargvals.push(llretptr);\n             let llenvptr = C_null(T_opaque_box_ptr(bcx.ccx()));\n             llargvals.push(llenvptr);\n             while i < n {\n-                let llargval = load_inbounds(bcx, llargbundle, ~[0u, i]);\n+                // Get a pointer to the argument:\n+                let mut llargval = GEPi(bcx, llargbundle, [0u, i]);\n+\n+                if !type_of::arg_is_indirect(ccx, &tys.fn_sig.inputs[i]) {\n+                    // If Rust would pass this by value, load the value.\n+                    llargval = Load(bcx, llargval);\n+                }\n+\n                 llargvals.push(llargval);\n                 i += 1u;\n             }\n             return llargvals;\n         }\n \n-        fn build_ret(_bcx: block, _tys: @c_stack_tys,\n+        fn build_ret(_bcx: block, _tys: &ShimTypes,\n                      _llargbundle: ValueRef, _llretval: ValueRef)  {\n             // Nop. The return pointer in the Rust ABI function\n             // is wired directly into the return slot in the shim struct\n@@ -904,36 +1020,48 @@ pub fn trans_foreign_fn(ccx: @CrateContext,\n     }\n \n     fn build_wrap_fn(ccx: @CrateContext, llshimfn: ValueRef,\n-                     llwrapfn: ValueRef, tys: @c_stack_tys) {\n+                     llwrapfn: ValueRef, tys: &ShimTypes)\n+    {\n+        /*!\n+         *\n+         * Generate the wrapper W:\n+         *\n+         *    Z W(X x, Y y) {\n+         *        struct { X x; Y y; Z *z; } args = { x, y, z };\n+         *        call_on_c_stack_shim(S, &args);\n+         *    }\n+         */\n \n         let _icx = ccx.insn_ctxt(\"foreign::foreign::build_wrap_fn\");\n \n-        fn build_args(bcx: block, tys: @c_stack_tys,\n+        build_wrap_fn_(ccx, tys, llshimfn, llwrapfn,\n+                       ccx.upcalls.call_shim_on_rust_stack,\n+                       build_args, build_ret);\n+\n+        fn build_args(bcx: block, tys: &ShimTypes,\n                       llwrapfn: ValueRef, llargbundle: ValueRef) {\n             let _icx = bcx.insn_ctxt(\"foreign::foreign::wrap::build_args\");\n-            tys.fn_ty.build_wrap_args(bcx, tys.ret_ty,\n-                                      llwrapfn, llargbundle);\n+            tys.fn_ty.build_wrap_args(\n+                bcx, tys.llsig.llret_ty,\n+                llwrapfn, llargbundle);\n         }\n \n-        fn build_ret(bcx: block, tys: @c_stack_tys,\n+        fn build_ret(bcx: block, tys: &ShimTypes,\n                      llargbundle: ValueRef) {\n             let _icx = bcx.insn_ctxt(\"foreign::foreign::wrap::build_ret\");\n-            tys.fn_ty.build_wrap_ret(bcx, tys.arg_tys, llargbundle);\n+            tys.fn_ty.build_wrap_ret(\n+                bcx, tys.llsig.llarg_tys, llargbundle);\n         }\n-\n-        build_wrap_fn_(ccx, tys, llshimfn, llwrapfn,\n-                       ccx.upcalls.call_shim_on_rust_stack,\n-                       build_args, build_ret);\n     }\n \n-    let tys = c_stack_tys(ccx, id);\n+    let tys = shim_types(ccx, id);\n     // The internal Rust ABI function - runs on the Rust stack\n     // XXX: Bad copy.\n     let llrustfn = build_rust_fn(ccx, copy path, decl, body, id);\n     // The internal shim function - runs on the Rust stack\n-    let llshimfn = build_shim_fn(ccx, path, llrustfn, tys);\n+    let llshimfn = build_shim_fn(ccx, path, llrustfn, &tys);\n     // The foreign C function - runs on the C stack\n-    build_wrap_fn(ccx, llshimfn, llwrapfn, tys)\n+    build_wrap_fn(ccx, llshimfn, llwrapfn, &tys)\n }\n \n pub fn register_foreign_fn(ccx: @CrateContext,\n@@ -944,11 +1072,8 @@ pub fn register_foreign_fn(ccx: @CrateContext,\n                         -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"foreign::register_foreign_fn\");\n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n-    let (llargtys, llretty, ret_ty) = c_arg_and_ret_lltys(ccx, node_id);\n-    let ret_def = !ty::type_is_bot(ret_ty) && !ty::type_is_nil(ret_ty);\n-    let fn_ty = abi_info(ccx.sess.targ_cfg.arch).\n-                    compute_info(llargtys, llretty, ret_def);\n-    do fn_ty.decl_fn |fnty| {\n+    let tys = shim_types(ccx, node_id);\n+    do tys.fn_ty.decl_fn |fnty| {\n         register_fn_fuller(ccx, sp, /*bad*/copy path, node_id, attrs,\n                            t, lib::llvm::CCallConv, fnty)\n     }"}, {"sha": "2a390a03fa1429e0883a261e093aa3f07f3088de", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=efc7f82bc44926c864c52caca8764816ab9150dd", "patch": "@@ -21,24 +21,22 @@ use util::ppaux;\n use core::option::None;\n use syntax::ast;\n \n-pub fn type_of_explicit_arg(ccx: @CrateContext, arg: ty::arg) -> TypeRef {\n-    let llty = type_of(ccx, arg.ty);\n+pub fn arg_is_indirect(ccx: @CrateContext, arg: &ty::arg) -> bool {\n     match ty::resolved_mode(ccx.tcx, arg.mode) {\n-        ast::by_val => llty,\n-        ast::by_copy => {\n-            if ty::type_is_immediate(arg.ty) {\n-                llty\n-            } else {\n-                T_ptr(llty)\n-            }\n-        }\n-        _ => T_ptr(llty)\n+        ast::by_val => false,\n+        ast::by_copy => !ty::type_is_immediate(arg.ty),\n+        ast::by_ref => true\n     }\n }\n \n+pub fn type_of_explicit_arg(ccx: @CrateContext, arg: &ty::arg) -> TypeRef {\n+    let llty = type_of(ccx, arg.ty);\n+    if arg_is_indirect(ccx, arg) {T_ptr(llty)} else {llty}\n+}\n+\n pub fn type_of_explicit_args(ccx: @CrateContext,\n                              inputs: &[ty::arg]) -> ~[TypeRef] {\n-    inputs.map(|arg| type_of_explicit_arg(ccx, *arg))\n+    inputs.map(|arg| type_of_explicit_arg(ccx, arg))\n }\n \n pub fn type_of_fn(cx: @CrateContext, inputs: &[ty::arg],"}, {"sha": "d768eef9a8c9b4c0b39bf73cdf110ae7b24a3991", "filename": "src/libstd/time.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=efc7f82bc44926c864c52caca8764816ab9150dd", "patch": "@@ -30,10 +30,10 @@ pub mod rustrt {\n \n         pub unsafe fn rust_tzset();\n         // FIXME: The i64 values can be passed by-val when #2064 is fixed.\n-        pub unsafe fn rust_gmtime(&&sec: i64, &&nsec: i32, &&result: Tm);\n-        pub unsafe fn rust_localtime(&&sec: i64, &&nsec: i32, &&result: Tm);\n-        pub unsafe fn rust_timegm(&&tm: Tm, sec: &mut i64);\n-        pub unsafe fn rust_mktime(&&tm: Tm, sec: &mut i64);\n+        pub unsafe fn rust_gmtime(sec: i64, nsec: i32, result: &mut Tm);\n+        pub unsafe fn rust_localtime(sec: i64, nsec: i32, result: &mut Tm);\n+        pub unsafe fn rust_timegm(tm: &Tm, sec: &mut i64);\n+        pub unsafe fn rust_mktime(tm: &Tm, sec: &mut i64);\n     }\n }\n \n@@ -172,7 +172,7 @@ pub fn at_utc(clock: Timespec) -> Tm {\n     unsafe {\n         let mut Timespec { sec, nsec } = clock;\n         let mut tm = empty_tm();\n-        rustrt::rust_gmtime(sec, nsec, tm);\n+        rustrt::rust_gmtime(sec, nsec, &mut tm);\n         tm\n     }\n }\n@@ -187,7 +187,7 @@ pub fn at(clock: Timespec) -> Tm {\n     unsafe {\n         let mut Timespec { sec, nsec } = clock;\n         let mut tm = empty_tm();\n-        rustrt::rust_localtime(sec, nsec, tm);\n+        rustrt::rust_localtime(sec, nsec, &mut tm);\n         tm\n     }\n }\n@@ -217,9 +217,9 @@ pub impl Tm {\n         unsafe {\n             let mut sec = 0i64;\n             if self.tm_gmtoff == 0_i32 {\n-                rustrt::rust_timegm(*self, &mut sec);\n+                rustrt::rust_timegm(self, &mut sec);\n             } else {\n-                rustrt::rust_mktime(*self, &mut sec);\n+                rustrt::rust_mktime(self, &mut sec);\n             }\n             Timespec::new(sec, self.tm_nsec)\n         }"}, {"sha": "5a9de9735ba0346abc69434552c998468c1b199d", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=efc7f82bc44926c864c52caca8764816ab9150dd", "patch": "@@ -434,18 +434,18 @@ rust_tzset() {\n }\n \n extern \"C\" CDECL void\n-rust_gmtime(int64_t *sec, int32_t *nsec, rust_tm *timeptr) {\n+rust_gmtime(int64_t sec, int32_t nsec, rust_tm *timeptr) {\n     tm tm;\n-    time_t s = *sec;\n+    time_t s = sec;\n     GMTIME(&s, &tm);\n \n-    tm_to_rust_tm(&tm, timeptr, 0, \"UTC\", *nsec);\n+    tm_to_rust_tm(&tm, timeptr, 0, \"UTC\", nsec);\n }\n \n extern \"C\" CDECL void\n-rust_localtime(int64_t *sec, int32_t *nsec, rust_tm *timeptr) {\n+rust_localtime(int64_t sec, int32_t nsec, rust_tm *timeptr) {\n     tm tm;\n-    time_t s = *sec;\n+    time_t s = sec;\n     LOCALTIME(&s, &tm);\n \n #if defined(__WIN32__)\n@@ -457,7 +457,7 @@ rust_localtime(int64_t *sec, int32_t *nsec, rust_tm *timeptr) {\n     const char *zone = tm.tm_zone;\n #endif\n \n-    tm_to_rust_tm(&tm, timeptr, gmtoff, zone, *nsec);\n+    tm_to_rust_tm(&tm, timeptr, gmtoff, zone, nsec);\n }\n \n extern \"C\" CDECL void\n@@ -844,6 +844,38 @@ rust_readdir() {\n \n #endif\n \n+// These functions are used in the unit tests for C ABI calls.\n+\n+extern \"C\" CDECL uint32_t\n+rust_dbg_extern_identity_u32(uint32_t u) {\n+    return u;\n+}\n+\n+extern \"C\" CDECL uint64_t\n+rust_dbg_extern_identity_u64(uint64_t u) {\n+    return u;\n+}\n+\n+struct TwoU64s {\n+    uint64_t one;\n+    uint64_t two;\n+};\n+\n+extern \"C\" CDECL TwoU64s\n+rust_dbg_extern_identity_TwoU64s(TwoU64s u) {\n+    return u;\n+}\n+\n+extern \"C\" CDECL double\n+rust_dbg_extern_identity_double(double u) {\n+    return u;\n+}\n+\n+extern \"C\" CDECL char\n+rust_dbg_extern_identity_u8(char u) {\n+    return u;\n+}\n+\n \n //\n // Local Variables:"}, {"sha": "7fb6334ca754cf499387825a4c853208e1c1a6eb", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=efc7f82bc44926c864c52caca8764816ab9150dd", "patch": "@@ -195,4 +195,9 @@ rust_get_exchange_count_ptr\n rust_get_sched_tls_key\n swap_registers\n rust_readdir\n-rust_opendir\n\\ No newline at end of file\n+rust_opendir\n+rust_dbg_extern_identity_u32\n+rust_dbg_extern_identity_u64\n+rust_dbg_extern_identity_TwoU64s\n+rust_dbg_extern_identity_double\n+rust_dbg_extern_identity_u8"}, {"sha": "12b305720cc93d8e29a27547dd5a05a42afd8f3a", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=efc7f82bc44926c864c52caca8764816ab9150dd", "patch": "@@ -546,8 +546,8 @@ extern \"C\" LLVMValueRef LLVMInlineAsm(LLVMTypeRef Ty,\n                                       char *Constraints,\n                                       LLVMBool HasSideEffects,\n                                       LLVMBool IsAlignStack,\n-                                      InlineAsm::AsmDialect Dialect) {\n+                                      unsigned Dialect) {\n     return wrap(InlineAsm::get(unwrap<FunctionType>(Ty), AsmString,\n                                Constraints, HasSideEffects,\n-                               IsAlignStack, Dialect));\n+                               IsAlignStack, (InlineAsm::AsmDialect) Dialect));\n }"}, {"sha": "00754afa703b258df701bcb6a5d67b8f7404dcd2", "filename": "src/test/run-pass/extern-pass-TwoU64s-ref.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s-ref.rs?ref=efc7f82bc44926c864c52caca8764816ab9150dd", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we ignore modes when calling extern functions.\n+\n+// xfail-test --- broken on 32-bit ABIs! (#5347)\n+\n+#[deriving_eq]\n+struct TwoU64s {\n+    one: u64, two: u64\n+}\n+\n+pub extern {\n+    pub fn rust_dbg_extern_identity_TwoU64s(&&u: TwoU64s) -> TwoU64s;\n+}\n+\n+pub fn main() {\n+    unsafe {\n+        let x = TwoU64s {one: 22, two: 23};\n+        let y = rust_dbg_extern_identity_TwoU64s(x);\n+        fail_unless!(x == y);\n+    }\n+}\n+"}, {"sha": "2baf383ce545f0efaacaff63ce5e2ef6d28f8157", "filename": "src/test/run-pass/extern-pass-TwoU64s.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s.rs?ref=efc7f82bc44926c864c52caca8764816ab9150dd", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a foreign function that accepts and returns a struct\n+// by value.\n+\n+// xfail-test --- broken on 32-bit ABIs! (#5347)\n+\n+#[deriving_eq]\n+struct TwoU64s {\n+    one: u64, two: u64\n+}\n+\n+pub extern {\n+    pub fn rust_dbg_extern_identity_TwoU64s(v: TwoU64s) -> TwoU64s;\n+}\n+\n+pub fn main() {\n+    unsafe {\n+        let x = TwoU64s {one: 22, two: 23};\n+        let y = rust_dbg_extern_identity_TwoU64s(x);\n+        fail_unless!(x == y);\n+    }\n+}\n+"}, {"sha": "104ea342cd5e013285af010214d170fac8d2793d", "filename": "src/test/run-pass/extern-pass-char.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Ftest%2Frun-pass%2Fextern-pass-char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Ftest%2Frun-pass%2Fextern-pass-char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-char.rs?ref=efc7f82bc44926c864c52caca8764816ab9150dd", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a function that takes/returns a u8.\n+\n+pub extern {\n+    pub fn rust_dbg_extern_identity_u8(v: u8) -> u8;\n+}\n+\n+pub fn main() {\n+    unsafe {\n+        fail_unless!(22_u8 == rust_dbg_extern_identity_u8(22_u8));\n+    }\n+}\n+"}, {"sha": "afdec4d1002986c3caf8d702575683f364a40b2f", "filename": "src/test/run-pass/extern-pass-double.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Ftest%2Frun-pass%2Fextern-pass-double.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Ftest%2Frun-pass%2Fextern-pass-double.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-double.rs?ref=efc7f82bc44926c864c52caca8764816ab9150dd", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub extern {\n+    pub fn rust_dbg_extern_identity_double(v: f64) -> f64;\n+}\n+\n+pub fn main() {\n+    unsafe {\n+        fail_unless!(22.0_f64 == rust_dbg_extern_identity_double(22.0_f64));\n+    }\n+}\n+"}, {"sha": "0d6220e7b25cda040a487fa9e5e2d90a70a8d43b", "filename": "src/test/run-pass/extern-pass-u32.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Ftest%2Frun-pass%2Fextern-pass-u32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Ftest%2Frun-pass%2Fextern-pass-u32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-u32.rs?ref=efc7f82bc44926c864c52caca8764816ab9150dd", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a function that takes/returns a u32.\n+\n+pub extern {\n+    pub fn rust_dbg_extern_identity_u32(v: u32) -> u32;\n+}\n+\n+pub fn main() {\n+    unsafe {\n+        fail_unless!(22_u32 == rust_dbg_extern_identity_u32(22_u32));\n+    }\n+}\n+"}, {"sha": "31777035238339238d238f28be95f89d248ad658", "filename": "src/test/run-pass/extern-pass-u64.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Ftest%2Frun-pass%2Fextern-pass-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc7f82bc44926c864c52caca8764816ab9150dd/src%2Ftest%2Frun-pass%2Fextern-pass-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-u64.rs?ref=efc7f82bc44926c864c52caca8764816ab9150dd", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a call to a function that takes/returns a u64.\n+\n+pub extern {\n+    pub fn rust_dbg_extern_identity_u64(v: u64) -> u64;\n+}\n+\n+pub fn main() {\n+    unsafe {\n+        fail_unless!(22_u64 == rust_dbg_extern_identity_u64(22_u64));\n+    }\n+}\n+"}]}