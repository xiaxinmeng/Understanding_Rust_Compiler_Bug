{"sha": "3b446b4b914945209d917a02572909717c6bd0b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiNDQ2YjRiOTE0OTQ1MjA5ZDkxN2EwMjU3MjkwOTcxN2M2YmQwYjk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-11T08:11:37Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-26T14:59:40Z"}, "message": "introduce `QueryTypeOp` trait and use it for `eq`", "tree": {"sha": "9567fae1235cee53f79d2bb951f97101b25c9cbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9567fae1235cee53f79d2bb951f97101b25c9cbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b446b4b914945209d917a02572909717c6bd0b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b446b4b914945209d917a02572909717c6bd0b9", "html_url": "https://github.com/rust-lang/rust/commit/3b446b4b914945209d917a02572909717c6bd0b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b446b4b914945209d917a02572909717c6bd0b9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d664622b6e46df7e41c0132ebbe60abcf482a21", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d664622b6e46df7e41c0132ebbe60abcf482a21", "html_url": "https://github.com/rust-lang/rust/commit/1d664622b6e46df7e41c0132ebbe60abcf482a21"}], "stats": {"total": 121, "additions": 107, "deletions": 14}, "files": [{"sha": "ca10f0e8cea937dd6585fdb6a494c9d59b9bbb20", "filename": "src/librustc_mir/borrow_check/nll/type_check/type_op/eq.rs", "status": "modified", "additions": 48, "deletions": 11, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/3b446b4b914945209d917a02572909717c6bd0b9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b446b4b914945209d917a02572909717c6bd0b9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Feq.rs?ref=3b446b4b914945209d917a02572909717c6bd0b9", "patch": "@@ -8,11 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::infer::{InferCtxt, InferResult};\n-use rustc::traits::ObligationCause;\n-use rustc::ty::{ParamEnv, Ty, TyCtxt};\n+use rustc::infer::canonical::{CanonicalizedQueryResult, Canonical};\n+use rustc::traits::query::NoSolution;\n+use rustc::traits::{FulfillmentContext, ObligationCause};\n+use rustc::ty::{self, ParamEnv, Ty, TyCtxt};\n+use syntax::codemap::DUMMY_SP;\n \n-#[derive(Debug)]\n+#[derive(Copy, Clone, Debug)]\n crate struct Eq<'tcx> {\n     param_env: ParamEnv<'tcx>,\n     a: Ty<'tcx>,\n@@ -25,20 +27,55 @@ impl<'tcx> Eq<'tcx> {\n     }\n }\n \n-impl<'gcx, 'tcx> super::TypeOp<'gcx, 'tcx> for Eq<'tcx> {\n-    type Output = ();\n+impl<'gcx: 'tcx, 'tcx> super::QueryTypeOp<'gcx, 'tcx> for Eq<'tcx> {\n+    type QueryResult = ();\n \n-    fn trivial_noop(self, _tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::Output, Self> {\n+    fn trivial_noop(self, _tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::QueryResult, Self> {\n         if self.a == self.b {\n             Ok(())\n         } else {\n             Err(self)\n         }\n     }\n \n-    fn perform(self, infcx: &InferCtxt<'_, 'gcx, 'tcx>) -> InferResult<'tcx, Self::Output> {\n-        infcx\n-            .at(&ObligationCause::dummy(), self.param_env)\n-            .eq(self.a, self.b)\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        self.param_env\n+    }\n+\n+    fn perform_query(\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        canonicalized: Canonical<'gcx, Eq<'gcx>>,\n+    ) -> CanonicalizedQueryResult<'gcx, ()> {\n+        let tcx = tcx.global_tcx();\n+        tcx.infer_ctxt()\n+            .enter(|ref infcx| {\n+                let (Eq { param_env, a, b }, canonical_inference_vars) =\n+                    infcx.instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonicalized);\n+                let fulfill_cx = &mut FulfillmentContext::new();\n+                let obligations = match infcx.at(&ObligationCause::dummy(), param_env).eq(a, b) {\n+                    Ok(v) => v.into_obligations(),\n+                    Err(_) => return Err(NoSolution),\n+                };\n+                fulfill_cx.register_predicate_obligations(infcx, obligations);\n+                infcx.make_canonicalized_query_result(canonical_inference_vars, (), fulfill_cx)\n+            })\n+            .unwrap()\n+    }\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for Eq<'tcx> {\n+        param_env,\n+        a,\n+        b,\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for Eq<'a> {\n+        type Lifted = Eq<'tcx>;\n+        param_env,\n+        a,\n+        b,\n     }\n }"}, {"sha": "4d9dd915f037370ecedf5b95f6dddc89babcddf7", "filename": "src/librustc_mir/borrow_check/nll/type_check/type_op/mod.rs", "status": "modified", "additions": 59, "deletions": 3, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/3b446b4b914945209d917a02572909717c6bd0b9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b446b4b914945209d917a02572909717c6bd0b9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ftype_op%2Fmod.rs?ref=3b446b4b914945209d917a02572909717c6bd0b9", "patch": "@@ -9,20 +9,21 @@\n // except according to those terms.\n \n use rustc::infer::canonical::query_result;\n-use rustc::infer::canonical::QueryRegionConstraint;\n+use rustc::infer::canonical::{Canonicalized, CanonicalizedQueryResult, QueryRegionConstraint};\n use rustc::infer::{InferCtxt, InferOk, InferResult};\n use rustc::traits::{ObligationCause, TraitEngine};\n use rustc::ty::error::TypeError;\n-use rustc::ty::TyCtxt;\n+use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::{Lift, ParamEnv, TyCtxt};\n use std::fmt;\n use std::rc::Rc;\n use syntax::codemap::DUMMY_SP;\n \n crate mod custom;\n crate mod eq;\n crate mod normalize;\n-crate mod predicates;\n crate mod outlives;\n+crate mod predicates;\n crate mod subtype;\n \n crate trait TypeOp<'gcx, 'tcx>: Sized + fmt::Debug {\n@@ -96,3 +97,58 @@ crate trait TypeOp<'gcx, 'tcx>: Sized + fmt::Debug {\n         }\n     }\n }\n+\n+type Lifted<'gcx, T> = <T as Lift<'gcx>>::Lifted;\n+\n+crate trait QueryTypeOp<'gcx: 'tcx, 'tcx>: TypeFoldable<'tcx> + Lift<'gcx> {\n+    type QueryResult: TypeFoldable<'tcx> + Lift<'gcx>;\n+\n+    /// Micro-optimization: returns `Ok(x)` if we can trivially\n+    /// produce the output, else returns `Err(self)` back.\n+    fn trivial_noop(\n+        self,\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+    ) -> Result<Lifted<'gcx, Self::QueryResult>, Self>;\n+\n+    fn param_env(&self) -> ParamEnv<'tcx>;\n+\n+    fn perform_query(\n+        tcx: TyCtxt<'_, 'gcx, 'tcx>,\n+        canonicalized: Canonicalized<'gcx, Self>,\n+    ) -> CanonicalizedQueryResult<'gcx, Self::QueryResult>;\n+}\n+\n+impl<'gcx: 'tcx, 'tcx, Q> TypeOp<'gcx, 'tcx> for Q\n+where\n+    Q: QueryTypeOp<'gcx, 'tcx>,\n+    Lifted<'gcx, Q::QueryResult>: TypeFoldable<'tcx>,\n+{\n+    type Output = Lifted<'gcx, Q::QueryResult>;\n+\n+    fn trivial_noop(self, tcx: TyCtxt<'_, 'gcx, 'tcx>) -> Result<Self::Output, Self> {\n+        QueryTypeOp::trivial_noop(self, tcx)\n+    }\n+\n+    fn perform(self, infcx: &InferCtxt<'_, 'gcx, 'tcx>) -> InferResult<'tcx, Self::Output> {\n+        let param_env = self.param_env();\n+\n+        let (canonical_self, canonical_var_values) = infcx.canonicalize_query(&self);\n+        let canonical_result = Q::perform_query(infcx.tcx, canonical_self);\n+\n+        // FIXME: This is not the most efficient setup. The\n+        // `instantiate_query_result_and_region_obligations` basically\n+        // takes the `QueryRegionConstraint` values that we ultimately\n+        // want to use and converts them into obligations. We return\n+        // those to our caller, which will convert them into AST\n+        // region constraints; we then convert *those* back into\n+        // `QueryRegionConstraint` and ultimately into NLL\n+        // constraints. We should cut out the middleman but that will\n+        // take a bit of refactoring.\n+        infcx.instantiate_query_result_and_region_obligations(\n+            &ObligationCause::dummy(),\n+            param_env,\n+            &canonical_var_values,\n+            &canonical_result,\n+        )\n+    }\n+}"}]}