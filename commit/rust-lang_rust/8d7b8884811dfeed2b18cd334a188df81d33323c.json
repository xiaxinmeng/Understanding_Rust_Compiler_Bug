{"sha": "8d7b8884811dfeed2b18cd334a188df81d33323c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkN2I4ODg0ODExZGZlZWQyYjE4Y2QzMzRhMTg4ZGY4MWQzMzMyM2M=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-05T12:04:13Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-05T12:04:13Z"}, "message": "Merge #194\n\n194: Introduce FilePosition r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "e4ade14c93e07ad1e55df0961ba5ca67902f29f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4ade14c93e07ad1e55df0961ba5ca67902f29f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d7b8884811dfeed2b18cd334a188df81d33323c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d7b8884811dfeed2b18cd334a188df81d33323c", "html_url": "https://github.com/rust-lang/rust/commit/8d7b8884811dfeed2b18cd334a188df81d33323c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d7b8884811dfeed2b18cd334a188df81d33323c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "8b132354bb7b08e96bb19b8446f1456c4013e842", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b132354bb7b08e96bb19b8446f1456c4013e842", "html_url": "https://github.com/rust-lang/rust/commit/8b132354bb7b08e96bb19b8446f1456c4013e842"}, {"sha": "0192c116f78b3a81ef15587eecac29a2676ae00c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0192c116f78b3a81ef15587eecac29a2676ae00c", "html_url": "https://github.com/rust-lang/rust/commit/0192c116f78b3a81ef15587eecac29a2676ae00c"}], "stats": {"total": 297, "additions": 132, "deletions": 165}, "files": [{"sha": "7c3476e5c2fd559ede1f456a7dc820acc7cebfa9", "filename": "crates/ra_analysis/src/completion.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8d7b8884811dfeed2b18cd334a188df81d33323c/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d7b8884811dfeed2b18cd334a188df81d33323c/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs?ref=8d7b8884811dfeed2b18cd334a188df81d33323c", "patch": "@@ -14,7 +14,7 @@ use crate::{\n     descriptors::module::{ModuleId, ModuleScope, ModuleTree, ModuleSource},\n     descriptors::DescriptorDatabase,\n     input::FilesDatabase,\n-    Cancelable, FileId,\n+    Cancelable, FilePosition,\n };\n \n #[derive(Debug)]\n@@ -29,21 +29,21 @@ pub struct CompletionItem {\n \n pub(crate) fn resolve_based_completion(\n     db: &db::RootDatabase,\n-    file_id: FileId,\n-    offset: TextUnit,\n+    position: FilePosition,\n ) -> Cancelable<Option<Vec<CompletionItem>>> {\n-    let source_root_id = db.file_source_root(file_id);\n-    let file = db.file_syntax(file_id);\n+    let source_root_id = db.file_source_root(position.file_id);\n+    let file = db.file_syntax(position.file_id);\n     let module_tree = db.module_tree(source_root_id)?;\n-    let module_id = match module_tree.any_module_for_source(ModuleSource::File(file_id)) {\n+    let module_id = match module_tree.any_module_for_source(ModuleSource::File(position.file_id)) {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n     let file = {\n-        let edit = AtomEdit::insert(offset, \"intellijRulezz\".to_string());\n+        let edit = AtomEdit::insert(position.offset, \"intellijRulezz\".to_string());\n         file.reparse(&edit)\n     };\n-    let target_module_id = match find_target_module(&module_tree, module_id, &file, offset) {\n+    let target_module_id = match find_target_module(&module_tree, module_id, &file, position.offset)\n+    {\n         None => return Ok(None),\n         Some(it) => it,\n     };\n@@ -99,18 +99,17 @@ fn crate_path(name_ref: ast::NameRef) -> Option<Vec<ast::NameRef>> {\n \n pub(crate) fn scope_completion(\n     db: &db::RootDatabase,\n-    file_id: FileId,\n-    offset: TextUnit,\n+    position: FilePosition,\n ) -> Option<Vec<CompletionItem>> {\n-    let original_file = db.file_syntax(file_id);\n+    let original_file = db.file_syntax(position.file_id);\n     // Insert a fake ident to get a valid parse tree\n     let file = {\n-        let edit = AtomEdit::insert(offset, \"intellijRulezz\".to_string());\n+        let edit = AtomEdit::insert(position.offset, \"intellijRulezz\".to_string());\n         original_file.reparse(&edit)\n     };\n     let mut has_completions = false;\n     let mut res = Vec::new();\n-    if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(file.syntax(), offset) {\n+    if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(file.syntax(), position.offset) {\n         has_completions = true;\n         complete_name_ref(&file, name_ref, &mut res);\n         // special case, `trait T { fn foo(i_am_a_name_ref) {} }`\n@@ -129,7 +128,7 @@ pub(crate) fn scope_completion(\n             _ => (),\n         }\n     }\n-    if let Some(name) = find_node_at_offset::<ast::Name>(file.syntax(), offset) {\n+    if let Some(name) = find_node_at_offset::<ast::Name>(file.syntax(), position.offset) {\n         if is_node::<ast::Param>(name.syntax()) {\n             has_completions = true;\n             param_completions(name.syntax(), &mut res);\n@@ -383,7 +382,7 @@ mod tests {\n \n     fn check_scope_completion(code: &str, expected_completions: &str) {\n         let (analysis, position) = single_file_with_position(code);\n-        let completions = scope_completion(&analysis.imp.db, position.file_id, position.offset)\n+        let completions = scope_completion(&analysis.imp.db, position)\n             .unwrap()\n             .into_iter()\n             .filter(|c| c.snippet.is_none())\n@@ -393,7 +392,7 @@ mod tests {\n \n     fn check_snippet_completion(code: &str, expected_completions: &str) {\n         let (analysis, position) = single_file_with_position(code);\n-        let completions = scope_completion(&analysis.imp.db, position.file_id, position.offset)\n+        let completions = scope_completion(&analysis.imp.db, position)\n             .unwrap()\n             .into_iter()\n             .filter(|c| c.snippet.is_some())"}, {"sha": "f2482559fcbe3f13b38694edf70b073cc0488421", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 36, "deletions": 42, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/8d7b8884811dfeed2b18cd334a188df81d33323c/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d7b8884811dfeed2b18cd334a188df81d33323c/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=8d7b8884811dfeed2b18cd334a188df81d33323c", "patch": "@@ -27,7 +27,7 @@ use crate::{\n     input::{FilesDatabase, SourceRoot, SourceRootId, WORKSPACE},\n     symbol_index::SymbolIndex,\n     AnalysisChange, Cancelable, CrateGraph, CrateId, Diagnostic, FileId, FileResolver,\n-    FileSystemEdit, Position, Query, SourceChange, SourceFileEdit,\n+    FileSystemEdit, FilePosition, Query, SourceChange, SourceFileEdit,\n };\n \n #[derive(Clone, Debug)]\n@@ -220,16 +220,13 @@ impl AnalysisImpl {\n         let source_root = self.db.file_source_root(file_id);\n         self.db.module_tree(source_root)\n     }\n-    pub fn parent_module(\n-        &self,\n-        file_id: FileId,\n-        offset: TextUnit,\n-    ) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n-        let module_tree = self.module_tree(file_id)?;\n-        let file = self.db.file_syntax(file_id);\n-        let module_source = match find_node_at_offset::<ast::Module>(file.syntax(), offset) {\n-            Some(m) if !m.has_semi() => ModuleSource::new_inline(file_id, m),\n-            _ => ModuleSource::File(file_id),\n+    pub fn parent_module(&self, position: FilePosition) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n+        let module_tree = self.module_tree(position.file_id)?;\n+        let file = self.db.file_syntax(position.file_id);\n+        let module_source = match find_node_at_offset::<ast::Module>(file.syntax(), position.offset)\n+        {\n+            Some(m) if !m.has_semi() => ModuleSource::new_inline(position.file_id, m),\n+            _ => ModuleSource::File(position.file_id),\n         };\n \n         let res = module_tree\n@@ -269,18 +266,14 @@ impl AnalysisImpl {\n     pub fn crate_root(&self, crate_id: CrateId) -> FileId {\n         self.db.crate_graph().crate_roots[&crate_id]\n     }\n-    pub fn completions(\n-        &self,\n-        file_id: FileId,\n-        offset: TextUnit,\n-    ) -> Cancelable<Option<Vec<CompletionItem>>> {\n+    pub fn completions(&self, position: FilePosition) -> Cancelable<Option<Vec<CompletionItem>>> {\n         let mut res = Vec::new();\n         let mut has_completions = false;\n-        if let Some(scope_based) = scope_completion(&self.db, file_id, offset) {\n+        if let Some(scope_based) = scope_completion(&self.db, position) {\n             res.extend(scope_based);\n             has_completions = true;\n         }\n-        if let Some(scope_based) = resolve_based_completion(&self.db, file_id, offset)? {\n+        if let Some(scope_based) = resolve_based_completion(&self.db, position)? {\n             res.extend(scope_based);\n             has_completions = true;\n         }\n@@ -289,18 +282,19 @@ impl AnalysisImpl {\n     }\n     pub fn approximately_resolve_symbol(\n         &self,\n-        file_id: FileId,\n-        offset: TextUnit,\n+        position: FilePosition,\n     ) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n-        let module_tree = self.module_tree(file_id)?;\n-        let file = self.db.file_syntax(file_id);\n+        let module_tree = self.module_tree(position.file_id)?;\n+        let file = self.db.file_syntax(position.file_id);\n         let syntax = file.syntax();\n-        if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(syntax, offset) {\n+        if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(syntax, position.offset) {\n             // First try to resolve the symbol locally\n-            return if let Some((name, range)) = resolve_local_name(&self.db, file_id, name_ref) {\n+            return if let Some((name, range)) =\n+                resolve_local_name(&self.db, position.file_id, name_ref)\n+            {\n                 let mut vec = vec![];\n                 vec.push((\n-                    file_id,\n+                    position.file_id,\n                     FileSymbol {\n                         name,\n                         node_range: range,\n@@ -313,10 +307,10 @@ impl AnalysisImpl {\n                 self.index_resolve(name_ref)\n             };\n         }\n-        if let Some(name) = find_node_at_offset::<ast::Name>(syntax, offset) {\n+        if let Some(name) = find_node_at_offset::<ast::Name>(syntax, position.offset) {\n             if let Some(module) = name.syntax().parent().and_then(ast::Module::cast) {\n                 if module.has_semi() {\n-                    let file_ids = self.resolve_module(&*module_tree, file_id, module);\n+                    let file_ids = self.resolve_module(&*module_tree, position.file_id, module);\n \n                     let res = file_ids\n                         .into_iter()\n@@ -341,16 +335,17 @@ impl AnalysisImpl {\n         Ok(vec![])\n     }\n \n-    pub fn find_all_refs(&self, file_id: FileId, offset: TextUnit) -> Vec<(FileId, TextRange)> {\n-        let file = self.db.file_syntax(file_id);\n+    pub fn find_all_refs(&self, position: FilePosition) -> Vec<(FileId, TextRange)> {\n+        let file = self.db.file_syntax(position.file_id);\n         let syntax = file.syntax();\n \n         // Find the binding associated with the offset\n-        let maybe_binding = find_node_at_offset::<ast::BindPat>(syntax, offset).or_else(|| {\n-            let name_ref = find_node_at_offset::<ast::NameRef>(syntax, offset)?;\n-            let resolved = resolve_local_name(&self.db, file_id, name_ref)?;\n-            find_node_at_offset::<ast::BindPat>(syntax, resolved.1.end())\n-        });\n+        let maybe_binding =\n+            find_node_at_offset::<ast::BindPat>(syntax, position.offset).or_else(|| {\n+                let name_ref = find_node_at_offset::<ast::NameRef>(syntax, position.offset)?;\n+                let resolved = resolve_local_name(&self.db, position.file_id, name_ref)?;\n+                find_node_at_offset::<ast::BindPat>(syntax, resolved.1.end())\n+            });\n \n         let binding = match maybe_binding {\n             None => return Vec::new(),\n@@ -359,11 +354,11 @@ impl AnalysisImpl {\n \n         let decl = DeclarationDescriptor::new(binding);\n \n-        let mut ret = vec![(file_id, decl.range)];\n+        let mut ret = vec![(position.file_id, decl.range)];\n         ret.extend(\n             decl.find_all_refs()\n                 .into_iter()\n-                .map(|ref_desc| (file_id, ref_desc.range)),\n+                .map(|ref_desc| (position.file_id, ref_desc.range)),\n         );\n \n         ret\n@@ -457,14 +452,13 @@ impl AnalysisImpl {\n \n     pub fn resolve_callable(\n         &self,\n-        file_id: FileId,\n-        offset: TextUnit,\n+        position: FilePosition,\n     ) -> Cancelable<Option<(FnDescriptor, Option<usize>)>> {\n-        let file = self.db.file_syntax(file_id);\n+        let file = self.db.file_syntax(position.file_id);\n         let syntax = file.syntax();\n \n         // Find the calling expression and it's NameRef\n-        let calling_node = match FnCallNode::with_node(syntax, offset) {\n+        let calling_node = match FnCallNode::with_node(syntax, position.offset) {\n             Some(node) => node,\n             None => return Ok(None),\n         };\n@@ -499,7 +493,7 @@ impl AnalysisImpl {\n                             if let Some(ref arg_list) = calling_node.arg_list() {\n                                 let start = arg_list.syntax().range().start();\n \n-                                let range_search = TextRange::from_to(start, offset);\n+                                let range_search = TextRange::from_to(start, position.offset);\n                                 let mut commas: usize = arg_list\n                                     .syntax()\n                                     .text()\n@@ -568,7 +562,7 @@ impl SourceChange {\n             file_system_edits: vec![],\n             cursor_position: edit\n                 .cursor_position\n-                .map(|offset| Position { offset, file_id }),\n+                .map(|offset| FilePosition { offset, file_id }),\n         }\n     }\n }"}, {"sha": "0ea9ebee7b5e3720ae901f389a703badf59b3a99", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 25, "deletions": 39, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8d7b8884811dfeed2b18cd334a188df81d33323c/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d7b8884811dfeed2b18cd334a188df81d33323c/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=8d7b8884811dfeed2b18cd334a188df81d33323c", "patch": "@@ -119,18 +119,18 @@ impl AnalysisHost {\n     }\n }\n \n+#[derive(Clone, Copy, Debug)]\n+pub struct FilePosition {\n+    pub file_id: FileId,\n+    pub offset: TextUnit,\n+}\n+\n #[derive(Debug)]\n pub struct SourceChange {\n     pub label: String,\n     pub source_file_edits: Vec<SourceFileEdit>,\n     pub file_system_edits: Vec<FileSystemEdit>,\n-    pub cursor_position: Option<Position>,\n-}\n-\n-#[derive(Debug)]\n-pub struct Position {\n-    pub file_id: FileId,\n-    pub offset: TextUnit,\n+    pub cursor_position: Option<FilePosition>,\n }\n \n #[derive(Debug)]\n@@ -224,18 +224,18 @@ impl Analysis {\n         let file = self.imp.file_syntax(file_id);\n         SourceChange::from_local_edit(file_id, \"join lines\", ra_editor::join_lines(&file, range))\n     }\n-    pub fn on_enter(&self, file_id: FileId, offset: TextUnit) -> Option<SourceChange> {\n-        let file = self.imp.file_syntax(file_id);\n-        let edit = ra_editor::on_enter(&file, offset)?;\n-        let res = SourceChange::from_local_edit(file_id, \"on enter\", edit);\n+    pub fn on_enter(&self, position: FilePosition) -> Option<SourceChange> {\n+        let file = self.imp.file_syntax(position.file_id);\n+        let edit = ra_editor::on_enter(&file, position.offset)?;\n+        let res = SourceChange::from_local_edit(position.file_id, \"on enter\", edit);\n         Some(res)\n     }\n-    pub fn on_eq_typed(&self, file_id: FileId, offset: TextUnit) -> Option<SourceChange> {\n-        let file = self.imp.file_syntax(file_id);\n+    pub fn on_eq_typed(&self, position: FilePosition) -> Option<SourceChange> {\n+        let file = self.imp.file_syntax(position.file_id);\n         Some(SourceChange::from_local_edit(\n-            file_id,\n+            position.file_id,\n             \"add semicolon\",\n-            ra_editor::on_eq_typed(&file, offset)?,\n+            ra_editor::on_eq_typed(&file, position.offset)?,\n         ))\n     }\n     pub fn file_structure(&self, file_id: FileId) -> Vec<StructureNode> {\n@@ -251,24 +251,15 @@ impl Analysis {\n     }\n     pub fn approximately_resolve_symbol(\n         &self,\n-        file_id: FileId,\n-        offset: TextUnit,\n+        position: FilePosition,\n     ) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n-        self.imp.approximately_resolve_symbol(file_id, offset)\n+        self.imp.approximately_resolve_symbol(position)\n     }\n-    pub fn find_all_refs(\n-        &self,\n-        file_id: FileId,\n-        offset: TextUnit,\n-    ) -> Cancelable<Vec<(FileId, TextRange)>> {\n-        Ok(self.imp.find_all_refs(file_id, offset))\n+    pub fn find_all_refs(&self, position: FilePosition) -> Cancelable<Vec<(FileId, TextRange)>> {\n+        Ok(self.imp.find_all_refs(position))\n     }\n-    pub fn parent_module(\n-        &self,\n-        file_id: FileId,\n-        offset: TextUnit,\n-    ) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n-        self.imp.parent_module(file_id, offset)\n+    pub fn parent_module(&self, position: FilePosition) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n+        self.imp.parent_module(position)\n     }\n     pub fn crate_for(&self, file_id: FileId) -> Cancelable<Vec<CrateId>> {\n         self.imp.crate_for(file_id)\n@@ -284,12 +275,8 @@ impl Analysis {\n         let file = self.imp.file_syntax(file_id);\n         Ok(ra_editor::highlight(&file))\n     }\n-    pub fn completions(\n-        &self,\n-        file_id: FileId,\n-        offset: TextUnit,\n-    ) -> Cancelable<Option<Vec<CompletionItem>>> {\n-        self.imp.completions(file_id, offset)\n+    pub fn completions(&self, position: FilePosition) -> Cancelable<Option<Vec<CompletionItem>>> {\n+        self.imp.completions(position)\n     }\n     pub fn assists(&self, file_id: FileId, range: TextRange) -> Cancelable<Vec<SourceChange>> {\n         Ok(self.imp.assists(file_id, range))\n@@ -299,10 +286,9 @@ impl Analysis {\n     }\n     pub fn resolve_callable(\n         &self,\n-        file_id: FileId,\n-        offset: TextUnit,\n+        position: FilePosition,\n     ) -> Cancelable<Option<(FnDescriptor, Option<usize>)>> {\n-        self.imp.resolve_callable(file_id, offset)\n+        self.imp.resolve_callable(position)\n     }\n }\n "}, {"sha": "8e8f969f454fc05d766923f657e4f70cfb807e16", "filename": "crates/ra_analysis/src/mock_analysis.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8d7b8884811dfeed2b18cd334a188df81d33323c/crates%2Fra_analysis%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d7b8884811dfeed2b18cd334a188df81d33323c/crates%2Fra_analysis%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fmock_analysis.rs?ref=8d7b8884811dfeed2b18cd334a188df81d33323c", "patch": "@@ -1,16 +1,9 @@\n use std::sync::Arc;\n \n-use ra_syntax::TextUnit;\n use relative_path::{RelativePath, RelativePathBuf};\n use test_utils::{extract_offset, parse_fixture, CURSOR_MARKER};\n \n-use crate::{Analysis, AnalysisChange, AnalysisHost, FileId, FileResolver};\n-\n-#[derive(Debug)]\n-pub struct FilePosition {\n-    pub file_id: FileId,\n-    pub offset: TextUnit,\n-}\n+use crate::{Analysis, AnalysisChange, AnalysisHost, FileId, FileResolver, FilePosition};\n \n /// Mock analysis is used in test to bootstrap an AnalysisHost/Analysis\n /// from a set of in-memory files."}, {"sha": "c605d34f0ba8d338b30936948c585af76c6ea270", "filename": "crates/ra_analysis/tests/tests.rs", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8d7b8884811dfeed2b18cd334a188df81d33323c/crates%2Fra_analysis%2Ftests%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d7b8884811dfeed2b18cd334a188df81d33323c/crates%2Fra_analysis%2Ftests%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Ftests%2Ftests.rs?ref=8d7b8884811dfeed2b18cd334a188df81d33323c", "patch": "@@ -15,10 +15,7 @@ use ra_analysis::{\n \n fn get_signature(text: &str) -> (FnDescriptor, Option<usize>) {\n     let (analysis, position) = single_file_with_position(text);\n-    analysis\n-        .resolve_callable(position.file_id, position.offset)\n-        .unwrap()\n-        .unwrap()\n+    analysis.resolve_callable(position).unwrap().unwrap()\n }\n \n #[test]\n@@ -32,9 +29,7 @@ fn test_resolve_module() {\n     \",\n     );\n \n-    let symbols = analysis\n-        .approximately_resolve_symbol(pos.file_id, pos.offset)\n-        .unwrap();\n+    let symbols = analysis.approximately_resolve_symbol(pos).unwrap();\n     assert_eq_dbg(\n         r#\"[(FileId(2), FileSymbol { name: \"foo\", node_range: [0; 0), kind: MODULE })]\"#,\n         &symbols,\n@@ -49,9 +44,7 @@ fn test_resolve_module() {\n     \",\n     );\n \n-    let symbols = analysis\n-        .approximately_resolve_symbol(pos.file_id, pos.offset)\n-        .unwrap();\n+    let symbols = analysis.approximately_resolve_symbol(pos).unwrap();\n     assert_eq_dbg(\n         r#\"[(FileId(2), FileSymbol { name: \"foo\", node_range: [0; 0), kind: MODULE })]\"#,\n         &symbols,\n@@ -92,7 +85,7 @@ fn test_resolve_parent_module() {\n         <|>// empty\n     \",\n     );\n-    let symbols = analysis.parent_module(pos.file_id, pos.offset).unwrap();\n+    let symbols = analysis.parent_module(pos).unwrap();\n     assert_eq_dbg(\n         r#\"[(FileId(1), FileSymbol { name: \"foo\", node_range: [4; 7), kind: MODULE })]\"#,\n         &symbols,\n@@ -111,7 +104,7 @@ fn test_resolve_parent_module_for_inline() {\n         }\n     \",\n     );\n-    let symbols = analysis.parent_module(pos.file_id, pos.offset).unwrap();\n+    let symbols = analysis.parent_module(pos).unwrap();\n     assert_eq_dbg(\n         r#\"[(FileId(1), FileSymbol { name: \"bar\", node_range: [18; 21), kind: MODULE })]\"#,\n         &symbols,\n@@ -397,9 +390,7 @@ By default this method stops actor's `Context`.\"#\n \n fn get_all_refs(text: &str) -> Vec<(FileId, TextRange)> {\n     let (analysis, position) = single_file_with_position(text);\n-    analysis\n-        .find_all_refs(position.file_id, position.offset)\n-        .unwrap()\n+    analysis.find_all_refs(position).unwrap()\n }\n \n #[test]\n@@ -454,10 +445,7 @@ fn test_complete_crate_path() {\n         use crate::Sp<|>\n     \",\n     );\n-    let completions = analysis\n-        .completions(position.file_id, position.offset)\n-        .unwrap()\n-        .unwrap();\n+    let completions = analysis.completions(position).unwrap().unwrap();\n     assert_eq_dbg(\n         r#\"[CompletionItem { label: \"foo\", lookup: None, snippet: None },\n             CompletionItem { label: \"Spam\", lookup: None, snippet: None }]\"#,"}, {"sha": "fa04f4b00bd998e819e2ca33033a16f890bdd22d", "filename": "crates/ra_lsp_server/src/conv.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8d7b8884811dfeed2b18cd334a188df81d33323c/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d7b8884811dfeed2b18cd334a188df81d33323c/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs?ref=8d7b8884811dfeed2b18cd334a188df81d33323c", "patch": "@@ -2,7 +2,7 @@ use languageserver_types::{\n     Location, Position, Range, SymbolKind, TextDocumentEdit, TextDocumentIdentifier,\n     TextDocumentItem, TextDocumentPositionParams, TextEdit, Url, VersionedTextDocumentIdentifier,\n };\n-use ra_analysis::{FileId, FileSystemEdit, SourceChange, SourceFileEdit};\n+use ra_analysis::{FileId, FileSystemEdit, SourceChange, SourceFileEdit, FilePosition};\n use ra_editor::{AtomEdit, Edit, LineCol, LineIndex};\n use ra_syntax::{SyntaxKind, TextRange, TextUnit};\n \n@@ -165,6 +165,17 @@ impl<'a> TryConvWith for &'a TextDocumentIdentifier {\n     }\n }\n \n+impl<'a> TryConvWith for &'a TextDocumentPositionParams {\n+    type Ctx = ServerWorld;\n+    type Output = FilePosition;\n+    fn try_conv_with(self, world: &ServerWorld) -> Result<FilePosition> {\n+        let file_id = self.text_document.try_conv_with(world)?;\n+        let line_index = world.analysis().file_line_index(file_id);\n+        let offset = self.position.conv_with(&line_index);\n+        Ok(FilePosition { file_id, offset })\n+    }\n+}\n+\n impl<T: TryConvWith> TryConvWith for Vec<T> {\n     type Ctx = <T as TryConvWith>::Ctx;\n     type Output = Vec<<T as TryConvWith>::Output>;"}, {"sha": "5314a333e8283ae65755dbf79101d9c2c34b4184", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/8d7b8884811dfeed2b18cd334a188df81d33323c/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d7b8884811dfeed2b18cd334a188df81d33323c/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=8d7b8884811dfeed2b18cd334a188df81d33323c", "patch": "@@ -6,9 +6,9 @@ use languageserver_types::{\n     DiagnosticSeverity, DocumentSymbol, Documentation, FoldingRange, FoldingRangeKind,\n     FoldingRangeParams, InsertTextFormat, Location, MarkupContent, MarkupKind, Position,\n     PrepareRenameResponse, RenameParams, SymbolInformation, TextDocumentIdentifier, TextEdit,\n-    WorkspaceEdit,\n+    WorkspaceEdit, ParameterInformation, SignatureInformation,\n };\n-use ra_analysis::{FileId, FoldKind, Query, RunnableKind};\n+use ra_analysis::{FileId, FoldKind, Query, RunnableKind, FilePosition};\n use ra_syntax::text_utils::contains_offset_nonstrict;\n use rustc_hash::FxHashMap;\n use serde_json::to_value;\n@@ -83,10 +83,8 @@ pub fn handle_on_enter(\n     world: ServerWorld,\n     params: req::TextDocumentPositionParams,\n ) -> Result<Option<req::SourceChange>> {\n-    let file_id = params.text_document.try_conv_with(&world)?;\n-    let line_index = world.analysis().file_line_index(file_id);\n-    let offset = params.position.conv_with(&line_index);\n-    match world.analysis().on_enter(file_id, offset) {\n+    let position = params.try_conv_with(&world)?;\n+    match world.analysis().on_enter(position) {\n         None => Ok(None),\n         Some(edit) => Ok(Some(edit.try_conv_with(&world)?)),\n     }\n@@ -102,8 +100,11 @@ pub fn handle_on_type_formatting(\n \n     let file_id = params.text_document.try_conv_with(&world)?;\n     let line_index = world.analysis().file_line_index(file_id);\n-    let offset = params.position.conv_with(&line_index);\n-    let edits = match world.analysis().on_eq_typed(file_id, offset) {\n+    let position = FilePosition {\n+        file_id,\n+        offset: params.position.conv_with(&line_index),\n+    };\n+    let edits = match world.analysis().on_eq_typed(position) {\n         None => return Ok(None),\n         Some(mut action) => action.source_file_edits.pop().unwrap().edits,\n     };\n@@ -201,14 +202,9 @@ pub fn handle_goto_definition(\n     world: ServerWorld,\n     params: req::TextDocumentPositionParams,\n ) -> Result<Option<req::GotoDefinitionResponse>> {\n-    let file_id = params.text_document.try_conv_with(&world)?;\n-    let line_index = world.analysis().file_line_index(file_id);\n-    let offset = params.position.conv_with(&line_index);\n+    let position = params.try_conv_with(&world)?;\n     let mut res = Vec::new();\n-    for (file_id, symbol) in world\n-        .analysis()\n-        .approximately_resolve_symbol(file_id, offset)?\n-    {\n+    for (file_id, symbol) in world.analysis().approximately_resolve_symbol(position)? {\n         let line_index = world.analysis().file_line_index(file_id);\n         let location = to_location(file_id, symbol.node_range, &world, &line_index)?;\n         res.push(location)\n@@ -220,11 +216,9 @@ pub fn handle_parent_module(\n     world: ServerWorld,\n     params: req::TextDocumentPositionParams,\n ) -> Result<Vec<Location>> {\n-    let file_id = params.text_document.try_conv_with(&world)?;\n-    let line_index = world.analysis().file_line_index(file_id);\n-    let offset = params.position.conv_with(&line_index);\n+    let position = params.try_conv_with(&world)?;\n     let mut res = Vec::new();\n-    for (file_id, symbol) in world.analysis().parent_module(file_id, offset)? {\n+    for (file_id, symbol) in world.analysis().parent_module(position)? {\n         let line_index = world.analysis().file_line_index(file_id);\n         let location = to_location(file_id, symbol.node_range, &world, &line_index)?;\n         res.push(location);\n@@ -381,10 +375,13 @@ pub fn handle_completion(\n     world: ServerWorld,\n     params: req::CompletionParams,\n ) -> Result<Option<req::CompletionResponse>> {\n-    let file_id = params.text_document.try_conv_with(&world)?;\n-    let line_index = world.analysis().file_line_index(file_id);\n-    let offset = params.position.conv_with(&line_index);\n-    let items = match world.analysis().completions(file_id, offset)? {\n+    let position = {\n+        let file_id = params.text_document.try_conv_with(&world)?;\n+        let line_index = world.analysis().file_line_index(file_id);\n+        let offset = params.position.conv_with(&line_index);\n+        FilePosition { file_id, offset }\n+    };\n+    let items = match world.analysis().completions(position)? {\n         None => return Ok(None),\n         Some(items) => items,\n     };\n@@ -444,13 +441,9 @@ pub fn handle_signature_help(\n     world: ServerWorld,\n     params: req::TextDocumentPositionParams,\n ) -> Result<Option<req::SignatureHelp>> {\n-    use languageserver_types::{ParameterInformation, SignatureInformation};\n+    let position = params.try_conv_with(&world)?;\n \n-    let file_id = params.text_document.try_conv_with(&world)?;\n-    let line_index = world.analysis().file_line_index(file_id);\n-    let offset = params.position.conv_with(&line_index);\n-\n-    if let Some((descriptor, active_param)) = world.analysis().resolve_callable(file_id, offset)? {\n+    if let Some((descriptor, active_param)) = world.analysis().resolve_callable(position)? {\n         let parameters: Vec<ParameterInformation> = descriptor\n             .params\n             .iter()\n@@ -489,18 +482,17 @@ pub fn handle_prepare_rename(\n     world: ServerWorld,\n     params: req::TextDocumentPositionParams,\n ) -> Result<Option<PrepareRenameResponse>> {\n-    let file_id = params.text_document.try_conv_with(&world)?;\n-    let line_index = world.analysis().file_line_index(file_id);\n-    let offset = params.position.conv_with(&line_index);\n+    let position = params.try_conv_with(&world)?;\n \n     // We support renaming references like handle_rename does.\n     // In the future we may want to reject the renaming of things like keywords here too.\n-    let refs = world.analysis().find_all_refs(file_id, offset)?;\n-    if refs.is_empty() {\n-        return Ok(None);\n-    }\n-\n-    let r = refs.first().unwrap();\n+    let refs = world.analysis().find_all_refs(position)?;\n+    let r = match refs.first() {\n+        Some(r) => r,\n+        None => return Ok(None),\n+    };\n+    let file_id = params.text_document.try_conv_with(&world)?;\n+    let line_index = world.analysis().file_line_index(file_id);\n     let loc = to_location(r.0, r.1, &world, &line_index)?;\n \n     Ok(Some(PrepareRenameResponse::Range(loc.range)))\n@@ -519,7 +511,9 @@ pub fn handle_rename(world: ServerWorld, params: RenameParams) -> Result<Option<\n         .into());\n     }\n \n-    let refs = world.analysis().find_all_refs(file_id, offset)?;\n+    let refs = world\n+        .analysis()\n+        .find_all_refs(FilePosition { file_id, offset })?;\n     if refs.is_empty() {\n         return Ok(None);\n     }\n@@ -550,7 +544,9 @@ pub fn handle_references(\n     let line_index = world.analysis().file_line_index(file_id);\n     let offset = params.position.conv_with(&line_index);\n \n-    let refs = world.analysis().find_all_refs(file_id, offset)?;\n+    let refs = world\n+        .analysis()\n+        .find_all_refs(FilePosition { file_id, offset })?;\n \n     Ok(Some(\n         refs.into_iter()"}]}