{"sha": "b3ca36b2d9fe5f2ef27cc19ced232e3168b77a38", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzY2EzNmIyZDlmZTVmMmVmMjdjYzE5Y2VkMjMyZTMxNjhiNzdhMzg=", "commit": {"author": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-07-26T07:43:47Z"}, "committer": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-07-26T11:58:35Z"}, "message": "SSR: Fix for path resolution of locals\n\nIt seems that Semantics::scope, if given a statement node, won't resolve\nlocals that were defined in the current scope, only in parent scopes.\nNot sure if this is intended / expected behavior, but we work around it\nfor now by finding another nearby node to use as the scope (e.g. the\nexpression inside the EXPR_STMT).", "tree": {"sha": "d7dce0768767f683eae0335a5c27e5cdcf4d7312", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7dce0768767f683eae0335a5c27e5cdcf4d7312"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3ca36b2d9fe5f2ef27cc19ced232e3168b77a38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3ca36b2d9fe5f2ef27cc19ced232e3168b77a38", "html_url": "https://github.com/rust-lang/rust/commit/b3ca36b2d9fe5f2ef27cc19ced232e3168b77a38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3ca36b2d9fe5f2ef27cc19ced232e3168b77a38/comments", "author": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb587fae1dc169aca2e587bc7876611852186dd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb587fae1dc169aca2e587bc7876611852186dd5", "html_url": "https://github.com/rust-lang/rust/commit/bb587fae1dc169aca2e587bc7876611852186dd5"}], "stats": {"total": 65, "additions": 65, "deletions": 0}, "files": [{"sha": "123bd2bb24e760f08d8fdbc2eb9ae3f546f29056", "filename": "crates/ra_ssr/src/resolving.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b3ca36b2d9fe5f2ef27cc19ced232e3168b77a38/crates%2Fra_ssr%2Fsrc%2Fresolving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ca36b2d9fe5f2ef27cc19ced232e3168b77a38/crates%2Fra_ssr%2Fsrc%2Fresolving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fresolving.rs?ref=b3ca36b2d9fe5f2ef27cc19ced232e3168b77a38", "patch": "@@ -152,6 +152,7 @@ impl<'db> ResolutionScope<'db> {\n             .left_biased()\n             .map(|token| token.parent())\n             .unwrap_or_else(|| file.syntax().clone());\n+        let node = pick_node_for_resolution(node);\n         let scope = sema.scope(&node);\n         ResolutionScope {\n             scope,\n@@ -185,6 +186,33 @@ impl<'db> ResolutionScope<'db> {\n     }\n }\n \n+/// Returns a suitable node for resolving paths in the current scope. If we create a scope based on\n+/// a statement node, then we can't resolve local variables that were defined in the current scope\n+/// (only in parent scopes). So we find another node, ideally a child of the statement where local\n+/// variable resolution is permitted.\n+fn pick_node_for_resolution(node: SyntaxNode) -> SyntaxNode {\n+    match node.kind() {\n+        SyntaxKind::EXPR_STMT => {\n+            if let Some(n) = node.first_child() {\n+                mark::hit!(cursor_after_semicolon);\n+                return n;\n+            }\n+        }\n+        SyntaxKind::LET_STMT | SyntaxKind::BIND_PAT => {\n+            if let Some(next) = node.next_sibling() {\n+                return pick_node_for_resolution(next);\n+            }\n+        }\n+        SyntaxKind::NAME => {\n+            if let Some(parent) = node.parent() {\n+                return pick_node_for_resolution(parent);\n+            }\n+        }\n+        _ => {}\n+    }\n+    node\n+}\n+\n /// Returns whether `path` or any of its qualifiers contains type arguments.\n fn path_contains_type_arguments(path: Option<ast::Path>) -> bool {\n     if let Some(path) = path {"}, {"sha": "18ef2506afa7714d9085a5f1b66b6515041ded21", "filename": "crates/ra_ssr/src/tests.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b3ca36b2d9fe5f2ef27cc19ced232e3168b77a38/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3ca36b2d9fe5f2ef27cc19ced232e3168b77a38/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Ftests.rs?ref=b3ca36b2d9fe5f2ef27cc19ced232e3168b77a38", "patch": "@@ -885,3 +885,40 @@ fn ufcs_matches_method_call() {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn replace_local_variable_reference() {\n+    // The pattern references a local variable `foo` in the block containing the cursor. We should\n+    // only replace references to this variable `foo`, not other variables that just happen to have\n+    // the same name.\n+    mark::check!(cursor_after_semicolon);\n+    assert_ssr_transform(\n+        \"foo + $a ==>> $a - foo\",\n+        r#\"\n+            fn bar1() -> i32 {\n+                let mut res = 0;\n+                let foo = 5;\n+                res += foo + 1;\n+                let foo = 10;\n+                res += foo + 2;<|>\n+                res += foo + 3;\n+                let foo = 15;\n+                res += foo + 4;\n+                res\n+            }\n+            \"#,\n+        expect![[r#\"\n+            fn bar1() -> i32 {\n+                let mut res = 0;\n+                let foo = 5;\n+                res += foo + 1;\n+                let foo = 10;\n+                res += 2 - foo;\n+                res += 3 - foo;\n+                let foo = 15;\n+                res += foo + 4;\n+                res\n+            }\n+        \"#]],\n+    )\n+}"}]}