{"sha": "01c2761769ab93682afec9101b4896a7253b5251", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxYzI3NjE3NjlhYjkzNjgyYWZlYzkxMDFiNDg5NmE3MjUzYjUyNTE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-02-22T23:28:47Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-02-22T23:50:07Z"}, "message": "Rework typechecking of bind expressions", "tree": {"sha": "f92674e05c49f42089e4fcc065b1f8ca6d0e1ddd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f92674e05c49f42089e4fcc065b1f8ca6d0e1ddd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01c2761769ab93682afec9101b4896a7253b5251", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01c2761769ab93682afec9101b4896a7253b5251", "html_url": "https://github.com/rust-lang/rust/commit/01c2761769ab93682afec9101b4896a7253b5251", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01c2761769ab93682afec9101b4896a7253b5251/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b389611ce772d65ed135d6e52fecb9ca2238e902", "url": "https://api.github.com/repos/rust-lang/rust/commits/b389611ce772d65ed135d6e52fecb9ca2238e902", "html_url": "https://github.com/rust-lang/rust/commit/b389611ce772d65ed135d6e52fecb9ca2238e902"}], "stats": {"total": 65, "additions": 29, "deletions": 36}, "files": [{"sha": "1b39cdf5ea68806389131ed72c1fc905951e6b3c", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 29, "deletions": 36, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/01c2761769ab93682afec9101b4896a7253b5251/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01c2761769ab93682afec9101b4896a7253b5251/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=01c2761769ab93682afec9101b4896a7253b5251", "patch": "@@ -1702,47 +1702,40 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         }\n \n         case (ast.expr_bind(?f, ?args, _)) {\n-            auto f_0 = check_expr(fcx, f);\n-            auto t_0 = expr_ty(f_0);\n-\n-            if (!ty.is_fn_ty(t_0)) {\n-                fcx.ccx.sess.span_err(f_0.span,\n-                                      \"mismatched types: bind callee has \" +\n-                                      \"non-function type: \" +\n-                                      ty_to_str(t_0));\n-            }\n-\n-            let ast.proto proto = ty.ty_fn_proto(t_0);\n-            let vec[arg] arg_tys_0 = ty.ty_fn_args(t_0);\n-            let @ty.t rt_0 = ty.ty_fn_ret(t_0);\n-            let vec[option.t[@ast.expr]] args_1 = vec();\n-\n-            let uint i = 0u;\n-\n-            let vec[arg] residual_args = vec();\n-            for (option.t[@ast.expr] a in args) {\n-                alt (a) {\n-                    case (none[@ast.expr]) {\n-                        append[arg](residual_args,\n-                                    arg_tys_0.(i));\n-                        append[option.t[@ast.expr]](args_1,\n-                                                    none[@ast.expr]);\n-                    }\n-                    case (some[@ast.expr](?sa)) {\n-                        auto arg_1 = check_expr(fcx, sa);\n-                        auto arg_t = expr_ty(arg_1);\n-                        demand_expr(fcx, arg_tys_0.(i).ty, arg_1);\n-                        append[option.t[@ast.expr]](args_1,\n-                                                    some[@ast.expr](arg_1));\n+            // Call the generic checker.\n+            auto result = check_call_or_bind(fcx, f, args);\n+\n+            // Pull the argument and return types out.\n+            auto proto_1 = ast.proto_fn;        // FIXME: typestate botch\n+            let vec[ty.arg] arg_tys_1 = vec();\n+            auto rt_1 = plain_ty(ty.ty_nil);    // FIXME: typestate botch\n+            alt (expr_ty(result._0).struct) {\n+                case (ty.ty_fn(?proto, ?arg_tys, ?rt)) {\n+                    proto_1 = proto;\n+                    rt_1 = rt;\n+\n+                    // For each blank argument, add the type of that argument\n+                    // to the resulting function type.\n+                    auto i = 0u;\n+                    while (i < _vec.len[option.t[@ast.expr]](args)) {\n+                        alt (args.(i)) {\n+                            case (some[@ast.expr](_)) { /* no-op */ }\n+                            case (none[@ast.expr]) {\n+                                arg_tys_1 += vec(arg_tys.(i));\n+                            }\n+                        }\n+                        i += 1u;\n                     }\n                 }\n-                i += 1u;\n+                case (_) {\n+                    log \"LHS of bind expr didn't have a function type?!\";\n+                    fail;\n+                }\n             }\n \n-            let @ty.t t_1 = plain_ty(ty.ty_fn(proto, residual_args, rt_0));\n-\n+            auto t_1 = plain_ty(ty.ty_fn(proto_1, arg_tys_1, rt_1));\n             ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_bind(f_0, args_1,\n+                                        ast.expr_bind(result._0, result._1,\n                                                       ast.ann_type(t_1)));\n         }\n "}]}