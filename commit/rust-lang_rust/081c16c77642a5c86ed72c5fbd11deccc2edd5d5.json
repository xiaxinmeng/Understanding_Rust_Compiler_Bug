{"sha": "081c16c77642a5c86ed72c5fbd11deccc2edd5d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4MWMxNmM3NzY0MmE1Yzg2ZWQ3MmM1ZmJkMTFkZWNjYzJlZGQ1ZDU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-17T12:37:17Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-17T12:37:17Z"}, "message": "initial mod resolve", "tree": {"sha": "90ddf4f92954fcb00f4c20a46968932c5f0bbdea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90ddf4f92954fcb00f4c20a46968932c5f0bbdea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/081c16c77642a5c86ed72c5fbd11deccc2edd5d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/081c16c77642a5c86ed72c5fbd11deccc2edd5d5", "html_url": "https://github.com/rust-lang/rust/commit/081c16c77642a5c86ed72c5fbd11deccc2edd5d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/081c16c77642a5c86ed72c5fbd11deccc2edd5d5/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55e87e0b742b46d40b1a5ef1598804e48e45f0e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/55e87e0b742b46d40b1a5ef1598804e48e45f0e0", "html_url": "https://github.com/rust-lang/rust/commit/55e87e0b742b46d40b1a5ef1598804e48e45f0e0"}], "stats": {"total": 134, "additions": 111, "deletions": 23}, "files": [{"sha": "19b64fece19ff4c50b6e8f41cbebc0dc3727c594", "filename": "crates/libanalysis/src/lib.rs", "status": "modified", "additions": 41, "deletions": 15, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/081c16c77642a5c86ed72c5fbd11deccc2edd5d5/crates%2Flibanalysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081c16c77642a5c86ed72c5fbd11deccc2edd5d5/crates%2Flibanalysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Flib.rs?ref=081c16c77642a5c86ed72c5fbd11deccc2edd5d5", "patch": "@@ -16,7 +16,7 @@ use rayon::prelude::*;\n \n use std::{\n     fmt,\n-    path::Path,\n+    path::{Path, PathBuf},\n     sync::{\n         Arc,\n         atomic::{AtomicUsize, Ordering::SeqCst},\n@@ -26,8 +26,9 @@ use std::{\n };\n \n use libsyntax2::{\n-    TextUnit,\n-    ast::{self, AstNode},\n+    TextUnit, TextRange, SyntaxRoot,\n+    ast::{self, AstNode, NameOwner},\n+    SyntaxKind::*,\n };\n use libeditor::{LineIndex, FileSymbol, find_node};\n \n@@ -119,33 +120,58 @@ impl World {\n         Ok(index.clone())\n     }\n \n-    pub fn world_symbols<'a>(&'a self, mut query: Query) -> impl Iterator<Item=(FileId, &'a FileSymbol)> + 'a {\n+    pub fn world_symbols(&self, mut query: Query) -> Vec<(FileId, FileSymbol)> {\n         self.reindex();\n         self.data.file_map.iter()\n             .flat_map(move |(id, data)| {\n                 let symbols = data.symbols();\n                 query.process(symbols).into_iter().map(move |s| (*id, s))\n             })\n+            .collect()\n     }\n \n-    pub fn approximately_resolve_symbol<'a>(\n-        &'a self,\n+    pub fn approximately_resolve_symbol(\n+        &self,\n         id: FileId,\n         offset: TextUnit,\n-    ) -> Result<Vec<(FileId, &'a FileSymbol)>> {\n+    ) -> Result<Vec<(FileId, FileSymbol)>> {\n         let file = self.file_syntax(id)?;\n-        let syntax = file.syntax();\n-        let syntax = syntax.as_ref();\n-        let name_ref = find_node::<ast::NameRef<_>>(syntax, offset);\n-        let name = match name_ref {\n-            None => return Ok(vec![]),\n-            Some(name_ref) => name_ref.text(),\n-        };\n+        let syntax = file.syntax_ref();\n+        if let Some(name_ref) = find_node::<ast::NameRef<_>>(syntax, offset) {\n+            return Ok(self.index_resolve(name_ref));\n+        }\n+        if let Some(name) = find_node::<ast::Name<_>>(syntax, offset) {\n+            if let Some(module) = name.syntax().parent().and_then(ast::Module::cast) {\n+                if module.has_semi() {\n+                    return Ok(self.resolve_module(id, module));\n+                }\n+            }\n+        }\n+        Ok(vec![])\n+    }\n \n+    fn index_resolve(&self, name_ref: ast::NameRef<&SyntaxRoot>) -> Vec<(FileId, FileSymbol)> {\n+        let name = name_ref.text();\n         let mut query = Query::new(name.to_string());\n         query.exact();\n         query.limit(4);\n-        Ok(self.world_symbols(query).collect())\n+        self.world_symbols(query)\n+    }\n+\n+    fn resolve_module(&self, id: FileId, module: ast::Module<&SyntaxRoot>) -> Vec<(FileId, FileSymbol)> {\n+        let name = match module.name() {\n+            Some(name) => name.text(),\n+            None => return Vec::new(),\n+        };\n+        let id = match self.resolve_relative_path(id, &PathBuf::from(format!(\"../{}.rs\", name))) {\n+            Some(id) => id,\n+            None => return Vec::new(),\n+        };\n+        vec![(id, FileSymbol {\n+            name: name.clone(),\n+            node_range: TextRange::offset_len(0.into(), 0.into()),\n+            kind: MODULE,\n+        })]\n     }\n \n     fn resolve_relative_path(&self, id: FileId, path: &Path) -> Option<FileId> {"}, {"sha": "3c3252956bc82008f5b2dccf6eb21549403012c2", "filename": "crates/libanalysis/src/symbol_index.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/081c16c77642a5c86ed72c5fbd11deccc2edd5d5/crates%2Flibanalysis%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081c16c77642a5c86ed72c5fbd11deccc2edd5d5/crates%2Flibanalysis%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fsymbol_index.rs?ref=081c16c77642a5c86ed72c5fbd11deccc2edd5d5", "patch": "@@ -62,10 +62,10 @@ impl Query {\n         self.limit = limit\n     }\n \n-    pub(crate) fn process<'a>(\n+    pub(crate) fn process(\n         &mut self,\n-        file: &'a FileSymbols,\n-    ) -> Vec<&'a FileSymbol> {\n+        file: &FileSymbols,\n+    ) -> Vec<FileSymbol> {\n         fn is_type(kind: SyntaxKind) -> bool {\n             match kind {\n                 STRUCT_DEF | ENUM_DEF | TRAIT_DEF | TYPE_DEF => true,\n@@ -87,7 +87,7 @@ impl Query {\n             if self.exact && symbol.name != self.query {\n                 continue;\n             }\n-            res.push(symbol);\n+            res.push(symbol.clone());\n             self.limit -= 1;\n         }\n         res"}, {"sha": "ce870430e2807bb7ae2882a9442771bbe92ea2db", "filename": "crates/libeditor/src/symbols.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/081c16c77642a5c86ed72c5fbd11deccc2edd5d5/crates%2Flibeditor%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081c16c77642a5c86ed72c5fbd11deccc2edd5d5/crates%2Flibeditor%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Fsymbols.rs?ref=081c16c77642a5c86ed72c5fbd11deccc2edd5d5", "patch": "@@ -9,7 +9,7 @@ use libsyntax2::{\n };\n use TextRange;\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub struct StructureNode {\n     pub parent: Option<usize>,\n     pub label: String,\n@@ -18,7 +18,7 @@ pub struct StructureNode {\n     pub kind: SyntaxKind,\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub struct FileSymbol {\n     pub name: SmolStr,\n     pub node_range: TextRange,"}, {"sha": "9b9200f99643dd35f06983c9b96210f42b2f00c8", "filename": "crates/libsyntax2/src/ast/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/081c16c77642a5c86ed72c5fbd11deccc2edd5d5/crates%2Flibsyntax2%2Fsrc%2Fast%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081c16c77642a5c86ed72c5fbd11deccc2edd5d5/crates%2Flibsyntax2%2Fsrc%2Fast%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fast%2Fmod.rs?ref=081c16c77642a5c86ed72c5fbd11deccc2edd5d5", "patch": "@@ -118,3 +118,12 @@ impl <R: TreeRoot> ImplItem<R> {\n         (first, second)\n     }\n }\n+\n+impl <R: TreeRoot> Module<R> {\n+    pub fn has_semi(&self) -> bool {\n+        match self.syntax_ref().last_child() {\n+            None => false,\n+            Some(node) => node.kind() == SEMI,\n+        }\n+    }\n+}"}, {"sha": "bb390751a2e835df94f90b136ec7a4ea9f3217ab", "filename": "crates/libsyntax2/src/yellow/syntax.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/081c16c77642a5c86ed72c5fbd11deccc2edd5d5/crates%2Flibsyntax2%2Fsrc%2Fyellow%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081c16c77642a5c86ed72c5fbd11deccc2edd5d5/crates%2Flibsyntax2%2Fsrc%2Fyellow%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fyellow%2Fsyntax.rs?ref=081c16c77642a5c86ed72c5fbd11deccc2edd5d5", "patch": "@@ -89,7 +89,15 @@ impl<R: TreeRoot> SyntaxNode<R> {\n     }\n \n     pub fn first_child(&self) -> Option<SyntaxNode<R>> {\n-        self.children().next()\n+        let red = self.red().get_child(0)?;\n+        Some(SyntaxNode { root: self.root.clone(), red })\n+    }\n+\n+    pub fn last_child(&self) -> Option<SyntaxNode<R>> {\n+        let n = self.red().n_children();\n+        let n = n.checked_sub(1)?;\n+        let red = self.red().get_child(n)?;\n+        Some(SyntaxNode { root: self.root.clone(), red })\n     }\n \n     pub fn next_sibling(&self) -> Option<SyntaxNode<R>> {"}, {"sha": "d2b811a3ba692599f1d35b772f952ca94e8d96fe", "filename": "crates/server/src/path_map.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/081c16c77642a5c86ed72c5fbd11deccc2edd5d5/crates%2Fserver%2Fsrc%2Fpath_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081c16c77642a5c86ed72c5fbd11deccc2edd5d5/crates%2Fserver%2Fsrc%2Fpath_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fpath_map.rs?ref=081c16c77642a5c86ed72c5fbd11deccc2edd5d5", "patch": "@@ -1,4 +1,4 @@\n-use std::path::{PathBuf, Path};\n+use std::path::{PathBuf, Path, Component};\n use im;\n use libanalysis::{FileId};\n \n@@ -36,6 +36,7 @@ impl PathMap {\n \n     pub fn resolve(&self, id: FileId, relpath: &Path) -> Option<FileId> {\n         let path = self.get_path(id).join(relpath);\n+        let path = normalize(&path);\n         self.get_id(&path)\n     }\n \n@@ -50,3 +51,47 @@ impl PathMap {\n         id\n     }\n }\n+\n+fn normalize(path: &Path) -> PathBuf {\n+    let mut components = path.components().peekable();\n+    let mut ret = if let Some(c @ Component::Prefix(..)) = components.peek().cloned() {\n+        components.next();\n+        PathBuf::from(c.as_os_str())\n+    } else {\n+        PathBuf::new()\n+    };\n+\n+    for component in components {\n+        match component {\n+            Component::Prefix(..) => unreachable!(),\n+            Component::RootDir => {\n+                ret.push(component.as_os_str());\n+            }\n+            Component::CurDir => {}\n+            Component::ParentDir => {\n+                ret.pop();\n+            }\n+            Component::Normal(c) => {\n+                ret.push(c);\n+            }\n+        }\n+    }\n+    ret\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    #[test]\n+    fn test_resolve() {\n+        let mut m = PathMap::new();\n+        let id1 = m.get_or_insert(PathBuf::from(\"/foo\"));\n+        let id2 = m.get_or_insert(PathBuf::from(\"/foo/bar.rs\"));\n+        assert_eq!(\n+            m.resolve(id1, &PathBuf::from(\"bar.rs\")),\n+            Some(id2),\n+        )\n+    }\n+}\n+"}]}