{"sha": "ec8477fea1989bb187ec026b2dad3e4b89d60e91", "node_id": "C_kwDOAAsO6NoAKGVjODQ3N2ZlYTE5ODliYjE4N2VjMDI2YjJkYWQzZTRiODlkNjBlOTE", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-06-28T10:00:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-28T10:00:02Z"}, "message": "Rollup merge of #98337 - c410-f3r:assert-compiler, r=oli-obk\n\n[RFC 2011] Optimize non-consuming operators\n\nTracking issue: https://github.com/rust-lang/rust/issues/44838\nFifth step of https://github.com/rust-lang/rust/pull/96496\n\nThe most non-invasive approach that will probably have very little to no performance impact.\n\n## Current behaviour\n\nCaptures are handled \"on-the-fly\", i.e., they are performed in the same place expressions are located.\n\n```rust\n// `let a = 1; let b = 2; assert!(a > 1 && b < 100);`\n\nif !(\n  { ***try capture `a` and then return `a`*** } > 1 && { ***try capture `b` and then return `b`*** } < 100\n) {\n  panic!( ... );\n}\n```\n\nAs such, some overhead is likely to occur (Specially with very large chains of conditions).\n\n## New behaviour for non-consuming operators\n\nWhen an operator is known to not take `self`, then it is possible to capture variables **AFTER** the condition.\n\n```rust\n// `let a = 1; let b = 2; assert!(a > 1 && b < 100);`\n\nif !( a > 1 && b < 100 ) {\n  { ***try capture `a`*** }\n  { ***try capture `b`*** }\n  panic!( ... );\n}\n```\n\nSo the possible impact on the runtime execution time will be diminished.\n\nr? ````@oli-obk````", "tree": {"sha": "9570e2eae5c4947563dfad2ab41a39743755f052", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9570e2eae5c4947563dfad2ab41a39743755f052"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec8477fea1989bb187ec026b2dad3e4b89d60e91", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiutEiCRBK7hj4Ov3rIwAAK3gIAIIOdxbC0WyW1Gz73kfHNE9E\nS22m43tqdWU6LzEdZxu+E+THLgkqdvc3c6S3vqyiQFPNsWmg79KYZrMuDMPjpeLs\nsFdZk5aYgOOjglThFKN9BYEdGTLRKjhzPxzAfi5jYpvG5S1Yh8sE4nwDe0c+2GSy\nY+9rsxbZyQxlIQ/NMVgt/ZPah2PpqTSza4Nn459aWhKn02AUxoCnyRxKnA2xqZam\nU1yFgMFaxi9tn7wENFADR0qd/3f2QFrtTPvAfMwaeVAyiZ5hjZVwcBLbZK2upp7s\nSOJP0jHcwHnm4dJ1iCpSx21WtCnBqe1AW6D6kv13U8szDz0UtlFNO7HmU3MEVzY=\n=vfR8\n-----END PGP SIGNATURE-----\n", "payload": "tree 9570e2eae5c4947563dfad2ab41a39743755f052\nparent 9b3dbb8200154d3432c6ba4c4094f96102494330\nparent a0eba6634f1430e29637257fd1416f896bcf9edc\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1656410402 +0530\ncommitter GitHub <noreply@github.com> 1656410402 +0530\n\nRollup merge of #98337 - c410-f3r:assert-compiler, r=oli-obk\n\n[RFC 2011] Optimize non-consuming operators\n\nTracking issue: https://github.com/rust-lang/rust/issues/44838\nFifth step of https://github.com/rust-lang/rust/pull/96496\n\nThe most non-invasive approach that will probably have very little to no performance impact.\n\n## Current behaviour\n\nCaptures are handled \"on-the-fly\", i.e., they are performed in the same place expressions are located.\n\n```rust\n// `let a = 1; let b = 2; assert!(a > 1 && b < 100);`\n\nif !(\n  { ***try capture `a` and then return `a`*** } > 1 && { ***try capture `b` and then return `b`*** } < 100\n) {\n  panic!( ... );\n}\n```\n\nAs such, some overhead is likely to occur (Specially with very large chains of conditions).\n\n## New behaviour for non-consuming operators\n\nWhen an operator is known to not take `self`, then it is possible to capture variables **AFTER** the condition.\n\n```rust\n// `let a = 1; let b = 2; assert!(a > 1 && b < 100);`\n\nif !( a > 1 && b < 100 ) {\n  { ***try capture `a`*** }\n  { ***try capture `b`*** }\n  panic!( ... );\n}\n```\n\nSo the possible impact on the runtime execution time will be diminished.\n\nr? ````@oli-obk````\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec8477fea1989bb187ec026b2dad3e4b89d60e91", "html_url": "https://github.com/rust-lang/rust/commit/ec8477fea1989bb187ec026b2dad3e4b89d60e91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec8477fea1989bb187ec026b2dad3e4b89d60e91/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b3dbb8200154d3432c6ba4c4094f96102494330", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b3dbb8200154d3432c6ba4c4094f96102494330", "html_url": "https://github.com/rust-lang/rust/commit/9b3dbb8200154d3432c6ba4c4094f96102494330"}, {"sha": "a0eba6634f1430e29637257fd1416f896bcf9edc", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0eba6634f1430e29637257fd1416f896bcf9edc", "html_url": "https://github.com/rust-lang/rust/commit/a0eba6634f1430e29637257fd1416f896bcf9edc"}], "stats": {"total": 313, "additions": 260, "deletions": 53}, "files": [{"sha": "9e50d33486cf2f51dca7e3c8d9ceafdc6f81d5de", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 81, "deletions": 15, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/ec8477fea1989bb187ec026b2dad3e4b89d60e91/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec8477fea1989bb187ec026b2dad3e4b89d60e91/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=ec8477fea1989bb187ec026b2dad3e4b89d60e91", "patch": "@@ -1,11 +1,10 @@\n-use crate::assert::expr_if_not;\n use rustc_ast::{\n     attr,\n     ptr::P,\n     token,\n     tokenstream::{DelimSpan, TokenStream, TokenTree},\n-    BorrowKind, Expr, ExprKind, ItemKind, MacArgs, MacCall, MacDelimiter, Mutability, Path,\n-    PathSegment, Stmt, StructRest, UseTree, UseTreeKind, DUMMY_NODE_ID,\n+    BinOpKind, BorrowKind, Expr, ExprKind, ItemKind, MacArgs, MacCall, MacDelimiter, Mutability,\n+    Path, PathSegment, Stmt, StructRest, UnOp, UseTree, UseTreeKind, DUMMY_NODE_ID,\n };\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n@@ -16,11 +15,19 @@ use rustc_span::{\n };\n \n pub(super) struct Context<'cx, 'a> {\n+    // An optimization.\n+    //\n+    // Elements that aren't consumed (PartialEq, PartialOrd, ...) can be copied **after** the\n+    // `assert!` expression fails rather than copied on-the-fly.\n+    best_case_captures: Vec<Stmt>,\n     // Top-level `let captureN = Capture::new()` statements\n     capture_decls: Vec<Capture>,\n     cx: &'cx ExtCtxt<'a>,\n     // Formatting string used for debugging\n     fmt_string: String,\n+    // If the current expression being visited consumes itself. Used to construct\n+    // `best_case_captures`.\n+    is_consumed: bool,\n     // Top-level `let __local_bindN = &expr` statements\n     local_bind_decls: Vec<Stmt>,\n     // Used to avoid capturing duplicated paths\n@@ -36,9 +43,11 @@ pub(super) struct Context<'cx, 'a> {\n impl<'cx, 'a> Context<'cx, 'a> {\n     pub(super) fn new(cx: &'cx ExtCtxt<'a>, span: Span) -> Self {\n         Self {\n+            best_case_captures: <_>::default(),\n             capture_decls: <_>::default(),\n             cx,\n             fmt_string: <_>::default(),\n+            is_consumed: true,\n             local_bind_decls: <_>::default(),\n             paths: <_>::default(),\n             span,\n@@ -69,14 +78,22 @@ impl<'cx, 'a> Context<'cx, 'a> {\n         self.manage_cond_expr(&mut cond_expr);\n         let initial_imports = self.build_initial_imports();\n         let panic = self.build_panic(&expr_str, panic_path);\n+        let cond_expr_with_unlikely = self.build_unlikely(cond_expr);\n+\n+        let Self { best_case_captures, capture_decls, cx, local_bind_decls, span, .. } = self;\n \n-        let Self { capture_decls, cx, local_bind_decls, span, .. } = self;\n+        let mut assert_then_stmts = Vec::with_capacity(2);\n+        assert_then_stmts.extend(best_case_captures);\n+        assert_then_stmts.push(self.cx.stmt_expr(panic));\n+        let assert_then = self.cx.block(span, assert_then_stmts);\n \n         let mut stmts = Vec::with_capacity(4);\n         stmts.push(initial_imports);\n         stmts.extend(capture_decls.into_iter().map(|c| c.decl));\n         stmts.extend(local_bind_decls);\n-        stmts.push(cx.stmt_expr(expr_if_not(cx, span, cond_expr, panic, None)));\n+        stmts.push(\n+            cx.stmt_expr(cx.expr(span, ExprKind::If(cond_expr_with_unlikely, assert_then, None))),\n+        );\n         cx.expr_block(cx.block(span, stmts))\n     }\n \n@@ -115,6 +132,16 @@ impl<'cx, 'a> Context<'cx, 'a> {\n         )\n     }\n \n+    /// Takes the conditional expression of `assert!` and then wraps it inside `unlikely`\n+    fn build_unlikely(&self, cond_expr: P<Expr>) -> P<Expr> {\n+        let unlikely_path = self.cx.std_path(&[sym::intrinsics, sym::unlikely]);\n+        self.cx.expr_call(\n+            self.span,\n+            self.cx.expr_path(self.cx.path(self.span, unlikely_path)),\n+            vec![self.cx.expr(self.span, ExprKind::Unary(UnOp::Not, cond_expr))],\n+        )\n+    }\n+\n     /// The necessary custom `panic!(...)` expression.\n     ///\n     /// panic!(\n@@ -167,17 +194,39 @@ impl<'cx, 'a> Context<'cx, 'a> {\n     /// See [Self::manage_initial_capture] and [Self::manage_try_capture]\n     fn manage_cond_expr(&mut self, expr: &mut P<Expr>) {\n         match (*expr).kind {\n-            ExprKind::AddrOf(_, _, ref mut local_expr) => {\n-                self.manage_cond_expr(local_expr);\n+            ExprKind::AddrOf(_, mutability, ref mut local_expr) => {\n+                self.with_is_consumed_management(\n+                    matches!(mutability, Mutability::Mut),\n+                    |this| this.manage_cond_expr(local_expr)\n+                );\n             }\n             ExprKind::Array(ref mut local_exprs) => {\n                 for local_expr in local_exprs {\n                     self.manage_cond_expr(local_expr);\n                 }\n             }\n-            ExprKind::Binary(_, ref mut lhs, ref mut rhs) => {\n-                self.manage_cond_expr(lhs);\n-                self.manage_cond_expr(rhs);\n+            ExprKind::Binary(ref op, ref mut lhs, ref mut rhs) => {\n+                self.with_is_consumed_management(\n+                    matches!(\n+                        op.node,\n+                        BinOpKind::Add\n+                            | BinOpKind::And\n+                            | BinOpKind::BitAnd\n+                            | BinOpKind::BitOr\n+                            | BinOpKind::BitXor\n+                            | BinOpKind::Div\n+                            | BinOpKind::Mul\n+                            | BinOpKind::Or\n+                            | BinOpKind::Rem\n+                            | BinOpKind::Shl\n+                            | BinOpKind::Shr\n+                            | BinOpKind::Sub\n+                    ),\n+                    |this| {\n+                        this.manage_cond_expr(lhs);\n+                        this.manage_cond_expr(rhs);\n+                    }\n+                );\n             }\n             ExprKind::Call(_, ref mut local_exprs) => {\n                 for local_expr in local_exprs {\n@@ -228,8 +277,11 @@ impl<'cx, 'a> Context<'cx, 'a> {\n                     self.manage_cond_expr(local_expr);\n                 }\n             }\n-            ExprKind::Unary(_, ref mut local_expr) => {\n-                self.manage_cond_expr(local_expr);\n+            ExprKind::Unary(un_op, ref mut local_expr) => {\n+                self.with_is_consumed_management(\n+                    matches!(un_op, UnOp::Neg | UnOp::Not),\n+                    |this| this.manage_cond_expr(local_expr)\n+                );\n             }\n             // Expressions that are not worth or can not be captured.\n             //\n@@ -337,9 +389,23 @@ impl<'cx, 'a> Context<'cx, 'a> {\n             ))\n             .add_trailing_semicolon();\n         let local_bind_path = self.cx.expr_path(Path::from_ident(local_bind));\n-        let ret = self.cx.stmt_expr(local_bind_path);\n-        let block = self.cx.expr_block(self.cx.block(self.span, vec![try_capture_call, ret]));\n-        *expr = self.cx.expr_deref(self.span, block);\n+        let rslt = if self.is_consumed {\n+            let ret = self.cx.stmt_expr(local_bind_path);\n+            self.cx.expr_block(self.cx.block(self.span, vec![try_capture_call, ret]))\n+        } else {\n+            self.best_case_captures.push(try_capture_call);\n+            local_bind_path\n+        };\n+        *expr = self.cx.expr_deref(self.span, rslt);\n+    }\n+\n+    // Calls `f` with the internal `is_consumed` set to `curr_is_consumed` and then\n+    // sets the internal `is_consumed` back to its original value.\n+    fn with_is_consumed_management(&mut self, curr_is_consumed: bool, f: impl FnOnce(&mut Self)) {\n+        let prev_is_consumed = self.is_consumed;\n+        self.is_consumed = curr_is_consumed;\n+        f(self);\n+        self.is_consumed = prev_is_consumed;\n     }\n }\n "}, {"sha": "1db9d33c72aeea1cf4c36ff2eba323f3a254805f", "filename": "src/test/ui/macros/rfc-2011-nicer-assert-messages/codegen.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9b3dbb8200154d3432c6ba4c4094f96102494330/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b3dbb8200154d3432c6ba4c4094f96102494330/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fcodegen.rs?ref=9b3dbb8200154d3432c6ba4c4094f96102494330", "patch": "@@ -1,9 +0,0 @@\n-// check-pass\n-// compile-flags: -Z unpretty=expanded\n-\n-#![feature(core_intrinsics, generic_assert, generic_assert_internals)]\n-\n-fn main() {\n-    let elem = 1i32;\n-    assert!(elem == 1);\n-}"}, {"sha": "a590eb3223254be489a166eabbf58545857b2e8c", "filename": "src/test/ui/macros/rfc-2011-nicer-assert-messages/codegen.stdout", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9b3dbb8200154d3432c6ba4c4094f96102494330/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fcodegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/9b3dbb8200154d3432c6ba4c4094f96102494330/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fcodegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fcodegen.stdout?ref=9b3dbb8200154d3432c6ba4c4094f96102494330", "patch": "@@ -1,29 +0,0 @@\n-#![feature(prelude_import)]\n-#![no_std]\n-// check-pass\n-// compile-flags: -Z unpretty=expanded\n-\n-#![feature(core_intrinsics, generic_assert, generic_assert_internals)]\n-#[prelude_import]\n-use ::std::prelude::rust_2015::*;\n-#[macro_use]\n-extern crate std;\n-\n-fn main() {\n-    let elem = 1i32;\n-    {\n-        #[allow(unused_imports)]\n-        use ::core::asserting::{TryCaptureGeneric, TryCapturePrintable};\n-        let mut __capture0 = ::core::asserting::Capture::new();\n-        let __local_bind0 = &elem;\n-        if !(*{\n-                                (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n-                                __local_bind0\n-                            } == 1) {\n-                {\n-                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: elem == 1\\nWith captures:\\n  elem = \",\n-                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n-                }\n-            }\n-    };\n-}"}, {"sha": "5ec84b08ff80809d4c5d0ab98379bfaa1ae71c96", "filename": "src/test/ui/macros/rfc-2011-nicer-assert-messages/non-consuming-methods-have-optimized-codegen.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ec8477fea1989bb187ec026b2dad3e4b89d60e91/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fnon-consuming-methods-have-optimized-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec8477fea1989bb187ec026b2dad3e4b89d60e91/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fnon-consuming-methods-have-optimized-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fnon-consuming-methods-have-optimized-codegen.rs?ref=ec8477fea1989bb187ec026b2dad3e4b89d60e91", "patch": "@@ -0,0 +1,32 @@\n+// check-pass\n+// compile-flags: -Z unpretty=expanded\n+\n+#![feature(core_intrinsics, generic_assert, generic_assert_internals)]\n+\n+fn arbitrary_consuming_method_for_demonstration_purposes() {\n+    let elem = 1i32;\n+    assert!(elem as usize);\n+}\n+\n+fn addr_of() {\n+    let elem = 1i32;\n+    assert!(&elem);\n+}\n+\n+fn binary() {\n+    let elem = 1i32;\n+    assert!(elem == 1);\n+    assert!(elem >= 1);\n+    assert!(elem > 0);\n+    assert!(elem < 3);\n+    assert!(elem <= 3);\n+    assert!(elem != 3);\n+}\n+\n+fn unary() {\n+    let elem = &1i32;\n+    assert!(*elem);\n+}\n+\n+fn main() {\n+}"}, {"sha": "90f858f80e6b5ffe340dcf0aa222b962d56b32e1", "filename": "src/test/ui/macros/rfc-2011-nicer-assert-messages/non-consuming-methods-have-optimized-codegen.stdout", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/ec8477fea1989bb187ec026b2dad3e4b89d60e91/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fnon-consuming-methods-have-optimized-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/ec8477fea1989bb187ec026b2dad3e4b89d60e91/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fnon-consuming-methods-have-optimized-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frfc-2011-nicer-assert-messages%2Fnon-consuming-methods-have-optimized-codegen.stdout?ref=ec8477fea1989bb187ec026b2dad3e4b89d60e91", "patch": "@@ -0,0 +1,147 @@\n+#![feature(prelude_import)]\n+#![no_std]\n+// check-pass\n+// compile-flags: -Z unpretty=expanded\n+\n+#![feature(core_intrinsics, generic_assert, generic_assert_internals)]\n+#[prelude_import]\n+use ::std::prelude::rust_2015::*;\n+#[macro_use]\n+extern crate std;\n+\n+fn arbitrary_consuming_method_for_demonstration_purposes() {\n+    let elem = 1i32;\n+    {\n+        #[allow(unused_imports)]\n+        use ::core::asserting::{TryCaptureGeneric, TryCapturePrintable};\n+        let mut __capture0 = ::core::asserting::Capture::new();\n+        let __local_bind0 = &elem;\n+        if ::core::intrinsics::unlikely(!(*{\n+                                    (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n+                                    __local_bind0\n+                                } as usize)) {\n+\n+\n+\n+\n+                {\n+                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: elem as usize\\nWith captures:\\n  elem = \",\n+                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                }\n+            }\n+    };\n+}\n+fn addr_of() {\n+    let elem = 1i32;\n+    {\n+        #[allow(unused_imports)]\n+        use ::core::asserting::{TryCaptureGeneric, TryCapturePrintable};\n+        let mut __capture0 = ::core::asserting::Capture::new();\n+        let __local_bind0 = &elem;\n+        if ::core::intrinsics::unlikely(!&*__local_bind0) {\n+                (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n+                {\n+                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: &elem\\nWith captures:\\n  elem = \",\n+                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                }\n+            }\n+    };\n+}\n+fn binary() {\n+    let elem = 1i32;\n+    {\n+        #[allow(unused_imports)]\n+        use ::core::asserting::{TryCaptureGeneric, TryCapturePrintable};\n+        let mut __capture0 = ::core::asserting::Capture::new();\n+        let __local_bind0 = &elem;\n+        if ::core::intrinsics::unlikely(!(*__local_bind0 == 1)) {\n+                (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n+                {\n+                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: elem == 1\\nWith captures:\\n  elem = \",\n+                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                }\n+            }\n+    };\n+    {\n+        #[allow(unused_imports)]\n+        use ::core::asserting::{TryCaptureGeneric, TryCapturePrintable};\n+        let mut __capture0 = ::core::asserting::Capture::new();\n+        let __local_bind0 = &elem;\n+        if ::core::intrinsics::unlikely(!(*__local_bind0 >= 1)) {\n+                (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n+                {\n+                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: elem >= 1\\nWith captures:\\n  elem = \",\n+                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                }\n+            }\n+    };\n+    {\n+        #[allow(unused_imports)]\n+        use ::core::asserting::{TryCaptureGeneric, TryCapturePrintable};\n+        let mut __capture0 = ::core::asserting::Capture::new();\n+        let __local_bind0 = &elem;\n+        if ::core::intrinsics::unlikely(!(*__local_bind0 > 0)) {\n+                (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n+                {\n+                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: elem > 0\\nWith captures:\\n  elem = \",\n+                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                }\n+            }\n+    };\n+    {\n+        #[allow(unused_imports)]\n+        use ::core::asserting::{TryCaptureGeneric, TryCapturePrintable};\n+        let mut __capture0 = ::core::asserting::Capture::new();\n+        let __local_bind0 = &elem;\n+        if ::core::intrinsics::unlikely(!(*__local_bind0 < 3)) {\n+                (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n+                {\n+                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: elem < 3\\nWith captures:\\n  elem = \",\n+                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                }\n+            }\n+    };\n+    {\n+        #[allow(unused_imports)]\n+        use ::core::asserting::{TryCaptureGeneric, TryCapturePrintable};\n+        let mut __capture0 = ::core::asserting::Capture::new();\n+        let __local_bind0 = &elem;\n+        if ::core::intrinsics::unlikely(!(*__local_bind0 <= 3)) {\n+                (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n+                {\n+                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: elem <= 3\\nWith captures:\\n  elem = \",\n+                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                }\n+            }\n+    };\n+    {\n+        #[allow(unused_imports)]\n+        use ::core::asserting::{TryCaptureGeneric, TryCapturePrintable};\n+        let mut __capture0 = ::core::asserting::Capture::new();\n+        let __local_bind0 = &elem;\n+        if ::core::intrinsics::unlikely(!(*__local_bind0 != 3)) {\n+                (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n+                {\n+                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: elem != 3\\nWith captures:\\n  elem = \",\n+                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                }\n+            }\n+    };\n+}\n+fn unary() {\n+    let elem = &1i32;\n+    {\n+        #[allow(unused_imports)]\n+        use ::core::asserting::{TryCaptureGeneric, TryCapturePrintable};\n+        let mut __capture0 = ::core::asserting::Capture::new();\n+        let __local_bind0 = &elem;\n+        if ::core::intrinsics::unlikely(!**__local_bind0) {\n+                (&::core::asserting::Wrapper(__local_bind0)).try_capture(&mut __capture0);\n+                {\n+                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(&[\"Assertion failed: *elem\\nWith captures:\\n  elem = \",\n+                                        \"\\n\"], &[::core::fmt::ArgumentV1::new_debug(&__capture0)]))\n+                }\n+            }\n+    };\n+}\n+fn main() {}"}]}