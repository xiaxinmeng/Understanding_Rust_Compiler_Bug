{"sha": "e753618b6b9cbf41434fa566d1d3c7d15c86c4f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3NTM2MThiNmI5Y2JmNDE0MzRmYTU2NmQxZDNjN2QxNWM4NmM0Zjc=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-09-21T05:01:01Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-09-21T05:02:56Z"}, "message": "drop `extra::par`\n\nThis was a dead end experiment, and not a sensible way of implementing\ngeneric data parallelism. This also removes the `graph500-bfs.rs`\nbenchmark because it relies on `extra::par`.\n\nCloses #5626", "tree": {"sha": "162aa24f4afab8e299f9c2cfe04fa302b9caf426", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/162aa24f4afab8e299f9c2cfe04fa302b9caf426"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e753618b6b9cbf41434fa566d1d3c7d15c86c4f7", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e753618b6b9cbf41434fa566d1d3c7d15c86c4f7", "html_url": "https://github.com/rust-lang/rust/commit/e753618b6b9cbf41434fa566d1d3c7d15c86c4f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e753618b6b9cbf41434fa566d1d3c7d15c86c4f7/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e268c7fcc58593d71962a49a147c21edfa702f20", "url": "https://api.github.com/repos/rust-lang/rust/commits/e268c7fcc58593d71962a49a147c21edfa702f20", "html_url": "https://github.com/rust-lang/rust/commit/e268c7fcc58593d71962a49a147c21edfa702f20"}], "stats": {"total": 661, "additions": 0, "deletions": 661}, "files": [{"sha": "6f893f28bd1f1fceac3d8e5e7ce3fc8451f67e9d", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e753618b6b9cbf41434fa566d1d3c7d15c86c4f7/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e753618b6b9cbf41434fa566d1d3c7d15c86c4f7/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=e753618b6b9cbf41434fa566d1d3c7d15c86c4f7", "patch": "@@ -89,7 +89,6 @@ pub mod glob;\n pub mod term;\n pub mod time;\n pub mod arena;\n-pub mod par;\n pub mod base64;\n pub mod rl;\n pub mod workcache;"}, {"sha": "b5514315226966b71614fd53b078474595e8e9aa", "filename": "src/libextra/par.rs", "status": "removed", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/e268c7fcc58593d71962a49a147c21edfa702f20/src%2Flibextra%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e268c7fcc58593d71962a49a147c21edfa702f20/src%2Flibextra%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpar.rs?ref=e268c7fcc58593d71962a49a147c21edfa702f20", "patch": "@@ -1,142 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-use std::cast;\n-use std::num;\n-use std::ptr;\n-use std::sys;\n-use std::vec;\n-use future::Future;\n-\n-/**\n- * The maximum number of tasks this module will spawn for a single\n- * operation.\n- */\n-static MAX_TASKS : uint = 32u;\n-\n-/// The minimum number of elements each task will process.\n-static MIN_GRANULARITY : uint = 1024u;\n-\n-/**\n- * An internal helper to map a function over a large vector and\n- * return the intermediate results.\n- *\n- * This is used to build most of the other parallel vector functions,\n- * like map or alli.\n- */\n-fn map_slices<A:Clone + Send,B:Clone + Send>(\n-    xs: &[A],\n-    f: &fn() -> ~fn(uint, v: &[A]) -> B)\n-    -> ~[B] {\n-\n-    let len = xs.len();\n-    if len < MIN_GRANULARITY {\n-        info!(\"small slice\");\n-        // This is a small vector, fall back on the normal map.\n-        ~[f()(0u, xs)]\n-    } else {\n-        let num_tasks = num::min(MAX_TASKS, len / MIN_GRANULARITY);\n-\n-        let items_per_task = len / num_tasks;\n-\n-        let mut futures = ~[];\n-        let mut base = 0u;\n-        info!(\"spawning tasks\");\n-        while base < len {\n-            let end = num::min(len, base + items_per_task);\n-            do xs.as_imm_buf |p, _len| {\n-                let f = f();\n-                let base = base;\n-                let f = do Future::spawn() || {\n-                    unsafe {\n-                        let len = end - base;\n-                        let slice = (ptr::offset(p, base as int),\n-                                     len * sys::size_of::<A>());\n-                        info!(\"pre-slice: %?\", (base, slice));\n-                        let slice : &[A] =\n-                            cast::transmute(slice);\n-                        info!(\"slice: %?\", (base, slice.len(), end - base));\n-                        assert_eq!(slice.len(), end - base);\n-                        f(base, slice)\n-                    }\n-                };\n-                futures.push(f);\n-            };\n-            base += items_per_task;\n-        }\n-        info!(\"tasks spawned\");\n-\n-        info!(\"num_tasks: %?\", (num_tasks, futures.len()));\n-        assert_eq!(num_tasks, futures.len());\n-\n-        do futures.move_iter().map |ys| {\n-            let mut ys = ys;\n-            ys.get()\n-        }.collect()\n-    }\n-}\n-\n-/// A parallel version of map.\n-pub fn map<A:Clone + Send,B:Clone + Send>(\n-    xs: &[A], fn_factory: &fn() -> ~fn(&A) -> B) -> ~[B] {\n-    vec::concat(map_slices(xs, || {\n-        let f = fn_factory();\n-        let result: ~fn(uint, &[A]) -> ~[B] =\n-            |_, slice| slice.iter().map(|x| f(x)).collect();\n-        result\n-    }))\n-}\n-\n-/// A parallel version of mapi.\n-pub fn mapi<A:Clone + Send,B:Clone + Send>(\n-        xs: &[A],\n-        fn_factory: &fn() -> ~fn(uint, &A) -> B) -> ~[B] {\n-    let slices = map_slices(xs, || {\n-        let f = fn_factory();\n-        let result: ~fn(uint, &[A]) -> ~[B] = |base, slice| {\n-            slice.iter().enumerate().map(|(i, x)| {\n-                f(i + base, x)\n-            }).collect()\n-        };\n-        result\n-    });\n-    let r = vec::concat(slices);\n-    info!(\"%?\", (r.len(), xs.len()));\n-    assert_eq!(r.len(), xs.len());\n-    r\n-}\n-\n-/// Returns true if the function holds for all elements in the vector.\n-pub fn alli<A:Clone + Send>(\n-    xs: &[A],\n-    fn_factory: &fn() -> ~fn(uint, &A) -> bool) -> bool\n-{\n-    let mapped = map_slices(xs, || {\n-        let f = fn_factory();\n-        let result: ~fn(uint, &[A]) -> bool = |base, slice| {\n-            slice.iter().enumerate().all(|(i, x)| f(i + base, x))\n-        };\n-        result\n-    });\n-    mapped.iter().all(|&x| x)\n-}\n-\n-/// Returns true if the function holds for any elements in the vector.\n-pub fn any<A:Clone + Send>(\n-    xs: &[A],\n-    fn_factory: &fn() -> ~fn(&A) -> bool) -> bool {\n-    let mapped = map_slices(xs, || {\n-        let f = fn_factory();\n-        let result: ~fn(uint, &[A]) -> bool = |_, slice| slice.iter().any(f);\n-        result\n-    });\n-    mapped.iter().any(|&x| x)\n-}"}, {"sha": "ff66fd121d98cb899c4d5ad3acf758ddb20e5b12", "filename": "src/test/bench/graph500-bfs.rs", "status": "removed", "additions": 0, "deletions": 518, "changes": 518, "blob_url": "https://github.com/rust-lang/rust/blob/e268c7fcc58593d71962a49a147c21edfa702f20/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e268c7fcc58593d71962a49a147c21edfa702f20/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=e268c7fcc58593d71962a49a147c21edfa702f20", "patch": "@@ -1,518 +0,0 @@\n-// xfail-pretty\n-\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-An implementation of the Graph500 Breadth First Search problem in Rust.\n-\n-*/\n-\n-extern mod extra;\n-use extra::arc;\n-use extra::time;\n-use extra::ringbuf::RingBuf;\n-use extra::container::Deque;\n-use extra::par;\n-use std::hashmap::HashSet;\n-use std::num::abs;\n-use std::io;\n-use std::os;\n-use std::rand::RngUtil;\n-use std::rand;\n-use std::uint;\n-use std::vec;\n-\n-type node_id = i64;\n-type graph = ~[~[node_id]];\n-type bfs_result = ~[node_id];\n-\n-fn make_edges(scale: uint, edgefactor: uint) -> ~[(node_id, node_id)] {\n-    let mut r = rand::XorShiftRng::new();\n-\n-    fn choose_edge<R: rand::Rng>(i: node_id,\n-                                 j: node_id,\n-                                 scale: uint,\n-                                 r: &mut R)\n-                                 -> (node_id, node_id) {\n-        let A = 0.57;\n-        let B = 0.19;\n-        let C = 0.19;\n-\n-        if scale == 0u {\n-            (i, j)\n-        } else {\n-            let i = i * 2i64;\n-            let j = j * 2i64;\n-            let scale = scale - 1u;\n-\n-            let x = r.gen::<float>();\n-\n-            if x < A {\n-                choose_edge(i, j, scale, r)\n-            }\n-            else {\n-                let x = x - A;\n-                if x < B {\n-                    choose_edge(i + 1i64, j, scale, r)\n-                }\n-                else {\n-                    let x = x - B;\n-                    if x < C {\n-                        choose_edge(i, j + 1i64, scale, r)\n-                    }\n-                    else {\n-                        choose_edge(i + 1i64, j + 1i64, scale, r)\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    do vec::from_fn((1u << scale) * edgefactor) |_i| {\n-        choose_edge(0i64, 0i64, scale, &mut r)\n-    }\n-}\n-\n-fn make_graph(N: uint, edges: ~[(node_id, node_id)]) -> graph {\n-    let mut graph = do vec::from_fn(N) |_i| {\n-        HashSet::new()\n-    };\n-\n-    for e in edges.iter() {\n-        match *e {\n-            (i, j) => {\n-                graph[i].insert(j);\n-                graph[j].insert(i);\n-            }\n-        }\n-    }\n-\n-    do graph.move_iter().map |v| {\n-        let mut vec = ~[];\n-        for i in v.move_iter() {\n-            vec.push(i);\n-        }\n-        vec\n-    }.collect()\n-}\n-\n-fn gen_search_keys(graph: &[~[node_id]], n: uint) -> ~[node_id] {\n-    let mut keys = HashSet::new();\n-    let mut r = rand::rng();\n-\n-    while keys.len() < n {\n-        let k = r.gen_uint_range(0u, graph.len());\n-\n-        if graph[k].len() > 0u && graph[k].iter().any(|i| {\n-            *i != k as node_id\n-        }) {\n-            keys.insert(k as node_id);\n-        }\n-    }\n-    let mut vec = ~[];\n-    for i in keys.move_iter() {\n-        vec.push(i);\n-    }\n-    return vec;\n-}\n-\n-/**\n- * Returns a vector of all the parents in the BFS tree rooted at key.\n- *\n- * Nodes that are unreachable have a parent of -1.\n- */\n-fn bfs(graph: graph, key: node_id) -> bfs_result {\n-    let mut marks : ~[node_id]\n-        = vec::from_elem(graph.len(), -1i64);\n-\n-    let mut q = RingBuf::new();\n-\n-    q.push_back(key);\n-    marks[key] = key;\n-\n-    while !q.is_empty() {\n-        let t = q.pop_front().unwrap();\n-\n-        do graph[t].iter().advance |k| {\n-            if marks[*k] == -1i64 {\n-                marks[*k] = t;\n-                q.push_back(*k);\n-            }\n-            true\n-        };\n-    }\n-\n-    marks\n-}\n-\n-#[deriving(Clone)]\n-enum color {\n-    white,\n-    // node_id marks which node turned this gray/black.\n-    // the node id later becomes the parent.\n-    gray(node_id),\n-    black(node_id)\n-}\n-\n-/**\n- * Another version of the bfs function.\n- *\n- * This one uses the same algorithm as the parallel one, just without\n- * using the parallel vector operators.\n- */\n-fn bfs2(graph: graph, key: node_id) -> bfs_result {\n-    // This works by doing functional updates of a color vector.\n-\n-    let mut colors = do vec::from_fn(graph.len()) |i| {\n-        if i as node_id == key {\n-            gray(key)\n-        }\n-        else {\n-            white\n-        }\n-    };\n-\n-    fn is_gray(c: &color) -> bool {\n-        match *c {\n-          gray(_) => { true }\n-          _ => { false }\n-        }\n-    }\n-\n-    let mut i = 0;\n-    while colors.iter().any(is_gray) {\n-        // Do the BFS.\n-        info!(\"PBFS iteration %?\", i);\n-        i += 1;\n-        colors = do colors.iter().enumerate().map |(i, c)| {\n-            let c : color = *c;\n-            match c {\n-              white => {\n-                let i = i as node_id;\n-\n-                let neighbors = &graph[i];\n-\n-                let mut color = white;\n-\n-                do neighbors.iter().advance |k| {\n-                    if is_gray(&colors[*k]) {\n-                        color = gray(*k);\n-                        false\n-                    }\n-                    else { true }\n-                };\n-\n-                color\n-              }\n-              gray(parent) => { black(parent) }\n-              black(parent) => { black(parent) }\n-            }\n-        }.collect()\n-    }\n-\n-    // Convert the results.\n-    do colors.iter().map |c| {\n-        match *c {\n-          white => { -1i64 }\n-          black(parent) => { parent }\n-          _ => { fail!(\"Found remaining gray nodes in BFS\") }\n-        }\n-    }.collect()\n-}\n-\n-/// A parallel version of the bfs function.\n-fn pbfs(graph: &arc::Arc<graph>, key: node_id) -> bfs_result {\n-    // This works by doing functional updates of a color vector.\n-\n-    let graph_vec = graph.get(); // FIXME #3387 requires this temp\n-    let mut colors = do vec::from_fn(graph_vec.len()) |i| {\n-        if i as node_id == key {\n-            gray(key)\n-        }\n-        else {\n-            white\n-        }\n-    };\n-\n-    #[inline(always)]\n-    fn is_gray(c: &color) -> bool {\n-        match *c {\n-          gray(_) => { true }\n-          _ => { false }\n-        }\n-    }\n-\n-    fn is_gray_factory() -> ~fn(c: &color) -> bool {\n-        let r: ~fn(c: &color) -> bool = is_gray;\n-        r\n-    }\n-\n-    let mut i = 0;\n-    while par::any(colors, is_gray_factory) {\n-        // Do the BFS.\n-        info!(\"PBFS iteration %?\", i);\n-        i += 1;\n-        let old_len = colors.len();\n-\n-        let color = arc::Arc::new(colors);\n-\n-        let color_vec = color.get(); // FIXME #3387 requires this temp\n-        colors = do par::mapi(*color_vec) {\n-            let colors = color.clone();\n-            let graph = graph.clone();\n-            let result: ~fn(x: uint, y: &color) -> color = |i, c| {\n-                let colors = colors.get();\n-                let graph = graph.get();\n-                match *c {\n-                  white => {\n-                    let i = i as node_id;\n-\n-                    let neighbors = graph[i].clone();\n-\n-                    let mut color = white;\n-\n-                    do neighbors.iter().advance |k| {\n-                        if is_gray(&colors[*k]) {\n-                            color = gray(*k);\n-                            false\n-                        }\n-                        else { true }\n-                    };\n-                    color\n-                  }\n-                  gray(parent) => { black(parent) }\n-                  black(parent) => { black(parent) }\n-                }\n-            };\n-            result\n-        };\n-        assert_eq!(colors.len(), old_len);\n-    }\n-\n-    // Convert the results.\n-    do par::map(colors) {\n-        let result: ~fn(c: &color) -> i64 = |c| {\n-            match *c {\n-                white => { -1i64 }\n-                black(parent) => { parent }\n-                _ => { fail!(\"Found remaining gray nodes in BFS\") }\n-            }\n-        };\n-        result\n-    }\n-}\n-\n-/// Performs at least some of the validation in the Graph500 spec.\n-fn validate(edges: ~[(node_id, node_id)],\n-            root: node_id, tree: bfs_result) -> bool {\n-    // There are 5 things to test. Below is code for each of them.\n-\n-    // 1. The BFS tree is a tree and does not contain cycles.\n-    //\n-    // We do this by iterating over the tree, and tracing each of the\n-    // parent chains back to the root. While we do this, we also\n-    // compute the levels for each node.\n-\n-    info!(~\"Verifying tree structure...\");\n-\n-    let mut status = true;\n-    let level = do tree.map() |parent| {\n-        let mut parent = *parent;\n-        let mut path = ~[];\n-\n-        if parent == -1i64 {\n-            // This node was not in the tree.\n-            -1\n-        }\n-        else {\n-            while parent != root {\n-                if path.contains(&parent) {\n-                    status = false;\n-                }\n-\n-                path.push(parent);\n-                parent = tree[parent];\n-            }\n-\n-            // The length of the path back to the root is the current\n-            // level.\n-            path.len() as int\n-        }\n-    };\n-\n-    if !status { return status }\n-\n-    // 2. Each tree edge connects vertices whose BFS levels differ by\n-    //    exactly one.\n-\n-    info!(~\"Verifying tree edges...\");\n-\n-    let status = do tree.iter().enumerate().all |(k, parent)| {\n-        if *parent != root && *parent != -1i64 {\n-            level[*parent] == level[k] - 1\n-        }\n-        else {\n-            true\n-        }\n-    };\n-\n-    if !status { return status }\n-\n-    // 3. Every edge in the input list has vertices with levels that\n-    //    differ by at most one or that both are not in the BFS tree.\n-\n-    info!(~\"Verifying graph edges...\");\n-\n-    let status = do edges.iter().all |e| {\n-        let (u, v) = *e;\n-\n-        abs(level[u] - level[v]) <= 1\n-    };\n-\n-    if !status { return status }\n-\n-    // 4. The BFS tree spans an entire connected component's vertices.\n-\n-    // This is harder. We'll skip it for now...\n-\n-    // 5. A node and its parent are joined by an edge of the original\n-    //    graph.\n-\n-    info!(~\"Verifying tree and graph edges...\");\n-\n-    let status = do par::alli(tree) {\n-        let edges = edges.clone();\n-        let result: ~fn(x: uint, v: &i64) -> bool = |u, v| {\n-            let u = u as node_id;\n-            if *v == -1i64 || u == root {\n-                true\n-            } else {\n-                edges.iter().any(|x| x == &(u, *v)) || edges.iter().any(|x| x == &(*v, u))\n-            }\n-        };\n-        result\n-    };\n-\n-    if !status { return status }\n-\n-    // If we get through here, all the tests passed!\n-    true\n-}\n-\n-fn main() {\n-    let args = os::args();\n-    let args = if os::getenv(\"RUST_BENCH\").is_some() {\n-        ~[~\"\", ~\"15\", ~\"48\"]\n-    } else if args.len() <= 1 {\n-        ~[~\"\", ~\"10\", ~\"16\"]\n-    } else {\n-        args\n-    };\n-\n-    let scale = from_str::<uint>(args[1]).unwrap();\n-    let num_keys = from_str::<uint>(args[2]).unwrap();\n-    let do_validate = false;\n-    let do_sequential = true;\n-\n-    let start = time::precise_time_s();\n-    let edges = make_edges(scale, 16);\n-    let stop = time::precise_time_s();\n-\n-    io::stdout().write_line(fmt!(\"Generated %? edges in %? seconds.\",\n-                                 edges.len(), stop - start));\n-\n-    let start = time::precise_time_s();\n-    let graph = make_graph(1 << scale, edges.clone());\n-    let stop = time::precise_time_s();\n-\n-    let mut total_edges = 0;\n-    for edges in graph.iter() { total_edges += edges.len(); }\n-\n-    io::stdout().write_line(fmt!(\"Generated graph with %? edges in %? seconds.\",\n-                                 total_edges / 2,\n-                                 stop - start));\n-\n-    let mut total_seq = 0.0;\n-    let mut total_par = 0.0;\n-\n-    let graph_arc = arc::Arc::new(graph.clone());\n-\n-    do gen_search_keys(graph, num_keys).map() |root| {\n-        io::stdout().write_line(\"\");\n-        io::stdout().write_line(fmt!(\"Search key: %?\", root));\n-\n-        if do_sequential {\n-            let start = time::precise_time_s();\n-            let bfs_tree = bfs(graph.clone(), *root);\n-            let stop = time::precise_time_s();\n-\n-            //total_seq += stop - start;\n-\n-            io::stdout().write_line(\n-                fmt!(\"Sequential BFS completed in %? seconds.\",\n-                     stop - start));\n-\n-            if do_validate {\n-                let start = time::precise_time_s();\n-                assert!((validate(edges.clone(), *root, bfs_tree)));\n-                let stop = time::precise_time_s();\n-\n-                io::stdout().write_line(\n-                    fmt!(\"Validation completed in %? seconds.\",\n-                         stop - start));\n-            }\n-\n-            let start = time::precise_time_s();\n-            let bfs_tree = bfs2(graph.clone(), *root);\n-            let stop = time::precise_time_s();\n-\n-            total_seq += stop - start;\n-\n-            io::stdout().write_line(\n-                fmt!(\"Alternate Sequential BFS completed in %? seconds.\",\n-                     stop - start));\n-\n-            if do_validate {\n-                let start = time::precise_time_s();\n-                assert!((validate(edges.clone(), *root, bfs_tree)));\n-                let stop = time::precise_time_s();\n-\n-                io::stdout().write_line(\n-                    fmt!(\"Validation completed in %? seconds.\",\n-                         stop - start));\n-            }\n-        }\n-\n-        let start = time::precise_time_s();\n-        let bfs_tree = pbfs(&graph_arc, *root);\n-        let stop = time::precise_time_s();\n-\n-        total_par += stop - start;\n-\n-        io::stdout().write_line(fmt!(\"Parallel BFS completed in %? seconds.\",\n-                                     stop - start));\n-\n-        if do_validate {\n-            let start = time::precise_time_s();\n-            assert!((validate(edges.clone(), *root, bfs_tree)));\n-            let stop = time::precise_time_s();\n-\n-            io::stdout().write_line(fmt!(\"Validation completed in %? seconds.\",\n-                                         stop - start));\n-        }\n-    };\n-\n-    io::stdout().write_line(\"\");\n-    io::stdout().write_line(\n-        fmt!(\"Total sequential: %? \\t Total Parallel: %? \\t Speedup: %?x\",\n-             total_seq, total_par, total_seq / total_par));\n-}"}]}