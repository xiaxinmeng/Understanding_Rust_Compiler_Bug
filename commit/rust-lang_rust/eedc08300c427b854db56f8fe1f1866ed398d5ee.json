{"sha": "eedc08300c427b854db56f8fe1f1866ed398d5ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlZGMwODMwMGM0MjdiODU0ZGI1NmY4ZmUxZjE4NjZlZDM5OGQ1ZWU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-13T15:56:57Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-13T15:56:57Z"}, "message": "goto defenition works for type-inferred methods", "tree": {"sha": "98a579f8c0fd7a0738862937ec32a7dc62172e1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98a579f8c0fd7a0738862937ec32a7dc62172e1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eedc08300c427b854db56f8fe1f1866ed398d5ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eedc08300c427b854db56f8fe1f1866ed398d5ee", "html_url": "https://github.com/rust-lang/rust/commit/eedc08300c427b854db56f8fe1f1866ed398d5ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eedc08300c427b854db56f8fe1f1866ed398d5ee/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "884ce4a4207ca68a5299b3a2e4e33b8f1f158001", "url": "https://api.github.com/repos/rust-lang/rust/commits/884ce4a4207ca68a5299b3a2e4e33b8f1f158001", "html_url": "https://github.com/rust-lang/rust/commit/884ce4a4207ca68a5299b3a2e4e33b8f1f158001"}], "stats": {"total": 76, "additions": 71, "deletions": 5}, "files": [{"sha": "fa46ddfe9eee33f9510ca97338fda65d1f2b691f", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/eedc08300c427b854db56f8fe1f1866ed398d5ee/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedc08300c427b854db56f8fe1f1866ed398d5ee/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=eedc08300c427b854db56f8fe1f1866ed398d5ee", "patch": "@@ -28,6 +28,7 @@ use log;\n use ena::unify::{InPlaceUnificationTable, UnifyKey, UnifyValue, NoError};\n use ra_arena::map::ArenaMap;\n use join_to_string::join;\n+use rustc_hash::FxHashMap;\n \n use ra_db::Cancelable;\n \n@@ -448,14 +449,14 @@ fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Cancelable<Ty> {\n     })\n }\n \n-pub fn type_for_enum(db: &impl HirDatabase, s: Enum) -> Cancelable<Ty> {\n+pub(crate) fn type_for_enum(db: &impl HirDatabase, s: Enum) -> Cancelable<Ty> {\n     Ok(Ty::Adt {\n         def_id: s.def_id(),\n         name: s.name(db)?.unwrap_or_else(Name::missing),\n     })\n }\n \n-pub fn type_for_enum_variant(db: &impl HirDatabase, ev: EnumVariant) -> Cancelable<Ty> {\n+pub(crate) fn type_for_enum_variant(db: &impl HirDatabase, ev: EnumVariant) -> Cancelable<Ty> {\n     let enum_parent = ev.parent_enum(db)?;\n \n     type_for_enum(db, enum_parent)\n@@ -512,10 +513,18 @@ pub(super) fn type_for_field(\n /// The result of type inference: A mapping from expressions and patterns to types.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct InferenceResult {\n+    /// For each method call expr, record the function it resolved to.\n+    method_resolutions: FxHashMap<ExprId, DefId>,\n     type_of_expr: ArenaMap<ExprId, Ty>,\n     type_of_pat: ArenaMap<PatId, Ty>,\n }\n \n+impl InferenceResult {\n+    pub fn method_resolution(&self, expr: ExprId) -> Option<DefId> {\n+        self.method_resolutions.get(&expr).map(|it| *it)\n+    }\n+}\n+\n impl Index<ExprId> for InferenceResult {\n     type Output = Ty;\n \n@@ -541,6 +550,7 @@ struct InferenceContext<'a, D: HirDatabase> {\n     module: Module,\n     impl_block: Option<ImplBlock>,\n     var_unification_table: InPlaceUnificationTable<TypeVarId>,\n+    method_resolutions: FxHashMap<ExprId, DefId>,\n     type_of_expr: ArenaMap<ExprId, Ty>,\n     type_of_pat: ArenaMap<PatId, Ty>,\n     /// The return type of the function being inferred.\n@@ -631,6 +641,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         impl_block: Option<ImplBlock>,\n     ) -> Self {\n         InferenceContext {\n+            method_resolutions: FxHashMap::default(),\n             type_of_expr: ArenaMap::default(),\n             type_of_pat: ArenaMap::default(),\n             var_unification_table: InPlaceUnificationTable::new(),\n@@ -655,6 +666,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             *ty = resolved;\n         }\n         InferenceResult {\n+            method_resolutions: mem::replace(&mut self.method_resolutions, Default::default()),\n             type_of_expr: expr_types,\n             type_of_pat: pat_types,\n         }\n@@ -664,6 +676,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.type_of_expr.insert(expr, ty);\n     }\n \n+    fn write_method_resolution(&mut self, expr: ExprId, def_id: DefId) {\n+        self.method_resolutions.insert(expr, def_id);\n+    }\n+\n     fn write_pat_ty(&mut self, pat: PatId, ty: Ty) {\n         self.type_of_pat.insert(pat, ty);\n     }\n@@ -900,7 +916,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let receiver_ty = self.infer_expr(*receiver, &Expectation::none())?;\n                 let resolved = receiver_ty.clone().lookup_method(self.db, method_name)?;\n                 let method_ty = match resolved {\n-                    Some(def_id) => self.db.type_for_def(def_id)?,\n+                    Some(def_id) => {\n+                        self.write_method_resolution(expr, def_id);\n+                        self.db.type_for_def(def_id)?\n+                    }\n                     None => Ty::Unknown,\n                 };\n                 let method_ty = self.insert_type_vars(method_ty);"}, {"sha": "332a2fb8d3ed2710556c4bea12895e8110741224", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 49, "deletions": 2, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/eedc08300c427b854db56f8fe1f1866ed398d5ee/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eedc08300c427b854db56f8fe1f1866ed398d5ee/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=eedc08300c427b854db56f8fe1f1866ed398d5ee", "patch": "@@ -47,15 +47,34 @@ pub(crate) fn reference_definition(\n     name_ref: &ast::NameRef,\n ) -> Cancelable<ReferenceResult> {\n     use self::ReferenceResult::*;\n-    if let Some(fn_descr) =\n+    if let Some(function) =\n         hir::source_binder::function_from_child_node(db, file_id, name_ref.syntax())?\n     {\n-        let scope = fn_descr.scopes(db)?;\n+        let scope = function.scopes(db)?;\n         // First try to resolve the symbol locally\n         if let Some(entry) = scope.resolve_local_name(name_ref) {\n             let nav = NavigationTarget::from_scope_entry(file_id, &entry);\n             return Ok(Exact(nav));\n         };\n+\n+        // Next check if it is a method\n+        if let Some(method_call) = name_ref\n+            .syntax()\n+            .parent()\n+            .and_then(ast::MethodCallExpr::cast)\n+        {\n+            let infer_result = function.infer(db)?;\n+            let syntax_mapping = function.body_syntax_mapping(db)?;\n+            let expr = ast::Expr::cast(method_call.syntax()).unwrap();\n+            if let Some(def_id) = syntax_mapping\n+                .node_expr(expr)\n+                .and_then(|it| infer_result.method_resolution(it))\n+            {\n+                if let Some(target) = NavigationTarget::from_def(db, def_id.resolve(db)?)? {\n+                    return Ok(Exact(target));\n+                }\n+            };\n+        }\n     }\n     // Then try module name resolution\n     if let Some(module) =\n@@ -167,4 +186,32 @@ mod tests {\n             \"foo SOURCE_FILE FileId(2) [0; 10)\",\n         );\n     }\n+\n+    #[test]\n+    fn goto_definition_works_for_methods() {\n+        check_goto(\n+            \"\n+            //- /lib.rs\n+            struct Foo;\n+            impl Foo {\n+                fn frobnicate(&self) {  }\n+            }\n+\n+            fn bar(foo: &Foo) {\n+                foo.frobnicate<|>();\n+            }\n+            \",\n+            \"frobnicate FN_DEF FileId(1) [27; 52) [30; 40)\",\n+        );\n+\n+        check_goto(\n+            \"\n+            //- /lib.rs\n+            mod <|>foo;\n+            //- /foo/mod.rs\n+            // empty\n+            \",\n+            \"foo SOURCE_FILE FileId(2) [0; 10)\",\n+        );\n+    }\n }"}]}