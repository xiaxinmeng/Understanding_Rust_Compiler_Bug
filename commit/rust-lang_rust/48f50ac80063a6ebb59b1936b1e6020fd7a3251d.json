{"sha": "48f50ac80063a6ebb59b1936b1e6020fd7a3251d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4ZjUwYWM4MDA2M2E2ZWJiNTliMTkzNmIxZTYwMjBmZDdhMzI1MWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-30T03:48:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-30T03:48:37Z"}, "message": "auto merge of #6107 : catamorphism/rust/mkdir_recursive, r=brson\n\nr? @brson This hopefully addresses your concerns about the termination condition, and adds more tests. With a bonus documentation commit.", "tree": {"sha": "ebf54099640d03cc044b334272ec568c9babece7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebf54099640d03cc044b334272ec568c9babece7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48f50ac80063a6ebb59b1936b1e6020fd7a3251d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48f50ac80063a6ebb59b1936b1e6020fd7a3251d", "html_url": "https://github.com/rust-lang/rust/commit/48f50ac80063a6ebb59b1936b1e6020fd7a3251d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48f50ac80063a6ebb59b1936b1e6020fd7a3251d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "868b7c153ce6797c768cc2c43a564f34615f6f2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/868b7c153ce6797c768cc2c43a564f34615f6f2d", "html_url": "https://github.com/rust-lang/rust/commit/868b7c153ce6797c768cc2c43a564f34615f6f2d"}, {"sha": "d045ce7b87af0fb0730ccf5291c11d28a5382254", "url": "https://api.github.com/repos/rust-lang/rust/commits/d045ce7b87af0fb0730ccf5291c11d28a5382254", "html_url": "https://github.com/rust-lang/rust/commit/d045ce7b87af0fb0730ccf5291c11d28a5382254"}], "stats": {"total": 141, "additions": 119, "deletions": 22}, "files": [{"sha": "f1962eeaa23d02e3fc53dbfa1ecba3e759e7d3ad", "filename": "src/libcore/os.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/48f50ac80063a6ebb59b1936b1e6020fd7a3251d/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48f50ac80063a6ebb59b1936b1e6020fd7a3251d/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=48f50ac80063a6ebb59b1936b1e6020fd7a3251d", "patch": "@@ -643,20 +643,22 @@ pub fn make_dir(p: &Path, mode: c_int) -> bool {\n /// Returns true iff creation\n /// succeeded. Also creates all intermediate subdirectories\n /// if they don't already exist, giving all of them the same mode.\n+\n+// tjc: if directory exists but with different permissions,\n+// should we return false?\n pub fn mkdir_recursive(p: &Path, mode: c_int) -> bool {\n     if path_is_dir(p) {\n         return true;\n     }\n-    let parent = p.dir_path();\n-    debug!(\"mkdir_recursive: parent = %s\",\n-           parent.to_str());\n-    if parent.to_str() == ~\".\"\n-        || parent.to_str() == ~\"/\" { // !!!\n+    else if p.components.is_empty() {\n+        return false;\n+    }\n+    else if p.components.len() == 1 {\n         // No parent directories to create\n-        path_is_dir(&parent) && make_dir(p, mode)\n+        path_is_dir(p) || make_dir(p, mode)\n     }\n     else {\n-        mkdir_recursive(&parent, mode) && make_dir(p, mode)\n+        mkdir_recursive(&p.pop(), mode) && make_dir(p, mode)\n     }\n }\n \n@@ -1267,6 +1269,8 @@ mod tests {\n     use run;\n     use str;\n     use vec;\n+    use libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n+\n \n     #[test]\n     pub fn last_os_error() {\n@@ -1490,16 +1494,16 @@ mod tests {\n     }\n \n     #[test]\n-    fn recursive_mkdir_ok() {\n-        use libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n+    fn recursive_mkdir_slash() {\n+        let path = Path(\"/\");\n+        assert!(os::mkdir_recursive(&path,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n+    }\n \n-        let root = os::tmpdir();\n-        let path = \"xy/z/zy\";\n-        let nested = root.push(path);\n-        assert!(os::mkdir_recursive(&nested,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n-        assert!(os::path_is_dir(&root.push(\"xy\")));\n-        assert!(os::path_is_dir(&root.push(\"xy/z\")));\n-        assert!(os::path_is_dir(&nested));\n+    #[test]\n+    fn recursive_mkdir_empty() {\n+        let path = Path(\"\");\n+        assert!(!os::mkdir_recursive(&path, (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n     }\n \n+    // More recursive_mkdir tests are in std::tempfile\n }"}, {"sha": "a87fd90f4e27ab4957229c9d3a4af210d86055be", "filename": "src/libcore/path.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/48f50ac80063a6ebb59b1936b1e6020fd7a3251d/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48f50ac80063a6ebb59b1936b1e6020fd7a3251d/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=48f50ac80063a6ebb59b1936b1e6020fd7a3251d", "patch": "@@ -49,31 +49,71 @@ pub fn PosixPath(s: &str) -> PosixPath {\n }\n \n pub trait GenericPath {\n+    /// Converts a string to a Path\n     fn from_str(&str) -> Self;\n \n+    /// Returns the directory component of `self`, as a string\n     fn dirname(&self) -> ~str;\n+    /// Returns the file component of `self`, as a string option.\n+    /// Returns None if `self` names a directory.\n     fn filename(&self) -> Option<~str>;\n+    /// Returns the stem of the file component of `self`, as a string option.\n+    /// The stem is the slice of a filename starting at 0 and ending just before\n+    /// the last '.' in the name.\n+    /// Returns None if `self` names a directory.\n     fn filestem(&self) -> Option<~str>;\n+    /// Returns the type of the file component of `self`, as a string option.\n+    /// The file type is the slice of a filename starting just after the last\n+    /// '.' in the name and ending at the last index in the filename.\n+    /// Returns None if `self` names a directory.\n     fn filetype(&self) -> Option<~str>;\n \n+    /// Returns a new path consisting of `self` with the parent directory component replaced\n+    /// with the given string.\n     fn with_dirname(&self, (&str)) -> Self;\n+    /// Returns a new path consisting of `self` with the file component replaced\n+    /// with the given string.\n     fn with_filename(&self, (&str)) -> Self;\n+    /// Returns a new path consisting of `self` with the file stem replaced\n+    /// with the given string.\n     fn with_filestem(&self, (&str)) -> Self;\n+    /// Returns a new path consisting of `self` with the file type replaced\n+    /// with the given string.\n     fn with_filetype(&self, (&str)) -> Self;\n \n+    /// Returns the directory component of `self`, as a new path.\n+    /// If `self` has no parent, returns `self`.\n     fn dir_path(&self) -> Self;\n+    /// Returns the file component of `self`, as a new path.\n+    /// If `self` names a directory, returns the empty path.\n     fn file_path(&self) -> Self;\n \n+    /// Returns a new Path whose parent directory is `self` and whose\n+    /// file component is the given string.\n     fn push(&self, (&str)) -> Self;\n+    /// Returns a new Path consisting of the given path, made relative to `self`.\n     fn push_rel(&self, (&Self)) -> Self;\n+    /// Returns a new Path consisting of the path given by the given vector\n+    /// of strings, relative to `self`.\n     fn push_many(&self, (&[~str])) -> Self;\n+    /// Identical to `dir_path` except in the case where `self` has only one\n+    /// component. In this case, `pop` returns the empty path.\n     fn pop(&self) -> Self;\n \n+    /// The same as `push_rel`, except that the directory argument must not\n+    /// contain directory separators in any of its components.\n     fn unsafe_join(&self, (&Self)) -> Self;\n+    /// On Unix, always returns false. On Windows, returns true iff `self`'s\n+    /// file stem is one of: `con` `aux` `com1` `com2` `com3` `com4`\n+    /// `lpt1` `lpt2` `lpt3` `prn` `nul`\n     fn is_restricted(&self) -> bool;\n \n+    /// Returns a new path that names the same file as `self`, without containing\n+    /// any '.', '..', or empty components. On Windows, uppercases the drive letter\n+    /// as well.\n     fn normalize(&self) -> Self;\n \n+    /// Returns `true` if `self` is an absolute path.\n     fn is_absolute(&self) -> bool;\n }\n "}, {"sha": "eec91b68454441566081f6eb02a1f9f827f9b61b", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 59, "deletions": 6, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/48f50ac80063a6ebb59b1936b1e6020fd7a3251d/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48f50ac80063a6ebb59b1936b1e6020fd7a3251d/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=48f50ac80063a6ebb59b1936b1e6020fd7a3251d", "patch": "@@ -23,9 +23,62 @@ pub fn mkdtemp(tmpdir: &Path, suffix: &str) -> Option<Path> {\n     None\n }\n \n-#[test]\n-fn test_mkdtemp() {\n-    let p = mkdtemp(&Path(\".\"), \"foobar\").unwrap();\n-    os::remove_dir(&p);\n-    assert!(str::ends_with(p.to_str(), \"foobar\"));\n-}\n+#[cfg(test)]\n+mod tests {\n+    use tempfile::mkdtemp;\n+    use tempfile;\n+\n+    #[test]\n+    fn test_mkdtemp() {\n+        let p = mkdtemp(&Path(\".\"), \"foobar\").unwrap();\n+        os::remove_dir(&p);\n+        assert!(str::ends_with(p.to_str(), \"foobar\"));\n+    }\n+\n+    // Ideally these would be in core::os but then core would need\n+    // to depend on std\n+    #[test]\n+    fn recursive_mkdir_rel() {\n+        use core::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n+        use core::os;\n+\n+        let root = mkdtemp(&os::tmpdir(), \"temp\").expect(\"recursive_mkdir_rel\");\n+        os::change_dir(&root);\n+        let path = Path(\"frob\");\n+        assert!(os::mkdir_recursive(&path,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n+        assert!(os::path_is_dir(&path));\n+        assert!(os::mkdir_recursive(&path,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n+        assert!(os::path_is_dir(&path));\n+    }\n+\n+    #[test]\n+    fn recursive_mkdir_dot() {\n+        use core::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n+        use core::os;\n+\n+        let dot = Path(\".\");\n+        assert!(os::mkdir_recursive(&dot,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n+        let dotdot = Path(\"..\");\n+        assert!(os::mkdir_recursive(&dotdot,  (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n+    }\n+\n+    #[test]\n+    fn recursive_mkdir_rel_2() {\n+        use core::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n+        use core::os;\n+\n+        let root = mkdtemp(&os::tmpdir(), \"temp\").expect(\"recursive_mkdir_rel_2\");\n+        os::change_dir(&root);\n+        let path = Path(\"./frob/baz\");\n+        debug!(\"...Making: %s in cwd %s\", path.to_str(), os::getcwd().to_str());\n+        assert!(os::mkdir_recursive(&path, (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n+        assert!(os::path_is_dir(&path));\n+        assert!(os::path_is_dir(&path.pop()));\n+        let path2 = Path(\"quux/blat\");\n+        debug!(\"Making: %s in cwd %s\", path2.to_str(), os::getcwd().to_str());\n+        assert!(os::mkdir_recursive(&path2, (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n+        assert!(os::path_is_dir(&path2));\n+        assert!(os::path_is_dir(&path2.pop()));\n+    }\n+\n+}\n\\ No newline at end of file"}]}