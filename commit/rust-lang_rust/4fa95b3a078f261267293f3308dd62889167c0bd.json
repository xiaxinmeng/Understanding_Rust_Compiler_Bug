{"sha": "4fa95b3a078f261267293f3308dd62889167c0bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmYTk1YjNhMDc4ZjI2MTI2NzI5M2YzMzA4ZGQ2Mjg4OTE2N2MwYmQ=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-12-12T04:01:26Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-12-12T05:01:01Z"}, "message": "Calculate span info on-demand instead of ahead of time\n\nThis should *vastly* reduce memory usage.", "tree": {"sha": "b2433cfc476e8a9c9ce83813171b8eea668ec5ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2433cfc476e8a9c9ce83813171b8eea668ec5ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4fa95b3a078f261267293f3308dd62889167c0bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4fa95b3a078f261267293f3308dd62889167c0bd", "html_url": "https://github.com/rust-lang/rust/commit/4fa95b3a078f261267293f3308dd62889167c0bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4fa95b3a078f261267293f3308dd62889167c0bd/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af6aa9f4313983deddd64543c5ad6c15e2160163", "url": "https://api.github.com/repos/rust-lang/rust/commits/af6aa9f4313983deddd64543c5ad6c15e2160163", "html_url": "https://github.com/rust-lang/rust/commit/af6aa9f4313983deddd64543c5ad6c15e2160163"}], "stats": {"total": 138, "additions": 69, "deletions": 69}, "files": [{"sha": "a21e9d9820cbd0da694902e7aeb1fe50029e80f3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4fa95b3a078f261267293f3308dd62889167c0bd/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa95b3a078f261267293f3308dd62889167c0bd/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4fa95b3a078f261267293f3308dd62889167c0bd", "patch": "@@ -25,7 +25,7 @@ use rustc_middle::ty::{self, AdtKind, Lift, Ty, TyCtxt};\n use rustc_mir::const_eval::{is_const_fn, is_min_const_fn, is_unstable_const_fn};\n use rustc_span::hygiene::{AstPass, MacroKind};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{self, ExpnKind, Pos};\n+use rustc_span::{self, ExpnKind};\n use rustc_typeck::hir_ty_to_ty;\n \n use std::collections::hash_map::Entry;\n@@ -1881,29 +1881,11 @@ impl Clean<VariantKind> for hir::VariantData<'_> {\n }\n \n impl Clean<Span> for rustc_span::Span {\n-    fn clean(&self, cx: &DocContext<'_>) -> Span {\n-        if self.is_dummy() {\n-            return Span::empty();\n-        }\n-\n+    fn clean(&self, _cx: &DocContext<'_>) -> Span {\n         // Get the macro invocation instead of the definition,\n         // in case the span is result of a macro expansion.\n         // (See rust-lang/rust#39726)\n-        let span = self.source_callsite();\n-\n-        let sm = cx.sess().source_map();\n-        let filename = sm.span_to_filename(span);\n-        let lo = sm.lookup_char_pos(span.lo());\n-        let hi = sm.lookup_char_pos(span.hi());\n-        Span {\n-            filename,\n-            cnum: lo.file.cnum,\n-            loline: lo.line,\n-            locol: lo.col.to_usize(),\n-            hiline: hi.line,\n-            hicol: hi.col.to_usize(),\n-            original: span,\n-        }\n+        Span { original: self.source_callsite() }\n     }\n }\n "}, {"sha": "a8626af8832f2414dc8a3c292ed5891ed1ba2bbd", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4fa95b3a078f261267293f3308dd62889167c0bd/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa95b3a078f261267293f3308dd62889167c0bd/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=4fa95b3a078f261267293f3308dd62889167c0bd", "patch": "@@ -17,15 +17,16 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_feature::UnstableFeatures;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n-use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::Mutability;\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::{AssocKind, TyCtxt};\n+use rustc_session::Session;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::DUMMY_SP;\n use rustc_span::symbol::{kw, sym, Ident, Symbol, SymbolStr};\n-use rustc_span::{self, FileName};\n+use rustc_span::{self, FileName, Loc};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi::Abi;\n use smallvec::{smallvec, SmallVec};\n@@ -1609,33 +1610,37 @@ crate enum VariantKind {\n     Struct(VariantStruct),\n }\n \n+/// Small wrapper around `rustc_span::Span` that adds helper methods.\n #[derive(Clone, Debug)]\n crate struct Span {\n-    crate filename: FileName,\n-    crate cnum: CrateNum,\n-    crate loline: usize,\n-    crate locol: usize,\n-    crate hiline: usize,\n-    crate hicol: usize,\n     crate original: rustc_span::Span,\n }\n \n impl Span {\n-    crate fn empty() -> Span {\n-        Span {\n-            filename: FileName::Anon(0),\n-            cnum: LOCAL_CRATE,\n-            loline: 0,\n-            locol: 0,\n-            hiline: 0,\n-            hicol: 0,\n-            original: rustc_span::DUMMY_SP,\n-        }\n+    crate fn empty() -> Self {\n+        Self { original: rustc_span::DUMMY_SP }\n     }\n \n     crate fn span(&self) -> rustc_span::Span {\n         self.original\n     }\n+\n+    crate fn filename(&self, sess: &Session) -> FileName {\n+        sess.source_map().span_to_filename(self.original)\n+    }\n+\n+    crate fn lo(&self, sess: &Session) -> Loc {\n+        sess.source_map().lookup_char_pos(self.original.lo())\n+    }\n+\n+    crate fn hi(&self, sess: &Session) -> Loc {\n+        sess.source_map().lookup_char_pos(self.original.hi())\n+    }\n+\n+    crate fn cnum(&self, sess: &Session) -> CrateNum {\n+        // FIXME: is there a time when the lo and hi crate would be different?\n+        self.lo(sess).file.cnum\n+    }\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]"}, {"sha": "b91f1a6c0e3a8ce101ecbaf027d9d4ce5d6d7230", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4fa95b3a078f261267293f3308dd62889167c0bd/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa95b3a078f261267293f3308dd62889167c0bd/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=4fa95b3a078f261267293f3308dd62889167c0bd", "patch": "@@ -103,7 +103,6 @@ crate fn ensure_trailing_slash(v: &str) -> impl fmt::Display + '_ {\n /// rustdoc tree).\n #[derive(Clone)]\n crate struct Context {\n-    crate sess: Lrc<Session>,\n     /// Current hierarchy of components leading down to what's currently being\n     /// rendered\n     crate current: Vec<String>,\n@@ -124,6 +123,7 @@ crate struct Context {\n }\n \n crate struct SharedContext {\n+    crate sess: Lrc<Session>,\n     /// The path to the crate root source minus the file name.\n     /// Used for simplifying paths to the highlighted source code files.\n     crate src_root: PathBuf,\n@@ -176,6 +176,10 @@ impl Context {\n         let filename = format!(\"{}{}.{}\", base, self.shared.resource_suffix, ext,);\n         self.dst.join(&filename)\n     }\n+\n+    fn sess(&self) -> &Session {\n+        &self.shared.sess\n+    }\n }\n \n impl SharedContext {\n@@ -459,6 +463,7 @@ impl FormatRenderer for Context {\n         }\n         let (sender, receiver) = channel();\n         let mut scx = SharedContext {\n+            sess,\n             collapsed: krate.collapsed,\n             src_root,\n             include_sources,\n@@ -498,7 +503,6 @@ impl FormatRenderer for Context {\n \n         let cache = Arc::new(cache);\n         let mut cx = Context {\n-            sess,\n             current: Vec::new(),\n             dst,\n             render_redirect_pages: false,\n@@ -1636,24 +1640,24 @@ impl Context {\n     /// of their crate documentation isn't known.\n     fn src_href(&self, item: &clean::Item, cache: &Cache) -> Option<String> {\n         let mut root = self.root_path();\n-\n         let mut path = String::new();\n+        let cnum = item.source.cnum(self.sess());\n \n         // We can safely ignore synthetic `SourceFile`s.\n-        let file = match item.source.filename {\n+        let file = match item.source.filename(self.sess()) {\n             FileName::Real(ref path) => path.local_path().to_path_buf(),\n             _ => return None,\n         };\n         let file = &file;\n \n-        let (krate, path) = if item.source.cnum == LOCAL_CRATE {\n+        let (krate, path) = if cnum == LOCAL_CRATE {\n             if let Some(path) = self.shared.local_sources.get(file) {\n                 (&self.shared.layout.krate, path)\n             } else {\n                 return None;\n             }\n         } else {\n-            let (krate, src_root) = match *cache.extern_locations.get(&item.source.cnum)? {\n+            let (krate, src_root) = match *cache.extern_locations.get(&cnum)? {\n                 (ref name, ref src, ExternalLocation::Local) => (name, src),\n                 (ref name, ref src, ExternalLocation::Remote(ref s)) => {\n                     root = s.to_string();\n@@ -1672,11 +1676,10 @@ impl Context {\n             (krate, &path)\n         };\n \n-        let lines = if item.source.loline == item.source.hiline {\n-            item.source.loline.to_string()\n-        } else {\n-            format!(\"{}-{}\", item.source.loline, item.source.hiline)\n-        };\n+        let loline = item.source.lo(self.sess()).line;\n+        let hiline = item.source.hi(self.sess()).line;\n+        let lines =\n+            if loline == hiline { loline.to_string() } else { format!(\"{}-{}\", loline, hiline) };\n         Some(format!(\n             \"{root}src/{krate}/{path}#{lines}\",\n             root = Escape(&root),"}, {"sha": "ef9e9f350fb84a9f00bf4ddebb8ab074e99006c2", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4fa95b3a078f261267293f3308dd62889167c0bd/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa95b3a078f261267293f3308dd62889167c0bd/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=4fa95b3a078f261267293f3308dd62889167c0bd", "patch": "@@ -7,6 +7,7 @@ use crate::html::highlight;\n use crate::html::layout;\n use crate::html::render::{SharedContext, BASIC_KEYWORDS};\n use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_session::Session;\n use rustc_span::source_map::FileName;\n use std::ffi::OsStr;\n use std::fs;\n@@ -34,37 +35,45 @@ struct SourceCollector<'a> {\n \n impl<'a> DocFolder for SourceCollector<'a> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n+        // If we're not rendering sources, there's nothing to do.\n         // If we're including source files, and we haven't seen this file yet,\n         // then we need to render it out to the filesystem.\n         if self.scx.include_sources\n             // skip all synthetic \"files\"\n-            && item.source.filename.is_real()\n+            && item.source.filename(self.sess()).is_real()\n             // skip non-local files\n-            && item.source.cnum == LOCAL_CRATE\n+            && item.source.cnum(self.sess()) == LOCAL_CRATE\n         {\n+            let filename = item.source.filename(self.sess());\n             // If it turns out that we couldn't read this file, then we probably\n             // can't read any of the files (generating html output from json or\n             // something like that), so just don't include sources for the\n             // entire crate. The other option is maintaining this mapping on a\n             // per-file basis, but that's probably not worth it...\n-            self.scx.include_sources = match self.emit_source(&item.source.filename) {\n+            self.scx.include_sources = match self.emit_source(&filename) {\n                 Ok(()) => true,\n                 Err(e) => {\n                     println!(\n                         \"warning: source code was requested to be rendered, \\\n                          but processing `{}` had an error: {}\",\n-                        item.source.filename, e\n+                        filename, e\n                     );\n                     println!(\"         skipping rendering of source code\");\n                     false\n                 }\n             };\n         }\n+        // FIXME: if `include_sources` isn't set and DocFolder didn't require consuming the crate by value,\n+        // we could return None here without having to walk the rest of the crate.\n         Some(self.fold_item_recur(item))\n     }\n }\n \n impl<'a> SourceCollector<'a> {\n+    fn sess(&self) -> &Session {\n+        &self.scx.sess\n+    }\n+\n     /// Renders the given filename into its corresponding HTML source file.\n     fn emit_source(&mut self, filename: &FileName) -> Result<(), Error> {\n         let p = match *filename {"}, {"sha": "9ae0a16ac35c5256fa976ec7dd2bfa68eb47ad88", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4fa95b3a078f261267293f3308dd62889167c0bd/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa95b3a078f261267293f3308dd62889167c0bd/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=4fa95b3a078f261267293f3308dd62889167c0bd", "patch": "@@ -56,18 +56,21 @@ impl From<clean::Item> for Option<Item> {\n }\n \n impl From<clean::Span> for Option<Span> {\n+    #[allow(unreachable_code)]\n     fn from(span: clean::Span) -> Self {\n-        let clean::Span { loline, locol, hiline, hicol, .. } = span;\n-        match span.filename {\n+        // TODO: this should actually work\n+        // Unfortunately this requires rethinking the whole framework,\n+        // since this now needs a context and not just .into().\n+        match span.filename(todo!()) {\n             rustc_span::FileName::Real(name) => Some(Span {\n                 filename: match name {\n                     rustc_span::RealFileName::Named(path) => path,\n                     rustc_span::RealFileName::Devirtualized { local_path, virtual_name: _ } => {\n                         local_path\n                     }\n                 },\n-                begin: (loline, locol),\n-                end: (hiline, hicol),\n+                begin: todo!(),\n+                end: todo!(),\n             }),\n             _ => None,\n         }"}, {"sha": "e094ead12bd0f4b98179521f2ab798af1bd4ef81", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4fa95b3a078f261267293f3308dd62889167c0bd/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa95b3a078f261267293f3308dd62889167c0bd/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=4fa95b3a078f261267293f3308dd62889167c0bd", "patch": "@@ -555,13 +555,14 @@ fn main_options(options: config::Options) -> MainResult {\n     info!(\"going to format\");\n     let (error_format, edition, debugging_options) = diag_opts;\n     let diag = core::new_handler(error_format, None, &debugging_options);\n+    let sess_time = sess.clone();\n     match output_format {\n-        None | Some(config::OutputFormat::Html) => sess.time(\"render_html\", || {\n+        None | Some(config::OutputFormat::Html) => sess_time.time(\"render_html\", || {\n             run_renderer::<html::render::Context>(\n                 krate, renderopts, renderinfo, &diag, edition, sess,\n             )\n         }),\n-        Some(config::OutputFormat::Json) => sess.time(\"render_json\", || {\n+        Some(config::OutputFormat::Json) => sess_time.time(\"render_json\", || {\n             run_renderer::<json::JsonRenderer>(krate, renderopts, renderinfo, &diag, edition, sess)\n         }),\n     }"}, {"sha": "52f6a97089bdef225f9879b86e3b659b55f081e6", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4fa95b3a078f261267293f3308dd62889167c0bd/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa95b3a078f261267293f3308dd62889167c0bd/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=4fa95b3a078f261267293f3308dd62889167c0bd", "patch": "@@ -216,13 +216,9 @@ impl<'a, 'b> fold::DocFolder for CoverageCalculator<'a, 'b> {\n                 return Some(i);\n             }\n             clean::ImplItem(ref impl_) => {\n+                let filename = i.source.filename(self.ctx.sess());\n                 if let Some(ref tr) = impl_.trait_ {\n-                    debug!(\n-                        \"impl {:#} for {:#} in {}\",\n-                        tr.print(),\n-                        impl_.for_.print(),\n-                        i.source.filename\n-                    );\n+                    debug!(\"impl {:#} for {:#} in {}\", tr.print(), impl_.for_.print(), filename,);\n \n                     // don't count trait impls, the missing-docs lint doesn't so we shouldn't\n                     // either\n@@ -231,7 +227,7 @@ impl<'a, 'b> fold::DocFolder for CoverageCalculator<'a, 'b> {\n                     // inherent impls *can* be documented, and those docs show up, but in most\n                     // cases it doesn't make sense, as all methods on a type are in one single\n                     // impl block\n-                    debug!(\"impl {:#} in {}\", impl_.for_.print(), i.source.filename);\n+                    debug!(\"impl {:#} in {}\", impl_.for_.print(), filename);\n                 }\n             }\n             _ => {\n@@ -251,15 +247,16 @@ impl<'a, 'b> fold::DocFolder for CoverageCalculator<'a, 'b> {\n                     None,\n                 );\n \n+                let filename = i.source.filename(self.ctx.sess());\n                 let has_doc_example = tests.found_tests != 0;\n                 let hir_id = self.ctx.tcx.hir().local_def_id_to_hir_id(i.def_id.expect_local());\n                 let (level, source) = self.ctx.tcx.lint_level_at_node(MISSING_DOCS, hir_id);\n                 // `missing_docs` is allow-by-default, so don't treat this as ignoring the item\n                 // unless the user had an explicit `allow`\n                 let should_have_docs =\n                     level != lint::Level::Allow || matches!(source, LintSource::Default);\n-                debug!(\"counting {:?} {:?} in {}\", i.type_(), i.name, i.source.filename);\n-                self.items.entry(i.source.filename.clone()).or_default().count_item(\n+                debug!(\"counting {:?} {:?} in {}\", i.type_(), i.name, filename);\n+                self.items.entry(filename).or_default().count_item(\n                     has_docs,\n                     has_doc_example,\n                     should_have_doc_example(self.ctx, &i),"}]}