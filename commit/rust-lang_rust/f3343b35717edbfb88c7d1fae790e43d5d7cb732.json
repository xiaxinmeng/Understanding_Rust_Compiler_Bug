{"sha": "f3343b35717edbfb88c7d1fae790e43d5d7cb732", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzMzQzYjM1NzE3ZWRiZmI4OGM3ZDFmYWU3OTBlNDNkNWQ3Y2I3MzI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-02-01T03:30:40Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-02-04T06:47:35Z"}, "message": "Beginnings of front-end support for classes\n\nAdded class support to the parser, prettyprinter, fold, and visit.\n(See Issue 1726.)\n\nThis is WIP -- the test case is xfailed, and attempting to compile\nit will error out in resolve.", "tree": {"sha": "6d93ac26b11428dfe4324cbc44a3e68f56f6859d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d93ac26b11428dfe4324cbc44a3e68f56f6859d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3343b35717edbfb88c7d1fae790e43d5d7cb732", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3343b35717edbfb88c7d1fae790e43d5d7cb732", "html_url": "https://github.com/rust-lang/rust/commit/f3343b35717edbfb88c7d1fae790e43d5d7cb732", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3343b35717edbfb88c7d1fae790e43d5d7cb732/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d65eabd5de4c41e4bc93b9c6c03d6278299ceb76", "url": "https://api.github.com/repos/rust-lang/rust/commits/d65eabd5de4c41e4bc93b9c6c03d6278299ceb76", "html_url": "https://github.com/rust-lang/rust/commit/d65eabd5de4c41e4bc93b9c6c03d6278299ceb76"}], "stats": {"total": 304, "additions": 294, "deletions": 10}, "files": [{"sha": "7cc2d56f1ac72d76aa68b7c9c93bb3019f35d28b", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3343b35717edbfb88c7d1fae790e43d5d7cb732/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3343b35717edbfb88c7d1fae790e43d5d7cb732/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=f3343b35717edbfb88c7d1fae790e43d5d7cb732", "patch": "@@ -119,6 +119,9 @@ fn encode_module_item_paths(ebml_w: ebml::writer, module: _mod, path: [str],\n             encode_def_id(ebml_w, local_def(it.id));\n             ebml::end_tag(ebml_w);\n           }\n+          item_class(_,_,_,_) {\n+              fail \"encode: implement item_class\";\n+          }\n           item_enum(variants, tps) {\n             add_to_index(ebml_w, path, index, it.ident);\n             ebml::start_tag(ebml_w, tag_paths_data_item);\n@@ -340,6 +343,9 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         ebml::end_tag(ebml_w);\n         encode_enum_variant_info(ecx, ebml_w, item.id, variants, index, tps);\n       }\n+      item_class(_,_,_,_) {\n+          fail \"encode: implement item_class\";\n+      }\n       item_res(_, tps, _, _, ctor_id) {\n         let fn_ty = node_id_to_type(tcx, ctor_id);\n "}, {"sha": "2ba68b927f0ae1417ca48d5464e1a5a41a3c4f02", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3343b35717edbfb88c7d1fae790e43d5d7cb732/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3343b35717edbfb88c7d1fae790e43d5d7cb732/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=f3343b35717edbfb88c7d1fae790e43d5d7cb732", "patch": "@@ -1421,6 +1421,9 @@ fn index_mod(md: ast::_mod) -> mod_index {\n                 variant_idx += 1u;\n             }\n           }\n+          ast::item_class(_, items, ctor_decl, _) {\n+              fail \"resolve::index_mod: item_class\";\n+          }\n         }\n     }\n     ret index;"}, {"sha": "02e5a33545c77c2dd3b70d6b496230f968e5c436", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3343b35717edbfb88c7d1fae790e43d5d7cb732/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3343b35717edbfb88c7d1fae790e43d5d7cb732/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=f3343b35717edbfb88c7d1fae790e43d5d7cb732", "patch": "@@ -60,6 +60,9 @@ fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n              ccx: ccx};\n         find_pre_post_fn(fcx, body);\n       }\n+      item_class(_,_,_,_) {\n+          fail \"find_pre_post_item: implement item_class\";\n+      }\n       item_impl(_, _, _, ms) { for m in ms { find_pre_post_method(ccx, m); } }\n     }\n }"}, {"sha": "90dfd5ccd9534a5bf9ad55e39a90c8cb75d2dbb4", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f3343b35717edbfb88c7d1fae790e43d5d7cb732/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3343b35717edbfb88c7d1fae790e43d5d7cb732/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=f3343b35717edbfb88c7d1fae790e43d5d7cb732", "patch": "@@ -426,6 +426,9 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n+      ast::item_class(_,_,_,_) {\n+          fail \"ty_of_item: implement item_class\";\n+      }\n       ast::item_impl(_, _, _, _) | ast::item_mod(_) |\n       ast::item_native_mod(_) { fail; }\n     }\n@@ -1232,15 +1235,15 @@ fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n                                  if subpats_len == 1u { \"\" } else { \"s\" },\n                                  arg_len,\n                                  if arg_len == 1u { \"\" } else { \"s\" }];\n-                    tcx.sess.span_fatal(pat.span, s);\n+                    tcx.sess.span_err(pat.span, s);\n                 }\n \n                 vec::iter2(subpats, arg_types) {|subpat, arg_ty|\n                     check_pat(fcx, map, subpat, arg_ty);\n                 }\n             } else if subpats_len > 0u {\n                 // TODO: note definition of enum variant\n-                tcx.sess.span_fatal\n+                tcx.sess.span_err\n                     (pat.span, #fmt[\"this pattern has %u field%s, \\\n                                      but the corresponding \\\n                                      variant has no fields\",\n@@ -1252,7 +1255,7 @@ fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n           _ {\n             // FIXME: Switch expected and actual in this message? I\n             // can never tell.\n-            tcx.sess.span_fatal\n+            tcx.sess.span_err\n                 (pat.span,\n                  #fmt[\"mismatched types: expected `%s` but found enum\",\n                       ty_to_str(tcx, expected)]);"}, {"sha": "b8e44257f523bd339fc2b0ce5b61ab48cfcb1d20", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f3343b35717edbfb88c7d1fae790e43d5d7cb732/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3343b35717edbfb88c7d1fae790e43d5d7cb732/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=f3343b35717edbfb88c7d1fae790e43d5d7cb732", "patch": "@@ -472,11 +472,29 @@ enum item_ {\n     item_enum([variant], [ty_param]),\n     item_res(fn_decl /* dtor */, [ty_param], blk,\n              node_id /* dtor id */, node_id /* ctor id */),\n+    item_class([ty_param], /* ty params for class */\n+               [@class_item], /* methods, etc. */\n+                             /* (not including ctor) */\n+               fn_decl, /* ctor decl */\n+               blk /* ctor body */\n+               ),\n     item_iface([ty_param], [ty_method]),\n     item_impl([ty_param], option<@ty> /* iface */,\n               @ty /* self */, [@method]),\n }\n \n+type class_item_ = {privacy: privacy, decl: @class_member};\n+type class_item = spanned<class_item_>;\n+\n+enum class_member {\n+    instance_var(ident, @ty, class_mutability, node_id),\n+    class_method(@item)\n+}\n+\n+enum class_mutability { class_mutable, class_immutable }\n+\n+enum privacy { priv, pub }\n+\n type native_item =\n     {ident: ident,\n      attrs: [attribute],"}, {"sha": "012b6257d891038894727436b0a0bce300823c26", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f3343b35717edbfb88c7d1fae790e43d5d7cb732/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3343b35717edbfb88c7d1fae790e43d5d7cb732/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=f3343b35717edbfb88c7d1fae790e43d5d7cb732", "patch": "@@ -27,6 +27,7 @@ type ast_fold_precursor =\n      fold_view_item: fn@(view_item_, ast_fold) -> view_item_,\n      fold_native_item: fn@(&&@native_item, ast_fold) -> @native_item,\n      fold_item: fn@(&&@item, ast_fold) -> @item,\n+     fold_class_item: fn@(&&@class_item, ast_fold) -> @class_item,\n      fold_item_underscore: fn@(item_, ast_fold) -> item_,\n      fold_method: fn@(&&@method, ast_fold) -> @method,\n      fold_block: fn@(blk_, span, ast_fold) -> (blk_, span),\n@@ -53,6 +54,7 @@ type a_f =\n      fold_view_item: fn@(&&@view_item) -> @view_item,\n      fold_native_item: fn@(&&@native_item) -> @native_item,\n      fold_item: fn@(&&@item) -> @item,\n+     fold_class_item: fn@(&&@class_item) -> @class_item,\n      fold_item_underscore: fn@(item_) -> item_,\n      fold_method: fn@(&&@method) -> @method,\n      fold_block: fn@(blk) -> blk,\n@@ -82,6 +84,7 @@ fn nf_crate_directive_dummy(&&_c: @crate_directive) -> @crate_directive {\n fn nf_view_item_dummy(&&_v: @view_item) -> @view_item { fail; }\n fn nf_native_item_dummy(&&_n: @native_item) -> @native_item { fail; }\n fn nf_item_dummy(&&_i: @item) -> @item { fail; }\n+fn nf_class_item_dummy(&&_ci: @class_item) -> @class_item { fail; }\n fn nf_item_underscore_dummy(_i: item_) -> item_ { fail; }\n fn nf_method_dummy(&&_m: @method) -> @method { fail; }\n fn nf_blk_dummy(_b: blk) -> blk { fail; }\n@@ -220,6 +223,20 @@ fn noop_fold_item(&&i: @item, fld: ast_fold) -> @item {\n           span: i.span};\n }\n \n+fn noop_fold_class_item(&&ci: @class_item, fld: ast_fold)\n+    -> @class_item {\n+    @{node: {\n+      privacy:ci.node.privacy,\n+            decl:\n+     @alt *ci.node.decl {\n+        instance_var(ident, t, cm, id) {\n+            instance_var(ident, fld.fold_ty(t), cm, id)\n+        }\n+        class_method(i) { class_method(fld.fold_item(i)) }\n+         }},\n+       span: ci.span}\n+}\n+\n fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n     ret alt i {\n           item_const(t, e) { item_const(fld.fold_ty(t), fld.fold_expr(e)) }\n@@ -233,6 +250,12 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n           item_enum(variants, typms) {\n             item_enum(vec::map(variants, fld.fold_variant), typms)\n           }\n+          item_class(typms, items, ctor_decl, ctor_body) {\n+              item_class(typms,\n+                         vec::map(items, fld.fold_class_item),\n+                         fold_fn_decl(ctor_decl, fld),\n+                         fld.fold_block(ctor_body))\n+          }\n           item_impl(tps, ifce, ty, methods) {\n             item_impl(tps, option::map(ifce, fld.fold_ty), fld.fold_ty(ty),\n                       vec::map(methods, fld.fold_method))\n@@ -518,6 +541,7 @@ fn default_ast_fold() -> @ast_fold_precursor {\n           fold_view_item: noop_fold_view_item,\n           fold_native_item: noop_fold_native_item,\n           fold_item: noop_fold_item,\n+          fold_class_item: noop_fold_class_item,\n           fold_item_underscore: noop_fold_item_underscore,\n           fold_method: noop_fold_method,\n           fold_block: wrap(noop_fold_block),\n@@ -548,6 +572,7 @@ fn make_fold(afp: ast_fold_precursor) -> ast_fold {\n                   fold_view_item: bind nf_view_item_dummy(_),\n                   fold_native_item: bind nf_native_item_dummy(_),\n                   fold_item: bind nf_item_dummy(_),\n+                  fold_class_item: bind nf_class_item_dummy(_),\n                   fold_item_underscore: bind nf_item_underscore_dummy(_),\n                   fold_method: bind nf_method_dummy(_),\n                   fold_block: bind nf_blk_dummy(_),\n@@ -591,6 +616,21 @@ fn make_fold(afp: ast_fold_precursor) -> ast_fold {\n     fn f_item(afp: ast_fold_precursor, f: ast_fold, &&i: @item) -> @item {\n         ret afp.fold_item(i, f);\n     }\n+    fn f_class_item(afp: ast_fold_precursor, f: ast_fold,\n+                      &&ci: @class_item) -> @class_item {\n+        @{node:\n+         {privacy:ci.node.privacy,\n+               decl:\n+        @alt *ci.node.decl {\n+           instance_var(nm, t, mt, id) {\n+               instance_var(nm, f_ty(afp, f, t),\n+                                 mt, id)\n+           }\n+           class_method(i) {\n+               class_method(afp.fold_item(i, f))\n+           }\n+            }}, span: ci.span}\n+    }\n     fn f_item_underscore(afp: ast_fold_precursor, f: ast_fold, i: item_) ->\n        item_ {\n         ret afp.fold_item_underscore(i, f);\n@@ -665,6 +705,7 @@ fn make_fold(afp: ast_fold_precursor) -> ast_fold {\n          fold_view_item: bind f_view_item(afp, result, _),\n          fold_native_item: bind f_native_item(afp, result, _),\n          fold_item: bind f_item(afp, result, _),\n+         fold_class_item: bind f_class_item(afp, result, _),\n          fold_item_underscore: bind f_item_underscore(afp, result, _),\n          fold_method: bind f_method(afp, result, _),\n          fold_block: bind f_block(afp, result, _),"}, {"sha": "a4ed54f2675c99ccca19b8f2ace663fd7af0ac93", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 105, "deletions": 1, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/f3343b35717edbfb88c7d1fae790e43d5d7cb732/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3343b35717edbfb88c7d1fae790e43d5d7cb732/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=f3343b35717edbfb88c7d1fae790e43d5d7cb732", "patch": "@@ -1616,6 +1616,21 @@ fn parse_let(p: parser) -> @ast::decl {\n     ret @spanned(lo, p.last_span.hi, ast::decl_local(locals));\n }\n \n+fn parse_instance_var(p:parser) -> @ast::class_member {\n+    let is_mut = ast::class_immutable;\n+    expect_word(p, \"let\");\n+    if eat_word(p, \"mutable\") {\n+            is_mut = ast::class_mutable;\n+    }\n+    if !is_plain_ident(p) {\n+        p.fatal(\"expecting ident\");\n+    }\n+    let name = parse_ident(p);\n+    expect(p, token::COLON);\n+    let ty = parse_ty(p, false);\n+    ret @ast::instance_var(name, ty, is_mut, p.get_id());\n+}\n+\n fn parse_stmt(p: parser, first_item_attrs: [ast::attribute]) -> @ast::stmt {\n     fn check_expected_item(p: parser, current_attrs: [ast::attribute]) {\n         // If we have attributes then we should have an item\n@@ -1980,6 +1995,92 @@ fn parse_item_res(p: parser, attrs: [ast::attribute]) -> @ast::item {\n                 attrs);\n }\n \n+fn parse_item_class(p: parser, attrs: [ast::attribute]) -> @ast::item {\n+    let lo = p.last_span.lo;\n+    let class_name = parse_value_ident(p);\n+    let ty_params = parse_ty_params(p);\n+    expect(p, token::LBRACE);\n+    let items: [@ast::class_item] = [];\n+    let the_ctor : option<(ast::fn_decl, ast::blk)> = none;\n+    while p.token != token::RBRACE {\n+       alt parse_class_item(p) {\n+            ctor_decl(a_fn_decl, blk) {\n+                the_ctor = some((a_fn_decl, blk));\n+            }\n+            plain_decl(a_decl) {\n+                items += [@{node: {privacy: ast::pub, decl: a_decl},\n+                            span: p.last_span}];\n+            }\n+            priv_decls(some_decls) {\n+                items += vec::map(some_decls, {|d|\n+                            @{node: {privacy: ast::priv, decl: d},\n+                                span: p.last_span}});\n+            }\n+       }\n+    }\n+    p.bump();\n+    alt the_ctor {\n+       some((ct_d, ct_b)) { ret mk_item(p, lo, p.last_span.hi, class_name,\n+                     ast::item_class(ty_params, items, ct_d, ct_b), attrs); }\n+       /*\n+         Is it strange for the parser to check this?\n+       */\n+       none { /* parse error */ fail \"Class with no ctor\"; }\n+    }\n+}\n+\n+// lets us identify the constructor declaration at\n+// parse time\n+// we don't really want just the fn_decl...\n+enum class_contents { ctor_decl(ast::fn_decl, ast::blk),\n+                      // assumed to be public\n+                      plain_decl(@ast::class_member),\n+                      // contents of a priv section --\n+                      // parse_class_item ensures that\n+                      // none of these are a ctor decl\n+                      priv_decls([@ast::class_member])}\n+\n+fn parse_class_item(p:parser) -> class_contents {\n+    if eat_word(p, \"new\") {\n+        // Can ctors have attrs?\n+        let decl = parse_fn_decl(p, ast::impure_fn);\n+        let body = parse_block(p);\n+        ret ctor_decl(decl, body);\n+    }\n+    // TODO: refactor\n+    else if eat_word(p, \"priv\") {\n+            expect(p, token::LBRACE);\n+            let results = [];\n+            while p.token != token::RBRACE {\n+               alt parse_item(p, []) {\n+                 some(i) {\n+                     results += [@ast::class_method(i)];\n+                 }\n+                 _ {\n+                     let a_var = parse_instance_var(p);\n+                     expect(p, token::SEMI);\n+                     results += [a_var];\n+                 }\n+               }\n+            }\n+            p.bump();\n+            ret priv_decls(results);\n+    }\n+    else {\n+        // Probably need to parse attrs\n+        alt parse_item(p, []) {\n+         some(i) {\n+             ret plain_decl(@ast::class_method(i));\n+         }\n+         _ {\n+             let a_var = parse_instance_var(p);\n+             expect(p, token::SEMI);\n+             ret plain_decl(a_var);\n+         }\n+        }\n+    }\n+}\n+\n fn parse_mod_items(p: parser, term: token::token,\n                    first_item_attrs: [ast::attribute]) -> ast::_mod {\n     // Shouldn't be any view items since we've already parsed an item attr\n@@ -2222,7 +2323,10 @@ fn parse_item(p: parser, attrs: [ast::attribute]) -> option<@ast::item> {\n         ret some(parse_item_impl(p, attrs));\n     } else if eat_word(p, \"resource\") {\n         ret some(parse_item_res(p, attrs));\n-    } else { ret none; }\n+    } else if eat_word(p, \"class\") {\n+        ret some(parse_item_class(p, attrs));\n+    }\n+else { ret none; }\n }\n \n // A type to distingush between the parsing of item attributes or syntax"}, {"sha": "f4a04c145d7c9784044a253ae0b0402ae85583e6", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f3343b35717edbfb88c7d1fae790e43d5d7cb732/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3343b35717edbfb88c7d1fae790e43d5d7cb732/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=f3343b35717edbfb88c7d1fae790e43d5d7cb732", "patch": "@@ -479,6 +479,52 @@ fn print_item(s: ps, &&item: @ast::item) {\n             bclose(s, item.span);\n         }\n       }\n+      ast::item_class(tps,items,ctor_decl,ctor_body) {\n+          head(s, \"class\");\n+          word_nbsp(s, item.ident);\n+          print_type_params(s, tps);\n+          bopen(s);\n+          hardbreak_if_not_bol(s);\n+          head(s, \"new\");\n+          print_fn_args_and_ret(s, ctor_decl);\n+          space(s.s);\n+          print_block(s, ctor_body);\n+          for ci in items {\n+                  /*\n+                     TODO: collect all private items and print them\n+                     in a single \"priv\" section\n+                   */\n+             hardbreak_if_not_bol(s);\n+             alt ci.node.privacy {\n+                ast::priv {\n+                    head(s, \"priv\");\n+                    bopen(s);\n+                    hardbreak_if_not_bol(s);\n+                }\n+                _ {}\n+             }\n+             alt *ci.node.decl {\n+                 ast::instance_var(nm, t, mt, _) {\n+                    word_nbsp(s, \"let\");\n+                    alt mt {\n+                      ast::class_mutable { word_nbsp(s, \"mutable\"); }\n+                      _ {}\n+                    }\n+                    word(s.s, nm);\n+                    word_nbsp(s, \":\");\n+                    print_type(s, t);\n+                    word(s.s, \";\");\n+                }\n+                ast::class_method(i) {\n+                    print_item(s, i);\n+                }\n+             }\n+             alt ci.node.privacy {\n+                 ast::priv { bclose(s, ci.span); }\n+                 _ {}\n+             }\n+          }\n+       }\n       ast::item_impl(tps, ifce, ty, methods) {\n         head(s, \"impl\");\n         word(s.s, item.ident);\n@@ -641,7 +687,6 @@ fn print_possibly_embedded_block_(s: ps, blk: ast::blk, embedded: embed_type,\n       ast::unsafe_blk { word(s.s, \"unsafe\"); }\n       ast::default_blk { }\n     }\n-\n     maybe_print_comment(s, blk.span.lo);\n     let ann_node = node_block(s, blk);\n     s.ann.pre(ann_node);"}, {"sha": "d868b7a97aa899bdbbd8e34729ab12335797c724", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f3343b35717edbfb88c7d1fae790e43d5d7cb732/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3343b35717edbfb88c7d1fae790e43d5d7cb732/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=f3343b35717edbfb88c7d1fae790e43d5d7cb732", "patch": "@@ -54,7 +54,8 @@ type visitor<E> =\n       visit_ty: fn@(@ty, E, vt<E>),\n       visit_ty_params: fn@([ty_param], E, vt<E>),\n       visit_constr: fn@(@path, span, node_id, E, vt<E>),\n-      visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id, E, vt<E>)};\n+      visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id, E, vt<E>),\n+      visit_class_item: fn@(span, privacy, @class_member, E, vt<E>)};\n \n fn default_visitor<E>() -> visitor<E> {\n     ret @{visit_mod: bind visit_mod::<E>(_, _, _, _, _),\n@@ -71,7 +72,8 @@ fn default_visitor<E>() -> visitor<E> {\n           visit_ty: bind skip_ty::<E>(_, _, _),\n           visit_ty_params: bind visit_ty_params::<E>(_, _, _),\n           visit_constr: bind visit_constr::<E>(_, _, _, _, _),\n-          visit_fn: bind visit_fn::<E>(_, _, _, _, _, _, _)};\n+          visit_fn: bind visit_fn::<E>(_, _, _, _, _, _, _),\n+          visit_class_item: bind visit_class_item::<E>(_,_,_,_,_)};\n }\n \n fn visit_crate<E>(c: crate, e: E, v: vt<E>) {\n@@ -135,6 +137,14 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n                        m.id, e, v);\n         }\n       }\n+      item_class(tps, members, ctor_decl, ctor_blk) {\n+          v.visit_ty_params(tps, e, v);\n+          for m in members {\n+             v.visit_class_item(m.span, m.node.privacy, m.node.decl, e, v);\n+          }\n+          visit_fn_decl(ctor_decl, e, v);\n+          v.visit_block(ctor_blk, e, v);\n+      }\n       item_iface(tps, methods) {\n         v.visit_ty_params(tps, e, v);\n         for m in methods {\n@@ -145,6 +155,18 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n     }\n }\n \n+fn visit_class_item<E>(_s: span, _p: privacy, cm: @class_member,\n+                       e:E, v:vt<E>) {\n+    alt *cm {\n+        instance_var(ident, t, mt, id) {\n+            v.visit_ty(t, e, v);\n+        }\n+        class_method(i) {\n+            v.visit_item(i, e, v);\n+        }\n+    }\n+}\n+\n fn skip_ty<E>(_t: @ty, _e: E, _v: vt<E>) {}\n \n fn visit_ty<E>(t: @ty, e: E, v: vt<E>) {\n@@ -387,7 +409,8 @@ type simple_visitor =\n       visit_ty: fn@(@ty),\n       visit_ty_params: fn@([ty_param]),\n       visit_constr: fn@(@path, span, node_id),\n-      visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id)};\n+      visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id),\n+      visit_class_item: fn@(span, privacy, @class_member)};\n \n fn simple_ignore_ty(_t: @ty) {}\n \n@@ -407,7 +430,8 @@ fn default_simple_visitor() -> simple_visitor {\n           visit_ty_params: fn@(_ps: [ty_param]) {},\n           visit_constr: fn@(_p: @path, _sp: span, _id: node_id) { },\n           visit_fn: fn@(_fk: fn_kind, _d: fn_decl, _b: blk, _sp: span,\n-                        _id: node_id) { }\n+                        _id: node_id) { },\n+          visit_class_item: fn@(_s: span, _p: privacy, _c: @class_member) {}\n          };\n }\n \n@@ -482,6 +506,12 @@ fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n     } else {\n         bind v_ty(v.visit_ty, _, _, _)\n     };\n+    fn v_class_item(f: fn@(span, privacy, @class_member),\n+                    s:span, p:privacy, cm: @class_member, &&e: (),\n+                    v: vt<()>) {\n+        f(s, p, cm);\n+        visit_class_item(s, p, cm, e, v);\n+    }\n     ret mk_vt(@{visit_mod: bind v_mod(v.visit_mod, _, _, _, _, _),\n                 visit_view_item: bind v_view_item(v.visit_view_item, _, _, _),\n                 visit_native_item:\n@@ -497,7 +527,9 @@ fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n                 visit_ty: visit_ty,\n                 visit_ty_params: bind v_ty_params(v.visit_ty_params, _, _, _),\n                 visit_constr: bind v_constr(v.visit_constr, _, _, _, _, _),\n-                visit_fn: bind v_fn(v.visit_fn, _, _, _, _, _, _, _)\n+                visit_fn: bind v_fn(v.visit_fn, _, _, _, _, _, _, _),\n+                visit_class_item: bind v_class_item(v.visit_class_item, _, _,\n+                                                    _, _, _)\n                });\n }\n "}, {"sha": "2d67bc2678547d8a37129cff372d0da35f3f4926", "filename": "src/test/run-pass/classes.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f3343b35717edbfb88c7d1fae790e43d5d7cb732/src%2Ftest%2Frun-pass%2Fclasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3343b35717edbfb88c7d1fae790e43d5d7cb732/src%2Ftest%2Frun-pass%2Fclasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses.rs?ref=f3343b35717edbfb88c7d1fae790e43d5d7cb732", "patch": "@@ -0,0 +1,29 @@\n+// xfail-test\n+class cat {\n+  priv {\n+    let mutable meows : uint;\n+    fn meow() {\n+      #error(\"Meow\");\n+      meows += 1;\n+      if meows % 5 == 0 {\n+          how_hungry += 1;\n+      }\n+    }\n+  }\n+\n+  let how_hungry : int;\n+\n+  new(in_x : uint, in_y : int) { meows = in_x; how_hungry = in_y; }\n+\n+  fn speak() { meow(); }\n+\n+  fn eat() {\n+    if how_hungry > 0 {\n+        #error(\"OM NOM NOM\");\n+        how_hungry -= 2;\n+    }\n+    else {\n+        #error(\"Not hungry!\");\n+    }\n+  }\n+}\n\\ No newline at end of file"}]}