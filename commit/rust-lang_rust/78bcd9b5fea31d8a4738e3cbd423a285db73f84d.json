{"sha": "78bcd9b5fea31d8a4738e3cbd423a285db73f84d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4YmNkOWI1ZmVhMzFkOGE0NzM4ZTNjYmQ0MjNhMjg1ZGI3M2Y4NGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-30T00:18:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-30T00:18:49Z"}, "message": "Auto merge of #50092 - abonander:issue-49934, r=petrochenkov\n\nWarn on pointless #[derive] in more places\n\nThis fixes the regression in #49934 and ensures that unused `#[derive]` invocations on statements, expressions and generic type parameters survive to trip the `unused_attributes` lint. There is a separate warning hardcoded for `#[derive]` on macro invocations since linting (even the early-lint pass) occurs after expansion. This also adds regression tests for some nodes that were already warning properly.\n\ncloses #49934", "tree": {"sha": "c6c50d0ee81c73fce60fca75f125b1dacc5ac7da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6c50d0ee81c73fce60fca75f125b1dacc5ac7da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78bcd9b5fea31d8a4738e3cbd423a285db73f84d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78bcd9b5fea31d8a4738e3cbd423a285db73f84d", "html_url": "https://github.com/rust-lang/rust/commit/78bcd9b5fea31d8a4738e3cbd423a285db73f84d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78bcd9b5fea31d8a4738e3cbd423a285db73f84d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "774a6a3c4b8d2743550c4b87e62fadfe3ed0323c", "url": "https://api.github.com/repos/rust-lang/rust/commits/774a6a3c4b8d2743550c4b87e62fadfe3ed0323c", "html_url": "https://github.com/rust-lang/rust/commit/774a6a3c4b8d2743550c4b87e62fadfe3ed0323c"}, {"sha": "f16d2ff7ec184de179f22322f1decd96f94ef8a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f16d2ff7ec184de179f22322f1decd96f94ef8a7", "html_url": "https://github.com/rust-lang/rust/commit/f16d2ff7ec184de179f22322f1decd96f94ef8a7"}], "stats": {"total": 200, "additions": 184, "deletions": 16}, "files": [{"sha": "3e5dcee113a4ed80e47af327c29306f228b84c95", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/78bcd9b5fea31d8a4738e3cbd423a285db73f84d/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78bcd9b5fea31d8a4738e3cbd423a285db73f84d/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=78bcd9b5fea31d8a4738e3cbd423a285db73f84d", "patch": "@@ -404,7 +404,7 @@ pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n     // Intentionally visiting the expr first - the initialization expr\n     // dominates the local's definition.\n     walk_list!(visitor, visit_expr, &local.init);\n-\n+    walk_list!(visitor, visit_attribute, local.attrs.iter());\n     visitor.visit_id(local.id);\n     visitor.visit_pat(&local.pat);\n     walk_list!(visitor, visit_ty, &local.ty);\n@@ -731,6 +731,7 @@ pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Generi\n             visitor.visit_name(ty_param.span, ty_param.name);\n             walk_list!(visitor, visit_ty_param_bound, &ty_param.bounds);\n             walk_list!(visitor, visit_ty, &ty_param.default);\n+            walk_list!(visitor, visit_attribute, ty_param.attrs.iter());\n         }\n     }\n }"}, {"sha": "3d20f922ac03db4a3fe0a577d5dc5ee7a0832e26", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78bcd9b5fea31d8a4738e3cbd423a285db73f84d/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78bcd9b5fea31d8a4738e3cbd423a285db73f84d/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=78bcd9b5fea31d8a4738e3cbd423a285db73f84d", "patch": "@@ -206,7 +206,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     // Resolves attribute and derive legacy macros from `#![plugin(..)]`.\n-    fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<ast::Attribute>)\n+    fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<ast::Attribute>, allow_derive: bool)\n                               -> Option<ast::Attribute> {\n         for i in 0..attrs.len() {\n             let name = unwrap_or!(attrs[i].name(), continue);\n@@ -227,6 +227,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n             }\n         }\n \n+        if !allow_derive { return None }\n+\n         // Check for legacy derives\n         for i in 0..attrs.len() {\n             let name = unwrap_or!(attrs[i].name(), continue);"}, {"sha": "b590a4a628608f790a6fec280301027ef33d2140", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78bcd9b5fea31d8a4738e3cbd423a285db73f84d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78bcd9b5fea31d8a4738e3cbd423a285db73f84d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=78bcd9b5fea31d8a4738e3cbd423a285db73f84d", "patch": "@@ -821,7 +821,7 @@ impl Stmt {\n \n     pub fn is_item(&self) -> bool {\n         match self.node {\n-            StmtKind::Local(_) => true,\n+            StmtKind::Item(_) => true,\n             _ => false,\n         }\n     }"}, {"sha": "3b76084f2fbe5cd7d8d2e22bafdab9fbcdf8f1eb", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/78bcd9b5fea31d8a4738e3cbd423a285db73f84d/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78bcd9b5fea31d8a4738e3cbd423a285db73f84d/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=78bcd9b5fea31d8a4738e3cbd423a285db73f84d", "patch": "@@ -118,6 +118,20 @@ impl Annotatable {\n         }\n     }\n \n+    pub fn expect_stmt(self) -> ast::Stmt {\n+        match self {\n+            Annotatable::Stmt(stmt) => stmt.into_inner(),\n+            _ => panic!(\"expected statement\"),\n+        }\n+    }\n+\n+    pub fn expect_expr(self) -> P<ast::Expr> {\n+        match self {\n+            Annotatable::Expr(expr) => expr,\n+            _ => panic!(\"expected expression\"),\n+        }\n+    }\n+\n     pub fn derive_allowed(&self) -> bool {\n         match *self {\n             Annotatable::Item(ref item) => match item.node {\n@@ -661,7 +675,9 @@ pub trait Resolver {\n \n     fn resolve_imports(&mut self);\n     // Resolves attribute and derive legacy macros from `#![plugin(..)]`.\n-    fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<Attribute>) -> Option<Attribute>;\n+    fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<Attribute>, allow_derive: bool)\n+                              -> Option<Attribute>;\n+\n     fn resolve_invoc(&mut self, invoc: &mut Invocation, scope: Mark, force: bool)\n                      -> Result<Option<Lrc<SyntaxExtension>>, Determinacy>;\n     fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n@@ -687,7 +703,8 @@ impl Resolver for DummyResolver {\n     fn add_builtin(&mut self, _ident: ast::Ident, _ext: Lrc<SyntaxExtension>) {}\n \n     fn resolve_imports(&mut self) {}\n-    fn find_legacy_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>) -> Option<Attribute> { None }\n+    fn find_legacy_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>, _allow_derive: bool)\n+                              -> Option<Attribute> { None }\n     fn resolve_invoc(&mut self, _invoc: &mut Invocation, _scope: Mark, _force: bool)\n                      -> Result<Option<Lrc<SyntaxExtension>>, Determinacy> {\n         Err(Determinacy::Determined)"}, {"sha": "2f3b35c33f3ec33557d48dc426c17d600da8f6f6", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 57, "deletions": 11, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/78bcd9b5fea31d8a4738e3cbd423a285db73f84d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78bcd9b5fea31d8a4738e3cbd423a285db73f84d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=78bcd9b5fea31d8a4738e3cbd423a285db73f84d", "patch": "@@ -143,7 +143,7 @@ impl ExpansionKind {\n     }\n \n     fn expect_from_annotatables<I: IntoIterator<Item = Annotatable>>(self, items: I) -> Expansion {\n-        let items = items.into_iter();\n+        let mut items = items.into_iter();\n         match self {\n             ExpansionKind::Items =>\n                 Expansion::Items(items.map(Annotatable::expect_item).collect()),\n@@ -153,7 +153,14 @@ impl ExpansionKind {\n                 Expansion::TraitItems(items.map(Annotatable::expect_trait_item).collect()),\n             ExpansionKind::ForeignItems =>\n                 Expansion::ForeignItems(items.map(Annotatable::expect_foreign_item).collect()),\n-            _ => unreachable!(),\n+            ExpansionKind::Stmts => Expansion::Stmts(items.map(Annotatable::expect_stmt).collect()),\n+            ExpansionKind::Expr => Expansion::Expr(\n+                items.next().expect(\"expected exactly one expression\").expect_expr()\n+            ),\n+            ExpansionKind::OptExpr =>\n+                Expansion::OptExpr(items.next().map(Annotatable::expect_expr)),\n+            ExpansionKind::Pat | ExpansionKind::Ty =>\n+                panic!(\"patterns and types aren't annotatable\"),\n         }\n     }\n }\n@@ -956,14 +963,15 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         self.collect(kind, InvocationKind::Attr { attr, traits, item })\n     }\n \n-    // If `item` is an attr invocation, remove and return the macro attribute.\n+    /// If `item` is an attr invocation, remove and return the macro attribute and derive traits.\n     fn classify_item<T>(&mut self, mut item: T) -> (Option<ast::Attribute>, Vec<Path>, T)\n         where T: HasAttrs,\n     {\n         let (mut attr, mut traits) = (None, Vec::new());\n \n         item = item.map_attrs(|mut attrs| {\n-            if let Some(legacy_attr_invoc) = self.cx.resolver.find_legacy_attr_invoc(&mut attrs) {\n+            if let Some(legacy_attr_invoc) = self.cx.resolver.find_legacy_attr_invoc(&mut attrs,\n+                                                                                     true) {\n                 attr = Some(legacy_attr_invoc);\n                 return attrs;\n             }\n@@ -978,6 +986,28 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         (attr, traits, item)\n     }\n \n+    /// Alternative of `classify_item()` that ignores `#[derive]` so invocations fallthrough\n+    /// to the unused-attributes lint (making it an error on statements and expressions\n+    /// is a breaking change)\n+    fn classify_nonitem<T: HasAttrs>(&mut self, mut item: T) -> (Option<ast::Attribute>, T) {\n+        let mut attr = None;\n+\n+        item = item.map_attrs(|mut attrs| {\n+            if let Some(legacy_attr_invoc) = self.cx.resolver.find_legacy_attr_invoc(&mut attrs,\n+                                                                                     false) {\n+                attr = Some(legacy_attr_invoc);\n+                return attrs;\n+            }\n+\n+            if self.cx.ecfg.proc_macro_enabled() {\n+                attr = find_attr_invoc(&mut attrs);\n+            }\n+            attrs\n+        });\n+\n+        (attr, item)\n+    }\n+\n     fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n         self.cfg.configure(node)\n     }\n@@ -988,6 +1018,13 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         let features = self.cx.ecfg.features.unwrap();\n         for attr in attrs.iter() {\n             feature_gate::check_attribute(attr, self.cx.parse_sess, features);\n+\n+            // macros are expanded before any lint passes so this warning has to be hardcoded\n+            if attr.path == \"derive\" {\n+                self.cx.struct_span_warn(attr.span, \"`#[derive]` does nothing on macro invocations\")\n+                    .note(\"this may become a hard error in a future release\")\n+                    .emit();\n+            }\n         }\n     }\n \n@@ -1008,15 +1045,16 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         let mut expr = self.cfg.configure_expr(expr).into_inner();\n         expr.node = self.cfg.configure_expr_kind(expr.node);\n \n-        let (attr, derives, expr) = self.classify_item(expr);\n+        // ignore derives so they remain unused\n+        let (attr, expr) = self.classify_nonitem(expr);\n \n-        if attr.is_some() || !derives.is_empty() {\n+        if attr.is_some() {\n             // collect the invoc regardless of whether or not attributes are permitted here\n             // expansion will eat the attribute so it won't error later\n             attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n \n             // ExpansionKind::Expr requires the macro to emit an expression\n-            return self.collect_attr(attr, derives, Annotatable::Expr(P(expr)), ExpansionKind::Expr)\n+            return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)), ExpansionKind::Expr)\n                 .make_expr();\n         }\n \n@@ -1032,12 +1070,13 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         let mut expr = configure!(self, expr).into_inner();\n         expr.node = self.cfg.configure_expr_kind(expr.node);\n \n-        let (attr, derives, expr) = self.classify_item(expr);\n+        // ignore derives so they remain unused\n+        let (attr, expr) = self.classify_nonitem(expr);\n \n-        if attr.is_some() || !derives.is_empty() {\n+        if attr.is_some() {\n             attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n \n-            return self.collect_attr(attr, derives, Annotatable::Expr(P(expr)),\n+            return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)),\n                                      ExpansionKind::OptExpr)\n                 .make_opt_expr();\n         }\n@@ -1071,7 +1110,14 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n         // we'll expand attributes on expressions separately\n         if !stmt.is_expr() {\n-            let (attr, derives, stmt_) = self.classify_item(stmt);\n+            let (attr, derives, stmt_) = if stmt.is_item() {\n+                self.classify_item(stmt)\n+            } else {\n+                // ignore derives on non-item statements so it falls through\n+                // to the unused-attributes lint\n+                let (attr, stmt) = self.classify_nonitem(stmt);\n+                (attr, vec![], stmt)\n+            };\n \n             if attr.is_some() || !derives.is_empty() {\n                 return self.collect_attr(attr, derives,"}, {"sha": "3e30e7a6450fc86dfa1d381779f8cb974cb757f2", "filename": "src/test/ui/issue-49934.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/78bcd9b5fea31d8a4738e3cbd423a285db73f84d/src%2Ftest%2Fui%2Fissue-49934.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78bcd9b5fea31d8a4738e3cbd423a285db73f84d/src%2Ftest%2Fui%2Fissue-49934.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-49934.rs?ref=78bcd9b5fea31d8a4738e3cbd423a285db73f84d", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+\n+#![feature(stmt_expr_attributes)]\n+#![warn(unused_attributes)] //~ NOTE lint level defined here\n+\n+fn foo<#[derive(Debug)] T>() { //~ WARN unused attribute\n+    match 0 {\n+        #[derive(Debug)] //~ WARN unused attribute\n+        _ => (),\n+    }\n+}\n+\n+fn main() {\n+    // fold_stmt (Item)\n+    #[allow(dead_code)]\n+    #[derive(Debug)] // should not warn\n+    struct Foo;\n+\n+    // fold_stmt (Mac)\n+    #[derive(Debug)]\n+    //~^ WARN `#[derive]` does nothing on macro invocations\n+    //~| NOTE this may become a hard error in a future release\n+    println!(\"Hello, world!\");\n+\n+    // fold_stmt (Semi)\n+    #[derive(Debug)] //~ WARN unused attribute\n+    \"Hello, world!\";\n+\n+    // fold_stmt (Local)\n+    #[derive(Debug)] //~ WARN unused attribute\n+    let _ = \"Hello, world!\";\n+\n+    // fold_expr\n+    let _ = #[derive(Debug)] \"Hello, world!\";\n+    //~^ WARN unused attribute\n+\n+    let _ = [\n+        // fold_opt_expr\n+        #[derive(Debug)] //~ WARN unused attribute\n+        \"Hello, world!\"\n+    ];\n+}"}, {"sha": "298230b8b29f74a29ff2a4a335dc64f1e74fc0fd", "filename": "src/test/ui/issue-49934.stderr", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/78bcd9b5fea31d8a4738e3cbd423a285db73f84d/src%2Ftest%2Fui%2Fissue-49934.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78bcd9b5fea31d8a4738e3cbd423a285db73f84d/src%2Ftest%2Fui%2Fissue-49934.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-49934.stderr?ref=78bcd9b5fea31d8a4738e3cbd423a285db73f84d", "patch": "@@ -0,0 +1,50 @@\n+warning: `#[derive]` does nothing on macro invocations\n+  --> $DIR/issue-49934.rs:30:5\n+   |\n+LL |     #[derive(Debug)]\n+   |     ^^^^^^^^^^^^^^^^\n+   |\n+   = note: this may become a hard error in a future release\n+\n+warning: unused attribute\n+  --> $DIR/issue-49934.rs:16:8\n+   |\n+LL | fn foo<#[derive(Debug)] T>() { //~ WARN unused attribute\n+   |        ^^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/issue-49934.rs:14:9\n+   |\n+LL | #![warn(unused_attributes)] //~ NOTE lint level defined here\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+warning: unused attribute\n+  --> $DIR/issue-49934.rs:18:9\n+   |\n+LL |         #[derive(Debug)] //~ WARN unused attribute\n+   |         ^^^^^^^^^^^^^^^^\n+\n+warning: unused attribute\n+  --> $DIR/issue-49934.rs:36:5\n+   |\n+LL |     #[derive(Debug)] //~ WARN unused attribute\n+   |     ^^^^^^^^^^^^^^^^\n+\n+warning: unused attribute\n+  --> $DIR/issue-49934.rs:40:5\n+   |\n+LL |     #[derive(Debug)] //~ WARN unused attribute\n+   |     ^^^^^^^^^^^^^^^^\n+\n+warning: unused attribute\n+  --> $DIR/issue-49934.rs:44:13\n+   |\n+LL |     let _ = #[derive(Debug)] \"Hello, world!\";\n+   |             ^^^^^^^^^^^^^^^^\n+\n+warning: unused attribute\n+  --> $DIR/issue-49934.rs:49:9\n+   |\n+LL |         #[derive(Debug)] //~ WARN unused attribute\n+   |         ^^^^^^^^^^^^^^^^\n+"}]}