{"sha": "37a7521ef93b2e2d7a4cd04df38929d841b8ffcc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3YTc1MjFlZjkzYjJlMmQ3YTRjZDA0ZGYzODkyOWQ4NDFiOGZmY2M=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-10-08T23:31:06Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:43:55Z"}, "message": "rustc: unpack scalar newtype layout ABIs.", "tree": {"sha": "30287acb7166ed268a6a3e3f911f5d536cacc1c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30287acb7166ed268a6a3e3f911f5d536cacc1c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37a7521ef93b2e2d7a4cd04df38929d841b8ffcc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37a7521ef93b2e2d7a4cd04df38929d841b8ffcc", "html_url": "https://github.com/rust-lang/rust/commit/37a7521ef93b2e2d7a4cd04df38929d841b8ffcc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37a7521ef93b2e2d7a4cd04df38929d841b8ffcc/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b8697241f3988bfa55b9f17d60732dab0e3d75d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b8697241f3988bfa55b9f17d60732dab0e3d75d", "html_url": "https://github.com/rust-lang/rust/commit/0b8697241f3988bfa55b9f17d60732dab0e3d75d"}], "stats": {"total": 179, "additions": 129, "deletions": 50}, "files": [{"sha": "3bf711d3e232f062c91d36f3ae51f7406e6b11f7", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 36, "deletions": 14, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/37a7521ef93b2e2d7a4cd04df38929d841b8ffcc/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a7521ef93b2e2d7a4cd04df38929d841b8ffcc/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=37a7521ef93b2e2d7a4cd04df38929d841b8ffcc", "patch": "@@ -1078,6 +1078,30 @@ impl<'a, 'tcx> CachedLayout {\n                 packed\n             };\n \n+            // Unpack newtype ABIs.\n+            if sized && optimize && size.bytes() > 0 {\n+                // All but one field must be ZSTs, and so they all start at 0.\n+                if offsets.iter().all(|o| o.bytes() == 0) {\n+                    let mut non_zst_fields = fields.iter().filter(|f| !f.is_zst());\n+\n+                    // We have exactly one non-ZST field.\n+                    match (non_zst_fields.next(), non_zst_fields.next()) {\n+                        (Some(field), None) => {\n+                            // Field size match and it has a scalar ABI.\n+                            if size == field.size {\n+                                match field.abi {\n+                                    Abi::Scalar(_) => {\n+                                        abi = field.abi.clone();\n+                                    }\n+                                    _ => {}\n+                                }\n+                            }\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+\n             // Look for a scalar pair, as an ABI optimization.\n             // FIXME(eddyb) ignore extra ZST fields and field ordering.\n             if sized && !packed && fields.len() == 2 {\n@@ -1424,6 +1448,18 @@ impl<'a, 'tcx> CachedLayout {\n \n                     let mut st = univariant_uninterned(&variants[v], &def.repr, kind)?;\n                     st.variants = Variants::Single { index: v };\n+                    // Exclude 0 from the range of a newtype ABI NonZero<T>.\n+                    if Some(def.did) == cx.tcx().lang_items().non_zero() {\n+                        match st.abi {\n+                            Abi::Scalar(ref mut scalar) |\n+                            Abi::ScalarPair(ref mut scalar, _) => {\n+                                if scalar.valid_range.start == 0 {\n+                                    scalar.valid_range.start = 1;\n+                                }\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n                     return Ok(tcx.intern_layout(st));\n                 }\n \n@@ -2284,20 +2320,6 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n             };\n         }\n \n-        // Is this the NonZero lang item wrapping a pointer or integer type?\n-        if let ty::TyAdt(def, _) = self.ty.sty {\n-            if Some(def.did) == cx.tcx().lang_items().non_zero() {\n-                let field = self.field(cx, 0)?;\n-                let offset = self.fields.offset(0);\n-                if let Abi::Scalar(Scalar { value, ref valid_range }) = field.abi {\n-                    return Ok(Some((offset, Scalar {\n-                        value,\n-                        valid_range: 0..=valid_range.end\n-                    }, 0)));\n-                }\n-            }\n-        }\n-\n         // Perhaps one of the fields is non-zero, let's recurse and find out.\n         if let FieldPlacement::Union(_) = self.fields {\n             // Only Rust enums have safe-to-inspect fields"}, {"sha": "223379527c989aee07d5a0409d7a6ea034201228", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37a7521ef93b2e2d7a4cd04df38929d841b8ffcc/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a7521ef93b2e2d7a4cd04df38929d841b8ffcc/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=37a7521ef93b2e2d7a4cd04df38929d841b8ffcc", "patch": "@@ -139,7 +139,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n         let ccx = self.cx.ccx;\n \n         if let mir::Lvalue::Projection(ref proj) = *lvalue {\n-            // Allow uses of projections that are ZSTs or from immediate scalar fields.\n+            // Allow uses of projections that are ZSTs or from scalar fields.\n             if let LvalueContext::Consume = context {\n                 let base_ty = proj.base.ty(self.cx.mir, ccx.tcx());\n                 let base_ty = self.cx.monomorphize(&base_ty);\n@@ -153,7 +153,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n \n                 if let mir::ProjectionElem::Field(..) = proj.elem {\n                     let layout = ccx.layout_of(base_ty.to_ty(ccx.tcx()));\n-                    if layout.is_llvm_scalar_pair() {\n+                    if layout.is_llvm_immediate() || layout.is_llvm_scalar_pair() {\n                         // Recurse as a `Consume` instead of `Projection`,\n                         // potentially stopping at non-operand projections,\n                         // which would trigger `mark_as_lvalue` on locals."}, {"sha": "6811861499d7e961f83d13712d619cb7373c6ff8", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37a7521ef93b2e2d7a4cd04df38929d841b8ffcc/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a7521ef93b2e2d7a4cd04df38929d841b8ffcc/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=37a7521ef93b2e2d7a4cd04df38929d841b8ffcc", "patch": "@@ -700,19 +700,21 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     let elem = if field.is_zst() {\n                         C_undef(field.llvm_type(bcx.ccx))\n                     } else {\n-                        bcx.extract_value(llval, tuple.layout.llvm_field_index(i))\n+                        // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n+                        bcx.bitcast(llval, field.immediate_llvm_type(bcx.ccx))\n                     };\n                     // If the tuple is immediate, the elements are as well\n                     let op = OperandRef {\n-                        val: Immediate(base::to_immediate(bcx, elem, field)),\n+                        val: Immediate(elem),\n                         layout: field,\n                     };\n                     self.trans_argument(bcx, op, llargs, &args[i]);\n                 }\n             }\n             Pair(a, b) => {\n                 let elems = [a, b];\n-                for i in 0..tuple.layout.fields.count() {\n+                assert_eq!(tuple.layout.fields.count(), 2);\n+                for i in 0..2 {\n                     // Pair is always made up of immediates\n                     let op = OperandRef {\n                         val: Immediate(elems[i]),"}, {"sha": "f223227cd72b4c04564a99c59bf4edc9a1b24a1e", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 43, "deletions": 11, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/37a7521ef93b2e2d7a4cd04df38929d841b8ffcc/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a7521ef93b2e2d7a4cd04df38929d841b8ffcc/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=37a7521ef93b2e2d7a4cd04df38929d841b8ffcc", "patch": "@@ -118,10 +118,27 @@ impl<'a, 'tcx> Const<'tcx> {\n \n     fn get_field(&self, ccx: &CrateContext<'a, 'tcx>, i: usize) -> ValueRef {\n         let layout = ccx.layout_of(self.ty);\n-        if let layout::Abi::ScalarPair(..) = layout.abi {\n-            const_get_elt(self.llval, i as u64)\n-        } else {\n-            const_get_elt(self.llval, layout.llvm_field_index(i))\n+        let field = layout.field(ccx, i);\n+        if field.is_zst() {\n+            return C_undef(field.immediate_llvm_type(ccx));\n+        }\n+        match layout.abi {\n+            layout::Abi::Scalar(_) => self.llval,\n+            layout::Abi::ScalarPair(ref a, ref b) => {\n+                let offset = layout.fields.offset(i);\n+                if offset.bytes() == 0 {\n+                    assert_eq!(field.size, a.value.size(ccx));\n+                    const_get_elt(self.llval, 0)\n+                } else {\n+                    assert_eq!(offset, a.value.size(ccx)\n+                        .abi_align(b.value.align(ccx)));\n+                    assert_eq!(field.size, b.value.size(ccx));\n+                    const_get_elt(self.llval, 1)\n+                }\n+            }\n+            _ => {\n+                const_get_elt(self.llval, layout.llvm_field_index(i))\n+            }\n         }\n     }\n \n@@ -159,7 +176,8 @@ impl<'a, 'tcx> Const<'tcx> {\n             // a constant LLVM global and cast its address if necessary.\n             let align = ccx.align_of(self.ty);\n             let ptr = consts::addr_of(ccx, self.llval, align, \"const\");\n-            OperandValue::Ref(consts::ptrcast(ptr, llty.ptr_to()), Alignment::AbiAligned)\n+            OperandValue::Ref(consts::ptrcast(ptr, layout.llvm_type(ccx).ptr_to()),\n+                              Alignment::AbiAligned)\n         };\n \n         OperandRef {\n@@ -1179,12 +1197,26 @@ fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 -> Const<'tcx> {\n     assert_eq!(vals.len(), layout.fields.count());\n \n-    if let layout::Abi::ScalarPair(..) = layout.abi {\n-        assert_eq!(vals.len(), 2);\n-        return Const::new(C_struct(ccx, &[\n-            vals[0].llval,\n-            vals[1].llval,\n-        ], false), layout.ty);\n+    match layout.abi {\n+        layout::Abi::Scalar(_) |\n+        layout::Abi::ScalarPair(..) if discr.is_none() => {\n+            let mut non_zst_fields = vals.iter().enumerate().map(|(i, f)| {\n+                (f, layout.fields.offset(i))\n+            }).filter(|&(f, _)| !ccx.layout_of(f.ty).is_zst());\n+            match (non_zst_fields.next(), non_zst_fields.next()) {\n+                (Some((x, offset)), None) if offset.bytes() == 0 => {\n+                    return Const::new(x.llval, layout.ty);\n+                }\n+                (Some((a, a_offset)), Some((b, _))) if a_offset.bytes() == 0 => {\n+                    return Const::new(C_struct(ccx, &[a.llval, b.llval], false), layout.ty);\n+                }\n+                (Some((a, _)), Some((b, b_offset))) if b_offset.bytes() == 0 => {\n+                    return Const::new(C_struct(ccx, &[b.llval, a.llval], false), layout.ty);\n+                }\n+                _ => {}\n+            }\n+        }\n+        _ => {}\n     }\n \n     // offset of current value"}, {"sha": "7826d998df33a40e365f0a302dbd21759700183c", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 38, "deletions": 15, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/37a7521ef93b2e2d7a4cd04df38929d841b8ffcc/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a7521ef93b2e2d7a4cd04df38929d841b8ffcc/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=37a7521ef93b2e2d7a4cd04df38929d841b8ffcc", "patch": "@@ -10,12 +10,12 @@\n \n use llvm::ValueRef;\n use rustc::ty;\n-use rustc::ty::layout::{LayoutOf, TyLayout};\n+use rustc::ty::layout::{self, LayoutOf, TyLayout};\n use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n \n use base;\n-use common::{CrateContext, C_undef};\n+use common::{CrateContext, C_undef, C_usize};\n use builder::Builder;\n use value::Value;\n use type_of::LayoutLlvmExt;\n@@ -207,24 +207,47 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             if let mir::ProjectionElem::Field(ref f, _) = proj.elem {\n                 if let Some(o) = self.maybe_trans_consume_direct(bcx, &proj.base) {\n                     let layout = o.layout.field(bcx.ccx, f.index());\n+                    let offset = o.layout.fields.offset(f.index());\n \n                     // Handled in `trans_consume`.\n                     assert!(!layout.is_zst());\n \n-                    match o.val {\n-                        OperandValue::Pair(a, b) => {\n-                            let llval = [a, b][f.index()];\n-                            // HACK(eddyb) have to bitcast pointers\n-                            // until LLVM removes pointee types.\n-                            let llval = bcx.bitcast(llval,\n-                                layout.immediate_llvm_type(bcx.ccx));\n-                            return Some(OperandRef {\n-                                val: OperandValue::Immediate(llval),\n-                                layout\n-                            });\n+                    // Offset has to match a scalar component.\n+                    let llval = match (o.val, &o.layout.abi) {\n+                        (OperandValue::Immediate(llval),\n+                         &layout::Abi::Scalar(ref scalar)) => {\n+                            assert_eq!(offset.bytes(), 0);\n+                            assert_eq!(layout.size, scalar.value.size(bcx.ccx));\n+                            llval\n                         }\n-                        _ => {}\n-                    }\n+                        (OperandValue::Pair(a_llval, b_llval),\n+                         &layout::Abi::ScalarPair(ref a, ref b)) => {\n+                            if offset.bytes() == 0 {\n+                                assert_eq!(layout.size, a.value.size(bcx.ccx));\n+                                a_llval\n+                            } else {\n+                                assert_eq!(offset, a.value.size(bcx.ccx)\n+                                    .abi_align(b.value.align(bcx.ccx)));\n+                                assert_eq!(layout.size, b.value.size(bcx.ccx));\n+                                b_llval\n+                            }\n+                        }\n+\n+                        // `#[repr(simd)]` types are also immediate.\n+                        (OperandValue::Immediate(llval),\n+                         &layout::Abi::Vector) => {\n+                            bcx.extract_element(llval, C_usize(bcx.ccx, f.index() as u64))\n+                        }\n+\n+                        _ => return None\n+                    };\n+\n+                    // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n+                    let llval = bcx.bitcast(llval, layout.immediate_llvm_type(bcx.ccx));\n+                    return Some(OperandRef {\n+                        val: OperandValue::Immediate(llval),\n+                        layout\n+                    });\n                 }\n             }\n         }"}, {"sha": "f96c104b265f9383aa26ca70b20684d2f0e9da2e", "filename": "src/test/codegen/function-arguments.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37a7521ef93b2e2d7a4cd04df38929d841b8ffcc/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a7521ef93b2e2d7a4cd04df38929d841b8ffcc/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs?ref=37a7521ef93b2e2d7a4cd04df38929d841b8ffcc", "patch": "@@ -46,13 +46,13 @@ pub fn static_borrow(_: &'static i32) {\n pub fn named_borrow<'r>(_: &'r i32) {\n }\n \n-// CHECK: @unsafe_borrow(%UnsafeInner* dereferenceable(2) %arg0)\n+// CHECK: @unsafe_borrow(i16* dereferenceable(2) %arg0)\n // unsafe interior means this isn't actually readonly and there may be aliases ...\n #[no_mangle]\n pub fn unsafe_borrow(_: &UnsafeInner) {\n }\n \n-// CHECK: @mutable_unsafe_borrow(%UnsafeInner* dereferenceable(2) %arg0)\n+// CHECK: @mutable_unsafe_borrow(i16* dereferenceable(2) %arg0)\n // ... unless this is a mutable borrow, those never alias\n // ... except that there's this LLVM bug that forces us to not use noalias, see #29485\n #[no_mangle]\n@@ -110,7 +110,7 @@ pub fn slice(_: &[u8]) {\n pub fn mutable_slice(_: &mut [u8]) {\n }\n \n-// CHECK: @unsafe_slice([0 x %UnsafeInner]* nonnull %arg0.0, [[USIZE]] %arg0.1)\n+// CHECK: @unsafe_slice([0 x i16]* nonnull %arg0.0, [[USIZE]] %arg0.1)\n // unsafe interior means this isn't actually readonly and there may be aliases ...\n #[no_mangle]\n pub fn unsafe_slice(_: &[UnsafeInner]) {"}, {"sha": "e5ec17385455e24d59089e7ea7a887e48d7ea329", "filename": "src/test/codegen/issue-32031.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37a7521ef93b2e2d7a4cd04df38929d841b8ffcc/src%2Ftest%2Fcodegen%2Fissue-32031.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a7521ef93b2e2d7a4cd04df38929d841b8ffcc/src%2Ftest%2Fcodegen%2Fissue-32031.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-32031.rs?ref=37a7521ef93b2e2d7a4cd04df38929d841b8ffcc", "patch": "@@ -15,7 +15,7 @@\n #[no_mangle]\n pub struct F32(f32);\n \n-// CHECK: define float @add_newtype_f32(float, float)\n+// CHECK: define float @add_newtype_f32(float %a, float %b)\n #[inline(never)]\n #[no_mangle]\n pub fn add_newtype_f32(a: F32, b: F32) -> F32 {\n@@ -25,7 +25,7 @@ pub fn add_newtype_f32(a: F32, b: F32) -> F32 {\n #[no_mangle]\n pub struct F64(f64);\n \n-// CHECK: define double @add_newtype_f64(double, double)\n+// CHECK: define double @add_newtype_f64(double %a, double %b)\n #[inline(never)]\n #[no_mangle]\n pub fn add_newtype_f64(a: F64, b: F64) -> F64 {"}]}