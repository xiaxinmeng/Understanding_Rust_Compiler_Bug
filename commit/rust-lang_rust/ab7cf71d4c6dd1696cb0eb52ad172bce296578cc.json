{"sha": "ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiN2NmNzFkNGM2ZGQxNjk2Y2IwZWI1MmFkMTcyYmNlMjk2NTc4Y2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-27T06:53:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-27T06:53:53Z"}, "message": "Auto merge of #61035 - nnethercote:avoid-more-symbol-interning, r=petrochenkov\n\nAvoid more symbol interning\n\nr? @petrochenkov", "tree": {"sha": "48c001b66e3a12c491ca5e20b8fb63d303c08636", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48c001b66e3a12c491ca5e20b8fb63d303c08636"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "html_url": "https://github.com/rust-lang/rust/commit/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be10e6277b738df3cc8ac316872227879118cc64", "url": "https://api.github.com/repos/rust-lang/rust/commits/be10e6277b738df3cc8ac316872227879118cc64", "html_url": "https://github.com/rust-lang/rust/commit/be10e6277b738df3cc8ac316872227879118cc64"}, {"sha": "33a3206dc5e7f267617a625d8b31ccc3250cdc1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/33a3206dc5e7f267617a625d8b31ccc3250cdc1e", "html_url": "https://github.com/rust-lang/rust/commit/33a3206dc5e7f267617a625d8b31ccc3250cdc1e"}], "stats": {"total": 527, "additions": 299, "deletions": 228}, "files": [{"sha": "d5e2969e9649a59fb36efba127c8c5181d64da84", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -3009,6 +3009,7 @@ dependencies = [\n  \"rustc_cratesio_shim 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"serialize 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n ]\n \n [[package]]"}, {"sha": "1d51e7cd74222085133f510bbc60c6a90d1b88a4", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -1145,9 +1145,7 @@ impl<'a> LoweringContext<'a> {\n         let unstable_span = self.sess.source_map().mark_span_with_reason(\n             CompilerDesugaringKind::Async,\n             span,\n-            Some(vec![\n-                Symbol::intern(\"gen_future\"),\n-            ].into()),\n+            Some(vec![sym::gen_future].into()),\n         );\n         let gen_future = self.expr_std_path(\n             unstable_span, &[sym::future, sym::from_generator], None, ThinVec::new());\n@@ -2958,7 +2956,7 @@ impl<'a> LoweringContext<'a> {\n             ident: match f.ident {\n                 Some(ident) => ident,\n                 // FIXME(jseyfried): positional field hygiene\n-                None => Ident::new(Symbol::intern(&index.to_string()), f.span),\n+                None => Ident::new(sym::integer(index), f.span),\n             },\n             vis: self.lower_visibility(&f.vis, None),\n             ty: self.lower_ty(&f.ty, ImplTraitContext::disallowed()),\n@@ -4177,9 +4175,7 @@ impl<'a> LoweringContext<'a> {\n                     let unstable_span = this.sess.source_map().mark_span_with_reason(\n                         CompilerDesugaringKind::TryBlock,\n                         body.span,\n-                        Some(vec![\n-                            Symbol::intern(\"try_trait\"),\n-                        ].into()),\n+                        Some(vec![sym::try_trait].into()),\n                     );\n                     let mut block = this.lower_block(body, true).into_inner();\n                     let tail = block.expr.take().map_or_else("}, {"sha": "bde27c71f9a6d242f68bcd5f8c4c2b08b912ac85", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -5,8 +5,7 @@ use crate::session::CrateDisambiguator;\n use syntax::ast::*;\n use syntax::ext::hygiene::Mark;\n use syntax::visit;\n-use syntax::symbol::kw;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{kw, sym};\n use syntax::parse::token::{self, Token};\n use syntax_pos::Span;\n \n@@ -221,7 +220,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                           _: &'a Generics, _: NodeId, _: Span) {\n         for (index, field) in data.fields().iter().enumerate() {\n             let name = field.ident.map(|ident| ident.name)\n-                .unwrap_or_else(|| Symbol::intern(&index.to_string()));\n+                .unwrap_or_else(|| sym::integer(index));\n             let def = self.create_def(field.id,\n                                       DefPathData::ValueNs(name.as_interned_str()),\n                                       field.span);"}, {"sha": "034ef32aafe016cff8fec1816a9b735cfabcf580", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -210,8 +210,8 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n     attrs.iter().find_map(|attr| Some(match attr {\n         _ if attr.check_name(sym::lang) => (attr.value_str()?, attr.span),\n-        _ if attr.check_name(sym::panic_handler) => (Symbol::intern(\"panic_impl\"), attr.span),\n-        _ if attr.check_name(sym::alloc_error_handler) => (Symbol::intern(\"oom\"), attr.span),\n+        _ if attr.check_name(sym::panic_handler) => (sym::panic_impl, attr.span),\n+        _ if attr.check_name(sym::alloc_error_handler) => (sym::oom, attr.span),\n         _ => return None,\n     }))\n }"}, {"sha": "6af43b04a7d60646368b1e1c97ffa655d03facb9", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -1316,7 +1316,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n                 for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n                     let subpat_ty = self.pat_ty_adjusted(&subpat)?; // see (*2)\n-                    let interior = InteriorField(FieldIndex(i, Name::intern(&i.to_string())));\n+                    let interior = InteriorField(FieldIndex(i, sym::integer(i)));\n                     let subcmt = Rc::new(\n                         self.cat_imm_interior(pat, cmt.clone(), subpat_ty, interior));\n                     self.cat_pattern_(subcmt, &subpat, op)?;\n@@ -1363,7 +1363,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 };\n                 for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n                     let subpat_ty = self.pat_ty_adjusted(&subpat)?; // see (*2)\n-                    let interior = InteriorField(FieldIndex(i, Name::intern(&i.to_string())));\n+                    let interior = InteriorField(FieldIndex(i, sym::integer(i)));\n                     let subcmt = Rc::new(\n                         self.cat_imm_interior(pat, cmt.clone(), subpat_ty, interior));\n                     self.cat_pattern_(subcmt, &subpat, op)?;"}, {"sha": "66fa9a5c6f1060aea38c59bcfd7e8263103404c3", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -437,7 +437,7 @@ impl<'a, 'tcx> Index<'tcx> {\n                         reason: Some(Symbol::intern(reason)),\n                         issue: 27812,\n                     },\n-                    feature: Symbol::intern(\"rustc_private\"),\n+                    feature: sym::rustc_private,\n                     rustc_depr: None,\n                     const_stability: None,\n                     promotable: false,\n@@ -880,7 +880,7 @@ pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // FIXME: only remove `libc` when `stdbuild` is active.\n     // FIXME: remove special casing for `test`.\n     remaining_lib_features.remove(&Symbol::intern(\"libc\"));\n-    remaining_lib_features.remove(&Symbol::intern(\"test\"));\n+    remaining_lib_features.remove(&sym::test);\n \n     let check_features =\n         |remaining_lib_features: &mut FxHashMap<_, _>, defined_features: &[_]| {"}, {"sha": "49cd3eff21a6c4ddb7035ffe534bb8afaec2aff3", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -19,7 +19,7 @@ use syntax::source_map::{FileName, FilePathMapping};\n use syntax::edition::{Edition, EDITION_NAME_LIST, DEFAULT_EDITION};\n use syntax::parse::token;\n use syntax::parse;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{sym, Symbol};\n use syntax::feature_gate::UnstableFeatures;\n use errors::emitter::HumanReadableErrorType;\n \n@@ -1503,31 +1503,31 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n         Some(Symbol::intern(vendor)),\n     ));\n     if sess.target.target.options.has_elf_tls {\n-        ret.insert((Symbol::intern(\"target_thread_local\"), None));\n+        ret.insert((sym::target_thread_local, None));\n     }\n     for &i in &[8, 16, 32, 64, 128] {\n         if i >= min_atomic_width && i <= max_atomic_width {\n             let s = i.to_string();\n             ret.insert((\n-                Symbol::intern(\"target_has_atomic\"),\n+                sym::target_has_atomic,\n                 Some(Symbol::intern(&s)),\n             ));\n             if &s == wordsz {\n                 ret.insert((\n-                    Symbol::intern(\"target_has_atomic\"),\n+                    sym::target_has_atomic,\n                     Some(Symbol::intern(\"ptr\")),\n                 ));\n             }\n         }\n     }\n     if atomic_cas {\n-        ret.insert((Symbol::intern(\"target_has_atomic\"), Some(Symbol::intern(\"cas\"))));\n+        ret.insert((sym::target_has_atomic, Some(Symbol::intern(\"cas\"))));\n     }\n     if sess.opts.debug_assertions {\n         ret.insert((Symbol::intern(\"debug_assertions\"), None));\n     }\n     if sess.opts.crate_types.contains(&CrateType::ProcMacro) {\n-        ret.insert((Symbol::intern(\"proc_macro\"), None));\n+        ret.insert((sym::proc_macro, None));\n     }\n     ret\n }\n@@ -1547,7 +1547,7 @@ pub fn build_configuration(sess: &Session, mut user_cfg: ast::CrateConfig) -> as\n     let default_cfg = default_configuration(sess);\n     // If the user wants a test runner, then add the test cfg\n     if sess.opts.test {\n-        user_cfg.insert((Symbol::intern(\"test\"), None));\n+        user_cfg.insert((sym::test, None));\n     }\n     user_cfg.extend(default_cfg.iter().cloned());\n     user_cfg\n@@ -2702,7 +2702,7 @@ mod tests {\n     use std::path::PathBuf;\n     use super::{Externs, OutputType, OutputTypes};\n     use rustc_target::spec::{MergeFunctions, PanicStrategy, RelroLevel};\n-    use syntax::symbol::Symbol;\n+    use syntax::symbol::sym;\n     use syntax::edition::{Edition, DEFAULT_EDITION};\n     use syntax;\n     use super::Options;\n@@ -2744,15 +2744,14 @@ mod tests {\n             let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n             let sess = build_session(sessopts, None, registry);\n             let cfg = build_configuration(&sess, to_crate_config(cfg));\n-            assert!(cfg.contains(&(Symbol::intern(\"test\"), None)));\n+            assert!(cfg.contains(&(sym::test, None)));\n         });\n     }\n \n     // When the user supplies --test and --cfg test, don't implicitly add\n     // another --cfg test\n     #[test]\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n-        use syntax::symbol::sym;\n         syntax::with_default_globals(|| {\n             let matches = &match optgroups().parse(&[\"--test\".to_string(),\n                                                      \"--cfg=test\".to_string()]) {"}, {"sha": "3ec06b17aff22a66c1a238ee3835c2fb43201c4a", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -91,9 +91,7 @@ impl MutVisitor for ExpandAllocatorDirectives<'_> {\n             call_site: item.span, // use the call site of the static\n             def_site: None,\n             format: MacroAttribute(Symbol::intern(name)),\n-            allow_internal_unstable: Some(vec![\n-                Symbol::intern(\"rustc_attrs\"),\n-            ].into()),\n+            allow_internal_unstable: Some(vec![sym::rustc_attrs].into()),\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n             edition: self.sess.edition,\n@@ -223,7 +221,7 @@ impl AllocFnFactory<'_> {\n     }\n \n     fn attrs(&self) -> Vec<Attribute> {\n-        let special = Symbol::intern(\"rustc_std_internal_symbol\");\n+        let special = sym::rustc_std_internal_symbol;\n         let special = self.cx.meta_word(self.span, special);\n         vec![self.cx.attribute(self.span, special)]\n     }"}, {"sha": "4ff996d1f5707a2b51379e884544c78d0a492410", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -68,7 +68,7 @@ pub fn add_configuration(\n     sess: &Session,\n     codegen_backend: &dyn CodegenBackend,\n ) {\n-    let tf = Symbol::intern(\"target_feature\");\n+    let tf = sym::target_feature;\n \n     cfg.extend(\n         codegen_backend"}, {"sha": "d184c671bbaf8a3234d9bffda63c91d07e4599e7", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -1439,8 +1439,8 @@ impl KeywordIdents {\n     {\n         let next_edition = match cx.sess.edition() {\n             Edition::Edition2015 => {\n-                match &ident.as_str()[..] {\n-                    \"async\" | \"await\" | \"try\" => Edition::Edition2018,\n+                match ident.name {\n+                    kw::Async | kw::Await | kw::Try => Edition::Edition2018,\n \n                     // rust-lang/rust#56327: Conservatively do not\n                     // attempt to report occurrences of `dyn` within\n@@ -1454,7 +1454,7 @@ impl KeywordIdents {\n                     // its precise role in the parsed AST and thus are\n                     // assured this is truly an attempt to use it as\n                     // an identifier.\n-                    \"dyn\" if !under_macro => Edition::Edition2018,\n+                    kw::Dyn if !under_macro => Edition::Edition2018,\n \n                     _ => return,\n                 }"}, {"sha": "1f6e54807d8cb16fdb504837d859c00d855ce455", "filename": "src/librustc_macros/src/symbols.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc_macros%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc_macros%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fsymbols.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -96,6 +96,7 @@ pub fn symbols(input: TokenStream) -> TokenStream {\n \n     let mut keyword_stream = quote! {};\n     let mut symbols_stream = quote! {};\n+    let mut digits_stream = quote! {};\n     let mut prefill_stream = quote! {};\n     let mut counter = 0u32;\n     let mut keys = HashSet::<String>::new();\n@@ -106,6 +107,7 @@ pub fn symbols(input: TokenStream) -> TokenStream {\n         }\n     };\n \n+    // Generate the listed keywords.\n     for keyword in &input.keywords.0 {\n         let name = &keyword.name;\n         let value = &keyword.value;\n@@ -119,6 +121,7 @@ pub fn symbols(input: TokenStream) -> TokenStream {\n         counter += 1;\n     }\n \n+    // Generate the listed symbols.\n     for symbol in &input.symbols.0 {\n         let name = &symbol.name;\n         let value = match &symbol.value {\n@@ -135,6 +138,19 @@ pub fn symbols(input: TokenStream) -> TokenStream {\n         counter += 1;\n     }\n \n+    // Generate symbols for the strings \"0\", \"1\", ..., \"9\".\n+    for n in 0..10 {\n+        let n = n.to_string();\n+        check_dup(&n);\n+        prefill_stream.extend(quote! {\n+            #n,\n+        });\n+        digits_stream.extend(quote! {\n+            Symbol::new(#counter),\n+        });\n+        counter += 1;\n+    }\n+\n     let tt = TokenStream::from(quote! {\n         macro_rules! keywords {\n             () => {\n@@ -145,6 +161,10 @@ pub fn symbols(input: TokenStream) -> TokenStream {\n         macro_rules! symbols {\n             () => {\n                 #symbols_stream\n+\n+                pub const digits_array: &[Symbol; 10] = &[\n+                    #digits_stream\n+                ];\n             }\n         }\n "}, {"sha": "c2c40ea79e8f5d5f56a143291dd36fc0adf1cb93", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -431,9 +431,7 @@ impl cstore::CStore {\n             let client = proc_macro::bridge::client::Client::expand1(proc_macro::quote);\n             let ext = SyntaxExtension::ProcMacro {\n                 expander: Box::new(BangProcMacro { client }),\n-                allow_internal_unstable: Some(vec![\n-                    Symbol::intern(\"proc_macro_def_site\"),\n-                ].into()),\n+                allow_internal_unstable: Some(vec![sym::proc_macro_def_site].into()),\n                 edition: data.root.edition,\n             };\n             return LoadedMacro::ProcMacro(Lrc::new(ext));"}, {"sha": "ccc38191a93b861887e0dc8ba03d5d7182ea4fd6", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -2,7 +2,7 @@ use std::fmt::Write;\n use std::hash::Hash;\n use std::ops::RangeInclusive;\n \n-use syntax_pos::symbol::Symbol;\n+use syntax_pos::symbol::{sym, Symbol};\n use rustc::hir;\n use rustc::ty::layout::{self, Size, Align, TyLayout, LayoutOf, VariantIdx};\n use rustc::ty;\n@@ -188,7 +188,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> ValidityVisitor<'rt, 'a, '\n \n                 PathElem::ClosureVar(name.unwrap_or_else(|| {\n                     // Fall back to showing the field index.\n-                    Symbol::intern(&field.to_string())\n+                    sym::integer(field)\n                 }))\n             }\n "}, {"sha": "3ab25146331c15729d1b8dd1032a48a8f80769d2", "filename": "src/librustc_target/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc_target%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc_target%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2FCargo.toml?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -15,3 +15,4 @@ log = \"0.4\"\n rustc_cratesio_shim = { path = \"../librustc_cratesio_shim\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n serialize = { path = \"../libserialize\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "8fc5e6aae34d4b8051ef89b9afa6ea25a52d7bc1", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -7,6 +7,7 @@ use std::fmt;\n use std::ops::{Add, Deref, Sub, Mul, AddAssign, Range, RangeInclusive};\n \n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use syntax_pos::symbol::{sym, Symbol};\n \n pub mod call;\n \n@@ -552,6 +553,13 @@ impl FloatTy {\n         }\n     }\n \n+    pub fn to_symbol(self) -> Symbol {\n+        match self {\n+            FloatTy::F32 => sym::f32,\n+            FloatTy::F64 => sym::f64,\n+        }\n+    }\n+\n     pub fn bit_width(self) -> usize {\n         match self {\n             FloatTy::F32 => 32,"}, {"sha": "bfe30488f9cced9e4b52ce221ef75189f154ad89", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -2697,16 +2697,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn resolve_place_op(&self, op: PlaceOp, is_mut: bool) -> (Option<DefId>, ast::Ident) {\n         let (tr, name) = match (op, is_mut) {\n-            (PlaceOp::Deref, false) =>\n-                (self.tcx.lang_items().deref_trait(), \"deref\"),\n-            (PlaceOp::Deref, true) =>\n-                (self.tcx.lang_items().deref_mut_trait(), \"deref_mut\"),\n-            (PlaceOp::Index, false) =>\n-                (self.tcx.lang_items().index_trait(), \"index\"),\n-            (PlaceOp::Index, true) =>\n-                (self.tcx.lang_items().index_mut_trait(), \"index_mut\"),\n+            (PlaceOp::Deref, false) => (self.tcx.lang_items().deref_trait(), sym::deref),\n+            (PlaceOp::Deref, true) => (self.tcx.lang_items().deref_mut_trait(), sym::deref_mut),\n+            (PlaceOp::Index, false) => (self.tcx.lang_items().index_trait(), sym::index),\n+            (PlaceOp::Index, true) => (self.tcx.lang_items().index_mut_trait(), sym::index_mut),\n         };\n-        (tr, ast::Ident::from_str(name))\n+        (tr, ast::Ident::with_empty_ctxt(name))\n     }\n \n     fn try_overloaded_place_op(&self,\n@@ -4948,7 +4944,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // This is less than ideal, it will not suggest a return type span on any\n                 // method called `main`, regardless of whether it is actually the entry point,\n                 // but it will still present it as the reason for the expected type.\n-                Some((decl, ident, ident.name != Symbol::intern(\"main\")))\n+                Some((decl, ident, ident.name != sym::main))\n             }),\n             Node::TraitItem(&hir::TraitItem {\n                 ident, node: hir::TraitItemKind::Method(hir::MethodSig {"}, {"sha": "75e83bd9f9c74db2f0b606452781f3e389da361e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -10,7 +10,7 @@ use crate::parse::token;\n use crate::print::pprust;\n use crate::ptr::P;\n use crate::source_map::{dummy_spanned, respan, Spanned};\n-use crate::symbol::{kw, Symbol};\n+use crate::symbol::{kw, sym, Symbol};\n use crate::tokenstream::TokenStream;\n use crate::ThinVec;\n \n@@ -1531,6 +1531,17 @@ impl IntTy {\n         }\n     }\n \n+    pub fn to_symbol(&self) -> Symbol {\n+        match *self {\n+            IntTy::Isize => sym::isize,\n+            IntTy::I8 => sym::i8,\n+            IntTy::I16 => sym::i16,\n+            IntTy::I32 => sym::i32,\n+            IntTy::I64 => sym::i64,\n+            IntTy::I128 => sym::i128,\n+        }\n+    }\n+\n     pub fn val_to_string(&self, val: i128) -> String {\n         // Cast to a `u128` so we can correctly print `INT128_MIN`. All integral types\n         // are parsed as `u128`, so we wouldn't want to print an extra negative\n@@ -1572,6 +1583,17 @@ impl UintTy {\n         }\n     }\n \n+    pub fn to_symbol(&self) -> Symbol {\n+        match *self {\n+            UintTy::Usize => sym::usize,\n+            UintTy::U8 => sym::u8,\n+            UintTy::U16 => sym::u16,\n+            UintTy::U32 => sym::u32,\n+            UintTy::U64 => sym::u64,\n+            UintTy::U128 => sym::u128,\n+        }\n+    }\n+\n     pub fn val_to_string(&self, val: u128) -> String {\n         format!(\"{}{}\", val, self.ty_to_string())\n     }"}, {"sha": "d72193ffe1205a269405d007db7b17e9f4cd8272", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -969,10 +969,10 @@ impl<'a> ExtCtxt<'a> {\n     pub fn ident_of(&self, st: &str) -> ast::Ident {\n         ast::Ident::from_str(st)\n     }\n-    pub fn std_path(&self, components: &[&str]) -> Vec<ast::Ident> {\n+    pub fn std_path(&self, components: &[Symbol]) -> Vec<ast::Ident> {\n         let def_site = DUMMY_SP.apply_mark(self.current_expansion.mark);\n         iter::once(Ident::new(kw::DollarCrate, def_site))\n-            .chain(components.iter().map(|s| self.ident_of(s)))\n+            .chain(components.iter().map(|&s| Ident::with_empty_ctxt(s)))\n             .collect()\n     }\n     pub fn name_of(&self, st: &str) -> ast::Name {"}, {"sha": "9c0ffc1f6e8cb39174077c0ffcacbe465d6fd510", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -3,11 +3,11 @@ use crate::attr;\n use crate::source_map::{dummy_spanned, respan, Spanned};\n use crate::ext::base::ExtCtxt;\n use crate::ptr::P;\n-use crate::symbol::{Symbol, kw};\n+use crate::symbol::{kw, sym, Symbol};\n use crate::ThinVec;\n \n use rustc_target::spec::abi::Abi;\n-use syntax_pos::{Pos, Span, DUMMY_SP};\n+use syntax_pos::{Pos, Span};\n \n pub trait AstBuilder {\n     // paths\n@@ -49,7 +49,6 @@ pub trait AstBuilder {\n               ty: P<ast::Ty>,\n               mutbl: ast::Mutability) -> P<ast::Ty>;\n \n-    fn ty_option(&self, ty: P<ast::Ty>) -> P<ast::Ty>;\n     fn ty_infer(&self, sp: Span) -> P<ast::Ty>;\n \n     fn typaram(&self,\n@@ -425,15 +424,6 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 ast::TyKind::Ptr(self.ty_mt(ty, mutbl)))\n     }\n \n-    fn ty_option(&self, ty: P<ast::Ty>) -> P<ast::Ty> {\n-        self.ty_path(\n-            self.path_all(DUMMY_SP,\n-                          true,\n-                          self.std_path(&[\"option\", \"Option\"]),\n-                          vec![ast::GenericArg::Type(ty)],\n-                          Vec::new()))\n-    }\n-\n     fn ty_infer(&self, span: Span) -> P<ast::Ty> {\n         self.ty(span, ast::TyKind::Infer)\n     }\n@@ -735,7 +725,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr(sp, ast::ExprKind::Array(exprs))\n     }\n     fn expr_vec_ng(&self, sp: Span) -> P<ast::Expr> {\n-        self.expr_call_global(sp, self.std_path(&[\"vec\", \"Vec\", \"new\"]),\n+        self.expr_call_global(sp, self.std_path(&[sym::vec, sym::Vec, sym::new]),\n                               Vec::new())\n     }\n     fn expr_vec_slice(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n@@ -751,12 +741,12 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n \n     fn expr_some(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n-        let some = self.std_path(&[\"option\", \"Option\", \"Some\"]);\n+        let some = self.std_path(&[sym::option, sym::Option, sym::Some]);\n         self.expr_call_global(sp, some, vec![expr])\n     }\n \n     fn expr_none(&self, sp: Span) -> P<ast::Expr> {\n-        let none = self.std_path(&[\"option\", \"Option\", \"None\"]);\n+        let none = self.std_path(&[sym::option, sym::Option, sym::None]);\n         let none = self.path_global(sp, none);\n         self.expr_path(none)\n     }\n@@ -780,7 +770,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let expr_loc_ptr = self.expr_addr_of(span, expr_loc_tuple);\n         self.expr_call_global(\n             span,\n-            self.std_path(&[\"rt\", \"begin_panic\"]),\n+            self.std_path(&[sym::rt, sym::begin_panic]),\n             vec![\n                 self.expr_str(span, msg),\n                 expr_loc_ptr])\n@@ -791,19 +781,19 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn expr_ok(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n-        let ok = self.std_path(&[\"result\", \"Result\", \"Ok\"]);\n+        let ok = self.std_path(&[sym::result, sym::Result, sym::Ok]);\n         self.expr_call_global(sp, ok, vec![expr])\n     }\n \n     fn expr_err(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n-        let err = self.std_path(&[\"result\", \"Result\", \"Err\"]);\n+        let err = self.std_path(&[sym::result, sym::Result, sym::Err]);\n         self.expr_call_global(sp, err, vec![expr])\n     }\n \n     fn expr_try(&self, sp: Span, head: P<ast::Expr>) -> P<ast::Expr> {\n-        let ok = self.std_path(&[\"result\", \"Result\", \"Ok\"]);\n+        let ok = self.std_path(&[sym::result, sym::Result, sym::Ok]);\n         let ok_path = self.path_global(sp, ok);\n-        let err = self.std_path(&[\"result\", \"Result\", \"Err\"]);\n+        let err = self.std_path(&[sym::result, sym::Result, sym::Err]);\n         let err_path = self.path_global(sp, err);\n \n         let binding_variable = self.ident_of(\"__try_var\");\n@@ -867,25 +857,25 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn pat_some(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n-        let some = self.std_path(&[\"option\", \"Option\", \"Some\"]);\n+        let some = self.std_path(&[sym::option, sym::Option, sym::Some]);\n         let path = self.path_global(span, some);\n         self.pat_tuple_struct(span, path, vec![pat])\n     }\n \n     fn pat_none(&self, span: Span) -> P<ast::Pat> {\n-        let some = self.std_path(&[\"option\", \"Option\", \"None\"]);\n+        let some = self.std_path(&[sym::option, sym::Option, sym::None]);\n         let path = self.path_global(span, some);\n         self.pat_path(span, path)\n     }\n \n     fn pat_ok(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n-        let some = self.std_path(&[\"result\", \"Result\", \"Ok\"]);\n+        let some = self.std_path(&[sym::result, sym::Result, sym::Ok]);\n         let path = self.path_global(span, some);\n         self.pat_tuple_struct(span, path, vec![pat])\n     }\n \n     fn pat_err(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n-        let some = self.std_path(&[\"result\", \"Result\", \"Err\"]);\n+        let some = self.std_path(&[sym::result, sym::Result, sym::Err]);\n         let path = self.path_global(span, some);\n         self.pat_tuple_struct(span, path, vec![pat])\n     }"}, {"sha": "c47224ca0ce3fe032dba61af4ac8698dc6131b27", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -58,10 +58,7 @@ pub fn add_derived_markers<T>(cx: &mut ExtCtxt<'_>, span: Span, traits: &[ast::P\n         call_site: span,\n         def_site: None,\n         format: ExpnFormat::MacroAttribute(Symbol::intern(&pretty_name)),\n-        allow_internal_unstable: Some(vec![\n-            Symbol::intern(\"rustc_attrs\"),\n-            Symbol::intern(\"structural_match\"),\n-        ].into()),\n+        allow_internal_unstable: Some(vec![sym::rustc_attrs, sym::structural_match].into()),\n         allow_internal_unsafe: false,\n         local_inner_macros: false,\n         edition: cx.parse_sess.edition,\n@@ -74,7 +71,7 @@ pub fn add_derived_markers<T>(cx: &mut ExtCtxt<'_>, span: Span, traits: &[ast::P\n             attrs.push(cx.attribute(span, meta));\n         }\n         if names.contains(&Symbol::intern(\"Copy\")) {\n-            let meta = cx.meta_word(span, Symbol::intern(\"rustc_copy_clone_marker\"));\n+            let meta = cx.meta_word(span, sym::rustc_copy_clone_marker);\n             attrs.push(cx.attribute(span, meta));\n         }\n     });"}, {"sha": "c2a73b662c680b7137f6e70813e98f84fb7f6291", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -938,7 +938,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             }\n             BuiltinDerive(func) => {\n                 expn_info.allow_internal_unstable = Some(vec![\n-                    Symbol::intern(\"rustc_attrs\"),\n+                    sym::rustc_attrs,\n                     Symbol::intern(\"derive_clone_copy\"),\n                     Symbol::intern(\"derive_eq\"),\n                     Symbol::intern(\"libstd_sys_internals\"), // RustcDeserialize and RustcSerialize"}, {"sha": "7b7cf80760f5c3f920feda9ba0eeb6f45f60e71d", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -80,7 +80,7 @@ use crate::parse::{Directory, ParseSess};\n use crate::parse::parser::{Parser, PathStyle};\n use crate::parse::token::{self, DocComment, Nonterminal, Token};\n use crate::print::pprust;\n-use crate::symbol::kw;\n+use crate::symbol::{kw, sym, Symbol};\n use crate::tokenstream::{DelimSpan, TokenStream};\n \n use errors::FatalError;\n@@ -598,7 +598,7 @@ fn inner_parse_loop<'root, 'tt>(\n                 TokenTree::MetaVarDecl(_, _, id) => {\n                     // Built-in nonterminals never start with these tokens,\n                     // so we can eliminate them from consideration.\n-                    if may_begin_with(&*id.as_str(), token) {\n+                    if may_begin_with(id.name, token) {\n                         bb_items.push(item);\n                     }\n                 }\n@@ -791,7 +791,7 @@ pub fn parse(\n                 let match_cur = item.match_cur;\n                 item.push_match(\n                     match_cur,\n-                    MatchedNonterminal(Lrc::new(parse_nt(&mut parser, span, &ident.as_str()))),\n+                    MatchedNonterminal(Lrc::new(parse_nt(&mut parser, span, ident.name))),\n                 );\n                 item.idx += 1;\n                 item.match_cur += 1;\n@@ -819,7 +819,7 @@ fn get_macro_ident(token: &Token) -> Option<(Ident, bool)> {\n ///\n /// Returning `false` is a *stability guarantee* that such a matcher will *never* begin with that\n /// token. Be conservative (return true) if not sure.\n-fn may_begin_with(name: &str, token: &Token) -> bool {\n+fn may_begin_with(name: Symbol, token: &Token) -> bool {\n     /// Checks whether the non-terminal may contain a single (non-keyword) identifier.\n     fn may_be_ident(nt: &token::Nonterminal) -> bool {\n         match *nt {\n@@ -829,16 +829,16 @@ fn may_begin_with(name: &str, token: &Token) -> bool {\n     }\n \n     match name {\n-        \"expr\" => token.can_begin_expr(),\n-        \"ty\" => token.can_begin_type(),\n-        \"ident\" => get_macro_ident(token).is_some(),\n-        \"literal\" => token.can_begin_literal_or_bool(),\n-        \"vis\" => match *token {\n+        sym::expr => token.can_begin_expr(),\n+        sym::ty => token.can_begin_type(),\n+        sym::ident => get_macro_ident(token).is_some(),\n+        sym::literal => token.can_begin_literal_or_bool(),\n+        sym::vis => match *token {\n             // The follow-set of :vis + \"priv\" keyword + interpolated\n             Token::Comma | Token::Ident(..) | Token::Interpolated(_) => true,\n             _ => token.can_begin_type(),\n         },\n-        \"block\" => match *token {\n+        sym::block => match *token {\n             Token::OpenDelim(token::Brace) => true,\n             Token::Interpolated(ref nt) => match **nt {\n                 token::NtItem(_)\n@@ -852,15 +852,15 @@ fn may_begin_with(name: &str, token: &Token) -> bool {\n             },\n             _ => false,\n         },\n-        \"path\" | \"meta\" => match *token {\n+        sym::path | sym::meta => match *token {\n             Token::ModSep | Token::Ident(..) => true,\n             Token::Interpolated(ref nt) => match **nt {\n                 token::NtPath(_) | token::NtMeta(_) => true,\n                 _ => may_be_ident(&nt),\n             },\n             _ => false,\n         },\n-        \"pat\" => match *token {\n+        sym::pat => match *token {\n             Token::Ident(..) |               // box, ref, mut, and other identifiers (can stricten)\n             Token::OpenDelim(token::Paren) |    // tuple pattern\n             Token::OpenDelim(token::Bracket) |  // slice pattern\n@@ -876,7 +876,7 @@ fn may_begin_with(name: &str, token: &Token) -> bool {\n             Token::Interpolated(ref nt) => may_be_ident(nt),\n             _ => false,\n         },\n-        \"lifetime\" => match *token {\n+        sym::lifetime => match *token {\n             Token::Lifetime(_) => true,\n             Token::Interpolated(ref nt) => match **nt {\n                 token::NtLifetime(_) | token::NtTT(_) => true,\n@@ -903,34 +903,34 @@ fn may_begin_with(name: &str, token: &Token) -> bool {\n /// # Returns\n ///\n /// The parsed non-terminal.\n-fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n-    if name == \"tt\" {\n+fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: Symbol) -> Nonterminal {\n+    if name == sym::tt {\n         return token::NtTT(p.parse_token_tree());\n     }\n     // check at the beginning and the parser checks after each bump\n     p.process_potential_macro_variable();\n     match name {\n-        \"item\" => match panictry!(p.parse_item()) {\n+        sym::item => match panictry!(p.parse_item()) {\n             Some(i) => token::NtItem(i),\n             None => {\n                 p.fatal(\"expected an item keyword\").emit();\n                 FatalError.raise();\n             }\n         },\n-        \"block\" => token::NtBlock(panictry!(p.parse_block())),\n-        \"stmt\" => match panictry!(p.parse_stmt()) {\n+        sym::block => token::NtBlock(panictry!(p.parse_block())),\n+        sym::stmt => match panictry!(p.parse_stmt()) {\n             Some(s) => token::NtStmt(s),\n             None => {\n                 p.fatal(\"expected a statement\").emit();\n                 FatalError.raise();\n             }\n         },\n-        \"pat\" => token::NtPat(panictry!(p.parse_pat(None))),\n-        \"expr\" => token::NtExpr(panictry!(p.parse_expr())),\n-        \"literal\" => token::NtLiteral(panictry!(p.parse_literal_maybe_minus())),\n-        \"ty\" => token::NtTy(panictry!(p.parse_ty())),\n+        sym::pat => token::NtPat(panictry!(p.parse_pat(None))),\n+        sym::expr => token::NtExpr(panictry!(p.parse_expr())),\n+        sym::literal => token::NtLiteral(panictry!(p.parse_literal_maybe_minus())),\n+        sym::ty => token::NtTy(panictry!(p.parse_ty())),\n         // this could be handled like a token, since it is one\n-        \"ident\" => if let Some((ident, is_raw)) = get_macro_ident(&p.token) {\n+        sym::ident => if let Some((ident, is_raw)) = get_macro_ident(&p.token) {\n             let span = p.span;\n             p.bump();\n             token::NtIdent(Ident::new(ident.name, span), is_raw)\n@@ -939,10 +939,10 @@ fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n             p.fatal(&format!(\"expected ident, found {}\", &token_str)).emit();\n             FatalError.raise()\n         }\n-        \"path\" => token::NtPath(panictry!(p.parse_path(PathStyle::Type))),\n-        \"meta\" => token::NtMeta(panictry!(p.parse_meta_item())),\n-        \"vis\" => token::NtVis(panictry!(p.parse_visibility(true))),\n-        \"lifetime\" => if p.check_lifetime() {\n+        sym::path => token::NtPath(panictry!(p.parse_path(PathStyle::Type))),\n+        sym::meta => token::NtMeta(panictry!(p.parse_meta_item())),\n+        sym::vis => token::NtVis(panictry!(p.parse_visibility(true))),\n+        sym::lifetime => if p.check_lifetime() {\n             token::NtLifetime(p.expect_lifetime().ident)\n         } else {\n             let token_str = pprust::token_to_string(&p.token);"}, {"sha": "285c88357a6a8c7dd3a6718e2bf14e945eab2717", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -396,7 +396,7 @@ pub fn compile(\n                         future this will become a hard error. Please use `allow_internal_unstable(\\\n                         foo, bar)` to only allow the `foo` and `bar` features\",\n                     );\n-                    vec![Symbol::intern(\"allow_internal_unstable_backcompat_hack\")].into()\n+                    vec![sym::allow_internal_unstable_backcompat_hack].into()\n                 })\n             );\n         let allow_internal_unsafe = attr::contains_name(&def.attrs, sym::allow_internal_unsafe);"}, {"sha": "b3d49524d7668599e9d37ed6d46907db65981776", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -8,7 +8,7 @@ use crate::parse::parser::{BlockMode, PathStyle, SemiColonMode, TokenType, Token\n use crate::print::pprust;\n use crate::ptr::P;\n use crate::source_map::Spanned;\n-use crate::symbol::kw;\n+use crate::symbol::{kw, sym};\n use crate::ThinVec;\n use crate::util::parser::AssocOp;\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n@@ -263,15 +263,15 @@ impl<'a> Parser<'a> {\n         };\n         self.last_unexpected_token_span = Some(self.span);\n         let mut err = self.fatal(&msg_exp);\n-        if self.token.is_ident_named(\"and\") {\n+        if self.token.is_ident_named(sym::and) {\n             err.span_suggestion_short(\n                 self.span,\n                 \"use `&&` instead of `and` for the boolean operator\",\n                 \"&&\".to_string(),\n                 Applicability::MaybeIncorrect,\n             );\n         }\n-        if self.token.is_ident_named(\"or\") {\n+        if self.token.is_ident_named(sym::or) {\n             err.span_suggestion_short(\n                 self.span,\n                 \"use `||` instead of `or` for the boolean operator\","}, {"sha": "a06a84f162a96a266b7b78e38d4acde9911fdf37", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -1,7 +1,7 @@\n use crate::ast::{self, Ident};\n use crate::parse::ParseSess;\n use crate::parse::token::{self, Token};\n-use crate::symbol::Symbol;\n+use crate::symbol::{sym, Symbol};\n use crate::parse::unescape;\n use crate::parse::unescape_error_reporting::{emit_unescape_error, push_escaped_char};\n \n@@ -754,7 +754,7 @@ impl<'a> StringReader<'a> {\n                 }\n                 _ => {\n                     // just a 0\n-                    return (token::Integer, self.name_from(start_bpos));\n+                    return (token::Integer, sym::integer(0));\n                 }\n             }\n         } else if c.is_digit(10) {"}, {"sha": "18019a89130e7f49219f62bb86a2139c7f574dda", "filename": "src/libsyntax/parse/literal.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Fparse%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Fparse%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fliteral.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -171,12 +171,15 @@ impl LitKind {\n     /// by an AST-based macro) or unavailable (e.g. from HIR pretty-printing).\n     pub fn to_lit_token(&self) -> token::Lit {\n         let (kind, symbol, suffix) = match *self {\n-            LitKind::Str(string, ast::StrStyle::Cooked) => {\n-                let escaped = string.as_str().escape_default().to_string();\n-                (token::Str, Symbol::intern(&escaped), None)\n+            LitKind::Str(symbol, ast::StrStyle::Cooked) => {\n+                // Don't re-intern unless the escaped string is different.\n+                let s = &symbol.as_str();\n+                let escaped = s.escape_default().to_string();\n+                let symbol = if escaped == *s { symbol } else { Symbol::intern(&escaped) };\n+                (token::Str, symbol, None)\n             }\n-            LitKind::Str(string, ast::StrStyle::Raw(n)) => {\n-                (token::StrRaw(n), string, None)\n+            LitKind::Str(symbol, ast::StrStyle::Raw(n)) => {\n+                (token::StrRaw(n), symbol, None)\n             }\n             LitKind::ByteStr(ref bytes) => {\n                 let string = bytes.iter().cloned().flat_map(ascii::escape_default)\n@@ -193,14 +196,14 @@ impl LitKind {\n             }\n             LitKind::Int(n, ty) => {\n                 let suffix = match ty {\n-                    ast::LitIntType::Unsigned(ty) => Some(Symbol::intern(ty.ty_to_string())),\n-                    ast::LitIntType::Signed(ty) => Some(Symbol::intern(ty.ty_to_string())),\n+                    ast::LitIntType::Unsigned(ty) => Some(ty.to_symbol()),\n+                    ast::LitIntType::Signed(ty) => Some(ty.to_symbol()),\n                     ast::LitIntType::Unsuffixed => None,\n                 };\n-                (token::Integer, Symbol::intern(&n.to_string()), suffix)\n+                (token::Integer, sym::integer(n), suffix)\n             }\n             LitKind::Float(symbol, ty) => {\n-                (token::Float, symbol, Some(Symbol::intern(ty.ty_to_string())))\n+                (token::Float, symbol, Some(ty.to_symbol()))\n             }\n             LitKind::FloatUnsuffixed(symbol) => {\n                 (token::Float, symbol, None)"}, {"sha": "07efeaa4cf264ce03b45d5e1c13f52d1c8422a8a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -2759,7 +2759,7 @@ impl<'a> Parser<'a> {\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n                 (lo.to(span), ExprKind::Box(e))\n             }\n-            token::Ident(..) if self.token.is_ident_named(\"not\") => {\n+            token::Ident(..) if self.token.is_ident_named(sym::not) => {\n                 // `not` is just an ordinary identifier in Rust-the-language,\n                 // but as `rustc`-the-compiler, we can issue clever diagnostics\n                 // for confused users who really want to say `!`\n@@ -4592,15 +4592,15 @@ impl<'a> Parser<'a> {\n             let do_not_suggest_help =\n                 self.token.is_keyword(kw::In) || self.token == token::Colon;\n \n-            if self.token.is_ident_named(\"and\") {\n+            if self.token.is_ident_named(sym::and) {\n                 e.span_suggestion_short(\n                     self.span,\n                     \"use `&&` instead of `and` for the boolean operator\",\n                     \"&&\".to_string(),\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n-            if self.token.is_ident_named(\"or\") {\n+            if self.token.is_ident_named(sym::or) {\n                 e.span_suggestion_short(\n                     self.span,\n                     \"use `||` instead of `or` for the boolean operator\",\n@@ -5787,7 +5787,7 @@ impl<'a> Parser<'a> {\n             VisibilityKind::Inherited => {}\n             _ => {\n                 let is_macro_rules: bool = match self.token {\n-                    token::Ident(sid, _) => sid.name == Symbol::intern(\"macro_rules\"),\n+                    token::Ident(sid, _) => sid.name == sym::macro_rules,\n                     _ => false,\n                 };\n                 let mut err = if is_macro_rules {"}, {"sha": "47185df8d616563a0cf23bf24372cb5ad32d9a71", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -391,9 +391,9 @@ impl Token {\n \n     /// Returns `true` if the token is a identifier whose name is the given\n     /// string slice.\n-    crate fn is_ident_named(&self, name: &str) -> bool {\n+    crate fn is_ident_named(&self, name: Symbol) -> bool {\n         match self.ident() {\n-            Some((ident, _)) => ident.as_str() == name,\n+            Some((ident, _)) => ident.name == name,\n             None => false\n         }\n     }"}, {"sha": "eea94f0d19458fa44146fa960121ad0519bc1ec4", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -20,9 +20,7 @@ fn ignored_span(sp: Span, edition: Edition) -> Span {\n         call_site: DUMMY_SP,\n         def_site: None,\n         format: MacroAttribute(Symbol::intern(\"std_inject\")),\n-        allow_internal_unstable: Some(vec![\n-            Symbol::intern(\"prelude_import\"),\n-        ].into()),\n+        allow_internal_unstable: Some(vec![sym::prelude_import].into()),\n         allow_internal_unsafe: false,\n         local_inner_macros: false,\n         edition,\n@@ -98,7 +96,7 @@ pub fn maybe_inject_crates_ref(\n     krate.module.items.insert(0, P(ast::Item {\n         attrs: vec![ast::Attribute {\n             style: ast::AttrStyle::Outer,\n-            path: ast::Path::from_ident(ast::Ident::new(Symbol::intern(\"prelude_import\"), span)),\n+            path: ast::Path::from_ident(ast::Ident::new(sym::prelude_import, span)),\n             tokens: TokenStream::empty(),\n             id: attr::mk_attr_id(),\n             is_sugared_doc: false,"}, {"sha": "1998ec19f13bf7033e28618d3ca8afc482502d83", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -283,12 +283,8 @@ fn generate_test_harness(sess: &ParseSess,\n     mark.set_expn_info(ExpnInfo {\n         call_site: DUMMY_SP,\n         def_site: None,\n-        format: MacroAttribute(Symbol::intern(\"test_case\")),\n-        allow_internal_unstable: Some(vec![\n-            Symbol::intern(\"main\"),\n-            Symbol::intern(\"test\"),\n-            Symbol::intern(\"rustc_attrs\"),\n-        ].into()),\n+        format: MacroAttribute(sym::test_case),\n+        allow_internal_unstable: Some(vec![sym::main, sym::test, sym::rustc_attrs].into()),\n         allow_internal_unsafe: false,\n         local_inner_macros: false,\n         edition: sess.edition,\n@@ -347,14 +343,14 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     let call_test_main = ecx.stmt_expr(call_test_main);\n \n     // #![main]\n-    let main_meta = ecx.meta_word(sp, Symbol::intern(\"main\"));\n+    let main_meta = ecx.meta_word(sp, sym::main);\n     let main_attr = ecx.attribute(sp, main_meta);\n \n     // extern crate test as test_gensym\n     let test_extern_stmt = ecx.stmt_item(sp, ecx.item(sp,\n         test_id,\n         vec![],\n-        ast::ItemKind::ExternCrate(Some(Symbol::intern(\"test\")))\n+        ast::ItemKind::ExternCrate(Some(sym::test))\n     ));\n \n     // pub fn main() { ... }"}, {"sha": "4d7083c1a790b955abbef10861be3c7f156d0c80", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -11,7 +11,7 @@ use syntax::ext::base::{self, *};\n use syntax::feature_gate;\n use syntax::parse::{self, token};\n use syntax::ptr::P;\n-use syntax::symbol::{Symbol, sym};\n+use syntax::symbol::{kw, sym, Symbol};\n use syntax::ast::AsmDialect;\n use syntax_pos::Span;\n use syntax::tokenstream;\n@@ -93,7 +93,7 @@ fn parse_inline_asm<'a>(\n         })\n         .unwrap_or(tts.len());\n     let mut p = cx.new_parser_from_tts(&tts[first_colon..]);\n-    let mut asm = Symbol::intern(\"\");\n+    let mut asm = kw::Invalid;\n     let mut asm_str_style = None;\n     let mut outputs = Vec::new();\n     let mut inputs = Vec::new();"}, {"sha": "13342c8e28e2ff3bf4d7e22c9ed0b6c2c6bffeeb", "filename": "src/libsyntax_ext/assert.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fassert.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -8,7 +8,7 @@ use syntax::parse::token::{self, Token};\n use syntax::parse::parser::Parser;\n use syntax::print::pprust;\n use syntax::ptr::P;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{sym, Symbol};\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -27,7 +27,7 @@ pub fn expand_assert<'cx>(\n \n     let sp = sp.apply_mark(cx.current_expansion.mark);\n     let panic_call = Mac_ {\n-        path: Path::from_ident(Ident::new(Symbol::intern(\"panic\"), sp)),\n+        path: Path::from_ident(Ident::new(sym::panic, sp)),\n         tts: custom_message.unwrap_or_else(|| {\n             TokenStream::from(TokenTree::Token(\n                 DUMMY_SP,"}, {"sha": "b3b6328e2ca7306536dff1787ca2ac07fcd8d2bb", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -7,7 +7,7 @@ use syntax::attr;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n-use syntax::symbol::{Symbol, kw, sym};\n+use syntax::symbol::{kw, sym, Symbol};\n use syntax_pos::Span;\n \n pub fn expand_deriving_clone(cx: &mut ExtCtxt<'_>,\n@@ -76,7 +76,7 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt<'_>,\n         _ => cx.span_bug(span, \"#[derive(Clone)] on trait item or impl item\"),\n     }\n \n-    let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n+    let inline = cx.meta_word(span, sym::inline);\n     let attrs = vec![cx.attribute(span, inline)];\n     let trait_def = TraitDef {\n         span,\n@@ -115,7 +115,7 @@ fn cs_clone_shallow(name: &str,\n         // set the expn ID so we can use the unstable struct.\n         let span = span.with_ctxt(cx.backtrace());\n         let assert_path = cx.path_all(span, true,\n-                                        cx.std_path(&[\"clone\", helper_name]),\n+                                        cx.std_path(&[sym::clone, Symbol::intern(helper_name)]),\n                                         vec![GenericArg::Type(ty)], vec![]);\n         stmts.push(cx.stmt_let_type_only(span, cx.ty_path(assert_path)));\n     }\n@@ -157,7 +157,7 @@ fn cs_clone(name: &str,\n             -> P<Expr> {\n     let ctor_path;\n     let all_fields;\n-    let fn_path = cx.std_path(&[\"clone\", \"Clone\", \"clone\"]);\n+    let fn_path = cx.std_path(&[sym::clone, sym::Clone, sym::clone]);\n     let subcall = |cx: &mut ExtCtxt<'_>, field: &FieldInfo<'_>| {\n         let args = vec![cx.expr_addr_of(field.span, field.self_.clone())];\n         cx.expr_call_global(field.span, fn_path.clone(), args)"}, {"sha": "1d981e0ff7906ba8b4788c6bb9cbcdbfa84c19d6", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -6,17 +6,17 @@ use syntax::ast::{self, Expr, MetaItem, GenericArg};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{sym, Symbol};\n use syntax_pos::Span;\n \n pub fn expand_deriving_eq(cx: &mut ExtCtxt<'_>,\n                           span: Span,\n                           mitem: &MetaItem,\n                           item: &Annotatable,\n                           push: &mut dyn FnMut(Annotatable)) {\n-    let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n-    let hidden = cx.meta_list_item_word(span, Symbol::intern(\"hidden\"));\n-    let doc = cx.meta_list(span, Symbol::intern(\"doc\"), vec![hidden]);\n+    let inline = cx.meta_word(span, sym::inline);\n+    let hidden = cx.meta_list_item_word(span, sym::hidden);\n+    let doc = cx.meta_list(span, sym::doc, vec![hidden]);\n     let attrs = vec![cx.attribute(span, inline), cx.attribute(span, doc)];\n     let trait_def = TraitDef {\n         span,\n@@ -54,7 +54,7 @@ fn cs_total_eq_assert(cx: &mut ExtCtxt<'_>,\n         // set the expn ID so we can use the unstable struct.\n         let span = span.with_ctxt(cx.backtrace());\n         let assert_path = cx.path_all(span, true,\n-                                        cx.std_path(&[\"cmp\", helper_name]),\n+                                        cx.std_path(&[sym::cmp, Symbol::intern(helper_name)]),\n                                         vec![GenericArg::Type(ty)], vec![]);\n         stmts.push(cx.stmt_let_type_only(span, cx.ty_path(assert_path)));\n     }"}, {"sha": "b25a9e4c50fbe9e87735ede37ae3a3b03e094e3c", "filename": "src/libsyntax_ext/deriving/cmp/ord.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -6,15 +6,15 @@ use syntax::ast::{self, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n \n pub fn expand_deriving_ord(cx: &mut ExtCtxt<'_>,\n                            span: Span,\n                            mitem: &MetaItem,\n                            item: &Annotatable,\n                            push: &mut dyn FnMut(Annotatable)) {\n-    let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n+    let inline = cx.meta_word(span, sym::inline);\n     let attrs = vec![cx.attribute(span, inline)];\n     let trait_def = TraitDef {\n         span,\n@@ -55,9 +55,9 @@ pub fn ordering_collapsed(cx: &mut ExtCtxt<'_>,\n \n pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {\n     let test_id = cx.ident_of(\"cmp\").gensym();\n-    let equals_path = cx.path_global(span, cx.std_path(&[\"cmp\", \"Ordering\", \"Equal\"]));\n+    let equals_path = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n \n-    let cmp_path = cx.std_path(&[\"cmp\", \"Ord\", \"cmp\"]);\n+    let cmp_path = cx.std_path(&[sym::cmp, sym::Ord, sym::cmp]);\n \n     // Builds:\n     //"}, {"sha": "6172f27261ecf730971d8d11994208d7dc4cf84c", "filename": "src/libsyntax_ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -6,7 +6,7 @@ use syntax::ast::{BinOpKind, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n \n pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt<'_>,\n@@ -62,7 +62,7 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt<'_>,\n \n     macro_rules! md {\n         ($name:expr, $f:ident) => { {\n-            let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n+            let inline = cx.meta_word(span, sym::inline);\n             let attrs = vec![cx.attribute(span, inline)];\n             MethodDef {\n                 name: $name,"}, {"sha": "3980741f252dd947e92e15fc7644405728c97bdf", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -8,7 +8,7 @@ use syntax::ast::{self, BinOpKind, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{sym, Symbol};\n use syntax_pos::Span;\n \n pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt<'_>,\n@@ -18,7 +18,7 @@ pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt<'_>,\n                                    push: &mut dyn FnMut(Annotatable)) {\n     macro_rules! md {\n         ($name:expr, $op:expr, $equal:expr) => { {\n-            let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n+            let inline = cx.meta_word(span, sym::inline);\n             let attrs = vec![cx.attribute(span, inline)];\n             MethodDef {\n                 name: $name,\n@@ -42,7 +42,7 @@ pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt<'_>,\n                                     vec![Box::new(ordering_ty)],\n                                     PathKind::Std));\n \n-    let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n+    let inline = cx.meta_word(span, sym::inline);\n     let attrs = vec![cx.attribute(span, inline)];\n \n     let partial_cmp_def = MethodDef {\n@@ -114,11 +114,11 @@ pub fn some_ordering_collapsed(cx: &mut ExtCtxt<'_>,\n \n pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {\n     let test_id = cx.ident_of(\"cmp\").gensym();\n-    let ordering = cx.path_global(span, cx.std_path(&[\"cmp\", \"Ordering\", \"Equal\"]));\n+    let ordering = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n     let ordering_expr = cx.expr_path(ordering.clone());\n     let equals_expr = cx.expr_some(span, ordering_expr);\n \n-    let partial_cmp_path = cx.std_path(&[\"cmp\", \"PartialOrd\", \"partial_cmp\"]);\n+    let partial_cmp_path = cx.std_path(&[sym::cmp, sym::PartialOrd, sym::partial_cmp]);\n \n     // Builds:\n     //\n@@ -188,7 +188,8 @@ fn cs_op(less: bool,\n          span: Span,\n          substr: &Substructure<'_>) -> P<Expr> {\n     let ordering_path = |cx: &mut ExtCtxt<'_>, name: &str| {\n-        cx.expr_path(cx.path_global(span, cx.std_path(&[\"cmp\", \"Ordering\", name])))\n+        cx.expr_path(cx.path_global(\n+            span, cx.std_path(&[sym::cmp, sym::Ordering, Symbol::intern(name)])))\n     };\n \n     let par_cmp = |cx: &mut ExtCtxt<'_>, span, self_f: P<Expr>, other_fs: &[P<Expr>], default| {\n@@ -198,19 +199,19 @@ fn cs_op(less: bool,\n         };\n \n         // `PartialOrd::partial_cmp(self.fi, other.fi)`\n-        let cmp_path = cx.expr_path(cx.path_global(span, cx.std_path(&[\"cmp\",\n-                                                                       \"PartialOrd\",\n-                                                                       \"partial_cmp\"])));\n+        let cmp_path = cx.expr_path(cx.path_global(span, cx.std_path(&[sym::cmp,\n+                                                                       sym::PartialOrd,\n+                                                                       sym::partial_cmp])));\n         let cmp = cx.expr_call(span,\n                                cmp_path,\n                                vec![cx.expr_addr_of(span, self_f),\n                                     cx.expr_addr_of(span, other_f.clone())]);\n \n         let default = ordering_path(cx, default);\n         // `Option::unwrap_or(_, Ordering::Equal)`\n-        let unwrap_path = cx.expr_path(cx.path_global(span, cx.std_path(&[\"option\",\n-                                                                          \"Option\",\n-                                                                          \"unwrap_or\"])));\n+        let unwrap_path = cx.expr_path(cx.path_global(span, cx.std_path(&[sym::option,\n+                                                                          sym::Option,\n+                                                                          sym::unwrap_or])));\n         cx.expr_call(span, unwrap_path, vec![cmp, default])\n     };\n \n@@ -256,9 +257,9 @@ fn cs_op(less: bool,\n \n             // `Ordering::then_with(Option::unwrap_or(..), ..)`\n             let then_with_path = cx.expr_path(cx.path_global(span,\n-                                                             cx.std_path(&[\"cmp\",\n-                                                                           \"Ordering\",\n-                                                                           \"then_with\"])));\n+                                                             cx.std_path(&[sym::cmp,\n+                                                                           sym::Ordering,\n+                                                                           sym::then_with])));\n             cx.expr_call(span, then_with_path, vec![par_cmp, cx.lambda0(span, subexpr)])\n         },\n         |cx, args| {"}, {"sha": "dec4c2dfc3b5eb50ccfdf05b8a84d6540bbf8df8", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -9,6 +9,7 @@ use syntax::ast::{Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n+use syntax::symbol::sym;\n use syntax_pos::{DUMMY_SP, Span};\n \n pub fn expand_deriving_debug(cx: &mut ExtCtxt<'_>,\n@@ -82,7 +83,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n \n                 let expr = cx.expr_method_call(span,\n                                                 builder_expr.clone(),\n-                                                Ident::from_str(\"field\"),\n+                                                Ident::with_empty_ctxt(sym::field),\n                                                 vec![field]);\n \n                 // Use `let _ = expr;` to avoid triggering the\n@@ -106,7 +107,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n                 let field = cx.expr_addr_of(field.span, field);\n                 let expr = cx.expr_method_call(span,\n                                                 builder_expr.clone(),\n-                                                Ident::from_str(\"field\"),\n+                                                Ident::with_empty_ctxt(sym::field),\n                                                 vec![name, field]);\n                 stmts.push(stmt_let_undescore(cx, span, expr));\n             }"}, {"sha": "fd8e87e2fefd17fc0674a7f096d4deb45e58a2ff", "filename": "src/libsyntax_ext/deriving/default.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -6,7 +6,7 @@ use syntax::ast::{Expr, MetaItem};\n use syntax::ext::base::{Annotatable, DummyResult, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::{kw, sym};\n use syntax::span_err;\n use syntax_pos::Span;\n \n@@ -15,7 +15,7 @@ pub fn expand_deriving_default(cx: &mut ExtCtxt<'_>,\n                                mitem: &MetaItem,\n                                item: &Annotatable,\n                                push: &mut dyn FnMut(Annotatable)) {\n-    let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n+    let inline = cx.meta_word(span, sym::inline);\n     let attrs = vec![cx.attribute(span, inline)];\n     let trait_def = TraitDef {\n         span,\n@@ -47,7 +47,8 @@ fn default_substructure(cx: &mut ExtCtxt<'_>,\n                         trait_span: Span,\n                         substr: &Substructure<'_>)\n                         -> P<Expr> {\n-    let default_ident = cx.std_path(&[\"default\", \"Default\", \"default\"]);\n+    // Note that `kw::Default` is \"default\" and `sym::Default` is \"Default\"!\n+    let default_ident = cx.std_path(&[kw::Default, sym::Default, kw::Default]);\n     let default_call = |span| cx.expr_call_global(span, default_ident.clone(), Vec::new());\n \n     return match *substr.fields {"}, {"sha": "7e3082a87d99252b532824d96d10a95115168091", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -666,14 +666,13 @@ impl<'a> TraitDef<'a> {\n         let self_type = cx.ty_path(path);\n \n         let attr = cx.attribute(self.span,\n-                                cx.meta_word(self.span,\n-                                             Symbol::intern(\"automatically_derived\")));\n+                                cx.meta_word(self.span, sym::automatically_derived));\n         // Just mark it now since we know that it'll end up used downstream\n         attr::mark_used(&attr);\n         let opt_trait_ref = Some(trait_ref);\n         let unused_qual = {\n             let word = cx.meta_list_item_word(self.span, Symbol::intern(\"unused_qualifications\"));\n-            cx.attribute(self.span, cx.meta_list(self.span, Symbol::intern(\"allow\"), vec![word]))\n+            cx.attribute(self.span, cx.meta_list(self.span, sym::allow, vec![word]))\n         };\n \n         let mut a = vec![attr, unused_qual];"}, {"sha": "e7f99d4578226382ea4c67f501c4488433bde4ff", "filename": "src/libsyntax_ext/deriving/hash.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -6,6 +6,7 @@ use syntax::ast::{Expr, MetaItem, Mutability};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n+use syntax::symbol::sym;\n use syntax_pos::Span;\n \n pub fn expand_deriving_hash(cx: &mut ExtCtxt<'_>,\n@@ -60,7 +61,7 @@ fn hash_substructure(cx: &mut ExtCtxt<'_>, trait_span: Span, substr: &Substructu\n     };\n     let call_hash = |span, thing_expr| {\n         let hash_path = {\n-            let strs = cx.std_path(&[\"hash\", \"Hash\", \"hash\"]);\n+            let strs = cx.std_path(&[sym::hash, sym::Hash, sym::hash]);\n \n             cx.expr_path(cx.path_global(span, strs))\n         };"}, {"sha": "ac41f30e6b39fafd57748a06c5010d50588bda8d", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -145,12 +145,12 @@ fn call_intrinsic(cx: &ExtCtxt<'_>,\n         span = span.with_ctxt(cx.backtrace());\n     } else { // Avoid instability errors with user defined curstom derives, cc #36316\n         let mut info = cx.current_expansion.mark.expn_info().unwrap();\n-        info.allow_internal_unstable = Some(vec![Symbol::intern(\"core_intrinsics\")].into());\n+        info.allow_internal_unstable = Some(vec![sym::core_intrinsics].into());\n         let mark = Mark::fresh(Mark::root());\n         mark.set_expn_info(info);\n         span = span.with_ctxt(SyntaxContext::empty().apply_mark(mark));\n     }\n-    let path = cx.std_path(&[\"intrinsics\", intrinsic]);\n+    let path = cx.std_path(&[sym::intrinsics, Symbol::intern(intrinsic)]);\n     let call = cx.expr_call_global(span, path, args);\n \n     cx.expr_block(P(ast::Block {"}, {"sha": "b7f2ecf0f9137b9931b40aecca232d8df3a18f5f", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -27,7 +27,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt<'_>,\n             let lt = cx.lifetime(sp, Ident::with_empty_ctxt(kw::StaticLifetime));\n             cx.expr_path(cx.path_all(sp,\n                                      true,\n-                                     cx.std_path(&[\"option\", \"Option\", \"None\"]),\n+                                     cx.std_path(&[sym::option, sym::Option, sym::None]),\n                                      vec![GenericArg::Type(cx.ty_rptr(sp,\n                                                      cx.ty_ident(sp,\n                                                                  Ident::with_empty_ctxt(sym::str)),\n@@ -37,7 +37,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt<'_>,\n         }\n         Ok(s) => {\n             cx.expr_call_global(sp,\n-                                cx.std_path(&[\"option\", \"Option\", \"Some\"]),\n+                                cx.std_path(&[sym::option, sym::Option, sym::Some]),\n                                 vec![cx.expr_str(sp, Symbol::intern(&s))])\n         }\n     };"}, {"sha": "b5be45547cfbe3149545aa775736162bdef7ac7b", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -387,7 +387,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     }\n \n     fn rtpath(ecx: &ExtCtxt<'_>, s: &str) -> Vec<ast::Ident> {\n-        ecx.std_path(&[\"fmt\", \"rt\", \"v1\", s])\n+        ecx.std_path(&[sym::fmt, sym::rt, sym::v1, Symbol::intern(s)])\n     }\n \n     fn build_count(&self, c: parse::Count<'_>) -> P<ast::Expr> {\n@@ -644,7 +644,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             (\"new_v1_formatted\", vec![pieces, args_slice, fmt])\n         };\n \n-        let path = self.ecx.std_path(&[\"fmt\", \"Arguments\", fn_name]);\n+        let path = self.ecx.std_path(&[sym::fmt, sym::Arguments, Symbol::intern(fn_name)]);\n         self.ecx.expr_call_global(self.macsp, path, fn_args)\n     }\n \n@@ -675,14 +675,14 @@ impl<'a, 'b> Context<'a, 'b> {\n                 }\n             }\n             Count => {\n-                let path = ecx.std_path(&[\"fmt\", \"ArgumentV1\", \"from_usize\"]);\n+                let path = ecx.std_path(&[sym::fmt, sym::ArgumentV1, sym::from_usize]);\n                 return ecx.expr_call_global(macsp, path, vec![arg]);\n             }\n         };\n \n-        let path = ecx.std_path(&[\"fmt\", trait_, \"fmt\"]);\n+        let path = ecx.std_path(&[sym::fmt, Symbol::intern(trait_), sym::fmt]);\n         let format_fn = ecx.path_global(sp, path);\n-        let path = ecx.std_path(&[\"fmt\", \"ArgumentV1\", \"new\"]);\n+        let path = ecx.std_path(&[sym::fmt, sym::ArgumentV1, sym::new]);\n         ecx.expr_call_global(macsp, path, vec![arg, ecx.expr_path(format_fn)])\n     }\n }"}, {"sha": "fc0015442750123062ad42535a0fca8a2ae18238", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -42,8 +42,8 @@ pub mod proc_macro_impl;\n use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n use syntax::ext::base::{MacroExpanderFn, NormalTT, NamedSyntaxExtension, MultiModifier};\n-use syntax::symbol::Symbol;\n use syntax::edition::Edition;\n+use syntax::symbol::{sym, Symbol};\n \n pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n                          user_exts: Vec<NamedSyntaxExtension>,\n@@ -93,30 +93,26 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n         assert: assert::expand_assert,\n     }\n \n-    register(Symbol::intern(\"test_case\"), MultiModifier(Box::new(test_case::expand)));\n-    register(Symbol::intern(\"test\"), MultiModifier(Box::new(test::expand_test)));\n-    register(Symbol::intern(\"bench\"), MultiModifier(Box::new(test::expand_bench)));\n+    register(sym::test_case, MultiModifier(Box::new(test_case::expand)));\n+    register(sym::test, MultiModifier(Box::new(test::expand_test)));\n+    register(sym::bench, MultiModifier(Box::new(test::expand_bench)));\n \n     // format_args uses `unstable` things internally.\n     register(Symbol::intern(\"format_args\"),\n              NormalTT {\n                 expander: Box::new(format::expand_format_args),\n                 def_info: None,\n-                allow_internal_unstable: Some(vec![\n-                    Symbol::intern(\"fmt_internals\"),\n-                ].into()),\n+                allow_internal_unstable: Some(vec![sym::fmt_internals].into()),\n                 allow_internal_unsafe: false,\n                 local_inner_macros: false,\n                 unstable_feature: None,\n                 edition,\n             });\n-    register(Symbol::intern(\"format_args_nl\"),\n+    register(sym::format_args_nl,\n              NormalTT {\n                  expander: Box::new(format::expand_format_args_nl),\n                  def_info: None,\n-                 allow_internal_unstable: Some(vec![\n-                     Symbol::intern(\"fmt_internals\"),\n-                 ].into()),\n+                 allow_internal_unstable: Some(vec![sym::fmt_internals].into()),\n                  allow_internal_unsafe: false,\n                  local_inner_macros: false,\n                  unstable_feature: None,"}, {"sha": "5b8f4f35f2dd10f9f57d39a2617b8d4d887a0e10", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -351,9 +351,9 @@ fn mk_decls(\n     mark.set_expn_info(ExpnInfo {\n         call_site: DUMMY_SP,\n         def_site: None,\n-        format: MacroAttribute(Symbol::intern(\"proc_macro\")),\n+        format: MacroAttribute(sym::proc_macro),\n         allow_internal_unstable: Some(vec![\n-            Symbol::intern(\"rustc_attrs\"),\n+            sym::rustc_attrs,\n             Symbol::intern(\"proc_macro_internals\"),\n         ].into()),\n         allow_internal_unsafe: false,\n@@ -420,7 +420,7 @@ fn mk_decls(\n         ast::Mutability::Immutable,\n         cx.expr_vec_slice(span, decls),\n     ).map(|mut i| {\n-        let attr = cx.meta_word(span, Symbol::intern(\"rustc_proc_macro_decls\"));\n+        let attr = cx.meta_word(span, sym::rustc_proc_macro_decls);\n         i.attrs.push(cx.attribute(span, attr));\n         i.vis = respan(span, ast::VisibilityKind::Public);\n         i"}, {"sha": "53730d2d080223010ac2892edfc86fd94f9af206", "filename": "src/libsyntax_ext/proc_macro_server.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_server.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -14,7 +14,7 @@ use syntax::parse::lexer::comments;\n use syntax::parse::{self, token, ParseSess};\n use syntax::tokenstream::{self, DelimSpan, IsJoint::*, TokenStream, TreeAndJoint};\n use syntax_pos::hygiene::{SyntaxContext, Transparency};\n-use syntax_pos::symbol::{kw, Symbol};\n+use syntax_pos::symbol::{kw, sym, Symbol};\n use syntax_pos::{BytePos, FileName, MultiSpan, Pos, SourceFile, Span};\n \n trait FromInternal<T> {\n@@ -159,7 +159,7 @@ impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n                     escaped.extend(ch.escape_debug());\n                 }\n                 let stream = vec![\n-                    Ident(ast::Ident::new(Symbol::intern(\"doc\"), span), false),\n+                    Ident(ast::Ident::new(sym::doc, span), false),\n                     Eq,\n                     Token::lit(token::Str, Symbol::intern(&escaped), None),\n                 ]"}, {"sha": "c20dc6cb2d7cdbb9ecd9f297384f2c7e7d926538", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -65,11 +65,8 @@ pub fn expand_test_or_bench(\n         mark.set_expn_info(ExpnInfo {\n             call_site: DUMMY_SP,\n             def_site: None,\n-            format: MacroAttribute(Symbol::intern(\"test\")),\n-            allow_internal_unstable: Some(vec![\n-                Symbol::intern(\"rustc_attrs\"),\n-                Symbol::intern(\"test\"),\n-            ].into()),\n+            format: MacroAttribute(sym::test),\n+            allow_internal_unstable: Some(vec![sym::rustc_attrs, sym::test].into()),\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n             edition: cx.parse_sess.edition,\n@@ -130,11 +127,11 @@ pub fn expand_test_or_bench(\n     let mut test_const = cx.item(sp, ast::Ident::new(item.ident.name, sp).gensym(),\n         vec![\n             // #[cfg(test)]\n-            cx.attribute(attr_sp, cx.meta_list(attr_sp, Symbol::intern(\"cfg\"), vec![\n-                cx.meta_list_item_word(attr_sp, Symbol::intern(\"test\"))\n+            cx.attribute(attr_sp, cx.meta_list(attr_sp, sym::cfg, vec![\n+                cx.meta_list_item_word(attr_sp, sym::test)\n             ])),\n             // #[rustc_test_marker]\n-            cx.attribute(attr_sp, cx.meta_word(attr_sp, Symbol::intern(\"rustc_test_marker\"))),\n+            cx.attribute(attr_sp, cx.meta_word(attr_sp, sym::rustc_test_marker)),\n         ],\n         // const $ident: test::TestDescAndFn =\n         ast::ItemKind::Const(cx.ty(sp, ast::TyKind::Path(None, test_path(\"TestDescAndFn\"))),\n@@ -180,7 +177,7 @@ pub fn expand_test_or_bench(\n     let test_extern = cx.item(sp,\n         test_id,\n         vec![],\n-        ast::ItemKind::ExternCrate(Some(Symbol::intern(\"test\")))\n+        ast::ItemKind::ExternCrate(Some(sym::test))\n     );\n \n     log::debug!(\"Synthetic test item:\\n{}\\n\", pprust::item_to_string(&test_const));"}, {"sha": "cffecdd0f18e79fdb02734b112b205b028a1e84b", "filename": "src/libsyntax_ext/test_case.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Ftest_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_ext%2Ftest_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_case.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -14,7 +14,7 @@ use syntax::ext::build::AstBuilder;\n use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ast;\n use syntax::source_map::respan;\n-use syntax::symbol::{Symbol, sym};\n+use syntax::symbol::sym;\n use syntax_pos::{DUMMY_SP, Span};\n use syntax::source_map::{ExpnInfo, MacroAttribute};\n use syntax::feature_gate;\n@@ -40,11 +40,8 @@ pub fn expand(\n         mark.set_expn_info(ExpnInfo {\n             call_site: DUMMY_SP,\n             def_site: None,\n-            format: MacroAttribute(Symbol::intern(\"test_case\")),\n-            allow_internal_unstable: Some(vec![\n-                Symbol::intern(\"test\"),\n-                Symbol::intern(\"rustc_attrs\"),\n-            ].into()),\n+            format: MacroAttribute(sym::test_case),\n+            allow_internal_unstable: Some(vec![sym::test, sym::rustc_attrs].into()),\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n             edition: ecx.parse_sess.edition,\n@@ -59,7 +56,7 @@ pub fn expand(\n         item.ident = item.ident.gensym();\n         item.attrs.push(\n             ecx.attribute(sp,\n-                ecx.meta_word(sp, Symbol::intern(\"rustc_test_marker\")))\n+                ecx.meta_word(sp, sym::rustc_test_marker))\n         );\n         item\n     });"}, {"sha": "60f87783b3e119d974e009fdc02b55665f70282b", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 58, "deletions": 2, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7cf71d4c6dd1696cb0eb52ad172bce296578cc/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=ab7cf71d4c6dd1696cb0eb52ad172bce296578cc", "patch": "@@ -9,10 +9,10 @@ use rustc_data_structures::newtype_index;\n use rustc_macros::symbols;\n use serialize::{Decodable, Decoder, Encodable, Encoder};\n \n-use std::fmt;\n-use std::str;\n use std::cmp::{PartialEq, Ordering, PartialOrd, Ord};\n+use std::fmt;\n use std::hash::{Hash, Hasher};\n+use std::str;\n \n use crate::hygiene::SyntaxContext;\n use crate::{Span, DUMMY_SP, GLOBALS};\n@@ -102,6 +102,9 @@ symbols! {\n     // Symbols that can be referred to with syntax_pos::sym::*. The symbol is\n     // the stringified identifier unless otherwise specified (e.g.\n     // `proc_dash_macro` represents \"proc-macro\").\n+    //\n+    // As well as the symbols listed, there are symbols for the the strings\n+    // \"0\", \"1\", ..., \"9\", which are accessible via `sym::integer`.\n     Symbols {\n         aarch64_target_feature,\n         abi,\n@@ -130,8 +133,11 @@ symbols! {\n         allow_internal_unstable,\n         allow_internal_unstable_backcompat_hack,\n         always,\n+        and,\n         any,\n         arbitrary_self_types,\n+        Arguments,\n+        ArgumentV1,\n         arm_target_feature,\n         asm,\n         associated_consts,\n@@ -145,6 +151,8 @@ symbols! {\n         automatically_derived,\n         avx512_target_feature,\n         await_macro,\n+        begin_panic,\n+        bench,\n         bin,\n         bind_by_move_pattern_guards,\n         block,\n@@ -163,9 +171,11 @@ symbols! {\n         cfg_target_thread_local,\n         cfg_target_vendor,\n         clone,\n+        Clone,\n         clone_closures,\n         clone_from,\n         closure_to_fn_coercion,\n+        cmp,\n         cmpxchg16b_target_feature,\n         cold,\n         compile_error,\n@@ -199,11 +209,14 @@ symbols! {\n         custom_test_frameworks,\n         c_variadic,\n         decl_macro,\n+        Default,\n         default_lib_allocator,\n         default_type_parameter_fallback,\n         default_type_params,\n         deny,\n         deprecated,\n+        deref,\n+        deref_mut,\n         derive,\n         doc,\n         doc_alias,\n@@ -231,13 +244,15 @@ symbols! {\n         enable,\n         err,\n         Err,\n+        Equal,\n         except,\n         exclusive_range_pattern,\n         exhaustive_integer_patterns,\n         exhaustive_patterns,\n         existential_type,\n         expected,\n         export_name,\n+        expr,\n         extern_absolute_paths,\n         external_doc,\n         extern_crate_item_prelude,\n@@ -250,8 +265,11 @@ symbols! {\n         f64,\n         feature,\n         ffi_returns_twice,\n+        field,\n         field_init_shorthand,\n         file,\n+        fmt,\n+        fmt_internals,\n         fn_must_use,\n         forbid,\n         format_args_nl,\n@@ -260,6 +278,7 @@ symbols! {\n         from_error,\n         from_generator,\n         from_ok,\n+        from_usize,\n         fundamental,\n         future,\n         Future,\n@@ -270,6 +289,8 @@ symbols! {\n         global_allocator,\n         global_asm,\n         globs,\n+        hash,\n+        Hash,\n         hexagon_target_feature,\n         hidden,\n         homogeneous_aggregate,\n@@ -291,6 +312,8 @@ symbols! {\n         impl_header_lifetime_elision,\n         impl_trait_in_bindings,\n         import_shadowing,\n+        index,\n+        index_mut,\n         in_band_lifetimes,\n         include,\n         inclusive_range_syntax,\n@@ -307,6 +330,7 @@ symbols! {\n         issue,\n         issue_5723_bootstrap,\n         issue_tracker_base_url,\n+        item,\n         item_like_imports,\n         iter,\n         Iterator,\n@@ -317,6 +341,7 @@ symbols! {\n         lang,\n         lang_items,\n         lib,\n+        lifetime,\n         link,\n         linkage,\n         link_args,\n@@ -325,6 +350,7 @@ symbols! {\n         link_name,\n         link_section,\n         lint_reasons,\n+        literal,\n         local_inner_macros,\n         log_syntax,\n         loop_break_value,\n@@ -364,6 +390,7 @@ symbols! {\n         negate_unsigned,\n         never,\n         never_type,\n+        new,\n         next,\n         __next,\n         nll,\n@@ -398,14 +425,21 @@ symbols! {\n         option,\n         Option,\n         opt_out_copy,\n+        or,\n+        Ord,\n+        Ordering,\n         Output,\n         overlapping_marker_traits,\n         packed,\n+        panic,\n         panic_handler,\n         panic_impl,\n         panic_implementation,\n         panic_runtime,\n+        partial_cmp,\n+        PartialOrd,\n         passes,\n+        pat,\n         path,\n         pattern_parentheses,\n         Pending,\n@@ -426,6 +460,7 @@ symbols! {\n         proc_dash_macro: \"proc-macro\",\n         proc_macro,\n         proc_macro_attribute,\n+        proc_macro_def_site,\n         proc_macro_derive,\n         proc_macro_expr,\n         proc_macro_gen,\n@@ -464,6 +499,7 @@ symbols! {\n         Result,\n         Return,\n         rlib,\n+        rt,\n         rtm_target_feature,\n         rust,\n         rust_2015_preview,\n@@ -547,6 +583,7 @@ symbols! {\n         static_recursion,\n         std,\n         str,\n+        stmt,\n         stmt_expr_attributes,\n         stop_after_dataflow,\n         struct_field_attributes,\n@@ -564,8 +601,10 @@ symbols! {\n         test,\n         test_2018_feature,\n         test_accepted_feature,\n+        test_case,\n         test_removed_feature,\n         test_runner,\n+        then_with,\n         thread_local,\n         tool_attributes,\n         tool_lints,\n@@ -577,6 +616,7 @@ symbols! {\n         Try,\n         try_blocks,\n         try_trait,\n+        tt,\n         tuple_indexing,\n         ty,\n         type_alias_enum_variants,\n@@ -605,12 +645,15 @@ symbols! {\n         untagged_unions,\n         unwind,\n         unwind_attributes,\n+        unwrap_or,\n         used,\n         use_extern_macros,\n         use_nested_groups,\n         usize,\n         v1,\n         val,\n+        vec,\n+        Vec,\n         vis,\n         visible_private_types,\n         volatile,\n@@ -935,8 +978,21 @@ pub mod kw {\n \n // This module has a very short name because it's used a lot.\n pub mod sym {\n+    use std::convert::TryInto;\n     use super::Symbol;\n+\n     symbols!();\n+\n+    // Get the symbol for an integer. The first few non-negative integers each\n+    // have a static symbol and therefore are fast.\n+    pub fn integer<N: TryInto<usize> + Copy + ToString>(n: N) -> Symbol {\n+        if let Result::Ok(idx) = n.try_into() {\n+            if let Option::Some(&sym) = digits_array.get(idx) {\n+                return sym;\n+            }\n+        }\n+        Symbol::intern(&n.to_string())\n+    }\n }\n \n impl Symbol {"}]}