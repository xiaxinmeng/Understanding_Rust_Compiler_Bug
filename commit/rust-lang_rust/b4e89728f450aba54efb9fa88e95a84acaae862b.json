{"sha": "b4e89728f450aba54efb9fa88e95a84acaae862b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0ZTg5NzI4ZjQ1MGFiYTU0ZWZiOWZhODhlOTVhODRhY2FhZTg2MmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-07T04:53:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-07T04:53:29Z"}, "message": "Auto merge of #36753 - srinivasreddy:hash, r=nrc\n\nrun rustfmt on libstd/collections/hash folder", "tree": {"sha": "ea782e6767fd61a1283d7391ad6bbbc8be5dcffc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea782e6767fd61a1283d7391ad6bbbc8be5dcffc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4e89728f450aba54efb9fa88e95a84acaae862b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4e89728f450aba54efb9fa88e95a84acaae862b", "html_url": "https://github.com/rust-lang/rust/commit/b4e89728f450aba54efb9fa88e95a84acaae862b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4e89728f450aba54efb9fa88e95a84acaae862b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75c155b834e3bd667ca50187741c1b7abbf9e3df", "url": "https://api.github.com/repos/rust-lang/rust/commits/75c155b834e3bd667ca50187741c1b7abbf9e3df", "html_url": "https://github.com/rust-lang/rust/commit/75c155b834e3bd667ca50187741c1b7abbf9e3df"}, {"sha": "45f2b6abb54c121dc7f7b60c9c6692f54a0d2f5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/45f2b6abb54c121dc7f7b60c9c6692f54a0d2f5c", "html_url": "https://github.com/rust-lang/rust/commit/45f2b6abb54c121dc7f7b60c9c6692f54a0d2f5c"}], "stats": {"total": 717, "additions": 438, "deletions": 279}, "files": [{"sha": "ff6cb7985a4de3a90b39646e518984e6d2feb36c", "filename": "src/libstd/collections/hash/bench.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b4e89728f450aba54efb9fa88e95a84acaae862b/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e89728f450aba54efb9fa88e95a84acaae862b/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fbench.rs?ref=b4e89728f450aba54efb9fa88e95a84acaae862b", "patch": "@@ -15,17 +15,17 @@ extern crate test;\n use self::test::Bencher;\n \n #[bench]\n-fn new_drop(b : &mut Bencher) {\n+fn new_drop(b: &mut Bencher) {\n     use super::map::HashMap;\n \n     b.iter(|| {\n-        let m : HashMap<i32, i32> = HashMap::new();\n+        let m: HashMap<i32, i32> = HashMap::new();\n         assert_eq!(m.len(), 0);\n     })\n }\n \n #[bench]\n-fn new_insert_drop(b : &mut Bencher) {\n+fn new_insert_drop(b: &mut Bencher) {\n     use super::map::HashMap;\n \n     b.iter(|| {"}, {"sha": "fb8a0c3c265547269bc0c81baa8bf0b60d39938c", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 264, "deletions": 184, "changes": 448, "blob_url": "https://github.com/rust-lang/rust/blob/b4e89728f450aba54efb9fa88e95a84acaae862b/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e89728f450aba54efb9fa88e95a84acaae862b/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=b4e89728f450aba54efb9fa88e95a84acaae862b", "patch": "@@ -21,19 +21,8 @@ use mem::{self, replace};\n use ops::{Deref, Index};\n use rand::{self, Rng};\n \n-use super::table::{\n-    self,\n-    Bucket,\n-    EmptyBucket,\n-    FullBucket,\n-    FullBucketMut,\n-    RawTable,\n-    SafeHash\n-};\n-use super::table::BucketState::{\n-    Empty,\n-    Full,\n-};\n+use super::table::{self, Bucket, EmptyBucket, FullBucket, FullBucketMut, RawTable, SafeHash};\n+use super::table::BucketState::{Empty, Full};\n \n const MIN_NONZERO_RAW_CAPACITY: usize = 32;     // must be a power of two\n \n@@ -370,12 +359,9 @@ pub struct HashMap<K, V, S = RandomState> {\n \n /// Search for a pre-hashed key.\n #[inline]\n-fn search_hashed<K, V, M, F>(table: M,\n-                             hash: SafeHash,\n-                             mut is_match: F)\n-                             -> InternalEntry<K, V, M> where\n-    M: Deref<Target=RawTable<K, V>>,\n-    F: FnMut(&K) -> bool,\n+fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F) -> InternalEntry<K, V, M>\n+    where M: Deref<Target = RawTable<K, V>>,\n+          F: FnMut(&K) -> bool\n {\n     // This is the only function where capacity can be zero. To avoid\n     // undefined behavior when Bucket::new gets the raw bucket in this\n@@ -397,7 +383,7 @@ fn search_hashed<K, V, M, F>(table: M,\n                     elem: NoElem(bucket),\n                 };\n             }\n-            Full(bucket) => bucket\n+            Full(bucket) => bucket,\n         };\n \n         let robin_ib = full.index() as isize - full.displacement() as isize;\n@@ -416,9 +402,7 @@ fn search_hashed<K, V, M, F>(table: M,\n         if hash == full.hash() {\n             // If the key doesn't match, it can't be this one..\n             if is_match(full.read().0) {\n-                return InternalEntry::Occupied {\n-                    elem: full\n-                };\n+                return InternalEntry::Occupied { elem: full };\n             }\n         }\n \n@@ -431,13 +415,13 @@ fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) {\n     let (empty, retkey, retval) = starting_bucket.take();\n     let mut gap = match empty.gap_peek() {\n         Some(b) => b,\n-        None => return (retkey, retval)\n+        None => return (retkey, retval),\n     };\n \n     while gap.full().displacement() != 0 {\n         gap = match gap.shift() {\n             Some(b) => b,\n-            None => break\n+            None => break,\n         };\n     }\n \n@@ -451,11 +435,11 @@ fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) {\n ///\n /// `hash`, `k`, and `v` are the elements to \"robin hood\" into the hashtable.\n fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n-                        mut ib: usize,\n-                        mut hash: SafeHash,\n-                        mut key: K,\n-                        mut val: V)\n-                        -> &'a mut V {\n+                                mut ib: usize,\n+                                mut hash: SafeHash,\n+                                mut key: K,\n+                                mut val: V)\n+                                -> &'a mut V {\n     let starting_index = bucket.index();\n     let size = bucket.table().size();\n     // Save the *starting point*.\n@@ -487,8 +471,8 @@ fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n                     // FullBucketMut, into just one FullBucketMut. The \"table\"\n                     // refers to the inner FullBucketMut in this context.\n                     return bucket.into_table().into_mut_refs().1;\n-                },\n-                Full(bucket) => bucket\n+                }\n+                Full(bucket) => bucket,\n             };\n \n             let probe_ib = full_bucket.index() - full_bucket.displacement();\n@@ -505,9 +489,12 @@ fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n }\n \n impl<K, V, S> HashMap<K, V, S>\n-    where K: Eq + Hash, S: BuildHasher\n+    where K: Eq + Hash,\n+          S: BuildHasher\n {\n-    fn make_hash<X: ?Sized>(&self, x: &X) -> SafeHash where X: Hash {\n+    fn make_hash<X: ?Sized>(&self, x: &X) -> SafeHash\n+        where X: Hash\n+    {\n         table::make_hash(&self.hash_builder, x)\n     }\n \n@@ -516,15 +503,17 @@ impl<K, V, S> HashMap<K, V, S>\n     /// search_hashed.\n     #[inline]\n     fn search<'a, Q: ?Sized>(&'a self, q: &Q) -> InternalEntry<K, V, &'a RawTable<K, V>>\n-        where K: Borrow<Q>, Q: Eq + Hash\n+        where K: Borrow<Q>,\n+              Q: Eq + Hash\n     {\n         let hash = self.make_hash(q);\n         search_hashed(&self.table, hash, |k| q.eq(k.borrow()))\n     }\n \n     #[inline]\n     fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q) -> InternalEntry<K, V, &'a mut RawTable<K, V>>\n-        where K: Borrow<Q>, Q: Eq + Hash\n+        where K: Borrow<Q>,\n+              Q: Eq + Hash\n     {\n         let hash = self.make_hash(q);\n         search_hashed(&mut self.table, hash, |k| q.eq(k.borrow()))\n@@ -544,7 +533,7 @@ impl<K, V, S> HashMap<K, V, S>\n                     empty.put(hash, k, v);\n                     return;\n                 }\n-                Full(b) => b.into_bucket()\n+                Full(b) => b.into_bucket(),\n             };\n             buckets.next();\n         }\n@@ -586,7 +575,8 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomState> {\n }\n \n impl<K, V, S> HashMap<K, V, S>\n-    where K: Eq + Hash, S: BuildHasher\n+    where K: Eq + Hash,\n+          S: BuildHasher\n {\n     /// Creates an empty `HashMap` which will use the given hash builder to hash\n     /// keys.\n@@ -640,8 +630,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n-    pub fn with_capacity_and_hasher(capacity: usize, hash_builder: S)\n-                                    -> HashMap<K, V, S> {\n+    pub fn with_capacity_and_hasher(capacity: usize, hash_builder: S) -> HashMap<K, V, S> {\n         let resize_policy = DefaultResizePolicy::new();\n         let raw_cap = resize_policy.raw_capacity(capacity);\n         HashMap {\n@@ -779,7 +768,7 @@ impl<K, V, S> HashMap<K, V, S>\n                     }\n                     b.into_bucket()\n                 }\n-                Empty(b) => b.into_bucket()\n+                Empty(b) => b.into_bucket(),\n             };\n             bucket.next();\n         }\n@@ -828,16 +817,12 @@ impl<K, V, S> HashMap<K, V, S>\n     fn insert_hashed_nocheck(&mut self, hash: SafeHash, k: K, v: V) -> Option<V> {\n         let entry = search_hashed(&mut self.table, hash, |key| *key == k).into_entry(k);\n         match entry {\n-            Some(Occupied(mut elem)) => {\n-                Some(elem.insert(v))\n-            }\n+            Some(Occupied(mut elem)) => Some(elem.insert(v)),\n             Some(Vacant(elem)) => {\n                 elem.insert(v);\n                 None\n             }\n-            None => {\n-                unreachable!()\n-            }\n+            None => unreachable!(),\n         }\n     }\n \n@@ -1001,7 +986,9 @@ impl<K, V, S> HashMap<K, V, S>\n     /// assert_eq!(a.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize { self.table.size() }\n+    pub fn len(&self) -> usize {\n+        self.table.size()\n+    }\n \n     /// Returns true if the map contains no elements.\n     ///\n@@ -1017,7 +1004,9 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+    pub fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n \n     /// Clears the map, returning all key-value pairs as an iterator. Keeps the\n     /// allocated memory for reuse.\n@@ -1041,9 +1030,7 @@ impl<K, V, S> HashMap<K, V, S>\n     #[inline]\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n     pub fn drain(&mut self) -> Drain<K, V> {\n-        Drain {\n-            inner: self.table.drain(),\n-        }\n+        Drain { inner: self.table.drain() }\n     }\n \n     /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n@@ -1086,7 +1073,8 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n-        where K: Borrow<Q>, Q: Hash + Eq\n+        where K: Borrow<Q>,\n+              Q: Hash + Eq\n     {\n         self.search(k).into_occupied_bucket().map(|bucket| bucket.into_refs().1)\n     }\n@@ -1112,7 +1100,8 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n-        where K: Borrow<Q>, Q: Hash + Eq\n+        where K: Borrow<Q>,\n+              Q: Hash + Eq\n     {\n         self.search(k).into_occupied_bucket().is_some()\n     }\n@@ -1140,7 +1129,8 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n-        where K: Borrow<Q>, Q: Hash + Eq\n+        where K: Borrow<Q>,\n+              Q: Hash + Eq\n     {\n         self.search_mut(k).into_occupied_bucket().map(|bucket| bucket.into_mut_refs().1)\n     }\n@@ -1198,10 +1188,11 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>\n-        where K: Borrow<Q>, Q: Hash + Eq\n+        where K: Borrow<Q>,\n+              Q: Hash + Eq\n     {\n         if self.table.size() == 0 {\n-            return None\n+            return None;\n         }\n \n         self.search_mut(k).into_occupied_bucket().map(|bucket| pop_internal(bucket).1)\n@@ -1210,25 +1201,32 @@ impl<K, V, S> HashMap<K, V, S>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> PartialEq for HashMap<K, V, S>\n-    where K: Eq + Hash, V: PartialEq, S: BuildHasher\n+    where K: Eq + Hash,\n+          V: PartialEq,\n+          S: BuildHasher\n {\n     fn eq(&self, other: &HashMap<K, V, S>) -> bool {\n-        if self.len() != other.len() { return false; }\n+        if self.len() != other.len() {\n+            return false;\n+        }\n \n-        self.iter().all(|(key, value)|\n-            other.get(key).map_or(false, |v| *value == *v)\n-        )\n+        self.iter().all(|(key, value)| other.get(key).map_or(false, |v| *value == *v))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> Eq for HashMap<K, V, S>\n-    where K: Eq + Hash, V: Eq, S: BuildHasher\n-{}\n+    where K: Eq + Hash,\n+          V: Eq,\n+          S: BuildHasher\n+{\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> Debug for HashMap<K, V, S>\n-    where K: Eq + Hash + Debug, V: Debug, S: BuildHasher\n+    where K: Eq + Hash + Debug,\n+          V: Debug,\n+          S: BuildHasher\n {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_map().entries(self.iter()).finish()\n@@ -1238,7 +1236,7 @@ impl<K, V, S> Debug for HashMap<K, V, S>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> Default for HashMap<K, V, S>\n     where K: Eq + Hash,\n-          S: BuildHasher + Default,\n+          S: BuildHasher + Default\n {\n     /// Creates an empty `HashMap<K, V, S>`, with the `Default` value for the hasher.\n     fn default() -> HashMap<K, V, S> {\n@@ -1250,7 +1248,7 @@ impl<K, V, S> Default for HashMap<K, V, S>\n impl<'a, K, Q: ?Sized, V, S> Index<&'a Q> for HashMap<K, V, S>\n     where K: Eq + Hash + Borrow<Q>,\n           Q: Eq + Hash,\n-          S: BuildHasher,\n+          S: BuildHasher\n {\n     type Output = V;\n \n@@ -1263,79 +1261,71 @@ impl<'a, K, Q: ?Sized, V, S> Index<&'a Q> for HashMap<K, V, S>\n /// HashMap iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a, V: 'a> {\n-    inner: table::Iter<'a, K, V>\n+    inner: table::Iter<'a, K, V>,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Clone for Iter<'a, K, V> {\n     fn clone(&self) -> Iter<'a, K, V> {\n-        Iter {\n-            inner: self.inner.clone()\n-        }\n+        Iter { inner: self.inner.clone() }\n     }\n }\n \n /// HashMap mutable values iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, K: 'a, V: 'a> {\n-    inner: table::IterMut<'a, K, V>\n+    inner: table::IterMut<'a, K, V>,\n }\n \n /// HashMap move iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n-    inner: table::IntoIter<K, V>\n+    inner: table::IntoIter<K, V>,\n }\n \n /// HashMap keys iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, K: 'a, V: 'a> {\n-    inner: Iter<'a, K, V>\n+    inner: Iter<'a, K, V>,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Clone for Keys<'a, K, V> {\n     fn clone(&self) -> Keys<'a, K, V> {\n-        Keys {\n-            inner: self.inner.clone()\n-        }\n+        Keys { inner: self.inner.clone() }\n     }\n }\n \n /// HashMap values iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, K: 'a, V: 'a> {\n-    inner: Iter<'a, K, V>\n+    inner: Iter<'a, K, V>,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Clone for Values<'a, K, V> {\n     fn clone(&self) -> Values<'a, K, V> {\n-        Values {\n-            inner: self.inner.clone()\n-        }\n+        Values { inner: self.inner.clone() }\n     }\n }\n \n /// HashMap drain iterator.\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n pub struct Drain<'a, K: 'a, V: 'a> {\n-    inner: table::Drain<'a, K, V>\n+    inner: table::Drain<'a, K, V>,\n }\n \n /// Mutable HashMap values iterator.\n #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n pub struct ValuesMut<'a, K: 'a, V: 'a> {\n-    inner: IterMut<'a, K, V>\n+    inner: IterMut<'a, K, V>,\n }\n \n enum InternalEntry<K, V, M> {\n-    Occupied {\n-        elem: FullBucket<K, V, M>,\n-    },\n+    Occupied { elem: FullBucket<K, V, M> },\n     Vacant {\n         hash: SafeHash,\n         elem: VacantEntryState<K, V, M>,\n@@ -1360,7 +1350,7 @@ impl<'a, K, V> InternalEntry<K, V, &'a mut RawTable<K, V>> {\n             InternalEntry::Occupied { elem } => {\n                 Some(Occupied(OccupiedEntry {\n                     key: Some(key),\n-                    elem: elem\n+                    elem: elem,\n                 }))\n             }\n             InternalEntry::Vacant { hash, elem } => {\n@@ -1370,7 +1360,7 @@ impl<'a, K, V> InternalEntry<K, V, &'a mut RawTable<K, V>> {\n                     elem: elem,\n                 }))\n             }\n-            InternalEntry::TableIsEmpty => None\n+            InternalEntry::TableIsEmpty => None,\n         }\n     }\n }\n@@ -1384,27 +1374,29 @@ impl<'a, K, V> InternalEntry<K, V, &'a mut RawTable<K, V>> {\n pub enum Entry<'a, K: 'a, V: 'a> {\n     /// An occupied Entry.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Occupied(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")] OccupiedEntry<'a, K, V>\n-    ),\n+    Occupied(#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+             OccupiedEntry<'a, K, V>),\n \n     /// A vacant Entry.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Vacant(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")] VacantEntry<'a, K, V>\n-    ),\n+    Vacant(#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+           VacantEntry<'a, K, V>),\n }\n \n #[stable(feature= \"debug_hash_map\", since = \"1.12.0\")]\n impl<'a, K: 'a + Debug, V: 'a + Debug> Debug for Entry<'a, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            Vacant(ref v) => f.debug_tuple(\"Entry\")\n-                              .field(v)\n-                              .finish(),\n-            Occupied(ref o) => f.debug_tuple(\"Entry\")\n-                                .field(o)\n-                                .finish(),\n+            Vacant(ref v) => {\n+                f.debug_tuple(\"Entry\")\n+                    .field(v)\n+                    .finish()\n+            }\n+            Occupied(ref o) => {\n+                f.debug_tuple(\"Entry\")\n+                    .field(o)\n+                    .finish()\n+            }\n         }\n     }\n }\n@@ -1423,9 +1415,9 @@ pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n impl<'a, K: 'a + Debug, V: 'a + Debug> Debug for OccupiedEntry<'a, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_struct(\"OccupiedEntry\")\n-         .field(\"key\", self.key())\n-         .field(\"value\", self.get())\n-         .finish()\n+            .field(\"key\", self.key())\n+            .field(\"value\", self.get())\n+            .finish()\n     }\n }\n \n@@ -1444,8 +1436,8 @@ pub struct VacantEntry<'a, K: 'a, V: 'a> {\n impl<'a, K: 'a + Debug, V: 'a> Debug for VacantEntry<'a, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_tuple(\"VacantEntry\")\n-         .field(self.key())\n-         .finish()\n+            .field(self.key())\n+            .finish()\n     }\n }\n \n@@ -1460,7 +1452,8 @@ enum VacantEntryState<K, V, M> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V, S> IntoIterator for &'a HashMap<K, V, S>\n-    where K: Eq + Hash, S: BuildHasher\n+    where K: Eq + Hash,\n+          S: BuildHasher\n {\n     type Item = (&'a K, &'a V);\n     type IntoIter = Iter<'a, K, V>;\n@@ -1472,7 +1465,8 @@ impl<'a, K, V, S> IntoIterator for &'a HashMap<K, V, S>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V, S> IntoIterator for &'a mut HashMap<K, V, S>\n-    where K: Eq + Hash, S: BuildHasher\n+    where K: Eq + Hash,\n+          S: BuildHasher\n {\n     type Item = (&'a K, &'a mut V);\n     type IntoIter = IterMut<'a, K, V>;\n@@ -1484,7 +1478,8 @@ impl<'a, K, V, S> IntoIterator for &'a mut HashMap<K, V, S>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> IntoIterator for HashMap<K, V, S>\n-    where K: Eq + Hash, S: BuildHasher\n+    where K: Eq + Hash,\n+          S: BuildHasher\n {\n     type Item = (K, V);\n     type IntoIter = IntoIter<K, V>;\n@@ -1507,22 +1502,29 @@ impl<K, V, S> IntoIterator for HashMap<K, V, S>\n     /// let vec: Vec<(&str, isize)> = map.into_iter().collect();\n     /// ```\n     fn into_iter(self) -> IntoIter<K, V> {\n-        IntoIter {\n-            inner: self.table.into_iter()\n-        }\n+        IntoIter { inner: self.table.into_iter() }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Iter<'a, K, V> {\n     type Item = (&'a K, &'a V);\n \n-    #[inline] fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    #[inline]\n+    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n+        self.inner.next()\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> {\n-    #[inline] fn len(&self) -> usize { self.inner.len() }\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n@@ -1532,12 +1534,21 @@ impl<'a, K, V> FusedIterator for Iter<'a, K, V> {}\n impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n     type Item = (&'a K, &'a mut V);\n \n-    #[inline] fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    #[inline]\n+    fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n+        self.inner.next()\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {\n-    #[inline] fn len(&self) -> usize { self.inner.len() }\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n }\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K, V> FusedIterator for IterMut<'a, K, V> {}\n@@ -1546,12 +1557,21 @@ impl<'a, K, V> FusedIterator for IterMut<'a, K, V> {}\n impl<K, V> Iterator for IntoIter<K, V> {\n     type Item = (K, V);\n \n-    #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next().map(|(_, k, v)| (k, v)) }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    #[inline]\n+    fn next(&mut self) -> Option<(K, V)> {\n+        self.inner.next().map(|(_, k, v)| (k, v))\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n-    #[inline] fn len(&self) -> usize { self.inner.len() }\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n }\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<K, V> FusedIterator for IntoIter<K, V> {}\n@@ -1560,12 +1580,21 @@ impl<K, V> FusedIterator for IntoIter<K, V> {}\n impl<'a, K, V> Iterator for Keys<'a, K, V> {\n     type Item = &'a K;\n \n-    #[inline] fn next(&mut self) -> Option<(&'a K)> { self.inner.next().map(|(k, _)| k) }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    #[inline]\n+    fn next(&mut self) -> Option<(&'a K)> {\n+        self.inner.next().map(|(k, _)| k)\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {\n-    #[inline] fn len(&self) -> usize { self.inner.len() }\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n }\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K, V> FusedIterator for Keys<'a, K, V> {}\n@@ -1574,12 +1603,21 @@ impl<'a, K, V> FusedIterator for Keys<'a, K, V> {}\n impl<'a, K, V> Iterator for Values<'a, K, V> {\n     type Item = &'a V;\n \n-    #[inline] fn next(&mut self) -> Option<(&'a V)> { self.inner.next().map(|(_, v)| v) }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    #[inline]\n+    fn next(&mut self) -> Option<(&'a V)> {\n+        self.inner.next().map(|(_, v)| v)\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {\n-    #[inline] fn len(&self) -> usize { self.inner.len() }\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n }\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K, V> FusedIterator for Values<'a, K, V> {}\n@@ -1588,12 +1626,21 @@ impl<'a, K, V> FusedIterator for Values<'a, K, V> {}\n impl<'a, K, V> Iterator for ValuesMut<'a, K, V> {\n     type Item = &'a mut V;\n \n-    #[inline] fn next(&mut self) -> Option<(&'a mut V)> { self.inner.next().map(|(_, v)| v) }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    #[inline]\n+    fn next(&mut self) -> Option<(&'a mut V)> {\n+        self.inner.next().map(|(_, v)| v)\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n impl<'a, K, V> ExactSizeIterator for ValuesMut<'a, K, V> {\n-    #[inline] fn len(&self) -> usize { self.inner.len() }\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n }\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K, V> FusedIterator for ValuesMut<'a, K, V> {}\n@@ -1602,12 +1649,21 @@ impl<'a, K, V> FusedIterator for ValuesMut<'a, K, V> {}\n impl<'a, K, V> Iterator for Drain<'a, K, V> {\n     type Item = (K, V);\n \n-    #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next().map(|(_, k, v)| (k, v)) }\n-    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    #[inline]\n+    fn next(&mut self) -> Option<(K, V)> {\n+        self.inner.next().map(|(_, k, v)| (k, v))\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n }\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> {\n-    #[inline] fn len(&self) -> usize { self.inner.len() }\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n }\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K, V> FusedIterator for Drain<'a, K, V> {}\n@@ -1902,21 +1958,18 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n         match self.elem {\n-            NeqElem(bucket, ib) => {\n-                robin_hood(bucket, ib, self.hash, self.key, value)\n-            }\n-            NoElem(bucket) => {\n-                bucket.put(self.hash, self.key, value).into_mut_refs().1\n-            }\n+            NeqElem(bucket, ib) => robin_hood(bucket, ib, self.hash, self.key, value),\n+            NoElem(bucket) => bucket.put(self.hash, self.key, value).into_mut_refs().1,\n         }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> FromIterator<(K, V)> for HashMap<K, V, S>\n-    where K: Eq + Hash, S: BuildHasher + Default\n+    where K: Eq + Hash,\n+          S: BuildHasher + Default\n {\n-    fn from_iter<T: IntoIterator<Item=(K, V)>>(iter: T) -> HashMap<K, V, S> {\n+    fn from_iter<T: IntoIterator<Item = (K, V)>>(iter: T) -> HashMap<K, V, S> {\n         let iterator = iter.into_iter();\n         let lower = iterator.size_hint().0;\n         let mut map = HashMap::with_capacity_and_hasher(lower, Default::default());\n@@ -1927,9 +1980,10 @@ impl<K, V, S> FromIterator<(K, V)> for HashMap<K, V, S>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> Extend<(K, V)> for HashMap<K, V, S>\n-    where K: Eq + Hash, S: BuildHasher\n+    where K: Eq + Hash,\n+          S: BuildHasher\n {\n-    fn extend<T: IntoIterator<Item=(K, V)>>(&mut self, iter: T) {\n+    fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) {\n         for (k, v) in iter {\n             self.insert(k, v);\n         }\n@@ -1938,9 +1992,11 @@ impl<K, V, S> Extend<(K, V)> for HashMap<K, V, S>\n \n #[stable(feature = \"hash_extend_copy\", since = \"1.4.0\")]\n impl<'a, K, V, S> Extend<(&'a K, &'a V)> for HashMap<K, V, S>\n-    where K: Eq + Hash + Copy, V: Copy, S: BuildHasher\n+    where K: Eq + Hash + Copy,\n+          V: Copy,\n+          S: BuildHasher\n {\n-    fn extend<T: IntoIterator<Item=(&'a K, &'a V)>>(&mut self, iter: T) {\n+    fn extend<T: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: T) {\n         self.extend(iter.into_iter().map(|(&key, &value)| (key, value)));\n     }\n }\n@@ -1982,7 +2038,8 @@ impl RandomState {\n     /// let s = RandomState::new();\n     /// ```\n     #[inline]\n-    #[allow(deprecated)] // rand\n+    #[allow(deprecated)]\n+    // rand\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n     pub fn new() -> RandomState {\n         // Historically this function did not cache keys from the OS and instead\n@@ -2009,9 +2066,7 @@ impl RandomState {\n             (r.gen(), r.gen())\n         });\n \n-        KEYS.with(|&(k0, k1)| {\n-            RandomState { k0: k0, k1: k1 }\n-        })\n+        KEYS.with(|&(k0, k1)| RandomState { k0: k0, k1: k1 })\n     }\n }\n \n@@ -2080,7 +2135,9 @@ impl Default for RandomState {\n }\n \n impl<K, S, Q: ?Sized> super::Recover<Q> for HashMap<K, (), S>\n-    where K: Eq + Hash + Borrow<Q>, S: BuildHasher, Q: Eq + Hash\n+    where K: Eq + Hash + Borrow<Q>,\n+          S: BuildHasher,\n+          Q: Eq + Hash\n {\n     type Key = K;\n \n@@ -2090,7 +2147,7 @@ impl<K, S, Q: ?Sized> super::Recover<Q> for HashMap<K, (), S>\n \n     fn take(&mut self, key: &Q) -> Option<K> {\n         if self.table.size() == 0 {\n-            return None\n+            return None;\n         }\n \n         self.search_mut(key).into_occupied_bucket().map(|bucket| pop_internal(bucket).0)\n@@ -2114,18 +2171,40 @@ impl<K, S, Q: ?Sized> super::Recover<Q> for HashMap<K, (), S>\n \n #[allow(dead_code)]\n fn assert_covariance() {\n-    fn map_key<'new>(v: HashMap<&'static str, u8>) -> HashMap<&'new str, u8> { v }\n-    fn map_val<'new>(v: HashMap<u8, &'static str>) -> HashMap<u8, &'new str> { v }\n-    fn iter_key<'a, 'new>(v: Iter<'a, &'static str, u8>) -> Iter<'a, &'new str, u8> { v }\n-    fn iter_val<'a, 'new>(v: Iter<'a, u8, &'static str>) -> Iter<'a, u8, &'new str> { v }\n-    fn into_iter_key<'new>(v: IntoIter<&'static str, u8>) -> IntoIter<&'new str, u8> { v }\n-    fn into_iter_val<'new>(v: IntoIter<u8, &'static str>) -> IntoIter<u8, &'new str> { v }\n-    fn keys_key<'a, 'new>(v: Keys<'a, &'static str, u8>) -> Keys<'a, &'new str, u8> { v }\n-    fn keys_val<'a, 'new>(v: Keys<'a, u8, &'static str>) -> Keys<'a, u8, &'new str> { v }\n-    fn values_key<'a, 'new>(v: Values<'a, &'static str, u8>) -> Values<'a, &'new str, u8> { v }\n-    fn values_val<'a, 'new>(v: Values<'a, u8, &'static str>) -> Values<'a, u8, &'new str> { v }\n+    fn map_key<'new>(v: HashMap<&'static str, u8>) -> HashMap<&'new str, u8> {\n+        v\n+    }\n+    fn map_val<'new>(v: HashMap<u8, &'static str>) -> HashMap<u8, &'new str> {\n+        v\n+    }\n+    fn iter_key<'a, 'new>(v: Iter<'a, &'static str, u8>) -> Iter<'a, &'new str, u8> {\n+        v\n+    }\n+    fn iter_val<'a, 'new>(v: Iter<'a, u8, &'static str>) -> Iter<'a, u8, &'new str> {\n+        v\n+    }\n+    fn into_iter_key<'new>(v: IntoIter<&'static str, u8>) -> IntoIter<&'new str, u8> {\n+        v\n+    }\n+    fn into_iter_val<'new>(v: IntoIter<u8, &'static str>) -> IntoIter<u8, &'new str> {\n+        v\n+    }\n+    fn keys_key<'a, 'new>(v: Keys<'a, &'static str, u8>) -> Keys<'a, &'new str, u8> {\n+        v\n+    }\n+    fn keys_val<'a, 'new>(v: Keys<'a, u8, &'static str>) -> Keys<'a, u8, &'new str> {\n+        v\n+    }\n+    fn values_key<'a, 'new>(v: Values<'a, &'static str, u8>) -> Values<'a, &'new str, u8> {\n+        v\n+    }\n+    fn values_val<'a, 'new>(v: Values<'a, u8, &'static str>) -> Values<'a, u8, &'new str> {\n+        v\n+    }\n     fn drain<'new>(d: Drain<'static, &'static str, &'static str>)\n-        -> Drain<'new, &'new str, &'new str> { d }\n+                   -> Drain<'new, &'new str, &'new str> {\n+        d\n+    }\n }\n \n #[cfg(test)]\n@@ -2208,7 +2287,7 @@ mod test_map {\n \n     #[derive(Hash, PartialEq, Eq)]\n     struct Dropable {\n-        k: usize\n+        k: usize,\n     }\n \n     impl Dropable {\n@@ -2252,7 +2331,7 @@ mod test_map {\n \n             for i in 0..100 {\n                 let d1 = Dropable::new(i);\n-                let d2 = Dropable::new(i+100);\n+                let d2 = Dropable::new(i + 100);\n                 m.insert(d1, d2);\n             }\n \n@@ -2311,7 +2390,7 @@ mod test_map {\n \n             for i in 0..100 {\n                 let d1 = Dropable::new(i);\n-                let d2 = Dropable::new(i+100);\n+                let d2 = Dropable::new(i + 100);\n                 hm.insert(d1, d2);\n             }\n \n@@ -2339,13 +2418,13 @@ mod test_map {\n             for _ in half.by_ref() {}\n \n             DROP_VECTOR.with(|v| {\n-                let nk = (0..100).filter(|&i| {\n-                    v.borrow()[i] == 1\n-                }).count();\n+                let nk = (0..100)\n+                    .filter(|&i| v.borrow()[i] == 1)\n+                    .count();\n \n-                let nv = (0..100).filter(|&i| {\n-                    v.borrow()[i+100] == 1\n-                }).count();\n+                let nv = (0..100)\n+                    .filter(|&i| v.borrow()[i + 100] == 1)\n+                    .count();\n \n                 assert_eq!(nk, 50);\n                 assert_eq!(nv, 50);\n@@ -2402,12 +2481,12 @@ mod test_map {\n             for i in 1..1001 {\n                 assert!(m.insert(i, i).is_none());\n \n-                for j in 1..i+1 {\n+                for j in 1..i + 1 {\n                     let r = m.get(&j);\n                     assert_eq!(r, Some(&j));\n                 }\n \n-                for j in i+1..1001 {\n+                for j in i + 1..1001 {\n                     let r = m.get(&j);\n                     assert_eq!(r, None);\n                 }\n@@ -2421,11 +2500,11 @@ mod test_map {\n             for i in 1..1001 {\n                 assert!(m.remove(&i).is_some());\n \n-                for j in 1..i+1 {\n+                for j in 1..i + 1 {\n                     assert!(!m.contains_key(&j));\n                 }\n \n-                for j in i+1..1001 {\n+                for j in i + 1..1001 {\n                     assert!(m.contains_key(&j));\n                 }\n             }\n@@ -2461,7 +2540,8 @@ mod test_map {\n         assert!(m.insert(5, 14).is_none());\n         let new = 100;\n         match m.get_mut(&5) {\n-            None => panic!(), Some(x) => *x = new\n+            None => panic!(),\n+            Some(x) => *x = new,\n         }\n         assert_eq!(m.get(&5), Some(&new));\n     }\n@@ -2580,7 +2660,7 @@ mod test_map {\n         m.insert(1, 2);\n         match m.get(&1) {\n             None => panic!(),\n-            Some(v) => assert_eq!(*v, 2)\n+            Some(v) => assert_eq!(*v, 2),\n         }\n     }\n \n@@ -2743,7 +2823,7 @@ mod test_map {\n     fn test_size_hint() {\n         let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n-        let map: HashMap<_, _>  = xs.iter().cloned().collect();\n+        let map: HashMap<_, _> = xs.iter().cloned().collect();\n \n         let mut iter = map.iter();\n \n@@ -2756,7 +2836,7 @@ mod test_map {\n     fn test_iter_len() {\n         let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n-        let map: HashMap<_, _>  = xs.iter().cloned().collect();\n+        let map: HashMap<_, _> = xs.iter().cloned().collect();\n \n         let mut iter = map.iter();\n \n@@ -2769,7 +2849,7 @@ mod test_map {\n     fn test_mut_size_hint() {\n         let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n-        let mut map: HashMap<_, _>  = xs.iter().cloned().collect();\n+        let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n \n         let mut iter = map.iter_mut();\n \n@@ -2782,7 +2862,7 @@ mod test_map {\n     fn test_iter_mut_len() {\n         let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n-        let mut map: HashMap<_, _>  = xs.iter().cloned().collect();\n+        let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n \n         let mut iter = map.iter_mut();\n \n@@ -2815,7 +2895,7 @@ mod test_map {\n     }\n \n     #[test]\n-    fn test_entry(){\n+    fn test_entry() {\n         let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n \n         let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n@@ -2889,11 +2969,11 @@ mod test_map {\n         for i in 0..1000 {\n             let x = rng.gen_range(-10, 10);\n             match m.entry(x) {\n-                Vacant(_) => {},\n+                Vacant(_) => {}\n                 Occupied(e) => {\n                     println!(\"{}: remove {}\", i, x);\n                     e.remove();\n-                },\n+                }\n             }\n \n             check(&m);\n@@ -2971,7 +3051,7 @@ mod test_map {\n             Vacant(e) => {\n                 assert_eq!(key, *e.key());\n                 e.insert(value.clone());\n-            },\n+            }\n         }\n         assert_eq!(a.len(), 1);\n         assert_eq!(a[key], value);"}, {"sha": "1ec7a4a7b639b51916e9cd10c81ac6ca83a6cdd5", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 159, "deletions": 76, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/b4e89728f450aba54efb9fa88e95a84acaae862b/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e89728f450aba54efb9fa88e95a84acaae862b/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=b4e89728f450aba54efb9fa88e95a84acaae862b", "patch": "@@ -115,7 +115,7 @@ use super::map::{self, HashMap, Keys, RandomState};\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct HashSet<T, S = RandomState> {\n-    map: HashMap<T, (), S>\n+    map: HashMap<T, (), S>,\n }\n \n impl<T: Hash + Eq> HashSet<T, RandomState> {\n@@ -152,7 +152,8 @@ impl<T: Hash + Eq> HashSet<T, RandomState> {\n }\n \n impl<T, S> HashSet<T, S>\n-    where T: Eq + Hash, S: BuildHasher\n+    where T: Eq + Hash,\n+          S: BuildHasher\n {\n     /// Creates a new empty hash set which will use the given hasher to hash\n     /// keys.\n@@ -203,8 +204,7 @@ impl<T, S> HashSet<T, S>\n     /// ```\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n-    pub fn with_capacity_and_hasher(capacity: usize, hasher: S)\n-                                    -> HashSet<T, S> {\n+    pub fn with_capacity_and_hasher(capacity: usize, hasher: S) -> HashSet<T, S> {\n         HashSet { map: HashMap::with_capacity_and_hasher(capacity, hasher) }\n     }\n \n@@ -342,8 +342,9 @@ impl<T, S> HashSet<T, S>\n     /// assert_eq!(diff1, [1, 4].iter().cloned().collect());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, S>)\n-        -> SymmetricDifference<'a, T, S> {\n+    pub fn symmetric_difference<'a>(&'a self,\n+                                    other: &'a HashSet<T, S>)\n+                                    -> SymmetricDifference<'a, T, S> {\n         SymmetricDifference { iter: self.difference(other).chain(other.difference(self)) }\n     }\n \n@@ -407,7 +408,9 @@ impl<T, S> HashSet<T, S>\n     /// assert_eq!(v.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize { self.map.len() }\n+    pub fn len(&self) -> usize {\n+        self.map.len()\n+    }\n \n     /// Returns true if the set contains no elements.\n     ///\n@@ -422,7 +425,9 @@ impl<T, S> HashSet<T, S>\n     /// assert!(!v.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool { self.map.is_empty() }\n+    pub fn is_empty(&self) -> bool {\n+        self.map.is_empty()\n+    }\n \n     /// Clears the set, returning all elements in an iterator.\n     #[inline]\n@@ -444,7 +449,9 @@ impl<T, S> HashSet<T, S>\n     /// assert!(v.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn clear(&mut self) { self.map.clear() }\n+    pub fn clear(&mut self) {\n+        self.map.clear()\n+    }\n \n     /// Returns `true` if the set contains a value.\n     ///\n@@ -463,7 +470,8 @@ impl<T, S> HashSet<T, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n-        where T: Borrow<Q>, Q: Hash + Eq\n+        where T: Borrow<Q>,\n+              Q: Hash + Eq\n     {\n         self.map.contains_key(value)\n     }\n@@ -475,7 +483,8 @@ impl<T, S> HashSet<T, S>\n     /// the value type.\n     #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n     pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>\n-        where T: Borrow<Q>, Q: Hash + Eq\n+        where T: Borrow<Q>,\n+              Q: Hash + Eq\n     {\n         Recover::get(&self.map, value)\n     }\n@@ -566,7 +575,9 @@ impl<T, S> HashSet<T, S>\n     /// assert_eq!(set.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()).is_none() }\n+    pub fn insert(&mut self, value: T) -> bool {\n+        self.map.insert(value, ()).is_none()\n+    }\n \n     /// Adds a value to the set, replacing the existing value, if any, that is equal to the given\n     /// one. Returns the replaced value.\n@@ -595,7 +606,8 @@ impl<T, S> HashSet<T, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n-        where T: Borrow<Q>, Q: Hash + Eq\n+        where T: Borrow<Q>,\n+              Q: Hash + Eq\n     {\n         self.map.remove(value).is_some()\n     }\n@@ -607,27 +619,33 @@ impl<T, S> HashSet<T, S>\n     /// the value type.\n     #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n     pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>\n-        where T: Borrow<Q>, Q: Hash + Eq\n+        where T: Borrow<Q>,\n+              Q: Hash + Eq\n     {\n         Recover::take(&mut self.map, value)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S> PartialEq for HashSet<T, S>\n-    where T: Eq + Hash, S: BuildHasher\n+    where T: Eq + Hash,\n+          S: BuildHasher\n {\n     fn eq(&self, other: &HashSet<T, S>) -> bool {\n-        if self.len() != other.len() { return false; }\n+        if self.len() != other.len() {\n+            return false;\n+        }\n \n         self.iter().all(|key| other.contains(key))\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S> Eq for HashSet<T, S>\n-    where T: Eq + Hash, S: BuildHasher\n-{}\n+    where T: Eq + Hash,\n+          S: BuildHasher\n+{\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S> fmt::Debug for HashSet<T, S>\n@@ -642,9 +660,9 @@ impl<T, S> fmt::Debug for HashSet<T, S>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S> FromIterator<T> for HashSet<T, S>\n     where T: Eq + Hash,\n-          S: BuildHasher + Default,\n+          S: BuildHasher + Default\n {\n-    fn from_iter<I: IntoIterator<Item=T>>(iter: I) -> HashSet<T, S> {\n+    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> HashSet<T, S> {\n         let iterator = iter.into_iter();\n         let lower = iterator.size_hint().0;\n         let mut set = HashSet::with_capacity_and_hasher(lower, Default::default());\n@@ -656,9 +674,9 @@ impl<T, S> FromIterator<T> for HashSet<T, S>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S> Extend<T> for HashSet<T, S>\n     where T: Eq + Hash,\n-          S: BuildHasher,\n+          S: BuildHasher\n {\n-    fn extend<I: IntoIterator<Item=T>>(&mut self, iter: I) {\n+    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n         for k in iter {\n             self.insert(k);\n         }\n@@ -668,17 +686,17 @@ impl<T, S> Extend<T> for HashSet<T, S>\n #[stable(feature = \"hash_extend_copy\", since = \"1.4.0\")]\n impl<'a, T, S> Extend<&'a T> for HashSet<T, S>\n     where T: 'a + Eq + Hash + Copy,\n-          S: BuildHasher,\n+          S: BuildHasher\n {\n-    fn extend<I: IntoIterator<Item=&'a T>>(&mut self, iter: I) {\n+    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S> Default for HashSet<T, S>\n     where T: Eq + Hash,\n-          S: BuildHasher + Default,\n+          S: BuildHasher + Default\n {\n     /// Creates an empty `HashSet<T, S>` with the `Default` value for the hasher.\n     fn default() -> HashSet<T, S> {\n@@ -689,7 +707,7 @@ impl<T, S> Default for HashSet<T, S>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T, S> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash + Clone,\n-          S: BuildHasher + Default,\n+          S: BuildHasher + Default\n {\n     type Output = HashSet<T, S>;\n \n@@ -721,7 +739,7 @@ impl<'a, 'b, T, S> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T, S> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash + Clone,\n-          S: BuildHasher + Default,\n+          S: BuildHasher + Default\n {\n     type Output = HashSet<T, S>;\n \n@@ -753,7 +771,7 @@ impl<'a, 'b, T, S> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T, S> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash + Clone,\n-          S: BuildHasher + Default,\n+          S: BuildHasher + Default\n {\n     type Output = HashSet<T, S>;\n \n@@ -785,7 +803,7 @@ impl<'a, 'b, T, S> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, 'b, T, S> Sub<&'b HashSet<T, S>> for &'a HashSet<T, S>\n     where T: Eq + Hash + Clone,\n-          S: BuildHasher + Default,\n+          S: BuildHasher + Default\n {\n     type Output = HashSet<T, S>;\n \n@@ -817,13 +835,13 @@ impl<'a, 'b, T, S> Sub<&'b HashSet<T, S>> for &'a HashSet<T, S>\n /// HashSet iterator\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a> {\n-    iter: Keys<'a, K, ()>\n+    iter: Keys<'a, K, ()>,\n }\n \n /// HashSet move iterator\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K> {\n-    iter: map::IntoIter<K, ()>\n+    iter: map::IntoIter<K, ()>,\n }\n \n /// HashSet drain iterator\n@@ -853,18 +871,19 @@ pub struct Difference<'a, T: 'a, S: 'a> {\n /// Symmetric difference iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SymmetricDifference<'a, T: 'a, S: 'a> {\n-    iter: Chain<Difference<'a, T, S>, Difference<'a, T, S>>\n+    iter: Chain<Difference<'a, T, S>, Difference<'a, T, S>>,\n }\n \n /// Set union iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Union<'a, T: 'a, S: 'a> {\n-    iter: Chain<Iter<'a, T>, Difference<'a, T, S>>\n+    iter: Chain<Iter<'a, T>, Difference<'a, T, S>>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> IntoIterator for &'a HashSet<T, S>\n-    where T: Eq + Hash, S: BuildHasher\n+    where T: Eq + Hash,\n+          S: BuildHasher\n {\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;\n@@ -909,18 +928,26 @@ impl<T, S> IntoIterator for HashSet<T, S>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K> Clone for Iter<'a, K> {\n-    fn clone(&self) -> Iter<'a, K> { Iter { iter: self.iter.clone() } }\n+    fn clone(&self) -> Iter<'a, K> {\n+        Iter { iter: self.iter.clone() }\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K> Iterator for Iter<'a, K> {\n     type Item = &'a K;\n \n-    fn next(&mut self) -> Option<&'a K> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<&'a K> {\n+        self.iter.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K> ExactSizeIterator for Iter<'a, K> {\n-    fn len(&self) -> usize { self.iter.len() }\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n }\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K> FusedIterator for Iter<'a, K> {}\n@@ -929,12 +956,18 @@ impl<'a, K> FusedIterator for Iter<'a, K> {}\n impl<K> Iterator for IntoIter<K> {\n     type Item = K;\n \n-    fn next(&mut self) -> Option<K> { self.iter.next().map(|(k, _)| k) }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<K> {\n+        self.iter.next().map(|(k, _)| k)\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K> ExactSizeIterator for IntoIter<K> {\n-    fn len(&self) -> usize { self.iter.len() }\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n }\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<K> FusedIterator for IntoIter<K> {}\n@@ -943,12 +976,18 @@ impl<K> FusedIterator for IntoIter<K> {}\n impl<'a, K> Iterator for Drain<'a, K> {\n     type Item = K;\n \n-    fn next(&mut self) -> Option<K> { self.iter.next().map(|(k, _)| k) }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<K> {\n+        self.iter.next().map(|(k, _)| k)\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K> ExactSizeIterator for Drain<'a, K> {\n-    fn len(&self) -> usize { self.iter.len() }\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n }\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K> FusedIterator for Drain<'a, K> {}\n@@ -962,17 +1001,20 @@ impl<'a, T, S> Clone for Intersection<'a, T, S> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> Iterator for Intersection<'a, T, S>\n-    where T: Eq + Hash, S: BuildHasher\n+    where T: Eq + Hash,\n+          S: BuildHasher\n {\n     type Item = &'a T;\n \n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match self.iter.next() {\n                 None => return None,\n-                Some(elt) => if self.other.contains(elt) {\n-                    return Some(elt)\n-                },\n+                Some(elt) => {\n+                    if self.other.contains(elt) {\n+                        return Some(elt);\n+                    }\n+                }\n             }\n         }\n     }\n@@ -985,8 +1027,10 @@ impl<'a, T, S> Iterator for Intersection<'a, T, S>\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T, S> FusedIterator for Intersection<'a, T, S>\n-    where T: Eq + Hash, S: BuildHasher\n-{}\n+    where T: Eq + Hash,\n+          S: BuildHasher\n+{\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> Clone for Difference<'a, T, S> {\n@@ -997,17 +1041,20 @@ impl<'a, T, S> Clone for Difference<'a, T, S> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> Iterator for Difference<'a, T, S>\n-    where T: Eq + Hash, S: BuildHasher\n+    where T: Eq + Hash,\n+          S: BuildHasher\n {\n     type Item = &'a T;\n \n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match self.iter.next() {\n                 None => return None,\n-                Some(elt) => if !self.other.contains(elt) {\n-                    return Some(elt)\n-                },\n+                Some(elt) => {\n+                    if !self.other.contains(elt) {\n+                        return Some(elt);\n+                    }\n+                }\n             }\n         }\n     }\n@@ -1020,8 +1067,10 @@ impl<'a, T, S> Iterator for Difference<'a, T, S>\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T, S> FusedIterator for Difference<'a, T, S>\n-    where T: Eq + Hash, S: BuildHasher\n-{}\n+    where T: Eq + Hash,\n+          S: BuildHasher\n+{\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> Clone for SymmetricDifference<'a, T, S> {\n@@ -1032,53 +1081,85 @@ impl<'a, T, S> Clone for SymmetricDifference<'a, T, S> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> Iterator for SymmetricDifference<'a, T, S>\n-    where T: Eq + Hash, S: BuildHasher\n+    where T: Eq + Hash,\n+          S: BuildHasher\n {\n     type Item = &'a T;\n \n-    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<&'a T> {\n+        self.iter.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T, S> FusedIterator for SymmetricDifference<'a, T, S>\n-    where T: Eq + Hash, S: BuildHasher\n-{}\n+    where T: Eq + Hash,\n+          S: BuildHasher\n+{\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> Clone for Union<'a, T, S> {\n-    fn clone(&self) -> Union<'a, T, S> { Union { iter: self.iter.clone() } }\n+    fn clone(&self) -> Union<'a, T, S> {\n+        Union { iter: self.iter.clone() }\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T, S> FusedIterator for Union<'a, T, S>\n-    where T: Eq + Hash, S: BuildHasher\n-{}\n+    where T: Eq + Hash,\n+          S: BuildHasher\n+{\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T, S> Iterator for Union<'a, T, S>\n-    where T: Eq + Hash, S: BuildHasher\n+    where T: Eq + Hash,\n+          S: BuildHasher\n {\n     type Item = &'a T;\n \n-    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+    fn next(&mut self) -> Option<&'a T> {\n+        self.iter.next()\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n }\n \n #[allow(dead_code)]\n fn assert_covariance() {\n-    fn set<'new>(v: HashSet<&'static str>) -> HashSet<&'new str> { v }\n-    fn iter<'a, 'new>(v: Iter<'a, &'static str>) -> Iter<'a, &'new str> { v }\n-    fn into_iter<'new>(v: IntoIter<&'static str>) -> IntoIter<&'new str> { v }\n+    fn set<'new>(v: HashSet<&'static str>) -> HashSet<&'new str> {\n+        v\n+    }\n+    fn iter<'a, 'new>(v: Iter<'a, &'static str>) -> Iter<'a, &'new str> {\n+        v\n+    }\n+    fn into_iter<'new>(v: IntoIter<&'static str>) -> IntoIter<&'new str> {\n+        v\n+    }\n     fn difference<'a, 'new>(v: Difference<'a, &'static str, RandomState>)\n-        -> Difference<'a, &'new str, RandomState> { v }\n+                            -> Difference<'a, &'new str, RandomState> {\n+        v\n+    }\n     fn symmetric_difference<'a, 'new>(v: SymmetricDifference<'a, &'static str, RandomState>)\n-        -> SymmetricDifference<'a, &'new str, RandomState> { v }\n+                                      -> SymmetricDifference<'a, &'new str, RandomState> {\n+        v\n+    }\n     fn intersection<'a, 'new>(v: Intersection<'a, &'static str, RandomState>)\n-        -> Intersection<'a, &'new str, RandomState> { v }\n+                              -> Intersection<'a, &'new str, RandomState> {\n+        v\n+    }\n     fn union<'a, 'new>(v: Union<'a, &'static str, RandomState>)\n-        -> Union<'a, &'new str, RandomState> { v }\n-    fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> { d }\n+                       -> Union<'a, &'new str, RandomState> {\n+        v\n+    }\n+    fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> {\n+        d\n+    }\n }\n \n #[cfg(test)]\n@@ -1383,7 +1464,9 @@ mod test_set {\n                 assert_eq!(last_i, 49);\n             }\n \n-            for _ in &s { panic!(\"s should be empty!\"); }\n+            for _ in &s {\n+                panic!(\"s should be empty!\");\n+            }\n \n             // reset to try again.\n             s.extend(1..100);"}, {"sha": "b12f132a3a97f7db7edc003200c2e6ad202bea78", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b4e89728f450aba54efb9fa88e95a84acaae862b/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e89728f450aba54efb9fa88e95a84acaae862b/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=b4e89728f450aba54efb9fa88e95a84acaae862b", "patch": "@@ -448,10 +448,10 @@ impl<'t, K, V> FullBucket<K, V, &'t mut RawTable<K, V>> {\n         unsafe {\n             *self.raw.hash = EMPTY_BUCKET;\n             (EmptyBucket {\n-                raw: self.raw,\n-                idx: self.idx,\n-                table: self.table,\n-            },\n+                 raw: self.raw,\n+                 idx: self.idx,\n+                 table: self.table,\n+             },\n              ptr::read(self.raw.key),\n              ptr::read(self.raw.val))\n         }\n@@ -643,13 +643,13 @@ impl<K, V> RawTable<K, V> {\n \n         // One check for overflow that covers calculation and rounding of size.\n         let size_of_bucket = size_of::<u64>()\n-                                 .checked_add(size_of::<K>())\n-                                 .unwrap()\n-                                 .checked_add(size_of::<V>())\n-                                 .unwrap();\n+            .checked_add(size_of::<K>())\n+            .unwrap()\n+            .checked_add(size_of::<V>())\n+            .unwrap();\n         assert!(size >=\n                 capacity.checked_mul(size_of_bucket)\n-                        .expect(\"capacity overflow\"),\n+                    .expect(\"capacity overflow\"),\n                 \"capacity overflow\");\n \n         let buffer = allocate(size, malloc_alignment);\n@@ -672,10 +672,8 @@ impl<K, V> RawTable<K, V> {\n         let keys_size = self.capacity * size_of::<K>();\n \n         let buffer = *self.hashes as *const u8;\n-        let (keys_offset, vals_offset, oflo) = calculate_offsets(hashes_size,\n-                                                                 keys_size,\n-                                                                 align_of::<K>(),\n-                                                                 align_of::<V>());\n+        let (keys_offset, vals_offset, oflo) =\n+            calculate_offsets(hashes_size, keys_size, align_of::<K>(), align_of::<V>());\n         debug_assert!(!oflo, \"capacity overflow\");\n         unsafe {\n             RawBucket {\n@@ -990,9 +988,7 @@ impl<'a, K, V> Iterator for Drain<'a, K, V> {\n }\n impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> {\n     fn len(&self) -> usize {\n-        unsafe {\n-            (**self.table).size()\n-        }\n+        unsafe { (**self.table).size() }\n     }\n }\n "}]}