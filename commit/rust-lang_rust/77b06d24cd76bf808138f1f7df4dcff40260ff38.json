{"sha": "77b06d24cd76bf808138f1f7df4dcff40260ff38", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3YjA2ZDI0Y2Q3NmJmODA4MTM4ZjFmN2RmNGRjZmY0MDI2MGZmMzg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-02-03T00:50:17Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-02-05T17:12:44Z"}, "message": "infer modes rather than overwriting with expected ty", "tree": {"sha": "1830c6000f2c4a02be320e088389979cefb1414f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1830c6000f2c4a02be320e088389979cefb1414f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77b06d24cd76bf808138f1f7df4dcff40260ff38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77b06d24cd76bf808138f1f7df4dcff40260ff38", "html_url": "https://github.com/rust-lang/rust/commit/77b06d24cd76bf808138f1f7df4dcff40260ff38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77b06d24cd76bf808138f1f7df4dcff40260ff38/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5163606d060ccb2c6462d34f590e2a1f30ce4a1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5163606d060ccb2c6462d34f590e2a1f30ce4a1f", "html_url": "https://github.com/rust-lang/rust/commit/5163606d060ccb2c6462d34f590e2a1f30ce4a1f"}], "stats": {"total": 475, "additions": 309, "deletions": 166}, "files": [{"sha": "5d74165c4b6d27f18faf2244d7eb43f6eecacd8b", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=77b06d24cd76bf808138f1f7df4dcff40260ff38", "patch": "@@ -382,7 +382,7 @@ fn mk_main(cx: test_ctxt) -> @ast::item {\n     let args_ty: ast::ty = nospan(ast::ty_vec(args_mt));\n \n     let args_arg: ast::arg =\n-        {mode: ast::by_val,\n+        {mode: ast::expl(ast::by_val),\n          ty: @args_ty,\n          ident: \"args\",\n          id: cx.sess.next_node_id()};"}, {"sha": "dc7496dddb350f7deda30f7f0c9a4c63a3b82e89", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=77b06d24cd76bf808138f1f7df4dcff40260ff38", "patch": "@@ -353,7 +353,7 @@ fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::fn_ty {\n           '#' { ast::by_val }\n         };\n         st.pos += 1u;\n-        inputs += [{mode: mode, ty: parse_ty(st, conv)}];\n+        inputs += [{mode: ast::expl(mode), ty: parse_ty(st, conv)}];\n     }\n     st.pos += 1u; // eat the ']'\n     let cs = parse_constrs(st, conv);"}, {"sha": "a9baa4f74702e10368de15efad5162e1184a27d5", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=77b06d24cd76bf808138f1f7df4dcff40260ff38", "patch": "@@ -203,16 +203,12 @@ fn enc_proto(w: io::writer, proto: proto) {\n fn enc_ty_fn(w: io::writer, cx: @ctxt, ft: ty::fn_ty) {\n     w.write_char('[');\n     for arg: ty::arg in ft.inputs {\n-        alt arg.mode {\n+        alt ty::resolved_mode(cx.tcx, arg.mode) {\n           by_mut_ref { w.write_char('&'); }\n           by_move { w.write_char('-'); }\n           by_copy { w.write_char('+'); }\n           by_ref { w.write_char('='); }\n           by_val { w.write_char('#'); }\n-          // tediously, this has to be there until there's a way\n-          // to constraint post-typeck types not to contain a mode_infer\n-          mode_infer { cx.tcx.sess.bug(\"enc_ty_fn: shouldn't see \\\n-            mode_infer\"); }\n         }\n         enc_ty(w, cx, arg.ty);\n     }"}, {"sha": "388fcb20c477e8a243eb77a3cb6a92401c9037d1", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=77b06d24cd76bf808138f1f7df4dcff40260ff38", "patch": "@@ -82,9 +82,11 @@ fn visit_fn(cx: @ctx, _fk: visit::fn_kind, decl: ast::fn_decl,\n     let fty = ty::node_id_to_type(cx.tcx, id);\n     let args = ty::ty_fn_args(cx.tcx, fty);\n     for arg in args {\n-        if arg.mode == ast::by_val &&\n-           ty::type_has_dynamic_size(cx.tcx, arg.ty) {\n+        alt ty::resolved_mode(cx.tcx, arg.mode) {\n+          ast::by_val if ty::type_has_dynamic_size(cx.tcx, arg.ty) {\n             err(*cx, sp, \"can not pass a dynamically-sized type by value\");\n+          }\n+          _ { /* fallthrough */ }\n         }\n     }\n \n@@ -226,26 +228,30 @@ fn check_call(cx: ctx, sc: scope, f: @ast::expr, args: [@ast::expr])\n     for arg_t: ty::arg in arg_ts {\n         let arg = args[i];\n         let root = expr_root(cx, arg, false);\n-        if arg_t.mode == ast::by_mut_ref {\n+        alt ty::resolved_mode(cx.tcx, arg_t.mode) {\n+          ast::by_mut_ref {\n             alt path_def(cx, arg) {\n               some(def) {\n                 let dnum = ast_util::def_id_of_def(def).node;\n                 mut_roots += [{arg: i, node: dnum}];\n               }\n               _ { }\n             }\n+          }\n+          ast::by_ref | ast::by_val | ast::by_move | ast::by_copy { }\n         }\n         let root_var = path_def_id(cx, root.ex);\n+        let arg_copied = alt ty::resolved_mode(cx.tcx, arg_t.mode) {\n+          ast::by_move | ast::by_copy { copied }\n+          ast::by_mut_ref { not_allowed }\n+          ast::by_ref | ast::by_val { not_copied }\n+        };\n         bindings += [@{node_id: arg.id,\n                        span: arg.span,\n                        root_var: root_var,\n                        local_id: 0u,\n                        unsafe_tys: unsafe_set(root.mut),\n-                       mutable copied: alt arg_t.mode {\n-                         ast::by_move | ast::by_copy { copied }\n-                         ast::by_mut_ref { not_allowed }\n-                         _ { not_copied }\n-                       }}];\n+                       mutable copied: arg_copied}];\n         i += 1u;\n     }\n     let f_may_close =\n@@ -279,7 +285,8 @@ fn check_call(cx: ctx, sc: scope, f: @ast::expr, args: [@ast::expr])\n         for unsafe_ty in b.unsafe_tys {\n             let i = 0u;\n             for arg_t: ty::arg in arg_ts {\n-                let mut_alias = arg_t.mode == ast::by_mut_ref;\n+                let mut_alias =\n+                    (ast::by_mut_ref == ty::arg_mode(cx.tcx, arg_t));\n                 if i != j &&\n                        ty_can_unsafely_include(cx, unsafe_ty, arg_t.ty,\n                                                mut_alias) &&"}, {"sha": "9d31e089e107b3dead1bf5596e162d0f5846657a", "filename": "src/comp/middle/block_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmiddle%2Fblock_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmiddle%2Fblock_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fblock_use.rs?ref=77b06d24cd76bf808138f1f7df4dcff40260ff38", "patch": "@@ -28,7 +28,7 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n         v.visit_expr(f, cx, v);\n         let i = 0u;\n         for arg_t in ty::ty_fn_args(cx.tcx, ty::expr_ty(cx.tcx, f)) {\n-            cx.allow_block = arg_t.mode == by_ref;\n+            cx.allow_block = (ty::arg_mode(cx.tcx, arg_t) == by_ref);\n             v.visit_expr(args[i], cx, v);\n             i += 1u;\n         }"}, {"sha": "8e02389f2d2de64e3817b1d5cbe5ca59853c6ba8", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=77b06d24cd76bf808138f1f7df4dcff40260ff38", "patch": "@@ -165,7 +165,10 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n       expr_call(f, args, _) {\n         let i = 0u;\n         for arg_t in ty::ty_fn_args(cx.tcx, ty::expr_ty(cx.tcx, f)) {\n-            alt arg_t.mode { by_copy { maybe_copy(cx, args[i]); } _ {} }\n+            alt ty::arg_mode(cx.tcx, arg_t) {\n+              by_copy { maybe_copy(cx, args[i]); }\n+              by_ref | by_val | by_mut_ref | by_move { }\n+            }\n             i += 1u;\n         }\n       }"}, {"sha": "9c7fd7c0bc1cd321c5bbf4cf72023be64eab8195", "filename": "src/comp/middle/last_use.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Flast_use.rs?ref=77b06d24cd76bf808138f1f7df4dcff40260ff38", "patch": "@@ -157,7 +157,7 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n                 fns += [arg];\n               }\n               _ {\n-                alt arg_ts[i].mode {\n+                alt ty::arg_mode(cx.tcx, arg_ts[i]) {\n                   by_mut_ref { clear_if_path(cx, arg, v, false); }\n                   _ { v.visit_expr(arg, cx, v); }\n                 }\n@@ -286,11 +286,21 @@ fn clear_in_current(cx: ctx, my_def: node_id, to: bool) {\n fn clear_def_if_path(cx: ctx, d: def, to: bool)\n     -> option<node_id> {\n     alt d {\n-      def_local(def_id, let_copy) | def_arg(def_id, by_copy) |\n-      def_arg(def_id, by_move) {\n+      def_local(def_id, let_copy) {\n         clear_in_current(cx, def_id.node, to);\n         some(def_id.node)\n       }\n+      def_arg(def_id, m) {\n+        alt ty::resolved_mode(cx.tcx, m) {\n+          by_copy | by_move {\n+            clear_in_current(cx, def_id.node, to);\n+            some(def_id.node)\n+          }\n+          by_ref | by_val | by_mut_ref {\n+            none\n+          }\n+        }\n+      }\n       _ {\n         none\n       }"}, {"sha": "8ea39d33de10c7538cf8630265af63ddcd3f9037", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=77b06d24cd76bf808138f1f7df4dcff40260ff38", "patch": "@@ -228,10 +228,10 @@ fn check_call(cx: @ctx, f: @expr, args: [@expr]) {\n     let arg_ts = ty::ty_fn_args(cx.tcx, ty::expr_ty(cx.tcx, f));\n     let i = 0u;\n     for arg_t: ty::arg in arg_ts {\n-        alt arg_t.mode {\n+        alt ty::resolved_mode(cx.tcx, arg_t.mode) {\n           by_mut_ref { check_lval(cx, args[i], msg_mut_ref); }\n           by_move { check_lval(cx, args[i], msg_move_out); }\n-          _ {}\n+          by_ref | by_val | by_copy { }\n         }\n         i += 1u;\n     }\n@@ -267,8 +267,12 @@ fn is_immutable_def(cx: @ctx, def: def) -> option<str> {\n       def_use(_) {\n         some(\"static item\")\n       }\n-      def_arg(_, by_ref) | def_arg(_, by_val) |\n-      def_arg(_, mode_infer) { some(\"argument\") }\n+      def_arg(_, m) {\n+        alt ty::resolved_mode(cx.tcx, m) {\n+          by_ref | by_val { some(\"argument\") }\n+          by_mut_ref | by_move | by_copy { none }\n+        }\n+      }\n       def_self(_) { some(\"self argument\") }\n       def_upvar(_, inner, node_id) {\n         let ty = ty::node_id_to_type(cx.tcx, node_id);"}, {"sha": "cc3572e28f15176d9a93ff60672f487160f84881", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=77b06d24cd76bf808138f1f7df4dcff40260ff38", "patch": "@@ -63,16 +63,18 @@ fn type_of(cx: @crate_ctxt, t: ty::t) : type_has_static_size(cx, t)\n \n fn type_of_explicit_args(cx: @crate_ctxt, inputs: [ty::arg]) ->\n    [TypeRef] {\n-    let atys = [];\n-    for arg in inputs {\n+    let tcx = ccx_tcx(cx);\n+    vec::map(inputs) {|arg|\n         let arg_ty = arg.ty;\n         // FIXME: would be nice to have a constraint on arg\n         // that would obviate the need for this check\n         check non_ty_var(cx, arg_ty);\n         let llty = type_of_inner(cx, arg_ty);\n-        atys += [if arg.mode == ast::by_val { llty } else { T_ptr(llty) }];\n+        alt ty::resolved_mode(tcx, arg.mode) {\n+          ast::by_val { llty }\n+          _ { T_ptr(llty) }\n+        }\n     }\n-    ret atys;\n }\n \n \n@@ -2981,15 +2983,16 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty: TypeRef,\n     let lv = trans_temp_lval(cx, e);\n     let bcx = lv.bcx;\n     let val = lv.val;\n+    let arg_mode = ty::resolved_mode(ccx.tcx, arg.mode);\n     if is_bot {\n         // For values of type _|_, we generate an\n         // \"undef\" value, as such a value should never\n         // be inspected. It's important for the value\n         // to have type lldestty (the callee's expected type).\n         val = llvm::LLVMGetUndef(lldestty);\n-    } else if arg.mode == ast::by_ref || arg.mode == ast::by_val {\n+    } else if arg_mode == ast::by_ref || arg_mode == ast::by_val {\n         let copied = false, imm = ty::type_is_immediate(ccx.tcx, e_ty);\n-        if arg.mode == ast::by_ref && lv.kind != owned && imm {\n+        if arg_mode == ast::by_ref && lv.kind != owned && imm {\n             val = do_spill_noroot(bcx, val);\n             copied = true;\n         }\n@@ -3002,10 +3005,10 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty: TypeRef,\n             } else { bcx = take_ty(bcx, val, e_ty); }\n             add_clean(bcx, val, e_ty);\n         }\n-        if arg.mode == ast::by_val && (lv.kind == owned || !imm) {\n+        if arg_mode == ast::by_val && (lv.kind == owned || !imm) {\n             val = Load(bcx, val);\n         }\n-        } else if arg.mode == ast::by_copy {\n+        } else if arg_mode == ast::by_copy {\n         let {bcx: cx, val: alloc} = alloc_ty(bcx, e_ty);\n         let last_use = ccx.last_uses.contains_key(e.id);\n         bcx = cx;\n@@ -3031,7 +3034,7 @@ fn trans_arg_expr(cx: @block_ctxt, arg: ty::arg, lldestty: TypeRef,\n     }\n \n     // Collect arg for later if it happens to be one we've moving out.\n-    if arg.mode == ast::by_move {\n+    if arg_mode == ast::by_move {\n         if lv.kind == owned {\n             // Use actual ty, not declared ty -- anything else doesn't make\n             // sense if declared ty is a ty param\n@@ -4414,17 +4417,18 @@ fn create_llargs_for_fn_args(cx: @fn_ctxt, ty_self: self_arg,\n \n fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: @block_ctxt, args: [ast::arg],\n                         arg_tys: [ty::arg]) -> @block_ctxt {\n+    let tcx = bcx_tcx(bcx);\n     let arg_n: uint = 0u, bcx = bcx;\n-    fn epic_fail_(bcx: @block_ctxt) -> ! {\n-        bcx_tcx(bcx).sess.bug(\"Someone forgot\\\n+    let epic_fail = fn@() -> ! {\n+        tcx.sess.bug(\"Someone forgot\\\n                 to document an invariant in copy_args_to_allocas!\");\n     }\n     let epic_fail = bind epic_fail_(bcx);\n     for arg in arg_tys {\n         let id = args[arg_n].id;\n         let argval = alt fcx.llargs.get(id) { local_mem(v) { v }\n                                               _ { epic_fail() } };\n-        alt arg.mode {\n+        alt ty::resolved_mode(tcx, arg.mode) {\n           ast::by_mut_ref { }\n           ast::by_move | ast::by_copy { add_clean(bcx, argval, arg.ty); }\n           ast::by_val {\n@@ -4438,7 +4442,6 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: @block_ctxt, args: [ast::arg],\n             }\n           }\n           ast::by_ref {}\n-          _ { epic_fail(); }\n         }\n         if fcx_ccx(fcx).sess.opts.extra_debuginfo {\n             debuginfo::create_arg(bcx, args[arg_n], args[arg_n].ty.span);\n@@ -4585,7 +4588,7 @@ fn trans_enum_variant(ccx: @crate_ctxt,\n     // Translate variant arguments to function arguments.\n     let fn_args = [], i = 0u;\n     for varg in variant.node.args {\n-        fn_args += [{mode: ast::by_copy,\n+        fn_args += [{mode: ast::expl(ast::by_copy),\n                      ty: varg.ty,\n                      ident: \"arg\" + uint::to_str(i, 10u),\n                      id: varg.id}];\n@@ -5039,7 +5042,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n                    takes_argv: bool) -> ValueRef {\n         let unit_ty = ty::mk_str(ccx.tcx);\n         let vecarg_ty: ty::arg =\n-            {mode: ast::by_val,\n+            {mode: ast::expl(ast::by_val),\n              ty: ty::mk_vec(ccx.tcx, {ty: unit_ty, mut: ast::imm})};\n         // FIXME: mk_nil should have a postcondition\n         let nt = ty::mk_nil(ccx.tcx);"}, {"sha": "12997f0e5393b0de95ef217989ff900ef5018ab7", "filename": "src/comp/middle/trans/closure.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs?ref=77b06d24cd76bf808138f1f7df4dcff40260ff38", "patch": "@@ -895,13 +895,20 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n                              [0, abi::closure_body_bindings, b]);\n             bcx = bound_arg.bcx;\n             let val = bound_arg.val;\n-            if out_arg.mode == ast::by_val { val = Load(bcx, val); }\n-            if out_arg.mode == ast::by_copy {\n+\n+            alt ty::resolved_mode(tcx, out_arg.mode) {\n+              ast::by_val {\n+                val = Load(bcx, val);\n+              }\n+              ast::by_copy {\n                 let {bcx: cx, val: alloc} = alloc_ty(bcx, out_arg.ty);\n                 bcx = memmove_ty(cx, alloc, val, out_arg.ty);\n                 bcx = take_ty(bcx, alloc, out_arg.ty);\n                 val = alloc;\n+              }\n+              ast::by_ref | ast::by_mut_ref | ast::by_move { }\n             }\n+\n             // If the type is parameterized, then we need to cast the\n             // type we actually have to the parameterized out type.\n             if ty::type_contains_params(ccx.tcx, out_arg.ty) {"}, {"sha": "4f8a6402da375e5cc93768f4e033f5b4e20d6c3b", "filename": "src/comp/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs?ref=77b06d24cd76bf808138f1f7df4dcff40260ff38", "patch": "@@ -300,7 +300,8 @@ fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id, inner_t: ty::t)\n     let nil_res = ty::mk_nil(ccx.tcx);\n     // FIXME: Silly check -- mk_nil should have a postcondition\n     check non_ty_var(ccx, nil_res);\n-    let f_t = type_of_fn(ccx, [{mode: ast::by_ref, ty: inner_t}],\n+    let fn_mode = ast::expl(ast::by_ref);\n+    let f_t = type_of_fn(ccx, [{mode: fn_mode, ty: inner_t}],\n                          nil_res, *param_bounds);\n     ret base::get_extern_const(ccx.externs, ccx.llmod,\n                                 csearch::get_symbol(ccx.sess.cstore,"}, {"sha": "18ee215b2dcdb3bf36db1bc4417beb81a02cda54", "filename": "src/comp/middle/trans/impl.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs?ref=77b06d24cd76bf808138f1f7df4dcff40260ff38", "patch": "@@ -63,7 +63,8 @@ fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n fn trans_self_arg(bcx: @block_ctxt, base: @ast::expr) -> result {\n     let tz = [], tr = [];\n     let basety = expr_ty(bcx, base);\n-    let {bcx, val} = trans_arg_expr(bcx, {mode: ast::by_ref, ty: basety},\n+    let m_by_ref = ast::expl(ast::by_ref);\n+    let {bcx, val} = trans_arg_expr(bcx, {mode: m_by_ref, ty: basety},\n                                     T_ptr(type_of_or_i8(bcx, basety)), tz,\n                                     tr, base);\n     rslt(bcx, PointerCast(bcx, val, T_opaque_cbox_ptr(bcx_ccx(bcx))))"}, {"sha": "222006f3fa84f6d846eff89f3983844bed311ff7", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=77b06d24cd76bf808138f1f7df4dcff40260ff38", "patch": "@@ -1089,10 +1089,12 @@ fn callee_modes(fcx: fn_ctxt, callee: node_id) -> [mode] {\n }\n \n fn callee_arg_init_ops(fcx: fn_ctxt, callee: node_id) -> [init_op] {\n-    fn mode_to_op(m: mode) -> init_op {\n-        alt m { by_move { init_move } _ { init_assign } }\n+    vec::map(callee_modes(fcx, callee)) {|m|\n+        alt ty::resolved_mode(fcx.ccx.tcx, m) {\n+          by_move { init_move }\n+          by_copy | by_ref | by_val | by_mut_ref { init_assign }\n+        }\n     }\n-    vec::map(callee_modes(fcx, callee), mode_to_op)\n }\n \n fn anon_bindings(ops: [init_op], es: [@expr]) -> [binding] {"}, {"sha": "0ca3a6ee2947c80c59de0db99de67a28cf2688a3", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=77b06d24cd76bf808138f1f7df4dcff40260ff38", "patch": "@@ -276,12 +276,11 @@ fn handle_var_def(fcx: fn_ctxt, rslt: pre_and_post, def: def, name: ident) {\n \n fn forget_args_moved_in(fcx: fn_ctxt, parent: @expr, modes: [mode],\n                         operands: [@expr]) {\n-    let i = 0u;\n-    for mode: mode in modes {\n-        if mode == by_move {\n-            forget_in_postcond(fcx, parent.id, operands[i].id);\n+    vec::iteri(modes) {|i,mode|\n+        alt ty::resolved_mode(fcx.ccx.tcx, mode) {\n+          by_move { forget_in_postcond(fcx, parent.id, operands[i].id); }\n+          by_ref | by_val | by_mut_ref | by_copy { }\n         }\n-        i += 1u;\n     }\n }\n "}, {"sha": "02f687cb6153a9cf40c0c64570b6cf88a5962a33", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 99, "deletions": 17, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=77b06d24cd76bf808138f1f7df4dcff40260ff38", "patch": "@@ -19,7 +19,6 @@ import util::common::*;\n import syntax::util::interner;\n import util::ppaux::ty_to_str;\n import util::ppaux::ty_constr_to_str;\n-import util::ppaux::mode_str;\n import syntax::print::pprust::*;\n \n export node_id_to_type;\n@@ -168,6 +167,10 @@ export type_structurally_contains;\n export type_structurally_contains_uniques;\n export type_autoderef;\n export type_param;\n+export resolved_mode;\n+export arg_mode;\n+export unify_mode;\n+export set_default_mode;\n export unify;\n export variant_info;\n export walk_ty;\n@@ -178,12 +181,12 @@ export ck_box;\n export ck_uniq;\n export param_bound, param_bounds, bound_copy, bound_send, bound_iface;\n export param_bounds_to_kind;\n+export default_arg_mode_for_ty;\n \n // Data types\n \n-// TODO: really should be a separate type, or a refinement,\n-// so that we don't have to handle the mode_infer case after\n-// typeck. but that's too hard right now.\n+// Note: after typeck, you should use resolved_mode() to convert this mode\n+// into an rmode, which will take into account the results of mode inference.\n type arg = {mode: ast::mode, ty: t};\n \n type field = {ident: ast::ident, mt: mt};\n@@ -217,7 +220,8 @@ type ctxt =\n       ast_ty_to_ty_cache: hashmap<@ast::ty, option<t>>,\n       enum_var_cache: hashmap<def_id, @[variant_info]>,\n       iface_method_cache: hashmap<def_id, @[method]>,\n-      ty_param_bounds: hashmap<ast::node_id, param_bounds>};\n+      ty_param_bounds: hashmap<ast::node_id, param_bounds>,\n+      inferred_modes: hashmap<ast::node_id, ast::mode>};\n \n type ty_ctxt = ctxt;\n \n@@ -424,7 +428,8 @@ fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n               map::mk_hashmap(ast_util::hash_ty, ast_util::eq_ty),\n           enum_var_cache: new_def_hash(),\n           iface_method_cache: new_def_hash(),\n-          ty_param_bounds: map::new_int_hash()};\n+          ty_param_bounds: map::new_int_hash(),\n+          inferred_modes: map::new_int_hash()};\n     populate_type_store(cx);\n     ret cx;\n }\n@@ -646,6 +651,12 @@ pure fn ty_name(cx: ctxt, typ: t) -> option<@str> {\n     }\n }\n \n+fn default_arg_mode_for_ty(tcx: ty::ctxt, ty: ty::t) -> ast::rmode {\n+    assert !ty::type_contains_vars(tcx, ty);\n+    if ty::type_is_immediate(tcx, ty) { ast::by_val }\n+    else { ast::by_ref }\n+}\n+\n fn walk_ty(cx: ctxt, ty: t, f: fn(t)) {\n     alt struct(cx, ty) {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n@@ -684,13 +695,14 @@ enum fold_mode {\n \n fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n     let ty = ty_0;\n-    // Fast paths.\n \n+    // Fast paths.\n     alt fld {\n       fm_var(_) { if !type_contains_vars(cx, ty) { ret ty; } }\n       fm_param(_) { if !type_contains_params(cx, ty) { ret ty; } }\n       fm_general(_) {/* no fast path */ }\n     }\n+\n     alt interner::get(*cx.ts, ty).struct {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_str | ty_type | ty_send_type | ty_opaque_closure_ptr(_) {}\n@@ -1619,6 +1631,77 @@ fn occurs_check_fails(tcx: ctxt, sp: option<span>, vid: int, rt: t) ->\n     } else { ret false; }\n }\n \n+// Maintains a little union-set tree for inferred modes.  `canon()` returns\n+// the current head value for `m0`.\n+fn canon<T:copy>(tbl: hashmap<ast::node_id, ast::inferable<T>>,\n+                 m0: ast::inferable<T>) -> ast::inferable<T> {\n+    alt m0 {\n+      ast::infer(id) {\n+        alt tbl.find(id) {\n+          none { m0 }\n+          some(m1) {\n+            let cm1 = canon(tbl, m1);\n+            // path compression:\n+            if cm1 != m1 { tbl.insert(id, cm1); }\n+            cm1\n+          }\n+        }\n+      }\n+      _ { m0 }\n+    }\n+}\n+\n+// Maintains a little union-set tree for inferred modes.  `resolve_mode()`\n+// returns the current head value for `m0`.\n+fn canon_mode(cx: ctxt, m0: ast::mode) -> ast::mode {\n+    canon(cx.inferred_modes, m0)\n+}\n+\n+// Returns the head value for mode, failing if `m` was a infer(_) that\n+// was never inferred.  This should be safe for use after typeck.\n+fn resolved_mode(cx: ctxt, m: ast::mode) -> ast::rmode {\n+    alt canon_mode(cx, m) {\n+      ast::infer(_) {\n+        cx.sess.bug(#fmt[\"mode %? was never resolved\", m]);\n+      }\n+      ast::expl(m0) { m0 }\n+    }\n+}\n+\n+fn arg_mode(cx: ctxt, a: arg) -> ast::rmode { ty::resolved_mode(cx, a.mode) }\n+\n+// Unifies `m1` and `m2`.  Returns unified value or failure code.\n+fn unify_mode(cx: ctxt, m1: ast::mode, m2: ast::mode)\n+    -> result::t<ast::mode, type_err> {\n+    alt (canon_mode(cx, m1), canon_mode(cx, m2)) {\n+      (m1, m2) if (m1 == m2) {\n+        result::ok(m1)\n+      }\n+      (ast::infer(id1), ast::infer(id2)) {\n+        cx.inferred_modes.insert(id2, m1);\n+        result::ok(m1)\n+      }\n+      (ast::infer(id), m) | (m, ast::infer(id)) {\n+        cx.inferred_modes.insert(id, m);\n+        result::ok(m1)\n+      }\n+      (m1, m2) {\n+        result::err(terr_mode_mismatch(m1, m2))\n+      }\n+    }\n+}\n+\n+// If `m` was never unified, unifies it with `m_def`.  Returns the final value\n+// for `m`.\n+fn set_default_mode(cx: ctxt, m: ast::mode, m_def: ast::rmode) {\n+    alt canon_mode(cx, m) {\n+      ast::infer(id) {\n+        cx.inferred_modes.insert(id, ast::expl(m_def));\n+      }\n+      ast::expl(_) { }\n+    }\n+}\n+\n // Type unification via Robinson's algorithm (Robinson 1965). Implemented as\n // described in Hoder and Voronkov:\n //\n@@ -1869,15 +1952,14 @@ mod unify {\n         for expected_input in e_args {\n             let actual_input = a_args[i];\n             i += 1u;\n+\n             // Unify the result modes.\n-            let result_mode = if expected_input.mode == ast::mode_infer {\n-                actual_input.mode\n-            } else if actual_input.mode == ast::mode_infer {\n-                expected_input.mode\n-            } else if expected_input.mode != actual_input.mode {\n-                ret either::left(ures_err(terr_mode_mismatch(\n-                    expected_input.mode, actual_input.mode)));\n-            } else { expected_input.mode };\n+            let result_mode =\n+                alt unify_mode(cx.tcx, expected_input.mode,\n+                               actual_input.mode) {\n+                  result::err(err) { ret either::left(ures_err(err)); }\n+                  result::ok(m) { m }\n+                };\n \n             alt unify_step(cx, expected_input.ty, actual_input.ty,\n                            variance) {\n@@ -2446,8 +2528,8 @@ fn type_err_to_str(err: ty::type_err) -> str {\n       }\n       terr_arg_count { ret \"incorrect number of function parameters\"; }\n       terr_mode_mismatch(e_mode, a_mode) {\n-        ret \"expected argument mode \" + mode_str(e_mode) + \" but found \" +\n-                mode_str(a_mode);\n+        ret \"expected argument mode \" + mode_to_str(e_mode) + \" but found \" +\n+                mode_to_str(a_mode);\n       }\n       terr_constr_len(e_len, a_len) {\n         ret \"Expected a type with \" + uint::str(e_len) +"}, {"sha": "148222d95f09e755a343c7984a3df4f4dc3fb525", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 80, "deletions": 58, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=77b06d24cd76bf808138f1f7df4dcff40260ff38", "patch": "@@ -64,7 +64,6 @@ type fn_ctxt =\n      var_bindings: @ty::unify::var_bindings,\n      locals: hashmap<ast::node_id, int>,\n      next_var_id: @mutable int,\n-     mutable fixups: [ast::node_id],\n      ccx: @crate_ctxt};\n \n \n@@ -215,27 +214,11 @@ fn type_is_c_like_enum(fcx: @fn_ctxt, sp: span, typ: ty::t) -> bool {\n     ret ty::type_is_c_like_enum(fcx.ccx.tcx, typ_s);\n }\n \n-// Parses the programmer's textual representation of a type into our internal\n-// notion of a type. `getter` is a function that returns the type\n-// corresponding to a definition ID:\n-fn default_arg_mode_for_ty(tcx: ty::ctxt, m: ast::mode,\n-                           ty: ty::t) -> ast::mode {\n-    alt m {\n-      ast::mode_infer {\n-        alt ty::struct(tcx, ty) {\n-            ty::ty_var(_) { ast::mode_infer }\n-            _ {\n-                if ty::type_is_immediate(tcx, ty) { ast::by_val }\n-                else { ast::by_ref }\n-            }\n-        }\n-      }\n-      _ { m }\n-    }\n-}\n-\n enum mode { m_collect, m_check, m_check_tyvar(@fn_ctxt), }\n \n+// Parses the programmer's textual representation of a type into our\n+// internal notion of a type. `getter` is a function that returns the type\n+// corresponding to a definition ID:\n fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n     fn getter(tcx: ty::ctxt, mode: mode, id: ast::def_id)\n         -> ty::ty_param_bounds_and_ty {\n@@ -443,13 +426,38 @@ fn ty_of_native_item(tcx: ty::ctxt, mode: mode, it: @ast::native_item)\n     }\n }\n fn ty_of_arg(tcx: ty::ctxt, mode: mode, a: ast::arg) -> ty::arg {\n+    fn arg_mode(tcx: ty::ctxt, m: ast::mode, ty: ty::t) -> ast::mode {\n+        alt m {\n+          ast::infer(_) {\n+            alt ty::struct(tcx, ty) {\n+              // If the type is not specified, then this must be a fn expr.\n+              // Leave the mode as infer(_), it will get inferred based\n+              // on constraints elsewhere.\n+              ty::ty_var(_) { m }\n+\n+              // If the type is known, then use the default for that type.\n+              // Here we unify m and the default.  This should update the\n+              // tables in tcx but should never fail, because nothing else\n+              // will have been unified with m yet:\n+              _ {\n+                let m1 = ast::expl(ty::default_arg_mode_for_ty(tcx, ty));\n+                result::get(ty::unify_mode(tcx, m, m1))\n+              }\n+            }\n+          }\n+          ast::expl(_) { m }\n+        }\n+    }\n+\n     let ty = ast_ty_to_ty(tcx, mode, a.ty);\n-    {mode: default_arg_mode_for_ty(tcx, a.mode, ty), ty: ty}\n-}\n-fn ty_of_fn_decl(tcx: ty::ctxt, mode: mode,\n-                 proto: ast::proto, decl: ast::fn_decl) -> ty::fn_ty {\n-    let input_tys = [];\n-    for a: ast::arg in decl.inputs { input_tys += [ty_of_arg(tcx, mode, a)]; }\n+    let mode = arg_mode(tcx, a.mode, ty);\n+    {mode: mode, ty: ty}\n+}\n+fn ty_of_fn_decl(tcx: ty::ctxt,\n+                 mode: mode,\n+                 proto: ast::proto,\n+                 decl: ast::fn_decl) -> ty::fn_ty {\n+    let input_tys = vec::map(decl.inputs) {|a| ty_of_arg(tcx, mode, a) };\n     let output_ty = ast_ty_to_ty(tcx, mode, decl.output);\n \n     let out_constrs = [];\n@@ -472,7 +480,9 @@ fn ty_of_native_fn_decl(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl,\n                         ty_params: [ast::ty_param], def_id: ast::def_id)\n     -> ty::ty_param_bounds_and_ty {\n     let input_tys = [], bounds = ty_param_bounds(tcx, mode, ty_params);\n-    for a: ast::arg in decl.inputs { input_tys += [ty_of_arg(tcx, mode, a)]; }\n+    for a: ast::arg in decl.inputs {\n+        input_tys += [ty_of_arg(tcx, mode, a)];\n+    }\n     let output_ty = ast_ty_to_ty(tcx, mode, decl.output);\n \n     let t_fn = ty::mk_fn(tcx, {proto: ast::proto_bare,\n@@ -585,7 +595,9 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n     } else {\n         let auto_modes = vec::map2(impl_m.fty.inputs, if_m.fty.inputs, {|i, f|\n             alt ty::struct(tcx, f.ty) {\n-              ty::ty_param(0u, _) { {mode: ast::by_ref with i} }\n+              ty::ty_param(0u, _) {\n+                {mode: ast::expl(ast::by_ref) with i}\n+              }\n               _ { i }\n             }\n         });\n@@ -641,7 +653,7 @@ mod collect {\n                 let args: [arg] = [];\n                 for va: ast::variant_arg in variant.node.args {\n                     let arg_ty = ast_ty_to_ty(cx.tcx, m_collect, va.ty);\n-                    args += [{mode: ast::by_copy, ty: arg_ty}];\n+                    args += [{mode: ast::expl(ast::by_copy), ty: arg_ty}];\n                 }\n                 // FIXME: this will be different for constrained types\n                 ty::mk_fn(cx.tcx,\n@@ -716,7 +728,7 @@ mod collect {\n                                    params);\n             let t_ctor = ty::mk_fn(cx.tcx, {\n                 proto: ast::proto_box,\n-                inputs: [{mode: ast::by_copy with t_arg}],\n+                inputs: [{mode: ast::expl(ast::by_copy) with t_arg}],\n                 output: t_res,\n                 ret_style: ast::return_val, constraints: []\n             });\n@@ -925,9 +937,6 @@ fn variant_arg_types(ccx: @crate_ctxt, _sp: span, vid: ast::def_id,\n // Type resolution: the phase that finds all the types in the AST with\n // unresolved type variables and replaces \"ty_var\" types with their\n // substitutions.\n-//\n-// TODO: inefficient since not all types have vars in them. It would be better\n-// to maintain a list of fixups.\n mod writeback {\n \n     export resolve_type_vars_in_block;\n@@ -946,24 +955,32 @@ mod writeback {\n           }\n         }\n     }\n-    fn resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span, id: ast::node_id) {\n+    fn resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span, id: ast::node_id)\n+        -> option<ty::t> {\n         let fcx = wbcx.fcx, tcx = fcx.ccx.tcx;\n         alt resolve_type_vars_in_type(fcx, sp, ty::node_id_to_type(tcx, id)) {\n-          some(t) { write_ty(tcx, id, t); }\n-          none { wbcx.success = false; ret }\n-        }\n-        alt tcx.node_type_substs.find(id) {\n-          some(substs) {\n-            let new_substs = [];\n-            for subst: ty::t in substs {\n-                alt resolve_type_vars_in_type(fcx, sp, subst) {\n-                  some(t) { new_substs += [t]; }\n-                  none { wbcx.success = false; ret; }\n+          none {\n+            wbcx.success = false;\n+            ret none;\n+          }\n+\n+          some(t) {\n+            write_ty(tcx, id, t);\n+            alt tcx.node_type_substs.find(id) {\n+              some(substs) {\n+                let new_substs = [];\n+                for subst: ty::t in substs {\n+                    alt resolve_type_vars_in_type(fcx, sp, subst) {\n+                      some(t) { new_substs += [t]; }\n+                      none { wbcx.success = false; ret none; }\n+                    }\n                 }\n+                write_substs(tcx, id, new_substs);\n+              }\n+              none {}\n             }\n-            write_substs(tcx, id, new_substs);\n+            ret some(t);\n           }\n-          none {}\n         }\n     }\n \n@@ -984,8 +1001,19 @@ mod writeback {\n         alt e.node {\n           ast::expr_fn(_, decl, _, _) |\n           ast::expr_fn_block(decl, _) {\n-            for input in decl.inputs {\n-                resolve_type_vars_for_node(wbcx, e.span, input.id);\n+            vec::iter(decl.inputs) {|input|\n+                let r_ty = resolve_type_vars_for_node(wbcx, e.span, input.id);\n+\n+                // Just in case we never constrained the mode to anything,\n+                // constrain it to the default for the type in question.\n+                alt (r_ty, input.mode) {\n+                  (some(t), ast::infer(_)) {\n+                    let tcx = wbcx.fcx.ccx.tcx;\n+                    let m_def = ty::default_arg_mode_for_ty(tcx, t);\n+                    ty::set_default_mode(tcx, input.mode, m_def);\n+                  }\n+                  _ {}\n+                }\n             }\n           }\n           _ { }\n@@ -1541,8 +1569,8 @@ fn check_expr_fn_with_unifier(fcx: @fn_ctxt,\n                               unify: unifier,\n                               expected: ty::t) {\n     let tcx = fcx.ccx.tcx;\n-    let fty = ty::mk_fn(tcx, ty_of_fn_decl(tcx, m_check_tyvar(fcx),\n-                                           proto, decl));\n+    let fty = ty::mk_fn(tcx,\n+                        ty_of_fn_decl(tcx, m_check_tyvar(fcx), proto, decl));\n \n     #debug(\"check_expr_fn_with_unifier %s fty=%s\",\n            expr_to_str(expr),\n@@ -1600,7 +1628,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                          }]);\n             // HACK: build an arguments list with dummy arguments to\n             // check against\n-            let dummy = {mode: ast::by_ref, ty: ty::mk_bot(fcx.ccx.tcx)};\n+            let dummy = {mode: ast::expl(ast::by_ref),\n+                         ty: ty::mk_bot(fcx.ccx.tcx)};\n             arg_tys = vec::init_elt(supplied_arg_count, dummy);\n         }\n \n@@ -2027,7 +2056,6 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                ty_to_str(tcx, expected));\n         check_expr_fn_with_unifier(fcx, expr, proto, decl, body,\n                                    unify, expected);\n-        write_ty(tcx, id, expected);\n       }\n       ast::expr_block(b) {\n         // If this is an unchecked block, turn off purity-checking\n@@ -2428,15 +2456,13 @@ fn check_const(ccx: @crate_ctxt, _sp: span, e: @ast::expr, id: ast::node_id) {\n     // FIXME: this is kinda a kludge; we manufacture a fake function context\n     // and statement context for checking the initializer expression.\n     let rty = node_id_to_type(ccx.tcx, id);\n-    let fixups: [ast::node_id] = [];\n     let fcx: @fn_ctxt =\n         @{ret_ty: rty,\n           purity: ast::pure_fn,\n           proto: ast::proto_box,\n           var_bindings: ty::unify::mk_var_bindings(),\n           locals: new_int_hash::<int>(),\n           next_var_id: @mutable 0,\n-          mutable fixups: fixups,\n           ccx: ccx};\n     check_expr(fcx, e);\n     let cty = expr_ty(fcx.ccx.tcx, e);\n@@ -2449,15 +2475,13 @@ fn check_enum_variants(ccx: @crate_ctxt, sp: span, vs: [ast::variant],\n     // FIXME: this is kinda a kludge; we manufacture a fake function context\n     // and statement context for checking the initializer expression.\n     let rty = node_id_to_type(ccx.tcx, id);\n-    let fixups: [ast::node_id] = [];\n     let fcx: @fn_ctxt =\n         @{ret_ty: rty,\n           purity: ast::pure_fn,\n           proto: ast::proto_box,\n           var_bindings: ty::unify::mk_var_bindings(),\n           locals: new_int_hash::<int>(),\n           next_var_id: @mutable 0,\n-          mutable fixups: fixups,\n           ccx: ccx};\n     let disr_vals: [int] = [];\n     let disr_val = 0;\n@@ -2630,15 +2654,13 @@ fn check_fn(ccx: @crate_ctxt,\n     };\n \n     let gather_result = gather_locals(ccx, decl, body, id, old_fcx);\n-    let fixups: [ast::node_id] = [];\n     let fcx: @fn_ctxt =\n         @{ret_ty: ty::ty_fn_ret(ccx.tcx, ty::node_id_to_type(ccx.tcx, id)),\n           purity: purity,\n           proto: proto,\n           var_bindings: gather_result.var_bindings,\n           locals: gather_result.locals,\n           next_var_id: gather_result.next_var_id,\n-          mutable fixups: fixups,\n           ccx: ccx};\n \n     check_constraints(fcx, decl.constraints, decl.inputs);"}, {"sha": "8db4573c2b43c7a62826647f5f5ff9b4e030949e", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=77b06d24cd76bf808138f1f7df4dcff40260ff38", "patch": "@@ -160,7 +160,17 @@ enum unop {\n     deref, not, neg,\n }\n \n-enum mode { by_ref, by_val, by_mut_ref, by_move, by_copy, mode_infer, }\n+// Generally, after typeck you can get the inferred value\n+// using ty::resolved_T(...).\n+enum inferable<T> {\n+    expl(T), infer(node_id)\n+}\n+\n+// \"resolved\" mode: the real modes.\n+enum rmode { by_ref, by_val, by_mut_ref, by_move, by_copy }\n+\n+// inferable mode.\n+type mode = inferable<rmode>;\n \n type stmt = spanned<stmt_>;\n "}, {"sha": "0b321b17b92007e5900cdc7c4dd1cf0c8d436cec", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=77b06d24cd76bf808138f1f7df4dcff40260ff38", "patch": "@@ -521,14 +521,19 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n }\n \n fn parse_arg_mode(p: parser) -> ast::mode {\n-    if eat(p, token::BINOP(token::AND)) { ast::by_mut_ref }\n-    else if eat(p, token::BINOP(token::MINUS)) { ast::by_move }\n-    else if eat(p, token::ANDAND) { ast::by_ref }\n-    else if eat(p, token::BINOP(token::PLUS)) {\n-        if eat(p, token::BINOP(token::PLUS)) { ast::by_val }\n-        else { ast::by_copy }\n-    }\n-    else { ast::mode_infer }\n+    if eat(p, token::BINOP(token::AND)) {\n+        ast::expl(ast::by_mut_ref)\n+    } else if eat(p, token::BINOP(token::MINUS)) {\n+        ast::expl(ast::by_move)\n+    } else if eat(p, token::ANDAND) {\n+        ast::expl(ast::by_ref)\n+    } else if eat(p, token::BINOP(token::PLUS)) {\n+        if eat(p, token::BINOP(token::PLUS)) {\n+            ast::expl(ast::by_val)\n+        } else {\n+            ast::expl(ast::by_copy)\n+        }\n+    } else { ast::infer(p.get_id()) }\n }\n \n fn parse_arg(p: parser) -> ast::arg {\n@@ -1984,8 +1989,8 @@ fn parse_item_res(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let dtor = parse_block_no_value(p);\n     let decl =\n         {inputs:\n-             [{mode: ast::by_ref, ty: t, ident: arg_ident,\n-               id: p.get_id()}],\n+             [{mode: ast::expl(ast::by_ref), ty: t,\n+               ident: arg_ident, id: p.get_id()}],\n          output: @spanned(lo, lo, ast::ty_nil),\n          purity: ast::impure_fn,\n          cf: ast::return_val,"}, {"sha": "864702d2ba1d1c495a372a949265ea05153fa2ee", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=77b06d24cd76bf808138f1f7df4dcff40260ff38", "patch": "@@ -136,7 +136,7 @@ fn res_to_str(decl: ast::fn_decl, name: ast::ident,\n fn test_res_to_str() {\n     let decl: ast::fn_decl = {\n         inputs: [{\n-            mode: ast::by_val,\n+            mode: ast::expl(ast::by_val),\n             ty: @ast_util::respan(ast_util::dummy_sp(), ast::ty_bool),\n             ident: \"b\",\n             id: 0\n@@ -1280,17 +1280,22 @@ fn print_fn_block_args(s: ps, decl: ast::fn_decl) {\n     maybe_print_comment(s, decl.output.span.lo);\n }\n \n-fn print_arg_mode(s: ps, m: ast::mode) {\n+fn mode_to_str(m: ast::mode) -> str {\n     alt m {\n-      ast::by_mut_ref { word(s.s, \"&\"); }\n-      ast::by_move { word(s.s, \"-\"); }\n-      ast::by_ref { word(s.s, \"&&\"); }\n-      ast::by_val { word(s.s, \"++\"); }\n-      ast::by_copy { word(s.s, \"+\"); }\n-      ast::mode_infer {}\n+      ast::expl(ast::by_mut_ref) { \"&\" }\n+      ast::expl(ast::by_move) { \"-\" }\n+      ast::expl(ast::by_ref) { \"&&\" }\n+      ast::expl(ast::by_val) { \"++\" }\n+      ast::expl(ast::by_copy) { \"+\" }\n+      ast::infer(_) { \"\" }\n     }\n }\n \n+fn print_arg_mode(s: ps, m: ast::mode) {\n+    let ms = mode_to_str(m);\n+    if ms != \"\" { word(s.s, ms); }\n+}\n+\n fn print_bounds(s: ps, bounds: @[ast::ty_param_bound]) {\n     if vec::len(*bounds) > 0u {\n         word(s.s, \":\");"}, {"sha": "512b02ca734f6d7b0fea6139a376adafa225988a", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77b06d24cd76bf808138f1f7df4dcff40260ff38/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=77b06d24cd76bf808138f1f7df4dcff40260ff38", "patch": "@@ -4,32 +4,18 @@ import middle::ty;\n import middle::ty::*;\n import metadata::encoder;\n import syntax::print::pprust;\n-import syntax::print::pprust::{path_to_str, constr_args_to_str, proto_to_str};\n+import syntax::print::pprust::{path_to_str, constr_args_to_str, proto_to_str,\n+                               mode_to_str};\n import syntax::{ast, ast_util};\n import middle::ast_map;\n \n-fn mode_str(m: ast::mode) -> str {\n-    alt m {\n-      ast::by_ref { \"&&\" }\n-      ast::by_val { \"++\" }\n-      ast::by_mut_ref { \"&\" }\n-      ast::by_move { \"-\" }\n-      ast::by_copy { \"+\" }\n-      _ { \"\" }\n-    }\n-}\n-\n fn ty_to_str(cx: ctxt, typ: t) -> str {\n     fn fn_input_to_str(cx: ctxt, input: {mode: ast::mode, ty: t}) ->\n        str {\n-        let modestr = alt input.mode {\n-          ast::by_ref {\n-            if ty::type_is_immediate(cx, input.ty) { \"&&\" } else { \"\" }\n-          }\n-          ast::by_val {\n-            if ty::type_is_immediate(cx, input.ty) { \"\" } else { \"++\" }\n-          }\n-          _ { mode_str(input.mode) }\n+        let arg_mode = ty::arg_mode(cx, input);\n+        let modestr = {\n+            if arg_mode == ty::default_arg_mode_for_ty(cx, input.ty) { \"\" }\n+            else { mode_to_str(input.mode) }\n         };\n         modestr + ty_to_str(cx, input.ty)\n     }"}]}