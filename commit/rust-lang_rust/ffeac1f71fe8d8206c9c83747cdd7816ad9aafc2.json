{"sha": "ffeac1f71fe8d8206c9c83747cdd7816ad9aafc2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmZWFjMWY3MWZlOGQ4MjA2YzljODM3NDdjZGQ3ODE2YWQ5YWFmYzI=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2019-10-20T18:06:20Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2019-10-23T21:21:09Z"}, "message": "proposal for access to BTreeMap/BTreeSet first/last, #62924", "tree": {"sha": "6fabe7a44d84133884f4760bc190502f58c91102", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fabe7a44d84133884f4760bc190502f58c91102"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffeac1f71fe8d8206c9c83747cdd7816ad9aafc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffeac1f71fe8d8206c9c83747cdd7816ad9aafc2", "html_url": "https://github.com/rust-lang/rust/commit/ffeac1f71fe8d8206c9c83747cdd7816ad9aafc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffeac1f71fe8d8206c9c83747cdd7816ad9aafc2/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a8c5b20c7772bc5342b83d4b0696ea216ef75a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a8c5b20c7772bc5342b83d4b0696ea216ef75a7", "html_url": "https://github.com/rust-lang/rust/commit/4a8c5b20c7772bc5342b83d4b0696ea216ef75a7"}], "stats": {"total": 325, "additions": 314, "deletions": 11}, "files": [{"sha": "b541fa94e954e430c77b4e131a61fdeb006cb838", "filename": "src/liballoc/benches/btree/map.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ffeac1f71fe8d8206c9c83747cdd7816ad9aafc2/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffeac1f71fe8d8206c9c83747cdd7816ad9aafc2/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs?ref=ffeac1f71fe8d8206c9c83747cdd7816ad9aafc2", "patch": "@@ -145,3 +145,28 @@ pub fn iter_1000(b: &mut Bencher) {\n pub fn iter_100000(b: &mut Bencher) {\n     bench_iter(b, 100000);\n }\n+\n+fn bench_first_and_last(b: &mut Bencher, size: i32) {\n+    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    b.iter(|| {\n+        for _ in 0..10 {\n+            black_box(map.first_key_value());\n+            black_box(map.last_key_value());\n+        }\n+    });\n+}\n+\n+#[bench]\n+pub fn first_and_last_0(b: &mut Bencher) {\n+    bench_first_and_last(b, 0);\n+}\n+\n+#[bench]\n+pub fn first_and_last_100(b: &mut Bencher) {\n+    bench_first_and_last(b, 100);\n+}\n+\n+#[bench]\n+pub fn first_and_last_10k(b: &mut Bencher) {\n+    bench_first_and_last(b, 10_000);\n+}"}, {"sha": "9acda886064ce5e2ea5d3b5a1ac4bc2906e26996", "filename": "src/liballoc/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ffeac1f71fe8d8206c9c83747cdd7816ad9aafc2/src%2Fliballoc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffeac1f71fe8d8206c9c83747cdd7816ad9aafc2/src%2Fliballoc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Flib.rs?ref=ffeac1f71fe8d8206c9c83747cdd7816ad9aafc2", "patch": "@@ -1,3 +1,4 @@\n+#![feature(map_first_last)]\n #![feature(repr_simd)]\n #![feature(test)]\n "}, {"sha": "5b48b594ff9079d552fbfcc3effc39fb1ac8dac6", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/ffeac1f71fe8d8206c9c83747cdd7816ad9aafc2/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffeac1f71fe8d8206c9c83747cdd7816ad9aafc2/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=ffeac1f71fe8d8206c9c83747cdd7816ad9aafc2", "patch": "@@ -598,6 +598,121 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         }\n     }\n \n+    /// Returns the first key-value pair in the map.\n+    /// The key in this pair is the minimum key in the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(map_first_last)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// assert_eq!(map.first_key_value(), None);\n+    /// map.insert(1, \"b\");\n+    /// map.insert(2, \"a\");\n+    /// assert_eq!(map.first_key_value(), Some((&1, &\"b\")));\n+    /// ```\n+    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n+    pub fn first_key_value<T: ?Sized>(&self) -> Option<(&K, &V)>\n+        where T: Ord, K: Borrow<T>\n+    {\n+        let front = first_leaf_edge(self.root.as_ref());\n+        front.right_kv().ok().map(Handle::into_kv)\n+    }\n+\n+    /// Returns the first entry in the map for in-place manipulation.\n+    /// The key of this entry is the minimum key in the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Contrived way to `clear` a map:\n+    ///\n+    /// ```\n+    /// #![feature(map_first_last)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// map.insert(1, \"a\");\n+    /// map.insert(2, \"b\");\n+    /// while let Some(entry) = map.first_entry() {\n+    ///     let (key, val) = entry.remove_entry();\n+    ///     assert!(!map.contains_key(&key));\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n+    pub fn first_entry<T: ?Sized>(&mut self) -> Option<OccupiedEntry<'_, K, V>>\n+        where T: Ord, K: Borrow<T>\n+    {\n+        match self.length {\n+            0 => None,\n+            _ => Some(OccupiedEntry {\n+                          handle: self.root.as_mut().first_kv(),\n+                          length: &mut self.length,\n+                          _marker: PhantomData,\n+                      }),\n+        }\n+    }\n+\n+    /// Returns the last key-value pair in the map.\n+    /// The key in this pair is the maximum key in the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(map_first_last)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// map.insert(1, \"b\");\n+    /// map.insert(2, \"a\");\n+    /// assert_eq!(map.last_key_value(), Some((&2, &\"a\")));\n+    /// ```\n+    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n+    pub fn last_key_value<T: ?Sized>(&self) -> Option<(&K, &V)>\n+        where T: Ord, K: Borrow<T>\n+    {\n+        let back = last_leaf_edge(self.root.as_ref());\n+        back.left_kv().ok().map(Handle::into_kv)\n+    }\n+\n+    /// Returns the last entry in the map for in-place manipulation.\n+    /// The key of this entry is the maximum key in the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Contrived way to `clear` a map:\n+    ///\n+    /// ```\n+    /// #![feature(map_first_last)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// map.insert(1, \"a\");\n+    /// map.insert(2, \"b\");\n+    /// while let Some(entry) = map.last_entry() {\n+    ///     let (key, val) = entry.remove_entry();\n+    ///     assert!(!map.contains_key(&key));\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n+    pub fn last_entry<T: ?Sized>(&mut self) -> Option<OccupiedEntry<'_, K, V>>\n+        where T: Ord, K: Borrow<T>\n+    {\n+        match self.length {\n+            0 => None,\n+            _ => Some(OccupiedEntry {\n+                          handle: self.root.as_mut().last_kv(),\n+                          length: &mut self.length,\n+                          _marker: PhantomData,\n+                      }),\n+        }\n+    }\n+\n     /// Returns `true` if the map contains a value for the specified key.\n     ///\n     /// The key may be any borrowed form of the map's key type, but the ordering"}, {"sha": "85b93e0eda45bfd49235f766fa6e0ab79fe692fe", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 99, "deletions": 11, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/ffeac1f71fe8d8206c9c83747cdd7816ad9aafc2/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffeac1f71fe8d8206c9c83747cdd7816ad9aafc2/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=ffeac1f71fe8d8206c9c83747cdd7816ad9aafc2", "patch": "@@ -194,16 +194,16 @@ pub struct Difference<'a, T: 'a> {\n #[derive(Debug)]\n enum DifferenceInner<'a, T: 'a> {\n     Stitch {\n-        // iterate all of self and some of other, spotting matches along the way\n+        // iterate all of `self` and some of `other`, spotting matches along the way\n         self_iter: Iter<'a, T>,\n         other_iter: Peekable<Iter<'a, T>>,\n     },\n     Search {\n-        // iterate a small set, look up in the large set\n+        // iterate `self`, look up in `other`\n         self_iter: Iter<'a, T>,\n         other_set: &'a BTreeSet<T>,\n     },\n-    Iterate(Iter<'a, T>), // simply stream self's elements\n+    Iterate(Iter<'a, T>), // simply produce all values in `self`\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n@@ -356,7 +356,7 @@ impl<T: Ord> BTreeSet<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n         let (self_min, self_max) = if let (Some(self_min), Some(self_max)) =\n-            (self.iter().next(), self.iter().next_back())\n+            (self.first(), self.last())\n         {\n             (self_min, self_max)\n         } else {\n@@ -365,7 +365,7 @@ impl<T: Ord> BTreeSet<T> {\n             };\n         };\n         let (other_min, other_max) = if let (Some(other_min), Some(other_max)) =\n-            (other.iter().next(), other.iter().next_back())\n+            (other.first(), other.last())\n         {\n             (other_min, other_max)\n         } else {\n@@ -450,7 +450,7 @@ impl<T: Ord> BTreeSet<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>) -> Intersection<'a, T> {\n         let (self_min, self_max) = if let (Some(self_min), Some(self_max)) =\n-            (self.iter().next(), self.iter().next_back())\n+            (self.first(), self.last())\n         {\n             (self_min, self_max)\n         } else {\n@@ -459,7 +459,7 @@ impl<T: Ord> BTreeSet<T> {\n             };\n         };\n         let (other_min, other_max) = if let (Some(other_min), Some(other_max)) =\n-            (other.iter().next(), other.iter().next_back())\n+            (other.first(), other.last())\n         {\n             (other_min, other_max)\n         } else {\n@@ -625,14 +625,14 @@ impl<T: Ord> BTreeSet<T> {\n             return false;\n         }\n         let (self_min, self_max) = if let (Some(self_min), Some(self_max)) =\n-            (self.iter().next(), self.iter().next_back())\n+            (self.first(), self.last())\n         {\n             (self_min, self_max)\n         } else {\n             return true; // self is empty\n         };\n         let (other_min, other_max) = if let (Some(other_min), Some(other_max)) =\n-            (other.iter().next(), other.iter().next_back())\n+            (other.first(), other.last())\n         {\n             (other_min, other_max)\n         } else {\n@@ -654,14 +654,12 @@ impl<T: Ord> BTreeSet<T> {\n             Less => (),\n         }\n         if self_iter.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n-            // Big difference in number of elements.\n             for next in self_iter {\n                 if !other.contains(next) {\n                     return false;\n                 }\n             }\n         } else {\n-            // Self is not much smaller than other set.\n             let mut other_iter = other.iter();\n             other_iter.next();\n             other_iter.next_back();\n@@ -702,6 +700,96 @@ impl<T: Ord> BTreeSet<T> {\n         other.is_subset(self)\n     }\n \n+    /// Returns a reference to the first value in the set, if any.\n+    /// This value is always the minimum of all values in the set.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(map_first_last)]\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut map = BTreeSet::new();\n+    /// assert_eq!(map.first(), None);\n+    /// map.insert(1);\n+    /// assert_eq!(map.first(), Some(&1));\n+    /// map.insert(2);\n+    /// assert_eq!(map.first(), Some(&1));\n+    /// ```\n+    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n+    pub fn first(&self) -> Option<&T> {\n+        self.map.first_key_value().map(|(k, _)| k)\n+    }\n+\n+    /// Returns a reference to the last value in the set, if any.\n+    /// This value is always the maximum of all values in the set.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(map_first_last)]\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut map = BTreeSet::new();\n+    /// assert_eq!(map.first(), None);\n+    /// map.insert(1);\n+    /// assert_eq!(map.last(), Some(&1));\n+    /// map.insert(2);\n+    /// assert_eq!(map.last(), Some(&2));\n+    /// ```\n+    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n+    pub fn last(&self) -> Option<&T> {\n+        self.map.last_key_value().map(|(k, _)| k)\n+    }\n+\n+    /// Removes the first value from the set and returns it, if any.\n+    /// The first value is always the minimum value in the set.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(map_first_last)]\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut set = BTreeSet::new();\n+    ///\n+    /// set.insert(1);\n+    /// while let Some(n) = set.pop_first() {\n+    ///     assert_eq!(n, 1);\n+    /// }\n+    /// assert!(set.is_empty());\n+    /// ```\n+    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n+    pub fn pop_first(&mut self) -> Option<T> {\n+        self.map.first_entry().map(|entry| entry.remove_entry().0)\n+    }\n+\n+    /// Removes the last value from the set and returns it, if any.\n+    /// The last value is always the maximum value in the set.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(map_first_last)]\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut set = BTreeSet::new();\n+    ///\n+    /// set.insert(1);\n+    /// while let Some(n) = set.pop_last() {\n+    ///     assert_eq!(n, 1);\n+    /// }\n+    /// assert!(set.is_empty());\n+    /// ```\n+    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n+    pub fn pop_last(&mut self) -> Option<T> {\n+        self.map.last_entry().map(|entry| entry.remove_entry().0)\n+    }\n+\n     /// Adds a value to the set.\n     ///\n     /// If the set did not have this value present, `true` is returned."}, {"sha": "27843aeaeb0c80fa236a7d17fc900d1b079ec40f", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ffeac1f71fe8d8206c9c83747cdd7816ad9aafc2/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffeac1f71fe8d8206c9c83747cdd7816ad9aafc2/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=ffeac1f71fe8d8206c9c83747cdd7816ad9aafc2", "patch": "@@ -58,15 +58,35 @@ fn test_basic_large() {\n fn test_basic_small() {\n     let mut map = BTreeMap::new();\n     assert_eq!(map.remove(&1), None);\n+    assert_eq!(map.len(), 0);\n+    assert_eq!(map.first_key_value(), None);\n+    assert_eq!(map.last_key_value(), None);\n     assert_eq!(map.get(&1), None);\n     assert_eq!(map.insert(1, 1), None);\n+    assert_eq!(map.len(), 1);\n     assert_eq!(map.get(&1), Some(&1));\n+    assert_eq!(map.first_key_value(), Some((&1, &1)));\n+    assert_eq!(map.last_key_value(), Some((&1, &1)));\n     assert_eq!(map.insert(1, 2), Some(1));\n+    assert_eq!(map.len(), 1);\n     assert_eq!(map.get(&1), Some(&2));\n+    assert_eq!(map.first_key_value(), Some((&1, &2)));\n+    assert_eq!(map.last_key_value(), Some((&1, &2)));\n     assert_eq!(map.insert(2, 4), None);\n+    assert_eq!(map.len(), 2);\n     assert_eq!(map.get(&2), Some(&4));\n+    assert_eq!(map.first_key_value(), Some((&1, &2)));\n+    assert_eq!(map.last_key_value(), Some((&2, &4)));\n     assert_eq!(map.remove(&1), Some(2));\n+    assert_eq!(map.len(), 1);\n+    assert_eq!(map.get(&1), None);\n+    assert_eq!(map.get(&2), Some(&4));\n+    assert_eq!(map.first_key_value(), Some((&2, &4)));\n+    assert_eq!(map.last_key_value(), Some((&2, &4)));\n     assert_eq!(map.remove(&2), Some(4));\n+    assert_eq!(map.len(), 0);\n+    assert_eq!(map.first_key_value(), None);\n+    assert_eq!(map.last_key_value(), None);\n     assert_eq!(map.remove(&1), None);\n }\n \n@@ -605,6 +625,31 @@ fn test_vacant_entry_key() {\n     assert_eq!(a[key], value);\n }\n \n+#[test]\n+fn test_first_last_entry() {\n+    let mut a = BTreeMap::new();\n+    assert!(a.first_entry().is_none());\n+    assert!(a.last_entry().is_none());\n+    a.insert(1, 42);\n+    assert_eq!(a.first_entry().unwrap().key(), &1);\n+    assert_eq!(a.last_entry().unwrap().key(), &1);\n+    a.insert(2, 24);\n+    assert_eq!(a.first_entry().unwrap().key(), &1);\n+    assert_eq!(a.last_entry().unwrap().key(), &2);\n+    a.insert(0, 6);\n+    assert_eq!(a.first_entry().unwrap().key(), &0);\n+    assert_eq!(a.last_entry().unwrap().key(), &2);\n+    let (k1, v1) = a.first_entry().unwrap().remove_entry();\n+    assert_eq!(k1, 0);\n+    assert_eq!(v1, 6);\n+    let (k2, v2) = a.last_entry().unwrap().remove_entry();\n+    assert_eq!(k2, 2);\n+    assert_eq!(v2, 24);\n+    assert_eq!(a.first_entry().unwrap().key(), &1);\n+    assert_eq!(a.last_entry().unwrap().key(), &1);\n+}\n+\n+\n macro_rules! create_append_test {\n     ($name:ident, $len:expr) => {\n         #[test]"}, {"sha": "13cd26280227ec62931762f138a55d177564696a", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ffeac1f71fe8d8206c9c83747cdd7816ad9aafc2/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffeac1f71fe8d8206c9c83747cdd7816ad9aafc2/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=ffeac1f71fe8d8206c9c83747cdd7816ad9aafc2", "patch": "@@ -470,6 +470,34 @@ fn test_append() {\n     assert_eq!(a.contains(&5), true);\n }\n \n+#[test]\n+fn test_first_last() {\n+    let mut a = BTreeSet::new();\n+    assert_eq!(a.first(), None);\n+    assert_eq!(a.last(), None);\n+    a.insert(1);\n+    assert_eq!(a.first(), Some(&1));\n+    assert_eq!(a.last(), Some(&1));\n+    a.insert(2);\n+    assert_eq!(a.first(), Some(&1));\n+    assert_eq!(a.last(), Some(&2));\n+    a.insert(3);\n+    assert_eq!(a.first(), Some(&1));\n+    assert_eq!(a.last(), Some(&3));\n+\n+    assert_eq!(a.len(), 3);\n+    assert_eq!(a.pop_first(), Some(1));\n+    assert_eq!(a.len(), 2);\n+    assert_eq!(a.pop_last(), Some(3));\n+    assert_eq!(a.len(), 1);\n+    assert_eq!(a.pop_first(), Some(2));\n+    assert_eq!(a.len(), 0);\n+    assert_eq!(a.pop_last(), None);\n+    assert_eq!(a.len(), 0);\n+    assert_eq!(a.pop_first(), None);\n+    assert_eq!(a.len(), 0);\n+}\n+\n fn rand_data(len: usize) -> Vec<u32> {\n     let mut rng = DeterministicRng::new();\n     Vec::from_iter((0..len).map(|_| rng.next()))"}, {"sha": "ea0f76174e48328753d221b9df7d56d24ffbe26a", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ffeac1f71fe8d8206c9c83747cdd7816ad9aafc2/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffeac1f71fe8d8206c9c83747cdd7816ad9aafc2/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=ffeac1f71fe8d8206c9c83747cdd7816ad9aafc2", "patch": "@@ -2,6 +2,7 @@\n #![feature(box_syntax)]\n #![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n+#![feature(map_first_last)]\n #![feature(new_uninit)]\n #![feature(option_flattening)]\n #![feature(pattern)]"}]}