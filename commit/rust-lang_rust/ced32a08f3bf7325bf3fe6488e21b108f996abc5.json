{"sha": "ced32a08f3bf7325bf3fe6488e21b108f996abc5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlZDMyYTA4ZjNiZjczMjViZjNmZTY0ODhlMjFiMTA4Zjk5NmFiYzU=", "commit": {"author": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-11-10T03:52:30Z"}, "committer": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-11-10T03:52:30Z"}, "message": "Fix exec", "tree": {"sha": "d9af3131bf73f5f94a62727eccfcb66fbf627376", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9af3131bf73f5f94a62727eccfcb66fbf627376"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ced32a08f3bf7325bf3fe6488e21b108f996abc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ced32a08f3bf7325bf3fe6488e21b108f996abc5", "html_url": "https://github.com/rust-lang/rust/commit/ced32a08f3bf7325bf3fe6488e21b108f996abc5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ced32a08f3bf7325bf3fe6488e21b108f996abc5/comments", "author": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01e837807095e99d68ecf9c0b38527288281dd02", "url": "https://api.github.com/repos/rust-lang/rust/commits/01e837807095e99d68ecf9c0b38527288281dd02", "html_url": "https://github.com/rust-lang/rust/commit/01e837807095e99d68ecf9c0b38527288281dd02"}], "stats": {"total": 66, "additions": 10, "deletions": 56}, "files": [{"sha": "ad50d1de283330ca1d6328235ead8d51ed92ebb0", "filename": "src/libstd/sys/redox/process.rs", "status": "modified", "additions": 10, "deletions": 56, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ced32a08f3bf7325bf3fe6488e21b108f996abc5/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ced32a08f3bf7325bf3fe6488e21b108f996abc5/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs?ref=ced32a08f3bf7325bf3fe6488e21b108f996abc5", "patch": "@@ -18,7 +18,7 @@ use path::Path;\n use sys::fd::FileDesc;\n use sys::fs::{File, OpenOptions};\n use sys::pipe::{self, AnonPipe};\n-use sys::{self, cvt};\n+use sys::cvt;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Command\n@@ -145,78 +145,32 @@ impl Command {\n \n     pub fn spawn(&mut self, default: Stdio, needs_stdin: bool)\n                  -> io::Result<(Process, StdioPipes)> {\n-        const CLOEXEC_MSG_FOOTER: &'static [u8] = b\"NOEX\";\n-\n         if self.saw_nul {\n             return Err(io::Error::new(ErrorKind::InvalidInput,\n                                       \"nul byte found in provided data\"));\n         }\n \n         let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n-        let (input, output) = sys::pipe::anon_pipe()?;\n \n         let pid = unsafe {\n-            match cvt(libc::clone(0))? {\n+            match cvt(libc::clone(libc::CLONE_VFORK))? {\n                 0 => {\n-                    drop(input);\n                     let err = self.do_exec(theirs);\n-                    let errno = err.raw_os_error().unwrap_or(libc::EINVAL) as u32;\n-                    let bytes = [\n-                        (errno >> 24) as u8,\n-                        (errno >> 16) as u8,\n-                        (errno >>  8) as u8,\n-                        (errno >>  0) as u8,\n-                        CLOEXEC_MSG_FOOTER[0], CLOEXEC_MSG_FOOTER[1],\n-                        CLOEXEC_MSG_FOOTER[2], CLOEXEC_MSG_FOOTER[3]\n-                    ];\n-                    // pipe I/O up to PIPE_BUF bytes should be atomic, and then\n-                    // we want to be sure we *don't* run at_exit destructors as\n-                    // we're being torn down regardless\n-                    assert!(output.write(&bytes).is_ok());\n-                    let _ = libc::exit(1);\n+                    let _ = libc::exit((-err.raw_os_error().unwrap_or(libc::EINVAL)) as usize);\n                     unreachable!();\n                 }\n                 n => n as pid_t,\n             }\n         };\n \n-        let mut p = Process { pid: pid, status: None };\n-        drop(output);\n-        let mut bytes = [0; 8];\n-\n-        // loop to handle EINTR\n-        loop {\n-            match input.read(&mut bytes) {\n-                Ok(0) => return Ok((p, ours)),\n-                Ok(8) => {\n-                    assert!(combine(CLOEXEC_MSG_FOOTER) == combine(&bytes[4.. 8]),\n-                            \"Validation on the CLOEXEC pipe failed: {:?}\", bytes);\n-                    let errno = combine(&bytes[0.. 4]);\n-                    assert!(p.wait().is_ok(),\n-                            \"wait() should either return Ok or panic\");\n-                    return Err(Error::from_raw_os_error(errno))\n-                }\n-                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n-                Err(e) => {\n-                    assert!(p.wait().is_ok(),\n-                            \"wait() should either return Ok or panic\");\n-                    panic!(\"the CLOEXEC pipe failed: {:?}\", e)\n-                },\n-                Ok(..) => { // pipe I/O up to PIPE_BUF bytes should be atomic\n-                    assert!(p.wait().is_ok(),\n-                            \"wait() should either return Ok or panic\");\n-                    panic!(\"short read on the CLOEXEC pipe\")\n-                }\n+        let mut status_mux = 0;\n+        if cvt(libc::waitpid(pid, &mut status_mux, libc::WNOHANG))? == pid {\n+            match libc::Error::demux(status_mux) {\n+                Ok(status) => Ok((Process { pid: pid, status: Some(ExitStatus::from(status as c_int)) }, ours)),\n+                Err(err) => Err(io::Error::from_raw_os_error(err.errno)),\n             }\n-        }\n-\n-        fn combine(arr: &[u8]) -> i32 {\n-            let a = arr[0] as u32;\n-            let b = arr[1] as u32;\n-            let c = arr[2] as u32;\n-            let d = arr[3] as u32;\n-\n-            ((a << 24) | (b << 16) | (c << 8) | (d << 0)) as i32\n+        } else {\n+            Ok((Process { pid: pid, status: None }, ours))\n         }\n     }\n "}]}