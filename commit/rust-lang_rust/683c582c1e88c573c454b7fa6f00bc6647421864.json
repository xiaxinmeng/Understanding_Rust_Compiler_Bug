{"sha": "683c582c1e88c573c454b7fa6f00bc6647421864", "node_id": "C_kwDOAAsO6NoAKDY4M2M1ODJjMWU4OGM1NzNjNDU0YjdmYTZmMDBiYzY2NDc0MjE4NjQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-29T11:58:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-29T11:58:24Z"}, "message": "Auto merge of #96468 - davidtwco:diagnostic-translation-subdiagnostic, r=oli-obk\n\nmacros: subdiagnostic derive\n\nAdd a new macro, `#[derive(SessionSubdiagnostic)]`, which can be applied to structs that represent subdiagnostics, such as labels, notes, helps or suggestions.\n\n`#[derive(SessionSubdiagnostic)]` can be used with the existing `#[derive(SessionDiagnostic)]`. All diagnostics implemented using either derive are translatable, and this new derive should make it easier to port existing diagnostics to using these derives.\n\nFor example, consider the following subdiagnostic types...\n\n```rust\n#[derive(SessionSubdiagnostic)]\npub enum ExpectedIdentifierLabel<'tcx> {\n    #[label(slug = \"parser-expected-identifier\")]\n    WithoutFound {\n        #[primary_span]\n        span: Span,\n    }\n    #[label(slug = \"parser-expected-identifier-found\")]\n    WithFound {\n        #[primary_span]\n        span: Span,\n        found: String,\n    }\n}\n\n#[derive(SessionSubdiagnostic)]\n#[suggestion_verbose(slug = \"parser-raw-identifier\")]\npub struct RawIdentifierSuggestion<'tcx> {\n    #[primary_span]\n    span: Span,\n    #[applicability]\n    applicability: Applicability,\n    ident: Ident,\n}\n```\n\n...and the corresponding Fluent messages:\n\n```fluent\nparser-expected-identifier = expected identifier\n\nparser-expected-identifier-found = expected identifier, found {$found}\n\nparser-raw-identifier = escape `{$ident}` to use it as an identifier\n```\n\nThese can be emitted using the new `subdiagnostic` function on `Diagnostic`...\n\n```rust\ndiag.subdiagnostic(ExpectedIdentifierLabel::WithoutFound { span });\ndiag.subdiagnostic(RawIdentifierSuggestion { span, applicability, ident });\n```\n\n...or as part of a larger `#[derive(SessionDiagnostic)]`:\n\n```rust\n#[derive(SessionDiagnostic)]\n#[error(slug = \"parser-expected-identifier\")]\npub struct ExpectedIdentifier {\n    #[primary_span]\n    span: Span,\n    token_descr: String,\n    #[subdiagnostic]\n    label: ExpectedIdentifierLabel,\n    #[subdiagnostic]\n    raw_identifier_suggestion: Option<RawIdentifierSuggestion>,\n}\n```\n\n```rust\nsess.emit_err(ExpectedIdentifier { ... });\n```\n\nr? `@oli-obk`\ncc `@pvdrz`", "tree": {"sha": "db4d2b296b27bd7d137b8399343ed7a5f44b7b19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db4d2b296b27bd7d137b8399343ed7a5f44b7b19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/683c582c1e88c573c454b7fa6f00bc6647421864", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/683c582c1e88c573c454b7fa6f00bc6647421864", "html_url": "https://github.com/rust-lang/rust/commit/683c582c1e88c573c454b7fa6f00bc6647421864", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/683c582c1e88c573c454b7fa6f00bc6647421864/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87937d3b6c302dfedfa5c4b94d0a30985d46298d", "url": "https://api.github.com/repos/rust-lang/rust/commits/87937d3b6c302dfedfa5c4b94d0a30985d46298d", "html_url": "https://github.com/rust-lang/rust/commit/87937d3b6c302dfedfa5c4b94d0a30985d46298d"}, {"sha": "dca88612b96db761f86ab66d85836baf0e804910", "url": "https://api.github.com/repos/rust-lang/rust/commits/dca88612b96db761f86ab66d85836baf0e804910", "html_url": "https://github.com/rust-lang/rust/commit/dca88612b96db761f86ab66d85836baf0e804910"}], "stats": {"total": 3863, "additions": 2758, "deletions": 1105}, "files": [{"sha": "fe5e3c5a81b61dda07296fe4e8f9a249bf75cabc", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -237,7 +237,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     err.span_suggestion_verbose(\n                         span,\n                         \"consider changing this to be mutable\",\n-                        \" mut \".into(),\n+                        \" mut \",\n                         Applicability::MaybeIncorrect,\n                     );\n                 }"}, {"sha": "b49331e28753db194fcfa5cc1470473d866382f5", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -235,7 +235,7 @@ fn validate_default_attribute(\n             .span_suggestion_hidden(\n                 attr.span,\n                 \"try using `#[default]`\",\n-                \"#[default]\".into(),\n+                \"#[default]\",\n                 Applicability::MaybeIncorrect,\n             )\n             .emit();"}, {"sha": "6a3235fc7728cad8044806e74ec5a51f0d54a6e3", "filename": "compiler/rustc_error_messages/locales/en-US/typeck.ftl", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ftypeck.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ftypeck.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ftypeck.ftl?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -82,3 +82,11 @@ typeck-value-of-associated-struct-already-specified =\n \n typeck-address-of-temporary-taken = cannot take address of a temporary\n     .label = temporary value\n+\n+typeck-add-return-type-add = try adding a return type\n+\n+typeck-add-return-type-missing-here = a return type might be missing here\n+\n+typeck-expected-default-return-type = expected `()` because of default return type\n+\n+typeck-expected-return-type = expected `{$expected}` because of return type"}, {"sha": "83e6a751394f5a44c9227b8eb1a68ef9f91c6a19", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -78,6 +78,13 @@ impl<'source> Into<FluentValue<'source>> for DiagnosticArgValue<'source> {\n     }\n }\n \n+/// Trait implemented by error types. This should not be implemented manually. Instead, use\n+/// `#[derive(SessionSubdiagnostic)]` -- see [rustc_macros::SessionSubdiagnostic].\n+pub trait AddSubdiagnostic {\n+    /// Add a subdiagnostic to an existing diagnostic.\n+    fn add_to_diagnostic(self, diag: &mut Diagnostic);\n+}\n+\n #[must_use]\n #[derive(Clone, Debug, Encodable, Decodable)]\n pub struct Diagnostic {\n@@ -605,7 +612,7 @@ impl Diagnostic {\n         &mut self,\n         sp: Span,\n         msg: impl Into<DiagnosticMessage>,\n-        suggestion: String,\n+        suggestion: impl ToString,\n         applicability: Applicability,\n     ) -> &mut Self {\n         self.span_suggestion_with_style(\n@@ -623,13 +630,13 @@ impl Diagnostic {\n         &mut self,\n         sp: Span,\n         msg: impl Into<DiagnosticMessage>,\n-        suggestion: String,\n+        suggestion: impl ToString,\n         applicability: Applicability,\n         style: SuggestionStyle,\n     ) -> &mut Self {\n         self.push_suggestion(CodeSuggestion {\n             substitutions: vec![Substitution {\n-                parts: vec![SubstitutionPart { snippet: suggestion, span: sp }],\n+                parts: vec![SubstitutionPart { snippet: suggestion.to_string(), span: sp }],\n             }],\n             msg: msg.into(),\n             style,\n@@ -643,7 +650,7 @@ impl Diagnostic {\n         &mut self,\n         sp: Span,\n         msg: impl Into<DiagnosticMessage>,\n-        suggestion: String,\n+        suggestion: impl ToString,\n         applicability: Applicability,\n     ) -> &mut Self {\n         self.span_suggestion_with_style(\n@@ -711,7 +718,7 @@ impl Diagnostic {\n         &mut self,\n         sp: Span,\n         msg: impl Into<DiagnosticMessage>,\n-        suggestion: String,\n+        suggestion: impl ToString,\n         applicability: Applicability,\n     ) -> &mut Self {\n         self.span_suggestion_with_style(\n@@ -734,7 +741,7 @@ impl Diagnostic {\n         &mut self,\n         sp: Span,\n         msg: impl Into<DiagnosticMessage>,\n-        suggestion: String,\n+        suggestion: impl ToString,\n         applicability: Applicability,\n     ) -> &mut Self {\n         self.span_suggestion_with_style(\n@@ -755,7 +762,7 @@ impl Diagnostic {\n         &mut self,\n         sp: Span,\n         msg: impl Into<DiagnosticMessage>,\n-        suggestion: String,\n+        suggestion: impl ToString,\n         applicability: Applicability,\n     ) -> &mut Self {\n         self.span_suggestion_with_style(\n@@ -768,6 +775,13 @@ impl Diagnostic {\n         self\n     }\n \n+    /// Add a subdiagnostic from a type that implements `SessionSubdiagnostic` - see\n+    /// [rustc_macros::SessionSubdiagnostic].\n+    pub fn subdiagnostic(&mut self, subdiagnostic: impl AddSubdiagnostic) -> &mut Self {\n+        subdiagnostic.add_to_diagnostic(self);\n+        self\n+    }\n+\n     pub fn set_span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self {\n         self.span = sp.into();\n         if let Some(span) = self.span.primary_span() {"}, {"sha": "96b730c2baaffd6885518af9e50c8d20c4e36f14", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -477,7 +477,7 @@ impl<'a, G: EmissionGuarantee> DiagnosticBuilder<'a, G> {\n         &mut self,\n         sp: Span,\n         msg: impl Into<DiagnosticMessage>,\n-        suggestion: String,\n+        suggestion: impl ToString,\n         applicability: Applicability,\n     ) -> &mut Self);\n     forward!(pub fn span_suggestions(\n@@ -497,28 +497,28 @@ impl<'a, G: EmissionGuarantee> DiagnosticBuilder<'a, G> {\n         &mut self,\n         sp: Span,\n         msg: impl Into<DiagnosticMessage>,\n-        suggestion: String,\n+        suggestion: impl ToString,\n         applicability: Applicability,\n     ) -> &mut Self);\n     forward!(pub fn span_suggestion_verbose(\n         &mut self,\n         sp: Span,\n         msg: impl Into<DiagnosticMessage>,\n-        suggestion: String,\n+        suggestion: impl ToString,\n         applicability: Applicability,\n     ) -> &mut Self);\n     forward!(pub fn span_suggestion_hidden(\n         &mut self,\n         sp: Span,\n         msg: impl Into<DiagnosticMessage>,\n-        suggestion: String,\n+        suggestion: impl ToString,\n         applicability: Applicability,\n     ) -> &mut Self);\n     forward!(pub fn tool_only_span_suggestion(\n         &mut self,\n         sp: Span,\n         msg: impl Into<DiagnosticMessage>,\n-        suggestion: String,\n+        suggestion: impl ToString,\n         applicability: Applicability,\n     ) -> &mut Self);\n \n@@ -530,6 +530,11 @@ impl<'a, G: EmissionGuarantee> DiagnosticBuilder<'a, G> {\n         name: impl Into<Cow<'static, str>>,\n         arg: DiagnosticArgValue<'static>,\n     ) -> &mut Self);\n+\n+    forward!(pub fn subdiagnostic(\n+        &mut self,\n+        subdiagnostic: impl crate::AddSubdiagnostic\n+    ) -> &mut Self);\n }\n \n impl<G: EmissionGuarantee> Debug for DiagnosticBuilder<'_, G> {"}, {"sha": "df41fc00714b684c9a16beaaa084b7a55b3c5bd4", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -370,8 +370,8 @@ impl fmt::Display for ExplicitBug {\n impl error::Error for ExplicitBug {}\n \n pub use diagnostic::{\n-    Diagnostic, DiagnosticArg, DiagnosticArgValue, DiagnosticId, DiagnosticStyledString,\n-    IntoDiagnosticArg, SubDiagnostic,\n+    AddSubdiagnostic, Diagnostic, DiagnosticArg, DiagnosticArgValue, DiagnosticId,\n+    DiagnosticStyledString, IntoDiagnosticArg, SubDiagnostic,\n };\n pub use diagnostic_builder::{DiagnosticBuilder, EmissionGuarantee};\n use std::backtrace::Backtrace;"}, {"sha": "c91125105d746a6c2431a892e49f29e307f116aa", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -511,7 +511,7 @@ pub fn parse_cfg<'a>(meta_item: &'a MetaItem, sess: &Session) -> Option<&'a Meta\n             err.span_suggestion(\n                 span,\n                 \"expected syntax is\",\n-                suggestion.into(),\n+                suggestion,\n                 Applicability::HasPlaceholders,\n             );\n         }"}, {"sha": "14555ad92559d2d89dfb340f9d94e460f7cad077", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -2198,7 +2198,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             err.span_suggestion(\n                 span.with_hi(before_close).shrink_to_hi(),\n                 msg,\n-                \",\".into(),\n+                \",\",\n                 Applicability::MachineApplicable,\n             );\n         } else {"}, {"sha": "dff2e31c6070c67bbe8478aeb9c81bff8f8d09f6", "filename": "compiler/rustc_lint/src/array_into_iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -129,7 +129,7 @@ impl<'tcx> LateLintPass<'tcx> for ArrayIntoIter {\n                 diag.span_suggestion(\n                     call.ident.span,\n                     \"use `.iter()` instead of `.into_iter()` to avoid ambiguity\",\n-                    \"iter\".into(),\n+                    \"iter\",\n                     Applicability::MachineApplicable,\n                 );\n                 if self.for_expr_span == expr.span {"}, {"sha": "d7cd5ec04f323a74dafce65c9cc9932b60a54f6c", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -738,7 +738,7 @@ pub trait LintContext: Sized {\n                     db.span_suggestion_verbose(\n                         span.shrink_to_hi(),\n                         \"insert whitespace here to avoid this being parsed as a prefix in Rust 2021\",\n-                        \" \".into(),\n+                        \" \",\n                         Applicability::MachineApplicable,\n                     );\n                 }"}, {"sha": "71769fceec1f2994c98bc6d9a478fc2e6cbc1b4c", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -176,7 +176,7 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n                 l.span_suggestion_verbose(\n                     arg_span.shrink_to_lo(),\n                     \"add a \\\"{}\\\" format string to Display the message\",\n-                    \"\\\"{}\\\", \".into(),\n+                    \"\\\"{}\\\", \",\n                     fmt_applicability,\n                 );\n             } else if suggest_debug {\n@@ -186,7 +186,7 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n                         \"add a \\\"{{:?}}\\\" format string to use the Debug implementation of `{}`\",\n                         ty,\n                     ),\n-                    \"\\\"{:?}\\\", \".into(),\n+                    \"\\\"{:?}\\\", \",\n                     fmt_applicability,\n                 );\n             }\n@@ -266,13 +266,13 @@ fn check_panic_str<'tcx>(\n                 l.span_suggestion(\n                     arg.span.shrink_to_hi(),\n                     &format!(\"add the missing argument{}\", pluralize!(n_arguments)),\n-                    \", ...\".into(),\n+                    \", ...\",\n                     Applicability::HasPlaceholders,\n                 );\n                 l.span_suggestion(\n                     arg.span.shrink_to_lo(),\n                     \"or add a \\\"{}\\\" format string to use the message literally\",\n-                    \"\\\"{}\\\", \".into(),\n+                    \"\\\"{}\\\", \",\n                     Applicability::MachineApplicable,\n                 );\n             }\n@@ -297,7 +297,7 @@ fn check_panic_str<'tcx>(\n                 l.span_suggestion(\n                     arg.span.shrink_to_lo(),\n                     \"add a \\\"{}\\\" format string to use the message literally\",\n-                    \"\\\"{}\\\", \".into(),\n+                    \"\\\"{}\\\", \",\n                     Applicability::MachineApplicable,\n                 );\n             }"}, {"sha": "f49166433faad545b45e4b7cdeb3f7850a371ed4", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "added", "additions": 586, "deletions": 0, "changes": 586, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -0,0 +1,586 @@\n+#![deny(unused_must_use)]\n+\n+use crate::diagnostics::error::{\n+    invalid_nested_attr, span_err, throw_invalid_attr, throw_invalid_nested_attr, throw_span_err,\n+    SessionDiagnosticDeriveError,\n+};\n+use crate::diagnostics::utils::{\n+    option_inner_ty, report_error_if_not_applied_to_span, type_matches_path, Applicability,\n+    FieldInfo, HasFieldMap, SetOnce,\n+};\n+use proc_macro2::TokenStream;\n+use quote::{format_ident, quote};\n+use std::collections::HashMap;\n+use std::str::FromStr;\n+use syn::{spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, Type};\n+use synstructure::Structure;\n+\n+/// The central struct for constructing the `into_diagnostic` method from an annotated struct.\n+pub(crate) struct SessionDiagnosticDerive<'a> {\n+    structure: Structure<'a>,\n+    builder: SessionDiagnosticDeriveBuilder,\n+}\n+\n+impl<'a> SessionDiagnosticDerive<'a> {\n+    pub(crate) fn new(diag: syn::Ident, sess: syn::Ident, structure: Structure<'a>) -> Self {\n+        // Build the mapping of field names to fields. This allows attributes to peek values from\n+        // other fields.\n+        let mut fields_map = HashMap::new();\n+\n+        // Convenience bindings.\n+        let ast = structure.ast();\n+\n+        if let syn::Data::Struct(syn::DataStruct { fields, .. }) = &ast.data {\n+            for field in fields.iter() {\n+                if let Some(ident) = &field.ident {\n+                    fields_map.insert(ident.to_string(), quote! { &self.#ident });\n+                }\n+            }\n+        }\n+\n+        Self {\n+            builder: SessionDiagnosticDeriveBuilder {\n+                diag,\n+                sess,\n+                fields: fields_map,\n+                kind: None,\n+                code: None,\n+                slug: None,\n+            },\n+            structure,\n+        }\n+    }\n+\n+    pub(crate) fn into_tokens(self) -> TokenStream {\n+        let SessionDiagnosticDerive { mut structure, mut builder } = self;\n+\n+        let ast = structure.ast();\n+        let attrs = &ast.attrs;\n+\n+        let (implementation, param_ty) = {\n+            if let syn::Data::Struct(..) = ast.data {\n+                let preamble = {\n+                    let preamble = attrs.iter().map(|attr| {\n+                        builder\n+                            .generate_structure_code(attr)\n+                            .unwrap_or_else(|v| v.to_compile_error())\n+                    });\n+\n+                    quote! {\n+                        #(#preamble)*;\n+                    }\n+                };\n+\n+                // Generates calls to `span_label` and similar functions based on the attributes\n+                // on fields. Code for suggestions uses formatting machinery and the value of\n+                // other fields - because any given field can be referenced multiple times, it\n+                // should be accessed through a borrow. When passing fields to `set_arg` (which\n+                // happens below) for Fluent, we want to move the data, so that has to happen\n+                // in a separate pass over the fields.\n+                let attrs = structure.each(|field_binding| {\n+                    let field = field_binding.ast();\n+                    let result = field.attrs.iter().map(|attr| {\n+                        builder\n+                            .generate_field_attr_code(\n+                                attr,\n+                                FieldInfo {\n+                                    vis: &field.vis,\n+                                    binding: field_binding,\n+                                    ty: &field.ty,\n+                                    span: &field.span(),\n+                                },\n+                            )\n+                            .unwrap_or_else(|v| v.to_compile_error())\n+                    });\n+\n+                    quote! { #(#result);* }\n+                });\n+\n+                // When generating `set_arg` calls, move data rather than borrow it to avoid\n+                // requiring clones - this must therefore be the last use of each field (for\n+                // example, any formatting machinery that might refer to a field should be\n+                // generated already).\n+                structure.bind_with(|_| synstructure::BindStyle::Move);\n+                let args = structure.each(|field_binding| {\n+                    let field = field_binding.ast();\n+                    // When a field has attributes like `#[label]` or `#[note]` then it doesn't\n+                    // need to be passed as an argument to the diagnostic. But when a field has no\n+                    // attributes then it must be passed as an argument to the diagnostic so that\n+                    // it can be referred to by Fluent messages.\n+                    if field.attrs.is_empty() {\n+                        let diag = &builder.diag;\n+                        let ident = field_binding.ast().ident.as_ref().unwrap();\n+                        quote! {\n+                            #diag.set_arg(\n+                                stringify!(#ident),\n+                                #field_binding.into_diagnostic_arg()\n+                            );\n+                        }\n+                    } else {\n+                        quote! {}\n+                    }\n+                });\n+\n+                let span = ast.span().unwrap();\n+                let (diag, sess) = (&builder.diag, &builder.sess);\n+                let init = match (builder.kind, builder.slug) {\n+                    (None, _) => {\n+                        span_err(span, \"diagnostic kind not specified\")\n+                            .help(\"use the `#[error(...)]` attribute to create an error\")\n+                            .emit();\n+                        return SessionDiagnosticDeriveError::ErrorHandled.to_compile_error();\n+                    }\n+                    (Some((kind, _)), None) => {\n+                        span_err(span, \"`slug` not specified\")\n+                            .help(&format!(\"use the `#[{}(slug = \\\"...\\\")]` attribute to set this diagnostic's slug\", kind.descr()))\n+                            .emit();\n+                        return SessionDiagnosticDeriveError::ErrorHandled.to_compile_error();\n+                    }\n+                    (Some((SessionDiagnosticKind::Error, _)), Some((slug, _))) => {\n+                        quote! {\n+                            let mut #diag = #sess.struct_err(\n+                                rustc_errors::DiagnosticMessage::fluent(#slug),\n+                            );\n+                        }\n+                    }\n+                    (Some((SessionDiagnosticKind::Warn, _)), Some((slug, _))) => {\n+                        quote! {\n+                            let mut #diag = #sess.struct_warn(\n+                                rustc_errors::DiagnosticMessage::fluent(#slug),\n+                            );\n+                        }\n+                    }\n+                };\n+\n+                let implementation = quote! {\n+                    #init\n+                    #preamble\n+                    match self {\n+                        #attrs\n+                    }\n+                    match self {\n+                        #args\n+                    }\n+                    #diag\n+                };\n+                let param_ty = match builder.kind {\n+                    Some((SessionDiagnosticKind::Error, _)) => {\n+                        quote! { rustc_errors::ErrorGuaranteed }\n+                    }\n+                    Some((SessionDiagnosticKind::Warn, _)) => quote! { () },\n+                    _ => unreachable!(),\n+                };\n+\n+                (implementation, param_ty)\n+            } else {\n+                span_err(\n+                    ast.span().unwrap(),\n+                    \"`#[derive(SessionDiagnostic)]` can only be used on structs\",\n+                )\n+                .emit();\n+\n+                let implementation = SessionDiagnosticDeriveError::ErrorHandled.to_compile_error();\n+                let param_ty = quote! { rustc_errors::ErrorGuaranteed };\n+                (implementation, param_ty)\n+            }\n+        };\n+\n+        let sess = &builder.sess;\n+        structure.gen_impl(quote! {\n+            gen impl<'__session_diagnostic_sess> rustc_session::SessionDiagnostic<'__session_diagnostic_sess, #param_ty>\n+                    for @Self\n+            {\n+                fn into_diagnostic(\n+                    self,\n+                    #sess: &'__session_diagnostic_sess rustc_session::parse::ParseSess\n+                ) -> rustc_errors::DiagnosticBuilder<'__session_diagnostic_sess, #param_ty> {\n+                    use rustc_errors::IntoDiagnosticArg;\n+                    #implementation\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+/// What kind of session diagnostic is being derived - an error or a warning?\n+#[derive(Copy, Clone)]\n+enum SessionDiagnosticKind {\n+    /// `#[error(..)]`\n+    Error,\n+    /// `#[warn(..)]`\n+    Warn,\n+}\n+\n+impl SessionDiagnosticKind {\n+    /// Returns human-readable string corresponding to the kind.\n+    fn descr(&self) -> &'static str {\n+        match self {\n+            SessionDiagnosticKind::Error => \"error\",\n+            SessionDiagnosticKind::Warn => \"warning\",\n+        }\n+    }\n+}\n+\n+/// Tracks persistent information required for building up the individual calls to diagnostic\n+/// methods for the final generated method. This is a separate struct to `SessionDiagnosticDerive`\n+/// only to be able to destructure and split `self.builder` and the `self.structure` up to avoid a\n+/// double mut borrow later on.\n+struct SessionDiagnosticDeriveBuilder {\n+    /// Name of the session parameter that's passed in to the `as_error` method.\n+    sess: syn::Ident,\n+    /// The identifier to use for the generated `DiagnosticBuilder` instance.\n+    diag: syn::Ident,\n+\n+    /// Store a map of field name to its corresponding field. This is built on construction of the\n+    /// derive builder.\n+    fields: HashMap<String, TokenStream>,\n+\n+    /// Kind of diagnostic requested via the struct attribute.\n+    kind: Option<(SessionDiagnosticKind, proc_macro::Span)>,\n+    /// Slug is a mandatory part of the struct attribute as corresponds to the Fluent message that\n+    /// has the actual diagnostic message.\n+    slug: Option<(String, proc_macro::Span)>,\n+    /// Error codes are a optional part of the struct attribute - this is only set to detect\n+    /// multiple specifications.\n+    code: Option<(String, proc_macro::Span)>,\n+}\n+\n+impl HasFieldMap for SessionDiagnosticDeriveBuilder {\n+    fn get_field_binding(&self, field: &String) -> Option<&TokenStream> {\n+        self.fields.get(field)\n+    }\n+}\n+\n+impl SessionDiagnosticDeriveBuilder {\n+    /// Establishes state in the `SessionDiagnosticDeriveBuilder` resulting from the struct\n+    /// attributes like `#[error(..)#`, such as the diagnostic kind and slug. Generates\n+    /// diagnostic builder calls for setting error code and creating note/help messages.\n+    fn generate_structure_code(\n+        &mut self,\n+        attr: &Attribute,\n+    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n+        let span = attr.span().unwrap();\n+\n+        let name = attr.path.segments.last().unwrap().ident.to_string();\n+        let name = name.as_str();\n+        let meta = attr.parse_meta()?;\n+\n+        if matches!(name, \"help\" | \"note\") && matches!(meta, Meta::Path(_) | Meta::NameValue(_)) {\n+            let diag = &self.diag;\n+            let slug = match &self.slug {\n+                Some((slug, _)) => slug.as_str(),\n+                None => throw_span_err!(\n+                    span,\n+                    &format!(\n+                        \"`#[{}{}]` must come after `#[error(..)]` or `#[warn(..)]`\",\n+                        name,\n+                        match meta {\n+                            Meta::Path(_) => \"\",\n+                            Meta::NameValue(_) => \" = ...\",\n+                            _ => unreachable!(),\n+                        }\n+                    )\n+                ),\n+            };\n+            let id = match meta {\n+                Meta::Path(..) => quote! { #name },\n+                Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n+                    quote! { #s }\n+                }\n+                _ => unreachable!(),\n+            };\n+            let fn_name = proc_macro2::Ident::new(name, attr.span());\n+\n+            return Ok(quote! {\n+                #diag.#fn_name(rustc_errors::DiagnosticMessage::fluent_attr(#slug, #id));\n+            });\n+        }\n+\n+        let nested = match meta {\n+            Meta::List(MetaList { ref nested, .. }) => nested,\n+            _ => throw_invalid_attr!(attr, &meta),\n+        };\n+\n+        let kind = match name {\n+            \"error\" => SessionDiagnosticKind::Error,\n+            \"warning\" => SessionDiagnosticKind::Warn,\n+            _ => throw_invalid_attr!(attr, &meta, |diag| {\n+                diag.help(\"only `error` and `warning` are valid attributes\")\n+            }),\n+        };\n+        self.kind.set_once((kind, span));\n+\n+        let mut tokens = Vec::new();\n+        for nested_attr in nested {\n+            let meta = match nested_attr {\n+                syn::NestedMeta::Meta(meta) => meta,\n+                _ => throw_invalid_nested_attr!(attr, &nested_attr),\n+            };\n+\n+            let path = meta.path();\n+            let nested_name = path.segments.last().unwrap().ident.to_string();\n+            match &meta {\n+                // Struct attributes are only allowed to be applied once, and the diagnostic\n+                // changes will be set in the initialisation code.\n+                Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n+                    let span = s.span().unwrap();\n+                    match nested_name.as_str() {\n+                        \"slug\" => {\n+                            self.slug.set_once((s.value(), span));\n+                        }\n+                        \"code\" => {\n+                            self.code.set_once((s.value(), span));\n+                            let (diag, code) = (&self.diag, &self.code.as_ref().map(|(v, _)| v));\n+                            tokens.push(quote! {\n+                                #diag.code(rustc_errors::DiagnosticId::Error(#code.to_string()));\n+                            });\n+                        }\n+                        _ => invalid_nested_attr(attr, &nested_attr)\n+                            .help(\"only `slug` and `code` are valid nested attributes\")\n+                            .emit(),\n+                    }\n+                }\n+                _ => invalid_nested_attr(attr, &nested_attr).emit(),\n+            }\n+        }\n+\n+        Ok(tokens.drain(..).collect())\n+    }\n+\n+    fn generate_field_attr_code(\n+        &mut self,\n+        attr: &syn::Attribute,\n+        info: FieldInfo<'_>,\n+    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n+        let field_binding = &info.binding.binding;\n+        let option_ty = option_inner_ty(&info.ty);\n+        let generated_code = self.generate_non_option_field_code(\n+            attr,\n+            FieldInfo {\n+                vis: info.vis,\n+                binding: info.binding,\n+                ty: option_ty.unwrap_or(&info.ty),\n+                span: info.span,\n+            },\n+        )?;\n+\n+        if option_ty.is_none() {\n+            Ok(quote! { #generated_code })\n+        } else {\n+            Ok(quote! {\n+                if let Some(#field_binding) = #field_binding {\n+                    #generated_code\n+                }\n+            })\n+        }\n+    }\n+\n+    fn generate_non_option_field_code(\n+        &mut self,\n+        attr: &Attribute,\n+        info: FieldInfo<'_>,\n+    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n+        let diag = &self.diag;\n+        let field_binding = &info.binding.binding;\n+\n+        let name = attr.path.segments.last().unwrap().ident.to_string();\n+        let name = name.as_str();\n+\n+        let meta = attr.parse_meta()?;\n+        match meta {\n+            Meta::Path(_) => match name {\n+                \"skip_arg\" => {\n+                    // Don't need to do anything - by virtue of the attribute existing, the\n+                    // `set_arg` call will not be generated.\n+                    Ok(quote! {})\n+                }\n+                \"primary_span\" => {\n+                    report_error_if_not_applied_to_span(attr, &info)?;\n+                    Ok(quote! {\n+                        #diag.set_span(*#field_binding);\n+                    })\n+                }\n+                \"label\" | \"note\" | \"help\" => {\n+                    report_error_if_not_applied_to_span(attr, &info)?;\n+                    Ok(self.add_subdiagnostic(field_binding, name, name))\n+                }\n+                \"subdiagnostic\" => Ok(quote! { #diag.subdiagnostic(*#field_binding); }),\n+                _ => throw_invalid_attr!(attr, &meta, |diag| {\n+                    diag\n+                        .help(\"only `skip_arg`, `primary_span`, `label`, `note`, `help` and `subdiagnostic` are valid field attributes\")\n+                }),\n+            },\n+            Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(ref s), .. }) => match name {\n+                \"label\" | \"note\" | \"help\" => {\n+                    report_error_if_not_applied_to_span(attr, &info)?;\n+                    Ok(self.add_subdiagnostic(field_binding, name, &s.value()))\n+                }\n+                _ => throw_invalid_attr!(attr, &meta, |diag| {\n+                    diag.help(\"only `label`, `note` and `help` are valid field attributes\")\n+                }),\n+            },\n+            Meta::List(MetaList { ref path, ref nested, .. }) => {\n+                let name = path.segments.last().unwrap().ident.to_string();\n+                let name = name.as_ref();\n+\n+                match name {\n+                    \"suggestion\" | \"suggestion_short\" | \"suggestion_hidden\"\n+                    | \"suggestion_verbose\" => (),\n+                    _ => throw_invalid_attr!(attr, &meta, |diag| {\n+                        diag\n+                            .help(\"only `suggestion{,_short,_hidden,_verbose}` are valid field attributes\")\n+                    }),\n+                };\n+\n+                let (span_field, mut applicability) = self.span_and_applicability_of_ty(info)?;\n+\n+                let mut msg = None;\n+                let mut code = None;\n+\n+                for nested_attr in nested {\n+                    let meta = match nested_attr {\n+                        syn::NestedMeta::Meta(ref meta) => meta,\n+                        syn::NestedMeta::Lit(_) => throw_invalid_nested_attr!(attr, &nested_attr),\n+                    };\n+\n+                    let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n+                    let nested_name = nested_name.as_str();\n+                    match meta {\n+                        Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n+                            let span = meta.span().unwrap();\n+                            match nested_name {\n+                                \"message\" => {\n+                                    msg = Some(s.value());\n+                                }\n+                                \"code\" => {\n+                                    let formatted_str = self.build_format(&s.value(), s.span());\n+                                    code = Some(formatted_str);\n+                                }\n+                                \"applicability\" => {\n+                                    applicability = match applicability {\n+                                        Some(v) => {\n+                                            span_err(\n+                                                span,\n+                                                \"applicability cannot be set in both the field and attribute\"\n+                                            ).emit();\n+                                            Some(v)\n+                                        }\n+                                        None => match Applicability::from_str(&s.value()) {\n+                                            Ok(v) => Some(quote! { #v }),\n+                                            Err(()) => {\n+                                                span_err(span, \"invalid applicability\").emit();\n+                                                None\n+                                            }\n+                                        },\n+                                    }\n+                                }\n+                                _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                                    diag.help(\n+                                        \"only `message`, `code` and `applicability` are valid field attributes\",\n+                                    )\n+                                }),\n+                            }\n+                        }\n+                        _ => throw_invalid_nested_attr!(attr, &nested_attr),\n+                    }\n+                }\n+\n+                let applicability = applicability\n+                    .unwrap_or_else(|| quote!(rustc_errors::Applicability::Unspecified));\n+\n+                let method = format_ident!(\"span_{}\", name);\n+\n+                let slug = self\n+                    .slug\n+                    .as_ref()\n+                    .map(|(slug, _)| slug.as_str())\n+                    .unwrap_or_else(|| \"missing-slug\");\n+                let msg = msg.as_deref().unwrap_or(\"suggestion\");\n+                let msg = quote! { rustc_errors::DiagnosticMessage::fluent_attr(#slug, #msg) };\n+                let code = code.unwrap_or_else(|| quote! { String::new() });\n+\n+                Ok(quote! { #diag.#method(#span_field, #msg, #code, #applicability); })\n+            }\n+            _ => throw_invalid_attr!(attr, &meta),\n+        }\n+    }\n+\n+    /// Adds a subdiagnostic by generating a `diag.span_$kind` call with the current slug and\n+    /// `fluent_attr_identifier`.\n+    fn add_subdiagnostic(\n+        &self,\n+        field_binding: &proc_macro2::Ident,\n+        kind: &str,\n+        fluent_attr_identifier: &str,\n+    ) -> TokenStream {\n+        let diag = &self.diag;\n+\n+        let slug =\n+            self.slug.as_ref().map(|(slug, _)| slug.as_str()).unwrap_or_else(|| \"missing-slug\");\n+        let fn_name = format_ident!(\"span_{}\", kind);\n+        quote! {\n+            #diag.#fn_name(\n+                *#field_binding,\n+                rustc_errors::DiagnosticMessage::fluent_attr(#slug, #fluent_attr_identifier)\n+            );\n+        }\n+    }\n+\n+    fn span_and_applicability_of_ty(\n+        &self,\n+        info: FieldInfo<'_>,\n+    ) -> Result<(TokenStream, Option<TokenStream>), SessionDiagnosticDeriveError> {\n+        match &info.ty {\n+            // If `ty` is `Span` w/out applicability, then use `Applicability::Unspecified`.\n+            ty @ Type::Path(..) if type_matches_path(ty, &[\"rustc_span\", \"Span\"]) => {\n+                let binding = &info.binding.binding;\n+                Ok((quote!(*#binding), None))\n+            }\n+            // If `ty` is `(Span, Applicability)` then return tokens accessing those.\n+            Type::Tuple(tup) => {\n+                let mut span_idx = None;\n+                let mut applicability_idx = None;\n+\n+                for (idx, elem) in tup.elems.iter().enumerate() {\n+                    if type_matches_path(elem, &[\"rustc_span\", \"Span\"]) {\n+                        if span_idx.is_none() {\n+                            span_idx = Some(syn::Index::from(idx));\n+                        } else {\n+                            throw_span_err!(\n+                                info.span.unwrap(),\n+                                \"type of field annotated with `#[suggestion(...)]` contains more than one `Span`\"\n+                            );\n+                        }\n+                    } else if type_matches_path(elem, &[\"rustc_errors\", \"Applicability\"]) {\n+                        if applicability_idx.is_none() {\n+                            applicability_idx = Some(syn::Index::from(idx));\n+                        } else {\n+                            throw_span_err!(\n+                                info.span.unwrap(),\n+                                \"type of field annotated with `#[suggestion(...)]` contains more than one Applicability\"\n+                            );\n+                        }\n+                    }\n+                }\n+\n+                if let Some(span_idx) = span_idx {\n+                    let binding = &info.binding.binding;\n+                    let span = quote!(#binding.#span_idx);\n+                    let applicability = applicability_idx\n+                        .map(|applicability_idx| quote!(#binding.#applicability_idx))\n+                        .unwrap_or_else(|| quote!(rustc_errors::Applicability::Unspecified));\n+\n+                    return Ok((span, Some(applicability)));\n+                }\n+\n+                throw_span_err!(info.span.unwrap(), \"wrong types for suggestion\", |diag| {\n+                    diag.help(\"`#[suggestion(...)]` on a tuple field must be applied to fields of type `(Span, Applicability)`\")\n+                });\n+            }\n+            // If `ty` isn't a `Span` or `(Span, Applicability)` then emit an error.\n+            _ => throw_span_err!(info.span.unwrap(), \"wrong field type for suggestion\", |diag| {\n+                diag.help(\"`#[suggestion(...)]` should be applied to fields of type `Span` or `(Span, Applicability)`\")\n+            }),\n+        }\n+    }\n+}"}, {"sha": "fd1dc2f307397f1bcd220a7a67f7349781b08d84", "filename": "compiler/rustc_macros/src/diagnostics/error.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -0,0 +1,132 @@\n+use proc_macro::{Diagnostic, Level, MultiSpan};\n+use proc_macro2::TokenStream;\n+use quote::quote;\n+use syn::{spanned::Spanned, Attribute, Error as SynError, Meta, NestedMeta};\n+\n+#[derive(Debug)]\n+pub(crate) enum SessionDiagnosticDeriveError {\n+    SynError(SynError),\n+    ErrorHandled,\n+}\n+\n+impl SessionDiagnosticDeriveError {\n+    pub(crate) fn to_compile_error(self) -> TokenStream {\n+        match self {\n+            SessionDiagnosticDeriveError::SynError(e) => e.to_compile_error(),\n+            SessionDiagnosticDeriveError::ErrorHandled => {\n+                // Return ! to avoid having to create a blank DiagnosticBuilder to return when an\n+                // error has already been emitted to the compiler.\n+                quote! {\n+                    { unreachable!(); }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl From<SynError> for SessionDiagnosticDeriveError {\n+    fn from(e: SynError) -> Self {\n+        SessionDiagnosticDeriveError::SynError(e)\n+    }\n+}\n+\n+/// Helper function for use with `throw_*` macros - constraints `$f` to an `impl FnOnce`.\n+pub(crate) fn _throw_err(\n+    diag: Diagnostic,\n+    f: impl FnOnce(Diagnostic) -> Diagnostic,\n+) -> SessionDiagnosticDeriveError {\n+    f(diag).emit();\n+    SessionDiagnosticDeriveError::ErrorHandled\n+}\n+\n+/// Returns an error diagnostic on span `span` with msg `msg`.\n+pub(crate) fn span_err(span: impl MultiSpan, msg: &str) -> Diagnostic {\n+    Diagnostic::spanned(span, Level::Error, msg)\n+}\n+\n+/// Emit a diagnostic on span `$span` with msg `$msg` (optionally performing additional decoration\n+/// using the `FnOnce` passed in `diag`) and return `Err(ErrorHandled)`.\n+///\n+/// For methods that return a `Result<_, SessionDiagnosticDeriveError>`:\n+macro_rules! throw_span_err {\n+    ($span:expr, $msg:expr) => {{ throw_span_err!($span, $msg, |diag| diag) }};\n+    ($span:expr, $msg:expr, $f:expr) => {{\n+        let diag = span_err($span, $msg);\n+        return Err(crate::diagnostics::error::_throw_err(diag, $f));\n+    }};\n+}\n+\n+pub(crate) use throw_span_err;\n+\n+/// Returns an error diagnostic for an invalid attribute.\n+pub(crate) fn invalid_attr(attr: &Attribute, meta: &Meta) -> Diagnostic {\n+    let span = attr.span().unwrap();\n+    let name = attr.path.segments.last().unwrap().ident.to_string();\n+    let name = name.as_str();\n+\n+    match meta {\n+        Meta::Path(_) => span_err(span, &format!(\"`#[{}]` is not a valid attribute\", name)),\n+        Meta::NameValue(_) => {\n+            span_err(span, &format!(\"`#[{} = ...]` is not a valid attribute\", name))\n+        }\n+        Meta::List(_) => span_err(span, &format!(\"`#[{}(...)]` is not a valid attribute\", name)),\n+    }\n+}\n+\n+/// Emit a error diagnostic for an invalid attribute (optionally performing additional decoration\n+/// using the `FnOnce` passed in `diag`) and return `Err(ErrorHandled)`.\n+///\n+/// For methods that return a `Result<_, SessionDiagnosticDeriveError>`:\n+macro_rules! throw_invalid_attr {\n+    ($attr:expr, $meta:expr) => {{ throw_invalid_attr!($attr, $meta, |diag| diag) }};\n+    ($attr:expr, $meta:expr, $f:expr) => {{\n+        let diag = crate::diagnostics::error::invalid_attr($attr, $meta);\n+        return Err(crate::diagnostics::error::_throw_err(diag, $f));\n+    }};\n+}\n+\n+pub(crate) use throw_invalid_attr;\n+\n+/// Returns an error diagnostic for an invalid nested attribute.\n+pub(crate) fn invalid_nested_attr(attr: &Attribute, nested: &NestedMeta) -> Diagnostic {\n+    let name = attr.path.segments.last().unwrap().ident.to_string();\n+    let name = name.as_str();\n+\n+    let span = nested.span().unwrap();\n+    let meta = match nested {\n+        syn::NestedMeta::Meta(meta) => meta,\n+        syn::NestedMeta::Lit(_) => {\n+            return span_err(span, &format!(\"`#[{}(\\\"...\\\")]` is not a valid attribute\", name));\n+        }\n+    };\n+\n+    let span = meta.span().unwrap();\n+    let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n+    let nested_name = nested_name.as_str();\n+    match meta {\n+        Meta::NameValue(..) => span_err(\n+            span,\n+            &format!(\"`#[{}({} = ...)]` is not a valid attribute\", name, nested_name),\n+        ),\n+        Meta::Path(..) => {\n+            span_err(span, &format!(\"`#[{}({})]` is not a valid attribute\", name, nested_name))\n+        }\n+        Meta::List(..) => {\n+            span_err(span, &format!(\"`#[{}({}(...))]` is not a valid attribute\", name, nested_name))\n+        }\n+    }\n+}\n+\n+/// Emit a error diagnostic for an invalid nested attribute (optionally performing additional\n+/// decoration using the `FnOnce` passed in `diag`) and return `Err(ErrorHandled)`.\n+///\n+/// For methods that return a `Result<_, SessionDiagnosticDeriveError>`:\n+macro_rules! throw_invalid_nested_attr {\n+    ($attr:expr, $nested_attr:expr) => {{ throw_invalid_nested_attr!($attr, $nested_attr, |diag| diag) }};\n+    ($attr:expr, $nested_attr:expr, $f:expr) => {{\n+        let diag = crate::diagnostics::error::invalid_nested_attr($attr, $nested_attr);\n+        return Err(crate::diagnostics::error::_throw_err(diag, $f));\n+    }};\n+}\n+\n+pub(crate) use throw_invalid_nested_attr;"}, {"sha": "73ad415d6c355b6442cd62158e44f00b92526ee3", "filename": "compiler/rustc_macros/src/diagnostics/mod.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -0,0 +1,114 @@\n+mod diagnostic;\n+mod error;\n+mod subdiagnostic;\n+mod utils;\n+\n+use diagnostic::SessionDiagnosticDerive;\n+use proc_macro2::TokenStream;\n+use quote::format_ident;\n+use subdiagnostic::SessionSubdiagnosticDerive;\n+use synstructure::Structure;\n+\n+/// Implements `#[derive(SessionDiagnostic)]`, which allows for errors to be specified as a struct,\n+/// independent from the actual diagnostics emitting code.\n+///\n+/// ```ignore (pseudo-rust)\n+/// # extern crate rustc_errors;\n+/// # use rustc_errors::Applicability;\n+/// # extern crate rustc_span;\n+/// # use rustc_span::{symbol::Ident, Span};\n+/// # extern crate rust_middle;\n+/// # use rustc_middle::ty::Ty;\n+/// #[derive(SessionDiagnostic)]\n+/// #[error(code = \"E0505\", slug = \"borrowck-move-out-of-borrow\")]\n+/// pub struct MoveOutOfBorrowError<'tcx> {\n+///     pub name: Ident,\n+///     pub ty: Ty<'tcx>,\n+///     #[primary_span]\n+///     #[label]\n+///     pub span: Span,\n+///     #[label = \"first-borrow-label\"]\n+///     pub first_borrow_span: Span,\n+///     #[suggestion(code = \"{name}.clone()\")]\n+///     pub clone_sugg: Option<(Span, Applicability)>\n+/// }\n+/// ```\n+///\n+/// ```fluent\n+/// move-out-of-borrow = cannot move out of {$name} because it is borrowed\n+///     .label = cannot move out of borrow\n+///     .first-borrow-label = `{$ty}` first borrowed here\n+///     .suggestion = consider cloning here\n+/// ```\n+///\n+/// Then, later, to emit the error:\n+///\n+/// ```ignore (pseudo-rust)\n+/// sess.emit_err(MoveOutOfBorrowError {\n+///     expected,\n+///     actual,\n+///     span,\n+///     first_borrow_span,\n+///     clone_sugg: Some(suggestion, Applicability::MachineApplicable),\n+/// });\n+/// ```\n+///\n+/// See rustc dev guide for more examples on using the `#[derive(SessionDiagnostic)]`:\n+/// <https://rustc-dev-guide.rust-lang.org/diagnostics/sessiondiagnostic.html>\n+pub fn session_diagnostic_derive(s: Structure<'_>) -> TokenStream {\n+    // Names for the diagnostic we build and the session we build it from.\n+    let diag = format_ident!(\"diag\");\n+    let sess = format_ident!(\"sess\");\n+\n+    SessionDiagnosticDerive::new(diag, sess, s).into_tokens()\n+}\n+\n+/// Implements `#[derive(SessionSubdiagnostic)]`, which allows for labels, notes, helps and\n+/// suggestions to be specified as a structs or enums, independent from the actual diagnostics\n+/// emitting code or diagnostic derives.\n+///\n+/// ```ignore (pseudo-rust)\n+/// #[derive(SessionSubdiagnostic)]\n+/// pub enum ExpectedIdentifierLabel<'tcx> {\n+///     #[label(slug = \"parser-expected-identifier\")]\n+///     WithoutFound {\n+///         #[primary_span]\n+///         span: Span,\n+///     }\n+///     #[label(slug = \"parser-expected-identifier-found\")]\n+///     WithFound {\n+///         #[primary_span]\n+///         span: Span,\n+///         found: String,\n+///     }\n+/// }\n+///\n+/// #[derive(SessionSubdiagnostic)]\n+/// #[suggestion_verbose(slug = \"parser-raw-identifier\")]\n+/// pub struct RawIdentifierSuggestion<'tcx> {\n+///     #[primary_span]\n+///     span: Span,\n+///     #[applicability]\n+///     applicability: Applicability,\n+///     ident: Ident,\n+/// }\n+/// ```\n+///\n+/// ```fluent\n+/// parser-expected-identifier = expected identifier\n+///\n+/// parser-expected-identifier-found = expected identifier, found {$found}\n+///\n+/// parser-raw-identifier = escape `{$ident}` to use it as an identifier\n+/// ```\n+///\n+/// Then, later, to add the subdiagnostic:\n+///\n+/// ```ignore (pseudo-rust)\n+/// diag.subdiagnostic(ExpectedIdentifierLabel::WithoutFound { span });\n+///\n+/// diag.subdiagnostic(RawIdentifierSuggestion { span, applicability, ident });\n+/// ```\n+pub fn session_subdiagnostic_derive(s: Structure<'_>) -> TokenStream {\n+    SessionSubdiagnosticDerive::new(s).into_tokens()\n+}"}, {"sha": "961b42f424fd138778e155d98181fade0bcf1388", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "added", "additions": 437, "deletions": 0, "changes": 437, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -0,0 +1,437 @@\n+#![deny(unused_must_use)]\n+\n+use crate::diagnostics::error::{\n+    span_err, throw_invalid_attr, throw_invalid_nested_attr, throw_span_err,\n+    SessionDiagnosticDeriveError,\n+};\n+use crate::diagnostics::utils::{\n+    option_inner_ty, report_error_if_not_applied_to_applicability,\n+    report_error_if_not_applied_to_span, Applicability, FieldInfo, HasFieldMap, SetOnce,\n+};\n+use proc_macro2::TokenStream;\n+use quote::{format_ident, quote};\n+use std::collections::HashMap;\n+use std::fmt;\n+use std::str::FromStr;\n+use syn::{spanned::Spanned, Meta, MetaList, MetaNameValue};\n+use synstructure::{BindingInfo, Structure, VariantInfo};\n+\n+/// Which kind of suggestion is being created?\n+#[derive(Clone, Copy)]\n+enum SubdiagnosticSuggestionKind {\n+    /// `#[suggestion]`\n+    Normal,\n+    /// `#[suggestion_short]`\n+    Short,\n+    /// `#[suggestion_hidden]`\n+    Hidden,\n+    /// `#[suggestion_verbose]`\n+    Verbose,\n+}\n+\n+/// Which kind of subdiagnostic is being created from a variant?\n+#[derive(Clone, Copy)]\n+enum SubdiagnosticKind {\n+    /// `#[label(...)]`\n+    Label,\n+    /// `#[note(...)]`\n+    Note,\n+    /// `#[help(...)]`\n+    Help,\n+    /// `#[suggestion{,_short,_hidden,_verbose}]`\n+    Suggestion(SubdiagnosticSuggestionKind),\n+}\n+\n+impl FromStr for SubdiagnosticKind {\n+    type Err = ();\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        match s {\n+            \"label\" => Ok(SubdiagnosticKind::Label),\n+            \"note\" => Ok(SubdiagnosticKind::Note),\n+            \"help\" => Ok(SubdiagnosticKind::Help),\n+            \"suggestion\" => Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Normal)),\n+            \"suggestion_short\" => {\n+                Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Short))\n+            }\n+            \"suggestion_hidden\" => {\n+                Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Hidden))\n+            }\n+            \"suggestion_verbose\" => {\n+                Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Verbose))\n+            }\n+            _ => Err(()),\n+        }\n+    }\n+}\n+\n+impl quote::IdentFragment for SubdiagnosticKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            SubdiagnosticKind::Label => write!(f, \"label\"),\n+            SubdiagnosticKind::Note => write!(f, \"note\"),\n+            SubdiagnosticKind::Help => write!(f, \"help\"),\n+            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Normal) => {\n+                write!(f, \"suggestion\")\n+            }\n+            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Short) => {\n+                write!(f, \"suggestion_short\")\n+            }\n+            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Hidden) => {\n+                write!(f, \"suggestion_hidden\")\n+            }\n+            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Verbose) => {\n+                write!(f, \"suggestion_verbose\")\n+            }\n+        }\n+    }\n+\n+    fn span(&self) -> Option<proc_macro2::Span> {\n+        None\n+    }\n+}\n+\n+/// The central struct for constructing the `add_to_diagnostic` method from an annotated struct.\n+pub(crate) struct SessionSubdiagnosticDerive<'a> {\n+    structure: Structure<'a>,\n+    diag: syn::Ident,\n+}\n+\n+impl<'a> SessionSubdiagnosticDerive<'a> {\n+    pub(crate) fn new(structure: Structure<'a>) -> Self {\n+        let diag = format_ident!(\"diag\");\n+        Self { structure, diag }\n+    }\n+\n+    pub(crate) fn into_tokens(self) -> TokenStream {\n+        let SessionSubdiagnosticDerive { mut structure, diag } = self;\n+        let implementation = {\n+            let ast = structure.ast();\n+            let span = ast.span().unwrap();\n+            match ast.data {\n+                syn::Data::Struct(..) | syn::Data::Enum(..) => (),\n+                syn::Data::Union(..) => {\n+                    span_err(\n+                        span,\n+                        \"`#[derive(SessionSubdiagnostic)]` can only be used on structs and enums\",\n+                    );\n+                }\n+            }\n+\n+            if matches!(ast.data, syn::Data::Enum(..)) {\n+                for attr in &ast.attrs {\n+                    span_err(\n+                        attr.span().unwrap(),\n+                        \"unsupported type attribute for subdiagnostic enum\",\n+                    )\n+                    .emit();\n+                }\n+            }\n+\n+            structure.bind_with(|_| synstructure::BindStyle::Move);\n+            let variants_ = structure.each_variant(|variant| {\n+                // Build the mapping of field names to fields. This allows attributes to peek\n+                // values from other fields.\n+                let mut fields_map = HashMap::new();\n+                for binding in variant.bindings() {\n+                    let field = binding.ast();\n+                    if let Some(ident) = &field.ident {\n+                        fields_map.insert(ident.to_string(), quote! { #binding });\n+                    }\n+                }\n+\n+                let mut builder = SessionSubdiagnosticDeriveBuilder {\n+                    diag: &diag,\n+                    variant,\n+                    span,\n+                    fields: fields_map,\n+                    kind: None,\n+                    slug: None,\n+                    code: None,\n+                    span_field: None,\n+                    applicability: None,\n+                };\n+                builder.into_tokens().unwrap_or_else(|v| v.to_compile_error())\n+            });\n+\n+            quote! {\n+                match self {\n+                    #variants_\n+                }\n+            }\n+        };\n+\n+        let ret = structure.gen_impl(quote! {\n+            gen impl rustc_errors::AddSubdiagnostic for @Self {\n+                fn add_to_diagnostic(self, #diag: &mut rustc_errors::Diagnostic) {\n+                    use rustc_errors::{Applicability, IntoDiagnosticArg};\n+                    #implementation\n+                }\n+            }\n+        });\n+        ret\n+    }\n+}\n+\n+/// Tracks persistent information required for building up the call to add to the diagnostic\n+/// for the final generated method. This is a separate struct to `SessionSubdiagnosticDerive`\n+/// only to be able to destructure and split `self.builder` and the `self.structure` up to avoid a\n+/// double mut borrow later on.\n+struct SessionSubdiagnosticDeriveBuilder<'a> {\n+    /// The identifier to use for the generated `DiagnosticBuilder` instance.\n+    diag: &'a syn::Ident,\n+\n+    /// Info for the current variant (or the type if not an enum).\n+    variant: &'a VariantInfo<'a>,\n+    /// Span for the entire type.\n+    span: proc_macro::Span,\n+\n+    /// Store a map of field name to its corresponding field. This is built on construction of the\n+    /// derive builder.\n+    fields: HashMap<String, TokenStream>,\n+\n+    /// Subdiagnostic kind of the type/variant.\n+    kind: Option<(SubdiagnosticKind, proc_macro::Span)>,\n+\n+    /// Slug of the subdiagnostic - corresponds to the Fluent identifier for the message - from the\n+    /// `#[kind(slug = \"...\")]` attribute on the type or variant.\n+    slug: Option<(String, proc_macro::Span)>,\n+    /// If a suggestion, the code to suggest as a replacement - from the `#[kind(code = \"...\")]`\n+    /// attribute on the type or variant.\n+    code: Option<(TokenStream, proc_macro::Span)>,\n+\n+    /// Identifier for the binding to the `#[primary_span]` field.\n+    span_field: Option<(proc_macro2::Ident, proc_macro::Span)>,\n+    /// If a suggestion, the identifier for the binding to the `#[applicability]` field or a\n+    /// `rustc_errors::Applicability::*` variant directly.\n+    applicability: Option<(TokenStream, proc_macro::Span)>,\n+}\n+\n+impl<'a> HasFieldMap for SessionSubdiagnosticDeriveBuilder<'a> {\n+    fn get_field_binding(&self, field: &String) -> Option<&TokenStream> {\n+        self.fields.get(field)\n+    }\n+}\n+\n+impl<'a> SessionSubdiagnosticDeriveBuilder<'a> {\n+    fn identify_kind(&mut self) -> Result<(), SessionDiagnosticDeriveError> {\n+        for attr in self.variant.ast().attrs {\n+            let span = attr.span().unwrap();\n+\n+            let name = attr.path.segments.last().unwrap().ident.to_string();\n+            let name = name.as_str();\n+\n+            let meta = attr.parse_meta()?;\n+            let kind = match meta {\n+                Meta::List(MetaList { ref nested, .. }) => {\n+                    for nested_attr in nested {\n+                        let meta = match nested_attr {\n+                            syn::NestedMeta::Meta(ref meta) => meta,\n+                            _ => throw_invalid_nested_attr!(attr, &nested_attr),\n+                        };\n+\n+                        let span = meta.span().unwrap();\n+                        let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n+                        let nested_name = nested_name.as_str();\n+\n+                        match meta {\n+                            Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n+                                match nested_name {\n+                                    \"code\" => {\n+                                        let formatted_str = self.build_format(&s.value(), s.span());\n+                                        self.code.set_once((formatted_str, span));\n+                                    }\n+                                    \"slug\" => self.slug.set_once((s.value(), span)),\n+                                    \"applicability\" => {\n+                                        let value = match Applicability::from_str(&s.value()) {\n+                                            Ok(v) => v,\n+                                            Err(()) => {\n+                                                span_err(span, \"invalid applicability\").emit();\n+                                                Applicability::Unspecified\n+                                            }\n+                                        };\n+                                        self.applicability.set_once((quote! { #value }, span));\n+                                    }\n+                                    _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                                        diag.help(\"only `code`, `slug` and `applicability` are valid nested attributes\")\n+                                    }),\n+                                }\n+                            }\n+                            _ => throw_invalid_nested_attr!(attr, &nested_attr),\n+                        }\n+                    }\n+\n+                    let Ok(kind) = SubdiagnosticKind::from_str(name) else {\n+                        throw_invalid_attr!(attr, &meta)\n+                    };\n+\n+                    kind\n+                }\n+                _ => throw_invalid_attr!(attr, &meta),\n+            };\n+\n+            if matches!(\n+                kind,\n+                SubdiagnosticKind::Label | SubdiagnosticKind::Help | SubdiagnosticKind::Note\n+            ) && self.code.is_some()\n+            {\n+                throw_span_err!(\n+                    span,\n+                    &format!(\"`code` is not a valid nested attribute of a `{}` attribute\", name)\n+                );\n+            }\n+\n+            if self.slug.is_none() {\n+                throw_span_err!(\n+                    span,\n+                    &format!(\"`slug` must be set in a `#[{}(...)]` attribute\", name)\n+                );\n+            }\n+\n+            self.kind.set_once((kind, span));\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn generate_field_code(\n+        &mut self,\n+        binding: &BindingInfo<'_>,\n+        is_suggestion: bool,\n+    ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n+        let ast = binding.ast();\n+\n+        let option_ty = option_inner_ty(&ast.ty);\n+        let info = FieldInfo {\n+            vis: &ast.vis,\n+            binding: binding,\n+            ty: option_ty.unwrap_or(&ast.ty),\n+            span: &ast.span(),\n+        };\n+\n+        for attr in &ast.attrs {\n+            let name = attr.path.segments.last().unwrap().ident.to_string();\n+            let name = name.as_str();\n+            let span = attr.span().unwrap();\n+\n+            let meta = attr.parse_meta()?;\n+            match meta {\n+                Meta::Path(_) => match name {\n+                    \"primary_span\" => {\n+                        report_error_if_not_applied_to_span(attr, &info)?;\n+                        self.span_field.set_once((binding.binding.clone(), span));\n+                        return Ok(quote! {});\n+                    }\n+                    \"applicability\" if is_suggestion => {\n+                        report_error_if_not_applied_to_applicability(attr, &info)?;\n+                        let binding = binding.binding.clone();\n+                        self.applicability.set_once((quote! { #binding }, span));\n+                        return Ok(quote! {});\n+                    }\n+                    \"applicability\" => {\n+                        span_err(span, \"`#[applicability]` is only valid on suggestions\").emit();\n+                        return Ok(quote! {});\n+                    }\n+                    \"skip_arg\" => {\n+                        return Ok(quote! {});\n+                    }\n+                    _ => throw_invalid_attr!(attr, &meta, |diag| {\n+                        diag.help(\"only `primary_span`, `applicability` and `skip_arg` are valid field attributes\")\n+                    }),\n+                },\n+                _ => throw_invalid_attr!(attr, &meta),\n+            }\n+        }\n+\n+        let ident = ast.ident.as_ref().unwrap();\n+\n+        let diag = &self.diag;\n+        let generated = quote! {\n+            #diag.set_arg(\n+                stringify!(#ident),\n+                #binding.into_diagnostic_arg()\n+            );\n+        };\n+\n+        if option_ty.is_none() {\n+            Ok(quote! { #generated })\n+        } else {\n+            Ok(quote! {\n+                if let Some(#binding) = #binding {\n+                    #generated\n+                }\n+            })\n+        }\n+    }\n+\n+    fn into_tokens(&mut self) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n+        self.identify_kind()?;\n+        let Some(kind) = self.kind.map(|(kind, _)| kind) else {\n+            throw_span_err!(\n+                self.variant.ast().ident.span().unwrap(),\n+                \"subdiagnostic kind not specified\"\n+            );\n+        };\n+\n+        let is_suggestion = matches!(kind, SubdiagnosticKind::Suggestion(_));\n+\n+        let mut args = TokenStream::new();\n+        for binding in self.variant.bindings() {\n+            let arg = self\n+                .generate_field_code(binding, is_suggestion)\n+                .unwrap_or_else(|v| v.to_compile_error());\n+            args.extend(arg);\n+        }\n+\n+        // Missing slug errors will already have been reported.\n+        let slug = self.slug.as_ref().map(|(slug, _)| &**slug).unwrap_or(\"missing-slug\");\n+        let code = match self.code.as_ref() {\n+            Some((code, _)) => Some(quote! { #code }),\n+            None if is_suggestion => {\n+                span_err(self.span, \"suggestion without `code = \\\"...\\\"`\").emit();\n+                Some(quote! { /* macro error */ \"...\" })\n+            }\n+            None => None,\n+        };\n+\n+        let span_field = self.span_field.as_ref().map(|(span, _)| span);\n+        let applicability = match self.applicability.clone() {\n+            Some((applicability, _)) => Some(applicability),\n+            None if is_suggestion => {\n+                span_err(self.span, \"suggestion without `applicability`\").emit();\n+                Some(quote! { rustc_errors::Applicability::Unspecified })\n+            }\n+            None => None,\n+        };\n+\n+        let diag = &self.diag;\n+        let name = format_ident!(\"{}{}\", if span_field.is_some() { \"span_\" } else { \"\" }, kind);\n+        let message = quote! { rustc_errors::DiagnosticMessage::fluent(#slug) };\n+        let call = if matches!(kind, SubdiagnosticKind::Suggestion(..)) {\n+            if let Some(span) = span_field {\n+                quote! { #diag.#name(#span, #message, #code, #applicability); }\n+            } else {\n+                span_err(self.span, \"suggestion without `#[primary_span]` field\").emit();\n+                quote! { unreachable!(); }\n+            }\n+        } else if matches!(kind, SubdiagnosticKind::Label) {\n+            if let Some(span) = span_field {\n+                quote! { #diag.#name(#span, #message); }\n+            } else {\n+                span_err(self.span, \"label without `#[primary_span]` field\").emit();\n+                quote! { unreachable!(); }\n+            }\n+        } else {\n+            if let Some(span) = span_field {\n+                quote! { #diag.#name(#span, #message); }\n+            } else {\n+                quote! { #diag.#name(#message); }\n+            }\n+        };\n+\n+        Ok(quote! {\n+            #call\n+            #args\n+        })\n+    }\n+}"}, {"sha": "1f36af0a20bcdfaae0d9c06df58208e8a89a3c47", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -0,0 +1,267 @@\n+use crate::diagnostics::error::{span_err, throw_span_err, SessionDiagnosticDeriveError};\n+use proc_macro::Span;\n+use proc_macro2::TokenStream;\n+use quote::{format_ident, quote};\n+use std::collections::BTreeSet;\n+use std::str::FromStr;\n+use syn::{spanned::Spanned, Attribute, Meta, Type, Visibility};\n+use synstructure::BindingInfo;\n+\n+/// Checks whether the type name of `ty` matches `name`.\n+///\n+/// Given some struct at `a::b::c::Foo`, this will return true for `c::Foo`, `b::c::Foo`, or\n+/// `a::b::c::Foo`. This reasonably allows qualified names to be used in the macro.\n+pub(crate) fn type_matches_path(ty: &Type, name: &[&str]) -> bool {\n+    if let Type::Path(ty) = ty {\n+        ty.path\n+            .segments\n+            .iter()\n+            .map(|s| s.ident.to_string())\n+            .rev()\n+            .zip(name.iter().rev())\n+            .all(|(x, y)| &x.as_str() == y)\n+    } else {\n+        false\n+    }\n+}\n+\n+/// Reports an error if the field's type is not `Applicability`.\n+fn report_error_if_not_applied_to_ty(\n+    attr: &Attribute,\n+    info: &FieldInfo<'_>,\n+    path: &[&str],\n+    ty_name: &str,\n+) -> Result<(), SessionDiagnosticDeriveError> {\n+    if !type_matches_path(&info.ty, path) {\n+        let name = attr.path.segments.last().unwrap().ident.to_string();\n+        let name = name.as_str();\n+        let meta = attr.parse_meta()?;\n+\n+        throw_span_err!(\n+            attr.span().unwrap(),\n+            &format!(\n+                \"the `#[{}{}]` attribute can only be applied to fields of type `{}`\",\n+                name,\n+                match meta {\n+                    Meta::Path(_) => \"\",\n+                    Meta::NameValue(_) => \" = ...\",\n+                    Meta::List(_) => \"(...)\",\n+                },\n+                ty_name\n+            )\n+        );\n+    }\n+\n+    Ok(())\n+}\n+\n+/// Reports an error if the field's type is not `Applicability`.\n+pub(crate) fn report_error_if_not_applied_to_applicability(\n+    attr: &Attribute,\n+    info: &FieldInfo<'_>,\n+) -> Result<(), SessionDiagnosticDeriveError> {\n+    report_error_if_not_applied_to_ty(\n+        attr,\n+        info,\n+        &[\"rustc_errors\", \"Applicability\"],\n+        \"Applicability\",\n+    )\n+}\n+\n+/// Reports an error if the field's type is not `Span`.\n+pub(crate) fn report_error_if_not_applied_to_span(\n+    attr: &Attribute,\n+    info: &FieldInfo<'_>,\n+) -> Result<(), SessionDiagnosticDeriveError> {\n+    report_error_if_not_applied_to_ty(attr, info, &[\"rustc_span\", \"Span\"], \"Span\")\n+}\n+\n+/// If `ty` is an Option, returns `Some(inner type)`, otherwise returns `None`.\n+pub(crate) fn option_inner_ty(ty: &Type) -> Option<&Type> {\n+    if type_matches_path(ty, &[\"std\", \"option\", \"Option\"]) {\n+        if let Type::Path(ty_path) = ty {\n+            let path = &ty_path.path;\n+            let ty = path.segments.iter().last().unwrap();\n+            if let syn::PathArguments::AngleBracketed(bracketed) = &ty.arguments {\n+                if bracketed.args.len() == 1 {\n+                    if let syn::GenericArgument::Type(ty) = &bracketed.args[0] {\n+                        return Some(ty);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    None\n+}\n+\n+/// Field information passed to the builder. Deliberately omits attrs to discourage the\n+/// `generate_*` methods from walking the attributes themselves.\n+pub(crate) struct FieldInfo<'a> {\n+    pub(crate) vis: &'a Visibility,\n+    pub(crate) binding: &'a BindingInfo<'a>,\n+    pub(crate) ty: &'a Type,\n+    pub(crate) span: &'a proc_macro2::Span,\n+}\n+\n+/// Small helper trait for abstracting over `Option` fields that contain a value and a `Span`\n+/// for error reporting if they are set more than once.\n+pub(crate) trait SetOnce<T> {\n+    fn set_once(&mut self, value: T);\n+}\n+\n+impl<T> SetOnce<(T, Span)> for Option<(T, Span)> {\n+    fn set_once(&mut self, (value, span): (T, Span)) {\n+        match self {\n+            None => {\n+                *self = Some((value, span));\n+            }\n+            Some((_, prev_span)) => {\n+                span_err(span, \"specified multiple times\")\n+                    .span_note(*prev_span, \"previously specified here\")\n+                    .emit();\n+            }\n+        }\n+    }\n+}\n+\n+pub(crate) trait HasFieldMap {\n+    /// Returns the binding for the field with the given name, if it exists on the type.\n+    fn get_field_binding(&self, field: &String) -> Option<&TokenStream>;\n+\n+    /// In the strings in the attributes supplied to this macro, we want callers to be able to\n+    /// reference fields in the format string. For example:\n+    ///\n+    /// ```ignore (not-usage-example)\n+    /// /// Suggest `==` when users wrote `===`.\n+    /// #[suggestion(slug = \"parser-not-javascript-eq\", code = \"{lhs} == {rhs}\")]\n+    /// struct NotJavaScriptEq {\n+    ///     #[primary_span]\n+    ///     span: Span,\n+    ///     lhs: Ident,\n+    ///     rhs: Ident,\n+    /// }\n+    /// ```\n+    ///\n+    /// We want to automatically pick up that `{lhs}` refers `self.lhs` and `{rhs}` refers to\n+    /// `self.rhs`, then generate this call to `format!`:\n+    ///\n+    /// ```ignore (not-usage-example)\n+    /// format!(\"{lhs} == {rhs}\", lhs = self.lhs, rhs = self.rhs)\n+    /// ```\n+    ///\n+    /// This function builds the entire call to `format!`.\n+    fn build_format(&self, input: &str, span: proc_macro2::Span) -> TokenStream {\n+        // This set is used later to generate the final format string. To keep builds reproducible,\n+        // the iteration order needs to be deterministic, hence why we use a `BTreeSet` here\n+        // instead of a `HashSet`.\n+        let mut referenced_fields: BTreeSet<String> = BTreeSet::new();\n+\n+        // At this point, we can start parsing the format string.\n+        let mut it = input.chars().peekable();\n+\n+        // Once the start of a format string has been found, process the format string and spit out\n+        // the referenced fields. Leaves `it` sitting on the closing brace of the format string, so\n+        // the next call to `it.next()` retrieves the next character.\n+        while let Some(c) = it.next() {\n+            if c == '{' && *it.peek().unwrap_or(&'\\0') != '{' {\n+                let mut eat_argument = || -> Option<String> {\n+                    let mut result = String::new();\n+                    // Format specifiers look like:\n+                    //\n+                    //   format   := '{' [ argument ] [ ':' format_spec ] '}' .\n+                    //\n+                    // Therefore, we only need to eat until ':' or '}' to find the argument.\n+                    while let Some(c) = it.next() {\n+                        result.push(c);\n+                        let next = *it.peek().unwrap_or(&'\\0');\n+                        if next == '}' {\n+                            break;\n+                        } else if next == ':' {\n+                            // Eat the ':' character.\n+                            assert_eq!(it.next().unwrap(), ':');\n+                            break;\n+                        }\n+                    }\n+                    // Eat until (and including) the matching '}'\n+                    while it.next()? != '}' {\n+                        continue;\n+                    }\n+                    Some(result)\n+                };\n+\n+                if let Some(referenced_field) = eat_argument() {\n+                    referenced_fields.insert(referenced_field);\n+                }\n+            }\n+        }\n+\n+        // At this point, `referenced_fields` contains a set of the unique fields that were\n+        // referenced in the format string. Generate the corresponding \"x = self.x\" format\n+        // string parameters:\n+        let args = referenced_fields.into_iter().map(|field: String| {\n+            let field_ident = format_ident!(\"{}\", field);\n+            let value = match self.get_field_binding(&field) {\n+                Some(value) => value.clone(),\n+                // This field doesn't exist. Emit a diagnostic.\n+                None => {\n+                    span_err(\n+                        span.unwrap(),\n+                        &format!(\"`{}` doesn't refer to a field on this type\", field),\n+                    )\n+                    .emit();\n+                    quote! {\n+                        \"{#field}\"\n+                    }\n+                }\n+            };\n+            quote! {\n+                #field_ident = #value\n+            }\n+        });\n+        quote! {\n+            format!(#input #(,#args)*)\n+        }\n+    }\n+}\n+\n+/// `Applicability` of a suggestion - mirrors `rustc_errors::Applicability` - and used to represent\n+/// the user's selection of applicability if specified in an attribute.\n+pub(crate) enum Applicability {\n+    MachineApplicable,\n+    MaybeIncorrect,\n+    HasPlaceholders,\n+    Unspecified,\n+}\n+\n+impl FromStr for Applicability {\n+    type Err = ();\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        match s {\n+            \"machine-applicable\" => Ok(Applicability::MachineApplicable),\n+            \"maybe-incorrect\" => Ok(Applicability::MaybeIncorrect),\n+            \"has-placeholders\" => Ok(Applicability::HasPlaceholders),\n+            \"unspecified\" => Ok(Applicability::Unspecified),\n+            _ => Err(()),\n+        }\n+    }\n+}\n+\n+impl quote::ToTokens for Applicability {\n+    fn to_tokens(&self, tokens: &mut TokenStream) {\n+        tokens.extend(match self {\n+            Applicability::MachineApplicable => {\n+                quote! { rustc_errors::Applicability::MachineApplicable }\n+            }\n+            Applicability::MaybeIncorrect => {\n+                quote! { rustc_errors::Applicability::MaybeIncorrect }\n+            }\n+            Applicability::HasPlaceholders => {\n+                quote! { rustc_errors::Applicability::HasPlaceholders }\n+            }\n+            Applicability::Unspecified => {\n+                quote! { rustc_errors::Applicability::Unspecified }\n+            }\n+        });\n+    }\n+}"}, {"sha": "b01e01414e878cd725b893f40178278bfe195187", "filename": "compiler/rustc_macros/src/lib.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Flib.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -1,18 +1,19 @@\n-#![feature(proc_macro_diagnostic)]\n #![feature(allow_internal_unstable)]\n+#![feature(let_else)]\n+#![feature(proc_macro_diagnostic)]\n #![allow(rustc::default_hash_types)]\n #![recursion_limit = \"128\"]\n \n use synstructure::decl_derive;\n \n use proc_macro::TokenStream;\n \n+mod diagnostics;\n mod hash_stable;\n mod lift;\n mod newtype;\n mod query;\n mod serialize;\n-mod session_diagnostic;\n mod symbols;\n mod type_foldable;\n \n@@ -72,8 +73,24 @@ decl_derive!(\n         skip_arg,\n         primary_span,\n         label,\n+        subdiagnostic,\n         suggestion,\n         suggestion_short,\n         suggestion_hidden,\n-        suggestion_verbose)] => session_diagnostic::session_diagnostic_derive\n+        suggestion_verbose)] => diagnostics::session_diagnostic_derive\n+);\n+decl_derive!(\n+    [SessionSubdiagnostic, attributes(\n+        // struct/variant attributes\n+        label,\n+        help,\n+        note,\n+        suggestion,\n+        suggestion_short,\n+        suggestion_hidden,\n+        suggestion_verbose,\n+        // field attributes\n+        skip_arg,\n+        primary_span,\n+        applicability)] => diagnostics::session_subdiagnostic_derive\n );"}, {"sha": "9466d0f34bc0750c360983d3a2efb0f909be0814", "filename": "compiler/rustc_macros/src/session_diagnostic.rs", "status": "removed", "additions": 0, "deletions": 966, "changes": 966, "blob_url": "https://github.com/rust-lang/rust/blob/87937d3b6c302dfedfa5c4b94d0a30985d46298d/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87937d3b6c302dfedfa5c4b94d0a30985d46298d/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs?ref=87937d3b6c302dfedfa5c4b94d0a30985d46298d", "patch": "@@ -1,966 +0,0 @@\n-#![deny(unused_must_use)]\n-use proc_macro::Diagnostic;\n-use quote::{format_ident, quote};\n-use syn::spanned::Spanned;\n-\n-use std::collections::{BTreeSet, HashMap};\n-\n-/// Implements `#[derive(SessionDiagnostic)]`, which allows for errors to be specified as a struct,\n-/// independent from the actual diagnostics emitting code.\n-///\n-/// ```ignore (pseudo-rust)\n-/// # extern crate rustc_errors;\n-/// # use rustc_errors::Applicability;\n-/// # extern crate rustc_span;\n-/// # use rustc_span::{symbol::Ident, Span};\n-/// # extern crate rust_middle;\n-/// # use rustc_middle::ty::Ty;\n-/// #[derive(SessionDiagnostic)]\n-/// #[error(code = \"E0505\", slug = \"borrowck-move-out-of-borrow\")]\n-/// pub struct MoveOutOfBorrowError<'tcx> {\n-///     pub name: Ident,\n-///     pub ty: Ty<'tcx>,\n-///     #[primary_span]\n-///     #[label]\n-///     pub span: Span,\n-///     #[label = \"first-borrow-label\"]\n-///     pub first_borrow_span: Span,\n-///     #[suggestion(code = \"{name}.clone()\")]\n-///     pub clone_sugg: Option<(Span, Applicability)>\n-/// }\n-/// ```\n-///\n-/// ```fluent\n-/// move-out-of-borrow = cannot move out of {$name} because it is borrowed\n-///     .label = cannot move out of borrow\n-///     .first-borrow-label = `{$ty}` first borrowed here\n-///     .suggestion = consider cloning here\n-/// ```\n-///\n-/// Then, later, to emit the error:\n-///\n-/// ```ignore (pseudo-rust)\n-/// sess.emit_err(MoveOutOfBorrowError {\n-///     expected,\n-///     actual,\n-///     span,\n-///     first_borrow_span,\n-///     clone_sugg: Some(suggestion, Applicability::MachineApplicable),\n-/// });\n-/// ```\n-///\n-/// See rustc dev guide for more examples on using the `#[derive(SessionDiagnostic)]`:\n-/// <https://rustc-dev-guide.rust-lang.org/diagnostics/sessiondiagnostic.html>\n-pub fn session_diagnostic_derive(s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {\n-    // Names for the diagnostic we build and the session we build it from.\n-    let diag = format_ident!(\"diag\");\n-    let sess = format_ident!(\"sess\");\n-\n-    SessionDiagnosticDerive::new(diag, sess, s).into_tokens()\n-}\n-\n-/// Checks whether the type name of `ty` matches `name`.\n-///\n-/// Given some struct at `a::b::c::Foo`, this will return true for `c::Foo`, `b::c::Foo`, or\n-/// `a::b::c::Foo`. This reasonably allows qualified names to be used in the macro.\n-fn type_matches_path(ty: &syn::Type, name: &[&str]) -> bool {\n-    if let syn::Type::Path(ty) = ty {\n-        ty.path\n-            .segments\n-            .iter()\n-            .map(|s| s.ident.to_string())\n-            .rev()\n-            .zip(name.iter().rev())\n-            .all(|(x, y)| &x.as_str() == y)\n-    } else {\n-        false\n-    }\n-}\n-\n-/// The central struct for constructing the `as_error` method from an annotated struct.\n-struct SessionDiagnosticDerive<'a> {\n-    structure: synstructure::Structure<'a>,\n-    builder: SessionDiagnosticDeriveBuilder<'a>,\n-}\n-\n-impl std::convert::From<syn::Error> for SessionDiagnosticDeriveError {\n-    fn from(e: syn::Error) -> Self {\n-        SessionDiagnosticDeriveError::SynError(e)\n-    }\n-}\n-\n-#[derive(Debug)]\n-enum SessionDiagnosticDeriveError {\n-    SynError(syn::Error),\n-    ErrorHandled,\n-}\n-\n-impl SessionDiagnosticDeriveError {\n-    fn to_compile_error(self) -> proc_macro2::TokenStream {\n-        match self {\n-            SessionDiagnosticDeriveError::SynError(e) => e.to_compile_error(),\n-            SessionDiagnosticDeriveError::ErrorHandled => {\n-                // Return ! to avoid having to create a blank DiagnosticBuilder to return when an\n-                // error has already been emitted to the compiler.\n-                quote! {\n-                    { unreachable!(); }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn span_err(span: impl proc_macro::MultiSpan, msg: &str) -> proc_macro::Diagnostic {\n-    Diagnostic::spanned(span, proc_macro::Level::Error, msg)\n-}\n-\n-/// For methods that return a `Result<_, SessionDiagnosticDeriveError>`:\n-///\n-/// Emit a diagnostic on span `$span` with msg `$msg` (optionally performing additional decoration\n-/// using the `FnOnce` passed in `diag`) and return `Err(ErrorHandled)`.\n-macro_rules! throw_span_err {\n-    ($span:expr, $msg:expr) => {{ throw_span_err!($span, $msg, |diag| diag) }};\n-    ($span:expr, $msg:expr, $f:expr) => {{\n-        return Err(_throw_span_err($span, $msg, $f));\n-    }};\n-}\n-\n-/// When possible, prefer using `throw_span_err!` over using this function directly. This only\n-/// exists as a function to constrain `f` to an `impl FnOnce`.\n-fn _throw_span_err(\n-    span: impl proc_macro::MultiSpan,\n-    msg: &str,\n-    f: impl FnOnce(proc_macro::Diagnostic) -> proc_macro::Diagnostic,\n-) -> SessionDiagnosticDeriveError {\n-    let diag = span_err(span, msg);\n-    f(diag).emit();\n-    SessionDiagnosticDeriveError::ErrorHandled\n-}\n-\n-impl<'a> SessionDiagnosticDerive<'a> {\n-    fn new(diag: syn::Ident, sess: syn::Ident, structure: synstructure::Structure<'a>) -> Self {\n-        // Build the mapping of field names to fields. This allows attributes to peek values from\n-        // other fields.\n-        let mut fields_map = HashMap::new();\n-\n-        // Convenience bindings.\n-        let ast = structure.ast();\n-\n-        if let syn::Data::Struct(syn::DataStruct { fields, .. }) = &ast.data {\n-            for field in fields.iter() {\n-                if let Some(ident) = &field.ident {\n-                    fields_map.insert(ident.to_string(), field);\n-                }\n-            }\n-        }\n-\n-        Self {\n-            builder: SessionDiagnosticDeriveBuilder {\n-                diag,\n-                sess,\n-                fields: fields_map,\n-                kind: None,\n-                code: None,\n-                slug: None,\n-            },\n-            structure,\n-        }\n-    }\n-\n-    fn into_tokens(self) -> proc_macro2::TokenStream {\n-        let SessionDiagnosticDerive { mut structure, mut builder } = self;\n-\n-        let ast = structure.ast();\n-        let attrs = &ast.attrs;\n-\n-        let (implementation, param_ty) = {\n-            if let syn::Data::Struct(..) = ast.data {\n-                let preamble = {\n-                    let preamble = attrs.iter().map(|attr| {\n-                        builder\n-                            .generate_structure_code(attr)\n-                            .unwrap_or_else(|v| v.to_compile_error())\n-                    });\n-\n-                    quote! {\n-                        #(#preamble)*;\n-                    }\n-                };\n-\n-                // Generates calls to `span_label` and similar functions based on the attributes\n-                // on fields. Code for suggestions uses formatting machinery and the value of\n-                // other fields - because any given field can be referenced multiple times, it\n-                // should be accessed through a borrow. When passing fields to `set_arg` (which\n-                // happens below) for Fluent, we want to move the data, so that has to happen\n-                // in a separate pass over the fields.\n-                let attrs = structure.each(|field_binding| {\n-                    let field = field_binding.ast();\n-                    let result = field.attrs.iter().map(|attr| {\n-                        builder\n-                            .generate_field_attr_code(\n-                                attr,\n-                                FieldInfo {\n-                                    vis: &field.vis,\n-                                    binding: field_binding,\n-                                    ty: &field.ty,\n-                                    span: &field.span(),\n-                                },\n-                            )\n-                            .unwrap_or_else(|v| v.to_compile_error())\n-                    });\n-\n-                    quote! { #(#result);* }\n-                });\n-\n-                // When generating `set_arg` calls, move data rather than borrow it to avoid\n-                // requiring clones - this must therefore be the last use of each field (for\n-                // example, any formatting machinery that might refer to a field should be\n-                // generated already).\n-                structure.bind_with(|_| synstructure::BindStyle::Move);\n-                let args = structure.each(|field_binding| {\n-                    let field = field_binding.ast();\n-                    // When a field has attributes like `#[label]` or `#[note]` then it doesn't\n-                    // need to be passed as an argument to the diagnostic. But when a field has no\n-                    // attributes then it must be passed as an argument to the diagnostic so that\n-                    // it can be referred to by Fluent messages.\n-                    if field.attrs.is_empty() {\n-                        let diag = &builder.diag;\n-                        let ident = field_binding.ast().ident.as_ref().unwrap();\n-                        quote! {\n-                            #diag.set_arg(\n-                                stringify!(#ident),\n-                                #field_binding.into_diagnostic_arg()\n-                            );\n-                        }\n-                    } else {\n-                        quote! {}\n-                    }\n-                });\n-\n-                let span = ast.span().unwrap();\n-                let (diag, sess) = (&builder.diag, &builder.sess);\n-                let init = match (builder.kind, builder.slug) {\n-                    (None, _) => {\n-                        span_err(span, \"diagnostic kind not specified\")\n-                            .help(\"use the `#[error(...)]` attribute to create an error\")\n-                            .emit();\n-                        return SessionDiagnosticDeriveError::ErrorHandled.to_compile_error();\n-                    }\n-                    (Some((kind, _)), None) => {\n-                        span_err(span, \"`slug` not specified\")\n-                            .help(&format!(\"use the `#[{}(slug = \\\"...\\\")]` attribute to set this diagnostic's slug\", kind.descr()))\n-                            .emit();\n-                        return SessionDiagnosticDeriveError::ErrorHandled.to_compile_error();\n-                    }\n-                    (Some((SessionDiagnosticKind::Error, _)), Some((slug, _))) => {\n-                        quote! {\n-                            let mut #diag = #sess.struct_err(\n-                                rustc_errors::DiagnosticMessage::fluent(#slug),\n-                            );\n-                        }\n-                    }\n-                    (Some((SessionDiagnosticKind::Warn, _)), Some((slug, _))) => {\n-                        quote! {\n-                            let mut #diag = #sess.struct_warn(\n-                                rustc_errors::DiagnosticMessage::fluent(#slug),\n-                            );\n-                        }\n-                    }\n-                };\n-\n-                let implementation = quote! {\n-                    #init\n-                    #preamble\n-                    match self {\n-                        #attrs\n-                    }\n-                    match self {\n-                        #args\n-                    }\n-                    #diag\n-                };\n-                let param_ty = match builder.kind {\n-                    Some((SessionDiagnosticKind::Error, _)) => {\n-                        quote! { rustc_errors::ErrorGuaranteed }\n-                    }\n-                    Some((SessionDiagnosticKind::Warn, _)) => quote! { () },\n-                    _ => unreachable!(),\n-                };\n-\n-                (implementation, param_ty)\n-            } else {\n-                span_err(\n-                    ast.span().unwrap(),\n-                    \"`#[derive(SessionDiagnostic)]` can only be used on structs\",\n-                )\n-                .emit();\n-\n-                let implementation = SessionDiagnosticDeriveError::ErrorHandled.to_compile_error();\n-                let param_ty = quote! { rustc_errors::ErrorGuaranteed };\n-                (implementation, param_ty)\n-            }\n-        };\n-\n-        let sess = &builder.sess;\n-        structure.gen_impl(quote! {\n-            gen impl<'__session_diagnostic_sess> rustc_session::SessionDiagnostic<'__session_diagnostic_sess, #param_ty>\n-                    for @Self\n-            {\n-                fn into_diagnostic(\n-                    self,\n-                    #sess: &'__session_diagnostic_sess rustc_session::parse::ParseSess\n-                ) -> rustc_errors::DiagnosticBuilder<'__session_diagnostic_sess, #param_ty> {\n-                    use rustc_errors::IntoDiagnosticArg;\n-                    #implementation\n-                }\n-            }\n-        })\n-    }\n-}\n-\n-/// Field information passed to the builder. Deliberately omits attrs to discourage the\n-/// `generate_*` methods from walking the attributes themselves.\n-struct FieldInfo<'a> {\n-    vis: &'a syn::Visibility,\n-    binding: &'a synstructure::BindingInfo<'a>,\n-    ty: &'a syn::Type,\n-    span: &'a proc_macro2::Span,\n-}\n-\n-/// What kind of session diagnostic is being derived - an error or a warning?\n-#[derive(Copy, Clone)]\n-enum SessionDiagnosticKind {\n-    /// `#[error(..)]`\n-    Error,\n-    /// `#[warn(..)]`\n-    Warn,\n-}\n-\n-impl SessionDiagnosticKind {\n-    /// Returns human-readable string corresponding to the kind.\n-    fn descr(&self) -> &'static str {\n-        match self {\n-            SessionDiagnosticKind::Error => \"error\",\n-            SessionDiagnosticKind::Warn => \"warning\",\n-        }\n-    }\n-}\n-\n-/// Tracks persistent information required for building up the individual calls to diagnostic\n-/// methods for the final generated method. This is a separate struct to `SessionDiagnosticDerive`\n-/// only to be able to destructure and split `self.builder` and the `self.structure` up to avoid a\n-/// double mut borrow later on.\n-struct SessionDiagnosticDeriveBuilder<'a> {\n-    /// Name of the session parameter that's passed in to the `as_error` method.\n-    sess: syn::Ident,\n-    /// The identifier to use for the generated `DiagnosticBuilder` instance.\n-    diag: syn::Ident,\n-\n-    /// Store a map of field name to its corresponding field. This is built on construction of the\n-    /// derive builder.\n-    fields: HashMap<String, &'a syn::Field>,\n-\n-    /// Kind of diagnostic requested via the struct attribute.\n-    kind: Option<(SessionDiagnosticKind, proc_macro::Span)>,\n-    /// Slug is a mandatory part of the struct attribute as corresponds to the Fluent message that\n-    /// has the actual diagnostic message.\n-    slug: Option<(String, proc_macro::Span)>,\n-    /// Error codes are a optional part of the struct attribute - this is only set to detect\n-    /// multiple specifications.\n-    code: Option<proc_macro::Span>,\n-}\n-\n-impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n-    /// Establishes state in the `SessionDiagnosticDeriveBuilder` resulting from the struct\n-    /// attributes like `#[error(..)#`, such as the diagnostic kind and slug. Generates\n-    /// diagnostic builder calls for setting error code and creating note/help messages.\n-    fn generate_structure_code(\n-        &mut self,\n-        attr: &syn::Attribute,\n-    ) -> Result<proc_macro2::TokenStream, SessionDiagnosticDeriveError> {\n-        let span = attr.span().unwrap();\n-\n-        let name = attr.path.segments.last().unwrap().ident.to_string();\n-        let name = name.as_str();\n-        let meta = attr.parse_meta()?;\n-\n-        if matches!(name, \"help\" | \"note\")\n-            && matches!(meta, syn::Meta::Path(_) | syn::Meta::NameValue(_))\n-        {\n-            let diag = &self.diag;\n-            let slug = match &self.slug {\n-                Some((slug, _)) => slug.as_str(),\n-                None => throw_span_err!(\n-                    span,\n-                    &format!(\n-                        \"`#[{}{}]` must come after `#[error(..)]` or `#[warn(..)]`\",\n-                        name,\n-                        match meta {\n-                            syn::Meta::Path(_) => \"\",\n-                            syn::Meta::NameValue(_) => \" = ...\",\n-                            _ => unreachable!(),\n-                        }\n-                    )\n-                ),\n-            };\n-            let id = match meta {\n-                syn::Meta::Path(..) => quote! { #name },\n-                syn::Meta::NameValue(syn::MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n-                    quote! { #s }\n-                }\n-                _ => unreachable!(),\n-            };\n-            let fn_name = proc_macro2::Ident::new(name, attr.span());\n-\n-            return Ok(quote! {\n-                #diag.#fn_name(rustc_errors::DiagnosticMessage::fluent_attr(#slug, #id));\n-            });\n-        }\n-\n-        let nested = match meta {\n-            syn::Meta::List(syn::MetaList { nested, .. }) => nested,\n-            syn::Meta::Path(..) => throw_span_err!(\n-                span,\n-                &format!(\"`#[{}]` is not a valid `SessionDiagnostic` struct attribute\", name)\n-            ),\n-            syn::Meta::NameValue(..) => throw_span_err!(\n-                span,\n-                &format!(\"`#[{} = ...]` is not a valid `SessionDiagnostic` struct attribute\", name)\n-            ),\n-        };\n-\n-        let kind = match name {\n-            \"error\" => SessionDiagnosticKind::Error,\n-            \"warning\" => SessionDiagnosticKind::Warn,\n-            other => throw_span_err!(\n-                span,\n-                &format!(\"`#[{}(...)]` is not a valid `SessionDiagnostic` struct attribute\", other)\n-            ),\n-        };\n-        self.set_kind_once(kind, span)?;\n-\n-        let mut tokens = Vec::new();\n-        for attr in nested {\n-            let span = attr.span().unwrap();\n-            let meta = match attr {\n-                syn::NestedMeta::Meta(meta) => meta,\n-                syn::NestedMeta::Lit(_) => throw_span_err!(\n-                    span,\n-                    &format!(\n-                        \"`#[{}(\\\"...\\\")]` is not a valid `SessionDiagnostic` struct attribute\",\n-                        name\n-                    )\n-                ),\n-            };\n-\n-            let path = meta.path();\n-            let nested_name = path.segments.last().unwrap().ident.to_string();\n-            match &meta {\n-                // Struct attributes are only allowed to be applied once, and the diagnostic\n-                // changes will be set in the initialisation code.\n-                syn::Meta::NameValue(syn::MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n-                    match nested_name.as_str() {\n-                        \"slug\" => {\n-                            self.set_slug_once(s.value(), s.span().unwrap());\n-                        }\n-                        \"code\" => {\n-                            tokens.push(self.set_code_once(s.value(), s.span().unwrap()));\n-                        }\n-                        other => {\n-                            let diag = span_err(\n-                                span,\n-                                &format!(\n-                                    \"`#[{}({} = ...)]` is not a valid `SessionDiagnostic` struct attribute\",\n-                                    name, other\n-                                ),\n-                            );\n-                            diag.emit();\n-                        }\n-                    }\n-                }\n-                syn::Meta::NameValue(..) => {\n-                    span_err(\n-                        span,\n-                        &format!(\n-                            \"`#[{}({} = ...)]` is not a valid `SessionDiagnostic` struct attribute\",\n-                            name, nested_name\n-                        ),\n-                    )\n-                    .help(\"value must be a string\")\n-                    .emit();\n-                }\n-                syn::Meta::Path(..) => {\n-                    span_err(\n-                        span,\n-                        &format!(\n-                            \"`#[{}({})]` is not a valid `SessionDiagnostic` struct attribute\",\n-                            name, nested_name\n-                        ),\n-                    )\n-                    .emit();\n-                }\n-                syn::Meta::List(..) => {\n-                    span_err(\n-                        span,\n-                        &format!(\n-                            \"`#[{}({}(...))]` is not a valid `SessionDiagnostic` struct attribute\",\n-                            name, nested_name\n-                        ),\n-                    )\n-                    .emit();\n-                }\n-            }\n-        }\n-\n-        Ok(tokens.drain(..).collect())\n-    }\n-\n-    #[must_use]\n-    fn set_kind_once(\n-        &mut self,\n-        kind: SessionDiagnosticKind,\n-        span: proc_macro::Span,\n-    ) -> Result<(), SessionDiagnosticDeriveError> {\n-        match self.kind {\n-            None => {\n-                self.kind = Some((kind, span));\n-                Ok(())\n-            }\n-            Some((prev_kind, prev_span)) => {\n-                let existing = prev_kind.descr();\n-                let current = kind.descr();\n-\n-                let msg = if current == existing {\n-                    format!(\"`{}` specified multiple times\", existing)\n-                } else {\n-                    format!(\"`{}` specified when `{}` was already specified\", current, existing)\n-                };\n-                throw_span_err!(span, &msg, |diag| diag\n-                    .span_note(prev_span, \"previously specified here\"));\n-            }\n-        }\n-    }\n-\n-    fn set_code_once(&mut self, code: String, span: proc_macro::Span) -> proc_macro2::TokenStream {\n-        match self.code {\n-            None => {\n-                self.code = Some(span);\n-            }\n-            Some(prev_span) => {\n-                span_err(span, \"`code` specified multiple times\")\n-                    .span_note(prev_span, \"previously specified here\")\n-                    .emit();\n-            }\n-        }\n-\n-        let diag = &self.diag;\n-        quote! { #diag.code(rustc_errors::DiagnosticId::Error(#code.to_string())); }\n-    }\n-\n-    fn set_slug_once(&mut self, slug: String, span: proc_macro::Span) {\n-        match self.slug {\n-            None => {\n-                self.slug = Some((slug, span));\n-            }\n-            Some((_, prev_span)) => {\n-                span_err(span, \"`slug` specified multiple times\")\n-                    .span_note(prev_span, \"previously specified here\")\n-                    .emit();\n-            }\n-        }\n-    }\n-\n-    fn generate_field_attr_code(\n-        &mut self,\n-        attr: &syn::Attribute,\n-        info: FieldInfo<'_>,\n-    ) -> Result<proc_macro2::TokenStream, SessionDiagnosticDeriveError> {\n-        let field_binding = &info.binding.binding;\n-        let option_ty = option_inner_ty(&info.ty);\n-        let generated_code = self.generate_non_option_field_code(\n-            attr,\n-            FieldInfo {\n-                vis: info.vis,\n-                binding: info.binding,\n-                ty: option_ty.unwrap_or(&info.ty),\n-                span: info.span,\n-            },\n-        )?;\n-\n-        if option_ty.is_none() {\n-            Ok(quote! { #generated_code })\n-        } else {\n-            Ok(quote! {\n-                if let Some(#field_binding) = #field_binding {\n-                    #generated_code\n-                }\n-            })\n-        }\n-    }\n-\n-    fn generate_non_option_field_code(\n-        &mut self,\n-        attr: &syn::Attribute,\n-        info: FieldInfo<'_>,\n-    ) -> Result<proc_macro2::TokenStream, SessionDiagnosticDeriveError> {\n-        let diag = &self.diag;\n-        let span = attr.span().unwrap();\n-        let field_binding = &info.binding.binding;\n-\n-        let name = attr.path.segments.last().unwrap().ident.to_string();\n-        let name = name.as_str();\n-\n-        let meta = attr.parse_meta()?;\n-        match meta {\n-            syn::Meta::Path(_) => match name {\n-                \"skip_arg\" => {\n-                    // Don't need to do anything - by virtue of the attribute existing, the\n-                    // `set_arg` call will not be generated.\n-                    Ok(quote! {})\n-                }\n-                \"primary_span\" => {\n-                    self.report_error_if_not_applied_to_span(attr, info)?;\n-                    Ok(quote! {\n-                        #diag.set_span(*#field_binding);\n-                    })\n-                }\n-                \"label\" | \"note\" | \"help\" => {\n-                    self.report_error_if_not_applied_to_span(attr, info)?;\n-                    Ok(self.add_subdiagnostic(field_binding, name, name))\n-                }\n-                other => throw_span_err!(\n-                    span,\n-                    &format!(\"`#[{}]` is not a valid `SessionDiagnostic` field attribute\", other)\n-                ),\n-            },\n-            syn::Meta::NameValue(syn::MetaNameValue { lit: syn::Lit::Str(s), .. }) => match name {\n-                \"label\" | \"note\" | \"help\" => {\n-                    self.report_error_if_not_applied_to_span(attr, info)?;\n-                    Ok(self.add_subdiagnostic(field_binding, name, &s.value()))\n-                }\n-                other => throw_span_err!(\n-                    span,\n-                    &format!(\n-                        \"`#[{} = ...]` is not a valid `SessionDiagnostic` field attribute\",\n-                        other\n-                    )\n-                ),\n-            },\n-            syn::Meta::NameValue(_) => throw_span_err!(\n-                span,\n-                &format!(\"`#[{} = ...]` is not a valid `SessionDiagnostic` field attribute\", name),\n-                |diag| diag.help(\"value must be a string\")\n-            ),\n-            syn::Meta::List(syn::MetaList { path, nested, .. }) => {\n-                let name = path.segments.last().unwrap().ident.to_string();\n-                let name = name.as_ref();\n-\n-                match name {\n-                    \"suggestion\" | \"suggestion_short\" | \"suggestion_hidden\"\n-                    | \"suggestion_verbose\" => (),\n-                    other => throw_span_err!(\n-                        span,\n-                        &format!(\n-                            \"`#[{}(...)]` is not a valid `SessionDiagnostic` field attribute\",\n-                            other\n-                        )\n-                    ),\n-                };\n-\n-                let (span_, applicability) = self.span_and_applicability_of_ty(info)?;\n-\n-                let mut msg = None;\n-                let mut code = None;\n-\n-                for attr in nested {\n-                    let meta = match attr {\n-                        syn::NestedMeta::Meta(meta) => meta,\n-                        syn::NestedMeta::Lit(_) => throw_span_err!(\n-                            span,\n-                            &format!(\n-                                \"`#[{}(\\\"...\\\")]` is not a valid `SessionDiagnostic` field attribute\",\n-                                name\n-                            )\n-                        ),\n-                    };\n-\n-                    let span = meta.span().unwrap();\n-                    let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n-                    let nested_name = nested_name.as_str();\n-\n-                    match meta {\n-                        syn::Meta::NameValue(syn::MetaNameValue {\n-                            lit: syn::Lit::Str(s), ..\n-                        }) => match nested_name {\n-                            \"message\" => {\n-                                msg = Some(s.value());\n-                            }\n-                            \"code\" => {\n-                                let formatted_str = self.build_format(&s.value(), s.span());\n-                                code = Some(formatted_str);\n-                            }\n-                            other => throw_span_err!(\n-                                span,\n-                                &format!(\n-                                    \"`#[{}({} = ...)]` is not a valid `SessionDiagnostic` field attribute\",\n-                                    name, other\n-                                )\n-                            ),\n-                        },\n-                        syn::Meta::NameValue(..) => throw_span_err!(\n-                            span,\n-                            &format!(\n-                                \"`#[{}({} = ...)]` is not a valid `SessionDiagnostic` struct attribute\",\n-                                name, nested_name\n-                            ),\n-                            |diag| diag.help(\"value must be a string\")\n-                        ),\n-                        syn::Meta::Path(..) => throw_span_err!(\n-                            span,\n-                            &format!(\n-                                \"`#[{}({})]` is not a valid `SessionDiagnostic` struct attribute\",\n-                                name, nested_name\n-                            )\n-                        ),\n-                        syn::Meta::List(..) => throw_span_err!(\n-                            span,\n-                            &format!(\n-                                \"`#[{}({}(...))]` is not a valid `SessionDiagnostic` struct attribute\",\n-                                name, nested_name\n-                            )\n-                        ),\n-                    }\n-                }\n-\n-                let method = format_ident!(\"span_{}\", name);\n-\n-                let slug = self\n-                    .slug\n-                    .as_ref()\n-                    .map(|(slug, _)| slug.as_str())\n-                    .unwrap_or_else(|| \"missing-slug\");\n-                let msg = msg.as_deref().unwrap_or(\"suggestion\");\n-                let msg = quote! { rustc_errors::DiagnosticMessage::fluent_attr(#slug, #msg) };\n-                let code = code.unwrap_or_else(|| quote! { String::new() });\n-\n-                Ok(quote! { #diag.#method(#span_, #msg, #code, #applicability); })\n-            }\n-        }\n-    }\n-\n-    /// Reports an error if the field's type is not `Span`.\n-    fn report_error_if_not_applied_to_span(\n-        &self,\n-        attr: &syn::Attribute,\n-        info: FieldInfo<'_>,\n-    ) -> Result<(), SessionDiagnosticDeriveError> {\n-        if !type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n-            let name = attr.path.segments.last().unwrap().ident.to_string();\n-            let name = name.as_str();\n-            let meta = attr.parse_meta()?;\n-\n-            throw_span_err!(\n-                attr.span().unwrap(),\n-                &format!(\n-                    \"the `#[{}{}]` attribute can only be applied to fields of type `Span`\",\n-                    name,\n-                    match meta {\n-                        syn::Meta::Path(_) => \"\",\n-                        syn::Meta::NameValue(_) => \" = ...\",\n-                        syn::Meta::List(_) => \"(...)\",\n-                    }\n-                )\n-            );\n-        }\n-\n-        Ok(())\n-    }\n-\n-    /// Adds a subdiagnostic by generating a `diag.span_$kind` call with the current slug and\n-    /// `fluent_attr_identifier`.\n-    fn add_subdiagnostic(\n-        &self,\n-        field_binding: &proc_macro2::Ident,\n-        kind: &str,\n-        fluent_attr_identifier: &str,\n-    ) -> proc_macro2::TokenStream {\n-        let diag = &self.diag;\n-\n-        let slug =\n-            self.slug.as_ref().map(|(slug, _)| slug.as_str()).unwrap_or_else(|| \"missing-slug\");\n-        let fn_name = format_ident!(\"span_{}\", kind);\n-        quote! {\n-            #diag.#fn_name(\n-                *#field_binding,\n-                rustc_errors::DiagnosticMessage::fluent_attr(#slug, #fluent_attr_identifier)\n-            );\n-        }\n-    }\n-\n-    fn span_and_applicability_of_ty(\n-        &self,\n-        info: FieldInfo<'_>,\n-    ) -> Result<(proc_macro2::TokenStream, proc_macro2::TokenStream), SessionDiagnosticDeriveError>\n-    {\n-        match &info.ty {\n-            // If `ty` is `Span` w/out applicability, then use `Applicability::Unspecified`.\n-            ty @ syn::Type::Path(..) if type_matches_path(ty, &[\"rustc_span\", \"Span\"]) => {\n-                let binding = &info.binding.binding;\n-                Ok((quote!(*#binding), quote!(rustc_errors::Applicability::Unspecified)))\n-            }\n-            // If `ty` is `(Span, Applicability)` then return tokens accessing those.\n-            syn::Type::Tuple(tup) => {\n-                let mut span_idx = None;\n-                let mut applicability_idx = None;\n-\n-                for (idx, elem) in tup.elems.iter().enumerate() {\n-                    if type_matches_path(elem, &[\"rustc_span\", \"Span\"]) {\n-                        if span_idx.is_none() {\n-                            span_idx = Some(syn::Index::from(idx));\n-                        } else {\n-                            throw_span_err!(\n-                                info.span.unwrap(),\n-                                \"type of field annotated with `#[suggestion(...)]` contains more than one `Span`\"\n-                            );\n-                        }\n-                    } else if type_matches_path(elem, &[\"rustc_errors\", \"Applicability\"]) {\n-                        if applicability_idx.is_none() {\n-                            applicability_idx = Some(syn::Index::from(idx));\n-                        } else {\n-                            throw_span_err!(\n-                                info.span.unwrap(),\n-                                \"type of field annotated with `#[suggestion(...)]` contains more than one Applicability\"\n-                            );\n-                        }\n-                    }\n-                }\n-\n-                if let Some(span_idx) = span_idx {\n-                    let binding = &info.binding.binding;\n-                    let span = quote!(#binding.#span_idx);\n-                    let applicability = applicability_idx\n-                        .map(|applicability_idx| quote!(#binding.#applicability_idx))\n-                        .unwrap_or_else(|| quote!(rustc_errors::Applicability::Unspecified));\n-\n-                    return Ok((span, applicability));\n-                }\n-\n-                throw_span_err!(info.span.unwrap(), \"wrong types for suggestion\", |diag| {\n-                    diag.help(\"`#[suggestion(...)]` on a tuple field must be applied to fields of type `(Span, Applicability)`\")\n-                });\n-            }\n-            // If `ty` isn't a `Span` or `(Span, Applicability)` then emit an error.\n-            _ => throw_span_err!(info.span.unwrap(), \"wrong field type for suggestion\", |diag| {\n-                diag.help(\"`#[suggestion(...)]` should be applied to fields of type `Span` or `(Span, Applicability)`\")\n-            }),\n-        }\n-    }\n-\n-    /// In the strings in the attributes supplied to this macro, we want callers to be able to\n-    /// reference fields in the format string. For example:\n-    ///\n-    /// ```ignore (not-usage-example)\n-    /// struct Point {\n-    ///     #[error = \"Expected a point greater than ({x}, {y})\"]\n-    ///     x: i32,\n-    ///     y: i32,\n-    /// }\n-    /// ```\n-    ///\n-    /// We want to automatically pick up that `{x}` refers `self.x` and `{y}` refers to `self.y`,\n-    /// then generate this call to `format!`:\n-    ///\n-    /// ```ignore (not-usage-example)\n-    /// format!(\"Expected a point greater than ({x}, {y})\", x = self.x, y = self.y)\n-    /// ```\n-    ///\n-    /// This function builds the entire call to `format!`.\n-    fn build_format(&self, input: &str, span: proc_macro2::Span) -> proc_macro2::TokenStream {\n-        // This set is used later to generate the final format string. To keep builds reproducible,\n-        // the iteration order needs to be deterministic, hence why we use a BTreeSet here instead\n-        // of a HashSet.\n-        let mut referenced_fields: BTreeSet<String> = BTreeSet::new();\n-\n-        // At this point, we can start parsing the format string.\n-        let mut it = input.chars().peekable();\n-        // Once the start of a format string has been found, process the format string and spit out\n-        // the referenced fields. Leaves `it` sitting on the closing brace of the format string, so the\n-        // next call to `it.next()` retrieves the next character.\n-        while let Some(c) = it.next() {\n-            if c == '{' && *it.peek().unwrap_or(&'\\0') != '{' {\n-                let mut eat_argument = || -> Option<String> {\n-                    let mut result = String::new();\n-                    // Format specifiers look like\n-                    // format   := '{' [ argument ] [ ':' format_spec ] '}' .\n-                    // Therefore, we only need to eat until ':' or '}' to find the argument.\n-                    while let Some(c) = it.next() {\n-                        result.push(c);\n-                        let next = *it.peek().unwrap_or(&'\\0');\n-                        if next == '}' {\n-                            break;\n-                        } else if next == ':' {\n-                            // Eat the ':' character.\n-                            assert_eq!(it.next().unwrap(), ':');\n-                            break;\n-                        }\n-                    }\n-                    // Eat until (and including) the matching '}'\n-                    while it.next()? != '}' {\n-                        continue;\n-                    }\n-                    Some(result)\n-                };\n-\n-                if let Some(referenced_field) = eat_argument() {\n-                    referenced_fields.insert(referenced_field);\n-                }\n-            }\n-        }\n-        // At this point, `referenced_fields` contains a set of the unique fields that were\n-        // referenced in the format string. Generate the corresponding \"x = self.x\" format\n-        // string parameters:\n-        let args = referenced_fields.into_iter().map(|field: String| {\n-            let field_ident = format_ident!(\"{}\", field);\n-            let value = if self.fields.contains_key(&field) {\n-                quote! {\n-                    &self.#field_ident\n-                }\n-            } else {\n-                // This field doesn't exist. Emit a diagnostic.\n-                Diagnostic::spanned(\n-                    span.unwrap(),\n-                    proc_macro::Level::Error,\n-                    format!(\"`{}` doesn't refer to a field on this type\", field),\n-                )\n-                .emit();\n-                quote! {\n-                    \"{#field}\"\n-                }\n-            };\n-            quote! {\n-                #field_ident = #value\n-            }\n-        });\n-        quote! {\n-            format!(#input #(,#args)*)\n-        }\n-    }\n-}\n-\n-/// If `ty` is an Option, returns `Some(inner type)`, otherwise returns `None`.\n-fn option_inner_ty(ty: &syn::Type) -> Option<&syn::Type> {\n-    if type_matches_path(ty, &[\"std\", \"option\", \"Option\"]) {\n-        if let syn::Type::Path(ty_path) = ty {\n-            let path = &ty_path.path;\n-            let ty = path.segments.iter().last().unwrap();\n-            if let syn::PathArguments::AngleBracketed(bracketed) = &ty.arguments {\n-                if bracketed.args.len() == 1 {\n-                    if let syn::GenericArgument::Type(ty) = &bracketed.args[0] {\n-                        return Some(ty);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    None\n-}"}, {"sha": "ee54dd44f7194e7fc48ec1291e5f54a0578f5527", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -612,14 +612,14 @@ impl<'a> StringReader<'a> {\n                 err.span_suggestion_verbose(\n                     prefix_span,\n                     \"use `br` for a raw byte string\",\n-                    \"br\".to_string(),\n+                    \"br\",\n                     Applicability::MaybeIncorrect,\n                 );\n             } else if expn_data.is_root() {\n                 err.span_suggestion_verbose(\n                     prefix_span.shrink_to_hi(),\n                     \"consider inserting whitespace here\",\n-                    \" \".into(),\n+                    \" \",\n                     Applicability::MaybeIncorrect,\n                 );\n             }"}, {"sha": "13e9a5e660fe63f381392e67a9f5a34ca3666aa6", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -1771,7 +1771,7 @@ impl<'a> Parser<'a> {\n             .span_suggestion(\n                 token.span,\n                 \"must have an integer part\",\n-                pprust::token_to_string(token).into(),\n+                pprust::token_to_string(token),\n                 Applicability::MachineApplicable,\n             )\n             .emit();\n@@ -2324,7 +2324,7 @@ impl<'a> Parser<'a> {\n             .span_suggestion_short(\n                 span,\n                 msg,\n-                sugg.into(),\n+                sugg,\n                 // Has been misleading, at least in the past (closed Issue #48492).\n                 Applicability::MaybeIncorrect,\n             )\n@@ -2828,7 +2828,7 @@ impl<'a> Parser<'a> {\n                             e.span_suggestion(\n                                 self.prev_token.span.shrink_to_hi(),\n                                 \"try adding a comma\",\n-                                \",\".into(),\n+                                \",\",\n                                 Applicability::MachineApplicable,\n                             );\n                         }"}, {"sha": "10f1daf11295107540cd1d6d180741c3db06c49d", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -332,7 +332,7 @@ impl<'a> Parser<'a> {\n             err.span_suggestion_short(\n                 sp,\n                 &msg,\n-                \" struct \".into(),\n+                \" struct \",\n                 Applicability::MaybeIncorrect, // speculative\n             );\n             Err(err)\n@@ -532,13 +532,13 @@ impl<'a> Parser<'a> {\n                 .span_suggestion(\n                     span,\n                     \"add a trait here\",\n-                    \" Trait \".into(),\n+                    \" Trait \",\n                     Applicability::HasPlaceholders,\n                 )\n                 .span_suggestion(\n                     span.to(self.token.span),\n                     \"for an inherent impl, drop this `for`\",\n-                    \"\".into(),\n+                    \"\",\n                     Applicability::MaybeIncorrect,\n                 )\n                 .emit();\n@@ -1459,7 +1459,7 @@ impl<'a> Parser<'a> {\n                         err.span_suggestion(\n                             sp,\n                             \"missing comma here\",\n-                            \",\".into(),\n+                            \",\",\n                             Applicability::MachineApplicable,\n                         );\n                     }\n@@ -1498,7 +1498,7 @@ impl<'a> Parser<'a> {\n                     err.span_suggestion(\n                         sp,\n                         \"try adding a comma\",\n-                        \",\".into(),\n+                        \",\",\n                         Applicability::MachineApplicable,\n                     );\n                     err.emit();"}, {"sha": "cd61584a876620c7dddc3a624730599015d7db81", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -802,7 +802,7 @@ impl<'a> Parser<'a> {\n                                     .span_suggestion_verbose(\n                                         self.prev_token.span.shrink_to_hi().until(self.token.span),\n                                         &msg,\n-                                        \" @ \".to_string(),\n+                                        \" @ \",\n                                         Applicability::MaybeIncorrect,\n                                     )\n                                     .emit();\n@@ -818,7 +818,7 @@ impl<'a> Parser<'a> {\n                                         .span_suggestion_short(\n                                             sp,\n                                             &format!(\"missing `{}`\", token_str),\n-                                            token_str.into(),\n+                                            token_str,\n                                             Applicability::MaybeIncorrect,\n                                         )\n                                         .emit();"}, {"sha": "8019c5fb67cb9b46f255e6141e4b468d3b364c6e", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -606,7 +606,7 @@ impl<'a> Parser<'a> {\n             .span_suggestion(\n                 mutref_span,\n                 \"try switching the order\",\n-                \"ref mut\".into(),\n+                \"ref mut\",\n                 Applicability::MachineApplicable,\n             )\n             .emit();"}, {"sha": "650a0dc82ce2338cc130c518c1807dd70631af9e", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -851,7 +851,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 .span_suggestion(\n                     item.span,\n                     \"rename the `self` crate to be able to import it\",\n-                    \"extern crate self as name;\".into(),\n+                    \"extern crate self as name;\",\n                     Applicability::HasPlaceholders,\n                 )\n                 .emit();"}, {"sha": "a92c288cac93ddcfcad38fb8edad85e0ca5e5bdc", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -1,5 +1,6 @@\n use super::FnCtxt;\n use crate::astconv::AstConv;\n+use crate::errors::{AddReturnTypeSuggestion, ExpectedReturnTypeLabel};\n \n use rustc_ast::util::parser::ExprPrecedence;\n use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n@@ -527,28 +528,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // haven't set a return type at all (and aren't `fn main()` or an impl).\n         match (&fn_decl.output, found.is_suggestable(self.tcx), can_suggest, expected.is_unit()) {\n             (&hir::FnRetTy::DefaultReturn(span), true, true, true) => {\n-                err.span_suggestion(\n-                    span,\n-                    \"try adding a return type\",\n-                    format!(\"-> {} \", found),\n-                    Applicability::MachineApplicable,\n-                );\n+                err.subdiagnostic(AddReturnTypeSuggestion::Add { span, found });\n                 true\n             }\n             (&hir::FnRetTy::DefaultReturn(span), false, true, true) => {\n                 // FIXME: if `found` could be `impl Iterator` or `impl Fn*`, we should suggest\n                 // that.\n-                err.span_suggestion(\n-                    span,\n-                    \"a return type might be missing here\",\n-                    \"-> _ \".to_string(),\n-                    Applicability::HasPlaceholders,\n-                );\n+                err.subdiagnostic(AddReturnTypeSuggestion::MissingHere { span });\n                 true\n             }\n             (&hir::FnRetTy::DefaultReturn(span), _, false, true) => {\n                 // `fn main()` must return `()`, do not suggest changing return type\n-                err.span_label(span, \"expected `()` because of default return type\");\n+                err.subdiagnostic(ExpectedReturnTypeLabel::Unit { span });\n                 true\n             }\n             // expectation was caused by something else, not the default return\n@@ -557,16 +548,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // Only point to return type if the expected type is the return type, as if they\n                 // are not, the expectation must have been caused by something else.\n                 debug!(\"suggest_missing_return_type: return type {:?} node {:?}\", ty, ty.kind);\n-                let sp = ty.span;\n+                let span = ty.span;\n                 let ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, ty);\n                 debug!(\"suggest_missing_return_type: return type {:?}\", ty);\n                 debug!(\"suggest_missing_return_type: expected type {:?}\", ty);\n                 let bound_vars = self.tcx.late_bound_vars(fn_id);\n                 let ty = Binder::bind_with_vars(ty, bound_vars);\n-                let ty = self.normalize_associated_types_in(sp, ty);\n+                let ty = self.normalize_associated_types_in(span, ty);\n                 let ty = self.tcx.erase_late_bound_regions(ty);\n                 if self.can_coerce(expected, ty) {\n-                    err.span_label(sp, format!(\"expected `{}` because of return type\", expected));\n+                    err.subdiagnostic(ExpectedReturnTypeLabel::Other { span, expected });\n                     self.try_suggest_return_impl_trait(err, expected, ty, fn_id);\n                     return true;\n                 }"}, {"sha": "3d2f93537e4e8d5d9eccd66aefcb68dec2f76514", "filename": "compiler/rustc_typeck/src/errors.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -1,6 +1,6 @@\n //! Errors emitted by typeck.\n use rustc_errors::Applicability;\n-use rustc_macros::SessionDiagnostic;\n+use rustc_macros::{SessionDiagnostic, SessionSubdiagnostic};\n use rustc_middle::ty::Ty;\n use rustc_span::{symbol::Ident, Span, Symbol};\n \n@@ -190,3 +190,41 @@ pub struct AddressOfTemporaryTaken {\n     #[label]\n     pub span: Span,\n }\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum AddReturnTypeSuggestion<'tcx> {\n+    #[suggestion(\n+        slug = \"typeck-add-return-type-add\",\n+        code = \"-> {found} \",\n+        applicability = \"machine-applicable\"\n+    )]\n+    Add {\n+        #[primary_span]\n+        span: Span,\n+        found: Ty<'tcx>,\n+    },\n+    #[suggestion(\n+        slug = \"typeck-add-return-type-missing-here\",\n+        code = \"-> _ \",\n+        applicability = \"has-placeholders\"\n+    )]\n+    MissingHere {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum ExpectedReturnTypeLabel<'tcx> {\n+    #[label(slug = \"typeck-expected-default-return-type\")]\n+    Unit {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[label(slug = \"typeck-expected-return-type\")]\n+    Other {\n+        #[primary_span]\n+        span: Span,\n+        expected: Ty<'tcx>,\n+    },\n+}"}, {"sha": "efbf78ac87d73a34e571742254a07b6ac10d458d", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "renamed", "additions": 65, "deletions": 17, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -15,7 +15,7 @@ use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n extern crate rustc_macros;\n-use rustc_macros::SessionDiagnostic;\n+use rustc_macros::{SessionDiagnostic, SessionSubdiagnostic};\n \n extern crate rustc_middle;\n use rustc_middle::ty::Ty;\n@@ -44,67 +44,74 @@ enum SessionDiagnosticOnEnum {\n #[derive(SessionDiagnostic)]\n #[error(code = \"E0123\", slug = \"foo\")]\n #[error = \"E0123\"]\n-//~^ ERROR `#[error = ...]` is not a valid `SessionDiagnostic` struct attribute\n+//~^ ERROR `#[error = ...]` is not a valid attribute\n struct WrongStructAttrStyle {}\n \n #[derive(SessionDiagnostic)]\n #[nonsense(code = \"E0123\", slug = \"foo\")]\n-//~^ ERROR `#[nonsense(...)]` is not a valid `SessionDiagnostic` struct attribute\n+//~^ ERROR `#[nonsense(...)]` is not a valid attribute\n //~^^ ERROR diagnostic kind not specified\n //~^^^ ERROR cannot find attribute `nonsense` in this scope\n struct InvalidStructAttr {}\n \n #[derive(SessionDiagnostic)]\n #[error(\"E0123\")]\n-//~^ ERROR `#[error(\"...\")]` is not a valid `SessionDiagnostic` struct attribute\n+//~^ ERROR `#[error(\"...\")]` is not a valid attribute\n //~^^ ERROR `slug` not specified\n struct InvalidLitNestedAttr {}\n \n #[derive(SessionDiagnostic)]\n #[error(nonsense, code = \"E0123\", slug = \"foo\")]\n-//~^ ERROR `#[error(nonsense)]` is not a valid `SessionDiagnostic` struct attribute\n+//~^ ERROR `#[error(nonsense)]` is not a valid attribute\n struct InvalidNestedStructAttr {}\n \n #[derive(SessionDiagnostic)]\n #[error(nonsense(\"foo\"), code = \"E0123\", slug = \"foo\")]\n-//~^ ERROR `#[error(nonsense(...))]` is not a valid `SessionDiagnostic` struct attribute\n+//~^ ERROR `#[error(nonsense(...))]` is not a valid attribute\n struct InvalidNestedStructAttr1 {}\n \n #[derive(SessionDiagnostic)]\n #[error(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n-//~^ ERROR `#[error(nonsense = ...)]` is not a valid `SessionDiagnostic` struct attribute\n+//~^ ERROR `#[error(nonsense = ...)]` is not a valid attribute\n struct InvalidNestedStructAttr2 {}\n \n #[derive(SessionDiagnostic)]\n #[error(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n-//~^ ERROR `#[error(nonsense = ...)]` is not a valid `SessionDiagnostic` struct attribute\n+//~^ ERROR `#[error(nonsense = ...)]` is not a valid attribute\n struct InvalidNestedStructAttr3 {}\n \n #[derive(SessionDiagnostic)]\n #[error(code = \"E0123\", slug = \"foo\")]\n struct WrongPlaceField {\n     #[suggestion = \"bar\"]\n-    //~^ ERROR `#[suggestion = ...]` is not a valid `SessionDiagnostic` field attribute\n+    //~^ ERROR `#[suggestion = ...]` is not a valid attribute\n     sp: Span,\n }\n \n #[derive(SessionDiagnostic)]\n #[error(code = \"E0123\", slug = \"foo\")]\n-#[error(code = \"E0456\", slug = \"bar\")] //~ ERROR `error` specified multiple times\n+#[error(code = \"E0456\", slug = \"bar\")]\n+//~^ ERROR specified multiple times\n+//~^^ ERROR specified multiple times\n+//~^^^ ERROR specified multiple times\n struct ErrorSpecifiedTwice {}\n \n #[derive(SessionDiagnostic)]\n #[error(code = \"E0123\", slug = \"foo\")]\n #[warning(code = \"E0293\", slug = \"bar\")]\n-//~^ ERROR `warning` specified when `error` was already specified\n+//~^ ERROR specified multiple times\n+//~^^ ERROR specified multiple times\n+//~^^^ ERROR specified multiple times\n struct WarnSpecifiedAfterError {}\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0456\", code = \"E0457\", slug = \"bar\")] //~ ERROR `code` specified multiple times\n+#[error(code = \"E0456\", code = \"E0457\", slug = \"bar\")]\n+//~^ ERROR specified multiple times\n struct CodeSpecifiedTwice {}\n \n #[derive(SessionDiagnostic)]\n-#[error(code = \"E0456\", slug = \"foo\", slug = \"bar\")] //~ ERROR `slug` specified multiple times\n+#[error(code = \"E0456\", slug = \"foo\", slug = \"bar\")]\n+//~^ ERROR specified multiple times\n struct SlugSpecifiedTwice {}\n \n #[derive(SessionDiagnostic)]\n@@ -130,7 +137,7 @@ struct MessageWrongType {\n #[error(code = \"E0123\", slug = \"foo\")]\n struct InvalidPathFieldAttr {\n     #[nonsense]\n-    //~^ ERROR `#[nonsense]` is not a valid `SessionDiagnostic` field attribute\n+    //~^ ERROR `#[nonsense]` is not a valid attribute\n     //~^^ ERROR cannot find attribute `nonsense` in this scope\n     foo: String,\n }\n@@ -215,15 +222,15 @@ struct SuggestWithoutCode {\n #[error(code = \"E0123\", slug = \"foo\")]\n struct SuggestWithBadKey {\n     #[suggestion(nonsense = \"bar\")]\n-    //~^ ERROR `#[suggestion(nonsense = ...)]` is not a valid `SessionDiagnostic` field attribute\n+    //~^ ERROR `#[suggestion(nonsense = ...)]` is not a valid attribute\n     suggestion: (Span, Applicability),\n }\n \n #[derive(SessionDiagnostic)]\n #[error(code = \"E0123\", slug = \"foo\")]\n struct SuggestWithShorthandMsg {\n     #[suggestion(msg = \"bar\")]\n-    //~^ ERROR `#[suggestion(msg = ...)]` is not a valid `SessionDiagnostic` field attribute\n+    //~^ ERROR `#[suggestion(msg = ...)]` is not a valid attribute\n     suggestion: (Span, Applicability),\n }\n \n@@ -276,7 +283,7 @@ struct SuggestWithDuplicateApplicabilityAndSpan {\n #[error(code = \"E0123\", slug = \"foo\")]\n struct WrongKindOfAnnotation {\n     #[label(\"bar\")]\n-    //~^ ERROR `#[label(...)]` is not a valid `SessionDiagnostic` field attribute\n+    //~^ ERROR `#[label(...)]` is not a valid attribute\n     z: Span,\n }\n \n@@ -426,3 +433,44 @@ struct ErrorWithNoteWrongOrder {\n struct ErrorWithNoteCustomWrongOrder {\n     val: String,\n }\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n+struct ApplicabilityInBoth {\n+    #[suggestion(message = \"bar\", code = \"...\", applicability = \"maybe-incorrect\")]\n+    //~^ ERROR applicability cannot be set in both the field and attribute\n+    suggestion: (Span, Applicability),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n+struct InvalidApplicability {\n+    #[suggestion(message = \"bar\", code = \"...\", applicability = \"batman\")]\n+    //~^ ERROR invalid applicability\n+    suggestion: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n+struct ValidApplicability {\n+    #[suggestion(message = \"bar\", code = \"...\", applicability = \"maybe-incorrect\")]\n+    suggestion: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n+struct NoApplicability {\n+    #[suggestion(message = \"bar\", code = \"...\")]\n+    suggestion: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[note(slug = \"note\")]\n+struct Note;\n+\n+#[derive(SessionDiagnostic)]\n+#[error(slug = \"subdiagnostic\")]\n+struct Subdiagnostic {\n+    #[subdiagnostic]\n+    note: Note,\n+}", "previous_filename": "src/test/ui-fulldeps/session-derive-errors.rs"}, {"sha": "b1738b60bc0d39ca9718b5e0406f1af879958aba", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.stderr", "status": "renamed", "additions": 132, "deletions": 60, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -1,5 +1,5 @@\n error: `#[derive(SessionDiagnostic)]` can only be used on structs\n-  --> $DIR/session-derive-errors.rs:37:1\n+  --> $DIR/diagnostic-derive.rs:37:1\n    |\n LL | / #[error(code = \"E0123\", slug = \"foo\")]\n LL | |\n@@ -9,20 +9,22 @@ LL | |     Bar,\n LL | | }\n    | |_^\n \n-error: `#[error = ...]` is not a valid `SessionDiagnostic` struct attribute\n-  --> $DIR/session-derive-errors.rs:46:1\n+error: `#[error = ...]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:46:1\n    |\n LL | #[error = \"E0123\"]\n    | ^^^^^^^^^^^^^^^^^^\n \n-error: `#[nonsense(...)]` is not a valid `SessionDiagnostic` struct attribute\n-  --> $DIR/session-derive-errors.rs:51:1\n+error: `#[nonsense(...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:51:1\n    |\n LL | #[nonsense(code = \"E0123\", slug = \"foo\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: only `error` and `warning` are valid attributes\n \n error: diagnostic kind not specified\n-  --> $DIR/session-derive-errors.rs:51:1\n+  --> $DIR/diagnostic-derive.rs:51:1\n    |\n LL | / #[nonsense(code = \"E0123\", slug = \"foo\")]\n LL | |\n@@ -33,14 +35,14 @@ LL | | struct InvalidStructAttr {}\n    |\n    = help: use the `#[error(...)]` attribute to create an error\n \n-error: `#[error(\"...\")]` is not a valid `SessionDiagnostic` struct attribute\n-  --> $DIR/session-derive-errors.rs:58:9\n+error: `#[error(\"...\")]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:58:9\n    |\n LL | #[error(\"E0123\")]\n    |         ^^^^^^^\n \n error: `slug` not specified\n-  --> $DIR/session-derive-errors.rs:58:1\n+  --> $DIR/diagnostic-derive.rs:58:1\n    |\n LL | / #[error(\"E0123\")]\n LL | |\n@@ -50,96 +52,146 @@ LL | | struct InvalidLitNestedAttr {}\n    |\n    = help: use the `#[error(slug = \"...\")]` attribute to set this diagnostic's slug\n \n-error: `#[error(nonsense)]` is not a valid `SessionDiagnostic` struct attribute\n-  --> $DIR/session-derive-errors.rs:64:9\n+error: `#[error(nonsense)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:64:9\n    |\n LL | #[error(nonsense, code = \"E0123\", slug = \"foo\")]\n    |         ^^^^^^^^\n \n-error: `#[error(nonsense(...))]` is not a valid `SessionDiagnostic` struct attribute\n-  --> $DIR/session-derive-errors.rs:69:9\n+error: `#[error(nonsense(...))]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:69:9\n    |\n LL | #[error(nonsense(\"foo\"), code = \"E0123\", slug = \"foo\")]\n    |         ^^^^^^^^^^^^^^^\n \n-error: `#[error(nonsense = ...)]` is not a valid `SessionDiagnostic` struct attribute\n-  --> $DIR/session-derive-errors.rs:74:9\n+error: `#[error(nonsense = ...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:74:9\n    |\n LL | #[error(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n    |         ^^^^^^^^^^^^^^^^\n+   |\n+   = help: only `slug` and `code` are valid nested attributes\n \n-error: `#[error(nonsense = ...)]` is not a valid `SessionDiagnostic` struct attribute\n-  --> $DIR/session-derive-errors.rs:79:9\n+error: `#[error(nonsense = ...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:79:9\n    |\n LL | #[error(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n    |         ^^^^^^^^^^^^\n-   |\n-   = help: value must be a string\n \n-error: `#[suggestion = ...]` is not a valid `SessionDiagnostic` field attribute\n-  --> $DIR/session-derive-errors.rs:86:5\n+error: `#[suggestion = ...]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:86:5\n    |\n LL |     #[suggestion = \"bar\"]\n    |     ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: only `label`, `note` and `help` are valid field attributes\n \n-error: `error` specified multiple times\n-  --> $DIR/session-derive-errors.rs:93:1\n+error: specified multiple times\n+  --> $DIR/diagnostic-derive.rs:93:1\n    |\n LL | #[error(code = \"E0456\", slug = \"bar\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/session-derive-errors.rs:92:1\n+  --> $DIR/diagnostic-derive.rs:92:1\n    |\n LL | #[error(code = \"E0123\", slug = \"foo\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: `warning` specified when `error` was already specified\n-  --> $DIR/session-derive-errors.rs:98:1\n+error: specified multiple times\n+  --> $DIR/diagnostic-derive.rs:93:16\n+   |\n+LL | #[error(code = \"E0456\", slug = \"bar\")]\n+   |                ^^^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/diagnostic-derive.rs:92:16\n+   |\n+LL | #[error(code = \"E0123\", slug = \"foo\")]\n+   |                ^^^^^^^\n+\n+error: specified multiple times\n+  --> $DIR/diagnostic-derive.rs:93:32\n+   |\n+LL | #[error(code = \"E0456\", slug = \"bar\")]\n+   |                                ^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/diagnostic-derive.rs:92:32\n+   |\n+LL | #[error(code = \"E0123\", slug = \"foo\")]\n+   |                                ^^^^^\n+\n+error: specified multiple times\n+  --> $DIR/diagnostic-derive.rs:101:1\n    |\n LL | #[warning(code = \"E0293\", slug = \"bar\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/session-derive-errors.rs:97:1\n+  --> $DIR/diagnostic-derive.rs:100:1\n    |\n LL | #[error(code = \"E0123\", slug = \"foo\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: `code` specified multiple times\n-  --> $DIR/session-derive-errors.rs:103:32\n+error: specified multiple times\n+  --> $DIR/diagnostic-derive.rs:101:18\n+   |\n+LL | #[warning(code = \"E0293\", slug = \"bar\")]\n+   |                  ^^^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/diagnostic-derive.rs:100:16\n+   |\n+LL | #[error(code = \"E0123\", slug = \"foo\")]\n+   |                ^^^^^^^\n+\n+error: specified multiple times\n+  --> $DIR/diagnostic-derive.rs:101:34\n+   |\n+LL | #[warning(code = \"E0293\", slug = \"bar\")]\n+   |                                  ^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/diagnostic-derive.rs:100:32\n+   |\n+LL | #[error(code = \"E0123\", slug = \"foo\")]\n+   |                                ^^^^^\n+\n+error: specified multiple times\n+  --> $DIR/diagnostic-derive.rs:108:32\n    |\n LL | #[error(code = \"E0456\", code = \"E0457\", slug = \"bar\")]\n    |                                ^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/session-derive-errors.rs:103:16\n+  --> $DIR/diagnostic-derive.rs:108:16\n    |\n LL | #[error(code = \"E0456\", code = \"E0457\", slug = \"bar\")]\n    |                ^^^^^^^\n \n-error: `slug` specified multiple times\n-  --> $DIR/session-derive-errors.rs:107:46\n+error: specified multiple times\n+  --> $DIR/diagnostic-derive.rs:113:46\n    |\n LL | #[error(code = \"E0456\", slug = \"foo\", slug = \"bar\")]\n    |                                              ^^^^^\n    |\n note: previously specified here\n-  --> $DIR/session-derive-errors.rs:107:32\n+  --> $DIR/diagnostic-derive.rs:113:32\n    |\n LL | #[error(code = \"E0456\", slug = \"foo\", slug = \"bar\")]\n    |                                ^^^^^\n \n error: diagnostic kind not specified\n-  --> $DIR/session-derive-errors.rs:111:1\n+  --> $DIR/diagnostic-derive.rs:118:1\n    |\n LL | struct KindNotProvided {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use the `#[error(...)]` attribute to create an error\n \n error: `slug` not specified\n-  --> $DIR/session-derive-errors.rs:114:1\n+  --> $DIR/diagnostic-derive.rs:121:1\n    |\n LL | / #[error(code = \"E0456\")]\n LL | | struct SlugNotProvided {}\n@@ -148,31 +200,33 @@ LL | | struct SlugNotProvided {}\n    = help: use the `#[error(slug = \"...\")]` attribute to set this diagnostic's slug\n \n error: the `#[primary_span]` attribute can only be applied to fields of type `Span`\n-  --> $DIR/session-derive-errors.rs:124:5\n+  --> $DIR/diagnostic-derive.rs:131:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n \n-error: `#[nonsense]` is not a valid `SessionDiagnostic` field attribute\n-  --> $DIR/session-derive-errors.rs:132:5\n+error: `#[nonsense]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:139:5\n    |\n LL |     #[nonsense]\n    |     ^^^^^^^^^^^\n+   |\n+   = help: only `skip_arg`, `primary_span`, `label`, `note`, `help` and `subdiagnostic` are valid field attributes\n \n error: the `#[label = ...]` attribute can only be applied to fields of type `Span`\n-  --> $DIR/session-derive-errors.rs:149:5\n+  --> $DIR/diagnostic-derive.rs:156:5\n    |\n LL |     #[label = \"bar\"]\n    |     ^^^^^^^^^^^^^^^^\n \n error: `name` doesn't refer to a field on this type\n-  --> $DIR/session-derive-errors.rs:157:42\n+  --> $DIR/diagnostic-derive.rs:164:42\n    |\n LL |     #[suggestion(message = \"bar\", code = \"{name}\")]\n    |                                          ^^^^^^^^\n \n error: invalid format string: expected `'}'` but string was terminated\n-  --> $DIR/session-derive-errors.rs:162:16\n+  --> $DIR/diagnostic-derive.rs:169:16\n    |\n LL | #[derive(SessionDiagnostic)]\n    |           -    ^ expected `'}'` in format string\n@@ -183,7 +237,7 @@ LL | #[derive(SessionDiagnostic)]\n    = note: this error originates in the derive macro `SessionDiagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: invalid format string: unmatched `}` found\n-  --> $DIR/session-derive-errors.rs:172:15\n+  --> $DIR/diagnostic-derive.rs:179:15\n    |\n LL | #[derive(SessionDiagnostic)]\n    |               ^ unmatched `}` in format string\n@@ -192,25 +246,29 @@ LL | #[derive(SessionDiagnostic)]\n    = note: this error originates in the derive macro `SessionDiagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: the `#[label = ...]` attribute can only be applied to fields of type `Span`\n-  --> $DIR/session-derive-errors.rs:192:5\n+  --> $DIR/diagnostic-derive.rs:199:5\n    |\n LL |     #[label = \"bar\"]\n    |     ^^^^^^^^^^^^^^^^\n \n-error: `#[suggestion(nonsense = ...)]` is not a valid `SessionDiagnostic` field attribute\n-  --> $DIR/session-derive-errors.rs:217:18\n+error: `#[suggestion(nonsense = ...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:224:18\n    |\n LL |     #[suggestion(nonsense = \"bar\")]\n    |                  ^^^^^^^^^^^^^^^^\n+   |\n+   = help: only `message`, `code` and `applicability` are valid field attributes\n \n-error: `#[suggestion(msg = ...)]` is not a valid `SessionDiagnostic` field attribute\n-  --> $DIR/session-derive-errors.rs:225:18\n+error: `#[suggestion(msg = ...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:232:18\n    |\n LL |     #[suggestion(msg = \"bar\")]\n    |                  ^^^^^^^^^^^\n+   |\n+   = help: only `message`, `code` and `applicability` are valid field attributes\n \n error: wrong field type for suggestion\n-  --> $DIR/session-derive-errors.rs:247:5\n+  --> $DIR/diagnostic-derive.rs:254:5\n    |\n LL | /     #[suggestion(message = \"bar\", code = \"This is suggested code\")]\n LL | |\n@@ -220,65 +278,79 @@ LL | |     suggestion: Applicability,\n    = help: `#[suggestion(...)]` should be applied to fields of type `Span` or `(Span, Applicability)`\n \n error: type of field annotated with `#[suggestion(...)]` contains more than one `Span`\n-  --> $DIR/session-derive-errors.rs:262:5\n+  --> $DIR/diagnostic-derive.rs:269:5\n    |\n LL | /     #[suggestion(message = \"bar\", code = \"This is suggested code\")]\n LL | |\n LL | |     suggestion: (Span, Span, Applicability),\n    | |___________________________________________^\n \n error: type of field annotated with `#[suggestion(...)]` contains more than one Applicability\n-  --> $DIR/session-derive-errors.rs:270:5\n+  --> $DIR/diagnostic-derive.rs:277:5\n    |\n LL | /     #[suggestion(message = \"bar\", code = \"This is suggested code\")]\n LL | |\n LL | |     suggestion: (Applicability, Applicability, Span),\n    | |____________________________________________________^\n \n-error: `#[label(...)]` is not a valid `SessionDiagnostic` field attribute\n-  --> $DIR/session-derive-errors.rs:278:5\n+error: `#[label(...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:285:5\n    |\n LL |     #[label(\"bar\")]\n    |     ^^^^^^^^^^^^^^^\n+   |\n+   = help: only `suggestion{,_short,_hidden,_verbose}` are valid field attributes\n \n error: `#[help]` must come after `#[error(..)]` or `#[warn(..)]`\n-  --> $DIR/session-derive-errors.rs:399:1\n+  --> $DIR/diagnostic-derive.rs:406:1\n    |\n LL | #[help]\n    | ^^^^^^^\n \n error: `#[help = ...]` must come after `#[error(..)]` or `#[warn(..)]`\n-  --> $DIR/session-derive-errors.rs:407:1\n+  --> $DIR/diagnostic-derive.rs:414:1\n    |\n LL | #[help = \"bar\"]\n    | ^^^^^^^^^^^^^^^\n \n error: `#[note]` must come after `#[error(..)]` or `#[warn(..)]`\n-  --> $DIR/session-derive-errors.rs:415:1\n+  --> $DIR/diagnostic-derive.rs:422:1\n    |\n LL | #[note]\n    | ^^^^^^^\n \n error: `#[note = ...]` must come after `#[error(..)]` or `#[warn(..)]`\n-  --> $DIR/session-derive-errors.rs:423:1\n+  --> $DIR/diagnostic-derive.rs:430:1\n    |\n LL | #[note = \"bar\"]\n    | ^^^^^^^^^^^^^^^\n \n+error: applicability cannot be set in both the field and attribute\n+  --> $DIR/diagnostic-derive.rs:440:49\n+   |\n+LL |     #[suggestion(message = \"bar\", code = \"...\", applicability = \"maybe-incorrect\")]\n+   |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid applicability\n+  --> $DIR/diagnostic-derive.rs:448:49\n+   |\n+LL |     #[suggestion(message = \"bar\", code = \"...\", applicability = \"batman\")]\n+   |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error: cannot find attribute `nonsense` in this scope\n-  --> $DIR/session-derive-errors.rs:51:3\n+  --> $DIR/diagnostic-derive.rs:51:3\n    |\n LL | #[nonsense(code = \"E0123\", slug = \"foo\")]\n    |   ^^^^^^^^\n \n error: cannot find attribute `nonsense` in this scope\n-  --> $DIR/session-derive-errors.rs:132:7\n+  --> $DIR/diagnostic-derive.rs:139:7\n    |\n LL |     #[nonsense]\n    |       ^^^^^^^^\n \n error[E0599]: no method named `into_diagnostic_arg` found for struct `Hello` in the current scope\n-  --> $DIR/session-derive-errors.rs:322:10\n+  --> $DIR/diagnostic-derive.rs:329:10\n    |\n LL | struct Hello {}\n    | ------------ method `into_diagnostic_arg` not found for this\n@@ -288,6 +360,6 @@ LL | #[derive(SessionDiagnostic)]\n    |\n    = note: this error originates in the derive macro `SessionDiagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 37 previous errors\n+error: aborting due to 43 previous errors\n \n For more information about this error, try `rustc --explain E0599`.", "previous_filename": "src/test/ui-fulldeps/session-derive-errors.stderr"}, {"sha": "bb406c35c0eef7f2f74ae2c80f6c3498b857de8a", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.rs", "status": "added", "additions": 501, "deletions": 0, "changes": 501, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -0,0 +1,501 @@\n+// check-fail\n+// Tests error conditions for specifying subdiagnostics using #[derive(SessionSubdiagnostic)]\n+\n+// The proc_macro2 crate handles spans differently when on beta/stable release rather than nightly,\n+// changing the output of this test. Since SessionSubdiagnostic is strictly internal to the compiler\n+// the test is just ignored on stable and beta:\n+// ignore-beta\n+// ignore-stable\n+\n+#![feature(rustc_private)]\n+#![crate_type = \"lib\"]\n+\n+extern crate rustc_errors;\n+extern crate rustc_session;\n+extern crate rustc_span;\n+extern crate rustc_macros;\n+\n+use rustc_errors::Applicability;\n+use rustc_span::Span;\n+use rustc_macros::SessionSubdiagnostic;\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug = \"label-a\")]\n+struct A {\n+    #[primary_span]\n+    span: Span,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+enum B {\n+    #[label(slug = \"label-b-a\")]\n+    A {\n+        #[primary_span]\n+        span: Span,\n+        var: String,\n+    },\n+    #[label(slug = \"label-b-b\")]\n+    B {\n+        #[primary_span]\n+        span: Span,\n+        var: String,\n+    }\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug = \"label-c\")]\n+//~^ ERROR label without `#[primary_span]` field\n+struct C {\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label]\n+//~^ ERROR `#[label]` is not a valid attribute\n+struct D {\n+    #[primary_span]\n+    span: Span,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[foo]\n+//~^ ERROR `#[foo]` is not a valid attribute\n+//~^^ ERROR cannot find attribute `foo` in this scope\n+struct E {\n+    #[primary_span]\n+    span: Span,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label = \"...\"]\n+//~^ ERROR `#[label = ...]` is not a valid attribute\n+struct F {\n+    #[primary_span]\n+    span: Span,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(bug = \"...\")]\n+//~^ ERROR `#[label(bug = ...)]` is not a valid attribute\n+struct G {\n+    #[primary_span]\n+    span: Span,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(\"...\")]\n+//~^ ERROR `#[label(\"...\")]` is not a valid attribute\n+struct H {\n+    #[primary_span]\n+    span: Span,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug = 4)]\n+//~^ ERROR `#[label(slug = ...)]` is not a valid attribute\n+struct J {\n+    #[primary_span]\n+    span: Span,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug(\"...\"))]\n+//~^ ERROR `#[label(slug(...))]` is not a valid attribute\n+struct K {\n+    #[primary_span]\n+    span: Span,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug)]\n+//~^ ERROR `#[label(slug)]` is not a valid attribute\n+struct L {\n+    #[primary_span]\n+    span: Span,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label()]\n+//~^ ERROR `slug` must be set in a `#[label(...)]` attribute\n+struct M {\n+    #[primary_span]\n+    span: Span,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(code = \"...\")]\n+//~^ ERROR `code` is not a valid nested attribute of a `label` attribute\n+struct N {\n+    #[primary_span]\n+    span: Span,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[foo]\n+//~^ ERROR cannot find attribute `foo` in this scope\n+//~^^ ERROR unsupported type attribute for subdiagnostic enum\n+enum O {\n+    #[label(slug = \"...\")]\n+    A {\n+        #[primary_span]\n+        span: Span,\n+        var: String,\n+    }\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+enum P {\n+    #[bar]\n+//~^ ERROR `#[bar]` is not a valid attribute\n+//~^^ ERROR cannot find attribute `bar` in this scope\n+    A {\n+        #[primary_span]\n+        span: Span,\n+        var: String,\n+    }\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+enum Q {\n+    #[bar = \"...\"]\n+//~^ ERROR `#[bar = ...]` is not a valid attribute\n+//~^^ ERROR cannot find attribute `bar` in this scope\n+    A {\n+        #[primary_span]\n+        span: Span,\n+        var: String,\n+    }\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+enum R {\n+    #[bar = 4]\n+//~^ ERROR `#[bar = ...]` is not a valid attribute\n+//~^^ ERROR cannot find attribute `bar` in this scope\n+    A {\n+        #[primary_span]\n+        span: Span,\n+        var: String,\n+    }\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+enum S {\n+    #[bar(\"...\")]\n+//~^ ERROR `#[bar(\"...\")]` is not a valid attribute\n+//~^^ ERROR cannot find attribute `bar` in this scope\n+    A {\n+        #[primary_span]\n+        span: Span,\n+        var: String,\n+    }\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+enum T {\n+    #[label(code = \"...\")]\n+//~^ ERROR `code` is not a valid nested attribute of a `label`\n+    A {\n+        #[primary_span]\n+        span: Span,\n+        var: String,\n+    }\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+enum U {\n+    #[label(slug = \"label-u\")]\n+    A {\n+        #[primary_span]\n+        span: Span,\n+        var: String,\n+    },\n+    B {\n+//~^ ERROR subdiagnostic kind not specified\n+        #[primary_span]\n+        span: Span,\n+        var: String,\n+    }\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug = \"...\")]\n+//~^ ERROR label without `#[primary_span]` field\n+struct V {\n+    #[primary_span]\n+    //~^ ERROR the `#[primary_span]` attribute can only be applied to fields of type `Span`\n+    span: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug = \"...\")]\n+struct W {\n+    #[primary_span]\n+    span: Span,\n+    #[applicability]\n+    //~^ ERROR `#[applicability]` is only valid on suggestions\n+    applicability: Applicability,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug = \"...\")]\n+struct X {\n+    #[primary_span]\n+    span: Span,\n+    #[bar]\n+    //~^ ERROR `#[bar]` is not a valid attribute\n+    //~^^ ERROR cannot find attribute `bar` in this scope\n+    bar: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug = \"...\")]\n+struct Y {\n+    #[primary_span]\n+    span: Span,\n+    #[bar = \"...\"]\n+    //~^ ERROR `#[bar = ...]` is not a valid attribute\n+    //~^^ ERROR cannot find attribute `bar` in this scope\n+    bar: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug = \"...\")]\n+struct Z {\n+    #[primary_span]\n+    span: Span,\n+    #[bar(\"...\")]\n+    //~^ ERROR `#[bar(...)]` is not a valid attribute\n+    //~^^ ERROR cannot find attribute `bar` in this scope\n+    bar: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug = \"label-aa\")]\n+struct AA {\n+    #[primary_span]\n+    span: Span,\n+    #[skip_arg]\n+    z: Z\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+union AB {\n+//~^ ERROR unexpected unsupported untagged union\n+    span: u32,\n+    b: u64\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug = \"label-ac-1\")]\n+//~^ NOTE previously specified here\n+//~^^ NOTE previously specified here\n+#[label(slug = \"label-ac-2\")]\n+//~^ ERROR specified multiple times\n+//~^^ ERROR specified multiple times\n+struct AC {\n+    #[primary_span]\n+    span: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug = \"label-ad-1\", slug = \"label-ad-2\")]\n+//~^ ERROR specified multiple times\n+//~^^ NOTE previously specified here\n+struct AD {\n+    #[primary_span]\n+    span: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label(slug = \"label-ad-1\")]\n+struct AE {\n+    #[primary_span]\n+//~^ NOTE previously specified here\n+    span_a: Span,\n+    #[primary_span]\n+//~^ ERROR specified multiple times\n+    span_b: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+struct AF {\n+//~^ ERROR subdiagnostic kind not specified\n+    #[primary_span]\n+    span: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[suggestion(slug = \"suggestion-af\", code = \"...\")]\n+struct AG {\n+    #[primary_span]\n+    span: Span,\n+    #[applicability]\n+    applicability: Applicability,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+enum AH {\n+    #[suggestion(slug = \"suggestion-ag-a\", code = \"...\")]\n+    A {\n+        #[primary_span]\n+        span: Span,\n+        #[applicability]\n+        applicability: Applicability,\n+        var: String,\n+    },\n+    #[suggestion(slug = \"suggestion-ag-b\", code = \"...\")]\n+    B {\n+        #[primary_span]\n+        span: Span,\n+        #[applicability]\n+        applicability: Applicability,\n+        var: String,\n+    }\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[suggestion(slug = \"...\", code = \"...\", code = \"...\")]\n+//~^ ERROR specified multiple times\n+//~^^ NOTE previously specified here\n+struct AI {\n+    #[primary_span]\n+    span: Span,\n+    #[applicability]\n+    applicability: Applicability,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[suggestion(slug = \"...\", code = \"...\")]\n+struct AJ {\n+    #[primary_span]\n+    span: Span,\n+    #[applicability]\n+//~^ NOTE previously specified here\n+    applicability_a: Applicability,\n+    #[applicability]\n+//~^ ERROR specified multiple times\n+    applicability_b: Applicability,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[suggestion(slug = \"...\", code = \"...\")]\n+//~^ ERROR suggestion without `applicability`\n+struct AK {\n+    #[primary_span]\n+    span: Span,\n+    #[applicability]\n+//~^ ERROR the `#[applicability]` attribute can only be applied to fields of type `Applicability`\n+    applicability: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[suggestion(slug = \"...\", code = \"...\")]\n+//~^ ERROR suggestion without `applicability`\n+struct AL {\n+    #[primary_span]\n+    span: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[suggestion(slug = \"...\")]\n+//~^ ERROR suggestion without `code = \"...\"`\n+struct AM {\n+    #[primary_span]\n+    span: Span,\n+    #[applicability]\n+    applicability: Applicability,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[suggestion(slug = \"...\", code =\"...\", applicability = \"foo\")]\n+//~^ ERROR invalid applicability\n+struct AN {\n+    #[primary_span]\n+    span: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[help(slug = \"label-am\")]\n+struct AO {\n+    var: String\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[note(slug = \"label-an\")]\n+struct AP;\n+\n+#[derive(SessionSubdiagnostic)]\n+#[suggestion(slug = \"...\", code = \"...\")]\n+//~^ ERROR suggestion without `applicability`\n+//~^^ ERROR suggestion without `#[primary_span]` field\n+struct AQ {\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[suggestion(slug = \"...\", code =\"...\", applicability = \"machine-applicable\")]\n+struct AR {\n+    #[primary_span]\n+    span: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[label]\n+//~^ ERROR unsupported type attribute for subdiagnostic enum\n+enum AS {\n+    #[label(slug = \"...\")]\n+    A {\n+        #[primary_span]\n+        span: Span,\n+        var: String,\n+    }\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[suggestion(slug = \"...\", code =\"{var}\", applicability = \"machine-applicable\")]\n+struct AT {\n+    #[primary_span]\n+    span: Span,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[suggestion(slug = \"...\", code =\"{var}\", applicability = \"machine-applicable\")]\n+//~^ ERROR `var` doesn't refer to a field on this type\n+struct AU {\n+    #[primary_span]\n+    span: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+enum AV {\n+    #[suggestion(slug = \"...\", code =\"{var}\", applicability = \"machine-applicable\")]\n+    A {\n+        #[primary_span]\n+        span: Span,\n+        var: String,\n+    }\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+enum AW {\n+    #[suggestion(slug = \"...\", code =\"{var}\", applicability = \"machine-applicable\")]\n+//~^ ERROR `var` doesn't refer to a field on this type\n+    A {\n+        #[primary_span]\n+        span: Span,\n+    }\n+}"}, {"sha": "4984cc4b3186c3b8a6b0522835baf890b59ea40e", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.stderr", "status": "added", "additions": 389, "deletions": 0, "changes": 389, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -0,0 +1,389 @@\n+error: label without `#[primary_span]` field\n+  --> $DIR/subdiagnostic-derive.rs:47:1\n+   |\n+LL | / #[label(slug = \"label-c\")]\n+LL | |\n+LL | | struct C {\n+LL | |     var: String,\n+LL | | }\n+   | |_^\n+\n+error: `#[label]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:54:1\n+   |\n+LL | #[label]\n+   | ^^^^^^^^\n+\n+error: `#[foo]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:63:1\n+   |\n+LL | #[foo]\n+   | ^^^^^^\n+\n+error: `#[label = ...]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:73:1\n+   |\n+LL | #[label = \"...\"]\n+   | ^^^^^^^^^^^^^^^^\n+\n+error: `#[label(bug = ...)]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:82:9\n+   |\n+LL | #[label(bug = \"...\")]\n+   |         ^^^^^^^^^^^\n+   |\n+   = help: only `code`, `slug` and `applicability` are valid nested attributes\n+\n+error: `#[label(\"...\")]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:91:9\n+   |\n+LL | #[label(\"...\")]\n+   |         ^^^^^\n+\n+error: `#[label(slug = ...)]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:100:9\n+   |\n+LL | #[label(slug = 4)]\n+   |         ^^^^^^^^\n+\n+error: `#[label(slug(...))]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:109:9\n+   |\n+LL | #[label(slug(\"...\"))]\n+   |         ^^^^^^^^^^^\n+\n+error: `#[label(slug)]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:118:9\n+   |\n+LL | #[label(slug)]\n+   |         ^^^^\n+\n+error: `slug` must be set in a `#[label(...)]` attribute\n+  --> $DIR/subdiagnostic-derive.rs:127:1\n+   |\n+LL | #[label()]\n+   | ^^^^^^^^^^\n+\n+error: `code` is not a valid nested attribute of a `label` attribute\n+  --> $DIR/subdiagnostic-derive.rs:136:1\n+   |\n+LL | #[label(code = \"...\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: unsupported type attribute for subdiagnostic enum\n+  --> $DIR/subdiagnostic-derive.rs:145:1\n+   |\n+LL | #[foo]\n+   | ^^^^^^\n+\n+error: `#[bar]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:159:5\n+   |\n+LL |     #[bar]\n+   |     ^^^^^^\n+\n+error: `#[bar = ...]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:171:5\n+   |\n+LL |     #[bar = \"...\"]\n+   |     ^^^^^^^^^^^^^^\n+\n+error: `#[bar = ...]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:183:5\n+   |\n+LL |     #[bar = 4]\n+   |     ^^^^^^^^^^\n+\n+error: `#[bar(\"...\")]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:195:11\n+   |\n+LL |     #[bar(\"...\")]\n+   |           ^^^^^\n+\n+error: `code` is not a valid nested attribute of a `label` attribute\n+  --> $DIR/subdiagnostic-derive.rs:207:5\n+   |\n+LL |     #[label(code = \"...\")]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: subdiagnostic kind not specified\n+  --> $DIR/subdiagnostic-derive.rs:224:5\n+   |\n+LL |     B {\n+   |     ^\n+\n+error: the `#[primary_span]` attribute can only be applied to fields of type `Span`\n+  --> $DIR/subdiagnostic-derive.rs:236:5\n+   |\n+LL |     #[primary_span]\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: label without `#[primary_span]` field\n+  --> $DIR/subdiagnostic-derive.rs:233:1\n+   |\n+LL | / #[label(slug = \"...\")]\n+LL | |\n+LL | | struct V {\n+LL | |     #[primary_span]\n+LL | |\n+LL | |     span: String,\n+LL | | }\n+   | |_^\n+\n+error: `#[applicability]` is only valid on suggestions\n+  --> $DIR/subdiagnostic-derive.rs:246:5\n+   |\n+LL |     #[applicability]\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error: `#[bar]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:256:5\n+   |\n+LL |     #[bar]\n+   |     ^^^^^^\n+   |\n+   = help: only `primary_span`, `applicability` and `skip_arg` are valid field attributes\n+\n+error: `#[bar = ...]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:267:5\n+   |\n+LL |     #[bar = \"...\"]\n+   |     ^^^^^^^^^^^^^^\n+\n+error: `#[bar(...)]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:278:5\n+   |\n+LL |     #[bar(\"...\")]\n+   |     ^^^^^^^^^^^^^\n+\n+error: unexpected unsupported untagged union\n+  --> $DIR/subdiagnostic-derive.rs:294:1\n+   |\n+LL | / union AB {\n+LL | |\n+LL | |     span: u32,\n+LL | |     b: u64\n+LL | | }\n+   | |_^\n+\n+error: specified multiple times\n+  --> $DIR/subdiagnostic-derive.rs:304:9\n+   |\n+LL | #[label(slug = \"label-ac-2\")]\n+   |         ^^^^^^^^^^^^^^^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/subdiagnostic-derive.rs:301:9\n+   |\n+LL | #[label(slug = \"label-ac-1\")]\n+   |         ^^^^^^^^^^^^^^^^^^^\n+\n+error: specified multiple times\n+  --> $DIR/subdiagnostic-derive.rs:304:1\n+   |\n+LL | #[label(slug = \"label-ac-2\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/subdiagnostic-derive.rs:301:1\n+   |\n+LL | #[label(slug = \"label-ac-1\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: specified multiple times\n+  --> $DIR/subdiagnostic-derive.rs:313:30\n+   |\n+LL | #[label(slug = \"label-ad-1\", slug = \"label-ad-2\")]\n+   |                              ^^^^^^^^^^^^^^^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/subdiagnostic-derive.rs:313:9\n+   |\n+LL | #[label(slug = \"label-ad-1\", slug = \"label-ad-2\")]\n+   |         ^^^^^^^^^^^^^^^^^^^\n+\n+error: specified multiple times\n+  --> $DIR/subdiagnostic-derive.rs:327:5\n+   |\n+LL |     #[primary_span]\n+   |     ^^^^^^^^^^^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/subdiagnostic-derive.rs:324:5\n+   |\n+LL |     #[primary_span]\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: subdiagnostic kind not specified\n+  --> $DIR/subdiagnostic-derive.rs:333:8\n+   |\n+LL | struct AF {\n+   |        ^^\n+\n+error: specified multiple times\n+  --> $DIR/subdiagnostic-derive.rs:370:42\n+   |\n+LL | #[suggestion(slug = \"...\", code = \"...\", code = \"...\")]\n+   |                                          ^^^^^^^^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/subdiagnostic-derive.rs:370:28\n+   |\n+LL | #[suggestion(slug = \"...\", code = \"...\", code = \"...\")]\n+   |                            ^^^^^^^^^^^^\n+\n+error: specified multiple times\n+  --> $DIR/subdiagnostic-derive.rs:388:5\n+   |\n+LL |     #[applicability]\n+   |     ^^^^^^^^^^^^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/subdiagnostic-derive.rs:385:5\n+   |\n+LL |     #[applicability]\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error: the `#[applicability]` attribute can only be applied to fields of type `Applicability`\n+  --> $DIR/subdiagnostic-derive.rs:399:5\n+   |\n+LL |     #[applicability]\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error: suggestion without `applicability`\n+  --> $DIR/subdiagnostic-derive.rs:394:1\n+   |\n+LL | / #[suggestion(slug = \"...\", code = \"...\")]\n+LL | |\n+LL | | struct AK {\n+LL | |     #[primary_span]\n+...  |\n+LL | |     applicability: Span,\n+LL | | }\n+   | |_^\n+\n+error: suggestion without `applicability`\n+  --> $DIR/subdiagnostic-derive.rs:405:1\n+   |\n+LL | / #[suggestion(slug = \"...\", code = \"...\")]\n+LL | |\n+LL | | struct AL {\n+LL | |     #[primary_span]\n+LL | |     span: Span,\n+LL | | }\n+   | |_^\n+\n+error: suggestion without `code = \"...\"`\n+  --> $DIR/subdiagnostic-derive.rs:413:1\n+   |\n+LL | / #[suggestion(slug = \"...\")]\n+LL | |\n+LL | | struct AM {\n+LL | |     #[primary_span]\n+...  |\n+LL | |     applicability: Applicability,\n+LL | | }\n+   | |_^\n+\n+error: invalid applicability\n+  --> $DIR/subdiagnostic-derive.rs:423:41\n+   |\n+LL | #[suggestion(slug = \"...\", code =\"...\", applicability = \"foo\")]\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: suggestion without `applicability`\n+  --> $DIR/subdiagnostic-derive.rs:441:1\n+   |\n+LL | / #[suggestion(slug = \"...\", code = \"...\")]\n+LL | |\n+LL | |\n+LL | | struct AQ {\n+LL | |     var: String,\n+LL | | }\n+   | |_^\n+\n+error: suggestion without `#[primary_span]` field\n+  --> $DIR/subdiagnostic-derive.rs:441:1\n+   |\n+LL | / #[suggestion(slug = \"...\", code = \"...\")]\n+LL | |\n+LL | |\n+LL | | struct AQ {\n+LL | |     var: String,\n+LL | | }\n+   | |_^\n+\n+error: unsupported type attribute for subdiagnostic enum\n+  --> $DIR/subdiagnostic-derive.rs:456:1\n+   |\n+LL | #[label]\n+   | ^^^^^^^^\n+\n+error: `var` doesn't refer to a field on this type\n+  --> $DIR/subdiagnostic-derive.rs:476:34\n+   |\n+LL | #[suggestion(slug = \"...\", code =\"{var}\", applicability = \"machine-applicable\")]\n+   |                                  ^^^^^^^\n+\n+error: `var` doesn't refer to a field on this type\n+  --> $DIR/subdiagnostic-derive.rs:495:38\n+   |\n+LL |     #[suggestion(slug = \"...\", code =\"{var}\", applicability = \"machine-applicable\")]\n+   |                                      ^^^^^^^\n+\n+error: cannot find attribute `foo` in this scope\n+  --> $DIR/subdiagnostic-derive.rs:63:3\n+   |\n+LL | #[foo]\n+   |   ^^^\n+\n+error: cannot find attribute `foo` in this scope\n+  --> $DIR/subdiagnostic-derive.rs:145:3\n+   |\n+LL | #[foo]\n+   |   ^^^\n+\n+error: cannot find attribute `bar` in this scope\n+  --> $DIR/subdiagnostic-derive.rs:159:7\n+   |\n+LL |     #[bar]\n+   |       ^^^\n+\n+error: cannot find attribute `bar` in this scope\n+  --> $DIR/subdiagnostic-derive.rs:171:7\n+   |\n+LL |     #[bar = \"...\"]\n+   |       ^^^\n+\n+error: cannot find attribute `bar` in this scope\n+  --> $DIR/subdiagnostic-derive.rs:183:7\n+   |\n+LL |     #[bar = 4]\n+   |       ^^^\n+\n+error: cannot find attribute `bar` in this scope\n+  --> $DIR/subdiagnostic-derive.rs:195:7\n+   |\n+LL |     #[bar(\"...\")]\n+   |       ^^^\n+\n+error: cannot find attribute `bar` in this scope\n+  --> $DIR/subdiagnostic-derive.rs:256:7\n+   |\n+LL |     #[bar]\n+   |       ^^^\n+\n+error: cannot find attribute `bar` in this scope\n+  --> $DIR/subdiagnostic-derive.rs:267:7\n+   |\n+LL |     #[bar = \"...\"]\n+   |       ^^^\n+\n+error: cannot find attribute `bar` in this scope\n+  --> $DIR/subdiagnostic-derive.rs:278:7\n+   |\n+LL |     #[bar(\"...\")]\n+   |       ^^^\n+\n+error: aborting due to 51 previous errors\n+"}, {"sha": "5462d913fb4414bf554e3c73d1bd5f0697493413", "filename": "src/tools/clippy/clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -108,7 +108,7 @@ fn check_needless_must_use(\n                 diag.span_suggestion(\n                     attr.span,\n                     \"remove the attribute\",\n-                    \"\".into(),\n+                    \"\",\n                     Applicability::MachineApplicable,\n                 );\n             },"}, {"sha": "4034079a90c0d097cbece091e56c388c3068c229", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/683c582c1e88c573c454b7fa6f00bc6647421864/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/683c582c1e88c573c454b7fa6f00bc6647421864/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=683c582c1e88c573c454b7fa6f00bc6647421864", "patch": "@@ -241,7 +241,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                                                 |x| Cow::from(format!(\"change `{}` to\", x)),\n                                             )\n                                             .as_ref(),\n-                                        suggestion.into(),\n+                                        suggestion,\n                                         Applicability::Unspecified,\n                                     );\n                                 }\n@@ -271,7 +271,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                                                 |x| Cow::from(format!(\"change `{}` to\", x))\n                                             )\n                                             .as_ref(),\n-                                        suggestion.into(),\n+                                        suggestion,\n                                         Applicability::Unspecified,\n                                     );\n                                 }"}]}