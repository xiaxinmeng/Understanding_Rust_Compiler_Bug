{"sha": "fb9ca16b3b7cf034f885de28879c4d50261ce3ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiOWNhMTZiM2I3Y2YwMzRmODg1ZGUyODg3OWM0ZDUwMjYxY2UzZWY=", "commit": {"author": {"name": "Paul Faria", "email": "Nashenas88@gmail.com", "date": "2017-05-24T01:51:21Z"}, "committer": {"name": "Paul Faria", "email": "Nashenas88@gmail.com", "date": "2017-05-24T23:15:19Z"}, "message": "Remove all instances of fragment_infos and fragment sets", "tree": {"sha": "2719b94d6c26ee39d0612416f14b3858b676ed30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2719b94d6c26ee39d0612416f14b3858b676ed30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb9ca16b3b7cf034f885de28879c4d50261ce3ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb9ca16b3b7cf034f885de28879c4d50261ce3ef", "html_url": "https://github.com/rust-lang/rust/commit/fb9ca16b3b7cf034f885de28879c4d50261ce3ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb9ca16b3b7cf034f885de28879c4d50261ce3ef/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b13bff5203c1bdc6ac6dc87f69b5359a9503078", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b13bff5203c1bdc6ac6dc87f69b5359a9503078", "html_url": "https://github.com/rust-lang/rust/commit/5b13bff5203c1bdc6ac6dc87f69b5359a9503078"}], "stats": {"total": 609, "additions": 1, "deletions": 608}, "files": [{"sha": "64e16c41d1132bde1629051f71002cc1c0fbeb67", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fb9ca16b3b7cf034f885de28879c4d50261ce3ef/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb9ca16b3b7cf034f885de28879c4d50261ce3ef/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=fb9ca16b3b7cf034f885de28879c4d50261ce3ef", "patch": "@@ -40,7 +40,7 @@ use ty::layout::{Layout, TargetDataLayout};\n use ty::inhabitedness::DefIdForest;\n use ty::maps;\n use ty::steal::Steal;\n-use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n+use util::nodemap::{NodeMap, NodeSet, DefIdSet};\n use util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n@@ -499,33 +499,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// Maps Expr NodeId's to `true` iff `&expr` can have 'static lifetime.\n     pub rvalue_promotable_to_static: RefCell<NodeMap<bool>>,\n \n-    /// Maps Fn items to a collection of fragment infos.\n-    ///\n-    /// The main goal is to identify data (each of which may be moved\n-    /// or assigned) whose subparts are not moved nor assigned\n-    /// (i.e. their state is *unfragmented*) and corresponding ast\n-    /// nodes where the path to that data is moved or assigned.\n-    ///\n-    /// In the long term, unfragmented values will have their\n-    /// destructor entirely driven by a single stack-local drop-flag,\n-    /// and their parents, the collections of the unfragmented values\n-    /// (or more simply, \"fragmented values\"), are mapped to the\n-    /// corresponding collections of stack-local drop-flags.\n-    ///\n-    /// (However, in the short term that is not the case; e.g. some\n-    /// unfragmented paths still need to be zeroed, namely when they\n-    /// reference parent data from an outer scope that was not\n-    /// entirely moved, and therefore that needs to be zeroed so that\n-    /// we do not get double-drop when we hit the end of the parent\n-    /// scope.)\n-    ///\n-    /// Also: currently the table solely holds keys for node-ids of\n-    /// unfragmented values (see `FragmentInfo` enum definition), but\n-    /// longer-term we will need to also store mappings from\n-    /// fragmented data to the set of unfragmented pieces that\n-    /// constitute it.\n-    pub fragment_infos: RefCell<DefIdMap<Vec<ty::FragmentInfo>>>,\n-\n     /// The definite name of the current crate after taking into account\n     /// attributes, commandline parameters, etc.\n     pub crate_name: Symbol,\n@@ -730,7 +703,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             rvalue_promotable_to_static: RefCell::new(NodeMap()),\n-            fragment_infos: RefCell::new(DefIdMap()),\n             crate_name: Symbol::intern(crate_name),\n             data_layout: data_layout,\n             layout_cache: RefCell::new(FxHashMap()),"}, {"sha": "cd72ac53583cefefd3ea2b65a706d1b4996483fb", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb9ca16b3b7cf034f885de28879c4d50261ce3ef/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb9ca16b3b7cf034f885de28879c4d50261ce3ef/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=fb9ca16b3b7cf034f885de28879c4d50261ce3ef", "patch": "@@ -443,17 +443,6 @@ pub struct CReaderCacheKey {\n     pub pos: usize,\n }\n \n-/// Describes the fragment-state associated with a NodeId.\n-///\n-/// Currently only unfragmented paths have entries in the table,\n-/// but longer-term this enum is expected to expand to also\n-/// include data for fragmented paths.\n-#[derive(Copy, Clone, Debug)]\n-pub enum FragmentInfo {\n-    Moved { var: NodeId, move_expr: NodeId },\n-    Assigned { var: NodeId, assign_expr: NodeId, assignee_id: NodeId },\n-}\n-\n // Flags that we track on types. These flags are propagated upwards\n // through the type during type construction, so that we can quickly\n // check whether the type has various kinds of types in it without"}, {"sha": "b728d4d534516672e436312a336f40f627017943", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "removed", "additions": 0, "deletions": 542, "changes": 542, "blob_url": "https://github.com/rust-lang/rust/blob/5b13bff5203c1bdc6ac6dc87f69b5359a9503078/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b13bff5203c1bdc6ac6dc87f69b5359a9503078/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=5b13bff5203c1bdc6ac6dc87f69b5359a9503078", "patch": "@@ -1,542 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Helper routines used for fragmenting structural paths due to moves for\n-//! tracking drop obligations. Please see the extensive comments in the\n-//! section \"Structural fragments\" in `README.md`.\n-\n-use self::Fragment::*;\n-\n-use borrowck::InteriorKind::{InteriorField, InteriorElement};\n-use borrowck::{self, LoanPath};\n-use borrowck::LoanPathKind::{LpVar, LpUpvar, LpDowncast, LpExtend};\n-use borrowck::LoanPathElem::{LpDeref, LpInterior};\n-use borrowck::move_data::InvalidMovePathIndex;\n-use borrowck::move_data::{MoveData, MovePathIndex};\n-use rustc::hir::def_id::{DefId};\n-use rustc::ty::{self, AdtKind, TyCtxt};\n-use rustc::middle::mem_categorization as mc;\n-\n-use std::mem;\n-use std::rc::Rc;\n-use syntax::ast;\n-use syntax_pos::DUMMY_SP;\n-\n-#[derive(PartialEq, Eq, PartialOrd, Ord)]\n-enum Fragment {\n-    // This represents the path described by the move path index\n-    Just(MovePathIndex),\n-\n-    // This represents the collection of all but one of the elements\n-    // from an array at the path described by the move path index.\n-    // Note that attached MovePathIndex should have mem_categorization\n-    // of InteriorElement (i.e. array dereference `&foo[..]`).\n-    AllButOneFrom(MovePathIndex),\n-}\n-\n-impl Fragment {\n-    fn loan_path_repr(&self, move_data: &MoveData) -> String {\n-        let lp = |mpi| move_data.path_loan_path(mpi);\n-        match *self {\n-            Just(mpi) => format!(\"{:?}\", lp(mpi)),\n-            AllButOneFrom(mpi) => format!(\"$(allbutone {:?})\", lp(mpi)),\n-        }\n-    }\n-\n-    fn loan_path_user_string(&self, move_data: &MoveData) -> String {\n-        let lp = |mpi| move_data.path_loan_path(mpi);\n-        match *self {\n-            Just(mpi) => lp(mpi).to_string(),\n-            AllButOneFrom(mpi) => format!(\"$(allbutone {})\", lp(mpi)),\n-        }\n-    }\n-}\n-\n-pub fn build_unfragmented_map(this: &mut borrowck::BorrowckCtxt,\n-                              move_data: &MoveData,\n-                              id: ast::NodeId) {\n-    let fr = &move_data.fragments.borrow();\n-\n-    // For now, don't care about other kinds of fragments; the precise\n-    // classfication of all paths for non-zeroing *drop* needs them,\n-    // but the loose approximation used by non-zeroing moves does not.\n-    let moved_leaf_paths = fr.moved_leaf_paths();\n-    let assigned_leaf_paths = fr.assigned_leaf_paths();\n-\n-    let mut fragment_infos = Vec::with_capacity(moved_leaf_paths.len());\n-\n-    let find_var_id = |move_path_index: MovePathIndex| -> Option<ast::NodeId> {\n-        let lp = move_data.path_loan_path(move_path_index);\n-        match lp.kind {\n-            LpVar(var_id) => Some(var_id),\n-            LpUpvar(ty::UpvarId { var_id, closure_expr_id }) => {\n-                // The `var_id` is unique *relative to* the current function.\n-                // (Check that we are indeed talking about the same function.)\n-                assert_eq!(id, closure_expr_id);\n-                Some(var_id)\n-            }\n-            LpDowncast(..) | LpExtend(..) => {\n-                // This simple implementation of non-zeroing move does\n-                // not attempt to deal with tracking substructure\n-                // accurately in the general case.\n-                None\n-            }\n-        }\n-    };\n-\n-    let moves = move_data.moves.borrow();\n-    for &move_path_index in moved_leaf_paths {\n-        let var_id = match find_var_id(move_path_index) {\n-            None => continue,\n-            Some(var_id) => var_id,\n-        };\n-\n-        move_data.each_applicable_move(move_path_index, |move_index| {\n-            let info = ty::FragmentInfo::Moved {\n-                var: var_id,\n-                move_expr: moves[move_index.get()].id,\n-            };\n-            debug!(\"fragment_infos push({:?} \\\n-                    due to move_path_index: {} move_index: {}\",\n-                   info, move_path_index.get(), move_index.get());\n-            fragment_infos.push(info);\n-            true\n-        });\n-    }\n-\n-    for &move_path_index in assigned_leaf_paths {\n-        let var_id = match find_var_id(move_path_index) {\n-            None => continue,\n-            Some(var_id) => var_id,\n-        };\n-\n-        let var_assigns = move_data.var_assignments.borrow();\n-        for var_assign in var_assigns.iter()\n-            .filter(|&assign| assign.path == move_path_index)\n-        {\n-            let info = ty::FragmentInfo::Assigned {\n-                var: var_id,\n-                assign_expr: var_assign.id,\n-                assignee_id: var_assign.assignee_id,\n-            };\n-            debug!(\"fragment_infos push({:?} due to var_assignment\", info);\n-            fragment_infos.push(info);\n-        }\n-    }\n-\n-    let mut fraginfo_map = this.tcx.fragment_infos.borrow_mut();\n-    let fn_did = this.tcx.hir.local_def_id(id);\n-    let prev = fraginfo_map.insert(fn_did, fragment_infos);\n-    assert!(prev.is_none());\n-}\n-\n-pub struct FragmentSets {\n-    /// During move_data construction, `moved_leaf_paths` tracks paths\n-    /// that have been used directly by being moved out of.  When\n-    /// move_data construction has been completed, `moved_leaf_paths`\n-    /// tracks such paths that are *leaf fragments* (e.g. `a.j` if we\n-    /// never move out any child like `a.j.x`); any parent paths\n-    /// (e.g. `a` for the `a.j` example) are moved over to\n-    /// `parents_of_fragments`.\n-    moved_leaf_paths: Vec<MovePathIndex>,\n-\n-    /// `assigned_leaf_paths` tracks paths that have been used\n-    /// directly by being overwritten, but is otherwise much like\n-    /// `moved_leaf_paths`.\n-    assigned_leaf_paths: Vec<MovePathIndex>,\n-\n-    /// `parents_of_fragments` tracks paths that are definitely\n-    /// parents of paths that have been moved.\n-    ///\n-    /// FIXME(pnkfelix) probably do not want/need\n-    /// `parents_of_fragments` at all, if we can avoid it.\n-    ///\n-    /// Update: I do not see a way to avoid it.  Maybe just remove\n-    /// above fixme, or at least document why doing this may be hard.\n-    parents_of_fragments: Vec<MovePathIndex>,\n-\n-    /// During move_data construction (specifically the\n-    /// fixup_fragment_sets call), `unmoved_fragments` tracks paths\n-    /// that have been \"left behind\" after a sibling has been moved or\n-    /// assigned.  When move_data construction has been completed,\n-    /// `unmoved_fragments` tracks paths that were *only* results of\n-    /// being left-behind, and never directly moved themselves.\n-    unmoved_fragments: Vec<Fragment>,\n-}\n-\n-impl FragmentSets {\n-    pub fn new() -> FragmentSets {\n-        FragmentSets {\n-            unmoved_fragments: Vec::new(),\n-            moved_leaf_paths: Vec::new(),\n-            assigned_leaf_paths: Vec::new(),\n-            parents_of_fragments: Vec::new(),\n-        }\n-    }\n-\n-    pub fn moved_leaf_paths(&self) -> &[MovePathIndex] {\n-        &self.moved_leaf_paths\n-    }\n-\n-    pub fn assigned_leaf_paths(&self) -> &[MovePathIndex] {\n-        &self.assigned_leaf_paths\n-    }\n-\n-    pub fn add_move(&mut self, path_index: MovePathIndex) {\n-        self.moved_leaf_paths.push(path_index);\n-    }\n-\n-    pub fn add_assignment(&mut self, path_index: MovePathIndex) {\n-        self.assigned_leaf_paths.push(path_index);\n-    }\n-}\n-\n-pub fn instrument_move_fragments<'a, 'tcx>(this: &MoveData<'tcx>,\n-                                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                           id: ast::NodeId) {\n-    let span_err = tcx.hir.attrs(id).iter()\n-                          .any(|a| a.check_name(\"rustc_move_fragments\"));\n-    let print = tcx.sess.opts.debugging_opts.print_move_fragments;\n-\n-    if !span_err && !print { return; }\n-\n-    let sp = tcx.hir.span(id);\n-\n-    let instrument_all_paths = |kind, vec_rc: &Vec<MovePathIndex>| {\n-        for (i, mpi) in vec_rc.iter().enumerate() {\n-            let lp = || this.path_loan_path(*mpi);\n-            if span_err {\n-                tcx.sess.span_err(sp, &format!(\"{}: `{}`\", kind, lp()));\n-            }\n-            if print {\n-                println!(\"id:{} {}[{}] `{}`\", id, kind, i, lp());\n-            }\n-        }\n-    };\n-\n-    let instrument_all_fragments = |kind, vec_rc: &Vec<Fragment>| {\n-        for (i, f) in vec_rc.iter().enumerate() {\n-            let render = || f.loan_path_user_string(this);\n-            if span_err {\n-                tcx.sess.span_err(sp, &format!(\"{}: `{}`\", kind, render()));\n-            }\n-            if print {\n-                println!(\"id:{} {}[{}] `{}`\", id, kind, i, render());\n-            }\n-        }\n-    };\n-\n-    let fragments = this.fragments.borrow();\n-    instrument_all_paths(\"moved_leaf_path\", &fragments.moved_leaf_paths);\n-    instrument_all_fragments(\"unmoved_fragment\", &fragments.unmoved_fragments);\n-    instrument_all_paths(\"parent_of_fragments\", &fragments.parents_of_fragments);\n-    instrument_all_paths(\"assigned_leaf_path\", &fragments.assigned_leaf_paths);\n-}\n-\n-/// Normalizes the fragment sets in `this`; i.e., removes duplicate entries, constructs the set of\n-/// parents, and constructs the left-over fragments.\n-///\n-/// Note: \"left-over fragments\" means paths that were not directly referenced in moves nor\n-/// assignments, but must nonetheless be tracked as potential drop obligations.\n-pub fn fixup_fragment_sets<'a, 'tcx>(this: &MoveData<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-\n-    let mut fragments = this.fragments.borrow_mut();\n-\n-    // Swap out contents of fragments so that we can modify the fields\n-    // without borrowing the common fragments.\n-    let mut unmoved = mem::replace(&mut fragments.unmoved_fragments, vec![]);\n-    let mut parents = mem::replace(&mut fragments.parents_of_fragments, vec![]);\n-    let mut moved = mem::replace(&mut fragments.moved_leaf_paths, vec![]);\n-    let mut assigned = mem::replace(&mut fragments.assigned_leaf_paths, vec![]);\n-\n-    let path_lps = |mpis: &[MovePathIndex]| -> Vec<String> {\n-        mpis.iter().map(|mpi| format!(\"{:?}\", this.path_loan_path(*mpi))).collect()\n-    };\n-\n-    let frag_lps = |fs: &[Fragment]| -> Vec<String> {\n-        fs.iter().map(|f| f.loan_path_repr(this)).collect()\n-    };\n-\n-    // First, filter out duplicates\n-    moved.sort();\n-    moved.dedup();\n-    debug!(\"fragments 1 moved: {:?}\", path_lps(&moved));\n-\n-    assigned.sort();\n-    assigned.dedup();\n-    debug!(\"fragments 1 assigned: {:?}\", path_lps(&assigned));\n-\n-    // Second, build parents from the moved and assigned.\n-    for m in &moved {\n-        let mut p = this.path_parent(*m);\n-        while p != InvalidMovePathIndex {\n-            parents.push(p);\n-            p = this.path_parent(p);\n-        }\n-    }\n-    for a in &assigned {\n-        let mut p = this.path_parent(*a);\n-        while p != InvalidMovePathIndex {\n-            parents.push(p);\n-            p = this.path_parent(p);\n-        }\n-    }\n-\n-    parents.sort();\n-    parents.dedup();\n-    debug!(\"fragments 2 parents: {:?}\", path_lps(&parents));\n-\n-    // Third, filter the moved and assigned fragments down to just the non-parents\n-    moved.retain(|f| non_member(*f, &parents));\n-    debug!(\"fragments 3 moved: {:?}\", path_lps(&moved));\n-\n-    assigned.retain(|f| non_member(*f, &parents));\n-    debug!(\"fragments 3 assigned: {:?}\", path_lps(&assigned));\n-\n-    // Fourth, build the leftover from the moved, assigned, and parents.\n-    for m in &moved {\n-        let lp = this.path_loan_path(*m);\n-        add_fragment_siblings(this, tcx, &mut unmoved, lp, None);\n-    }\n-    for a in &assigned {\n-        let lp = this.path_loan_path(*a);\n-        add_fragment_siblings(this, tcx, &mut unmoved, lp, None);\n-    }\n-    for p in &parents {\n-        let lp = this.path_loan_path(*p);\n-        add_fragment_siblings(this, tcx, &mut unmoved, lp, None);\n-    }\n-\n-    unmoved.sort();\n-    unmoved.dedup();\n-    debug!(\"fragments 4 unmoved: {:?}\", frag_lps(&unmoved));\n-\n-    // Fifth, filter the leftover fragments down to its core.\n-    unmoved.retain(|f| match *f {\n-        AllButOneFrom(_) => true,\n-        Just(mpi) => non_member(mpi, &parents) &&\n-            non_member(mpi, &moved) &&\n-            non_member(mpi, &assigned)\n-    });\n-    debug!(\"fragments 5 unmoved: {:?}\", frag_lps(&unmoved));\n-\n-    // Swap contents back in.\n-    fragments.unmoved_fragments = unmoved;\n-    fragments.parents_of_fragments = parents;\n-    fragments.moved_leaf_paths = moved;\n-    fragments.assigned_leaf_paths = assigned;\n-\n-    return;\n-\n-    fn non_member(elem: MovePathIndex, set: &[MovePathIndex]) -> bool {\n-        match set.binary_search(&elem) {\n-            Ok(_) => false,\n-            Err(_) => true,\n-        }\n-    }\n-}\n-\n-/// Adds all of the precisely-tracked siblings of `lp` as potential move paths of interest. For\n-/// example, if `lp` represents `s.x.j`, then adds moves paths for `s.x.i` and `s.x.k`, the\n-/// siblings of `s.x.j`.\n-fn add_fragment_siblings<'a, 'tcx>(this: &MoveData<'tcx>,\n-                                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   gathered_fragments: &mut Vec<Fragment>,\n-                                   lp: Rc<LoanPath<'tcx>>,\n-                                   origin_id: Option<ast::NodeId>) {\n-    match lp.kind {\n-        LpVar(_) | LpUpvar(..) => {} // Local variables have no siblings.\n-\n-        // Consuming a downcast is like consuming the original value, so propage inward.\n-        LpDowncast(ref loan_parent, _) => {\n-            add_fragment_siblings(this, tcx, gathered_fragments, loan_parent.clone(), origin_id);\n-        }\n-\n-        // *LV for Unique consumes the contents of the box (at\n-        // least when it is non-copy...), so propagate inward.\n-        LpExtend(ref loan_parent, _, LpDeref(mc::Unique)) => {\n-            add_fragment_siblings(this, tcx, gathered_fragments, loan_parent.clone(), origin_id);\n-        }\n-\n-        // *LV for unsafe and borrowed pointers do not consume their loan path, so stop here.\n-        LpExtend(.., LpDeref(mc::UnsafePtr(..)))   |\n-        LpExtend(.., LpDeref(mc::Implicit(..)))    |\n-        LpExtend(.., LpDeref(mc::BorrowedPtr(..))) => {}\n-\n-        // FIXME (pnkfelix): LV[j] should be tracked, at least in the\n-        // sense of we will track the remaining drop obligation of the\n-        // rest of the array.\n-        //\n-        // Well, either that or LV[j] should be made illegal.\n-        // But even then, we will need to deal with destructuring\n-        // bind.\n-        //\n-        // Anyway, for now: LV[j] is not tracked precisely\n-        LpExtend(.., LpInterior(_, InteriorElement(..))) => {\n-            let mp = this.move_path(tcx, lp.clone());\n-            gathered_fragments.push(AllButOneFrom(mp));\n-        }\n-\n-        // field access LV.x and tuple access LV#k are the cases\n-        // we are interested in\n-        LpExtend(ref loan_parent, mc,\n-                 LpInterior(_, InteriorField(ref field_name))) => {\n-            let enum_variant_info = match loan_parent.kind {\n-                LpDowncast(ref loan_parent_2, variant_def_id) =>\n-                    Some((variant_def_id, loan_parent_2.clone())),\n-                LpExtend(..) | LpVar(..) | LpUpvar(..) =>\n-                    None,\n-            };\n-            add_fragment_siblings_for_extension(\n-                this,\n-                tcx,\n-                gathered_fragments,\n-                loan_parent, mc, field_name, &lp, origin_id, enum_variant_info);\n-        }\n-    }\n-}\n-\n-/// We have determined that `origin_lp` destructures to LpExtend(parent, original_field_name).\n-/// Based on this, add move paths for all of the siblings of `origin_lp`.\n-fn add_fragment_siblings_for_extension<'a, 'tcx>(this: &MoveData<'tcx>,\n-                                                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                 gathered_fragments: &mut Vec<Fragment>,\n-                                                 parent_lp: &Rc<LoanPath<'tcx>>,\n-                                                 mc: mc::MutabilityCategory,\n-                                                 origin_field_name: &mc::FieldName,\n-                                                 origin_lp: &Rc<LoanPath<'tcx>>,\n-                                                 origin_id: Option<ast::NodeId>,\n-                                                 enum_variant_info: Option<(DefId,\n-                                                    Rc<LoanPath<'tcx>>)>) {\n-    let parent_ty = parent_lp.to_type();\n-\n-    let mut add_fragment_sibling_local = |field_name, variant_did| {\n-        add_fragment_sibling_core(\n-            this, tcx, gathered_fragments, parent_lp.clone(), mc, field_name, origin_lp,\n-            variant_did);\n-    };\n-\n-    match parent_ty.sty {\n-        ty::TyTuple(ref v, _) => {\n-            let tuple_idx = match *origin_field_name {\n-                mc::PositionalField(tuple_idx) => tuple_idx,\n-                mc::NamedField(_) =>\n-                    bug!(\"tuple type {:?} should not have named fields.\",\n-                         parent_ty),\n-            };\n-            let tuple_len = v.len();\n-            for i in 0..tuple_len {\n-                if i == tuple_idx { continue }\n-                let field_name = mc::PositionalField(i);\n-                add_fragment_sibling_local(field_name, None);\n-            }\n-        }\n-\n-        ty::TyAdt(def, ..) => match def.adt_kind() {\n-            AdtKind::Struct => {\n-                match *origin_field_name {\n-                    mc::NamedField(ast_name) => {\n-                        for f in &def.struct_variant().fields {\n-                            if f.name == ast_name {\n-                                continue;\n-                            }\n-                            let field_name = mc::NamedField(f.name);\n-                            add_fragment_sibling_local(field_name, None);\n-                        }\n-                    }\n-                    mc::PositionalField(tuple_idx) => {\n-                        for (i, _f) in def.struct_variant().fields.iter().enumerate() {\n-                            if i == tuple_idx {\n-                                continue\n-                            }\n-                            let field_name = mc::PositionalField(i);\n-                            add_fragment_sibling_local(field_name, None);\n-                        }\n-                    }\n-                }\n-            }\n-            AdtKind::Union => {\n-                // Do nothing, all union fields are moved/assigned together.\n-            }\n-            AdtKind::Enum => {\n-                let variant = match enum_variant_info {\n-                    Some((vid, ref _lp2)) => def.variant_with_id(vid),\n-                    None => {\n-                        assert!(def.is_univariant());\n-                        &def.variants[0]\n-                    }\n-                };\n-                match *origin_field_name {\n-                    mc::NamedField(ast_name) => {\n-                        for field in &variant.fields {\n-                            if field.name == ast_name {\n-                                continue;\n-                            }\n-                            let field_name = mc::NamedField(field.name);\n-                            add_fragment_sibling_local(field_name, Some(variant.did));\n-                        }\n-                    }\n-                    mc::PositionalField(tuple_idx) => {\n-                        for (i, _f) in variant.fields.iter().enumerate() {\n-                            if tuple_idx == i {\n-                                continue;\n-                            }\n-                            let field_name = mc::PositionalField(i);\n-                            add_fragment_sibling_local(field_name, None);\n-                        }\n-                    }\n-                }\n-            }\n-        },\n-\n-        ref ty => {\n-            let span = origin_id.map_or(DUMMY_SP, |id| tcx.hir.span(id));\n-            span_bug!(span,\n-                      \"type {:?} ({:?}) is not fragmentable\",\n-                      parent_ty, ty);\n-        }\n-    }\n-}\n-\n-/// Adds the single sibling `LpExtend(parent, new_field_name)` of `origin_lp` (the original\n-/// loan-path).\n-fn add_fragment_sibling_core<'a, 'tcx>(this: &MoveData<'tcx>,\n-                                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       gathered_fragments: &mut Vec<Fragment>,\n-                                       parent: Rc<LoanPath<'tcx>>,\n-                                       mc: mc::MutabilityCategory,\n-                                       new_field_name: mc::FieldName,\n-                                       origin_lp: &Rc<LoanPath<'tcx>>,\n-                                       enum_variant_did: Option<DefId>)\n-                                       -> MovePathIndex {\n-    let opt_variant_did = match parent.kind {\n-        LpDowncast(_, variant_did) => Some(variant_did),\n-        LpVar(..) | LpUpvar(..) | LpExtend(..) => enum_variant_did,\n-    };\n-\n-    let loan_path_elem = LpInterior(opt_variant_did, InteriorField(new_field_name));\n-    let new_lp_type = match new_field_name {\n-        mc::NamedField(ast_name) =>\n-            tcx.named_element_ty(parent.to_type(), ast_name, opt_variant_did),\n-        mc::PositionalField(idx) =>\n-            tcx.positional_element_ty(parent.to_type(), idx, opt_variant_did),\n-    };\n-    let new_lp_variant = LpExtend(parent, mc, loan_path_elem);\n-    let new_lp = LoanPath::new(new_lp_variant, new_lp_type.unwrap());\n-    debug!(\"add_fragment_sibling_core(new_lp={:?}, origin_lp={:?})\",\n-           new_lp, origin_lp);\n-    let mp = this.move_path(tcx, Rc::new(new_lp));\n-\n-    // Do not worry about checking for duplicates here; we will sort\n-    // and dedup after all are added.\n-    gathered_fragments.push(Just(mp));\n-\n-    mp\n-}"}, {"sha": "ff5ebb9c1dc5d1aee2ce4fa94a03e37dfb24db22", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb9ca16b3b7cf034f885de28879c4d50261ce3ef/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb9ca16b3b7cf034f885de28879c4d50261ce3ef/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=fb9ca16b3b7cf034f885de28879c4d50261ce3ef", "patch": "@@ -129,13 +129,6 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId) {\n                        move_data: flowed_moves } =\n         build_borrowck_dataflow_data(bccx, &cfg, body_id);\n \n-    move_data::fragments::instrument_move_fragments(&flowed_moves.move_data,\n-                                                    bccx.tcx,\n-                                                    owner_id);\n-    move_data::fragments::build_unfragmented_map(bccx,\n-                                                 &flowed_moves.move_data,\n-                                                 owner_id);\n-\n     check_loans::check_loans(bccx, &loan_dfcx, &flowed_moves, &all_loans, body);\n }\n "}, {"sha": "1b364596a23f7fd518de0871ebb808afa4778592", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fb9ca16b3b7cf034f885de28879c4d50261ce3ef/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb9ca16b3b7cf034f885de28879c4d50261ce3ef/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=fb9ca16b3b7cf034f885de28879c4d50261ce3ef", "patch": "@@ -33,9 +33,6 @@ use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::intravisit::IdRange;\n \n-#[path=\"fragments.rs\"]\n-pub mod fragments;\n-\n pub struct MoveData<'tcx> {\n     /// Move paths. See section \"Move paths\" in `README.md`.\n     pub paths: RefCell<Vec<MovePath<'tcx>>>,\n@@ -62,9 +59,6 @@ pub struct MoveData<'tcx> {\n \n     /// Assignments to a variable or path, like `x = foo`, but not `x += foo`.\n     pub assignee_ids: RefCell<NodeSet>,\n-\n-    /// Path-fragments from moves in to or out of parts of structured data.\n-    pub fragments: RefCell<fragments::FragmentSets>,\n }\n \n pub struct FlowedMoveData<'a, 'tcx: 'a> {\n@@ -223,7 +217,6 @@ impl<'a, 'tcx> MoveData<'tcx> {\n             var_assignments: RefCell::new(Vec::new()),\n             variant_matches: RefCell::new(Vec::new()),\n             assignee_ids: RefCell::new(NodeSet()),\n-            fragments: RefCell::new(fragments::FragmentSets::new()),\n         }\n     }\n \n@@ -401,8 +394,6 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         let path_index = self.move_path(tcx, lp.clone());\n         let move_index = MoveIndex(self.moves.borrow().len());\n \n-        self.fragments.borrow_mut().add_move(path_index);\n-\n         let next_move = self.path_first_move(path_index);\n         self.set_path_first_move(path_index, move_index);\n \n@@ -458,8 +449,6 @@ impl<'a, 'tcx> MoveData<'tcx> {\n \n         let path_index = self.move_path(tcx, lp.clone());\n \n-        self.fragments.borrow_mut().add_assignment(path_index);\n-\n         match mode {\n             MutateMode::Init | MutateMode::JustWrite => {\n                 self.assignee_ids.borrow_mut().insert(assignee_id);\n@@ -502,8 +491,6 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         let path_index = self.move_path(tcx, lp.clone());\n         let base_path_index = self.move_path(tcx, base_lp.clone());\n \n-        self.fragments.borrow_mut().add_assignment(path_index);\n-\n         let variant_match = VariantMatch {\n             path: path_index,\n             base_path: base_path_index,\n@@ -514,10 +501,6 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         self.variant_matches.borrow_mut().push(variant_match);\n     }\n \n-    fn fixup_fragment_sets(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-        fragments::fixup_fragment_sets(self, tcx)\n-    }\n-\n     /// Adds the gen/kills for the various moves and\n     /// assignments into the provided data flow contexts.\n     /// Moves are generated by moves and killed by assignments and\n@@ -677,8 +660,6 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n                                  id_range,\n                                  move_data.var_assignments.borrow().len());\n \n-        move_data.fixup_fragment_sets(tcx);\n-\n         move_data.add_gen_kills(bccx,\n                                 &mut dfcx_moves,\n                                 &mut dfcx_assign);"}]}