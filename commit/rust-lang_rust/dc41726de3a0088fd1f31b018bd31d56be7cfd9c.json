{"sha": "dc41726de3a0088fd1f31b018bd31d56be7cfd9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjNDE3MjZkZTNhMDA4OGZkMWYzMWIwMThiZDMxZDU2YmU3Y2ZkOWM=", "commit": {"author": {"name": "Jonathan Behrens", "email": "fintelia@gmail.com", "date": "2018-09-13T20:19:40Z"}, "committer": {"name": "Jonathan Behrens", "email": "fintelia@gmail.com", "date": "2018-09-13T20:19:40Z"}, "message": "Fix tests and update issue number", "tree": {"sha": "93864ec33e274636a04791d12063b1366371ea4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93864ec33e274636a04791d12063b1366371ea4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc41726de3a0088fd1f31b018bd31d56be7cfd9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc41726de3a0088fd1f31b018bd31d56be7cfd9c", "html_url": "https://github.com/rust-lang/rust/commit/dc41726de3a0088fd1f31b018bd31d56be7cfd9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc41726de3a0088fd1f31b018bd31d56be7cfd9c/comments", "author": {"login": "fintelia", "id": 4943209, "node_id": "MDQ6VXNlcjQ5NDMyMDk=", "avatar_url": "https://avatars.githubusercontent.com/u/4943209?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fintelia", "html_url": "https://github.com/fintelia", "followers_url": "https://api.github.com/users/fintelia/followers", "following_url": "https://api.github.com/users/fintelia/following{/other_user}", "gists_url": "https://api.github.com/users/fintelia/gists{/gist_id}", "starred_url": "https://api.github.com/users/fintelia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fintelia/subscriptions", "organizations_url": "https://api.github.com/users/fintelia/orgs", "repos_url": "https://api.github.com/users/fintelia/repos", "events_url": "https://api.github.com/users/fintelia/events{/privacy}", "received_events_url": "https://api.github.com/users/fintelia/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fintelia", "id": 4943209, "node_id": "MDQ6VXNlcjQ5NDMyMDk=", "avatar_url": "https://avatars.githubusercontent.com/u/4943209?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fintelia", "html_url": "https://github.com/fintelia", "followers_url": "https://api.github.com/users/fintelia/followers", "following_url": "https://api.github.com/users/fintelia/following{/other_user}", "gists_url": "https://api.github.com/users/fintelia/gists{/gist_id}", "starred_url": "https://api.github.com/users/fintelia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fintelia/subscriptions", "organizations_url": "https://api.github.com/users/fintelia/orgs", "repos_url": "https://api.github.com/users/fintelia/repos", "events_url": "https://api.github.com/users/fintelia/events{/privacy}", "received_events_url": "https://api.github.com/users/fintelia/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c0f385d0c16c6797788ef5a5f42ac02ced50da1", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c0f385d0c16c6797788ef5a5f42ac02ced50da1", "html_url": "https://github.com/rust-lang/rust/commit/2c0f385d0c16c6797788ef5a5f42ac02ced50da1"}], "stats": {"total": 294, "additions": 156, "deletions": 138}, "files": [{"sha": "62e5cdcf90e8bd599c10849b876ee26ad488d552", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 156, "deletions": 138, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/dc41726de3a0088fd1f31b018bd31d56be7cfd9c/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc41726de3a0088fd1f31b018bd31d56be7cfd9c/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=dc41726de3a0088fd1f31b018bd31d56be7cfd9c", "patch": "@@ -435,29 +435,13 @@ fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, is_match: F) -> InternalE\n         return InternalEntry::TableIsEmpty;\n     }\n \n-    search_hashed_nonempty(table, hash, is_match)\n-}\n-\n-/// Search for a pre-hashed key.\n-/// If you don't already know the hash, use search or search_mut instead\n-#[inline]\n-fn search_hashed_mut<K, V, M, F>(table: M, hash: SafeHash, is_match: F) -> InternalEntry<K, V, M>\n-    where M: DerefMut<Target = RawTable<K, V>>,\n-          F: FnMut(&K) -> bool\n-{\n-    // This is the only function where capacity can be zero. To avoid\n-    // undefined behavior when Bucket::new gets the raw bucket in this\n-    // case, immediately return the appropriate search result.\n-    if table.capacity() == 0 {\n-        return InternalEntry::TableIsEmpty;\n-    }\n-\n-    search_hashed_nonempty_mut(table, hash, is_match)\n+    search_hashed_nonempty(table, hash, is_match, true)\n }\n \n /// Search for a pre-hashed key when the hash map is known to be non-empty.\n #[inline]\n-fn search_hashed_nonempty<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F)\n+fn search_hashed_nonempty<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F,\n+                                      compare_hashes: bool)\n     -> InternalEntry<K, V, M>\n     where M: Deref<Target = RawTable<K, V>>,\n           F: FnMut(&K) -> bool\n@@ -493,7 +477,7 @@ fn search_hashed_nonempty<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F)\n         }\n \n         // If the hash doesn't match, it can't be this one..\n-        if hash == full.hash() {\n+        if hash == full.hash() || !compare_hashes {\n             // If the key doesn't match, it can't be this one..\n             if is_match(full.read().0) {\n                 return InternalEntry::Occupied { elem: full };\n@@ -507,7 +491,8 @@ fn search_hashed_nonempty<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F)\n \n /// Search for a pre-hashed key when the hash map is known to be non-empty.\n #[inline]\n-fn search_hashed_nonempty_mut<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F)\n+fn search_hashed_nonempty_mut<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F,\n+                                          compare_hashes: bool)\n     -> InternalEntry<K, V, M>\n     where M: DerefMut<Target = RawTable<K, V>>,\n           F: FnMut(&K) -> bool\n@@ -543,7 +528,7 @@ fn search_hashed_nonempty_mut<K, V, M, F>(table: M, hash: SafeHash, mut is_match\n         }\n \n         // If the hash doesn't match, it can't be this one..\n-        if hash == full.hash() {\n+        if hash == full.hash() || !compare_hashes {\n             // If the key doesn't match, it can't be this one..\n             if is_match(full.read_mut().0) {\n                 return InternalEntry::Occupied { elem: full };\n@@ -660,7 +645,7 @@ impl<K, V, S> HashMap<K, V, S>\n         }\n \n         let hash = self.make_hash(q);\n-        search_hashed_nonempty(&self.table, hash, |k| q.eq(k.borrow()))\n+        search_hashed_nonempty(&self.table, hash, |k| q.eq(k.borrow()), true)\n             .into_occupied_bucket()\n     }\n \n@@ -675,7 +660,7 @@ impl<K, V, S> HashMap<K, V, S>\n         }\n \n         let hash = self.make_hash(q);\n-        search_hashed_nonempty(&mut self.table, hash, |k| q.eq(k.borrow()))\n+        search_hashed_nonempty(&mut self.table, hash, |k| q.eq(k.borrow()), true)\n             .into_occupied_bucket()\n     }\n \n@@ -1590,7 +1575,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// # Examples\n     ///\n     ///\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n     pub fn raw_entry_mut(&mut self) -> RawEntryBuilderMut<K, V, S> {\n         self.reserve(1);\n         RawEntryBuilderMut { map: self }\n@@ -1611,7 +1596,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// `get` should be preferred.\n     ///\n     /// Immutable raw entries have very limited use; you might instead want `raw_entry`.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n     pub fn raw_entry(&self) -> RawEntryBuilder<K, V, S> {\n         RawEntryBuilder { map: self }\n     }\n@@ -1860,7 +1845,7 @@ impl<'a, K, V> InternalEntry<K, V, &'a mut RawTable<K, V>> {\n /// A builder for computing where in a HashMap a key-value pair would be stored.\n ///\n /// See the [`HashMap::raw_entry_mut`][] docs for usage examples.\n-#[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n pub struct RawEntryBuilderMut<'a, K: 'a, V: 'a, S: 'a> {\n     map: &'a mut HashMap<K, V, S>,\n }\n@@ -1874,7 +1859,7 @@ pub struct RawEntryBuilderMut<'a, K: 'a, V: 'a, S: 'a> {\n /// [`HashMap`]: struct.HashMap.html\n /// [`Entry`]: struct.Entry.html\n /// [`raw_entry`]: struct.HashMap.html#method.raw_entry\n-#[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n pub enum RawEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n     /// An occupied entry.\n     Occupied(RawOccupiedEntryMut<'a, K, V>),\n@@ -1886,7 +1871,7 @@ pub enum RawEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n /// It is part of the [`RawEntryMut`] enum.\n ///\n /// [`RawEntryMut`]: enum.RawEntryMut.html\n-#[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n pub struct RawOccupiedEntryMut<'a, K: 'a, V: 'a> {\n     elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n }\n@@ -1895,7 +1880,7 @@ pub struct RawOccupiedEntryMut<'a, K: 'a, V: 'a> {\n /// It is part of the [`RawEntryMut`] enum.\n ///\n /// [`RawEntryMut`]: enum.RawEntryMut.html\n-#[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n pub struct RawVacantEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n     elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n     hash_builder: &'a S,\n@@ -1904,7 +1889,7 @@ pub struct RawVacantEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n /// A builder for computing where in a HashMap a key-value pair would be stored.\n ///\n /// See the [`HashMap::raw_entry`][] docs for usage examples.\n-#[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n pub struct RawEntryBuilder<'a, K: 'a, V: 'a, S: 'a> {\n     map: &'a HashMap<K, V, S>,\n }\n@@ -1914,7 +1899,7 @@ impl<'a, K, V, S> RawEntryBuilderMut<'a, K, V, S>\n           K: Eq + Hash,\n {\n     /// Create a `RawEntryMut` from the given key.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n     pub fn from_key<Q: ?Sized>(self, k: &Q) -> RawEntryMut<'a, K, V, S>\n         where K: Borrow<Q>,\n               Q: Hash + Eq\n@@ -1925,20 +1910,21 @@ impl<'a, K, V, S> RawEntryBuilderMut<'a, K, V, S>\n     }\n \n     /// Create a `RawEntryMut` from the given key and its hash.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n     pub fn from_key_hashed_nocheck<Q: ?Sized>(self, hash: u64, k: &Q) -> RawEntryMut<'a, K, V, S>\n         where K: Borrow<Q>,\n               Q: Eq\n     {\n         self.from_hash(hash, |q| q.borrow().eq(k))\n     }\n \n-    /// Create a `RawEntryMut` from the given hash.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n-    pub fn from_hash<F>(self, hash: u64, is_match: F) -> RawEntryMut<'a, K, V, S>\n+    fn search<F>(self, hash: u64, is_match: F, compare_hashes: bool)  -> RawEntryMut<'a, K, V, S>\n         where for<'b> F: FnMut(&'b K) -> bool,\n     {\n-        match search_hashed_mut(&mut self.map.table, SafeHash::new(hash), is_match) {\n+        match search_hashed_nonempty_mut(&mut self.map.table,\n+                                         SafeHash::new(hash),\n+                                         is_match,\n+                                         compare_hashes) {\n             InternalEntry::Occupied { elem } => {\n                 RawEntryMut::Occupied(RawOccupiedEntryMut { elem })\n             }\n@@ -1953,60 +1939,30 @@ impl<'a, K, V, S> RawEntryBuilderMut<'a, K, V, S>\n             }\n         }\n     }\n-\n-    /// Create a `RawEntryMut` by examining the elements of a hash bucket until `is_match` returns\n-    /// true for one of them.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n-    pub fn from_bucket<F>(self, hash_bucket: u64, mut is_match: F) -> RawEntryMut<'a, K, V, S>\n+    /// Create a `RawEntryMut` from the given hash.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn from_hash<F>(self, hash: u64, is_match: F) -> RawEntryMut<'a, K, V, S>\n         where for<'b> F: FnMut(&'b K) -> bool,\n     {\n-        let hash = SafeHash::new(hash_bucket);\n-\n-        let size = self.map.table.size();\n-        let mut probe = Bucket::new(&mut self.map.table, hash);\n-        let mut displacement = 0;\n-\n-        loop {\n-            let full = match probe.peek() {\n-                Empty(bucket) => {\n-                    // Found a hole!\n-                    return RawEntryMut::Vacant(RawVacantEntryMut {\n-                        elem: NoElem(bucket, displacement),\n-                        hash_builder: &self.map.hash_builder,\n-                    });\n-                }\n-                Full(bucket) => bucket,\n-            };\n-\n-            let probe_displacement = full.displacement();\n-\n-            if probe_displacement < displacement {\n-                // Found a luckier bucket than me.\n-                // We can finish the search early if we hit any bucket\n-                // with a lower distance to initial bucket than we've probed.\n-                return RawEntryMut::Vacant(RawVacantEntryMut {\n-                    elem: NeqElem(full, probe_displacement),\n-                    hash_builder: &self.map.hash_builder,\n-                })\n-            }\n-\n-            // Call is_match even if hash doesn't match hash_bucket.\n-            if is_match(full.read().0) {\n-                return RawEntryMut::Occupied(RawOccupiedEntryMut { elem: full });\n-            }\n+        self.search(hash, is_match, true)\n+    }\n \n-            displacement += 1;\n-            probe = full.next();\n-            debug_assert!(displacement <= size);\n-        }\n+    /// Search possible locations for an element with hash `hash` until `is_match` returns true for\n+    /// one of them. There is no guarantee that all keys passed to `is_match` will have the provided\n+    /// hash.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn search_bucket<F>(self, hash: u64, is_match: F) -> RawEntryMut<'a, K, V, S>\n+        where for<'b> F: FnMut(&'b K) -> bool,\n+    {\n+        self.search(hash, is_match, false)\n     }\n }\n \n impl<'a, K, V, S> RawEntryBuilder<'a, K, V, S>\n     where S: BuildHasher,\n {\n     /// Access an entry by key.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n     pub fn from_key<Q: ?Sized>(self, k: &Q) -> Option<(&'a K, &'a V)>\n         where K: Borrow<Q>,\n               Q: Hash + Eq\n@@ -2017,7 +1973,7 @@ impl<'a, K, V, S> RawEntryBuilder<'a, K, V, S>\n     }\n \n     /// Access an entry by a key and its hash.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n     pub fn from_key_hashed_nocheck<Q: ?Sized>(self, hash: u64, k: &Q) -> Option<(&'a K, &'a V)>\n         where K: Borrow<Q>,\n               Q: Hash + Eq\n@@ -2026,17 +1982,36 @@ impl<'a, K, V, S> RawEntryBuilder<'a, K, V, S>\n         self.from_hash(hash, |q| q.borrow().eq(k))\n     }\n \n-    /// Access an entry by hash.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n-    pub fn from_hash<F>(self, hash: u64, is_match: F) -> Option<(&'a K, &'a V)>\n+    fn search<F>(self, hash: u64, is_match: F, compare_hashes: bool) -> Option<(&'a K, &'a V)>\n         where F: FnMut(&K) -> bool\n     {\n-        match search_hashed(&self.map.table, SafeHash::new(hash), is_match) {\n+        match search_hashed_nonempty(&self.map.table,\n+                                     SafeHash::new(hash),\n+                                     is_match,\n+                                     compare_hashes) {\n             InternalEntry::Occupied { elem } => Some(elem.into_refs()),\n             InternalEntry::Vacant { .. } => None,\n             InternalEntry::TableIsEmpty => unreachable!(),\n         }\n     }\n+\n+    /// Access an entry by hash.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn from_hash<F>(self, hash: u64, is_match: F) -> Option<(&'a K, &'a V)>\n+        where F: FnMut(&K) -> bool\n+    {\n+        self.search(hash, is_match, true)\n+    }\n+\n+    /// Search possible locations for an element with hash `hash` until `is_match` returns true for\n+    /// one of them. There is no guarantee that all keys passed to `is_match` will have the provided\n+    /// hash.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n+    pub fn search_bucket<F>(self, hash: u64, is_match: F) -> Option<(&'a K, &'a V)>\n+        where F: FnMut(&K) -> bool\n+    {\n+        self.search(hash, is_match, false)\n+    }\n }\n \n impl<'a, K, V, S> RawEntryMut<'a, K, V, S> {\n@@ -2046,17 +2021,18 @@ impl<'a, K, V, S> RawEntryMut<'a, K, V, S> {\n     /// # Examples\n     ///\n     /// ```\n+    /// #![feature(hash_raw_entry)]\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map: HashMap<&str, u32> = HashMap::new();\n-    /// map.raw_entry().search_by(\"poneyland\").or_insert(\"poneyland\", 12);\n+    /// map.raw_entry_mut().from_key(\"poneyland\").or_insert(\"poneyland\", 12);\n     ///\n     /// assert_eq!(map[\"poneyland\"], 12);\n     ///\n-    /// *map.raw_entry().search_by(\"poneyland\").or_insert(\"poneyland\", 12).1 += 10;\n+    /// *map.raw_entry_mut().from_key(\"poneyland\").or_insert(\"poneyland\", 12).1 += 10;\n     /// assert_eq!(map[\"poneyland\"], 22);\n     /// ```\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n     pub fn or_insert(self, default_key: K, default_val: V) -> (&'a mut K, &'a mut V)\n         where K: Hash,\n               S: BuildHasher,\n@@ -2073,17 +2049,18 @@ impl<'a, K, V, S> RawEntryMut<'a, K, V, S> {\n     /// # Examples\n     ///\n     /// ```\n+    /// #![feature(hash_raw_entry)]\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map: HashMap<&str, String> = HashMap::new();\n     ///\n-    /// map.raw_entry().search_by(\"poneyland\").or_insert_with(|| {\n-    ///     (\"poneyland\".to_string(), \"hoho\".to_string())\n+    /// map.raw_entry_mut().from_key(\"poneyland\").or_insert_with(|| {\n+    ///     (\"poneyland\", \"hoho\".to_string())\n     /// });\n     ///\n     /// assert_eq!(map[\"poneyland\"], \"hoho\".to_string());\n     /// ```\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n     pub fn or_insert_with<F>(self, default: F) -> (&'a mut K, &'a mut V)\n         where F: FnOnce() -> (K, V),\n               K: Hash,\n@@ -2104,23 +2081,24 @@ impl<'a, K, V, S> RawEntryMut<'a, K, V, S> {\n     /// # Examples\n     ///\n     /// ```\n+    /// #![feature(hash_raw_entry)]\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map: HashMap<&str, u32> = HashMap::new();\n     ///\n-    /// map.raw_entry()\n-    ///    .search_by(\"poneyland\")\n+    /// map.raw_entry_mut()\n+    ///    .from_key(\"poneyland\")\n     ///    .and_modify(|_k, v| { *v += 1 })\n     ///    .or_insert(\"poneyland\", 42);\n     /// assert_eq!(map[\"poneyland\"], 42);\n     ///\n-    /// map.raw_entry()\n-    ///    .search_by(\"poneyland\")\n+    /// map.raw_entry_mut()\n+    ///    .from_key(\"poneyland\")\n     ///    .and_modify(|_k, v| { *v += 1 })\n-    ///    .or_insert(\"poneyland\", 42);\n+    ///    .or_insert(\"poneyland\", 0);\n     /// assert_eq!(map[\"poneyland\"], 43);\n     /// ```\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n     pub fn and_modify<F>(self, f: F) -> Self\n         where F: FnOnce(&mut K, &mut V)\n     {\n@@ -2139,83 +2117,82 @@ impl<'a, K, V, S> RawEntryMut<'a, K, V, S> {\n \n impl<'a, K, V> RawOccupiedEntryMut<'a, K, V> {\n     /// Gets a reference to the key in the entry.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n     pub fn key(&self) -> &K {\n         self.elem.read().0\n     }\n \n     /// Gets a mutable reference to the key in the entry.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n     pub fn key_mut(&mut self) -> &mut K {\n         self.elem.read_mut().0\n     }\n \n     /// Converts the entry into a mutable reference to the key in the entry\n     /// with a lifetime bound to the map itself.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n     pub fn into_key(self) -> &'a mut K {\n         self.elem.into_mut_refs().0\n     }\n \n     /// Gets a reference to the value in the entry.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n     pub fn get(&self) -> &V {\n         self.elem.read().1\n     }\n \n     /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n     /// with a lifetime bound to the map itself.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n     pub fn into_mut(self) -> &'a mut V {\n         self.elem.into_mut_refs().1\n     }\n \n     /// Gets a mutable reference to the value in the entry.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n     pub fn get_mut(&mut self) -> &mut V {\n         self.elem.read_mut().1\n     }\n \n     /// Gets a reference to the key and value in the entry.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n     pub fn get_key_value(&mut self) -> (&K, &V) {\n         self.elem.read()\n     }\n \n     /// Gets a mutable reference to the key and value in the entry.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n     pub fn get_key_value_mut(&mut self) -> (&mut K, &mut V) {\n         self.elem.read_mut()\n     }\n \n     /// Converts the OccupiedEntry into a mutable reference to the key and value in the entry\n     /// with a lifetime bound to the map itself.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n     pub fn into_key_value(self) -> (&'a mut K, &'a mut V) {\n         self.elem.into_mut_refs()\n     }\n \n     /// Sets the value of the entry, and returns the entry's old value.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n     pub fn insert(&mut self, value: V) -> V {\n         mem::replace(self.get_mut(), value)\n     }\n \n     /// Sets the value of the entry, and returns the entry's old value.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n     pub fn insert_key(&mut self, key: K) -> K {\n         mem::replace(self.key_mut(), key)\n     }\n \n     /// Takes the value out of the entry, and returns it.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n     pub fn remove(self) -> V {\n         pop_internal(self.elem).1\n     }\n \n-\n     /// Take the ownership of the key and value from the map.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n     pub fn remove_entry(self) -> (K, V) {\n         let (k, v, _) = pop_internal(self.elem);\n         (k, v)\n@@ -2225,7 +2202,7 @@ impl<'a, K, V> RawOccupiedEntryMut<'a, K, V> {\n impl<'a, K, V, S> RawVacantEntryMut<'a, K, V, S> {\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n     pub fn insert(self, key: K, value: V) -> (&'a mut K, &'a mut V)\n         where K: Hash,\n               S: BuildHasher,\n@@ -2237,7 +2214,7 @@ impl<'a, K, V, S> RawVacantEntryMut<'a, K, V, S> {\n \n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n     pub fn insert_hashed_nocheck(self, hash: u64, key: K, value: V) -> (&'a mut K, &'a mut V) {\n         let hash = SafeHash::new(hash);\n         let b = match self.elem {\n@@ -2258,15 +2235,15 @@ impl<'a, K, V, S> RawVacantEntryMut<'a, K, V, S> {\n     }\n }\n \n-#[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n impl<'a, K, V, S> Debug for RawEntryBuilderMut<'a, K, V, S> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_struct(\"RawEntryBuilder\")\n          .finish()\n     }\n }\n \n-#[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n impl<'a, K: Debug, V: Debug, S> Debug for RawEntryMut<'a, K, V, S> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -2284,7 +2261,7 @@ impl<'a, K: Debug, V: Debug, S> Debug for RawEntryMut<'a, K, V, S> {\n     }\n }\n \n-#[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n impl<'a, K: Debug, V: Debug> Debug for RawOccupiedEntryMut<'a, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_struct(\"RawOccupiedEntryMut\")\n@@ -2294,15 +2271,15 @@ impl<'a, K: Debug, V: Debug> Debug for RawOccupiedEntryMut<'a, K, V> {\n     }\n }\n \n-#[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n impl<'a, K, V, S> Debug for RawVacantEntryMut<'a, K, V, S> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_struct(\"RawVacantEntryMut\")\n          .finish()\n     }\n }\n \n-#[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+#[unstable(feature = \"hash_raw_entry\", issue = \"54043\")]\n impl<'a, K, V, S> Debug for RawEntryBuilder<'a, K, V, S> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_struct(\"RawEntryBuilder\")\n@@ -4271,63 +4248,104 @@ mod test_map {\n \n     #[test]\n     fn test_raw_entry() {\n-        use super::RawEntry::{Occupied, Vacant};\n+        use super::RawEntryMut::{Occupied, Vacant};\n \n         let xs = [(1i32, 10i32), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n \n         let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n \n+        let compute_hash = |map: &HashMap<i32, i32>, k: i32| -> u64 {\n+            use core::hash::{BuildHasher, Hash, Hasher};\n+\n+            let mut hasher = map.hasher().build_hasher();\n+            k.hash(&mut hasher);\n+            hasher.finish()\n+        };\n+\n         // Existing key (insert)\n-        match map.raw_entry().search_by(&1) {\n+        match map.raw_entry_mut().from_key(&1) {\n             Vacant(_) => unreachable!(),\n             Occupied(mut view) => {\n                 assert_eq!(view.get(), &10);\n                 assert_eq!(view.insert(100), 10);\n             }\n         }\n-        assert_eq!(map.raw_entry_immut().hash_with(|mut h| {\n-            1i32.hash(&mut h);\n-            h.finish()\n-        }).search_with(|k| *k == 1)\n-          .unwrap(), (&10, &100));\n+        let hash1 = compute_hash(&map, 1);\n+        assert_eq!(map.raw_entry().from_key(&1).unwrap(), (&1, &100));\n+        assert_eq!(map.raw_entry().from_hash(hash1, |k| *k == 1).unwrap(), (&1, &100));\n+        assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash1, &1).unwrap(), (&1, &100));\n+        assert_eq!(map.raw_entry().search_bucket(hash1, |k| *k == 1).unwrap(), (&1, &100));\n         assert_eq!(map.len(), 6);\n \n-\n         // Existing key (update)\n-        match map.raw_entry().hash_by(&2).search_by(&2) {\n+        match map.raw_entry_mut().from_key(&2) {\n             Vacant(_) => unreachable!(),\n             Occupied(mut view) => {\n                 let v = view.get_mut();\n                 let new_v = (*v) * 10;\n                 *v = new_v;\n             }\n         }\n-        assert_eq!(map.raw_entry_immut().search_by(&2).unwrap(), (&2, &200));\n+        let hash2 = compute_hash(&map, 2);\n+        assert_eq!(map.raw_entry().from_key(&2).unwrap(), (&2, &200));\n+        assert_eq!(map.raw_entry().from_hash(hash2, |k| *k == 2).unwrap(), (&2, &200));\n+        assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash2, &2).unwrap(), (&2, &200));\n+        assert_eq!(map.raw_entry().search_bucket(hash2, |k| *k == 2).unwrap(), (&2, &200));\n         assert_eq!(map.len(), 6);\n \n         // Existing key (take)\n-        match map.raw_entry().hash_with(|mut h| {\n-            3i32.hash(&mut h);\n-            h.finish()\n-        }).search_with(|k| *k == 3) {\n+        let hash3 = compute_hash(&map, 3);\n+        match map.raw_entry_mut().from_key_hashed_nocheck(hash3, &3) {\n             Vacant(_) => unreachable!(),\n             Occupied(view) => {\n-                assert_eq!(view.remove_key_value(), (3, 30));\n+                assert_eq!(view.remove_entry(), (3, 30));\n             }\n         }\n-        assert_eq!(map.raw_entry_immut().search_by(&3), None);\n+        assert_eq!(map.raw_entry().from_key(&3), None);\n+        assert_eq!(map.raw_entry().from_hash(hash3, |k| *k == 3), None);\n+        assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash3, &3), None);\n+        assert_eq!(map.raw_entry().search_bucket(hash3, |k| *k == 3), None);\n         assert_eq!(map.len(), 5);\n \n \n-        // Inexistent key (insert)\n-        match map.raw_entry().search_by(&10) {\n+        // Nonexistent key (insert)\n+        match map.raw_entry_mut().from_key(&10) {\n             Occupied(_) => unreachable!(),\n             Vacant(view) => {\n                 assert_eq!(view.insert(10, 1000), (&mut 10, &mut 1000));\n             }\n         }\n-        assert_eq!(map.raw_entry_immut().hash_by(&10).search_by(&10).unwrap(), (&10, &1000));\n+        assert_eq!(map.raw_entry().from_key(&10).unwrap(), (&10, &1000));\n         assert_eq!(map.len(), 6);\n+\n+        // Ensure all lookup methods produce equivalent results.\n+        for k in 0..12 {\n+            let hash = compute_hash(&map, k);\n+            let v = map.get(&k).cloned();\n+            let kv = v.as_ref().map(|v| (&k, v));\n+\n+            assert_eq!(map.raw_entry().from_key(&k), kv);\n+            assert_eq!(map.raw_entry().from_hash(hash, |q| *q == k), kv);\n+            assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash, &k), kv);\n+            assert_eq!(map.raw_entry().search_bucket(hash, |q| *q == k), kv);\n+\n+            match map.raw_entry_mut().from_key(&k) {\n+                Occupied(mut o) => assert_eq!(Some(o.get_key_value()), kv),\n+                Vacant(_) => assert_eq!(v, None),\n+            }\n+            match map.raw_entry_mut().from_key_hashed_nocheck(hash, &k) {\n+                Occupied(mut o) => assert_eq!(Some(o.get_key_value()), kv),\n+                Vacant(_) => assert_eq!(v, None),\n+            }\n+            match map.raw_entry_mut().from_hash(hash, |q| *q == k) {\n+                Occupied(mut o) => assert_eq!(Some(o.get_key_value()), kv),\n+                Vacant(_) => assert_eq!(v, None),\n+            }\n+            match map.raw_entry_mut().search_bucket(hash, |q| *q == k) {\n+                Occupied(mut o) => assert_eq!(Some(o.get_key_value()), kv),\n+                Vacant(_) => assert_eq!(v, None),\n+            }\n+        }\n     }\n \n }"}]}