{"sha": "869c96dbf088203867c62776c9c28a19658edd8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2OWM5NmRiZjA4ODIwMzg2N2M2Mjc3NmM5YzI4YTE5NjU4ZWRkOGQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-06T15:08:00Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-17T07:53:06Z"}, "message": "De-@ type checking contexts.", "tree": {"sha": "887703cce6879eea9cfd31f0c6124078241c5a26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/887703cce6879eea9cfd31f0c6124078241c5a26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/869c96dbf088203867c62776c9c28a19658edd8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/869c96dbf088203867c62776c9c28a19658edd8d", "html_url": "https://github.com/rust-lang/rust/commit/869c96dbf088203867c62776c9c28a19658edd8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/869c96dbf088203867c62776c9c28a19658edd8d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6879916a060218cbbec69a235efd7b6da9b32021", "url": "https://api.github.com/repos/rust-lang/rust/commits/6879916a060218cbbec69a235efd7b6da9b32021", "html_url": "https://github.com/rust-lang/rust/commit/6879916a060218cbbec69a235efd7b6da9b32021"}], "stats": {"total": 269, "additions": 136, "deletions": 133}, "files": [{"sha": "557b6fce22874a33d86986c21736bbce0e38f7de", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/869c96dbf088203867c62776c9c28a19658edd8d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/869c96dbf088203867c62776c9c28a19658edd8d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=869c96dbf088203867c62776c9c28a19658edd8d", "patch": "@@ -20,7 +20,7 @@\n  * `AstConv` instance; in this phase, the `get_item_ty()` function\n  * triggers a recursive call to `ty_of_item()`  (note that\n  * `ast_ty_to_ty()` will detect recursive types and report an error).\n- * In the check phase, when the @FnCtxt is used as the `AstConv`,\n+ * In the check phase, when the FnCtxt is used as the `AstConv`,\n  * `get_item_ty()` just looks up the item type in `tcx.tcache`.\n  *\n  * The `RegionScope` trait controls what happens when the user does"}, {"sha": "bfb0ab6400d38dec4dffd6329a6a8be339e4d9f6", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/869c96dbf088203867c62776c9c28a19658edd8d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/869c96dbf088203867c62776c9c28a19658edd8d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=869c96dbf088203867c62776c9c28a19658edd8d", "patch": "@@ -27,7 +27,7 @@ use syntax::parse::token;\n use syntax::codemap::Span;\n use syntax::print::pprust;\n \n-pub fn check_match(fcx: @FnCtxt,\n+pub fn check_match(fcx: &FnCtxt,\n                    expr: &ast::Expr,\n                    discrim: &ast::Expr,\n                    arms: &[ast::Arm]) {\n@@ -104,7 +104,7 @@ pub fn check_match(fcx: @FnCtxt,\n }\n \n pub struct pat_ctxt<'a> {\n-    fcx: @FnCtxt<'a>,\n+    fcx: &'a FnCtxt<'a>,\n     map: PatIdMap,\n }\n "}, {"sha": "dc9aa1b7e8cb23c257c46a6d3826936b7ef85069", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/869c96dbf088203867c62776c9c28a19658edd8d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/869c96dbf088203867c62776c9c28a19658edd8d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=869c96dbf088203867c62776c9c28a19658edd8d", "patch": "@@ -46,7 +46,7 @@ pub fn suptype_with_fn(fcx: &FnCtxt,\n     }\n }\n \n-pub fn eqtype(fcx: @FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n+pub fn eqtype(fcx: &FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n     match infer::mk_eqty(fcx.infcx(), false, infer::Misc(sp), actual, expected) {\n         Ok(()) => { /* ok */ }\n         Err(ref err) => {\n@@ -56,7 +56,7 @@ pub fn eqtype(fcx: @FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n }\n \n // Checks that the type `actual` can be coerced to `expected`.\n-pub fn coerce(fcx: @FnCtxt, sp: Span, expected: ty::t, expr: &ast::Expr) {\n+pub fn coerce(fcx: &FnCtxt, sp: Span, expected: ty::t, expr: &ast::Expr) {\n     let expr_ty = fcx.expr_ty(expr);\n     match fcx.mk_assignty(expr, expr_ty, expected) {\n       result::Ok(()) => { /* ok */ }"}, {"sha": "78f0ea664f54fd2cdee88f3b423a138d6f4221f9", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/869c96dbf088203867c62776c9c28a19658edd8d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/869c96dbf088203867c62776c9c28a19658edd8d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=869c96dbf088203867c62776c9c28a19658edd8d", "patch": "@@ -120,7 +120,7 @@ pub enum AutoderefReceiverFlag {\n }\n \n pub fn lookup<'a>(\n-        fcx: @FnCtxt,\n+        fcx: &'a FnCtxt<'a>,\n \n         // In a call `a.b::<X, Y, ...>(...)`:\n         expr: &ast::Expr,                   // The expression `a.b(...)`.\n@@ -165,7 +165,7 @@ pub fn lookup<'a>(\n }\n \n pub fn lookup_in_trait<'a>(\n-        fcx: @FnCtxt,\n+        fcx: &'a FnCtxt<'a>,\n \n         // In a call `a.b::<X, Y, ...>(...)`:\n         span: Span,                         // The expression `a.b(...)`'s span.\n@@ -199,7 +199,7 @@ pub fn lookup_in_trait<'a>(\n }\n \n struct LookupContext<'a> {\n-    fcx: @FnCtxt<'a>,\n+    fcx: &'a FnCtxt<'a>,\n     span: Span,\n \n     // The receiver to the method call. Only `None` in the case of\n@@ -1351,7 +1351,7 @@ impl<'a> LookupContext<'a> {\n             }\n         }\n \n-        fn rcvr_matches_ty(fcx: @FnCtxt,\n+        fn rcvr_matches_ty(fcx: &FnCtxt,\n                            rcvr_ty: ty::t,\n                            candidate: &Candidate) -> bool {\n             match candidate.rcvr_match_condition {"}, {"sha": "28e6f31019dffa8788c7b23ae89e8f3f3c12e384", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 104, "deletions": 97, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/869c96dbf088203867c62776c9c28a19658edd8d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/869c96dbf088203867c62776c9c28a19658edd8d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=869c96dbf088203867c62776c9c28a19658edd8d", "patch": "@@ -251,9 +251,9 @@ pub struct FnCtxt<'a> {\n     // function return type.\n     fn_kind: FnKind,\n \n-    inh: @Inherited<'a>,\n+    inh: &'a Inherited<'a>,\n \n-    ccx: @CrateCtxt<'a>,\n+    ccx: &'a CrateCtxt<'a>,\n }\n \n impl<'a> Inherited<'a> {\n@@ -275,26 +275,31 @@ impl<'a> Inherited<'a> {\n }\n \n // Used by check_const and check_enum_variants\n-pub fn blank_fn_ctxt<'a>(ccx: @CrateCtxt<'a>,\n-                         rty: ty::t,\n-                         region_bnd: ast::NodeId)\n-                         -> @FnCtxt<'a> {\n-    // It's kind of a kludge to manufacture a fake function context\n-    // and statement context, but we might as well do write the code only once\n-    let param_env = ty::ParameterEnvironment { free_substs: substs::empty(),\n-                                               self_param_bound: None,\n-                                               type_param_bounds: Vec::new() };\n-    @FnCtxt {\n+fn blank_fn_ctxt<'a>(ccx: &'a CrateCtxt<'a>,\n+                     inh: &'a Inherited<'a>,\n+                     rty: ty::t,\n+                     region_bnd: ast::NodeId)\n+                     -> FnCtxt<'a> {\n+    FnCtxt {\n         err_count_on_creation: ccx.tcx.sess.err_count(),\n         ret_ty: rty,\n         ps: RefCell::new(PurityState::function(ast::ImpureFn, 0)),\n         region_lb: Cell::new(region_bnd),\n         fn_kind: Vanilla,\n-        inh: @Inherited::new(ccx.tcx, param_env),\n+        inh: inh,\n         ccx: ccx\n     }\n }\n \n+fn blank_inherited_fields<'a>(ccx: &'a CrateCtxt<'a>) -> Inherited<'a> {\n+    // It's kind of a kludge to manufacture a fake function context\n+    // and statement context, but we might as well do write the code only once\n+    let param_env = ty::ParameterEnvironment { free_substs: substs::empty(),\n+                                               self_param_bound: None,\n+                                               type_param_bounds: Vec::new() };\n+    Inherited::new(ccx.tcx, param_env)\n+}\n+\n impl<'a> ExprTyProvider for FnCtxt<'a> {\n     fn expr_ty(&self, ex: &ast::Expr) -> ty::t {\n         self.expr_ty(ex)\n@@ -305,7 +310,7 @@ impl<'a> ExprTyProvider for FnCtxt<'a> {\n     }\n }\n \n-struct CheckItemTypesVisitor<'a> { ccx: @CrateCtxt<'a> }\n+struct CheckItemTypesVisitor<'a> { ccx: &'a CrateCtxt<'a> }\n \n impl<'a> Visitor<()> for CheckItemTypesVisitor<'a> {\n     fn visit_item(&mut self, i: &ast::Item, _: ()) {\n@@ -314,34 +319,34 @@ impl<'a> Visitor<()> for CheckItemTypesVisitor<'a> {\n     }\n }\n \n-pub fn check_item_types(ccx: @CrateCtxt, krate: &ast::Crate) {\n+pub fn check_item_types(ccx: &CrateCtxt, krate: &ast::Crate) {\n     let mut visit = CheckItemTypesVisitor { ccx: ccx };\n     visit::walk_crate(&mut visit, krate, ());\n }\n \n-fn check_bare_fn(ccx: @CrateCtxt,\n+fn check_bare_fn(ccx: &CrateCtxt,\n                  decl: &ast::FnDecl,\n                  body: &ast::Block,\n                  id: ast::NodeId,\n                  fty: ty::t,\n                  param_env: ty::ParameterEnvironment) {\n     match ty::get(fty).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n-            let fcx =\n-                check_fn(ccx, fn_ty.purity, &fn_ty.sig, decl, id, body,\n-                         Vanilla, @Inherited::new(ccx.tcx, param_env));\n+            let inh = Inherited::new(ccx.tcx, param_env);\n+            let fcx = check_fn(ccx, fn_ty.purity, &fn_ty.sig,\n+                               decl, id, body, Vanilla, &inh);\n \n-            vtable::resolve_in_block(fcx, body);\n-            regionck::regionck_fn(fcx, body);\n-            writeback::resolve_type_vars_in_fn(fcx, decl, body);\n+            vtable::resolve_in_block(&fcx, body);\n+            regionck::regionck_fn(&fcx, body);\n+            writeback::resolve_type_vars_in_fn(&fcx, decl, body);\n         }\n         _ => ccx.tcx.sess.impossible_case(body.span,\n                                  \"check_bare_fn: function type expected\")\n     }\n }\n \n struct GatherLocalsVisitor<'a> {\n-    fcx: @FnCtxt<'a>\n+    fcx: &'a FnCtxt<'a>\n }\n \n impl<'a> GatherLocalsVisitor<'a> {\n@@ -415,14 +420,14 @@ impl<'a> Visitor<()> for GatherLocalsVisitor<'a> {\n \n }\n \n-fn check_fn<'a>(ccx: @CrateCtxt<'a>,\n+fn check_fn<'a>(ccx: &'a CrateCtxt<'a>,\n                 purity: ast::Purity,\n                 fn_sig: &ty::FnSig,\n                 decl: &ast::FnDecl,\n                 id: ast::NodeId,\n                 body: &ast::Block,\n                 fn_kind: FnKind,\n-                inherited: @Inherited<'a>) -> @FnCtxt<'a>\n+                inherited: &'a Inherited<'a>) -> FnCtxt<'a>\n {\n     /*!\n      * Helper used by check_bare_fn and check_expr_fn.  Does the\n@@ -454,7 +459,7 @@ fn check_fn<'a>(ccx: @CrateCtxt<'a>,\n \n     // Create the function context.  This is either derived from scratch or,\n     // in the case of function expressions, based on the outer context.\n-    let fcx = @FnCtxt {\n+    let fcx = FnCtxt {\n         err_count_on_creation: err_count_on_creation,\n         ret_ty: ret_ty,\n         ps: RefCell::new(PurityState::function(purity, id)),\n@@ -466,7 +471,7 @@ fn check_fn<'a>(ccx: @CrateCtxt<'a>,\n \n     {\n \n-        let mut visit = GatherLocalsVisitor { fcx: fcx, };\n+        let mut visit = GatherLocalsVisitor { fcx: &fcx, };\n         // Add formal parameters.\n         for (arg_ty, input) in arg_tys.iter().zip(decl.inputs.iter()) {\n             // Create type variables for each argument.\n@@ -478,7 +483,7 @@ fn check_fn<'a>(ccx: @CrateCtxt<'a>,\n \n             // Check the pattern.\n             let pcx = pat_ctxt {\n-                fcx: fcx,\n+                fcx: &fcx,\n                 map: pat_id_map(tcx.def_map, input.pat),\n             };\n             _match::check_pat(&pcx, input.pat, *arg_ty);\n@@ -487,15 +492,15 @@ fn check_fn<'a>(ccx: @CrateCtxt<'a>,\n         visit.visit_block(body, ());\n     }\n \n-    check_block_with_expected(fcx, body, Some(ret_ty));\n+    check_block_with_expected(&fcx, body, Some(ret_ty));\n \n     // We unify the tail expr's type with the\n     // function result type, if there is a tail expr.\n     match body.expr {\n         Some(tail_expr) => {\n             // Special case: we print a special error if there appears\n             // to be do-block/for-loop confusion\n-            demand::suptype_with_fn(fcx, tail_expr.span, false,\n+            demand::suptype_with_fn(&fcx, tail_expr.span, false,\n                 fcx.ret_ty, fcx.expr_ty(tail_expr),\n                 |sp, e, a, s| {\n                     fcx.report_mismatched_return_types(sp, e, a, s);\n@@ -532,7 +537,7 @@ pub fn check_no_duplicate_fields(tcx: &ty::ctxt,\n     }\n }\n \n-pub fn check_struct(ccx: @CrateCtxt, id: ast::NodeId, span: Span) {\n+pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n     let tcx = ccx.tcx;\n \n     // Check that the struct is representable\n@@ -546,7 +551,7 @@ pub fn check_struct(ccx: @CrateCtxt, id: ast::NodeId, span: Span) {\n     }\n }\n \n-pub fn check_item(ccx: @CrateCtxt, it: &ast::Item) {\n+pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n     debug!(\"check_item(it.id={}, it.ident={})\",\n            it.id,\n            ty::item_path_str(ccx.tcx, local_def(it.id)));\n@@ -648,7 +653,7 @@ pub fn check_item(ccx: @CrateCtxt, it: &ast::Item) {\n     }\n }\n \n-fn check_method_body(ccx: @CrateCtxt,\n+fn check_method_body(ccx: &CrateCtxt,\n                      item_generics: &ty::Generics,\n                      self_bound: Option<@ty::TraitRef>,\n                      method: &ast::Method) {\n@@ -689,7 +694,7 @@ fn check_method_body(ccx: @CrateCtxt,\n     check_bare_fn(ccx, method.decl, method.body, method.id, fty, param_env);\n }\n \n-fn check_impl_methods_against_trait(ccx: @CrateCtxt,\n+fn check_impl_methods_against_trait(ccx: &CrateCtxt,\n                                     impl_span: Span,\n                                     impl_generics: &ty::Generics,\n                                     ast_trait_ref: &ast::TraitRef,\n@@ -1240,7 +1245,7 @@ pub enum LvaluePreference {\n     NoPreference\n }\n \n-pub fn autoderef<T>(fcx: @FnCtxt, sp: Span, base_ty: ty::t,\n+pub fn autoderef<T>(fcx: &FnCtxt, sp: Span, base_ty: ty::t,\n                     expr_id: Option<ast::NodeId>,\n                     mut lvalue_pref: LvaluePreference,\n                     should_stop: |ty::t, uint| -> Option<T>)\n@@ -1291,7 +1296,7 @@ pub fn autoderef<T>(fcx: @FnCtxt, sp: Span, base_ty: ty::t,\n     (ty::mk_err(), 0, None)\n }\n \n-fn try_overloaded_deref(fcx: @FnCtxt,\n+fn try_overloaded_deref(fcx: &FnCtxt,\n                         span: Span,\n                         method_call: Option<MethodCall>,\n                         base_expr: Option<&ast::Expr>,\n@@ -1334,7 +1339,7 @@ fn try_overloaded_deref(fcx: @FnCtxt,\n }\n \n // AST fragment checking\n-pub fn check_lit(fcx: @FnCtxt, lit: &ast::Lit) -> ty::t {\n+pub fn check_lit(fcx: &FnCtxt, lit: &ast::Lit) -> ty::t {\n     let tcx = fcx.ccx.tcx;\n \n     match lit.node {\n@@ -1362,7 +1367,7 @@ pub fn check_lit(fcx: @FnCtxt, lit: &ast::Lit) -> ty::t {\n     }\n }\n \n-pub fn valid_range_bounds(ccx: @CrateCtxt,\n+pub fn valid_range_bounds(ccx: &CrateCtxt,\n                           from: &ast::Expr,\n                           to: &ast::Expr)\n                        -> Option<bool> {\n@@ -1373,40 +1378,40 @@ pub fn valid_range_bounds(ccx: @CrateCtxt,\n }\n \n pub fn check_expr_has_type(\n-    fcx: @FnCtxt, expr: &ast::Expr,\n+    fcx: &FnCtxt, expr: &ast::Expr,\n     expected: ty::t) {\n     check_expr_with_unifier(fcx, expr, Some(expected), NoPreference, || {\n         demand::suptype(fcx, expr.span, expected, fcx.expr_ty(expr));\n     });\n }\n \n-fn check_expr_coercable_to_type(fcx: @FnCtxt, expr: &ast::Expr, expected: ty::t) {\n+fn check_expr_coercable_to_type(fcx: &FnCtxt, expr: &ast::Expr, expected: ty::t) {\n     check_expr_with_unifier(fcx, expr, Some(expected), NoPreference, || {\n         demand::coerce(fcx, expr.span, expected, expr)\n     });\n }\n \n-fn check_expr_with_hint(fcx: @FnCtxt, expr: &ast::Expr, expected: ty::t) {\n+fn check_expr_with_hint(fcx: &FnCtxt, expr: &ast::Expr, expected: ty::t) {\n     check_expr_with_unifier(fcx, expr, Some(expected), NoPreference, || ())\n }\n \n-fn check_expr_with_opt_hint(fcx: @FnCtxt, expr: &ast::Expr,\n+fn check_expr_with_opt_hint(fcx: &FnCtxt, expr: &ast::Expr,\n                             expected: Option<ty::t>)  {\n     check_expr_with_unifier(fcx, expr, expected, NoPreference, || ())\n }\n \n-fn check_expr_with_opt_hint_and_lvalue_pref(fcx: @FnCtxt,\n+fn check_expr_with_opt_hint_and_lvalue_pref(fcx: &FnCtxt,\n                                             expr: &ast::Expr,\n                                             expected: Option<ty::t>,\n                                             lvalue_pref: LvaluePreference) {\n     check_expr_with_unifier(fcx, expr, expected, lvalue_pref, || ())\n }\n \n-fn check_expr(fcx: @FnCtxt, expr: &ast::Expr)  {\n+fn check_expr(fcx: &FnCtxt, expr: &ast::Expr)  {\n     check_expr_with_unifier(fcx, expr, None, NoPreference, || ())\n }\n \n-fn check_expr_with_lvalue_pref(fcx: @FnCtxt, expr: &ast::Expr,\n+fn check_expr_with_lvalue_pref(fcx: &FnCtxt, expr: &ast::Expr,\n                                lvalue_pref: LvaluePreference)  {\n     check_expr_with_unifier(fcx, expr, None, lvalue_pref, || ())\n }\n@@ -1477,7 +1482,7 @@ fn generics_of_static_method_container(type_context: &ty::ctxt,\n \n // Verifies that type parameters supplied in paths are in the right\n // locations.\n-fn check_type_parameter_positions_in_path(function_context: @FnCtxt,\n+fn check_type_parameter_positions_in_path(function_context: &FnCtxt,\n                                           path: &ast::Path,\n                                           def: ast::Def) {\n     // We only care about checking the case in which the path has two or\n@@ -1634,15 +1639,15 @@ fn check_type_parameter_positions_in_path(function_context: @FnCtxt,\n /// Note that inspecting a type's structure *directly* may expose the fact\n /// that there are actually multiple representations for both `ty_err` and\n /// `ty_bot`, so avoid that when err and bot need to be handled differently.\n-fn check_expr_with_unifier(fcx: @FnCtxt,\n+fn check_expr_with_unifier(fcx: &FnCtxt,\n                            expr: &ast::Expr,\n                            expected: Option<ty::t>,\n                            lvalue_pref: LvaluePreference,\n                            unifier: ||) {\n     debug!(\">> typechecking\");\n \n     fn check_method_argument_types(\n-        fcx: @FnCtxt,\n+        fcx: &FnCtxt,\n         sp: Span,\n         method_fn_ty: ty::t,\n         callee_expr: &ast::Expr,\n@@ -1673,7 +1678,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         }\n     }\n \n-    fn check_argument_types(fcx: @FnCtxt,\n+    fn check_argument_types(fcx: &FnCtxt,\n                             sp: Span,\n                             fn_inputs: &[ty::t],\n                             callee_expr: &ast::Expr,\n@@ -1824,12 +1829,12 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         Vec::from_fn(len, |_| ty::mk_err())\n     }\n \n-    fn write_call(fcx: @FnCtxt, call_expr: &ast::Expr, output: ty::t) {\n+    fn write_call(fcx: &FnCtxt, call_expr: &ast::Expr, output: ty::t) {\n         fcx.write_ty(call_expr.id, output);\n     }\n \n     // A generic function for doing all of the checking for call expressions\n-    fn check_call(fcx: @FnCtxt,\n+    fn check_call(fcx: &FnCtxt,\n                   call_expr: &ast::Expr,\n                   f: &ast::Expr,\n                   args: &[@ast::Expr]) {\n@@ -1878,7 +1883,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n     }\n \n     // Checks a method call.\n-    fn check_method_call(fcx: @FnCtxt,\n+    fn check_method_call(fcx: &FnCtxt,\n                          expr: &ast::Expr,\n                          method_name: ast::Ident,\n                          args: &[@ast::Expr],\n@@ -1935,7 +1940,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n \n     // A generic function for checking the then and else in an if\n     // or if-check\n-    fn check_then_else(fcx: @FnCtxt,\n+    fn check_then_else(fcx: &FnCtxt,\n                        cond_expr: &ast::Expr,\n                        then_blk: &ast::Block,\n                        opt_else_expr: Option<@ast::Expr>,\n@@ -1974,7 +1979,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         fcx.write_ty(id, if_ty);\n     }\n \n-    fn lookup_op_method(fcx: @FnCtxt,\n+    fn lookup_op_method(fcx: &FnCtxt,\n                         op_ex: &ast::Expr,\n                         self_t: ty::t,\n                         opname: ast::Name,\n@@ -2013,7 +2018,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n     }\n \n     // could be either an expr_binop or an expr_assign_binop\n-    fn check_binop(fcx: @FnCtxt,\n+    fn check_binop(fcx: &FnCtxt,\n                    expr: &ast::Expr,\n                    op: ast::BinOp,\n                    lhs: @ast::Expr,\n@@ -2091,7 +2096,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         }\n     }\n \n-    fn check_user_binop(fcx: @FnCtxt,\n+    fn check_user_binop(fcx: &FnCtxt,\n                         ex: &ast::Expr,\n                         lhs_expr: @ast::Expr,\n                         lhs_resolved_t: ty::t,\n@@ -2130,7 +2135,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         })\n     }\n \n-    fn check_user_unop(fcx: @FnCtxt,\n+    fn check_user_unop(fcx: &FnCtxt,\n                        op_str: &str,\n                        mname: &str,\n                        trait_did: Option<ast::DefId>,\n@@ -2150,7 +2155,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n     // resolution is not possible (e.g., no constraints yet present), just\n     // returns `none`.\n     fn unpack_expected<O>(\n-                       fcx: @FnCtxt,\n+                       fcx: &FnCtxt,\n                        expected: Option<ty::t>,\n                        unpack: |&ty::sty| -> Option<O>)\n                        -> Option<O> {\n@@ -2165,7 +2170,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         }\n     }\n \n-    fn check_expr_fn(fcx: @FnCtxt,\n+    fn check_expr_fn(fcx: &FnCtxt,\n                      expr: &ast::Expr,\n                      ast_sigil_opt: Option<ast::Sigil>,\n                      decl: &ast::FnDecl,\n@@ -2271,7 +2276,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n \n \n     // Check field access expressions\n-    fn check_field(fcx: @FnCtxt,\n+    fn check_field(fcx: &FnCtxt,\n                    expr: &ast::Expr,\n                    lvalue_pref: LvaluePreference,\n                    base: &ast::Expr,\n@@ -2340,7 +2345,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         fcx.write_error(expr.id);\n     }\n \n-    fn check_struct_or_variant_fields(fcx: @FnCtxt,\n+    fn check_struct_or_variant_fields(fcx: &FnCtxt,\n                                       struct_ty: ty::t,\n                                       span: Span,\n                                       class_id: ast::DefId,\n@@ -2428,7 +2433,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         }\n     }\n \n-    fn check_struct_constructor(fcx: @FnCtxt,\n+    fn check_struct_constructor(fcx: &FnCtxt,\n                                 id: ast::NodeId,\n                                 span: codemap::Span,\n                                 class_id: ast::DefId,\n@@ -2484,7 +2489,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         fcx.write_ty(id, struct_type);\n     }\n \n-    fn check_struct_enum_variant(fcx: @FnCtxt,\n+    fn check_struct_enum_variant(fcx: &FnCtxt,\n                                  id: ast::NodeId,\n                                  span: codemap::Span,\n                                  enum_id: ast::DefId,\n@@ -3020,7 +3025,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n                                 _ => false\n                             }\n                         }\n-                        fn types_compatible(fcx: @FnCtxt, sp: Span,\n+                        fn types_compatible(fcx: &FnCtxt, sp: Span,\n                                             t1: ty::t, t2: ty::t) -> bool {\n                             if !is_vec(t1) {\n                                 false\n@@ -3205,7 +3210,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n     unifier();\n }\n \n-pub fn require_integral(fcx: @FnCtxt, sp: Span, t: ty::t) {\n+pub fn require_integral(fcx: &FnCtxt, sp: Span, t: ty::t) {\n     if !type_is_integral(fcx, sp, t) {\n         fcx.type_error_message(sp, |actual| {\n             format!(\"mismatched types: expected integral type but found `{}`\",\n@@ -3214,15 +3219,15 @@ pub fn require_integral(fcx: @FnCtxt, sp: Span, t: ty::t) {\n     }\n }\n \n-pub fn check_decl_initializer(fcx: @FnCtxt,\n+pub fn check_decl_initializer(fcx: &FnCtxt,\n                               nid: ast::NodeId,\n                               init: &ast::Expr)\n                             {\n     let local_ty = fcx.local_ty(init.span, nid);\n     check_expr_coercable_to_type(fcx, init, local_ty)\n }\n \n-pub fn check_decl_local(fcx: @FnCtxt, local: &ast::Local)  {\n+pub fn check_decl_local(fcx: &FnCtxt, local: &ast::Local)  {\n     let tcx = fcx.ccx.tcx;\n \n     let t = fcx.local_ty(local.span, local.id);\n@@ -3250,7 +3255,7 @@ pub fn check_decl_local(fcx: @FnCtxt, local: &ast::Local)  {\n     }\n }\n \n-pub fn check_stmt(fcx: @FnCtxt, stmt: &ast::Stmt)  {\n+pub fn check_stmt(fcx: &FnCtxt, stmt: &ast::Stmt)  {\n     let node_id;\n     let mut saw_bot = false;\n     let mut saw_err = false;\n@@ -3295,7 +3300,7 @@ pub fn check_stmt(fcx: @FnCtxt, stmt: &ast::Stmt)  {\n     }\n }\n \n-pub fn check_block_no_value(fcx: @FnCtxt, blk: &ast::Block)  {\n+pub fn check_block_no_value(fcx: &FnCtxt, blk: &ast::Block)  {\n     check_block_with_expected(fcx, blk, Some(ty::mk_nil()));\n     let blkty = fcx.node_ty(blk.id);\n     if ty::type_is_error(blkty) {\n@@ -3310,11 +3315,11 @@ pub fn check_block_no_value(fcx: @FnCtxt, blk: &ast::Block)  {\n     }\n }\n \n-pub fn check_block(fcx0: @FnCtxt, blk: &ast::Block)  {\n+pub fn check_block(fcx0: &FnCtxt, blk: &ast::Block)  {\n     check_block_with_expected(fcx0, blk, None)\n }\n \n-pub fn check_block_with_expected(fcx: @FnCtxt,\n+pub fn check_block_with_expected(fcx: &FnCtxt,\n                                  blk: &ast::Block,\n                                  expected: Option<ty::t>) {\n     let prev = {\n@@ -3383,20 +3388,21 @@ pub fn check_block_with_expected(fcx: @FnCtxt,\n     fcx.ps.set(prev);\n }\n \n-pub fn check_const(ccx: @CrateCtxt,\n+pub fn check_const(ccx: &CrateCtxt,\n                    sp: Span,\n                    e: &ast::Expr,\n                    id: ast::NodeId) {\n+    let inh = blank_inherited_fields(ccx);\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n-    let fcx = blank_fn_ctxt(ccx, rty, e.id);\n+    let fcx = blank_fn_ctxt(ccx, &inh, rty, e.id);\n     let declty = {\n         let tcache = fcx.ccx.tcx.tcache.borrow();\n         tcache.get().get(&local_def(id)).ty\n     };\n-    check_const_with_ty(fcx, sp, e, declty);\n+    check_const_with_ty(&fcx, sp, e, declty);\n }\n \n-pub fn check_const_with_ty(fcx: @FnCtxt,\n+pub fn check_const_with_ty(fcx: &FnCtxt,\n                            _: Span,\n                            e: &ast::Expr,\n                            declty: ty::t) {\n@@ -3486,15 +3492,15 @@ pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n     }\n }\n \n-pub fn check_enum_variants(ccx: @CrateCtxt,\n+pub fn check_enum_variants(ccx: &CrateCtxt,\n                            sp: Span,\n                            vs: &[ast::P<ast::Variant>],\n                            id: ast::NodeId) {\n \n-    fn disr_in_range(ccx: @CrateCtxt,\n+    fn disr_in_range(ccx: &CrateCtxt,\n                      ty: attr::IntType,\n                      disr: ty::Disr) -> bool {\n-        fn uint_in_range(ccx: @CrateCtxt, ty: ast::UintTy, disr: ty::Disr) -> bool {\n+        fn uint_in_range(ccx: &CrateCtxt, ty: ast::UintTy, disr: ty::Disr) -> bool {\n             match ty {\n                 ast::TyU8 => disr as u8 as Disr == disr,\n                 ast::TyU16 => disr as u16 as Disr == disr,\n@@ -3503,7 +3509,7 @@ pub fn check_enum_variants(ccx: @CrateCtxt,\n                 ast::TyU => uint_in_range(ccx, ccx.tcx.sess.targ_cfg.uint_type, disr)\n             }\n         }\n-        fn int_in_range(ccx: @CrateCtxt, ty: ast::IntTy, disr: ty::Disr) -> bool {\n+        fn int_in_range(ccx: &CrateCtxt, ty: ast::IntTy, disr: ty::Disr) -> bool {\n             match ty {\n                 ast::TyI8 => disr as i8 as Disr == disr,\n                 ast::TyI16 => disr as i16 as Disr == disr,\n@@ -3518,7 +3524,7 @@ pub fn check_enum_variants(ccx: @CrateCtxt,\n         }\n     }\n \n-    fn do_check(ccx: @CrateCtxt,\n+    fn do_check(ccx: &CrateCtxt,\n                 vs: &[ast::P<ast::Variant>],\n                 id: ast::NodeId,\n                 hint: attr::ReprAttr)\n@@ -3542,9 +3548,10 @@ pub fn check_enum_variants(ccx: @CrateCtxt,\n                 Some(e) => {\n                     debug!(\"disr expr, checking {}\", pprust::expr_to_str(e));\n \n-                    let fcx = blank_fn_ctxt(ccx, rty, e.id);\n+                    let inh = blank_inherited_fields(ccx);\n+                    let fcx = blank_fn_ctxt(ccx, &inh, rty, e.id);\n                     let declty = ty::mk_int_var(ccx.tcx, fcx.infcx().next_int_var_id());\n-                    check_const_with_ty(fcx, e.span, e, declty);\n+                    check_const_with_ty(&fcx, e.span, e, declty);\n                     // check_expr (from check_const pass) doesn't guarantee\n                     // that the expression is in an form that eval_const_expr can\n                     // handle, so we may still get an internal compiler error\n@@ -3617,12 +3624,12 @@ pub fn check_enum_variants(ccx: @CrateCtxt,\n     check_instantiable(ccx.tcx, sp, id);\n }\n \n-pub fn lookup_def(fcx: @FnCtxt, sp: Span, id: ast::NodeId) -> ast::Def {\n+pub fn lookup_def(fcx: &FnCtxt, sp: Span, id: ast::NodeId) -> ast::Def {\n     lookup_def_ccx(fcx.ccx, sp, id)\n }\n \n // Returns the type parameter count and the type for the given definition.\n-pub fn ty_param_bounds_and_ty_for_def(fcx: @FnCtxt,\n+pub fn ty_param_bounds_and_ty_for_def(fcx: &FnCtxt,\n                                       sp: Span,\n                                       defn: ast::Def)\n                                    -> ty_param_bounds_and_ty {\n@@ -3672,7 +3679,7 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @FnCtxt,\n \n // Instantiates the given path, which must refer to an item with the given\n // number of type parameters and type.\n-pub fn instantiate_path(fcx: @FnCtxt,\n+pub fn instantiate_path(fcx: &FnCtxt,\n                         pth: &ast::Path,\n                         tpt: ty_param_bounds_and_ty,\n                         def: ast::Def,\n@@ -3858,47 +3865,47 @@ pub fn structurally_resolved_type(fcx: &FnCtxt, sp: Span, tp: ty::t) -> ty::t {\n }\n \n // Returns the one-level-deep structure of the given type.\n-pub fn structure_of<'a>(fcx: @FnCtxt, sp: Span, typ: ty::t)\n+pub fn structure_of<'a>(fcx: &FnCtxt, sp: Span, typ: ty::t)\n                         -> &'a ty::sty {\n     &ty::get(structurally_resolved_type(fcx, sp, typ)).sty\n }\n \n-pub fn type_is_integral(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_integral(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_integral(typ_s);\n }\n \n-pub fn type_is_scalar(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_scalar(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_scalar(typ_s);\n }\n \n-pub fn type_is_char(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_char(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_char(typ_s);\n }\n \n-pub fn type_is_bare_fn(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_bare_fn(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_bare_fn(typ_s);\n }\n \n-pub fn type_is_unsafe_ptr(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_unsafe_ptr(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_unsafe_ptr(typ_s);\n }\n \n-pub fn type_is_region_ptr(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_region_ptr(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_region_ptr(typ_s);\n }\n \n-pub fn type_is_c_like_enum(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_c_like_enum(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_c_like_enum(fcx.ccx.tcx, typ_s);\n }\n \n-pub fn ast_expr_vstore_to_vstore(fcx: @FnCtxt,\n+pub fn ast_expr_vstore_to_vstore(fcx: &FnCtxt,\n                                  e: &ast::Expr,\n                                  v: ast::ExprVstore)\n                               -> ty::vstore {\n@@ -3962,7 +3969,7 @@ pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: ast::P<ast::Block>) -> bool\n         }}))\n }\n \n-pub fn check_bounds_are_used(ccx: @CrateCtxt,\n+pub fn check_bounds_are_used(ccx: &CrateCtxt,\n                              span: Span,\n                              tps: &OptVec<ast::TyParam>,\n                              ty: ty::t) {\n@@ -3992,8 +3999,8 @@ pub fn check_bounds_are_used(ccx: @CrateCtxt,\n     }\n }\n \n-pub fn check_intrinsic_type(ccx: @CrateCtxt, it: &ast::ForeignItem) {\n-    fn param(ccx: @CrateCtxt, n: uint) -> ty::t {\n+pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n+    fn param(ccx: &CrateCtxt, n: uint) -> ty::t {\n         ty::mk_param(ccx.tcx, n, local_def(0))\n     }\n "}, {"sha": "4610305a70b08f247d394b26776922892cb9bcb4", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/869c96dbf088203867c62776c9c28a19658edd8d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/869c96dbf088203867c62776c9c28a19658edd8d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=869c96dbf088203867c62776c9c28a19658edd8d", "patch": "@@ -293,7 +293,7 @@ impl<'a, 'b> mc::Typer for &'a mut Rcx<'b> {\n     }\n }\n \n-pub fn regionck_expr(fcx: @FnCtxt, e: &ast::Expr) {\n+pub fn regionck_expr(fcx: &FnCtxt, e: &ast::Expr) {\n     let mut rcx = Rcx { fcx: fcx, errors_reported: 0,\n                          repeating_scope: e.id };\n     let rcx = &mut rcx;\n@@ -304,7 +304,7 @@ pub fn regionck_expr(fcx: @FnCtxt, e: &ast::Expr) {\n     fcx.infcx().resolve_regions();\n }\n \n-pub fn regionck_fn(fcx: @FnCtxt, blk: &ast::Block) {\n+pub fn regionck_fn(fcx: &FnCtxt, blk: &ast::Block) {\n     let mut rcx = Rcx { fcx: fcx, errors_reported: 0,\n                          repeating_scope: blk.id };\n     let rcx = &mut rcx;"}, {"sha": "1c03328bceaf374a7f7fcfc989a3997d6a6fc44d", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/869c96dbf088203867c62776c9c28a19658edd8d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/869c96dbf088203867c62776c9c28a19658edd8d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=869c96dbf088203867c62776c9c28a19658edd8d", "patch": "@@ -35,7 +35,7 @@ use syntax::print::pprust::pat_to_str;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n-fn resolve_type_vars_in_type(fcx: @FnCtxt, sp: Span, typ: ty::t)\n+fn resolve_type_vars_in_type(fcx: &FnCtxt, sp: Span, typ: ty::t)\n                           -> Option<ty::t> {\n     if !ty::type_needs_infer(typ) { return Some(typ); }\n     match resolve_type(fcx.infcx(), typ, resolve_all | force_all) {\n@@ -53,7 +53,7 @@ fn resolve_type_vars_in_type(fcx: @FnCtxt, sp: Span, typ: ty::t)\n     }\n }\n \n-fn resolve_type_vars_in_types(fcx: @FnCtxt, sp: Span, tys: &[ty::t])\n+fn resolve_type_vars_in_types(fcx: &FnCtxt, sp: Span, tys: &[ty::t])\n                           -> Vec<ty::t> {\n     tys.iter().map(|t| {\n         match resolve_type_vars_in_type(fcx, sp, *t) {\n@@ -101,7 +101,7 @@ fn resolve_method_map_entry(wbcx: &mut WbCtxt, sp: Span, method_call: MethodCall\n     }\n }\n \n-fn resolve_vtable_map_entry(fcx: @FnCtxt, sp: Span, id: ast::NodeId) {\n+fn resolve_vtable_map_entry(fcx: &FnCtxt, sp: Span, id: ast::NodeId) {\n     // Resolve any vtable map entry\n     match fcx.inh.vtable_map.borrow().get().find_copy(&id) {\n         Some(origins) => {\n@@ -113,12 +113,12 @@ fn resolve_vtable_map_entry(fcx: @FnCtxt, sp: Span, id: ast::NodeId) {\n         None => {}\n     }\n \n-    fn resolve_origins(fcx: @FnCtxt, sp: Span,\n+    fn resolve_origins(fcx: &FnCtxt, sp: Span,\n                        vtbls: vtable_res) -> vtable_res {\n         @vtbls.map(|os| @os.map(|o| resolve_origin(fcx, sp, o)))\n     }\n \n-    fn resolve_origin(fcx: @FnCtxt,\n+    fn resolve_origin(fcx: &FnCtxt,\n                       sp: Span,\n                       origin: &vtable_origin) -> vtable_origin {\n         match origin {\n@@ -255,7 +255,7 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n }\n \n struct WbCtxt<'a> {\n-    fcx: @FnCtxt<'a>,\n+    fcx: &'a FnCtxt<'a>,\n \n     // As soon as we hit an error we have to stop resolving\n     // the entire function.\n@@ -383,15 +383,15 @@ fn resolve_upvar_borrow_map(wbcx: &mut WbCtxt) {\n     }\n }\n \n-pub fn resolve_type_vars_in_expr(fcx: @FnCtxt, e: &ast::Expr) -> bool {\n+pub fn resolve_type_vars_in_expr(fcx: &FnCtxt, e: &ast::Expr) -> bool {\n     let mut wbcx = WbCtxt { fcx: fcx, success: true };\n     let wbcx = &mut wbcx;\n     wbcx.visit_expr(e, ());\n     resolve_upvar_borrow_map(wbcx);\n     return wbcx.success;\n }\n \n-pub fn resolve_type_vars_in_fn(fcx: @FnCtxt, decl: &ast::FnDecl,\n+pub fn resolve_type_vars_in_fn(fcx: &FnCtxt, decl: &ast::FnDecl,\n                                blk: &ast::Block) -> bool {\n     let mut wbcx = WbCtxt { fcx: fcx, success: true };\n     let wbcx = &mut wbcx;"}, {"sha": "bd61190a79f1832403477112eb50470db6469264", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/869c96dbf088203867c62776c9c28a19658edd8d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/869c96dbf088203867c62776c9c28a19658edd8d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=869c96dbf088203867c62776c9c28a19658edd8d", "patch": "@@ -145,7 +145,7 @@ fn get_base_type_def_id(inference_context: &InferCtxt,\n }\n \n struct CoherenceChecker<'a> {\n-    crate_context: @CrateCtxt<'a>,\n+    crate_context: &'a CrateCtxt<'a>,\n     inference_context: InferCtxt<'a>,\n }\n \n@@ -227,13 +227,6 @@ impl<'a> visit::Visitor<()> for PrivilegedScopeVisitor<'a> {\n }\n \n impl<'a> CoherenceChecker<'a> {\n-    fn new(crate_context: @CrateCtxt<'a>) -> CoherenceChecker<'a> {\n-        CoherenceChecker {\n-            crate_context: crate_context,\n-            inference_context: new_infer_ctxt(crate_context.tcx),\n-        }\n-    }\n-\n     fn check(&self, krate: &Crate) {\n         // Check implementations and traits. This populates the tables\n         // containing the inherent methods and extension methods. It also\n@@ -838,6 +831,9 @@ fn subst_receiver_types_in_method_ty(tcx: &ty::ctxt,\n     )\n }\n \n-pub fn check_coherence(crate_context: @CrateCtxt, krate: &Crate) {\n-    CoherenceChecker::new(crate_context).check(krate);\n+pub fn check_coherence(crate_context: &CrateCtxt, krate: &Crate) {\n+    CoherenceChecker {\n+        crate_context: crate_context,\n+        inference_context: new_infer_ctxt(crate_context.tcx),\n+    }.check(krate);\n }"}, {"sha": "fc6b4c91b4e8902fe41a09602f1322755e4891ee", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/869c96dbf088203867c62776c9c28a19658edd8d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/869c96dbf088203867c62776c9c28a19658edd8d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=869c96dbf088203867c62776c9c28a19658edd8d", "patch": "@@ -62,7 +62,7 @@ use syntax::visit;\n use syntax::opt_vec::OptVec;\n \n struct CollectItemTypesVisitor<'a> {\n-    ccx: @CrateCtxt<'a>\n+    ccx: &'a CrateCtxt<'a>\n }\n \n impl<'a> visit::Visitor<()> for CollectItemTypesVisitor<'a> {\n@@ -76,7 +76,7 @@ impl<'a> visit::Visitor<()> for CollectItemTypesVisitor<'a> {\n     }\n }\n \n-pub fn collect_item_types(ccx: @CrateCtxt, krate: &ast::Crate) {\n+pub fn collect_item_types(ccx: &CrateCtxt, krate: &ast::Crate) {\n     fn collect_intrinsic_type(ccx: &CrateCtxt,\n                               lang_item: ast::DefId) {\n         let ty::ty_param_bounds_and_ty { ty: ty, .. } ="}, {"sha": "bf34e7c13516a4f04d968e532b7c124c4e5cfd15", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/869c96dbf088203867c62776c9c28a19658edd8d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/869c96dbf088203867c62776c9c28a19658edd8d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=869c96dbf088203867c62776c9c28a19658edd8d", "patch": "@@ -462,15 +462,15 @@ pub fn check_crate(tcx: &ty::ctxt,\n                    krate: &ast::Crate)\n                 -> (MethodMap, vtable_map) {\n     let time_passes = tcx.sess.time_passes();\n-    let ccx = @CrateCtxt {\n+    let ccx = CrateCtxt {\n         trait_map: trait_map,\n         method_map: @RefCell::new(FnvHashMap::new()),\n         vtable_map: @RefCell::new(NodeMap::new()),\n         tcx: tcx\n     };\n \n     time(time_passes, \"type collecting\", (), |_|\n-        collect::collect_item_types(ccx, krate));\n+        collect::collect_item_types(&ccx, krate));\n \n     // this ensures that later parts of type checking can assume that items\n     // have valid types and not error\n@@ -480,12 +480,12 @@ pub fn check_crate(tcx: &ty::ctxt,\n          variance::infer_variance(tcx, krate));\n \n     time(time_passes, \"coherence checking\", (), |_|\n-        coherence::check_coherence(ccx, krate));\n+        coherence::check_coherence(&ccx, krate));\n \n     time(time_passes, \"type checking\", (), |_|\n-        check::check_item_types(ccx, krate));\n+        check::check_item_types(&ccx, krate));\n \n-    check_for_entry_fn(ccx);\n+    check_for_entry_fn(&ccx);\n     tcx.sess.abort_if_errors();\n     (ccx.method_map, ccx.vtable_map)\n }"}]}