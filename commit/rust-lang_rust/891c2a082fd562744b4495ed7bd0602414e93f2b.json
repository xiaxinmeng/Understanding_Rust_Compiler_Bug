{"sha": "891c2a082fd562744b4495ed7bd0602414e93f2b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5MWMyYTA4MmZkNTYyNzQ0YjQ0OTVlZDdiZDA2MDI0MTRlOTNmMmI=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-05-07T00:02:09Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-07-08T13:37:23Z"}, "message": "trans: Make translation of statics collector-driven.", "tree": {"sha": "79ea7d2059369267de569252afa3158c0a8d779b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79ea7d2059369267de569252afa3158c0a8d779b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/891c2a082fd562744b4495ed7bd0602414e93f2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/891c2a082fd562744b4495ed7bd0602414e93f2b", "html_url": "https://github.com/rust-lang/rust/commit/891c2a082fd562744b4495ed7bd0602414e93f2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/891c2a082fd562744b4495ed7bd0602414e93f2b/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3fa1cdf23cd28b8dc5c8ba1f626c5256713cc991", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fa1cdf23cd28b8dc5c8ba1f626c5256713cc991", "html_url": "https://github.com/rust-lang/rust/commit/3fa1cdf23cd28b8dc5c8ba1f626c5256713cc991"}], "stats": {"total": 358, "additions": 221, "deletions": 137}, "files": [{"sha": "40ae50251806a16a0ca01d438a8c4569e346979f", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 36, "deletions": 10, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/891c2a082fd562744b4495ed7bd0602414e93f2b/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/891c2a082fd562744b4495ed7bd0602414e93f2b/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=891c2a082fd562744b4495ed7bd0602414e93f2b", "patch": "@@ -2249,8 +2249,10 @@ pub fn update_linkage(ccx: &CrateContext,\n     }\n }\n \n-fn set_global_section(ccx: &CrateContext, llval: ValueRef, i: &hir::Item) {\n-    if let Some(sect) = attr::first_attr_value_str_by_name(&i.attrs, \"link_section\") {\n+pub fn set_link_section(ccx: &CrateContext,\n+                        llval: ValueRef,\n+                        attrs: &[ast::Attribute]) {\n+    if let Some(sect) = attr::first_attr_value_str_by_name(attrs, \"link_section\") {\n         if contains_null(&sect) {\n             ccx.sess().fatal(&format!(\"Illegal null byte in link_section value: `{}`\", &sect));\n         }\n@@ -2280,7 +2282,7 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n                     let empty_substs = ccx.empty_substs_for_def_id(def_id);\n                     let llfn = Callee::def(ccx, def_id, empty_substs).reify(ccx).val;\n                     trans_fn(ccx, &decl, &body, llfn, empty_substs, item.id);\n-                    set_global_section(ccx, llfn, item);\n+                    set_link_section(ccx, llfn, &item.attrs);\n                     update_linkage(ccx,\n                                    llfn,\n                                    Some(item.id),\n@@ -2336,13 +2338,9 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n                 enum_variant_size_lint(ccx, enum_definition, item.span, item.id);\n             }\n         }\n-        hir::ItemStatic(_, m, ref expr) => {\n-            let g = match consts::trans_static(ccx, m, expr, item.id, &item.attrs) {\n-                Ok(g) => g,\n-                Err(err) => ccx.tcx().sess.span_fatal(expr.span, &err.description()),\n-            };\n-            set_global_section(ccx, g, item);\n-            update_linkage(ccx, g, Some(item.id), OriginalTranslation);\n+        hir::ItemStatic(..) => {\n+            // Don't do anything here. Translation of statics has been moved to\n+            // being \"collector-driven\".\n         }\n         _ => {}\n     }\n@@ -2700,6 +2698,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let codegen_units = collect_and_partition_translation_items(&shared_ccx);\n     let codegen_unit_count = codegen_units.len();\n+\n     assert!(tcx.sess.opts.cg.codegen_units == codegen_unit_count ||\n             tcx.sess.opts.debugging_opts.incremental.is_some());\n \n@@ -2723,6 +2722,33 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         };\n     }\n \n+    // Instantiate translation items without filling out definitions yet...\n+    for ccx in crate_context_list.iter() {\n+        for (&trans_item, &linkage) in &ccx.codegen_unit().items {\n+            trans_item.predefine(&ccx, linkage);\n+        }\n+    }\n+\n+    // ... and now that we have everything pre-defined, fill out those definitions.\n+    for ccx in crate_context_list.iter() {\n+        for (&trans_item, _) in &ccx.codegen_unit().items {\n+            match trans_item {\n+                TransItem::Static(node_id) => {\n+                    let item = ccx.tcx().map.expect_item(node_id);\n+                    if let hir::ItemStatic(_, m, ref expr) = item.node {\n+                        match consts::trans_static(&ccx, m, expr, item.id, &item.attrs) {\n+                            Ok(_) => { /* Cool, everything's alright. */ },\n+                            Err(err) => ccx.tcx().sess.span_fatal(expr.span, &err.description()),\n+                        };\n+                    } else {\n+                        span_bug!(item.span, \"Mismatch between hir::Item type and TransItem type\")\n+                    }\n+                }\n+                _ => { }\n+            }\n+        }\n+    }\n+\n     {\n         let ccx = crate_context_list.get_ccx(0);\n "}, {"sha": "1a38baeff37841ba3559d05acc7bd49489323313", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/891c2a082fd562744b4495ed7bd0602414e93f2b/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/891c2a082fd562744b4495ed7bd0602414e93f2b/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=891c2a082fd562744b4495ed7bd0602414e93f2b", "patch": "@@ -1017,22 +1017,29 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n \n     let g = if let Some(id) = ccx.tcx().map.as_local_node_id(def_id) {\n         let llty = type_of::type_of(ccx, ty);\n-        match ccx.tcx().map.get(id) {\n+        let (g, attrs) = match ccx.tcx().map.get(id) {\n             hir_map::NodeItem(&hir::Item {\n-                span, node: hir::ItemStatic(..), ..\n+                ref attrs, span, node: hir::ItemStatic(..), ..\n             }) => {\n-                // If this static came from an external crate, then\n-                // we need to get the symbol from metadata instead of\n-                // using the current crate's name/version\n-                // information in the hash of the symbol\n-                debug!(\"making {}\", sym);\n-\n-                // Create the global before evaluating the initializer;\n-                // this is necessary to allow recursive statics.\n-                declare::define_global(ccx, &sym, llty).unwrap_or_else(|| {\n-                    ccx.sess().span_fatal(span,\n-                        &format!(\"symbol `{}` is already defined\", sym))\n-                })\n+                // Make sure that this is never executed for something inlined.\n+                assert!(!ccx.external_srcs().borrow().contains_key(&id));\n+\n+                let defined_in_current_codegen_unit = ccx.codegen_unit()\n+                                                         .items\n+                                                         .contains_key(&TransItem::Static(id));\n+                if defined_in_current_codegen_unit {\n+                    if declare::get_declared_value(ccx, &sym).is_none() {\n+                        span_bug!(span, \"trans: Static not properly pre-defined?\");\n+                    }\n+                } else {\n+                    if declare::get_declared_value(ccx, &sym).is_some() {\n+                        span_bug!(span, \"trans: Conflicting symbol names for static?\");\n+                    }\n+                }\n+\n+                let g = declare::define_global(ccx, &sym, llty).unwrap();\n+\n+                (g, attrs)\n             }\n \n             hir_map::NodeForeignItem(&hir::ForeignItem {\n@@ -1083,17 +1090,19 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                     declare::declare_global(ccx, &sym, llty)\n                 };\n \n-                for attr in attrs {\n-                    if attr.check_name(\"thread_local\") {\n-                        llvm::set_thread_local(g, true);\n-                    }\n-                }\n-\n-                g\n+                (g, attrs)\n             }\n \n             item => bug!(\"get_static: expected static, found {:?}\", item)\n+        };\n+\n+        for attr in attrs {\n+            if attr.check_name(\"thread_local\") {\n+                llvm::set_thread_local(g, true);\n+            }\n         }\n+\n+        g\n     } else {\n         // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n         // FIXME(nagisa): investigate whether it can be changed into define_global\n@@ -1197,6 +1206,9 @@ pub fn trans_static(ccx: &CrateContext,\n                                \"thread_local\") {\n             llvm::set_thread_local(g, true);\n         }\n+\n+        base::set_link_section(ccx, g, attrs);\n+\n         Ok(g)\n     }\n }"}, {"sha": "92fddd7d77d91da798c4306288f821ef119e2c32", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 152, "deletions": 106, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/891c2a082fd562744b4495ed7bd0602414e93f2b/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/891c2a082fd562744b4495ed7bd0602414e93f2b/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=891c2a082fd562744b4495ed7bd0602414e93f2b", "patch": "@@ -14,7 +14,9 @@\n //! item-path. This is used for unit testing the code that generates\n //! paths etc in all kinds of annoying scenarios.\n \n-use base::llvm_linkage_by_name;\n+use base;\n+use context::CrateContext;\n+use declare;\n use glue::DropGlueKind;\n use llvm;\n use monomorphize::Instance;\n@@ -26,6 +28,8 @@ use std::hash::{Hash, Hasher};\n use syntax::ast::{self, NodeId};\n use syntax::attr;\n use syntax::parse::token;\n+use type_of;\n+\n \n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n pub enum TransItem<'tcx> {\n@@ -54,6 +58,153 @@ impl<'tcx> Hash for TransItem<'tcx> {\n     }\n }\n \n+\n+impl<'tcx> TransItem<'tcx> {\n+\n+    pub fn predefine<'ccx>(&self,\n+                           ccx: &CrateContext<'ccx, 'tcx>,\n+                           linkage: llvm::Linkage) {\n+        match *self {\n+            TransItem::Static(node_id) => {\n+                TransItem::predefine_static(ccx, node_id, linkage);\n+            }\n+            _ => {\n+                // Not yet implemented\n+            }\n+        }\n+    }\n+\n+    fn predefine_static<'a>(ccx: &CrateContext<'a, 'tcx>,\n+                            node_id: ast::NodeId,\n+                            linkage: llvm::Linkage) {\n+        let def_id = ccx.tcx().map.local_def_id(node_id);\n+        let ty = ccx.tcx().lookup_item_type(def_id).ty;\n+        let llty = type_of::type_of(ccx, ty);\n+\n+        match ccx.tcx().map.get(node_id) {\n+            hir::map::NodeItem(&hir::Item {\n+                span, node: hir::ItemStatic(..), ..\n+            }) => {\n+                let instance = Instance::mono(ccx.shared(), def_id);\n+                let sym = instance.symbol_name(ccx.shared());\n+                debug!(\"making {}\", sym);\n+\n+                let g = declare::define_global(ccx, &sym, llty).unwrap_or_else(|| {\n+                    ccx.sess().span_fatal(span,\n+                        &format!(\"symbol `{}` is already defined\", sym))\n+                });\n+\n+                llvm::SetLinkage(g, linkage);\n+            }\n+\n+            item => bug!(\"predefine_static: expected static, found {:?}\", item)\n+        }\n+    }\n+\n+    pub fn requests_inline<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n+        match *self {\n+            TransItem::Fn(ref instance) => {\n+                let attributes = tcx.get_attrs(instance.def);\n+                attr::requests_inline(&attributes[..])\n+            }\n+            TransItem::DropGlue(..) => true,\n+            TransItem::Static(..)   => false,\n+        }\n+    }\n+\n+    pub fn is_from_extern_crate(&self) -> bool {\n+        match *self {\n+            TransItem::Fn(ref instance) => !instance.def.is_local(),\n+            TransItem::DropGlue(..) |\n+            TransItem::Static(..)   => false,\n+        }\n+    }\n+\n+    pub fn is_lazily_instantiated(&self) -> bool {\n+        match *self {\n+            TransItem::Fn(ref instance) => !instance.substs.types.is_empty(),\n+            TransItem::DropGlue(..) => true,\n+            TransItem::Static(..)   => false,\n+        }\n+    }\n+\n+    pub fn explicit_linkage<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<llvm::Linkage> {\n+        let def_id = match *self {\n+            TransItem::Fn(ref instance) => instance.def,\n+            TransItem::Static(node_id) => tcx.map.local_def_id(node_id),\n+            TransItem::DropGlue(..) => return None,\n+        };\n+\n+        let attributes = tcx.get_attrs(def_id);\n+        if let Some(name) = attr::first_attr_value_str_by_name(&attributes, \"linkage\") {\n+            if let Some(linkage) = base::llvm_linkage_by_name(&name) {\n+                Some(linkage)\n+            } else {\n+                let span = tcx.map.span_if_local(def_id);\n+                if let Some(span) = span {\n+                    tcx.sess.span_fatal(span, \"invalid linkage specified\")\n+                } else {\n+                    tcx.sess.fatal(&format!(\"invalid linkage specified: {}\", name))\n+                }\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn to_string<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n+        let hir_map = &tcx.map;\n+\n+        return match *self {\n+            TransItem::DropGlue(dg) => {\n+                let mut s = String::with_capacity(32);\n+                match dg {\n+                    DropGlueKind::Ty(_) => s.push_str(\"drop-glue \"),\n+                    DropGlueKind::TyContents(_) => s.push_str(\"drop-glue-contents \"),\n+                };\n+                push_unique_type_name(tcx, dg.ty(), &mut s);\n+                s\n+            }\n+            TransItem::Fn(instance) => {\n+                to_string_internal(tcx, \"fn \", instance)\n+            },\n+            TransItem::Static(node_id) => {\n+                let def_id = hir_map.local_def_id(node_id);\n+                let instance = Instance::new(def_id,\n+                                             tcx.mk_substs(subst::Substs::empty()));\n+                to_string_internal(tcx, \"static \", instance)\n+            },\n+        };\n+\n+        fn to_string_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx,'tcx>,\n+                                        prefix: &str,\n+                                        instance: Instance<'tcx>)\n+                                        -> String {\n+            let mut result = String::with_capacity(32);\n+            result.push_str(prefix);\n+            push_instance_as_string(tcx, instance, &mut result);\n+            result\n+        }\n+    }\n+\n+    pub fn to_raw_string(&self) -> String {\n+        match *self {\n+            TransItem::DropGlue(dg) => {\n+                format!(\"DropGlue({})\", dg.ty() as *const _ as usize)\n+            }\n+            TransItem::Fn(instance) => {\n+                format!(\"Fn({:?}, {})\",\n+                         instance.def,\n+                         instance.substs as *const _ as usize)\n+            }\n+            TransItem::Static(id) => {\n+                format!(\"Static({:?})\", id)\n+            }\n+        }\n+    }\n+}\n+\n+\n //=-----------------------------------------------------------------------------\n // TransItem String Keys\n //=-----------------------------------------------------------------------------\n@@ -277,108 +428,3 @@ pub fn type_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     push_unique_type_name(tcx, ty, &mut output);\n     output\n }\n-\n-impl<'tcx> TransItem<'tcx> {\n-\n-    pub fn requests_inline<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n-        match *self {\n-            TransItem::Fn(ref instance) => {\n-                let attributes = tcx.get_attrs(instance.def);\n-                attr::requests_inline(&attributes[..])\n-            }\n-            TransItem::DropGlue(..) => true,\n-            TransItem::Static(..)   => false,\n-        }\n-    }\n-\n-    pub fn is_from_extern_crate(&self) -> bool {\n-        match *self {\n-            TransItem::Fn(ref instance) => !instance.def.is_local(),\n-            TransItem::DropGlue(..) |\n-            TransItem::Static(..)   => false,\n-        }\n-    }\n-\n-    pub fn is_lazily_instantiated(&self) -> bool {\n-        match *self {\n-            TransItem::Fn(ref instance) => !instance.substs.types.is_empty(),\n-            TransItem::DropGlue(..) => true,\n-            TransItem::Static(..)   => false,\n-        }\n-    }\n-\n-    pub fn explicit_linkage<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<llvm::Linkage> {\n-        let def_id = match *self {\n-            TransItem::Fn(ref instance) => instance.def,\n-            TransItem::Static(node_id) => tcx.map.local_def_id(node_id),\n-            TransItem::DropGlue(..) => return None,\n-        };\n-\n-        let attributes = tcx.get_attrs(def_id);\n-        if let Some(name) = attr::first_attr_value_str_by_name(&attributes, \"linkage\") {\n-            if let Some(linkage) = llvm_linkage_by_name(&name) {\n-                Some(linkage)\n-            } else {\n-                let span = tcx.map.span_if_local(def_id);\n-                if let Some(span) = span {\n-                    tcx.sess.span_fatal(span, \"invalid linkage specified\")\n-                } else {\n-                    tcx.sess.fatal(&format!(\"invalid linkage specified: {}\", name))\n-                }\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn to_string<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n-        let hir_map = &tcx.map;\n-\n-        return match *self {\n-            TransItem::DropGlue(dg) => {\n-                let mut s = String::with_capacity(32);\n-                match dg {\n-                    DropGlueKind::Ty(_) => s.push_str(\"drop-glue \"),\n-                    DropGlueKind::TyContents(_) => s.push_str(\"drop-glue-contents \"),\n-                };\n-                push_unique_type_name(tcx, dg.ty(), &mut s);\n-                s\n-            }\n-            TransItem::Fn(instance) => {\n-                to_string_internal(tcx, \"fn \", instance)\n-            },\n-            TransItem::Static(node_id) => {\n-                let def_id = hir_map.local_def_id(node_id);\n-                let empty_substs = tcx.mk_substs(subst::Substs::empty());\n-                let instance = Instance::new(def_id, empty_substs);\n-                to_string_internal(tcx, \"static \", instance)\n-            },\n-        };\n-\n-        fn to_string_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        prefix: &str,\n-                                        instance: Instance<'tcx>)\n-                                        -> String {\n-            let mut result = String::with_capacity(32);\n-            result.push_str(prefix);\n-            push_instance_as_string(tcx, instance, &mut result);\n-            result\n-        }\n-    }\n-\n-    pub fn to_raw_string(&self) -> String {\n-        match *self {\n-            TransItem::DropGlue(dg) => {\n-                format!(\"DropGlue({})\", dg.ty() as *const _ as usize)\n-            }\n-            TransItem::Fn(instance) => {\n-                format!(\"Fn({:?}, {})\",\n-                         instance.def,\n-                         instance.substs as *const _ as usize)\n-            }\n-            TransItem::Static(id) => {\n-                format!(\"Static({:?})\", id)\n-            }\n-        }\n-    }\n-}"}]}