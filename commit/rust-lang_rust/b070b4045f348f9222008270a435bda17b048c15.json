{"sha": "b070b4045f348f9222008270a435bda17b048c15", "node_id": "C_kwDOAAsO6NoAKGIwNzBiNDA0NWYzNDhmOTIyMjAwODI3MGE0MzViZGExN2IwNDhjMTU", "commit": {"author": {"name": "Nahua Kang", "email": "kangnahua@gmail.com", "date": "2022-08-14T16:33:55Z"}, "committer": {"name": "Nahua Kang", "email": "kangnahua@gmail.com", "date": "2022-08-20T10:09:09Z"}, "message": "Simplify lint logic and address code review comments", "tree": {"sha": "1bfb1c288f1fd91bb29fc6628dd842a7c2934174", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bfb1c288f1fd91bb29fc6628dd842a7c2934174"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b070b4045f348f9222008270a435bda17b048c15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b070b4045f348f9222008270a435bda17b048c15", "html_url": "https://github.com/rust-lang/rust/commit/b070b4045f348f9222008270a435bda17b048c15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b070b4045f348f9222008270a435bda17b048c15/comments", "author": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb30b64f6379eb22880d70bfebce66ceccc75269", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb30b64f6379eb22880d70bfebce66ceccc75269", "html_url": "https://github.com/rust-lang/rust/commit/fb30b64f6379eb22880d70bfebce66ceccc75269"}], "stats": {"total": 531, "additions": 201, "deletions": 330}, "files": [{"sha": "561033be5b6af3945bfadf83c6903a56b7f486c9", "filename": "clippy_lints/src/methods/collapsible_str_replace.rs", "status": "modified", "additions": 61, "deletions": 240, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/b070b4045f348f9222008270a435bda17b048c15/clippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b070b4045f348f9222008270a435bda17b048c15/clippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs?ref=b070b4045f348f9222008270a435bda17b048c15", "patch": "@@ -1,275 +1,96 @@\n-// run-rustfix\n-\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::get_parent_expr;\n+use clippy_utils::source::snippet;\n use clippy_utils::visitors::for_each_expr;\n+use clippy_utils::{eq_expr_value, get_parent_expr};\n use core::ops::ControlFlow;\n-use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::{ExprKind, Path, QPath};\n use rustc_lint::LateContext;\n-use rustc_middle::ty;\n-use rustc_span::source_map::Spanned;\n-use rustc_span::Span;\n+use std::collections::VecDeque;\n \n use super::method_call;\n use super::COLLAPSIBLE_STR_REPLACE;\n \n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'tcx>,\n-    name: &str,\n-    recv: &'tcx hir::Expr<'tcx>,\n+    from: &'tcx hir::Expr<'tcx>,\n+    to: &'tcx hir::Expr<'tcx>,\n ) {\n-    if name == \"replace\" {\n-        // The receiver of the method call must be `str` type to lint `collapsible_str_replace`\n-        let original_recv = find_original_recv(recv);\n-        let original_recv_ty_kind = cx.typeck_results().expr_ty(original_recv).peel_refs().kind();\n-        let original_recv_is_str_kind = matches!(original_recv_ty_kind, ty::Str);\n-\n-        if_chain! {\n-            if original_recv_is_str_kind;\n-            if let Some(parent) = get_parent_expr(cx, expr);\n-            if let Some((name, ..)) = method_call(parent);\n-            if name == \"replace\";\n-\n-            then {\n-                // If the parent node is a `str::replace` call, we've already handled the lint, don't lint again\n-                return;\n-            }\n+    let replace_methods = collect_replace_calls(cx, expr, to);\n+    if replace_methods.methods.len() > 1 {\n+        let from_kind = cx.typeck_results().expr_ty(from).peel_refs().kind();\n+        // If the parent node's `to` argument is the same as the `to` argument\n+        // of the last replace call in the current chain, don't lint as it was already linted\n+        if let Some(parent) = get_parent_expr(cx, expr)\n+            && let Some((\"replace\", [_, current_from, current_to], _)) = method_call(parent)\n+            && eq_expr_value(cx, to, current_to)\n+            && from_kind == cx.typeck_results().expr_ty(current_from).peel_refs().kind()\n+        {\n+            return;\n         }\n \n-        if let Some((\"replace\", ..)) = method_call(recv) {\n-            // Check if there's an earlier `str::replace` call\n-            if original_recv_is_str_kind {\n-                check_consecutive_replace_calls(cx, expr);\n-            }\n-        }\n+        check_consecutive_replace_calls(cx, expr, &replace_methods, to);\n     }\n }\n \n-/// Check a chain of `str::replace` calls for `collapsible_str_replace` lint.\n-fn check_consecutive_replace_calls<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'tcx>) {\n-    if_chain! {\n-        if let Some(from_args) = get_replace_call_from_args_if_all_char_ty(cx, expr);\n-        if let Some(to_arg) = get_replace_call_unique_to_arg_repr(expr);\n-        then {\n-            let earliest_replace_call_span = get_earliest_replace_call_span(expr);\n-\n-            if replace_call_from_args_are_only_lit_chars(&from_args) {\n-                let from_arg_reprs: Vec<String> = from_args.iter().map(|from_arg| {\n-                    get_replace_call_char_arg_repr(from_arg).unwrap()\n-                }).collect();\n-                let app = Applicability::MachineApplicable;\n-\n-                span_lint_and_sugg(\n-                    cx,\n-                    COLLAPSIBLE_STR_REPLACE,\n-                    expr.span.with_lo(earliest_replace_call_span.lo()),\n-                    \"used consecutive `str::replace` call\",\n-                    \"replace with\",\n-                    format!(\n-                        \"replace(|c| matches!(c, {}), {})\",\n-                        from_arg_reprs.join(\" | \"),\n-                        to_arg,\n-                    ),\n-                    app,\n-                );\n-            } else {\n-                // Use fallback lint\n-                let from_arg_reprs: Vec<String> = from_args.iter().map(|from_arg| {\n-                    get_replace_call_char_arg_repr(from_arg).unwrap()\n-                }).collect();\n-                let app = Applicability::MachineApplicable;\n-\n-                span_lint_and_sugg(\n-                    cx,\n-                    COLLAPSIBLE_STR_REPLACE,\n-                    expr.span.with_lo(earliest_replace_call_span.lo()),\n-                    \"used consecutive `str::replace` call\",\n-                    \"replace with\",\n-                    format!(\n-                        \"replace(&[{}], {})\",\n-                        from_arg_reprs.join(\" , \"),\n-                        to_arg,\n-                    ),\n-                    app,\n-                );\n-            }\n-        }\n-    }\n+struct ReplaceMethods<'tcx> {\n+    methods: VecDeque<&'tcx hir::Expr<'tcx>>,\n+    from_args: VecDeque<&'tcx hir::Expr<'tcx>>,\n }\n \n-/// Check if all the `from` arguments of a chain of consecutive calls to `str::replace`\n-/// are all of `ExprKind::Lit` types. If any is not, return false.\n-fn replace_call_from_args_are_only_lit_chars<'tcx>(from_args: &[&'tcx hir::Expr<'tcx>]) -> bool {\n-    let mut only_lit_chars = true;\n-\n-    for from_arg in from_args.iter() {\n-        match from_arg.kind {\n-            ExprKind::Lit(..) => {},\n-            _ => only_lit_chars = false,\n-        }\n-    }\n-\n-    only_lit_chars\n-}\n-\n-/// Collect and return all of the `from` arguments of a chain of consecutive `str::replace` calls\n-/// if these `from` arguments's expressions are of the `ty::Char` kind. Otherwise return `None`.\n-fn get_replace_call_from_args_if_all_char_ty<'tcx>(\n+fn collect_replace_calls<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'tcx>,\n-) -> Option<Vec<&'tcx hir::Expr<'tcx>>> {\n-    let mut all_from_args_are_chars = true;\n-    let mut from_args = Vec::new();\n+    to_arg: &'tcx hir::Expr<'tcx>,\n+) -> ReplaceMethods<'tcx> {\n+    let mut methods = VecDeque::new();\n+    let mut from_args = VecDeque::new();\n \n     let _: Option<()> = for_each_expr(expr, |e| {\n-        if let Some((name, [_, args @ ..], _)) = method_call(e) {\n-            match (name, args) {\n-                (\"replace\", [from, _]) => {\n-                    let from_ty_kind = cx.typeck_results().expr_ty(from).peel_refs().kind();\n-                    if matches!(from_ty_kind, ty::Char) {\n-                        from_args.push(from);\n-                    } else {\n-                        all_from_args_are_chars = false;\n-                    }\n-                    ControlFlow::Continue(())\n-                },\n-                _ => ControlFlow::BREAK,\n-            }\n-        } else {\n-            ControlFlow::Continue(())\n-        }\n-    });\n-\n-    if all_from_args_are_chars {\n-        return Some(from_args);\n-    }\n-\n-    None\n-}\n-\n-/// Return a unique String representation of the `to` argument used in a chain of `str::replace`\n-/// calls if each `str::replace` call's `to` argument is identical to the other `to` arguments in\n-/// the chain. Otherwise, return `None`.\n-fn get_replace_call_unique_to_arg_repr<'tcx>(expr: &'tcx hir::Expr<'tcx>) -> Option<String> {\n-    let mut to_args = Vec::new();\n-\n-    let _: Option<()> = for_each_expr(expr, |e| {\n-        if let Some((name, [_, args @ ..], _)) = method_call(e) {\n-            match (name, args) {\n-                (\"replace\", [_, to]) => {\n-                    to_args.push(to);\n-                    ControlFlow::Continue(())\n-                },\n-                _ => ControlFlow::BREAK,\n+        if let Some((\"replace\", [_, from, to], _)) = method_call(e) {\n+            if eq_expr_value(cx, to_arg, to) && cx.typeck_results().expr_ty(from).peel_refs().is_char() {\n+                methods.push_front(e);\n+                from_args.push_front(from);\n+                ControlFlow::Continue(())\n+            } else {\n+                ControlFlow::BREAK\n             }\n         } else {\n             ControlFlow::Continue(())\n         }\n     });\n \n-    // let mut to_arg_repr_set = FxHashSet::default();\n-    let mut to_arg_reprs = Vec::new();\n-    for &to_arg in &to_args {\n-        if let Some(to_arg_repr) = get_replace_call_char_arg_repr(to_arg) {\n-            to_arg_reprs.push(to_arg_repr);\n-        }\n-    }\n-\n-    let to_arg_repr_set = to_arg_reprs.iter().cloned().collect::<FxHashSet<_>>();\n-    // Check if the set of `to` argument representations has more than one unique value\n-    if to_arg_repr_set.len() != 1 {\n-        return None;\n-    }\n-\n-    // Return the single representation value\n-    to_arg_reprs.pop()\n+    ReplaceMethods { methods, from_args }\n }\n \n-/// Get the representation of an argument of a `str::replace` call either of the literal char value\n-/// or variable name, i.e. the resolved path segments `ident`.\n-/// Return:\n-/// - the str literal with double quotes, e.g. \"\\\"l\\\"\"\n-/// - the char literal with single quotes, e.g. \"'l'\"\n-/// - the variable as a String, e.g. \"l\"\n-fn get_replace_call_char_arg_repr<'tcx>(arg: &'tcx hir::Expr<'tcx>) -> Option<String> {\n-    match arg.kind {\n-        ExprKind::Lit(Spanned {\n-            node: LitKind::Str(to_arg_val, _),\n-            ..\n-        }) => {\n-            let repr = to_arg_val.as_str();\n-            let double_quote = \"\\\"\";\n-            Some(double_quote.to_owned() + repr + double_quote)\n-        },\n-        ExprKind::Lit(Spanned {\n-            node: LitKind::Char(to_arg_val),\n-            ..\n-        }) => {\n-            let repr = to_arg_val.to_string();\n-            let double_quote = \"\\'\";\n-            Some(double_quote.to_owned() + &repr + double_quote)\n-        },\n-        ExprKind::Path(QPath::Resolved(\n-            _,\n-            Path {\n-                segments: path_segments,\n-                ..\n-            },\n-        )) => {\n-            // join the path_segments values by \"::\"\n-            let path_segment_ident_names: Vec<&str> = path_segments\n-                .iter()\n-                .map(|path_seg| path_seg.ident.name.as_str())\n-                .collect();\n-            Some(path_segment_ident_names.join(\"::\"))\n-        },\n-        _ => None,\n+/// Check a chain of `str::replace` calls for `collapsible_str_replace` lint.\n+fn check_consecutive_replace_calls<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'tcx>,\n+    replace_methods: &ReplaceMethods<'tcx>,\n+    to_arg: &'tcx hir::Expr<'tcx>,\n+) {\n+    let from_args = &replace_methods.from_args;\n+    let from_arg_reprs: Vec<String> = from_args\n+        .iter()\n+        .map(|from_arg| snippet(cx, from_arg.span, \"..\").to_string())\n+        .collect();\n+    let app = Applicability::MachineApplicable;\n+    let earliest_replace_call = replace_methods.methods.front().unwrap();\n+    if let Some((_, [..], span_lo)) = method_call(earliest_replace_call) {\n+        span_lint_and_sugg(\n+            cx,\n+            COLLAPSIBLE_STR_REPLACE,\n+            expr.span.with_lo(span_lo.lo()),\n+            \"used consecutive `str::replace` call\",\n+            \"replace with\",\n+            format!(\n+                \"replace([{}], {})\",\n+                from_arg_reprs.join(\", \"),\n+                snippet(cx, to_arg.span, \"..\"),\n+            ),\n+            app,\n+        );\n     }\n }\n-\n-fn get_earliest_replace_call_span<'tcx>(expr: &'tcx hir::Expr<'tcx>) -> Span {\n-    let mut earliest_replace_call_span = expr.span;\n-\n-    let _: Option<()> = for_each_expr(expr, |e| {\n-        if let Some((name, [_, args @ ..], span)) = method_call(e) {\n-            match (name, args) {\n-                (\"replace\", [_, _]) => {\n-                    earliest_replace_call_span = span;\n-                    ControlFlow::Continue(())\n-                },\n-                _ => ControlFlow::BREAK,\n-            }\n-        } else {\n-            ControlFlow::Continue(())\n-        }\n-    });\n-\n-    earliest_replace_call_span\n-}\n-\n-/// Find the original receiver of a chain of `str::replace` method calls.\n-fn find_original_recv<'tcx>(recv: &'tcx hir::Expr<'tcx>) -> &'tcx hir::Expr<'tcx> {\n-    let mut original_recv = recv;\n-\n-    let _: Option<()> = for_each_expr(recv, |e| {\n-        if let Some((name, [prev_recv, args @ ..], _)) = method_call(e) {\n-            match (name, args) {\n-                (\"replace\", [_, _]) => {\n-                    original_recv = prev_recv;\n-                    ControlFlow::Continue(())\n-                },\n-                _ => ControlFlow::BREAK,\n-            }\n-        } else {\n-            ControlFlow::Continue(())\n-        }\n-    });\n-\n-    original_recv\n-}"}, {"sha": "49d4900295fd88ba4725e664da43dbd8b18ffcc3", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b070b4045f348f9222008270a435bda17b048c15/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b070b4045f348f9222008270a435bda17b048c15/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=b070b4045f348f9222008270a435bda17b048c15", "patch": "@@ -156,7 +156,7 @@ declare_clippy_lint! {\n     /// ```\n     /// Use instead:\n     /// ```rust\n-    /// let hello = \"hesuo worpd\".replace(|c| matches!(c, 's' | 'u' | 'p'), \"l\");\n+    /// let hello = \"hesuo worpd\".replace(&['s', 'u', 'p'], \"l\");\n     /// ```\n     #[clippy::version = \"1.64.0\"]\n     pub COLLAPSIBLE_STR_REPLACE,\n@@ -3507,6 +3507,14 @@ impl Methods {\n                 (\"repeat\", [arg]) => {\n                     repeat_once::check(cx, expr, recv, arg);\n                 },\n+                (name @ (\"replace\" | \"replacen\"), [arg1, arg2] | [arg1, arg2, _]) => {\n+                    no_effect_replace::check(cx, expr, arg1, arg2);\n+\n+                    // Check for repeated `str::replace` calls to perform `collapsible_str_replace` lint\n+                    if name == \"replace\" && let Some((\"replace\", ..)) = method_call(recv) {\n+                        collapsible_str_replace::check(cx, expr, arg1, arg2);\n+                    }\n+                },\n                 (\"resize\", [count_arg, default_arg]) => {\n                     vec_resize_to_zero::check(cx, expr, count_arg, default_arg, span);\n                 },\n@@ -3519,10 +3527,6 @@ impl Methods {\n                 (\"sort_unstable_by\", [arg]) => {\n                     unnecessary_sort_by::check(cx, expr, recv, arg, true);\n                 },\n-                (\"replace\" | \"replacen\", [arg1, arg2] | [arg1, arg2, _]) => {\n-                    no_effect_replace::check(cx, expr, arg1, arg2);\n-                    collapsible_str_replace::check(cx, expr, name, recv);\n-                },\n                 (\"splitn\" | \"rsplitn\", [count_arg, pat_arg]) => {\n                     if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n                         suspicious_splitn::check(cx, name, expr, recv, count);"}, {"sha": "49fc9a9629e25415a714b6e3616602c77367f239", "filename": "tests/ui/collapsible_str_replace.fixed", "status": "modified", "additions": 39, "deletions": 31, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/b070b4045f348f9222008270a435bda17b048c15/tests%2Fui%2Fcollapsible_str_replace.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b070b4045f348f9222008270a435bda17b048c15/tests%2Fui%2Fcollapsible_str_replace.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_str_replace.fixed?ref=b070b4045f348f9222008270a435bda17b048c15", "patch": "@@ -2,64 +2,72 @@\n \n #![warn(clippy::collapsible_str_replace)]\n \n-fn get_filter() -> &'static str {\n-    \"u\"\n+fn get_filter() -> char {\n+    'u'\n }\n \n fn main() {\n-    let misspelled = \"hesuo worpd\";\n-\n+    let d = 'd';\n     let p = 'p';\n     let s = 's';\n     let u = 'u';\n     let l = \"l\";\n \n+    let mut iter = [\"l\", \"z\"].iter();\n+\n     // LINT CASES\n-    let _ = misspelled.replace(|c| matches!(c, 'u' | 's'), \"l\");\n+    let _ = \"hesuo worpd\".replace(['s', 'u'], \"l\");\n \n-    let _ = misspelled.replace(|c| matches!(c, 'u' | 's'), l);\n+    let _ = \"hesuo worpd\".replace(['s', 'u'], l);\n \n-    let _ = misspelled.replace(|c| matches!(c, 'p' | 'u' | 's'), \"l\");\n+    let _ = \"hesuo worpd\".replace(['s', 'u', 'p'], \"l\");\n \n-    let _ = misspelled\n-        .replace(|c| matches!(c, 'd' | 'p' | 'u' | 's'), \"l\");\n+    let _ = \"hesuo worpd\"\n+        .replace(['s', 'u', 'p', 'd'], \"l\");\n \n-    // FALLBACK CASES\n-    // If there are consecutive calls to `str::replace` and all or any chars are variables,\n-    // recommend the fallback `misspelled.replace(&[s, u, p], \"l\")`\n-    let _ = misspelled.replace(&['u' , s], \"l\");\n+    let _ = \"hesuo world\".replace([s, 'u'], \"l\");\n \n-    let _ = misspelled.replace(&['p' , 'u' , s], \"l\");\n+    let _ = \"hesuo worpd\".replace([s, 'u', 'p'], \"l\");\n \n-    let _ = misspelled.replace(&['p' , u , s], \"l\");\n+    let _ = \"hesuo worpd\".replace([s, u, 'p'], \"l\");\n \n-    let _ = misspelled.replace(&[p , u , s], \"l\");\n+    let _ = \"hesuo worpd\".replace([s, u, p], \"l\");\n \n-    // NO LINT CASES\n-    let _ = misspelled.replace('s', \"l\");\n+    let _ = \"hesuo worlp\".replace(['s', 'u'], \"l\").replace('p', \"d\");\n+\n+    let _ = \"hesuo worpd\".replace('s', \"x\").replace(['u', 'p'], \"l\");\n \n-    let _ = misspelled.replace(s, \"l\");\n+    // Note: Future iterations could lint `replace(|c| matches!(c, \"su\" | 'd' | 'p'), \"l\")`\n+    let _ = \"hesudo worpd\".replace(\"su\", \"l\").replace(['d', 'p'], \"l\");\n \n-    // If the consecutive `str::replace` calls have different `to` arguments, do not lint\n-    let _ = misspelled.replace('s', \"l\").replace('u', \"p\");\n+    let _ = \"hesudo worpd\".replace([d, 'p'], \"l\").replace(\"su\", \"l\");\n+\n+    let _ = \"hesuo world\".replace([get_filter(), 's'], \"l\");\n+\n+    // NO LINT CASES\n+    let _ = \"hesuo world\".replace('s', \"l\").replace('u', \"p\");\n \n-    let _ = misspelled.replace(&get_filter(), \"l\");\n+    let _ = \"hesuo worpd\".replace('s', \"l\").replace('p', l);\n \n-    let _ = misspelled.replace(&['s', 'u', 'p'], \"l\");\n+    let _ = \"hesudo worpd\".replace('d', \"l\").replace(\"su\", \"l\").replace('p', \"l\");\n \n-    let _ = misspelled.replace(&['s', 'u', 'p'], l);\n+    // Note: Future iterations of `collapsible_str_replace` might lint this and combine to `[s, u, p]`\n+    let _ = \"hesuo worpd\".replace([s, u], \"l\").replace([u, p], \"l\");\n \n-    let _ = misspelled.replace(&['s', 'u'], \"l\").replace(&['u', 'p'], \"l\");\n+    let _ = \"hesuo worpd\".replace(['s', 'u'], \"l\").replace(['u', 'p'], \"l\");\n \n-    let _ = misspelled.replace('s', \"l\").replace(&['u', 'p'], \"l\");\n+    let _ = \"hesuo worpd\".replace('s', \"l\").replace(['u', 'p'], \"l\");\n \n-    let _ = misspelled.replace(&['s', 'u'], \"l\").replace('p', \"l\");\n+    let _ = \"hesuo worpd\".replace(['s', 'u', 'p'], \"l\").replace('r', \"l\");\n \n-    let _ = misspelled.replace(&['s', u, 'p'], \"l\");\n+    let _ = \"hesuo worpd\".replace(['s', 'u', 'p'], l).replace('r', l);\n \n-    let _ = misspelled.replace(&[s, u, 'p'], \"l\");\n+    let _ = \"hesuo worpd\".replace(['s', u, 'p'], \"l\").replace('r', \"l\");\n \n-    let _ = misspelled.replace(&[s, u, p], \"l\");\n+    let _ = \"hesuo worpd\".replace([s, u], \"l\").replace(p, \"l\");\n \n-    let _ = misspelled.replace(&[s, u], \"l\").replace(&[u, p], \"l\");\n+    // Regression test\n+    let _ = \"hesuo worpd\"\n+        .replace('u', iter.next().unwrap())\n+        .replace('s', iter.next().unwrap());\n }"}, {"sha": "e3e25c4146ffa6bdd7a71bcd2067ba9a6ec6b68e", "filename": "tests/ui/collapsible_str_replace.rs", "status": "modified", "additions": 38, "deletions": 30, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b070b4045f348f9222008270a435bda17b048c15/tests%2Fui%2Fcollapsible_str_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b070b4045f348f9222008270a435bda17b048c15/tests%2Fui%2Fcollapsible_str_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_str_replace.rs?ref=b070b4045f348f9222008270a435bda17b048c15", "patch": "@@ -2,67 +2,75 @@\n \n #![warn(clippy::collapsible_str_replace)]\n \n-fn get_filter() -> &'static str {\n-    \"u\"\n+fn get_filter() -> char {\n+    'u'\n }\n \n fn main() {\n-    let misspelled = \"hesuo worpd\";\n-\n+    let d = 'd';\n     let p = 'p';\n     let s = 's';\n     let u = 'u';\n     let l = \"l\";\n \n+    let mut iter = [\"l\", \"z\"].iter();\n+\n     // LINT CASES\n-    let _ = misspelled.replace('s', \"l\").replace('u', \"l\");\n+    let _ = \"hesuo worpd\".replace('s', \"l\").replace('u', \"l\");\n \n-    let _ = misspelled.replace('s', l).replace('u', l);\n+    let _ = \"hesuo worpd\".replace('s', l).replace('u', l);\n \n-    let _ = misspelled.replace('s', \"l\").replace('u', \"l\").replace('p', \"l\");\n+    let _ = \"hesuo worpd\".replace('s', \"l\").replace('u', \"l\").replace('p', \"l\");\n \n-    let _ = misspelled\n+    let _ = \"hesuo worpd\"\n         .replace('s', \"l\")\n         .replace('u', \"l\")\n         .replace('p', \"l\")\n         .replace('d', \"l\");\n \n-    // FALLBACK CASES\n-    // If there are consecutive calls to `str::replace` and all or any chars are variables,\n-    // recommend the fallback `misspelled.replace(&[s, u, p], \"l\")`\n-    let _ = misspelled.replace(s, \"l\").replace('u', \"l\");\n+    let _ = \"hesuo world\".replace(s, \"l\").replace('u', \"l\");\n \n-    let _ = misspelled.replace(s, \"l\").replace('u', \"l\").replace('p', \"l\");\n+    let _ = \"hesuo worpd\".replace(s, \"l\").replace('u', \"l\").replace('p', \"l\");\n \n-    let _ = misspelled.replace(s, \"l\").replace(u, \"l\").replace('p', \"l\");\n+    let _ = \"hesuo worpd\".replace(s, \"l\").replace(u, \"l\").replace('p', \"l\");\n \n-    let _ = misspelled.replace(s, \"l\").replace(u, \"l\").replace(p, \"l\");\n+    let _ = \"hesuo worpd\".replace(s, \"l\").replace(u, \"l\").replace(p, \"l\");\n \n-    // NO LINT CASES\n-    let _ = misspelled.replace('s', \"l\");\n+    let _ = \"hesuo worlp\".replace('s', \"l\").replace('u', \"l\").replace('p', \"d\");\n+\n+    let _ = \"hesuo worpd\".replace('s', \"x\").replace('u', \"l\").replace('p', \"l\");\n \n-    let _ = misspelled.replace(s, \"l\");\n+    // Note: Future iterations could lint `replace(|c| matches!(c, \"su\" | 'd' | 'p'), \"l\")`\n+    let _ = \"hesudo worpd\".replace(\"su\", \"l\").replace('d', \"l\").replace('p', \"l\");\n \n-    // If the consecutive `str::replace` calls have different `to` arguments, do not lint\n-    let _ = misspelled.replace('s', \"l\").replace('u', \"p\");\n+    let _ = \"hesudo worpd\".replace(d, \"l\").replace('p', \"l\").replace(\"su\", \"l\");\n+\n+    let _ = \"hesuo world\".replace(get_filter(), \"l\").replace('s', \"l\");\n+\n+    // NO LINT CASES\n+    let _ = \"hesuo world\".replace('s', \"l\").replace('u', \"p\");\n \n-    let _ = misspelled.replace(&get_filter(), \"l\");\n+    let _ = \"hesuo worpd\".replace('s', \"l\").replace('p', l);\n \n-    let _ = misspelled.replace(&['s', 'u', 'p'], \"l\");\n+    let _ = \"hesudo worpd\".replace('d', \"l\").replace(\"su\", \"l\").replace('p', \"l\");\n \n-    let _ = misspelled.replace(&['s', 'u', 'p'], l);\n+    // Note: Future iterations of `collapsible_str_replace` might lint this and combine to `[s, u, p]`\n+    let _ = \"hesuo worpd\".replace([s, u], \"l\").replace([u, p], \"l\");\n \n-    let _ = misspelled.replace(&['s', 'u'], \"l\").replace(&['u', 'p'], \"l\");\n+    let _ = \"hesuo worpd\".replace(['s', 'u'], \"l\").replace(['u', 'p'], \"l\");\n \n-    let _ = misspelled.replace('s', \"l\").replace(&['u', 'p'], \"l\");\n+    let _ = \"hesuo worpd\".replace('s', \"l\").replace(['u', 'p'], \"l\");\n \n-    let _ = misspelled.replace(&['s', 'u'], \"l\").replace('p', \"l\");\n+    let _ = \"hesuo worpd\".replace(['s', 'u', 'p'], \"l\").replace('r', \"l\");\n \n-    let _ = misspelled.replace(&['s', u, 'p'], \"l\");\n+    let _ = \"hesuo worpd\".replace(['s', 'u', 'p'], l).replace('r', l);\n \n-    let _ = misspelled.replace(&[s, u, 'p'], \"l\");\n+    let _ = \"hesuo worpd\".replace(['s', u, 'p'], \"l\").replace('r', \"l\");\n \n-    let _ = misspelled.replace(&[s, u, p], \"l\");\n+    let _ = \"hesuo worpd\".replace([s, u], \"l\").replace(p, \"l\");\n \n-    let _ = misspelled.replace(&[s, u], \"l\").replace(&[u, p], \"l\");\n+    // Regression test\n+    let _ = \"hesuo worpd\"\n+        .replace('u', iter.next().unwrap())\n+        .replace('s', iter.next().unwrap());\n }"}, {"sha": "8e3daf3b898a3328e6f5f9de77f42e24f2729b79", "filename": "tests/ui/collapsible_str_replace.stderr", "status": "modified", "additions": 54, "deletions": 24, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/b070b4045f348f9222008270a435bda17b048c15/tests%2Fui%2Fcollapsible_str_replace.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b070b4045f348f9222008270a435bda17b048c15/tests%2Fui%2Fcollapsible_str_replace.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_str_replace.stderr?ref=b070b4045f348f9222008270a435bda17b048c15", "patch": "@@ -1,56 +1,86 @@\n error: used consecutive `str::replace` call\n-  --> $DIR/collapsible_str_replace.rs:18:24\n+  --> $DIR/collapsible_str_replace.rs:19:27\n    |\n-LL |     let _ = misspelled.replace('s', \"l\").replace('u', \"l\");\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace(|c| matches!(c, 'u' | 's'), \"l\")`\n+LL |     let _ = \"hesuo worpd\".replace('s', \"l\").replace('u', \"l\");\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace(['s', 'u'], \"l\")`\n    |\n    = note: `-D clippy::collapsible-str-replace` implied by `-D warnings`\n \n error: used consecutive `str::replace` call\n-  --> $DIR/collapsible_str_replace.rs:20:24\n+  --> $DIR/collapsible_str_replace.rs:21:27\n    |\n-LL |     let _ = misspelled.replace('s', l).replace('u', l);\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace(|c| matches!(c, 'u' | 's'), l)`\n+LL |     let _ = \"hesuo worpd\".replace('s', l).replace('u', l);\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace(['s', 'u'], l)`\n \n error: used consecutive `str::replace` call\n-  --> $DIR/collapsible_str_replace.rs:22:24\n+  --> $DIR/collapsible_str_replace.rs:23:27\n    |\n-LL |     let _ = misspelled.replace('s', \"l\").replace('u', \"l\").replace('p', \"l\");\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace(|c| matches!(c, 'p' | 'u' | 's'), \"l\")`\n+LL |     let _ = \"hesuo worpd\".replace('s', \"l\").replace('u', \"l\").replace('p', \"l\");\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace(['s', 'u', 'p'], \"l\")`\n \n error: used consecutive `str::replace` call\n-  --> $DIR/collapsible_str_replace.rs:25:10\n+  --> $DIR/collapsible_str_replace.rs:26:10\n    |\n LL |           .replace('s', \"l\")\n    |  __________^\n LL | |         .replace('u', \"l\")\n LL | |         .replace('p', \"l\")\n LL | |         .replace('d', \"l\");\n-   | |__________________________^ help: replace with: `replace(|c| matches!(c, 'd' | 'p' | 'u' | 's'), \"l\")`\n+   | |__________________________^ help: replace with: `replace(['s', 'u', 'p', 'd'], \"l\")`\n \n error: used consecutive `str::replace` call\n-  --> $DIR/collapsible_str_replace.rs:33:24\n+  --> $DIR/collapsible_str_replace.rs:31:27\n    |\n-LL |     let _ = misspelled.replace(s, \"l\").replace('u', \"l\");\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace(&['u' , s], \"l\")`\n+LL |     let _ = \"hesuo world\".replace(s, \"l\").replace('u', \"l\");\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace([s, 'u'], \"l\")`\n \n error: used consecutive `str::replace` call\n-  --> $DIR/collapsible_str_replace.rs:35:24\n+  --> $DIR/collapsible_str_replace.rs:33:27\n    |\n-LL |     let _ = misspelled.replace(s, \"l\").replace('u', \"l\").replace('p', \"l\");\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace(&['p' , 'u' , s], \"l\")`\n+LL |     let _ = \"hesuo worpd\".replace(s, \"l\").replace('u', \"l\").replace('p', \"l\");\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace([s, 'u', 'p'], \"l\")`\n \n error: used consecutive `str::replace` call\n-  --> $DIR/collapsible_str_replace.rs:37:24\n+  --> $DIR/collapsible_str_replace.rs:35:27\n    |\n-LL |     let _ = misspelled.replace(s, \"l\").replace(u, \"l\").replace('p', \"l\");\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace(&['p' , u , s], \"l\")`\n+LL |     let _ = \"hesuo worpd\".replace(s, \"l\").replace(u, \"l\").replace('p', \"l\");\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace([s, u, 'p'], \"l\")`\n \n error: used consecutive `str::replace` call\n-  --> $DIR/collapsible_str_replace.rs:39:24\n+  --> $DIR/collapsible_str_replace.rs:37:27\n    |\n-LL |     let _ = misspelled.replace(s, \"l\").replace(u, \"l\").replace(p, \"l\");\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace(&[p , u , s], \"l\")`\n+LL |     let _ = \"hesuo worpd\".replace(s, \"l\").replace(u, \"l\").replace(p, \"l\");\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace([s, u, p], \"l\")`\n \n-error: aborting due to 8 previous errors\n+error: used consecutive `str::replace` call\n+  --> $DIR/collapsible_str_replace.rs:39:27\n+   |\n+LL |     let _ = \"hesuo worlp\".replace('s', \"l\").replace('u', \"l\").replace('p', \"d\");\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace(['s', 'u'], \"l\")`\n+\n+error: used consecutive `str::replace` call\n+  --> $DIR/collapsible_str_replace.rs:41:45\n+   |\n+LL |     let _ = \"hesuo worpd\".replace('s', \"x\").replace('u', \"l\").replace('p', \"l\");\n+   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace(['u', 'p'], \"l\")`\n+\n+error: used consecutive `str::replace` call\n+  --> $DIR/collapsible_str_replace.rs:44:47\n+   |\n+LL |     let _ = \"hesudo worpd\".replace(\"su\", \"l\").replace('d', \"l\").replace('p', \"l\");\n+   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace(['d', 'p'], \"l\")`\n+\n+error: used consecutive `str::replace` call\n+  --> $DIR/collapsible_str_replace.rs:46:28\n+   |\n+LL |     let _ = \"hesudo worpd\".replace(d, \"l\").replace('p', \"l\").replace(\"su\", \"l\");\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace([d, 'p'], \"l\")`\n+\n+error: used consecutive `str::replace` call\n+  --> $DIR/collapsible_str_replace.rs:48:27\n+   |\n+LL |     let _ = \"hesuo world\".replace(get_filter(), \"l\").replace('s', \"l\");\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `replace([get_filter(), 's'], \"l\")`\n+\n+error: aborting due to 13 previous errors\n "}]}