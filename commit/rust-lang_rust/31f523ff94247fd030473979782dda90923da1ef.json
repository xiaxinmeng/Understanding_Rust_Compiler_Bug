{"sha": "31f523ff94247fd030473979782dda90923da1ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxZjUyM2ZmOTQyNDdmZDAzMDQ3Mzk3OTc4MmRkYTkwOTIzZGExZWY=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2021-05-11T08:13:52Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2021-05-13T03:12:42Z"}, "message": "Simplified body_span and filtered span code\n\nSome code cleanup extracted from future (but unfinished) commit to fix\ncoverage in attr macro functions.", "tree": {"sha": "b14c048814ea0039b6b6a67dafaadf941278f4f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b14c048814ea0039b6b6a67dafaadf941278f4f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31f523ff94247fd030473979782dda90923da1ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31f523ff94247fd030473979782dda90923da1ef", "html_url": "https://github.com/rust-lang/rust/commit/31f523ff94247fd030473979782dda90923da1ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31f523ff94247fd030473979782dda90923da1ef/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e354cca69629045fe678918757ce036cea2be4f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e354cca69629045fe678918757ce036cea2be4f1", "html_url": "https://github.com/rust-lang/rust/commit/e354cca69629045fe678918757ce036cea2be4f1"}], "stats": {"total": 148, "additions": 80, "deletions": 68}, "files": [{"sha": "dc21bfbb445929696d66c20da3b134c7ade10b99", "filename": "compiler/rustc_mir/src/transform/coverage/mod.rs", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/31f523ff94247fd030473979782dda90923da1ef/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31f523ff94247fd030473979782dda90923da1ef/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fmod.rs?ref=31f523ff94247fd030473979782dda90923da1ef", "patch": "@@ -95,7 +95,7 @@ impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n \n         trace!(\"InstrumentCoverage starting for {:?}\", mir_source.def_id());\n         Instrumentor::new(&self.name(), tcx, mir_body).inject_counters();\n-        trace!(\"InstrumentCoverage starting for {:?}\", mir_source.def_id());\n+        trace!(\"InstrumentCoverage done for {:?}\", mir_source.def_id());\n     }\n }\n \n@@ -116,25 +116,7 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n         let def_id = mir_body.source.def_id();\n         let (some_fn_sig, hir_body) = fn_sig_and_body(tcx, def_id);\n \n-        let mut body_span = hir_body.value.span;\n-\n-        if tcx.is_closure(def_id) {\n-            // If the MIR function is a closure, and if the closure body span\n-            // starts from a macro, but it's content is not in that macro, try\n-            // to find a non-macro callsite, and instrument the spans there\n-            // instead.\n-            loop {\n-                let expn_data = body_span.ctxt().outer_expn_data();\n-                if expn_data.is_root() {\n-                    break;\n-                }\n-                if let ExpnKind::Macro { .. } = expn_data.kind {\n-                    body_span = expn_data.call_site;\n-                } else {\n-                    break;\n-                }\n-            }\n-        }\n+        let body_span = get_body_span(tcx, hir_body, mir_body);\n \n         let source_file = source_map.lookup_source_file(body_span.lo());\n         let fn_sig_span = match some_fn_sig.filter(|fn_sig| {\n@@ -144,6 +126,15 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n             Some(fn_sig) => fn_sig.span.with_hi(body_span.lo()),\n             None => body_span.shrink_to_lo(),\n         };\n+\n+        debug!(\n+            \"instrumenting {}: {:?}, fn sig span: {:?}, body span: {:?}\",\n+            if tcx.is_closure(def_id) { \"closure\" } else { \"function\" },\n+            def_id,\n+            fn_sig_span,\n+            body_span\n+        );\n+\n         let function_source_hash = hash_mir_source(tcx, hir_body);\n         let basic_coverage_blocks = CoverageGraph::from_mir(mir_body);\n         Self {\n@@ -160,19 +151,21 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n \n     fn inject_counters(&'a mut self) {\n         let tcx = self.tcx;\n-        let source_map = tcx.sess.source_map();\n         let mir_source = self.mir_body.source;\n         let def_id = mir_source.def_id();\n         let fn_sig_span = self.fn_sig_span;\n         let body_span = self.body_span;\n \n+<<<<<<< HEAD\n         debug!(\n             \"instrumenting {:?}, fn sig span: {}, body span: {}\",\n             def_id,\n             source_map.span_to_diagnostic_string(fn_sig_span),\n             source_map.span_to_diagnostic_string(body_span)\n         );\n \n+=======\n+>>>>>>> 476104d0f54 (Simplified body_span and filtered span code)\n         let mut graphviz_data = debug::GraphvizData::new();\n         let mut debug_used_expressions = debug::UsedExpressions::new();\n \n@@ -561,6 +554,35 @@ fn fn_sig_and_body<'tcx>(\n     (hir::map::fn_sig(hir_node), tcx.hir().body(fn_body_id))\n }\n \n+fn get_body_span<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    hir_body: &rustc_hir::Body<'tcx>,\n+    mir_body: &mut mir::Body<'tcx>,\n+) -> Span {\n+    let mut body_span = hir_body.value.span;\n+    let def_id = mir_body.source.def_id();\n+\n+    if tcx.is_closure(def_id) {\n+        // If the MIR function is a closure, and if the closure body span\n+        // starts from a macro, but it's content is not in that macro, try\n+        // to find a non-macro callsite, and instrument the spans there\n+        // instead.\n+        loop {\n+            let expn_data = body_span.ctxt().outer_expn_data();\n+            if expn_data.is_root() {\n+                break;\n+            }\n+            if let ExpnKind::Macro{..} = expn_data.kind {\n+                body_span = expn_data.call_site;\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+    body_span\n+}\n+\n fn hash_mir_source<'tcx>(tcx: TyCtxt<'tcx>, hir_body: &'tcx rustc_hir::Body<'tcx>) -> u64 {\n     let mut hcx = tcx.create_no_span_stable_hashing_context();\n     hash(&mut hcx, &hir_body.value).to_smaller_hash()"}, {"sha": "f62171b3c535c757fe25accb398462dfa7bce5b3", "filename": "compiler/rustc_mir/src/transform/coverage/spans.rs", "status": "modified", "additions": 35, "deletions": 43, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/31f523ff94247fd030473979782dda90923da1ef/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31f523ff94247fd030473979782dda90923da1ef/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs?ref=31f523ff94247fd030473979782dda90923da1ef", "patch": "@@ -530,17 +530,25 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n                     .iter()\n                     .enumerate()\n                     .filter_map(move |(index, statement)| {\n-                        filtered_statement_span(statement, self.body_span).map(\n-                            |(span, expn_span)| {\n-                                CoverageSpan::for_statement(\n-                                    statement, span, expn_span, bcb, bb, index,\n-                                )\n-                            },\n-                        )\n+                        filtered_statement_span(statement).map(|span| {\n+                            CoverageSpan::for_statement(\n+                                statement,\n+                                function_source_span(span, self.body_span),\n+                                span,\n+                                bcb,\n+                                bb,\n+                                index,\n+                            )\n+                        })\n                     })\n-                    .chain(filtered_terminator_span(data.terminator(), self.body_span).map(\n-                        |(span, expn_span)| CoverageSpan::for_terminator(span, expn_span, bcb, bb),\n-                    ))\n+                    .chain(filtered_terminator_span(data.terminator()).map(|span| {\n+                        CoverageSpan::for_terminator(\n+                            function_source_span(span, self.body_span),\n+                            span,\n+                            bcb,\n+                            bb,\n+                        )\n+                    }))\n             })\n             .collect()\n     }\n@@ -795,13 +803,9 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n     }\n }\n \n-/// See `function_source_span()` for a description of the two returned spans.\n-/// If the MIR `Statement` is not contributive to computing coverage spans,\n-/// returns `None`.\n-pub(super) fn filtered_statement_span(\n-    statement: &'a Statement<'tcx>,\n-    body_span: Span,\n-) -> Option<(Span, Span)> {\n+/// If the MIR `Statement` has a span contributive to computing coverage spans,\n+/// return it; otherwise return `None`.\n+pub(super) fn filtered_statement_span(statement: &'a Statement<'tcx>) -> Option<Span> {\n     match statement.kind {\n         // These statements have spans that are often outside the scope of the executed source code\n         // for their parent `BasicBlock`.\n@@ -838,18 +842,14 @@ pub(super) fn filtered_statement_span(\n         | StatementKind::LlvmInlineAsm(_)\n         | StatementKind::Retag(_, _)\n         | StatementKind::AscribeUserType(_, _) => {\n-            Some(function_source_span(statement.source_info.span, body_span))\n+            Some(statement.source_info.span)\n         }\n     }\n }\n \n-/// See `function_source_span()` for a description of the two returned spans.\n-/// If the MIR `Terminator` is not contributive to computing coverage spans,\n-/// returns `None`.\n-pub(super) fn filtered_terminator_span(\n-    terminator: &'a Terminator<'tcx>,\n-    body_span: Span,\n-) -> Option<(Span, Span)> {\n+/// If the MIR `Terminator` has a span contributive to computing coverage spans,\n+/// return it; otherwise return `None`.\n+pub(super) fn filtered_terminator_span(terminator: &'a Terminator<'tcx>) -> Option<Span> {\n     match terminator.kind {\n         // These terminators have spans that don't positively contribute to computing a reasonable\n         // span of actually executed source code. (For example, SwitchInt terminators extracted from\n@@ -873,7 +873,7 @@ pub(super) fn filtered_terminator_span(\n                     span = span.with_lo(constant.span.lo());\n                 }\n             }\n-            Some(function_source_span(span, body_span))\n+            Some(span)\n         }\n \n         // Retain spans from all other terminators\n@@ -884,28 +884,20 @@ pub(super) fn filtered_terminator_span(\n         | TerminatorKind::GeneratorDrop\n         | TerminatorKind::FalseUnwind { .. }\n         | TerminatorKind::InlineAsm { .. } => {\n-            Some(function_source_span(terminator.source_info.span, body_span))\n+            Some(terminator.source_info.span)\n         }\n     }\n }\n \n-/// Returns two spans from the given span (the span associated with a\n-/// `Statement` or `Terminator`):\n-///\n-///   1. An extrapolated span (pre-expansion[^1]) corresponding to a range within\n-///      the function's body source. This span is guaranteed to be contained\n-///      within, or equal to, the `body_span`. If the extrapolated span is not\n-///      contained within the `body_span`, the `body_span` is returned.\n-///   2. The actual `span` value from the `Statement`, before expansion.\n-///\n-/// Only the first span is used when computing coverage code regions. The second\n-/// span is useful if additional expansion data is needed (such as to look up\n-/// the macro name for a composed span within that macro).)\n+/// Returns an extrapolated span (pre-expansion[^1]) corresponding to a range\n+/// within the function's body source. This span is guaranteed to be contained\n+/// within, or equal to, the `body_span`. If the extrapolated span is not\n+/// contained within the `body_span`, the `body_span` is returned.\n ///\n-/// [^1]Expansions result from Rust syntax including macros, syntactic\n-/// sugar, etc.).\n+/// [^1]Expansions result from Rust syntax including macros, syntactic sugar,\n+/// etc.).\n #[inline]\n-fn function_source_span(span: Span, body_span: Span) -> (Span, Span) {\n+pub(super) fn function_source_span(span: Span, body_span: Span) -> Span {\n     let original_span = original_sp(span, body_span).with_ctxt(body_span.ctxt());\n-    (if body_span.contains(original_span) { original_span } else { body_span }, span)\n+    if body_span.contains(original_span) { original_span } else { body_span }\n }"}, {"sha": "b04c2d542d459fda4a9b5aa30f1e0208b65bede1", "filename": "compiler/rustc_mir/src/transform/coverage/tests.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31f523ff94247fd030473979782dda90923da1ef/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31f523ff94247fd030473979782dda90923da1ef/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs?ref=31f523ff94247fd030473979782dda90923da1ef", "patch": "@@ -683,12 +683,10 @@ fn test_make_bcb_counters() {\n         let mut basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n         let mut coverage_spans = Vec::new();\n         for (bcb, data) in basic_coverage_blocks.iter_enumerated() {\n-            if let Some((span, expn_span)) =\n-                spans::filtered_terminator_span(data.terminator(&mir_body), body_span)\n-            {\n+            if let Some(span) = spans::filtered_terminator_span(data.terminator(&mir_body)) {\n                 coverage_spans.push(spans::CoverageSpan::for_terminator(\n+                    spans::function_source_span(span, body_span),\n                     span,\n-                    expn_span,\n                     bcb,\n                     data.last_bb(),\n                 ));"}]}