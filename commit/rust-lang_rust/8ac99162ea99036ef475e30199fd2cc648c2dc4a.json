{"sha": "8ac99162ea99036ef475e30199fd2cc648c2dc4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhYzk5MTYyZWE5OTAzNmVmNDc1ZTMwMTk5ZmQyY2M2NDhjMmRjNGE=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-08-08T19:13:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-08T19:13:16Z"}, "message": "Merge pull request #1152 from oli-obk/wrong_self_conv_fn_level\n\nenable changing wrong_self_convention's lint level at the function level", "tree": {"sha": "6317842fa20ddd698a52c652cb79acba78eeab96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6317842fa20ddd698a52c652cb79acba78eeab96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ac99162ea99036ef475e30199fd2cc648c2dc4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ac99162ea99036ef475e30199fd2cc648c2dc4a", "html_url": "https://github.com/rust-lang/rust/commit/8ac99162ea99036ef475e30199fd2cc648c2dc4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ac99162ea99036ef475e30199fd2cc648c2dc4a/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b8f6a0b0f11296376591b7431b15c31b7b5afc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b8f6a0b0f11296376591b7431b15c31b7b5afc3", "html_url": "https://github.com/rust-lang/rust/commit/4b8f6a0b0f11296376591b7431b15c31b7b5afc3"}, {"sha": "49f276ec6f08a136c00ff621caf77500e03c16d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/49f276ec6f08a136c00ff621caf77500e03c16d3", "html_url": "https://github.com/rust-lang/rust/commit/49f276ec6f08a136c00ff621caf77500e03c16d3"}], "stats": {"total": 109, "additions": 55, "deletions": 54}, "files": [{"sha": "d6d51e2d7804986e20361e6b8e1af72ae7ccbd64", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 52, "deletions": 54, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/8ac99162ea99036ef475e30199fd2cc648c2dc4a/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac99162ea99036ef475e30199fd2cc648c2dc4a/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=8ac99162ea99036ef475e30199fd2cc648c2dc4a", "patch": "@@ -538,68 +538,66 @@ impl LateLintPass for Pass {\n         }\n     }\n \n-    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n-        if in_external_macro(cx, item.span) {\n+    fn check_impl_item(&mut self, cx: &LateContext, implitem: &hir::ImplItem) {\n+        if in_external_macro(cx, implitem.span) {\n             return;\n         }\n+        let name = implitem.name;\n+        let parent = cx.tcx.map.get_parent(implitem.id);\n+        let item = cx.tcx.map.expect_item(parent);\n+        if_let_chain! {[\n+            let hir::ImplItemKind::Method(ref sig, _) = implitem.node,\n+            let Some(explicit_self) = sig.decl.inputs.get(0).and_then(hir::Arg::to_self),\n+            let hir::ItemImpl(_, _, _, None, _, _) = item.node,\n+        ], {\n+            // check missing trait implementations\n+            for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n+                if name.as_str() == method_name &&\n+                   sig.decl.inputs.len() == n_args &&\n+                   out_type.matches(&sig.decl.output) &&\n+                   self_kind.matches(&explicit_self, false) {\n+                    span_lint(cx, SHOULD_IMPLEMENT_TRAIT, implitem.span, &format!(\n+                        \"defining a method called `{}` on this type; consider implementing \\\n+                         the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n+                }\n+            }\n \n-        if let hir::ItemImpl(_, _, _, None, _, ref items) = item.node {\n-            for implitem in items {\n-                let name = implitem.name;\n+            // check conventions w.r.t. conversion method names and predicates\n+            let ty = cx.tcx.lookup_item_type(cx.tcx.map.local_def_id(item.id)).ty;\n+            let is_copy = is_copy(cx, ty, item.id);\n+            for &(ref conv, self_kinds) in &CONVENTIONS {\n                 if_let_chain! {[\n-                    let hir::ImplItemKind::Method(ref sig, _) = implitem.node,\n+                    conv.check(&name.as_str()),\n                     let Some(explicit_self) = sig.decl.inputs.get(0).and_then(hir::Arg::to_self),\n+                    !self_kinds.iter().any(|k| k.matches(&explicit_self, is_copy)),\n                 ], {\n-                    // check missing trait implementations\n-                    for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n-                        if name.as_str() == method_name &&\n-                           sig.decl.inputs.len() == n_args &&\n-                           out_type.matches(&sig.decl.output) &&\n-                           self_kind.matches(&explicit_self, false) {\n-                            span_lint(cx, SHOULD_IMPLEMENT_TRAIT, implitem.span, &format!(\n-                                \"defining a method called `{}` on this type; consider implementing \\\n-                                 the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n-                        }\n-                    }\n-\n-                    // check conventions w.r.t. conversion method names and predicates\n-                    let ty = cx.tcx.lookup_item_type(cx.tcx.map.local_def_id(item.id)).ty;\n-                    let is_copy = is_copy(cx, ty, item.id);\n-                    for &(ref conv, self_kinds) in &CONVENTIONS {\n-                        if_let_chain! {[\n-                            conv.check(&name.as_str()),\n-                            let Some(explicit_self) = sig.decl.inputs.get(0).and_then(hir::Arg::to_self),\n-                            !self_kinds.iter().any(|k| k.matches(&explicit_self, is_copy)),\n-                        ], {\n-                            let lint = if item.vis == hir::Visibility::Public {\n-                                WRONG_PUB_SELF_CONVENTION\n-                            } else {\n-                                WRONG_SELF_CONVENTION\n-                            };\n-                            span_lint(cx,\n-                                      lint,\n-                                      explicit_self.span,\n-                                      &format!(\"methods called `{}` usually take {}; consider choosing a less \\\n-                                                ambiguous name\",\n-                                               conv,\n-                                               &self_kinds.iter()\n-                                                          .map(|k| k.description())\n-                                                          .collect::<Vec<_>>()\n-                                                          .join(\" or \")));\n-                        }}\n-                    }\n-\n-                    let ret_ty = return_ty(cx, implitem.id);\n-                    if &name.as_str() == &\"new\" &&\n-                       !ret_ty.map_or(false, |ret_ty| ret_ty.walk().any(|t| same_tys(cx, t, ty, implitem.id))) {\n-                        span_lint(cx,\n-                                  NEW_RET_NO_SELF,\n-                                  explicit_self.span,\n-                                  \"methods called `new` usually return `Self`\");\n-                    }\n+                    let lint = if item.vis == hir::Visibility::Public {\n+                        WRONG_PUB_SELF_CONVENTION\n+                    } else {\n+                        WRONG_SELF_CONVENTION\n+                    };\n+                    span_lint(cx,\n+                              lint,\n+                              explicit_self.span,\n+                              &format!(\"methods called `{}` usually take {}; consider choosing a less \\\n+                                        ambiguous name\",\n+                                       conv,\n+                                       &self_kinds.iter()\n+                                                  .map(|k| k.description())\n+                                                  .collect::<Vec<_>>()\n+                                                  .join(\" or \")));\n                 }}\n             }\n-        }\n+\n+            let ret_ty = return_ty(cx, implitem.id);\n+            if &name.as_str() == &\"new\" &&\n+               !ret_ty.map_or(false, |ret_ty| ret_ty.walk().any(|t| same_tys(cx, t, ty, implitem.id))) {\n+                span_lint(cx,\n+                          NEW_RET_NO_SELF,\n+                          explicit_self.span,\n+                          \"methods called `new` usually return `Self`\");\n+            }\n+        }}\n     }\n }\n "}, {"sha": "682f522b363d9e39ecb6994396f4abbd48210ad8", "filename": "tests/compile-fail/wrong_self_convention.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ac99162ea99036ef475e30199fd2cc648c2dc4a/tests%2Fcompile-fail%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac99162ea99036ef475e30199fd2cc648c2dc4a/tests%2Fcompile-fail%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fwrong_self_convention.rs?ref=8ac99162ea99036ef475e30199fd2cc648c2dc4a", "patch": "@@ -23,6 +23,9 @@ impl Foo {\n     pub fn is_i64(self) {}\n     pub fn to_i64(self) {}\n     pub fn from_i64(self) {} //~ERROR: methods called `from_*` usually take no self\n+    // check whether the lint can be allowed at the function level\n+    #[allow(wrong_self_convention)]\n+    pub fn from_cake(self) {}\n \n }\n "}]}