{"sha": "a96e3883c130972ac01348df2a912dc97843939d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5NmUzODgzYzEzMDk3MmFjMDEzNDhkZjJhOTEyZGM5Nzg0MzkzOWQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-04-03T02:36:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-04-03T02:36:12Z"}, "message": "Rollup merge of #59514 - tmandry:remove-adt-def-from-projection-elem, r=eddyb\n\nRemove adt_def from projections and downcasts in MIR\n\nAs part of optimizing generator layouts in MIR, we'd like to allow downcasting generators to variants which do not have a corresponding `def_id`, since they are created by the compiler.\n\nThis refactor hopes to allow that, without regressing perf.\n\nr? @eddyb", "tree": {"sha": "797ec7fc780c449cac492f1c782b274f7c8b02a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/797ec7fc780c449cac492f1c782b274f7c8b02a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a96e3883c130972ac01348df2a912dc97843939d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcpBwcCRBK7hj4Ov3rIwAAdHIIAH/YC8dYtvBvpNaTWNhWlnfU\nQuLgJVlUKtzOwoLvmGTXNTHST1/94eCPyyml3Z/HVNExo5x6yQen3+WYRrqy196V\nrC+amABRtdNP4srQJTRFaMxFUFPrgIxiwGil3NrCIxzyZ/3QWh3wqO8bxMVx9ECI\nTGkRYFeY6oRloE6aauYVORpD/SXd66ey7EXZHDS2wpUDi9fO4CebX4gco2Vk89Jg\nKSSvx/ZGxFWfO+idAETfVk4/MHqDy3vR7KlWp4KMyUQ4NRFRS6+g7oCAw0GgE0ls\nZM76ZUgdHuoSN6THIALPGjs1BNNCMkwAoDfQSnfDgf3sDiRaqZN8MrlZpTzA414=\n=Wqzd\n-----END PGP SIGNATURE-----\n", "payload": "tree 797ec7fc780c449cac492f1c782b274f7c8b02a1\nparent 9898182b478d0c6ad560627260d61c82a56c0f75\nparent 4122d2221ec65232bc211a266d0796a4713e0d39\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1554258972 +0200\ncommitter GitHub <noreply@github.com> 1554258972 +0200\n\nRollup merge of #59514 - tmandry:remove-adt-def-from-projection-elem, r=eddyb\n\nRemove adt_def from projections and downcasts in MIR\n\nAs part of optimizing generator layouts in MIR, we'd like to allow downcasting generators to variants which do not have a corresponding `def_id`, since they are created by the compiler.\n\nThis refactor hopes to allow that, without regressing perf.\n\nr? @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a96e3883c130972ac01348df2a912dc97843939d", "html_url": "https://github.com/rust-lang/rust/commit/a96e3883c130972ac01348df2a912dc97843939d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a96e3883c130972ac01348df2a912dc97843939d/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9898182b478d0c6ad560627260d61c82a56c0f75", "url": "https://api.github.com/repos/rust-lang/rust/commits/9898182b478d0c6ad560627260d61c82a56c0f75", "html_url": "https://github.com/rust-lang/rust/commit/9898182b478d0c6ad560627260d61c82a56c0f75"}, {"sha": "4122d2221ec65232bc211a266d0796a4713e0d39", "url": "https://api.github.com/repos/rust-lang/rust/commits/4122d2221ec65232bc211a266d0796a4713e0d39", "html_url": "https://github.com/rust-lang/rust/commit/4122d2221ec65232bc211a266d0796a4713e0d39"}], "stats": {"total": 567, "additions": 277, "deletions": 290}, "files": [{"sha": "a72161084f38c9a33928cccf78ef9b6b3a138f0c", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -25,7 +25,7 @@ use std::slice;\n use std::vec::IntoIter;\n use std::{iter, mem, option, u32};\n use syntax::ast::{self, Name};\n-use syntax::symbol::InternedString;\n+use syntax::symbol::{InternedString, Symbol};\n use syntax_pos::{Span, DUMMY_SP};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::subst::{Subst, SubstsRef};\n@@ -772,7 +772,7 @@ pub struct LocalDecl<'tcx> {\n     /// e.g., via `let x: T`, then we carry that type here. The MIR\n     /// borrow checker needs this information since it can affect\n     /// region inference.\n-    pub user_ty: UserTypeProjections<'tcx>,\n+    pub user_ty: UserTypeProjections,\n \n     /// Name of the local, used in debuginfo and pretty-printing.\n     ///\n@@ -1805,7 +1805,7 @@ pub enum StatementKind<'tcx> {\n     /// - `Contravariant` -- requires that `T_y :> T`\n     /// - `Invariant` -- requires that `T_y == T`\n     /// - `Bivariant` -- no effect\n-    AscribeUserType(Place<'tcx>, ty::Variance, Box<UserTypeProjection<'tcx>>),\n+    AscribeUserType(Place<'tcx>, ty::Variance, Box<UserTypeProjection>),\n \n     /// No-op. Useful for deleting instructions without affecting statement indices.\n     Nop,\n@@ -1939,14 +1939,14 @@ impl_stable_hash_for!(struct Static<'tcx> {\n /// `PlaceProjection` etc below.\n #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord,\n          Hash, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct Projection<'tcx, B, V, T> {\n+pub struct Projection<B, V, T> {\n     pub base: B,\n-    pub elem: ProjectionElem<'tcx, V, T>,\n+    pub elem: ProjectionElem<V, T>,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord,\n          Hash, RustcEncodable, RustcDecodable, HashStable)]\n-pub enum ProjectionElem<'tcx, V, T> {\n+pub enum ProjectionElem<V, T> {\n     Deref,\n     Field(Field, T),\n     Index(V),\n@@ -1980,16 +1980,18 @@ pub enum ProjectionElem<'tcx, V, T> {\n     /// \"Downcast\" to a variant of an ADT. Currently, we only introduce\n     /// this for ADTs with more than one variant. It may be better to\n     /// just introduce it always, or always for enums.\n-    Downcast(&'tcx AdtDef, VariantIdx),\n+    ///\n+    /// The included Symbol is the name of the variant, used for printing MIR.\n+    Downcast(Option<Symbol>, VariantIdx),\n }\n \n /// Alias for projections as they appear in places, where the base is a place\n /// and the index is a local.\n-pub type PlaceProjection<'tcx> = Projection<'tcx, Place<'tcx>, Local, Ty<'tcx>>;\n+pub type PlaceProjection<'tcx> = Projection<Place<'tcx>, Local, Ty<'tcx>>;\n \n /// Alias for projections as they appear in places, where the base is a place\n /// and the index is a local.\n-pub type PlaceElem<'tcx> = ProjectionElem<'tcx, Local, Ty<'tcx>>;\n+pub type PlaceElem<'tcx> = ProjectionElem<Local, Ty<'tcx>>;\n \n // at least on 64 bit systems, `PlaceElem` should not be larger than two pointers\n static_assert!(PROJECTION_ELEM_IS_2_PTRS_LARGE:\n@@ -1998,7 +2000,7 @@ static_assert!(PROJECTION_ELEM_IS_2_PTRS_LARGE:\n \n /// Alias for projections as they appear in `UserTypeProjection`, where we\n /// need neither the `V` parameter for `Index` nor the `T` for `Field`.\n-pub type ProjectionKind<'tcx> = ProjectionElem<'tcx, (), ()>;\n+pub type ProjectionKind = ProjectionElem<(), ()>;\n \n newtype_index! {\n     pub struct Field {\n@@ -2019,7 +2021,9 @@ impl<'tcx> Place<'tcx> {\n     }\n \n     pub fn downcast(self, adt_def: &'tcx AdtDef, variant_index: VariantIdx) -> Place<'tcx> {\n-        self.elem(ProjectionElem::Downcast(adt_def, variant_index))\n+        self.elem(ProjectionElem::Downcast(\n+            Some(adt_def.variants[variant_index].ident.name),\n+            variant_index))\n     }\n \n     pub fn index(self, index: Local) -> Place<'tcx> {\n@@ -2080,8 +2084,11 @@ impl<'tcx> Debug for Place<'tcx> {\n                 )\n             },\n             Projection(ref data) => match data.elem {\n-                ProjectionElem::Downcast(ref adt_def, index) => {\n-                    write!(fmt, \"({:?} as {})\", data.base, adt_def.variants[index].ident)\n+                ProjectionElem::Downcast(Some(name), _index) => {\n+                    write!(fmt, \"({:?} as {})\", data.base, name)\n+                }\n+                ProjectionElem::Downcast(None, index) => {\n+                    write!(fmt, \"({:?} as variant#{:?})\", data.base, index)\n                 }\n                 ProjectionElem::Deref => write!(fmt, \"(*{:?})\", data.base),\n                 ProjectionElem::Field(field, ty) => {\n@@ -2542,36 +2549,36 @@ pub struct Constant<'tcx> {\n /// inferred region `'1`). The second will lead to the constraint `w:\n /// &'static str`.\n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct UserTypeProjections<'tcx> {\n-    pub(crate) contents: Vec<(UserTypeProjection<'tcx>, Span)>,\n+pub struct UserTypeProjections {\n+    pub(crate) contents: Vec<(UserTypeProjection, Span)>,\n }\n \n BraceStructTypeFoldableImpl! {\n-    impl<'tcx> TypeFoldable<'tcx> for UserTypeProjections<'tcx> {\n+    impl<'tcx> TypeFoldable<'tcx> for UserTypeProjections {\n         contents\n     }\n }\n \n-impl<'tcx> UserTypeProjections<'tcx> {\n+impl<'tcx> UserTypeProjections {\n     pub fn none() -> Self {\n         UserTypeProjections { contents: vec![] }\n     }\n \n-    pub fn from_projections(projs: impl Iterator<Item=(UserTypeProjection<'tcx>, Span)>) -> Self {\n+    pub fn from_projections(projs: impl Iterator<Item=(UserTypeProjection, Span)>) -> Self {\n         UserTypeProjections { contents: projs.collect() }\n     }\n \n-    pub fn projections_and_spans(&self) -> impl Iterator<Item=&(UserTypeProjection<'tcx>, Span)> {\n+    pub fn projections_and_spans(&self) -> impl Iterator<Item=&(UserTypeProjection, Span)> {\n         self.contents.iter()\n     }\n \n-    pub fn projections(&self) -> impl Iterator<Item=&UserTypeProjection<'tcx>> {\n+    pub fn projections(&self) -> impl Iterator<Item=&UserTypeProjection> {\n         self.contents.iter().map(|&(ref user_type, _span)| user_type)\n     }\n \n     pub fn push_projection(\n         mut self,\n-        user_ty: &UserTypeProjection<'tcx>,\n+        user_ty: &UserTypeProjection,\n         span: Span,\n     ) -> Self {\n         self.contents.push((user_ty.clone(), span));\n@@ -2580,7 +2587,7 @@ impl<'tcx> UserTypeProjections<'tcx> {\n \n     fn map_projections(\n         mut self,\n-        mut f: impl FnMut(UserTypeProjection<'tcx>) -> UserTypeProjection<'tcx>\n+        mut f: impl FnMut(UserTypeProjection) -> UserTypeProjection\n     ) -> Self {\n         self.contents = self.contents.drain(..).map(|(proj, span)| (f(proj), span)).collect();\n         self\n@@ -2628,14 +2635,14 @@ impl<'tcx> UserTypeProjections<'tcx> {\n ///   `field[0]` (aka `.0`), indicating that the type of `s` is\n ///   determined by finding the type of the `.0` field from `T`.\n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct UserTypeProjection<'tcx> {\n+pub struct UserTypeProjection {\n     pub base: UserTypeAnnotationIndex,\n-    pub projs: Vec<ProjectionElem<'tcx, (), ()>>,\n+    pub projs: Vec<ProjectionElem<(), ()>>,\n }\n \n-impl<'tcx> Copy for ProjectionKind<'tcx> { }\n+impl Copy for ProjectionKind { }\n \n-impl<'tcx> UserTypeProjection<'tcx> {\n+impl UserTypeProjection {\n     pub(crate) fn index(mut self) -> Self {\n         self.projs.push(ProjectionElem::Index(()));\n         self\n@@ -2662,15 +2669,17 @@ impl<'tcx> UserTypeProjection<'tcx> {\n         variant_index: VariantIdx,\n         field: Field,\n     ) -> Self {\n-        self.projs.push(ProjectionElem::Downcast(adt_def, variant_index));\n+        self.projs.push(ProjectionElem::Downcast(\n+            Some(adt_def.variants[variant_index].ident.name),\n+            variant_index));\n         self.projs.push(ProjectionElem::Field(field, ()));\n         self\n     }\n }\n \n-CloneTypeFoldableAndLiftImpls! { ProjectionKind<'tcx>, }\n+CloneTypeFoldableAndLiftImpls! { ProjectionKind, }\n \n-impl<'tcx> TypeFoldable<'tcx> for UserTypeProjection<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for UserTypeProjection {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         use crate::mir::ProjectionElem::*;\n \n@@ -3428,7 +3437,7 @@ impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n     }\n }\n \n-impl<'tcx, B, V, T> TypeFoldable<'tcx> for Projection<'tcx, B, V, T>\n+impl<'tcx, B, V, T> TypeFoldable<'tcx> for Projection<B, V, T>\n where\n     B: TypeFoldable<'tcx>,\n     V: TypeFoldable<'tcx>,"}, {"sha": "0eb37f0ac9e9604b6b71466ce1b2d95769bc13ba", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 43, "deletions": 76, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -4,21 +4,17 @@\n  */\n \n use crate::mir::*;\n-use crate::ty::subst::{Subst, SubstsRef};\n-use crate::ty::{self, AdtDef, Ty, TyCtxt};\n+use crate::ty::subst::Subst;\n+use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::layout::VariantIdx;\n use crate::hir;\n use crate::ty::util::IntTypeExt;\n \n #[derive(Copy, Clone, Debug)]\n-pub enum PlaceTy<'tcx> {\n-    /// Normal type.\n-    Ty { ty: Ty<'tcx> },\n-\n-    /// Downcast to a particular variant of an enum.\n-    Downcast { adt_def: &'tcx AdtDef,\n-               substs: SubstsRef<'tcx>,\n-               variant_index: VariantIdx },\n+pub struct PlaceTy<'tcx> {\n+    pub ty: Ty<'tcx>,\n+    /// Downcast to a particular variant of an enum, if included.\n+    pub variant_index: Option<VariantIdx>,\n }\n \n static_assert!(PLACE_TY_IS_3_PTRS_LARGE:\n@@ -27,16 +23,7 @@ static_assert!(PLACE_TY_IS_3_PTRS_LARGE:\n \n impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n     pub fn from_ty(ty: Ty<'tcx>) -> PlaceTy<'tcx> {\n-        PlaceTy::Ty { ty }\n-    }\n-\n-    pub fn to_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n-        match *self {\n-            PlaceTy::Ty { ty } =>\n-                ty,\n-            PlaceTy::Downcast { adt_def, substs, variant_index: _ } =>\n-                tcx.mk_adt(adt_def, substs),\n-        }\n+        PlaceTy { ty, variant_index: None }\n     }\n \n     /// `place_ty.field_ty(tcx, f)` computes the type at a given field\n@@ -48,21 +35,20 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n     /// Note that the resulting type has not been normalized.\n     pub fn field_ty(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, f: &Field) -> Ty<'tcx>\n     {\n-        // Pass `0` here so it can be used as a \"default\" variant_index in first arm below\n-        let answer = match (self, VariantIdx::new(0)) {\n-            (PlaceTy::Ty {\n-                ty: &ty::TyS { sty: ty::TyKind::Adt(adt_def, substs), .. } }, variant_index) |\n-            (PlaceTy::Downcast { adt_def, substs, variant_index }, _) => {\n-                let variant_def = &adt_def.variants[variant_index];\n+        let answer = match self.ty.sty {\n+            ty::TyKind::Adt(adt_def, substs) => {\n+                let variant_def = match self.variant_index {\n+                    None => adt_def.non_enum_variant(),\n+                    Some(variant_index) => {\n+                        assert!(adt_def.is_enum());\n+                        &adt_def.variants[variant_index]\n+                    }\n+                };\n                 let field_def = &variant_def.fields[f.index()];\n                 field_def.ty(tcx, substs)\n             }\n-            (PlaceTy::Ty { ty }, _) => {\n-                match ty.sty {\n-                    ty::Tuple(ref tys) => tys[f.index()],\n-                    _ => bug!(\"extracting field of non-tuple non-adt: {:?}\", self),\n-                }\n-            }\n+            ty::Tuple(ref tys) => tys[f.index()],\n+            _ => bug!(\"extracting field of non-tuple non-adt: {:?}\", self),\n         };\n         debug!(\"field_ty self: {:?} f: {:?} yields: {:?}\", self, f, answer);\n         answer\n@@ -86,70 +72,51 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n     pub fn projection_ty_core<V, T>(\n         self,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-        elem: &ProjectionElem<'tcx, V, T>,\n+        elem: &ProjectionElem<V, T>,\n         mut handle_field: impl FnMut(&Self, &Field, &T) -> Ty<'tcx>)\n         -> PlaceTy<'tcx>\n     where\n         V: ::std::fmt::Debug, T: ::std::fmt::Debug\n     {\n         let answer = match *elem {\n             ProjectionElem::Deref => {\n-                let ty = self.to_ty(tcx)\n+                let ty = self.ty\n                              .builtin_deref(true)\n                              .unwrap_or_else(|| {\n                                  bug!(\"deref projection of non-dereferencable ty {:?}\", self)\n                              })\n                              .ty;\n-                PlaceTy::Ty {\n-                    ty,\n-                }\n+                PlaceTy::from_ty(ty)\n             }\n             ProjectionElem::Index(_) | ProjectionElem::ConstantIndex { .. } =>\n-                PlaceTy::Ty {\n-                    ty: self.to_ty(tcx).builtin_index().unwrap()\n-                },\n+                PlaceTy::from_ty(self.ty.builtin_index().unwrap()),\n             ProjectionElem::Subslice { from, to } => {\n-                let ty = self.to_ty(tcx);\n-                PlaceTy::Ty {\n-                    ty: match ty.sty {\n-                        ty::Array(inner, size) => {\n-                            let size = size.unwrap_usize(tcx);\n-                            let len = size - (from as u64) - (to as u64);\n-                            tcx.mk_array(inner, len)\n-                        }\n-                        ty::Slice(..) => ty,\n-                        _ => {\n-                            bug!(\"cannot subslice non-array type: `{:?}`\", self)\n-                        }\n-                    }\n-                }\n-            }\n-            ProjectionElem::Downcast(adt_def1, index) =>\n-                match self.to_ty(tcx).sty {\n-                    ty::Adt(adt_def, substs) => {\n-                        assert!(adt_def.is_enum());\n-                        assert!(index.as_usize() < adt_def.variants.len());\n-                        assert_eq!(adt_def, adt_def1);\n-                        PlaceTy::Downcast { adt_def,\n-                                            substs,\n-                                            variant_index: index }\n+                PlaceTy::from_ty(match self.ty.sty {\n+                    ty::Array(inner, size) => {\n+                        let size = size.unwrap_usize(tcx);\n+                        let len = size - (from as u64) - (to as u64);\n+                        tcx.mk_array(inner, len)\n                     }\n+                    ty::Slice(..) => self.ty,\n                     _ => {\n-                        bug!(\"cannot downcast non-ADT type: `{:?}`\", self)\n+                        bug!(\"cannot subslice non-array type: `{:?}`\", self)\n                     }\n-                },\n+                })\n+            }\n+            ProjectionElem::Downcast(_name, index) =>\n+                PlaceTy { ty: self.ty, variant_index: Some(index) },\n             ProjectionElem::Field(ref f, ref fty) =>\n-                PlaceTy::Ty { ty: handle_field(&self, f, fty) },\n+                PlaceTy::from_ty(handle_field(&self, f, fty)),\n         };\n         debug!(\"projection_ty self: {:?} elem: {:?} yields: {:?}\", self, elem, answer);\n         answer\n     }\n }\n \n-EnumTypeFoldableImpl! {\n+BraceStructTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for PlaceTy<'tcx> {\n-        (PlaceTy::Ty) { ty },\n-        (PlaceTy::Downcast) { adt_def, substs, variant_index },\n+        ty,\n+        variant_index,\n     }\n }\n \n@@ -159,9 +126,9 @@ impl<'tcx> Place<'tcx> {\n     {\n         match *self {\n             Place::Base(PlaceBase::Local(index)) =>\n-                PlaceTy::Ty { ty: local_decls.local_decls()[index].ty },\n+                PlaceTy::from_ty(local_decls.local_decls()[index].ty),\n             Place::Base(PlaceBase::Static(ref data)) =>\n-                PlaceTy::Ty { ty: data.ty },\n+                PlaceTy::from_ty(data.ty),\n             Place::Projection(ref proj) =>\n                 proj.base.ty(local_decls, tcx).projection_ty(tcx, &proj.elem),\n         }\n@@ -186,7 +153,7 @@ impl<'tcx> Place<'tcx> {\n         match place {\n             Place::Projection(ref proj) => match proj.elem {\n                 ProjectionElem::Field(field, _ty) => {\n-                    let base_ty = proj.base.ty(mir, *tcx).to_ty(*tcx);\n+                    let base_ty = proj.base.ty(mir, *tcx).ty;\n \n                     if (base_ty.is_closure() || base_ty.is_generator()) &&\n                         (!by_ref || mir.upvar_decls[field.index()].by_ref)\n@@ -218,7 +185,7 @@ impl<'tcx> Rvalue<'tcx> {\n                 tcx.mk_array(operand.ty(local_decls, tcx), count)\n             }\n             Rvalue::Ref(reg, bk, ref place) => {\n-                let place_ty = place.ty(local_decls, tcx).to_ty(tcx);\n+                let place_ty = place.ty(local_decls, tcx).ty;\n                 tcx.mk_ref(reg,\n                     ty::TypeAndMut {\n                         ty: place_ty,\n@@ -244,7 +211,7 @@ impl<'tcx> Rvalue<'tcx> {\n                 operand.ty(local_decls, tcx)\n             }\n             Rvalue::Discriminant(ref place) => {\n-                let ty = place.ty(local_decls, tcx).to_ty(tcx);\n+                let ty = place.ty(local_decls, tcx).ty;\n                 if let ty::Adt(adt_def, _) = ty.sty {\n                     adt_def.repr.discr_type().to_ty(tcx)\n                 } else {\n@@ -293,7 +260,7 @@ impl<'tcx> Operand<'tcx> {\n     {\n         match self {\n             &Operand::Copy(ref l) |\n-            &Operand::Move(ref l) => l.ty(local_decls, tcx).to_ty(tcx),\n+            &Operand::Move(ref l) => l.ty(local_decls, tcx).ty,\n             &Operand::Constant(ref c) => c.ty,\n         }\n     }"}, {"sha": "e41f1e3a91fb5f3b3c209105980f402019fbbe02", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -137,7 +137,7 @@ macro_rules! make_mir_visitor {\n             fn visit_ascribe_user_ty(&mut self,\n                                      place: & $($mutability)? Place<'tcx>,\n                                      variance: & $($mutability)? ty::Variance,\n-                                     user_ty: & $($mutability)? UserTypeProjection<'tcx>,\n+                                     user_ty: & $($mutability)? UserTypeProjection,\n                                      location: Location) {\n                 self.super_ascribe_user_ty(place, variance, user_ty, location);\n             }\n@@ -205,7 +205,7 @@ macro_rules! make_mir_visitor {\n \n             fn visit_user_type_projection(\n                 &mut self,\n-                ty: & $($mutability)? UserTypeProjection<'tcx>,\n+                ty: & $($mutability)? UserTypeProjection,\n             ) {\n                 self.super_user_type_projection(ty);\n             }\n@@ -700,7 +700,7 @@ macro_rules! make_mir_visitor {\n             fn super_ascribe_user_ty(&mut self,\n                                      place: & $($mutability)? Place<'tcx>,\n                                      _variance: & $($mutability)? ty::Variance,\n-                                     user_ty: & $($mutability)? UserTypeProjection<'tcx>,\n+                                     user_ty: & $($mutability)? UserTypeProjection,\n                                      location: Location) {\n                 self.visit_place(\n                     place,\n@@ -777,7 +777,7 @@ macro_rules! make_mir_visitor {\n                                                     min_length: _,\n                                                     from_end: _ } => {\n                     }\n-                    ProjectionElem::Downcast(_adt_def, _variant_index) => {\n+                    ProjectionElem::Downcast(_name, _variant_index) => {\n                     }\n                 }\n             }\n@@ -851,7 +851,7 @@ macro_rules! make_mir_visitor {\n \n             fn super_user_type_projection(\n                 &mut self,\n-                _ty: & $($mutability)? UserTypeProjection<'tcx>,\n+                _ty: & $($mutability)? UserTypeProjection,\n             ) {\n             }\n "}, {"sha": "03936a82c71512b80cb05d982d0ea83f2773218a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -125,7 +125,7 @@ pub struct CtxtInterners<'tcx> {\n     clauses: InternedSet<'tcx, List<Clause<'tcx>>>,\n     goal: InternedSet<'tcx, GoalKind<'tcx>>,\n     goal_list: InternedSet<'tcx, List<Goal<'tcx>>>,\n-    projs: InternedSet<'tcx, List<ProjectionKind<'tcx>>>,\n+    projs: InternedSet<'tcx, List<ProjectionKind>>,\n     const_: InternedSet<'tcx, Const<'tcx>>,\n }\n \n@@ -1802,7 +1802,7 @@ nop_list_lift!{Ty<'a> => Ty<'tcx>}\n nop_list_lift!{ExistentialPredicate<'a> => ExistentialPredicate<'tcx>}\n nop_list_lift!{Predicate<'a> => Predicate<'tcx>}\n nop_list_lift!{CanonicalVarInfo => CanonicalVarInfo}\n-nop_list_lift!{ProjectionKind<'a> => ProjectionKind<'tcx>}\n+nop_list_lift!{ProjectionKind => ProjectionKind}\n \n // this is the impl for `&'a InternalSubsts<'a>`\n nop_list_lift!{Kind<'a> => Kind<'tcx>}\n@@ -2261,9 +2261,9 @@ impl<'tcx: 'lcx, 'lcx> Borrow<[Kind<'lcx>]> for Interned<'tcx, InternalSubsts<'t\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<[ProjectionKind<'lcx>]>\n-    for Interned<'tcx, List<ProjectionKind<'tcx>>> {\n-    fn borrow<'a>(&'a self) -> &'a [ProjectionKind<'lcx>] {\n+impl<'tcx> Borrow<[ProjectionKind]>\n+    for Interned<'tcx, List<ProjectionKind>> {\n+    fn borrow<'a>(&'a self) -> &'a [ProjectionKind] {\n         &self.0[..]\n     }\n }\n@@ -2391,22 +2391,22 @@ direct_interners!('tcx,\n );\n \n macro_rules! slice_interners {\n-    ($($field:ident: $method:ident($ty:ident)),+) => (\n+    ($($field:ident: $method:ident($ty:ty)),+) => (\n         $(intern_method!( 'tcx, $field: $method(\n-            &[$ty<'tcx>],\n+            &[$ty],\n             |a, v| List::from_arena(a, v),\n             Deref::deref,\n-            |xs: &[$ty<'_>]| xs.iter().any(keep_local)) -> List<$ty<'tcx>>);)+\n-    )\n+            |xs: &[$ty]| xs.iter().any(keep_local)) -> List<$ty>);)+\n+    );\n }\n \n slice_interners!(\n-    existential_predicates: _intern_existential_predicates(ExistentialPredicate),\n-    predicates: _intern_predicates(Predicate),\n-    type_list: _intern_type_list(Ty),\n-    substs: _intern_substs(Kind),\n-    clauses: _intern_clauses(Clause),\n-    goal_list: _intern_goals(Goal),\n+    existential_predicates: _intern_existential_predicates(ExistentialPredicate<'tcx>),\n+    predicates: _intern_predicates(Predicate<'tcx>),\n+    type_list: _intern_type_list(Ty<'tcx>),\n+    substs: _intern_substs(Kind<'tcx>),\n+    clauses: _intern_clauses(Clause<'tcx>),\n+    goal_list: _intern_goals(Goal<'tcx>),\n     projs: _intern_projs(ProjectionKind)\n );\n \n@@ -2774,7 +2774,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn intern_projs(self, ps: &[ProjectionKind<'tcx>]) -> &'tcx List<ProjectionKind<'tcx>> {\n+    pub fn intern_projs(self, ps: &[ProjectionKind]) -> &'tcx List<ProjectionKind> {\n         if ps.len() == 0 {\n             List::empty()\n         } else {"}, {"sha": "262dc30033472b6bc7c90b8a313d8b920a6f0d13", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -936,7 +936,7 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<Ty<'tcx>> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ProjectionKind<'tcx>> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ProjectionKind> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter().map(|t| t.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n         folder.tcx().intern_projs(&v)"}, {"sha": "8253a1672454d33cb688269101ab5e05259f3904", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -172,14 +172,14 @@ impl<'mir, 'a: 'mir, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n                 // ZSTs don't require any actual memory access.\n                 let elem_ty = base_ty\n                     .projection_ty(cx.tcx(), &proj.elem)\n-                    .to_ty(cx.tcx());\n+                    .ty;\n                 let elem_ty = self.fx.monomorphize(&elem_ty);\n                 if cx.layout_of(elem_ty).is_zst() {\n                     return;\n                 }\n \n                 if let mir::ProjectionElem::Field(..) = proj.elem {\n-                    let layout = cx.layout_of(base_ty.to_ty(cx.tcx()));\n+                    let layout = cx.layout_of(base_ty.ty);\n                     if cx.is_backend_immediate(layout) || cx.is_backend_scalar_pair(layout) {\n                         // Recurse with the same context, instead of `Projection`,\n                         // potentially stopping at non-operand projections,\n@@ -247,7 +247,7 @@ impl<'mir, 'a: 'mir, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n             PlaceContext::MutatingUse(MutatingUseContext::Drop) => {\n                 let ty = mir::Place::Base(mir::PlaceBase::Local(local)).ty(self.fx.mir,\n                                                                            self.fx.cx.tcx());\n-                let ty = self.fx.monomorphize(&ty.to_ty(self.fx.cx.tcx()));\n+                let ty = self.fx.monomorphize(&ty.ty);\n \n                 // Only need the place if we're actually dropping it.\n                 if self.fx.cx.type_needs_drop(ty) {"}, {"sha": "65f7e023fa226a00bce0ec225aa7b81ccbf2e034", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -301,7 +301,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         target: mir::BasicBlock,\n         unwind: Option<mir::BasicBlock>,\n     ) {\n-        let ty = location.ty(self.mir, bx.tcx()).to_ty(bx.tcx());\n+        let ty = location.ty(self.mir, bx.tcx()).ty;\n         let ty = self.monomorphize(&ty);\n         let drop_fn = monomorphize::resolve_drop_in_place(bx.tcx(), ty);\n "}, {"sha": "2b7b900475332422cd0f15bf1bf93690996db57f", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -494,8 +494,8 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     mir::ProjectionElem::Subslice { from, to } => {\n                         let mut subslice = cg_base.project_index(bx,\n                             bx.cx().const_usize(from as u64));\n-                        let projected_ty = PlaceTy::Ty { ty: cg_base.layout.ty }\n-                            .projection_ty(tcx, &projection.elem).to_ty(tcx);\n+                        let projected_ty = PlaceTy::from_ty(cg_base.layout.ty)\n+                            .projection_ty(tcx, &projection.elem).ty;\n                         subslice.layout = bx.cx().layout_of(self.monomorphize(&projected_ty));\n \n                         if subslice.layout.is_unsized() {\n@@ -523,6 +523,6 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn monomorphized_place_ty(&self, place: &mir::Place<'tcx>) -> Ty<'tcx> {\n         let tcx = self.cx.tcx();\n         let place_ty = place.ty(self.mir, tcx);\n-        self.monomorphize(&place_ty.to_ty(tcx))\n+        self.monomorphize(&place_ty.ty)\n     }\n }"}, {"sha": "c04a36fe9c69c66d38129201fa0f83b72af24818", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -13,6 +13,7 @@ use rustc::mir::{\n     Static, StaticKind, TerminatorKind, VarBindingForm,\n };\n use rustc::ty::{self, DefIdTree};\n+use rustc::ty::layout::VariantIdx;\n use rustc::ty::print::Print;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -201,7 +202,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 );\n             }\n \n-            let ty = used_place.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n+            let ty = used_place.ty(self.mir, self.infcx.tcx).ty;\n             let needs_note = match ty.sty {\n                 ty::Closure(id, _) => {\n                     let tables = self.infcx.tcx.typeck_tables_of(id);\n@@ -216,7 +217,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let mpi = self.move_data.moves[move_out_indices[0]].path;\n                 let place = &self.move_data.move_paths[mpi].place;\n \n-                let ty = place.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n+                let ty = place.ty(self.mir, self.infcx.tcx).ty;\n                 let opt_name = self.describe_place_with_options(place, IncludingDowncast(true));\n                 let note_msg = match opt_name {\n                     Some(ref name) => format!(\"`{}`\", name),\n@@ -596,8 +597,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // Define a small closure that we can use to check if the type of a place\n         // is a union.\n         let is_union = |place: &Place<'tcx>| -> bool {\n-            place.ty(self.mir, self.infcx.tcx)\n-                .to_ty(self.infcx.tcx)\n+            place.ty(self.mir, self.infcx.tcx).ty\n                 .ty_adt_def()\n                 .map(|adt| adt.is_union())\n                 .unwrap_or(false)\n@@ -646,7 +646,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                             // Also compute the name of the union type, eg. `Foo` so we\n                             // can add a helpful note with it.\n-                            let ty = base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n+                            let ty = base.ty(self.mir, self.infcx.tcx).ty;\n \n                             return Some((desc_base, desc_first, desc_second, ty.to_string()));\n                         },\n@@ -1761,20 +1761,22 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     }\n \n     /// End-user visible description of the `field`nth field of `base`\n-    fn describe_field(&self, base: &Place<'_>, field: Field) -> String {\n+    fn describe_field(&self, base: &Place<'tcx>, field: Field) -> String {\n         match *base {\n             Place::Base(PlaceBase::Local(local)) => {\n                 let local = &self.mir.local_decls[local];\n-                self.describe_field_from_ty(&local.ty, field)\n+                self.describe_field_from_ty(&local.ty, field, None)\n             }\n             Place::Base(PlaceBase::Static(ref static_)) =>\n-                self.describe_field_from_ty(&static_.ty, field),\n+                self.describe_field_from_ty(&static_.ty, field, None),\n             Place::Projection(ref proj) => match proj.elem {\n                 ProjectionElem::Deref => self.describe_field(&proj.base, field),\n-                ProjectionElem::Downcast(def, variant_index) =>\n-                    def.variants[variant_index].fields[field.index()].ident.to_string(),\n+                ProjectionElem::Downcast(_, variant_index) => {\n+                    let base_ty = base.ty(self.mir, self.infcx.tcx).ty;\n+                    self.describe_field_from_ty(&base_ty, field, Some(variant_index))\n+                }\n                 ProjectionElem::Field(_, field_type) => {\n-                    self.describe_field_from_ty(&field_type, field)\n+                    self.describe_field_from_ty(&field_type, field, None)\n                 }\n                 ProjectionElem::Index(..)\n                 | ProjectionElem::ConstantIndex { .. }\n@@ -1786,24 +1788,34 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     }\n \n     /// End-user visible description of the `field_index`nth field of `ty`\n-    fn describe_field_from_ty(&self, ty: &ty::Ty<'_>, field: Field) -> String {\n+    fn describe_field_from_ty(\n+        &self,\n+        ty: &ty::Ty<'_>,\n+        field: Field,\n+        variant_index: Option<VariantIdx>\n+    ) -> String {\n         if ty.is_box() {\n             // If the type is a box, the field is described from the boxed type\n-            self.describe_field_from_ty(&ty.boxed_ty(), field)\n+            self.describe_field_from_ty(&ty.boxed_ty(), field, variant_index)\n         } else {\n             match ty.sty {\n-                ty::Adt(def, _) => if def.is_enum() {\n-                    field.index().to_string()\n-                } else {\n-                    def.non_enum_variant().fields[field.index()]\n+                ty::Adt(def, _) => {\n+                    let variant = if let Some(idx) = variant_index {\n+                        assert!(def.is_enum());\n+                        &def.variants[idx]\n+                    } else {\n+                        def.non_enum_variant()\n+                    };\n+                    variant.fields[field.index()]\n                         .ident\n                         .to_string()\n                 },\n                 ty::Tuple(_) => field.index().to_string(),\n                 ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n-                    self.describe_field_from_ty(&ty, field)\n+                    self.describe_field_from_ty(&ty, field, variant_index)\n                 }\n-                ty::Array(ty, _) | ty::Slice(ty) => self.describe_field_from_ty(&ty, field),\n+                ty::Array(ty, _) | ty::Slice(ty) =>\n+                    self.describe_field_from_ty(&ty, field, variant_index),\n                 ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n                     // Convert the def-id into a node-id. node-ids are only valid for\n                     // the local code in the current crate, so this returns an `Option` in case\n@@ -1861,15 +1873,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         StorageDeadOrDrop::LocalStorageDead\n                         | StorageDeadOrDrop::BoxedStorageDead => {\n                             assert!(\n-                                base.ty(self.mir, tcx).to_ty(tcx).is_box(),\n+                                base.ty(self.mir, tcx).ty.is_box(),\n                                 \"Drop of value behind a reference or raw pointer\"\n                             );\n                             StorageDeadOrDrop::BoxedStorageDead\n                         }\n                         StorageDeadOrDrop::Destructor(_) => base_access,\n                     },\n                     ProjectionElem::Field(..) | ProjectionElem::Downcast(..) => {\n-                        let base_ty = base.ty(self.mir, tcx).to_ty(tcx);\n+                        let base_ty = base.ty(self.mir, tcx).ty;\n                         match base_ty.sty {\n                             ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                 // Report the outermost adt with a destructor"}, {"sha": "d9764288283b3b96ce02902ec2d457d17f4892ca", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -616,8 +616,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 let drop_place_ty = drop_place.ty(self.mir, self.infcx.tcx);\n \n                 // Erase the regions.\n-                let drop_place_ty = self.infcx.tcx.erase_regions(&drop_place_ty)\n-                    .to_ty(self.infcx.tcx);\n+                let drop_place_ty = self.infcx.tcx.erase_regions(&drop_place_ty).ty;\n \n                 // \"Lift\" into the gcx -- once regions are erased, this type should be in the\n                 // global arenas; this \"lift\" operation basically just asserts that is true, but\n@@ -1641,7 +1640,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             // assigning to `P.f` requires `P` itself\n                             // be already initialized\n                             let tcx = self.infcx.tcx;\n-                            match base.ty(self.mir, tcx).to_ty(tcx).sty {\n+                            match base.ty(self.mir, tcx).ty.sty {\n                                 ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                     self.check_if_path_or_subpath_is_moved(\n                                         context, InitializationRequiringAction::Assignment,\n@@ -1746,7 +1745,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 // no move out from an earlier location) then this is an attempt at initialization\n                 // of the union - we should error in that case.\n                 let tcx = this.infcx.tcx;\n-                if let ty::TyKind::Adt(def, _) = base.ty(this.mir, tcx).to_ty(tcx).sty {\n+                if let ty::TyKind::Adt(def, _) = base.ty(this.mir, tcx).ty.sty {\n                     if def.is_union() {\n                         if this.move_data.path_map[mpi].iter().any(|moi| {\n                             this.move_data.moves[*moi].source.is_predecessor_of(\n@@ -2007,7 +2006,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n-                        let base_ty = proj.base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n+                        let base_ty = proj.base.ty(self.mir, self.infcx.tcx).ty;\n \n                         // Check the kind of deref to decide\n                         match base_ty.sty {"}, {"sha": "b6e7996586e4a496901ef2ce55054b064a69eccb", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -266,7 +266,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                         // Inspect the type of the content behind the\n                         // borrow to provide feedback about why this\n                         // was a move rather than a copy.\n-                        let ty = place.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n+                        let ty = place.ty(self.mir, self.infcx.tcx).ty;\n                         let is_upvar_field_projection =\n                             self.prefixes(&original_path, PrefixSet::All)\n                             .any(|p| p.is_upvar_field_projection(self.mir, &self.infcx.tcx)\n@@ -530,7 +530,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     // We're only interested in assignments (in particular, where the\n                     // assignment came from - was it an `Rc` or `Arc`?).\n                     if let StatementKind::Assign(_, box Rvalue::Ref(_, _, source)) = &stmt.kind {\n-                        let ty = source.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n+                        let ty = source.ty(self.mir, self.infcx.tcx).ty;\n                         let ty = match ty.sty {\n                             ty::TyKind::Ref(_, ty, _) => ty,\n                             _ => ty,\n@@ -555,7 +555,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                             _ => continue,\n                         };\n \n-                        let ty = source.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx);\n+                        let ty = source.ty(self.mir, self.infcx.tcx).ty;\n                         let ty = match ty.sty {\n                             ty::TyKind::Ref(_, ty, _) => ty,\n                             _ => ty,\n@@ -581,7 +581,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             base,\n             elem: ProjectionElem::Deref,\n         }) = place {\n-            if base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx).is_unsafe_ptr() {\n+            if base.ty(self.mir, self.infcx.tcx).ty.is_unsafe_ptr() {\n                 return BorrowedContentSource::DerefRawPointer;\n             }\n         }"}, {"sha": "8a55a59b15b17f728216ac16c45f68ac92858b6d", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -64,7 +64,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 elem: ProjectionElem::Field(upvar_index, _),\n             }) => {\n                 debug_assert!(is_closure_or_generator(\n-                    base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx)\n+                    base.ty(self.mir, self.infcx.tcx).ty\n                 ));\n \n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n@@ -85,7 +85,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                     debug_assert!(self.mir.local_decls[Local::new(1)].ty.is_region_ptr());\n                     debug_assert!(is_closure_or_generator(\n-                        the_place_err.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx)\n+                        the_place_err.ty(self.mir, self.infcx.tcx).ty\n                     ));\n \n                     reason = if access_place.is_upvar_field_projection(self.mir,\n@@ -110,7 +110,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     reason = \", as it is immutable for the pattern guard\".to_string();\n                 } else {\n                     let pointer_type =\n-                        if base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx).is_region_ptr() {\n+                        if base.ty(self.mir, self.infcx.tcx).ty.is_region_ptr() {\n                             \"`&` reference\"\n                         } else {\n                             \"`*const` pointer\"\n@@ -232,7 +232,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n \n                 if let Some((span, message)) = annotate_struct_field(\n                     self.infcx.tcx,\n-                    base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx),\n+                    base.ty(self.mir, self.infcx.tcx).ty,\n                     field,\n                 ) {\n                     err.span_suggestion(\n@@ -304,7 +304,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 elem: ProjectionElem::Field(upvar_index, _),\n             }) => {\n                 debug_assert!(is_closure_or_generator(\n-                    base.ty(self.mir, self.infcx.tcx).to_ty(self.infcx.tcx)\n+                    base.ty(self.mir, self.infcx.tcx).ty\n                 ));\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));"}, {"sha": "bf9cff1e4ae03c8f65f757f579591a2da615838c", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -174,7 +174,7 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n         &mut self,\n         _place: &Place<'tcx>,\n         _variance: &ty::Variance,\n-        _user_ty: &UserTypeProjection<'tcx>,\n+        _user_ty: &UserTypeProjection,\n         _location: Location,\n     ) {\n     }"}, {"sha": "b06ebbdbf34f6719c03a586ff23cd8c5940b29d8", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 62, "deletions": 60, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -450,9 +450,8 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     ) -> PlaceTy<'tcx> {\n         debug!(\"sanitize_place: {:?}\", place);\n         let place_ty = match place {\n-            Place::Base(PlaceBase::Local(index)) => PlaceTy::Ty {\n-                ty: self.mir.local_decls[*index].ty,\n-            },\n+            Place::Base(PlaceBase::Local(index)) =>\n+                PlaceTy::from_ty(self.mir.local_decls[*index].ty),\n             Place::Base(PlaceBase::Static(box Static { kind, ty: sty })) => {\n                 let sty = self.sanitize_type(place, sty);\n                 let check_err =\n@@ -493,7 +492,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                         check_err(self, place, ty, sty);\n                     }\n                 }\n-                PlaceTy::Ty { ty: sty }\n+                PlaceTy::from_ty(sty)\n             }\n             Place::Projection(ref proj) => {\n                 let base_context = if context.is_mutating_use() {\n@@ -502,12 +501,10 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                     PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection)\n                 };\n                 let base_ty = self.sanitize_place(&proj.base, location, base_context);\n-                if let PlaceTy::Ty { ty } = base_ty {\n-                    if ty.references_error() {\n+                if base_ty.variant_index.is_none() {\n+                    if base_ty.ty.references_error() {\n                         assert!(self.errors_reported);\n-                        return PlaceTy::Ty {\n-                            ty: self.tcx().types.err,\n-                        };\n+                        return PlaceTy::from_ty(self.tcx().types.err);\n                     }\n                 }\n                 self.sanitize_projection(base_ty, &proj.elem, place, location)\n@@ -517,7 +514,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             let tcx = self.tcx();\n             let trait_ref = ty::TraitRef {\n                 def_id: tcx.lang_items().copy_trait().unwrap(),\n-                substs: tcx.mk_substs_trait(place_ty.to_ty(tcx), &[]),\n+                substs: tcx.mk_substs_trait(place_ty.ty, &[]),\n             };\n \n             // In order to have a Copy operand, the type T of the\n@@ -615,40 +612,40 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     ) -> PlaceTy<'tcx> {\n         debug!(\"sanitize_projection: {:?} {:?} {:?}\", base, pi, place);\n         let tcx = self.tcx();\n-        let base_ty = base.to_ty(tcx);\n+        let base_ty = base.ty;\n         match *pi {\n             ProjectionElem::Deref => {\n                 let deref_ty = base_ty.builtin_deref(true);\n-                PlaceTy::Ty {\n-                    ty: deref_ty.map(|t| t.ty).unwrap_or_else(|| {\n+                PlaceTy::from_ty(\n+                    deref_ty.map(|t| t.ty).unwrap_or_else(|| {\n                         span_mirbug_and_err!(self, place, \"deref of non-pointer {:?}\", base_ty)\n-                    }),\n-                }\n+                    })\n+                )\n             }\n             ProjectionElem::Index(i) => {\n-                let index_ty = Place::Base(PlaceBase::Local(i)).ty(self.mir, tcx).to_ty(tcx);\n+                let index_ty = Place::Base(PlaceBase::Local(i)).ty(self.mir, tcx).ty;\n                 if index_ty != tcx.types.usize {\n-                    PlaceTy::Ty {\n-                        ty: span_mirbug_and_err!(self, i, \"index by non-usize {:?}\", i),\n-                    }\n+                    PlaceTy::from_ty(\n+                        span_mirbug_and_err!(self, i, \"index by non-usize {:?}\", i),\n+                    )\n                 } else {\n-                    PlaceTy::Ty {\n-                        ty: base_ty.builtin_index().unwrap_or_else(|| {\n+                    PlaceTy::from_ty(\n+                        base_ty.builtin_index().unwrap_or_else(|| {\n                             span_mirbug_and_err!(self, place, \"index of non-array {:?}\", base_ty)\n                         }),\n-                    }\n+                    )\n                 }\n             }\n             ProjectionElem::ConstantIndex { .. } => {\n                 // consider verifying in-bounds\n-                PlaceTy::Ty {\n-                    ty: base_ty.builtin_index().unwrap_or_else(|| {\n+                PlaceTy::from_ty(\n+                    base_ty.builtin_index().unwrap_or_else(|| {\n                         span_mirbug_and_err!(self, place, \"index of non-array {:?}\", base_ty)\n                     }),\n-                }\n+                )\n             }\n-            ProjectionElem::Subslice { from, to } => PlaceTy::Ty {\n-                ty: match base_ty.sty {\n+            ProjectionElem::Subslice { from, to } => PlaceTy::from_ty(\n+                match base_ty.sty {\n                     ty::Array(inner, size) => {\n                         let size = size.unwrap_usize(tcx);\n                         let min_size = (from as u64) + (to as u64);\n@@ -666,35 +663,39 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                     ty::Slice(..) => base_ty,\n                     _ => span_mirbug_and_err!(self, place, \"slice of non-array {:?}\", base_ty),\n                 },\n-            },\n-            ProjectionElem::Downcast(adt_def1, index) => match base_ty.sty {\n-                ty::Adt(adt_def, substs) if adt_def.is_enum() && adt_def == adt_def1 => {\n+            ),\n+            ProjectionElem::Downcast(maybe_name, index) => match base_ty.sty {\n+                ty::Adt(adt_def, _substs) if adt_def.is_enum() => {\n                     if index.as_usize() >= adt_def.variants.len() {\n-                        PlaceTy::Ty {\n-                            ty: span_mirbug_and_err!(\n+                        PlaceTy::from_ty(\n+                            span_mirbug_and_err!(\n                                 self,\n                                 place,\n                                 \"cast to variant #{:?} but enum only has {:?}\",\n                                 index,\n                                 adt_def.variants.len()\n                             ),\n-                        }\n+                        )\n                     } else {\n-                        PlaceTy::Downcast {\n-                            adt_def,\n-                            substs,\n-                            variant_index: index,\n+                        PlaceTy {\n+                            ty: base_ty,\n+                            variant_index: Some(index),\n                         }\n                     }\n                 }\n-                _ => PlaceTy::Ty {\n-                    ty: span_mirbug_and_err!(\n-                        self,\n-                        place,\n-                        \"can't downcast {:?} as {:?}\",\n-                        base_ty,\n-                        adt_def1\n-                    ),\n+                _ => {\n+                    let ty = if let Some(name) = maybe_name {\n+                        span_mirbug_and_err!(\n+                            self,\n+                            place,\n+                            \"can't downcast {:?} as {:?}\",\n+                            base_ty,\n+                            name\n+                        )\n+                    } else {\n+                        span_mirbug_and_err!(self, place, \"can't downcast {:?}\", base_ty)\n+                    };\n+                    PlaceTy::from_ty(ty)\n                 },\n             },\n             ProjectionElem::Field(field, fty) => {\n@@ -723,7 +724,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                         field_count\n                     ),\n                 }\n-                PlaceTy::Ty { ty: fty }\n+                PlaceTy::from_ty(fty)\n             }\n         }\n     }\n@@ -743,12 +744,13 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         let tcx = self.tcx();\n \n         let (variant, substs) = match base_ty {\n-            PlaceTy::Downcast {\n-                adt_def,\n-                substs,\n-                variant_index,\n-            } => (&adt_def.variants[variant_index], substs),\n-            PlaceTy::Ty { ty } => match ty.sty {\n+            PlaceTy { ty, variant_index: Some(variant_index) } => {\n+                match ty.sty {\n+                    ty::TyKind::Adt(adt_def, substs) => (&adt_def.variants[variant_index], substs),\n+                    _ => bug!(\"can't have downcast of non-adt type\"),\n+                }\n+            }\n+            PlaceTy { ty, variant_index: None } => match ty.sty {\n                 ty::Adt(adt_def, substs) if !adt_def.is_enum() =>\n                     (&adt_def.variants[VariantIdx::new(0)], substs),\n                 ty::Closure(def_id, substs) => {\n@@ -1161,7 +1163,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         &mut self,\n         a: Ty<'tcx>,\n         v: ty::Variance,\n-        user_ty: &UserTypeProjection<'tcx>,\n+        user_ty: &UserTypeProjection,\n         locations: Locations,\n         category: ConstraintCategory,\n     ) -> Fallible<()> {\n@@ -1185,7 +1187,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         debug!(\"user_ty base: {:?} freshened: {:?} projs: {:?} yields: {:?}\",\n                 user_ty.base, annotated_type, user_ty.projs, curr_projected_ty);\n \n-        let ty = curr_projected_ty.to_ty(tcx);\n+        let ty = curr_projected_ty.ty;\n         self.relate_types(a, v, ty, locations, category)?;\n \n         Ok(())\n@@ -1333,7 +1335,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     _ => ConstraintCategory::Assignment,\n                 };\n \n-                let place_ty = place.ty(mir, tcx).to_ty(tcx);\n+                let place_ty = place.ty(mir, tcx).ty;\n                 let rv_ty = rv.ty(mir, tcx);\n                 if let Err(terr) =\n                     self.sub_types_or_anon(rv_ty, place_ty, location.to_locations(), category)\n@@ -1385,7 +1387,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 ref place,\n                 variant_index,\n             } => {\n-                let place_type = place.ty(mir, tcx).to_ty(tcx);\n+                let place_type = place.ty(mir, tcx).ty;\n                 let adt = match place_type.sty {\n                     TyKind::Adt(adt, _) if adt.is_enum() => adt,\n                     _ => {\n@@ -1407,7 +1409,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 };\n             }\n             StatementKind::AscribeUserType(ref place, variance, box ref projection) => {\n-                let place_ty = place.ty(mir, tcx).to_ty(tcx);\n+                let place_ty = place.ty(mir, tcx).ty;\n                 if let Err(terr) = self.relate_type_and_user_type(\n                     place_ty,\n                     variance,\n@@ -1463,7 +1465,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 target: _,\n                 unwind: _,\n             } => {\n-                let place_ty = location.ty(mir, tcx).to_ty(tcx);\n+                let place_ty = location.ty(mir, tcx).ty;\n                 let rv_ty = value.ty(mir, tcx);\n \n                 let locations = term_location.to_locations();\n@@ -1611,7 +1613,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         let tcx = self.tcx();\n         match *destination {\n             Some((ref dest, _target_block)) => {\n-                let dest_ty = dest.ty(mir, tcx).to_ty(tcx);\n+                let dest_ty = dest.ty(mir, tcx).ty;\n                 let category = match *dest {\n                     Place::Base(PlaceBase::Local(RETURN_PLACE)) => {\n                         if let Some(BorrowCheckContext {\n@@ -2370,7 +2372,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             match *elem {\n                 ProjectionElem::Deref => {\n                     let tcx = self.infcx.tcx;\n-                    let base_ty = base.ty(mir, tcx).to_ty(tcx);\n+                    let base_ty = base.ty(mir, tcx).ty;\n \n                     debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n                     match base_ty.sty {"}, {"sha": "8269b7b95f490ea4ac88e6e5118d3b74afe9d77c", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -63,7 +63,7 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n                     tcx, mir, locals_state_at_exit),\n \n                 ProjectionElem::Deref => {\n-                    let ty = proj.base.ty(mir, tcx).to_ty(tcx);\n+                    let ty = proj.base.ty(mir, tcx).ty;\n                     match ty.sty {\n                         // For both derefs of raw pointers and `&T`\n                         // references, the original path is `Copy` and"}, {"sha": "fbe8b8485dda5b9d886ee7b1d8a3834d4c4ab11e", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -191,7 +191,7 @@ fn place_components_conflict<'gcx, 'tcx>(\n                     Place::Projection(box Projection { base, elem }) => (base, elem),\n                     _ => bug!(\"place has no base?\"),\n                 };\n-                let base_ty = base.ty(mir, tcx).to_ty(tcx);\n+                let base_ty = base.ty(mir, tcx).ty;\n \n                 match (elem, &base_ty.sty, access) {\n                     (_, _, Shallow(Some(ArtificialField::ArrayLength)))\n@@ -427,7 +427,7 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n                         debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n                         Overlap::EqualOrDisjoint\n                     } else {\n-                        let ty = pi1.base.ty(mir, tcx).to_ty(tcx);\n+                        let ty = pi1.base.ty(mir, tcx).ty;\n                         match ty.sty {\n                             ty::Adt(def, _) if def.is_union() => {\n                                 // Different fields of a union, we are basically stuck."}, {"sha": "866f1cf994e69669508e953f4d0424263837d7c6", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -139,7 +139,7 @@ impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n             // derefs, except we stop at the deref of a shared\n             // reference.\n \n-            let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+            let ty = proj.base.ty(self.mir, self.tcx).ty;\n             match ty.sty {\n                 ty::RawPtr(_) |\n                 ty::Ref("}, {"sha": "7469aceee3a9ee959c7647fee82007ba20eaed77", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -163,7 +163,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // Then, the block may have an optional trailing expression which is a \u201creturn\u201d value\n         // of the block, which is stored into `destination`.\n         let tcx = this.hir.tcx();\n-        let destination_ty = destination.ty(&this.local_decls, tcx).to_ty(tcx);\n+        let destination_ty = destination.ty(&this.local_decls, tcx).ty;\n         if let Some(expr) = expr {\n             let tail_result_is_ignored = destination_ty.is_unit() ||\n                 this.block_context.currently_ignores_tail_results();"}, {"sha": "566f1790f8f7f488e8d63451684d31e91e9a4a90", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -374,7 +374,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let ty_source_info = self.source_info(user_ty_span);\n                 let user_ty = box pat_ascription_ty.user_ty(\n                     &mut self.canonical_user_type_annotations,\n-                    place.ty(&self.local_decls, self.hir.tcx()).to_ty(self.hir.tcx()),\n+                    place.ty(&self.local_decls, self.hir.tcx()).ty,\n                     ty_source_info.span,\n                 );\n                 self.cfg.push(\n@@ -575,7 +575,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub(super) fn visit_bindings(\n         &mut self,\n         pattern: &Pattern<'tcx>,\n-        pattern_user_ty: UserTypeProjections<'tcx>,\n+        pattern_user_ty: UserTypeProjections,\n         f: &mut impl FnMut(\n             &mut Self,\n             Mutability,\n@@ -584,7 +584,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             HirId,\n             Span,\n             Ty<'tcx>,\n-            UserTypeProjections<'tcx>,\n+            UserTypeProjections,\n         ),\n     ) {\n         debug!(\"visit_bindings: pattern={:?} pattern_user_ty={:?}\", pattern, pattern_user_ty);\n@@ -1293,7 +1293,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         debug!(\"add_fake_borrows all_fake_borrows = {:?}\", all_fake_borrows);\n \n         all_fake_borrows.into_iter().map(|matched_place| {\n-            let fake_borrow_deref_ty = matched_place.ty(&self.local_decls, tcx).to_ty(tcx);\n+            let fake_borrow_deref_ty = matched_place.ty(&self.local_decls, tcx).ty;\n             let fake_borrow_ty = tcx.mk_imm_ref(tcx.types.re_erased, fake_borrow_deref_ty);\n             let fake_borrow_temp = self.local_decls.push(\n                 LocalDecl::new_temp(fake_borrow_ty, temp_span)\n@@ -1587,7 +1587,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             let user_ty = box ascription.user_ty.clone().user_ty(\n                 &mut self.canonical_user_type_annotations,\n-                ascription.source.ty(&self.local_decls, self.hir.tcx()).to_ty(self.hir.tcx()),\n+                ascription.source.ty(&self.local_decls, self.hir.tcx()).ty,\n                 source_info.span\n             );\n             self.cfg.push(\n@@ -1701,7 +1701,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         mode: BindingMode,\n         var_id: HirId,\n         var_ty: Ty<'tcx>,\n-        user_ty: UserTypeProjections<'tcx>,\n+        user_ty: UserTypeProjections,\n         has_guard: ArmHasGuard,\n         opt_match_place: Option<(Option<Place<'tcx>>, Span)>,\n         pat_span: Span,"}, {"sha": "b06022196106a43d035bbfa2865042997f9d7219", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -693,7 +693,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // So, if we have a match-pattern like `x @ Enum::Variant(P1, P2)`,\n         // we want to create a set of derived match-patterns like\n         // `(x as Variant).0 @ P1` and `(x as Variant).1 @ P1`.\n-        let elem = ProjectionElem::Downcast(adt_def, variant_index);\n+        let elem = ProjectionElem::Downcast(\n+            Some(adt_def.variants[variant_index].ident.name), variant_index);\n         let downcast_place = match_pair.place.elem(elem); // `(x as Variant)`\n         let consequent_match_pairs =\n             subpatterns.iter()"}, {"sha": "d71a13dec5a2f971340dd3acf5bd6589ec9da708", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -70,7 +70,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     pub fn consume_by_copy_or_move(&self, place: Place<'tcx>) -> Operand<'tcx> {\n         let tcx = self.hir.tcx();\n-        let ty = place.ty(&self.local_decls, tcx).to_ty(tcx);\n+        let ty = place.ty(&self.local_decls, tcx).ty;\n         if !self.hir.type_is_copy_modulo_regions(ty, DUMMY_SP) {\n             Operand::Move(place)\n         } else {"}, {"sha": "aae4590a387a7a7a2a33164c60f346ce24433dbc", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -49,7 +49,7 @@ pub fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n fn place_contents_drop_state_cannot_differ<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                                             mir: &Mir<'tcx>,\n                                                             place: &mir::Place<'tcx>) -> bool {\n-    let ty = place.ty(mir, tcx).to_ty(tcx);\n+    let ty = place.ty(mir, tcx).ty;\n     match ty.sty {\n         ty::Array(..) => {\n             debug!(\"place_contents_drop_state_cannot_differ place: {:?} ty: {:?} => false\",\n@@ -141,7 +141,7 @@ pub(crate) fn on_all_drop_children_bits<'a, 'gcx, 'tcx, F>(\n {\n     on_all_children_bits(tcx, mir, &ctxt.move_data, path, |child| {\n         let place = &ctxt.move_data.move_paths[path].place;\n-        let ty = place.ty(mir, tcx).to_ty(tcx);\n+        let ty = place.ty(mir, tcx).ty;\n         debug!(\"on_all_drop_children_bits({:?}, {:?} : {:?})\", path, place, ty);\n \n         let gcx = tcx.global_tcx();"}, {"sha": "b26547c4ff77e1bf427cc2531daa64497e5136cc", "filename": "src/librustc_mir/dataflow/move_paths/abs_domain.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -18,8 +18,7 @@ use rustc::ty::Ty;\n pub struct AbstractOperand;\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct AbstractType;\n-pub type AbstractElem<'tcx> =\n-    ProjectionElem<'tcx, AbstractOperand, AbstractType>;\n+pub type AbstractElem = ProjectionElem<AbstractOperand, AbstractType>;\n \n pub trait Lift {\n     type Abstract;\n@@ -38,7 +37,7 @@ impl<'tcx> Lift for Ty<'tcx> {\n     fn lift(&self) -> Self::Abstract { AbstractType }\n }\n impl<'tcx> Lift for PlaceElem<'tcx> {\n-    type Abstract = AbstractElem<'tcx>;\n+    type Abstract = AbstractElem;\n     fn lift(&self) -> Self::Abstract {\n         match *self {\n             ProjectionElem::Deref =>\n@@ -56,7 +55,7 @@ impl<'tcx> Lift for PlaceElem<'tcx> {\n                     from_end,\n                 },\n             ProjectionElem::Downcast(a, u) =>\n-                ProjectionElem::Downcast(a.clone(), u.clone()),\n+                ProjectionElem::Downcast(a, u.clone()),\n         }\n     }\n }"}, {"sha": "20a306a3ef7a631f98699943c1ddf9d9c46d1491", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -120,7 +120,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n         let base = self.move_path_for(&proj.base)?;\n         let mir = self.builder.mir;\n         let tcx = self.builder.tcx;\n-        let place_ty = proj.base.ty(mir, tcx).to_ty(tcx);\n+        let place_ty = proj.base.ty(mir, tcx).ty;\n         match place_ty.sty {\n             ty::Ref(..) | ty::RawPtr(..) =>\n                 return Err(MoveError::cannot_move_out_of(\n@@ -424,7 +424,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n             Place::Projection(box Projection {\n                 base,\n                 elem: ProjectionElem::Field(_, _),\n-            }) if match base.ty(self.builder.mir, self.builder.tcx).to_ty(self.builder.tcx).sty {\n+            }) if match base.ty(self.builder.mir, self.builder.tcx).ty.sty {\n                     ty::TyKind::Adt(def, _) if def.is_union() => true,\n                     _ => false,\n             } => base,"}, {"sha": "5806a01c687cb18b323e72a8704bcc2ddfa771d7", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -148,7 +148,7 @@ pub struct MoveData<'tcx> {\n     /// particular path being moved.)\n     pub loc_map: LocationMap<SmallVec<[MoveOutIndex; 4]>>,\n     pub path_map: IndexVec<MovePathIndex, SmallVec<[MoveOutIndex; 4]>>,\n-    pub rev_lookup: MovePathLookup<'tcx>,\n+    pub rev_lookup: MovePathLookup,\n     pub inits: IndexVec<InitIndex, Init>,\n     /// Each Location `l` is mapped to the Inits that are effects\n     /// of executing the code at `l`.\n@@ -258,7 +258,7 @@ impl Init {\n \n /// Tables mapping from a place to its MovePathIndex.\n #[derive(Debug)]\n-pub struct MovePathLookup<'tcx> {\n+pub struct MovePathLookup {\n     locals: IndexVec<Local, MovePathIndex>,\n \n     /// projections are made from a base-place and a projection\n@@ -267,7 +267,7 @@ pub struct MovePathLookup<'tcx> {\n     /// subsequent search so that it is solely relative to that\n     /// base-place). For the remaining lookup, we map the projection\n     /// elem to the associated MovePathIndex.\n-    projections: FxHashMap<(MovePathIndex, AbstractElem<'tcx>), MovePathIndex>\n+    projections: FxHashMap<(MovePathIndex, AbstractElem), MovePathIndex>\n }\n \n mod builder;\n@@ -278,7 +278,7 @@ pub enum LookupResult {\n     Parent(Option<MovePathIndex>)\n }\n \n-impl<'tcx> MovePathLookup<'tcx> {\n+impl MovePathLookup {\n     // Unlike the builder `fn move_path_for` below, this lookup\n     // alternative will *not* create a MovePath on the fly for an\n     // unknown place, but will rather return the nearest available"}, {"sha": "fc12443c0923a7ccb660ff2778557cf13422c9b9", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> PatternTypeProjection<'tcx> {\n         annotations: &mut CanonicalUserTypeAnnotations<'tcx>,\n         inferred_ty: Ty<'tcx>,\n         span: Span,\n-    ) -> UserTypeProjection<'tcx> {\n+    ) -> UserTypeProjection {\n         UserTypeProjection {\n             base: annotations.push(CanonicalUserTypeAnnotation {\n                 span,\n@@ -1094,7 +1094,7 @@ CloneImpls!{ <'tcx>\n     Span, Field, Mutability, ast::Name, hir::HirId, usize, ty::Const<'tcx>,\n     Region<'tcx>, Ty<'tcx>, BindingMode, &'tcx AdtDef,\n     SubstsRef<'tcx>, &'tcx Kind<'tcx>, UserType<'tcx>,\n-    UserTypeProjection<'tcx>, PatternTypeProjection<'tcx>\n+    UserTypeProjection, PatternTypeProjection<'tcx>\n }\n \n impl<'tcx> PatternFoldable<'tcx> for FieldPattern<'tcx> {"}, {"sha": "4f7b59a5a9a955ab9b8fcec79e59882c64116e21", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -558,7 +558,7 @@ where\n     pub fn place_projection(\n         &mut self,\n         base: PlaceTy<'tcx, M::PointerTag>,\n-        proj_elem: &mir::ProjectionElem<'tcx, mir::Local, Ty<'tcx>>,\n+        proj_elem: &mir::ProjectionElem<mir::Local, Ty<'tcx>>,\n     ) -> EvalResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::ProjectionElem::*;\n         Ok(match *proj_elem {"}, {"sha": "af875c2f9e8a183ea13bbb3a93797849421b3005", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -625,8 +625,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             }\n             mir::TerminatorKind::Drop { ref location, .. } |\n             mir::TerminatorKind::DropAndReplace { ref location, .. } => {\n-                let ty = location.ty(self.mir, self.tcx)\n-                    .to_ty(self.tcx);\n+                let ty = location.ty(self.mir, self.tcx).ty;\n                 let ty = tcx.subst_and_normalize_erasing_regions(\n                     self.param_substs,\n                     ty::ParamEnv::reveal_all(),"}, {"sha": "b6436ec70eef24ff64f77a32594b07671fbf0313", "filename": "src/librustc_mir/transform/add_moves_for_packed_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -106,7 +106,7 @@ fn add_move_for_packed_drop<'a, 'tcx>(\n     };\n \n     let source_info = terminator.source_info;\n-    let ty = location.ty(mir, tcx).to_ty(tcx);\n+    let ty = location.ty(mir, tcx).ty;\n     let temp = patch.new_temp(ty, terminator.source_info.span);\n \n     let storage_dead_block = patch.new_block(BasicBlockData {"}, {"sha": "9b9e6594296bac191813550e1d44dc18cf7cce82", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -87,7 +87,7 @@ impl MirPass for AddRetag {\n         let needs_retag = |place: &Place<'tcx>| {\n             // FIXME: Instead of giving up for unstable places, we should introduce\n             // a temporary and retag on that.\n-            is_stable(place) && may_have_reference(place.ty(&*local_decls, tcx).to_ty(tcx), tcx)\n+            is_stable(place) && may_have_reference(place.ty(&*local_decls, tcx).ty, tcx)\n         };\n \n         // PART 1"}, {"sha": "93f3afe1aea6b85f6c94af606ae2489c075801bb", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -227,7 +227,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 }\n                 let is_borrow_of_interior_mut = context.is_borrow() && !base\n                     .ty(self.mir, self.tcx)\n-                    .to_ty(self.tcx)\n+                    .ty\n                     .is_freeze(self.tcx, self.param_env, self.source_info.span);\n                 // prevent\n                 // * `&mut x.field`\n@@ -249,7 +249,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                         self.source_info = self.mir.local_decls[local].source_info;\n                     }\n                 }\n-                let base_ty = base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                let base_ty = base.ty(self.mir, self.tcx).ty;\n                 match base_ty.sty {\n                     ty::RawPtr(..) => {\n                         self.require_unsafe(\"dereference of raw pointer\",\n@@ -420,7 +420,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n         }) = place {\n             match *elem {\n                 ProjectionElem::Field(..) => {\n-                    let ty = base.ty(&self.mir.local_decls, self.tcx).to_ty(self.tcx);\n+                    let ty = base.ty(&self.mir.local_decls, self.tcx).ty;\n                     match ty.sty {\n                         ty::Adt(def, _) => match self.tcx.layout_scalar_valid_range(def.did) {\n                             (Bound::Unbounded, Bound::Unbounded) => {},"}, {"sha": "e0ff71cbe52f82bb3358dfe9610cf25b4f5caa0e", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -556,7 +556,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n         if let StatementKind::Assign(ref place, ref rval) = statement.kind {\n             let place_ty: ty::Ty<'tcx> = place\n                 .ty(&self.mir.local_decls, self.tcx)\n-                .to_ty(self.tcx);\n+                .ty;\n             if let Ok(place_layout) = self.tcx.layout_of(self.param_env.and(place_ty)) {\n                 if let Some(value) = self.const_prop(rval, place_layout, statement.source_info) {\n                     if let Place::Base(PlaceBase::Local(local)) = *place {"}, {"sha": "027ae70b06a175e1aa6c1bd98778f7a2a2efde42", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -319,8 +319,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                     work_list.push(target);\n                     // If the location doesn't actually need dropping, treat it like\n                     // a regular goto.\n-                    let ty = location.ty(callee_mir, tcx).subst(tcx, callsite.substs);\n-                    let ty = ty.to_ty(tcx);\n+                    let ty = location.ty(callee_mir, tcx).subst(tcx, callsite.substs).ty;\n                     if ty.needs_drop(tcx, param_env) {\n                         cost += CALL_PENALTY;\n                         if let Some(unwind) = unwind {\n@@ -563,7 +562,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             assert!(args.next().is_none());\n \n             let tuple = Place::Base(PlaceBase::Local(tuple));\n-            let tuple_tys = if let ty::Tuple(s) = tuple.ty(caller_mir, tcx).to_ty(tcx).sty {\n+            let tuple_tys = if let ty::Tuple(s) = tuple.ty(caller_mir, tcx).ty.sty {\n                 s\n             } else {\n                 bug!(\"Closure arguments are not passed as a tuple\");"}, {"sha": "7e925f65ee2d733b5155c46afb0a3015b2fe241b", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -82,14 +82,14 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for OptimizationFinder<'b, 'a, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         if let Rvalue::Ref(_, _, Place::Projection(ref projection)) = *rvalue {\n             if let ProjectionElem::Deref = projection.elem {\n-                if projection.base.ty(self.mir, self.tcx).to_ty(self.tcx).is_region_ptr() {\n+                if projection.base.ty(self.mir, self.tcx).ty.is_region_ptr() {\n                     self.optimizations.and_stars.insert(location);\n                 }\n             }\n         }\n \n         if let Rvalue::Len(ref place) = *rvalue {\n-            let place_ty = place.ty(&self.mir.local_decls, self.tcx).to_ty(self.tcx);\n+            let place_ty = place.ty(&self.mir.local_decls, self.tcx).ty;\n             if let TyKind::Array(_, len) = place_ty.sty {\n                 let span = self.mir.source_info(location).span;\n                 let ty = self.tcx.types.usize;"}, {"sha": "dda9457cc8ccf844f48e5656baca822ac1482ad2", "filename": "src/librustc_mir/transform/lower_128bit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -135,7 +135,7 @@ fn check_lang_item_type<'a, 'tcx, D>(\n     let sig = poly_sig.no_bound_vars().unwrap();\n     let lhs_ty = lhs.ty(local_decls, tcx);\n     let rhs_ty = rhs.ty(local_decls, tcx);\n-    let place_ty = place.ty(local_decls, tcx).to_ty(tcx);\n+    let place_ty = place.ty(local_decls, tcx).ty;\n     let expected = [lhs_ty, rhs_ty, place_ty];\n     assert_eq!(sig.inputs_and_output[..], expected,\n         \"lang item `{}`\", tcx.def_path_str(did));"}, {"sha": "43723aaf568daadbd6a136ef845fa461d5e10cc5", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -310,7 +310,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                                 place = &mut proj.base;\n                             };\n \n-                            let ty = place.ty(local_decls, self.tcx).to_ty(self.tcx);\n+                            let ty = place.ty(local_decls, self.tcx).ty;\n                             let span = statement.source_info.span;\n \n                             Operand::Move(mem::replace(place, promoted_place(ty, span)))"}, {"sha": "5adcbf84da5a06a2d7aeb4739caf871bb23b5141", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -168,7 +168,7 @@ trait Qualif {\n             cx,\n             proj.base.ty(cx.mir, cx.tcx)\n                 .projection_ty(cx.tcx, &proj.elem)\n-                .to_ty(cx.tcx),\n+                .ty,\n         );\n         match proj.elem {\n             ProjectionElem::Deref |\n@@ -245,7 +245,7 @@ trait Qualif {\n                 // Special-case reborrows to be more like a copy of the reference.\n                 if let Place::Projection(ref proj) = *place {\n                     if let ProjectionElem::Deref = proj.elem {\n-                        let base_ty = proj.base.ty(cx.mir, cx.tcx).to_ty(cx.tcx);\n+                        let base_ty = proj.base.ty(cx.mir, cx.tcx).ty;\n                         if let ty::Ref(..) = base_ty.sty {\n                             return Self::in_place(cx, &proj.base);\n                         }\n@@ -301,7 +301,7 @@ impl Qualif for HasMutInterior {\n             // allowed in constants (and the `Checker` will error), and/or it\n             // won't be promoted, due to `&mut ...` or interior mutability.\n             Rvalue::Ref(_, kind, ref place) => {\n-                let ty = place.ty(cx.mir, cx.tcx).to_ty(cx.tcx);\n+                let ty = place.ty(cx.mir, cx.tcx).ty;\n \n                 if let BorrowKind::Mut { .. } = kind {\n                     // In theory, any zero-sized value could be borrowed\n@@ -398,7 +398,7 @@ impl Qualif for IsNotConst {\n \n             ProjectionElem::Field(..) => {\n                 if cx.mode == Mode::Fn {\n-                    let base_ty = proj.base.ty(cx.mir, cx.tcx).to_ty(cx.tcx);\n+                    let base_ty = proj.base.ty(cx.mir, cx.tcx).ty;\n                     if let Some(def) = base_ty.ty_adt_def() {\n                         if def.is_union() {\n                             return true;\n@@ -988,7 +988,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                             // `not_const` errors out in const contexts\n                             self.not_const()\n                         }\n-                        let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                        let base_ty = proj.base.ty(self.mir, self.tcx).ty;\n                         match self.mode {\n                             Mode::Fn => {},\n                             _ => {\n@@ -1012,7 +1012,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     ProjectionElem::Subslice {..} |\n                     ProjectionElem::Field(..) |\n                     ProjectionElem::Index(_) => {\n-                        let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                        let base_ty = proj.base.ty(self.mir, self.tcx).ty;\n                         if let Some(def) = base_ty.ty_adt_def() {\n                             if def.is_union() {\n                                 match self.mode {\n@@ -1069,7 +1069,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             let mut is_reborrow = false;\n             if let Place::Projection(ref proj) = *place {\n                 if let ProjectionElem::Deref = proj.elem {\n-                    let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                    let base_ty = proj.base.ty(self.mir, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.sty {\n                         is_reborrow = true;\n                     }\n@@ -1193,7 +1193,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 self.assign(dest, ValueSource::Call {\n                     callee: func,\n                     args,\n-                    return_ty: dest.ty(self.mir, self.tcx).to_ty(self.tcx),\n+                    return_ty: dest.ty(self.mir, self.tcx).ty,\n                 }, location);\n             }\n \n@@ -1367,7 +1367,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n \n                 if let Some(span) = needs_drop {\n                     // Double-check the type being dropped, to minimize false positives.\n-                    let ty = place.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                    let ty = place.ty(self.mir, self.tcx).ty;\n                     if ty.needs_drop(self.tcx, self.param_env) {\n                         struct_span_err!(self.tcx.sess, span, E0493,\n                                          \"destructors cannot be evaluated at compile-time\")"}, {"sha": "616944dd7ef99ed87eb2361d783af84d15593554", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n                                                      from_end: false} = proj.elem {\n                     // no need to transformation\n                 } else {\n-                    let place_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                    let place_ty = proj.base.ty(self.mir, self.tcx).ty;\n                     if let ty::Array(item_ty, const_size) = place_ty.sty {\n                         if let Some(size) = const_size.assert_usize(self.tcx) {\n                             assert!(size <= u32::max_value() as u64,\n@@ -195,7 +195,7 @@ impl MirPass for RestoreSubsliceArrayMoveOut {\n \n                         let opt_src_place = items.first().and_then(|x| *x).map(|x| x.2);\n                         let opt_size = opt_src_place.and_then(|src_place| {\n-                            let src_ty = src_place.ty(mir, tcx).to_ty(tcx);\n+                            let src_ty = src_place.ty(mir, tcx).ty;\n                             if let ty::Array(_, ref size_o) = src_ty.sty {\n                                 size_o.assert_usize(tcx)\n                             } else {"}, {"sha": "788b7fdaaf91257e9bca59e4b0e35ae4b8b6e356", "filename": "src/librustc_mir/util/alignment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Falignment.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -17,7 +17,7 @@ pub fn is_disaligned<'a, 'tcx, L>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return false\n     }\n \n-    let ty = place.ty(local_decls, tcx).to_ty(tcx);\n+    let ty = place.ty(local_decls, tcx).ty;\n     match tcx.layout_raw(param_env.and(ty)) {\n         Ok(layout) if layout.align.abi.bytes() == 1 => {\n             // if the alignment is 1, the type can't be further\n@@ -46,7 +46,7 @@ fn is_within_packed<'a, 'tcx, L>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // encountered a Deref, which is ABI-aligned\n             ProjectionElem::Deref => break,\n             ProjectionElem::Field(..) => {\n-                let ty = base.ty(local_decls, tcx).to_ty(tcx);\n+                let ty = base.ty(local_decls, tcx).ty;\n                 match ty.sty {\n                     ty::Adt(def, _) if def.repr.packed() => {\n                         return true"}, {"sha": "2d275c9a13792df1501304a7948160da03feaf24", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96e3883c130972ac01348df2a912dc97843939d/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=a96e3883c130972ac01348df2a912dc97843939d", "patch": "@@ -122,7 +122,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     where D: DropElaborator<'b, 'tcx>\n {\n     fn place_ty(&self, place: &Place<'tcx>) -> Ty<'tcx> {\n-        place.ty(self.elaborator.mir(), self.tcx()).to_ty(self.tcx())\n+        place.ty(self.elaborator.mir(), self.tcx()).ty\n     }\n \n     fn tcx(&self) -> TyCtxt<'b, 'tcx, 'tcx> {\n@@ -412,8 +412,8 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                 self.path, variant_index);\n             if let Some(variant_path) = subpath {\n                 let base_place = self.place.clone().elem(\n-                    ProjectionElem::Downcast(adt, variant_index)\n-                        );\n+                    ProjectionElem::Downcast(Some(adt.variants[variant_index].ident.name),\n+                                             variant_index));\n                 let fields = self.move_paths_for_fields(\n                     &base_place,\n                     variant_path,"}]}