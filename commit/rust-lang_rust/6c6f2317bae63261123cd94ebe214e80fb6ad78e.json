{"sha": "6c6f2317bae63261123cd94ebe214e80fb6ad78e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNmYyMzE3YmFlNjMyNjExMjNjZDk0ZWJlMjE0ZTgwZmI2YWQ3OGU=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-25T04:59:46Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-25T04:59:46Z"}, "message": "Rollup merge of #22729 - alexcrichton:ptr-stabilization, r=aturon\n\n Specifically, the following actions were takend:\n\n* The `copy_memory` and `copy_nonoverlapping_memory` functions\n  to drop the `_memory` suffix (as it's implied by the functionality). Both\n  functions are now marked as `#[stable]`.\n* The `set_memory` function was renamed to `write_bytes` and is now stable.\n* The `zero_memory` function is now deprecated in favor of `write_bytes`\n  directly.\n* The `Unique` pointer type is now behind its own feature gate called `unique`\n  to facilitate future stabilization.\n\n[breaking-change]", "tree": {"sha": "00c20a39f5f26cd3f94ea5b949d1194cd68526b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00c20a39f5f26cd3f94ea5b949d1194cd68526b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c6f2317bae63261123cd94ebe214e80fb6ad78e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c6f2317bae63261123cd94ebe214e80fb6ad78e", "html_url": "https://github.com/rust-lang/rust/commit/6c6f2317bae63261123cd94ebe214e80fb6ad78e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c6f2317bae63261123cd94ebe214e80fb6ad78e/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b18584cbd942e2559e718d6318fdbc494e9047bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/b18584cbd942e2559e718d6318fdbc494e9047bd", "html_url": "https://github.com/rust-lang/rust/commit/b18584cbd942e2559e718d6318fdbc494e9047bd"}, {"sha": "ab45694198356ae78972025e0d3beece297431d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab45694198356ae78972025e0d3beece297431d1", "html_url": "https://github.com/rust-lang/rust/commit/ab45694198356ae78972025e0d3beece297431d1"}], "stats": {"total": 248, "additions": 126, "deletions": 122}, "files": [{"sha": "82bd13475c74eabb6f106112edd5434c7411cc70", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=6c6f2317bae63261123cd94ebe214e80fb6ad78e", "patch": "@@ -73,6 +73,7 @@\n #![feature(unboxed_closures)]\n #![feature(unsafe_no_drop_flag)]\n #![feature(core)]\n+#![feature(unique)]\n #![cfg_attr(test, feature(test, alloc, rustc_private))]\n #![cfg_attr(all(not(feature = \"external_funcs\"), not(feature = \"external_crate\")),\n             feature(libc))]"}, {"sha": "b8703f6e7d9350fe6186ae73d40199939789863f", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=6c6f2317bae63261123cd94ebe214e80fb6ad78e", "patch": "@@ -1136,12 +1136,12 @@ impl<K, V> Node<K, V> {\n     // This must be followed by insert_edge on an internal node.\n     #[inline]\n     unsafe fn insert_kv(&mut self, index: usize, key: K, val: V) -> &mut V {\n-        ptr::copy_memory(\n+        ptr::copy(\n             self.keys_mut().as_mut_ptr().offset(index as isize + 1),\n             self.keys().as_ptr().offset(index as isize),\n             self.len() - index\n         );\n-        ptr::copy_memory(\n+        ptr::copy(\n             self.vals_mut().as_mut_ptr().offset(index as isize + 1),\n             self.vals().as_ptr().offset(index as isize),\n             self.len() - index\n@@ -1158,7 +1158,7 @@ impl<K, V> Node<K, V> {\n     // This can only be called immediately after a call to insert_kv.\n     #[inline]\n     unsafe fn insert_edge(&mut self, index: usize, edge: Node<K, V>) {\n-        ptr::copy_memory(\n+        ptr::copy(\n             self.edges_mut().as_mut_ptr().offset(index as isize + 1),\n             self.edges().as_ptr().offset(index as isize),\n             self.len() - index\n@@ -1191,12 +1191,12 @@ impl<K, V> Node<K, V> {\n         let key = ptr::read(self.keys().get_unchecked(index));\n         let val = ptr::read(self.vals().get_unchecked(index));\n \n-        ptr::copy_memory(\n+        ptr::copy(\n             self.keys_mut().as_mut_ptr().offset(index as isize),\n             self.keys().as_ptr().offset(index as isize + 1),\n             self.len() - index - 1\n         );\n-        ptr::copy_memory(\n+        ptr::copy(\n             self.vals_mut().as_mut_ptr().offset(index as isize),\n             self.vals().as_ptr().offset(index as isize + 1),\n             self.len() - index - 1\n@@ -1212,7 +1212,7 @@ impl<K, V> Node<K, V> {\n     unsafe fn remove_edge(&mut self, index: usize) -> Node<K, V> {\n         let edge = ptr::read(self.edges().get_unchecked(index));\n \n-        ptr::copy_memory(\n+        ptr::copy(\n             self.edges_mut().as_mut_ptr().offset(index as isize),\n             self.edges().as_ptr().offset(index as isize + 1),\n             self.len() - index + 1\n@@ -1239,18 +1239,18 @@ impl<K, V> Node<K, V> {\n         unsafe {\n             right._len = self.len() / 2;\n             let right_offset = self.len() - right.len();\n-            ptr::copy_nonoverlapping_memory(\n+            ptr::copy_nonoverlapping(\n                 right.keys_mut().as_mut_ptr(),\n                 self.keys().as_ptr().offset(right_offset as isize),\n                 right.len()\n             );\n-            ptr::copy_nonoverlapping_memory(\n+            ptr::copy_nonoverlapping(\n                 right.vals_mut().as_mut_ptr(),\n                 self.vals().as_ptr().offset(right_offset as isize),\n                 right.len()\n             );\n             if !self.is_leaf() {\n-                ptr::copy_nonoverlapping_memory(\n+                ptr::copy_nonoverlapping(\n                     right.edges_mut().as_mut_ptr(),\n                     self.edges().as_ptr().offset(right_offset as isize),\n                     right.len() + 1\n@@ -1280,18 +1280,18 @@ impl<K, V> Node<K, V> {\n             ptr::write(self.keys_mut().get_unchecked_mut(old_len), key);\n             ptr::write(self.vals_mut().get_unchecked_mut(old_len), val);\n \n-            ptr::copy_nonoverlapping_memory(\n+            ptr::copy_nonoverlapping(\n                 self.keys_mut().as_mut_ptr().offset(old_len as isize + 1),\n                 right.keys().as_ptr(),\n                 right.len()\n             );\n-            ptr::copy_nonoverlapping_memory(\n+            ptr::copy_nonoverlapping(\n                 self.vals_mut().as_mut_ptr().offset(old_len as isize + 1),\n                 right.vals().as_ptr(),\n                 right.len()\n             );\n             if !self.is_leaf() {\n-                ptr::copy_nonoverlapping_memory(\n+                ptr::copy_nonoverlapping(\n                     self.edges_mut().as_mut_ptr().offset(old_len as isize + 1),\n                     right.edges().as_ptr(),\n                     right.len() + 1"}, {"sha": "7b66bfee34f2121b15f4e06ae47e832ed4a7edcf", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=6c6f2317bae63261123cd94ebe214e80fb6ad78e", "patch": "@@ -30,6 +30,7 @@\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(unsafe_destructor)]\n+#![feature(unique)]\n #![feature(unsafe_no_drop_flag)]\n #![cfg_attr(test, feature(rand, rustc_private, test))]\n #![cfg_attr(test, allow(deprecated))] // rand"}, {"sha": "d4c53739686142cfa6ffb16dc7db15bd840a4a95", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=6c6f2317bae63261123cd94ebe214e80fb6ad78e", "patch": "@@ -1331,12 +1331,10 @@ fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> O\n \n             if i != j {\n                 let tmp = ptr::read(read_ptr);\n-                ptr::copy_memory(buf_v.offset(j + 1),\n-                                 &*buf_v.offset(j),\n-                                 (i - j) as usize);\n-                ptr::copy_nonoverlapping_memory(buf_v.offset(j),\n-                                                &tmp,\n-                                                1);\n+                ptr::copy(buf_v.offset(j + 1),\n+                          &*buf_v.offset(j),\n+                          (i - j) as usize);\n+                ptr::copy_nonoverlapping(buf_v.offset(j), &tmp, 1);\n                 mem::forget(tmp);\n             }\n         }\n@@ -1409,10 +1407,10 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n                 // j + 1 could be `len` (for the last `i`), but in\n                 // that case, `i == j` so we don't copy. The\n                 // `.offset(j)` is always in bounds.\n-                ptr::copy_memory(buf_dat.offset(j + 1),\n-                                 &*buf_dat.offset(j),\n-                                 i - j as usize);\n-                ptr::copy_nonoverlapping_memory(buf_dat.offset(j), read_ptr, 1);\n+                ptr::copy(buf_dat.offset(j + 1),\n+                          &*buf_dat.offset(j),\n+                          i - j as usize);\n+                ptr::copy_nonoverlapping(buf_dat.offset(j), read_ptr, 1);\n             }\n         }\n     }\n@@ -1460,11 +1458,11 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n                     if left == right_start {\n                         // the number remaining in this run.\n                         let elems = (right_end as usize - right as usize) / mem::size_of::<T>();\n-                        ptr::copy_nonoverlapping_memory(out, &*right, elems);\n+                        ptr::copy_nonoverlapping(out, &*right, elems);\n                         break;\n                     } else if right == right_end {\n                         let elems = (right_start as usize - left as usize) / mem::size_of::<T>();\n-                        ptr::copy_nonoverlapping_memory(out, &*left, elems);\n+                        ptr::copy_nonoverlapping(out, &*left, elems);\n                         break;\n                     }\n \n@@ -1478,7 +1476,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n                     } else {\n                         step(&mut left)\n                     };\n-                    ptr::copy_nonoverlapping_memory(out, &*to_copy, 1);\n+                    ptr::copy_nonoverlapping(out, &*to_copy, 1);\n                     step(&mut out);\n                 }\n             }\n@@ -1492,7 +1490,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n     // write the result to `v` in one go, so that there are never two copies\n     // of the same object in `v`.\n     unsafe {\n-        ptr::copy_nonoverlapping_memory(v.as_mut_ptr(), &*buf_dat, len);\n+        ptr::copy_nonoverlapping(v.as_mut_ptr(), &*buf_dat, len);\n     }\n \n     // increment the pointer, returning the old pointer."}, {"sha": "94abffa3db61cf6c33d24e87807af67e419fe1a1", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=6c6f2317bae63261123cd94ebe214e80fb6ad78e", "patch": "@@ -568,9 +568,9 @@ impl String {\n \n         let CharRange { ch, next } = self.char_range_at(idx);\n         unsafe {\n-            ptr::copy_memory(self.vec.as_mut_ptr().offset(idx as isize),\n-                             self.vec.as_ptr().offset(next as isize),\n-                             len - next);\n+            ptr::copy(self.vec.as_mut_ptr().offset(idx as isize),\n+                      self.vec.as_ptr().offset(next as isize),\n+                      len - next);\n             self.vec.set_len(len - (next - idx));\n         }\n         ch\n@@ -598,12 +598,12 @@ impl String {\n         let amt = ch.encode_utf8(&mut bits).unwrap();\n \n         unsafe {\n-            ptr::copy_memory(self.vec.as_mut_ptr().offset((idx + amt) as isize),\n-                             self.vec.as_ptr().offset(idx as isize),\n-                             len - idx);\n-            ptr::copy_memory(self.vec.as_mut_ptr().offset(idx as isize),\n-                             bits.as_ptr(),\n-                             amt);\n+            ptr::copy(self.vec.as_mut_ptr().offset((idx + amt) as isize),\n+                      self.vec.as_ptr().offset(idx as isize),\n+                      len - idx);\n+            ptr::copy(self.vec.as_mut_ptr().offset(idx as isize),\n+                      bits.as_ptr(),\n+                      amt);\n             self.vec.set_len(len + amt);\n         }\n     }"}, {"sha": "6d4541b5bde16d25f0616c7953476b0fe38a9b98", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=6c6f2317bae63261123cd94ebe214e80fb6ad78e", "patch": "@@ -267,7 +267,7 @@ impl<T> Vec<T> {\n     pub unsafe fn from_raw_buf(ptr: *const T, elts: usize) -> Vec<T> {\n         let mut dst = Vec::with_capacity(elts);\n         dst.set_len(elts);\n-        ptr::copy_nonoverlapping_memory(dst.as_mut_ptr(), ptr, elts);\n+        ptr::copy_nonoverlapping(dst.as_mut_ptr(), ptr, elts);\n         dst\n     }\n \n@@ -548,7 +548,7 @@ impl<T> Vec<T> {\n                 let p = self.as_mut_ptr().offset(index as isize);\n                 // Shift everything over to make space. (Duplicating the\n                 // `index`th element into two consecutive places.)\n-                ptr::copy_memory(p.offset(1), &*p, len - index);\n+                ptr::copy(p.offset(1), &*p, len - index);\n                 // Write it in, overwriting the first copy of the `index`th\n                 // element.\n                 ptr::write(&mut *p, element);\n@@ -585,7 +585,7 @@ impl<T> Vec<T> {\n                 ret = ptr::read(ptr);\n \n                 // Shift everything down to fill in that spot.\n-                ptr::copy_memory(ptr, &*ptr.offset(1), len - index - 1);\n+                ptr::copy(ptr, &*ptr.offset(1), len - index - 1);\n             }\n             self.set_len(len - 1);\n             ret\n@@ -718,7 +718,7 @@ impl<T> Vec<T> {\n         self.reserve(other.len());\n         let len = self.len();\n         unsafe {\n-            ptr::copy_nonoverlapping_memory(\n+            ptr::copy_nonoverlapping(\n                 self.get_unchecked_mut(len),\n                 other.as_ptr(),\n                 other.len());\n@@ -1036,7 +1036,7 @@ impl<T> Vec<T> {\n             self.set_len(at);\n             other.set_len(other_len);\n \n-            ptr::copy_nonoverlapping_memory(\n+            ptr::copy_nonoverlapping(\n                 other.as_mut_ptr(),\n                 self.as_ptr().offset(at as isize),\n                 other.len());"}, {"sha": "e99d44551d5368c1f5fe05c81b76188d10032814", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=6c6f2317bae63261123cd94ebe214e80fb6ad78e", "patch": "@@ -134,7 +134,7 @@ impl<T> VecDeque<T> {\n                       self.cap);\n         debug_assert!(src + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n                       self.cap);\n-        ptr::copy_memory(\n+        ptr::copy(\n             self.ptr.offset(dst as isize),\n             self.ptr.offset(src as isize),\n             len);\n@@ -147,7 +147,7 @@ impl<T> VecDeque<T> {\n                       self.cap);\n         debug_assert!(src + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n                       self.cap);\n-        ptr::copy_nonoverlapping_memory(\n+        ptr::copy_nonoverlapping(\n             self.ptr.offset(dst as isize),\n             self.ptr.offset(src as isize),\n             len);\n@@ -1343,22 +1343,22 @@ impl<T> VecDeque<T> {\n                 // `at` lies in the first half.\n                 let amount_in_first = first_len - at;\n \n-                ptr::copy_nonoverlapping_memory(*other.ptr,\n-                                                first_half.as_ptr().offset(at as isize),\n-                                                amount_in_first);\n+                ptr::copy_nonoverlapping(*other.ptr,\n+                                         first_half.as_ptr().offset(at as isize),\n+                                         amount_in_first);\n \n                 // just take all of the second half.\n-                ptr::copy_nonoverlapping_memory(other.ptr.offset(amount_in_first as isize),\n-                                                second_half.as_ptr(),\n-                                                second_len);\n+                ptr::copy_nonoverlapping(other.ptr.offset(amount_in_first as isize),\n+                                         second_half.as_ptr(),\n+                                         second_len);\n             } else {\n                 // `at` lies in the second half, need to factor in the elements we skipped\n                 // in the first half.\n                 let offset = at - first_len;\n                 let amount_in_second = second_len - offset;\n-                ptr::copy_nonoverlapping_memory(*other.ptr,\n-                                                second_half.as_ptr().offset(offset as isize),\n-                                                amount_in_second);\n+                ptr::copy_nonoverlapping(*other.ptr,\n+                                         second_half.as_ptr().offset(offset as isize),\n+                                         amount_in_second);\n             }\n         }\n "}, {"sha": "e7af0be88a0859bae60fa9c76f5d02040151667c", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=6c6f2317bae63261123cd94ebe214e80fb6ad78e", "patch": "@@ -293,7 +293,7 @@ extern \"rust-intrinsic\" {\n     ///     }\n     /// }\n     /// ```\n-    #[unstable(feature = \"core\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: usize);\n \n     /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n@@ -323,13 +323,12 @@ extern \"rust-intrinsic\" {\n     /// }\n     /// ```\n     ///\n-    #[unstable(feature = \"core\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn copy_memory<T>(dst: *mut T, src: *const T, count: usize);\n \n     /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n     /// bytes of memory starting at `dst` to `c`.\n-    #[unstable(feature = \"core\",\n-               reason = \"uncertain about naming and semantics\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn set_memory<T>(dst: *mut T, val: u8, count: usize);\n \n     /// Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with"}, {"sha": "2aa8ec0c548d958b4c20eeb8b57ca68908b469fb", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=6c6f2317bae63261123cd94ebe214e80fb6ad78e", "patch": "@@ -203,9 +203,9 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n         let mut t: T = uninitialized();\n \n         // Perform the swap, `&mut` pointers never alias\n-        ptr::copy_nonoverlapping_memory(&mut t, &*x, 1);\n-        ptr::copy_nonoverlapping_memory(x, &*y, 1);\n-        ptr::copy_nonoverlapping_memory(y, &t, 1);\n+        ptr::copy_nonoverlapping(&mut t, &*x, 1);\n+        ptr::copy_nonoverlapping(x, &*y, 1);\n+        ptr::copy_nonoverlapping(y, &t, 1);\n \n         // y and t now point to the same thing, but we need to completely forget `t`\n         // because it's no longer relevant."}, {"sha": "0625c3c7d6018e26d4e36f2c0a43246cd6794d88", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 56, "deletions": 53, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=6c6f2317bae63261123cd94ebe214e80fb6ad78e", "patch": "@@ -101,16 +101,28 @@ use cmp::Ordering::{self, Less, Equal, Greater};\n \n // FIXME #19649: intrinsic docs don't render, so these have no docs :(\n \n-#[unstable(feature = \"core\")]\n-pub use intrinsics::copy_nonoverlapping_memory;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use intrinsics::copy_nonoverlapping_memory as copy_nonoverlapping;\n \n-#[unstable(feature = \"core\")]\n-pub use intrinsics::copy_memory;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use intrinsics::copy_memory as copy;\n \n-#[unstable(feature = \"core\",\n-           reason = \"uncertain about naming and semantics\")]\n-pub use intrinsics::set_memory;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use intrinsics::set_memory as write_bytes;\n \n+extern \"rust-intrinsic\" {\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to `copy_nonoverlapping`\")]\n+    pub fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: usize);\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to `copy`\")]\n+    pub fn copy_memory<T>(dst: *mut T, src: *const T, count: usize);\n+\n+    #[unstable(feature = \"core\",\n+               reason = \"uncertain about naming and semantics\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to `write_bytes`\")]\n+    pub fn set_memory<T>(dst: *mut T, val: u8, count: usize);\n+}\n \n /// Creates a null raw pointer.\n ///\n@@ -150,8 +162,9 @@ pub fn null_mut<T>() -> *mut T { 0 as *mut T }\n #[inline]\n #[unstable(feature = \"core\",\n            reason = \"may play a larger role in std::ptr future extensions\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use `write_bytes` instead\")]\n pub unsafe fn zero_memory<T>(dst: *mut T, count: usize) {\n-    set_memory(dst, 0, count);\n+    write_bytes(dst, 0, count);\n }\n \n /// Swaps the values at two mutable locations of the same type, without\n@@ -169,9 +182,9 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     let t: *mut T = &mut tmp;\n \n     // Perform the swap\n-    copy_nonoverlapping_memory(t, &*x, 1);\n-    copy_memory(x, &*y, 1); // `x` and `y` may overlap\n-    copy_nonoverlapping_memory(y, &*t, 1);\n+    copy_nonoverlapping(t, &*x, 1);\n+    copy(x, &*y, 1); // `x` and `y` may overlap\n+    copy_nonoverlapping(y, &*t, 1);\n \n     // y and t now point to the same thing, but we need to completely forget `tmp`\n     // because it's no longer relevant.\n@@ -207,7 +220,7 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn read<T>(src: *const T) -> T {\n     let mut tmp: T = mem::uninitialized();\n-    copy_nonoverlapping_memory(&mut tmp, src, 1);\n+    copy_nonoverlapping(&mut tmp, src, 1);\n     tmp\n }\n \n@@ -224,7 +237,7 @@ pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n     let tmp = read(&*dest);\n \n     // Now zero out `dest`:\n-    zero_memory(dest, 1);\n+    write_bytes(dest, 0, 1);\n \n     tmp\n }\n@@ -248,9 +261,9 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n \n /// Methods on raw pointers\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait PtrExt: Sized {\n+pub trait PtrExt {\n     /// The type which is being pointed at\n-    type Target;\n+    type Target: ?Sized;\n \n     /// Returns true if the pointer is null.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -279,14 +292,14 @@ pub trait PtrExt: Sized {\n     /// Otherwise `offset` invokes Undefined Behaviour, regardless of whether\n     /// the pointer is used.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe fn offset(self, count: isize) -> Self;\n+    unsafe fn offset(self, count: isize) -> Self where Self::Target: Sized;\n }\n \n /// Methods on mutable raw pointers\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait MutPtrExt {\n     /// The type which is being pointed at\n-    type Target;\n+    type Target: ?Sized;\n \n     /// Returns `None` if the pointer is null, or else returns a mutable\n     /// reference to the value wrapped in `Some`.\n@@ -302,7 +315,7 @@ pub trait MutPtrExt {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> PtrExt for *const T {\n+impl<T: ?Sized> PtrExt for *const T {\n     type Target = T;\n \n     #[inline]\n@@ -311,7 +324,7 @@ impl<T> PtrExt for *const T {\n \n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe fn offset(self, count: isize) -> *const T {\n+    unsafe fn offset(self, count: isize) -> *const T where T: Sized {\n         intrinsics::offset(self, count)\n     }\n \n@@ -329,7 +342,7 @@ impl<T> PtrExt for *const T {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> PtrExt for *mut T {\n+impl<T: ?Sized> PtrExt for *mut T {\n     type Target = T;\n \n     #[inline]\n@@ -338,7 +351,7 @@ impl<T> PtrExt for *mut T {\n \n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe fn offset(self, count: isize) -> *mut T {\n+    unsafe fn offset(self, count: isize) -> *mut T where T: Sized {\n         intrinsics::offset(self, count) as *mut T\n     }\n \n@@ -356,7 +369,7 @@ impl<T> PtrExt for *mut T {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> MutPtrExt for *mut T {\n+impl<T: ?Sized> MutPtrExt for *mut T {\n     type Target = T;\n \n     #[inline]\n@@ -374,41 +387,33 @@ impl<T> MutPtrExt for *mut T {\n \n // Equality for pointers\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> PartialEq for *const T {\n+impl<T: ?Sized> PartialEq for *const T {\n     #[inline]\n-    fn eq(&self, other: &*const T) -> bool {\n-        *self == *other\n-    }\n-    #[inline]\n-    fn ne(&self, other: &*const T) -> bool { !self.eq(other) }\n+    fn eq(&self, other: &*const T) -> bool { *self == *other }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Eq for *const T {}\n+impl<T: ?Sized> Eq for *const T {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> PartialEq for *mut T {\n-    #[inline]\n-    fn eq(&self, other: &*mut T) -> bool {\n-        *self == *other\n-    }\n+impl<T: ?Sized> PartialEq for *mut T {\n     #[inline]\n-    fn ne(&self, other: &*mut T) -> bool { !self.eq(other) }\n+    fn eq(&self, other: &*mut T) -> bool { *self == *other }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Eq for *mut T {}\n+impl<T: ?Sized> Eq for *mut T {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Clone for *const T {\n+impl<T: ?Sized> Clone for *const T {\n     #[inline]\n     fn clone(&self) -> *const T {\n         *self\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Clone for *mut T {\n+impl<T: ?Sized> Clone for *mut T {\n     #[inline]\n     fn clone(&self) -> *mut T {\n         *self\n@@ -452,7 +457,7 @@ mod externfnpointers {\n \n // Comparison for pointers\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Ord for *const T {\n+impl<T: ?Sized> Ord for *const T {\n     #[inline]\n     fn cmp(&self, other: &*const T) -> Ordering {\n         if self < other {\n@@ -466,7 +471,7 @@ impl<T> Ord for *const T {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> PartialOrd for *const T {\n+impl<T: ?Sized> PartialOrd for *const T {\n     #[inline]\n     fn partial_cmp(&self, other: &*const T) -> Option<Ordering> {\n         Some(self.cmp(other))\n@@ -486,7 +491,7 @@ impl<T> PartialOrd for *const T {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Ord for *mut T {\n+impl<T: ?Sized> Ord for *mut T {\n     #[inline]\n     fn cmp(&self, other: &*mut T) -> Ordering {\n         if self < other {\n@@ -500,7 +505,7 @@ impl<T> Ord for *mut T {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> PartialOrd for *mut T {\n+impl<T: ?Sized> PartialOrd for *mut T {\n     #[inline]\n     fn partial_cmp(&self, other: &*mut T) -> Option<Ordering> {\n         Some(self.cmp(other))\n@@ -527,8 +532,8 @@ impl<T> PartialOrd for *mut T {\n /// modified without a unique path to the `Unique` reference. Useful\n /// for building abstractions like `Vec<T>` or `Box<T>`, which\n /// internally use raw pointers to manage the memory that they own.\n-#[unstable(feature = \"core\", reason = \"recently added to this module\")]\n-pub struct Unique<T:?Sized> {\n+#[unstable(feature = \"unique\")]\n+pub struct Unique<T: ?Sized> {\n     pointer: NonZero<*const T>,\n     _marker: PhantomData<T>,\n }\n@@ -537,39 +542,37 @@ pub struct Unique<T:?Sized> {\n /// reference is unaliased. Note that this aliasing invariant is\n /// unenforced by the type system; the abstraction using the\n /// `Unique` must enforce it.\n-#[unstable(feature = \"core\", reason = \"recently added to this module\")]\n+#[unstable(feature = \"unique\")]\n unsafe impl<T: Send + ?Sized> Send for Unique<T> { }\n \n /// `Unique` pointers are `Sync` if `T` is `Sync` because the data they\n /// reference is unaliased. Note that this aliasing invariant is\n /// unenforced by the type system; the abstraction using the\n /// `Unique` must enforce it.\n-#[unstable(feature = \"core\", reason = \"recently added to this module\")]\n+#[unstable(feature = \"unique\")]\n unsafe impl<T: Sync + ?Sized> Sync for Unique<T> { }\n \n-impl<T:?Sized> Unique<T> {\n+impl<T: ?Sized> Unique<T> {\n     /// Create a new `Unique`.\n-    #[unstable(feature = \"core\",\n-               reason = \"recently added to this module\")]\n+    #[unstable(feature = \"unique\")]\n     pub unsafe fn new(ptr: *mut T) -> Unique<T> {\n         Unique { pointer: NonZero::new(ptr as *const T), _marker: PhantomData }\n     }\n \n     /// Dereference the content.\n-    #[unstable(feature = \"core\",\n-               reason = \"recently added to this module\")]\n+    #[unstable(feature = \"unique\")]\n     pub unsafe fn get(&self) -> &T {\n         &**self.pointer\n     }\n \n     /// Mutably dereference the content.\n-    #[unstable(feature = \"core\",\n-               reason = \"recently added to this module\")]\n+    #[unstable(feature = \"unique\")]\n     pub unsafe fn get_mut(&mut self) -> &mut T {\n         &mut ***self\n     }\n }\n \n+#[unstable(feature = \"unique\")]\n impl<T:?Sized> Deref for Unique<T> {\n     type Target = *mut T;\n "}, {"sha": "ae64a57a390f8938b1817ab71597342ad7a3cfef", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=6c6f2317bae63261123cd94ebe214e80fb6ad78e", "patch": "@@ -1500,7 +1500,7 @@ pub mod bytes {\n     impl MutableByteVector for [u8] {\n         #[inline]\n         fn set_memory(&mut self, value: u8) {\n-            unsafe { ptr::set_memory(self.as_mut_ptr(), value, self.len()) };\n+            unsafe { ptr::write_bytes(self.as_mut_ptr(), value, self.len()) };\n         }\n     }\n \n@@ -1514,9 +1514,9 @@ pub mod bytes {\n         // `dst` is unaliasable, so we know statically it doesn't overlap\n         // with `src`.\n         unsafe {\n-            ptr::copy_nonoverlapping_memory(dst.as_mut_ptr(),\n-                                            src.as_ptr(),\n-                                            len_src);\n+            ptr::copy_nonoverlapping(dst.as_mut_ptr(),\n+                                     src.as_ptr(),\n+                                     len_src);\n         }\n     }\n }"}, {"sha": "2ce52cdec2560a92ee1e32559e2ae4392b73e37e", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=6c6f2317bae63261123cd94ebe214e80fb6ad78e", "patch": "@@ -27,6 +27,7 @@\n #![feature(int_uint)]\n #![feature(libc)]\n #![feature(staged_api)]\n+#![feature(unique)]\n \n #[cfg(test)] #[macro_use] extern crate log;\n "}, {"sha": "4c03d8915eb8a04ca0909e022739eb6c38ade22a", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=6c6f2317bae63261123cd94ebe214e80fb6ad78e", "patch": "@@ -23,7 +23,7 @@ use num::{Int, UnsignedInt};\n use ops::{Deref, DerefMut, Drop};\n use option::Option;\n use option::Option::{Some, None};\n-use ptr::{self, PtrExt, copy_nonoverlapping_memory, Unique, zero_memory};\n+use ptr::{self, PtrExt, Unique};\n use rt::heap::{allocate, deallocate, EMPTY};\n use collections::hash_state::HashState;\n \n@@ -477,8 +477,8 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> GapThenFull<K, V, M> {\n     pub fn shift(mut self) -> Option<GapThenFull<K, V, M>> {\n         unsafe {\n             *self.gap.raw.hash = mem::replace(&mut *self.full.raw.hash, EMPTY_BUCKET);\n-            copy_nonoverlapping_memory(self.gap.raw.key, self.full.raw.key, 1);\n-            copy_nonoverlapping_memory(self.gap.raw.val, self.full.raw.val, 1);\n+            ptr::copy_nonoverlapping(self.gap.raw.key, self.full.raw.key, 1);\n+            ptr::copy_nonoverlapping(self.gap.raw.val, self.full.raw.val, 1);\n         }\n \n         let FullBucket { raw: prev_raw, idx: prev_idx, .. } = self.full;\n@@ -637,7 +637,7 @@ impl<K, V> RawTable<K, V> {\n     pub fn new(capacity: usize) -> RawTable<K, V> {\n         unsafe {\n             let ret = RawTable::new_uninitialized(capacity);\n-            zero_memory(*ret.hashes, capacity);\n+            ptr::write_bytes(*ret.hashes, 0, capacity);\n             ret\n         }\n     }"}, {"sha": "1135609959015d2fbee5d2565a0dd18affd69b7f", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=6c6f2317bae63261123cd94ebe214e80fb6ad78e", "patch": "@@ -155,9 +155,9 @@ impl<W: Write> BufWriter<W> {\n         if written > 0 {\n             // NB: would be better expressed as .remove(0..n) if it existed\n             unsafe {\n-                ptr::copy_memory(self.buf.as_mut_ptr(),\n-                                 self.buf.as_ptr().offset(written as isize),\n-                                 len - written);\n+                ptr::copy(self.buf.as_mut_ptr(),\n+                          self.buf.as_ptr().offset(written as isize),\n+                          len - written);\n             }\n         }\n         self.buf.truncate(len - written);"}, {"sha": "b5bdeb7f181b0ddab0bebb3c25491c619d385ddc", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c6f2317bae63261123cd94ebe214e80fb6ad78e/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=6c6f2317bae63261123cd94ebe214e80fb6ad78e", "patch": "@@ -123,6 +123,7 @@\n #![feature(unsafe_no_drop_flag)]\n #![feature(macro_reexport)]\n #![feature(hash)]\n+#![feature(unique)]\n #![cfg_attr(test, feature(test, rustc_private, env))]\n \n // Don't link to std. We are std."}]}