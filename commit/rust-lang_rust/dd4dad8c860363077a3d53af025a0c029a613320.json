{"sha": "dd4dad8c860363077a3d53af025a0c029a613320", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkNGRhZDhjODYwMzYzMDc3YTNkNTNhZjAyNWEwYzAyOWE2MTMzMjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-14T18:18:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-14T18:18:39Z"}, "message": "Auto merge of #24920 - alexcrichton:duration, r=aturon\n\nThis commit is an implementation of [RFC 1040][rfc] which is a redesign of the\r\ncurrently-unstable `Duration` type. The API of the type has been scaled back to\r\nbe more conservative and it also no longer supports negative durations.\r\n\r\n[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/1040-duration-reform.md\r\n\r\nThe inner `duration` module of the `time` module has now been hidden (as\r\n`Duration` is reexported) and the feature name for this type has changed from\r\n`std_misc` to `duration`. All APIs accepting durations have also been audited to\r\ntake a more flavorful feature name instead of `std_misc`.\r\n\r\nCloses #24874", "tree": {"sha": "11c4b5dda04fee8cb25b1e4119eb40b2ca2d3804", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11c4b5dda04fee8cb25b1e4119eb40b2ca2d3804"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd4dad8c860363077a3d53af025a0c029a613320", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd4dad8c860363077a3d53af025a0c029a613320", "html_url": "https://github.com/rust-lang/rust/commit/dd4dad8c860363077a3d53af025a0c029a613320", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd4dad8c860363077a3d53af025a0c029a613320/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af522079a2e13046cbf5f426874d7f6b672c501e", "url": "https://api.github.com/repos/rust-lang/rust/commits/af522079a2e13046cbf5f426874d7f6b672c501e", "html_url": "https://github.com/rust-lang/rust/commit/af522079a2e13046cbf5f426874d7f6b672c501e"}, {"sha": "556e76bb78cdd1d951e3966b2264ef8567371881", "url": "https://api.github.com/repos/rust-lang/rust/commits/556e76bb78cdd1d951e3966b2264ef8567371881", "html_url": "https://github.com/rust-lang/rust/commit/556e76bb78cdd1d951e3966b2264ef8567371881"}], "stats": {"total": 1005, "additions": 374, "deletions": 631}, "files": [{"sha": "12d6fcd0303ec0d1f1b31ffa555bdc29710e7053", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=dd4dad8c860363077a3d53af025a0c029a613320", "patch": "@@ -30,6 +30,8 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(duration)]\n+#![feature(duration_span)]\n #![feature(fs_canonicalize)]\n #![feature(hash)]\n #![feature(into_cow)]"}, {"sha": "9a95120ee686fd5747253818361d1c77dd768c03", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=dd4dad8c860363077a3d53af025a0c029a613320", "patch": "@@ -720,8 +720,7 @@ fn get_metadata_section(is_osx: bool, filename: &Path) -> Result<MetadataBlob, S\n     let dur = Duration::span(|| {\n         ret = Some(get_metadata_section_imp(is_osx, filename));\n     });\n-    info!(\"reading {:?} => {}ms\", filename.file_name().unwrap(),\n-          dur.num_milliseconds());\n+    info!(\"reading {:?} => {}\", filename.file_name().unwrap(), dur);\n     return ret.unwrap();;\n }\n "}, {"sha": "5a5567c48adeec4b52d56e5b032abe05c17ba3f6", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=dd4dad8c860363077a3d53af025a0c029a613320", "patch": "@@ -55,8 +55,8 @@ pub fn time<T, U, F>(do_it: bool, what: &str, u: U, f: F) -> T where\n     };\n     let rv = rv.unwrap();\n \n-    println!(\"{}time: {}.{:03} \\t{}\", repeat(\"  \").take(old).collect::<String>(),\n-             dur.num_seconds(), dur.num_milliseconds() % 1000, what);\n+    println!(\"{}time: {} \\t{}\", repeat(\"  \").take(old).collect::<String>(),\n+             dur, what);\n     DEPTH.with(|slot| slot.set(old));\n \n     rv"}, {"sha": "8da917916e5cd5945ba82471ba2dd82c90765994", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 63, "deletions": 19, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=dd4dad8c860363077a3d53af025a0c029a613320", "patch": "@@ -69,20 +69,20 @@ pub struct Condvar { inner: Box<StaticCondvar> }\n /// # Examples\n ///\n /// ```\n-/// # #![feature(std_misc)]\n+/// # #![feature(static_condvar)]\n /// use std::sync::{StaticCondvar, CONDVAR_INIT};\n ///\n /// static CVAR: StaticCondvar = CONDVAR_INIT;\n /// ```\n-#[unstable(feature = \"std_misc\",\n+#[unstable(feature = \"static_condvar\",\n            reason = \"may be merged with Condvar in the future\")]\n pub struct StaticCondvar {\n     inner: sys::Condvar,\n     mutex: AtomicUsize,\n }\n \n /// Constant initializer for a statically allocated condition variable.\n-#[unstable(feature = \"std_misc\",\n+#[unstable(feature = \"static_condvar\",\n            reason = \"may be merged with Condvar in the future\")]\n pub const CONDVAR_INIT: StaticCondvar = StaticCondvar {\n     inner: sys::CONDVAR_INIT,\n@@ -161,6 +161,30 @@ impl Condvar {\n         }\n     }\n \n+    /// Waits on this condition variable for a notification, timing out after a\n+    /// specified duration.\n+    ///\n+    /// The semantics of this function are equivalent to `wait()` except that\n+    /// the thread will be blocked for roughly no longer than `dur`. This\n+    /// method should not be used for precise timing due to anomalies such as\n+    /// preemption or platform differences that may not cause the maximum\n+    /// amount of time waited to be precisely `dur`.\n+    ///\n+    /// The returned boolean is `false` only if the timeout is known\n+    /// to have elapsed.\n+    ///\n+    /// Like `wait`, the lock specified will be re-acquired when this function\n+    /// returns, regardless of whether the timeout elapsed or not.\n+    #[unstable(feature = \"wait_timeout\", reason = \"waiting for Duration\")]\n+    pub fn wait_timeout<'a, T>(&self, guard: MutexGuard<'a, T>,\n+                               dur: Duration)\n+                               -> LockResult<(MutexGuard<'a, T>, bool)> {\n+        unsafe {\n+            let me: &'static Condvar = &*(self as *const _);\n+            me.inner.wait_timeout(guard, dur)\n+        }\n+    }\n+\n     /// Waits on this condition variable for a notification, timing out after a\n     /// specified duration.\n     ///\n@@ -214,7 +238,7 @@ impl StaticCondvar {\n     /// notification.\n     ///\n     /// See `Condvar::wait`.\n-    #[unstable(feature = \"std_misc\",\n+    #[unstable(feature = \"static_condvar\",\n                reason = \"may be merged with Condvar in the future\")]\n     pub fn wait<'a, T>(&'static self, guard: MutexGuard<'a, T>)\n                        -> LockResult<MutexGuard<'a, T>> {\n@@ -235,14 +259,27 @@ impl StaticCondvar {\n     /// specified duration.\n     ///\n     /// See `Condvar::wait_timeout`.\n-    #[unstable(feature = \"std_misc\",\n+    #[unstable(feature = \"static_condvar\",\n                reason = \"may be merged with Condvar in the future\")]\n     pub fn wait_timeout_ms<'a, T>(&'static self, guard: MutexGuard<'a, T>, ms: u32)\n                                   -> LockResult<(MutexGuard<'a, T>, bool)> {\n+        self.wait_timeout(guard, Duration::from_millis(ms as u64))\n+    }\n+\n+    /// Waits on this condition variable for a notification, timing out after a\n+    /// specified duration.\n+    ///\n+    /// See `Condvar::wait_timeout`.\n+    #[unstable(feature = \"static_condvar\",\n+               reason = \"may be merged with Condvar in the future\")]\n+    pub fn wait_timeout<'a, T>(&'static self,\n+                               guard: MutexGuard<'a, T>,\n+                               timeout: Duration)\n+                               -> LockResult<(MutexGuard<'a, T>, bool)> {\n         let (poisoned, success) = unsafe {\n             let lock = mutex::guard_lock(&guard);\n             self.verify(lock);\n-            let success = self.inner.wait_timeout(lock, Duration::milliseconds(ms as i64));\n+            let success = self.inner.wait_timeout(lock, timeout);\n             (mutex::guard_poison(&guard).get(), success)\n         };\n         if poisoned {\n@@ -259,15 +296,16 @@ impl StaticCondvar {\n     /// passed and the function returns `false`.\n     ///\n     /// See `Condvar::wait_timeout_with`.\n-    #[unstable(feature = \"std_misc\",\n+    #[unstable(feature = \"static_condvar\",\n                reason = \"may be merged with Condvar in the future\")]\n     pub fn wait_timeout_with<'a, T, F>(&'static self,\n                                        guard: MutexGuard<'a, T>,\n                                        dur: Duration,\n                                        mut f: F)\n                                        -> LockResult<(MutexGuard<'a, T>, bool)>\n             where F: FnMut(LockResult<&mut T>) -> bool {\n-        // This could be made more efficient by pushing the implementation into sys::condvar\n+        // This could be made more efficient by pushing the implementation into\n+        // sys::condvar\n         let start = SteadyTime::now();\n         let mut guard_result: LockResult<MutexGuard<'a, T>> = Ok(guard);\n         while !f(guard_result\n@@ -277,12 +315,15 @@ impl StaticCondvar {\n             let now = SteadyTime::now();\n             let consumed = &now - &start;\n             let guard = guard_result.unwrap_or_else(|e| e.into_inner());\n-            let res = self.wait_timeout_ms(guard, (dur - consumed).num_milliseconds() as u32);\n-            let (new_guard_result, no_timeout) = match res {\n-                Ok((new_guard, no_timeout)) => (Ok(new_guard), no_timeout),\n-                Err(err) => {\n-                    let (new_guard, no_timeout) = err.into_inner();\n-                    (Err(PoisonError::new(new_guard)), no_timeout)\n+            let (new_guard_result, no_timeout) = if consumed > dur {\n+                (Ok(guard), false)\n+            } else {\n+                match self.wait_timeout(guard, dur - consumed) {\n+                    Ok((new_guard, no_timeout)) => (Ok(new_guard), no_timeout),\n+                    Err(err) => {\n+                        let (new_guard, no_timeout) = err.into_inner();\n+                        (Err(PoisonError::new(new_guard)), no_timeout)\n+                    }\n                 }\n             };\n             guard_result = new_guard_result;\n@@ -301,14 +342,14 @@ impl StaticCondvar {\n     /// Wakes up one blocked thread on this condvar.\n     ///\n     /// See `Condvar::notify_one`.\n-    #[unstable(feature = \"std_misc\",\n+    #[unstable(feature = \"static_condvar\",\n                reason = \"may be merged with Condvar in the future\")]\n     pub fn notify_one(&'static self) { unsafe { self.inner.notify_one() } }\n \n     /// Wakes up all blocked threads on this condvar.\n     ///\n     /// See `Condvar::notify_all`.\n-    #[unstable(feature = \"std_misc\",\n+    #[unstable(feature = \"static_condvar\",\n                reason = \"may be merged with Condvar in the future\")]\n     pub fn notify_all(&'static self) { unsafe { self.inner.notify_all() } }\n \n@@ -318,7 +359,7 @@ impl StaticCondvar {\n     /// active users of the condvar, and this also doesn't prevent any future\n     /// users of the condvar. This method is required to be called to not leak\n     /// memory on all platforms.\n-    #[unstable(feature = \"std_misc\",\n+    #[unstable(feature = \"static_condvar\",\n                reason = \"may be merged with Condvar in the future\")]\n     pub unsafe fn destroy(&'static self) {\n         self.inner.destroy()\n@@ -447,7 +488,9 @@ mod tests {\n         static S: AtomicUsize = ATOMIC_USIZE_INIT;\n \n         let g = M.lock().unwrap();\n-        let (g, success) = C.wait_timeout_with(g, Duration::nanoseconds(1000), |_| false).unwrap();\n+        let (g, success) = C.wait_timeout_with(g, Duration::new(0, 1000), |_| {\n+            false\n+        }).unwrap();\n         assert!(!success);\n \n         let (tx, rx) = channel();\n@@ -471,7 +514,8 @@ mod tests {\n         });\n \n         let mut state = 0;\n-        let (_g, success) = C.wait_timeout_with(g, Duration::days(1), |_| {\n+        let day = 24 * 60 * 60;\n+        let (_g, success) = C.wait_timeout_with(g, Duration::new(day, 0), |_| {\n             assert_eq!(state, S.load(Ordering::SeqCst));\n             tx.send(()).unwrap();\n             state += 1;"}, {"sha": "29a13cc6be731549a86f4c29e8ee553981f1b806", "filename": "src/libstd/sys/unix/condvar.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs?ref=dd4dad8c860363077a3d53af025a0c029a613320", "patch": "@@ -57,25 +57,20 @@ impl Condvar {\n     // https://github.com/llvm-mirror/libcxx/blob/release_35/src/condition_variable.cpp#L46\n     // https://github.com/llvm-mirror/libcxx/blob/release_35/include/__mutex_base#L367\n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n-        if dur <= Duration::zero() {\n-            return false;\n-        }\n-\n-        // First, figure out what time it currently is, in both system and stable time.\n-        // pthread_cond_timedwait uses system time, but we want to report timeout based on stable\n-        // time.\n+        // First, figure out what time it currently is, in both system and\n+        // stable time.  pthread_cond_timedwait uses system time, but we want to\n+        // report timeout based on stable time.\n         let mut sys_now = libc::timeval { tv_sec: 0, tv_usec: 0 };\n         let stable_now = time::SteadyTime::now();\n         let r = ffi::gettimeofday(&mut sys_now, ptr::null_mut());\n         debug_assert_eq!(r, 0);\n \n-        let seconds = dur.num_seconds() as libc::time_t;\n+        let seconds = dur.secs() as libc::time_t;\n         let timeout = match sys_now.tv_sec.checked_add(seconds) {\n             Some(sec) => {\n                 libc::timespec {\n                     tv_sec: sec,\n-                    tv_nsec: (dur - Duration::seconds(dur.num_seconds()))\n-                        .num_nanoseconds().unwrap() as libc::c_long,\n+                    tv_nsec: dur.extra_nanos() as libc::c_long,\n                 }\n             }\n             None => {\n@@ -87,11 +82,12 @@ impl Condvar {\n         };\n \n         // And wait!\n-        let r = ffi::pthread_cond_timedwait(self.inner.get(), mutex::raw(mutex), &timeout);\n+        let r = ffi::pthread_cond_timedwait(self.inner.get(), mutex::raw(mutex),\n+                                            &timeout);\n         debug_assert!(r == libc::ETIMEDOUT || r == 0);\n \n-        // ETIMEDOUT is not a totally reliable method of determining timeout due to clock shifts,\n-        // so do the check ourselves\n+        // ETIMEDOUT is not a totally reliable method of determining timeout due\n+        // to clock shifts, so do the check ourselves\n         &time::SteadyTime::now() - &stable_now < dur\n     }\n "}, {"sha": "0cb5a06e6b62f04544193bea70316bc7001e7d7a", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=dd4dad8c860363077a3d53af025a0c029a613320", "patch": "@@ -129,14 +129,9 @@ impl Thread {\n     }\n \n     pub fn sleep(dur: Duration) {\n-        if dur < Duration::zero() {\n-            return Thread::yield_now()\n-        }\n-        let seconds = dur.num_seconds();\n-        let ns = dur - Duration::seconds(seconds);\n         let mut ts = libc::timespec {\n-            tv_sec: seconds as libc::time_t,\n-            tv_nsec: ns.num_nanoseconds().unwrap() as libc::c_long,\n+            tv_sec: dur.secs() as libc::time_t,\n+            tv_nsec: dur.extra_nanos() as libc::c_long,\n         };\n \n         // If we're awoken with a signal then the return value will be -1 and"}, {"sha": "16dfd3eebd02e5f9ccc98502441fa7a34947af8e", "filename": "src/libstd/sys/unix/time.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftime.rs?ref=dd4dad8c860363077a3d53af025a0c029a613320", "patch": "@@ -10,12 +10,15 @@\n \n pub use self::inner::SteadyTime;\n \n+const NSEC_PER_SEC: u64 = 1_000_000_000;\n+\n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n mod inner {\n     use libc;\n     use time::Duration;\n     use ops::Sub;\n     use sync::{Once, ONCE_INIT};\n+    use super::NSEC_PER_SEC;\n \n     pub struct SteadyTime {\n         t: u64\n@@ -32,11 +35,6 @@ mod inner {\n                 t: unsafe { mach_absolute_time() },\n             }\n         }\n-\n-        pub fn ns(&self) -> u64 {\n-            let info = info();\n-            self.t * info.numer as u64 / info.denom as u64\n-        }\n     }\n \n     fn info() -> &'static libc::mach_timebase_info {\n@@ -59,8 +57,9 @@ mod inner {\n \n         fn sub(self, other: &SteadyTime) -> Duration {\n             let info = info();\n-            let diff = self.t as i64 - other.t as i64;\n-            Duration::nanoseconds(diff * info.numer as i64 / info.denom as i64)\n+            let diff = self.t as u64 - other.t as u64;\n+            let nanos = diff * info.numer as u64 / info.denom as u64;\n+            Duration::new(nanos / NSEC_PER_SEC, (nanos % NSEC_PER_SEC) as u32)\n         }\n     }\n }\n@@ -70,8 +69,7 @@ mod inner {\n     use libc;\n     use time::Duration;\n     use ops::Sub;\n-\n-    const NSEC_PER_SEC: i64 = 1_000_000_000;\n+    use super::NSEC_PER_SEC;\n \n     pub struct SteadyTime {\n         t: libc::timespec,\n@@ -104,23 +102,19 @@ mod inner {\n             }\n             t\n         }\n-\n-        pub fn ns(&self) -> u64 {\n-            self.t.tv_sec as u64 * NSEC_PER_SEC as u64 + self.t.tv_nsec as u64\n-        }\n     }\n \n     impl<'a> Sub for &'a SteadyTime {\n         type Output = Duration;\n \n         fn sub(self, other: &SteadyTime) -> Duration {\n             if self.t.tv_nsec >= other.t.tv_nsec {\n-                Duration::seconds(self.t.tv_sec as i64 - other.t.tv_sec as i64) +\n-                    Duration::nanoseconds(self.t.tv_nsec as i64 - other.t.tv_nsec as i64)\n+                Duration::new(self.t.tv_sec as u64 - other.t.tv_sec as u64,\n+                              self.t.tv_nsec as u32 - other.t.tv_nsec as u32)\n             } else {\n-                Duration::seconds(self.t.tv_sec as i64 - 1 - other.t.tv_sec as i64) +\n-                    Duration::nanoseconds(self.t.tv_nsec as i64 + NSEC_PER_SEC -\n-                                          other.t.tv_nsec as i64)\n+                Duration::new(self.t.tv_sec as u64 - 1 - other.t.tv_sec as u64,\n+                              self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) -\n+                                          other.t.tv_nsec as u32)\n             }\n         }\n     }"}, {"sha": "8bb2326e4d6b9dc52d713a0a3347d4f3f22d085a", "filename": "src/libstd/sys/windows/condvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs?ref=dd4dad8c860363077a3d53af025a0c029a613320", "patch": "@@ -42,7 +42,7 @@ impl Condvar {\n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n         let r = ffi::SleepConditionVariableSRW(self.inner.get(),\n                                                mutex::raw(mutex),\n-                                               dur.num_milliseconds() as DWORD,\n+                                               super::dur2timeout(dur),\n                                                0);\n         if r == 0 {\n             const ERROR_TIMEOUT: DWORD = 0x5B4;"}, {"sha": "6b7bff2c1c6f82929df83458d5ad68be66bd54a3", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=dd4dad8c860363077a3d53af025a0c029a613320", "patch": "@@ -20,6 +20,7 @@ use libc;\n use num::Zero;\n use os::windows::ffi::{OsStrExt, OsStringExt};\n use path::PathBuf;\n+use time::Duration;\n \n pub mod backtrace;\n pub mod c;\n@@ -151,6 +152,27 @@ fn cvt<I: PartialEq + Zero>(i: I) -> io::Result<I> {\n     }\n }\n \n+fn dur2timeout(dur: Duration) -> libc::DWORD {\n+    // Note that a duration is a (u64, u32) (seconds, nanoseconds) pair, and the\n+    // timeouts in windows APIs are typically u32 milliseconds. To translate, we\n+    // have two pieces to take care of:\n+    //\n+    // * Nanosecond precision is rounded up\n+    // * Greater than u32::MAX milliseconds (50 days) is rounded up to INFINITE\n+    //   (never time out).\n+    dur.secs().checked_mul(1000).and_then(|ms| {\n+        ms.checked_add((dur.extra_nanos() as u64) / 1_000_000)\n+    }).and_then(|ms| {\n+        ms.checked_add(if dur.extra_nanos() % 1_000_000 > 0 {1} else {0})\n+    }).map(|ms| {\n+        if ms > <libc::DWORD>::max_value() as u64 {\n+            libc::INFINITE\n+        } else {\n+            ms as libc::DWORD\n+        }\n+    }).unwrap_or(libc::INFINITE)\n+}\n+\n fn ms_to_filetime(ms: u64) -> libc::FILETIME {\n     // A FILETIME is a count of 100 nanosecond intervals, so we multiply by\n     // 10000 b/c there are 10000 intervals in 1 ms"}, {"sha": "50dfee4ab1011d6a58581404da327ac151c123d9", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=dd4dad8c860363077a3d53af025a0c029a613320", "patch": "@@ -80,15 +80,7 @@ impl Thread {\n \n     pub fn sleep(dur: Duration) {\n         unsafe {\n-            if dur < Duration::zero() {\n-                return Thread::yield_now()\n-            }\n-            let ms = dur.num_milliseconds();\n-            // if we have a fractional number of milliseconds then add an extra\n-            // millisecond to sleep for\n-            let extra = dur - Duration::milliseconds(ms);\n-            let ms = ms + if extra.is_zero() {0} else {1};\n-            c::Sleep(ms as DWORD);\n+            c::Sleep(super::dur2timeout(dur))\n         }\n     }\n }"}, {"sha": "e64df54a0fa035bc7285e3a08323430cac480d95", "filename": "src/libstd/sys/windows/time.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs?ref=dd4dad8c860363077a3d53af025a0c029a613320", "patch": "@@ -12,7 +12,7 @@ use ops::Sub;\n use time::Duration;\n use sync::{Once, ONCE_INIT};\n \n-const NANOS_PER_SEC: i64 = 1_000_000_000;\n+const NANOS_PER_SEC: u64 = 1_000_000_000;\n \n pub struct SteadyTime {\n     t: libc::LARGE_INTEGER,\n@@ -24,10 +24,6 @@ impl SteadyTime {\n         unsafe { libc::QueryPerformanceCounter(&mut t.t); }\n         t\n     }\n-\n-    pub fn ns(&self) -> u64 {\n-        mul_div_i64(self.t as i64, NANOS_PER_SEC, frequency() as i64) as u64\n-    }\n }\n \n fn frequency() -> libc::LARGE_INTEGER {\n@@ -46,15 +42,16 @@ impl<'a> Sub for &'a SteadyTime {\n     type Output = Duration;\n \n     fn sub(self, other: &SteadyTime) -> Duration {\n-        let diff = self.t as i64 - other.t as i64;\n-        Duration::nanoseconds(mul_div_i64(diff, NANOS_PER_SEC, frequency() as i64))\n+        let diff = self.t as u64 - other.t as u64;\n+        let nanos = mul_div_u64(diff, NANOS_PER_SEC, frequency() as u64);\n+        Duration::new(nanos / NANOS_PER_SEC, (nanos % NANOS_PER_SEC) as u32)\n     }\n }\n \n // Computes (value*numer)/denom without overflow, as long as both\n // (numer*denom) and the overall result fit into i64 (which is the case\n // for our time conversions).\n-fn mul_div_i64(value: i64, numer: i64, denom: i64) -> i64 {\n+fn mul_div_u64(value: u64, numer: u64, denom: u64) -> u64 {\n     let q = value / denom;\n     let r = value % denom;\n     // Decompose value as (value/denom*denom + value%denom),\n@@ -65,9 +62,6 @@ fn mul_div_i64(value: i64, numer: i64, denom: i64) -> i64 {\n \n #[test]\n fn test_muldiv() {\n-    assert_eq!(mul_div_i64( 1_000_000_000_001, 1_000_000_000, 1_000_000),  1_000_000_000_001_000);\n-    assert_eq!(mul_div_i64(-1_000_000_000_001, 1_000_000_000, 1_000_000), -1_000_000_000_001_000);\n-    assert_eq!(mul_div_i64(-1_000_000_000_001,-1_000_000_000, 1_000_000),  1_000_000_000_001_000);\n-    assert_eq!(mul_div_i64( 1_000_000_000_001, 1_000_000_000,-1_000_000), -1_000_000_000_001_000);\n-    assert_eq!(mul_div_i64( 1_000_000_000_001,-1_000_000_000,-1_000_000),  1_000_000_000_001_000);\n+    assert_eq!(mul_div_u64( 1_000_000_000_001, 1_000_000_000, 1_000_000),\n+               1_000_000_000_001_000);\n }"}, {"sha": "7c8cb5b01c1088bfe9f176a6f738d812f5cf1e73", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=dd4dad8c860363077a3d53af025a0c029a613320", "patch": "@@ -482,7 +482,23 @@ pub fn catch_panic<F, R>(f: F) -> Result<R>\n /// spurious wakeup.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn sleep_ms(ms: u32) {\n-    imp::Thread::sleep(Duration::milliseconds(ms as i64))\n+    sleep(Duration::from_millis(ms as u64))\n+}\n+\n+/// Puts the current thread to sleep for the specified amount of time.\n+///\n+/// The thread may sleep longer than the duration specified due to scheduling\n+/// specifics or platform-dependent functionality.\n+///\n+/// # Platform behavior\n+///\n+/// On Unix platforms this function will not return early due to a\n+/// signal being received or a spurious wakeup. Platforms which do not support\n+/// nanosecond precision for sleeping will have `dur` rounded up to the nearest\n+/// granularity of time they can sleep for.\n+#[unstable(feature = \"thread_sleep\", reason = \"waiting on Duration\")]\n+pub fn sleep(dur: Duration) {\n+    imp::Thread::sleep(dur)\n }\n \n /// Blocks unless or until the current thread's token is made available (may wake spuriously).\n@@ -508,18 +524,38 @@ pub fn park() {\n /// the specified duration has been reached (may wake spuriously).\n ///\n /// The semantics of this function are equivalent to `park()` except that the\n-/// thread will be blocked for roughly no longer than *duration*. This method\n+/// thread will be blocked for roughly no longer than *ms*. This method\n /// should not be used for precise timing due to anomalies such as\n /// preemption or platform differences that may not cause the maximum\n-/// amount of time waited to be precisely *duration* long.\n+/// amount of time waited to be precisely *ms* long.\n ///\n /// See the module doc for more detail.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn park_timeout_ms(ms: u32) {\n+    park_timeout(Duration::from_millis(ms as u64))\n+}\n+\n+/// Blocks unless or until the current thread's token is made available or\n+/// the specified duration has been reached (may wake spuriously).\n+///\n+/// The semantics of this function are equivalent to `park()` except that the\n+/// thread will be blocked for roughly no longer than *dur*. This method\n+/// should not be used for precise timing due to anomalies such as\n+/// preemption or platform differences that may not cause the maximum\n+/// amount of time waited to be precisely *dur* long.\n+///\n+/// See the module doc for more detail.\n+///\n+/// # Platform behavior\n+///\n+/// Platforms which do not support nanosecond precision for sleeping will have\n+/// `dur` rounded up to the nearest granularity of time they can sleep for.\n+#[unstable(feature = \"park_timeout\", reason = \"waiting on Duration\")]\n+pub fn park_timeout(dur: Duration) {\n     let thread = current();\n     let mut guard = thread.inner.lock.lock().unwrap();\n     if !*guard {\n-        let (g, _) = thread.inner.cvar.wait_timeout_ms(guard, ms).unwrap();\n+        let (g, _) = thread.inner.cvar.wait_timeout(guard, dur).unwrap();\n         guard = g;\n     }\n     *guard = false;"}, {"sha": "8001df29d1fc725c4ba4f646057edf0129dc7d1a", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 170, "deletions": 494, "changes": 664, "blob_url": "https://github.com/rust-lang/rust/blob/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=dd4dad8c860363077a3d53af025a0c029a613320", "patch": "@@ -10,589 +10,265 @@\n \n //! Temporal quantification\n \n-#![unstable(feature = \"std_misc\")]\n+#![unstable(feature = \"duration\", reason = \"recently added API per RFC 1040\")]\n \n use prelude::v1::*;\n \n-use {fmt, i64};\n-use ops::{Add, Sub, Mul, Div, Neg};\n-\n-/// The number of nanoseconds in a microsecond.\n-const NANOS_PER_MICRO: i32 = 1000;\n-/// The number of nanoseconds in a millisecond.\n-const NANOS_PER_MILLI: i32 = 1000_000;\n-/// The number of nanoseconds in seconds.\n-const NANOS_PER_SEC: i32 = 1_000_000_000;\n-/// The number of microseconds per second.\n-const MICROS_PER_SEC: i64 = 1000_000;\n-/// The number of milliseconds per second.\n-const MILLIS_PER_SEC: i64 = 1000;\n-/// The number of seconds in a minute.\n-const SECS_PER_MINUTE: i64 = 60;\n-/// The number of seconds in an hour.\n-const SECS_PER_HOUR: i64 = 3600;\n-/// The number of (non-leap) seconds in days.\n-const SECS_PER_DAY: i64 = 86400;\n-/// The number of (non-leap) seconds in a week.\n-const SECS_PER_WEEK: i64 = 604800;\n-\n-macro_rules! try_opt {\n-    ($e:expr) => (match $e { Some(v) => v, None => return None })\n-}\n-\n-\n-/// ISO 8601 time duration with nanosecond precision.\n-/// This also allows for the negative duration; see individual methods for details.\n-#[unstable(feature = \"std_misc\")]\n+use fmt;\n+use ops::{Add, Sub, Mul, Div};\n+use sys::time::SteadyTime;\n+\n+const NANOS_PER_SEC: u32 = 1_000_000_000;\n+const NANOS_PER_MILLI: u32 = 1_000_000;\n+const MILLIS_PER_SEC: u64 = 1_000;\n+\n+/// A duration type to represent a span of time, typically used for system\n+/// timeouts.\n+///\n+/// Each duration is composed of a number of seconds and nanosecond precision.\n+/// APIs binding a system timeout will typically round up the nanosecond\n+/// precision if the underlying system does not support that level of precision.\n+///\n+/// Durations implement many common traits, including `Add`, `Sub`, and other\n+/// ops traits. Currently a duration may only be inspected for its number of\n+/// seconds and its nanosecond precision.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(duration)]\n+/// use std::time::Duration;\n+///\n+/// let five_seconds = Duration::new(5, 0);\n+/// let five_seconds_and_five_nanos = five_seconds + Duration::new(0, 5);\n+///\n+/// assert_eq!(five_seconds_and_five_nanos.secs(), 5);\n+/// assert_eq!(five_seconds_and_five_nanos.extra_nanos(), 5);\n+///\n+/// let ten_millis = Duration::from_millis(10);\n+/// ```\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]\n pub struct Duration {\n-    secs: i64,\n-    nanos: i32, // Always 0 <= nanos < NANOS_PER_SEC\n+    secs: u64,\n+    nanos: u32, // Always 0 <= nanos < NANOS_PER_SEC\n }\n \n-/// The minimum possible `Duration`: `i64::MIN` milliseconds.\n-#[unstable(feature = \"std_misc\")]\n-pub const MIN: Duration = Duration {\n-    secs: i64::MIN / MILLIS_PER_SEC - 1,\n-    nanos: NANOS_PER_SEC + (i64::MIN % MILLIS_PER_SEC) as i32 * NANOS_PER_MILLI\n-};\n-\n-/// The maximum possible `Duration`: `i64::MAX` milliseconds.\n-#[unstable(feature = \"std_misc\")]\n-pub const MAX: Duration = Duration {\n-    secs: i64::MAX / MILLIS_PER_SEC,\n-    nanos: (i64::MAX % MILLIS_PER_SEC) as i32 * NANOS_PER_MILLI\n-};\n-\n impl Duration {\n-    /// Makes a new `Duration` with given number of weeks.\n-    /// Equivalent to `Duration::seconds(weeks * 7 * 24 * 60 * 60)` with overflow checks.\n-    /// Panics when the duration is out of bounds.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn weeks(weeks: i64) -> Duration {\n-        let secs = weeks.checked_mul(SECS_PER_WEEK).expect(\"Duration::weeks out of bounds\");\n-        Duration::seconds(secs)\n-    }\n-\n-    /// Makes a new `Duration` with given number of days.\n-    /// Equivalent to `Duration::seconds(days * 24 * 60 * 60)` with overflow checks.\n-    /// Panics when the duration is out of bounds.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn days(days: i64) -> Duration {\n-        let secs = days.checked_mul(SECS_PER_DAY).expect(\"Duration::days out of bounds\");\n-        Duration::seconds(secs)\n-    }\n-\n-    /// Makes a new `Duration` with given number of hours.\n-    /// Equivalent to `Duration::seconds(hours * 60 * 60)` with overflow checks.\n-    /// Panics when the duration is out of bounds.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn hours(hours: i64) -> Duration {\n-        let secs = hours.checked_mul(SECS_PER_HOUR).expect(\"Duration::hours ouf of bounds\");\n-        Duration::seconds(secs)\n-    }\n-\n-    /// Makes a new `Duration` with given number of minutes.\n-    /// Equivalent to `Duration::seconds(minutes * 60)` with overflow checks.\n-    /// Panics when the duration is out of bounds.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn minutes(minutes: i64) -> Duration {\n-        let secs = minutes.checked_mul(SECS_PER_MINUTE).expect(\"Duration::minutes out of bounds\");\n-        Duration::seconds(secs)\n-    }\n-\n-    /// Makes a new `Duration` with given number of seconds.\n-    /// Panics when the duration is more than `i64::MAX` milliseconds\n-    /// or less than `i64::MIN` milliseconds.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn seconds(seconds: i64) -> Duration {\n-        let d = Duration { secs: seconds, nanos: 0 };\n-        if d < MIN || d > MAX {\n-            panic!(\"Duration::seconds out of bounds\");\n-        }\n-        d\n-    }\n-\n-    /// Makes a new `Duration` with given number of milliseconds.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn milliseconds(milliseconds: i64) -> Duration {\n-        let (secs, millis) = div_mod_floor_64(milliseconds, MILLIS_PER_SEC);\n-        let nanos = millis as i32 * NANOS_PER_MILLI;\n+    /// Crates a new `Duration` from the specified number of seconds and\n+    /// additional nanosecond precision.\n+    ///\n+    /// If the nanoseconds is greater than 1 billion (the number of nanoseconds\n+    /// in a second), then it will carry over into the seconds provided.\n+    pub fn new(secs: u64, nanos: u32) -> Duration {\n+        let secs = secs + (nanos / NANOS_PER_SEC) as u64;\n+        let nanos = nanos % NANOS_PER_SEC;\n         Duration { secs: secs, nanos: nanos }\n     }\n \n-    /// Makes a new `Duration` with given number of microseconds.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn microseconds(microseconds: i64) -> Duration {\n-        let (secs, micros) = div_mod_floor_64(microseconds, MICROS_PER_SEC);\n-        let nanos = micros as i32 * NANOS_PER_MICRO;\n-        Duration { secs: secs, nanos: nanos }\n-    }\n-\n-    /// Makes a new `Duration` with given number of nanoseconds.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn nanoseconds(nanos: i64) -> Duration {\n-        let (secs, nanos) = div_mod_floor_64(nanos, NANOS_PER_SEC as i64);\n-        Duration { secs: secs, nanos: nanos as i32 }\n-    }\n-\n     /// Runs a closure, returning the duration of time it took to run the\n     /// closure.\n-    #[unstable(feature = \"std_misc\")]\n+    #[unstable(feature = \"duration_span\",\n+               reason = \"unsure if this is the right API or whether it should \\\n+                         wait for a more general \\\"moment in time\\\" \\\n+                         abstraction\")]\n     pub fn span<F>(f: F) -> Duration where F: FnOnce() {\n-        let before = super::precise_time_ns();\n+        let start = SteadyTime::now();\n         f();\n-        Duration::nanoseconds((super::precise_time_ns() - before) as i64)\n-    }\n-\n-    /// Returns the total number of whole weeks in the duration.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn num_weeks(&self) -> i64 {\n-        self.num_days() / 7\n-    }\n-\n-    /// Returns the total number of whole days in the duration.\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn num_days(&self) -> i64 {\n-        self.num_seconds() / SECS_PER_DAY\n-    }\n-\n-    /// Returns the total number of whole hours in the duration.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn num_hours(&self) -> i64 {\n-        self.num_seconds() / SECS_PER_HOUR\n-    }\n-\n-    /// Returns the total number of whole minutes in the duration.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn num_minutes(&self) -> i64 {\n-        self.num_seconds() / SECS_PER_MINUTE\n-    }\n-\n-    /// Returns the total number of whole seconds in the duration.\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn num_seconds(&self) -> i64 {\n-        // If secs is negative, nanos should be subtracted from the duration.\n-        if self.secs < 0 && self.nanos > 0 {\n-            self.secs + 1\n-        } else {\n-            self.secs\n-        }\n-    }\n-\n-    /// Returns the number of nanoseconds such that\n-    /// `nanos_mod_sec() + num_seconds() * NANOS_PER_SEC` is the total number of\n-    /// nanoseconds in the duration.\n-    fn nanos_mod_sec(&self) -> i32 {\n-        if self.secs < 0 && self.nanos > 0 {\n-            self.nanos - NANOS_PER_SEC\n-        } else {\n-            self.nanos\n-        }\n-    }\n-\n-    /// Returns the total number of whole milliseconds in the duration,\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn num_milliseconds(&self) -> i64 {\n-        // A proper Duration will not overflow, because MIN and MAX are defined\n-        // such that the range is exactly i64 milliseconds.\n-        let secs_part = self.num_seconds() * MILLIS_PER_SEC;\n-        let nanos_part = self.nanos_mod_sec() / NANOS_PER_MILLI;\n-        secs_part + nanos_part as i64\n-    }\n-\n-    /// Returns the total number of whole microseconds in the duration,\n-    /// or `None` on overflow (exceeding 2^63 microseconds in either direction).\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn num_microseconds(&self) -> Option<i64> {\n-        let secs_part = try_opt!(self.num_seconds().checked_mul(MICROS_PER_SEC));\n-        let nanos_part = self.nanos_mod_sec() / NANOS_PER_MICRO;\n-        secs_part.checked_add(nanos_part as i64)\n+        &SteadyTime::now() - &start\n     }\n \n-    /// Returns the total number of whole nanoseconds in the duration,\n-    /// or `None` on overflow (exceeding 2^63 nanoseconds in either direction).\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn num_nanoseconds(&self) -> Option<i64> {\n-        let secs_part = try_opt!(self.num_seconds().checked_mul(NANOS_PER_SEC as i64));\n-        let nanos_part = self.nanos_mod_sec();\n-        secs_part.checked_add(nanos_part as i64)\n+    /// Creates a new `Duration` from the specified number of seconds.\n+    pub fn from_secs(secs: u64) -> Duration {\n+        Duration { secs: secs, nanos: 0 }\n     }\n \n-    /// Add two durations, returning `None` if overflow occurred.\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn checked_add(&self, rhs: &Duration) -> Option<Duration> {\n-        let mut secs = try_opt!(self.secs.checked_add(rhs.secs));\n-        let mut nanos = self.nanos + rhs.nanos;\n-        if nanos >= NANOS_PER_SEC {\n-            nanos -= NANOS_PER_SEC;\n-            secs = try_opt!(secs.checked_add(1));\n-        }\n-        let d = Duration { secs: secs, nanos: nanos };\n-        // Even if d is within the bounds of i64 seconds,\n-        // it might still overflow i64 milliseconds.\n-        if d < MIN || d > MAX { None } else { Some(d) }\n-    }\n-\n-    /// Subtract two durations, returning `None` if overflow occurred.\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn checked_sub(&self, rhs: &Duration) -> Option<Duration> {\n-        let mut secs = try_opt!(self.secs.checked_sub(rhs.secs));\n-        let mut nanos = self.nanos - rhs.nanos;\n-        if nanos < 0 {\n-            nanos += NANOS_PER_SEC;\n-            secs = try_opt!(secs.checked_sub(1));\n-        }\n-        let d = Duration { secs: secs, nanos: nanos };\n-        // Even if d is within the bounds of i64 seconds,\n-        // it might still overflow i64 milliseconds.\n-        if d < MIN || d > MAX { None } else { Some(d) }\n-    }\n-\n-    /// The minimum possible `Duration`: `i64::MIN` milliseconds.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn min_value() -> Duration { MIN }\n-\n-    /// The maximum possible `Duration`: `i64::MAX` milliseconds.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn max_value() -> Duration { MAX }\n-\n-    /// A duration where the stored seconds and nanoseconds are equal to zero.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn zero() -> Duration {\n-        Duration { secs: 0, nanos: 0 }\n-    }\n-\n-    /// Returns `true` if the duration equals `Duration::zero()`.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn is_zero(&self) -> bool {\n-        self.secs == 0 && self.nanos == 0\n+    /// Creates a new `Duration` from the specified number of milliseconds.\n+    pub fn from_millis(millis: u64) -> Duration {\n+        let secs = millis / MILLIS_PER_SEC;\n+        let nanos = ((millis % MILLIS_PER_SEC) as u32) * NANOS_PER_MILLI;\n+        Duration { secs: secs, nanos: nanos }\n     }\n-}\n \n-#[unstable(feature = \"std_misc\")]\n-impl Neg for Duration {\n-    type Output = Duration;\n+    /// Returns the number of whole seconds represented by this duration.\n+    ///\n+    /// The extra precision represented by this duration is ignored (e.g. extra\n+    /// nanoseconds are not represented in the returned value).\n+    pub fn secs(&self) -> u64 { self.secs }\n \n-    #[inline]\n-    fn neg(self) -> Duration {\n-        if self.nanos == 0 {\n-            Duration { secs: -self.secs, nanos: 0 }\n-        } else {\n-            Duration { secs: -self.secs - 1, nanos: NANOS_PER_SEC - self.nanos }\n-        }\n-    }\n+    /// Returns the nanosecond precision represented by this duration.\n+    ///\n+    /// This method does **not** return the length of the duration when\n+    /// represented by nanoseconds. The returned number always represents a\n+    /// fractional portion of a second (e.g. it is less than one billion).\n+    pub fn extra_nanos(&self) -> u32 { self.nanos }\n }\n \n-#[unstable(feature = \"std_misc\")]\n impl Add for Duration {\n     type Output = Duration;\n \n     fn add(self, rhs: Duration) -> Duration {\n-        let mut secs = self.secs + rhs.secs;\n+        let mut secs = self.secs.checked_add(rhs.secs)\n+                           .expect(\"overflow when adding durations\");\n         let mut nanos = self.nanos + rhs.nanos;\n         if nanos >= NANOS_PER_SEC {\n             nanos -= NANOS_PER_SEC;\n-            secs += 1;\n+            secs = secs.checked_add(1).expect(\"overflow when adding durations\");\n         }\n+        debug_assert!(nanos < NANOS_PER_SEC);\n         Duration { secs: secs, nanos: nanos }\n     }\n }\n \n-#[unstable(feature = \"std_misc\")]\n impl Sub for Duration {\n     type Output = Duration;\n \n     fn sub(self, rhs: Duration) -> Duration {\n-        let mut secs = self.secs - rhs.secs;\n-        let mut nanos = self.nanos - rhs.nanos;\n-        if nanos < 0 {\n-            nanos += NANOS_PER_SEC;\n-            secs -= 1;\n-        }\n+        let mut secs = self.secs.checked_sub(rhs.secs)\n+                           .expect(\"overflow when subtracting durations\");\n+        let nanos = if self.nanos >= rhs.nanos {\n+            self.nanos - rhs.nanos\n+        } else {\n+            secs = secs.checked_sub(1)\n+                       .expect(\"overflow when subtracting durations\");\n+            self.nanos + NANOS_PER_SEC - rhs.nanos\n+        };\n+        debug_assert!(nanos < NANOS_PER_SEC);\n         Duration { secs: secs, nanos: nanos }\n     }\n }\n \n-#[unstable(feature = \"std_misc\")]\n-impl Mul<i32> for Duration {\n+impl Mul<u32> for Duration {\n     type Output = Duration;\n \n-    fn mul(self, rhs: i32) -> Duration {\n-        // Multiply nanoseconds as i64, because it cannot overflow that way.\n-        let total_nanos = self.nanos as i64 * rhs as i64;\n-        let (extra_secs, nanos) = div_mod_floor_64(total_nanos, NANOS_PER_SEC as i64);\n-        let secs = self.secs * rhs as i64 + extra_secs;\n-        Duration { secs: secs, nanos: nanos as i32 }\n+    fn mul(self, rhs: u32) -> Duration {\n+        // Multiply nanoseconds as u64, because it cannot overflow that way.\n+        let total_nanos = self.nanos as u64 * rhs as u64;\n+        let extra_secs = total_nanos / (NANOS_PER_SEC as u64);\n+        let nanos = (total_nanos % (NANOS_PER_SEC as u64)) as u32;\n+        let secs = self.secs.checked_mul(rhs as u64)\n+                       .and_then(|s| s.checked_add(extra_secs))\n+                       .expect(\"overflow when multiplying duration\");\n+        debug_assert!(nanos < NANOS_PER_SEC);\n+        Duration { secs: secs, nanos: nanos }\n     }\n }\n \n-#[unstable(feature = \"std_misc\")]\n-impl Div<i32> for Duration {\n+impl Div<u32> for Duration {\n     type Output = Duration;\n \n-    fn div(self, rhs: i32) -> Duration {\n-        let mut secs = self.secs / rhs as i64;\n-        let carry = self.secs - secs * rhs as i64;\n-        let extra_nanos = carry * NANOS_PER_SEC as i64 / rhs as i64;\n-        let mut nanos = self.nanos / rhs + extra_nanos as i32;\n-        if nanos >= NANOS_PER_SEC {\n-            nanos -= NANOS_PER_SEC;\n-            secs += 1;\n-        }\n-        if nanos < 0 {\n-            nanos += NANOS_PER_SEC;\n-            secs -= 1;\n-        }\n+    fn div(self, rhs: u32) -> Duration {\n+        let secs = self.secs / (rhs as u64);\n+        let carry = self.secs - secs * (rhs as u64);\n+        let extra_nanos = carry * (NANOS_PER_SEC as u64) / (rhs as u64);\n+        let nanos = self.nanos / rhs + (extra_nanos as u32);\n+        debug_assert!(nanos < NANOS_PER_SEC);\n         Duration { secs: secs, nanos: nanos }\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for Duration {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // technically speaking, negative duration is not valid ISO 8601,\n-        // but we need to print it anyway.\n-        let (abs, sign) = if self.secs < 0 { (-*self, \"-\") } else { (*self, \"\") };\n-\n-        let days = abs.secs / SECS_PER_DAY;\n-        let secs = abs.secs - days * SECS_PER_DAY;\n-        let hasdate = days != 0;\n-        let hastime = (secs != 0 || abs.nanos != 0) || !hasdate;\n-\n-        try!(write!(f, \"{}P\", sign));\n-\n-        if hasdate {\n-            try!(write!(f, \"{}D\", days));\n-        }\n-        if hastime {\n-            if abs.nanos == 0 {\n-                try!(write!(f, \"T{}S\", secs));\n-            } else if abs.nanos % NANOS_PER_MILLI == 0 {\n-                try!(write!(f, \"T{}.{:03}S\", secs, abs.nanos / NANOS_PER_MILLI));\n-            } else if abs.nanos % NANOS_PER_MICRO == 0 {\n-                try!(write!(f, \"T{}.{:06}S\", secs, abs.nanos / NANOS_PER_MICRO));\n-            } else {\n-                try!(write!(f, \"T{}.{:09}S\", secs, abs.nanos));\n-            }\n+        match (self.secs, self.nanos) {\n+            (s, 0) => write!(f, \"{}s\", s),\n+            (0, n) if n % NANOS_PER_MILLI == 0 => write!(f, \"{}ms\",\n+                                                         n / NANOS_PER_MILLI),\n+            (0, n) if n % 1_000 == 0 => write!(f, \"{}\u00b5s\", n / 1_000),\n+            (0, n) => write!(f, \"{}ns\", n),\n+            (s, n) => write!(f, \"{}.{}s\", s,\n+                             format!(\"{:09}\", n).trim_right_matches('0'))\n         }\n-        Ok(())\n-    }\n-}\n-\n-// Copied from libnum\n-#[inline]\n-fn div_mod_floor_64(this: i64, other: i64) -> (i64, i64) {\n-    (div_floor_64(this, other), mod_floor_64(this, other))\n-}\n-\n-#[inline]\n-fn div_floor_64(this: i64, other: i64) -> i64 {\n-    match div_rem_64(this, other) {\n-        (d, r) if (r > 0 && other < 0)\n-               || (r < 0 && other > 0) => d - 1,\n-        (d, _)                         => d,\n-    }\n-}\n-\n-#[inline]\n-fn mod_floor_64(this: i64, other: i64) -> i64 {\n-    match this % other {\n-        r if (r > 0 && other < 0)\n-          || (r < 0 && other > 0) => r + other,\n-        r                         => r,\n     }\n }\n \n-#[inline]\n-fn div_rem_64(this: i64, other: i64) -> (i64, i64) {\n-    (this / other, this % other)\n-}\n-\n #[cfg(test)]\n mod tests {\n-    use super::{Duration, MIN, MAX};\n-    use {i32, i64};\n-    use option::Option::{Some, None};\n-    use string::ToString;\n+    use prelude::v1::*;\n+    use super::Duration;\n \n     #[test]\n-    fn test_duration() {\n-        assert!(Duration::seconds(1) != Duration::zero());\n-        assert_eq!(Duration::seconds(1) + Duration::seconds(2), Duration::seconds(3));\n-        assert_eq!(Duration::seconds(86399) + Duration::seconds(4),\n-                   Duration::days(1) + Duration::seconds(3));\n-        assert_eq!(Duration::days(10) - Duration::seconds(1000), Duration::seconds(863000));\n-        assert_eq!(Duration::days(10) - Duration::seconds(1000000), Duration::seconds(-136000));\n-        assert_eq!(Duration::days(2) + Duration::seconds(86399) +\n-                   Duration::nanoseconds(1234567890),\n-                   Duration::days(3) + Duration::nanoseconds(234567890));\n-        assert_eq!(-Duration::days(3), Duration::days(-3));\n-        assert_eq!(-(Duration::days(3) + Duration::seconds(70)),\n-                   Duration::days(-4) + Duration::seconds(86400-70));\n+    fn creation() {\n+        assert!(Duration::from_secs(1) != Duration::from_secs(0));\n+        assert_eq!(Duration::from_secs(1) + Duration::from_secs(2),\n+                   Duration::from_secs(3));\n+        assert_eq!(Duration::from_millis(10) + Duration::from_secs(4),\n+                   Duration::new(4, 10 * 1_000_000));\n+        assert_eq!(Duration::from_millis(4000), Duration::new(4, 0));\n     }\n \n     #[test]\n-    fn test_duration_num_days() {\n-        assert_eq!(Duration::zero().num_days(), 0);\n-        assert_eq!(Duration::days(1).num_days(), 1);\n-        assert_eq!(Duration::days(-1).num_days(), -1);\n-        assert_eq!(Duration::seconds(86399).num_days(), 0);\n-        assert_eq!(Duration::seconds(86401).num_days(), 1);\n-        assert_eq!(Duration::seconds(-86399).num_days(), 0);\n-        assert_eq!(Duration::seconds(-86401).num_days(), -1);\n-        assert_eq!(Duration::days(i32::MAX as i64).num_days(), i32::MAX as i64);\n-        assert_eq!(Duration::days(i32::MIN as i64).num_days(), i32::MIN as i64);\n+    fn secs() {\n+        assert_eq!(Duration::new(0, 0).secs(), 0);\n+        assert_eq!(Duration::from_secs(1).secs(), 1);\n+        assert_eq!(Duration::from_millis(999).secs(), 0);\n+        assert_eq!(Duration::from_millis(1001).secs(), 1);\n     }\n \n     #[test]\n-    fn test_duration_num_seconds() {\n-        assert_eq!(Duration::zero().num_seconds(), 0);\n-        assert_eq!(Duration::seconds(1).num_seconds(), 1);\n-        assert_eq!(Duration::seconds(-1).num_seconds(), -1);\n-        assert_eq!(Duration::milliseconds(999).num_seconds(), 0);\n-        assert_eq!(Duration::milliseconds(1001).num_seconds(), 1);\n-        assert_eq!(Duration::milliseconds(-999).num_seconds(), 0);\n-        assert_eq!(Duration::milliseconds(-1001).num_seconds(), -1);\n+    fn nanos() {\n+        assert_eq!(Duration::new(0, 0).extra_nanos(), 0);\n+        assert_eq!(Duration::new(0, 5).extra_nanos(), 5);\n+        assert_eq!(Duration::new(0, 1_000_000_001).extra_nanos(), 1);\n+        assert_eq!(Duration::from_secs(1).extra_nanos(), 0);\n+        assert_eq!(Duration::from_millis(999).extra_nanos(), 999 * 1_000_000);\n+        assert_eq!(Duration::from_millis(1001).extra_nanos(), 1 * 1_000_000);\n     }\n \n     #[test]\n-    fn test_duration_num_milliseconds() {\n-        assert_eq!(Duration::zero().num_milliseconds(), 0);\n-        assert_eq!(Duration::milliseconds(1).num_milliseconds(), 1);\n-        assert_eq!(Duration::milliseconds(-1).num_milliseconds(), -1);\n-        assert_eq!(Duration::microseconds(999).num_milliseconds(), 0);\n-        assert_eq!(Duration::microseconds(1001).num_milliseconds(), 1);\n-        assert_eq!(Duration::microseconds(-999).num_milliseconds(), 0);\n-        assert_eq!(Duration::microseconds(-1001).num_milliseconds(), -1);\n-        assert_eq!(Duration::milliseconds(i64::MAX).num_milliseconds(), i64::MAX);\n-        assert_eq!(Duration::milliseconds(i64::MIN).num_milliseconds(), i64::MIN);\n-        assert_eq!(MAX.num_milliseconds(), i64::MAX);\n-        assert_eq!(MIN.num_milliseconds(), i64::MIN);\n+    fn add() {\n+        assert_eq!(Duration::new(0, 0) + Duration::new(0, 1),\n+                   Duration::new(0, 1));\n+        assert_eq!(Duration::new(0, 500_000_000) + Duration::new(0, 500_000_001),\n+                   Duration::new(1, 1));\n     }\n \n     #[test]\n-    fn test_duration_num_microseconds() {\n-        assert_eq!(Duration::zero().num_microseconds(), Some(0));\n-        assert_eq!(Duration::microseconds(1).num_microseconds(), Some(1));\n-        assert_eq!(Duration::microseconds(-1).num_microseconds(), Some(-1));\n-        assert_eq!(Duration::nanoseconds(999).num_microseconds(), Some(0));\n-        assert_eq!(Duration::nanoseconds(1001).num_microseconds(), Some(1));\n-        assert_eq!(Duration::nanoseconds(-999).num_microseconds(), Some(0));\n-        assert_eq!(Duration::nanoseconds(-1001).num_microseconds(), Some(-1));\n-        assert_eq!(Duration::microseconds(i64::MAX).num_microseconds(), Some(i64::MAX));\n-        assert_eq!(Duration::microseconds(i64::MIN).num_microseconds(), Some(i64::MIN));\n-        assert_eq!(MAX.num_microseconds(), None);\n-        assert_eq!(MIN.num_microseconds(), None);\n-\n-        // overflow checks\n-        const MICROS_PER_DAY: i64 = 86400_000_000;\n-        assert_eq!(Duration::days(i64::MAX / MICROS_PER_DAY).num_microseconds(),\n-                   Some(i64::MAX / MICROS_PER_DAY * MICROS_PER_DAY));\n-        assert_eq!(Duration::days(i64::MIN / MICROS_PER_DAY).num_microseconds(),\n-                   Some(i64::MIN / MICROS_PER_DAY * MICROS_PER_DAY));\n-        assert_eq!(Duration::days(i64::MAX / MICROS_PER_DAY + 1).num_microseconds(), None);\n-        assert_eq!(Duration::days(i64::MIN / MICROS_PER_DAY - 1).num_microseconds(), None);\n+    fn sub() {\n+        assert_eq!(Duration::new(0, 1) - Duration::new(0, 0),\n+                   Duration::new(0, 1));\n+        assert_eq!(Duration::new(0, 500_000_001) - Duration::new(0, 500_000_000),\n+                   Duration::new(0, 1));\n+        assert_eq!(Duration::new(1, 0) - Duration::new(0, 1),\n+                   Duration::new(0, 999_999_999));\n     }\n \n-    #[test]\n-    fn test_duration_num_nanoseconds() {\n-        assert_eq!(Duration::zero().num_nanoseconds(), Some(0));\n-        assert_eq!(Duration::nanoseconds(1).num_nanoseconds(), Some(1));\n-        assert_eq!(Duration::nanoseconds(-1).num_nanoseconds(), Some(-1));\n-        assert_eq!(Duration::nanoseconds(i64::MAX).num_nanoseconds(), Some(i64::MAX));\n-        assert_eq!(Duration::nanoseconds(i64::MIN).num_nanoseconds(), Some(i64::MIN));\n-        assert_eq!(MAX.num_nanoseconds(), None);\n-        assert_eq!(MIN.num_nanoseconds(), None);\n-\n-        // overflow checks\n-        const NANOS_PER_DAY: i64 = 86400_000_000_000;\n-        assert_eq!(Duration::days(i64::MAX / NANOS_PER_DAY).num_nanoseconds(),\n-                   Some(i64::MAX / NANOS_PER_DAY * NANOS_PER_DAY));\n-        assert_eq!(Duration::days(i64::MIN / NANOS_PER_DAY).num_nanoseconds(),\n-                   Some(i64::MIN / NANOS_PER_DAY * NANOS_PER_DAY));\n-        assert_eq!(Duration::days(i64::MAX / NANOS_PER_DAY + 1).num_nanoseconds(), None);\n-        assert_eq!(Duration::days(i64::MIN / NANOS_PER_DAY - 1).num_nanoseconds(), None);\n+    #[test] #[should_panic]\n+    fn sub_bad1() {\n+        Duration::new(0, 0) - Duration::new(0, 1);\n     }\n \n-    #[test]\n-    fn test_duration_checked_ops() {\n-        assert_eq!(Duration::milliseconds(i64::MAX - 1).checked_add(&Duration::microseconds(999)),\n-                   Some(Duration::milliseconds(i64::MAX - 2) + Duration::microseconds(1999)));\n-        assert!(Duration::milliseconds(i64::MAX).checked_add(&Duration::microseconds(1000))\n-                                                .is_none());\n-\n-        assert_eq!(Duration::milliseconds(i64::MIN).checked_sub(&Duration::milliseconds(0)),\n-                   Some(Duration::milliseconds(i64::MIN)));\n-        assert!(Duration::milliseconds(i64::MIN).checked_sub(&Duration::milliseconds(1))\n-                                                .is_none());\n+    #[test] #[should_panic]\n+    fn sub_bad2() {\n+        Duration::new(0, 0) - Duration::new(1, 0);\n     }\n \n     #[test]\n-    fn test_duration_mul() {\n-        assert_eq!(Duration::zero() * i32::MAX, Duration::zero());\n-        assert_eq!(Duration::zero() * i32::MIN, Duration::zero());\n-        assert_eq!(Duration::nanoseconds(1) * 0, Duration::zero());\n-        assert_eq!(Duration::nanoseconds(1) * 1, Duration::nanoseconds(1));\n-        assert_eq!(Duration::nanoseconds(1) * 1_000_000_000, Duration::seconds(1));\n-        assert_eq!(Duration::nanoseconds(1) * -1_000_000_000, -Duration::seconds(1));\n-        assert_eq!(-Duration::nanoseconds(1) * 1_000_000_000, -Duration::seconds(1));\n-        assert_eq!(Duration::nanoseconds(30) * 333_333_333,\n-                   Duration::seconds(10) - Duration::nanoseconds(10));\n-        assert_eq!((Duration::nanoseconds(1) + Duration::seconds(1) + Duration::days(1)) * 3,\n-                   Duration::nanoseconds(3) + Duration::seconds(3) + Duration::days(3));\n-        assert_eq!(Duration::milliseconds(1500) * -2, Duration::seconds(-3));\n-        assert_eq!(Duration::milliseconds(-1500) * 2, Duration::seconds(-3));\n+    fn mul() {\n+        assert_eq!(Duration::new(0, 1) * 2, Duration::new(0, 2));\n+        assert_eq!(Duration::new(1, 1) * 3, Duration::new(3, 3));\n+        assert_eq!(Duration::new(0, 500_000_001) * 4, Duration::new(2, 4));\n+        assert_eq!(Duration::new(0, 500_000_001) * 4000,\n+                   Duration::new(2000, 4000));\n     }\n \n     #[test]\n-    fn test_duration_div() {\n-        assert_eq!(Duration::zero() / i32::MAX, Duration::zero());\n-        assert_eq!(Duration::zero() / i32::MIN, Duration::zero());\n-        assert_eq!(Duration::nanoseconds(123_456_789) / 1, Duration::nanoseconds(123_456_789));\n-        assert_eq!(Duration::nanoseconds(123_456_789) / -1, -Duration::nanoseconds(123_456_789));\n-        assert_eq!(-Duration::nanoseconds(123_456_789) / -1, Duration::nanoseconds(123_456_789));\n-        assert_eq!(-Duration::nanoseconds(123_456_789) / 1, -Duration::nanoseconds(123_456_789));\n-        assert_eq!(Duration::seconds(1) / 3, Duration::nanoseconds(333_333_333));\n-        assert_eq!(Duration::seconds(4) / 3, Duration::nanoseconds(1_333_333_333));\n-        assert_eq!(Duration::seconds(-1) / 2, Duration::milliseconds(-500));\n-        assert_eq!(Duration::seconds(1) / -2, Duration::milliseconds(-500));\n-        assert_eq!(Duration::seconds(-1) / -2, Duration::milliseconds(500));\n-        assert_eq!(Duration::seconds(-4) / 3, Duration::nanoseconds(-1_333_333_333));\n-        assert_eq!(Duration::seconds(-4) / -3, Duration::nanoseconds(1_333_333_333));\n+    fn div() {\n+        assert_eq!(Duration::new(0, 1) / 2, Duration::new(0, 0));\n+        assert_eq!(Duration::new(1, 1) / 3, Duration::new(0, 333_333_333));\n+        assert_eq!(Duration::new(99, 999_999_000) / 100,\n+                   Duration::new(0, 999_999_990));\n     }\n \n     #[test]\n-    fn test_duration_fmt() {\n-        assert_eq!(Duration::zero().to_string(), \"PT0S\");\n-        assert_eq!(Duration::days(42).to_string(), \"P42D\");\n-        assert_eq!(Duration::days(-42).to_string(), \"-P42D\");\n-        assert_eq!(Duration::seconds(42).to_string(), \"PT42S\");\n-        assert_eq!(Duration::milliseconds(42).to_string(), \"PT0.042S\");\n-        assert_eq!(Duration::microseconds(42).to_string(), \"PT0.000042S\");\n-        assert_eq!(Duration::nanoseconds(42).to_string(), \"PT0.000000042S\");\n-        assert_eq!((Duration::days(7) + Duration::milliseconds(6543)).to_string(),\n-                   \"P7DT6.543S\");\n-        assert_eq!(Duration::seconds(-86401).to_string(), \"-P1DT1S\");\n-        assert_eq!(Duration::nanoseconds(-1).to_string(), \"-PT0.000000001S\");\n-\n-        // the format specifier should have no effect on `Duration`\n-        assert_eq!(format!(\"{:30}\", Duration::days(1) + Duration::milliseconds(2345)),\n-                   \"P1DT2.345S\");\n+    fn display() {\n+        assert_eq!(Duration::new(0, 2).to_string(), \"2ns\");\n+        assert_eq!(Duration::new(0, 2_000_000).to_string(), \"2ms\");\n+        assert_eq!(Duration::new(2, 0).to_string(), \"2s\");\n+        assert_eq!(Duration::new(2, 2).to_string(), \"2.000000002s\");\n+        assert_eq!(Duration::new(2, 2_000_000).to_string(),\n+                   \"2.002s\");\n+        assert_eq!(Duration::new(0, 2_000_002).to_string(),\n+                   \"2000002ns\");\n+        assert_eq!(Duration::new(2, 2_000_002).to_string(),\n+                   \"2.002000002s\");\n     }\n }"}, {"sha": "d535b195519952d924a2b95b6c0bd631b5082e96", "filename": "src/libstd/time/mod.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibstd%2Ftime%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibstd%2Ftime%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fmod.rs?ref=dd4dad8c860363077a3d53af025a0c029a613320", "patch": "@@ -10,17 +10,8 @@\n \n //! Temporal quantification.\n \n-#![unstable(feature = \"std_misc\")]\n-\n-use sys::time::SteadyTime;\n+#![unstable(feature = \"time\")]\n \n pub use self::duration::Duration;\n \n-pub mod duration;\n-\n-/// Returns the current value of a high-resolution performance counter\n-/// in nanoseconds since an unspecified epoch.\n-// NB: this is intentionally not public, this is not ready to stabilize its api.\n-fn precise_time_ns() -> u64 {\n-    SteadyTime::now().ns()\n-}\n+mod duration;"}, {"sha": "b16154861530dc70a61ddefb7beafc615b098bfc", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4dad8c860363077a3d53af025a0c029a613320/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=dd4dad8c860363077a3d53af025a0c029a613320", "patch": "@@ -43,6 +43,8 @@\n #![feature(std_misc)]\n #![feature(libc)]\n #![feature(set_stdio)]\n+#![feature(duration)]\n+#![feature(duration_span)]\n \n extern crate getopts;\n extern crate serialize;\n@@ -1069,7 +1071,7 @@ impl Bencher {\n     }\n \n     pub fn ns_elapsed(&mut self) -> u64 {\n-        self.dur.num_nanoseconds().unwrap() as u64\n+        self.dur.secs() * 1_000_000_000 + (self.dur.extra_nanos() as u64)\n     }\n \n     pub fn ns_per_iter(&mut self) -> u64 {\n@@ -1105,7 +1107,7 @@ impl Bencher {\n         // (i.e. larger error bars).\n         if n == 0 { n = 1; }\n \n-        let mut total_run = Duration::nanoseconds(0);\n+        let mut total_run = Duration::new(0, 0);\n         let samples : &mut [f64] = &mut [0.0_f64; 50];\n         loop {\n             let mut summ = None;\n@@ -1134,15 +1136,15 @@ impl Bencher {\n \n             // If we've run for 100ms and seem to have converged to a\n             // stable median.\n-            if loop_run.num_milliseconds() > 100 &&\n+            if loop_run > Duration::from_millis(100) &&\n                 summ.median_abs_dev_pct < 1.0 &&\n                 summ.median - summ5.median < summ5.median_abs_dev {\n                 return summ5;\n             }\n \n             total_run = total_run + loop_run;\n             // Longest we ever run for is 3s.\n-            if total_run.num_seconds() > 3 {\n+            if total_run > Duration::from_secs(3) {\n                 return summ5;\n             }\n \n@@ -1166,7 +1168,7 @@ pub mod bench {\n     pub fn benchmark<F>(f: F) -> BenchSamples where F: FnMut(&mut Bencher) {\n         let mut bs = Bencher {\n             iterations: 0,\n-            dur: Duration::nanoseconds(0),\n+            dur: Duration::new(0, 0),\n             bytes: 0\n         };\n \n@@ -1185,7 +1187,7 @@ pub mod bench {\n     pub fn run_once<F>(f: F) where F: FnOnce(&mut Bencher) {\n         let mut bs = Bencher {\n             iterations: 0,\n-            dur: Duration::nanoseconds(0),\n+            dur: Duration::new(0, 0),\n             bytes: 0\n         };\n         bs.bench_n(1, f);"}, {"sha": "af61b0aa0cdf41dc211788df85bbe12ca5a76344", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd4dad8c860363077a3d53af025a0c029a613320/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4dad8c860363077a3d53af025a0c029a613320/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=dd4dad8c860363077a3d53af025a0c029a613320", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(std_misc, rand)]\n+#![feature(std_misc, rand, duration, duration_span)]\n \n use std::collections::{BTreeMap, HashMap, HashSet};\n use std::env;"}, {"sha": "eebf6feaffac33d0a4e120a26f48587a219d5e69", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dd4dad8c860363077a3d53af025a0c029a613320/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4dad8c860363077a3d53af025a0c029a613320/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=dd4dad8c860363077a3d53af025a0c029a613320", "patch": "@@ -10,7 +10,7 @@\n \n // ignore-pretty very bad with line comments\n \n-#![feature(unboxed_closures, rand, std_misc, collections)]\n+#![feature(unboxed_closures, rand, std_misc, collections, duration, duration_span)]\n \n extern crate collections;\n extern crate rand;\n@@ -167,13 +167,13 @@ fn write_results(label: &str, results: &Results) {\n \n fn empty_results() -> Results {\n     Results {\n-        sequential_ints: Duration::seconds(0),\n-        random_ints: Duration::seconds(0),\n-        delete_ints: Duration::seconds(0),\n+        sequential_ints: Duration::new(0, 0),\n+        random_ints: Duration::new(0, 0),\n+        delete_ints: Duration::new(0, 0),\n \n-        sequential_strings: Duration::seconds(0),\n-        random_strings: Duration::seconds(0),\n-        delete_strings: Duration::seconds(0),\n+        sequential_strings: Duration::new(0, 0),\n+        random_strings: Duration::new(0, 0),\n+        delete_strings: Duration::new(0, 0),\n     }\n }\n "}, {"sha": "6e85abb8e149fa64033690be0eb8b282594b9108", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd4dad8c860363077a3d53af025a0c029a613320/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4dad8c860363077a3d53af025a0c029a613320/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=dd4dad8c860363077a3d53af025a0c029a613320", "patch": "@@ -10,7 +10,7 @@\n \n // Microbenchmarks for various functions in std and extra\n \n-#![feature(rand, collections, std_misc)]\n+#![feature(rand, collections, std_misc, duration, duration_span)]\n \n use std::iter::repeat;\n use std::mem::swap;\n@@ -52,7 +52,7 @@ fn maybe_run_test<F>(argv: &[String], name: String, test: F) where F: FnOnce() {\n \n     let dur = Duration::span(test);\n \n-    println!(\"{}:\\t\\t{} ms\", name, dur.num_milliseconds());\n+    println!(\"{}:\\t\\t{}\", name, dur);\n }\n \n fn shift_push() {"}, {"sha": "2b7e204423e32226498cc5ad3329266257d31345", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dd4dad8c860363077a3d53af025a0c029a613320/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4dad8c860363077a3d53af025a0c029a613320/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=dd4dad8c860363077a3d53af025a0c029a613320", "patch": "@@ -18,7 +18,7 @@\n // different scalability characteristics compared to the select\n // version.\n \n-#![feature(std_misc)]\n+#![feature(duration, duration_span)]\n \n use std::sync::mpsc::{channel, Sender, Receiver};\n use std::env;\n@@ -88,9 +88,9 @@ fn run(args: &[String]) {\n     });\n     let result = result.unwrap();\n     print!(\"Count is {}\\n\", result);\n-    print!(\"Test took {} ms\\n\", dur.num_milliseconds());\n-    let thruput = ((size / workers * workers) as f64) / (dur.num_milliseconds() as f64);\n-    print!(\"Throughput={} per sec\\n\", thruput / 1000.0);\n+    print!(\"Test took {}\\n\", dur);\n+    let thruput = ((size / workers * workers) as f64) / (dur.secs() as f64);\n+    print!(\"Throughput={} per sec\\n\", thruput);\n     assert_eq!(result, num_bytes * size);\n }\n "}, {"sha": "5a541420d2abf528f19de88e1ed7ae1a73b125bc", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dd4dad8c860363077a3d53af025a0c029a613320/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4dad8c860363077a3d53af025a0c029a613320/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=dd4dad8c860363077a3d53af025a0c029a613320", "patch": "@@ -14,7 +14,7 @@\n //\n // I *think* it's the same, more or less.\n \n-#![feature(std_misc)]\n+#![feature(duration, duration_span)]\n \n use std::sync::mpsc::{channel, Sender, Receiver};\n use std::env;\n@@ -95,9 +95,9 @@ fn run(args: &[String]) {\n     });\n     let result = result.unwrap();\n     print!(\"Count is {}\\n\", result);\n-    print!(\"Test took {} ms\\n\", dur.num_milliseconds());\n-    let thruput = ((size / workers * workers) as f64) / (dur.num_milliseconds() as f64);\n-    print!(\"Throughput={} per sec\\n\", thruput / 1000.0);\n+    print!(\"Test took {}\\n\", dur);\n+    let thruput = ((size / workers * workers) as f64) / (dur.secs() as f64);\n+    print!(\"Throughput={} per sec\\n\", thruput);\n     assert_eq!(result, num_bytes * size);\n }\n "}, {"sha": "93e3394097bc57695a002cf2a9affb1256a2b344", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dd4dad8c860363077a3d53af025a0c029a613320/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4dad8c860363077a3d53af025a0c029a613320/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=dd4dad8c860363077a3d53af025a0c029a613320", "patch": "@@ -17,7 +17,7 @@\n \n // no-pretty-expanded FIXME #15189\n \n-#![feature(std_misc)]\n+#![feature(duration, duration_span, std_misc)]\n \n use std::env;\n use std::sync::{Arc, Future, Mutex, Condvar};\n@@ -107,9 +107,9 @@ fn main() {\n \n     // all done, report stats.\n     let num_msgs = num_tasks * msg_per_task;\n-    let rate = (num_msgs as f64) / (dur.num_milliseconds() as f64);\n+    let rate = (num_msgs as f64) / (dur.secs() as f64);\n \n-    println!(\"Sent {} messages in {} ms\", num_msgs, dur.num_milliseconds());\n-    println!(\"  {} messages / second\", rate / 1000.0);\n-    println!(\"  {} \u03bcs / message\", 1000000. / rate / 1000.0);\n+    println!(\"Sent {} messages in {}\", num_msgs, dur);\n+    println!(\"  {} messages / second\", rate);\n+    println!(\"  {} \u03bcs / message\", 1000000. / rate);\n }"}, {"sha": "2d5aae30ae8a95292b297338e9a3b2ebe9f8816e", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd4dad8c860363077a3d53af025a0c029a613320/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4dad8c860363077a3d53af025a0c029a613320/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=dd4dad8c860363077a3d53af025a0c029a613320", "patch": "@@ -18,7 +18,7 @@\n \n */\n \n-#![feature(std_misc, rustc_private)]\n+#![feature(duration, duration_span, rustc_private)]\n \n extern crate getopts;\n "}, {"sha": "d7e556a124fe1ff635b6cfa9c110469adf7ed0cb", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dd4dad8c860363077a3d53af025a0c029a613320/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4dad8c860363077a3d53af025a0c029a613320/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=dd4dad8c860363077a3d53af025a0c029a613320", "patch": "@@ -10,7 +10,7 @@\n \n // Microbenchmark for the smallintmap library\n \n-#![feature(collections, std_misc)]\n+#![feature(collections, duration, duration_span)]\n \n use std::collections::VecMap;\n use std::env;\n@@ -40,8 +40,8 @@ fn main() {\n     let max = args[1].parse::<usize>().unwrap();\n     let rep = args[2].parse::<usize>().unwrap();\n \n-    let mut checkf = Duration::seconds(0);\n-    let mut appendf = Duration::seconds(0);\n+    let mut checkf = Duration::new(0, 0);\n+    let mut appendf = Duration::new(0, 0);\n \n     for _ in 0..rep {\n         let mut map = VecMap::new();\n@@ -55,7 +55,7 @@ fn main() {\n     let maxf = max as f64;\n \n     println!(\"insert(): {} seconds\\n\", checkf);\n-    println!(\"        : {} op/ms\\n\", maxf / checkf.num_milliseconds() as f64);\n+    println!(\"        : {} op/s\\n\", maxf / checkf.secs() as f64);\n     println!(\"get()   : {} seconds\\n\", appendf);\n-    println!(\"        : {} op/ms\\n\", maxf / appendf.num_milliseconds() as f64);\n+    println!(\"        : {} op/s\\n\", maxf / appendf.secs() as f64);\n }"}, {"sha": "babae4d149f52d45e88c1c72cc71c48302f2f9c0", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd4dad8c860363077a3d53af025a0c029a613320/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4dad8c860363077a3d53af025a0c029a613320/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=dd4dad8c860363077a3d53af025a0c029a613320", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(box_syntax, std_misc, collections)]\n+#![feature(box_syntax, duration, duration_span, collections)]\n \n use std::env;\n use std::thread;"}, {"sha": "83ce0db365f8bb8afb5d212ae5c032b732954099", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd4dad8c860363077a3d53af025a0c029a613320/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4dad8c860363077a3d53af025a0c029a613320/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=dd4dad8c860363077a3d53af025a0c029a613320", "patch": "@@ -16,7 +16,7 @@\n // instead of in std.\n \n #![reexport_test_harness_main = \"test_main\"]\n-#![feature(libc, std_misc)]\n+#![feature(libc, std_misc, duration)]\n \n extern crate libc;\n "}, {"sha": "36314c5e14ac2d082a60094c5f04dfceb83bd4fb", "filename": "src/test/run-pass/std-sync-right-kind-impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd4dad8c860363077a3d53af025a0c029a613320/src%2Ftest%2Frun-pass%2Fstd-sync-right-kind-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd4dad8c860363077a3d53af025a0c029a613320/src%2Ftest%2Frun-pass%2Fstd-sync-right-kind-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstd-sync-right-kind-impls.rs?ref=dd4dad8c860363077a3d53af025a0c029a613320", "patch": "@@ -10,7 +10,7 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(std_misc, alloc)]\n+#![feature(std_misc, alloc, static_condvar)]\n \n use std::sync;\n "}]}