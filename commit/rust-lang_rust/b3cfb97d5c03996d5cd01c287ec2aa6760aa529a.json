{"sha": "b3cfb97d5c03996d5cd01c287ec2aa6760aa529a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzY2ZiOTdkNWMwMzk5NmQ1Y2QwMWMyODdlYzJhYTY3NjBhYTUyOWE=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-02-10T00:54:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-10T00:54:17Z"}, "message": "Rollup merge of #68966 - jonas-schievink:coherence-perf, r=varkor\n\nImprove performance of coherence checks\n\nThe biggest perf improvement in here is expected to come from the removal of the remaining #43355 warning code since that effectively runs the expensive parts of coherence *twice*, which can even be visualized by obtaining a flamegraph:\n\n![image](https://user-images.githubusercontent.com/5047365/74091959-e1f41200-4a8b-11ea-969d-2849d3f86c63.png)", "tree": {"sha": "b0880dd292ac2e125d0073164e469c95ae3c5857", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0880dd292ac2e125d0073164e469c95ae3c5857"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3cfb97d5c03996d5cd01c287ec2aa6760aa529a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3cfb97d5c03996d5cd01c287ec2aa6760aa529a", "html_url": "https://github.com/rust-lang/rust/commit/b3cfb97d5c03996d5cd01c287ec2aa6760aa529a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3cfb97d5c03996d5cd01c287ec2aa6760aa529a/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8007f8468b942e689a8db771c4e76c67cdd40c3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8007f8468b942e689a8db771c4e76c67cdd40c3b", "html_url": "https://github.com/rust-lang/rust/commit/8007f8468b942e689a8db771c4e76c67cdd40c3b"}, {"sha": "23095928a7e51e84f2e58a28ea0b76db6599d9d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/23095928a7e51e84f2e58a28ea0b76db6599d9d7", "html_url": "https://github.com/rust-lang/rust/commit/23095928a7e51e84f2e58a28ea0b76db6599d9d7"}], "stats": {"total": 217, "additions": 81, "deletions": 136}, "files": [{"sha": "425f14a5740d413babaac7131c858c04ee1ab183", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3cfb97d5c03996d5cd01c287ec2aa6760aa529a/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3cfb97d5c03996d5cd01c287ec2aa6760aa529a/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=b3cfb97d5c03996d5cd01c287ec2aa6760aa529a", "patch": "@@ -647,7 +647,8 @@ rustc_queries! {\n         query trait_impls_of(key: DefId) -> &'tcx ty::trait_def::TraitImpls {\n             desc { |tcx| \"trait impls of `{}`\", tcx.def_path_str(key) }\n         }\n-        query specialization_graph_of(_: DefId) -> &'tcx specialization_graph::Graph {\n+        query specialization_graph_of(key: DefId) -> &'tcx specialization_graph::Graph {\n+            desc { |tcx| \"building specialization graph of trait `{}`\", tcx.def_path_str(key) }\n             cache_on_disk_if { true }\n         }\n         query is_object_safe(key: DefId) -> bool {"}, {"sha": "2a667b535508be2600d9fe36e90333994d506bc0", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b3cfb97d5c03996d5cd01c287ec2aa6760aa529a/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3cfb97d5c03996d5cd01c287ec2aa6760aa529a/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=b3cfb97d5c03996d5cd01c287ec2aa6760aa529a", "patch": "@@ -6,7 +6,6 @@\n \n use crate::infer::{CombinedSnapshot, InferOk};\n use crate::traits::select::IntercrateAmbiguityCause;\n-use crate::traits::IntercrateMode;\n use crate::traits::SkipLeakCheck;\n use crate::traits::{self, Normalized, Obligation, ObligationCause, SelectionContext};\n use crate::ty::fold::TypeFoldable;\n@@ -27,7 +26,7 @@ enum InCrate {\n #[derive(Debug, Copy, Clone)]\n pub enum Conflict {\n     Upstream,\n-    Downstream { used_to_be_broken: bool },\n+    Downstream,\n }\n \n pub struct OverlapResult<'tcx> {\n@@ -53,7 +52,6 @@ pub fn overlapping_impls<F1, F2, R>(\n     tcx: TyCtxt<'_>,\n     impl1_def_id: DefId,\n     impl2_def_id: DefId,\n-    intercrate_mode: IntercrateMode,\n     skip_leak_check: SkipLeakCheck,\n     on_overlap: F1,\n     no_overlap: F2,\n@@ -65,13 +63,12 @@ where\n     debug!(\n         \"overlapping_impls(\\\n            impl1_def_id={:?}, \\\n-           impl2_def_id={:?},\n-           intercrate_mode={:?})\",\n-        impl1_def_id, impl2_def_id, intercrate_mode\n+           impl2_def_id={:?})\",\n+        impl1_def_id, impl2_def_id,\n     );\n \n     let overlaps = tcx.infer_ctxt().enter(|infcx| {\n-        let selcx = &mut SelectionContext::intercrate(&infcx, intercrate_mode);\n+        let selcx = &mut SelectionContext::intercrate(&infcx);\n         overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id).is_some()\n     });\n \n@@ -83,7 +80,7 @@ where\n     // this time tracking intercrate ambuiguity causes for better\n     // diagnostics. (These take time and can lead to false errors.)\n     tcx.infer_ctxt().enter(|infcx| {\n-        let selcx = &mut SelectionContext::intercrate(&infcx, intercrate_mode);\n+        let selcx = &mut SelectionContext::intercrate(&infcx);\n         selcx.enable_tracking_intercrate_ambiguity_causes();\n         on_overlap(overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id).unwrap())\n     })\n@@ -202,15 +199,7 @@ pub fn trait_ref_is_knowable<'tcx>(\n     if orphan_check_trait_ref(tcx, trait_ref, InCrate::Remote).is_ok() {\n         // A downstream or cousin crate is allowed to implement some\n         // substitution of this trait-ref.\n-\n-        // A trait can be implementable for a trait ref by both the current\n-        // crate and crates downstream of it. Older versions of rustc\n-        // were not aware of this, causing incoherence (issue #43355).\n-        let used_to_be_broken = orphan_check_trait_ref(tcx, trait_ref, InCrate::Local).is_ok();\n-        if used_to_be_broken {\n-            debug!(\"trait_ref_is_knowable({:?}) - USED TO BE BROKEN\", trait_ref);\n-        }\n-        return Some(Conflict::Downstream { used_to_be_broken });\n+        return Some(Conflict::Downstream);\n     }\n \n     if trait_ref_is_local_or_fundamental(tcx, trait_ref) {"}, {"sha": "417b52c38a74d3fc23e3b74fa0ed1dee31060738", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b3cfb97d5c03996d5cd01c287ec2aa6760aa529a/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3cfb97d5c03996d5cd01c287ec2aa6760aa529a/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=b3cfb97d5c03996d5cd01c287ec2aa6760aa529a", "patch": "@@ -78,13 +78,6 @@ pub use self::chalk_fulfill::{\n \n pub use self::types::*;\n \n-/// Whether to enable bug compatibility with issue #43355.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum IntercrateMode {\n-    Issue43355,\n-    Fixed,\n-}\n-\n /// Whether to skip the leak check, as part of a future compatibility warning step.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum SkipLeakCheck {"}, {"sha": "cfeb392f87f46848bae59021631c142757f717c7", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 15, "deletions": 29, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b3cfb97d5c03996d5cd01c287ec2aa6760aa529a/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3cfb97d5c03996d5cd01c287ec2aa6760aa529a/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=b3cfb97d5c03996d5cd01c287ec2aa6760aa529a", "patch": "@@ -19,8 +19,8 @@ use super::DerivedObligationCause;\n use super::Selection;\n use super::SelectionResult;\n use super::TraitNotObjectSafe;\n+use super::TraitQueryMode;\n use super::{BuiltinDerivedObligation, ImplDerivedObligation, ObligationCauseCode};\n-use super::{IntercrateMode, TraitQueryMode};\n use super::{ObjectCastObligation, Obligation};\n use super::{ObligationCause, PredicateObligation, TraitObligation};\n use super::{OutputTypeParameterMismatch, Overflow, SelectionError, Unimplemented};\n@@ -80,7 +80,7 @@ pub struct SelectionContext<'cx, 'tcx> {\n     /// other words, we consider `$0: Bar` to be unimplemented if\n     /// there is no type that the user could *actually name* that\n     /// would satisfy it. This avoids crippling inference, basically.\n-    intercrate: Option<IntercrateMode>,\n+    intercrate: bool,\n \n     intercrate_ambiguity_causes: Option<Vec<IntercrateAmbiguityCause>>,\n \n@@ -218,22 +218,18 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx,\n             freshener: infcx.freshener(),\n-            intercrate: None,\n+            intercrate: false,\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls: false,\n             query_mode: TraitQueryMode::Standard,\n         }\n     }\n \n-    pub fn intercrate(\n-        infcx: &'cx InferCtxt<'cx, 'tcx>,\n-        mode: IntercrateMode,\n-    ) -> SelectionContext<'cx, 'tcx> {\n-        debug!(\"intercrate({:?})\", mode);\n+    pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'tcx>) -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx,\n             freshener: infcx.freshener(),\n-            intercrate: Some(mode),\n+            intercrate: true,\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls: false,\n             query_mode: TraitQueryMode::Standard,\n@@ -248,7 +244,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx,\n             freshener: infcx.freshener(),\n-            intercrate: None,\n+            intercrate: false,\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls,\n             query_mode: TraitQueryMode::Standard,\n@@ -263,7 +259,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx,\n             freshener: infcx.freshener(),\n-            intercrate: None,\n+            intercrate: false,\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls: false,\n             query_mode,\n@@ -276,7 +272,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// false overflow results (#47139) and because it costs\n     /// computation time.\n     pub fn enable_tracking_intercrate_ambiguity_causes(&mut self) {\n-        assert!(self.intercrate.is_some());\n+        assert!(self.intercrate);\n         assert!(self.intercrate_ambiguity_causes.is_none());\n         self.intercrate_ambiguity_causes = Some(vec![]);\n         debug!(\"selcx: enable_tracking_intercrate_ambiguity_causes\");\n@@ -286,7 +282,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// was enabled and disables tracking at the same time. If\n     /// tracking is not enabled, just returns an empty vector.\n     pub fn take_intercrate_ambiguity_causes(&mut self) -> Vec<IntercrateAmbiguityCause> {\n-        assert!(self.intercrate.is_some());\n+        assert!(self.intercrate);\n         self.intercrate_ambiguity_causes.take().unwrap_or(vec![])\n     }\n \n@@ -562,7 +558,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> Result<EvaluationResult, OverflowError> {\n         debug!(\"evaluate_trait_predicate_recursively({:?})\", obligation);\n \n-        if self.intercrate.is_none()\n+        if !self.intercrate\n             && obligation.is_global()\n             && obligation.param_env.caller_bounds.iter().all(|bound| bound.needs_subst())\n         {\n@@ -727,7 +723,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             stack.fresh_trait_ref.skip_binder().input_types().any(|ty| ty.is_fresh());\n         // This check was an imperfect workaround for a bug in the old\n         // intercrate mode; it should be removed when that goes away.\n-        if unbound_input_types && self.intercrate == Some(IntercrateMode::Issue43355) {\n+        if unbound_input_types && self.intercrate {\n             debug!(\n                 \"evaluate_stack({:?}) --> unbound argument, intercrate -->  ambiguous\",\n                 stack.fresh_trait_ref\n@@ -1206,7 +1202,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn is_knowable<'o>(&mut self, stack: &TraitObligationStack<'o, 'tcx>) -> Option<Conflict> {\n         debug!(\"is_knowable(intercrate={:?})\", self.intercrate);\n \n-        if !self.intercrate.is_some() {\n+        if !self.intercrate {\n             return None;\n         }\n \n@@ -1218,17 +1214,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // bound regions.\n         let trait_ref = predicate.skip_binder().trait_ref;\n \n-        let result = coherence::trait_ref_is_knowable(self.tcx(), trait_ref);\n-        if let (\n-            Some(Conflict::Downstream { used_to_be_broken: true }),\n-            Some(IntercrateMode::Issue43355),\n-        ) = (result, self.intercrate)\n-        {\n-            debug!(\"is_knowable: IGNORING conflict to be bug-compatible with #43355\");\n-            None\n-        } else {\n-            result\n-        }\n+        coherence::trait_ref_is_knowable(self.tcx(), trait_ref)\n     }\n \n     /// Returns `true` if the global caches can be used.\n@@ -1249,7 +1235,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // the master cache. Since coherence executes pretty quickly,\n         // it's not worth going to more trouble to increase the\n         // hit-rate, I don't think.\n-        if self.intercrate.is_some() {\n+        if self.intercrate {\n             return false;\n         }\n \n@@ -3305,7 +3291,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Err(());\n         }\n \n-        if self.intercrate.is_none()\n+        if !self.intercrate\n             && self.tcx().impl_polarity(impl_def_id) == ty::ImplPolarity::Reservation\n         {\n             debug!(\"match_impl: reservation impls only apply in intercrate mode\");"}, {"sha": "071b5277dd95db8c560d8b093d3c675c44a140d3", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b3cfb97d5c03996d5cd01c287ec2aa6760aa529a/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3cfb97d5c03996d5cd01c287ec2aa6760aa529a/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=b3cfb97d5c03996d5cd01c287ec2aa6760aa529a", "patch": "@@ -332,14 +332,9 @@ pub(super) fn specialization_graph_provider(\n                 let impl_span =\n                     tcx.sess.source_map().def_span(tcx.span_of_impl(impl_def_id).unwrap());\n                 let mut err = match used_to_be_allowed {\n-                    Some(FutureCompatOverlapErrorKind::Issue43355) | None => {\n-                        struct_span_err!(tcx.sess, impl_span, E0119, \"{}\", msg)\n-                    }\n+                    None => struct_span_err!(tcx.sess, impl_span, E0119, \"{}\", msg),\n                     Some(kind) => {\n                         let lint = match kind {\n-                            FutureCompatOverlapErrorKind::Issue43355 => {\n-                                unreachable!(\"converted to hard error above\")\n-                            }\n                             FutureCompatOverlapErrorKind::Issue33140 => {\n                                 ORDER_DEPENDENT_TRAIT_OBJECTS\n                             }"}, {"sha": "ca7740199ec7dff635bbc79b303aac5b02e6a444", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 6, "deletions": 24, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b3cfb97d5c03996d5cd01c287ec2aa6760aa529a/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3cfb97d5c03996d5cd01c287ec2aa6760aa529a/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=b3cfb97d5c03996d5cd01c287ec2aa6760aa529a", "patch": "@@ -9,7 +9,6 @@ pub use rustc::traits::types::specialization_graph::*;\n \n #[derive(Copy, Clone, Debug)]\n pub enum FutureCompatOverlapErrorKind {\n-    Issue43355,\n     Issue33140,\n     LeakCheck,\n }\n@@ -107,16 +106,16 @@ impl<'tcx> Children {\n                 }\n             };\n \n+            let allowed_to_overlap =\n+                tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling);\n+\n             let (le, ge) = traits::overlapping_impls(\n                 tcx,\n                 possible_sibling,\n                 impl_def_id,\n-                traits::IntercrateMode::Issue43355,\n                 traits::SkipLeakCheck::default(),\n                 |overlap| {\n-                    if let Some(overlap_kind) =\n-                        tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling)\n-                    {\n+                    if let Some(overlap_kind) = &allowed_to_overlap {\n                         match overlap_kind {\n                             ty::ImplOverlapKind::Permitted { marker: _ } => {}\n                             ty::ImplOverlapKind::Issue33140 => {\n@@ -154,31 +153,14 @@ impl<'tcx> Children {\n \n                 replace_children.push(possible_sibling);\n             } else {\n-                if let None = tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling) {\n-                    // do future-compat checks for overlap. Have issue #33140\n-                    // errors overwrite issue #43355 errors when both are present.\n-\n-                    traits::overlapping_impls(\n-                        tcx,\n-                        possible_sibling,\n-                        impl_def_id,\n-                        traits::IntercrateMode::Fixed,\n-                        traits::SkipLeakCheck::default(),\n-                        |overlap| {\n-                            last_lint = Some(FutureCompatOverlapError {\n-                                error: overlap_error(overlap),\n-                                kind: FutureCompatOverlapErrorKind::Issue43355,\n-                            });\n-                        },\n-                        || (),\n-                    );\n+                if let None = allowed_to_overlap {\n+                    // Do future-compat checks for overlap.\n \n                     if last_lint.is_none() {\n                         traits::overlapping_impls(\n                             tcx,\n                             possible_sibling,\n                             impl_def_id,\n-                            traits::IntercrateMode::Fixed,\n                             traits::SkipLeakCheck::Yes,\n                             |overlap| {\n                                 last_lint = Some(FutureCompatOverlapError {"}, {"sha": "1970b1e5c5deb06f8ab7c84ad7a0ac6f15eb9e4e", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b3cfb97d5c03996d5cd01c287ec2aa6760aa529a/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3cfb97d5c03996d5cd01c287ec2aa6760aa529a/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=b3cfb97d5c03996d5cd01c287ec2aa6760aa529a", "patch": "@@ -18,14 +18,12 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::ItemKind;\n \n pub fn check_trait(tcx: TyCtxt<'_>, trait_def_id: DefId) {\n+    let lang_items = tcx.lang_items();\n     Checker { tcx, trait_def_id }\n-        .check(tcx.lang_items().drop_trait(), visit_implementation_of_drop)\n-        .check(tcx.lang_items().copy_trait(), visit_implementation_of_copy)\n-        .check(tcx.lang_items().coerce_unsized_trait(), visit_implementation_of_coerce_unsized)\n-        .check(\n-            tcx.lang_items().dispatch_from_dyn_trait(),\n-            visit_implementation_of_dispatch_from_dyn,\n-        );\n+        .check(lang_items.drop_trait(), visit_implementation_of_drop)\n+        .check(lang_items.copy_trait(), visit_implementation_of_copy)\n+        .check(lang_items.coerce_unsized_trait(), visit_implementation_of_coerce_unsized)\n+        .check(lang_items.dispatch_from_dyn_trait(), visit_implementation_of_dispatch_from_dyn);\n }\n \n struct Checker<'tcx> {"}, {"sha": "ffea849c4f20942ffc0be97f8715f21af6314369", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3cfb97d5c03996d5cd01c287ec2aa6760aa529a/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3cfb97d5c03996d5cd01c287ec2aa6760aa529a/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=b3cfb97d5c03996d5cd01c287ec2aa6760aa529a", "patch": "@@ -1,5 +1,5 @@\n use crate::namespace::Namespace;\n-use rustc::traits::{self, IntercrateMode, SkipLeakCheck};\n+use rustc::traits::{self, SkipLeakCheck};\n use rustc::ty::{AssocItem, TyCtxt};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n@@ -93,7 +93,6 @@ impl InherentOverlapChecker<'tcx> {\n             self.tcx,\n             impl1_def_id,\n             impl2_def_id,\n-            IntercrateMode::Issue43355,\n             // We go ahead and just skip the leak check for\n             // inherent impls without warning.\n             SkipLeakCheck::Yes,"}, {"sha": "1526182576c315450f26896c9125b121c09a9436", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 43, "deletions": 41, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/b3cfb97d5c03996d5cd01c287ec2aa6760aa529a/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3cfb97d5c03996d5cd01c287ec2aa6760aa529a/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=b3cfb97d5c03996d5cd01c287ec2aa6760aa529a", "patch": "@@ -10,45 +10,43 @@ use rustc::ty::query::Providers;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n use rustc_errors::struct_span_err;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_hir::HirId;\n+use rustc_span::Span;\n \n mod builtin;\n mod inherent_impls;\n mod inherent_impls_overlap;\n mod orphan;\n mod unsafety;\n \n-fn check_impl(tcx: TyCtxt<'_>, hir_id: HirId) {\n-    let impl_def_id = tcx.hir().local_def_id(hir_id);\n-\n-    // If there are no traits, then this implementation must have a\n-    // base type.\n-\n-    if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n-        debug!(\n-            \"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n-            trait_ref,\n-            tcx.def_path_str(impl_def_id)\n-        );\n+/// Obtains the span of just the impl header of `impl_def_id`.\n+fn impl_header_span(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Span {\n+    tcx.sess.source_map().def_span(tcx.span_of_impl(impl_def_id).unwrap())\n+}\n \n-        // Skip impls where one of the self type is an error type.\n-        // This occurs with e.g., resolve failures (#30589).\n-        if trait_ref.references_error() {\n-            return;\n-        }\n+fn check_impl(tcx: TyCtxt<'_>, impl_def_id: DefId, trait_ref: ty::TraitRef<'_>) {\n+    debug!(\n+        \"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n+        trait_ref,\n+        tcx.def_path_str(impl_def_id)\n+    );\n \n-        enforce_trait_manually_implementable(tcx, impl_def_id, trait_ref.def_id);\n-        enforce_empty_impls_for_marker_traits(tcx, impl_def_id, trait_ref.def_id);\n+    // Skip impls where one of the self type is an error type.\n+    // This occurs with e.g., resolve failures (#30589).\n+    if trait_ref.references_error() {\n+        return;\n     }\n+\n+    enforce_trait_manually_implementable(tcx, impl_def_id, trait_ref.def_id);\n+    enforce_empty_impls_for_marker_traits(tcx, impl_def_id, trait_ref.def_id);\n }\n \n fn enforce_trait_manually_implementable(tcx: TyCtxt<'_>, impl_def_id: DefId, trait_def_id: DefId) {\n     let did = Some(trait_def_id);\n     let li = tcx.lang_items();\n-    let span = tcx.sess.source_map().def_span(tcx.span_of_impl(impl_def_id).unwrap());\n \n     // Disallow *all* explicit impls of `Sized` and `Unsize` for now.\n     if did == li.sized_trait() {\n+        let span = impl_header_span(tcx, impl_def_id);\n         struct_span_err!(\n             tcx.sess,\n             span,\n@@ -61,6 +59,7 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt<'_>, impl_def_id: DefId, tra\n     }\n \n     if did == li.unsize_trait() {\n+        let span = impl_header_span(tcx, impl_def_id);\n         struct_span_err!(\n             tcx.sess,\n             span,\n@@ -86,6 +85,8 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt<'_>, impl_def_id: DefId, tra\n     } else {\n         return; // everything OK\n     };\n+\n+    let span = impl_header_span(tcx, impl_def_id);\n     struct_span_err!(\n         tcx.sess,\n         span,\n@@ -109,7 +110,7 @@ fn enforce_empty_impls_for_marker_traits(tcx: TyCtxt<'_>, impl_def_id: DefId, tr\n         return;\n     }\n \n-    let span = tcx.sess.source_map().def_span(tcx.span_of_impl(impl_def_id).unwrap());\n+    let span = impl_header_span(tcx, impl_def_id);\n     struct_span_err!(tcx.sess, span, E0715, \"impls for marker traits cannot contain items\").emit();\n }\n \n@@ -129,12 +130,17 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n fn coherent_trait(tcx: TyCtxt<'_>, def_id: DefId) {\n+    // Trigger building the specialization graph for the trait. This will detect and report any\n+    // overlap errors.\n+    tcx.specialization_graph_of(def_id);\n+\n     let impls = tcx.hir().trait_impls(def_id);\n-    for &impl_id in impls {\n-        check_impl(tcx, impl_id);\n-    }\n-    for &impl_id in impls {\n-        check_impl_overlap(tcx, impl_id);\n+    for &hir_id in impls {\n+        let impl_def_id = tcx.hir().local_def_id(hir_id);\n+        let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+\n+        check_impl(tcx, impl_def_id, trait_ref);\n+        check_object_overlap(tcx, impl_def_id, trait_ref);\n     }\n     builtin::check_trait(tcx, def_id);\n }\n@@ -152,24 +158,20 @@ pub fn check_coherence(tcx: TyCtxt<'_>) {\n     tcx.ensure().crate_inherent_impls_overlap_check(LOCAL_CRATE);\n }\n \n-/// Overlap: no two impls for the same trait are implemented for the\n-/// same type. Likewise, no two inherent impls for a given type\n-/// constructor provide a method with the same name.\n-fn check_impl_overlap<'tcx>(tcx: TyCtxt<'tcx>, hir_id: HirId) {\n-    let impl_def_id = tcx.hir().local_def_id(hir_id);\n-    let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+/// Checks whether an impl overlaps with the automatic `impl Trait for dyn Trait`.\n+fn check_object_overlap<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    impl_def_id: DefId,\n+    trait_ref: ty::TraitRef<'tcx>,\n+) {\n     let trait_def_id = trait_ref.def_id;\n \n     if trait_ref.references_error() {\n         debug!(\"coherence: skipping impl {:?} with error {:?}\", impl_def_id, trait_ref);\n         return;\n     }\n \n-    // Trigger building the specialization graph for the trait of this impl.\n-    // This will detect any overlap errors.\n-    tcx.specialization_graph_of(trait_def_id);\n-\n-    // check for overlap with the automatic `impl Trait for Trait`\n+    // check for overlap with the automatic `impl Trait for dyn Trait`\n     if let ty::Dynamic(ref data, ..) = trait_ref.self_ty().kind {\n         // This is something like impl Trait1 for Trait2. Illegal\n         // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe.\n@@ -194,17 +196,17 @@ fn check_impl_overlap<'tcx>(tcx: TyCtxt<'tcx>, hir_id: HirId) {\n             } else {\n                 let mut supertrait_def_ids = traits::supertrait_def_ids(tcx, component_def_id);\n                 if supertrait_def_ids.any(|d| d == trait_def_id) {\n-                    let sp = tcx.sess.source_map().def_span(tcx.span_of_impl(impl_def_id).unwrap());\n+                    let span = impl_header_span(tcx, impl_def_id);\n                     struct_span_err!(\n                         tcx.sess,\n-                        sp,\n+                        span,\n                         E0371,\n                         \"the object type `{}` automatically implements the trait `{}`\",\n                         trait_ref.self_ty(),\n                         tcx.def_path_str(trait_def_id)\n                     )\n                     .span_label(\n-                        sp,\n+                        span,\n                         format!(\n                             \"`{}` automatically implements trait `{}`\",\n                             trait_ref.self_ty(),"}, {"sha": "71f997c54c6f23441951140f51a9105c1db566fb", "filename": "src/test/ui/coherence/coherence-inherited-assoc-ty-cycle-err.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3cfb97d5c03996d5cd01c287ec2aa6760aa529a/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-inherited-assoc-ty-cycle-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b3cfb97d5c03996d5cd01c287ec2aa6760aa529a/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-inherited-assoc-ty-cycle-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-inherited-assoc-ty-cycle-err.stderr?ref=b3cfb97d5c03996d5cd01c287ec2aa6760aa529a", "patch": "@@ -1,10 +1,10 @@\n-error[E0391]: cycle detected when processing `Trait`\n+error[E0391]: cycle detected when building specialization graph of trait `Trait`\n   --> $DIR/coherence-inherited-assoc-ty-cycle-err.rs:8:1\n    |\n LL | trait Trait<T> { type Assoc; }\n    | ^^^^^^^^^^^^^^\n    |\n-   = note: ...which again requires processing `Trait`, completing the cycle\n+   = note: ...which again requires building specialization graph of trait `Trait`, completing the cycle\n note: cycle used when coherence checking all impls of trait `Trait`\n   --> $DIR/coherence-inherited-assoc-ty-cycle-err.rs:8:1\n    |"}]}