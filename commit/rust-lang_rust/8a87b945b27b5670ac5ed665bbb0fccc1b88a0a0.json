{"sha": "8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhODdiOTQ1YjI3YjU2NzBhYzVlZDY2NWJiYjBmY2NjMWI4OGEwYTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-14T15:29:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-14T15:29:43Z"}, "message": "Auto merge of #67711 - Amanieu:fix_unwind_leak, r=alexcrichton\n\nFix memory leak if C++ catches a Rust panic and discards it\n\nIf C++ catches a Rust panic using `catch (...)` and then chooses not to rethrow it, the `Box<dyn Any>` in the exception may be leaked. This PR fixes this by adding the necessary destructors to the exception object.\n\nr? @Mark-Simulacrum", "tree": {"sha": "54b1965761803218ab8de9e66368698ec4a1b49d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54b1965761803218ab8de9e66368698ec4a1b49d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0", "html_url": "https://github.com/rust-lang/rust/commit/8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb6122db3fa22031c48ca6b332fc856b8d098027", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb6122db3fa22031c48ca6b332fc856b8d098027", "html_url": "https://github.com/rust-lang/rust/commit/cb6122db3fa22031c48ca6b332fc856b8d098027"}, {"sha": "25519e5290b4e04ab7a6cb07bcda01a542a0b1f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/25519e5290b4e04ab7a6cb07bcda01a542a0b1f3", "html_url": "https://github.com/rust-lang/rust/commit/25519e5290b4e04ab7a6cb07bcda01a542a0b1f3"}], "stats": {"total": 165, "additions": 139, "deletions": 26}, "files": [{"sha": "9161d49959cf5cc1577264dcdb1502cde151115a", "filename": "src/libpanic_unwind/emcc.rs", "status": "modified", "additions": 34, "deletions": 7, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0/src%2Flibpanic_unwind%2Femcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0/src%2Flibpanic_unwind%2Femcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Femcc.rs?ref=8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0", "patch": "@@ -52,22 +52,49 @@ pub fn payload() -> *mut u8 {\n     ptr::null_mut()\n }\n \n+struct Exception {\n+    // This needs to be an Option because the object's lifetime follows C++\n+    // semantics: when catch_unwind moves the Box out of the exception it must\n+    // still leave the exception object in a valid state because its destructor\n+    // is still going to be called by __cxa_end_catch..\n+    data: Option<Box<dyn Any + Send>>,\n+}\n+\n pub unsafe fn cleanup(ptr: *mut u8) -> Box<dyn Any + Send> {\n     assert!(!ptr.is_null());\n-    let adjusted_ptr = __cxa_begin_catch(ptr as *mut libc::c_void);\n-    let ex = ptr::read(adjusted_ptr as *mut _);\n+    let adjusted_ptr = __cxa_begin_catch(ptr as *mut libc::c_void) as *mut Exception;\n+    let ex = (*adjusted_ptr).data.take();\n     __cxa_end_catch();\n-    ex\n+    ex.unwrap()\n }\n \n pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     let sz = mem::size_of_val(&data);\n-    let exception = __cxa_allocate_exception(sz);\n+    let exception = __cxa_allocate_exception(sz) as *mut Exception;\n     if exception.is_null() {\n         return uw::_URC_FATAL_PHASE1_ERROR as u32;\n     }\n-    ptr::write(exception as *mut _, data);\n-    __cxa_throw(exception as *mut _, &EXCEPTION_TYPE_INFO, ptr::null_mut());\n+    ptr::write(exception, Exception { data: Some(data) });\n+    __cxa_throw(exception as *mut _, &EXCEPTION_TYPE_INFO, exception_cleanup);\n+}\n+\n+// On WASM and ARM, the destructor returns the pointer to the object.\n+cfg_if::cfg_if! {\n+    if #[cfg(any(target_arch = \"arm\", target_arch = \"wasm32\"))] {\n+        type DestructorRet = *mut libc::c_void;\n+    } else {\n+        type DestructorRet = ();\n+    }\n+}\n+extern \"C\" fn exception_cleanup(ptr: *mut libc::c_void) -> DestructorRet {\n+    unsafe {\n+        if let Some(b) = (ptr as *mut Exception).read().data {\n+            drop(b);\n+            super::__rust_drop_panic();\n+        }\n+        #[cfg(any(target_arch = \"arm\", target_arch = \"wasm32\"))]\n+        ptr\n+    }\n }\n \n #[lang = \"eh_personality\"]\n@@ -89,7 +116,7 @@ extern \"C\" {\n     fn __cxa_throw(\n         thrown_exception: *mut libc::c_void,\n         tinfo: *const TypeInfo,\n-        dest: *mut libc::c_void,\n+        dest: extern \"C\" fn(*mut libc::c_void) -> DestructorRet,\n     ) -> !;\n     fn __gxx_personality_v0(\n         version: c_int,"}, {"sha": "6e04317d491fc4ad13d2977cabcfda13236bd6aa", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0", "patch": "@@ -57,7 +57,7 @@ use unwind as uw;\n #[repr(C)]\n struct Exception {\n     _uwe: uw::_Unwind_Exception,\n-    cause: Option<Box<dyn Any + Send>>,\n+    cause: Box<dyn Any + Send>,\n }\n \n pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n@@ -67,7 +67,7 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n             exception_cleanup,\n             private: [0; uw::unwinder_private_data_size],\n         },\n-        cause: Some(data),\n+        cause: data,\n     });\n     let exception_param = Box::into_raw(exception) as *mut uw::_Unwind_Exception;\n     return uw::_Unwind_RaiseException(exception_param) as u32;\n@@ -78,6 +78,7 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     ) {\n         unsafe {\n             let _: Box<Exception> = Box::from_raw(exception as *mut Exception);\n+            super::__rust_drop_panic();\n         }\n     }\n }\n@@ -87,10 +88,8 @@ pub fn payload() -> *mut u8 {\n }\n \n pub unsafe fn cleanup(ptr: *mut u8) -> Box<dyn Any + Send> {\n-    let my_ep = ptr as *mut Exception;\n-    let cause = (*my_ep).cause.take();\n-    uw::_Unwind_DeleteException(ptr as *mut _);\n-    cause.unwrap()\n+    let exception = Box::from_raw(ptr as *mut Exception);\n+    exception.cause\n }\n \n // Rust's exception class identifier.  This is used by personality routines to"}, {"sha": "6383ae39fb6dba0c6795de05873964bc528341bb", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0", "patch": "@@ -26,6 +26,7 @@\n #![feature(staged_api)]\n #![feature(std_internals)]\n #![feature(unwind_attributes)]\n+#![feature(abi_thiscall)]\n #![panic_runtime]\n #![feature(panic_runtime)]\n \n@@ -60,6 +61,12 @@ cfg_if::cfg_if! {\n     }\n }\n \n+extern \"C\" {\n+    /// Handler in libstd called when a panic object is dropped outside of\n+    /// `catch_unwind`.\n+    fn __rust_drop_panic() -> !;\n+}\n+\n mod dwarf;\n \n // Entry point for catching an exception, implemented using the `try` intrinsic"}, {"sha": "d9dca2c0f4f479e6319a3fd750b260b2e1666be0", "filename": "src/libpanic_unwind/seh.rs", "status": "modified", "additions": 58, "deletions": 7, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0/src%2Flibpanic_unwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0/src%2Flibpanic_unwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh.rs?ref=8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0", "patch": "@@ -77,8 +77,11 @@ use libc::{c_int, c_uint, c_void};\n //      #include <stdint.h>\n //\n //      struct rust_panic {\n+//          rust_panic(const rust_panic&);\n+//          ~rust_panic();\n+//\n //          uint64_t x[2];\n-//      }\n+//      };\n //\n //      void foo() {\n //          rust_panic a = {0, 1};\n@@ -128,7 +131,7 @@ mod imp {\n #[repr(C)]\n pub struct _ThrowInfo {\n     pub attributes: c_uint,\n-    pub pnfnUnwind: imp::ptr_t,\n+    pub pmfnUnwind: imp::ptr_t,\n     pub pForwardCompat: imp::ptr_t,\n     pub pCatchableTypeArray: imp::ptr_t,\n }\n@@ -145,7 +148,7 @@ pub struct _CatchableType {\n     pub pType: imp::ptr_t,\n     pub thisDisplacement: _PMD,\n     pub sizeOrOffset: c_int,\n-    pub copy_function: imp::ptr_t,\n+    pub copyFunction: imp::ptr_t,\n }\n \n #[repr(C)]\n@@ -168,7 +171,7 @@ const TYPE_NAME: [u8; 11] = *b\"rust_panic\\0\";\n \n static mut THROW_INFO: _ThrowInfo = _ThrowInfo {\n     attributes: 0,\n-    pnfnUnwind: ptr!(0),\n+    pmfnUnwind: ptr!(0),\n     pForwardCompat: ptr!(0),\n     pCatchableTypeArray: ptr!(0),\n };\n@@ -181,7 +184,7 @@ static mut CATCHABLE_TYPE: _CatchableType = _CatchableType {\n     pType: ptr!(0),\n     thisDisplacement: _PMD { mdisp: 0, pdisp: -1, vdisp: 0 },\n     sizeOrOffset: mem::size_of::<[u64; 2]>() as c_int,\n-    copy_function: ptr!(0),\n+    copyFunction: ptr!(0),\n };\n \n extern \"C\" {\n@@ -208,6 +211,43 @@ static mut TYPE_DESCRIPTOR: _TypeDescriptor = _TypeDescriptor {\n     name: TYPE_NAME,\n };\n \n+// Destructor used if the C++ code decides to capture the exception and drop it\n+// without propagating it. The catch part of the try intrinsic will set the\n+// first word of the exception object to 0 so that it is skipped by the\n+// destructor.\n+//\n+// Note that x86 Windows uses the \"thiscall\" calling convention for C++ member\n+// functions instead of the default \"C\" calling convention.\n+//\n+// The exception_copy function is a bit special here: it is invoked by the MSVC\n+// runtime under a try/catch block and the panic that we generate here will be\n+// used as the result of the exception copy. This is used by the C++ runtime to\n+// support capturing exceptions with std::exception_ptr, which we can't support\n+// because Box<dyn Any> isn't clonable.\n+macro_rules! define_cleanup {\n+    ($abi:tt) => {\n+        unsafe extern $abi fn exception_cleanup(e: *mut [u64; 2]) {\n+            if (*e)[0] != 0 {\n+                cleanup(*e);\n+                super::__rust_drop_panic();\n+            }\n+        }\n+        #[unwind(allowed)]\n+        unsafe extern $abi fn exception_copy(_dest: *mut [u64; 2],\n+                                             _src: *mut [u64; 2])\n+                                             -> *mut [u64; 2] {\n+            panic!(\"Rust panics cannot be copied\");\n+        }\n+    }\n+}\n+cfg_if::cfg_if! {\n+   if #[cfg(target_arch = \"x86\")] {\n+       define_cleanup!(\"thiscall\");\n+   } else {\n+       define_cleanup!(\"C\");\n+   }\n+}\n+\n pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     use core::intrinsics::atomic_store;\n \n@@ -220,8 +260,7 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     // exception (constructed above).\n     let ptrs = mem::transmute::<_, raw::TraitObject>(data);\n     let mut ptrs = [ptrs.data as u64, ptrs.vtable as u64];\n-    let ptrs_ptr = ptrs.as_mut_ptr();\n-    let throw_ptr = ptrs_ptr as *mut _;\n+    let throw_ptr = ptrs.as_mut_ptr() as *mut _;\n \n     // This... may seems surprising, and justifiably so. On 32-bit MSVC the\n     // pointers between these structure are just that, pointers. On 64-bit MSVC,\n@@ -243,6 +282,12 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     //\n     // In any case, we basically need to do something like this until we can\n     // express more operations in statics (and we may never be able to).\n+    if !cfg!(bootstrap) {\n+        atomic_store(\n+            &mut THROW_INFO.pmfnUnwind as *mut _ as *mut u32,\n+            ptr!(exception_cleanup) as u32,\n+        );\n+    }\n     atomic_store(\n         &mut THROW_INFO.pCatchableTypeArray as *mut _ as *mut u32,\n         ptr!(&CATCHABLE_TYPE_ARRAY as *const _) as u32,\n@@ -255,6 +300,12 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n         &mut CATCHABLE_TYPE.pType as *mut _ as *mut u32,\n         ptr!(&TYPE_DESCRIPTOR as *const _) as u32,\n     );\n+    if !cfg!(bootstrap) {\n+        atomic_store(\n+            &mut CATCHABLE_TYPE.copyFunction as *mut _ as *mut u32,\n+            ptr!(exception_copy) as u32,\n+        );\n+    }\n \n     extern \"system\" {\n         #[unwind(allowed)]"}, {"sha": "031837c1efbe814da24c7843022d3bb3cb710c0f", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0", "patch": "@@ -922,40 +922,61 @@ fn codegen_msvc_try(\n         //      #include <stdint.h>\n         //\n         //      struct rust_panic {\n+        //          rust_panic(const rust_panic&);\n+        //          ~rust_panic();\n+        //\n         //          uint64_t x[2];\n         //      }\n         //\n         //      int bar(void (*foo)(void), uint64_t *ret) {\n         //          try {\n         //              foo();\n         //              return 0;\n-        //          } catch(rust_panic a) {\n+        //          } catch(rust_panic& a) {\n         //              ret[0] = a.x[0];\n         //              ret[1] = a.x[1];\n+        //              a.x[0] = 0;\n         //              return 1;\n         //          }\n         //      }\n         //\n         // More information can be found in libstd's seh.rs implementation.\n         let i64_2 = bx.type_array(bx.type_i64(), 2);\n-        let i64_align = bx.tcx().data_layout.i64_align.abi;\n-        let slot = bx.alloca(i64_2, i64_align);\n+        let i64_2_ptr = bx.type_ptr_to(i64_2);\n+        let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n+        let slot = bx.alloca(i64_2_ptr, ptr_align);\n         bx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(), None);\n \n         normal.ret(bx.const_i32(0));\n \n         let cs = catchswitch.catch_switch(None, None, 1);\n         catchswitch.add_handler(cs, catchpad.llbb());\n \n+        // The flag value of 8 indicates that we are catching the exception by\n+        // reference instead of by value. We can't use catch by value because\n+        // that requires copying the exception object, which we don't support\n+        // since our exception object effectively contains a Box.\n+        //\n+        // Source: MicrosoftCXXABI::getAddrOfCXXCatchHandlerType in clang\n+        let flags = bx.const_i32(8);\n         let tydesc = match bx.tcx().lang_items().eh_catch_typeinfo() {\n             Some(did) => bx.get_static(did),\n             None => bug!(\"eh_catch_typeinfo not defined, but needed for SEH unwinding\"),\n         };\n-        let funclet = catchpad.catch_pad(cs, &[tydesc, bx.const_i32(0), slot]);\n+        let funclet = catchpad.catch_pad(cs, &[tydesc, flags, slot]);\n \n-        let payload = catchpad.load(slot, i64_align);\n+        let i64_align = bx.tcx().data_layout.i64_align.abi;\n+        let payload_ptr = catchpad.load(slot, ptr_align);\n+        let payload = catchpad.load(payload_ptr, i64_align);\n         let local_ptr = catchpad.bitcast(local_ptr, bx.type_ptr_to(i64_2));\n         catchpad.store(payload, local_ptr, i64_align);\n+\n+        // Clear the first word of the exception so avoid double-dropping it.\n+        // This will be read by the destructor which is implicitly called at the\n+        // end of the catch block by the runtime.\n+        let payload_0_ptr = catchpad.inbounds_gep(payload_ptr, &[bx.const_i32(0), bx.const_i32(0)]);\n+        catchpad.store(bx.const_u64(0), payload_0_ptr, i64_align);\n+\n         catchpad.catch_ret(&funclet, caught.llbb());\n \n         caught.ret(bx.const_i32(1));"}, {"sha": "bfadeafb7c7737d0b583bb51aaa912842674e196", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0", "patch": "@@ -55,6 +55,15 @@ extern \"C\" {\n     fn __rust_start_panic(payload: usize) -> u32;\n }\n \n+/// This function is called by the panic runtime if FFI code catches a Rust\n+/// panic but doesn't rethrow it. We don't support this case since it messes\n+/// with our panic count.\n+#[cfg(not(test))]\n+#[rustc_std_internal_symbol]\n+extern \"C\" fn __rust_drop_panic() -> ! {\n+    rtabort!(\"Rust panics must be rethrown\");\n+}\n+\n #[derive(Copy, Clone)]\n enum Hook {\n     Default,"}, {"sha": "9c2045c8c89f72c24dcfe78d61d095578b5ae5a8", "filename": "src/test/run-make-fulldeps/foreign-exceptions/foo.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2Ffoo.rs?ref=8a87b945b27b5670ac5ed665bbb0fccc1b88a0a0", "patch": "@@ -4,7 +4,6 @@\n \n // For linking libstdc++ on MinGW\n #![cfg_attr(all(windows, target_env = \"gnu\"), feature(static_nobundle))]\n-\n #![feature(unwind_attributes)]\n \n use std::panic::{catch_unwind, AssertUnwindSafe};"}]}