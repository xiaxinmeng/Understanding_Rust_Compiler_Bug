{"sha": "b629c85bd74dfb730a3e9308312b007c0bf027cb", "node_id": "C_kwDOAAsO6NoAKGI2MjljODViZDc0ZGZiNzMwYTNlOTMwODMxMmIwMDdjMGJmMDI3Y2I", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-26T04:28:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-26T04:28:41Z"}, "message": "Auto merge of #99745 - JohnTitor:rollup-lvrie64, r=JohnTitor\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #98211 (Implement `fs::get_path` for FreeBSD.)\n - #99353 (Slightly improve mismatched GAT where clause error)\n - #99593 (Suggest removing the tuple struct field for the unwrapped value)\n - #99615 (Remove some explicit `self.infcx` for `FnCtxt`, which already derefs into `InferCtxt`)\n - #99711 (Remove reachable coverage without counters)\n - #99718 (Avoid `&str`/`Symbol` to `String` conversions)\n - #99720 (Sync rustc_codegen_cranelift)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "fd1af610fe65c0dff7fb3ead05b43937e2b635a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd1af610fe65c0dff7fb3ead05b43937e2b635a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b629c85bd74dfb730a3e9308312b007c0bf027cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b629c85bd74dfb730a3e9308312b007c0bf027cb", "html_url": "https://github.com/rust-lang/rust/commit/b629c85bd74dfb730a3e9308312b007c0bf027cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b629c85bd74dfb730a3e9308312b007c0bf027cb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "daaae25022cedcd7ded230170cdf48cfb799f9a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/daaae25022cedcd7ded230170cdf48cfb799f9a2", "html_url": "https://github.com/rust-lang/rust/commit/daaae25022cedcd7ded230170cdf48cfb799f9a2"}, {"sha": "a572f061c7a8c58aab67335f6b63a74cfc6e4973", "url": "https://api.github.com/repos/rust-lang/rust/commits/a572f061c7a8c58aab67335f6b63a74cfc6e4973", "html_url": "https://github.com/rust-lang/rust/commit/a572f061c7a8c58aab67335f6b63a74cfc6e4973"}], "stats": {"total": 1395, "additions": 844, "deletions": 551}, "files": [{"sha": "1d66153734c782f36d0217ecf35e29615ff5379f", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -850,13 +850,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             debug!(\"trait spans found: {:?}\", traits);\n             for span in &traits {\n                 let mut multi_span: MultiSpan = vec![*span].into();\n-                multi_span.push_span_label(\n-                    *span,\n-                    \"this has an implicit `'static` lifetime requirement\".to_string(),\n-                );\n+                multi_span\n+                    .push_span_label(*span, \"this has an implicit `'static` lifetime requirement\");\n                 multi_span.push_span_label(\n                     ident.span,\n-                    \"calling this method introduces the `impl`'s 'static` requirement\".to_string(),\n+                    \"calling this method introduces the `impl`'s 'static` requirement\",\n                 );\n                 err.span_note(multi_span, \"the used `impl` has a `'static` requirement\");\n                 err.span_suggestion_verbose("}, {"sha": "d88309e412ed0e596f1f4091dd500a96b65b2338", "filename": "compiler/rustc_codegen_cranelift/.vscode/settings.json", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -1,10 +1,9 @@\n {\n     // source for rustc_* is not included in the rust-src component; disable the errors about this\n     \"rust-analyzer.diagnostics.disabled\": [\"unresolved-extern-crate\", \"unresolved-macro-call\"],\n-    \"rust-analyzer.assist.importGranularity\": \"module\",\n-    \"rust-analyzer.assist.importEnforceGranularity\": true,\n-    \"rust-analyzer.assist.importPrefix\": \"crate\",\n-    \"rust-analyzer.cargo.runBuildScripts\": true,\n+    \"rust-analyzer.imports.granularity.enforce\": true,\n+    \"rust-analyzer.imports.granularity.group\": \"module\",\n+    \"rust-analyzer.imports.prefix\": \"crate\",\n     \"rust-analyzer.cargo.features\": [\"unstable-features\"],\n     \"rust-analyzer.linkedProjects\": [\n         \"./Cargo.toml\","}, {"sha": "532049c858d4f4ce78218a816512d2a9c7acd9cb", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 103, "deletions": 36, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -2,6 +2,17 @@\n # It is not intended for manual editing.\n version = 3\n \n+[[package]]\n+name = \"ahash\"\n+version = \"0.7.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fcb51a0695d8f838b1ee009b3fbf66bda078cd64590202a864a8f3e8c4315c47\"\n+dependencies = [\n+ \"getrandom\",\n+ \"once_cell\",\n+ \"version_check\",\n+]\n+\n [[package]]\n name = \"anyhow\"\n version = \"1.0.56\"\n@@ -25,6 +36,12 @@ version = \"1.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n \n+[[package]]\n+name = \"byteorder\"\n+version = \"1.4.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"14c189c53d098945499cdfa7ecc63567cf3886b3332b312a5b4585d8d3a6a610\"\n+\n [[package]]\n name = \"cfg-if\"\n version = \"1.0.0\"\n@@ -33,68 +50,75 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"cranelift-bforest\"\n-version = \"0.83.0\"\n+version = \"0.85.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ed44413e7e2fe3260d0ed73e6956ab188b69c10ee92b892e401e0f4f6808c68b\"\n+checksum = \"749d0d6022c9038dccf480bdde2a38d435937335bf2bb0f14e815d94517cdce8\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n-version = \"0.83.0\"\n+version = \"0.85.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0b5d83f0f26bf213f971f45589d17e5b65e4861f9ed22392b0cbb6eaa5bd329c\"\n+checksum = \"e94370cc7b37bf652ccd8bb8f09bd900997f7ccf97520edfc75554bb5c4abbea\"\n dependencies = [\n  \"cranelift-bforest\",\n  \"cranelift-codegen-meta\",\n  \"cranelift-codegen-shared\",\n  \"cranelift-entity\",\n+ \"cranelift-isle\",\n  \"gimli\",\n  \"log\",\n- \"regalloc\",\n+ \"regalloc2\",\n  \"smallvec\",\n  \"target-lexicon\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-meta\"\n-version = \"0.83.0\"\n+version = \"0.85.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6800dc386177df6ecc5a32680607ed8ba1fa0d31a2a59c8c61fbf44826b8191d\"\n+checksum = \"e0a3cea8fdab90e44018c5b9a1dfd460d8ee265ac354337150222a354628bdb6\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-shared\"\n-version = \"0.83.0\"\n+version = \"0.85.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c961f85070985ebc8fcdb81b838a5cf842294d1e6ed4852446161c7e246fd455\"\n+checksum = \"5ac72f76f2698598951ab26d8c96eaa854810e693e7dd52523958b5909fde6b2\"\n \n [[package]]\n name = \"cranelift-entity\"\n-version = \"0.83.0\"\n+version = \"0.85.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2347b2b8d1d5429213668f2a8e36c85ee3c73984a2f6a79007e365d3e575e7ed\"\n+checksum = \"09eaeacfcd2356fe0e66b295e8f9d59fdd1ac3ace53ba50de14d628ec902f72d\"\n \n [[package]]\n name = \"cranelift-frontend\"\n-version = \"0.83.0\"\n+version = \"0.85.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4cbcdbf7bed29e363568b778649b69dabc3d727256d5d25236096ef693757654\"\n+checksum = \"dba69c9980d5ffd62c18a2bde927855fcd7c8dc92f29feaf8636052662cbd99c\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n  \"smallvec\",\n  \"target-lexicon\",\n ]\n \n+[[package]]\n+name = \"cranelift-isle\"\n+version = \"0.85.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d2920dc1e05cac40304456ed3301fde2c09bd6a9b0210bcfa2f101398d628d5b\"\n+\n [[package]]\n name = \"cranelift-jit\"\n-version = \"0.83.0\"\n+version = \"0.85.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7c769d4e0d76f59c8b2a3bf0477d89ee149bb0731b53fbb245ee081d49063095\"\n+checksum = \"1c3c5ed067f2c81577e431f3039148a9c187b33cc79e0d1731fede27d801ec56\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -110,19 +134,19 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-module\"\n-version = \"0.83.0\"\n+version = \"0.85.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0ab57d399a2401074bb0cc40b3031e420f3d66d46ec0cf21eeae53ac04bd73e2\"\n+checksum = \"eee6784303bf9af235237a4885f7417e09a35df896d38ea969a0081064b3ede4\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n ]\n \n [[package]]\n name = \"cranelift-native\"\n-version = \"0.83.0\"\n+version = \"0.85.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8f4cdf93552e5ceb2e3c042829ebb4de4378492705f769eadc6a7c6c5251624c\"\n+checksum = \"f04dfa45f9b2a6f587c564d6b63388e00cd6589d2df6ea2758cf79e1a13285e6\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"libc\",\n@@ -131,9 +155,9 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-object\"\n-version = \"0.83.0\"\n+version = \"0.85.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cf8e65f4839c26e6237fc0744911d79b0a2ac5e76b4e4eebd14db2b8d849fd31\"\n+checksum = \"0bf38b2c505db749276793116c0cb30bd096206c7810e471677a453134881881\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -152,6 +176,26 @@ dependencies = [\n  \"cfg-if\",\n ]\n \n+[[package]]\n+name = \"fxhash\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c31b6d751ae2c7f11320402d34e41349dd1016f8d5d45e48c4312bc8625af50c\"\n+dependencies = [\n+ \"byteorder\",\n+]\n+\n+[[package]]\n+name = \"getrandom\"\n+version = \"0.2.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9be70c98951c83b8d2f8f60d7065fa6d5146873094452a1008da8c2f1e4205ad\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"libc\",\n+ \"wasi\",\n+]\n+\n [[package]]\n name = \"gimli\"\n version = \"0.26.1\"\n@@ -161,6 +205,15 @@ dependencies = [\n  \"indexmap\",\n ]\n \n+[[package]]\n+name = \"hashbrown\"\n+version = \"0.11.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ab5ef0d4909ef3724cc8cce6ccc8572c5c817592e9285f5464f8e86f8bd3726e\"\n+dependencies = [\n+ \"ahash\",\n+]\n+\n [[package]]\n name = \"hashbrown\"\n version = \"0.12.3\"\n@@ -174,14 +227,14 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"10a35a97730320ffe8e2d410b5d3b69279b98d2c14bdb8b70ea89ecf7888d41e\"\n dependencies = [\n  \"autocfg\",\n- \"hashbrown\",\n+ \"hashbrown 0.12.3\",\n ]\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.119\"\n+version = \"0.2.126\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1bf2e165bb3457c8e098ea76f3e3bc9db55f87aa90d52d0e6be741470916aaa4\"\n+checksum = \"349d5a591cd28b49e1d1037471617a32ddcda5731b99419008085f72d5a53836\"\n \n [[package]]\n name = \"libloading\"\n@@ -219,11 +272,12 @@ checksum = \"308cc39be01b73d0d18f82a0e7b2a3df85245f84af96fdddc5d202d27e47b86a\"\n \n [[package]]\n name = \"object\"\n-version = \"0.27.1\"\n+version = \"0.28.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"67ac1d3f9a1d3616fd9a60c8d74296f22406a238b6a72f5cc1e6f314df4ffbf9\"\n+checksum = \"e42c982f2d955fac81dd7e1d0e1426a7d702acd9c98d19ab01083a6a0328c424\"\n dependencies = [\n  \"crc32fast\",\n+ \"hashbrown 0.11.2\",\n  \"indexmap\",\n  \"memchr\",\n ]\n@@ -235,13 +289,14 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"87f3e037eac156d1775da914196f0f37741a274155e34a0b7e427c35d2a2ecb9\"\n \n [[package]]\n-name = \"regalloc\"\n-version = \"0.0.34\"\n+name = \"regalloc2\"\n+version = \"0.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"62446b1d3ebf980bdc68837700af1d77b37bc430e524bf95319c6eada2a4cc02\"\n+checksum = \"4a8d23b35d7177df3b9d31ed8a9ab4bf625c668be77a319d4f5efd4a5257701c\"\n dependencies = [\n+ \"fxhash\",\n  \"log\",\n- \"rustc-hash\",\n+ \"slice-group-by\",\n  \"smallvec\",\n ]\n \n@@ -257,12 +312,6 @@ dependencies = [\n  \"winapi\",\n ]\n \n-[[package]]\n-name = \"rustc-hash\"\n-version = \"1.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2\"\n-\n [[package]]\n name = \"rustc_codegen_cranelift\"\n version = \"0.1.0\"\n@@ -283,6 +332,12 @@ dependencies = [\n  \"target-lexicon\",\n ]\n \n+[[package]]\n+name = \"slice-group-by\"\n+version = \"0.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"03b634d87b960ab1a38c4fe143b508576f075e7c978bfad18217645ebfdfa2ec\"\n+\n [[package]]\n name = \"smallvec\"\n version = \"1.8.1\"\n@@ -295,6 +350,18 @@ version = \"0.12.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d7fa7e55043acb85fca6b3c01485a2eeb6b69c5d21002e273c79e465f43b7ac1\"\n \n+[[package]]\n+name = \"version_check\"\n+version = \"0.9.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f\"\n+\n+[[package]]\n+name = \"wasi\"\n+version = \"0.10.2+wasi-snapshot-preview1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fd6fbd9a79829dd1ad0cc20627bf1ed606756a7f77edff7b66b7064f9cb327c6\"\n+\n [[package]]\n name = \"winapi\"\n version = \"0.3.9\""}, {"sha": "61e977e3e69bfbd0ae0e23a4d82693a509e25d3e", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -8,15 +8,15 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n # These have to be in sync with each other\n-cranelift-codegen = { version = \"0.83.0\", features = [\"unwind\", \"all-arch\"] }\n-cranelift-frontend = \"0.83.0\"\n-cranelift-module = \"0.83.0\"\n-cranelift-native = \"0.83.0\"\n-cranelift-jit = { version = \"0.83.0\", optional = true }\n-cranelift-object = \"0.83.0\"\n+cranelift-codegen = { version = \"0.85.3\", features = [\"unwind\", \"all-arch\"] }\n+cranelift-frontend = \"0.85.3\"\n+cranelift-module = \"0.85.3\"\n+cranelift-native = \"0.85.3\"\n+cranelift-jit = { version = \"0.85.3\", optional = true }\n+cranelift-object = \"0.85.3\"\n target-lexicon = \"0.12.0\"\n gimli = { version = \"0.26.0\", default-features = false, features = [\"write\"]}\n-object = { version = \"0.27.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n+object = { version = \"0.28.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n \n ar = { git = \"https://github.com/bjorn3/rust-ar.git\", branch = \"do_not_remove_cg_clif_ranlib\" }\n indexmap = \"1.9.1\""}, {"sha": "7b2cdd273366f41ea8b21939395ba82e124b07ae", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -56,9 +56,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.72\"\n+version = \"0.1.75\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"afdbb35d279238cf77f0c9e8d90ad50d6c7bff476ab342baafa29440f0f10bff\"\n+checksum = \"c6e3183e88f659a862835db8f4b67dbeed3d93e44dd4927eef78edb1c149d784\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -112,9 +112,9 @@ dependencies = [\n \n [[package]]\n name = \"hashbrown\"\n-version = \"0.12.1\"\n+version = \"0.12.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"db0d4cf898abf0081f964436dc980e96670a0f36863e4b83aaacdb65c9d7ccc3\"\n+checksum = \"8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n@@ -123,20 +123,21 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.2.0\"\n+version = \"0.2.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1ab7905ea95c6d9af62940f9d7dd9596d54c334ae2c15300c482051292d5637f\"\n+checksum = \"7668753748e445859e4e373c3d41117235d9feed578392f5a3a73efdc751ca4a\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\",\n+ \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n ]\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.125\"\n+version = \"0.2.126\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5916d2ae698f6de9bfb891ad7a8d65c09d232dc58cc4ac433c7da3b2fd84bc2b\"\n+checksum = \"349d5a591cd28b49e1d1037471617a32ddcda5731b99419008085f72d5a53836\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]"}, {"sha": "16cce83dd9c850f06222f5e0549fc30b538bb31f", "filename": "compiler/rustc_codegen_cranelift/build_system/build_sysroot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -205,7 +205,7 @@ fn build_clif_sysroot_for_triple(\n     {\n         let entry = entry.unwrap();\n         if let Some(ext) = entry.path().extension() {\n-            if ext == \"rmeta\" || ext == \"d\" || ext == \"dSYM\" {\n+            if ext == \"rmeta\" || ext == \"d\" || ext == \"dSYM\" || ext == \"clif\" {\n                 continue;\n             }\n         } else {"}, {"sha": "8b6042a3d66380909f63bb727a4fcb08cce5fc5e", "filename": "compiler/rustc_codegen_cranelift/example/mini_core.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -458,7 +458,7 @@ pub trait FnMut<Args>: FnOnce<Args> {\n \n #[lang = \"panic\"]\n #[track_caller]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\n\\0\" as *const str as *const i8);\n         intrinsics::abort();\n@@ -497,7 +497,7 @@ pub trait Deref {\n #[repr(transparent)]\n #[rustc_layout_scalar_valid_range_start(1)]\n #[rustc_nonnull_optimization_guaranteed]\n-pub struct NonNull<T: ?Sized>(pub *mut T);\n+pub struct NonNull<T: ?Sized>(pub *const T);\n \n impl<T: ?Sized, U: ?Sized> CoerceUnsized<NonNull<U>> for NonNull<T> where T: Unsize<U> {}\n impl<T: ?Sized, U: ?Sized> DispatchFromDyn<NonNull<U>> for NonNull<T> where T: Unsize<U> {}\n@@ -521,7 +521,7 @@ impl<T: ?Sized> Drop for Box<T> {\n     }\n }\n \n-impl<T> Deref for Box<T> {\n+impl<T: ?Sized> Deref for Box<T> {\n     type Target = T;\n \n     fn deref(&self) -> &Self::Target {"}, {"sha": "aa1f239bae23ec55bce6c5872f7eac3d37ae8355", "filename": "compiler/rustc_codegen_cranelift/example/mini_core_hello_world.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -124,6 +124,23 @@ fn call_return_u128_pair() {\n     return_u128_pair();\n }\n \n+#[repr(C)]\n+pub struct bool_11 {\n+    field0: bool,\n+    field1: bool,\n+    field2: bool,\n+    field3: bool,\n+    field4: bool,\n+    field5: bool,\n+    field6: bool,\n+    field7: bool,\n+    field8: bool,\n+    field9: bool,\n+    field10: bool,\n+}\n+\n+extern \"C\" fn bool_struct_in_11(arg0: bool_11) {}\n+\n #[allow(unreachable_code)] // FIXME false positive\n fn main() {\n     take_unique(Unique {\n@@ -134,6 +151,20 @@ fn main() {\n \n     call_return_u128_pair();\n \n+    bool_struct_in_11(bool_11 {\n+        field0: true,\n+        field1: true,\n+        field2: true,\n+        field3: true,\n+        field4: true,\n+        field5: true,\n+        field6: true,\n+        field7: true,\n+        field8: true,\n+        field9: true,\n+        field10: true,\n+    });\n+\n     let slice = &[0, 1] as &[i32];\n     let slice_ptr = slice as *const [i32] as *const i32;\n \n@@ -299,6 +330,17 @@ fn main() {\n     static REF1: &u8 = &42;\n     static REF2: &u8 = REF1;\n     assert_eq!(*REF1, *REF2);\n+\n+    extern \"C\" {\n+        type A;\n+    }\n+\n+    fn main() {\n+        let x: &A = unsafe { &*(1usize as *const A) };\n+\n+        assert_eq!(unsafe { intrinsics::size_of_val(x) }, 0);\n+        assert_eq!(unsafe { intrinsics::min_align_of_val(x) }, 1);\n+}\n }\n \n #[cfg(all(not(jit), target_arch = \"x86_64\", target_os = \"linux\"))]"}, {"sha": "0b5b6cd55d720d4750060ecb81f75b83f76f4cf6", "filename": "compiler/rustc_codegen_cranelift/example/std_example.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -128,6 +128,25 @@ fn main() {\n         0 => loop {},\n         v => panic(v),\n     };\n+\n+    if black_box(false) {\n+        // Based on https://github.com/rust-lang/rust/blob/2f320a224e827b400be25966755a621779f797cc/src/test/ui/debuginfo/debuginfo_with_uninhabitable_field_and_unsized.rs\n+        let _ = Foo::<dyn Send>::new();\n+\n+        #[allow(dead_code)]\n+        struct Foo<T: ?Sized> {\n+            base: Never,\n+            value: T,\n+        }\n+\n+        impl<T: ?Sized> Foo<T> {\n+            pub fn new() -> Box<Foo<T>> {\n+                todo!()\n+            }\n+        }\n+\n+        enum Never {}\n+    }\n }\n \n fn panic(_: u128) {"}, {"sha": "3ab395d89d50e884945dd045e080c922039c73aa", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-05-15\"\n+channel = \"nightly-2022-07-25\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "091bfa1e9926fac647315298b8c35c386f46b3d3", "filename": "compiler/rustc_codegen_cranelift/scripts/setup_rust_fork.sh", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -29,14 +29,15 @@ diff --git a/src/tools/compiletest/src/runtest.rs b/src/tools/compiletest/src/ru\n index 8431aa7b818..a3ff7e68ce5 100644\n --- a/src/tools/compiletest/src/runtest.rs\n +++ b/src/tools/compiletest/src/runtest.rs\n-@@ -3489,11 +3489,7 @@ fn normalize_output(&self, output: &str, custom_rules: &[(String, String)]) -> S\n-             .join(\"library\");\n-         normalize_path(&src_dir, \"$(echo '$SRC_DIR')\");\n+@@ -3489,12 +3489,7 @@ fn normalize_output(&self, output: &str, custom_rules: &[(String, String)]) -> S\n+         let compiler_src_dir = base_dir.join(\"compiler\");\n+         normalize_path(&compiler_src_dir, \"$(echo '$COMPILER_DIR')\");\n \n -        if let Some(virtual_rust_source_base_dir) =\n -            option_env!(\"CFG_VIRTUAL_RUST_SOURCE_BASE_DIR\").map(PathBuf::from)\n -        {\n -            normalize_path(&virtual_rust_source_base_dir.join(\"library\"), \"$(echo '$SRC_DIR')\");\n+-            normalize_path(&virtual_rust_source_base_dir.join(\"compiler\"), \"$(echo '$COMPILER_DIR')\");\n -        }\n +        normalize_path(&Path::new(\"$(cd ../build_sysroot/sysroot_src/library; pwd)\"), \"$(echo '$SRC_DIR')\");\n \n@@ -62,3 +63,6 @@ deny-warnings = false\n verbose-tests = false\n EOF\n popd\n+\n+# FIXME remove once inline asm is fully supported\n+export RUSTFLAGS=\"$RUSTFLAGS --cfg=rustix_use_libc\""}, {"sha": "944787612d8bc206e1a29a7ab130518696ecc410", "filename": "compiler/rustc_codegen_cranelift/scripts/test_rustc_tests.sh", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -33,6 +33,7 @@ rm src/test/ui/test-attrs/test-fn-signature-verification-for-explicit-return-typ\n rm src/test/ui/async-await/async-fn-size-moved-locals.rs # -Cpanic=abort shrinks some generator by one byte\n rm src/test/ui/async-await/async-fn-size-uninit-locals.rs # same\n rm src/test/ui/generator/size-moved-locals.rs # same\n+rm -r src/test/ui/macros/rfc-2011-nicer-assert-messages/\n \n # vendor intrinsics\n rm src/test/ui/sse2.rs # cpuid not supported, so sse2 not detected\n@@ -65,11 +66,13 @@ rm src/test/ui/intrinsics/intrinsic-nearby.rs # unimplemented nearbyintf32 and n\n rm src/test/ui/target-feature/missing-plusminus.rs # error not implemented\n rm src/test/ui/fn/dyn-fn-alignment.rs # wants a 256 byte alignment\n rm -r src/test/run-make/emit-named-files # requires full --emit support\n+rm src/test/ui/abi/stack-probes.rs # stack probes not yet implemented\n \n # optimization tests\n # ==================\n-rm src/test/ui/issues/issue-28950.rs # depends on stack size optimizations\n+rm src/test/ui/codegen/issue-28950.rs # depends on stack size optimizations\n rm src/test/ui/codegen/init-large-type.rs # same\n+rm src/test/ui/issues/issue-40883.rs # same\n rm -r src/test/run-make/fmt-write-bloat/ # tests an optimization\n \n # backend specific tests\n@@ -89,14 +92,13 @@ rm src/test/ui/consts/issue-33537.rs # same\n rm -r src/test/run-make/emit-shared-files # requires the rustdoc executable in build/bin/\n rm -r src/test/run-make/unstable-flag-required # same\n rm -r src/test/run-make/rustdoc-* # same\n+rm -r src/test/run-make/issue-88756-default-output # same\n+rm -r src/test/run-make/remap-path-prefix-dwarf # requires llvm-dwarfdump\n \n # genuine bugs\n # ============\n rm src/test/ui/allocator/no_std-alloc-error-handler-default.rs # missing rust_oom definition\n \n-rm -r src/test/ui/polymorphization/ # polymorphization not yet supported\n-rm src/test/codegen-units/polymorphization/unused_type_parameters.rs # same\n-\n rm src/test/incremental/spike-neg1.rs # errors out for some reason\n rm src/test/incremental/spike-neg2.rs # same\n rm src/test/ui/issues/issue-74564-if-expr-stack-overflow.rs # gives a stackoverflow before the backend runs\n@@ -111,6 +113,8 @@ rm src/test/ui/backtrace.rs # TODO warning\n rm src/test/ui/empty_global_asm.rs # TODO add needs-asm-support\n rm src/test/ui/simple_global_asm.rs # TODO add needs-asm-support\n rm src/test/ui/test-attrs/test-type.rs # TODO panic message on stderr. correct stdout\n+# not sure if this is actually a bug in the test suite, but the symbol list shows the function without leading _ for some reason\n+rm -r src/test/run-make/native-link-modifier-bundle\n \n echo \"[TEST] rustc test suite\"\n RUST_TEST_NOCAPTURE=1 COMPILETEST_FORCE_STAGE0=1 ./x.py test --stage 0 src/test/{codegen-units,run-make,run-pass-valgrind,ui,incremental}"}, {"sha": "815450f689e4ab50c4957a35d5ee90faf22ca7e9", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -4,6 +4,7 @@ mod comments;\n mod pass_mode;\n mod returning;\n \n+use cranelift_module::ModuleError;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::ty::layout::FnAbiOf;\n use rustc_target::abi::call::{Conv, FnAbi};\n@@ -69,7 +70,17 @@ pub(crate) fn import_function<'tcx>(\n ) -> FuncId {\n     let name = tcx.symbol_name(inst).name;\n     let sig = get_function_sig(tcx, module.isa().triple(), inst);\n-    module.declare_function(name, Linkage::Import, &sig).unwrap()\n+    match module.declare_function(name, Linkage::Import, &sig) {\n+        Ok(func_id) => func_id,\n+        Err(ModuleError::IncompatibleDeclaration(_)) => tcx.sess.fatal(&format!(\n+            \"attempt to declare `{name}` as function, but it was already declared as static\"\n+        )),\n+        Err(ModuleError::IncompatibleSignature(_, prev_sig, new_sig)) => tcx.sess.fatal(&format!(\n+            \"attempt to declare `{name}` with signature {new_sig:?}, \\\n+             but it was already declared with signature {prev_sig:?}\"\n+        )),\n+        Err(err) => Err::<_, _>(err).unwrap(),\n+    }\n }\n \n impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n@@ -182,6 +193,15 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n     }\n \n     let fn_abi = fx.fn_abi.take().unwrap();\n+\n+    // FIXME implement variadics in cranelift\n+    if fn_abi.c_variadic {\n+        fx.tcx.sess.span_fatal(\n+            fx.mir.span,\n+            \"Defining variadic functions is not yet supported by Cranelift\",\n+        );\n+    }\n+\n     let mut arg_abis_iter = fn_abi.args.iter();\n \n     let func_params = fx\n@@ -376,9 +396,15 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         RevealAllLayoutCx(fx.tcx).fn_abi_of_fn_ptr(fn_ty.fn_sig(fx.tcx), extra_args)\n     };\n \n-    let is_cold = instance\n-        .map(|inst| fx.tcx.codegen_fn_attrs(inst.def_id()).flags.contains(CodegenFnAttrFlags::COLD))\n-        .unwrap_or(false);\n+    let is_cold = if fn_sig.abi == Abi::RustCold {\n+        true\n+    } else {\n+        instance\n+            .map(|inst| {\n+                fx.tcx.codegen_fn_attrs(inst.def_id()).flags.contains(CodegenFnAttrFlags::COLD)\n+            })\n+            .unwrap_or(false)\n+    };\n     if is_cold {\n         fx.bcx.set_cold_block(fx.bcx.current_block().unwrap());\n         if let Some(destination_block) = target {"}, {"sha": "6c10baa53d415da6e32e64adebecab4d57a059d4", "filename": "compiler/rustc_codegen_cranelift/src/abi/pass_mode.rs", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -18,9 +18,9 @@ fn reg_to_abi_param(reg: Reg) -> AbiParam {\n     let clif_ty = match (reg.kind, reg.size.bytes()) {\n         (RegKind::Integer, 1) => types::I8,\n         (RegKind::Integer, 2) => types::I16,\n-        (RegKind::Integer, 4) => types::I32,\n-        (RegKind::Integer, 8) => types::I64,\n-        (RegKind::Integer, 16) => types::I128,\n+        (RegKind::Integer, 3..=4) => types::I32,\n+        (RegKind::Integer, 5..=8) => types::I64,\n+        (RegKind::Integer, 9..=16) => types::I128,\n         (RegKind::Float, 4) => types::F32,\n         (RegKind::Float, 8) => types::F64,\n         (RegKind::Vector, size) => types::I8.by(u16::try_from(size).unwrap()).unwrap(),\n@@ -48,23 +48,9 @@ fn cast_target_to_abi_params(cast: CastTarget) -> SmallVec<[AbiParam; 2]> {\n         )\n     };\n \n-    if cast.prefix.iter().all(|x| x.is_none()) {\n-        // Simplify to a single unit when there is no prefix and size <= unit size\n-        if cast.rest.total <= cast.rest.unit.size {\n-            let clif_ty = match (cast.rest.unit.kind, cast.rest.unit.size.bytes()) {\n-                (RegKind::Integer, 1) => types::I8,\n-                (RegKind::Integer, 2) => types::I16,\n-                (RegKind::Integer, 3..=4) => types::I32,\n-                (RegKind::Integer, 5..=8) => types::I64,\n-                (RegKind::Integer, 9..=16) => types::I128,\n-                (RegKind::Float, 4) => types::F32,\n-                (RegKind::Float, 8) => types::F64,\n-                (RegKind::Vector, size) => types::I8.by(u16::try_from(size).unwrap()).unwrap(),\n-                _ => unreachable!(\"{:?}\", cast.rest.unit),\n-            };\n-            return smallvec![AbiParam::new(clif_ty)];\n-        }\n-    }\n+    // Note: Unlike the LLVM equivalent of this code we don't have separate branches for when there\n+    // is no prefix as a single unit, an array and a heterogeneous struct are not represented using\n+    // different types in Cranelift IR. Instead a single array of primitive types is used.\n \n     // Create list of fields in the main structure\n     let mut args = cast\n@@ -230,7 +216,7 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n     arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n     is_owned: bool,\n ) -> SmallVec<[Value; 2]> {\n-    assert_assignable(fx, arg.layout().ty, arg_abi.layout.ty);\n+    assert_assignable(fx, arg.layout().ty, arg_abi.layout.ty, 16);\n     match arg_abi.mode {\n         PassMode::Ignore => smallvec![],\n         PassMode::Direct(_) => smallvec![arg.load_scalar(fx)],"}, {"sha": "c92c1051139542299ae933bbd904035e319a6307", "filename": "compiler/rustc_codegen_cranelift/src/archive.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -86,7 +86,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n \n         let mut entries = Vec::new();\n \n-        for (entry_name, entry) in self.entries {\n+        for (mut entry_name, entry) in self.entries {\n             // FIXME only read the symbol table of the object files to avoid having to keep all\n             // object files in memory at once, or read them twice.\n             let data = match entry {\n@@ -109,6 +109,23 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n             };\n \n             if !self.no_builtin_ranlib {\n+                if symbol_table.contains_key(&entry_name) {\n+                    // The ar crate can't handle creating a symbol table in case of multiple archive\n+                    // members with the same name. Work around this by prepending a number until we\n+                    // get a unique name.\n+                    for i in 1.. {\n+                        let new_name = format!(\"{}_\", i)\n+                            .into_bytes()\n+                            .into_iter()\n+                            .chain(entry_name.iter().copied())\n+                            .collect::<Vec<_>>();\n+                        if !symbol_table.contains_key(&new_name) {\n+                            entry_name = new_name;\n+                            break;\n+                        }\n+                    }\n+                }\n+\n                 match object::File::parse(&*data) {\n                     Ok(object) => {\n                         symbol_table.insert("}, {"sha": "122e103ff62bc14262a1b91a7e38d4e293bba6e4", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -175,10 +175,37 @@ fn compile_fn<'tcx>(\n         );\n     });\n \n+    #[cfg(any())] // This is never true\n+    let _clif_guard = {\n+        use std::fmt::Write;\n+\n+        let func_clone = context.func.clone();\n+        let clif_comments_clone = clif_comments.clone();\n+        let mut clif = String::new();\n+        for flag in module.isa().flags().iter() {\n+            writeln!(clif, \"set {}\", flag).unwrap();\n+        }\n+        write!(clif, \"target {}\", module.isa().triple().architecture.to_string()).unwrap();\n+        for isa_flag in module.isa().isa_flags().iter() {\n+            write!(clif, \" {}\", isa_flag).unwrap();\n+        }\n+        writeln!(clif, \"\\n\").unwrap();\n+        crate::PrintOnPanic(move || {\n+            let mut clif = clif.clone();\n+            ::cranelift_codegen::write::decorate_function(\n+                &mut &clif_comments_clone,\n+                &mut clif,\n+                &func_clone,\n+            )\n+            .unwrap();\n+            clif\n+        })\n+    };\n+\n     // Define function\n     tcx.sess.time(\"define function\", || {\n         context.want_disasm = crate::pretty_clif::should_write_ir(tcx);\n-        module.define_function(func_id, context).unwrap()\n+        module.define_function(func_id, context).unwrap();\n     });\n \n     // Write optimized function to file for debugging\n@@ -815,15 +842,7 @@ pub(crate) fn codegen_place<'tcx>(\n     for elem in place.projection {\n         match elem {\n             PlaceElem::Deref => {\n-                if cplace.layout().ty.is_box() {\n-                    cplace = cplace\n-                        .place_field(fx, Field::new(0)) // Box<T> -> Unique<T>\n-                        .place_field(fx, Field::new(0)) // Unique<T> -> NonNull<T>\n-                        .place_field(fx, Field::new(0)) // NonNull<T> -> *mut T\n-                        .place_deref(fx);\n-                } else {\n-                    cplace = cplace.place_deref(fx);\n-                }\n+                cplace = cplace.place_deref(fx);\n             }\n             PlaceElem::Field(field, _ty) => {\n                 cplace = cplace.place_field(fx, field);"}, {"sha": "bad5d1f08a9cf5454766b36de3f2614e5a6020a4", "filename": "compiler/rustc_codegen_cranelift/src/cast.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -149,17 +149,8 @@ pub(crate) fn clif_int_or_float_cast(\n         }\n \n         let is_not_nan = fx.bcx.ins().fcmp(FloatCC::Equal, from, from);\n-        if to_ty == types::I128 {\n-            // FIXME(bytecodealliance/wasmtime#3963): select.i128 on fcmp eq miscompiles\n-            let (lsb, msb) = fx.bcx.ins().isplit(val);\n-            let zero = fx.bcx.ins().iconst(types::I64, 0);\n-            let lsb = fx.bcx.ins().select(is_not_nan, lsb, zero);\n-            let msb = fx.bcx.ins().select(is_not_nan, msb, zero);\n-            fx.bcx.ins().iconcat(lsb, msb)\n-        } else {\n-            let zero = fx.bcx.ins().iconst(to_ty, 0);\n-            fx.bcx.ins().select(is_not_nan, val, zero)\n-        }\n+        let zero = fx.bcx.ins().iconst(to_ty, 0);\n+        fx.bcx.ins().select(is_not_nan, val, zero)\n     } else if from_ty.is_float() && to_ty.is_float() {\n         // float -> float\n         match (from_ty, to_ty) {"}, {"sha": "7f7fd0e9c579d17fb2d8a6fc7803c439bd7fc020", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -328,14 +328,18 @@ fn data_id_for_static(\n \n     let attrs = tcx.codegen_fn_attrs(def_id);\n \n-    let data_id = module\n-        .declare_data(\n-            &*symbol_name,\n-            linkage,\n-            is_mutable,\n-            attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL),\n-        )\n-        .unwrap();\n+    let data_id = match module.declare_data(\n+        &*symbol_name,\n+        linkage,\n+        is_mutable,\n+        attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL),\n+    ) {\n+        Ok(data_id) => data_id,\n+        Err(ModuleError::IncompatibleDeclaration(_)) => tcx.sess.fatal(&format!(\n+            \"attempt to declare `{symbol_name}` as static, but it was already declared as function\"\n+        )),\n+        Err(err) => Err::<_, _>(err).unwrap(),\n+    };\n \n     if rlinkage.is_some() {\n         // Comment copied from https://github.com/rust-lang/rust/blob/45060c2a66dfd667f88bd8b94261b28a58d85bd5/src/librustc_codegen_llvm/consts.rs#L141\n@@ -441,7 +445,8 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n             let data_id = match reloc_target_alloc {\n                 GlobalAlloc::Function(instance) => {\n                     assert_eq!(addend, 0);\n-                    let func_id = crate::abi::import_function(tcx, module, instance);\n+                    let func_id =\n+                        crate::abi::import_function(tcx, module, instance.polymorphize(tcx));\n                     let local_func_id = module.declare_func_in_data(func_id, &mut data_ctx);\n                     data_ctx.write_function_addr(offset.bytes() as u32, local_func_id);\n                     continue;"}, {"sha": "241de5e36530c8bbddb1bce99b2f4f2fe39fa23b", "filename": "compiler/rustc_codegen_cranelift/src/inline_asm.rs", "status": "modified", "additions": 90, "deletions": 80, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -18,86 +18,96 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n ) {\n     // FIXME add .eh_frame unwind info directives\n \n-    if template[0] == InlineAsmTemplatePiece::String(\"int $$0x29\".to_string()) {\n-        let true_ = fx.bcx.ins().iconst(types::I32, 1);\n-        fx.bcx.ins().trapnz(true_, TrapCode::User(1));\n-        return;\n-    } else if template[0] == InlineAsmTemplatePiece::String(\"movq %rbx, \".to_string())\n-        && matches!(\n-            template[1],\n-            InlineAsmTemplatePiece::Placeholder { operand_idx: 0, modifier: Some('r'), span: _ }\n-        )\n-        && template[2] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n-        && template[3] == InlineAsmTemplatePiece::String(\"cpuid\".to_string())\n-        && template[4] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n-        && template[5] == InlineAsmTemplatePiece::String(\"xchgq %rbx, \".to_string())\n-        && matches!(\n-            template[6],\n-            InlineAsmTemplatePiece::Placeholder { operand_idx: 0, modifier: Some('r'), span: _ }\n-        )\n-    {\n-        assert_eq!(operands.len(), 4);\n-        let (leaf, eax_place) = match operands[1] {\n-            InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n-                assert_eq!(\n-                    reg,\n-                    InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::ax))\n-                );\n-                (\n-                    crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n-                    crate::base::codegen_place(fx, out_place.unwrap()),\n-                )\n-            }\n-            _ => unreachable!(),\n-        };\n-        let ebx_place = match operands[0] {\n-            InlineAsmOperand::Out { reg, late: true, place } => {\n-                assert_eq!(\n-                    reg,\n-                    InlineAsmRegOrRegClass::RegClass(InlineAsmRegClass::X86(\n-                        X86InlineAsmRegClass::reg\n-                    ))\n-                );\n-                crate::base::codegen_place(fx, place.unwrap())\n-            }\n-            _ => unreachable!(),\n-        };\n-        let (sub_leaf, ecx_place) = match operands[2] {\n-            InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n-                assert_eq!(\n-                    reg,\n-                    InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::cx))\n-                );\n-                (\n-                    crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n-                    crate::base::codegen_place(fx, out_place.unwrap()),\n-                )\n-            }\n-            _ => unreachable!(),\n-        };\n-        let edx_place = match operands[3] {\n-            InlineAsmOperand::Out { reg, late: true, place } => {\n-                assert_eq!(\n-                    reg,\n-                    InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::dx))\n-                );\n-                crate::base::codegen_place(fx, place.unwrap())\n-            }\n-            _ => unreachable!(),\n-        };\n-\n-        let (eax, ebx, ecx, edx) = crate::intrinsics::codegen_cpuid_call(fx, leaf, sub_leaf);\n-\n-        eax_place.write_cvalue(fx, CValue::by_val(eax, fx.layout_of(fx.tcx.types.u32)));\n-        ebx_place.write_cvalue(fx, CValue::by_val(ebx, fx.layout_of(fx.tcx.types.u32)));\n-        ecx_place.write_cvalue(fx, CValue::by_val(ecx, fx.layout_of(fx.tcx.types.u32)));\n-        edx_place.write_cvalue(fx, CValue::by_val(edx, fx.layout_of(fx.tcx.types.u32)));\n-        return;\n-    } else if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") {\n-        // ___chkstk, ___chkstk_ms and __alloca are only used on Windows\n-        crate::trap::trap_unimplemented(fx, \"Stack probes are not supported\");\n-    } else if fx.tcx.symbol_name(fx.instance).name == \"__alloca\" {\n-        crate::trap::trap_unimplemented(fx, \"Alloca is not supported\");\n+    if !template.is_empty() {\n+        if template[0] == InlineAsmTemplatePiece::String(\"int $$0x29\".to_string()) {\n+            let true_ = fx.bcx.ins().iconst(types::I32, 1);\n+            fx.bcx.ins().trapnz(true_, TrapCode::User(1));\n+            return;\n+        } else if template[0] == InlineAsmTemplatePiece::String(\"movq %rbx, \".to_string())\n+            && matches!(\n+                template[1],\n+                InlineAsmTemplatePiece::Placeholder {\n+                    operand_idx: 0,\n+                    modifier: Some('r'),\n+                    span: _\n+                }\n+            )\n+            && template[2] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+            && template[3] == InlineAsmTemplatePiece::String(\"cpuid\".to_string())\n+            && template[4] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+            && template[5] == InlineAsmTemplatePiece::String(\"xchgq %rbx, \".to_string())\n+            && matches!(\n+                template[6],\n+                InlineAsmTemplatePiece::Placeholder {\n+                    operand_idx: 0,\n+                    modifier: Some('r'),\n+                    span: _\n+                }\n+            )\n+        {\n+            assert_eq!(operands.len(), 4);\n+            let (leaf, eax_place) = match operands[1] {\n+                InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n+                    assert_eq!(\n+                        reg,\n+                        InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::ax))\n+                    );\n+                    (\n+                        crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n+                        crate::base::codegen_place(fx, out_place.unwrap()),\n+                    )\n+                }\n+                _ => unreachable!(),\n+            };\n+            let ebx_place = match operands[0] {\n+                InlineAsmOperand::Out { reg, late: true, place } => {\n+                    assert_eq!(\n+                        reg,\n+                        InlineAsmRegOrRegClass::RegClass(InlineAsmRegClass::X86(\n+                            X86InlineAsmRegClass::reg\n+                        ))\n+                    );\n+                    crate::base::codegen_place(fx, place.unwrap())\n+                }\n+                _ => unreachable!(),\n+            };\n+            let (sub_leaf, ecx_place) = match operands[2] {\n+                InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n+                    assert_eq!(\n+                        reg,\n+                        InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::cx))\n+                    );\n+                    (\n+                        crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n+                        crate::base::codegen_place(fx, out_place.unwrap()),\n+                    )\n+                }\n+                _ => unreachable!(),\n+            };\n+            let edx_place = match operands[3] {\n+                InlineAsmOperand::Out { reg, late: true, place } => {\n+                    assert_eq!(\n+                        reg,\n+                        InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::dx))\n+                    );\n+                    crate::base::codegen_place(fx, place.unwrap())\n+                }\n+                _ => unreachable!(),\n+            };\n+\n+            let (eax, ebx, ecx, edx) = crate::intrinsics::codegen_cpuid_call(fx, leaf, sub_leaf);\n+\n+            eax_place.write_cvalue(fx, CValue::by_val(eax, fx.layout_of(fx.tcx.types.u32)));\n+            ebx_place.write_cvalue(fx, CValue::by_val(ebx, fx.layout_of(fx.tcx.types.u32)));\n+            ecx_place.write_cvalue(fx, CValue::by_val(ecx, fx.layout_of(fx.tcx.types.u32)));\n+            edx_place.write_cvalue(fx, CValue::by_val(edx, fx.layout_of(fx.tcx.types.u32)));\n+            return;\n+        } else if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") {\n+            // ___chkstk, ___chkstk_ms and __alloca are only used on Windows\n+            crate::trap::trap_unimplemented(fx, \"Stack probes are not supported\");\n+        } else if fx.tcx.symbol_name(fx.instance).name == \"__alloca\" {\n+            crate::trap::trap_unimplemented(fx, \"Alloca is not supported\");\n+        }\n     }\n \n     let mut inputs = Vec::new();"}, {"sha": "8d8db1da5818325eb55aeaf9acc6dd9f5e3c55f4", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -404,7 +404,9 @@ fn codegen_regular_intrinsic_call<'tcx>(\n         };\n         size_of_val, (c ptr) {\n             let layout = fx.layout_of(substs.type_at(0));\n-            let size = if layout.is_unsized() {\n+            // Note: Can't use is_unsized here as truly unsized types need to take the fixed size\n+            // branch\n+            let size = if let Abi::ScalarPair(_, _) = ptr.layout().abi {\n                 let (_ptr, info) = ptr.load_scalar_pair(fx);\n                 let (size, _align) = crate::unsize::size_and_align_of_dst(fx, layout, info);\n                 size\n@@ -418,7 +420,9 @@ fn codegen_regular_intrinsic_call<'tcx>(\n         };\n         min_align_of_val, (c ptr) {\n             let layout = fx.layout_of(substs.type_at(0));\n-            let align = if layout.is_unsized() {\n+            // Note: Can't use is_unsized here as truly unsized types need to take the fixed size\n+            // branch\n+            let align = if let Abi::ScalarPair(_, _) = ptr.layout().abi {\n                 let (_ptr, info) = ptr.load_scalar_pair(fx);\n                 let (_size, align) = crate::unsize::size_and_align_of_dst(fx, layout, info);\n                 align\n@@ -1145,6 +1149,20 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             // FIXME implement black_box semantics\n             ret.write_cvalue(fx, a);\n         };\n+\n+        // FIXME implement variadics in cranelift\n+        va_copy, (o _dest, o _src) {\n+            fx.tcx.sess.span_fatal(\n+                source_info.span,\n+                \"Defining variadic functions is not yet supported by Cranelift\",\n+            );\n+        };\n+        va_arg | va_end, (o _valist) {\n+            fx.tcx.sess.span_fatal(\n+                source_info.span,\n+                \"Defining variadic functions is not yet supported by Cranelift\",\n+            );\n+        };\n     }\n \n     let ret_block = fx.get_block(destination.unwrap());"}, {"sha": "568bb20a3f4a7614ab35b22a8931291695e824be", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -141,7 +141,11 @@ impl<'tcx> CodegenCx<'tcx> {\n \n         let unwind_context =\n             UnwindContext::new(isa, matches!(backend_config.codegen_mode, CodegenMode::Aot));\n-        let debug_context = if debug_info { Some(DebugContext::new(tcx, isa)) } else { None };\n+        let debug_context = if debug_info && !tcx.sess.target.options.is_like_windows {\n+            Some(DebugContext::new(tcx, isa))\n+        } else {\n+            None\n+        };\n         CodegenCx {\n             tcx,\n             global_asm: String::new(),\n@@ -243,6 +247,7 @@ fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Box<dyn isa::Tar\n     flags_builder.set(\"enable_probestack\", \"false\").unwrap(); // __cranelift_probestack is not provided\n     let enable_verifier = if backend_config.enable_verifier { \"true\" } else { \"false\" };\n     flags_builder.set(\"enable_verifier\", enable_verifier).unwrap();\n+    flags_builder.set(\"regalloc_checker\", enable_verifier).unwrap();\n \n     let tls_model = match target_triple.binary_format {\n         BinaryFormat::Elf => \"elf_gd\","}, {"sha": "c67b6e98b32c7daeeca8558ed2882f082cd0b103", "filename": "compiler/rustc_codegen_cranelift/src/main_shim.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -109,7 +109,8 @@ pub(crate) fn maybe_create_entry_wrapper(\n                     tcx.mk_substs([GenericArg::from(main_ret_ty)].iter()),\n                 )\n                 .unwrap()\n-                .unwrap();\n+                .unwrap()\n+                .polymorphize(tcx);\n \n                 let report_name = tcx.symbol_name(report).name;\n                 let report_sig = get_function_sig(tcx, m.isa().triple(), report);"}, {"sha": "1d1ec21680e30a7dc981c262b4fc7b172b12a013", "filename": "compiler/rustc_codegen_cranelift/src/pretty_clif.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -66,7 +66,7 @@ use rustc_session::config::OutputType;\n \n use crate::prelude::*;\n \n-#[derive(Debug)]\n+#[derive(Clone, Debug)]\n pub(crate) struct CommentWriter {\n     enabled: bool,\n     global_comments: Vec<String>,\n@@ -237,6 +237,7 @@ pub(crate) fn write_clif_file<'tcx>(\n     func: &cranelift_codegen::ir::Function,\n     mut clif_comments: &CommentWriter,\n ) {\n+    // FIXME work around filename too long errors\n     write_ir_file(\n         tcx,\n         || format!(\"{}.{}.clif\", tcx.symbol_name(instance).name, postfix),"}, {"sha": "052ca0a082b3c62261bea1e2d36a3a93936d84a4", "filename": "compiler/rustc_codegen_cranelift/src/unsize.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -153,11 +153,7 @@ pub(crate) fn size_and_align_of_dst<'tcx>(\n     layout: TyAndLayout<'tcx>,\n     info: Value,\n ) -> (Value, Value) {\n-    if !layout.is_unsized() {\n-        let size = fx.bcx.ins().iconst(fx.pointer_type, layout.size.bytes() as i64);\n-        let align = fx.bcx.ins().iconst(fx.pointer_type, layout.align.abi.bytes() as i64);\n-        return (size, align);\n-    }\n+    assert!(layout.is_unsized() || layout.abi == Abi::Uninhabited);\n     match layout.ty.kind() {\n         ty::Dynamic(..) => {\n             // load size/align from vtable"}, {"sha": "45ae2bd8f07cb1c28003790b49344db68481307d", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 50, "deletions": 7, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -324,6 +324,12 @@ impl<'tcx> CPlace<'tcx> {\n             };\n         }\n \n+        if layout.size.bytes() >= u64::from(u32::MAX - 16) {\n+            fx.tcx\n+                .sess\n+                .fatal(&format!(\"values of type {} are too big to store on the stack\", layout.ty));\n+        }\n+\n         let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n             kind: StackSlotKind::ExplicitSlot,\n             // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n@@ -420,7 +426,7 @@ impl<'tcx> CPlace<'tcx> {\n     }\n \n     pub(crate) fn write_cvalue(self, fx: &mut FunctionCx<'_, '_, 'tcx>, from: CValue<'tcx>) {\n-        assert_assignable(fx, from.layout().ty, self.layout().ty);\n+        assert_assignable(fx, from.layout().ty, self.layout().ty, 16);\n \n         self.write_cvalue_maybe_transmute(fx, from, \"write_cvalue\");\n     }\n@@ -774,18 +780,25 @@ pub(crate) fn assert_assignable<'tcx>(\n     fx: &FunctionCx<'_, '_, 'tcx>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n+    limit: usize,\n ) {\n+    if limit == 0 {\n+        // assert_assignable exists solely to catch bugs in cg_clif. it isn't necessary for\n+        // soundness. don't attempt to check deep types to avoid exponential behavior in certain\n+        // cases.\n+        return;\n+    }\n     match (from_ty.kind(), to_ty.kind()) {\n         (ty::Ref(_, a, _), ty::Ref(_, b, _))\n         | (\n             ty::RawPtr(TypeAndMut { ty: a, mutbl: _ }),\n             ty::RawPtr(TypeAndMut { ty: b, mutbl: _ }),\n         ) => {\n-            assert_assignable(fx, *a, *b);\n+            assert_assignable(fx, *a, *b, limit - 1);\n         }\n         (ty::Ref(_, a, _), ty::RawPtr(TypeAndMut { ty: b, mutbl: _ }))\n         | (ty::RawPtr(TypeAndMut { ty: a, mutbl: _ }), ty::Ref(_, b, _)) => {\n-            assert_assignable(fx, *a, *b);\n+            assert_assignable(fx, *a, *b, limit - 1);\n         }\n         (ty::FnPtr(_), ty::FnPtr(_)) => {\n             let from_sig = fx.tcx.normalize_erasing_late_bound_regions(\n@@ -815,25 +828,55 @@ pub(crate) fn assert_assignable<'tcx>(\n             }\n             // dyn for<'r> Trait<'r> -> dyn Trait<'_> is allowed\n         }\n+        (&ty::Tuple(types_a), &ty::Tuple(types_b)) => {\n+            let mut types_a = types_a.iter();\n+            let mut types_b = types_b.iter();\n+            loop {\n+                match (types_a.next(), types_b.next()) {\n+                    (Some(a), Some(b)) => assert_assignable(fx, a, b, limit - 1),\n+                    (None, None) => return,\n+                    (Some(_), None) | (None, Some(_)) => panic!(\"{:#?}/{:#?}\", from_ty, to_ty),\n+                }\n+            }\n+        }\n         (&ty::Adt(adt_def_a, substs_a), &ty::Adt(adt_def_b, substs_b))\n             if adt_def_a.did() == adt_def_b.did() =>\n         {\n             let mut types_a = substs_a.types();\n             let mut types_b = substs_b.types();\n             loop {\n                 match (types_a.next(), types_b.next()) {\n-                    (Some(a), Some(b)) => assert_assignable(fx, a, b),\n+                    (Some(a), Some(b)) => assert_assignable(fx, a, b, limit - 1),\n                     (None, None) => return,\n                     (Some(_), None) | (None, Some(_)) => panic!(\"{:#?}/{:#?}\", from_ty, to_ty),\n                 }\n             }\n         }\n-        (ty::Array(a, _), ty::Array(b, _)) => assert_assignable(fx, *a, *b),\n+        (ty::Array(a, _), ty::Array(b, _)) => assert_assignable(fx, *a, *b, limit - 1),\n+        (&ty::Closure(def_id_a, substs_a), &ty::Closure(def_id_b, substs_b))\n+            if def_id_a == def_id_b =>\n+        {\n+            let mut types_a = substs_a.types();\n+            let mut types_b = substs_b.types();\n+            loop {\n+                match (types_a.next(), types_b.next()) {\n+                    (Some(a), Some(b)) => assert_assignable(fx, a, b, limit - 1),\n+                    (None, None) => return,\n+                    (Some(_), None) | (None, Some(_)) => panic!(\"{:#?}/{:#?}\", from_ty, to_ty),\n+                }\n+            }\n+        }\n+        (ty::Param(_), _) | (_, ty::Param(_)) if fx.tcx.sess.opts.unstable_opts.polymorphize => {\n+            // No way to check if it is correct or not with polymorphization enabled\n+        }\n         _ => {\n             assert_eq!(\n-                from_ty, to_ty,\n+                from_ty,\n+                to_ty,\n                 \"Can't write value with incompatible type {:?} to place with type {:?}\\n\\n{:#?}\",\n-                from_ty, to_ty, fx,\n+                from_ty.kind(),\n+                to_ty.kind(),\n+                fx,\n             );\n         }\n     }"}, {"sha": "e06af1fac0699660dc6a13cb21a6e6b3ecc6d2d7", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -1883,7 +1883,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             exp_span, exp_found.expected, exp_found.found,\n         );\n \n-        if let ObligationCauseCode::CompareImplMethodObligation { .. } = cause.code() {\n+        if let ObligationCauseCode::CompareImplItemObligation { .. } = cause.code() {\n             return;\n         }\n \n@@ -2351,7 +2351,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             GenericKind::Projection(ref p) => format!(\"the associated type `{}`\", p),\n         };\n \n-        if let Some(SubregionOrigin::CompareImplMethodObligation {\n+        if let Some(SubregionOrigin::CompareImplItemObligation {\n             span,\n             impl_item_def_id,\n             trait_item_def_id,\n@@ -2788,8 +2788,15 @@ impl<'tcx> ObligationCauseExt<'tcx> for ObligationCause<'tcx> {\n         use self::FailureCode::*;\n         use crate::traits::ObligationCauseCode::*;\n         match self.code() {\n-            CompareImplMethodObligation { .. } => Error0308(\"method not compatible with trait\"),\n-            CompareImplTypeObligation { .. } => Error0308(\"type not compatible with trait\"),\n+            CompareImplItemObligation { kind: ty::AssocKind::Fn, .. } => {\n+                Error0308(\"method not compatible with trait\")\n+            }\n+            CompareImplItemObligation { kind: ty::AssocKind::Type, .. } => {\n+                Error0308(\"type not compatible with trait\")\n+            }\n+            CompareImplItemObligation { kind: ty::AssocKind::Const, .. } => {\n+                Error0308(\"const not compatible with trait\")\n+            }\n             MatchExpressionArm(box MatchExpressionArmCause { source, .. }) => {\n                 Error0308(match source {\n                     hir::MatchSource::TryDesugar => \"`?` operator has incompatible types\",\n@@ -2823,8 +2830,15 @@ impl<'tcx> ObligationCauseExt<'tcx> for ObligationCause<'tcx> {\n     fn as_requirement_str(&self) -> &'static str {\n         use crate::traits::ObligationCauseCode::*;\n         match self.code() {\n-            CompareImplMethodObligation { .. } => \"method type is compatible with trait\",\n-            CompareImplTypeObligation { .. } => \"associated type is compatible with trait\",\n+            CompareImplItemObligation { kind: ty::AssocKind::Fn, .. } => {\n+                \"method type is compatible with trait\"\n+            }\n+            CompareImplItemObligation { kind: ty::AssocKind::Type, .. } => {\n+                \"associated type is compatible with trait\"\n+            }\n+            CompareImplItemObligation { kind: ty::AssocKind::Const, .. } => {\n+                \"const is compatible with trait\"\n+            }\n             ExprAssignable => \"expression is assignable\",\n             IfExpression { .. } => \"`if` and `else` have incompatible types\",\n             IfExpressionWithNoElse => \"`if` missing an `else` returns `()`\","}, {"sha": "da465a764299270ec845383fc8547f869631bef8", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 17, "deletions": 52, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -2,17 +2,17 @@\n \n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n-use crate::infer::{SubregionOrigin, Subtype};\n-use crate::traits::ObligationCauseCode::CompareImplMethodObligation;\n+use crate::infer::Subtype;\n+use crate::traits::ObligationCauseCode::CompareImplItemObligation;\n use rustc_errors::{ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::print::RegionHighlightMode;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeSuperVisitable, TypeVisitor};\n-use rustc_span::{Span, Symbol};\n+use rustc_span::Span;\n \n use std::ops::ControlFlow;\n \n@@ -22,38 +22,22 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let error = self.error.as_ref()?;\n         debug!(\"try_report_impl_not_conforming_to_trait {:?}\", error);\n         if let RegionResolutionError::SubSupConflict(\n-                _, var_origin, sub_origin, _sub, sup_origin, _sup, _,\n+                _,\n+                var_origin,\n+                sub_origin,\n+                _sub,\n+                sup_origin,\n+                _sup,\n+                _,\n             ) = error.clone()\n-            && let (&Subtype(ref sup_trace), &Subtype(ref sub_trace)) = (&sup_origin, &sub_origin)\n-            && let (\n-                sub_expected_found @ Some((sub_expected, sub_found)),\n-                sup_expected_found @ Some(_),\n-                CompareImplMethodObligation { trait_item_def_id, .. },\n-            ) = (sub_trace.values.ty(), sup_trace.values.ty(), sub_trace.cause.code())\n+            && let (Subtype(sup_trace), Subtype(sub_trace)) = (&sup_origin, &sub_origin)\n+            && let sub_expected_found @ Some((sub_expected, sub_found)) = sub_trace.values.ty()\n+            && let sup_expected_found @ Some(_) = sup_trace.values.ty()\n+            && let CompareImplItemObligation { trait_item_def_id, .. } = sub_trace.cause.code()\n             && sup_expected_found == sub_expected_found\n         {\n-            let guar = self.emit_err(\n-                var_origin.span(),\n-                sub_expected,\n-                sub_found,\n-                *trait_item_def_id,\n-            );\n-            return Some(guar);\n-        }\n-        if let RegionResolutionError::ConcreteFailure(origin, _, _)\n-            | RegionResolutionError::GenericBoundFailure(origin, _, _) = error.clone()\n-            && let SubregionOrigin::CompareImplTypeObligation {\n-                span,\n-                impl_item_def_id,\n-                trait_item_def_id,\n-            } = origin\n-        {\n-            let guar = self.emit_associated_type_err(\n-                span,\n-                self.infcx.tcx.item_name(impl_item_def_id.to_def_id()),\n-                impl_item_def_id,\n-                trait_item_def_id,\n-            );\n+            let guar =\n+                self.emit_err(var_origin.span(), sub_expected, sub_found, *trait_item_def_id);\n             return Some(guar);\n         }\n         None\n@@ -147,25 +131,6 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         }\n         err.emit()\n     }\n-\n-    fn emit_associated_type_err(\n-        &self,\n-        span: Span,\n-        item_name: Symbol,\n-        impl_item_def_id: LocalDefId,\n-        trait_item_def_id: DefId,\n-    ) -> ErrorGuaranteed {\n-        let impl_sp = self.tcx().def_span(impl_item_def_id);\n-        let trait_sp = self.tcx().def_span(trait_item_def_id);\n-        let mut err = self\n-            .tcx()\n-            .sess\n-            .struct_span_err(span, &format!(\"`impl` associated type signature for `{}` doesn't match `trait` associated type signature\", item_name));\n-        err.span_label(impl_sp, \"found\");\n-        err.span_label(trait_sp, \"expected\");\n-\n-        err.emit()\n-    }\n }\n \n struct TypeParamSpanVisitor<'tcx> {"}, {"sha": "c1940c5c0824a3e096f40f61e0622f0b1cbe6015", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -86,13 +86,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"...so that the declared lifetime parameter bounds are satisfied\",\n                 );\n             }\n-            infer::CompareImplMethodObligation { span, .. } => {\n-                label_or_note(\n-                    span,\n-                    \"...so that the definition in impl matches the definition from the trait\",\n-                );\n-            }\n-            infer::CompareImplTypeObligation { span, .. } => {\n+            infer::CompareImplItemObligation { span, .. } => {\n                 label_or_note(\n                     span,\n                     \"...so that the definition in impl matches the definition from the trait\",\n@@ -329,15 +323,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 );\n                 err\n             }\n-            infer::CompareImplMethodObligation { span, impl_item_def_id, trait_item_def_id } => {\n-                self.report_extra_impl_obligation(\n-                    span,\n-                    impl_item_def_id,\n-                    trait_item_def_id,\n-                    &format!(\"`{}: {}`\", sup, sub),\n-                )\n-            }\n-            infer::CompareImplTypeObligation { span, impl_item_def_id, trait_item_def_id } => self\n+            infer::CompareImplItemObligation { span, impl_item_def_id, trait_item_def_id } => self\n                 .report_extra_impl_obligation(\n                     span,\n                     impl_item_def_id,"}, {"sha": "5e7c0661728aaa4ea9c8a92dd796ed17cab8dcdd", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -405,15 +405,7 @@ pub enum SubregionOrigin<'tcx> {\n \n     /// Comparing the signature and requirements of an impl method against\n     /// the containing trait.\n-    CompareImplMethodObligation {\n-        span: Span,\n-        impl_item_def_id: LocalDefId,\n-        trait_item_def_id: DefId,\n-    },\n-\n-    /// Comparing the signature and requirements of an impl associated type\n-    /// against the containing trait\n-    CompareImplTypeObligation { span: Span, impl_item_def_id: LocalDefId, trait_item_def_id: DefId },\n+    CompareImplItemObligation { span: Span, impl_item_def_id: LocalDefId, trait_item_def_id: DefId },\n \n     /// Checking that the bounds of a trait's associated type hold for a given impl\n     CheckAssociatedTypeBounds {\n@@ -1945,8 +1937,7 @@ impl<'tcx> SubregionOrigin<'tcx> {\n             ReborrowUpvar(a, _) => a,\n             DataBorrowed(_, a) => a,\n             ReferenceOutlivesReferent(_, a) => a,\n-            CompareImplMethodObligation { span, .. } => span,\n-            CompareImplTypeObligation { span, .. } => span,\n+            CompareImplItemObligation { span, .. } => span,\n             CheckAssociatedTypeBounds { ref parent, .. } => parent.span(),\n         }\n     }\n@@ -1960,19 +1951,11 @@ impl<'tcx> SubregionOrigin<'tcx> {\n                 SubregionOrigin::ReferenceOutlivesReferent(ref_type, cause.span)\n             }\n \n-            traits::ObligationCauseCode::CompareImplMethodObligation {\n-                impl_item_def_id,\n-                trait_item_def_id,\n-            } => SubregionOrigin::CompareImplMethodObligation {\n-                span: cause.span,\n-                impl_item_def_id,\n-                trait_item_def_id,\n-            },\n-\n-            traits::ObligationCauseCode::CompareImplTypeObligation {\n+            traits::ObligationCauseCode::CompareImplItemObligation {\n                 impl_item_def_id,\n                 trait_item_def_id,\n-            } => SubregionOrigin::CompareImplTypeObligation {\n+                kind: _,\n+            } => SubregionOrigin::CompareImplItemObligation {\n                 span: cause.span,\n                 impl_item_def_id,\n                 trait_item_def_id,"}, {"sha": "72b848c3ee2dd150728d09ba9a05e1d556597b2a", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -311,18 +311,10 @@ pub enum ObligationCauseCode<'tcx> {\n     },\n \n     /// Error derived when matching traits/impls; see ObligationCause for more details\n-    CompareImplConstObligation,\n-\n-    /// Error derived when matching traits/impls; see ObligationCause for more details\n-    CompareImplMethodObligation {\n-        impl_item_def_id: LocalDefId,\n-        trait_item_def_id: DefId,\n-    },\n-\n-    /// Error derived when matching traits/impls; see ObligationCause for more details\n-    CompareImplTypeObligation {\n+    CompareImplItemObligation {\n         impl_item_def_id: LocalDefId,\n         trait_item_def_id: DefId,\n+        kind: ty::AssocKind,\n     },\n \n     /// Checking that the bounds of a trait's associated type hold for a given impl"}, {"sha": "eb732148e3eb4ad7f1122de80a3799d3cbe27318", "filename": "compiler/rustc_middle/src/ty/assoc.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -105,6 +105,16 @@ impl AssocKind {\n     }\n }\n \n+impl std::fmt::Display for AssocKind {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            AssocKind::Fn => write!(f, \"method\"),\n+            AssocKind::Const => write!(f, \"associated const\"),\n+            AssocKind::Type => write!(f, \"associated type\"),\n+        }\n+    }\n+}\n+\n /// A list of `ty::AssocItem`s in definition order that allows for efficient lookup by name.\n ///\n /// When doing lookup by name, we try to postpone hygienic comparison for as long as possible since"}, {"sha": "91246051316fa42ec6cb440f78323913af29e240", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -660,12 +660,8 @@ impl<T> Trait<T> for X {\n                     | hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }),\n             )\n         );\n-        let impl_comparison = matches!(\n-            cause_code,\n-            ObligationCauseCode::CompareImplMethodObligation { .. }\n-                | ObligationCauseCode::CompareImplTypeObligation { .. }\n-                | ObligationCauseCode::CompareImplConstObligation\n-        );\n+        let impl_comparison =\n+            matches!(cause_code, ObligationCauseCode::CompareImplItemObligation { .. });\n         let assoc = self.associated_item(proj_ty.item_def_id);\n         if !callable_scope || impl_comparison {\n             // We do not want to suggest calling functions when the reason of the"}, {"sha": "7660a2f3af60a51c64a374fb35a374e1bdccc665", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -224,6 +224,7 @@ TrivialTypeTraversalAndLiftImpls! {\n     // general `Region`.\n     crate::ty::BoundRegionKind,\n     crate::ty::AssocItem,\n+    crate::ty::AssocKind,\n     crate::ty::Placeholder<crate::ty::BoundRegionKind>,\n     crate::ty::ClosureKind,\n     crate::ty::FreeRegion,"}, {"sha": "3435f127c72e2420306ef0895b5cdf9dbd7ee30a", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -951,7 +951,7 @@ fn adt_defined_here<'p, 'tcx>(\n         let mut span: MultiSpan =\n             if spans.is_empty() { def_span.into() } else { spans.clone().into() };\n \n-        span.push_span_label(def_span, String::new());\n+        span.push_span_label(def_span, \"\");\n         for pat in spans {\n             span.push_span_label(pat, \"not covered\");\n         }"}, {"sha": "180f4c7dcd6e80d1a1dac8e1c0f7c0623147ebff", "filename": "compiler/rustc_mir_transform/src/simplify.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -315,7 +315,7 @@ pub fn remove_dead_blocks<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n /// with `0` executions.\n ///\n /// If there are no live `Counter` `Coverage` statements remaining, we remove\n-/// dead `Coverage` statements along with the dead blocks. Since at least one\n+/// `Coverage` statements along with the dead blocks. Since at least one\n /// counter per function is required by LLVM (and necessary, to add the\n /// `function_hash` to the counter's call to the LLVM intrinsic\n /// `instrprof.increment()`).\n@@ -342,6 +342,16 @@ fn save_unreachable_coverage(\n         }\n     }\n \n+    for block in &mut basic_blocks.raw[..first_dead_block] {\n+        for statement in &mut block.statements {\n+            let StatementKind::Coverage(_) = &statement.kind else { continue };\n+            let instance = statement.source_info.scope.inlined_instance(source_scopes);\n+            if !live.contains(&instance) {\n+                statement.make_nop();\n+            }\n+        }\n+    }\n+\n     if live.is_empty() {\n         return;\n     }"}, {"sha": "8a655cbf3845ad68a182ec1578b86f1e4a48cd1c", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -565,8 +565,7 @@ impl<'a> Resolver<'a> {\n                     } else if let Some(sp) = sm.generate_fn_name_span(span) {\n                         err.span_label(\n                             sp,\n-                            \"try adding a local generic parameter in this method instead\"\n-                                .to_string(),\n+                            \"try adding a local generic parameter in this method instead\",\n                         );\n                     } else {\n                         err.help(\"try using a local generic parameter instead\");"}, {"sha": "47159584afe3b3780f7113fa748e0a6a1ad7e36f", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -586,17 +586,6 @@ impl SourceMap {\n         }\n     }\n \n-    /// Returns whether or not this span points into a file\n-    /// in the current crate. This may be `false` for spans\n-    /// produced by a macro expansion, or for spans associated\n-    /// with the definition of an item in a foreign crate\n-    pub fn is_local_span(&self, sp: Span) -> bool {\n-        let local_begin = self.lookup_byte_offset(sp.lo());\n-        let local_end = self.lookup_byte_offset(sp.hi());\n-        // This might be a weird span that covers multiple files\n-        local_begin.sf.src.is_some() && local_end.sf.src.is_some()\n-    }\n-\n     pub fn is_span_accessible(&self, sp: Span) -> bool {\n         self.span_to_source(sp, |src, start_index, end_index| {\n             Ok(src.get(start_index..end_index).is_some())"}, {"sha": "41c5087c43d42a15c5dd2ffc9d5b664bb352d76a", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -301,13 +301,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         span = obligation.cause.span;\n                     }\n                 }\n-                if let ObligationCauseCode::CompareImplMethodObligation {\n-                    impl_item_def_id,\n-                    trait_item_def_id,\n-                }\n-                | ObligationCauseCode::CompareImplTypeObligation {\n+                if let ObligationCauseCode::CompareImplItemObligation {\n                     impl_item_def_id,\n                     trait_item_def_id,\n+                    kind: _,\n                 } = *obligation.cause.code()\n                 {\n                     self.report_extra_impl_obligation("}, {"sha": "89d7c050c408bc757fbf9ef9d277f41e0c39fe60", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 4, "deletions": 36, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -2682,11 +2682,11 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     )\n                 });\n             }\n-            ObligationCauseCode::CompareImplMethodObligation { trait_item_def_id, .. } => {\n+            ObligationCauseCode::CompareImplItemObligation { trait_item_def_id, kind, .. } => {\n                 let item_name = self.tcx.item_name(trait_item_def_id);\n                 let msg = format!(\n-                    \"the requirement `{}` appears on the impl method `{}` but not on the \\\n-                     corresponding trait method\",\n+                    \"the requirement `{}` appears on the `impl`'s {kind} `{}` but not on the \\\n+                     corresponding trait's {kind}\",\n                     predicate, item_name,\n                 );\n                 let sp = self\n@@ -2697,7 +2697,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 let mut assoc_span: MultiSpan = sp.into();\n                 assoc_span.push_span_label(\n                     sp,\n-                    format!(\"this trait method doesn't have the requirement `{}`\", predicate),\n+                    format!(\"this trait's {kind} doesn't have the requirement `{}`\", predicate),\n                 );\n                 if let Some(ident) = self\n                     .tcx\n@@ -2708,38 +2708,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 }\n                 err.span_note(assoc_span, &msg);\n             }\n-            ObligationCauseCode::CompareImplTypeObligation { trait_item_def_id, .. } => {\n-                let item_name = self.tcx.item_name(trait_item_def_id);\n-                let msg = format!(\n-                    \"the requirement `{}` appears on the associated impl type `{}` but not on the \\\n-                     corresponding associated trait type\",\n-                    predicate, item_name,\n-                );\n-                let sp = self.tcx.def_span(trait_item_def_id);\n-                let mut assoc_span: MultiSpan = sp.into();\n-                assoc_span.push_span_label(\n-                    sp,\n-                    format!(\n-                        \"this trait associated type doesn't have the requirement `{}`\",\n-                        predicate,\n-                    ),\n-                );\n-                if let Some(ident) = self\n-                    .tcx\n-                    .opt_associated_item(trait_item_def_id)\n-                    .and_then(|i| self.tcx.opt_item_ident(i.container.id()))\n-                {\n-                    assoc_span.push_span_label(ident.span, \"in this trait\");\n-                }\n-                err.span_note(assoc_span, &msg);\n-            }\n-            ObligationCauseCode::CompareImplConstObligation => {\n-                err.note(&format!(\n-                    \"the requirement `{}` appears on the associated impl constant \\\n-                     but not on the corresponding associated trait constant\",\n-                    predicate\n-                ));\n-            }\n             ObligationCauseCode::TrivialBound => {\n                 err.help(\"see issue #48214\");\n                 if tcx.sess.opts.unstable_features.is_nightly_build() {"}, {"sha": "99a8101dc96ba3b60239fc167345fed08b70ab67", "filename": "compiler/rustc_typeck/src/astconv/errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Ferrors.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::ty;\n use rustc_session::parse::feature_err;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{sym, Ident};\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::{Span, Symbol, DUMMY_SP};\n \n use std::collections::BTreeSet;\n \n@@ -17,7 +17,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// the type parameter's name as a placeholder.\n     pub(crate) fn complain_about_missing_type_params(\n         &self,\n-        missing_type_params: Vec<String>,\n+        missing_type_params: Vec<Symbol>,\n         def_id: DefId,\n         span: Span,\n         empty_generic_args: bool,"}, {"sha": "58f4f02052f8bd64a7c9d964311fb73263a5e32a", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -382,7 +382,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             def_id: DefId,\n             generic_args: &'a GenericArgs<'a>,\n             span: Span,\n-            missing_type_params: Vec<String>,\n+            missing_type_params: Vec<Symbol>,\n             inferred_params: Vec<Span>,\n             infer_args: bool,\n             is_object: bool,\n@@ -514,7 +514,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             // defaults. This will lead to an ICE if we are not\n                             // careful!\n                             if self.default_needs_object_self(param) {\n-                                self.missing_type_params.push(param.name.to_string());\n+                                self.missing_type_params.push(param.name);\n                                 tcx.ty_error().into()\n                             } else {\n                                 // This is a default type parameter.\n@@ -1150,17 +1150,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .expect(\"missing associated type\");\n \n         if !assoc_item.vis.is_accessible_from(def_scope, tcx) {\n-            let kind = match assoc_item.kind {\n-                ty::AssocKind::Type => \"type\",\n-                ty::AssocKind::Const => \"const\",\n-                _ => unreachable!(),\n-            };\n             tcx.sess\n                 .struct_span_err(\n                     binding.span,\n-                    &format!(\"associated {kind} `{}` is private\", binding.item_name),\n+                    &format!(\"{} `{}` is private\", assoc_item.kind, binding.item_name),\n                 )\n-                .span_label(binding.span, &format!(\"private associated {kind}\"))\n+                .span_label(binding.span, &format!(\"private {}\", assoc_item.kind))\n                 .emit();\n         }\n         tcx.check_stability(assoc_item.def_id, Some(hir_ref_id), binding.span, None);"}, {"sha": "147d87e7594c5be5e06d977087e65ba85dfea8ad", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -488,17 +488,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 ty::Binder::dummy(ty::PredicateKind::Trait(ty::TraitPredicate {\n                                     trait_ref: ty::TraitRef {\n                                         def_id: t.def_id(),\n-                                        substs: self.infcx.tcx.mk_substs_trait(outer_ty, &[]),\n+                                        substs: self.tcx.mk_substs_trait(outer_ty, &[]),\n                                     },\n                                     constness: t.constness,\n                                     polarity: t.polarity,\n                                 }));\n                             let obl = Obligation::new(\n                                 o.cause.clone(),\n                                 self.param_env,\n-                                pred.to_predicate(self.infcx.tcx),\n+                                pred.to_predicate(self.tcx),\n                             );\n-                            suggest_box &= self.infcx.predicate_must_hold_modulo_regions(&obl);\n+                            suggest_box &= self.predicate_must_hold_modulo_regions(&obl);\n                             if !suggest_box {\n                                 // We've encountered some obligation that didn't hold, so the\n                                 // return expression can't just be boxed. We don't need to"}, {"sha": "0836f15a1221bf27e2f2eb285bbd1c9dc13c4939", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -376,7 +376,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             self.param_env,\n                             *predicate,\n                         );\n-                        let result = self.infcx.evaluate_obligation(&obligation);\n+                        let result = self.evaluate_obligation(&obligation);\n                         self.tcx\n                             .sess\n                             .struct_span_err("}, {"sha": "fee872155f5b2d1fa86c3ca4958a8c5d0384ce3a", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -96,7 +96,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.tcx.typeck_root_def_id(expr_def_id.to_def_id()),\n         );\n \n-        let tupled_upvars_ty = self.infcx.next_ty_var(TypeVariableOrigin {\n+        let tupled_upvars_ty = self.next_ty_var(TypeVariableOrigin {\n             kind: TypeVariableOriginKind::ClosureSynthetic,\n             span: self.tcx.hir().span(expr.hir_id),\n         });\n@@ -141,7 +141,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // Create a type variable (for now) to represent the closure kind.\n             // It will be unified during the upvar inference phase (`upvar.rs`)\n-            None => self.infcx.next_ty_var(TypeVariableOrigin {\n+            None => self.next_ty_var(TypeVariableOrigin {\n                 // FIXME(eddyb) distinguish closure kind inference variables from the rest.\n                 kind: TypeVariableOriginKind::ClosureSynthetic,\n                 span: expr.span,\n@@ -531,7 +531,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         //\n         // [c1]: https://github.com/rust-lang/rust/pull/45072#issuecomment-341089706\n         // [c2]: https://github.com/rust-lang/rust/pull/45072#issuecomment-341096796\n-        self.infcx.commit_if_ok(|_| {\n+        self.commit_if_ok(|_| {\n             let mut all_obligations = vec![];\n \n             // The liberated version of this signature should be a subtype\n@@ -544,7 +544,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 expected_sigs.liberated_sig.inputs(), // `liberated_sig` is E'.\n             ) {\n                 // Instantiate (this part of..) S to S', i.e., with fresh variables.\n-                let supplied_ty = self.infcx.replace_bound_vars_with_fresh_vars(\n+                let supplied_ty = self.replace_bound_vars_with_fresh_vars(\n                     hir_ty.span,\n                     LateBoundRegionConversionTime::FnCall,\n                     supplied_sig.inputs().rebind(supplied_ty),\n@@ -557,7 +557,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 all_obligations.extend(obligations);\n             }\n \n-            let supplied_output_ty = self.infcx.replace_bound_vars_with_fresh_vars(\n+            let supplied_output_ty = self.replace_bound_vars_with_fresh_vars(\n                 decl.output.span(),\n                 LateBoundRegionConversionTime::FnCall,\n                 supplied_sig.output(),"}, {"sha": "639cab98f1741f02175482d65b658417c12cb8e0", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -241,13 +241,13 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         make_adjustments: impl FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>,\n     ) -> CoerceResult<'tcx> {\n         debug!(\"coerce_from_inference_variable(a={:?}, b={:?})\", a, b);\n-        assert!(a.is_ty_var() && self.infcx.shallow_resolve(a) == a);\n-        assert!(self.infcx.shallow_resolve(b) == b);\n+        assert!(a.is_ty_var() && self.shallow_resolve(a) == a);\n+        assert!(self.shallow_resolve(b) == b);\n \n         if b.is_ty_var() {\n             // Two unresolved type variables: create a `Coerce` predicate.\n             let target_ty = if self.use_lub {\n-                self.infcx.next_ty_var(TypeVariableOrigin {\n+                self.next_ty_var(TypeVariableOrigin {\n                     kind: TypeVariableOriginKind::LatticeVariable,\n                     span: self.cause.span,\n                 })\n@@ -991,7 +991,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.autoderef(rustc_span::DUMMY_SP, expr_ty).nth(1).and_then(|(deref_ty, _)| {\n             self.infcx\n                 .type_implements_trait(\n-                    self.infcx.tcx.lang_items().deref_mut_trait()?,\n+                    self.tcx.lang_items().deref_mut_trait()?,\n                     expr_ty,\n                     ty::List::empty(),\n                     self.param_env,"}, {"sha": "af77efc3c2d57434692c14e091bf1605358c0d10", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -90,9 +90,10 @@ fn compare_predicate_entailment<'tcx>(\n     let mut cause = ObligationCause::new(\n         impl_m_span,\n         impl_m_hir_id,\n-        ObligationCauseCode::CompareImplMethodObligation {\n+        ObligationCauseCode::CompareImplItemObligation {\n             impl_item_def_id: impl_m.def_id.expect_local(),\n             trait_item_def_id: trait_m.def_id,\n+            kind: impl_m.kind,\n         },\n     );\n \n@@ -223,9 +224,10 @@ fn compare_predicate_entailment<'tcx>(\n             let cause = ObligationCause::new(\n                 span,\n                 impl_m_hir_id,\n-                ObligationCauseCode::CompareImplMethodObligation {\n+                ObligationCauseCode::CompareImplItemObligation {\n                     impl_item_def_id: impl_m.def_id.expect_local(),\n                     trait_item_def_id: trait_m.def_id,\n+                    kind: impl_m.kind,\n                 },\n             );\n             ocx.register_obligation(traits::Obligation::new(cause, param_env, predicate));\n@@ -1079,7 +1081,11 @@ pub(crate) fn compare_const_impl<'tcx>(\n         let mut cause = ObligationCause::new(\n             impl_c_span,\n             impl_c_hir_id,\n-            ObligationCauseCode::CompareImplConstObligation,\n+            ObligationCauseCode::CompareImplItemObligation {\n+                impl_item_def_id: impl_c.def_id.expect_local(),\n+                trait_item_def_id: trait_c.def_id,\n+                kind: impl_c.kind,\n+            },\n         );\n \n         // There is no \"body\" here, so just pass dummy id.\n@@ -1212,15 +1218,6 @@ fn compare_type_predicate_entailment<'tcx>(\n     // `ObligationCause` (and the `FnCtxt`). This is what\n     // `regionck_item` expects.\n     let impl_ty_hir_id = tcx.hir().local_def_id_to_hir_id(impl_ty.def_id.expect_local());\n-    let cause = ObligationCause::new(\n-        impl_ty_span,\n-        impl_ty_hir_id,\n-        ObligationCauseCode::CompareImplTypeObligation {\n-            impl_item_def_id: impl_ty.def_id.expect_local(),\n-            trait_item_def_id: trait_ty.def_id,\n-        },\n-    );\n-\n     debug!(\"compare_type_predicate_entailment: trait_to_impl_substs={:?}\", trait_to_impl_substs);\n \n     // The predicates declared by the impl definition, the trait and the\n@@ -1239,20 +1236,33 @@ fn compare_type_predicate_entailment<'tcx>(\n         Reveal::UserFacing,\n         hir::Constness::NotConst,\n     );\n-    let param_env = traits::normalize_param_env_or_error(tcx, param_env, normalize_cause.clone());\n+    let param_env = traits::normalize_param_env_or_error(tcx, param_env, normalize_cause);\n     tcx.infer_ctxt().enter(|infcx| {\n         let ocx = ObligationCtxt::new(&infcx);\n \n         debug!(\"compare_type_predicate_entailment: caller_bounds={:?}\", param_env.caller_bounds());\n \n         let mut selcx = traits::SelectionContext::new(&infcx);\n \n-        for predicate in impl_ty_own_bounds.predicates {\n+        assert_eq!(impl_ty_own_bounds.predicates.len(), impl_ty_own_bounds.spans.len());\n+        for (span, predicate) in\n+            std::iter::zip(impl_ty_own_bounds.spans, impl_ty_own_bounds.predicates)\n+        {\n+            let cause = ObligationCause::misc(span, impl_ty_hir_id);\n             let traits::Normalized { value: predicate, obligations } =\n-                traits::normalize(&mut selcx, param_env, normalize_cause.clone(), predicate);\n+                traits::normalize(&mut selcx, param_env, cause, predicate);\n \n+            let cause = ObligationCause::new(\n+                span,\n+                impl_ty_hir_id,\n+                ObligationCauseCode::CompareImplItemObligation {\n+                    impl_item_def_id: impl_ty.def_id.expect_local(),\n+                    trait_item_def_id: trait_ty.def_id,\n+                    kind: impl_ty.kind,\n+                },\n+            );\n             ocx.register_obligations(obligations);\n-            ocx.register_obligation(traits::Obligation::new(cause.clone(), param_env, predicate));\n+            ocx.register_obligation(traits::Obligation::new(cause, param_env, predicate));\n         }\n \n         // Check that all obligations are satisfied by the implementation's"}, {"sha": "58b0399c5c927cab49c64ef1ba9d3641434b7975", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -287,6 +287,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr_ty: Ty<'tcx>,\n     ) {\n         if let ty::Adt(expected_adt, substs) = expected.kind() {\n+            if let hir::ExprKind::Field(base, ident) = expr.kind {\n+                let base_ty = self.typeck_results.borrow().expr_ty(base);\n+                if self.can_eq(self.param_env, base_ty, expected).is_ok()\n+                    && let Some(base_span) = base.span.find_ancestor_inside(expr.span)\n+                {\n+                    err.span_suggestion_verbose(\n+                        expr.span.with_lo(base_span.hi()),\n+                        format!(\"consider removing the tuple struct field `{ident}`\"),\n+                        \"\",\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    return\n+                }\n+            }\n+\n             // If the expression is of type () and it's the return expression of a block,\n             // we suggest adding a separate return expression instead.\n             // (To avoid things like suggesting `Ok(while .. { .. })`.)\n@@ -815,7 +830,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, ref expr),\n                 _,\n                 &ty::Ref(_, checked, _),\n-            ) if self.infcx.can_sub(self.param_env, checked, expected).is_ok() => {\n+            ) if self.can_sub(self.param_env, checked, expected).is_ok() => {\n                 // We have `&T`, check if what was expected was `T`. If so,\n                 // we may want to suggest removing a `&`.\n                 if sm.is_imported(expr.span) {\n@@ -959,7 +974,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                     // For this suggestion to make sense, the type would need to be `Copy`,\n                     // or we have to be moving out of a `Box<T>`\n-                    if self.infcx.type_is_copy_modulo_regions(self.param_env, expected, sp)\n+                    if self.type_is_copy_modulo_regions(self.param_env, expected, sp)\n                         // FIXME(compiler-errors): We can actually do this if the checked_ty is\n                         // `steps` layers of boxes, not just one, but this is easier and most likely.\n                         || (checked_ty.is_box() && steps == 1)"}, {"sha": "ba5ef5edc8630cd803cbe4379652e48f992ef578", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -2235,7 +2235,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         base: &'tcx hir::Expr<'tcx>,\n         ty: Ty<'tcx>,\n     ) {\n-        let output_ty = match self.infcx.get_impl_future_output_ty(ty) {\n+        let output_ty = match self.get_impl_future_output_ty(ty) {\n             Some(output_ty) => self.resolve_vars_if_possible(output_ty),\n             _ => return,\n         };"}, {"sha": "4059b3403b19fe4851db0658c6d1fe870b8a9a3d", "filename": "compiler/rustc_typeck/src/check/fallback.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffallback.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -218,9 +218,9 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             .diverging_type_vars\n             .borrow()\n             .iter()\n-            .map(|&ty| self.infcx.shallow_resolve(ty))\n+            .map(|&ty| self.shallow_resolve(ty))\n             .filter_map(|ty| ty.ty_vid())\n-            .map(|vid| self.infcx.root_var(vid))\n+            .map(|vid| self.root_var(vid))\n             .collect();\n         debug!(\n             \"calculate_diverging_fallback: diverging_type_vars={:?}\",\n@@ -236,7 +236,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         let mut diverging_vids = vec![];\n         let mut non_diverging_vids = vec![];\n         for unsolved_vid in unsolved_vids {\n-            let root_vid = self.infcx.root_var(unsolved_vid);\n+            let root_vid = self.root_var(unsolved_vid);\n             debug!(\n                 \"calculate_diverging_fallback: unsolved_vid={:?} root_vid={:?} diverges={:?}\",\n                 unsolved_vid,\n@@ -271,7 +271,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         // variables. (Note that this set consists of \"root variables\".)\n         let mut roots_reachable_from_non_diverging = DepthFirstSearch::new(&coercion_graph);\n         for &non_diverging_vid in &non_diverging_vids {\n-            let root_vid = self.infcx.root_var(non_diverging_vid);\n+            let root_vid = self.root_var(non_diverging_vid);\n             if roots_reachable_from_diverging.visited(root_vid) {\n                 continue;\n             }\n@@ -294,15 +294,15 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         diverging_fallback.reserve(diverging_vids.len());\n         for &diverging_vid in &diverging_vids {\n             let diverging_ty = self.tcx.mk_ty_var(diverging_vid);\n-            let root_vid = self.infcx.root_var(diverging_vid);\n+            let root_vid = self.root_var(diverging_vid);\n             let can_reach_non_diverging = coercion_graph\n                 .depth_first_search(root_vid)\n                 .any(|n| roots_reachable_from_non_diverging.visited(n));\n \n             let mut relationship = ty::FoundRelationships { self_in_trait: false, output: false };\n \n             for (vid, rel) in relationships.iter() {\n-                if self.infcx.root_var(*vid) == root_vid {\n+                if self.root_var(*vid) == root_vid {\n                     relationship.self_in_trait |= rel.self_in_trait;\n                     relationship.output |= rel.output;\n                 }\n@@ -387,12 +387,12 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             })\n             .collect();\n         debug!(\"create_coercion_graph: coercion_edges={:?}\", coercion_edges);\n-        let num_ty_vars = self.infcx.num_ty_vars();\n+        let num_ty_vars = self.num_ty_vars();\n         VecGraph::new(num_ty_vars, coercion_edges)\n     }\n \n     /// If `ty` is an unresolved type variable, returns its root vid.\n     fn root_vid(&self, ty: Ty<'tcx>) -> Option<ty::TyVid> {\n-        Some(self.infcx.root_var(self.infcx.shallow_resolve(ty).ty_vid()?))\n+        Some(self.root_var(self.shallow_resolve(ty).ty_vid()?))\n     }\n }"}, {"sha": "d1c10a3b63c65cdf15cb637757e5e9d185f831e7", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -185,20 +185,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if !method.substs.is_empty() {\n             let method_generics = self.tcx.generics_of(method.def_id);\n             if !method_generics.params.is_empty() {\n-                let user_type_annotation = self.infcx.probe(|_| {\n+                let user_type_annotation = self.probe(|_| {\n                     let user_substs = UserSubsts {\n                         substs: InternalSubsts::for_item(self.tcx, method.def_id, |param, _| {\n                             let i = param.index as usize;\n                             if i < method_generics.parent_count {\n-                                self.infcx.var_for_def(DUMMY_SP, param)\n+                                self.var_for_def(DUMMY_SP, param)\n                             } else {\n                                 method.substs[i]\n                             }\n                         }),\n                         user_self_ty: None, // not relevant here\n                     };\n \n-                    self.infcx.canonicalize_user_type_annotation(UserType::TypeOf(\n+                    self.canonicalize_user_type_annotation(UserType::TypeOf(\n                         method.def_id,\n                         user_substs,\n                     ))\n@@ -236,7 +236,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\"fcx {}\", self.tag());\n \n         if Self::can_contain_user_lifetime_bounds((substs, user_self_ty)) {\n-            let canonicalized = self.infcx.canonicalize_user_type_annotation(UserType::TypeOf(\n+            let canonicalized = self.canonicalize_user_type_annotation(UserType::TypeOf(\n                 def_id,\n                 UserSubsts { substs, user_self_ty },\n             ));\n@@ -480,7 +480,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\"to_ty_saving_user_provided_ty: ty={:?}\", ty);\n \n         if Self::can_contain_user_lifetime_bounds(ty) {\n-            let c_ty = self.infcx.canonicalize_response(UserType::Ty(ty));\n+            let c_ty = self.canonicalize_response(UserType::Ty(ty));\n             debug!(\"to_ty_saving_user_provided_ty: c_ty={:?}\", c_ty);\n             self.typeck_results.borrow_mut().user_provided_types_mut().insert(ast_ty.hir_id, c_ty);\n         }\n@@ -764,7 +764,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if let ty::subst::GenericArgKind::Type(ty) = ty.unpack()\n                     && let ty::Opaque(def_id, _) = *ty.kind()\n                     && let Some(def_id) = def_id.as_local()\n-                    && self.infcx.opaque_type_origin(def_id, DUMMY_SP).is_some() {\n+                    && self.opaque_type_origin(def_id, DUMMY_SP).is_some() {\n                     return None;\n                 }\n             }\n@@ -826,7 +826,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else {\n             self.tcx.bound_type_of(def_id)\n         };\n-        let substs = self.infcx.fresh_substs_for_item(span, def_id);\n+        let substs = self.fresh_substs_for_item(span, def_id);\n         let ty = item_ty.subst(self.tcx, substs);\n \n         self.write_resolution(hir_id, Ok((def_kind, def_id)));"}, {"sha": "498913ce546eb0c21e828a6d8dd1a65ace73a298", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -1520,21 +1520,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// ```\n     fn get_expr_coercion_span(&self, expr: &hir::Expr<'_>) -> rustc_span::Span {\n         let check_in_progress = |elem: &hir::Expr<'_>| {\n-            self.in_progress_typeck_results\n-                .and_then(|typeck_results| typeck_results.borrow().node_type_opt(elem.hir_id))\n-                .and_then(|ty| {\n-                    if ty.is_never() {\n-                        None\n-                    } else {\n-                        Some(match elem.kind {\n-                            // Point at the tail expression when possible.\n-                            hir::ExprKind::Block(block, _) => {\n-                                block.expr.map_or(block.span, |e| e.span)\n-                            }\n-                            _ => elem.span,\n-                        })\n-                    }\n-                })\n+            self.typeck_results.borrow().node_type_opt(elem.hir_id).filter(|ty| !ty.is_never()).map(\n+                |_| match elem.kind {\n+                    // Point at the tail expression when possible.\n+                    hir::ExprKind::Block(block, _) => block.expr.map_or(block.span, |e| e.span),\n+                    _ => elem.span,\n+                },\n+            )\n         };\n \n         if let hir::ExprKind::If(_, _, Some(el)) = expr.kind {"}, {"sha": "8f5f3657fc972eb628875867fc33a9deae88124d", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -343,15 +343,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         OP: FnOnce(ProbeContext<'a, 'tcx>) -> Result<R, MethodError<'tcx>>,\n     {\n         let mut orig_values = OriginalQueryValues::default();\n-        let param_env_and_self_ty = self.infcx.canonicalize_query(\n+        let param_env_and_self_ty = self.canonicalize_query(\n             ParamEnvAnd { param_env: self.param_env, value: self_ty },\n             &mut orig_values,\n         );\n \n         let steps = if mode == Mode::MethodCall {\n             self.tcx.method_autoderef_steps(param_env_and_self_ty)\n         } else {\n-            self.infcx.probe(|_| {\n+            self.probe(|_| {\n                 // Mode::Path - the deref steps is \"trivial\". This turns\n                 // our CanonicalQuery into a \"trivial\" QueryResponse. This\n                 // is a bit inefficient, but I don't think that writing"}, {"sha": "93d34c72109cfdd51dddadbfa30d6049c5408f4b", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -865,27 +865,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             .join(\"\\n\");\n                         let actual_prefix = actual.prefix_string(self.tcx);\n                         info!(\"unimplemented_traits.len() == {}\", unimplemented_traits.len());\n-                        let (primary_message, label) = if unimplemented_traits.len() == 1\n-                            && unimplemented_traits_only\n-                        {\n-                            unimplemented_traits\n-                                .into_iter()\n-                                .next()\n-                                .map(|(_, (trait_ref, obligation))| {\n-                                    if trait_ref.self_ty().references_error()\n-                                        || actual.references_error()\n-                                    {\n-                                        // Avoid crashing.\n-                                        return (None, None);\n-                                    }\n-                                    let OnUnimplementedNote { message, label, .. } =\n-                                        self.infcx.on_unimplemented_note(trait_ref, &obligation);\n-                                    (message, label)\n-                                })\n-                                .unwrap_or((None, None))\n-                        } else {\n-                            (None, None)\n-                        };\n+                        let (primary_message, label) =\n+                            if unimplemented_traits.len() == 1 && unimplemented_traits_only {\n+                                unimplemented_traits\n+                                    .into_iter()\n+                                    .next()\n+                                    .map(|(_, (trait_ref, obligation))| {\n+                                        if trait_ref.self_ty().references_error()\n+                                            || actual.references_error()\n+                                        {\n+                                            // Avoid crashing.\n+                                            return (None, None);\n+                                        }\n+                                        let OnUnimplementedNote { message, label, .. } =\n+                                            self.on_unimplemented_note(trait_ref, &obligation);\n+                                        (message, label)\n+                                    })\n+                                    .unwrap_or((None, None))\n+                            } else {\n+                                (None, None)\n+                            };\n                         let primary_message = primary_message.unwrap_or_else(|| format!(\n                             \"the {item_kind} `{item_name}` exists for {actual_prefix} `{ty_str}`, but its trait bounds were not satisfied\"\n                         ));\n@@ -1648,7 +1647,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         call: &hir::Expr<'_>,\n         span: Span,\n     ) {\n-        let output_ty = match self.infcx.get_impl_future_output_ty(ty) {\n+        let output_ty = match self.get_impl_future_output_ty(ty) {\n             Some(output_ty) => self.resolve_vars_if_possible(output_ty).skip_binder(),\n             _ => return,\n         };"}, {"sha": "920b3e688089b1f1070c4737b695eaf47c7bf043", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -475,7 +475,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         suggest_deref_binop(lhs_deref_ty);\n                 } else if is_assign == IsAssign::No\n                     && let Ref(_, lhs_deref_ty, _) = lhs_ty.kind() {\n-                    if self.infcx.type_is_copy_modulo_regions(self.param_env, *lhs_deref_ty, lhs_expr.span) {\n+                    if self.type_is_copy_modulo_regions(self.param_env, *lhs_deref_ty, lhs_expr.span) {\n                         suggest_deref_binop(*lhs_deref_ty);\n                     }\n                 }\n@@ -523,7 +523,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         _ => None,\n                                     };\n \n-                                    self.infcx.suggest_restricting_param_bound(\n+                                    self.suggest_restricting_param_bound(\n                                         &mut err,\n                                         trait_pred,\n                                         proj_pred,\n@@ -740,7 +740,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 error.obligation.predicate.to_opt_poly_trait_pred()\n                             });\n                         for pred in predicates {\n-                            self.infcx.suggest_restricting_param_bound(\n+                            self.suggest_restricting_param_bound(\n                                 &mut err,\n                                 pred,\n                                 None,"}, {"sha": "d72e215934a0d8626bbd9980fd6b315ce1df039c", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -948,7 +948,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let root_var_min_capture_list = min_captures.and_then(|m| m.get(&var_hir_id))?;\n \n-        let ty = self.infcx.resolve_vars_if_possible(self.node_ty(var_hir_id));\n+        let ty = self.resolve_vars_if_possible(self.node_ty(var_hir_id));\n \n         let ty = match closure_clause {\n             hir::CaptureBy::Value => ty, // For move closure the capture kind should be by value\n@@ -1064,7 +1064,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         closure_clause: hir::CaptureBy,\n         var_hir_id: hir::HirId,\n     ) -> Option<FxHashSet<UpvarMigrationInfo>> {\n-        let ty = self.infcx.resolve_vars_if_possible(self.node_ty(var_hir_id));\n+        let ty = self.resolve_vars_if_possible(self.node_ty(var_hir_id));\n \n         if !ty.has_significant_drop(self.tcx, self.tcx.param_env(closure_def_id.expect_local())) {\n             debug!(\"does not have significant drop\");"}, {"sha": "fa6053ac39585be8eddb6b49b5e5540251dcba6b", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -748,7 +748,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n                 // (e.g. keep `for<'a>` named `for<'a>`).\n                 // This allows NLL to generate error messages that\n                 // refer to the higher-ranked lifetime names written by the user.\n-                EraseEarlyRegions { tcx: self.infcx.tcx }.fold_ty(t)\n+                EraseEarlyRegions { tcx: self.tcx }.fold_ty(t)\n             }\n             Err(_) => {\n                 debug!(\"Resolver::fold_ty: input type `{:?}` not fully resolvable\", t);\n@@ -766,7 +766,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n \n     fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n         match self.infcx.fully_resolve(ct) {\n-            Ok(ct) => self.infcx.tcx.erase_regions(ct),\n+            Ok(ct) => self.tcx.erase_regions(ct),\n             Err(_) => {\n                 debug!(\"Resolver::fold_const: input const `{:?}` not fully resolvable\", ct);\n                 self.report_const_error(ct);"}, {"sha": "0438ac02ea91a75fed88aa5e83d42b617667afa2", "filename": "compiler/rustc_typeck/src/errors.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -244,7 +244,7 @@ pub struct UnconstrainedOpaqueType {\n pub struct MissingTypeParams {\n     pub span: Span,\n     pub def_span: Span,\n-    pub missing_type_params: Vec<String>,\n+    pub missing_type_params: Vec<Symbol>,\n     pub empty_generic_args: bool,\n }\n \n@@ -285,7 +285,15 @@ impl<'a> SessionDiagnostic<'a> for MissingTypeParams {\n                 err.span_suggestion(\n                     self.span,\n                     rustc_errors::fluent::typeck::suggestion,\n-                    format!(\"{}<{}>\", snippet, self.missing_type_params.join(\", \")),\n+                    format!(\n+                        \"{}<{}>\",\n+                        snippet,\n+                        self.missing_type_params\n+                            .iter()\n+                            .map(|n| n.to_string())\n+                            .collect::<Vec<_>>()\n+                            .join(\", \")\n+                    ),\n                     Applicability::HasPlaceholders,\n                 );\n                 suggested = true;"}, {"sha": "71522865b7dcfda18c64d19ba91ec7b036150f2f", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -1126,6 +1126,19 @@ impl fmt::Debug for File {\n             Some(PathBuf::from(OsString::from_vec(buf)))\n         }\n \n+        #[cfg(all(target_os = \"freebsd\", target_arch = \"x86_64\"))]\n+        fn get_path(fd: c_int) -> Option<PathBuf> {\n+            let info = Box::<libc::kinfo_file>::new_zeroed();\n+            let mut info = unsafe { info.assume_init() };\n+            info.kf_structsize = mem::size_of::<libc::kinfo_file>() as libc::c_int;\n+            let n = unsafe { libc::fcntl(fd, libc::F_KINFO, &mut *info) };\n+            if n == -1 {\n+                return None;\n+            }\n+            let buf = unsafe { CStr::from_ptr(info.kf_path.as_mut_ptr()).to_bytes().to_vec() };\n+            Some(PathBuf::from(OsString::from_vec(buf)))\n+        }\n+\n         #[cfg(target_os = \"vxworks\")]\n         fn get_path(fd: c_int) -> Option<PathBuf> {\n             let mut buf = vec![0; libc::PATH_MAX as usize];\n@@ -1142,6 +1155,7 @@ impl fmt::Debug for File {\n             target_os = \"linux\",\n             target_os = \"macos\",\n             target_os = \"vxworks\",\n+            all(target_os = \"freebsd\", target_arch = \"x86_64\"),\n             target_os = \"netbsd\"\n         )))]\n         fn get_path(_fd: c_int) -> Option<PathBuf> {"}, {"sha": "effdef80e8eb65628a784f09a9865d4c86d4f77c", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.inline-dead.txt", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.inline-dead.txt", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.inline-dead.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.inline-dead.txt?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -1,21 +1,28 @@\n     1|       |// Regression test for issue #98833.\n-    2|       |// compile-flags: -Zinline-mir\n+    2|       |// compile-flags: -Zinline-mir -Cdebug-assertions=off\n     3|       |\n     4|      1|fn main() {\n     5|      1|    println!(\"{}\", live::<false>());\n-    6|      1|}\n-    7|       |\n-    8|       |#[inline]\n-    9|      1|fn live<const B: bool>() -> u32 {\n-   10|      1|    if B {\n-   11|      0|        dead()\n-   12|       |    } else {\n-   13|      1|        0\n-   14|       |    }\n-   15|      1|}\n-   16|       |\n-   17|       |#[inline]\n-   18|      0|fn dead() -> u32 {\n-   19|      0|    42\n-   20|      0|}\n+    6|      1|\n+    7|      1|    let f = |x: bool| {\n+    8|       |        debug_assert!(\n+    9|       |            x\n+   10|       |        );\n+   11|      1|    };\n+   12|      1|    f(false);\n+   13|      1|}\n+   14|       |\n+   15|       |#[inline]\n+   16|      1|fn live<const B: bool>() -> u32 {\n+   17|      1|    if B {\n+   18|      0|        dead()\n+   19|       |    } else {\n+   20|      1|        0\n+   21|       |    }\n+   22|      1|}\n+   23|       |\n+   24|       |#[inline]\n+   25|      0|fn dead() -> u32 {\n+   26|      0|    42\n+   27|      0|}\n "}, {"sha": "854fa062967526a5b530b4f68ca7883c1907f73a", "filename": "src/test/run-make-fulldeps/coverage/inline-dead.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Finline-dead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Finline-dead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Finline-dead.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -1,8 +1,15 @@\n // Regression test for issue #98833.\n-// compile-flags: -Zinline-mir\n+// compile-flags: -Zinline-mir -Cdebug-assertions=off\n \n fn main() {\n     println!(\"{}\", live::<false>());\n+\n+    let f = |x: bool| {\n+        debug_assert!(\n+            x\n+        );\n+    };\n+    f(false);\n }\n \n #[inline]"}, {"sha": "63bac96135b42f4c9763d253924ab3bf40e44f67", "filename": "src/test/ui/associated-consts/associated-const-impl-wrong-lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Fui%2Fassociated-consts%2Fassociated-const-impl-wrong-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Fui%2Fassociated-consts%2Fassociated-const-impl-wrong-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fassociated-const-impl-wrong-lifetime.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -5,7 +5,7 @@ trait Foo {\n \n impl<'a> Foo for &'a () {\n     const NAME: &'a str = \"unit\";\n-    //~^ ERROR mismatched types [E0308]\n+    //~^ ERROR const not compatible with trait\n }\n \n fn main() {}"}, {"sha": "de1d9589e99615bcdc0c271f143d670c3c27f046", "filename": "src/test/ui/associated-consts/associated-const-impl-wrong-lifetime.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Fui%2Fassociated-consts%2Fassociated-const-impl-wrong-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Fui%2Fassociated-consts%2Fassociated-const-impl-wrong-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fassociated-const-impl-wrong-lifetime.stderr?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -1,4 +1,4 @@\n-error[E0308]: mismatched types\n+error[E0308]: const not compatible with trait\n   --> $DIR/associated-const-impl-wrong-lifetime.rs:7:5\n    |\n LL |     const NAME: &'a str = \"unit\";"}, {"sha": "e866b3bab7972b6efbda369e1f17cf5194f30316", "filename": "src/test/ui/generic-associated-types/generic-associated-types-where.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgeneric-associated-types-where.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgeneric-associated-types-where.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgeneric-associated-types-where.stderr?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -11,13 +11,13 @@ LL |     type Assoc2<T: std::fmt::Display> = Vec<T>;\n    |                  +++++++++++++++++++\n \n error[E0276]: impl has stricter requirements than trait\n-  --> $DIR/generic-associated-types-where.rs:22:5\n+  --> $DIR/generic-associated-types-where.rs:22:38\n    |\n LL |     type Assoc3<T>;\n    |     -------------- definition of `Assoc3` from trait\n ...\n LL |     type Assoc3<T> = Vec<T> where T: Iterator;\n-   |     ^^^^^^^^^^^^^^ impl has extra requirement `T: Iterator`\n+   |                                      ^^^^^^^^ impl has extra requirement `T: Iterator`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ec1d171c044701f7c9f30e025bbfc81a87e540e9", "filename": "src/test/ui/generic-associated-types/impl_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -13,9 +13,9 @@ struct Fooy<T>(T);\n \n impl<T> Foo for Fooy<T> {\n     type A<'a> = (&'a ()) where Self: 'static;\n-    //~^ ERROR `impl` associated type\n+    //~^ ERROR impl has stricter requirements than trait\n     type B<'a, 'b> = (&'a(), &'b ()) where 'b: 'a;\n-    //~^ ERROR `impl` associated type\n+    //~^ ERROR impl has stricter requirements than trait\n     //~| ERROR lifetime bound not satisfied\n     type C = String where Self: Copy;\n     //~^ ERROR the trait bound `T: Copy` is not satisfied"}, {"sha": "ce79c635add69ac2e94f8c8e6fd6125980115109", "filename": "src/test/ui/generic-associated-types/impl_bounds.stderr", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.stderr?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -1,20 +1,20 @@\n-error: `impl` associated type signature for `A` doesn't match `trait` associated type signature\n-  --> $DIR/impl_bounds.rs:15:5\n+error[E0276]: impl has stricter requirements than trait\n+  --> $DIR/impl_bounds.rs:15:39\n    |\n LL |     type A<'a> where Self: 'a;\n-   |     ---------- expected\n+   |     ---------- definition of `A` from trait\n ...\n LL |     type A<'a> = (&'a ()) where Self: 'static;\n-   |     ^^^^^^^^^^ found\n+   |                                       ^^^^^^^ impl has extra requirement `T: 'static`\n \n-error: `impl` associated type signature for `B` doesn't match `trait` associated type signature\n-  --> $DIR/impl_bounds.rs:17:5\n+error[E0276]: impl has stricter requirements than trait\n+  --> $DIR/impl_bounds.rs:17:48\n    |\n LL |     type B<'a, 'b> where 'a: 'b;\n-   |     -------------- expected\n+   |     -------------- definition of `B` from trait\n ...\n LL |     type B<'a, 'b> = (&'a(), &'b ()) where 'b: 'a;\n-   |     ^^^^^^^^^^^^^^ found\n+   |                                                ^^ impl has extra requirement `'b: 'a`\n \n error[E0478]: lifetime bound not satisfied\n   --> $DIR/impl_bounds.rs:17:22\n@@ -37,24 +37,24 @@ LL |     type B<'a, 'b> = (&'a(), &'b ()) where 'b: 'a;\n    |                ^^\n \n error[E0277]: the trait bound `T: Copy` is not satisfied\n-  --> $DIR/impl_bounds.rs:20:5\n+  --> $DIR/impl_bounds.rs:20:33\n    |\n LL |     type C = String where Self: Copy;\n-   |     ^^^^^^ the trait `Copy` is not implemented for `T`\n+   |                                 ^^^^ the trait `Copy` is not implemented for `T`\n    |\n note: required because of the requirements on the impl of `Copy` for `Fooy<T>`\n   --> $DIR/impl_bounds.rs:11:10\n    |\n LL | #[derive(Copy, Clone)]\n    |          ^^^^\n-note: the requirement `Fooy<T>: Copy` appears on the associated impl type `C` but not on the corresponding associated trait type\n-  --> $DIR/impl_bounds.rs:7:5\n+note: the requirement `Fooy<T>: Copy` appears on the `impl`'s associated type `C` but not on the corresponding trait's associated type\n+  --> $DIR/impl_bounds.rs:7:10\n    |\n LL | trait Foo {\n    |       --- in this trait\n ...\n LL |     type C where Self: Clone;\n-   |     ^^^^^^ this trait associated type doesn't have the requirement `Fooy<T>: Copy`\n+   |          ^ this trait's associated type doesn't have the requirement `Fooy<T>: Copy`\n    = note: this error originates in the derive macro `Copy` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider restricting type parameter `T`\n    |\n@@ -72,14 +72,14 @@ note: required because of the requirements on the impl of `Copy` for `Fooy<T>`\n    |\n LL | #[derive(Copy, Clone)]\n    |          ^^^^\n-note: the requirement `Fooy<T>: Copy` appears on the impl method `d` but not on the corresponding trait method\n+note: the requirement `Fooy<T>: Copy` appears on the `impl`'s method `d` but not on the corresponding trait's method\n   --> $DIR/impl_bounds.rs:8:8\n    |\n LL | trait Foo {\n    |       --- in this trait\n ...\n LL |     fn d() where Self: Clone;\n-   |        ^ this trait method doesn't have the requirement `Fooy<T>: Copy`\n+   |        ^ this trait's method doesn't have the requirement `Fooy<T>: Copy`\n    = note: this error originates in the derive macro `Copy` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider restricting type parameter `T`\n    |\n@@ -88,5 +88,5 @@ LL | impl<T: std::marker::Copy> Foo for Fooy<T> {\n \n error: aborting due to 5 previous errors\n \n-Some errors have detailed explanations: E0277, E0478.\n-For more information about an error, try `rustc --explain E0277`.\n+Some errors have detailed explanations: E0276, E0277, E0478.\n+For more information about an error, try `rustc --explain E0276`."}, {"sha": "31948a878edfaa812e4ea90f2101678c8e713261", "filename": "src/test/ui/generic-associated-types/issue-47206-where-clause.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-47206-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-47206-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-47206-where-clause.stderr?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -1,11 +1,11 @@\n error[E0276]: impl has stricter requirements than trait\n-  --> $DIR/issue-47206-where-clause.rs:12:5\n+  --> $DIR/issue-47206-where-clause.rs:12:38\n    |\n LL |     type Assoc3<T>;\n    |     -------------- definition of `Assoc3` from trait\n ...\n LL |     type Assoc3<T> = Vec<T> where T: Iterator;\n-   |     ^^^^^^^^^^^^^^ impl has extra requirement `T: Iterator`\n+   |                                      ^^^^^^^^ impl has extra requirement `T: Iterator`\n \n error: aborting due to previous error\n "}, {"sha": "8171dc0ae28d62d81feab67ed6e4881d074bd92a", "filename": "src/test/ui/generic-associated-types/missing-where-clause-on-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-where-clause-on-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-where-clause-on-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-where-clause-on-trait.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -7,7 +7,7 @@ trait Foo {\n }\n impl Foo for () {\n     type Assoc<'a, 'b> = () where 'a: 'b;\n-    //~^ `impl` associated type\n+    //~^ impl has stricter requirements than trait\n }\n \n fn main() {}"}, {"sha": "edd1f9367d129f7971de9b3481415e1cc4d4c249", "filename": "src/test/ui/generic-associated-types/missing-where-clause-on-trait.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-where-clause-on-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-where-clause-on-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-where-clause-on-trait.stderr?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -1,11 +1,12 @@\n-error: `impl` associated type signature for `Assoc` doesn't match `trait` associated type signature\n-  --> $DIR/missing-where-clause-on-trait.rs:9:5\n+error[E0276]: impl has stricter requirements than trait\n+  --> $DIR/missing-where-clause-on-trait.rs:9:39\n    |\n LL |     type Assoc<'a, 'b>;\n-   |     ------------------ expected\n+   |     ------------------ definition of `Assoc` from trait\n ...\n LL |     type Assoc<'a, 'b> = () where 'a: 'b;\n-   |     ^^^^^^^^^^^^^^^^^^ found\n+   |                                       ^^ impl has extra requirement `'a: 'b`\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0276`."}, {"sha": "63b65ab20fea8a961f920959e81f8597c5d6ab60", "filename": "src/test/ui/mismatched_types/suggest-removing-tulpe-struct-field.fixed", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-removing-tulpe-struct-field.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-removing-tulpe-struct-field.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-removing-tulpe-struct-field.fixed?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -0,0 +1,17 @@\n+// run-rustfix\n+\n+macro_rules! my_wrapper {\n+    ($expr:expr) => { MyWrapper($expr) }\n+}\n+\n+pub struct MyWrapper(u32);\n+\n+fn main() {\n+    let value = MyWrapper(123);\n+    some_fn(value); //~ ERROR mismatched types\n+    some_fn(my_wrapper!(123)); //~ ERROR mismatched types\n+}\n+\n+fn some_fn(wrapped: MyWrapper) {\n+    drop(wrapped);\n+}"}, {"sha": "2ab4e3955f336aad0a1a0363066066cafba0bcfa", "filename": "src/test/ui/mismatched_types/suggest-removing-tulpe-struct-field.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-removing-tulpe-struct-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-removing-tulpe-struct-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-removing-tulpe-struct-field.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -0,0 +1,17 @@\n+// run-rustfix\n+\n+macro_rules! my_wrapper {\n+    ($expr:expr) => { MyWrapper($expr) }\n+}\n+\n+pub struct MyWrapper(u32);\n+\n+fn main() {\n+    let value = MyWrapper(123);\n+    some_fn(value.0); //~ ERROR mismatched types\n+    some_fn(my_wrapper!(123).0); //~ ERROR mismatched types\n+}\n+\n+fn some_fn(wrapped: MyWrapper) {\n+    drop(wrapped);\n+}"}, {"sha": "82a7f276372c9903dec8c85b1b64202ddb3c9aae", "filename": "src/test/ui/mismatched_types/suggest-removing-tulpe-struct-field.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-removing-tulpe-struct-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-removing-tulpe-struct-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fsuggest-removing-tulpe-struct-field.stderr?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -0,0 +1,41 @@\n+error[E0308]: mismatched types\n+  --> $DIR/suggest-removing-tulpe-struct-field.rs:11:13\n+   |\n+LL |     some_fn(value.0);\n+   |     ------- ^^^^^^^ expected struct `MyWrapper`, found `u32`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+note: function defined here\n+  --> $DIR/suggest-removing-tulpe-struct-field.rs:15:4\n+   |\n+LL | fn some_fn(wrapped: MyWrapper) {\n+   |    ^^^^^^^ ------------------\n+help: consider removing the tuple struct field `0`\n+   |\n+LL -     some_fn(value.0);\n+LL +     some_fn(value);\n+   |\n+\n+error[E0308]: mismatched types\n+  --> $DIR/suggest-removing-tulpe-struct-field.rs:12:13\n+   |\n+LL |     some_fn(my_wrapper!(123).0);\n+   |     ------- ^^^^^^^^^^^^^^^^^^ expected struct `MyWrapper`, found `u32`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+note: function defined here\n+  --> $DIR/suggest-removing-tulpe-struct-field.rs:15:4\n+   |\n+LL | fn some_fn(wrapped: MyWrapper) {\n+   |    ^^^^^^^ ------------------\n+help: consider removing the tuple struct field `0`\n+   |\n+LL -     some_fn(my_wrapper!(123).0);\n+LL +     some_fn(my_wrapper!(123));\n+   |\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "e13ae80f918b2be0fb9d0e341cd95421866e4fa7", "filename": "src/test/ui/nll/trait-associated-constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Fui%2Fnll%2Ftrait-associated-constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Fui%2Fnll%2Ftrait-associated-constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Ftrait-associated-constant.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -19,7 +19,7 @@ struct FailStruct { }\n \n impl<'a: 'b, 'b, 'c> Anything<'a, 'b> for FailStruct {\n     const AC: Option<&'c str> = None;\n-    //~^ ERROR: mismatched types\n+    //~^ ERROR: const not compatible with trait\n }\n \n struct OKStruct2 { }"}, {"sha": "ae0ffd904e7996e496e9ccf18adfe3ecb9feac32", "filename": "src/test/ui/nll/trait-associated-constant.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Fui%2Fnll%2Ftrait-associated-constant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftest%2Fui%2Fnll%2Ftrait-associated-constant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Ftrait-associated-constant.stderr?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -1,4 +1,4 @@\n-error[E0308]: mismatched types\n+error[E0308]: const not compatible with trait\n   --> $DIR/trait-associated-constant.rs:21:5\n    |\n LL |     const AC: Option<&'c str> = None;"}, {"sha": "333f85f6d62b8615e3d52cc41824e8ce85e6f079", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b629c85bd74dfb730a3e9308312b007c0bf027cb/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=b629c85bd74dfb730a3e9308312b007c0bf027cb", "patch": "@@ -55,12 +55,13 @@ const EXCEPTIONS_CRANELIFT: &[(&str, &str)] = &[\n     (\"cranelift-codegen-shared\", \"Apache-2.0 WITH LLVM-exception\"),\n     (\"cranelift-entity\", \"Apache-2.0 WITH LLVM-exception\"),\n     (\"cranelift-frontend\", \"Apache-2.0 WITH LLVM-exception\"),\n+    (\"cranelift-isle\", \"Apache-2.0 WITH LLVM-exception\"),\n     (\"cranelift-jit\", \"Apache-2.0 WITH LLVM-exception\"),\n     (\"cranelift-module\", \"Apache-2.0 WITH LLVM-exception\"),\n     (\"cranelift-native\", \"Apache-2.0 WITH LLVM-exception\"),\n     (\"cranelift-object\", \"Apache-2.0 WITH LLVM-exception\"),\n     (\"mach\", \"BSD-2-Clause\"),\n-    (\"regalloc\", \"Apache-2.0 WITH LLVM-exception\"),\n+    (\"regalloc2\", \"Apache-2.0 WITH LLVM-exception\"),\n     (\"target-lexicon\", \"Apache-2.0 WITH LLVM-exception\"),\n ];\n \n@@ -258,22 +259,27 @@ const PERMITTED_DEPENDENCIES: &[&str] = &[\n ];\n \n const PERMITTED_CRANELIFT_DEPENDENCIES: &[&str] = &[\n+    \"ahash\",\n     \"anyhow\",\n     \"ar\",\n     \"autocfg\",\n     \"bitflags\",\n+    \"byteorder\",\n     \"cfg-if\",\n     \"cranelift-bforest\",\n     \"cranelift-codegen\",\n     \"cranelift-codegen-meta\",\n     \"cranelift-codegen-shared\",\n     \"cranelift-entity\",\n     \"cranelift-frontend\",\n+    \"cranelift-isle\",\n     \"cranelift-jit\",\n     \"cranelift-module\",\n     \"cranelift-native\",\n     \"cranelift-object\",\n     \"crc32fast\",\n+    \"fxhash\",\n+    \"getrandom\",\n     \"gimli\",\n     \"hashbrown\",\n     \"indexmap\",\n@@ -284,11 +290,13 @@ const PERMITTED_CRANELIFT_DEPENDENCIES: &[&str] = &[\n     \"memchr\",\n     \"object\",\n     \"once_cell\",\n-    \"regalloc\",\n+    \"regalloc2\",\n     \"region\",\n-    \"rustc-hash\",\n+    \"slice-group-by\",\n     \"smallvec\",\n     \"target-lexicon\",\n+    \"version_check\",\n+    \"wasi\",\n     \"winapi\",\n     \"winapi-i686-pc-windows-gnu\",\n     \"winapi-x86_64-pc-windows-gnu\","}]}