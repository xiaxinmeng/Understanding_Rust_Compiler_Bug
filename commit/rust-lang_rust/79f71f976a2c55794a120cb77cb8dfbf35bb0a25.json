{"sha": "79f71f976a2c55794a120cb77cb8dfbf35bb0a25", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ZjcxZjk3NmEyYzU1Nzk0YTEyMGNiNzdjYjhkZmJmMzViYjBhMjU=", "commit": {"author": {"name": "Aravind Gollakota", "email": "aravindprasant@gmail.com", "date": "2018-04-05T17:29:18Z"}, "committer": {"name": "Aravind Gollakota", "email": "aravindprasant@gmail.com", "date": "2018-04-27T01:26:20Z"}, "message": "Refactor overflow handling in traits::select to propagate overflow instead of aborting eagerly\n\nWe store the obligation that caused the overflow as part of the OverflowError, and report it at the public API endpoints (rather than in the implementation internals).", "tree": {"sha": "d7b009c0e8af92fbd33554ae087698ad20d82fdb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7b009c0e8af92fbd33554ae087698ad20d82fdb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79f71f976a2c55794a120cb77cb8dfbf35bb0a25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79f71f976a2c55794a120cb77cb8dfbf35bb0a25", "html_url": "https://github.com/rust-lang/rust/commit/79f71f976a2c55794a120cb77cb8dfbf35bb0a25", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79f71f976a2c55794a120cb77cb8dfbf35bb0a25/comments", "author": {"login": "aravind-pg", "id": 6913107, "node_id": "MDQ6VXNlcjY5MTMxMDc=", "avatar_url": "https://avatars.githubusercontent.com/u/6913107?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aravind-pg", "html_url": "https://github.com/aravind-pg", "followers_url": "https://api.github.com/users/aravind-pg/followers", "following_url": "https://api.github.com/users/aravind-pg/following{/other_user}", "gists_url": "https://api.github.com/users/aravind-pg/gists{/gist_id}", "starred_url": "https://api.github.com/users/aravind-pg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aravind-pg/subscriptions", "organizations_url": "https://api.github.com/users/aravind-pg/orgs", "repos_url": "https://api.github.com/users/aravind-pg/repos", "events_url": "https://api.github.com/users/aravind-pg/events{/privacy}", "received_events_url": "https://api.github.com/users/aravind-pg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aravind-pg", "id": 6913107, "node_id": "MDQ6VXNlcjY5MTMxMDc=", "avatar_url": "https://avatars.githubusercontent.com/u/6913107?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aravind-pg", "html_url": "https://github.com/aravind-pg", "followers_url": "https://api.github.com/users/aravind-pg/followers", "following_url": "https://api.github.com/users/aravind-pg/following{/other_user}", "gists_url": "https://api.github.com/users/aravind-pg/gists{/gist_id}", "starred_url": "https://api.github.com/users/aravind-pg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aravind-pg/subscriptions", "organizations_url": "https://api.github.com/users/aravind-pg/orgs", "repos_url": "https://api.github.com/users/aravind-pg/repos", "events_url": "https://api.github.com/users/aravind-pg/events{/privacy}", "received_events_url": "https://api.github.com/users/aravind-pg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f3444e1baf0d335b4bf379f845dbc28cdd0509c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f3444e1baf0d335b4bf379f845dbc28cdd0509c", "html_url": "https://github.com/rust-lang/rust/commit/7f3444e1baf0d335b4bf379f845dbc28cdd0509c"}], "stats": {"total": 182, "additions": 113, "deletions": 69}, "files": [{"sha": "686008cc1efd50b318c3c30625b93bca667fa8b7", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/79f71f976a2c55794a120cb77cb8dfbf35bb0a25/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f71f976a2c55794a120cb77cb8dfbf35bb0a25/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=79f71f976a2c55794a120cb77cb8dfbf35bb0a25", "patch": "@@ -24,6 +24,7 @@ use super::{\n     SelectionContext,\n     SelectionError,\n     ObjectSafetyViolation,\n+    Overflow,\n };\n \n use errors::DiagnosticBuilder;\n@@ -830,6 +831,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 err.struct_error(self.tcx, span, \"constant expression\")\n             }\n+\n+            Overflow(_) => {\n+                bug!(\"overflow should be handled before the `report_selection_error` path\");\n+            }\n         };\n         self.note_obligation_cause(&mut err, obligation);\n         err.emit();"}, {"sha": "6101d37956afd3716f95cb17b2e035381ff281db", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79f71f976a2c55794a120cb77cb8dfbf35bb0a25/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f71f976a2c55794a120cb77cb8dfbf35bb0a25/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=79f71f976a2c55794a120cb77cb8dfbf35bb0a25", "patch": "@@ -349,6 +349,8 @@ pub enum SelectionError<'tcx> {\n                                 ty::error::TypeError<'tcx>),\n     TraitNotObjectSafe(DefId),\n     ConstEvalFailure(ConstEvalErr<'tcx>),\n+    // upon overflow, stores the obligation that hit the recursion limit\n+    Overflow(TraitObligation<'tcx>),\n }\n \n pub struct FulfillmentError<'tcx> {"}, {"sha": "e65bfa7a72ecdd7128db9817e7d872ce540c52b7", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 105, "deletions": 69, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/79f71f976a2c55794a120cb77cb8dfbf35bb0a25/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f71f976a2c55794a120cb77cb8dfbf35bb0a25/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=79f71f976a2c55794a120cb77cb8dfbf35bb0a25", "patch": "@@ -22,7 +22,7 @@ use super::project;\n use super::project::{normalize_with_depth, Normalized, ProjectionCacheKey};\n use super::{PredicateObligation, TraitObligation, ObligationCause};\n use super::{ObligationCauseCode, BuiltinDerivedObligation, ImplDerivedObligation};\n-use super::{SelectionError, Unimplemented, OutputTypeParameterMismatch};\n+use super::{SelectionError, Unimplemented, OutputTypeParameterMismatch, Overflow};\n use super::{ObjectCastObligation, Obligation};\n use super::TraitNotObjectSafe;\n use super::Selection;\n@@ -408,6 +408,17 @@ impl EvaluationResult {\n     }\n }\n \n+#[derive(Clone, Debug, PartialEq, Eq)]\n+/// Indicates that trait evaluation caused overflow. Stores the obligation\n+/// that hit the recursion limit.\n+pub struct OverflowError<'tcx>(TraitObligation<'tcx>);\n+\n+impl<'tcx> From<OverflowError<'tcx>> for SelectionError<'tcx> {\n+    fn from(OverflowError(o): OverflowError<'tcx>) -> SelectionError<'tcx> {\n+        SelectionError::Overflow(o)\n+    }\n+}\n+\n #[derive(Clone)]\n pub struct EvaluationCache<'tcx> {\n     hashmap: RefCell<FxHashMap<ty::PolyTraitRef<'tcx>, WithDepNode<EvaluationResult>>>\n@@ -528,12 +539,21 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         assert!(!obligation.predicate.has_escaping_regions());\n \n         let stack = self.push_stack(TraitObligationStackList::empty(), obligation);\n-        let ret = match self.candidate_from_obligation(&stack)? {\n-            None => None,\n-            Some(candidate) => Some(self.confirm_candidate(obligation, candidate)?)\n+\n+        let candidate = match self.candidate_from_obligation(&stack) {\n+            Err(SelectionError::Overflow(o)) =>\n+                self.infcx().report_overflow_error(&o, true),\n+            Err(e) => { return Err(e); },\n+            Ok(None) => { return Ok(None); },\n+            Ok(Some(candidate)) => candidate\n         };\n \n-        Ok(ret)\n+        match self.confirm_candidate(obligation, candidate) {\n+            Err(SelectionError::Overflow(o)) =>\n+                self.infcx().report_overflow_error(&o, true),\n+            Err(e) => Err(e),\n+            Ok(candidate) => Ok(Some(candidate))\n+        }\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -554,10 +574,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         debug!(\"evaluate_obligation({:?})\",\n                obligation);\n \n-        self.probe(|this, _| {\n+        match self.probe(|this, _| {\n             this.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n-                .may_apply()\n-        })\n+        }) {\n+            Ok(result) => result.may_apply(),\n+            Err(OverflowError(o)) => self.infcx().report_overflow_error(&o, true)\n+        }\n     }\n \n     /// Evaluates whether the obligation `obligation` can be satisfied,\n@@ -570,10 +592,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         debug!(\"evaluate_obligation_conservatively({:?})\",\n                obligation);\n \n-        self.probe(|this, _| {\n+        match self.probe(|this, _| {\n             this.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n-                == EvaluatedToOk\n-        })\n+        }) {\n+            Ok(result) => result == EvaluatedToOk,\n+            Err(OverflowError(o)) => self.infcx().report_overflow_error(&o, true)\n+        }\n     }\n \n     /// Evaluates the predicates in `predicates` recursively. Note that\n@@ -582,29 +606,29 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn evaluate_predicates_recursively<'a,'o,I>(&mut self,\n                                                 stack: TraitObligationStackList<'o, 'tcx>,\n                                                 predicates: I)\n-                                                -> EvaluationResult\n+                                                -> Result<EvaluationResult, OverflowError<'tcx>>\n         where I : IntoIterator<Item=&'a PredicateObligation<'tcx>>, 'tcx:'a\n     {\n         let mut result = EvaluatedToOk;\n         for obligation in predicates {\n-            let eval = self.evaluate_predicate_recursively(stack, obligation);\n+            let eval = self.evaluate_predicate_recursively(stack, obligation)?;\n             debug!(\"evaluate_predicate_recursively({:?}) = {:?}\",\n                    obligation, eval);\n             if let EvaluatedToErr = eval {\n                 // fast-path - EvaluatedToErr is the top of the lattice,\n                 // so we don't need to look on the other predicates.\n-                return EvaluatedToErr;\n+                return Ok(EvaluatedToErr);\n             } else {\n                 result = cmp::max(result, eval);\n             }\n         }\n-        result\n+        Ok(result)\n     }\n \n     fn evaluate_predicate_recursively<'o>(&mut self,\n                                           previous_stack: TraitObligationStackList<'o, 'tcx>,\n                                           obligation: &PredicateObligation<'tcx>)\n-                                           -> EvaluationResult\n+                                           -> Result<EvaluationResult, OverflowError<'tcx>>\n     {\n         debug!(\"evaluate_predicate_recursively({:?})\",\n                obligation);\n@@ -620,11 +644,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // does this code ever run?\n                 match self.infcx.subtype_predicate(&obligation.cause, obligation.param_env, p) {\n                     Some(Ok(InferOk { obligations, .. })) => {\n-                        self.evaluate_predicates_recursively(previous_stack, &obligations);\n-                        EvaluatedToOk\n+                        self.evaluate_predicates_recursively(previous_stack, &obligations)\n                     },\n-                    Some(Err(_)) => EvaluatedToErr,\n-                    None => EvaluatedToAmbig,\n+                    Some(Err(_)) => Ok(EvaluatedToErr),\n+                    None => Ok(EvaluatedToAmbig),\n                 }\n             }\n \n@@ -636,21 +659,21 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     Some(obligations) =>\n                         self.evaluate_predicates_recursively(previous_stack, obligations.iter()),\n                     None =>\n-                        EvaluatedToAmbig,\n+                        Ok(EvaluatedToAmbig),\n                 }\n             }\n \n             ty::Predicate::TypeOutlives(..) | ty::Predicate::RegionOutlives(..) => {\n                 // we do not consider region relationships when\n                 // evaluating trait matches\n-                EvaluatedToOk\n+                Ok(EvaluatedToOk)\n             }\n \n             ty::Predicate::ObjectSafe(trait_def_id) => {\n                 if self.tcx().is_object_safe(trait_def_id) {\n-                    EvaluatedToOk\n+                    Ok(EvaluatedToOk)\n                 } else {\n-                    EvaluatedToErr\n+                    Ok(EvaluatedToErr)\n                 }\n             }\n \n@@ -668,10 +691,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         result\n                     }\n                     Ok(None) => {\n-                        EvaluatedToAmbig\n+                        Ok(EvaluatedToAmbig)\n                     }\n                     Err(_) => {\n-                        EvaluatedToErr\n+                        Ok(EvaluatedToErr)\n                     }\n                 }\n             }\n@@ -680,13 +703,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 match self.infcx.closure_kind(closure_def_id, closure_substs) {\n                     Some(closure_kind) => {\n                         if closure_kind.extends(kind) {\n-                            EvaluatedToOk\n+                            Ok(EvaluatedToOk)\n                         } else {\n-                            EvaluatedToErr\n+                            Ok(EvaluatedToErr)\n                         }\n                     }\n                     None => {\n-                        EvaluatedToAmbig\n+                        Ok(EvaluatedToAmbig)\n                     }\n                 }\n             }\n@@ -707,16 +730,16 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                 promoted: None\n                             };\n                             match self.tcx().const_eval(param_env.and(cid)) {\n-                                Ok(_) => EvaluatedToOk,\n-                                Err(_) => EvaluatedToErr\n+                                Ok(_) => Ok(EvaluatedToOk),\n+                                Err(_) => Ok(EvaluatedToErr)\n                             }\n                         } else {\n-                            EvaluatedToErr\n+                            Ok(EvaluatedToErr)\n                         }\n                     }\n                     None => {\n                         // Inference variables still left in param_env or substs.\n-                        EvaluatedToAmbig\n+                        Ok(EvaluatedToAmbig)\n                     }\n                 }\n             }\n@@ -726,7 +749,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn evaluate_trait_predicate_recursively<'o>(&mut self,\n                                                 previous_stack: TraitObligationStackList<'o, 'tcx>,\n                                                 mut obligation: TraitObligation<'tcx>)\n-                                                -> EvaluationResult\n+                                                -> Result<EvaluationResult, OverflowError<'tcx>>\n     {\n         debug!(\"evaluate_trait_predicate_recursively({:?})\",\n                obligation);\n@@ -745,22 +768,23 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             debug!(\"CACHE HIT: EVAL({:?})={:?}\",\n                    fresh_trait_ref,\n                    result);\n-            return result;\n+            return Ok(result);\n         }\n \n         let (result, dep_node) = self.in_task(|this| this.evaluate_stack(&stack));\n+        let result = result?;\n \n         debug!(\"CACHE MISS: EVAL({:?})={:?}\",\n                fresh_trait_ref,\n                result);\n         self.insert_evaluation_cache(obligation.param_env, fresh_trait_ref, dep_node, result);\n \n-        result\n+        Ok(result)\n     }\n \n     fn evaluate_stack<'o>(&mut self,\n                           stack: &TraitObligationStack<'o, 'tcx>)\n-                          -> EvaluationResult\n+                          -> Result<EvaluationResult, OverflowError<'tcx>>\n     {\n         // In intercrate mode, whenever any of the types are unbound,\n         // there can always be an impl. Even if there are no impls in\n@@ -815,7 +839,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            return EvaluatedToAmbig;\n+            return Ok(EvaluatedToAmbig);\n         }\n         if unbound_input_types &&\n               stack.iter().skip(1).any(\n@@ -825,7 +849,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         {\n             debug!(\"evaluate_stack({:?}) --> unbound argument, recursive --> giving up\",\n                    stack.fresh_trait_ref);\n-            return EvaluatedToUnknown;\n+            return Ok(EvaluatedToUnknown);\n         }\n \n         // If there is any previous entry on the stack that precisely\n@@ -860,18 +884,19 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             if self.coinductive_match(cycle) {\n                 debug!(\"evaluate_stack({:?}) --> recursive, coinductive\",\n                        stack.fresh_trait_ref);\n-                return EvaluatedToOk;\n+                return Ok(EvaluatedToOk);\n             } else {\n                 debug!(\"evaluate_stack({:?}) --> recursive, inductive\",\n                        stack.fresh_trait_ref);\n-                return EvaluatedToRecur;\n+                return Ok(EvaluatedToRecur);\n             }\n         }\n \n         match self.candidate_from_obligation(stack) {\n             Ok(Some(c)) => self.evaluate_candidate(stack, &c),\n-            Ok(None) => EvaluatedToAmbig,\n-            Err(..) => EvaluatedToErr\n+            Ok(None) => Ok(EvaluatedToAmbig),\n+            Err(Overflow(o)) => Err(OverflowError(o)),\n+            Err(..) => Ok(EvaluatedToErr)\n         }\n     }\n \n@@ -909,7 +934,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn evaluate_candidate<'o>(&mut self,\n                               stack: &TraitObligationStack<'o, 'tcx>,\n                               candidate: &SelectionCandidate<'tcx>)\n-                              -> EvaluationResult\n+                              -> Result<EvaluationResult, OverflowError<'tcx>>\n     {\n         debug!(\"evaluate_candidate: depth={} candidate={:?}\",\n                stack.obligation.recursion_depth, candidate);\n@@ -921,12 +946,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         stack.list(),\n                         selection.nested_obligations().iter())\n                 }\n-                Err(..) => EvaluatedToErr\n+                Err(..) => Ok(EvaluatedToErr)\n             }\n-        });\n+        })?;\n         debug!(\"evaluate_candidate: depth={} result={:?}\",\n                stack.obligation.recursion_depth, result);\n-        result\n+        Ok(result)\n     }\n \n     fn check_evaluation_cache(&self,\n@@ -1000,7 +1025,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // not update) the cache.\n         let recursion_limit = *self.infcx.tcx.sess.recursion_limit.get();\n         if stack.obligation.recursion_depth >= recursion_limit {\n-            self.infcx().report_overflow_error(&stack.obligation, true);\n+            return Err(Overflow(stack.obligation.clone()));\n         }\n \n         // Check the cache. Note that we skolemize the trait-ref\n@@ -1081,9 +1106,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     debug!(\"evaluate_stack: intercrate_ambiguity_causes is some\");\n                     // Heuristics: show the diagnostics when there are no candidates in crate.\n                     if let Ok(candidate_set) = self.assemble_candidates(stack) {\n-                        if !candidate_set.ambiguous && candidate_set.vec.iter().all(|c| {\n-                            !self.evaluate_candidate(stack, &c).may_apply()\n-                        }) {\n+                        let no_candidates_apply =\n+                            candidate_set\n+                            .vec\n+                            .iter()\n+                            .map(|c| self.evaluate_candidate(stack, &c))\n+                            .collect::<Result<Vec<_>, OverflowError<'_>>>()?\n+                            .iter()\n+                            .all(|r| !r.may_apply());\n+                        if !candidate_set.ambiguous && no_candidates_apply {\n                             let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n                             let self_ty = trait_ref.self_ty();\n                             let trait_desc = trait_ref.to_string();\n@@ -1151,18 +1182,21 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         }\n \n         // Winnow, but record the exact outcome of evaluation, which\n-        // is needed for specialization.\n-        let mut candidates: Vec<_> = candidates.into_iter().filter_map(|c| {\n-            let eval = self.evaluate_candidate(stack, &c);\n-            if eval.may_apply() {\n-                Some(EvaluatedCandidate {\n+        // is needed for specialization. Propagate overflow if it occurs.\n+        let candidates: Result<Vec<Option<EvaluatedCandidate>>, _> = candidates\n+            .into_iter()\n+            .map(|c| match self.evaluate_candidate(stack, &c) {\n+                Ok(eval) if eval.may_apply() => Ok(Some(EvaluatedCandidate {\n                     candidate: c,\n                     evaluation: eval,\n-                })\n-            } else {\n-                None\n-            }\n-        }).collect();\n+                })),\n+                Ok(_) => Ok(None),\n+                Err(OverflowError(o)) => Err(Overflow(o)),\n+            })\n+            .collect();\n+\n+        let mut candidates: Vec<EvaluatedCandidate> =\n+            candidates?.into_iter().filter_map(|c| c).collect();\n \n         // If there are STILL multiple candidate, we can further\n         // reduce the list by dropping duplicates -- including\n@@ -1537,12 +1571,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let matching_bounds =\n             all_bounds.filter(|p| p.def_id() == stack.obligation.predicate.def_id());\n \n-        let matching_bounds =\n-            matching_bounds.filter(\n-                |bound| self.evaluate_where_clause(stack, bound.clone()).may_apply());\n-\n-        let param_candidates =\n-            matching_bounds.map(|bound| ParamCandidate(bound));\n+        // keep only those bounds which may apply, and propagate overflow if it occurs\n+        let mut param_candidates = vec![];\n+        for bound in matching_bounds {\n+            let wc = self.evaluate_where_clause(stack, bound.clone())?;\n+            if wc.may_apply() {\n+                param_candidates.push(ParamCandidate(bound));\n+            }\n+        }\n \n         candidates.vec.extend(param_candidates);\n \n@@ -1552,14 +1588,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn evaluate_where_clause<'o>(&mut self,\n                                  stack: &TraitObligationStack<'o, 'tcx>,\n                                  where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n-                                 -> EvaluationResult\n+                                 -> Result<EvaluationResult, OverflowError<'tcx>>\n     {\n         self.probe(move |this, _| {\n             match this.match_where_clause_trait_ref(stack.obligation, where_clause_trait_ref) {\n                 Ok(obligations) => {\n                     this.evaluate_predicates_recursively(stack.list(), obligations.iter())\n                 }\n-                Err(()) => EvaluatedToErr\n+                Err(()) => Ok(EvaluatedToErr)\n             }\n         })\n     }"}, {"sha": "c124cd7942a68ccc6efd78f1e2cc90b94cfcadcc", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/79f71f976a2c55794a120cb77cb8dfbf35bb0a25/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f71f976a2c55794a120cb77cb8dfbf35bb0a25/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=79f71f976a2c55794a120cb77cb8dfbf35bb0a25", "patch": "@@ -177,6 +177,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n             super::ConstEvalFailure(ref err) => {\n                 tcx.lift(err).map(super::ConstEvalFailure)\n             }\n+            super::Overflow(_) => bug!() // FIXME: ape ConstEvalFailure?\n         }\n     }\n }"}]}