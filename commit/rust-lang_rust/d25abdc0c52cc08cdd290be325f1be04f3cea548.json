{"sha": "d25abdc0c52cc08cdd290be325f1be04f3cea548", "node_id": "C_kwDOAAsO6NoAKGQyNWFiZGMwYzUyY2MwOGNkZDI5MGJlMzI1ZjFiZTA0ZjNjZWE1NDg", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-07-13T05:39:01Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-07-14T23:36:46Z"}, "message": "Point out custom Fn-family trait impl", "tree": {"sha": "c439ec566cdce1199ad5d9c8946ff2c791ae4d11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c439ec566cdce1199ad5d9c8946ff2c791ae4d11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d25abdc0c52cc08cdd290be325f1be04f3cea548", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d25abdc0c52cc08cdd290be325f1be04f3cea548", "html_url": "https://github.com/rust-lang/rust/commit/d25abdc0c52cc08cdd290be325f1be04f3cea548", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d25abdc0c52cc08cdd290be325f1be04f3cea548/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddb7003b7950a6df815d1f03ea6eca9f4cc2a408", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddb7003b7950a6df815d1f03ea6eca9f4cc2a408", "html_url": "https://github.com/rust-lang/rust/commit/ddb7003b7950a6df815d1f03ea6eca9f4cc2a408"}], "stats": {"total": 167, "additions": 114, "deletions": 53}, "files": [{"sha": "8ead05122740e6f9926828f9770d037a0537e6eb", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d25abdc0c52cc08cdd290be325f1be04f3cea548/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d25abdc0c52cc08cdd290be325f1be04f3cea548/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=d25abdc0c52cc08cdd290be325f1be04f3cea548", "patch": "@@ -128,6 +128,14 @@ impl<'tcx> ClosureKind {\n             None\n         }\n     }\n+\n+    pub fn to_def_id(&self, tcx: TyCtxt<'_>) -> DefId {\n+        match self {\n+            ClosureKind::Fn => tcx.lang_items().fn_once_trait().unwrap(),\n+            ClosureKind::FnMut => tcx.lang_items().fn_mut_trait().unwrap(),\n+            ClosureKind::FnOnce => tcx.lang_items().fn_trait().unwrap(),\n+        }\n+    }\n }\n \n /// A composite describing a `Place` that is captured by a closure."}, {"sha": "ec045d3e70c96d806f5e28b9885673ffc7e003ab", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 90, "deletions": 53, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/d25abdc0c52cc08cdd290be325f1be04f3cea548/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d25abdc0c52cc08cdd290be325f1be04f3cea548/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=d25abdc0c52cc08cdd290be325f1be04f3cea548", "patch": "@@ -21,6 +21,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::{ExprKind, Node, QPath};\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::error_reporting::{FailureCode, ObligationCauseExt};\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::InferOk;\n use rustc_infer::infer::TypeTrace;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n@@ -29,7 +30,9 @@ use rustc_middle::ty::{self, DefIdTree, IsSuggestable, Ty};\n use rustc_session::Session;\n use rustc_span::symbol::Ident;\n use rustc_span::{self, Span};\n-use rustc_trait_selection::traits::{self, ObligationCauseCode, StatementAsExpression};\n+use rustc_trait_selection::traits::{\n+    self, ObligationCauseCode, SelectionContext, StatementAsExpression,\n+};\n \n use std::iter;\n use std::slice;\n@@ -393,41 +396,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         if !call_appears_satisfied {\n-            // Next, let's construct the error\n-            let (error_span, full_call_span, ctor_of) = match &call_expr.kind {\n-                hir::ExprKind::Call(\n-                    hir::Expr {\n-                        span,\n-                        kind:\n-                            hir::ExprKind::Path(hir::QPath::Resolved(\n-                                _,\n-                                hir::Path { res: Res::Def(DefKind::Ctor(of, _), _), .. },\n-                            )),\n-                        ..\n-                    },\n-                    _,\n-                ) => (call_span, *span, Some(of)),\n-                hir::ExprKind::Call(hir::Expr { span, .. }, _) => (call_span, *span, None),\n-                hir::ExprKind::MethodCall(path_segment, _, span) => {\n-                    let ident_span = path_segment.ident.span;\n-                    let ident_span = if let Some(args) = path_segment.args {\n-                        ident_span.with_hi(args.span_ext.hi())\n-                    } else {\n-                        ident_span\n-                    };\n-                    (\n-                        *span, ident_span, None, // methods are never ctors\n-                    )\n-                }\n-                k => span_bug!(call_span, \"checking argument types on a non-call: `{:?}`\", k),\n-            };\n-            let args_span = error_span.trim_start(full_call_span).unwrap_or(error_span);\n-            let call_name = match ctor_of {\n-                Some(CtorOf::Struct) => \"struct\",\n-                Some(CtorOf::Variant) => \"enum variant\",\n-                None => \"function\",\n-            };\n-\n             let compatibility_diagonal = IndexVec::from_raw(compatibility_diagonal);\n             let provided_args = IndexVec::from_iter(provided_args.iter().take(if c_variadic {\n                 minimum_input_count\n@@ -451,13 +419,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 compatibility_diagonal,\n                 formal_and_expected_inputs,\n                 provided_args,\n-                full_call_span,\n-                error_span,\n-                args_span,\n-                call_name,\n                 c_variadic,\n                 err_code,\n                 fn_def_id,\n+                call_span,\n                 call_expr,\n             );\n         }\n@@ -468,15 +433,47 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         compatibility_diagonal: IndexVec<ProvidedIdx, Compatibility<'tcx>>,\n         formal_and_expected_inputs: IndexVec<ExpectedIdx, (Ty<'tcx>, Ty<'tcx>)>,\n         provided_args: IndexVec<ProvidedIdx, &'tcx hir::Expr<'tcx>>,\n-        full_call_span: Span,\n-        error_span: Span,\n-        args_span: Span,\n-        call_name: &str,\n         c_variadic: bool,\n         err_code: &str,\n         fn_def_id: Option<DefId>,\n+        call_span: Span,\n         call_expr: &hir::Expr<'tcx>,\n     ) {\n+        // Next, let's construct the error\n+        let (error_span, full_call_span, ctor_of) = match &call_expr.kind {\n+            hir::ExprKind::Call(\n+                hir::Expr {\n+                    span,\n+                    kind:\n+                        hir::ExprKind::Path(hir::QPath::Resolved(\n+                            _,\n+                            hir::Path { res: Res::Def(DefKind::Ctor(of, _), _), .. },\n+                        )),\n+                    ..\n+                },\n+                _,\n+            ) => (call_span, *span, Some(of)),\n+            hir::ExprKind::Call(hir::Expr { span, .. }, _) => (call_span, *span, None),\n+            hir::ExprKind::MethodCall(path_segment, _, span) => {\n+                let ident_span = path_segment.ident.span;\n+                let ident_span = if let Some(args) = path_segment.args {\n+                    ident_span.with_hi(args.span_ext.hi())\n+                } else {\n+                    ident_span\n+                };\n+                (\n+                    *span, ident_span, None, // methods are never ctors\n+                )\n+            }\n+            k => span_bug!(call_span, \"checking argument types on a non-call: `{:?}`\", k),\n+        };\n+        let args_span = error_span.trim_start(full_call_span).unwrap_or(error_span);\n+        let call_name = match ctor_of {\n+            Some(CtorOf::Struct) => \"struct\",\n+            Some(CtorOf::Variant) => \"enum variant\",\n+            None => \"function\",\n+        };\n+\n         // Don't print if it has error types or is just plain `_`\n         fn has_error_or_infer<'tcx>(tys: impl IntoIterator<Item = Ty<'tcx>>) -> bool {\n             tys.into_iter().any(|ty| ty.references_error() || ty.is_ty_var())\n@@ -1818,17 +1815,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn label_fn_like(\n         &self,\n         err: &mut rustc_errors::DiagnosticBuilder<'tcx, rustc_errors::ErrorGuaranteed>,\n-        def_id: Option<DefId>,\n+        callable_def_id: Option<DefId>,\n         callee_ty: Option<Ty<'tcx>>,\n     ) {\n-        let Some(mut def_id) = def_id else {\n+        let Some(mut def_id) = callable_def_id else {\n             return;\n         };\n \n         if let Some(assoc_item) = self.tcx.opt_associated_item(def_id)\n-            && let trait_def_id = assoc_item.trait_item_def_id.unwrap_or_else(|| self.tcx.parent(def_id))\n+            // Possibly points at either impl or trait item, so try to get it\n+            // to point to trait item, then get the parent.\n+            // This parent might be an impl in the case of an inherent function,\n+            // but the next check will fail.\n+            && let maybe_trait_item_def_id = assoc_item.trait_item_def_id.unwrap_or(def_id)\n+            && let maybe_trait_def_id = self.tcx.parent(maybe_trait_item_def_id)\n             // Just an easy way to check \"trait_def_id == Fn/FnMut/FnOnce\"\n-            && ty::ClosureKind::from_def_id(self.tcx, trait_def_id).is_some()\n+            && let Some(call_kind) = ty::ClosureKind::from_def_id(self.tcx, maybe_trait_def_id)\n             && let Some(callee_ty) = callee_ty\n         {\n             let callee_ty = callee_ty.peel_refs();\n@@ -1853,7 +1855,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             std::iter::zip(instantiated.predicates, instantiated.spans)\n                         {\n                             if let ty::PredicateKind::Trait(pred) = predicate.kind().skip_binder()\n-                                && pred.self_ty() == callee_ty\n+                                && pred.self_ty().peel_refs() == callee_ty\n                                 && ty::ClosureKind::from_def_id(self.tcx, pred.def_id()).is_some()\n                             {\n                                 err.span_note(span, \"callable defined here\");\n@@ -1862,11 +1864,46 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     }\n                 }\n-                ty::Opaque(new_def_id, _) | ty::Closure(new_def_id, _) | ty::FnDef(new_def_id, _) => {\n+                ty::Opaque(new_def_id, _)\n+                | ty::Closure(new_def_id, _)\n+                | ty::FnDef(new_def_id, _) => {\n                     def_id = new_def_id;\n                 }\n                 _ => {\n-                    return;\n+                    // Look for a user-provided impl of a `Fn` trait, and point to it.\n+                    let new_def_id = self.probe(|_| {\n+                        let trait_ref = ty::TraitRef::new(\n+                            call_kind.to_def_id(self.tcx),\n+                            self.tcx.mk_substs([\n+                                ty::GenericArg::from(callee_ty),\n+                                self.next_ty_var(TypeVariableOrigin {\n+                                    kind: TypeVariableOriginKind::MiscVariable,\n+                                    span: rustc_span::DUMMY_SP,\n+                                })\n+                                .into(),\n+                            ].into_iter()),\n+                        );\n+                        let obligation = traits::Obligation::new(\n+                            traits::ObligationCause::dummy(),\n+                            self.param_env,\n+                            ty::Binder::dummy(ty::TraitPredicate {\n+                                trait_ref,\n+                                constness: ty::BoundConstness::NotConst,\n+                                polarity: ty::ImplPolarity::Positive,\n+                            }),\n+                        );\n+                        match SelectionContext::new(&self).select(&obligation) {\n+                            Ok(Some(traits::ImplSource::UserDefined(impl_source))) => {\n+                                Some(impl_source.impl_def_id)\n+                            }\n+                            _ => None\n+                        }\n+                    });\n+                    if let Some(new_def_id) = new_def_id {\n+                        def_id = new_def_id;\n+                    } else {\n+                        return;\n+                    }\n                 }\n             }\n         }\n@@ -1888,8 +1925,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             let def_kind = self.tcx.def_kind(def_id);\n             err.span_note(spans, &format!(\"{} defined here\", def_kind.descr(def_id)));\n-        } else if let def_kind @ (DefKind::Closure | DefKind::OpaqueTy) = self.tcx.def_kind(def_id)\n-        {\n+        } else {\n+            let def_kind = self.tcx.def_kind(def_id);\n             err.span_note(\n                 self.tcx.def_span(def_id),\n                 &format!(\"{} defined here\", def_kind.descr(def_id)),"}, {"sha": "475ea9dfaf1b44d842c3d4dfbe2a11d73df2eea7", "filename": "src/test/ui/mismatched_types/overloaded-calls-bad.stderr", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d25abdc0c52cc08cdd290be325f1be04f3cea548/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d25abdc0c52cc08cdd290be325f1be04f3cea548/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.stderr?ref=d25abdc0c52cc08cdd290be325f1be04f3cea548", "patch": "@@ -5,13 +5,24 @@ LL |     let ans = s(\"what\");\n    |               - ^^^^^^ expected `isize`, found `&str`\n    |               |\n    |               arguments to this function are incorrect\n+   |\n+note: implementation defined here\n+  --> $DIR/overloaded-calls-bad.rs:10:1\n+   |\n+LL | impl FnMut<(isize,)> for S {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0057]: this function takes 1 argument but 0 arguments were supplied\n   --> $DIR/overloaded-calls-bad.rs:29:15\n    |\n LL |     let ans = s();\n    |               ^-- an argument of type `isize` is missing\n    |\n+note: implementation defined here\n+  --> $DIR/overloaded-calls-bad.rs:10:1\n+   |\n+LL | impl FnMut<(isize,)> for S {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: provide the argument\n    |\n LL |     let ans = s(/* isize */);\n@@ -25,6 +36,11 @@ LL |     let ans = s(\"burma\", \"shave\");\n    |                 |\n    |                 expected `isize`, found `&str`\n    |\n+note: implementation defined here\n+  --> $DIR/overloaded-calls-bad.rs:10:1\n+   |\n+LL | impl FnMut<(isize,)> for S {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: remove the extra argument\n    |\n LL |     let ans = s(/* isize */);"}]}