{"sha": "219924e669d98bfea2a6b48ac0b0638df1234432", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxOTkyNGU2NjlkOThiZmVhMmE2YjQ4YWMwYjA2MzhkZjEyMzQ0MzI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-06-16T18:56:34Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-06-16T19:13:20Z"}, "message": "Bring back if-check\n\nAdd \"if check\" (expr_if_check), a variation on check that executes\nan \"else\" clause rather than failing if the check doesn't hold.", "tree": {"sha": "b660125cac88695e7a935afa2b7f58d8c047a47c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b660125cac88695e7a935afa2b7f58d8c047a47c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/219924e669d98bfea2a6b48ac0b0638df1234432", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/219924e669d98bfea2a6b48ac0b0638df1234432", "html_url": "https://github.com/rust-lang/rust/commit/219924e669d98bfea2a6b48ac0b0638df1234432", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/219924e669d98bfea2a6b48ac0b0638df1234432/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94ae4590c51663cca69543bdad5a9efae46c755a", "url": "https://api.github.com/repos/rust-lang/rust/commits/94ae4590c51663cca69543bdad5a9efae46c755a", "html_url": "https://github.com/rust-lang/rust/commit/94ae4590c51663cca69543bdad5a9efae46c755a"}], "stats": {"total": 391, "additions": 258, "deletions": 133}, "files": [{"sha": "b07d3d9fd80ab850b096150f584f656720a826a0", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/219924e669d98bfea2a6b48ac0b0638df1234432/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/219924e669d98bfea2a6b48ac0b0638df1234432/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=219924e669d98bfea2a6b48ac0b0638df1234432", "patch": "@@ -269,6 +269,9 @@ tag expr_ {\n \n     /* preds that typestate is aware of */\n     expr_check(@expr, ann);\n+   /* FIXME Would be nice if expr_check desugared\n+      to expr_if_check. */\n+    expr_if_check(@expr, block, option::t[@expr], ann);\n     expr_port(ann);\n     expr_chan(@expr, ann);\n     expr_anon_obj(anon_obj, vec[ty_param], obj_def_ids, ann);"}, {"sha": "65f30195b141d3d7fdabfd949f61191f98d00b9b", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/219924e669d98bfea2a6b48ac0b0638df1234432/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/219924e669d98bfea2a6b48ac0b0638df1234432/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=219924e669d98bfea2a6b48ac0b0638df1234432", "patch": "@@ -1187,7 +1187,9 @@ fn parse_assign_expr(&parser p) -> @ast::expr {\n     ret lhs;\n }\n \n-fn parse_if_expr(&parser p) -> @ast::expr {\n+fn parse_if_expr_1(&parser p) -> tup(@ast::expr,\n+                                     ast::block, option::t[@ast::expr],\n+                                     ast::ann, uint, uint) {\n     auto lo = p.get_last_lo_pos();\n     expect(p, token::LPAREN);\n     auto cond = parse_expr(p);\n@@ -1200,7 +1202,20 @@ fn parse_if_expr(&parser p) -> @ast::expr {\n         els = some(elexpr);\n         hi = elexpr.span.hi;\n     }\n-    ret @spanned(lo, hi, ast::expr_if(cond, thn, els, p.get_ann()));\n+    ret tup(cond, thn, els, p.get_ann(), lo, hi);\n+}\n+\n+fn parse_if_expr(&parser p) -> @ast::expr {\n+    auto lo = p.get_last_lo_pos();\n+    if (eat_word(p, \"check\")) {\n+            auto q = parse_if_expr_1(p);\n+            ret @spanned(q._4, q._5,\n+                         ast::expr_if_check(q._0, q._1, q._2, q._3));\n+    }\n+    else {\n+        auto q = parse_if_expr_1(p);\n+        ret @spanned(q._4, q._5, ast::expr_if(q._0, q._1, q._2, q._3));\n+    }\n }\n \n fn parse_fn_expr(&parser p) -> @ast::expr {"}, {"sha": "6c79f12cffa000e2e943f49364ff1ec415038f0c", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/219924e669d98bfea2a6b48ac0b0638df1234432/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/219924e669d98bfea2a6b48ac0b0638df1234432/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=219924e669d98bfea2a6b48ac0b0638df1234432", "patch": "@@ -5516,6 +5516,10 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n             ret with_out_method(bind trans_if(cx, cond, thn, els, ann, _), cx,\n                                 ann, output);\n         }\n+        case (ast::expr_if_check(?cond, ?thn, ?els, ?ann)) {\n+            ret with_out_method(bind trans_if(cx, cond, thn, els, ann, _), cx,\n+                                ann, output);\n+        }\n         case (ast::expr_for(?decl, ?seq, ?body, _)) {\n             ret trans_for(cx, decl, seq, body);\n         }\n@@ -5689,7 +5693,8 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n         }\n         case (_) {\n             // The expression is an lvalue. Fall through.\n-\n+            assert (ty::is_lval(e)); // make sure it really is and that we \n+                               // didn't forget to add a case for a new expr!\n         }\n     }\n     // lval cases fall through to trans_lval and then"}, {"sha": "587caf244b3420886d32504d8d121c16e4330498", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/219924e669d98bfea2a6b48ac0b0638df1234432/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/219924e669d98bfea2a6b48ac0b0638df1234432/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=219924e669d98bfea2a6b48ac0b0638df1234432", "patch": "@@ -37,6 +37,9 @@ fn collect_pred(&ctxt cx, &@expr e) {\n         case (expr_check(?e, _)) {\n             vec::push(*cx.cs, expr_to_constr(cx.tcx, e));\n         }\n+        case (expr_if_check(?e, _, _, _)) {\n+            vec::push(*cx.cs, expr_to_constr(cx.tcx, e));\n+        }\n         // If it's a call, generate appropriate instances of the\n         // call's constraints.\n         case (expr_call(?operator, ?operands, ?a)) {"}, {"sha": "5cc5679d2dd1d25ba763e7eab9b927aa0ad670b7", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 60, "deletions": 44, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/219924e669d98bfea2a6b48ac0b0638df1234432/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/219924e669d98bfea2a6b48ac0b0638df1234432/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=219924e669d98bfea2a6b48ac0b0638df1234432", "patch": "@@ -172,6 +172,52 @@ fn find_pre_post_loop(&fn_ctxt fcx, &@local l, &@expr index, &block body,\n     set_pre_and_post(fcx.ccx, a, loop_precond, loop_postcond);\n }\n \n+// Generates a pre/post assuming that a is the \n+// annotation for an if-expression with consequent conseq\n+// and alternative maybe_alt\n+fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n+                  &option::t[@expr] maybe_alt, &ann a) {\n+    auto num_local_vars = num_constraints(fcx.enclosing);\n+    find_pre_post_block(fcx, conseq);\n+    alt (maybe_alt) {\n+        case (none) {\n+            auto precond_res =\n+                seq_preconds(fcx,\n+                             [expr_pp(fcx.ccx, antec),\n+                              block_pp(fcx.ccx, conseq)]);\n+            set_pre_and_post(fcx.ccx, a, precond_res,\n+                             expr_poststate(fcx.ccx, antec));\n+        }\n+        case (some(?altern)) {\n+            find_pre_post_expr(fcx, altern);\n+            auto precond_true_case =\n+                seq_preconds(fcx,\n+                             [expr_pp(fcx.ccx, antec),\n+                              block_pp(fcx.ccx, conseq)]);\n+            auto postcond_true_case =\n+                union_postconds(num_local_vars,\n+                                [expr_postcond(fcx.ccx, antec),\n+                                 block_postcond(fcx.ccx, conseq)]);\n+            auto precond_false_case =\n+                seq_preconds(fcx,\n+                             [expr_pp(fcx.ccx, antec),\n+                              expr_pp(fcx.ccx, altern)]);\n+            auto postcond_false_case =\n+                union_postconds(num_local_vars,\n+                                [expr_postcond(fcx.ccx, antec),\n+                                 expr_postcond(fcx.ccx, altern)]);\n+            auto precond_res =\n+                union_postconds(num_local_vars,\n+                                [precond_true_case,\n+                                 precond_false_case]);\n+            auto postcond_res =\n+                intersect_postconds([postcond_true_case,\n+                                     postcond_false_case]);\n+            set_pre_and_post(fcx.ccx, a, precond_res, postcond_res);\n+        }\n+    }\n+}\n+\n fn gen_if_local(&fn_ctxt fcx, @expr lhs, @expr rhs, &ann larger_ann,\n                 &ann new_var, &path pth) {\n     alt (ann_to_def(fcx.ccx, new_var)) {\n@@ -345,47 +391,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n         }\n         case (expr_if(?antec, ?conseq, ?maybe_alt, ?a)) {\n             find_pre_post_expr(fcx, antec);\n-            find_pre_post_block(fcx, conseq);\n-            alt (maybe_alt) {\n-                case (none) {\n-                    log \"333\";\n-                    auto precond_res =\n-                        seq_preconds(fcx,\n-                                     [expr_pp(fcx.ccx, antec),\n-                                      block_pp(fcx.ccx, conseq)]);\n-                    set_pre_and_post(fcx.ccx, a, precond_res,\n-                                     expr_poststate(fcx.ccx, antec));\n-                }\n-                case (some(?altern)) {\n-                    find_pre_post_expr(fcx, altern);\n-                    log \"444\";\n-                    auto precond_true_case =\n-                        seq_preconds(fcx,\n-                                     [expr_pp(fcx.ccx, antec),\n-                                      block_pp(fcx.ccx, conseq)]);\n-                    auto postcond_true_case =\n-                        union_postconds(num_local_vars,\n-                                        [expr_postcond(fcx.ccx, antec),\n-                                         block_postcond(fcx.ccx, conseq)]);\n-                    log \"555\";\n-                    auto precond_false_case =\n-                        seq_preconds(fcx,\n-                                     [expr_pp(fcx.ccx, antec),\n-                                      expr_pp(fcx.ccx, altern)]);\n-                    auto postcond_false_case =\n-                        union_postconds(num_local_vars,\n-                                        [expr_postcond(fcx.ccx, antec),\n-                                         expr_postcond(fcx.ccx, altern)]);\n-                    auto precond_res =\n-                        union_postconds(num_local_vars,\n-                                        [precond_true_case,\n-                                         precond_false_case]);\n-                    auto postcond_res =\n-                        intersect_postconds([postcond_true_case,\n-                                             postcond_false_case]);\n-                    set_pre_and_post(fcx.ccx, a, precond_res, postcond_res);\n-                }\n-            }\n+            join_then_else(fcx, antec, conseq, maybe_alt, a);\n         }\n         case (expr_binary(?bop, ?l, ?r, ?a)) {\n             /* *unless* bop is lazy (e.g. and, or)? \n@@ -484,16 +490,26 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n             copy_pre_post(fcx.ccx, a, p);\n         }\n         case (expr_check(?p, ?a)) {\n-            /* FIXME: Can we bypass this by having a\n-             node-id-to-constr_occ table? */\n-\n             find_pre_post_expr(fcx, p);\n             copy_pre_post(fcx.ccx, a, p);\n             /* predicate p holds after this expression executes */\n \n             let aux::constr c = expr_to_constr(fcx.ccx.tcx, p);\n             gen(fcx, a, c.node);\n         }\n+        case (expr_if_check(?p, ?conseq, ?maybe_alt, ?a)) {\n+            find_pre_post_expr(fcx, p);\n+            copy_pre_post(fcx.ccx, a, p);\n+            /* the typestate for the whole expression */\n+            join_then_else(fcx, p, conseq, maybe_alt, a);\n+\n+            /* predicate p holds inside the \"thn\" expression */\n+            /* (so far, the negation of p does *not* hold inside\n+             the \"elsopt\" expression) */\n+            let aux::constr c = expr_to_constr(fcx.ccx.tcx, p);\n+            gen(fcx, conseq.node.a, c.node);\n+        }\n+\n         case (expr_bind(?operator, ?maybe_args, ?a)) {\n             auto args = vec::cat_options[@expr](maybe_args);\n             vec::push[@expr](args, operator); /* ??? order of eval? */"}, {"sha": "856b8c3f981f7634eeb31c353529b76b8b0b9d51", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 45, "deletions": 31, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/219924e669d98bfea2a6b48ac0b0638df1234432/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/219924e669d98bfea2a6b48ac0b0638df1234432/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=219924e669d98bfea2a6b48ac0b0638df1234432", "patch": "@@ -129,6 +129,38 @@ fn gen_if_local(&fn_ctxt fcx, &ann a_new_var, &ann a, &path p) -> bool {\n     }\n }\n \n+fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n+                  &option::t[@expr] maybe_alt, &ann a) -> bool {\n+    auto changed = false;\n+\n+    changed =\n+        find_pre_post_state_block(fcx, expr_poststate(fcx.ccx, antec),\n+                                  conseq) || changed;\n+    alt (maybe_alt) {\n+        case (none) {\n+            changed =\n+                extend_poststate_ann(fcx.ccx, a,\n+                                     expr_poststate(fcx.ccx, antec))\n+                || changed;\n+        }\n+        case (some(?altern)) {\n+            changed =\n+                find_pre_post_state_expr(fcx,\n+                                         expr_poststate(fcx.ccx,\n+                                                        antec),\n+                                         altern) || changed;\n+            auto poststate_res =\n+                intersect_postconds([block_poststate(fcx.ccx, conseq),\n+                                     expr_poststate(fcx.ccx,\n+                                                    altern)]);\n+            changed =\n+                extend_poststate_ann(fcx.ccx, a, poststate_res) ||\n+                changed;\n+        }\n+    }\n+    ret changed;\n+}\n+\n fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n     auto changed = false;\n     auto num_local_vars = num_constraints(fcx.enclosing);\n@@ -407,37 +439,9 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n         case (expr_if(?antec, ?conseq, ?maybe_alt, ?a)) {\n             changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n             changed = find_pre_post_state_expr(fcx, pres, antec) || changed;\n-            changed =\n-                find_pre_post_state_block(fcx, expr_poststate(fcx.ccx, antec),\n-                                          conseq) || changed;\n-            alt (maybe_alt) {\n-                case (none) {\n-                    changed =\n-                        extend_poststate_ann(fcx.ccx, a,\n-                                             expr_poststate(fcx.ccx, antec))\n-                            || changed;\n-                }\n-                case (some(?altern)) {\n-                    changed =\n-                        find_pre_post_state_expr(fcx,\n-                                                 expr_poststate(fcx.ccx,\n-                                                                antec),\n-                                                 altern) || changed;\n-                    auto poststate_res =\n-                        intersect_postconds([block_poststate(fcx.ccx, conseq),\n-                                             expr_poststate(fcx.ccx,\n-                                                            altern)]);\n-                    changed =\n-                        extend_poststate_ann(fcx.ccx, a, poststate_res) ||\n-                            changed;\n-                }\n-            }\n-            log \"if:\";\n-            log_expr(*e);\n-            log \"new prestate:\";\n-            log_bitv(fcx, pres);\n-            log \"new poststate:\";\n-            log_bitv(fcx, expr_poststate(fcx.ccx, e));\n+            changed = join_then_else(fcx, antec, conseq, maybe_alt, a)\n+                || changed;\n+\n             ret changed;\n         }\n         case (expr_binary(?bop, ?l, ?r, ?a)) {\n@@ -613,6 +617,16 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n             changed = gen_poststate(fcx, a, c.node) || changed;\n             ret changed;\n         }\n+        case (expr_if_check(?p, ?conseq, ?maybe_alt, ?a)) {\n+            changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+            changed = find_pre_post_state_expr(fcx, pres, p) || changed;\n+            let aux::constr c = expr_to_constr(fcx.ccx.tcx, p);\n+            changed = gen_poststate(fcx, expr_ann(p), c.node) || changed;\n+            \n+            changed = join_then_else(fcx, p, conseq, maybe_alt, a)\n+                || changed;\n+            ret changed;\n+        }\n         case (expr_break(?a)) { ret pure_exp(fcx.ccx, a, pres); }\n         case (expr_cont(?a)) { ret pure_exp(fcx.ccx, a, pres); }\n         case (expr_port(?a)) { ret pure_exp(fcx.ccx, a, pres); }"}, {"sha": "7a6d0f6b0b723ed8c91dc5fbcd2ebf62454f4c36", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/219924e669d98bfea2a6b48ac0b0638df1234432/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/219924e669d98bfea2a6b48ac0b0638df1234432/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=219924e669d98bfea2a6b48ac0b0638df1234432", "patch": "@@ -1519,6 +1519,7 @@ fn expr_ann(&@ast::expr e) -> ast::ann {\n         case (ast::expr_lit(_, ?a)) { ret a; }\n         case (ast::expr_cast(_, _, ?a)) { ret a; }\n         case (ast::expr_if(_, _, _, ?a)) { ret a; }\n+        case (ast::expr_if_check(_, _, _, ?a)) { ret a; }\n         case (ast::expr_while(_, _, ?a)) { ret a; }\n         case (ast::expr_for(_, _, _, ?a)) { ret a; }\n         case (ast::expr_for_each(_, _, _, ?a)) { ret a; }"}, {"sha": "7ac053a9b16f4f42fd789135b369744d6e3a0de4", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 69, "deletions": 51, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/219924e669d98bfea2a6b48ac0b0638df1234432/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/219924e669d98bfea2a6b48ac0b0638df1234432/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=219924e669d98bfea2a6b48ac0b0638df1234432", "patch": "@@ -1453,6 +1453,68 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n         auto typ = ty::mk_nil(fcx.ccx.tcx);\n         write::ty_only_fixup(fcx, node_id, typ);\n     }\n+\n+    // A generic function for checking the pred in a check\n+    // or if-check\n+    fn check_pred_expr(&@fn_ctxt fcx, &@ast::expr e) {\n+        check_expr(fcx, e);\n+        demand::simple(fcx, e.span, ty::mk_bool(fcx.ccx.tcx),\n+                       expr_ty(fcx.ccx.tcx, e));\n+        \n+        /* e must be a call expr where all arguments are either\n+           literals or slots */\n+            alt (e.node) {\n+                case (ast::expr_call(?operator, ?operands, _)) {\n+                    alt (operator.node) {\n+                        case (ast::expr_path(?oper_name, ?ann)) {\n+                            auto d_id;\n+                            alt (fcx.ccx.tcx.def_map.get(ann.id)) {\n+                                case (ast::def_fn(?_d_id)) { d_id = _d_id; }\n+                            }\n+                            for (@ast::expr operand in operands) {\n+                                if (!ast::is_constraint_arg(operand)) {\n+                                    auto s = \"Constraint args must be \\\n+                                              slot variables or literals\";\n+                                    fcx.ccx.tcx.sess.span_err(e.span, s);\n+                                }\n+                            }\n+                            require_pure_function(fcx.ccx, d_id, e.span);\n+                         }\n+                        case (_) {\n+                            auto s = \"In a constraint, expected the \\\n+                                      constraint name to be an explicit name\";\n+                            fcx.ccx.tcx.sess.span_err(e.span,s);\n+                        }\n+                    }\n+                }\n+                case (_) {\n+                    fcx.ccx.tcx.sess.span_err(e.span,\n+                                              \"check on non-predicate\");\n+                }\n+            }\n+    }\n+\n+    // A generic function for checking the then and else in an if\n+    // or if-check\n+    fn check_then_else(&@fn_ctxt fcx, &ast::block thn,\n+                       &option::t[@ast::expr] elsopt, &ann a, &span sp) {\n+        check_block(fcx, thn);\n+        auto if_t =\n+            alt (elsopt) {\n+                    case (some(?els)) {\n+                        check_expr(fcx, els);\n+                        auto thn_t = block_ty(fcx.ccx.tcx, thn);\n+                        auto elsopt_t = expr_ty(fcx.ccx.tcx, els);\n+                        demand::simple(fcx, sp, thn_t, elsopt_t);\n+                        if (!ty::type_is_bot(fcx.ccx.tcx, elsopt_t)) {\n+                            elsopt_t\n+                                } else { thn_t }\n+                    }\n+                    case (none) { ty::mk_nil(fcx.ccx.tcx) }\n+            };\n+        write::ty_only_fixup(fcx, a.id, if_t);\n+    }\n+\n     alt (expr.node) {\n         case (ast::expr_lit(?lit, ?a)) {\n             auto typ = check_lit(fcx.ccx, lit);\n@@ -1586,42 +1648,12 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             write::nil_ty(fcx.ccx.tcx, a.id);\n         }\n         case (ast::expr_check(?e, ?a)) {\n-            check_expr(fcx, e);\n-            demand::simple(fcx, expr.span, ty::mk_bool(fcx.ccx.tcx),\n-                           expr_ty(fcx.ccx.tcx, e));\n-\n-            /* e must be a call expr where all arguments are either\n-             literals or slots */\n-            alt (e.node) {\n-                case (ast::expr_call(?operator, ?operands, _)) {\n-                    alt (operator.node) {\n-                        case (ast::expr_path(?oper_name, ?ann)) {\n-                            auto d_id;\n-                            alt (fcx.ccx.tcx.def_map.get(ann.id)) {\n-                                case (ast::def_fn(?_d_id)) { d_id = _d_id; }\n-                            }\n-                            for (@ast::expr operand in operands) {\n-                                if (!ast::is_constraint_arg(operand)) {\n-                                    auto s = \"Constraint args must be \\\n-                                              slot variables or literals\";\n-                                    fcx.ccx.tcx.sess.span_err(expr.span, s);\n-                                }\n-                            }\n-                            require_pure_function(fcx.ccx, d_id, expr.span);\n-                            write::nil_ty(fcx.ccx.tcx, a.id);\n-                        }\n-                        case (_) {\n-                            auto s = \"In a constraint, expected the \\\n-                                      constraint name to be an explicit name\";\n-                            fcx.ccx.tcx.sess.span_err(expr.span,s);\n-                        }\n-                    }\n-                }\n-                case (_) {\n-                    fcx.ccx.tcx.sess.span_err(expr.span,\n-                                              \"check on non-predicate\");\n-                }\n-            }\n+            check_pred_expr(fcx, e);\n+            write::nil_ty(fcx.ccx.tcx, a.id);\n+        }\n+        case (ast::expr_if_check(?cond, ?thn, ?elsopt, ?a)) {\n+            check_pred_expr(fcx, cond);\n+            check_then_else(fcx, thn, elsopt, a, expr.span);\n         }\n         case (ast::expr_assert(?e, ?a)) {\n             check_expr(fcx, e);\n@@ -1676,21 +1708,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n         }\n         case (ast::expr_if(?cond, ?thn, ?elsopt, ?a)) {\n             check_expr(fcx, cond);\n-            check_block(fcx, thn);\n-            auto if_t =\n-                alt (elsopt) {\n-                    case (some(?els)) {\n-                        check_expr(fcx, els);\n-                        auto thn_t = block_ty(fcx.ccx.tcx, thn);\n-                        auto elsopt_t = expr_ty(fcx.ccx.tcx, els);\n-                        demand::simple(fcx, expr.span, thn_t, elsopt_t);\n-                        if (!ty::type_is_bot(fcx.ccx.tcx, elsopt_t)) {\n-                            elsopt_t\n-                        } else { thn_t }\n-                    }\n-                    case (none) { ty::mk_nil(fcx.ccx.tcx) }\n-                };\n-            write::ty_only_fixup(fcx, a.id, if_t);\n+            check_then_else(fcx, thn, elsopt, a, expr.span);\n         }\n         case (ast::expr_for(?decl, ?seq, ?body, ?a)) {\n             check_expr(fcx, seq);"}, {"sha": "fe0a19be9fc2f2990bd03bfa3e07aa79f75449d3", "filename": "src/comp/middle/visit.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/219924e669d98bfea2a6b48ac0b0638df1234432/src%2Fcomp%2Fmiddle%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/219924e669d98bfea2a6b48ac0b0638df1234432/src%2Fcomp%2Fmiddle%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fvisit.rs?ref=219924e669d98bfea2a6b48ac0b0638df1234432", "patch": "@@ -279,6 +279,11 @@ fn visit_expr[E](&@expr ex, &E e, &vt[E] v) {\n             vt(v).visit_block(b, e, v);\n             visit_expr_opt(eo, e, v);\n         }\n+        case (expr_if_check(?x, ?b, ?eo, _)) {\n+            vt(v).visit_expr(x, e, v);\n+            vt(v).visit_block(b, e, v);\n+            visit_expr_opt(eo, e, v);\n+        }\n         case (expr_while(?x, ?b, _)) {\n             vt(v).visit_expr(x, e, v);\n             vt(v).visit_block(b, e, v);"}, {"sha": "c055adde49d71340c07237691cac71d26818fcf3", "filename": "src/comp/middle/walk.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/219924e669d98bfea2a6b48ac0b0638df1234432/src%2Fcomp%2Fmiddle%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/219924e669d98bfea2a6b48ac0b0638df1234432/src%2Fcomp%2Fmiddle%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fwalk.rs?ref=219924e669d98bfea2a6b48ac0b0638df1234432", "patch": "@@ -310,6 +310,12 @@ fn walk_expr(&ast_visitor v, @ast::expr e) {\n             walk_block(v, b);\n             walk_expr_opt(v, eo);\n         }\n+        case (ast::expr_if_check(?x, ?b, ?eo, _)) {\n+            walk_expr(v, x);\n+            walk_block(v, b);\n+            walk_expr_opt(v, eo);\n+        }\n+        \n         case (ast::expr_while(?x, ?b, _)) {\n             walk_expr(v, x);\n             walk_block(v, b);"}, {"sha": "1de7bd991bd77b77026eed552b4d1931bfc0e3c6", "filename": "src/test/run-fail/if-check-fail.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/219924e669d98bfea2a6b48ac0b0638df1234432/src%2Ftest%2Frun-fail%2Fif-check-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/219924e669d98bfea2a6b48ac0b0638df1234432/src%2Ftest%2Frun-fail%2Fif-check-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fif-check-fail.rs?ref=219924e669d98bfea2a6b48ac0b0638df1234432", "patch": "@@ -0,0 +1,26 @@\n+// xfail-stage0\n+// error-pattern:Number is odd\n+pred even(uint x) -> bool {\n+  if (x < 2) {\n+    ret false;\n+  }\n+  else if (x == 2) {\n+    ret true;\n+  }\n+  else {\n+    ret even(x - 2);\n+  }\n+}\n+\n+fn foo(uint x) -> () {\n+  if check(even(x)) { \n+      log x;\n+    }\n+  else {\n+    fail \"Number is odd\";\n+  }\n+}\n+\n+fn main() {\n+  foo(3u);\n+}"}, {"sha": "32e4fed6656414ef8e093b73bec32e484a3fce0d", "filename": "src/test/run-pass/if-check.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/219924e669d98bfea2a6b48ac0b0638df1234432/src%2Ftest%2Frun-pass%2Fif-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/219924e669d98bfea2a6b48ac0b0638df1234432/src%2Ftest%2Frun-pass%2Fif-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fif-check.rs?ref=219924e669d98bfea2a6b48ac0b0638df1234432", "patch": "@@ -1,6 +1,19 @@\n // xfail-stage0\n-fn foo(int x) -> () {\n-  if check even(x) { \n+\n+pred even(uint x) -> bool {\n+  if (x < 2) {\n+    ret false;\n+  }\n+  else if (x == 2) {\n+    ret true;\n+  }\n+  else {\n+    ret even(x - 2);\n+  }\n+}\n+\n+fn foo(uint x) -> () {\n+  if check(even(x)) { \n       log x;\n     }\n   else {\n@@ -9,5 +22,5 @@ fn foo(int x) -> () {\n }\n \n fn main() {\n-  foo(2);\n-}\n\\ No newline at end of file\n+  foo(2u);\n+}"}]}