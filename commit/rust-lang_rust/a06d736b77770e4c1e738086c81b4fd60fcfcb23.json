{"sha": "a06d736b77770e4c1e738086c81b4fd60fcfcb23", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwNmQ3MzZiNzc3NzBlNGMxZTczODA4NmM4MWI0ZmQ2MGZjZmNiMjM=", "commit": {"author": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-08-31T08:26:55Z"}, "committer": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-10-08T01:59:31Z"}, "message": "Add support for struct & trait methods", "tree": {"sha": "e70d61afec0cb7cf71c4ad2636a7adb8186a7a2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e70d61afec0cb7cf71c4ad2636a7adb8186a7a2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a06d736b77770e4c1e738086c81b4fd60fcfcb23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a06d736b77770e4c1e738086c81b4fd60fcfcb23", "html_url": "https://github.com/rust-lang/rust/commit/a06d736b77770e4c1e738086c81b4fd60fcfcb23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a06d736b77770e4c1e738086c81b4fd60fcfcb23/comments", "author": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfda0d25834250a3adbcd0d26953a1cdc6662e7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfda0d25834250a3adbcd0d26953a1cdc6662e7f", "html_url": "https://github.com/rust-lang/rust/commit/bfda0d25834250a3adbcd0d26953a1cdc6662e7f"}], "stats": {"total": 90, "additions": 83, "deletions": 7}, "files": [{"sha": "1e102997f29f42ce7c87fda71e9be6a4e75c8a4e", "filename": "crates/ide/src/link_rewrite.rs", "status": "modified", "additions": 83, "deletions": 7, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/a06d736b77770e4c1e738086c81b4fd60fcfcb23/crates%2Fide%2Fsrc%2Flink_rewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a06d736b77770e4c1e738086c81b4fd60fcfcb23/crates%2Fide%2Fsrc%2Flink_rewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flink_rewrite.rs?ref=a06d736b77770e4c1e738086c81b4fd60fcfcb23", "patch": "@@ -91,7 +91,6 @@ pub fn remove_links(markdown: &str) -> String {\n }\n \n pub fn get_doc_link<T: Resolvable + Clone>(db: &dyn HirDatabase, definition: &T) -> Option<String> {\n-    eprintln!(\"hir::doc_links::get_doc_link\");\n     let module_def = definition.clone().try_into_module_def()?;\n \n     get_doc_link_impl(db, &module_def)\n@@ -105,8 +104,31 @@ pub fn get_doc_link<T: Resolvable + Clone>(db: &dyn HirDatabase, definition: &T)\n // BUG: For methods\n // import_map.path_of(ns) fails, is not designed to resolve methods\n fn get_doc_link_impl(db: &dyn HirDatabase, moddef: &ModuleDef) -> Option<String> {\n-    eprintln!(\"get_doc_link_impl: {:#?}\", moddef);\n-    let ns = ItemInNs::Types(moddef.clone().into());\n+    // Get the outermost definition for the moduledef. This is used to resolve the public path to the type,\n+    // then we can join the method, field, etc onto it if required.\n+    let target_def: ModuleDef = match moddef {\n+        ModuleDef::Function(f) => match f.as_assoc_item(db).map(|assoc| assoc.container(db)) {\n+            Some(AssocItemContainer::Trait(t)) => t.into(),\n+            Some(AssocItemContainer::ImplDef(imp)) => {\n+                let resolver = ModuleId::from(imp.module(db)).resolver(db.upcast());\n+                let ctx = TyLoweringContext::new(db, &resolver);\n+                Adt::from(\n+                    Ty::from_hir(\n+                        &ctx,\n+                        &imp.target_trait(db).unwrap_or_else(|| imp.target_type(db)),\n+                    )\n+                    .as_adt()\n+                    .map(|t| t.0)\n+                    .unwrap(),\n+                )\n+                .into()\n+            }\n+            None => ModuleDef::Function(*f),\n+        },\n+        moddef => *moddef,\n+    };\n+\n+    let ns = ItemInNs::Types(target_def.clone().into());\n \n     let module = moddef.module(db)?;\n     let krate = module.krate();\n@@ -117,7 +139,28 @@ fn get_doc_link_impl(db: &dyn HirDatabase, moddef: &ModuleDef) -> Option<String>\n \n     get_doc_url(db, &krate)\n         .and_then(|url| url.join(&base).ok())\n-        .and_then(|url| get_symbol_filename(db, &moddef).as_deref().and_then(|f| url.join(f).ok()))\n+        .and_then(|url| {\n+            get_symbol_filename(db, &target_def).as_deref().and_then(|f| url.join(f).ok())\n+        })\n+        .and_then(|url| match moddef {\n+            ModuleDef::Function(f) => {\n+                get_symbol_fragment(db, &FieldOrAssocItem::AssocItem(AssocItem::Function(*f)))\n+                    .as_deref()\n+                    .and_then(|f| url.join(f).ok())\n+            }\n+            ModuleDef::Const(c) => {\n+                get_symbol_fragment(db, &FieldOrAssocItem::AssocItem(AssocItem::Const(*c)))\n+                    .as_deref()\n+                    .and_then(|f| url.join(f).ok())\n+            }\n+            ModuleDef::TypeAlias(ty) => {\n+                get_symbol_fragment(db, &FieldOrAssocItem::AssocItem(AssocItem::TypeAlias(*ty)))\n+                    .as_deref()\n+                    .and_then(|f| url.join(f).ok())\n+            }\n+            // TODO:  Field <- this requires passing in a definition or something\n+            _ => Some(url),\n+        })\n         .map(|url| url.into_string())\n }\n \n@@ -307,6 +350,12 @@ fn ns_from_intra_spec(s: &str) -> Option<hir::Namespace> {\n     .next()\n }\n \n+/// Get the root URL for the documentation of a crate.\n+///\n+/// ```\n+/// https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next\n+/// ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+/// ```\n fn get_doc_url(db: &RootDatabase, krate: &Crate) -> Option<Url> {\n     krate\n         .get_html_root_url(db)\n@@ -323,8 +372,11 @@ fn get_doc_url(db: &RootDatabase, krate: &Crate) -> Option<Url> {\n \n /// Get the filename and extension generated for a symbol by rustdoc.\n ///\n-/// Example: `struct.Shard.html`\n-fn get_symbol_filename(db: &RootDatabase, definition: &ModuleDef) -> Option<String> {\n+/// ```\n+/// https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next\n+///                                    ^^^^^^^^^^^^^^^^^^^\n+/// ```\n+fn get_symbol_filename(db: &dyn HirDatabase, definition: &ModuleDef) -> Option<String> {\n     Some(match definition {\n         ModuleDef::Adt(adt) => match adt {\n             Adt::Struct(s) => format!(\"struct.{}.html\", s.name(db)),\n@@ -334,7 +386,7 @@ fn get_symbol_filename(db: &RootDatabase, definition: &ModuleDef) -> Option<Stri\n         ModuleDef::Module(_) => \"index.html\".to_string(),\n         ModuleDef::Trait(t) => format!(\"trait.{}.html\", t.name(db)),\n         ModuleDef::TypeAlias(t) => format!(\"type.{}.html\", t.name(db)),\n-        ModuleDef::BuiltinType(t) => format!(\"primitive.{}.html\", t),\n+        ModuleDef::BuiltinType(t) => format!(\"primitive.{}.html\", t.as_name()),\n         ModuleDef::Function(f) => format!(\"fn.{}.html\", f.name(db)),\n         ModuleDef::EnumVariant(ev) => {\n             format!(\"enum.{}.html#variant.{}\", ev.parent_enum(db).name(db), ev.name(db))\n@@ -344,6 +396,30 @@ fn get_symbol_filename(db: &RootDatabase, definition: &ModuleDef) -> Option<Stri\n     })\n }\n \n+enum FieldOrAssocItem {\n+    Field(Field),\n+    AssocItem(AssocItem),\n+}\n+\n+/// Get the fragment required to link to a specific field, method, associated type, or associated constant.\n+///\n+/// ```\n+/// https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next\n+///                                                       ^^^^^^^^^^^^^^\n+/// ```\n+fn get_symbol_fragment(db: &dyn HirDatabase, field_or_assoc: &FieldOrAssocItem) -> Option<String> {\n+    Some(match field_or_assoc {\n+        FieldOrAssocItem::Field(field) => format!(\"#structfield.{}\", field.name(db)),\n+        FieldOrAssocItem::AssocItem(assoc) => match assoc {\n+            // TODO: Rustdoc sometimes uses tymethod instead of method. This case needs to be investigated.\n+            AssocItem::Function(function) => format!(\"#method.{}\", function.name(db)),\n+            // TODO: This might be the old method for documenting associated constants, i32::MAX uses a separate page...\n+            AssocItem::Const(constant) => format!(\"#associatedconstant.{}\", constant.name(db)?),\n+            AssocItem::TypeAlias(ty) => format!(\"#associatedtype.{}\", ty.name(db)),\n+        },\n+    })\n+}\n+\n fn pick_best(tokens: TokenAtOffset<SyntaxToken>) -> Option<SyntaxToken> {\n     return tokens.max_by_key(priority);\n     fn priority(n: &SyntaxToken) -> usize {"}]}