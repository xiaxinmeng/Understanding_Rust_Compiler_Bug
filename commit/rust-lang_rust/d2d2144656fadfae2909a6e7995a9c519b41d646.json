{"sha": "d2d2144656fadfae2909a6e7995a9c519b41d646", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyZDIxNDQ2NTZmYWRmYWUyOTA5YTZlNzk5NWE5YzUxOWI0MWQ2NDY=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-01-26T09:52:33Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-01-28T05:07:40Z"}, "message": "Refactor away NameSearchType", "tree": {"sha": "96c0cc2cf75aab2ced1e40ec312b2c353b8dd467", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96c0cc2cf75aab2ced1e40ec312b2c353b8dd467"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2d2144656fadfae2909a6e7995a9c519b41d646", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2d2144656fadfae2909a6e7995a9c519b41d646", "html_url": "https://github.com/rust-lang/rust/commit/d2d2144656fadfae2909a6e7995a9c519b41d646", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2d2144656fadfae2909a6e7995a9c519b41d646/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fcde2bdbc2c725b66c42d4621b0aa9a4c90b459", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fcde2bdbc2c725b66c42d4621b0aa9a4c90b459", "html_url": "https://github.com/rust-lang/rust/commit/1fcde2bdbc2c725b66c42d4621b0aa9a4c90b459"}], "stats": {"total": 66, "additions": 11, "deletions": 55}, "files": [{"sha": "49f939af52ae8e875a537b36c3ef9e26a3c86618", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 10, "deletions": 52, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/d2d2144656fadfae2909a6e7995a9c519b41d646/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d2144656fadfae2909a6e7995a9c519b41d646/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d2d2144656fadfae2909a6e7995a9c519b41d646", "patch": "@@ -44,7 +44,6 @@ use self::RibKind::*;\n use self::UseLexicalScopeFlag::*;\n use self::ModulePrefixResult::*;\n use self::AssocItemResolveResult::*;\n-use self::NameSearchType::*;\n use self::BareIdentifierPatternResolution::*;\n use self::ParentLink::*;\n use self::FallbackChecks::*;\n@@ -784,16 +783,6 @@ enum AssocItemResolveResult {\n     ResolveAttempt(Option<PathResolution>),\n }\n \n-#[derive(Copy, Clone, PartialEq)]\n-enum NameSearchType {\n-    /// We're doing a name search in order to resolve a `use` directive.\n-    ImportSearch,\n-\n-    /// We're doing a name search in order to resolve a path type, a path\n-    /// expression, or a path pattern.\n-    PathSearch,\n-}\n-\n #[derive(Copy, Clone)]\n enum BareIdentifierPatternResolution {\n     FoundStructOrEnumVariant(Def, LastPrivate),\n@@ -1370,7 +1359,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                      module_path: &[Name],\n                                      index: usize,\n                                      span: Span,\n-                                     name_search_type: NameSearchType,\n                                      lp: LastPrivate)\n                                      -> ResolveResult<(Module<'a>, LastPrivate)> {\n         fn search_parent_externals<'a>(needle: Name, module: Module<'a>)\n@@ -1396,11 +1384,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // modules as we go.\n         while index < module_path_len {\n             let name = module_path[index];\n-            match self.resolve_name_in_module(search_module,\n-                                              name,\n-                                              TypeNS,\n-                                              name_search_type,\n-                                              false) {\n+            match self.resolve_name_in_module(search_module, name, TypeNS, false) {\n                 Failed(None) => {\n                     let segment_name = name.as_str();\n                     let module_name = module_to_string(search_module);\n@@ -1477,8 +1461,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                            module_: Module<'a>,\n                            module_path: &[Name],\n                            use_lexical_scope: UseLexicalScopeFlag,\n-                           span: Span,\n-                           name_search_type: NameSearchType)\n+                           span: Span)\n                            -> ResolveResult<(Module<'a>, LastPrivate)> {\n         let module_path_len = module_path.len();\n         assert!(module_path_len > 0);\n@@ -1559,7 +1542,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                            module_path,\n                                            start_index,\n                                            span,\n-                                           name_search_type,\n                                            last_private)\n     }\n \n@@ -1658,11 +1640,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             // Resolve the name in the parent module.\n-            match self.resolve_name_in_module(search_module,\n-                                              name,\n-                                              namespace,\n-                                              PathSearch,\n-                                              true) {\n+            match self.resolve_name_in_module(search_module, name, namespace, true) {\n                 Failed(Some((span, msg))) => {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n                 }\n@@ -1787,7 +1765,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                               module_: Module<'a>,\n                               name: Name,\n                               namespace: Namespace,\n-                              name_search_type: NameSearchType,\n                               allow_private_imports: bool)\n                               -> ResolveResult<(Target<'a>, bool)> {\n         debug!(\"(resolving name in module) resolving `{}` in `{}`\",\n@@ -3167,11 +3144,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let containing_module;\n         let last_private;\n         let current_module = self.current_module;\n-        match self.resolve_module_path(current_module,\n-                                       &module_path[..],\n-                                       UseLexicalScope,\n-                                       span,\n-                                       PathSearch) {\n+        match self.resolve_module_path(current_module, &module_path, UseLexicalScope, span) {\n             Failed(err) => {\n                 let (span, msg) = match err {\n                     Some((span, msg)) => (span, msg),\n@@ -3193,11 +3166,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         let name = segments.last().unwrap().identifier.name;\n-        let def = match self.resolve_name_in_module(containing_module,\n-                                                    name,\n-                                                    namespace,\n-                                                    NameSearchType::PathSearch,\n-                                                    false) {\n+        let def = match self.resolve_name_in_module(containing_module, name, namespace, false) {\n             Success((Target { binding, .. }, _)) => {\n                 let (def, lp) = binding.def_and_lp();\n                 (def, last_private.or(lp))\n@@ -3232,7 +3201,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                  &module_path[..],\n                                                  0,\n                                                  span,\n-                                                 PathSearch,\n                                                  LastMod(AllPublic)) {\n             Failed(err) => {\n                 let (span, msg) = match err {\n@@ -3257,11 +3225,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         let name = segments.last().unwrap().identifier.name;\n-        match self.resolve_name_in_module(containing_module,\n-                                          name,\n-                                          namespace,\n-                                          NameSearchType::PathSearch,\n-                                          false) {\n+        match self.resolve_name_in_module(containing_module, name, namespace, false) {\n             Success((Target { binding, .. }, _)) => {\n                 let (def, lp) = binding.def_and_lp();\n                 Some((def, last_private.or(lp)))\n@@ -3303,7 +3267,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 if let Success((target, _)) = self.resolve_name_in_module(module,\n                                                                           ident.unhygienic_name,\n                                                                           namespace,\n-                                                                          PathSearch,\n                                                                           true) {\n                     if let Some(def) = target.binding.def() {\n                         return Some(LocalDef::from_def(def));\n@@ -3399,11 +3362,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 }\n             } else {\n-                match this.resolve_module_path(root,\n-                                               &name_path[..],\n-                                               UseLexicalScope,\n-                                               span,\n-                                               PathSearch) {\n+                match this.resolve_module_path(root, &name_path, UseLexicalScope, span) {\n                     Success((module, _)) => Some(module),\n                     _ => None,\n                 }\n@@ -3649,10 +3608,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     let current_module = self.current_module;\n \n                                     match self.resolve_module_path(current_module,\n-                                                   &name_path[..],\n-                                                   UseLexicalScope,\n-                                                   expr.span,\n-                                                   PathSearch) {\n+                                                                   &name_path[..],\n+                                                                   UseLexicalScope,\n+                                                                   expr.span) {\n                                         Success(_) => {\n                                             context = UnresolvedNameContext::PathIsMod(expr.id);\n                                         },"}, {"sha": "364218d84137cf0648801f185743b31899e7eade", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2d2144656fadfae2909a6e7995a9c519b41d646/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d2144656fadfae2909a6e7995a9c519b41d646/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=d2d2144656fadfae2909a6e7995a9c519b41d646", "patch": "@@ -16,7 +16,6 @@ use Namespace::{self, TypeNS, ValueNS};\n use {NameBindings, NameBinding};\n use NamespaceResult::{BoundResult, UnboundResult, UnknownResult};\n use NamespaceResult;\n-use NameSearchType;\n use ResolveResult;\n use Resolver;\n use UseLexicalScopeFlag;\n@@ -321,8 +320,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             match self.resolver.resolve_module_path(module_,\n                                                     &module_path[..],\n                                                     UseLexicalScopeFlag::DontUseLexicalScope,\n-                                                    import_directive.span,\n-                                                    NameSearchType::ImportSearch) {\n+                                                    import_directive.span) {\n                 ResolveResult::Failed(err) => {\n                     resolution_result = ResolveResult::Failed(err);\n                     None"}]}