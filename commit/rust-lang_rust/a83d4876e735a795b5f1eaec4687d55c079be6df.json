{"sha": "a83d4876e735a795b5f1eaec4687d55c079be6df", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4M2Q0ODc2ZTczNWE3OTViNWYxZWFlYzQ2ODdkNTVjMDc5YmU2ZGY=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-05-23T13:12:37Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-05-23T13:12:37Z"}, "message": "Allow first child to stay on the same line with block parent", "tree": {"sha": "364a133b6960497f3a1692025d9bbe62ee19ca98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/364a133b6960497f3a1692025d9bbe62ee19ca98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a83d4876e735a795b5f1eaec4687d55c079be6df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a83d4876e735a795b5f1eaec4687d55c079be6df", "html_url": "https://github.com/rust-lang/rust/commit/a83d4876e735a795b5f1eaec4687d55c079be6df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a83d4876e735a795b5f1eaec4687d55c079be6df/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c8432f05bf77ccd7aba238e9871ba50160e85df", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c8432f05bf77ccd7aba238e9871ba50160e85df", "html_url": "https://github.com/rust-lang/rust/commit/7c8432f05bf77ccd7aba238e9871ba50160e85df"}], "stats": {"total": 49, "additions": 34, "deletions": 15}, "files": [{"sha": "92f4aa212a27dfbee7cfda4e2a73273f14927b7e", "filename": "src/chains.rs", "status": "modified", "additions": 34, "deletions": 15, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a83d4876e735a795b5f1eaec4687d55c079be6df/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a83d4876e735a795b5f1eaec4687d55c079be6df/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=a83d4876e735a795b5f1eaec4687d55c079be6df", "patch": "@@ -99,10 +99,14 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     }\n \n     // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n-    let mut parent_shape = shape;\n-    if is_block_expr(&parent, \"\\n\") {\n-        parent_shape = chain_indent(context, shape);\n-    }\n+    let parent_shape = if is_block_expr(context, &parent, \"\\n\") {\n+        match context.config.chain_indent() {\n+            IndentStyle::Visual => shape.visual_indent(0),\n+            IndentStyle::Block => shape.block(),\n+        }\n+    } else {\n+        shape\n+    };\n     let parent_rewrite = try_opt!(parent.rewrite(context, parent_shape));\n     let parent_rewrite_contains_newline = parent_rewrite.contains('\\n');\n \n@@ -121,10 +125,14 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         (nested_shape,\n          context.config.chain_indent() == IndentStyle::Visual ||\n          parent_rewrite.len() <= context.config.tab_spaces())\n-    } else if is_block_expr(&parent, &parent_rewrite) {\n-        // The parent is a block, so align the rest of the chain with the closing\n-        // brace.\n-        (parent_shape, false)\n+    } else if is_block_expr(context, &parent, &parent_rewrite) {\n+        match context.config.chain_indent() {\n+            // Try to put the first child on the same line with parent's last line\n+            IndentStyle::Block => (parent_shape.block_indent(context.config.tab_spaces()), true),\n+            // The parent is a block, so align the rest of the chain with the closing\n+            // brace.\n+            IndentStyle::Visual => (parent_shape, false),\n+        }\n     } else if parent_rewrite_contains_newline {\n         (chain_indent(context, parent_shape), false)\n     } else {\n@@ -140,11 +148,11 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         ..nested_shape\n     };\n     let first_child_shape = if extend {\n-        let first_child_shape = try_opt!(parent_shape\n-                                             .offset_left(last_line_width(&parent_rewrite)));\n+        let overhead = last_line_width(&parent_rewrite);\n+        let offset = parent_rewrite.lines().rev().next().unwrap().trim().len();\n         match context.config.chain_indent() {\n-            IndentStyle::Visual => first_child_shape,\n-            IndentStyle::Block => first_child_shape.block(),\n+            IndentStyle::Visual => try_opt!(parent_shape.offset_left(overhead)),\n+            IndentStyle::Block => try_opt!(parent_shape.block().offset_left(offset)),\n         }\n     } else {\n         other_child_shape\n@@ -224,8 +232,16 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         format!(\"\\n{}\", nested_shape.indent.to_string(context.config))\n     };\n \n-    let first_connector = if extend || subexpr_list.is_empty() || first_subexpr_is_try {\n+    let first_connector = if subexpr_list.is_empty() {\n         \"\"\n+    } else if extend || first_subexpr_is_try {\n+        // 1 = \";\", being conservative here.\n+        if last_line_width(&parent_rewrite) + first_line_width(&rewrites[0]) + 1 <=\n+           context.config.max_width() {\n+            \"\"\n+        } else {\n+            &*connector\n+        }\n     } else {\n         &*connector\n     };\n@@ -277,8 +293,11 @@ fn join_rewrites(rewrites: &[String], subexps: &[ast::Expr], connector: &str) ->\n \n // States whether an expression's last line exclusively consists of closing\n // parens, braces, and brackets in its idiomatic formatting.\n-fn is_block_expr(expr: &ast::Expr, repr: &str) -> bool {\n+fn is_block_expr(context: &RewriteContext, expr: &ast::Expr, repr: &str) -> bool {\n     match expr.node {\n+        ast::ExprKind::Call(..) => {\n+            context.config.fn_call_style() == IndentStyle::Block && repr.contains('\\n')\n+        }\n         ast::ExprKind::Struct(..) |\n         ast::ExprKind::While(..) |\n         ast::ExprKind::WhileLet(..) |\n@@ -291,7 +310,7 @@ fn is_block_expr(expr: &ast::Expr, repr: &str) -> bool {\n         ast::ExprKind::Paren(ref expr) |\n         ast::ExprKind::Binary(_, _, ref expr) |\n         ast::ExprKind::Index(_, ref expr) |\n-        ast::ExprKind::Unary(_, ref expr) => is_block_expr(expr, repr),\n+        ast::ExprKind::Unary(_, ref expr) => is_block_expr(context, expr, repr),\n         _ => false,\n     }\n }"}]}