{"sha": "f6cbc92e2a91cd6018a999ce99a0e4af924c5b59", "node_id": "C_kwDOAAsO6NoAKGY2Y2JjOTJlMmE5MWNkNjAxOGE5OTljZTk5YTBlNGFmOTI0YzViNTk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-02T03:28:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-02T03:28:14Z"}, "message": "Auto merge of #96622 - JohnTitor:rollup-8hckgaj, r=JohnTitor\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #94126 (Classify BinaryHeap & LinkedList unit tests as such)\n - #96222 (Clarify docs for `from_raw_parts` on `Vec` and `String`)\n - #96499 (Make it possible to write doctests for bootstrap)\n - #96567 (Fix docs for u32 and i32 logs func)\n - #96568 (std::fmt: Various fixes and improvements to documentation)\n - #96571 (Add a bathroom stall to weird expressions test)\n - #96610 (Update browser-ui-test version to 0.9.0)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "387ed9ada4682c675a04a40e59584d3608148523", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/387ed9ada4682c675a04a40e59584d3608148523"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59", "html_url": "https://github.com/rust-lang/rust/commit/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c5efea6fed6fdb30ffcbb49325c76e2856ac01d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c5efea6fed6fdb30ffcbb49325c76e2856ac01d", "html_url": "https://github.com/rust-lang/rust/commit/4c5efea6fed6fdb30ffcbb49325c76e2856ac01d"}, {"sha": "5750e3305536fa961f846cb63b2600068f707d69", "url": "https://api.github.com/repos/rust-lang/rust/commits/5750e3305536fa961f846cb63b2600068f707d69", "html_url": "https://github.com/rust-lang/rust/commit/5750e3305536fa961f846cb63b2600068f707d69"}], "stats": {"total": 1479, "additions": 756, "deletions": 723}, "files": [{"sha": "c3c1d0c92a86be67d291e2cc05d73f2003620b2f", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=f6cbc92e2a91cd6018a999ce99a0e4af924c5b59", "patch": "@@ -155,6 +155,9 @@ use crate::vec::{self, AsVecIntoIter, Vec};\n \n use super::SpecExtend;\n \n+#[cfg(test)]\n+mod tests;\n+\n /// A priority queue implemented with a binary heap.\n ///\n /// This will be a max-heap."}, {"sha": "7c758dbb3ab8a23079625ceed193741b2bbb9f11", "filename": "library/alloc/src/collections/binary_heap/tests.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Ftests.rs?ref=f6cbc92e2a91cd6018a999ce99a0e4af924c5b59", "patch": "@@ -1,5 +1,5 @@\n-use std::collections::binary_heap::{Drain, PeekMut};\n-use std::collections::BinaryHeap;\n+use super::*;\n+use crate::boxed::Box;\n use std::iter::TrustedLen;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::sync::atomic::{AtomicU32, Ordering};", "previous_filename": "library/alloc/tests/binary_heap.rs"}, {"sha": "38c702aa387bd1a46c74b719482b4e6358145416", "filename": "library/alloc/src/collections/linked_list/tests.rs", "status": "modified", "additions": 687, "deletions": 8, "changes": 695, "blob_url": "https://github.com/rust-lang/rust/blob/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs?ref=f6cbc92e2a91cd6018a999ce99a0e4af924c5b59", "patch": "@@ -1,10 +1,55 @@\n use super::*;\n+use crate::vec::Vec;\n \n+use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::thread;\n-use std::vec::Vec;\n \n use rand::{thread_rng, RngCore};\n \n+#[test]\n+fn test_basic() {\n+    let mut m = LinkedList::<Box<_>>::new();\n+    assert_eq!(m.pop_front(), None);\n+    assert_eq!(m.pop_back(), None);\n+    assert_eq!(m.pop_front(), None);\n+    m.push_front(box 1);\n+    assert_eq!(m.pop_front(), Some(box 1));\n+    m.push_back(box 2);\n+    m.push_back(box 3);\n+    assert_eq!(m.len(), 2);\n+    assert_eq!(m.pop_front(), Some(box 2));\n+    assert_eq!(m.pop_front(), Some(box 3));\n+    assert_eq!(m.len(), 0);\n+    assert_eq!(m.pop_front(), None);\n+    m.push_back(box 1);\n+    m.push_back(box 3);\n+    m.push_back(box 5);\n+    m.push_back(box 7);\n+    assert_eq!(m.pop_front(), Some(box 1));\n+\n+    let mut n = LinkedList::new();\n+    n.push_front(2);\n+    n.push_front(3);\n+    {\n+        assert_eq!(n.front().unwrap(), &3);\n+        let x = n.front_mut().unwrap();\n+        assert_eq!(*x, 3);\n+        *x = 0;\n+    }\n+    {\n+        assert_eq!(n.back().unwrap(), &2);\n+        let y = n.back_mut().unwrap();\n+        assert_eq!(*y, 2);\n+        *y = 1;\n+    }\n+    assert_eq!(n.pop_front(), Some(0));\n+    assert_eq!(n.pop_front(), Some(1));\n+}\n+\n+fn generate_test() -> LinkedList<i32> {\n+    list_from(&[0, 1, 2, 3, 4, 5, 6])\n+}\n+\n fn list_from<T: Clone>(v: &[T]) -> LinkedList<T> {\n     v.iter().cloned().collect()\n }\n@@ -110,6 +155,123 @@ fn test_append() {\n     check_links(&n);\n }\n \n+#[test]\n+fn test_iterator() {\n+    let m = generate_test();\n+    for (i, elt) in m.iter().enumerate() {\n+        assert_eq!(i as i32, *elt);\n+    }\n+    let mut n = LinkedList::new();\n+    assert_eq!(n.iter().next(), None);\n+    n.push_front(4);\n+    let mut it = n.iter();\n+    assert_eq!(it.size_hint(), (1, Some(1)));\n+    assert_eq!(it.next().unwrap(), &4);\n+    assert_eq!(it.size_hint(), (0, Some(0)));\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn test_iterator_clone() {\n+    let mut n = LinkedList::new();\n+    n.push_back(2);\n+    n.push_back(3);\n+    n.push_back(4);\n+    let mut it = n.iter();\n+    it.next();\n+    let mut jt = it.clone();\n+    assert_eq!(it.next(), jt.next());\n+    assert_eq!(it.next_back(), jt.next_back());\n+    assert_eq!(it.next(), jt.next());\n+}\n+\n+#[test]\n+fn test_iterator_double_end() {\n+    let mut n = LinkedList::new();\n+    assert_eq!(n.iter().next(), None);\n+    n.push_front(4);\n+    n.push_front(5);\n+    n.push_front(6);\n+    let mut it = n.iter();\n+    assert_eq!(it.size_hint(), (3, Some(3)));\n+    assert_eq!(it.next().unwrap(), &6);\n+    assert_eq!(it.size_hint(), (2, Some(2)));\n+    assert_eq!(it.next_back().unwrap(), &4);\n+    assert_eq!(it.size_hint(), (1, Some(1)));\n+    assert_eq!(it.next_back().unwrap(), &5);\n+    assert_eq!(it.next_back(), None);\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn test_rev_iter() {\n+    let m = generate_test();\n+    for (i, elt) in m.iter().rev().enumerate() {\n+        assert_eq!((6 - i) as i32, *elt);\n+    }\n+    let mut n = LinkedList::new();\n+    assert_eq!(n.iter().rev().next(), None);\n+    n.push_front(4);\n+    let mut it = n.iter().rev();\n+    assert_eq!(it.size_hint(), (1, Some(1)));\n+    assert_eq!(it.next().unwrap(), &4);\n+    assert_eq!(it.size_hint(), (0, Some(0)));\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn test_mut_iter() {\n+    let mut m = generate_test();\n+    let mut len = m.len();\n+    for (i, elt) in m.iter_mut().enumerate() {\n+        assert_eq!(i as i32, *elt);\n+        len -= 1;\n+    }\n+    assert_eq!(len, 0);\n+    let mut n = LinkedList::new();\n+    assert!(n.iter_mut().next().is_none());\n+    n.push_front(4);\n+    n.push_back(5);\n+    let mut it = n.iter_mut();\n+    assert_eq!(it.size_hint(), (2, Some(2)));\n+    assert!(it.next().is_some());\n+    assert!(it.next().is_some());\n+    assert_eq!(it.size_hint(), (0, Some(0)));\n+    assert!(it.next().is_none());\n+}\n+\n+#[test]\n+fn test_iterator_mut_double_end() {\n+    let mut n = LinkedList::new();\n+    assert!(n.iter_mut().next_back().is_none());\n+    n.push_front(4);\n+    n.push_front(5);\n+    n.push_front(6);\n+    let mut it = n.iter_mut();\n+    assert_eq!(it.size_hint(), (3, Some(3)));\n+    assert_eq!(*it.next().unwrap(), 6);\n+    assert_eq!(it.size_hint(), (2, Some(2)));\n+    assert_eq!(*it.next_back().unwrap(), 4);\n+    assert_eq!(it.size_hint(), (1, Some(1)));\n+    assert_eq!(*it.next_back().unwrap(), 5);\n+    assert!(it.next_back().is_none());\n+    assert!(it.next().is_none());\n+}\n+\n+#[test]\n+fn test_mut_rev_iter() {\n+    let mut m = generate_test();\n+    for (i, elt) in m.iter_mut().rev().enumerate() {\n+        assert_eq!((6 - i) as i32, *elt);\n+    }\n+    let mut n = LinkedList::new();\n+    assert!(n.iter_mut().rev().next().is_none());\n+    n.push_front(4);\n+    let mut it = n.iter_mut().rev();\n+    assert!(it.next().is_some());\n+    assert!(it.next().is_none());\n+}\n+\n #[test]\n fn test_clone_from() {\n     // Short cloned from long\n@@ -168,13 +330,60 @@ fn test_send() {\n }\n \n #[test]\n-fn test_fuzz() {\n-    for _ in 0..25 {\n-        fuzz_test(3);\n-        fuzz_test(16);\n-        #[cfg(not(miri))] // Miri is too slow\n-        fuzz_test(189);\n-    }\n+fn test_eq() {\n+    let mut n = list_from(&[]);\n+    let mut m = list_from(&[]);\n+    assert!(n == m);\n+    n.push_front(1);\n+    assert!(n != m);\n+    m.push_back(1);\n+    assert!(n == m);\n+\n+    let n = list_from(&[2, 3, 4]);\n+    let m = list_from(&[1, 2, 3]);\n+    assert!(n != m);\n+}\n+\n+#[test]\n+fn test_ord() {\n+    let n = list_from(&[]);\n+    let m = list_from(&[1, 2, 3]);\n+    assert!(n < m);\n+    assert!(m > n);\n+    assert!(n <= n);\n+    assert!(n >= n);\n+}\n+\n+#[test]\n+fn test_ord_nan() {\n+    let nan = 0.0f64 / 0.0;\n+    let n = list_from(&[nan]);\n+    let m = list_from(&[nan]);\n+    assert!(!(n < m));\n+    assert!(!(n > m));\n+    assert!(!(n <= m));\n+    assert!(!(n >= m));\n+\n+    let n = list_from(&[nan]);\n+    let one = list_from(&[1.0f64]);\n+    assert!(!(n < one));\n+    assert!(!(n > one));\n+    assert!(!(n <= one));\n+    assert!(!(n >= one));\n+\n+    let u = list_from(&[1.0f64, 2.0, nan]);\n+    let v = list_from(&[1.0f64, 2.0, 3.0]);\n+    assert!(!(u < v));\n+    assert!(!(u > v));\n+    assert!(!(u <= v));\n+    assert!(!(u >= v));\n+\n+    let s = list_from(&[1.0f64, 2.0, 4.0, 2.0]);\n+    let t = list_from(&[1.0f64, 2.0, 3.0, 2.0]);\n+    assert!(!(s < t));\n+    assert!(s > one);\n+    assert!(!(s <= one));\n+    assert!(s >= one);\n }\n \n #[test]\n@@ -215,6 +424,62 @@ fn test_split_off() {\n     }\n }\n \n+#[test]\n+fn test_split_off_2() {\n+    // singleton\n+    {\n+        let mut m = LinkedList::new();\n+        m.push_back(1);\n+\n+        let p = m.split_off(0);\n+        assert_eq!(m.len(), 0);\n+        assert_eq!(p.len(), 1);\n+        assert_eq!(p.back(), Some(&1));\n+        assert_eq!(p.front(), Some(&1));\n+    }\n+\n+    // not singleton, forwards\n+    {\n+        let u = vec![1, 2, 3, 4, 5];\n+        let mut m = list_from(&u);\n+        let mut n = m.split_off(2);\n+        assert_eq!(m.len(), 2);\n+        assert_eq!(n.len(), 3);\n+        for elt in 1..3 {\n+            assert_eq!(m.pop_front(), Some(elt));\n+        }\n+        for elt in 3..6 {\n+            assert_eq!(n.pop_front(), Some(elt));\n+        }\n+    }\n+    // not singleton, backwards\n+    {\n+        let u = vec![1, 2, 3, 4, 5];\n+        let mut m = list_from(&u);\n+        let mut n = m.split_off(4);\n+        assert_eq!(m.len(), 4);\n+        assert_eq!(n.len(), 1);\n+        for elt in 1..5 {\n+            assert_eq!(m.pop_front(), Some(elt));\n+        }\n+        for elt in 5..6 {\n+            assert_eq!(n.pop_front(), Some(elt));\n+        }\n+    }\n+\n+    // no-op on the last index\n+    {\n+        let mut m = LinkedList::new();\n+        m.push_back(1);\n+\n+        let p = m.split_off(1);\n+        assert_eq!(m.len(), 1);\n+        assert_eq!(p.len(), 0);\n+        assert_eq!(m.back(), Some(&1));\n+        assert_eq!(m.front(), Some(&1));\n+    }\n+}\n+\n fn fuzz_test(sz: i32) {\n     let mut m: LinkedList<_> = LinkedList::new();\n     let mut v = vec![];\n@@ -253,6 +518,25 @@ fn fuzz_test(sz: i32) {\n     assert_eq!(i, v.len());\n }\n \n+#[test]\n+fn test_fuzz() {\n+    for _ in 0..25 {\n+        fuzz_test(3);\n+        fuzz_test(16);\n+        #[cfg(not(miri))] // Miri is too slow\n+        fuzz_test(189);\n+    }\n+}\n+\n+#[test]\n+fn test_show() {\n+    let list: LinkedList<_> = (0..10).collect();\n+    assert_eq!(format!(\"{list:?}\"), \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n+\n+    let list: LinkedList<_> = [\"just\", \"one\", \"test\", \"more\"].into_iter().collect();\n+    assert_eq!(format!(\"{list:?}\"), \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n+}\n+\n #[test]\n fn drain_filter_test() {\n     let mut m: LinkedList<u32> = LinkedList::new();\n@@ -475,3 +759,398 @@ fn test_cursor_pop_front_back() {\n     assert_eq!(c.current(), None);\n     assert_eq!(c.index, 2);\n }\n+\n+#[test]\n+fn test_extend_ref() {\n+    let mut a = LinkedList::new();\n+    a.push_back(1);\n+\n+    a.extend(&[2, 3, 4]);\n+\n+    assert_eq!(a.len(), 4);\n+    assert_eq!(a, list_from(&[1, 2, 3, 4]));\n+\n+    let mut b = LinkedList::new();\n+    b.push_back(5);\n+    b.push_back(6);\n+    a.extend(&b);\n+\n+    assert_eq!(a.len(), 6);\n+    assert_eq!(a, list_from(&[1, 2, 3, 4, 5, 6]));\n+}\n+\n+#[test]\n+fn test_extend() {\n+    let mut a = LinkedList::new();\n+    a.push_back(1);\n+    a.extend(vec![2, 3, 4]); // uses iterator\n+\n+    assert_eq!(a.len(), 4);\n+    assert!(a.iter().eq(&[1, 2, 3, 4]));\n+\n+    let b: LinkedList<_> = [5, 6, 7].into_iter().collect();\n+    a.extend(b); // specializes to `append`\n+\n+    assert_eq!(a.len(), 7);\n+    assert!(a.iter().eq(&[1, 2, 3, 4, 5, 6, 7]));\n+}\n+\n+#[test]\n+fn test_contains() {\n+    let mut l = LinkedList::new();\n+    l.extend(&[2, 3, 4]);\n+\n+    assert!(l.contains(&3));\n+    assert!(!l.contains(&1));\n+\n+    l.clear();\n+\n+    assert!(!l.contains(&3));\n+}\n+\n+#[test]\n+fn drain_filter_empty() {\n+    let mut list: LinkedList<i32> = LinkedList::new();\n+\n+    {\n+        let mut iter = list.drain_filter(|_| true);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(list.len(), 0);\n+    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![]);\n+}\n+\n+#[test]\n+fn drain_filter_zst() {\n+    let mut list: LinkedList<_> = [(), (), (), (), ()].into_iter().collect();\n+    let initial_len = list.len();\n+    let mut count = 0;\n+\n+    {\n+        let mut iter = list.drain_filter(|_| true);\n+        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n+        while let Some(_) = iter.next() {\n+            count += 1;\n+            assert_eq!(iter.size_hint(), (0, Some(initial_len - count)));\n+        }\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(count, initial_len);\n+    assert_eq!(list.len(), 0);\n+    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![]);\n+}\n+\n+#[test]\n+fn drain_filter_false() {\n+    let mut list: LinkedList<_> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n+\n+    let initial_len = list.len();\n+    let mut count = 0;\n+\n+    {\n+        let mut iter = list.drain_filter(|_| false);\n+        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n+        for _ in iter.by_ref() {\n+            count += 1;\n+        }\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(count, 0);\n+    assert_eq!(list.len(), initial_len);\n+    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+}\n+\n+#[test]\n+fn drain_filter_true() {\n+    let mut list: LinkedList<_> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n+\n+    let initial_len = list.len();\n+    let mut count = 0;\n+\n+    {\n+        let mut iter = list.drain_filter(|_| true);\n+        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n+        while let Some(_) = iter.next() {\n+            count += 1;\n+            assert_eq!(iter.size_hint(), (0, Some(initial_len - count)));\n+        }\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(count, initial_len);\n+    assert_eq!(list.len(), 0);\n+    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![]);\n+}\n+\n+#[test]\n+fn drain_filter_complex() {\n+    {\n+        //                [+xxx++++++xxxxx++++x+x++]\n+        let mut list = [\n+            1, 2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36, 37,\n+            39,\n+        ]\n+        .into_iter()\n+        .collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n+\n+        assert_eq!(list.len(), 14);\n+        assert_eq!(\n+            list.into_iter().collect::<Vec<_>>(),\n+            vec![1, 7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35, 37, 39]\n+        );\n+    }\n+\n+    {\n+        // [xxx++++++xxxxx++++x+x++]\n+        let mut list =\n+            [2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36, 37, 39]\n+                .into_iter()\n+                .collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n+\n+        assert_eq!(list.len(), 13);\n+        assert_eq!(\n+            list.into_iter().collect::<Vec<_>>(),\n+            vec![7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35, 37, 39]\n+        );\n+    }\n+\n+    {\n+        // [xxx++++++xxxxx++++x+x]\n+        let mut list =\n+            [2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36]\n+                .into_iter()\n+                .collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n+\n+        assert_eq!(list.len(), 11);\n+        assert_eq!(\n+            list.into_iter().collect::<Vec<_>>(),\n+            vec![7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35]\n+        );\n+    }\n+\n+    {\n+        // [xxxxxxxxxx+++++++++++]\n+        let mut list = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n+            .into_iter()\n+            .collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20]);\n+\n+        assert_eq!(list.len(), 10);\n+        assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n+    }\n+\n+    {\n+        // [+++++++++++xxxxxxxxxx]\n+        let mut list = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n+            .into_iter()\n+            .collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20]);\n+\n+        assert_eq!(list.len(), 10);\n+        assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n+    }\n+}\n+\n+#[test]\n+fn drain_filter_drop_panic_leak() {\n+    static mut DROPS: i32 = 0;\n+\n+    struct D(bool);\n+\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+\n+            if self.0 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let mut q = LinkedList::new();\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_front(D(false));\n+    q.push_front(D(true));\n+    q.push_front(D(false));\n+\n+    catch_unwind(AssertUnwindSafe(|| drop(q.drain_filter(|_| true)))).ok();\n+\n+    assert_eq!(unsafe { DROPS }, 8);\n+    assert!(q.is_empty());\n+}\n+\n+#[test]\n+fn drain_filter_pred_panic_leak() {\n+    static mut DROPS: i32 = 0;\n+\n+    #[derive(Debug)]\n+    struct D(u32);\n+\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+        }\n+    }\n+\n+    let mut q = LinkedList::new();\n+    q.push_back(D(3));\n+    q.push_back(D(4));\n+    q.push_back(D(5));\n+    q.push_back(D(6));\n+    q.push_back(D(7));\n+    q.push_front(D(2));\n+    q.push_front(D(1));\n+    q.push_front(D(0));\n+\n+    catch_unwind(AssertUnwindSafe(|| {\n+        drop(q.drain_filter(|item| if item.0 >= 2 { panic!() } else { true }))\n+    }))\n+    .ok();\n+\n+    assert_eq!(unsafe { DROPS }, 2); // 0 and 1\n+    assert_eq!(q.len(), 6);\n+}\n+\n+#[test]\n+fn test_drop() {\n+    static mut DROPS: i32 = 0;\n+    struct Elem;\n+    impl Drop for Elem {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+        }\n+    }\n+\n+    let mut ring = LinkedList::new();\n+    ring.push_back(Elem);\n+    ring.push_front(Elem);\n+    ring.push_back(Elem);\n+    ring.push_front(Elem);\n+    drop(ring);\n+\n+    assert_eq!(unsafe { DROPS }, 4);\n+}\n+\n+#[test]\n+fn test_drop_with_pop() {\n+    static mut DROPS: i32 = 0;\n+    struct Elem;\n+    impl Drop for Elem {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+        }\n+    }\n+\n+    let mut ring = LinkedList::new();\n+    ring.push_back(Elem);\n+    ring.push_front(Elem);\n+    ring.push_back(Elem);\n+    ring.push_front(Elem);\n+\n+    drop(ring.pop_back());\n+    drop(ring.pop_front());\n+    assert_eq!(unsafe { DROPS }, 2);\n+\n+    drop(ring);\n+    assert_eq!(unsafe { DROPS }, 4);\n+}\n+\n+#[test]\n+fn test_drop_clear() {\n+    static mut DROPS: i32 = 0;\n+    struct Elem;\n+    impl Drop for Elem {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+        }\n+    }\n+\n+    let mut ring = LinkedList::new();\n+    ring.push_back(Elem);\n+    ring.push_front(Elem);\n+    ring.push_back(Elem);\n+    ring.push_front(Elem);\n+    ring.clear();\n+    assert_eq!(unsafe { DROPS }, 4);\n+\n+    drop(ring);\n+    assert_eq!(unsafe { DROPS }, 4);\n+}\n+\n+#[test]\n+fn test_drop_panic() {\n+    static mut DROPS: i32 = 0;\n+\n+    struct D(bool);\n+\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+\n+            if self.0 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let mut q = LinkedList::new();\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_front(D(false));\n+    q.push_front(D(false));\n+    q.push_front(D(true));\n+\n+    catch_unwind(move || drop(q)).ok();\n+\n+    assert_eq!(unsafe { DROPS }, 8);\n+}"}, {"sha": "73b75ea4d83d5baff277aa164d5b8e2096d1d96a", "filename": "library/alloc/src/fmt.rs", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/library%2Falloc%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/library%2Falloc%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Ffmt.rs?ref=f6cbc92e2a91cd6018a999ce99a0e4af924c5b59", "patch": "@@ -221,10 +221,12 @@\n //!\n //! 3. An asterisk `.*`:\n //!\n-//!    `.*` means that this `{...}` is associated with *two* format inputs rather than one: the\n-//!    first input holds the `usize` precision, and the second holds the value to print. Note that\n-//!    in this case, if one uses the format string `{<arg>:<spec>.*}`, then the `<arg>` part refers\n-//!    to the *value* to print, and the `precision` must come in the input preceding `<arg>`.\n+//!    `.*` means that this `{...}` is associated with *two* format inputs rather than one:\n+//!    - If a format string in the fashion of `{:<spec>.*}` is used, then the first input holds\n+//!      the `usize` precision, and the second holds the value to print.\n+//!    - If a format string in the fashion of `{<arg>:<spec>.*}` is used, then the `<arg>` part\n+//!      refers to the value to print, and the `precision` is taken like it was specified with an\n+//!      omitted positional parameter (`{}` instead of `{<arg>:}`).\n //!\n //! For example, the following calls all print the same thing `Hello x is 0.01000`:\n //!\n@@ -238,15 +240,19 @@\n //! // Hello {arg 0 (\"x\")} is {arg 2 (0.01) with precision specified in arg 1 (5)}\n //! println!(\"Hello {0} is {2:.1$}\", \"x\", 5, 0.01);\n //!\n-//! // Hello {next arg (\"x\")} is {second of next two args (0.01) with precision\n-//! //                          specified in first of next two args (5)}\n+//! // Hello {next arg -> arg 0 (\"x\")} is {second of next two args -> arg 2 (0.01) with precision\n+//! //                          specified in first of next two args -> arg 1 (5)}\n //! println!(\"Hello {} is {:.*}\",    \"x\", 5, 0.01);\n //!\n-//! // Hello {next arg (\"x\")} is {arg 2 (0.01) with precision\n-//! //                          specified in its predecessor (5)}\n+//! // Hello {arg 1 (\"x\")} is {arg 2 (0.01) with precision\n+//! //                          specified in next arg -> arg 0 (5)}\n+//! println!(\"Hello {1} is {2:.*}\",  5, \"x\", 0.01);\n+//!\n+//! // Hello {next arg -> arg 0 (\"x\")} is {arg 2 (0.01) with precision\n+//! //                          specified in next arg -> arg 1 (5)}\n //! println!(\"Hello {} is {2:.*}\",   \"x\", 5, 0.01);\n //!\n-//! // Hello {next arg (\"x\")} is {arg \"number\" (0.01) with precision specified\n+//! // Hello {next arg -> arg 0 (\"x\")} is {arg \"number\" (0.01) with precision specified\n //! //                          in arg \"prec\" (5)}\n //! println!(\"Hello {} is {number:.prec$}\", \"x\", prec = 5, number = 0.01);\n //! ```\n@@ -304,7 +310,7 @@\n //! ```text\n //! format_string := text [ maybe_format text ] *\n //! maybe_format := '{' '{' | '}' '}' | format\n-//! format := '{' [ argument ] [ ':' format_spec ] '}'\n+//! format := '{' [ argument ] [ ':' format_spec ] [ ws ] * '}'\n //! argument := integer | identifier\n //!\n //! format_spec := [[fill]align][sign]['#']['0'][width]['.' precision]type\n@@ -317,7 +323,12 @@\n //! count := parameter | integer\n //! parameter := argument '$'\n //! ```\n-//! In the above grammar, `text` must not contain any `'{'` or `'}'` characters.\n+//! In the above grammar,\n+//! - `text` must not contain any `'{'` or `'}'` characters,\n+//! - `ws` is any character for which [`char::is_whitespace`] returns `true`, has no semantic\n+//!   meaning and is completely optional,\n+//! - `integer` is a decimal integer that may contain leading zeroes and\n+//! - `identifier` is an `IDENTIFIER_OR_KEYWORD` (not an `IDENTIFIER`) as defined by the [Rust language reference](https://doc.rust-lang.org/reference/identifiers.html).\n //!\n //! # Formatting traits\n //!\n@@ -358,9 +369,9 @@\n //! ```\n //!\n //! Your type will be passed as `self` by-reference, and then the function\n-//! should emit output into the `f.buf` stream. It is up to each format trait\n-//! implementation to correctly adhere to the requested formatting parameters.\n-//! The values of these parameters will be listed in the fields of the\n+//! should emit output into the Formatter `f` which implements `fmt::Write`. It is up to each\n+//! format trait implementation to correctly adhere to the requested formatting parameters.\n+//! The values of these parameters can be accessed with methods of the\n //! [`Formatter`] struct. In order to help with this, the [`Formatter`] struct also\n //! provides some helper methods.\n //!\n@@ -449,7 +460,7 @@\n //!\n //! ```ignore (only-for-syntax-highlight)\n //! format!      // described above\n-//! write!       // first argument is a &mut io::Write, the destination\n+//! write!       // first argument is either a &mut io::Write or a &mut fmt::Write, the destination\n //! writeln!     // same as write but appends a newline\n //! print!       // the format string is printed to the standard output\n //! println!     // same as print but appends a newline\n@@ -460,11 +471,11 @@\n //!\n //! ### `write!`\n //!\n-//! This and [`writeln!`] are two macros which are used to emit the format string\n+//! [`write!`] and [`writeln!`] are two macros which are used to emit the format string\n //! to a specified stream. This is used to prevent intermediate allocations of\n //! format strings and instead directly write the output. Under the hood, this\n //! function is actually invoking the [`write_fmt`] function defined on the\n-//! [`std::io::Write`] trait. Example usage is:\n+//! [`std::io::Write`] and the [`std::fmt::Write`] trait. Example usage is:\n //!\n //! ```\n //! # #![allow(unused_must_use)]\n@@ -491,7 +502,7 @@\n //!\n //! ### `format_args!`\n //!\n-//! This is a curious macro used to safely pass around\n+//! [`format_args!`] is a curious macro used to safely pass around\n //! an opaque object describing the format string. This object\n //! does not require any heap allocations to create, and it only\n //! references information on the stack. Under the hood, all of\n@@ -529,10 +540,12 @@\n //! [`to_string`]: crate::string::ToString::to_string \"ToString::to_string\"\n //! [`write_fmt`]: ../../std/io/trait.Write.html#method.write_fmt\n //! [`std::io::Write`]: ../../std/io/trait.Write.html\n+//! [`std::fmt::Write`]: ../../std/fmt/trait.Write.html\n //! [`print!`]: ../../std/macro.print.html \"print!\"\n //! [`println!`]: ../../std/macro.println.html \"println!\"\n //! [`eprint!`]: ../../std/macro.eprint.html \"eprint!\"\n //! [`eprintln!`]: ../../std/macro.eprintln.html \"eprintln!\"\n+//! [`format_args!`]: ../../std/macro.format_args.html \"format_args!\"\n //! [`fmt::Arguments`]: Arguments \"fmt::Arguments\"\n //! [`format`]: format() \"fmt::format\"\n "}, {"sha": "2272c5b7330dc872b0386646fecb655288061c1b", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=f6cbc92e2a91cd6018a999ce99a0e4af924c5b59", "patch": "@@ -770,7 +770,10 @@ impl String {\n     /// * The first `length` bytes at `buf` need to be valid UTF-8.\n     ///\n     /// Violating these may cause problems like corrupting the allocator's\n-    /// internal data structures.\n+    /// internal data structures. For example, it is normally **not** safe to\n+    /// build a `String` from a pointer to a C `char` array containing UTF-8\n+    /// _unless_ you are certain that array was originally allocated by the\n+    /// Rust standard library's allocator.\n     ///\n     /// The ownership of `buf` is effectively transferred to the\n     /// `String` which may then deallocate, reallocate or change the"}, {"sha": "3dc8a4fbba86ba064926de4668fb25a3dfefba01", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=f6cbc92e2a91cd6018a999ce99a0e4af924c5b59", "patch": "@@ -489,8 +489,10 @@ impl<T> Vec<T> {\n     /// * `length` needs to be less than or equal to `capacity`.\n     ///\n     /// Violating these may cause problems like corrupting the allocator's\n-    /// internal data structures. For example it is **not** safe\n-    /// to build a `Vec<u8>` from a pointer to a C `char` array with length `size_t`.\n+    /// internal data structures. For example it is normally **not** safe\n+    /// to build a `Vec<u8>` from a pointer to a C `char` array with length\n+    /// `size_t`, doing so is only safe if the array was initially allocated by\n+    /// a `Vec` or `String`.\n     /// It's also not safe to build one from a `Vec<u16>` and its length, because\n     /// the allocator cares about the alignment, and these two types have different\n     /// alignments. The buffer was allocated with alignment 2 (for `u16`), but after"}, {"sha": "601a87aa4ac899af12c2419fef3d1c2a67b0d106", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=f6cbc92e2a91cd6018a999ce99a0e4af924c5b59", "patch": "@@ -47,7 +47,6 @@ use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};\n \n mod arc;\n-mod binary_heap;\n mod borrow;\n mod boxed;\n mod btree_set_hash;"}, {"sha": "65b09cb00c45ddeb06a951f9c7e2037178ed35d3", "filename": "library/alloc/tests/linked_list.rs", "status": "modified", "additions": 0, "deletions": 683, "changes": 683, "blob_url": "https://github.com/rust-lang/rust/blob/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/library%2Falloc%2Ftests%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/library%2Falloc%2Ftests%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flinked_list.rs?ref=f6cbc92e2a91cd6018a999ce99a0e4af924c5b59", "patch": "@@ -1,241 +1,4 @@\n use std::collections::LinkedList;\n-use std::panic::{catch_unwind, AssertUnwindSafe};\n-\n-#[test]\n-fn test_basic() {\n-    let mut m = LinkedList::<Box<_>>::new();\n-    assert_eq!(m.pop_front(), None);\n-    assert_eq!(m.pop_back(), None);\n-    assert_eq!(m.pop_front(), None);\n-    m.push_front(box 1);\n-    assert_eq!(m.pop_front(), Some(box 1));\n-    m.push_back(box 2);\n-    m.push_back(box 3);\n-    assert_eq!(m.len(), 2);\n-    assert_eq!(m.pop_front(), Some(box 2));\n-    assert_eq!(m.pop_front(), Some(box 3));\n-    assert_eq!(m.len(), 0);\n-    assert_eq!(m.pop_front(), None);\n-    m.push_back(box 1);\n-    m.push_back(box 3);\n-    m.push_back(box 5);\n-    m.push_back(box 7);\n-    assert_eq!(m.pop_front(), Some(box 1));\n-\n-    let mut n = LinkedList::new();\n-    n.push_front(2);\n-    n.push_front(3);\n-    {\n-        assert_eq!(n.front().unwrap(), &3);\n-        let x = n.front_mut().unwrap();\n-        assert_eq!(*x, 3);\n-        *x = 0;\n-    }\n-    {\n-        assert_eq!(n.back().unwrap(), &2);\n-        let y = n.back_mut().unwrap();\n-        assert_eq!(*y, 2);\n-        *y = 1;\n-    }\n-    assert_eq!(n.pop_front(), Some(0));\n-    assert_eq!(n.pop_front(), Some(1));\n-}\n-\n-fn generate_test() -> LinkedList<i32> {\n-    list_from(&[0, 1, 2, 3, 4, 5, 6])\n-}\n-\n-fn list_from<T: Clone>(v: &[T]) -> LinkedList<T> {\n-    v.iter().cloned().collect()\n-}\n-\n-#[test]\n-fn test_split_off() {\n-    // singleton\n-    {\n-        let mut m = LinkedList::new();\n-        m.push_back(1);\n-\n-        let p = m.split_off(0);\n-        assert_eq!(m.len(), 0);\n-        assert_eq!(p.len(), 1);\n-        assert_eq!(p.back(), Some(&1));\n-        assert_eq!(p.front(), Some(&1));\n-    }\n-\n-    // not singleton, forwards\n-    {\n-        let u = vec![1, 2, 3, 4, 5];\n-        let mut m = list_from(&u);\n-        let mut n = m.split_off(2);\n-        assert_eq!(m.len(), 2);\n-        assert_eq!(n.len(), 3);\n-        for elt in 1..3 {\n-            assert_eq!(m.pop_front(), Some(elt));\n-        }\n-        for elt in 3..6 {\n-            assert_eq!(n.pop_front(), Some(elt));\n-        }\n-    }\n-    // not singleton, backwards\n-    {\n-        let u = vec![1, 2, 3, 4, 5];\n-        let mut m = list_from(&u);\n-        let mut n = m.split_off(4);\n-        assert_eq!(m.len(), 4);\n-        assert_eq!(n.len(), 1);\n-        for elt in 1..5 {\n-            assert_eq!(m.pop_front(), Some(elt));\n-        }\n-        for elt in 5..6 {\n-            assert_eq!(n.pop_front(), Some(elt));\n-        }\n-    }\n-\n-    // no-op on the last index\n-    {\n-        let mut m = LinkedList::new();\n-        m.push_back(1);\n-\n-        let p = m.split_off(1);\n-        assert_eq!(m.len(), 1);\n-        assert_eq!(p.len(), 0);\n-        assert_eq!(m.back(), Some(&1));\n-        assert_eq!(m.front(), Some(&1));\n-    }\n-}\n-\n-#[test]\n-fn test_iterator() {\n-    let m = generate_test();\n-    for (i, elt) in m.iter().enumerate() {\n-        assert_eq!(i as i32, *elt);\n-    }\n-    let mut n = LinkedList::new();\n-    assert_eq!(n.iter().next(), None);\n-    n.push_front(4);\n-    let mut it = n.iter();\n-    assert_eq!(it.size_hint(), (1, Some(1)));\n-    assert_eq!(it.next().unwrap(), &4);\n-    assert_eq!(it.size_hint(), (0, Some(0)));\n-    assert_eq!(it.next(), None);\n-}\n-\n-#[test]\n-fn test_iterator_clone() {\n-    let mut n = LinkedList::new();\n-    n.push_back(2);\n-    n.push_back(3);\n-    n.push_back(4);\n-    let mut it = n.iter();\n-    it.next();\n-    let mut jt = it.clone();\n-    assert_eq!(it.next(), jt.next());\n-    assert_eq!(it.next_back(), jt.next_back());\n-    assert_eq!(it.next(), jt.next());\n-}\n-\n-#[test]\n-fn test_iterator_double_end() {\n-    let mut n = LinkedList::new();\n-    assert_eq!(n.iter().next(), None);\n-    n.push_front(4);\n-    n.push_front(5);\n-    n.push_front(6);\n-    let mut it = n.iter();\n-    assert_eq!(it.size_hint(), (3, Some(3)));\n-    assert_eq!(it.next().unwrap(), &6);\n-    assert_eq!(it.size_hint(), (2, Some(2)));\n-    assert_eq!(it.next_back().unwrap(), &4);\n-    assert_eq!(it.size_hint(), (1, Some(1)));\n-    assert_eq!(it.next_back().unwrap(), &5);\n-    assert_eq!(it.next_back(), None);\n-    assert_eq!(it.next(), None);\n-}\n-\n-#[test]\n-fn test_rev_iter() {\n-    let m = generate_test();\n-    for (i, elt) in m.iter().rev().enumerate() {\n-        assert_eq!((6 - i) as i32, *elt);\n-    }\n-    let mut n = LinkedList::new();\n-    assert_eq!(n.iter().rev().next(), None);\n-    n.push_front(4);\n-    let mut it = n.iter().rev();\n-    assert_eq!(it.size_hint(), (1, Some(1)));\n-    assert_eq!(it.next().unwrap(), &4);\n-    assert_eq!(it.size_hint(), (0, Some(0)));\n-    assert_eq!(it.next(), None);\n-}\n-\n-#[test]\n-fn test_mut_iter() {\n-    let mut m = generate_test();\n-    let mut len = m.len();\n-    for (i, elt) in m.iter_mut().enumerate() {\n-        assert_eq!(i as i32, *elt);\n-        len -= 1;\n-    }\n-    assert_eq!(len, 0);\n-    let mut n = LinkedList::new();\n-    assert!(n.iter_mut().next().is_none());\n-    n.push_front(4);\n-    n.push_back(5);\n-    let mut it = n.iter_mut();\n-    assert_eq!(it.size_hint(), (2, Some(2)));\n-    assert!(it.next().is_some());\n-    assert!(it.next().is_some());\n-    assert_eq!(it.size_hint(), (0, Some(0)));\n-    assert!(it.next().is_none());\n-}\n-\n-#[test]\n-fn test_iterator_mut_double_end() {\n-    let mut n = LinkedList::new();\n-    assert!(n.iter_mut().next_back().is_none());\n-    n.push_front(4);\n-    n.push_front(5);\n-    n.push_front(6);\n-    let mut it = n.iter_mut();\n-    assert_eq!(it.size_hint(), (3, Some(3)));\n-    assert_eq!(*it.next().unwrap(), 6);\n-    assert_eq!(it.size_hint(), (2, Some(2)));\n-    assert_eq!(*it.next_back().unwrap(), 4);\n-    assert_eq!(it.size_hint(), (1, Some(1)));\n-    assert_eq!(*it.next_back().unwrap(), 5);\n-    assert!(it.next_back().is_none());\n-    assert!(it.next().is_none());\n-}\n-\n-#[test]\n-fn test_mut_rev_iter() {\n-    let mut m = generate_test();\n-    for (i, elt) in m.iter_mut().rev().enumerate() {\n-        assert_eq!((6 - i) as i32, *elt);\n-    }\n-    let mut n = LinkedList::new();\n-    assert!(n.iter_mut().rev().next().is_none());\n-    n.push_front(4);\n-    let mut it = n.iter_mut().rev();\n-    assert!(it.next().is_some());\n-    assert!(it.next().is_none());\n-}\n-\n-#[test]\n-fn test_eq() {\n-    let mut n = list_from(&[]);\n-    let mut m = list_from(&[]);\n-    assert!(n == m);\n-    n.push_front(1);\n-    assert!(n != m);\n-    m.push_back(1);\n-    assert!(n == m);\n-\n-    let n = list_from(&[2, 3, 4]);\n-    let m = list_from(&[1, 2, 3]);\n-    assert!(n != m);\n-}\n \n #[test]\n fn test_hash() {\n@@ -256,449 +19,3 @@ fn test_hash() {\n \n     assert!(hash(&x) == hash(&y));\n }\n-\n-#[test]\n-fn test_ord() {\n-    let n = list_from(&[]);\n-    let m = list_from(&[1, 2, 3]);\n-    assert!(n < m);\n-    assert!(m > n);\n-    assert!(n <= n);\n-    assert!(n >= n);\n-}\n-\n-#[test]\n-fn test_ord_nan() {\n-    let nan = 0.0f64 / 0.0;\n-    let n = list_from(&[nan]);\n-    let m = list_from(&[nan]);\n-    assert!(!(n < m));\n-    assert!(!(n > m));\n-    assert!(!(n <= m));\n-    assert!(!(n >= m));\n-\n-    let n = list_from(&[nan]);\n-    let one = list_from(&[1.0f64]);\n-    assert!(!(n < one));\n-    assert!(!(n > one));\n-    assert!(!(n <= one));\n-    assert!(!(n >= one));\n-\n-    let u = list_from(&[1.0f64, 2.0, nan]);\n-    let v = list_from(&[1.0f64, 2.0, 3.0]);\n-    assert!(!(u < v));\n-    assert!(!(u > v));\n-    assert!(!(u <= v));\n-    assert!(!(u >= v));\n-\n-    let s = list_from(&[1.0f64, 2.0, 4.0, 2.0]);\n-    let t = list_from(&[1.0f64, 2.0, 3.0, 2.0]);\n-    assert!(!(s < t));\n-    assert!(s > one);\n-    assert!(!(s <= one));\n-    assert!(s >= one);\n-}\n-\n-#[test]\n-fn test_show() {\n-    let list: LinkedList<_> = (0..10).collect();\n-    assert_eq!(format!(\"{list:?}\"), \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n-\n-    let list: LinkedList<_> = [\"just\", \"one\", \"test\", \"more\"].into_iter().collect();\n-    assert_eq!(format!(\"{list:?}\"), \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n-}\n-\n-#[test]\n-fn test_extend_ref() {\n-    let mut a = LinkedList::new();\n-    a.push_back(1);\n-\n-    a.extend(&[2, 3, 4]);\n-\n-    assert_eq!(a.len(), 4);\n-    assert_eq!(a, list_from(&[1, 2, 3, 4]));\n-\n-    let mut b = LinkedList::new();\n-    b.push_back(5);\n-    b.push_back(6);\n-    a.extend(&b);\n-\n-    assert_eq!(a.len(), 6);\n-    assert_eq!(a, list_from(&[1, 2, 3, 4, 5, 6]));\n-}\n-\n-#[test]\n-fn test_extend() {\n-    let mut a = LinkedList::new();\n-    a.push_back(1);\n-    a.extend(vec![2, 3, 4]); // uses iterator\n-\n-    assert_eq!(a.len(), 4);\n-    assert!(a.iter().eq(&[1, 2, 3, 4]));\n-\n-    let b: LinkedList<_> = [5, 6, 7].into_iter().collect();\n-    a.extend(b); // specializes to `append`\n-\n-    assert_eq!(a.len(), 7);\n-    assert!(a.iter().eq(&[1, 2, 3, 4, 5, 6, 7]));\n-}\n-\n-#[test]\n-fn test_contains() {\n-    let mut l = LinkedList::new();\n-    l.extend(&[2, 3, 4]);\n-\n-    assert!(l.contains(&3));\n-    assert!(!l.contains(&1));\n-\n-    l.clear();\n-\n-    assert!(!l.contains(&3));\n-}\n-\n-#[test]\n-fn drain_filter_empty() {\n-    let mut list: LinkedList<i32> = LinkedList::new();\n-\n-    {\n-        let mut iter = list.drain_filter(|_| true);\n-        assert_eq!(iter.size_hint(), (0, Some(0)));\n-        assert_eq!(iter.next(), None);\n-        assert_eq!(iter.size_hint(), (0, Some(0)));\n-        assert_eq!(iter.next(), None);\n-        assert_eq!(iter.size_hint(), (0, Some(0)));\n-    }\n-\n-    assert_eq!(list.len(), 0);\n-    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![]);\n-}\n-\n-#[test]\n-fn drain_filter_zst() {\n-    let mut list: LinkedList<_> = [(), (), (), (), ()].into_iter().collect();\n-    let initial_len = list.len();\n-    let mut count = 0;\n-\n-    {\n-        let mut iter = list.drain_filter(|_| true);\n-        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n-        while let Some(_) = iter.next() {\n-            count += 1;\n-            assert_eq!(iter.size_hint(), (0, Some(initial_len - count)));\n-        }\n-        assert_eq!(iter.size_hint(), (0, Some(0)));\n-        assert_eq!(iter.next(), None);\n-        assert_eq!(iter.size_hint(), (0, Some(0)));\n-    }\n-\n-    assert_eq!(count, initial_len);\n-    assert_eq!(list.len(), 0);\n-    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![]);\n-}\n-\n-#[test]\n-fn drain_filter_false() {\n-    let mut list: LinkedList<_> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n-\n-    let initial_len = list.len();\n-    let mut count = 0;\n-\n-    {\n-        let mut iter = list.drain_filter(|_| false);\n-        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n-        for _ in iter.by_ref() {\n-            count += 1;\n-        }\n-        assert_eq!(iter.size_hint(), (0, Some(0)));\n-        assert_eq!(iter.next(), None);\n-        assert_eq!(iter.size_hint(), (0, Some(0)));\n-    }\n-\n-    assert_eq!(count, 0);\n-    assert_eq!(list.len(), initial_len);\n-    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n-}\n-\n-#[test]\n-fn drain_filter_true() {\n-    let mut list: LinkedList<_> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n-\n-    let initial_len = list.len();\n-    let mut count = 0;\n-\n-    {\n-        let mut iter = list.drain_filter(|_| true);\n-        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n-        while let Some(_) = iter.next() {\n-            count += 1;\n-            assert_eq!(iter.size_hint(), (0, Some(initial_len - count)));\n-        }\n-        assert_eq!(iter.size_hint(), (0, Some(0)));\n-        assert_eq!(iter.next(), None);\n-        assert_eq!(iter.size_hint(), (0, Some(0)));\n-    }\n-\n-    assert_eq!(count, initial_len);\n-    assert_eq!(list.len(), 0);\n-    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![]);\n-}\n-\n-#[test]\n-fn drain_filter_complex() {\n-    {\n-        //                [+xxx++++++xxxxx++++x+x++]\n-        let mut list = [\n-            1, 2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36, 37,\n-            39,\n-        ]\n-        .into_iter()\n-        .collect::<LinkedList<_>>();\n-\n-        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n-        assert_eq!(removed.len(), 10);\n-        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n-\n-        assert_eq!(list.len(), 14);\n-        assert_eq!(\n-            list.into_iter().collect::<Vec<_>>(),\n-            vec![1, 7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35, 37, 39]\n-        );\n-    }\n-\n-    {\n-        // [xxx++++++xxxxx++++x+x++]\n-        let mut list =\n-            [2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36, 37, 39]\n-                .into_iter()\n-                .collect::<LinkedList<_>>();\n-\n-        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n-        assert_eq!(removed.len(), 10);\n-        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n-\n-        assert_eq!(list.len(), 13);\n-        assert_eq!(\n-            list.into_iter().collect::<Vec<_>>(),\n-            vec![7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35, 37, 39]\n-        );\n-    }\n-\n-    {\n-        // [xxx++++++xxxxx++++x+x]\n-        let mut list =\n-            [2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36]\n-                .into_iter()\n-                .collect::<LinkedList<_>>();\n-\n-        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n-        assert_eq!(removed.len(), 10);\n-        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n-\n-        assert_eq!(list.len(), 11);\n-        assert_eq!(\n-            list.into_iter().collect::<Vec<_>>(),\n-            vec![7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35]\n-        );\n-    }\n-\n-    {\n-        // [xxxxxxxxxx+++++++++++]\n-        let mut list = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n-            .into_iter()\n-            .collect::<LinkedList<_>>();\n-\n-        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n-        assert_eq!(removed.len(), 10);\n-        assert_eq!(removed, vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20]);\n-\n-        assert_eq!(list.len(), 10);\n-        assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n-    }\n-\n-    {\n-        // [+++++++++++xxxxxxxxxx]\n-        let mut list = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n-            .into_iter()\n-            .collect::<LinkedList<_>>();\n-\n-        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n-        assert_eq!(removed.len(), 10);\n-        assert_eq!(removed, vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20]);\n-\n-        assert_eq!(list.len(), 10);\n-        assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n-    }\n-}\n-\n-#[test]\n-fn drain_filter_drop_panic_leak() {\n-    static mut DROPS: i32 = 0;\n-\n-    struct D(bool);\n-\n-    impl Drop for D {\n-        fn drop(&mut self) {\n-            unsafe {\n-                DROPS += 1;\n-            }\n-\n-            if self.0 {\n-                panic!(\"panic in `drop`\");\n-            }\n-        }\n-    }\n-\n-    let mut q = LinkedList::new();\n-    q.push_back(D(false));\n-    q.push_back(D(false));\n-    q.push_back(D(false));\n-    q.push_back(D(false));\n-    q.push_back(D(false));\n-    q.push_front(D(false));\n-    q.push_front(D(true));\n-    q.push_front(D(false));\n-\n-    catch_unwind(AssertUnwindSafe(|| drop(q.drain_filter(|_| true)))).ok();\n-\n-    assert_eq!(unsafe { DROPS }, 8);\n-    assert!(q.is_empty());\n-}\n-\n-#[test]\n-fn drain_filter_pred_panic_leak() {\n-    static mut DROPS: i32 = 0;\n-\n-    #[derive(Debug)]\n-    struct D(u32);\n-\n-    impl Drop for D {\n-        fn drop(&mut self) {\n-            unsafe {\n-                DROPS += 1;\n-            }\n-        }\n-    }\n-\n-    let mut q = LinkedList::new();\n-    q.push_back(D(3));\n-    q.push_back(D(4));\n-    q.push_back(D(5));\n-    q.push_back(D(6));\n-    q.push_back(D(7));\n-    q.push_front(D(2));\n-    q.push_front(D(1));\n-    q.push_front(D(0));\n-\n-    catch_unwind(AssertUnwindSafe(|| {\n-        drop(q.drain_filter(|item| if item.0 >= 2 { panic!() } else { true }))\n-    }))\n-    .ok();\n-\n-    assert_eq!(unsafe { DROPS }, 2); // 0 and 1\n-    assert_eq!(q.len(), 6);\n-}\n-\n-#[test]\n-fn test_drop() {\n-    static mut DROPS: i32 = 0;\n-    struct Elem;\n-    impl Drop for Elem {\n-        fn drop(&mut self) {\n-            unsafe {\n-                DROPS += 1;\n-            }\n-        }\n-    }\n-\n-    let mut ring = LinkedList::new();\n-    ring.push_back(Elem);\n-    ring.push_front(Elem);\n-    ring.push_back(Elem);\n-    ring.push_front(Elem);\n-    drop(ring);\n-\n-    assert_eq!(unsafe { DROPS }, 4);\n-}\n-\n-#[test]\n-fn test_drop_with_pop() {\n-    static mut DROPS: i32 = 0;\n-    struct Elem;\n-    impl Drop for Elem {\n-        fn drop(&mut self) {\n-            unsafe {\n-                DROPS += 1;\n-            }\n-        }\n-    }\n-\n-    let mut ring = LinkedList::new();\n-    ring.push_back(Elem);\n-    ring.push_front(Elem);\n-    ring.push_back(Elem);\n-    ring.push_front(Elem);\n-\n-    drop(ring.pop_back());\n-    drop(ring.pop_front());\n-    assert_eq!(unsafe { DROPS }, 2);\n-\n-    drop(ring);\n-    assert_eq!(unsafe { DROPS }, 4);\n-}\n-\n-#[test]\n-fn test_drop_clear() {\n-    static mut DROPS: i32 = 0;\n-    struct Elem;\n-    impl Drop for Elem {\n-        fn drop(&mut self) {\n-            unsafe {\n-                DROPS += 1;\n-            }\n-        }\n-    }\n-\n-    let mut ring = LinkedList::new();\n-    ring.push_back(Elem);\n-    ring.push_front(Elem);\n-    ring.push_back(Elem);\n-    ring.push_front(Elem);\n-    ring.clear();\n-    assert_eq!(unsafe { DROPS }, 4);\n-\n-    drop(ring);\n-    assert_eq!(unsafe { DROPS }, 4);\n-}\n-\n-#[test]\n-fn test_drop_panic() {\n-    static mut DROPS: i32 = 0;\n-\n-    struct D(bool);\n-\n-    impl Drop for D {\n-        fn drop(&mut self) {\n-            unsafe {\n-                DROPS += 1;\n-            }\n-\n-            if self.0 {\n-                panic!(\"panic in `drop`\");\n-            }\n-        }\n-    }\n-\n-    let mut q = LinkedList::new();\n-    q.push_back(D(false));\n-    q.push_back(D(false));\n-    q.push_back(D(false));\n-    q.push_back(D(false));\n-    q.push_back(D(false));\n-    q.push_front(D(false));\n-    q.push_front(D(false));\n-    q.push_front(D(true));\n-\n-    catch_unwind(move || drop(q)).ok();\n-\n-    assert_eq!(unsafe { DROPS }, 8);\n-}"}, {"sha": "1bf447347408d0ee6e7eea68e5626b868e274ad9", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=f6cbc92e2a91cd6018a999ce99a0e4af924c5b59", "patch": "@@ -2189,7 +2189,7 @@ macro_rules! int_impl {\n         ///\n         /// # Panics\n         ///\n-        /// When the number is zero, or if the base is not at least 2; it\n+        /// When the number is negative, zero, or if the base is not at least 2; it\n         /// panics in debug mode and the return value is 0 in release\n         /// mode.\n         ///\n@@ -2223,7 +2223,7 @@ macro_rules! int_impl {\n         ///\n         /// # Panics\n         ///\n-        /// When the number is zero it panics in debug mode and the return value\n+        /// When the number is negative or zero it panics in debug mode and the return value\n         /// is 0 in release mode.\n         ///\n         /// # Examples\n@@ -2256,7 +2256,7 @@ macro_rules! int_impl {\n         ///\n         /// # Panics\n         ///\n-        /// When the number is zero it panics in debug mode and the return value\n+        /// When the number is negative or zero it panics in debug mode and the return value\n         /// is 0 in release mode.\n         ///\n         /// # Example"}, {"sha": "ce52e4773ce1f4388ab289786f02c0c194727348", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=f6cbc92e2a91cd6018a999ce99a0e4af924c5b59", "patch": "@@ -689,7 +689,7 @@ macro_rules! uint_impl {\n         ///\n         /// # Panics\n         ///\n-        /// When the number is negative, zero, or if the base is not at least 2;\n+        /// When the number is zero, or if the base is not at least 2;\n         /// it panics in debug mode and the return value is 0 in release mode.\n         ///\n         /// # Examples\n@@ -722,7 +722,7 @@ macro_rules! uint_impl {\n         ///\n         /// # Panics\n         ///\n-        /// When the number is negative or zero it panics in debug mode and\n+        /// When the number is zero it panics in debug mode and\n         /// the return value is 0 in release mode.\n         ///\n         /// # Examples\n@@ -755,7 +755,7 @@ macro_rules! uint_impl {\n         ///\n         /// # Panics\n         ///\n-        /// When the number is negative or zero it panics in debug mode and the\n+        /// When the number is zero it panics in debug mode and the\n         /// return value is 0 in release mode.\n         ///\n         /// # Example"}, {"sha": "4dfc02dea460572b8a724338f2f95319fd36b1f0", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=f6cbc92e2a91cd6018a999ce99a0e4af924c5b59", "patch": "@@ -2359,6 +2359,7 @@ impl Step for Bootstrap {\n             .env(\"RUSTFLAGS\", \"-Cdebuginfo=2\")\n             .env(\"CARGO_TARGET_DIR\", builder.out.join(\"bootstrap\"))\n             .env(\"RUSTC_BOOTSTRAP\", \"1\")\n+            .env(\"RUSTDOC\", builder.rustdoc(builder.compiler(0, builder.build.build)))\n             .env(\"RUSTC\", &builder.initial_rustc);\n         if let Some(flags) = option_env!(\"RUSTFLAGS\") {\n             // Use the same rustc flags for testing as for \"normal\" compilation,\n@@ -2369,6 +2370,16 @@ impl Step for Bootstrap {\n         if !builder.fail_fast {\n             cmd.arg(\"--no-fail-fast\");\n         }\n+        match builder.doc_tests {\n+            DocTests::Only => {\n+                cmd.arg(\"--doc\");\n+            }\n+            DocTests::No => {\n+                cmd.args(&[\"--lib\", \"--bins\", \"--examples\", \"--tests\", \"--benches\"]);\n+            }\n+            DocTests::Yes => {}\n+        }\n+\n         cmd.arg(\"--\").args(&builder.config.cmd.test_args());\n         // rustbuild tests are racy on directory creation so just run them one at a time.\n         // Since there's not many this shouldn't be a problem."}, {"sha": "899f24fc754a14b89617093824d258aaa3aa2943", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-tools/browser-ui-test.version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fbrowser-ui-test.version", "raw_url": "https://github.com/rust-lang/rust/raw/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fbrowser-ui-test.version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fbrowser-ui-test.version?ref=f6cbc92e2a91cd6018a999ce99a0e4af924c5b59", "patch": "@@ -1 +1 @@\n-0.8.5\n\\ No newline at end of file\n+0.9.0\n\\ No newline at end of file"}, {"sha": "42acd30a0ff6a5caf5d784dd275c4e6c251809c0", "filename": "src/test/ui/weird-exprs.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/src%2Ftest%2Fui%2Fweird-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/src%2Ftest%2Fui%2Fweird-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fweird-exprs.rs?ref=f6cbc92e2a91cd6018a999ce99a0e4af924c5b59", "patch": "@@ -164,6 +164,12 @@ fn monkey_barrel() {\n     assert_eq!(val, ());\n }\n \n+fn bathroom_stall() {\n+    let mut i = 1;\n+    matches!(2, _|_|_|_|_|_ if (i+=1) != (i+=1));\n+    assert_eq!(i, 13);\n+}\n+\n pub fn main() {\n     strange();\n     funny();\n@@ -183,4 +189,5 @@ pub fn main() {\n     i_yield();\n     match_nested_if();\n     monkey_barrel();\n+    bathroom_stall();\n }"}, {"sha": "d75884567afee2db06aa351e2b051883e8d08f11", "filename": "src/tools/rustdoc-gui/tester.js", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/src%2Ftools%2Frustdoc-gui%2Ftester.js", "raw_url": "https://github.com/rust-lang/rust/raw/f6cbc92e2a91cd6018a999ce99a0e4af924c5b59/src%2Ftools%2Frustdoc-gui%2Ftester.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-gui%2Ftester.js?ref=f6cbc92e2a91cd6018a999ce99a0e4af924c5b59", "patch": "@@ -138,7 +138,6 @@ async function main(argv) {\n     try {\n         // This is more convenient that setting fields one by one.\n         let args = [\n-            \"--no-screenshot-comparison\",\n             \"--variable\", \"DOC_PATH\", opts[\"doc_folder\"],\n         ];\n         if (opts[\"debug\"]) {"}]}