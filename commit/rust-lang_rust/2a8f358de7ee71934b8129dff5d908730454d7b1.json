{"sha": "2a8f358de7ee71934b8129dff5d908730454d7b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhOGYzNThkZTdlZTcxOTM0YjgxMjlkZmY1ZDkwODczMDQ1NGQ3YjE=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2015-11-03T16:39:51Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2015-11-26T20:46:12Z"}, "message": "Add syntax support for attributes on expressions and all syntax\nnodes in statement position.\n\nExtended #[cfg] folder to allow removal of statements, and\nof expressions in optional positions like expression lists and trailing\nblock expressions.\n\nExtended lint checker to recognize lint levels on expressions and\nlocals.", "tree": {"sha": "977fde21c8fa8ce4d39aad1c6ac5c7c3b2386a93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/977fde21c8fa8ce4d39aad1c6ac5c7c3b2386a93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a8f358de7ee71934b8129dff5d908730454d7b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a8f358de7ee71934b8129dff5d908730454d7b1", "html_url": "https://github.com/rust-lang/rust/commit/2a8f358de7ee71934b8129dff5d908730454d7b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a8f358de7ee71934b8129dff5d908730454d7b1/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ef02eff89e3d2a29eab3346bff393821df6e033", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ef02eff89e3d2a29eab3346bff393821df6e033", "html_url": "https://github.com/rust-lang/rust/commit/6ef02eff89e3d2a29eab3346bff393821df6e033"}], "stats": {"total": 2018, "additions": 1602, "deletions": 416}, "files": [{"sha": "9a30ec1a2b6034b162e4ec0ccedca713a4286047", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -41,7 +41,7 @@ use syntax::ast_util::{self, IdVisitingOperation};\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n-use syntax::ast;\n+use syntax::ast::{self, ThinAttributesExt};\n use rustc_front::hir;\n use rustc_front::util;\n use rustc_front::intravisit as hir_visit;\n@@ -674,11 +674,18 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, e: &hir::Expr) {\n-        run_lints!(self, check_expr, late_passes, e);\n-        hir_visit::walk_expr(self, e);\n+        self.with_lint_attrs(e.attrs.as_attrs(), |cx| {\n+            run_lints!(cx, check_expr, late_passes, e);\n+            hir_visit::walk_expr(cx, e);\n+        })\n     }\n \n     fn visit_stmt(&mut self, s: &hir::Stmt) {\n+        // statement attributes are actually just attributes on one of\n+        // - item\n+        // - local\n+        // - expression\n+        // so we keep track of lint levels there\n         run_lints!(self, check_stmt, late_passes, s);\n         hir_visit::walk_stmt(self, s);\n     }\n@@ -730,8 +737,10 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_local(&mut self, l: &hir::Local) {\n-        run_lints!(self, check_local, late_passes, l);\n-        hir_visit::walk_local(self, l);\n+        self.with_lint_attrs(l.attrs.as_attrs(), |cx| {\n+            run_lints!(cx, check_local, late_passes, l);\n+            hir_visit::walk_local(cx, l);\n+        })\n     }\n \n     fn visit_block(&mut self, b: &hir::Block) {"}, {"sha": "a292c83682c0e3340da742af8f078f4e70925c3a", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -409,7 +409,8 @@ fn const_val_to_expr(value: &ConstVal) -> P<hir::Expr> {\n     P(hir::Expr {\n         id: 0,\n         node: hir::ExprLit(P(Spanned { node: node, span: DUMMY_SP })),\n-        span: DUMMY_SP\n+        span: DUMMY_SP,\n+        attrs: None,\n     })\n }\n "}, {"sha": "9a489ac6fdf71a29a408d82a0ae28a7f21bfea9f", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -654,6 +654,7 @@ impl fold::Folder for ReplaceBodyWithLoop {\n                 node: ast::ExprLoop(empty_block, None),\n                 id: ast::DUMMY_NODE_ID,\n                 span: codemap::DUMMY_SP,\n+                attrs: None,\n             });\n \n             expr_to_block(b.rules, Some(loop_expr))"}, {"sha": "028ecbc336e7e64466352b7c79367fa2a3baddf3", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -13,7 +13,7 @@\n \n use hir::*;\n use syntax::ast::{Ident, Name, NodeId, DUMMY_NODE_ID, Attribute, Attribute_, MetaItem};\n-use syntax::ast::{MetaWord, MetaList, MetaNameValue};\n+use syntax::ast::{MetaWord, MetaList, MetaNameValue, ThinAttributesExt};\n use hir;\n use syntax::codemap::{respan, Span, Spanned};\n use syntax::owned_slice::OwnedSlice;\n@@ -501,13 +501,14 @@ pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesizedPara\n }\n \n pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n-    l.map(|Local { id, pat, ty, init, span }| {\n+    l.map(|Local { id, pat, ty, init, span, attrs }| {\n         Local {\n             id: fld.new_id(id),\n             ty: ty.map(|t| fld.fold_ty(t)),\n             pat: fld.fold_pat(pat),\n             init: init.map(|e| fld.fold_expr(e)),\n             span: fld.new_span(span),\n+            attrs: attrs.map_opt_attrs(|attrs| fold_attrs(attrs, fld)),\n         }\n     })\n }\n@@ -1048,7 +1049,7 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n     })\n }\n \n-pub fn noop_fold_expr<T: Folder>(Expr { id, node, span }: Expr, folder: &mut T) -> Expr {\n+pub fn noop_fold_expr<T: Folder>(Expr { id, node, span, attrs }: Expr, folder: &mut T) -> Expr {\n     Expr {\n         id: folder.new_id(id),\n         node: match node {\n@@ -1171,6 +1172,7 @@ pub fn noop_fold_expr<T: Folder>(Expr { id, node, span }: Expr, folder: &mut T)\n             }\n         },\n         span: folder.new_span(span),\n+        attrs: attrs.map_opt_attrs(|attrs| fold_attrs(attrs, folder)),\n     }\n }\n "}, {"sha": "f0f9512cd0f0ee372c25ab5b733d06b2527589a5", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -41,6 +41,7 @@ use syntax::codemap::{self, Span, Spanned, DUMMY_SP, ExpnId};\n use syntax::abi::Abi;\n use syntax::ast::{Name, Ident, NodeId, DUMMY_NODE_ID, TokenTree, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, CrateConfig};\n+use syntax::ast::ThinAttributes;\n use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n@@ -558,6 +559,7 @@ pub struct Local {\n     pub init: Option<P<Expr>>,\n     pub id: NodeId,\n     pub span: Span,\n+    pub attrs: ThinAttributes,\n }\n \n pub type Decl = Spanned<Decl_>;\n@@ -609,6 +611,7 @@ pub struct Expr {\n     pub id: NodeId,\n     pub node: Expr_,\n     pub span: Span,\n+    pub attrs: ThinAttributes,\n }\n \n impl fmt::Debug for Expr {"}, {"sha": "0f89ddb99870fa76251e9f6932fb35307ef650ce", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 44, "deletions": 21, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -331,6 +331,7 @@ pub fn lower_local(lctx: &LoweringContext, l: &Local) -> P<hir::Local> {\n         pat: lower_pat(lctx, &l.pat),\n         init: l.init.as_ref().map(|e| lower_expr(lctx, e)),\n         span: l.span,\n+        attrs: l.attrs.clone(),\n     })\n }\n \n@@ -1215,7 +1216,14 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                 maybe_expr.as_ref().map(|x| lower_expr(lctx, x)))\n             }\n             ExprParen(ref ex) => {\n-                return lower_expr(lctx, ex);\n+                // merge attributes into the inner expression.\n+                return lower_expr(lctx, ex).map(|mut ex| {\n+                    ex.attrs.update(|attrs| {\n+                        // FIXME: Badly named\n+                        attrs.prepend_outer(e.attrs.clone())\n+                    });\n+                    ex\n+                });\n             }\n \n             // Desugar ExprIfLet\n@@ -1454,6 +1462,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n             ExprMac(_) => panic!(\"Shouldn't exist here\"),\n         },\n         span: e.span,\n+        attrs: e.attrs.clone(),\n     })\n }\n \n@@ -1552,60 +1561,71 @@ fn arm(pats: Vec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n     }\n }\n \n-fn expr_break(lctx: &LoweringContext, span: Span) -> P<hir::Expr> {\n-    expr(lctx, span, hir::ExprBreak(None))\n+fn expr_break(lctx: &LoweringContext, span: Span,\n+              attrs: ThinAttributes) -> P<hir::Expr> {\n+    expr(lctx, span, hir::ExprBreak(None), attrs)\n }\n \n fn expr_call(lctx: &LoweringContext,\n              span: Span,\n              e: P<hir::Expr>,\n-             args: Vec<P<hir::Expr>>)\n+             args: Vec<P<hir::Expr>>,\n+             attrs: ThinAttributes)\n              -> P<hir::Expr> {\n-    expr(lctx, span, hir::ExprCall(e, args))\n+    expr(lctx, span, hir::ExprCall(e, args), attrs)\n }\n \n-fn expr_ident(lctx: &LoweringContext, span: Span, id: Ident) -> P<hir::Expr> {\n-    expr_path(lctx, path_ident(span, id))\n+fn expr_ident(lctx: &LoweringContext, span: Span, id: Ident,\n+              attrs: ThinAttributes) -> P<hir::Expr> {\n+    expr_path(lctx, path_ident(span, id), attrs)\n }\n \n-fn expr_mut_addr_of(lctx: &LoweringContext, span: Span, e: P<hir::Expr>) -> P<hir::Expr> {\n-    expr(lctx, span, hir::ExprAddrOf(hir::MutMutable, e))\n+fn expr_mut_addr_of(lctx: &LoweringContext, span: Span, e: P<hir::Expr>,\n+                    attrs: ThinAttributes) -> P<hir::Expr> {\n+    expr(lctx, span, hir::ExprAddrOf(hir::MutMutable, e), attrs)\n }\n \n-fn expr_path(lctx: &LoweringContext, path: hir::Path) -> P<hir::Expr> {\n-    expr(lctx, path.span, hir::ExprPath(None, path))\n+fn expr_path(lctx: &LoweringContext, path: hir::Path,\n+             attrs: ThinAttributes) -> P<hir::Expr> {\n+    expr(lctx, path.span, hir::ExprPath(None, path), attrs)\n }\n \n fn expr_match(lctx: &LoweringContext,\n               span: Span,\n               arg: P<hir::Expr>,\n               arms: Vec<hir::Arm>,\n-              source: hir::MatchSource)\n+              source: hir::MatchSource,\n+              attrs: ThinAttributes)\n               -> P<hir::Expr> {\n-    expr(lctx, span, hir::ExprMatch(arg, arms, source))\n+    expr(lctx, span, hir::ExprMatch(arg, arms, source), attrs)\n }\n \n-fn expr_block(lctx: &LoweringContext, b: P<hir::Block>) -> P<hir::Expr> {\n-    expr(lctx, b.span, hir::ExprBlock(b))\n+fn expr_block(lctx: &LoweringContext, b: P<hir::Block>,\n+              attrs: ThinAttributes) -> P<hir::Expr> {\n+    expr(lctx, b.span, hir::ExprBlock(b), attrs)\n }\n \n-fn expr_tuple(lctx: &LoweringContext, sp: Span, exprs: Vec<P<hir::Expr>>) -> P<hir::Expr> {\n-    expr(lctx, sp, hir::ExprTup(exprs))\n+fn expr_tuple(lctx: &LoweringContext, sp: Span, exprs: Vec<P<hir::Expr>>,\n+              attrs: ThinAttributes) -> P<hir::Expr> {\n+    expr(lctx, sp, hir::ExprTup(exprs), attrs)\n }\n \n-fn expr(lctx: &LoweringContext, span: Span, node: hir::Expr_) -> P<hir::Expr> {\n+fn expr(lctx: &LoweringContext, span: Span, node: hir::Expr_,\n+        attrs: ThinAttributes) -> P<hir::Expr> {\n     P(hir::Expr {\n         id: lctx.next_id(),\n         node: node,\n         span: span,\n+        attrs: attrs,\n     })\n }\n \n fn stmt_let(lctx: &LoweringContext,\n             sp: Span,\n             mutbl: bool,\n             ident: Ident,\n-            ex: P<hir::Expr>)\n+            ex: P<hir::Expr>,\n+            attrs: ThinAttributes)\n             -> P<hir::Stmt> {\n     let pat = if mutbl {\n         pat_ident_binding_mode(lctx, sp, ident, hir::BindByValue(hir::MutMutable))\n@@ -1618,6 +1638,7 @@ fn stmt_let(lctx: &LoweringContext,\n         init: Some(ex),\n         id: lctx.next_id(),\n         span: sp,\n+        attrs: attrs,\n     });\n     let decl = respan(sp, hir::DeclLocal(local));\n     P(respan(sp, hir::StmtDecl(P(decl), lctx.next_id())))\n@@ -1755,7 +1776,8 @@ fn signal_block_expr(lctx: &LoweringContext,\n                      stmts: Vec<P<hir::Stmt>>,\n                      expr: P<hir::Expr>,\n                      span: Span,\n-                     rule: hir::BlockCheckMode)\n+                     rule: hir::BlockCheckMode,\n+                     attrs: ThinAttributes)\n                      -> P<hir::Expr> {\n     let id = lctx.next_id();\n     expr_block(lctx,\n@@ -1765,7 +1787,8 @@ fn signal_block_expr(lctx: &LoweringContext,\n                    id: id,\n                    stmts: stmts,\n                    expr: Some(expr),\n-               }))\n+               }),\n+               attrs)\n }\n \n "}, {"sha": "b5f8be496fb02f451867a5d26e61e2d4ca1f5a39", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -138,7 +138,7 @@ impl LateLintPass for NonCamelCaseTypes {\n declare_lint! {\n     pub NON_SNAKE_CASE,\n     Warn,\n-    \"methods, functions, lifetime parameters and modules should have snake case names\"\n+    \"variables, methods, functions, lifetime parameters and modules should have snake case names\"\n }\n \n #[derive(Copy, Clone)]"}, {"sha": "48c5be8e07eab8bfbd59382ecf0c174dea9bf36b", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 141, "deletions": 1, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -692,8 +692,21 @@ pub enum Stmt_ {\n     /// Expr with trailing semi-colon (may have any type):\n     StmtSemi(P<Expr>, NodeId),\n \n-    StmtMac(P<Mac>, MacStmtStyle),\n+    StmtMac(P<Mac>, MacStmtStyle, ThinAttributes),\n }\n+\n+impl Stmt_ {\n+    pub fn attrs(&self) -> &[Attribute] {\n+        match *self {\n+            StmtDecl(ref d, _) => d.attrs(),\n+            StmtExpr(ref e, _) |\n+            StmtSemi(ref e, _) => e.attrs(),\n+            StmtMac(_, _, Some(ref b)) => b,\n+            StmtMac(_, _, None) => &[],\n+        }\n+    }\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum MacStmtStyle {\n     /// The macro statement had a trailing semicolon, e.g. `foo! { ... };`\n@@ -718,6 +731,16 @@ pub struct Local {\n     pub init: Option<P<Expr>>,\n     pub id: NodeId,\n     pub span: Span,\n+    pub attrs: ThinAttributes,\n+}\n+\n+impl Local {\n+    pub fn attrs(&self) -> &[Attribute] {\n+        match self.attrs {\n+            Some(ref b) => b,\n+            None => &[],\n+        }\n+    }\n }\n \n pub type Decl = Spanned<Decl_>;\n@@ -730,6 +753,15 @@ pub enum Decl_ {\n     DeclItem(P<Item>),\n }\n \n+impl Decl {\n+    pub fn attrs(&self) -> &[Attribute] {\n+        match self.node {\n+            DeclLocal(ref l) => l.attrs(),\n+            DeclItem(ref i) => i.attrs(),\n+        }\n+    }\n+}\n+\n /// represents one arm of a 'match'\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Arm {\n@@ -766,6 +798,16 @@ pub struct Expr {\n     pub id: NodeId,\n     pub node: Expr_,\n     pub span: Span,\n+    pub attrs: ThinAttributes\n+}\n+\n+impl Expr {\n+    pub fn attrs(&self) -> &[Attribute] {\n+        match self.attrs {\n+            Some(ref b) => b,\n+            None => &[],\n+        }\n+    }\n }\n \n impl fmt::Debug for Expr {\n@@ -1792,6 +1834,12 @@ pub struct Item {\n     pub span: Span,\n }\n \n+impl Item {\n+    pub fn attrs(&self) -> &[Attribute] {\n+        &self.attrs\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Item_ {\n     /// An`extern crate` item, with optional original crate name,\n@@ -1904,6 +1952,98 @@ pub struct MacroDef {\n     pub body: Vec<TokenTree>,\n }\n \n+/// A list of attributes, behind a optional box as\n+/// a space optimization.\n+pub type ThinAttributes = Option<Box<Vec<Attribute>>>;\n+\n+pub trait ThinAttributesExt {\n+    fn map_opt_attrs<F>(self, f: F) -> Self\n+        where F: FnOnce(Vec<Attribute>) -> Vec<Attribute>;\n+    fn prepend_outer(mut self, attrs: Self) -> Self;\n+    fn append_inner(mut self, attrs: Self) -> Self;\n+    fn update<F>(&mut self, f: F)\n+        where Self: Sized,\n+              F: FnOnce(Self) -> Self;\n+    fn as_attrs(&self) -> &[Attribute];\n+    fn into_attrs(self) -> Vec<Attribute>;\n+}\n+\n+// FIXME: Rename inner/outer\n+// FIXME: Rename opt_attrs\n+\n+impl ThinAttributesExt for ThinAttributes {\n+    fn map_opt_attrs<F>(self, f: F) -> Self\n+        where F: FnOnce(Vec<Attribute>) -> Vec<Attribute> {\n+\n+        // This is kinda complicated... Ensure the function is\n+        // always called, and that None inputs or results are\n+        // correctly handled.\n+        if let Some(mut b) = self {\n+            use std::mem::replace;\n+\n+            let vec = replace(&mut *b, Vec::new());\n+            let vec = f(vec);\n+            if vec.len() == 0 {\n+                None\n+            } else {\n+                replace(&mut*b, vec);\n+                Some(b)\n+            }\n+        } else {\n+            f(Vec::new()).into_opt_attrs()\n+        }\n+    }\n+\n+    fn prepend_outer(self, attrs: ThinAttributes) -> Self {\n+        attrs.map_opt_attrs(|mut attrs| {\n+            attrs.extend(self.into_attrs());\n+            attrs\n+        })\n+    }\n+\n+    fn append_inner(self, attrs: ThinAttributes) -> Self {\n+        self.map_opt_attrs(|mut self_| {\n+            self_.extend(attrs.into_attrs());\n+            self_\n+        })\n+    }\n+\n+    fn update<F>(&mut self, f: F)\n+        where Self: Sized,\n+              F: FnOnce(ThinAttributes) -> ThinAttributes\n+    {\n+        let self_ = f(self.take());\n+        *self = self_;\n+    }\n+\n+    fn as_attrs(&self) -> &[Attribute] {\n+        match *self {\n+            Some(ref b) => b,\n+            None => &[],\n+        }\n+    }\n+\n+    fn into_attrs(self) -> Vec<Attribute> {\n+        match self {\n+            Some(b) => *b,\n+            None => Vec::new(),\n+        }\n+    }\n+}\n+\n+pub trait AttributesExt {\n+    fn into_opt_attrs(self) -> ThinAttributes;\n+}\n+impl AttributesExt for Vec<Attribute> {\n+    fn into_opt_attrs(self) -> ThinAttributes {\n+        if self.len() == 0 {\n+            None\n+        } else {\n+            Some(Box::new(self))\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use serialize;"}, {"sha": "18f7311418f6a8b3cb39f4b9f02dca0901acf568", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -16,6 +16,8 @@ pub use self::IntType::*;\n \n use ast;\n use ast::{AttrId, Attribute, Attribute_, MetaItem, MetaWord, MetaNameValue, MetaList};\n+use ast::{Stmt, StmtDecl, StmtExpr, StmtMac, StmtSemi, DeclItem, DeclLocal, ThinAttributes};\n+use ast::{Expr, ThinAttributesExt, Item, Local, Decl};\n use codemap::{Span, Spanned, spanned, dummy_spanned};\n use codemap::BytePos;\n use diagnostic::SpanHandler;\n@@ -720,3 +722,83 @@ impl IntType {\n         }\n     }\n }\n+\n+/// A cheap way to add Attributes to an AST node.\n+pub trait WithAttrs {\n+    // FIXME: Could be extended to anything IntoIter<Item=Attribute>\n+    fn with_attrs(self, attrs: ThinAttributes) -> Self;\n+}\n+\n+impl WithAttrs for P<Expr> {\n+    fn with_attrs(self, attrs: ThinAttributes) -> Self {\n+        self.map(|mut e| {\n+            e.attrs.update(|a| a.append_inner(attrs));\n+            e\n+        })\n+    }\n+}\n+\n+impl WithAttrs for P<Item> {\n+    fn with_attrs(self, attrs: ThinAttributes) -> Self {\n+        self.map(|Item { ident, attrs: mut ats, id, node, vis, span }| {\n+            ats.extend(attrs.into_attrs());\n+            Item {\n+                ident: ident,\n+                attrs: ats,\n+                id: id,\n+                node: node,\n+                vis: vis,\n+                span: span,\n+            }\n+        })\n+    }\n+}\n+\n+impl WithAttrs for P<Local> {\n+    fn with_attrs(self, attrs: ThinAttributes) -> Self {\n+        self.map(|Local { pat, ty, init, id, span, attrs: mut ats }| {\n+            ats.update(|a| a.append_inner(attrs));\n+            Local {\n+                pat: pat,\n+                ty: ty,\n+                init: init,\n+                id: id,\n+                span: span,\n+                attrs: ats,\n+            }\n+        })\n+    }\n+}\n+\n+impl WithAttrs for P<Decl> {\n+    fn with_attrs(self, attrs: ThinAttributes) -> Self {\n+        self.map(|Spanned { span, node }| {\n+            Spanned {\n+                span: span,\n+                node: match node {\n+                    DeclLocal(local) => DeclLocal(local.with_attrs(attrs)),\n+                    DeclItem(item) => DeclItem(item.with_attrs(attrs)),\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+impl WithAttrs for P<Stmt> {\n+    fn with_attrs(self, attrs: ThinAttributes) -> Self {\n+        self.map(|Spanned { span, node }| {\n+            Spanned {\n+                span: span,\n+                node: match node {\n+                    StmtDecl(decl, id) => StmtDecl(decl.with_attrs(attrs), id),\n+                    StmtExpr(expr, id) => StmtExpr(expr.with_attrs(attrs), id),\n+                    StmtSemi(expr, id) => StmtSemi(expr.with_attrs(attrs), id),\n+                    StmtMac(mac, style, mut ats) => {\n+                        ats.update(|a| a.append_inner(attrs));\n+                        StmtMac(mac, style, ats)\n+                    }\n+                },\n+            }\n+        })\n+    }\n+}"}, {"sha": "a867b45075f327e784a10b9f3788267869ff2b1b", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 65, "deletions": 42, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -20,8 +20,9 @@ use util::small_vector::SmallVector;\n \n /// A folder that strips out items that do not belong in the current\n /// configuration.\n-struct Context<F> where F: FnMut(&[ast::Attribute]) -> bool {\n+struct Context<'a, F> where F: FnMut(&[ast::Attribute]) -> bool {\n     in_cfg: F,\n+    diagnostic: &'a SpanHandler,\n }\n \n // Support conditional compilation by transforming the AST, stripping out\n@@ -32,25 +33,41 @@ pub fn strip_unconfigured_items(diagnostic: &SpanHandler, krate: ast::Crate,\n {\n     let krate = process_cfg_attr(diagnostic, krate, feature_gated_cfgs);\n     let config = krate.config.clone();\n-    strip_items(krate, |attrs| in_cfg(diagnostic, &config, attrs, feature_gated_cfgs))\n+    strip_items(diagnostic,\n+                krate,\n+                |attrs| in_cfg(diagnostic, &config, attrs, feature_gated_cfgs))\n }\n \n-impl<F> fold::Folder for Context<F> where F: FnMut(&[ast::Attribute]) -> bool {\n+impl<'a, F> fold::Folder for Context<'a, F> where F: FnMut(&[ast::Attribute]) -> bool {\n     fn fold_mod(&mut self, module: ast::Mod) -> ast::Mod {\n         fold_mod(self, module)\n     }\n-    fn fold_block(&mut self, block: P<ast::Block>) -> P<ast::Block> {\n-        fold_block(self, block)\n-    }\n     fn fold_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n         fold_foreign_mod(self, foreign_mod)\n     }\n     fn fold_item_underscore(&mut self, item: ast::Item_) -> ast::Item_ {\n         fold_item_underscore(self, item)\n     }\n     fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n+        // If an expr is valid to cfg away it will have been removed by the\n+        // outer stmt or expression folder before descending in here.\n+        // Anything else is always required, and thus has to error out\n+        // in case of a cfg attr.\n+        //\n+        // NB: This intentionally not part of the fold_expr() function\n+        //     in order for fold_opt_expr() to be able to avoid this check\n+        if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(a)) {\n+            self.diagnostic.span_err(attr.span,\n+                \"removing an expression is not supported in this position\");\n+        }\n         fold_expr(self, expr)\n     }\n+    fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n+        fold_opt_expr(self, expr)\n+    }\n+    fn fold_stmt(&mut self, stmt: P<ast::Stmt>) -> SmallVector<P<ast::Stmt>> {\n+        fold_stmt(self, stmt)\n+    }\n     fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n         fold::noop_fold_mac(mac, self)\n     }\n@@ -59,11 +76,13 @@ impl<F> fold::Folder for Context<F> where F: FnMut(&[ast::Attribute]) -> bool {\n     }\n }\n \n-pub fn strip_items<F>(krate: ast::Crate, in_cfg: F) -> ast::Crate where\n+pub fn strip_items<'a, F>(diagnostic: &'a SpanHandler,\n+                          krate: ast::Crate, in_cfg: F) -> ast::Crate where\n     F: FnMut(&[ast::Attribute]) -> bool,\n {\n     let mut ctxt = Context {\n         in_cfg: in_cfg,\n+        diagnostic: diagnostic,\n     };\n     ctxt.fold_crate(krate)\n }\n@@ -182,45 +201,20 @@ fn fold_struct<F>(cx: &mut Context<F>, vdata: ast::VariantData) -> ast::VariantD\n     }\n }\n \n-fn retain_stmt<F>(cx: &mut Context<F>, stmt: &ast::Stmt) -> bool where\n-    F: FnMut(&[ast::Attribute]) -> bool\n+fn fold_opt_expr<F>(cx: &mut Context<F>, expr: P<ast::Expr>) -> Option<P<ast::Expr>>\n+    where F: FnMut(&[ast::Attribute]) -> bool\n {\n-    match stmt.node {\n-        ast::StmtDecl(ref decl, _) => {\n-            match decl.node {\n-                ast::DeclItem(ref item) => {\n-                    item_in_cfg(cx, item)\n-                }\n-                _ => true\n-            }\n-        }\n-        _ => true\n+    if expr_in_cfg(cx, &expr) {\n+        Some(fold_expr(cx, expr))\n+    } else {\n+        None\n     }\n }\n \n-fn fold_block<F>(cx: &mut Context<F>, b: P<ast::Block>) -> P<ast::Block> where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    b.map(|ast::Block {id, stmts, expr, rules, span}| {\n-        let resulting_stmts: Vec<P<ast::Stmt>> =\n-            stmts.into_iter().filter(|a| retain_stmt(cx, a)).collect();\n-        let resulting_stmts = resulting_stmts.into_iter()\n-            .flat_map(|stmt| cx.fold_stmt(stmt).into_iter())\n-            .collect();\n-        ast::Block {\n-            id: id,\n-            stmts: resulting_stmts,\n-            expr: expr.map(|x| cx.fold_expr(x)),\n-            rules: rules,\n-            span: span,\n-        }\n-    })\n-}\n-\n fn fold_expr<F>(cx: &mut Context<F>, expr: P<ast::Expr>) -> P<ast::Expr> where\n     F: FnMut(&[ast::Attribute]) -> bool\n {\n-    expr.map(|ast::Expr {id, span, node}| {\n+    expr.map(|ast::Expr {id, span, node, attrs}| {\n         fold::noop_fold_expr(ast::Expr {\n             id: id,\n             node: match node {\n@@ -231,11 +225,34 @@ fn fold_expr<F>(cx: &mut Context<F>, expr: P<ast::Expr>) -> P<ast::Expr> where\n                 }\n                 _ => node\n             },\n-            span: span\n+            span: span,\n+            attrs: attrs,\n         }, cx)\n     })\n }\n \n+fn fold_stmt<F>(cx: &mut Context<F>, stmt: P<ast::Stmt>) -> SmallVector<P<ast::Stmt>>\n+    where F: FnMut(&[ast::Attribute]) -> bool\n+{\n+    if stmt_in_cfg(cx, &stmt) {\n+        stmt.and_then(|s| fold::noop_fold_stmt(s, cx))\n+    } else {\n+        SmallVector::zero()\n+    }\n+}\n+\n+fn stmt_in_cfg<F>(cx: &mut Context<F>, stmt: &ast::Stmt) -> bool where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n+    (cx.in_cfg)(stmt.node.attrs())\n+}\n+\n+fn expr_in_cfg<F>(cx: &mut Context<F>, expr: &ast::Expr) -> bool where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n+    (cx.in_cfg)(expr.attrs())\n+}\n+\n fn item_in_cfg<F>(cx: &mut Context<F>, item: &ast::Item) -> bool where\n     F: FnMut(&[ast::Attribute]) -> bool\n {\n@@ -248,13 +265,19 @@ fn foreign_item_in_cfg<F>(cx: &mut Context<F>, item: &ast::ForeignItem) -> bool\n     return (cx.in_cfg)(&item.attrs);\n }\n \n+fn is_cfg(attr: &ast::Attribute) -> bool {\n+    attr.check_name(\"cfg\")\n+}\n+\n // Determine if an item should be translated in the current crate\n // configuration based on the item's attributes\n-fn in_cfg(diagnostic: &SpanHandler, cfg: &[P<ast::MetaItem>], attrs: &[ast::Attribute],\n+fn in_cfg(diagnostic: &SpanHandler,\n+          cfg: &[P<ast::MetaItem>],\n+          attrs: &[ast::Attribute],\n           feature_gated_cfgs: &mut Vec<GatedCfg>) -> bool {\n     attrs.iter().all(|attr| {\n         let mis = match attr.node.value.node {\n-            ast::MetaList(_, ref mis) if attr.check_name(\"cfg\") => mis,\n+            ast::MetaList(_, ref mis) if is_cfg(&attr) => mis,\n             _ => return true\n         };\n "}, {"sha": "d968858f634eb60f20267808233d1cb90f0604ce", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -233,6 +233,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             dialect: dialect,\n             expn_id: expn_id,\n         }),\n-        span: sp\n+        span: sp,\n+        attrs: None,\n     }))\n }"}, {"sha": "8c93327c322b25fc8140ac20cb2750c2f3c9af31", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -349,6 +349,7 @@ impl DummyResult {\n             id: ast::DUMMY_NODE_ID,\n             node: ast::ExprLit(P(codemap::respan(sp, ast::LitBool(false)))),\n             span: sp,\n+            attrs: None,\n         })\n     }\n "}, {"sha": "806f5a7ee22ed36cec7529a9d89836dd503eb515", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -525,6 +525,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             init: Some(ex),\n             id: ast::DUMMY_NODE_ID,\n             span: sp,\n+            attrs: None,\n         });\n         let decl = respan(sp, ast::DeclLocal(local));\n         P(respan(sp, ast::StmtDecl(P(decl), ast::DUMMY_NODE_ID)))\n@@ -548,6 +549,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             init: Some(ex),\n             id: ast::DUMMY_NODE_ID,\n             span: sp,\n+            attrs: None,\n         });\n         let decl = respan(sp, ast::DeclLocal(local));\n         P(respan(sp, ast::StmtDecl(P(decl), ast::DUMMY_NODE_ID)))\n@@ -584,6 +586,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n             span: span,\n+            attrs: None,\n         })\n     }\n "}, {"sha": "c2233202b2f81067ee9abbd9413f358e9d7cc09e", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -67,6 +67,7 @@ pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree])\n             }\n         ),\n         span: sp,\n+        attrs: None,\n     });\n     MacEager::expr(e)\n }"}, {"sha": "9488cfb86fc9fd6d2439acb2d65517e192b76a06", "filename": "src/libsyntax/ext/deriving/debug.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdebug.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -148,6 +148,7 @@ fn stmt_let_undescore(cx: &mut ExtCtxt,\n         init: Some(expr),\n         id: ast::DUMMY_NODE_ID,\n         span: sp,\n+        attrs: None,\n     });\n     let decl = respan(sp, ast::DeclLocal(local));\n     P(respan(sp, ast::StmtDecl(P(decl), ast::DUMMY_NODE_ID)))"}, {"sha": "132b29c76232e28b5ea175397cbb68b9b95a5261", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -17,7 +17,7 @@ use ast;\n use ext::mtwt;\n use ext::build::AstBuilder;\n use attr;\n-use attr::AttrMetaMethods;\n+use attr::{AttrMetaMethods, WithAttrs};\n use codemap;\n use codemap::{Span, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use ext::base::*;\n@@ -37,11 +37,16 @@ use std::collections::HashSet;\n \n pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n     let expr_span = e.span;\n-    return e.and_then(|ast::Expr {id, node, span}| match node {\n+    // FIXME: Drop attrs on the floor for now.\n+    return e.and_then(|ast::Expr {id, node, span, attrs}| match node {\n \n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n         ast::ExprMac(mac) => {\n+\n+            // drop attributes on the macro itself\n+            let _ = attrs;\n+\n             let expanded_expr = match expand_mac_invoc(mac, span,\n                                                        |r| r.make_expr(),\n                                                        mark_expr, fld) {\n@@ -60,6 +65,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n                 id: ast::DUMMY_NODE_ID,\n                 node: e.node,\n                 span: span,\n+                attrs: e.attrs,\n             })\n         }\n \n@@ -73,12 +79,14 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             let placer = fld.fold_expr(placer);\n             let value_expr = fld.fold_expr(value_expr);\n             fld.cx.expr(span, ast::ExprInPlace(placer, value_expr))\n+                .with_attrs(attrs)\n         }\n \n         ast::ExprWhile(cond, body, opt_ident) => {\n             let cond = fld.fold_expr(cond);\n             let (body, opt_ident) = expand_loop_block(body, opt_ident, fld);\n             fld.cx.expr(span, ast::ExprWhile(cond, body, opt_ident))\n+                .with_attrs(attrs)\n         }\n \n         ast::ExprWhileLet(pat, expr, body, opt_ident) => {\n@@ -96,11 +104,13 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             assert!(rewritten_pats.len() == 1);\n \n             fld.cx.expr(span, ast::ExprWhileLet(rewritten_pats.remove(0), expr, body, opt_ident))\n+                .with_attrs(attrs)\n         }\n \n         ast::ExprLoop(loop_block, opt_ident) => {\n             let (loop_block, opt_ident) = expand_loop_block(loop_block, opt_ident, fld);\n             fld.cx.expr(span, ast::ExprLoop(loop_block, opt_ident))\n+                .with_attrs(attrs)\n         }\n \n         ast::ExprForLoop(pat, head, body, opt_ident) => {\n@@ -118,6 +128,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n \n             let head = fld.fold_expr(head);\n             fld.cx.expr(span, ast::ExprForLoop(rewritten_pats.remove(0), head, body, opt_ident))\n+                .with_attrs(attrs)\n         }\n \n         ast::ExprIfLet(pat, sub_expr, body, else_opt) => {\n@@ -136,6 +147,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             let else_opt = else_opt.map(|else_opt| fld.fold_expr(else_opt));\n             let sub_expr = fld.fold_expr(sub_expr);\n             fld.cx.expr(span, ast::ExprIfLet(rewritten_pats.remove(0), sub_expr, body, else_opt))\n+                .with_attrs(attrs)\n         }\n \n         ast::ExprClosure(capture_clause, fn_decl, block) => {\n@@ -144,15 +156,18 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             let new_node = ast::ExprClosure(capture_clause,\n                                             rewritten_fn_decl,\n                                             rewritten_block);\n-            P(ast::Expr{id:id, node: new_node, span: fld.new_span(span)})\n+            P(ast::Expr{id:id, node: new_node, span: fld.new_span(span),\n+                        attrs: None})\n+                .with_attrs(attrs)\n         }\n \n         _ => {\n             P(noop_fold_expr(ast::Expr {\n                 id: id,\n                 node: node,\n-                span: span\n-            }, fld))\n+                span: span,\n+                attrs: None\n+            }, fld)).with_attrs(attrs)\n         }\n     });\n }\n@@ -486,11 +501,14 @@ pub fn expand_item_mac(it: P<ast::Item>,\n /// Expand a stmt\n fn expand_stmt(stmt: P<Stmt>, fld: &mut MacroExpander) -> SmallVector<P<Stmt>> {\n     let stmt = stmt.and_then(|stmt| stmt);\n-    let (mac, style) = match stmt.node {\n-        StmtMac(mac, style) => (mac, style),\n+    let (mac, style, attrs) = match stmt.node {\n+        StmtMac(mac, style, attrs) => (mac, style, attrs),\n         _ => return expand_non_macro_stmt(stmt, fld)\n     };\n \n+    // FIXME: drop attrs for macros.\n+    let _ = attrs;\n+\n     let maybe_new_items =\n         expand_mac_invoc(mac.and_then(|m| m), stmt.span,\n                          |r| r.make_stmts(),\n@@ -538,7 +556,7 @@ fn expand_non_macro_stmt(Spanned {node, span: stmt_span}: Stmt, fld: &mut MacroE\n         StmtDecl(decl, node_id) => decl.and_then(|Spanned {node: decl, span}| match decl {\n             DeclLocal(local) => {\n                 // take it apart:\n-                let rewritten_local = local.map(|Local {id, pat, ty, init, span}| {\n+                let rewritten_local = local.map(|Local {id, pat, ty, init, span, attrs}| {\n                     // expand the ty since TyFixedLengthVec contains an Expr\n                     // and thus may have a macro use\n                     let expanded_ty = ty.map(|t| fld.fold_ty(t));\n@@ -568,7 +586,8 @@ fn expand_non_macro_stmt(Spanned {node, span: stmt_span}: Stmt, fld: &mut MacroE\n                         pat: rewritten_pat,\n                         // also, don't forget to expand the init:\n                         init: init.map(|e| fld.fold_expr(e)),\n-                        span: span\n+                        span: span,\n+                        attrs: attrs\n                     }\n                 });\n                 SmallVector::one(P(Spanned {"}, {"sha": "fc6cacb40f1f37d95511ad8f083cce399c59fe0a", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -242,6 +242,7 @@ pub mod rt {\n                 id: ast::DUMMY_NODE_ID,\n                 node: ast::ExprLit(P(self.clone())),\n                 span: DUMMY_SP,\n+                attrs: None,\n             }).to_tokens(cx)\n         }\n     }"}, {"sha": "1d499bce3c695ecb501263a9c1763aec5f01db5b", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 48, "deletions": 19, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -134,6 +134,14 @@ pub trait Folder : Sized {\n         e.map(|e| noop_fold_expr(e, self))\n     }\n \n+    fn fold_opt_expr(&mut self, e: P<Expr>) -> Option<P<Expr>> {\n+        noop_fold_opt_expr(e, self)\n+    }\n+\n+    fn fold_exprs(&mut self, es: Vec<P<Expr>>) -> Vec<P<Expr>> {\n+        noop_fold_exprs(es, self)\n+    }\n+\n     fn fold_ty(&mut self, t: P<Ty>) -> P<Ty> {\n         noop_fold_ty(t, self)\n     }\n@@ -508,12 +516,13 @@ pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesizedPara\n }\n \n pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n-    l.map(|Local {id, pat, ty, init, span}| Local {\n+    l.map(|Local {id, pat, ty, init, span, attrs}| Local {\n         id: fld.new_id(id),\n         ty: ty.map(|t| fld.fold_ty(t)),\n         pat: fld.fold_pat(pat),\n         init: init.map(|e| fld.fold_expr(e)),\n-        span: fld.new_span(span)\n+        span: fld.new_span(span),\n+        attrs: attrs.map_opt_attrs(|v| fold_attrs(v, fld)),\n     })\n }\n \n@@ -891,7 +900,7 @@ pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n     b.map(|Block {id, stmts, expr, rules, span}| Block {\n         id: folder.new_id(id),\n         stmts: stmts.into_iter().flat_map(|s| folder.fold_stmt(s).into_iter()).collect(),\n-        expr: expr.map(|x| folder.fold_expr(x)),\n+        expr: expr.and_then(|x| folder.fold_opt_expr(x)),\n         rules: rules,\n         span: folder.new_span(span),\n     })\n@@ -1171,7 +1180,7 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n     })\n }\n \n-pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) -> Expr {\n+pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mut T) -> Expr {\n     Expr {\n         id: folder.new_id(id),\n         node: match node {\n@@ -1182,21 +1191,21 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n                 ExprInPlace(folder.fold_expr(p), folder.fold_expr(e))\n             }\n             ExprVec(exprs) => {\n-                ExprVec(exprs.move_map(|x| folder.fold_expr(x)))\n+                ExprVec(folder.fold_exprs(exprs))\n             }\n             ExprRepeat(expr, count) => {\n                 ExprRepeat(folder.fold_expr(expr), folder.fold_expr(count))\n             }\n-            ExprTup(elts) => ExprTup(elts.move_map(|x| folder.fold_expr(x))),\n+            ExprTup(exprs) => ExprTup(folder.fold_exprs(exprs)),\n             ExprCall(f, args) => {\n                 ExprCall(folder.fold_expr(f),\n-                         args.move_map(|x| folder.fold_expr(x)))\n+                         folder.fold_exprs(args))\n             }\n             ExprMethodCall(i, tps, args) => {\n                 ExprMethodCall(\n                     respan(folder.new_span(i.span), folder.fold_ident(i.node)),\n                     tps.move_map(|x| folder.fold_ty(x)),\n-                    args.move_map(|x| folder.fold_expr(x)))\n+                    folder.fold_exprs(args))\n             }\n             ExprBinary(binop, lhs, rhs) => {\n                 ExprBinary(binop,\n@@ -1329,10 +1338,20 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n             },\n             ExprParen(ex) => ExprParen(folder.fold_expr(ex))\n         },\n-        span: folder.new_span(span)\n+        span: folder.new_span(span),\n+        attrs: attrs.map_opt_attrs(|v| fold_attrs(v, folder)),\n     }\n }\n \n+pub fn noop_fold_opt_expr<T: Folder>(e: P<Expr>, folder: &mut T) -> Option<P<Expr>> {\n+    Some(folder.fold_expr(e))\n+}\n+\n+pub fn noop_fold_exprs<T: Folder>(es: Vec<P<Expr>>, folder: &mut T) -> Vec<P<Expr>> {\n+    // FIXME: Needs a efficient in-place flat_map\n+    es.into_iter().flat_map(|e| folder.fold_opt_expr(e)).collect()\n+}\n+\n pub fn noop_fold_stmt<T: Folder>(Spanned {node, span}: Stmt, folder: &mut T)\n                                  -> SmallVector<P<Stmt>> {\n     let span = folder.new_span(span);\n@@ -1346,20 +1365,30 @@ pub fn noop_fold_stmt<T: Folder>(Spanned {node, span}: Stmt, folder: &mut T)\n         }\n         StmtExpr(e, id) => {\n             let id = folder.new_id(id);\n-            SmallVector::one(P(Spanned {\n-                node: StmtExpr(folder.fold_expr(e), id),\n-                span: span\n-            }))\n+            if let Some(e) = folder.fold_opt_expr(e) {\n+                SmallVector::one(P(Spanned {\n+                    node: StmtExpr(e, id),\n+                    span: span\n+                }))\n+            } else {\n+                SmallVector::zero()\n+            }\n         }\n         StmtSemi(e, id) => {\n             let id = folder.new_id(id);\n-            SmallVector::one(P(Spanned {\n-                node: StmtSemi(folder.fold_expr(e), id),\n-                span: span\n-            }))\n+            if let Some(e) = folder.fold_opt_expr(e) {\n+                SmallVector::one(P(Spanned {\n+                    node: StmtSemi(e, id),\n+                    span: span\n+                }))\n+            } else {\n+                SmallVector::zero()\n+            }\n         }\n-        StmtMac(mac, semi) => SmallVector::one(P(Spanned {\n-            node: StmtMac(mac.map(|m| folder.fold_mac(m)), semi),\n+        StmtMac(mac, semi, attrs) => SmallVector::one(P(Spanned {\n+            node: StmtMac(mac.map(|m| folder.fold_mac(m)),\n+                          semi,\n+                          attrs.map_opt_attrs(|v| fold_attrs(v, folder))),\n             span: span\n         }))\n     }"}, {"sha": "e9c8173a4d9802e4bc6b0f5d7a36f0e6a06aa8e9", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -699,7 +699,8 @@ mod tests {\n                             }\n                         ),\n                     }),\n-                    span: sp(0, 1)\n+                    span: sp(0, 1),\n+                    attrs: None,\n                    }))\n     }\n \n@@ -721,7 +722,8 @@ mod tests {\n                                 }\n                             )\n                         }),\n-                    span: sp(0, 6)\n+                    span: sp(0, 6),\n+                    attrs: None,\n                    }))\n     }\n \n@@ -848,9 +850,11 @@ mod tests {\n                                 }\n                             ),\n                         }),\n-                        span:sp(7,8)\n+                        span:sp(7,8),\n+                        attrs: None,\n                     }))),\n-                    span:sp(0,8)\n+                    span:sp(0,8),\n+                    attrs: None,\n                    }))\n     }\n \n@@ -869,7 +873,8 @@ mod tests {\n                                 }\n                                ),\n                             }),\n-                           span: sp(0,1)}),\n+                           span: sp(0,1),\n+                           attrs: None}),\n                                            ast::DUMMY_NODE_ID),\n                        span: sp(0,1)})))\n \n@@ -963,7 +968,8 @@ mod tests {\n                                                             }\n                                                         ),\n                                                       }),\n-                                                span: sp(17,18)}),\n+                                                span: sp(17,18),\n+                                                attrs: None,}),\n                                                 ast::DUMMY_NODE_ID),\n                                             span: sp(17,19)})),\n                                         expr: None,"}, {"sha": "2f67ecad4e74d86502838e816bed3e5db0d0d61c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 302, "deletions": 146, "changes": 448, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -56,6 +56,7 @@ use ast::TypeTraitItem;\n use ast::{UnnamedField, UnsafeBlock};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n+use ast::{ThinAttributes, ThinAttributesExt, AttributesExt};\n use ast;\n use ast_util::{self, ident_to_path};\n use codemap::{self, Span, BytePos, Spanned, spanned, mk_sp, CodeMap};\n@@ -140,7 +141,7 @@ macro_rules! maybe_whole_expr {\n                         _ => unreachable!()\n                     };\n                     let span = $p.span;\n-                    Some($p.mk_expr(span.lo, span.hi, ExprPath(None, pt)))\n+                    Some($p.mk_expr(span.lo, span.hi, ExprPath(None, pt), None))\n                 }\n                 token::Interpolated(token::NtBlock(_)) => {\n                     // FIXME: The following avoids an issue with lexical borrowck scopes,\n@@ -150,7 +151,7 @@ macro_rules! maybe_whole_expr {\n                         _ => unreachable!()\n                     };\n                     let span = $p.span;\n-                    Some($p.mk_expr(span.lo, span.hi, ExprBlock(b)))\n+                    Some($p.mk_expr(span.lo, span.hi, ExprBlock(b), None))\n                 }\n                 _ => None\n             };\n@@ -319,6 +320,27 @@ pub struct ModulePathError {\n     pub help_msg: String,\n }\n \n+pub enum LhsExpr {\n+    NotYetParsed,\n+    AttributesParsed(ThinAttributes),\n+    AlreadyParsed(P<Expr>),\n+}\n+\n+impl From<Option<ThinAttributes>> for LhsExpr {\n+    fn from(o: Option<ThinAttributes>) -> Self {\n+        if let Some(attrs) = o {\n+            LhsExpr::AttributesParsed(attrs)\n+        } else {\n+            LhsExpr::NotYetParsed\n+        }\n+    }\n+}\n+\n+impl From<P<Expr>> for LhsExpr {\n+    fn from(expr: P<Expr>) -> Self {\n+        LhsExpr::AlreadyParsed(expr)\n+    }\n+}\n \n impl<'a> Parser<'a> {\n     pub fn new(sess: &'a ParseSess,\n@@ -1557,19 +1579,18 @@ impl<'a> Parser<'a> {\n     }\n \n     /// matches '-' lit | lit\n-    pub fn parse_literal_maybe_minus(&mut self) -> PResult<P<Expr>> {\n+    pub fn parse_pat_literal_maybe_minus(&mut self) -> PResult<P<Expr>> {\n         let minus_lo = self.span.lo;\n         let minus_present = try!(self.eat(&token::BinOp(token::Minus)));\n-\n         let lo = self.span.lo;\n         let literal = P(try!(self.parse_lit()));\n         let hi = self.last_span.hi;\n-        let expr = self.mk_expr(lo, hi, ExprLit(literal));\n+        let expr = self.mk_expr(lo, hi, ExprLit(literal), None);\n \n         if minus_present {\n             let minus_hi = self.last_span.hi;\n             let unary = self.mk_unary(UnNeg, expr);\n-            Ok(self.mk_expr(minus_lo, minus_hi, unary))\n+            Ok(self.mk_expr(minus_lo, minus_hi, unary, None))\n         } else {\n             Ok(expr)\n         }\n@@ -1914,11 +1935,13 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    pub fn mk_expr(&mut self, lo: BytePos, hi: BytePos, node: Expr_) -> P<Expr> {\n+    pub fn mk_expr(&mut self, lo: BytePos, hi: BytePos,\n+                   node: Expr_, attrs: ThinAttributes) -> P<Expr> {\n         P(Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n             span: mk_sp(lo, hi),\n+            attrs: attrs,\n         })\n     }\n \n@@ -1966,15 +1989,17 @@ impl<'a> Parser<'a> {\n         ExprAssignOp(binop, lhs, rhs)\n     }\n \n-    pub fn mk_mac_expr(&mut self, lo: BytePos, hi: BytePos, m: Mac_) -> P<Expr> {\n+    pub fn mk_mac_expr(&mut self, lo: BytePos, hi: BytePos,\n+                       m: Mac_, attrs: ThinAttributes) -> P<Expr> {\n         P(Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: ExprMac(codemap::Spanned {node: m, span: mk_sp(lo, hi)}),\n             span: mk_sp(lo, hi),\n+            attrs: attrs,\n         })\n     }\n \n-    pub fn mk_lit_u32(&mut self, i: u32) -> P<Expr> {\n+    pub fn mk_lit_u32(&mut self, i: u32, attrs: ThinAttributes) -> P<Expr> {\n         let span = &self.span;\n         let lv_lit = P(codemap::Spanned {\n             node: LitInt(i as u64, ast::UnsignedIntLit(TyU32)),\n@@ -1985,6 +2010,7 @@ impl<'a> Parser<'a> {\n             id: ast::DUMMY_NODE_ID,\n             node: ExprLit(lv_lit),\n             span: *span,\n+            attrs: attrs,\n         })\n     }\n \n@@ -2002,9 +2028,20 @@ impl<'a> Parser<'a> {\n     /// At the bottom (top?) of the precedence hierarchy,\n     /// parse things like parenthesized exprs,\n     /// macros, return, etc.\n-    pub fn parse_bottom_expr(&mut self) -> PResult<P<Expr>> {\n+    ///\n+    /// NB: This does not parse outer attributes,\n+    ///     and is private because it only works\n+    ///     correctly if called from parse_dot_or_call_expr().\n+    fn parse_bottom_expr(&mut self) -> PResult<P<Expr>> {\n         maybe_whole_expr!(self);\n \n+        // Outer attributes are already parsed and will be\n+        // added to the return value after the fact.\n+        //\n+        // Therefore, prevent sub-parser from parsing\n+        // attributes by giving them a empty \"already parsed\" list.\n+        let mut attrs = None;\n+\n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n \n@@ -2015,6 +2052,10 @@ impl<'a> Parser<'a> {\n             token::OpenDelim(token::Paren) => {\n                 try!(self.bump());\n \n+                let attrs = try!(self.parse_inner_attributes())\n+                    .into_opt_attrs()\n+                    .prepend_outer(attrs);\n+\n                 // (e) is parenthesized e\n                 // (e,) is a tuple with only one field, e\n                 let mut es = vec![];\n@@ -2036,17 +2077,17 @@ impl<'a> Parser<'a> {\n \n                 hi = self.last_span.hi;\n                 return if es.len() == 1 && !trailing_comma {\n-                    Ok(self.mk_expr(lo, hi, ExprParen(es.into_iter().nth(0).unwrap())))\n+                    Ok(self.mk_expr(lo, hi, ExprParen(es.into_iter().nth(0).unwrap()), attrs))\n                 } else {\n-                    Ok(self.mk_expr(lo, hi, ExprTup(es)))\n+                    Ok(self.mk_expr(lo, hi, ExprTup(es), attrs))\n                 }\n             },\n             token::OpenDelim(token::Brace) => {\n-                return self.parse_block_expr(lo, DefaultBlock);\n+                return self.parse_block_expr(lo, DefaultBlock, attrs);\n             },\n             token::BinOp(token::Or) |  token::OrOr => {\n                 let lo = self.span.lo;\n-                return self.parse_lambda_expr(lo, CaptureByRef);\n+                return self.parse_lambda_expr(lo, CaptureByRef, attrs);\n             },\n             token::Ident(id @ ast::Ident {\n                             name: token::SELF_KEYWORD_NAME,\n@@ -2060,6 +2101,10 @@ impl<'a> Parser<'a> {\n             token::OpenDelim(token::Bracket) => {\n                 try!(self.bump());\n \n+                let inner_attrs = try!(self.parse_inner_attributes())\n+                    .into_opt_attrs();\n+                attrs.update(|attrs| attrs.append_inner(inner_attrs));\n+\n                 if self.check(&token::CloseDelim(token::Bracket)) {\n                     // Empty vector.\n                     try!(self.bump());\n@@ -2097,42 +2142,42 @@ impl<'a> Parser<'a> {\n                     let (qself, path) =\n                         try!(self.parse_qualified_path(LifetimeAndTypesWithColons));\n                     hi = path.span.hi;\n-                    return Ok(self.mk_expr(lo, hi, ExprPath(Some(qself), path)));\n+                    return Ok(self.mk_expr(lo, hi, ExprPath(Some(qself), path), attrs));\n                 }\n                 if try!(self.eat_keyword(keywords::Move) ){\n                     let lo = self.last_span.lo;\n-                    return self.parse_lambda_expr(lo, CaptureByValue);\n+                    return self.parse_lambda_expr(lo, CaptureByValue, attrs);\n                 }\n                 if try!(self.eat_keyword(keywords::If)) {\n-                    return self.parse_if_expr();\n+                    return self.parse_if_expr(attrs);\n                 }\n                 if try!(self.eat_keyword(keywords::For) ){\n                     let lo = self.last_span.lo;\n-                    return self.parse_for_expr(None, lo);\n+                    return self.parse_for_expr(None, lo, attrs);\n                 }\n                 if try!(self.eat_keyword(keywords::While) ){\n                     let lo = self.last_span.lo;\n-                    return self.parse_while_expr(None, lo);\n+                    return self.parse_while_expr(None, lo, attrs);\n                 }\n                 if self.token.is_lifetime() {\n                     let lifetime = self.get_lifetime();\n                     let lo = self.span.lo;\n                     try!(self.bump());\n                     try!(self.expect(&token::Colon));\n                     if try!(self.eat_keyword(keywords::While) ){\n-                        return self.parse_while_expr(Some(lifetime), lo)\n+                        return self.parse_while_expr(Some(lifetime), lo, attrs)\n                     }\n                     if try!(self.eat_keyword(keywords::For) ){\n-                        return self.parse_for_expr(Some(lifetime), lo)\n+                        return self.parse_for_expr(Some(lifetime), lo, attrs)\n                     }\n                     if try!(self.eat_keyword(keywords::Loop) ){\n-                        return self.parse_loop_expr(Some(lifetime), lo)\n+                        return self.parse_loop_expr(Some(lifetime), lo, attrs)\n                     }\n                     return Err(self.fatal(\"expected `while`, `for`, or `loop` after a label\"))\n                 }\n                 if try!(self.eat_keyword(keywords::Loop) ){\n                     let lo = self.last_span.lo;\n-                    return self.parse_loop_expr(None, lo);\n+                    return self.parse_loop_expr(None, lo, attrs);\n                 }\n                 if try!(self.eat_keyword(keywords::Continue) ){\n                     let ex = if self.token.is_lifetime() {\n@@ -2146,15 +2191,16 @@ impl<'a> Parser<'a> {\n                         ExprAgain(None)\n                     };\n                     let hi = self.last_span.hi;\n-                    return Ok(self.mk_expr(lo, hi, ex));\n+                    return Ok(self.mk_expr(lo, hi, ex, attrs));\n                 }\n                 if try!(self.eat_keyword(keywords::Match) ){\n-                    return self.parse_match_expr();\n+                    return self.parse_match_expr(attrs);\n                 }\n                 if try!(self.eat_keyword(keywords::Unsafe) ){\n                     return self.parse_block_expr(\n                         lo,\n-                        UnsafeBlock(ast::UserProvided));\n+                        UnsafeBlock(ast::UserProvided),\n+                        attrs);\n                 }\n                 if try!(self.eat_keyword(keywords::Return) ){\n                     if self.token.can_begin_expr() {\n@@ -2196,7 +2242,8 @@ impl<'a> Parser<'a> {\n \n                         return Ok(self.mk_mac_expr(lo,\n                                                    hi,\n-                                                   Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT }));\n+                                                   Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT },\n+                                                   attrs));\n                     }\n                     if self.check(&token::OpenDelim(token::Brace)) {\n                         // This is a struct literal, unless we're prohibited\n@@ -2210,6 +2257,10 @@ impl<'a> Parser<'a> {\n                             let mut fields = Vec::new();\n                             let mut base = None;\n \n+                            let attrs = attrs.append_inner(\n+                                try!(self.parse_inner_attributes())\n+                                    .into_opt_attrs());\n+\n                             while self.token != token::CloseDelim(token::Brace) {\n                                 if try!(self.eat(&token::DotDot) ){\n                                     base = Some(try!(self.parse_expr()));\n@@ -2225,7 +2276,7 @@ impl<'a> Parser<'a> {\n                             hi = self.span.hi;\n                             try!(self.expect(&token::CloseDelim(token::Brace)));\n                             ex = ExprStruct(pth, fields, base);\n-                            return Ok(self.mk_expr(lo, hi, ex));\n+                            return Ok(self.mk_expr(lo, hi, ex, attrs));\n                         }\n                     }\n \n@@ -2240,24 +2291,74 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        return Ok(self.mk_expr(lo, hi, ex));\n+        return Ok(self.mk_expr(lo, hi, ex, attrs));\n+    }\n+\n+    fn parse_or_use_outer_attributes(&mut self,\n+                                     already_parsed_attrs: Option<ThinAttributes>)\n+                                     -> PResult<ThinAttributes> {\n+        if let Some(attrs) = already_parsed_attrs {\n+            Ok(attrs)\n+        } else {\n+            self.parse_outer_attributes().map(|a| a.into_opt_attrs())\n+        }\n     }\n \n     /// Parse a block or unsafe block\n-    pub fn parse_block_expr(&mut self, lo: BytePos, blk_mode: BlockCheckMode)\n+    pub fn parse_block_expr(&mut self, lo: BytePos, blk_mode: BlockCheckMode,\n+                            attrs: ThinAttributes)\n                             -> PResult<P<Expr>> {\n+\n+        let outer_attrs = attrs;\n         try!(self.expect(&token::OpenDelim(token::Brace)));\n+\n+        let inner_attrs = try!(self.parse_inner_attributes()).into_opt_attrs();\n+        let attrs = outer_attrs.append_inner(inner_attrs);\n+\n         let blk = try!(self.parse_block_tail(lo, blk_mode));\n-        return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprBlock(blk)));\n+        return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprBlock(blk), attrs));\n     }\n \n     /// parse a.b or a(13) or a[4] or just a\n-    pub fn parse_dot_or_call_expr(&mut self) -> PResult<P<Expr>> {\n+    pub fn parse_dot_or_call_expr(&mut self,\n+                                  already_parsed_attrs: Option<ThinAttributes>)\n+                                  -> PResult<P<Expr>> {\n+        let attrs = try!(self.parse_or_use_outer_attributes(already_parsed_attrs));\n+\n         let b = try!(self.parse_bottom_expr());\n-        self.parse_dot_or_call_expr_with(b)\n+        self.parse_dot_or_call_expr_with(b, attrs)\n+    }\n+\n+    pub fn parse_dot_or_call_expr_with(&mut self,\n+                                       e0: P<Expr>,\n+                                       attrs: ThinAttributes)\n+                                       -> PResult<P<Expr>> {\n+        // Stitch the list of outer attributes onto the return value.\n+        // A little bit ugly, but the best way given the current code\n+        // structure\n+        self.parse_dot_or_call_expr_with_(e0)\n+        .map(|expr|\n+            expr.map(|mut expr| {\n+                expr.attrs.update(|a| a.prepend_outer(attrs));\n+                match expr.node {\n+                    ExprIf(..) | ExprIfLet(..) => {\n+                        if !expr.attrs.as_attrs().is_empty() {\n+                            // Just point to the first attribute in there...\n+                            let span = expr.attrs.as_attrs()[0].span;\n+\n+                            self.span_err(span,\n+                                \"attributes are not yet allowed on `if` \\\n+                                expressions\");\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+                expr\n+            })\n+        )\n     }\n \n-    pub fn parse_dot_or_call_expr_with(&mut self, e0: P<Expr>) -> PResult<P<Expr>> {\n+    fn parse_dot_or_call_expr_with_(&mut self, e0: P<Expr>) -> PResult<P<Expr>> {\n         let mut e = e0;\n         let lo = e.span.lo;\n         let mut hi;\n@@ -2295,7 +2396,7 @@ impl<'a> Parser<'a> {\n                             es.insert(0, e);\n                             let id = spanned(dot, hi, i);\n                             let nd = self.mk_method_call(id, tys, es);\n-                            e = self.mk_expr(lo, hi, nd);\n+                            e = self.mk_expr(lo, hi, nd, None);\n                         }\n                         _ => {\n                             if !tys.is_empty() {\n@@ -2307,7 +2408,7 @@ impl<'a> Parser<'a> {\n \n                             let id = spanned(dot, hi, i);\n                             let field = self.mk_field(e, id);\n-                            e = self.mk_expr(lo, hi, field);\n+                            e = self.mk_expr(lo, hi, field, None);\n                         }\n                     }\n                   }\n@@ -2326,7 +2427,7 @@ impl<'a> Parser<'a> {\n                         Some(n) => {\n                             let id = spanned(dot, hi, n);\n                             let field = self.mk_tup_field(e, id);\n-                            e = self.mk_expr(lo, hi, field);\n+                            e = self.mk_expr(lo, hi, field, None);\n                         }\n                         None => {\n                             let last_span = self.last_span;\n@@ -2370,7 +2471,7 @@ impl<'a> Parser<'a> {\n                 hi = self.last_span.hi;\n \n                 let nd = self.mk_call(e, es);\n-                e = self.mk_expr(lo, hi, nd);\n+                e = self.mk_expr(lo, hi, nd, None);\n               }\n \n               // expr[...]\n@@ -2381,7 +2482,7 @@ impl<'a> Parser<'a> {\n                 hi = self.span.hi;\n                 try!(self.commit_expr_expecting(&*ix, token::CloseDelim(token::Bracket)));\n                 let index = self.mk_index(e, ix);\n-                e = self.mk_expr(lo, hi, index)\n+                e = self.mk_expr(lo, hi, index, None)\n               }\n               _ => return Ok(e)\n             }\n@@ -2578,75 +2679,90 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a prefix-unary-operator expr\n-    pub fn parse_prefix_expr(&mut self) -> PResult<P<Expr>> {\n+    pub fn parse_prefix_expr(&mut self,\n+                             already_parsed_attrs: Option<ThinAttributes>)\n+                             -> PResult<P<Expr>> {\n+        let attrs = try!(self.parse_or_use_outer_attributes(already_parsed_attrs));\n         let lo = self.span.lo;\n         let hi;\n         // Note: when adding new unary operators, don't forget to adjust Token::can_begin_expr()\n         let ex = match self.token {\n             token::Not => {\n                 try!(self.bump());\n-                let e = try!(self.parse_prefix_expr());\n+                let e = try!(self.parse_prefix_expr(None));\n                 hi = e.span.hi;\n                 self.mk_unary(UnNot, e)\n             }\n             token::BinOp(token::Minus) => {\n                 try!(self.bump());\n-                let e = try!(self.parse_prefix_expr());\n+                let e = try!(self.parse_prefix_expr(None));\n                 hi = e.span.hi;\n                 self.mk_unary(UnNeg, e)\n             }\n             token::BinOp(token::Star) => {\n                 try!(self.bump());\n-                let e = try!(self.parse_prefix_expr());\n+                let e = try!(self.parse_prefix_expr(None));\n                 hi = e.span.hi;\n                 self.mk_unary(UnDeref, e)\n             }\n             token::BinOp(token::And) | token::AndAnd => {\n                 try!(self.expect_and());\n                 let m = try!(self.parse_mutability());\n-                let e = try!(self.parse_prefix_expr());\n+                let e = try!(self.parse_prefix_expr(None));\n                 hi = e.span.hi;\n                 ExprAddrOf(m, e)\n             }\n             token::Ident(..) if self.token.is_keyword(keywords::In) => {\n                 try!(self.bump());\n-                let place = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n+                let place = try!(self.parse_expr_res(\n+                    Restrictions::RESTRICTION_NO_STRUCT_LITERAL,\n+                    None,\n+                ));\n                 let blk = try!(self.parse_block());\n                 let span = blk.span;\n                 hi = span.hi;\n-                let blk_expr = self.mk_expr(span.lo, span.hi, ExprBlock(blk));\n+                let blk_expr = self.mk_expr(span.lo, span.hi, ExprBlock(blk),\n+                                            None);\n                 ExprInPlace(place, blk_expr)\n             }\n             token::Ident(..) if self.token.is_keyword(keywords::Box) => {\n                 try!(self.bump());\n-                let subexpression = try!(self.parse_prefix_expr());\n+                let subexpression = try!(self.parse_prefix_expr(None));\n                 hi = subexpression.span.hi;\n                 ExprBox(subexpression)\n             }\n-            _ => return self.parse_dot_or_call_expr()\n+            _ => return self.parse_dot_or_call_expr(Some(attrs))\n         };\n-        return Ok(self.mk_expr(lo, hi, ex));\n+        return Ok(self.mk_expr(lo, hi, ex, attrs));\n     }\n \n     /// Parse an associative expression\n     ///\n     /// This parses an expression accounting for associativity and precedence of the operators in\n     /// the expression.\n-    pub fn parse_assoc_expr(&mut self) -> PResult<P<Expr>> {\n-        self.parse_assoc_expr_with(0, None)\n+    pub fn parse_assoc_expr(&mut self,\n+                            already_parsed_attrs: Option<ThinAttributes>)\n+                            -> PResult<P<Expr>> {\n+        self.parse_assoc_expr_with(0, already_parsed_attrs.into())\n     }\n \n     /// Parse an associative expression with operators of at least `min_prec` precedence\n     pub fn parse_assoc_expr_with(&mut self,\n                                  min_prec: usize,\n-                                 lhs: Option<P<Expr>>)\n+                                 lhs: LhsExpr)\n                                  -> PResult<P<Expr>> {\n-        let mut lhs = if lhs.is_some() {\n-            lhs.unwrap()\n-        } else if self.token == token::DotDot {\n-            return self.parse_prefix_range_expr();\n+        let mut lhs = if let LhsExpr::AlreadyParsed(expr) = lhs {\n+            expr\n         } else {\n-            try!(self.parse_prefix_expr())\n+            let attrs = match lhs {\n+                LhsExpr::AttributesParsed(attrs) => Some(attrs),\n+                _ => None,\n+            };\n+            if self.token == token::DotDot {\n+                return self.parse_prefix_range_expr(attrs);\n+            } else {\n+                try!(self.parse_prefix_expr(attrs))\n+            }\n         };\n         if self.expr_is_complete(&*lhs) {\n             // Semi-statement forms are odd. See https://github.com/rust-lang/rust/issues/29071\n@@ -2670,7 +2786,8 @@ impl<'a> Parser<'a> {\n             // Special cases:\n             if op == AssocOp::As {\n                 let rhs = try!(self.parse_ty());\n-                lhs = self.mk_expr(lhs.span.lo, rhs.span.hi, ExprCast(lhs, rhs));\n+                lhs = self.mk_expr(lhs.span.lo, rhs.span.hi,\n+                                   ExprCast(lhs, rhs), None);\n                 continue\n             } else if op == AssocOp::DotDot {\n                     // If we didn\u2019t have to handle `x..`, it would be pretty easy to generalise\n@@ -2679,7 +2796,8 @@ impl<'a> Parser<'a> {\n                     // We have 2 alternatives here: `x..y` and `x..` The other two variants are\n                     // handled with `parse_prefix_range_expr` call above.\n                     let rhs = if self.is_at_start_of_range_notation_rhs() {\n-                        self.parse_assoc_expr_with(op.precedence() + 1, None).ok()\n+                        self.parse_assoc_expr_with(op.precedence() + 1,\n+                                                   LhsExpr::NotYetParsed).ok()\n                     } else {\n                         None\n                     };\n@@ -2689,22 +2807,22 @@ impl<'a> Parser<'a> {\n                         cur_op_span\n                     });\n                     let r = self.mk_range(Some(lhs), rhs);\n-                    lhs = self.mk_expr(lhs_span.lo, rhs_span.hi, r);\n+                    lhs = self.mk_expr(lhs_span.lo, rhs_span.hi, r, None);\n                     break\n             }\n \n \n             let rhs = try!(match op.fixity() {\n                 Fixity::Right => self.with_res(restrictions, |this|{\n-                    this.parse_assoc_expr_with(op.precedence(), None)\n+                    this.parse_assoc_expr_with(op.precedence(), LhsExpr::NotYetParsed)\n                 }),\n                 Fixity::Left => self.with_res(restrictions, |this|{\n-                    this.parse_assoc_expr_with(op.precedence() + 1, None)\n+                    this.parse_assoc_expr_with(op.precedence() + 1, LhsExpr::NotYetParsed)\n                 }),\n                 // We currently have no non-associative operators that are not handled above by\n                 // the special cases. The code is here only for future convenience.\n                 Fixity::None => self.with_res(restrictions, |this|{\n-                    this.parse_assoc_expr_with(op.precedence() + 1, None)\n+                    this.parse_assoc_expr_with(op.precedence() + 1, LhsExpr::NotYetParsed)\n                 }),\n             });\n \n@@ -2717,12 +2835,12 @@ impl<'a> Parser<'a> {\n                     let ast_op = op.to_ast_binop().unwrap();\n                     let (lhs_span, rhs_span) = (lhs.span, rhs.span);\n                     let binary = self.mk_binary(codemap::respan(cur_op_span, ast_op), lhs, rhs);\n-                    self.mk_expr(lhs_span.lo, rhs_span.hi, binary)\n+                    self.mk_expr(lhs_span.lo, rhs_span.hi, binary, None)\n                 }\n                 AssocOp::Assign =>\n-                    self.mk_expr(lhs.span.lo, rhs.span.hi, ExprAssign(lhs, rhs)),\n+                    self.mk_expr(lhs.span.lo, rhs.span.hi, ExprAssign(lhs, rhs), None),\n                 AssocOp::Inplace =>\n-                    self.mk_expr(lhs.span.lo, rhs.span.hi, ExprInPlace(lhs, rhs)),\n+                    self.mk_expr(lhs.span.lo, rhs.span.hi, ExprInPlace(lhs, rhs), None),\n                 AssocOp::AssignOp(k) => {\n                     let aop = match k {\n                         token::Plus =>    BiAdd,\n@@ -2738,7 +2856,7 @@ impl<'a> Parser<'a> {\n                     };\n                     let (lhs_span, rhs_span) = (lhs.span, rhs.span);\n                     let aopexpr = self.mk_assign_op(codemap::respan(cur_op_span, aop), lhs, rhs);\n-                    self.mk_expr(lhs_span.lo, rhs_span.hi, aopexpr)\n+                    self.mk_expr(lhs_span.lo, rhs_span.hi, aopexpr, None)\n                 }\n                 AssocOp::As | AssocOp::DotDot => self.bug(\"As or DotDot branch reached\")\n             };\n@@ -2769,23 +2887,28 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse prefix-forms of range notation: `..expr` and `..`\n-    fn parse_prefix_range_expr(&mut self) -> PResult<P<Expr>> {\n+    fn parse_prefix_range_expr(&mut self,\n+                               already_parsed_attrs: Option<ThinAttributes>)\n+                               -> PResult<P<Expr>> {\n         debug_assert!(self.token == token::DotDot);\n+        let attrs = try!(self.parse_or_use_outer_attributes(already_parsed_attrs));\n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n         try!(self.bump());\n         let opt_end = if self.is_at_start_of_range_notation_rhs() {\n             // RHS must be parsed with more associativity than DotDot.\n             let next_prec = AssocOp::from_token(&token::DotDot).unwrap().precedence() + 1;\n-            Some(try!(self.parse_assoc_expr_with(next_prec, None).map(|x|{\n+            Some(try!(self.parse_assoc_expr_with(next_prec,\n+                                                 LhsExpr::NotYetParsed)\n+            .map(|x|{\n                 hi = x.span.hi;\n                 x\n             })))\n          } else {\n             None\n         };\n         let r = self.mk_range(None, opt_end);\n-        Ok(self.mk_expr(lo, hi, r))\n+        Ok(self.mk_expr(lo, hi, r, attrs))\n     }\n \n     fn is_at_start_of_range_notation_rhs(&self) -> bool {\n@@ -2801,12 +2924,12 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an 'if' or 'if let' expression ('if' token already eaten)\n-    pub fn parse_if_expr(&mut self) -> PResult<P<Expr>> {\n+    pub fn parse_if_expr(&mut self, attrs: ThinAttributes) -> PResult<P<Expr>> {\n         if self.check_keyword(keywords::Let) {\n-            return self.parse_if_let_expr();\n+            return self.parse_if_let_expr(attrs);\n         }\n         let lo = self.last_span.lo;\n-        let cond = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n+        let cond = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None));\n         let thn = try!(self.parse_block());\n         let mut els: Option<P<Expr>> = None;\n         let mut hi = thn.span.hi;\n@@ -2815,28 +2938,31 @@ impl<'a> Parser<'a> {\n             hi = elexpr.span.hi;\n             els = Some(elexpr);\n         }\n-        Ok(self.mk_expr(lo, hi, ExprIf(cond, thn, els)))\n+        Ok(self.mk_expr(lo, hi, ExprIf(cond, thn, els), attrs))\n     }\n \n     /// Parse an 'if let' expression ('if' token already eaten)\n-    pub fn parse_if_let_expr(&mut self) -> PResult<P<Expr>> {\n+    pub fn parse_if_let_expr(&mut self, attrs: ThinAttributes)\n+                             -> PResult<P<Expr>> {\n         let lo = self.last_span.lo;\n         try!(self.expect_keyword(keywords::Let));\n         let pat = try!(self.parse_pat());\n         try!(self.expect(&token::Eq));\n-        let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n+        let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None));\n         let thn = try!(self.parse_block());\n         let (hi, els) = if try!(self.eat_keyword(keywords::Else) ){\n             let expr = try!(self.parse_else_expr());\n             (expr.span.hi, Some(expr))\n         } else {\n             (thn.span.hi, None)\n         };\n-        Ok(self.mk_expr(lo, hi, ExprIfLet(pat, expr, thn, els)))\n+        Ok(self.mk_expr(lo, hi, ExprIfLet(pat, expr, thn, els), attrs))\n     }\n \n     // `|args| expr`\n-    pub fn parse_lambda_expr(&mut self, lo: BytePos, capture_clause: CaptureClause)\n+    pub fn parse_lambda_expr(&mut self, lo: BytePos,\n+                             capture_clause: CaptureClause,\n+                             attrs: ThinAttributes)\n                              -> PResult<P<Expr>>\n     {\n         let decl = try!(self.parse_fn_block_decl());\n@@ -2863,80 +2989,98 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_expr(\n             lo,\n             body.span.hi,\n-            ExprClosure(capture_clause, decl, body)))\n+            ExprClosure(capture_clause, decl, body), attrs))\n     }\n \n+    // `else` token already eaten\n     pub fn parse_else_expr(&mut self) -> PResult<P<Expr>> {\n         if try!(self.eat_keyword(keywords::If) ){\n-            return self.parse_if_expr();\n+            return self.parse_if_expr(None);\n         } else {\n             let blk = try!(self.parse_block());\n-            return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprBlock(blk)));\n+            return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprBlock(blk), None));\n         }\n     }\n \n     /// Parse a 'for' .. 'in' expression ('for' token already eaten)\n     pub fn parse_for_expr(&mut self, opt_ident: Option<ast::Ident>,\n-                          span_lo: BytePos) -> PResult<P<Expr>> {\n+                          span_lo: BytePos,\n+                          attrs: ThinAttributes) -> PResult<P<Expr>> {\n         // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n \n         let pat = try!(self.parse_pat());\n         try!(self.expect_keyword(keywords::In));\n-        let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n-        let loop_block = try!(self.parse_block());\n+        let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None));\n+        let (iattrs, loop_block) = try!(self.parse_inner_attrs_and_block());\n+        let attrs = attrs.append_inner(iattrs.into_opt_attrs());\n+\n         let hi = self.last_span.hi;\n \n-        Ok(self.mk_expr(span_lo, hi, ExprForLoop(pat, expr, loop_block, opt_ident)))\n+        Ok(self.mk_expr(span_lo, hi,\n+                        ExprForLoop(pat, expr, loop_block, opt_ident),\n+                        attrs))\n     }\n \n     /// Parse a 'while' or 'while let' expression ('while' token already eaten)\n     pub fn parse_while_expr(&mut self, opt_ident: Option<ast::Ident>,\n-                            span_lo: BytePos) -> PResult<P<Expr>> {\n+                            span_lo: BytePos,\n+                            attrs: ThinAttributes) -> PResult<P<Expr>> {\n         if self.token.is_keyword(keywords::Let) {\n-            return self.parse_while_let_expr(opt_ident, span_lo);\n+            return self.parse_while_let_expr(opt_ident, span_lo, attrs);\n         }\n-        let cond = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n-        let body = try!(self.parse_block());\n+        let cond = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None));\n+        let (iattrs, body) = try!(self.parse_inner_attrs_and_block());\n+        let attrs = attrs.append_inner(iattrs.into_opt_attrs());\n         let hi = body.span.hi;\n-        return Ok(self.mk_expr(span_lo, hi, ExprWhile(cond, body, opt_ident)));\n+        return Ok(self.mk_expr(span_lo, hi, ExprWhile(cond, body, opt_ident),\n+                               attrs));\n     }\n \n     /// Parse a 'while let' expression ('while' token already eaten)\n     pub fn parse_while_let_expr(&mut self, opt_ident: Option<ast::Ident>,\n-                                span_lo: BytePos) -> PResult<P<Expr>> {\n+                                span_lo: BytePos,\n+                                attrs: ThinAttributes) -> PResult<P<Expr>> {\n         try!(self.expect_keyword(keywords::Let));\n         let pat = try!(self.parse_pat());\n         try!(self.expect(&token::Eq));\n-        let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n-        let body = try!(self.parse_block());\n+        let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None));\n+        let (iattrs, body) = try!(self.parse_inner_attrs_and_block());\n+        let attrs = attrs.append_inner(iattrs.into_opt_attrs());\n         let hi = body.span.hi;\n-        return Ok(self.mk_expr(span_lo, hi, ExprWhileLet(pat, expr, body, opt_ident)));\n+        return Ok(self.mk_expr(span_lo, hi, ExprWhileLet(pat, expr, body, opt_ident), attrs));\n     }\n \n+    // parse `loop {...}`, `loop` token already eaten\n     pub fn parse_loop_expr(&mut self, opt_ident: Option<ast::Ident>,\n-                           span_lo: BytePos) -> PResult<P<Expr>> {\n-        let body = try!(self.parse_block());\n+                           span_lo: BytePos,\n+                           attrs: ThinAttributes) -> PResult<P<Expr>> {\n+        let (iattrs, body) = try!(self.parse_inner_attrs_and_block());\n+        let attrs = attrs.append_inner(iattrs.into_opt_attrs());\n         let hi = body.span.hi;\n-        Ok(self.mk_expr(span_lo, hi, ExprLoop(body, opt_ident)))\n+        Ok(self.mk_expr(span_lo, hi, ExprLoop(body, opt_ident), attrs))\n     }\n \n-    fn parse_match_expr(&mut self) -> PResult<P<Expr>> {\n+    // `match` token already eaten\n+    fn parse_match_expr(&mut self, attrs: ThinAttributes) -> PResult<P<Expr>> {\n         let match_span = self.last_span;\n         let lo = self.last_span.lo;\n-        let discriminant = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n+        let discriminant = try!(self.parse_expr_res(\n+            Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None));\n         if let Err(e) = self.commit_expr_expecting(&*discriminant, token::OpenDelim(token::Brace)) {\n             if self.token == token::Token::Semi {\n                 self.span_note(match_span, \"did you mean to remove this `match` keyword?\");\n             }\n             return Err(e)\n         }\n+        let attrs = attrs.append_inner(\n+            try!(self.parse_inner_attributes()).into_opt_attrs());\n         let mut arms: Vec<Arm> = Vec::new();\n         while self.token != token::CloseDelim(token::Brace) {\n             arms.push(try!(self.parse_arm()));\n         }\n         let hi = self.span.hi;\n         try!(self.bump());\n-        return Ok(self.mk_expr(lo, hi, ExprMatch(discriminant, arms)));\n+        return Ok(self.mk_expr(lo, hi, ExprMatch(discriminant, arms), attrs));\n     }\n \n     pub fn parse_arm(&mut self) -> PResult<Arm> {\n@@ -2949,7 +3093,7 @@ impl<'a> Parser<'a> {\n             guard = Some(try!(self.parse_expr()));\n         }\n         try!(self.expect(&token::FatArrow));\n-        let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_STMT_EXPR));\n+        let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_STMT_EXPR, None));\n \n         let require_comma =\n             !classify::expr_is_simple_block(&*expr)\n@@ -2971,7 +3115,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse an expression\n     pub fn parse_expr(&mut self) -> PResult<P<Expr>> {\n-        self.parse_expr_res(Restrictions::empty())\n+        self.parse_expr_res(Restrictions::empty(), None)\n     }\n \n     /// Evaluate the closure with restrictions in place.\n@@ -2988,8 +3132,10 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an expression, subject to the given restrictions\n-    pub fn parse_expr_res(&mut self, r: Restrictions) -> PResult<P<Expr>> {\n-        self.with_res(r, |this| this.parse_assoc_expr())\n+    pub fn parse_expr_res(&mut self, r: Restrictions,\n+                          already_parsed_attrs: Option<ThinAttributes>)\n+                          -> PResult<P<Expr>> {\n+        self.with_res(r, |this| this.parse_assoc_expr(already_parsed_attrs))\n     }\n \n     /// Parse the RHS of a local variable declaration (e.g. '= 14;')\n@@ -3173,9 +3319,9 @@ impl<'a> Parser<'a> {\n                 (None, try!(self.parse_path(LifetimeAndTypesWithColons)))\n             };\n             let hi = self.last_span.hi;\n-            Ok(self.mk_expr(lo, hi, ExprPath(qself, path)))\n+            Ok(self.mk_expr(lo, hi, ExprPath(qself, path), None))\n         } else {\n-            self.parse_literal_maybe_minus()\n+            self.parse_pat_literal_maybe_minus()\n         }\n     }\n \n@@ -3274,7 +3420,7 @@ impl<'a> Parser<'a> {\n                       token::DotDotDot => {\n                         // Parse range\n                         let hi = self.last_span.hi;\n-                        let begin = self.mk_expr(lo, hi, ExprPath(qself, path));\n+                        let begin = self.mk_expr(lo, hi, ExprPath(qself, path), None);\n                         try!(self.bump());\n                         let end = try!(self.parse_pat_range_end());\n                         pat = PatRange(begin, end);\n@@ -3321,7 +3467,7 @@ impl<'a> Parser<'a> {\n                 }\n             } else {\n                 // Try to parse everything else as literal with optional minus\n-                let begin = try!(self.parse_literal_maybe_minus());\n+                let begin = try!(self.parse_pat_literal_maybe_minus());\n                 if try!(self.eat(&token::DotDotDot)) {\n                     let end = try!(self.parse_pat_range_end());\n                     pat = PatRange(begin, end);\n@@ -3378,7 +3524,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a local variable declaration\n-    fn parse_local(&mut self) -> PResult<P<Local>> {\n+    fn parse_local(&mut self, attrs: ThinAttributes) -> PResult<P<Local>> {\n         let lo = self.span.lo;\n         let pat = try!(self.parse_pat());\n \n@@ -3393,13 +3539,14 @@ impl<'a> Parser<'a> {\n             init: init,\n             id: ast::DUMMY_NODE_ID,\n             span: mk_sp(lo, self.last_span.hi),\n+            attrs: attrs,\n         }))\n     }\n \n     /// Parse a \"let\" stmt\n-    fn parse_let(&mut self) -> PResult<P<Decl>> {\n+    fn parse_let(&mut self, attrs: ThinAttributes) -> PResult<P<Decl>> {\n         let lo = self.span.lo;\n-        let local = try!(self.parse_local());\n+        let local = try!(self.parse_local(attrs));\n         Ok(P(spanned(lo, self.last_span.hi, DeclLocal(local))))\n     }\n \n@@ -3444,28 +3591,20 @@ impl<'a> Parser<'a> {\n     fn parse_stmt_(&mut self) -> PResult<Option<Stmt>> {\n         maybe_whole!(Some deref self, NtStmt);\n \n-        fn check_expected_item(p: &mut Parser, attrs: &[Attribute]) {\n-            // If we have attributes then we should have an item\n-            if !attrs.is_empty() {\n-                p.expected_item_err(attrs);\n-            }\n-        }\n-\n         let attrs = try!(self.parse_outer_attributes());\n         let lo = self.span.lo;\n \n         Ok(Some(if self.check_keyword(keywords::Let) {\n-            check_expected_item(self, &attrs);\n             try!(self.expect_keyword(keywords::Let));\n-            let decl = try!(self.parse_let());\n-            spanned(lo, decl.span.hi, StmtDecl(decl, ast::DUMMY_NODE_ID))\n+            let decl = try!(self.parse_let(attrs.into_opt_attrs()));\n+            let hi = decl.span.hi;\n+            let stmt = StmtDecl(decl, ast::DUMMY_NODE_ID);\n+            spanned(lo, hi, stmt)\n         } else if self.token.is_ident()\n             && !self.token.is_any_keyword()\n             && self.look_ahead(1, |t| *t == token::Not) {\n             // it's a macro invocation:\n \n-            check_expected_item(self, &attrs);\n-\n             // Potential trouble: if we allow macros with paths instead of\n             // idents, we'd need to look ahead past the whole path here...\n             let pth = try!(self.parse_path(NoTypesAllowed));\n@@ -3511,11 +3650,12 @@ impl<'a> Parser<'a> {\n             };\n \n             if id.name == token::special_idents::invalid.name {\n-                spanned(lo, hi,\n-                        StmtMac(P(spanned(lo,\n-                                          hi,\n-                                          Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT })),\n-                                  style))\n+                let stmt = StmtMac(P(spanned(lo,\n+                                             hi,\n+                                             Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT })),\n+                                   style,\n+                                   attrs.into_opt_attrs());\n+                spanned(lo, hi, stmt)\n             } else {\n                 // if it has a special ident, it's definitely an item\n                 //\n@@ -3535,30 +3675,43 @@ impl<'a> Parser<'a> {\n                             lo, hi, id /*id is good here*/,\n                             ItemMac(spanned(lo, hi,\n                                             Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT })),\n-                            Inherited, Vec::new(/*no attrs*/))))),\n+                            Inherited, attrs)))),\n                     ast::DUMMY_NODE_ID))\n             }\n         } else {\n-            match try!(self.parse_item_(attrs, false)) {\n+            // FIXME: Bad copy of attrs\n+            match try!(self.parse_item_(attrs.clone(), false, true)) {\n                 Some(i) => {\n                     let hi = i.span.hi;\n                     let decl = P(spanned(lo, hi, DeclItem(i)));\n                     spanned(lo, hi, StmtDecl(decl, ast::DUMMY_NODE_ID))\n                 }\n                 None => {\n+                    let unused_attrs = |attrs: &[_], s: &mut Self| {\n+                        if attrs.len() > 0 {\n+                            s.span_err(s.span,\n+                                \"expected statement after outer attribute\");\n+                        }\n+                    };\n+\n                     // Do not attempt to parse an expression if we're done here.\n                     if self.token == token::Semi {\n+                        unused_attrs(&attrs, self);\n                         try!(self.bump());\n                         return Ok(None);\n                     }\n \n                     if self.token == token::CloseDelim(token::Brace) {\n+                        unused_attrs(&attrs, self);\n                         return Ok(None);\n                     }\n \n                     // Remainder are line-expr stmts.\n-                    let e = try!(self.parse_expr_res(Restrictions::RESTRICTION_STMT_EXPR));\n-                    spanned(lo, e.span.hi, StmtExpr(e, ast::DUMMY_NODE_ID))\n+                    let e = try!(self.parse_expr_res(\n+                        Restrictions::RESTRICTION_STMT_EXPR, Some(attrs.into_opt_attrs())));\n+                    let hi = e.span.hi;\n+                    let stmt = StmtExpr(e, ast::DUMMY_NODE_ID);\n+                    spanned(lo, hi, stmt)\n                 }\n             }\n         }))\n@@ -3614,22 +3767,23 @@ impl<'a> Parser<'a> {\n                 StmtExpr(e, _) => {\n                     try!(self.handle_expression_like_statement(e, span, &mut stmts, &mut expr));\n                 }\n-                StmtMac(mac, MacStmtWithoutBraces) => {\n+                StmtMac(mac, MacStmtWithoutBraces, attrs) => {\n                     // statement macro without braces; might be an\n                     // expr depending on whether a semicolon follows\n                     match self.token {\n                         token::Semi => {\n                             stmts.push(P(Spanned {\n-                                node: StmtMac(mac, MacStmtWithSemicolon),\n+                                node: StmtMac(mac, MacStmtWithSemicolon, attrs),\n                                 span: mk_sp(span.lo, self.span.hi),\n                             }));\n                             try!(self.bump());\n                         }\n                         _ => {\n                             let e = self.mk_mac_expr(span.lo, span.hi,\n-                                                     mac.and_then(|m| m.node));\n-                            let e = try!(self.parse_dot_or_call_expr_with(e));\n-                            let e = try!(self.parse_assoc_expr_with(0, Some(e)));\n+                                                     mac.and_then(|m| m.node),\n+                                                     None);\n+                            let e = try!(self.parse_dot_or_call_expr_with(e, attrs));\n+                            let e = try!(self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e)));\n                             try!(self.handle_expression_like_statement(\n                                 e,\n                                 span,\n@@ -3638,12 +3792,12 @@ impl<'a> Parser<'a> {\n                         }\n                     }\n                 }\n-                StmtMac(m, style) => {\n+                StmtMac(m, style, attrs) => {\n                     // statement macro; might be an expr\n                     match self.token {\n                         token::Semi => {\n                             stmts.push(P(Spanned {\n-                                node: StmtMac(m, MacStmtWithSemicolon),\n+                                node: StmtMac(m, MacStmtWithSemicolon, attrs),\n                                 span: mk_sp(span.lo, self.span.hi),\n                             }));\n                             try!(self.bump());\n@@ -3652,11 +3806,12 @@ impl<'a> Parser<'a> {\n                             // if a block ends in `m!(arg)` without\n                             // a `;`, it must be an expr\n                             expr = Some(self.mk_mac_expr(span.lo, span.hi,\n-                                                         m.and_then(|x| x.node)));\n+                                                         m.and_then(|x| x.node),\n+                                                         attrs));\n                         }\n                         _ => {\n                             stmts.push(P(Spanned {\n-                                node: StmtMac(m, style),\n+                                node: StmtMac(m, style, attrs),\n                                 span: span\n                             }));\n                         }\n@@ -5210,7 +5365,7 @@ impl<'a> Parser<'a> {\n     /// NB: this function no longer parses the items inside an\n     /// extern crate.\n     fn parse_item_(&mut self, attrs: Vec<Attribute>,\n-                   macros_allowed: bool) -> PResult<Option<P<Item>>> {\n+                   macros_allowed: bool, attributes_allowed: bool) -> PResult<Option<P<Item>>> {\n         let nt_item = match self.token {\n             token::Interpolated(token::NtItem(ref item)) => {\n                 Some((**item).clone())\n@@ -5468,7 +5623,7 @@ impl<'a> Parser<'a> {\n                                     maybe_append(attrs, extra_attrs));\n             return Ok(Some(item));\n         }\n-        self.parse_macro_use_or_failure(attrs,macros_allowed,lo,visibility)\n+        self.parse_macro_use_or_failure(attrs,macros_allowed,attributes_allowed,lo,visibility)\n     }\n \n     /// Parse a foreign item.\n@@ -5487,7 +5642,7 @@ impl<'a> Parser<'a> {\n         }\n \n         // FIXME #5668: this will occur for a macro invocation:\n-        match try!(self.parse_macro_use_or_failure(attrs, true, lo, visibility)) {\n+        match try!(self.parse_macro_use_or_failure(attrs, true, false, lo, visibility)) {\n             Some(item) => {\n                 return Err(self.span_fatal(item.span, \"macros cannot expand to foreign items\"));\n             }\n@@ -5500,6 +5655,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         attrs: Vec<Attribute> ,\n         macros_allowed: bool,\n+        attributes_allowed: bool,\n         lo: BytePos,\n         visibility: Visibility\n     ) -> PResult<Option<P<Item>>> {\n@@ -5566,15 +5722,15 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        if !attrs.is_empty() {\n+        if !attributes_allowed && !attrs.is_empty() {\n             self.expected_item_err(&attrs);\n         }\n         Ok(None)\n     }\n \n     pub fn parse_item(&mut self) -> PResult<Option<P<Item>>> {\n         let attrs = try!(self.parse_outer_attributes());\n-        self.parse_item_(attrs, true)\n+        self.parse_item_(attrs, true, false)\n     }\n \n "}, {"sha": "17b7d8dbaece9588d1dbcf846a0ac32391381619", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -202,6 +202,7 @@ impl Token {\n             Interpolated(NtIdent(..))   => true,\n             Interpolated(NtBlock(..))   => true,\n             Interpolated(NtPath(..))    => true,\n+            Pound                       => true, // for expression attributes\n             _                           => false,\n         }\n     }"}, {"sha": "6919bc4efdd8f3131048cd1bfc568dd67894e3e4", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 145, "deletions": 84, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -13,6 +13,7 @@ pub use self::AnnNode::*;\n use abi;\n use ast::{self, TokenTree};\n use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n+use ast::{ThinAttributesExt, Attribute};\n use ast_util;\n use util::parser::AssocOp;\n use attr;\n@@ -77,7 +78,7 @@ pub fn rust_printer<'a>(writer: Box<Write+'a>) -> State<'a> {\n pub fn rust_printer_annotated<'a>(writer: Box<Write+'a>,\n                                   ann: &'a PpAnn) -> State<'a> {\n     State {\n-        s: pp::mk_printer(writer, default_columns),\n+        s: pp::mk_printer(writer, DEFAULT_COLUMNS),\n         cm: None,\n         comments: None,\n         literals: None,\n@@ -90,11 +91,9 @@ pub fn rust_printer_annotated<'a>(writer: Box<Write+'a>,\n     }\n }\n \n-#[allow(non_upper_case_globals)]\n-pub const indent_unit: usize = 4;\n+pub const INDENT_UNIT: usize = 4;\n \n-#[allow(non_upper_case_globals)]\n-pub const default_columns: usize = 78;\n+pub const DEFAULT_COLUMNS: usize = 78;\n \n /// Requires you to pass an input filename and reader so that\n /// it can scan the input text for comments and literals to\n@@ -170,7 +169,7 @@ impl<'a> State<'a> {\n                comments: Option<Vec<comments::Comment>>,\n                literals: Option<Vec<comments::Literal>>) -> State<'a> {\n         State {\n-            s: pp::mk_printer(out, default_columns),\n+            s: pp::mk_printer(out, DEFAULT_COLUMNS),\n             cm: Some(cm),\n             comments: comments,\n             literals: literals,\n@@ -401,7 +400,7 @@ pub fn fun_to_string(decl: &ast::FnDecl,\n pub fn block_to_string(blk: &ast::Block) -> String {\n     to_string(|s| {\n         // containing cbox, will be closed by print-block at }\n-        try!(s.cbox(indent_unit));\n+        try!(s.cbox(INDENT_UNIT));\n         // head-ibox, will be closed by print-block after {\n         try!(s.ibox(0));\n         s.print_block(blk)\n@@ -707,43 +706,61 @@ pub trait PrintState<'a> {\n     }\n \n     fn print_inner_attributes(&mut self,\n-                                  attrs: &[ast::Attribute]) -> io::Result<()> {\n-        let mut count = 0;\n-        for attr in attrs {\n-            match attr.node.style {\n-                ast::AttrStyle::Inner => {\n-                    try!(self.print_attribute(attr));\n-                    count += 1;\n-                }\n-                _ => {/* fallthrough */ }\n-            }\n-        }\n-        if count > 0 {\n-            try!(self.hardbreak_if_not_bol());\n-        }\n-        Ok(())\n+                              attrs: &[ast::Attribute]) -> io::Result<()> {\n+        self.print_either_attributes(attrs, ast::AttrStyle::Inner, false, true)\n+    }\n+\n+    fn print_inner_attributes_no_trailing_hardbreak(&mut self,\n+                                                   attrs: &[ast::Attribute])\n+                                                   -> io::Result<()> {\n+        self.print_either_attributes(attrs, ast::AttrStyle::Inner, false, false)\n     }\n \n     fn print_outer_attributes(&mut self,\n                               attrs: &[ast::Attribute]) -> io::Result<()> {\n+        self.print_either_attributes(attrs, ast::AttrStyle::Outer, false, true)\n+    }\n+\n+    fn print_inner_attributes_inline(&mut self,\n+                                     attrs: &[ast::Attribute]) -> io::Result<()> {\n+        self.print_either_attributes(attrs, ast::AttrStyle::Inner, true, true)\n+    }\n+\n+    fn print_outer_attributes_inline(&mut self,\n+                                     attrs: &[ast::Attribute]) -> io::Result<()> {\n+        self.print_either_attributes(attrs, ast::AttrStyle::Outer, true, true)\n+    }\n+\n+    fn print_either_attributes(&mut self,\n+                              attrs: &[ast::Attribute],\n+                              kind: ast::AttrStyle,\n+                              is_inline: bool,\n+                              trailing_hardbreak: bool) -> io::Result<()> {\n         let mut count = 0;\n         for attr in attrs {\n-            match attr.node.style {\n-                ast::AttrStyle::Outer => {\n-                    try!(self.print_attribute(attr));\n+            if attr.node.style == kind {\n+                    try!(self.print_attribute_inline(attr, is_inline));\n+                    if is_inline {\n+                        try!(self.nbsp());\n+                    }\n                     count += 1;\n-                }\n-                _ => {/* fallthrough */ }\n             }\n         }\n-        if count > 0 {\n+        if count > 0 && trailing_hardbreak && !is_inline {\n             try!(self.hardbreak_if_not_bol());\n         }\n         Ok(())\n     }\n \n     fn print_attribute(&mut self, attr: &ast::Attribute) -> io::Result<()> {\n-        try!(self.hardbreak_if_not_bol());\n+        self.print_attribute_inline(attr, false)\n+    }\n+\n+    fn print_attribute_inline(&mut self, attr: &ast::Attribute,\n+                              is_inline: bool) -> io::Result<()> {\n+        if !is_inline {\n+            try!(self.hardbreak_if_not_bol());\n+        }\n         try!(self.maybe_print_comment(attr.span.lo));\n         if attr.node.is_sugared_doc {\n             word(self.writer(), &attr.value_str().unwrap())\n@@ -758,7 +775,7 @@ pub trait PrintState<'a> {\n     }\n \n     fn print_meta_item(&mut self, item: &ast::MetaItem) -> io::Result<()> {\n-        try!(self.ibox(indent_unit));\n+        try!(self.ibox(INDENT_UNIT));\n         match item.node {\n             ast::MetaWord(ref name) => {\n                 try!(word(self.writer(), &name));\n@@ -779,6 +796,13 @@ pub trait PrintState<'a> {\n         }\n         self.end()\n     }\n+\n+    fn space_if_not_bol(&mut self) -> io::Result<()> {\n+        if !self.is_bol() { try!(space(self.writer())); }\n+        Ok(())\n+    }\n+\n+    fn nbsp(&mut self) -> io::Result<()> { word(self.writer(), \" \") }\n }\n \n impl<'a> PrintState<'a> for State<'a> {\n@@ -809,16 +833,14 @@ impl<'a> State<'a> {\n         pp::cbox(&mut self.s, u)\n     }\n \n-    pub fn nbsp(&mut self) -> io::Result<()> { word(&mut self.s, \" \") }\n-\n     pub fn word_nbsp(&mut self, w: &str) -> io::Result<()> {\n         try!(word(&mut self.s, w));\n         self.nbsp()\n     }\n \n     pub fn head(&mut self, w: &str) -> io::Result<()> {\n         // outer-box is consistent\n-        try!(self.cbox(indent_unit));\n+        try!(self.cbox(INDENT_UNIT));\n         // head-box is inconsistent\n         try!(self.ibox(w.len() + 1));\n         // keyword that starts the head\n@@ -848,7 +870,7 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n     pub fn bclose(&mut self, span: codemap::Span) -> io::Result<()> {\n-        self.bclose_(span, indent_unit)\n+        self.bclose_(span, INDENT_UNIT)\n     }\n \n     pub fn in_cbox(&self) -> bool {\n@@ -858,10 +880,6 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn space_if_not_bol(&mut self) -> io::Result<()> {\n-        if !self.is_bol() { try!(space(&mut self.s)); }\n-        Ok(())\n-    }\n     pub fn break_offset_if_not_bol(&mut self, n: usize,\n                                    off: isize) -> io::Result<()> {\n         if !self.is_bol() {\n@@ -1200,7 +1218,7 @@ impl<'a> State<'a> {\n                 try!(self.bclose(item.span));\n             }\n             ast::ItemTy(ref ty, ref params) => {\n-                try!(self.ibox(indent_unit));\n+                try!(self.ibox(INDENT_UNIT));\n                 try!(self.ibox(0));\n                 try!(self.word_nbsp(&visibility_qualified(item.vis, \"type\")));\n                 try!(self.print_ident(item.ident));\n@@ -1314,7 +1332,7 @@ impl<'a> State<'a> {\n                 try!(self.print_path(&node.path, false, 0));\n                 try!(word(&mut self.s, \"! \"));\n                 try!(self.print_ident(item.ident));\n-                try!(self.cbox(indent_unit));\n+                try!(self.cbox(INDENT_UNIT));\n                 try!(self.popen());\n                 try!(self.print_tts(&node.tts[..]));\n                 try!(self.pclose());\n@@ -1370,7 +1388,7 @@ impl<'a> State<'a> {\n             try!(self.space_if_not_bol());\n             try!(self.maybe_print_comment(v.span.lo));\n             try!(self.print_outer_attributes(&v.node.attrs));\n-            try!(self.ibox(indent_unit));\n+            try!(self.ibox(INDENT_UNIT));\n             try!(self.print_variant(&**v));\n             try!(word(&mut self.s, \",\"));\n             try!(self.end());\n@@ -1592,7 +1610,7 @@ impl<'a> State<'a> {\n                 // code copied from ItemMac:\n                 try!(self.print_path(&node.path, false, 0));\n                 try!(word(&mut self.s, \"! \"));\n-                try!(self.cbox(indent_unit));\n+                try!(self.cbox(INDENT_UNIT));\n                 try!(self.popen());\n                 try!(self.print_tts(&node.tts[..]));\n                 try!(self.pclose());\n@@ -1611,15 +1629,16 @@ impl<'a> State<'a> {\n             }\n             ast::StmtExpr(ref expr, _) => {\n                 try!(self.space_if_not_bol());\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr_outer_attr_style(&**expr, false));\n             }\n             ast::StmtSemi(ref expr, _) => {\n                 try!(self.space_if_not_bol());\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr_outer_attr_style(&**expr, false));\n                 try!(word(&mut self.s, \";\"));\n             }\n-            ast::StmtMac(ref mac, style) => {\n+            ast::StmtMac(ref mac, style, ref attrs) => {\n                 try!(self.space_if_not_bol());\n+                try!(self.print_outer_attributes(attrs.as_attrs()));\n                 let delim = match style {\n                     ast::MacStmtWithBraces => token::Brace,\n                     _ => token::Paren\n@@ -1633,6 +1652,8 @@ impl<'a> State<'a> {\n         }\n         if parse::classify::stmt_ends_with_semi(&st.node) {\n             try!(word(&mut self.s, \";\"));\n+        } else {\n+            //try!(word(&mut self.s, \"\"));\n         }\n         self.maybe_print_trailing_comment(st.span, None)\n     }\n@@ -1642,7 +1663,13 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_block_unclosed(&mut self, blk: &ast::Block) -> io::Result<()> {\n-        self.print_block_unclosed_indent(blk, indent_unit)\n+        self.print_block_unclosed_indent(blk, INDENT_UNIT)\n+    }\n+\n+    pub fn print_block_unclosed_with_attrs(&mut self, blk: &ast::Block,\n+                                            attrs: &[ast::Attribute])\n+                                           -> io::Result<()> {\n+        self.print_block_maybe_unclosed(blk, INDENT_UNIT, attrs, false)\n     }\n \n     pub fn print_block_unclosed_indent(&mut self, blk: &ast::Block,\n@@ -1653,7 +1680,7 @@ impl<'a> State<'a> {\n     pub fn print_block_with_attrs(&mut self,\n                                   blk: &ast::Block,\n                                   attrs: &[ast::Attribute]) -> io::Result<()> {\n-        self.print_block_maybe_unclosed(blk, indent_unit, attrs, true)\n+        self.print_block_maybe_unclosed(blk, INDENT_UNIT, attrs, true)\n     }\n \n     pub fn print_block_maybe_unclosed(&mut self,\n@@ -1677,7 +1704,7 @@ impl<'a> State<'a> {\n         match blk.expr {\n             Some(ref expr) => {\n                 try!(self.space_if_not_bol());\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr_outer_attr_style(&**expr, false));\n                 try!(self.maybe_print_trailing_comment(expr.span, Some(blk.span.hi)));\n             }\n             _ => ()\n@@ -1692,7 +1719,7 @@ impl<'a> State<'a> {\n                 match _else.node {\n                     // \"another else-if\"\n                     ast::ExprIf(ref i, ref then, ref e) => {\n-                        try!(self.cbox(indent_unit - 1));\n+                        try!(self.cbox(INDENT_UNIT - 1));\n                         try!(self.ibox(0));\n                         try!(word(&mut self.s, \" else if \"));\n                         try!(self.print_expr(&**i));\n@@ -1702,7 +1729,7 @@ impl<'a> State<'a> {\n                     }\n                     // \"another else-if-let\"\n                     ast::ExprIfLet(ref pat, ref expr, ref then, ref e) => {\n-                        try!(self.cbox(indent_unit - 1));\n+                        try!(self.cbox(INDENT_UNIT - 1));\n                         try!(self.ibox(0));\n                         try!(word(&mut self.s, \" else if let \"));\n                         try!(self.print_pat(&**pat));\n@@ -1715,7 +1742,7 @@ impl<'a> State<'a> {\n                     }\n                     // \"final else\"\n                     ast::ExprBlock(ref b) => {\n-                        try!(self.cbox(indent_unit - 1));\n+                        try!(self.cbox(INDENT_UNIT - 1));\n                         try!(self.ibox(0));\n                         try!(word(&mut self.s, \" else \"));\n                         self.print_block(&**b)\n@@ -1758,7 +1785,13 @@ impl<'a> State<'a> {\n         match delim {\n             token::Paren => try!(self.popen()),\n             token::Bracket => try!(word(&mut self.s, \"[\")),\n-            token::Brace => try!(self.bopen()),\n+            token::Brace => {\n+                // head-ibox, will be closed by bopen()\n+                try!(self.ibox(0));\n+                // Don't ask me why the regular bopen() does\n+                // more then just opening a brace...\n+                try!(self.bopen())\n+            }\n         }\n         try!(self.print_tts(&m.node.tts));\n         match delim {\n@@ -1811,19 +1844,23 @@ impl<'a> State<'a> {\n         self.print_expr_maybe_paren(expr)\n     }\n \n-    fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>]) -> io::Result<()> {\n-        try!(self.ibox(indent_unit));\n+    fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>],\n+                      attrs: &[Attribute]) -> io::Result<()> {\n+        try!(self.ibox(INDENT_UNIT));\n         try!(word(&mut self.s, \"[\"));\n+        try!(self.print_inner_attributes_inline(attrs));\n         try!(self.commasep_exprs(Inconsistent, &exprs[..]));\n         try!(word(&mut self.s, \"]\"));\n         self.end()\n     }\n \n     fn print_expr_repeat(&mut self,\n                          element: &ast::Expr,\n-                         count: &ast::Expr) -> io::Result<()> {\n-        try!(self.ibox(indent_unit));\n+                         count: &ast::Expr,\n+                         attrs: &[Attribute]) -> io::Result<()> {\n+        try!(self.ibox(INDENT_UNIT));\n         try!(word(&mut self.s, \"[\"));\n+        try!(self.print_inner_attributes_inline(attrs));\n         try!(self.print_expr(element));\n         try!(self.word_space(\";\"));\n         try!(self.print_expr(count));\n@@ -1834,14 +1871,16 @@ impl<'a> State<'a> {\n     fn print_expr_struct(&mut self,\n                          path: &ast::Path,\n                          fields: &[ast::Field],\n-                         wth: &Option<P<ast::Expr>>) -> io::Result<()> {\n+                         wth: &Option<P<ast::Expr>>,\n+                         attrs: &[Attribute]) -> io::Result<()> {\n         try!(self.print_path(path, true, 0));\n         try!(word(&mut self.s, \"{\"));\n+        try!(self.print_inner_attributes_inline(attrs));\n         try!(self.commasep_cmnt(\n             Consistent,\n             &fields[..],\n             |s, field| {\n-                try!(s.ibox(indent_unit));\n+                try!(s.ibox(INDENT_UNIT));\n                 try!(s.print_ident(field.ident.node));\n                 try!(s.word_space(\":\"));\n                 try!(s.print_expr(&*field.expr));\n@@ -1850,7 +1889,7 @@ impl<'a> State<'a> {\n             |f| f.span));\n         match *wth {\n             Some(ref expr) => {\n-                try!(self.ibox(indent_unit));\n+                try!(self.ibox(INDENT_UNIT));\n                 if !fields.is_empty() {\n                     try!(word(&mut self.s, \",\"));\n                     try!(space(&mut self.s));\n@@ -1867,8 +1906,10 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    fn print_expr_tup(&mut self, exprs: &[P<ast::Expr>]) -> io::Result<()> {\n+    fn print_expr_tup(&mut self, exprs: &[P<ast::Expr>],\n+                      attrs: &[Attribute]) -> io::Result<()> {\n         try!(self.popen());\n+        try!(self.print_inner_attributes_inline(attrs));\n         try!(self.commasep_exprs(Inconsistent, &exprs[..]));\n         if exprs.len() == 1 {\n             try!(word(&mut self.s, \",\"));\n@@ -1934,8 +1975,22 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_expr(&mut self, expr: &ast::Expr) -> io::Result<()> {\n+        self.print_expr_outer_attr_style(expr, true)\n+    }\n+\n+    fn print_expr_outer_attr_style(&mut self,\n+                                  expr: &ast::Expr,\n+                                  is_inline: bool) -> io::Result<()> {\n         try!(self.maybe_print_comment(expr.span.lo));\n-        try!(self.ibox(indent_unit));\n+\n+        let attrs = expr.attrs.as_attrs();\n+        if is_inline {\n+            try!(self.print_outer_attributes_inline(attrs));\n+        } else {\n+            try!(self.print_outer_attributes(attrs));\n+        }\n+\n+        try!(self.ibox(INDENT_UNIT));\n         try!(self.ann.pre(self, NodeExpr(expr)));\n         match expr.node {\n             ast::ExprBox(ref expr) => {\n@@ -1946,16 +2001,16 @@ impl<'a> State<'a> {\n                 try!(self.print_expr_in_place(place, expr));\n             }\n             ast::ExprVec(ref exprs) => {\n-                try!(self.print_expr_vec(&exprs[..]));\n+                try!(self.print_expr_vec(&exprs[..], attrs));\n             }\n             ast::ExprRepeat(ref element, ref count) => {\n-                try!(self.print_expr_repeat(&**element, &**count));\n+                try!(self.print_expr_repeat(&**element, &**count, attrs));\n             }\n             ast::ExprStruct(ref path, ref fields, ref wth) => {\n-                try!(self.print_expr_struct(path, &fields[..], wth));\n+                try!(self.print_expr_struct(path, &fields[..], wth, attrs));\n             }\n             ast::ExprTup(ref exprs) => {\n-                try!(self.print_expr_tup(&exprs[..]));\n+                try!(self.print_expr_tup(&exprs[..], attrs));\n             }\n             ast::ExprCall(ref func, ref args) => {\n                 try!(self.print_expr_call(&**func, &args[..]));\n@@ -1999,7 +2054,7 @@ impl<'a> State<'a> {\n                 try!(self.head(\"while\"));\n                 try!(self.print_expr(&**test));\n                 try!(space(&mut self.s));\n-                try!(self.print_block(&**blk));\n+                try!(self.print_block_with_attrs(&**blk, attrs));\n             }\n             ast::ExprWhileLet(ref pat, ref expr, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n@@ -2012,7 +2067,7 @@ impl<'a> State<'a> {\n                 try!(self.word_space(\"=\"));\n                 try!(self.print_expr(&**expr));\n                 try!(space(&mut self.s));\n-                try!(self.print_block(&**blk));\n+                try!(self.print_block_with_attrs(&**blk, attrs));\n             }\n             ast::ExprForLoop(ref pat, ref iter, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n@@ -2025,7 +2080,7 @@ impl<'a> State<'a> {\n                 try!(self.word_space(\"in\"));\n                 try!(self.print_expr(&**iter));\n                 try!(space(&mut self.s));\n-                try!(self.print_block(&**blk));\n+                try!(self.print_block_with_attrs(&**blk, attrs));\n             }\n             ast::ExprLoop(ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n@@ -2034,19 +2089,20 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.head(\"loop\"));\n                 try!(space(&mut self.s));\n-                try!(self.print_block(&**blk));\n+                try!(self.print_block_with_attrs(&**blk, attrs));\n             }\n             ast::ExprMatch(ref expr, ref arms) => {\n-                try!(self.cbox(indent_unit));\n+                try!(self.cbox(INDENT_UNIT));\n                 try!(self.ibox(4));\n                 try!(self.word_nbsp(\"match\"));\n                 try!(self.print_expr(&**expr));\n                 try!(space(&mut self.s));\n                 try!(self.bopen());\n+                try!(self.print_inner_attributes_no_trailing_hardbreak(attrs));\n                 for arm in arms {\n                     try!(self.print_arm(arm));\n                 }\n-                try!(self.bclose_(expr.span, indent_unit));\n+                try!(self.bclose_(expr.span, INDENT_UNIT));\n             }\n             ast::ExprClosure(capture_clause, ref decl, ref body) => {\n                 try!(self.print_capture_clause(capture_clause));\n@@ -2063,13 +2119,16 @@ impl<'a> State<'a> {\n                     try!(self.print_block_unclosed(&**body));\n                 } else {\n                     // we extract the block, so as not to create another set of boxes\n-                    match body.expr.as_ref().unwrap().node {\n+                    let i_expr = body.expr.as_ref().unwrap();\n+                    match i_expr.node {\n                         ast::ExprBlock(ref blk) => {\n-                            try!(self.print_block_unclosed(&**blk));\n+                            try!(self.print_block_unclosed_with_attrs(\n+                                &**blk,\n+                                i_expr.attrs.as_attrs()));\n                         }\n                         _ => {\n                             // this is a bare expression\n-                            try!(self.print_expr(body.expr.as_ref().map(|e| &**e).unwrap()));\n+                            try!(self.print_expr(&**i_expr));\n                             try!(self.end()); // need to close a box\n                         }\n                     }\n@@ -2081,10 +2140,10 @@ impl<'a> State<'a> {\n             }\n             ast::ExprBlock(ref blk) => {\n                 // containing cbox, will be closed by print-block at }\n-                try!(self.cbox(indent_unit));\n+                try!(self.cbox(INDENT_UNIT));\n                 // head-box, will be closed by print-block after {\n                 try!(self.ibox(0));\n-                try!(self.print_block(&**blk));\n+                try!(self.print_block_with_attrs(&**blk, attrs));\n             }\n             ast::ExprAssign(ref lhs, ref rhs) => {\n                 try!(self.print_expr(&**lhs));\n@@ -2222,6 +2281,7 @@ impl<'a> State<'a> {\n             ast::ExprMac(ref m) => try!(self.print_mac(m, token::Paren)),\n             ast::ExprParen(ref e) => {\n                 try!(self.popen());\n+                try!(self.print_inner_attributes_inline(attrs));\n                 try!(self.print_expr(&**e));\n                 try!(self.pclose());\n             }\n@@ -2243,11 +2303,12 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(decl.span.lo));\n         match decl.node {\n             ast::DeclLocal(ref loc) => {\n+                try!(self.print_outer_attributes(loc.attrs.as_attrs()));\n                 try!(self.space_if_not_bol());\n-                try!(self.ibox(indent_unit));\n+                try!(self.ibox(INDENT_UNIT));\n                 try!(self.word_nbsp(\"let\"));\n \n-                try!(self.ibox(indent_unit));\n+                try!(self.ibox(INDENT_UNIT));\n                 try!(self.print_local_decl(&**loc));\n                 try!(self.end());\n                 if let Some(ref init) = loc.init {\n@@ -2452,7 +2513,7 @@ impl<'a> State<'a> {\n                 try!(self.commasep_cmnt(\n                     Consistent, &fields[..],\n                     |s, f| {\n-                        try!(s.cbox(indent_unit));\n+                        try!(s.cbox(INDENT_UNIT));\n                         if !f.node.is_shorthand {\n                             try!(s.print_ident(f.node.ident));\n                             try!(s.word_nbsp(\":\"));\n@@ -2525,7 +2586,7 @@ impl<'a> State<'a> {\n         if arm.attrs.is_empty() {\n             try!(space(&mut self.s));\n         }\n-        try!(self.cbox(indent_unit));\n+        try!(self.cbox(INDENT_UNIT));\n         try!(self.ibox(0));\n         try!(self.print_outer_attributes(&arm.attrs));\n         let mut first = true;\n@@ -2549,7 +2610,7 @@ impl<'a> State<'a> {\n         match arm.body.node {\n             ast::ExprBlock(ref blk) => {\n                 // the block will close the pattern's ibox\n-                try!(self.print_block_unclosed_indent(&**blk, indent_unit));\n+                try!(self.print_block_unclosed_indent(&**blk, INDENT_UNIT));\n \n                 // If it is a user-provided unsafe block, print a comma after it\n                 if let ast::UnsafeBlock(ast::UserProvided) = blk.rules {\n@@ -2907,7 +2968,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_arg(&mut self, input: &ast::Arg) -> io::Result<()> {\n-        try!(self.ibox(indent_unit));\n+        try!(self.ibox(INDENT_UNIT));\n         match input.ty.node {\n             ast::TyInfer => try!(self.print_pat(&*input.pat)),\n             _ => {\n@@ -2935,7 +2996,7 @@ impl<'a> State<'a> {\n         }\n \n         try!(self.space_if_not_bol());\n-        try!(self.ibox(indent_unit));\n+        try!(self.ibox(INDENT_UNIT));\n         try!(self.word_space(\"->\"));\n         match decl.output {\n             ast::NoReturn(_) =>\n@@ -2960,7 +3021,7 @@ impl<'a> State<'a> {\n                        generics: &ast::Generics,\n                        opt_explicit_self: Option<&ast::ExplicitSelf_>)\n                        -> io::Result<()> {\n-        try!(self.ibox(indent_unit));\n+        try!(self.ibox(INDENT_UNIT));\n         if !generics.lifetimes.is_empty() || !generics.ty_params.is_empty() {\n             try!(word(&mut self.s, \"for\"));\n             try!(self.print_generics(generics));"}, {"sha": "aab106b7a6702df8daec46cb1b32c25743c88355", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -88,7 +88,7 @@ pub fn modify_for_testing(sess: &ParseSess,\n     if should_test {\n         generate_test_harness(sess, reexport_test_harness_main, krate, cfg, span_diagnostic)\n     } else {\n-        strip_test_functions(krate)\n+        strip_test_functions(span_diagnostic, krate)\n     }\n }\n \n@@ -314,10 +314,11 @@ fn generate_test_harness(sess: &ParseSess,\n     return res;\n }\n \n-fn strip_test_functions(krate: ast::Crate) -> ast::Crate {\n+fn strip_test_functions(diagnostic: &diagnostic::SpanHandler, krate: ast::Crate)\n+                        -> ast::Crate {\n     // When not compiling with --test we should not compile the\n     // #[test] functions\n-    config::strip_items(krate, |attrs| {\n+    config::strip_items(diagnostic, krate, |attrs| {\n         !attr::contains_name(&attrs[..], \"test\") &&\n         !attr::contains_name(&attrs[..], \"bench\")\n     })\n@@ -619,8 +620,10 @@ fn mk_test_descs(cx: &TestCtxt) -> P<ast::Expr> {\n                     mk_test_desc_and_fn_rec(cx, test)\n                 }).collect()),\n                 span: DUMMY_SP,\n+                attrs: None,\n             })),\n         span: DUMMY_SP,\n+        attrs: None,\n     })\n }\n "}, {"sha": "2d97e2680d7fb4abfedb6800581278b3ef072a41", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -628,7 +628,12 @@ pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n         StmtExpr(ref expression, _) | StmtSemi(ref expression, _) => {\n             visitor.visit_expr(expression)\n         }\n-        StmtMac(ref mac, _) => visitor.visit_mac(mac),\n+        StmtMac(ref mac, _, ref attrs) => {\n+            visitor.visit_mac(mac);\n+            for attr in attrs.as_attrs() {\n+                visitor.visit_attribute(attr);\n+            }\n+        }\n     }\n }\n "}, {"sha": "e15350fcad79c9d23230a56a15cf7d18fb7adea7", "filename": "src/test/parse-fail/attr-before-ext.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fparse-fail%2Fattr-before-ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fparse-fail%2Fattr-before-ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fattr-before-ext.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z parse-only\n-\n-fn main() {\n-    #[attr] //~ ERROR expected item after attributes\n-    println!(\"hi\");\n-}"}, {"sha": "03dabb980f20d923c3a22c49c3ab84d9d160d785", "filename": "src/test/parse-fail/attr-before-let.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fparse-fail%2Fattr-before-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fparse-fail%2Fattr-before-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fattr-before-let.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z parse-only\n-\n-fn main() {\n-    #[attr] //~ ERROR expected item\n-    let __isize = 0;\n-}"}, {"sha": "bc306048cdc4a3e6760e09adab210554ff33faad", "filename": "src/test/parse-fail/attr-before-stmt.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fparse-fail%2Fattr-before-stmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fparse-fail%2Fattr-before-stmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fattr-before-stmt.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z parse-only\n-\n-// error-pattern:expected item\n-\n-fn f() {\n-  #[foo = \"bar\"]\n-  let x = 10;\n-}\n-\n-fn main() {\n-}"}, {"sha": "7b731b6d6de609632241c3aebeb5b62d1253a0f1", "filename": "src/test/parse-fail/attr-dangling-in-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Ftest%2Fparse-fail%2Fattr-dangling-in-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Ftest%2Fparse-fail%2Fattr-dangling-in-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fattr-dangling-in-fn.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -10,7 +10,7 @@\n \n // compile-flags: -Z parse-only\n \n-// error-pattern:expected item\n+// error-pattern:expected statement\n \n fn f() {\n   #[foo = \"bar\"]"}, {"sha": "44435bde03c0d39fe998f692e09e09a00373f98d", "filename": "src/test/parse-fail/doc-before-macro.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fparse-fail%2Fdoc-before-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ef02eff89e3d2a29eab3346bff393821df6e033/src%2Ftest%2Fparse-fail%2Fdoc-before-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fdoc-before-macro.rs?ref=6ef02eff89e3d2a29eab3346bff393821df6e033", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z parse-only\n-\n-fn main() {\n-    /// hi\n-    println!(\"hi\");\n-    //~^^ ERROR expected item after doc comment\n-}"}, {"sha": "295d5ae432ecb3f48f1c3a1216c115582919daaf", "filename": "src/test/parse-fail/doc-before-rbrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Ftest%2Fparse-fail%2Fdoc-before-rbrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Ftest%2Fparse-fail%2Fdoc-before-rbrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fdoc-before-rbrace.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -12,5 +12,5 @@\n \n fn main() {\n     println!(\"Hi\"); /// hi\n-    //~^ ERROR expected item after doc comment\n }\n+//~^ ERROR expected statement"}, {"sha": "6a8906953be091ade684055cd72cf09527813445", "filename": "src/test/parse-fail/doc-before-semi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Ftest%2Fparse-fail%2Fdoc-before-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Ftest%2Fparse-fail%2Fdoc-before-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fdoc-before-semi.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -13,5 +13,5 @@\n fn main() {\n     /// hi\n     ;\n-    //~^^ ERROR expected item after doc comment\n+    //~^ ERROR expected statement\n }"}, {"sha": "48c2a0470e14eb709b331da9efaf9641a8f8a757", "filename": "src/test/pretty/stmt_expr_attributes.rs", "status": "added", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -0,0 +1,281 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// pp-exact\n+\n+#![feature(custom_attribute)]\n+#![feature(box_syntax)]\n+#![feature(placement_in_syntax)]\n+\n+fn main() { }\n+\n+fn _0() {\n+\n+    #[attr]\n+    foo();\n+}\n+\n+fn _1() {\n+\n+    #[attr]\n+    unsafe {\n+        // code\n+    }\n+}\n+\n+fn _2() {\n+\n+    #[attr]\n+    { foo(); }\n+\n+    {\n+        #![attr]\n+\n+        foo()\n+    }\n+}\n+\n+fn _3() {\n+\n+    #[attr]\n+    match () { _ => { } }\n+}\n+\n+fn _4() {\n+\n+    #[attr]\n+    match () {\n+        #![attr]\n+        _ => (),\n+    }\n+\n+    let _ =\n+        #[attr] match () {\n+                    #![attr]\n+                    () => (),\n+                };\n+}\n+\n+fn _5() {\n+\n+    #[attr]\n+    let x = 1;\n+\n+    let x = #[attr] 1;\n+\n+    let y = ();\n+    let z = ();\n+\n+    foo3(x, #[attr] y, z);\n+\n+    qux(3 + #[attr] 2);\n+}\n+\n+fn _6() {\n+\n+    #[attr]\n+    [#![attr] 1, 2, 3];\n+\n+    let _ = #[attr] [#![attr] 1, 2, 3];\n+\n+    #[attr]\n+    [#![attr] 1; 4];\n+\n+    let _ = #[attr] [#![attr] 1; 4];\n+}\n+\n+struct Foo {\n+    data: (),\n+}\n+\n+struct Bar(());\n+\n+fn _7() {\n+\n+    #[attr]\n+    Foo{#![attr] data: (),};\n+\n+    let _ = #[attr] Foo{#![attr] data: (),};\n+}\n+\n+fn _8() {\n+\n+    #[attr]\n+    (#![attr] );\n+\n+    #[attr]\n+    (#![attr] 0);\n+\n+    #[attr]\n+    (#![attr] 0,);\n+\n+    #[attr]\n+    (#![attr] 0, 1);\n+}\n+\n+fn _9() {\n+    macro_rules! stmt_mac((  ) => { let _ = (  ) ; });\n+\n+    #[attr]\n+    stmt_mac!();\n+\n+    /*\n+    // pre existing pp bug: delimiter styles gets lost:\n+\n+    #[attr]\n+    stmt_mac!{ };\n+\n+    #[attr]\n+    stmt_mac![];\n+\n+    #[attr]\n+    stmt_mac!{ } // pre-existing pp bug: compiler ICEs with a None unwrap\n+    */\n+\n+    let _ = ();\n+}\n+\n+macro_rules! expr_mac((  ) => { (  ) });\n+\n+fn _10() {\n+\n+    let _ = #[attr] expr_mac!();\n+\n+    /*\n+    // pre existing pp bug: delimiter styles gets lost:\n+    let _ = #[attr] expr_mac![];\n+    let _ = #[attr] expr_mac!{};\n+    */\n+}\n+\n+fn _11() {\n+    let _ = #[attr] box 0;\n+    let _: [(); 0] = #[attr] [#![attr] ];\n+    let _ = #[attr] [#![attr] 0, 0];\n+    let _ = #[attr] [#![attr] 0; 0];\n+    let _ = #[attr] foo();\n+    let _ = #[attr] 1i32.clone();\n+    let _ = #[attr] (#![attr] );\n+    let _ = #[attr] (#![attr] 0);\n+    let _ = #[attr] (#![attr] 0,);\n+    let _ = #[attr] (#![attr] 0, 0);\n+    let _ = #[attr] 0 + #[attr] 0;\n+    let _ = #[attr] !0;\n+    let _ = #[attr] -0i32;\n+    let _ = #[attr] false;\n+    let _ = #[attr] 'c';\n+    let _ = #[attr] 0;\n+    let _ = #[attr] 0 as usize;\n+    let _ =\n+        #[attr] while false {\n+                    #![attr]\n+                };\n+    let _ =\n+        #[attr] while let None = Some(()) {\n+                    #![attr]\n+                };\n+    let _ =\n+        #[attr] for _ in 0..0 {\n+                    #![attr]\n+                };\n+    // FIXME: pp bug, two spaces after the loop\n+    let _ =\n+        #[attr] loop  {\n+                    #![attr]\n+                };\n+    let _ =\n+        #[attr] match false {\n+                    #![attr]\n+                    _ => (),\n+                };\n+    let _ = #[attr] || #[attr] ();\n+    let _ = #[attr] move || #[attr] ();\n+    let _ = #[attr] || {\n+        #![attr]\n+        #[attr]\n+        () };\n+    let _ = #[attr] move || {\n+        #![attr]\n+        #[attr]\n+        () };\n+    let _ =\n+        #[attr] {\n+                    #![attr]\n+                };\n+    let _ =\n+        #[attr] {\n+                    #![attr]\n+                    let _ = ();\n+                };\n+    let _ =\n+        #[attr] {\n+                    #![attr]\n+                    let _ = ();\n+                    ()\n+                };\n+    let mut x = 0;\n+    let _ = #[attr] x = 15;\n+    let _ = #[attr] x += 15;\n+    let s = Foo{data: (),};\n+    let _ = #[attr] s.data;\n+    let _ = (#[attr] s).data;\n+    let t = Bar(());\n+    let _ = #[attr] t.0;\n+    let _ = (#[attr] t).0;\n+    let v = vec!(0);\n+    let _ = #[attr] v[0];\n+    let _ = (#[attr] v)[0];\n+    let _ = #[attr] 0..#[attr] 0;\n+    let _ = #[attr] 0..;\n+    let _ = #[attr] (0..0);\n+    let _ = #[attr] (0..);\n+    let _ = #[attr] (..0);\n+    let _ = #[attr] (..);\n+    let _: fn(&u32) -> u32 = #[attr] std::clone::Clone::clone;\n+    let _ = #[attr] &0;\n+    let _ = #[attr] &mut 0;\n+    let _ = #[attr] &#[attr] 0;\n+    let _ = #[attr] &mut #[attr] 0;\n+    // FIXME: pp bug, extra space after keyword?\n+    while false { let _ = #[attr] continue ; }\n+    while true { let _ = #[attr] break ; }\n+    || #[attr] return;\n+    let _ = #[attr] expr_mac!();\n+    /* FIXME: pp bug, loosing delimiter styles\n+    let _ = #[attr] expr_mac![];\n+    let _ = #[attr] expr_mac!{};\n+    */\n+    let _ = #[attr] Foo{#![attr] data: (),};\n+    let _ = #[attr] Foo{#![attr] ..s};\n+    let _ = #[attr] Foo{#![attr] data: (), ..s};\n+    let _ = #[attr] (#![attr] 0);\n+}\n+\n+fn _12() {\n+    #[attr]\n+    let _ = 0;\n+\n+    #[attr]\n+    0;\n+\n+    #[attr]\n+    expr_mac!();\n+\n+    #[attr]\n+    {\n+        #![attr]\n+    }\n+}\n+\n+/////////////////\n+\n+fn foo() { }\n+fn foo3(_: i32, _: (), _: ()) { }\n+fn qux(_: i32) { }"}, {"sha": "4c20b3997f9c3c7ff58121fe40103d2953f8a30d", "filename": "src/test/run-pass-fulldeps/ast_stmt_expr_attr.rs", "status": "added", "additions": 306, "deletions": 0, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -0,0 +1,306 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_private)]\n+\n+extern crate syntax;\n+\n+use syntax::ast::*;\n+use syntax::ast;\n+use syntax::parse;\n+use syntax::parse::{ParseSess,filemap_to_tts, PResult};\n+use syntax::parse::new_parser_from_source_str;\n+use syntax::parse::parser::Parser;\n+use syntax::parse::token;\n+use syntax::ptr::P;\n+use syntax::str::char_at;\n+use syntax::parse::attr::*;\n+use syntax::print::pprust;\n+use std::fmt;\n+\n+\n+// Copied out of syntax::util::parser_testing\n+\n+pub fn string_to_parser<'a>(ps: &'a ParseSess, source_str: String) -> Parser<'a> {\n+    new_parser_from_source_str(ps,\n+                               Vec::new(),\n+                               \"bogofile\".to_string(),\n+                               source_str)\n+}\n+\n+fn with_error_checking_parse<T, F>(s: String, f: F) -> PResult<T> where\n+    F: FnOnce(&mut Parser) -> PResult<T>,\n+{\n+    let ps = ParseSess::new();\n+    let mut p = string_to_parser(&ps, s);\n+    let x = f(&mut p);\n+\n+    if ps.span_diagnostic.handler().has_errors() || p.token != token::Eof {\n+        return Err(p.fatal(\"parse error\"));\n+    }\n+\n+    x\n+}\n+\n+fn expr(s: &str) -> PResult<P<ast::Expr>> {\n+    with_error_checking_parse(s.to_string(), |p| {\n+        p.parse_expr_nopanic()\n+    })\n+}\n+\n+fn stmt(s: &str) -> PResult<P<ast::Stmt>> {\n+    with_error_checking_parse(s.to_string(), |p| {\n+        p.parse_stmt_nopanic().map(|s| s.unwrap())\n+    })\n+}\n+\n+fn attr(s: &str) -> PResult<ast::Attribute> {\n+    with_error_checking_parse(s.to_string(), |p| {\n+        p.parse_attribute(true)\n+    })\n+}\n+\n+fn str_compare<T, F: Fn(&T) -> String>(e: &str, expected: &[T], actual: &[T], f: F) {\n+    let expected: Vec<_> = expected.iter().map(|e| f(e)).collect();\n+    let actual: Vec<_> = actual.iter().map(|e| f(e)).collect();\n+\n+    if expected != actual {\n+        panic!(\"parsed `{}` as {:?}, expected {:?}\", e, actual, expected);\n+    }\n+}\n+\n+fn check_expr_attrs(es: &str, expected: &[&str]) {\n+    let e = expr(es).expect(\"parse error\");\n+    let actual = &e.attrs;\n+    str_compare(es,\n+                &expected.iter().map(|r| attr(r).unwrap()).collect::<Vec<_>>(),\n+                actual.as_attrs(),\n+                pprust::attribute_to_string);\n+}\n+\n+fn check_stmt_attrs(es: &str, expected: &[&str]) {\n+    let e = stmt(es).expect(\"parse error\");\n+    let actual = e.node.attrs();\n+    str_compare(es,\n+                &expected.iter().map(|r| attr(r).unwrap()).collect::<Vec<_>>(),\n+                actual,\n+                pprust::attribute_to_string);\n+}\n+\n+fn reject_expr_parse(es: &str) {\n+    assert!(expr(es).is_err(), \"parser did not reject `{}`\", es);\n+}\n+\n+fn reject_stmt_parse(es: &str) {\n+    assert!(stmt(es).is_err(), \"parser did not reject `{}`\", es);\n+}\n+\n+fn main() {\n+    let both = &[\"#[attr]\", \"#![attr]\"];\n+    let outer = &[\"#[attr]\"];\n+    let none = &[];\n+\n+    check_expr_attrs(\"#[attr] box 0\", outer);\n+    reject_expr_parse(\"box #![attr] 0\");\n+\n+    check_expr_attrs(\"#[attr] 0 <- #[attr] 0\", none);\n+    check_expr_attrs(\"#[attr] (0 <- 0)\", outer);\n+    reject_expr_parse(\"0 #[attr] <- 0\");\n+    reject_expr_parse(\"0 <- #![attr] 0\");\n+\n+    check_expr_attrs(\"in #[attr] 0 {#[attr] 0}\", none);\n+    check_expr_attrs(\"#[attr] (in 0 {0})\", outer);\n+    reject_expr_parse(\"in 0 #[attr] {0}\");\n+    reject_expr_parse(\"in 0 {#![attr] 0}\");\n+\n+    check_expr_attrs(\"#[attr] [#![attr]]\", both);\n+    check_expr_attrs(\"#[attr] [#![attr] 0]\", both);\n+    check_expr_attrs(\"#[attr] [#![attr] 0; 0]\", both);\n+    check_expr_attrs(\"#[attr] [#![attr] 0, 0, 0]\", both);\n+    reject_expr_parse(\"[#[attr]]\");\n+\n+    check_expr_attrs(\"#[attr] foo()\", outer);\n+    check_expr_attrs(\"#[attr] x.foo()\", outer);\n+    reject_expr_parse(\"foo#[attr]()\");\n+    reject_expr_parse(\"foo(#![attr])\");\n+    reject_expr_parse(\"x.foo(#![attr])\");\n+    reject_expr_parse(\"x.#[attr]foo()\");\n+    reject_expr_parse(\"x.#![attr]foo()\");\n+\n+    check_expr_attrs(\"#[attr] (#![attr])\", both);\n+    check_expr_attrs(\"#[attr] (#![attr] #[attr] 0,)\", both);\n+    check_expr_attrs(\"#[attr] (#![attr] #[attr] 0, 0)\", both);\n+\n+    check_expr_attrs(\"#[attr] 0 + #[attr] 0\", none);\n+    check_expr_attrs(\"#[attr] 0 / #[attr] 0\", none);\n+    check_expr_attrs(\"#[attr] 0 & #[attr] 0\", none);\n+    check_expr_attrs(\"#[attr] 0 % #[attr] 0\", none);\n+    check_expr_attrs(\"#[attr] (0 + 0)\", outer);\n+    reject_expr_parse(\"0 + #![attr] 0\");\n+\n+    check_expr_attrs(\"#[attr] !0\", outer);\n+    check_expr_attrs(\"#[attr] -0\", outer);\n+    reject_expr_parse(\"!#![attr] 0\");\n+    reject_expr_parse(\"-#![attr] 0\");\n+\n+    check_expr_attrs(\"#[attr] false\", outer);\n+    check_expr_attrs(\"#[attr] 0\", outer);\n+    check_expr_attrs(\"#[attr] 'c'\", outer);\n+\n+    check_expr_attrs(\"#[attr] x as Y\", none);\n+    check_expr_attrs(\"#[attr] (x as Y)\", outer);\n+    reject_expr_parse(\"x #![attr] as Y\");\n+\n+    reject_expr_parse(\"#[attr] if false {}\");\n+    reject_expr_parse(\"if false #[attr] {}\");\n+    reject_expr_parse(\"if false {#![attr]}\");\n+    reject_expr_parse(\"if false {} #[attr] else {}\");\n+    reject_expr_parse(\"if false {} else #[attr] {}\");\n+    reject_expr_parse(\"if false {} else {#![attr]}\");\n+    reject_expr_parse(\"if false {} else #[attr] if true {}\");\n+    reject_expr_parse(\"if false {} else if true #[attr] {}\");\n+    reject_expr_parse(\"if false {} else if true {#![attr]}\");\n+\n+    reject_expr_parse(\"#[attr] if let Some(false) = false {}\");\n+    reject_expr_parse(\"if let Some(false) = false #[attr] {}\");\n+    reject_expr_parse(\"if let Some(false) = false {#![attr]}\");\n+    reject_expr_parse(\"if let Some(false) = false {} #[attr] else {}\");\n+    reject_expr_parse(\"if let Some(false) = false {} else #[attr] {}\");\n+    reject_expr_parse(\"if let Some(false) = false {} else {#![attr]}\");\n+    reject_expr_parse(\"if let Some(false) = false {} else #[attr] if let Some(false) = true {}\");\n+    reject_expr_parse(\"if let Some(false) = false {} else if let Some(false) = true #[attr] {}\");\n+    reject_expr_parse(\"if let Some(false) = false {} else if let Some(false) = true {#![attr]}\");\n+\n+    check_expr_attrs(\"#[attr] while true {#![attr]}\", both);\n+\n+    check_expr_attrs(\"#[attr] while let Some(false) = true {#![attr]}\", both);\n+\n+    check_expr_attrs(\"#[attr] for x in y {#![attr]}\", both);\n+\n+    check_expr_attrs(\"#[attr] loop {#![attr]}\", both);\n+\n+    check_expr_attrs(\"#[attr] match true {#![attr] #[attr] _ => false}\", both);\n+\n+    check_expr_attrs(\"#[attr]      || #[attr] foo\", outer);\n+    check_expr_attrs(\"#[attr] move || #[attr] foo\", outer);\n+    check_expr_attrs(\"#[attr]      || #[attr] { #![attr] foo }\", outer);\n+    check_expr_attrs(\"#[attr] move || #[attr] { #![attr] foo }\", outer);\n+    check_expr_attrs(\"#[attr]      || { #![attr] foo }\", outer);\n+    check_expr_attrs(\"#[attr] move || { #![attr] foo }\", outer);\n+    reject_expr_parse(\"|| #![attr] foo\");\n+    reject_expr_parse(\"move || #![attr] foo\");\n+    reject_expr_parse(\"|| #![attr] {foo}\");\n+    reject_expr_parse(\"move || #![attr] {foo}\");\n+\n+    check_expr_attrs(\"#[attr] { #![attr] }\", both);\n+    check_expr_attrs(\"#[attr] { #![attr] let _ = (); }\", both);\n+    check_expr_attrs(\"#[attr] { #![attr] let _ = (); foo }\", both);\n+\n+    check_expr_attrs(\"#[attr] x = y\", none);\n+    check_expr_attrs(\"#[attr] (x = y)\", outer);\n+\n+    check_expr_attrs(\"#[attr] x += y\", none);\n+    check_expr_attrs(\"#[attr] (x += y)\", outer);\n+\n+    check_expr_attrs(\"#[attr] foo.bar\", outer);\n+    check_expr_attrs(\"(#[attr] foo).bar\", none);\n+\n+    check_expr_attrs(\"#[attr] foo.0\", outer);\n+    check_expr_attrs(\"(#[attr] foo).0\", none);\n+\n+    check_expr_attrs(\"#[attr] foo[bar]\", outer);\n+    check_expr_attrs(\"(#[attr] foo)[bar]\", none);\n+\n+    check_expr_attrs(\"#[attr] 0..#[attr] 0\", none);\n+    check_expr_attrs(\"#[attr] 0..\", none);\n+    reject_expr_parse(\"#[attr] ..#[attr] 0\");\n+    reject_expr_parse(\"#[attr] ..\");\n+\n+    check_expr_attrs(\"#[attr] (0..0)\", outer);\n+    check_expr_attrs(\"#[attr] (0..)\", outer);\n+    check_expr_attrs(\"#[attr] (..0)\", outer);\n+    check_expr_attrs(\"#[attr] (..)\", outer);\n+\n+    check_expr_attrs(\"#[attr] foo::bar::baz\", outer);\n+\n+    check_expr_attrs(\"#[attr] &0\", outer);\n+    check_expr_attrs(\"#[attr] &mut 0\", outer);\n+    check_expr_attrs(\"#[attr] & #[attr] 0\", outer);\n+    check_expr_attrs(\"#[attr] &mut #[attr] 0\", outer);\n+    reject_expr_parse(\"#[attr] &#![attr] 0\");\n+    reject_expr_parse(\"#[attr] &mut #![attr] 0\");\n+\n+    check_expr_attrs(\"#[attr] break\", outer);\n+    check_expr_attrs(\"#[attr] continue\", outer);\n+    check_expr_attrs(\"#[attr] return\", outer);\n+\n+    check_expr_attrs(\"#[attr] foo!()\", outer);\n+    check_expr_attrs(\"#[attr] foo!(#![attr])\", outer);\n+    check_expr_attrs(\"#[attr] foo![]\", outer);\n+    check_expr_attrs(\"#[attr] foo![#![attr]]\", outer);\n+    check_expr_attrs(\"#[attr] foo!{}\", outer);\n+    check_expr_attrs(\"#[attr] foo!{#![attr]}\", outer);\n+\n+    check_expr_attrs(\"#[attr] Foo { #![attr] bar: baz }\", both);\n+    check_expr_attrs(\"#[attr] Foo { #![attr] ..foo }\", both);\n+    check_expr_attrs(\"#[attr] Foo { #![attr] bar: baz, ..foo }\", both);\n+\n+    check_expr_attrs(\"#[attr] (#![attr] 0)\", both);\n+\n+    // Look at statements in their natural habitat...\n+    check_expr_attrs(\"{\n+        #[attr] let _ = 0;\n+        #[attr] 0;\n+        #[attr] foo!();\n+        #[attr] foo!{}\n+        #[attr] foo![];\n+    }\", none);\n+\n+    check_stmt_attrs(\"#[attr] let _ = 0\", outer);\n+    check_stmt_attrs(\"#[attr] 0\",         outer);\n+    check_stmt_attrs(\"#[attr] {#![attr]}\", both);\n+    check_stmt_attrs(\"#[attr] foo!()\",    outer);\n+    check_stmt_attrs(\"#[attr] foo![]\",    outer);\n+    check_stmt_attrs(\"#[attr] foo!{}\",    outer);\n+\n+    reject_stmt_parse(\"#[attr] #![attr] let _ = 0\");\n+    reject_stmt_parse(\"#[attr] #![attr] 0\");\n+    reject_stmt_parse(\"#[attr] #![attr] foo!()\");\n+    reject_stmt_parse(\"#[attr] #![attr] foo![]\");\n+    reject_stmt_parse(\"#[attr] #![attr] foo!{}\");\n+\n+    // FIXME: Allow attributes in pattern constexprs?\n+    // would require parens in patterns to allow disambiguation...\n+\n+    reject_expr_parse(\"match 0 {\n+        0...#[attr] 10 => ()\n+    }\");\n+    reject_expr_parse(\"match 0 {\n+        0...#[attr] -10 => ()\n+    }\");\n+    reject_expr_parse(\"match 0 {\n+        0...-#[attr] 10 => ()\n+    }\");\n+    reject_expr_parse(\"match 0 {\n+        0...#[attr] FOO => ()\n+    }\");\n+\n+    // make sure we don't catch this bug again...\n+    reject_expr_parse(\"{\n+        fn foo() {\n+            #[attr];\n+        }\n+    }\");\n+    reject_expr_parse(\"{\n+        fn foo() {\n+            #[attr]\n+        }\n+    }\");\n+}"}, {"sha": "f2b2a567b044d063cf9883d16657945763c5383d", "filename": "src/test/run-pass/cfg_stmt_expr.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Ftest%2Frun-pass%2Fcfg_stmt_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a8f358de7ee71934b8129dff5d908730454d7b1/src%2Ftest%2Frun-pass%2Fcfg_stmt_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcfg_stmt_expr.rs?ref=2a8f358de7ee71934b8129dff5d908730454d7b1", "patch": "@@ -0,0 +1,97 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(non_snake_case)]\n+\n+fn main() {\n+    let a = 413;\n+    #[cfg(unset)]\n+    let a = ();\n+    assert_eq!(a, 413);\n+\n+    let mut b = 612;\n+    #[cfg(unset)]\n+    {\n+        b = 1111;\n+    }\n+    assert_eq!(b, 612);\n+\n+    #[cfg(unset)]\n+    undefined_fn();\n+\n+    #[cfg(unset)]\n+    undefined_macro!();\n+    #[cfg(unset)]\n+    undefined_macro![];\n+    #[cfg(unset)]\n+    undefined_macro!{};\n+\n+    // pretty printer bug...\n+    // #[cfg(unset)]\n+    // undefined_macro!{}\n+\n+    let () = (#[cfg(unset)] 341,); // Should this also work on parens?\n+    let t = (1, #[cfg(unset)] 3, 4);\n+    assert_eq!(t, (1, 4));\n+\n+    let f = |_: u32, _: u32| ();\n+    f(2, 1, #[cfg(unset)] 6);\n+\n+    let _: u32 = a.clone(#[cfg(unset)] undefined);\n+\n+    let _: [(); 0] = [#[cfg(unset)] 126];\n+    let t = [#[cfg(unset)] 1, 2, 6];\n+    assert_eq!(t, [2, 6]);\n+\n+    {\n+        let r;\n+        #[cfg(unset)]\n+        (r = 5);\n+        #[cfg(not(unset))]\n+        (r = 10);\n+        assert_eq!(r, 10);\n+    }\n+\n+    // check that macro expanded code works\n+\n+    macro_rules! if_cfg {\n+        ($cfg:meta $ib:block else $eb:block) => {\n+            {\n+                let r;\n+                #[cfg($cfg)]\n+                (r = $ib);\n+                #[cfg(not($cfg))]\n+                (r = $eb);\n+                r\n+            }\n+        }\n+    }\n+\n+    let n = if_cfg!(unset {\n+        413\n+    } else {\n+        612\n+    });\n+\n+    assert_eq!((#[cfg(unset)] 1, #[cfg(not(unset))] 2), (2,));\n+    assert_eq!(n, 612);\n+\n+    // check that lints work\n+\n+    #[allow(non_snake_case)]\n+    let FOOBAR = {\n+        fn SYLADEX() {}\n+    };\n+\n+    #[allow(non_snake_case)]\n+    {\n+        fn CRUXTRUDER() {}\n+    }\n+}"}]}