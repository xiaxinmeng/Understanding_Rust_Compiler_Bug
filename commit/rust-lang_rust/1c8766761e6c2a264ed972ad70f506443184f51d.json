{"sha": "1c8766761e6c2a264ed972ad70f506443184f51d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjODc2Njc2MWU2YzJhMjY0ZWQ5NzJhZDcwZjUwNjQ0MzE4NGY1MWQ=", "commit": {"author": {"name": "ggomez", "email": "ggomez@ggo.ifr.lan", "date": "2016-02-15T16:57:21Z"}, "committer": {"name": "ggomez", "email": "ggomez@ggo.ifr.lan", "date": "2016-02-15T16:57:21Z"}, "message": "Global error explanations improvements", "tree": {"sha": "9f1c369d76c6a07dd408f10448489cbd96eb4e1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f1c369d76c6a07dd408f10448489cbd96eb4e1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c8766761e6c2a264ed972ad70f506443184f51d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c8766761e6c2a264ed972ad70f506443184f51d", "html_url": "https://github.com/rust-lang/rust/commit/1c8766761e6c2a264ed972ad70f506443184f51d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c8766761e6c2a264ed972ad70f506443184f51d/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b7245047b802f8e01c824a6efd8197da8be82fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b7245047b802f8e01c824a6efd8197da8be82fb", "html_url": "https://github.com/rust-lang/rust/commit/4b7245047b802f8e01c824a6efd8197da8be82fb"}], "stats": {"total": 359, "additions": 223, "deletions": 136}, "files": [{"sha": "92db527ef9803ac3b0e1f8b52a994f113a0de5c1", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 162, "deletions": 85, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/1c8766761e6c2a264ed972ad70f506443184f51d/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c8766761e6c2a264ed972ad70f506443184f51d/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=1c8766761e6c2a264ed972ad70f506443184f51d", "patch": "@@ -20,8 +20,8 @@ This error suggests that the expression arm corresponding to the noted pattern\n will never be reached as for all possible values of the expression being\n matched, one of the preceding patterns will match.\n \n-This means that perhaps some of the preceding patterns are too general, this one\n-is too specific or the ordering is incorrect.\n+This means that perhaps some of the preceding patterns are too general, this\n+one is too specific or the ordering is incorrect.\n \n For example, the following `match` block has too many arms:\n \n@@ -104,28 +104,86 @@ E0004: r##\"\n This error indicates that the compiler cannot guarantee a matching pattern for\n one or more possible inputs to a match expression. Guaranteed matches are\n required in order to assign values to match expressions, or alternatively,\n-determine the flow of execution.\n+determine the flow of execution. Erroneous code example:\n+\n+```compile_fail\n+enum Terminator {\n+    HastaLaVistaBaby,\n+    TalkToMyHand,\n+}\n+\n+let x = Terminator::HastaLaVistaBaby;\n+\n+match x { // error: non-exhaustive patterns: `HastaLaVistaBaby` not covered\n+    Terminator::TalkToMyHand => {}\n+}\n+```\n \n If you encounter this error you must alter your patterns so that every possible\n value of the input type is matched. For types with a small number of variants\n (like enums) you should probably cover all cases explicitly. Alternatively, the\n underscore `_` wildcard pattern can be added after all other patterns to match\n-\"anything else\".\n+\"anything else\". Example:\n+\n+```\n+enum Terminator {\n+    HastaLaVistaBaby,\n+    TalkToMyHand,\n+}\n+\n+let x = Terminator::HastaLaVistaBaby;\n+\n+match x {\n+    Terminator::TalkToMyHand => {}\n+    Terminator::HastaLaVistaBaby => {}\n+}\n+\n+// or:\n+\n+match x {\n+    Terminator::TalkToMyHand => {}\n+    _ => {}\n+}\n+```\n \"##,\n \n E0005: r##\"\n Patterns used to bind names must be irrefutable, that is, they must guarantee\n-that a name will be extracted in all cases. If you encounter this error you\n-probably need to use a `match` or `if let` to deal with the possibility of\n-failure.\n+that a name will be extracted in all cases. Erroneous code example:\n+\n+```compile_fail\n+let x = Some(1);\n+let Some(y) = x;\n+// error: refutable pattern in local binding: `None` not covered\n+```\n+\n+If you encounter this error you probably need to use a `match` or `if let` to\n+deal with the possibility of failure. Example:\n+\n+```compile_fail\n+let x = Some(1);\n+\n+match x {\n+    Some(y) => {\n+        // do something\n+    },\n+    None => {}\n+}\n+\n+// or:\n+\n+if let Some(y) = x {\n+    // do something\n+}\n+```\n \"##,\n \n E0007: r##\"\n This error indicates that the bindings in a match arm would require a value to\n-be moved into more than one location, thus violating unique ownership. Code like\n-the following is invalid as it requires the entire `Option<String>` to be moved\n-into a variable called `op_string` while simultaneously requiring the inner\n-String to be moved into a variable called `s`.\n+be moved into more than one location, thus violating unique ownership. Code\n+like the following is invalid as it requires the entire `Option<String>` to be\n+moved into a variable called `op_string` while simultaneously requiring the\n+inner `String` to be moved into a variable called `s`.\n \n ```compile_fail\n let x = Some(\"s\".to_string());\n@@ -180,7 +238,7 @@ by-ref.\n \n This limitation may be removed in a future version of Rust.\n \n-Wrong example:\n+Erroneous code example:\n \n ```compile_fail\n struct X { x: (), }\n@@ -264,7 +322,7 @@ trait Foo where Self: Sized {\n }\n ```\n \n-we cannot create an object of type `Box<Foo>` or `&Foo` since in this case\n+We cannot create an object of type `Box<Foo>` or `&Foo` since in this case\n `Self` would not be `Sized`.\n \n Generally, `Self : Sized` is used to indicate that the trait should not be used\n@@ -294,7 +352,7 @@ impl Trait for u8 {\n ```\n \n (Note that `&self` and `&mut self` are okay, it's additional `Self` types which\n-cause this problem)\n+cause this problem.)\n \n In such a case, the compiler cannot predict the return type of `foo()` in a\n situation like the following:\n@@ -573,15 +631,15 @@ type X = u32; // ok!\n \"##,\n \n E0133: r##\"\n-Using unsafe functionality, is potentially dangerous and disallowed\n-by safety checks. Examples:\n+Using unsafe functionality is potentially dangerous and disallowed by safety\n+checks. Examples:\n \n-- Dereferencing raw pointers\n-- Calling functions via FFI\n-- Calling functions marked unsafe\n+* Dereferencing raw pointers\n+* Calling functions via FFI\n+* Calling functions marked unsafe\n \n-These safety checks can be relaxed for a section of the code\n-by wrapping the unsafe instructions with an `unsafe` block. For instance:\n+These safety checks can be relaxed for a section of the code by wrapping the\n+unsafe instructions with an `unsafe` block. For instance:\n \n ```\n unsafe fn f() { return; }\n@@ -1039,14 +1097,16 @@ let y = match x {\n println!(\"{}\", y);\n ```\n \n-In the previous example, the print statement was never reached when the wildcard\n-match arm was hit, so we were okay with `foo()` not returning an integer that we\n-could set to `y`. But in this example, `foo()` actually does return control, so\n-the print statement will be executed with an uninitialized value.\n+In the previous example, the print statement was never reached when the\n+wildcard match arm was hit, so we were okay with `foo()` not returning an\n+integer that we could set to `y`. But in this example, `foo()` actually does\n+return control, so the print statement will be executed with an uninitialized\n+value.\n \n Obviously we cannot have functions which are allowed to be used in such\n positions and yet can return control. So, if you are defining a function that\n-returns `!`, make sure that there is no way for it to actually finish executing.\n+returns `!`, make sure that there is no way for it to actually finish\n+executing.\n \"##,\n \n E0271: r##\"\n@@ -1206,19 +1266,19 @@ trait Index<Idx> { ... }\n foo(true); // `bool` does not implement `Index<u8>`\n ```\n \n-there will be an error about `bool` not implementing `Index<u8>`, followed by a\n+There will be an error about `bool` not implementing `Index<u8>`, followed by a\n note saying \"the type `bool` cannot be indexed by `u8`\".\n \n-As you can see, you can specify type parameters in curly braces for substitution\n-with the actual types (using the regular format string syntax) in a given\n-situation. Furthermore, `{Self}` will substitute to the type (in this case,\n-`bool`) that we tried to use.\n+As you can see, you can specify type parameters in curly braces for\n+substitution with the actual types (using the regular format string syntax) in\n+a given situation. Furthermore, `{Self}` will substitute to the type (in this\n+case, `bool`) that we tried to use.\n \n This error appears when the curly braces contain an identifier which doesn't\n-match with any of the type parameters or the string `Self`. This might happen if\n-you misspelled a type parameter, or if you intended to use literal curly braces.\n-If it is the latter, escape the curly braces with a second curly brace of the\n-same type; e.g. a literal `{` is `{{`\n+match with any of the type parameters or the string `Self`. This might happen\n+if you misspelled a type parameter, or if you intended to use literal curly\n+braces. If it is the latter, escape the curly braces with a second curly brace\n+of the same type; e.g. a literal `{` is `{{`.\n \"##,\n \n E0273: r##\"\n@@ -1239,10 +1299,10 @@ foo(true); // `bool` does not implement `Index<u8>`\n there will be an error about `bool` not implementing `Index<u8>`, followed by a\n note saying \"the type `bool` cannot be indexed by `u8`\".\n \n-As you can see, you can specify type parameters in curly braces for substitution\n-with the actual types (using the regular format string syntax) in a given\n-situation. Furthermore, `{Self}` will substitute to the type (in this case,\n-`bool`) that we tried to use.\n+As you can see, you can specify type parameters in curly braces for\n+substitution with the actual types (using the regular format string syntax) in\n+a given situation. Furthermore, `{Self}` will substitute to the type (in this\n+case, `bool`) that we tried to use.\n \n This error appears when the curly braces do not contain an identifier. Please\n add one of the same name as a type parameter. If you intended to use literal\n@@ -1274,8 +1334,8 @@ trait.\n \n E0275: r##\"\n This error occurs when there was a recursive trait requirement that overflowed\n-before it could be evaluated. Often this means that there is unbounded recursion\n-in resolving some type bounds.\n+before it could be evaluated. Often this means that there is unbounded\n+recursion in resolving some type bounds.\n \n For example, in the following code:\n \n@@ -1288,9 +1348,9 @@ impl<T> Foo for T where Bar<T>: Foo {}\n ```\n \n To determine if a `T` is `Foo`, we need to check if `Bar<T>` is `Foo`. However,\n-to do this check, we need to determine that `Bar<Bar<T>>` is `Foo`. To determine\n-this, we check if `Bar<Bar<Bar<T>>>` is `Foo`, and so on. This is clearly a\n-recursive requirement that can't be resolved directly.\n+to do this check, we need to determine that `Bar<Bar<T>>` is `Foo`. To\n+determine this, we check if `Bar<Bar<Bar<T>>>` is `Foo`, and so on. This is\n+clearly a recursive requirement that can't be resolved directly.\n \n Consider changing your trait bounds so that they're less self-referential.\n \"##,\n@@ -1336,7 +1396,7 @@ fn main() {\n     // we now call the method with the i32 type, which doesn't implement\n     // the Foo trait\n     some_func(5i32); // error: the trait `Foo` is not implemented for the\n-                     //     type `i32`\n+                     //        type `i32`\n }\n ```\n \n@@ -1564,7 +1624,9 @@ borrows were allowed:\n ```compile_fail\n match Some(()) {\n     None => { },\n-    option if option.take().is_none() => { /* impossible, option is `Some` */ },\n+    option if option.take().is_none() => {\n+        /* impossible, option is `Some` */\n+    },\n     Some(_) => { } // When the previous match failed, the option became `None`.\n }\n ```\n@@ -1615,12 +1677,29 @@ See also https://github.com/rust-lang/rust/issues/14587\n \n E0306: r##\"\n In an array literal `[x; N]`, `N` is the number of elements in the array. This\n-number cannot be negative.\n+must be an unsigned integer. Erroneous code example:\n+\n+```compile_fail\n+let x = [0i32; true]; // error: expected positive integer for repeat count,\n+                      //        found boolean\n+```\n+\n+Working example:\n+\n+```\n+let x = [0i32; 2];\n+```\n \"##,\n \n E0307: r##\"\n-The length of an array is part of its type. For this reason, this length must be\n-a compile-time constant.\n+The length of an array is part of its type. For this reason, this length must\n+be a compile-time constant. Erroneous code example:\n+\n+```compile_fail\n+    let len = 10;\n+    let x = [0i32; len]; // error: expected constant integer for repeat count,\n+                         //        found variable\n+```\n \"##,\n \n E0308: r##\"\n@@ -1713,24 +1792,22 @@ struct Foo<T: 'static> {\n \"##,\n \n E0398: r##\"\n-In Rust 1.3, the default object lifetime bounds are expected to\n-change, as described in RFC #1156 [1]. You are getting a warning\n-because the compiler thinks it is possible that this change will cause\n-a compilation error in your code. It is possible, though unlikely,\n-that this is a false alarm.\n-\n-The heart of the change is that where `&'a Box<SomeTrait>` used to\n-default to `&'a Box<SomeTrait+'a>`, it now defaults to `&'a\n-Box<SomeTrait+'static>` (here, `SomeTrait` is the name of some trait\n-type). Note that the only types which are affected are references to\n-boxes, like `&Box<SomeTrait>` or `&[Box<SomeTrait>]`.  More common\n-types like `&SomeTrait` or `Box<SomeTrait>` are unaffected.\n-\n-To silence this warning, edit your code to use an explicit bound.\n-Most of the time, this means that you will want to change the\n-signature of a function that you are calling. For example, if\n-the error is reported on a call like `foo(x)`, and `foo` is\n-defined as follows:\n+In Rust 1.3, the default object lifetime bounds are expected to change, as\n+described in RFC #1156 [1]. You are getting a warning because the compiler\n+thinks it is possible that this change will cause a compilation error in your\n+code. It is possible, though unlikely, that this is a false alarm.\n+\n+The heart of the change is that where `&'a Box<SomeTrait>` used to default to\n+`&'a Box<SomeTrait+'a>`, it now defaults to `&'a Box<SomeTrait+'static>` (here,\n+`SomeTrait` is the name of some trait type). Note that the only types which are\n+affected are references to boxes, like `&Box<SomeTrait>` or\n+`&[Box<SomeTrait>]`. More common types like `&SomeTrait` or `Box<SomeTrait>`\n+are unaffected.\n+\n+To silence this warning, edit your code to use an explicit bound. Most of the\n+time, this means that you will want to change the signature of a function that\n+you are calling. For example, if the error is reported on a call like `foo(x)`,\n+and `foo` is defined as follows:\n \n ```ignore\n fn foo(arg: &Box<SomeTrait>) { ... }\n@@ -1742,8 +1819,8 @@ You might change it to:\n fn foo<'a>(arg: &Box<SomeTrait+'a>) { ... }\n ```\n \n-This explicitly states that you expect the trait object `SomeTrait` to\n-contain references (with a maximum lifetime of `'a`).\n+This explicitly states that you expect the trait object `SomeTrait` to contain\n+references (with a maximum lifetime of `'a`).\n \n [1]: https://github.com/rust-lang/rfcs/pull/1156\n \"##,\n@@ -1812,8 +1889,8 @@ Also, for now, it is not possible to write deprecation messages either.\n \"##,\n \n E0517: r##\"\n-This error indicates that a `#[repr(..)]` attribute was placed on an unsupported\n-item.\n+This error indicates that a `#[repr(..)]` attribute was placed on an\n+unsupported item.\n \n Examples of erroneous code:\n \n@@ -1829,29 +1906,29 @@ struct Foo {bar: bool, baz: bool}\n \n #[repr(C)]\n impl Foo {\n-    ...\n+    // ...\n }\n ```\n \n- - The `#[repr(C)]` attribute can only be placed on structs and enums\n- - The `#[repr(packed)]` and `#[repr(simd)]` attributes only work on structs\n- - The `#[repr(u8)]`, `#[repr(i16)]`, etc attributes only work on enums\n+* The `#[repr(C)]` attribute can only be placed on structs and enums.\n+* The `#[repr(packed)]` and `#[repr(simd)]` attributes only work on structs.\n+* The `#[repr(u8)]`, `#[repr(i16)]`, etc attributes only work on enums.\n \n These attributes do not work on typedefs, since typedefs are just aliases.\n \n Representations like `#[repr(u8)]`, `#[repr(i64)]` are for selecting the\n-discriminant size for C-like enums (when there is no associated data, e.g. `enum\n-Color {Red, Blue, Green}`), effectively setting the size of the enum to the size\n-of the provided type. Such an enum can be cast to a value of the same type as\n-well. In short, `#[repr(u8)]` makes the enum behave like an integer with a\n-constrained set of allowed values.\n+discriminant size for C-like enums (when there is no associated data, e.g.\n+`enum Color {Red, Blue, Green}`), effectively setting the size of the enum to\n+the size of the provided type. Such an enum can be cast to a value of the same\n+type as well. In short, `#[repr(u8)]` makes the enum behave like an integer\n+with a constrained set of allowed values.\n \n Only C-like enums can be cast to numerical primitives, so this attribute will\n not apply to structs.\n \n `#[repr(packed)]` reduces padding to make the struct size smaller. The\n-representation of enums isn't strictly defined in Rust, and this attribute won't\n-work on enums.\n+representation of enums isn't strictly defined in Rust, and this attribute\n+won't work on enums.\n \n `#[repr(simd)]` will give a struct consisting of a homogenous series of machine\n types (i.e. `u8`, `i32`, etc) a representation that permits vectorization via\n@@ -1860,8 +1937,8 @@ single list of data.\n \"##,\n \n E0518: r##\"\n-This error indicates that an `#[inline(..)]` attribute was incorrectly placed on\n-something other than a function or method.\n+This error indicates that an `#[inline(..)]` attribute was incorrectly placed\n+on something other than a function or method.\n \n Examples of erroneous code:\n \n@@ -1871,7 +1948,7 @@ struct Foo;\n \n #[inline(never)]\n impl Foo {\n-    ...\n+    // ...\n }\n ```\n "}, {"sha": "7f6fd9de3d294709957a0e363e4cc5f5d5ee541c", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1c8766761e6c2a264ed972ad70f506443184f51d/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c8766761e6c2a264ed972ad70f506443184f51d/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=1c8766761e6c2a264ed972ad70f506443184f51d", "patch": "@@ -26,7 +26,8 @@ fn foo() -> Box<Fn(u32) -> u32> {\n \n Notice that `x` is stack-allocated by `foo()`. By default, Rust captures\n closed-over data by reference. This means that once `foo()` returns, `x` no\n-longer exists. An attempt to access `x` within the closure would thus be unsafe.\n+longer exists. An attempt to access `x` within the closure would thus be\n+unsafe.\n \n Another situation where this might be encountered is when spawning threads:\n \n@@ -73,7 +74,14 @@ fn main() {\n ```\n \n To fix this, ensure that any declared variables are initialized before being\n-used.\n+used. Example:\n+\n+```\n+fn main() {\n+    let x: i32 = 0;\n+    let y = x; // ok!\n+}\n+```\n \"##,\n \n E0382: r##\"\n@@ -210,8 +218,8 @@ let mut y: Box<_> = Box::new(&mut x);\n **y = 2;\n ```\n \n-It can also be fixed by using a type with interior mutability, such as `Cell` or\n-`RefCell`:\n+It can also be fixed by using a type with interior mutability, such as `Cell`\n+or `RefCell`:\n \n ```\n use std::cell::Cell;\n@@ -259,8 +267,8 @@ fn foo<F: FnMut()>(f: F) { }\n ```\n \n Alternatively, we can consider using the `Cell` and `RefCell` types to achieve\n-interior mutability through a shared reference. Our example's `mutable` function\n-could be redefined as below:\n+interior mutability through a shared reference. Our example's `mutable`\n+function could be redefined as below:\n \n ```\n use std::cell::Cell;"}, {"sha": "36ba3d0ca73636bb291c1310ab4c9e6b4998c5d9", "filename": "src/librustc_privacy/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1c8766761e6c2a264ed972ad70f506443184f51d/src%2Flibrustc_privacy%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c8766761e6c2a264ed972ad70f506443184f51d/src%2Flibrustc_privacy%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Fdiagnostics.rs?ref=1c8766761e6c2a264ed972ad70f506443184f51d", "patch": "@@ -27,8 +27,8 @@ pub fn foo<T: Foo> (t: T) {} // same error\n ```\n \n To solve this error, please ensure that the trait is also public. The trait\n-can be made inaccessible if necessary by placing it into a private inner module,\n-but it still has to be marked with `pub`. Example:\n+can be made inaccessible if necessary by placing it into a private inner\n+module, but it still has to be marked with `pub`. Example:\n \n ```ignore\n pub trait Foo { // we set the Foo trait public\n@@ -55,8 +55,8 @@ mod Foo {\n ```\n \n To solve this error, please ensure that the type is also public. The type\n-can be made inaccessible if necessary by placing it into a private inner module,\n-but it still has to be marked with `pub`.\n+can be made inaccessible if necessary by placing it into a private inner\n+module, but it still has to be marked with `pub`.\n Example:\n \n ```\n@@ -165,7 +165,7 @@ let f = Bar::Foo(0); // error: cannot invoke tuple struct constructor with\n ```\n \n To solve this issue, please ensure that all of the fields of the tuple struct\n-are public. Alternatively, provide a new() method to the tuple struct to\n+are public. Alternatively, provide a `new()` method to the tuple struct to\n construct it from a given inner value. Example:\n \n ```"}, {"sha": "dee2727c163167b65ddf83cc186173db1712c79e", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 42, "deletions": 40, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/1c8766761e6c2a264ed972ad70f506443184f51d/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c8766761e6c2a264ed972ad70f506443184f51d/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=1c8766761e6c2a264ed972ad70f506443184f51d", "patch": "@@ -94,8 +94,8 @@ mod bar {\n \"##,\n \n E0253: r##\"\n-Attempt was made to import an unimportable value. This can happen when\n-trying to import a method from a trait. An example of this error:\n+Attempt was made to import an unimportable value. This can happen when trying\n+to import a method from a trait. An example of this error:\n \n ```compile_fail\n mod foo {\n@@ -149,10 +149,10 @@ fn main() {}\n \"##,\n \n E0259: r##\"\n-The name chosen for an external crate conflicts with another external crate that\n-has been imported into the current module.\n+The name chosen for an external crate conflicts with another external crate\n+that has been imported into the current module.\n \n-Wrong example:\n+Erroneous code example:\n \n ```compile_fail\n extern crate a;\n@@ -251,8 +251,8 @@ https://doc.rust-lang.org/reference.html#types\n \"##,\n \n E0364: r##\"\n-Private items cannot be publicly re-exported.  This error indicates that\n-you attempted to `pub use` a type or value that was not itself public.\n+Private items cannot be publicly re-exported.  This error indicates that you\n+attempted to `pub use` a type or value that was not itself public.\n \n Here is an example that demonstrates the error:\n \n@@ -275,15 +275,15 @@ mod foo {\n pub use foo::X;\n ```\n \n-See the 'Use Declarations' section of the reference for more information\n-on this topic:\n+See the 'Use Declarations' section of the reference for more information on\n+this topic:\n \n https://doc.rust-lang.org/reference.html#use-declarations\n \"##,\n \n E0365: r##\"\n-Private modules cannot be publicly re-exported.  This error indicates\n-that you attempted to `pub use` a module that was not itself public.\n+Private modules cannot be publicly re-exported. This error indicates that you\n+attempted to `pub use` a module that was not itself public.\n \n Here is an example that demonstrates the error:\n \n@@ -313,8 +313,8 @@ https://doc.rust-lang.org/reference.html#use-declarations\n \"##,\n \n E0401: r##\"\n-Inner items do not inherit type parameters from the functions they are\n-embedded in. For example, this will not compile:\n+Inner items do not inherit type parameters from the functions they are embedded\n+in. For example, this will not compile:\n \n ```compile_fail\n fn foo<T>(x: T) {\n@@ -543,16 +543,15 @@ impl Bar {\n \"##,\n \n E0411: r##\"\n-The `Self` keyword was used outside an impl or a trait. Erroneous\n-code example:\n+The `Self` keyword was used outside an impl or a trait. Erroneous code example:\n \n ```compile_fail\n <Self>::foo; // error: use of `Self` outside of an impl or trait\n ```\n \n-The `Self` keyword represents the current type, which explains why it\n-can only be used inside an impl or a trait. It gives access to the\n-associated items of a type:\n+The `Self` keyword represents the current type, which explains why it can only\n+be used inside an impl or a trait. It gives access to the associated items of a\n+type:\n \n ```\n trait Foo {\n@@ -564,7 +563,7 @@ trait Baz : Foo {\n }\n ```\n \n-However, be careful when two types has a common associated type:\n+However, be careful when two types have a common associated type:\n \n ```compile_fail\n trait Foo {\n@@ -581,8 +580,8 @@ trait Baz : Foo + Foo2 {\n }\n ```\n \n-This problem can be solved by specifying from which trait we want\n-to use the `Bar` type:\n+This problem can be solved by specifying from which trait we want to use the\n+`Bar` type:\n \n ```\n trait Foo {\n@@ -604,16 +603,20 @@ An undeclared type name was used. Example of erroneous codes:\n \n ```compile_fail\n impl Something {} // error: use of undeclared type name `Something`\n+\n // or:\n+\n trait Foo {\n     fn bar(N); // error: use of undeclared type name `N`\n }\n+\n // or:\n+\n fn foo(x: T) {} // error: use of undeclared type name `T`\n ```\n \n-To fix this error, please verify you didn't misspell the type name,\n-you did declare it or imported it into the scope. Examples:\n+To fix this error, please verify you didn't misspell the type name, you did\n+declare it or imported it into the scope. Examples:\n \n ```\n struct Something;\n@@ -635,8 +638,8 @@ fn foo<T>(x: T) {} // ok!\n \"##,\n \n E0413: r##\"\n-A declaration shadows an enum variant or unit-like struct in scope.\n-Example of erroneous code:\n+A declaration shadows an enum variant or unit-like struct in scope. Example of\n+erroneous code:\n \n ```compile_fail\n struct Foo;\n@@ -666,8 +669,7 @@ The goal here is to avoid a conflict of names.\n \"##,\n \n E0415: r##\"\n-More than one function parameter have the same name. Example of erroneous\n-code:\n+More than one function parameter have the same name. Example of erroneous code:\n \n ```compile_fail\n fn foo(f: i32, f: i32) {} // error: identifier `f` is bound more than\n@@ -682,8 +684,7 @@ fn foo(f: i32, g: i32) {} // ok!\n \"##,\n \n E0416: r##\"\n-An identifier is bound more than once in a pattern. Example of erroneous\n-code:\n+An identifier is bound more than once in a pattern. Example of erroneous code:\n \n ```compile_fail\n match (1, 2) {\n@@ -739,8 +740,7 @@ match 0 {\n \"##,\n \n E0419: r##\"\n-An unknown enum variant, struct or const was used. Example of\n-erroneous code:\n+An unknown enum variant, struct or const was used. Example of erroneous code:\n \n ```compile_fail\n match 0 {\n@@ -766,8 +766,8 @@ match Something::NotFoo {\n \"##,\n \n E0422: r##\"\n-You are trying to use an identifier that is either undefined or not a\n-struct. For instance:\n+You are trying to use an identifier that is either undefined or not a struct.\n+For instance:\n \n ``` compile_fail\n fn main () {\n@@ -785,13 +785,13 @@ fn main () {\n }\n ```\n \n-In this case, `foo` is defined, but is not a struct, so Rust can't use\n-it as one.\n+In this case, `foo` is defined, but is not a struct, so Rust can't use it as\n+one.\n \"##,\n \n E0423: r##\"\n-A `struct` variant name was used like a function name. Example of\n-erroneous code:\n+A `struct` variant name was used like a function name. Example of erroneous\n+code:\n \n ```compile_fail\n struct Foo { a: bool};\n@@ -801,8 +801,8 @@ let f = Foo();\n //        it like a function name\n ```\n \n-Please verify you didn't misspell the name of what you actually wanted\n-to use here. Example:\n+Please verify you didn't misspell the name of what you actually wanted to use\n+here. Example:\n \n ```\n fn Foo() -> u32 { 0 }\n@@ -851,13 +851,15 @@ something_that_doesnt_exist::foo;\n // error: unresolved name `something_that_doesnt_exist::foo`\n \n // or:\n+\n trait Foo {\n     fn bar() {\n         Self; // error: unresolved name `Self`\n     }\n }\n \n // or:\n+\n let x = unknown_variable;  // error: unresolved name `unknown_variable`\n ```\n \n@@ -941,7 +943,7 @@ use something::self; // ok!\n \"##,\n \n E0431: r##\"\n-`self` import was made. Erroneous code example:\n+An invalid `self` import was made. Erroneous code example:\n \n ```compile_fail\n use {self}; // error: `self` import can only appear in an import list with a"}]}