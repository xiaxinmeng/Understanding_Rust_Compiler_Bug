{"sha": "d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4YzZlMTkyZjdiMzVjNTdlN2ZmOWQxNjdhYjEwZGI4YThjZDkwYjQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-10-15T15:39:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-15T15:39:35Z"}, "message": "Merge #6243\n\n6243: Clarify classification API r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "460a055c661b2c44ffef28b920f1a59bdbfd5017", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/460a055c661b2c44ffef28b920f1a59bdbfd5017"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfiG03CRBK7hj4Ov3rIwAAdHIIAAYDmvsshgDrkZl24/0K2VUT\nIZpY/aZ++Cy8fLk3LYzEPERfF2Pw0R+NQt38U7iowMOQmYA+yUeSO1eRcNcsp7Sz\nU+z6jW9xgMN9ih//wjRnoITwWYIzGVt7E0uVOBxbDo1fa8/vNErCGKfBZik7/irL\n01zT0RTWTSfG6PBuuDH7hX67dtMak9C3blkQCOPzDNZQmI+0V4uEENOvPnNK7nGa\nnU+7AWm4Yq6FqPSK2qoz7Cu8jhVMOpAHKwZyANoRGQSRlKU04JCo+dSpoLx6YOsf\n4tVIrej0IA4h2lT/FoCjG1lejj72tdLs0T9xBR0ZO3zlTjFFjyj8PHv+MKnpn50=\n=fU1v\n-----END PGP SIGNATURE-----\n", "payload": "tree 460a055c661b2c44ffef28b920f1a59bdbfd5017\nparent 7fadc78ebb43b0eb9b6ccf314e29bdd23717542f\nparent c5868a48795c899d43fde773091f0b133bee0a59\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1602776375 +0000\ncommitter GitHub <noreply@github.com> 1602776375 +0000\n\nMerge #6243\n\n6243: Clarify classification API r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4", "html_url": "https://github.com/rust-lang/rust/commit/d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fadc78ebb43b0eb9b6ccf314e29bdd23717542f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fadc78ebb43b0eb9b6ccf314e29bdd23717542f", "html_url": "https://github.com/rust-lang/rust/commit/7fadc78ebb43b0eb9b6ccf314e29bdd23717542f"}, {"sha": "c5868a48795c899d43fde773091f0b133bee0a59", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5868a48795c899d43fde773091f0b133bee0a59", "html_url": "https://github.com/rust-lang/rust/commit/c5868a48795c899d43fde773091f0b133bee0a59"}], "stats": {"total": 443, "additions": 228, "deletions": 215}, "files": [{"sha": "e3d84d6986afcaced592137f95c8edd17477352f", "filename": "crates/assists/src/handlers/add_turbo_fish.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs?ref=d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4", "patch": "@@ -1,4 +1,4 @@\n-use ide_db::defs::{classify_name_ref, Definition, NameRefClass};\n+use ide_db::defs::{Definition, NameRefClass};\n use syntax::{ast, AstNode, SyntaxKind, T};\n use test_utils::mark;\n \n@@ -39,7 +39,7 @@ pub(crate) fn add_turbo_fish(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n         return None;\n     }\n     let name_ref = ast::NameRef::cast(ident.parent())?;\n-    let def = match classify_name_ref(&ctx.sema, &name_ref)? {\n+    let def = match NameRefClass::classify(&ctx.sema, &name_ref)? {\n         NameRefClass::Definition(def) => def,\n         NameRefClass::ExternCrate(_) | NameRefClass::FieldShorthand { .. } => return None,\n     };"}, {"sha": "316a58d883adf37b4216edbb3c36001493b581d4", "filename": "crates/assists/src/handlers/expand_glob_import.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4/crates%2Fassists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4/crates%2Fassists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs?ref=d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4", "patch": "@@ -1,7 +1,7 @@\n use either::Either;\n use hir::{AssocItem, MacroDef, Module, ModuleDef, Name, PathResolution, ScopeDef};\n use ide_db::{\n-    defs::{classify_name_ref, Definition, NameRefClass},\n+    defs::{Definition, NameRefClass},\n     search::SearchScope,\n };\n use syntax::{\n@@ -217,7 +217,7 @@ fn find_imported_defs(ctx: &AssistContext, star: SyntaxToken) -> Option<Vec<Def>\n             .flatten()\n             .filter_map(|n| Some(n.descendants().filter_map(ast::NameRef::cast)))\n             .flatten()\n-            .filter_map(|r| match classify_name_ref(&ctx.sema, &r)? {\n+            .filter_map(|r| match NameRefClass::classify(&ctx.sema, &r)? {\n                 NameRefClass::Definition(Definition::ModuleDef(def)) => Some(Def::ModuleDef(def)),\n                 NameRefClass::Definition(Definition::Macro(def)) => Some(Def::MacroDef(def)),\n                 _ => None,"}, {"sha": "d9dc63b33cc0494cf46d84472dcaf22c9034dd40", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4", "patch": "@@ -14,7 +14,7 @@ use hir::{\n     ModuleDef,\n };\n use ide_db::{\n-    defs::{classify_name, classify_name_ref, Definition},\n+    defs::{Definition, NameClass, NameRefClass},\n     RootDatabase,\n };\n use syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset, T};\n@@ -232,8 +232,8 @@ pub(crate) fn external_docs(\n     let node = token.parent();\n     let definition = match_ast! {\n         match node {\n-            ast::NameRef(name_ref) => classify_name_ref(&sema, &name_ref).map(|d| d.definition(sema.db)),\n-            ast::Name(name) => classify_name(&sema, &name).map(|d| d.definition(sema.db)),\n+            ast::NameRef(name_ref) => NameRefClass::classify(&sema, &name_ref).map(|d| d.referenced(sema.db)),\n+            ast::Name(name) => NameClass::classify(&sema, &name).map(|d| d.referenced_or_defined(sema.db)),\n             _ => None,\n         }\n     };"}, {"sha": "a87e31019df260227b9fae95dee5406d67804ee2", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4", "patch": "@@ -1,6 +1,6 @@\n use hir::Semantics;\n use ide_db::{\n-    defs::{classify_name, classify_name_ref},\n+    defs::{NameClass, NameRefClass},\n     symbol_index, RootDatabase,\n };\n use syntax::{\n@@ -40,7 +40,7 @@ pub(crate) fn goto_definition(\n                 reference_definition(&sema, &name_ref).to_vec()\n             },\n             ast::Name(name) => {\n-                let def = classify_name(&sema, &name)?.definition(sema.db);\n+                let def = NameClass::classify(&sema, &name)?.referenced_or_defined(sema.db);\n                 let nav = def.try_to_nav(sema.db)?;\n                 vec![nav]\n             },\n@@ -81,9 +81,9 @@ pub(crate) fn reference_definition(\n     sema: &Semantics<RootDatabase>,\n     name_ref: &ast::NameRef,\n ) -> ReferenceResult {\n-    let name_kind = classify_name_ref(sema, name_ref);\n+    let name_kind = NameRefClass::classify(sema, name_ref);\n     if let Some(def) = name_kind {\n-        let def = def.definition(sema.db);\n+        let def = def.referenced(sema.db);\n         return match def.try_to_nav(sema.db) {\n             Some(nav) => ReferenceResult::Exact(nav),\n             None => ReferenceResult::Approximate(Vec::new()),"}, {"sha": "845333e2aec0e96b4e528beffb84a9f7d448513f", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4", "patch": "@@ -4,7 +4,7 @@ use hir::{\n     Module, ModuleDef, ModuleSource, Semantics,\n };\n use ide_db::{\n-    defs::{classify_name, classify_name_ref, Definition},\n+    defs::{Definition, NameClass, NameRefClass},\n     RootDatabase,\n };\n use itertools::Itertools;\n@@ -107,8 +107,8 @@ pub(crate) fn hover(\n     let node = token.parent();\n     let definition = match_ast! {\n         match node {\n-            ast::NameRef(name_ref) => classify_name_ref(&sema, &name_ref).map(|d| d.definition(sema.db)),\n-            ast::Name(name) => classify_name(&sema, &name).and_then(|d| d.into_definition(sema.db)),\n+            ast::Name(name) => NameClass::classify(&sema, &name).and_then(|d| d.defined(sema.db)),\n+            ast::NameRef(name_ref) => NameRefClass::classify(&sema, &name_ref).map(|d| d.referenced(sema.db)),\n             _ => None,\n         }\n     };"}, {"sha": "67ec257a8e9f6cbe52bc0ae94223f140fbf87dbd", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4", "patch": "@@ -13,7 +13,7 @@ pub(crate) mod rename;\n \n use hir::Semantics;\n use ide_db::{\n-    defs::{classify_name, classify_name_ref, Definition},\n+    defs::{Definition, NameClass, NameRefClass},\n     search::SearchScope,\n     RootDatabase,\n };\n@@ -132,13 +132,13 @@ fn find_name(\n     opt_name: Option<ast::Name>,\n ) -> Option<RangeInfo<Definition>> {\n     if let Some(name) = opt_name {\n-        let def = classify_name(sema, &name)?.definition(sema.db);\n+        let def = NameClass::classify(sema, &name)?.referenced_or_defined(sema.db);\n         let range = name.syntax().text_range();\n         return Some(RangeInfo::new(range, def));\n     }\n     let name_ref =\n         sema.find_node_at_offset_with_descend::<ast::NameRef>(&syntax, position.offset)?;\n-    let def = classify_name_ref(sema, &name_ref)?.definition(sema.db);\n+    let def = NameRefClass::classify(sema, &name_ref)?.referenced(sema.db);\n     let range = name_ref.syntax().text_range();\n     Some(RangeInfo::new(range, def))\n }"}, {"sha": "35aafc49d740231c349d866e4fd466a964396eb5", "filename": "crates/ide/src/references/rename.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences%2Frename.rs?ref=d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4", "patch": "@@ -3,7 +3,7 @@\n use base_db::SourceDatabaseExt;\n use hir::{Module, ModuleDef, ModuleSource, Semantics};\n use ide_db::{\n-    defs::{classify_name, classify_name_ref, Definition, NameClass, NameRefClass},\n+    defs::{Definition, NameClass, NameRefClass},\n     RootDatabase,\n };\n \n@@ -88,13 +88,13 @@ fn find_module_at_offset(\n     let module = match_ast! {\n         match (ident.parent()) {\n             ast::NameRef(name_ref) => {\n-                match classify_name_ref(sema, &name_ref)? {\n+                match NameRefClass::classify(sema, &name_ref)? {\n                     NameRefClass::Definition(Definition::ModuleDef(ModuleDef::Module(module))) => module,\n                     _ => return None,\n                 }\n             },\n             ast::Name(name) => {\n-                match classify_name(&sema, &name)? {\n+                match NameClass::classify(&sema, &name)? {\n                     NameClass::Definition(Definition::ModuleDef(ModuleDef::Module(module))) => module,\n                     _ => return None,\n                 }"}, {"sha": "b35c031627fadc590c3961f6891be4bd56993587", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4", "patch": "@@ -8,7 +8,7 @@ mod tests;\n \n use hir::{Local, Name, Semantics, VariantDef};\n use ide_db::{\n-    defs::{classify_name, classify_name_ref, Definition, NameClass, NameRefClass},\n+    defs::{Definition, NameClass, NameRefClass},\n     RootDatabase,\n };\n use rustc_hash::FxHashMap;\n@@ -443,7 +443,7 @@ fn highlight_element(\n         // Highlight definitions depending on the \"type\" of the definition.\n         NAME => {\n             let name = element.into_node().and_then(ast::Name::cast).unwrap();\n-            let name_kind = classify_name(sema, &name);\n+            let name_kind = NameClass::classify(sema, &name);\n \n             if let Some(NameClass::Definition(Definition::Local(local))) = &name_kind {\n                 if let Some(name) = local.name(db) {\n@@ -459,9 +459,9 @@ fn highlight_element(\n                     highlight_def(db, def) | HighlightModifier::Definition\n                 }\n                 Some(NameClass::ConstReference(def)) => highlight_def(db, def),\n-                Some(NameClass::FieldShorthand { field, .. }) => {\n+                Some(NameClass::PatFieldShorthand { field_ref, .. }) => {\n                     let mut h = HighlightTag::Field.into();\n-                    if let Definition::Field(field) = field {\n+                    if let Definition::Field(field) = field_ref {\n                         if let VariantDef::Union(_) = field.parent_def(db) {\n                             h |= HighlightModifier::Unsafe;\n                         }\n@@ -480,7 +480,7 @@ fn highlight_element(\n         NAME_REF => {\n             let name_ref = element.into_node().and_then(ast::NameRef::cast).unwrap();\n             highlight_func_by_name_ref(sema, &name_ref).unwrap_or_else(|| {\n-                match classify_name_ref(sema, &name_ref) {\n+                match NameRefClass::classify(sema, &name_ref) {\n                     Some(name_kind) => match name_kind {\n                         NameRefClass::ExternCrate(_) => HighlightTag::Module.into(),\n                         NameRefClass::Definition(def) => {"}, {"sha": "201a3d6fa0075c0900b313e94372690d561b9975", "filename": "crates/ide_db/src/defs.rs", "status": "modified", "additions": 195, "deletions": 182, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4/crates%2Fide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4/crates%2Fide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fdefs.rs?ref=d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4", "patch": "@@ -81,146 +81,152 @@ impl Definition {\n pub enum NameClass {\n     ExternCrate(Crate),\n     Definition(Definition),\n-    /// `None` in `if let None = Some(82) {}`\n+    /// `None` in `if let None = Some(82) {}`.\n     ConstReference(Definition),\n-    FieldShorthand {\n-        local: Local,\n-        field: Definition,\n+    /// `field` in `if let Foo { field } = foo`.\n+    PatFieldShorthand {\n+        local_def: Local,\n+        field_ref: Definition,\n     },\n }\n \n impl NameClass {\n-    pub fn into_definition(self, db: &dyn HirDatabase) -> Option<Definition> {\n-        Some(match self {\n+    /// `Definition` defined by this name.\n+    pub fn defined(self, db: &dyn HirDatabase) -> Option<Definition> {\n+        let res = match self {\n             NameClass::ExternCrate(krate) => Definition::ModuleDef(krate.root_module(db).into()),\n             NameClass::Definition(it) => it,\n             NameClass::ConstReference(_) => return None,\n-            NameClass::FieldShorthand { local, field: _ } => Definition::Local(local),\n-        })\n+            NameClass::PatFieldShorthand { local_def, field_ref: _ } => {\n+                Definition::Local(local_def)\n+            }\n+        };\n+        Some(res)\n     }\n \n-    pub fn definition(self, db: &dyn HirDatabase) -> Definition {\n+    /// `Definition` referenced or defined by this name.\n+    pub fn referenced_or_defined(self, db: &dyn HirDatabase) -> Definition {\n         match self {\n             NameClass::ExternCrate(krate) => Definition::ModuleDef(krate.root_module(db).into()),\n             NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n-            NameClass::FieldShorthand { local: _, field } => field,\n+            NameClass::PatFieldShorthand { local_def: _, field_ref } => field_ref,\n         }\n     }\n-}\n \n-pub fn classify_name(sema: &Semantics<RootDatabase>, name: &ast::Name) -> Option<NameClass> {\n-    let _p = profile::span(\"classify_name\");\n+    pub fn classify(sema: &Semantics<RootDatabase>, name: &ast::Name) -> Option<NameClass> {\n+        let _p = profile::span(\"classify_name\");\n \n-    let parent = name.syntax().parent()?;\n+        let parent = name.syntax().parent()?;\n \n-    if let Some(bind_pat) = ast::IdentPat::cast(parent.clone()) {\n-        if let Some(def) = sema.resolve_bind_pat_to_const(&bind_pat) {\n-            return Some(NameClass::ConstReference(Definition::ModuleDef(def)));\n+        if let Some(bind_pat) = ast::IdentPat::cast(parent.clone()) {\n+            if let Some(def) = sema.resolve_bind_pat_to_const(&bind_pat) {\n+                return Some(NameClass::ConstReference(Definition::ModuleDef(def)));\n+            }\n         }\n-    }\n \n-    match_ast! {\n-        match parent {\n-            ast::Rename(it) => {\n-                if let Some(use_tree) = it.syntax().parent().and_then(ast::UseTree::cast) {\n-                    let path = use_tree.path()?;\n-                    let path_segment = path.segment()?;\n-                    let name_ref_class = path_segment\n-                        .name_ref()\n-                        // The rename might be from a `self` token, so fallback to the name higher\n-                        // in the use tree.\n-                        .or_else(||{\n-                            if path_segment.self_token().is_none() {\n-                                return None;\n-                            }\n+        match_ast! {\n+            match parent {\n+                ast::Rename(it) => {\n+                    if let Some(use_tree) = it.syntax().parent().and_then(ast::UseTree::cast) {\n+                        let path = use_tree.path()?;\n+                        let path_segment = path.segment()?;\n+                        let name_ref_class = path_segment\n+                            .name_ref()\n+                            // The rename might be from a `self` token, so fallback to the name higher\n+                            // in the use tree.\n+                            .or_else(||{\n+                                if path_segment.self_token().is_none() {\n+                                    return None;\n+                                }\n \n-                            let use_tree = use_tree\n-                                .syntax()\n-                                .parent()\n-                                .as_ref()\n-                                // Skip over UseTreeList\n-                                .and_then(SyntaxNode::parent)\n-                                .and_then(ast::UseTree::cast)?;\n-                            let path = use_tree.path()?;\n-                            let path_segment = path.segment()?;\n-                            path_segment.name_ref()\n-                        })\n-                        .and_then(|name_ref| classify_name_ref(sema, &name_ref))?;\n+                                let use_tree = use_tree\n+                                    .syntax()\n+                                    .parent()\n+                                    .as_ref()\n+                                    // Skip over UseTreeList\n+                                    .and_then(SyntaxNode::parent)\n+                                    .and_then(ast::UseTree::cast)?;\n+                                let path = use_tree.path()?;\n+                                let path_segment = path.segment()?;\n+                                path_segment.name_ref()\n+                            })\n+                            .and_then(|name_ref| NameRefClass::classify(sema, &name_ref))?;\n \n-                    Some(NameClass::Definition(name_ref_class.definition(sema.db)))\n-                } else {\n-                    let extern_crate = it.syntax().parent().and_then(ast::ExternCrate::cast)?;\n-                    let resolved = sema.resolve_extern_crate(&extern_crate)?;\n-                    Some(NameClass::ExternCrate(resolved))\n-                }\n-            },\n-            ast::IdentPat(it) => {\n-                let local = sema.to_def(&it)?;\n+                        Some(NameClass::Definition(name_ref_class.referenced(sema.db)))\n+                    } else {\n+                        let extern_crate = it.syntax().parent().and_then(ast::ExternCrate::cast)?;\n+                        let resolved = sema.resolve_extern_crate(&extern_crate)?;\n+                        Some(NameClass::ExternCrate(resolved))\n+                    }\n+                },\n+                ast::IdentPat(it) => {\n+                    let local = sema.to_def(&it)?;\n \n-                if let Some(record_pat_field) = it.syntax().parent().and_then(ast::RecordPatField::cast) {\n-                    if record_pat_field.name_ref().is_none() {\n-                        if let Some(field) = sema.resolve_record_pat_field(&record_pat_field) {\n-                            let field = Definition::Field(field);\n-                            return Some(NameClass::FieldShorthand { local, field });\n+                    if let Some(record_pat_field) = it.syntax().parent().and_then(ast::RecordPatField::cast) {\n+                        if record_pat_field.name_ref().is_none() {\n+                            if let Some(field) = sema.resolve_record_pat_field(&record_pat_field) {\n+                                let field = Definition::Field(field);\n+                                return Some(NameClass::PatFieldShorthand { local_def: local, field_ref: field });\n+                            }\n                         }\n                     }\n-                }\n \n-                Some(NameClass::Definition(Definition::Local(local)))\n-            },\n-            ast::RecordField(it) => {\n-                let field: hir::Field = sema.to_def(&it)?;\n-                Some(NameClass::Definition(Definition::Field(field)))\n-            },\n-            ast::Module(it) => {\n-                let def = sema.to_def(&it)?;\n-                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n-            },\n-            ast::Struct(it) => {\n-                let def: hir::Struct = sema.to_def(&it)?;\n-                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n-            },\n-            ast::Union(it) => {\n-                let def: hir::Union = sema.to_def(&it)?;\n-                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n-            },\n-            ast::Enum(it) => {\n-                let def: hir::Enum = sema.to_def(&it)?;\n-                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n-            },\n-            ast::Trait(it) => {\n-                let def: hir::Trait = sema.to_def(&it)?;\n-                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n-            },\n-            ast::Static(it) => {\n-                let def: hir::Static = sema.to_def(&it)?;\n-                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n-            },\n-            ast::Variant(it) => {\n-                let def: hir::EnumVariant = sema.to_def(&it)?;\n-                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n-            },\n-            ast::Fn(it) => {\n-                let def: hir::Function = sema.to_def(&it)?;\n-                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n-            },\n-            ast::Const(it) => {\n-                let def: hir::Const = sema.to_def(&it)?;\n-                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n-            },\n-            ast::TypeAlias(it) => {\n-                let def: hir::TypeAlias = sema.to_def(&it)?;\n-                Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n-            },\n-            ast::MacroCall(it) => {\n-                let def = sema.to_def(&it)?;\n-                Some(NameClass::Definition(Definition::Macro(def)))\n-            },\n-            ast::TypeParam(it) => {\n-                let def = sema.to_def(&it)?;\n-                Some(NameClass::Definition(Definition::TypeParam(def)))\n-            },\n-            _ => None,\n+                    Some(NameClass::Definition(Definition::Local(local)))\n+                },\n+                ast::RecordField(it) => {\n+                    let field: hir::Field = sema.to_def(&it)?;\n+                    Some(NameClass::Definition(Definition::Field(field)))\n+                },\n+                ast::Module(it) => {\n+                    let def = sema.to_def(&it)?;\n+                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                },\n+                ast::Struct(it) => {\n+                    let def: hir::Struct = sema.to_def(&it)?;\n+                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                },\n+                ast::Union(it) => {\n+                    let def: hir::Union = sema.to_def(&it)?;\n+                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                },\n+                ast::Enum(it) => {\n+                    let def: hir::Enum = sema.to_def(&it)?;\n+                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                },\n+                ast::Trait(it) => {\n+                    let def: hir::Trait = sema.to_def(&it)?;\n+                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                },\n+                ast::Static(it) => {\n+                    let def: hir::Static = sema.to_def(&it)?;\n+                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                },\n+                ast::Variant(it) => {\n+                    let def: hir::EnumVariant = sema.to_def(&it)?;\n+                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                },\n+                ast::Fn(it) => {\n+                    let def: hir::Function = sema.to_def(&it)?;\n+                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                },\n+                ast::Const(it) => {\n+                    let def: hir::Const = sema.to_def(&it)?;\n+                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                },\n+                ast::TypeAlias(it) => {\n+                    let def: hir::TypeAlias = sema.to_def(&it)?;\n+                    Some(NameClass::Definition(Definition::ModuleDef(def.into())))\n+                },\n+                ast::MacroCall(it) => {\n+                    let def = sema.to_def(&it)?;\n+                    Some(NameClass::Definition(Definition::Macro(def)))\n+                },\n+                ast::TypeParam(it) => {\n+                    let def = sema.to_def(&it)?;\n+                    Some(NameClass::Definition(Definition::TypeParam(def)))\n+                },\n+                _ => None,\n+            }\n         }\n     }\n }\n@@ -229,102 +235,109 @@ pub fn classify_name(sema: &Semantics<RootDatabase>, name: &ast::Name) -> Option\n pub enum NameRefClass {\n     ExternCrate(Crate),\n     Definition(Definition),\n-    FieldShorthand { local: Local, field: Definition },\n+    FieldShorthand { local_ref: Local, field_ref: Definition },\n }\n \n impl NameRefClass {\n-    pub fn definition(self, db: &dyn HirDatabase) -> Definition {\n+    /// `Definition`, which this name refers to.\n+    pub fn referenced(self, db: &dyn HirDatabase) -> Definition {\n         match self {\n             NameRefClass::ExternCrate(krate) => Definition::ModuleDef(krate.root_module(db).into()),\n             NameRefClass::Definition(def) => def,\n-            NameRefClass::FieldShorthand { local, field: _ } => Definition::Local(local),\n+            NameRefClass::FieldShorthand { local_ref, field_ref: _ } => {\n+                // FIXME: this is inherently ambiguous -- this name refers to\n+                // two different defs....\n+                Definition::Local(local_ref)\n+            }\n         }\n     }\n-}\n \n-// Note: we don't have unit-tests for this rather important function.\n-// It is primarily exercised via goto definition tests in `ide`.\n-pub fn classify_name_ref(\n-    sema: &Semantics<RootDatabase>,\n-    name_ref: &ast::NameRef,\n-) -> Option<NameRefClass> {\n-    let _p = profile::span(\"classify_name_ref\");\n+    // Note: we don't have unit-tests for this rather important function.\n+    // It is primarily exercised via goto definition tests in `ide`.\n+    pub fn classify(\n+        sema: &Semantics<RootDatabase>,\n+        name_ref: &ast::NameRef,\n+    ) -> Option<NameRefClass> {\n+        let _p = profile::span(\"classify_name_ref\");\n \n-    let parent = name_ref.syntax().parent()?;\n+        let parent = name_ref.syntax().parent()?;\n \n-    if let Some(method_call) = ast::MethodCallExpr::cast(parent.clone()) {\n-        if let Some(func) = sema.resolve_method_call(&method_call) {\n-            return Some(NameRefClass::Definition(Definition::ModuleDef(func.into())));\n+        if let Some(method_call) = ast::MethodCallExpr::cast(parent.clone()) {\n+            if let Some(func) = sema.resolve_method_call(&method_call) {\n+                return Some(NameRefClass::Definition(Definition::ModuleDef(func.into())));\n+            }\n         }\n-    }\n \n-    if let Some(field_expr) = ast::FieldExpr::cast(parent.clone()) {\n-        if let Some(field) = sema.resolve_field(&field_expr) {\n-            return Some(NameRefClass::Definition(Definition::Field(field)));\n+        if let Some(field_expr) = ast::FieldExpr::cast(parent.clone()) {\n+            if let Some(field) = sema.resolve_field(&field_expr) {\n+                return Some(NameRefClass::Definition(Definition::Field(field)));\n+            }\n         }\n-    }\n \n-    if let Some(record_field) = ast::RecordExprField::for_field_name(name_ref) {\n-        if let Some((field, local)) = sema.resolve_record_field(&record_field) {\n-            let field = Definition::Field(field);\n-            let res = match local {\n-                None => NameRefClass::Definition(field),\n-                Some(local) => NameRefClass::FieldShorthand { field, local },\n-            };\n-            return Some(res);\n+        if let Some(record_field) = ast::RecordExprField::for_field_name(name_ref) {\n+            if let Some((field, local)) = sema.resolve_record_field(&record_field) {\n+                let field = Definition::Field(field);\n+                let res = match local {\n+                    None => NameRefClass::Definition(field),\n+                    Some(local) => {\n+                        NameRefClass::FieldShorthand { field_ref: field, local_ref: local }\n+                    }\n+                };\n+                return Some(res);\n+            }\n         }\n-    }\n \n-    if let Some(record_pat_field) = ast::RecordPatField::cast(parent.clone()) {\n-        if let Some(field) = sema.resolve_record_pat_field(&record_pat_field) {\n-            let field = Definition::Field(field);\n-            return Some(NameRefClass::Definition(field));\n+        if let Some(record_pat_field) = ast::RecordPatField::cast(parent.clone()) {\n+            if let Some(field) = sema.resolve_record_pat_field(&record_pat_field) {\n+                let field = Definition::Field(field);\n+                return Some(NameRefClass::Definition(field));\n+            }\n         }\n-    }\n \n-    if ast::AssocTypeArg::cast(parent.clone()).is_some() {\n-        // `Trait<Assoc = Ty>`\n-        //        ^^^^^\n-        let path = name_ref.syntax().ancestors().find_map(ast::Path::cast)?;\n-        let resolved = sema.resolve_path(&path)?;\n-        if let PathResolution::Def(ModuleDef::Trait(tr)) = resolved {\n-            if let Some(ty) = tr\n-                .items(sema.db)\n-                .iter()\n-                .filter_map(|assoc| match assoc {\n-                    hir::AssocItem::TypeAlias(it) => Some(*it),\n-                    _ => None,\n-                })\n-                .find(|alias| alias.name(sema.db).to_string() == **name_ref.text())\n-            {\n-                return Some(NameRefClass::Definition(Definition::ModuleDef(\n-                    ModuleDef::TypeAlias(ty),\n-                )));\n+        if ast::AssocTypeArg::cast(parent.clone()).is_some() {\n+            // `Trait<Assoc = Ty>`\n+            //        ^^^^^\n+            let path = name_ref.syntax().ancestors().find_map(ast::Path::cast)?;\n+            let resolved = sema.resolve_path(&path)?;\n+            if let PathResolution::Def(ModuleDef::Trait(tr)) = resolved {\n+                if let Some(ty) = tr\n+                    .items(sema.db)\n+                    .iter()\n+                    .filter_map(|assoc| match assoc {\n+                        hir::AssocItem::TypeAlias(it) => Some(*it),\n+                        _ => None,\n+                    })\n+                    .find(|alias| alias.name(sema.db).to_string() == **name_ref.text())\n+                {\n+                    return Some(NameRefClass::Definition(Definition::ModuleDef(\n+                        ModuleDef::TypeAlias(ty),\n+                    )));\n+                }\n             }\n         }\n-    }\n \n-    if let Some(macro_call) = parent.ancestors().find_map(ast::MacroCall::cast) {\n-        if let Some(path) = macro_call.path() {\n-            if path.qualifier().is_none() {\n-                // Only use this to resolve single-segment macro calls like `foo!()`. Multi-segment\n-                // paths are handled below (allowing `log<|>::info!` to resolve to the log crate).\n-                if let Some(macro_def) = sema.resolve_macro_call(&macro_call) {\n-                    return Some(NameRefClass::Definition(Definition::Macro(macro_def)));\n+        if let Some(macro_call) = parent.ancestors().find_map(ast::MacroCall::cast) {\n+            if let Some(path) = macro_call.path() {\n+                if path.qualifier().is_none() {\n+                    // Only use this to resolve single-segment macro calls like `foo!()`. Multi-segment\n+                    // paths are handled below (allowing `log<|>::info!` to resolve to the log crate).\n+                    if let Some(macro_def) = sema.resolve_macro_call(&macro_call) {\n+                        return Some(NameRefClass::Definition(Definition::Macro(macro_def)));\n+                    }\n                 }\n             }\n         }\n-    }\n \n-    if let Some(path) = name_ref.syntax().ancestors().find_map(ast::Path::cast) {\n-        if let Some(resolved) = sema.resolve_path(&path) {\n-            return Some(NameRefClass::Definition(resolved.into()));\n+        if let Some(path) = name_ref.syntax().ancestors().find_map(ast::Path::cast) {\n+            if let Some(resolved) = sema.resolve_path(&path) {\n+                return Some(NameRefClass::Definition(resolved.into()));\n+            }\n         }\n-    }\n \n-    let extern_crate = ast::ExternCrate::cast(parent)?;\n-    let resolved = sema.resolve_extern_crate(&extern_crate)?;\n-    Some(NameRefClass::ExternCrate(resolved))\n+        let extern_crate = ast::ExternCrate::cast(parent)?;\n+        let resolved = sema.resolve_extern_crate(&extern_crate)?;\n+        Some(NameRefClass::ExternCrate(resolved))\n+    }\n }\n \n impl From<PathResolution> for Definition {"}, {"sha": "df74be00bb20861a4e7039825cf240c3071cacbd", "filename": "crates/ide_db/src/imports_locator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4/crates%2Fide_db%2Fsrc%2Fimports_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4/crates%2Fide_db%2Fsrc%2Fimports_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fimports_locator.rs?ref=d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4", "patch": "@@ -5,7 +5,7 @@ use hir::{Crate, MacroDef, ModuleDef, Semantics};\n use syntax::{ast, AstNode, SyntaxKind::NAME};\n \n use crate::{\n-    defs::{classify_name, Definition},\n+    defs::{Definition, NameClass},\n     symbol_index::{self, FileSymbol, Query},\n     RootDatabase,\n };\n@@ -60,5 +60,5 @@ fn get_name_definition<'a>(\n         candidate_node\n     };\n     let name = ast::Name::cast(candidate_name_node)?;\n-    classify_name(sema, &name)?.into_definition(sema.db)\n+    NameClass::classify(sema, &name)?.defined(sema.db)\n }"}, {"sha": "a243352406eeb9afe66fb701cec509ca54f2d027", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=d8c6e192f7b35c57e7ff9d167ab10db8a8cd90b4", "patch": "@@ -14,7 +14,7 @@ use syntax::{ast, match_ast, AstNode, TextRange, TextSize};\n \n use crate::defs::NameClass;\n use crate::{\n-    defs::{classify_name, classify_name_ref, Definition, NameRefClass},\n+    defs::{Definition, NameRefClass},\n     RootDatabase,\n };\n \n@@ -276,7 +276,7 @@ impl<'a> FindUsages<'a> {\n         name_ref: &ast::NameRef,\n         sink: &mut dyn FnMut(Reference) -> bool,\n     ) -> bool {\n-        match classify_name_ref(self.sema, &name_ref) {\n+        match NameRefClass::classify(self.sema, &name_ref) {\n             Some(NameRefClass::Definition(def)) if &def == self.def => {\n                 let kind = if is_record_lit_name_ref(&name_ref) || is_call_expr_name_ref(&name_ref)\n                 {\n@@ -292,7 +292,7 @@ impl<'a> FindUsages<'a> {\n                 };\n                 sink(reference)\n             }\n-            Some(NameRefClass::FieldShorthand { local, field }) => {\n+            Some(NameRefClass::FieldShorthand { local_ref: local, field_ref: field }) => {\n                 let reference = match self.def {\n                     Definition::Field(_) if &field == self.def => Reference {\n                         file_range: self.sema.original_range(name_ref.syntax()),\n@@ -313,10 +313,10 @@ impl<'a> FindUsages<'a> {\n     }\n \n     fn found_name(&self, name: &ast::Name, sink: &mut dyn FnMut(Reference) -> bool) -> bool {\n-        match classify_name(self.sema, name) {\n-            Some(NameClass::FieldShorthand { local: _, field }) => {\n+        match NameClass::classify(self.sema, name) {\n+            Some(NameClass::PatFieldShorthand { local_def: _, field_ref }) => {\n                 let reference = match self.def {\n-                    Definition::Field(_) if &field == self.def => Reference {\n+                    Definition::Field(_) if &field_ref == self.def => Reference {\n                         file_range: self.sema.original_range(name.syntax()),\n                         kind: ReferenceKind::FieldShorthandForField,\n                         // FIXME: mutable patterns should have `Write` access"}]}