{"sha": "c8041dd8ac780425f880e5e4e00d055e3bd0bece", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4MDQxZGQ4YWM3ODA0MjVmODgwZTVlNGUwMGQwNTVlM2JkMGJlY2U=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-01-23T12:31:11Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-02-08T11:16:30Z"}, "message": "Add `AutoBorrowMutability`; its like `hir::Mutability`  but w/ two-phase borrow info too.\n\nNamely, the mutable borrows also carries a flag indicating whether\nthey should support two-phase borrows.\n\nThis allows us to thread down, from the point of the borrow's\nintroduction, whether the particular adjustment that created it is one\nthat yields two-phase mutable borrows.", "tree": {"sha": "064b83242068272c751b6521101953e400460b73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/064b83242068272c751b6521101953e400460b73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8041dd8ac780425f880e5e4e00d055e3bd0bece", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8041dd8ac780425f880e5e4e00d055e3bd0bece", "html_url": "https://github.com/rust-lang/rust/commit/c8041dd8ac780425f880e5e4e00d055e3bd0bece", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8041dd8ac780425f880e5e4e00d055e3bd0bece/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1855ab742458cc4359e27deadbdf3d8747ce361d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1855ab742458cc4359e27deadbdf3d8747ce361d", "html_url": "https://github.com/rust-lang/rust/commit/1855ab742458cc4359e27deadbdf3d8747ce361d"}], "stats": {"total": 182, "additions": 154, "deletions": 28}, "files": [{"sha": "d1e431597e7455237c7683d78dc88115177cf4fa", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c8041dd8ac780425f880e5e4e00d055e3bd0bece/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8041dd8ac780425f880e5e4e00d055e3bd0bece/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=c8041dd8ac780425f880e5e4e00d055e3bd0bece", "patch": "@@ -163,6 +163,20 @@ impl_stable_hash_for!(struct ty::adjustment::Adjustment<'tcx> { kind, target });\n impl_stable_hash_for!(struct ty::adjustment::OverloadedDeref<'tcx> { region, mutbl });\n impl_stable_hash_for!(struct ty::UpvarBorrow<'tcx> { kind, region });\n \n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::adjustment::AutoBorrowMutability {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            ty::adjustment::AutoBorrowMutability::Mutable { ref allow_two_phase_borrow } => {\n+                allow_two_phase_borrow.hash_stable(hcx, hasher);\n+            }\n+            ty::adjustment::AutoBorrowMutability::Immutable => {}\n+        }\n+    }\n+}\n+\n impl_stable_hash_for!(struct ty::UpvarId { var_id, closure_expr_id });\n \n impl_stable_hash_for!(enum ty::BorrowKind {"}, {"sha": "7db75a516689896067ed41770e55f14b5fe61230", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8041dd8ac780425f880e5e4e00d055e3bd0bece/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8041dd8ac780425f880e5e4e00d055e3bd0bece/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=c8041dd8ac780425f880e5e4e00d055e3bd0bece", "patch": "@@ -760,7 +760,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                                      expr.span,\n                                      cmt_base,\n                                      r,\n-                                     ty::BorrowKind::from_mutbl(m),\n+                                     ty::BorrowKind::from_mutbl(m.into()),\n                                      AutoRef);\n             }\n "}, {"sha": "7579d95a8fe6822f2a14818d8f93bcc9a6906272", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c8041dd8ac780425f880e5e4e00d055e3bd0bece/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8041dd8ac780425f880e5e4e00d055e3bd0bece/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=c8041dd8ac780425f880e5e4e00d055e3bd0bece", "patch": "@@ -119,10 +119,25 @@ impl<'a, 'gcx, 'tcx> OverloadedDeref<'tcx> {\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n+pub enum AutoBorrowMutability {\n+    Mutable { allow_two_phase_borrow: bool },\n+    Immutable,\n+}\n+\n+impl From<AutoBorrowMutability> for hir::Mutability {\n+    fn from(m: AutoBorrowMutability) -> Self {\n+        match m {\n+            AutoBorrowMutability::Mutable { .. } => hir::MutMutable,\n+            AutoBorrowMutability::Immutable => hir::MutImmutable,\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n pub enum AutoBorrow<'tcx> {\n     /// Convert from T to &T.\n-    Ref(ty::Region<'tcx>, hir::Mutability),\n+    Ref(ty::Region<'tcx>, AutoBorrowMutability),\n \n     /// Convert from T to *T.\n     RawPtr(hir::Mutability),"}, {"sha": "439533fae49d915d8e9bdb546355c82e7f6952a1", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c8041dd8ac780425f880e5e4e00d055e3bd0bece/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8041dd8ac780425f880e5e4e00d055e3bd0bece/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=c8041dd8ac780425f880e5e4e00d055e3bd0bece", "patch": "@@ -437,8 +437,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAllocation {\n         for adj in cx.tables.expr_adjustments(e) {\n             if let adjustment::Adjust::Borrow(adjustment::AutoBorrow::Ref(_, m)) = adj.kind {\n                 let msg = match m {\n-                    hir::MutImmutable => \"unnecessary allocation, use & instead\",\n-                    hir::MutMutable => \"unnecessary allocation, use &mut instead\"\n+                    adjustment::AutoBorrowMutability::Immutable =>\n+                        \"unnecessary allocation, use & instead\",\n+                    adjustment::AutoBorrowMutability::Mutable { .. }=>\n+                        \"unnecessary allocation, use &mut instead\"\n                 };\n                 cx.span_lint(UNUSED_ALLOCATION, e.span, msg);\n             }"}, {"sha": "00ab2e4599528f3de48828ff454a454f83b75042", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c8041dd8ac780425f880e5e4e00d055e3bd0bece/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8041dd8ac780425f880e5e4e00d055e3bd0bece/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=c8041dd8ac780425f880e5e4e00d055e3bd0bece", "patch": "@@ -17,7 +17,7 @@ use hair::cx::to_ref::ToRef;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, AdtKind, VariantDef, Ty};\n-use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::cast::CastKind as TyCastKind;\n use rustc::hir;\n use rustc::hir::def_id::LocalDefId;\n@@ -112,7 +112,7 @@ fn apply_adjustment<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 span,\n                 kind: ExprKind::Borrow {\n                     region: deref.region,\n-                    borrow_kind: to_borrow_kind(deref.mutbl, true),\n+                    borrow_kind: deref.mutbl.to_borrow_kind(),\n                     arg: expr.to_ref(),\n                 },\n             };\n@@ -122,7 +122,7 @@ fn apply_adjustment<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         Adjust::Borrow(AutoBorrow::Ref(r, m)) => {\n             ExprKind::Borrow {\n                 region: r,\n-                borrow_kind: to_borrow_kind(m, true),\n+                borrow_kind: m.to_borrow_kind(),\n                 arg: expr.to_ref(),\n             }\n         }\n@@ -142,7 +142,7 @@ fn apply_adjustment<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 span,\n                 kind: ExprKind::Borrow {\n                     region,\n-                    borrow_kind: to_borrow_kind(m, true),\n+                    borrow_kind: m.to_borrow_kind(),\n                     arg: expr.to_ref(),\n                 },\n             };\n@@ -288,7 +288,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             };\n             ExprKind::Borrow {\n                 region,\n-                borrow_kind: to_borrow_kind(mutbl, false),\n+                borrow_kind: mutbl.to_borrow_kind(),\n                 arg: expr.to_ref(),\n             }\n         }\n@@ -643,10 +643,25 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     }\n }\n \n-fn to_borrow_kind(m: hir::Mutability, allow_two_phase_borrow: bool) -> BorrowKind {\n-    match m {\n-        hir::MutMutable => BorrowKind::Mut { allow_two_phase_borrow },\n-        hir::MutImmutable => BorrowKind::Shared,\n+trait ToBorrowKind { fn to_borrow_kind(&self) -> BorrowKind; }\n+\n+impl ToBorrowKind for AutoBorrowMutability {\n+    fn to_borrow_kind(&self) -> BorrowKind {\n+        match *self {\n+            AutoBorrowMutability::Mutable { allow_two_phase_borrow } =>\n+                BorrowKind::Mut { allow_two_phase_borrow },\n+            AutoBorrowMutability::Immutable =>\n+                BorrowKind::Shared,\n+        }\n+    }\n+}\n+\n+impl ToBorrowKind for hir::Mutability {\n+    fn to_borrow_kind(&self) -> BorrowKind {\n+        match *self {\n+            hir::MutMutable => BorrowKind::Mut { allow_two_phase_borrow: false },\n+            hir::MutImmutable => BorrowKind::Shared,\n+        }\n     }\n }\n "}, {"sha": "3d61ffe39336a5b7778948cb8b2d6c36cc32a539", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c8041dd8ac780425f880e5e4e00d055e3bd0bece/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8041dd8ac780425f880e5e4e00d055e3bd0bece/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=c8041dd8ac780425f880e5e4e00d055e3bd0bece", "patch": "@@ -16,7 +16,7 @@ use hir::def::Def;\n use hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::{infer, traits};\n use rustc::ty::{self, TyCtxt, TypeFoldable, Ty};\n-use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability};\n use syntax::abi;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n@@ -176,8 +176,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let mut autoref = None;\n                     if borrow {\n                         if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n+                            let mutbl = match mt.mutbl {\n+                                hir::MutImmutable => AutoBorrowMutability::Immutable,\n+                                hir::MutMutable => AutoBorrowMutability::Mutable {\n+                                    // For initial two-phase borrow\n+                                    // deployment, conservatively omit\n+                                    // overloaded function call ops.\n+                                    allow_two_phase_borrow: false,\n+                                }\n+                            };\n                             autoref = Some(Adjustment {\n-                                kind: Adjust::Borrow(AutoBorrow::Ref(region, mt.mutbl)),\n+                                kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n                                 target: method.sig.inputs()[0]\n                             });\n                         }"}, {"sha": "47e4b0272bed416bc07f0caf21300b1e7e4204d7", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c8041dd8ac780425f880e5e4e00d055e3bd0bece/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8041dd8ac780425f880e5e4e00d055e3bd0bece/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=c8041dd8ac780425f880e5e4e00d055e3bd0bece", "patch": "@@ -68,7 +68,7 @@ use rustc::infer::{Coercion, InferResult, InferOk};\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::lint;\n use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n-use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::{self, TypeAndMut, Ty, ClosureSubsts};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::error::TypeError;\n@@ -421,8 +421,17 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             ty::TyRef(r_borrow, _) => r_borrow,\n             _ => span_bug!(span, \"expected a ref type, got {:?}\", ty),\n         };\n+        let mutbl = match mt_b.mutbl {\n+            hir::MutImmutable => AutoBorrowMutability::Immutable,\n+            hir::MutMutable => AutoBorrowMutability::Mutable {\n+                // Deref-coercion is a case where we deliberately\n+                // disallow two-phase borrows in its initial\n+                // deployment; see discussion on PR #47489.\n+                allow_two_phase_borrow: false,\n+            }\n+        };\n         adjustments.push(Adjustment {\n-            kind: Adjust::Borrow(AutoBorrow::Ref(r_borrow, mt_b.mutbl)),\n+            kind: Adjust::Borrow(AutoBorrow::Ref(r_borrow, mutbl)),\n             target: ty\n         });\n \n@@ -461,11 +470,17 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n                 let coercion = Coercion(self.cause.span);\n                 let r_borrow = self.next_region_var(coercion);\n+                let mutbl = match mt_b.mutbl {\n+                    hir::MutImmutable => AutoBorrowMutability::Immutable,\n+                    hir::MutMutable => AutoBorrowMutability::Mutable {\n+                        allow_two_phase_borrow: false,\n+                    }\n+                };\n                 Some((Adjustment {\n                     kind: Adjust::Deref(None),\n                     target: mt_a.ty\n                 }, Adjustment {\n-                    kind: Adjust::Borrow(AutoBorrow::Ref(r_borrow, mt_b.mutbl)),\n+                    kind: Adjust::Borrow(AutoBorrow::Ref(r_borrow, mutbl)),\n                     target:  self.tcx.mk_ref(r_borrow, ty::TypeAndMut {\n                         mutbl: mt_b.mutbl,\n                         ty: mt_a.ty\n@@ -871,6 +886,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 ] => {\n                     match self.node_ty(expr.hir_id).sty {\n                         ty::TyRef(_, mt_orig) => {\n+                            let mutbl_adj: hir::Mutability = mutbl_adj.into();\n                             // Reborrow that we can safely ignore, because\n                             // the next adjustment can only be a Deref\n                             // which will be merged into it."}, {"sha": "20d58991496459403ebaf132dab3fc9e48ed93e8", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c8041dd8ac780425f880e5e4e00d055e3bd0bece/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8041dd8ac780425f880e5e4e00d055e3bd0bece/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=c8041dd8ac780425f880e5e4e00d055e3bd0bece", "patch": "@@ -17,7 +17,7 @@ use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, Ty};\n use rustc::ty::subst::Subst;\n-use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, OverloadedDeref};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability, OverloadedDeref};\n use rustc::ty::fold::TypeFoldable;\n use rustc::infer::{self, InferOk};\n use syntax_pos::Span;\n@@ -165,14 +165,22 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                 mutbl,\n                 ty: target\n             });\n+            let mutbl = match mutbl {\n+                hir::MutImmutable => AutoBorrowMutability::Immutable,\n+                hir::MutMutable => AutoBorrowMutability::Mutable {\n+                    // Method call receivers are the primary use case\n+                    // for two-phase borrows.\n+                    allow_two_phase_borrow: true,\n+                }\n+            };\n             adjustments.push(Adjustment {\n                 kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n                 target\n             });\n \n             if let Some(unsize_target) = pick.unsize {\n                 target = self.tcx.mk_ref(region, ty::TypeAndMut {\n-                    mutbl,\n+                    mutbl: mutbl.into(),\n                     ty: unsize_target\n                 });\n                 adjustments.push(Adjustment {\n@@ -530,10 +538,19 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             for adjustment in &mut adjustments[..] {\n                 if let Adjust::Borrow(AutoBorrow::Ref(..)) = adjustment.kind {\n                     debug!(\"convert_place_op_to_mutable: converting autoref {:?}\", adjustment);\n+                    let mutbl = match mutbl {\n+                        hir::MutImmutable => AutoBorrowMutability::Immutable,\n+                        hir::MutMutable => AutoBorrowMutability::Mutable {\n+                            // For initial two-phase borrow\n+                            // deployment, conservatively omit\n+                            // overloaded operators.\n+                            allow_two_phase_borrow: false,\n+                        }\n+                    };\n                     adjustment.kind = Adjust::Borrow(AutoBorrow::Ref(region, mutbl));\n                     adjustment.target = self.tcx.mk_ref(region, ty::TypeAndMut {\n                         ty: source,\n-                        mutbl\n+                        mutbl: mutbl.into(),\n                     });\n                 }\n                 source = adjustment.target;"}, {"sha": "47bf085c9c05bc9ee4120b460d0f8bbed6531a59", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c8041dd8ac780425f880e5e4e00d055e3bd0bece/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8041dd8ac780425f880e5e4e00d055e3bd0bece/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c8041dd8ac780425f880e5e4e00d055e3bd0bece", "patch": "@@ -96,7 +96,7 @@ use rustc::middle::region;\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, FulfillmentContext, ObligationCause, ObligationCauseCode};\n use rustc::ty::{self, Ty, TyCtxt, Visibility, ToPredicate};\n-use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n+use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::maps::Providers;\n use rustc::ty::util::{Representability, IntTypeExt};\n@@ -2357,8 +2357,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 let mut adjustments = autoderef.adjust_steps(needs);\n                 if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n+                    let mutbl = match mt.mutbl {\n+                        hir::MutImmutable => AutoBorrowMutability::Immutable,\n+                        hir::MutMutable => AutoBorrowMutability::Mutable {\n+                            // FIXME (#46747): arguably indexing is\n+                            // \"just another kind of call\"; perhaps it\n+                            // would be more consistent to allow\n+                            // two-phase borrows for .index()\n+                            // receivers here.\n+                            allow_two_phase_borrow: false,\n+                        }\n+                    };\n                     adjustments.push(Adjustment {\n-                        kind: Adjust::Borrow(AutoBorrow::Ref(region, mt.mutbl)),\n+                        kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n                         target: self.tcx.mk_ref(region, ty::TypeAndMut {\n                             mutbl: mt.mutbl,\n                             ty: adjusted_ty\n@@ -3646,8 +3657,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 expr.span, oprnd_t, needs) {\n                             let method = self.register_infer_ok_obligations(ok);\n                             if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n+                                let mutbl = match mt.mutbl {\n+                                    hir::MutImmutable => AutoBorrowMutability::Immutable,\n+                                    hir::MutMutable => AutoBorrowMutability::Mutable {\n+                                        // (It shouldn't actually matter for unary ops whether\n+                                        // we enable two-phase borrows or not, since a unary\n+                                        // op has no additional operands.)\n+                                        allow_two_phase_borrow: false,\n+                                    }\n+                                };\n                                 self.apply_adjustments(oprnd, vec![Adjustment {\n-                                    kind: Adjust::Borrow(AutoBorrow::Ref(region, mt.mutbl)),\n+                                    kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n                                     target: method.sig.inputs()[0]\n                                 }]);\n                             }"}, {"sha": "a6776a0fe8612f75d7776a772f0d11f6b9496d3c", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c8041dd8ac780425f880e5e4e00d055e3bd0bece/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8041dd8ac780425f880e5e4e00d055e3bd0bece/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=c8041dd8ac780425f880e5e4e00d055e3bd0bece", "patch": "@@ -14,7 +14,7 @@ use super::{FnCtxt, Needs};\n use super::method::MethodCallee;\n use rustc::ty::{self, Ty, TypeFoldable, TypeVariants};\n use rustc::ty::TypeVariants::{TyStr, TyRef};\n-use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability};\n use rustc::infer::type_variable::TypeVariableOrigin;\n use errors;\n use syntax_pos::Span;\n@@ -198,17 +198,35 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let by_ref_binop = !op.node.is_by_value();\n                 if is_assign == IsAssign::Yes || by_ref_binop {\n                     if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n+                        let mutbl = match mt.mutbl {\n+                            hir::MutImmutable => AutoBorrowMutability::Immutable,\n+                            hir::MutMutable => AutoBorrowMutability::Mutable {\n+                                // For initial two-phase borrow\n+                                // deployment, conservatively omit\n+                                // overloaded binary ops.\n+                                allow_two_phase_borrow: false,\n+                            }\n+                        };\n                         let autoref = Adjustment {\n-                            kind: Adjust::Borrow(AutoBorrow::Ref(region, mt.mutbl)),\n+                            kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n                             target: method.sig.inputs()[0]\n                         };\n                         self.apply_adjustments(lhs_expr, vec![autoref]);\n                     }\n                 }\n                 if by_ref_binop {\n                     if let ty::TyRef(region, mt) = method.sig.inputs()[1].sty {\n+                        let mutbl = match mt.mutbl {\n+                            hir::MutImmutable => AutoBorrowMutability::Immutable,\n+                            hir::MutMutable => AutoBorrowMutability::Mutable {\n+                                // For initial two-phase borrow\n+                                // deployment, conservatively omit\n+                                // overloaded binary ops.\n+                                allow_two_phase_borrow: false,\n+                            }\n+                        };\n                         let autoref = Adjustment {\n-                            kind: Adjust::Borrow(AutoBorrow::Ref(region, mt.mutbl)),\n+                            kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n                             target: method.sig.inputs()[1]\n                         };\n                         // HACK(eddyb) Bypass checks due to reborrows being in"}, {"sha": "b5bf59fef9afc7852232a473f04168b7551b6abb", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8041dd8ac780425f880e5e4e00d055e3bd0bece/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8041dd8ac780425f880e5e4e00d055e3bd0bece/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=c8041dd8ac780425f880e5e4e00d055e3bd0bece", "patch": "@@ -1063,7 +1063,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         match *autoref {\n             adjustment::AutoBorrow::Ref(r, m) => {\n                 self.link_region(expr.span, r,\n-                                 ty::BorrowKind::from_mutbl(m), expr_cmt);\n+                                 ty::BorrowKind::from_mutbl(m.into()), expr_cmt);\n             }\n \n             adjustment::AutoBorrow::RawPtr(m) => {"}]}