{"sha": "25825cd4fa735c4b6d8b004940709bc066477c7c", "node_id": "C_kwDOAAsO6NoAKDI1ODI1Y2Q0ZmE3MzVjNGI2ZDhiMDA0OTQwNzA5YmMwNjY0NzdjN2M", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2022-07-26T17:49:24Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2022-08-04T14:26:52Z"}, "message": "Extract create_and_capture_lifetime_defs function", "tree": {"sha": "a2a149a7ad2165ffa37bde49c429c3fd91c9c418", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2a149a7ad2165ffa37bde49c429c3fd91c9c418"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25825cd4fa735c4b6d8b004940709bc066477c7c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEF0ntrgrd9qf9uuThgTGiTgx5768FAmLr1ywACgkQgTGiTgx5\n76/6iQ//cRqYVl+SFp7n6iDEBPjGyovS4H5alFo7MLM9yCoquxJ8IdF25Acq4LLR\nIAbB16s4/K50ewuh2FmlBujLvmowqL2m640/KszpwaerDlSuAJ5YljZx7SUgQiAL\nqaUBBWBP9SUAPXuoxlz+7C/qVXDC10y9lftSuj2zICZcbrdGrYEM3rH5grpXjpTy\nB+gparxt1rWCiGWrtotsRArIhZYO8SnBmrB8n2nifWm5pwCIv41HCRzrbOxaX3E1\nKGbRyeeS4J+SFvzddNxJxmpscxy/HWB/VJSRnW4bEqsKT8RXhZ9uf6GB224G9Rb4\nlxnPFgaQUaUbNfot47NT0mUm44hQYAVOvXPcgRxgD0FRiZh+FQVWvBcLVcDWuYlq\nkaUl3XPrebJ7Lw6AcBb+069SpGrTTvHxK+tLp9hFO2/6P5Bw4tC1n1/xh1PbOhqo\noj6aaDdLRZ/qHVhfdpNccKDXvmuuh9RehsUzv5Obf7oi56ydmIWLfySCZnAdG8vR\n48dTF3kcscqEO3RgNKk4PDbWW0uLecaaNZL+WUHB1aZDLFiQ7cUeAdCgNHPQIMqx\ndy7pb20wGCYyLc5vaH9RlDe1I6ImheyDDy1XLQtq16OnF9SSdiNI0Pa5XflBsaTn\nphXG+Se18Bq1LKwY2hlsZ8Q4Zhd+9ITViVcaWLFmGOyJ2QwsCQc=\n=1CoM\n-----END PGP SIGNATURE-----", "payload": "tree a2a149a7ad2165ffa37bde49c429c3fd91c9c418\nparent fac763168f35bc24b83c435d4d7009dca648432b\nauthor Santiago Pastorino <spastorino@gmail.com> 1658857764 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1659623212 -0300\n\nExtract create_and_capture_lifetime_defs function\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25825cd4fa735c4b6d8b004940709bc066477c7c", "html_url": "https://github.com/rust-lang/rust/commit/25825cd4fa735c4b6d8b004940709bc066477c7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25825cd4fa735c4b6d8b004940709bc066477c7c/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fac763168f35bc24b83c435d4d7009dca648432b", "url": "https://api.github.com/repos/rust-lang/rust/commits/fac763168f35bc24b83c435d4d7009dca648432b", "html_url": "https://github.com/rust-lang/rust/commit/fac763168f35bc24b83c435d4d7009dca648432b"}], "stats": {"total": 155, "additions": 81, "deletions": 74}, "files": [{"sha": "9009ae7a0510f2407a48fb1070205db6276aa975", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 81, "deletions": 74, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/25825cd4fa735c4b6d8b004940709bc066477c7c/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25825cd4fa735c4b6d8b004940709bc066477c7c/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=25825cd4fa735c4b6d8b004940709bc066477c7c", "patch": "@@ -1392,80 +1392,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 debug!(?lifetimes_in_bounds);\n                 debug!(?binders_to_ignore);\n \n-                for lifetime in &lifetimes_in_bounds {\n-                    let ident = lifetime.ident;\n-                    let span = ident.span;\n-\n-                    let res =\n-                        lctx.resolver.get_lifetime_res(lifetime.id).unwrap_or(LifetimeRes::Error);\n-                    debug!(?res);\n-\n-                    if let Some(mut captured_lifetimes) = lctx.captured_lifetimes.take() {\n-                        match res {\n-                            LifetimeRes::Param { param, binder } => {\n-                                if !captured_lifetimes.binders_to_ignore.contains(&binder)\n-                                    && !binders_to_ignore\n-                                        .get(&lifetime.id)\n-                                        .unwrap_or(&Vec::new())\n-                                        .contains(&binder)\n-                                {\n-                                    match captured_lifetimes.captures.entry(param) {\n-                                        Entry::Occupied(_) => {}\n-                                        Entry::Vacant(v) => {\n-                                            let node_id = lctx.next_node_id();\n-                                            let name = ParamName::Plain(ident);\n-\n-                                            lctx.create_def(\n-                                                captured_lifetimes.parent_def_id,\n-                                                node_id,\n-                                                DefPathData::LifetimeNs(name.ident().name),\n-                                            );\n-\n-                                            v.insert((span, node_id, name, res));\n-                                        }\n-                                    }\n-                                }\n-                            }\n-\n-                            LifetimeRes::Fresh { param, binder } => {\n-                                debug_assert_eq!(ident.name, kw::UnderscoreLifetime);\n-                                if !captured_lifetimes.binders_to_ignore.contains(&binder)\n-                                    && !binders_to_ignore\n-                                        .get(&lifetime.id)\n-                                        .unwrap_or(&Vec::new())\n-                                        .contains(&binder)\n-                                {\n-                                    let param = lctx.local_def_id(param);\n-                                    match captured_lifetimes.captures.entry(param) {\n-                                        Entry::Occupied(_) => {}\n-                                        Entry::Vacant(v) => {\n-                                            let node_id = lctx.next_node_id();\n-\n-                                            let name = ParamName::Fresh;\n-\n-                                            lctx.create_def(\n-                                                captured_lifetimes.parent_def_id,\n-                                                node_id,\n-                                                DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n-                                            );\n-\n-                                            v.insert((span, node_id, name, res));\n-                                        }\n-                                    }\n-                                }\n-                            }\n-\n-                            LifetimeRes::Infer | LifetimeRes::Static | LifetimeRes::Error => {}\n-\n-                            res => panic!(\n-                                \"Unexpected lifetime resolution {:?} for {:?} at {:?}\",\n-                                res, lifetime.ident, lifetime.ident.span\n-                            ),\n-                        }\n-\n-                        lctx.captured_lifetimes = Some(captured_lifetimes);\n-                    }\n-                }\n+                lctx.create_and_capture_lifetime_defs(&lifetimes_in_bounds, &binders_to_ignore);\n \n                 let ret = lctx.lower_param_bounds(bounds, itctx, false);\n \n@@ -1554,6 +1481,86 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         hir::OwnerNode::Item(self.arena.alloc(opaque_ty_item))\n     }\n \n+    fn create_and_capture_lifetime_defs(\n+        &mut self,\n+        lifetimes_in_bounds: &[&Lifetime],\n+        binders_to_ignore: &FxHashMap<NodeId, Vec<NodeId>>,\n+    ) {\n+        for lifetime in lifetimes_in_bounds {\n+            let ident = lifetime.ident;\n+            let span = ident.span;\n+\n+            let res = self.resolver.get_lifetime_res(lifetime.id).unwrap_or(LifetimeRes::Error);\n+            debug!(?res);\n+\n+            if let Some(mut captured_lifetimes) = self.captured_lifetimes.take() {\n+                match res {\n+                    LifetimeRes::Param { param, binder } => {\n+                        if !captured_lifetimes.binders_to_ignore.contains(&binder)\n+                            && !binders_to_ignore\n+                                .get(&lifetime.id)\n+                                .unwrap_or(&Vec::new())\n+                                .contains(&binder)\n+                        {\n+                            match captured_lifetimes.captures.entry(param) {\n+                                Entry::Occupied(_) => {}\n+                                Entry::Vacant(v) => {\n+                                    let node_id = self.next_node_id();\n+                                    let name = ParamName::Plain(ident);\n+\n+                                    self.create_def(\n+                                        captured_lifetimes.parent_def_id,\n+                                        node_id,\n+                                        DefPathData::LifetimeNs(name.ident().name),\n+                                    );\n+\n+                                    v.insert((span, node_id, name, res));\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    LifetimeRes::Fresh { param, binder } => {\n+                        debug_assert_eq!(ident.name, kw::UnderscoreLifetime);\n+                        if !captured_lifetimes.binders_to_ignore.contains(&binder)\n+                            && !binders_to_ignore\n+                                .get(&lifetime.id)\n+                                .unwrap_or(&Vec::new())\n+                                .contains(&binder)\n+                        {\n+                            let param = self.local_def_id(param);\n+                            match captured_lifetimes.captures.entry(param) {\n+                                Entry::Occupied(_) => {}\n+                                Entry::Vacant(v) => {\n+                                    let node_id = self.next_node_id();\n+\n+                                    let name = ParamName::Fresh;\n+\n+                                    self.create_def(\n+                                        captured_lifetimes.parent_def_id,\n+                                        node_id,\n+                                        DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n+                                    );\n+\n+                                    v.insert((span, node_id, name, res));\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    LifetimeRes::Infer | LifetimeRes::Static | LifetimeRes::Error => {}\n+\n+                    res => panic!(\n+                        \"Unexpected lifetime resolution {:?} for {:?} at {:?}\",\n+                        res, lifetime.ident, lifetime.ident.span\n+                    ),\n+                }\n+\n+                self.captured_lifetimes = Some(captured_lifetimes);\n+            }\n+        }\n+    }\n+\n     fn lower_fn_params_to_names(&mut self, decl: &FnDecl) -> &'hir [Ident] {\n         // Skip the `...` (`CVarArgs`) trailing arguments from the AST,\n         // as they are not explicit in HIR/Ty function signatures."}]}