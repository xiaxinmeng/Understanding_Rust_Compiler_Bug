{"sha": "1fb6912cfd07812b106ad4e1bf9705a57b6f0ef6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmYjY5MTJjZmQwNzgxMmIxMDZhZDRlMWJmOTcwNWE1N2I2ZjBlZjY=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-11-12T18:37:54Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-11-12T18:37:54Z"}, "message": "Rustup to rustc 1.32.0-nightly (ca79ecd69 2018-11-11)\n\nI had to put the original source of liballoc_system in tree, because it got removed from rustc", "tree": {"sha": "7303497f71224378fb0d23d56f1b05cdb86cd672", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7303497f71224378fb0d23d56f1b05cdb86cd672"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fb6912cfd07812b106ad4e1bf9705a57b6f0ef6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fb6912cfd07812b106ad4e1bf9705a57b6f0ef6", "html_url": "https://github.com/rust-lang/rust/commit/1fb6912cfd07812b106ad4e1bf9705a57b6f0ef6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fb6912cfd07812b106ad4e1bf9705a57b6f0ef6/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef5d16178d7743bf0e6a11c63c55855822f2693b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef5d16178d7743bf0e6a11c63c55855822f2693b", "html_url": "https://github.com/rust-lang/rust/commit/ef5d16178d7743bf0e6a11c63c55855822f2693b"}], "stats": {"total": 412, "additions": 399, "deletions": 13}, "files": [{"sha": "bdd3615d6e4f6b3b568f98c6b9c643203bea77db", "filename": "0001-Disable-stdsimd.patch", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1fb6912cfd07812b106ad4e1bf9705a57b6f0ef6/0001-Disable-stdsimd.patch", "raw_url": "https://github.com/rust-lang/rust/raw/1fb6912cfd07812b106ad4e1bf9705a57b6f0ef6/0001-Disable-stdsimd.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/0001-Disable-stdsimd.patch?ref=1fb6912cfd07812b106ad4e1bf9705a57b6f0ef6", "patch": "@@ -1,6 +1,6 @@\n-From 17e82251ba8f36149c03aee327de8b4054e6c88e Mon Sep 17 00:00:00 2001\n+From fd6acae580c2be9e8ba9c32b013df4e9547d936f Mon Sep 17 00:00:00 2001\n From: bjorn3 <bjorn3@users.noreply.github.com>\n-Date: Sat, 6 Oct 2018 11:07:31 +0200\n+Date: Mon, 12 Nov 2018 19:08:45 +0100\n Subject: [PATCH] Disable stdsimd\n \n ---\n@@ -9,35 +9,35 @@ Subject: [PATCH] Disable stdsimd\n  2 files changed, 4 insertions(+)\n \n diff --git a/src/libcore/lib.rs b/src/libcore/lib.rs\n-index 0211b05..cd224f1 100644\n+index c69d444..1b7abad 100644\n --- a/src/libcore/lib.rs\n +++ b/src/libcore/lib.rs\n-@@ -226,6 +226,7 @@ mod nonzero;\n+@@ -228,6 +228,7 @@ mod nonzero;\n  mod tuple;\n  mod unit;\n  \n +/*\n- // Pull in the the `coresimd` crate directly into libcore. This is where all the\n+ // Pull in the `coresimd` crate directly into libcore. This is where all the\n  // architecture-specific (and vendor-specific) intrinsics are defined. AKA\n  // things like SIMD and such. Note that the actual source for all this lies in a\n-@@ -254,3 +255,4 @@ mod coresimd;\n+@@ -256,3 +257,4 @@ mod coresimd;\n  #[stable(feature = \"simd_arch\", since = \"1.27.0\")]\n  #[cfg(not(stage0))]\n  pub use coresimd::arch;\n +*/\n diff --git a/src/libstd/lib.rs b/src/libstd/lib.rs\n-index c58bd36..4768e8b 100644\n+index f460d10..6110b05 100644\n --- a/src/libstd/lib.rs\n +++ b/src/libstd/lib.rs\n-@@ -501,6 +501,7 @@ mod memchr;\n+@@ -493,6 +493,7 @@ mod memchr;\n  // compiler\n  pub mod rt;\n  \n +/*\n- // Pull in the the `stdsimd` crate directly into libstd. This is the same as\n+ // Pull in the `stdsimd` crate directly into libstd. This is the same as\n  // libcore's arch/simd modules where the source of truth here is in a different\n  // repository, but we pull things in here manually to get it into libstd.\n-@@ -525,6 +526,7 @@ mod coresimd {\n+@@ -517,6 +518,7 @@ mod coresimd {\n  #[stable(feature = \"simd_arch\", since = \"1.27.0\")]\n  #[cfg(all(not(stage0), not(test)))]\n  pub use stdsimd::arch;\n@@ -46,5 +46,5 @@ index c58bd36..4768e8b 100644\n  // Include a number of private modules that exist solely to provide\n  // the rustdoc documentation for primitive types. Using `include!`\n -- \n-2.17.1 (Apple Git-112)\n+2.11.0\n "}, {"sha": "ae146c48e3aac7a39a9b9eb9190f6b8ad1691646", "filename": "alloc_system/Cargo.toml", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1fb6912cfd07812b106ad4e1bf9705a57b6f0ef6/alloc_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1fb6912cfd07812b106ad4e1bf9705a57b6f0ef6/alloc_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/alloc_system%2FCargo.toml?ref=1fb6912cfd07812b106ad4e1bf9705a57b6f0ef6", "patch": "@@ -0,0 +1,16 @@\n+[package]\n+authors = [\"The Rust Project Developers\", \"bjorn3 (edited to be usable outside the rust source)\"]\n+name = \"alloc_system\"\n+version = \"0.0.0\"\n+[lib]\n+name = \"alloc_system\"\n+path = \"lib.rs\"\n+test = false\n+doc = false\n+[dependencies]\n+core = { path = \"../libcore\" }\n+libc = { path = \"../rustc/libc_shim\" }\n+compiler_builtins = { path = \"../rustc/compiler_builtins_shim\" }\n+# See comments in the source for what this dependency is\n+[target.'cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))'.dependencies]\n+dlmalloc = { path = \"../rustc/dlmalloc_shim\" }"}, {"sha": "74b52a6497e17af74e69ab486b7b0c865ed2a9c6", "filename": "alloc_system/lib.rs", "status": "added", "additions": 365, "deletions": 0, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/1fb6912cfd07812b106ad4e1bf9705a57b6f0ef6/alloc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb6912cfd07812b106ad4e1bf9705a57b6f0ef6/alloc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/alloc_system%2Flib.rs?ref=1fb6912cfd07812b106ad4e1bf9705a57b6f0ef6", "patch": "@@ -0,0 +1,365 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![no_std]\n+#![allow(unused_attributes)]\n+#![unstable(feature = \"alloc_system\",\n+            reason = \"this library is unlikely to be stabilized in its current \\\n+                      form or name\",\n+            issue = \"32838\")]\n+#![feature(allocator_api)]\n+#![feature(core_intrinsics)]\n+#![feature(nll)]\n+#![feature(staged_api)]\n+#![feature(rustc_attrs)]\n+#![cfg_attr(\n+    all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n+    feature(integer_atomics, stdsimd)\n+)]\n+#![cfg_attr(any(unix, target_os = \"cloudabi\", target_os = \"redox\"), feature(libc))]\n+#![rustc_alloc_kind = \"lib\"]\n+// The minimum alignment guaranteed by the architecture. This value is used to\n+// add fast paths for low alignment values.\n+#[cfg(all(any(target_arch = \"x86\",\n+              target_arch = \"arm\",\n+              target_arch = \"mips\",\n+              target_arch = \"powerpc\",\n+              target_arch = \"powerpc64\",\n+              target_arch = \"asmjs\",\n+              target_arch = \"wasm32\")))]\n+#[allow(dead_code)]\n+const MIN_ALIGN: usize = 8;\n+#[cfg(all(any(target_arch = \"x86_64\",\n+              target_arch = \"aarch64\",\n+              target_arch = \"mips64\",\n+              target_arch = \"s390x\",\n+              target_arch = \"sparc64\")))]\n+#[allow(dead_code)]\n+const MIN_ALIGN: usize = 16;\n+use core::alloc::{Alloc, GlobalAlloc, AllocErr, Layout};\n+use core::ptr::NonNull;\n+/// The default memory allocator provided by the operating system.\n+///\n+/// This is based on `malloc` on Unix platforms and `HeapAlloc` on Windows,\n+/// plus related functions.\n+///\n+/// This type can be used in a `static` item\n+/// with the `#[global_allocator]` attribute\n+/// to force the global allocator to be the system\u2019s one.\n+/// (The default is jemalloc for executables, on some platforms.)\n+///\n+/// ```rust\n+/// use std::alloc::System;\n+///\n+/// #[global_allocator]\n+/// static A: System = System;\n+///\n+/// fn main() {\n+///     let a = Box::new(4); // Allocates from the system allocator.\n+///     println!(\"{}\", a);\n+/// }\n+/// ```\n+///\n+/// It can also be used directly to allocate memory\n+/// independently of the standard library\u2019s global allocator.\n+#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n+pub struct System;\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+unsafe impl Alloc for System {\n+    #[inline]\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n+        NonNull::new(GlobalAlloc::alloc(self, layout)).ok_or(AllocErr)\n+    }\n+    #[inline]\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n+        NonNull::new(GlobalAlloc::alloc_zeroed(self, layout)).ok_or(AllocErr)\n+    }\n+    #[inline]\n+    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n+        GlobalAlloc::dealloc(self, ptr.as_ptr(), layout)\n+    }\n+    #[inline]\n+    unsafe fn realloc(&mut self,\n+                      ptr: NonNull<u8>,\n+                      layout: Layout,\n+                      new_size: usize) -> Result<NonNull<u8>, AllocErr> {\n+        NonNull::new(GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)\n+    }\n+}\n+#[cfg(any(windows, unix, target_os = \"cloudabi\", target_os = \"redox\"))]\n+mod realloc_fallback {\n+    use core::alloc::{GlobalAlloc, Layout};\n+    use core::cmp;\n+    use core::ptr;\n+    impl super::System {\n+        pub(crate) unsafe fn realloc_fallback(&self, ptr: *mut u8, old_layout: Layout,\n+                                              new_size: usize) -> *mut u8 {\n+            // Docs for GlobalAlloc::realloc require this to be valid:\n+            let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n+            let new_ptr = GlobalAlloc::alloc(self, new_layout);\n+            if !new_ptr.is_null() {\n+                let size = cmp::min(old_layout.size(), new_size);\n+                ptr::copy_nonoverlapping(ptr, new_ptr, size);\n+                GlobalAlloc::dealloc(self, ptr, old_layout);\n+            }\n+            new_ptr\n+        }\n+    }\n+}\n+#[cfg(any(unix, target_os = \"cloudabi\", target_os = \"redox\"))]\n+mod platform {\n+    extern crate libc;\n+    use core::ptr;\n+    use MIN_ALIGN;\n+    use System;\n+    use core::alloc::{GlobalAlloc, Layout};\n+    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n+    unsafe impl GlobalAlloc for System {\n+        #[inline]\n+        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+            if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n+                libc::malloc(layout.size()) as *mut u8\n+            } else {\n+                #[cfg(target_os = \"macos\")]\n+                {\n+                    if layout.align() > (1 << 31) {\n+                        return ptr::null_mut()\n+                    }\n+                }\n+                aligned_malloc(&layout)\n+            }\n+        }\n+        #[inline]\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+            if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n+                libc::calloc(layout.size(), 1) as *mut u8\n+            } else {\n+                let ptr = self.alloc(layout.clone());\n+                if !ptr.is_null() {\n+                    ptr::write_bytes(ptr, 0, layout.size());\n+                }\n+                ptr\n+            }\n+        }\n+        #[inline]\n+        unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {\n+            libc::free(ptr as *mut libc::c_void)\n+        }\n+        #[inline]\n+        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+            if layout.align() <= MIN_ALIGN && layout.align() <= new_size {\n+                libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8\n+            } else {\n+                self.realloc_fallback(ptr, layout, new_size)\n+            }\n+        }\n+    }\n+    #[cfg(any(target_os = \"android\",\n+              target_os = \"hermit\",\n+              target_os = \"redox\",\n+              target_os = \"solaris\"))]\n+    #[inline]\n+    unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n+        // On android we currently target API level 9 which unfortunately\n+        // doesn't have the `posix_memalign` API used below. Instead we use\n+        // `memalign`, but this unfortunately has the property on some systems\n+        // where the memory returned cannot be deallocated by `free`!\n+        //\n+        // Upon closer inspection, however, this appears to work just fine with\n+        // Android, so for this platform we should be fine to call `memalign`\n+        // (which is present in API level 9). Some helpful references could\n+        // possibly be chromium using memalign [1], attempts at documenting that\n+        // memalign + free is ok [2] [3], or the current source of chromium\n+        // which still uses memalign on android [4].\n+        //\n+        // [1]: https://codereview.chromium.org/10796020/\n+        // [2]: https://code.google.com/p/android/issues/detail?id=35391\n+        // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n+        // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n+        //                                       /memory/aligned_memory.cc\n+        libc::memalign(layout.align(), layout.size()) as *mut u8\n+    }\n+    #[cfg(not(any(target_os = \"android\",\n+                  target_os = \"hermit\",\n+                  target_os = \"redox\",\n+                  target_os = \"solaris\")))]\n+    #[inline]\n+    unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n+        let mut out = ptr::null_mut();\n+        let ret = libc::posix_memalign(&mut out, layout.align(), layout.size());\n+        if ret != 0 {\n+            ptr::null_mut()\n+        } else {\n+            out as *mut u8\n+        }\n+    }\n+}\n+#[cfg(windows)]\n+#[allow(nonstandard_style)]\n+mod platform {\n+    use MIN_ALIGN;\n+    use System;\n+    use core::alloc::{GlobalAlloc, Layout};\n+    type LPVOID = *mut u8;\n+    type HANDLE = LPVOID;\n+    type SIZE_T = usize;\n+    type DWORD = u32;\n+    type BOOL = i32;\n+    extern \"system\" {\n+        fn GetProcessHeap() -> HANDLE;\n+        fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) -> LPVOID;\n+        fn HeapReAlloc(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID, dwBytes: SIZE_T) -> LPVOID;\n+        fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID) -> BOOL;\n+        fn GetLastError() -> DWORD;\n+    }\n+    #[repr(C)]\n+    struct Header(*mut u8);\n+    const HEAP_ZERO_MEMORY: DWORD = 0x00000008;\n+    unsafe fn get_header<'a>(ptr: *mut u8) -> &'a mut Header {\n+        &mut *(ptr as *mut Header).offset(-1)\n+    }\n+    unsafe fn align_ptr(ptr: *mut u8, align: usize) -> *mut u8 {\n+        let aligned = ptr.add(align - (ptr as usize & (align - 1)));\n+        *get_header(aligned) = Header(ptr);\n+        aligned\n+    }\n+    #[inline]\n+    unsafe fn allocate_with_flags(layout: Layout, flags: DWORD) -> *mut u8 {\n+        let ptr = if layout.align() <= MIN_ALIGN {\n+            HeapAlloc(GetProcessHeap(), flags, layout.size())\n+        } else {\n+            let size = layout.size() + layout.align();\n+            let ptr = HeapAlloc(GetProcessHeap(), flags, size);\n+            if ptr.is_null() {\n+                ptr\n+            } else {\n+                align_ptr(ptr, layout.align())\n+            }\n+        };\n+        ptr as *mut u8\n+    }\n+    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n+    unsafe impl GlobalAlloc for System {\n+        #[inline]\n+        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+            allocate_with_flags(layout, 0)\n+        }\n+        #[inline]\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+            allocate_with_flags(layout, HEAP_ZERO_MEMORY)\n+        }\n+        #[inline]\n+        unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+            if layout.align() <= MIN_ALIGN {\n+                let err = HeapFree(GetProcessHeap(), 0, ptr as LPVOID);\n+                debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n+                              GetLastError());\n+            } else {\n+                let header = get_header(ptr);\n+                let err = HeapFree(GetProcessHeap(), 0, header.0 as LPVOID);\n+                debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n+                              GetLastError());\n+            }\n+        }\n+        #[inline]\n+        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+            if layout.align() <= MIN_ALIGN {\n+                HeapReAlloc(GetProcessHeap(), 0, ptr as LPVOID, new_size) as *mut u8\n+            } else {\n+                self.realloc_fallback(ptr, layout, new_size)\n+            }\n+        }\n+    }\n+}\n+// This is an implementation of a global allocator on the wasm32 platform when\n+// emscripten is not in use. In that situation there's no actual runtime for us\n+// to lean on for allocation, so instead we provide our own!\n+//\n+// The wasm32 instruction set has two instructions for getting the current\n+// amount of memory and growing the amount of memory. These instructions are the\n+// foundation on which we're able to build an allocator, so we do so! Note that\n+// the instructions are also pretty \"global\" and this is the \"global\" allocator\n+// after all!\n+//\n+// The current allocator here is the `dlmalloc` crate which we've got included\n+// in the rust-lang/rust repository as a submodule. The crate is a port of\n+// dlmalloc.c from C to Rust and is basically just so we can have \"pure Rust\"\n+// for now which is currently technically required (can't link with C yet).\n+//\n+// The crate itself provides a global allocator which on wasm has no\n+// synchronization as there are no threads!\n+#[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))]\n+mod platform {\n+    extern crate dlmalloc;\n+    use core::alloc::{GlobalAlloc, Layout};\n+    use System;\n+    static mut DLMALLOC: dlmalloc::Dlmalloc = dlmalloc::DLMALLOC_INIT;\n+    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n+    unsafe impl GlobalAlloc for System {\n+        #[inline]\n+        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+            let _lock = lock::lock();\n+            DLMALLOC.malloc(layout.size(), layout.align())\n+        }\n+        #[inline]\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+            let _lock = lock::lock();\n+            DLMALLOC.calloc(layout.size(), layout.align())\n+        }\n+        #[inline]\n+        unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+            let _lock = lock::lock();\n+            DLMALLOC.free(ptr, layout.size(), layout.align())\n+        }\n+        #[inline]\n+        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+            let _lock = lock::lock();\n+            DLMALLOC.realloc(ptr, layout.size(), layout.align(), new_size)\n+        }\n+    }\n+    #[cfg(target_feature = \"atomics\")]\n+    mod lock {\n+        use core::arch::wasm32;\n+        use core::sync::atomic::{AtomicI32, Ordering::SeqCst};\n+        static LOCKED: AtomicI32 = AtomicI32::new(0);\n+        pub struct DropLock;\n+        pub fn lock() -> DropLock {\n+            loop {\n+                if LOCKED.swap(1, SeqCst) == 0 {\n+                    return DropLock\n+                }\n+                unsafe {\n+                    let r = wasm32::atomic::wait_i32(\n+                        &LOCKED as *const AtomicI32 as *mut i32,\n+                        1,  // expected value\n+                        -1, // timeout\n+                    );\n+                    debug_assert!(r == 0 || r == 1);\n+                }\n+            }\n+        }\n+        impl Drop for DropLock {\n+            fn drop(&mut self) {\n+                let r = LOCKED.swap(0, SeqCst);\n+                debug_assert_eq!(r, 1);\n+                unsafe {\n+                    wasm32::atomic::wake(\n+                        &LOCKED as *const AtomicI32 as *mut i32,\n+                        1, // only one thread\n+                    );\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(not(target_feature = \"atomics\"))]\n+    mod lock {\n+        #[inline]\n+        pub fn lock() {} // no atomics, no threads, that's easy!\n+    }\n+}"}, {"sha": "ce13f80816f80e3838c3bedd8a96f1ebd0a956f3", "filename": "prepare_libcore.sh", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1fb6912cfd07812b106ad4e1bf9705a57b6f0ef6/prepare_libcore.sh", "raw_url": "https://github.com/rust-lang/rust/raw/1fb6912cfd07812b106ad4e1bf9705a57b6f0ef6/prepare_libcore.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/prepare_libcore.sh?ref=1fb6912cfd07812b106ad4e1bf9705a57b6f0ef6", "patch": "@@ -13,10 +13,15 @@ rm -rf $DST_DIR\n mkdir -p $DST_DIR/src\n cp -r $SRC_DIR/src $DST_DIR/\n \n-cd $DST_DIR\n+pushd $DST_DIR\n git init\n git add .\n git commit -m \"Initial commit\" -q\n git apply ../../000*.patch\n+popd\n+\n+# `alloc_system` has been merged with libstd, which doesn't build yet.\n+# This copies the original source to the sysroot source dir to simplify building it\n+cp -r alloc_system $DST_DIR/src/liballoc_system\n \n echo \"Successfully prepared libcore for building\""}, {"sha": "2fef2be4c0283eab390582f786d2bb17ffcb7599", "filename": "xargo/Xargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fb6912cfd07812b106ad4e1bf9705a57b6f0ef6/xargo%2FXargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1fb6912cfd07812b106ad4e1bf9705a57b6f0ef6/xargo%2FXargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xargo%2FXargo.toml?ref=1fb6912cfd07812b106ad4e1bf9705a57b6f0ef6", "patch": "@@ -4,4 +4,4 @@ alloc = {}\n alloc_system = {}\n \n # Disabled due to missing support for many things (intrinsics, etc) in rustc_codegen_cranelift\n-#std = {features = [\"force_alloc_system\"]}\n+#std = {}"}]}