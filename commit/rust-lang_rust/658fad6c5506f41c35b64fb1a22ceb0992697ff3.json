{"sha": "658fad6c5506f41c35b64fb1a22ceb0992697ff3", "node_id": "C_kwDOAAsO6NoAKDY1OGZhZDZjNTUwNmY0MWMzNWI2NGZiMWEyMmNlYjA5OTI2OTdmZjM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-03T17:53:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-03T17:53:49Z"}, "message": "Auto merge of #107642 - Dylan-DPC:rollup-edcqhm5, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #107082 (Autotrait bounds on dyn-safe trait methods)\n - #107427 (Add candidates for DiscriminantKind builtin)\n - #107539 (Emit warnings on unused parens in index expressions)\n - #107544 (Improve `TokenCursor`.)\n - #107585 (Don't cause a cycle when formatting query description that references a FnDef)\n - #107633 (Fix suggestion for coercing Option<&String> to Option<&str>)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "d9beffb3e496848ea5acbe6d9caf2d102f473eab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9beffb3e496848ea5acbe6d9caf2d102f473eab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/658fad6c5506f41c35b64fb1a22ceb0992697ff3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/658fad6c5506f41c35b64fb1a22ceb0992697ff3", "html_url": "https://github.com/rust-lang/rust/commit/658fad6c5506f41c35b64fb1a22ceb0992697ff3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/658fad6c5506f41c35b64fb1a22ceb0992697ff3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9545094994f1ab45cab5799d5b45980871a9e97b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9545094994f1ab45cab5799d5b45980871a9e97b", "html_url": "https://github.com/rust-lang/rust/commit/9545094994f1ab45cab5799d5b45980871a9e97b"}, {"sha": "c9270272df5bd7254b6ce1c7b69d41c75e443406", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9270272df5bd7254b6ce1c7b69d41c75e443406", "html_url": "https://github.com/rust-lang/rust/commit/c9270272df5bd7254b6ce1c7b69d41c75e443406"}], "stats": {"total": 886, "additions": 684, "deletions": 202}, "files": [{"sha": "f0a6a5e0725860b5f090f8f6a12223ad13b868f1", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -41,7 +41,8 @@ use std::{fmt, iter};\n /// Nothing special happens to misnamed or misplaced `SubstNt`s.\n #[derive(Debug, Clone, PartialEq, Encodable, Decodable, HashStable_Generic)]\n pub enum TokenTree {\n-    /// A single token.\n+    /// A single token. Should never be `OpenDelim` or `CloseDelim`, because\n+    /// delimiters are implicitly represented by `Delimited`.\n     Token(Token, Spacing),\n     /// A delimited sequence of token trees.\n     Delimited(DelimSpan, Delimiter, TokenStream),\n@@ -388,12 +389,12 @@ impl TokenStream {\n         self.0.len()\n     }\n \n-    pub fn trees(&self) -> CursorRef<'_> {\n-        CursorRef::new(self)\n+    pub fn trees(&self) -> RefTokenTreeCursor<'_> {\n+        RefTokenTreeCursor::new(self)\n     }\n \n-    pub fn into_trees(self) -> Cursor {\n-        Cursor::new(self)\n+    pub fn into_trees(self) -> TokenTreeCursor {\n+        TokenTreeCursor::new(self)\n     }\n \n     /// Compares two `TokenStream`s, checking equality without regarding span information.\n@@ -551,24 +552,25 @@ impl TokenStream {\n     }\n }\n \n-/// By-reference iterator over a [`TokenStream`].\n+/// By-reference iterator over a [`TokenStream`], that produces `&TokenTree`\n+/// items.\n #[derive(Clone)]\n-pub struct CursorRef<'t> {\n+pub struct RefTokenTreeCursor<'t> {\n     stream: &'t TokenStream,\n     index: usize,\n }\n \n-impl<'t> CursorRef<'t> {\n+impl<'t> RefTokenTreeCursor<'t> {\n     fn new(stream: &'t TokenStream) -> Self {\n-        CursorRef { stream, index: 0 }\n+        RefTokenTreeCursor { stream, index: 0 }\n     }\n \n     pub fn look_ahead(&self, n: usize) -> Option<&TokenTree> {\n         self.stream.0.get(self.index + n)\n     }\n }\n \n-impl<'t> Iterator for CursorRef<'t> {\n+impl<'t> Iterator for RefTokenTreeCursor<'t> {\n     type Item = &'t TokenTree;\n \n     fn next(&mut self) -> Option<&'t TokenTree> {\n@@ -579,15 +581,16 @@ impl<'t> Iterator for CursorRef<'t> {\n     }\n }\n \n-/// Owning by-value iterator over a [`TokenStream`].\n+/// Owning by-value iterator over a [`TokenStream`], that produces `TokenTree`\n+/// items.\n // FIXME: Many uses of this can be replaced with by-reference iterator to avoid clones.\n #[derive(Clone)]\n-pub struct Cursor {\n+pub struct TokenTreeCursor {\n     pub stream: TokenStream,\n     index: usize,\n }\n \n-impl Iterator for Cursor {\n+impl Iterator for TokenTreeCursor {\n     type Item = TokenTree;\n \n     fn next(&mut self) -> Option<TokenTree> {\n@@ -598,9 +601,9 @@ impl Iterator for Cursor {\n     }\n }\n \n-impl Cursor {\n+impl TokenTreeCursor {\n     fn new(stream: TokenStream) -> Self {\n-        Cursor { stream, index: 0 }\n+        TokenTreeCursor { stream, index: 0 }\n     }\n \n     #[inline]\n@@ -614,6 +617,15 @@ impl Cursor {\n     pub fn look_ahead(&self, n: usize) -> Option<&TokenTree> {\n         self.stream.0.get(self.index + n)\n     }\n+\n+    // Replace the previously obtained token tree with `tts`, and rewind to\n+    // just before them.\n+    pub fn replace_prev_and_rewind(&mut self, tts: Vec<TokenTree>) {\n+        assert!(self.index > 0);\n+        self.index -= 1;\n+        let stream = Lrc::make_mut(&mut self.stream.0);\n+        stream.splice(self.index..self.index + 1, tts);\n+    }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Encodable, Decodable, HashStable_Generic)]"}, {"sha": "ad71dcdf9d95384421a94cf71d35277e8dde8b03", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -31,8 +31,8 @@ cfg_if! {\n         pub auto trait Send {}\n         pub auto trait Sync {}\n \n-        impl<T: ?Sized> Send for T {}\n-        impl<T: ?Sized> Sync for T {}\n+        impl<T> Send for T {}\n+        impl<T> Sync for T {}\n \n         #[macro_export]\n         macro_rules! rustc_erase_owner {"}, {"sha": "05ac8db0db88f893d64604f50fd86de7fa542026", "filename": "compiler/rustc_error_messages/locales/en-US/hir_typeck.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_typeck.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_typeck.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_typeck.ftl?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -61,3 +61,5 @@ hir_typeck_lang_start_incorrect_ret_ty = the return type of the `start` lang ite\n hir_typeck_help_set_edition_cargo = set `edition = \"{$edition}\"` in `Cargo.toml`\n hir_typeck_help_set_edition_standalone = pass `--edition {$edition}` to `rustc`\n hir_typeck_note_edition_guide = for more on editions, read https://doc.rust-lang.org/edition-guide\n+\n+hir_typeck_convert_to_str = try converting the passed type into a `&str`"}, {"sha": "de34df0114a743c2f89327d94c2cd7f13fbad9a9", "filename": "compiler/rustc_expand/src/mbe/metavar_expr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -1,5 +1,5 @@\n use rustc_ast::token::{self, Delimiter};\n-use rustc_ast::tokenstream::{CursorRef, TokenStream, TokenTree};\n+use rustc_ast::tokenstream::{RefTokenTreeCursor, TokenStream, TokenTree};\n use rustc_ast::{LitIntType, LitKind};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{Applicability, PResult};\n@@ -72,7 +72,7 @@ impl MetaVarExpr {\n \n // Checks if there are any remaining tokens. For example, `${ignore(ident ... a b c ...)}`\n fn check_trailing_token<'sess>(\n-    iter: &mut CursorRef<'_>,\n+    iter: &mut RefTokenTreeCursor<'_>,\n     sess: &'sess ParseSess,\n ) -> PResult<'sess, ()> {\n     if let Some(tt) = iter.next() {\n@@ -88,7 +88,7 @@ fn check_trailing_token<'sess>(\n \n /// Parse a meta-variable `count` expression: `count(ident[, depth])`\n fn parse_count<'sess>(\n-    iter: &mut CursorRef<'_>,\n+    iter: &mut RefTokenTreeCursor<'_>,\n     sess: &'sess ParseSess,\n     span: Span,\n ) -> PResult<'sess, MetaVarExpr> {\n@@ -99,7 +99,7 @@ fn parse_count<'sess>(\n \n /// Parses the depth used by index(depth) and length(depth).\n fn parse_depth<'sess>(\n-    iter: &mut CursorRef<'_>,\n+    iter: &mut RefTokenTreeCursor<'_>,\n     sess: &'sess ParseSess,\n     span: Span,\n ) -> PResult<'sess, usize> {\n@@ -126,7 +126,7 @@ fn parse_depth<'sess>(\n \n /// Parses an generic ident\n fn parse_ident<'sess>(\n-    iter: &mut CursorRef<'_>,\n+    iter: &mut RefTokenTreeCursor<'_>,\n     sess: &'sess ParseSess,\n     span: Span,\n ) -> PResult<'sess, Ident> {\n@@ -152,7 +152,7 @@ fn parse_ident<'sess>(\n \n /// Tries to move the iterator forward returning `true` if there is a comma. If not, then the\n /// iterator is not modified and the result is `false`.\n-fn try_eat_comma(iter: &mut CursorRef<'_>) -> bool {\n+fn try_eat_comma(iter: &mut RefTokenTreeCursor<'_>) -> bool {\n     if let Some(TokenTree::Token(token::Token { kind: token::Comma, .. }, _)) = iter.look_ahead(0) {\n         let _ = iter.next();\n         return true;"}, {"sha": "7d381d8902ac2f10ee913ac96fe7c98ec0d01613", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 183, "deletions": 40, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -8,7 +8,7 @@ use rustc_hir as hir;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::IgnoreRegions;\n use rustc_middle::ty::{\n-    self, ImplPolarity, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n+    self, AliasKind, ImplPolarity, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n };\n use rustc_session::lint;\n use rustc_span::def_id::{DefId, LocalDefId};\n@@ -86,7 +86,7 @@ fn do_orphan_check_impl<'tcx>(\n     // struct B { }\n     // impl Foo for A { }\n     // impl Foo for B { }\n-    // impl !Send for (A, B) { }\n+    // impl !Foo for (A, B) { }\n     // ```\n     //\n     // This final impl is legal according to the orphan\n@@ -99,50 +99,193 @@ fn do_orphan_check_impl<'tcx>(\n         tcx.trait_is_auto(trait_def_id)\n     );\n \n-    if tcx.trait_is_auto(trait_def_id) && !trait_def_id.is_local() {\n+    if tcx.trait_is_auto(trait_def_id) {\n         let self_ty = trait_ref.self_ty();\n-        let opt_self_def_id = match *self_ty.kind() {\n-            ty::Adt(self_def, _) => Some(self_def.did()),\n-            ty::Foreign(did) => Some(did),\n-            _ => None,\n-        };\n \n-        let msg = match opt_self_def_id {\n-            // We only want to permit nominal types, but not *all* nominal types.\n-            // They must be local to the current crate, so that people\n-            // can't do `unsafe impl Send for Rc<SomethingLocal>` or\n-            // `impl !Send for Box<SomethingLocalAndSend>`.\n-            Some(self_def_id) => {\n-                if self_def_id.is_local() {\n-                    None\n+        // If the impl is in the same crate as the auto-trait, almost anything\n+        // goes.\n+        //\n+        //     impl MyAuto for Rc<Something> {}  // okay\n+        //     impl<T> !MyAuto for *const T {}   // okay\n+        //     impl<T> MyAuto for T {}           // okay\n+        //\n+        // But there is one important exception: implementing for a trait object\n+        // is not allowed.\n+        //\n+        //     impl MyAuto for dyn Trait {}      // NOT OKAY\n+        //     impl<T: ?Sized> MyAuto for T {}   // NOT OKAY\n+        //\n+        // With this restriction, it's guaranteed that an auto-trait is\n+        // implemented for a trait object if and only if the auto-trait is one\n+        // of the trait object's trait bounds (or a supertrait of a bound). In\n+        // other words `dyn Trait + AutoTrait` always implements AutoTrait,\n+        // while `dyn Trait` never implements AutoTrait.\n+        //\n+        // This is necessary in order for autotrait bounds on methods of trait\n+        // objects to be sound.\n+        //\n+        //     auto trait AutoTrait {}\n+        //\n+        //     trait ObjectSafeTrait {\n+        //         fn f(&self) where Self: AutoTrait;\n+        //     }\n+        //\n+        // We can allow f to be called on `dyn ObjectSafeTrait + AutoTrait`.\n+        //\n+        // If we didn't deny `impl AutoTrait for dyn Trait`, it would be unsound\n+        // for the ObjectSafeTrait shown above to be object safe because someone\n+        // could take some type implementing ObjectSafeTrait but not AutoTrait,\n+        // unsize it to `dyn ObjectSafeTrait`, and call .f() which has no\n+        // concrete implementation (issue #50781).\n+        enum LocalImpl {\n+            Allow,\n+            Disallow { problematic_kind: &'static str },\n+        }\n+\n+        // If the auto-trait is from a dependency, it must only be getting\n+        // implemented for a nominal type, and specifically one local to the\n+        // current crate.\n+        //\n+        //     impl<T> Sync for MyStruct<T> {}   // okay\n+        //\n+        //     impl Sync for Rc<MyStruct> {}     // NOT OKAY\n+        enum NonlocalImpl {\n+            Allow,\n+            DisallowBecauseNonlocal,\n+            DisallowOther,\n+        }\n+\n+        // Exhaustive match considering that this logic is essential for\n+        // soundness.\n+        let (local_impl, nonlocal_impl) = match self_ty.kind() {\n+            // struct Struct<T>;\n+            // impl AutoTrait for Struct<Foo> {}\n+            ty::Adt(self_def, _) => (\n+                LocalImpl::Allow,\n+                if self_def.did().is_local() {\n+                    NonlocalImpl::Allow\n+                } else {\n+                    NonlocalImpl::DisallowBecauseNonlocal\n+                },\n+            ),\n+\n+            // extern { type OpaqueType; }\n+            // impl AutoTrait for OpaqueType {}\n+            ty::Foreign(did) => (\n+                LocalImpl::Allow,\n+                if did.is_local() {\n+                    NonlocalImpl::Allow\n                 } else {\n-                    Some((\n-                        format!(\n-                            \"cross-crate traits with a default impl, like `{}`, \\\n-                                    can only be implemented for a struct/enum type \\\n-                                    defined in the current crate\",\n-                            tcx.def_path_str(trait_def_id)\n-                        ),\n-                        \"can't implement cross-crate trait for type in another crate\",\n-                    ))\n+                    NonlocalImpl::DisallowBecauseNonlocal\n+                },\n+            ),\n+\n+            // impl AutoTrait for dyn Trait {}\n+            ty::Dynamic(..) => (\n+                LocalImpl::Disallow { problematic_kind: \"trait object\" },\n+                NonlocalImpl::DisallowOther,\n+            ),\n+\n+            // impl<T> AutoTrait for T {}\n+            // impl<T: ?Sized> AutoTrait for T {}\n+            ty::Param(..) => (\n+                if self_ty.is_sized(tcx, tcx.param_env(def_id)) {\n+                    LocalImpl::Allow\n+                } else {\n+                    LocalImpl::Disallow { problematic_kind: \"generic type\" }\n+                },\n+                NonlocalImpl::DisallowOther,\n+            ),\n+\n+            // trait Id { type This: ?Sized; }\n+            // impl<T: ?Sized> Id for T {\n+            //     type This = T;\n+            // }\n+            // impl<T: ?Sized> AutoTrait for <T as Id>::This {}\n+            ty::Alias(AliasKind::Projection, _) => (\n+                LocalImpl::Disallow { problematic_kind: \"associated type\" },\n+                NonlocalImpl::DisallowOther,\n+            ),\n+\n+            // type Opaque = impl Trait;\n+            // impl AutoTrait for Opaque {}\n+            ty::Alias(AliasKind::Opaque, _) => (\n+                LocalImpl::Disallow { problematic_kind: \"opaque type\" },\n+                NonlocalImpl::DisallowOther,\n+            ),\n+\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(..)\n+            | ty::Uint(..)\n+            | ty::Float(..)\n+            | ty::Str\n+            | ty::Array(..)\n+            | ty::Slice(..)\n+            | ty::RawPtr(..)\n+            | ty::Ref(..)\n+            | ty::FnDef(..)\n+            | ty::FnPtr(..)\n+            | ty::Never\n+            | ty::Tuple(..) => (LocalImpl::Allow, NonlocalImpl::DisallowOther),\n+\n+            ty::Closure(..)\n+            | ty::Generator(..)\n+            | ty::GeneratorWitness(..)\n+            | ty::GeneratorWitnessMIR(..)\n+            | ty::Bound(..)\n+            | ty::Placeholder(..)\n+            | ty::Infer(..) => span_bug!(sp, \"weird self type for autotrait impl\"),\n+\n+            ty::Error(..) => (LocalImpl::Allow, NonlocalImpl::Allow),\n+        };\n+\n+        if trait_def_id.is_local() {\n+            match local_impl {\n+                LocalImpl::Allow => {}\n+                LocalImpl::Disallow { problematic_kind } => {\n+                    let msg = format!(\n+                        \"traits with a default impl, like `{trait}`, \\\n+                                cannot be implemented for {problematic_kind} `{self_ty}`\",\n+                        trait = tcx.def_path_str(trait_def_id),\n+                    );\n+                    let label = format!(\n+                        \"a trait object implements `{trait}` if and only if `{trait}` \\\n+                                is one of the trait object's trait bounds\",\n+                        trait = tcx.def_path_str(trait_def_id),\n+                    );\n+                    let reported =\n+                        struct_span_err!(tcx.sess, sp, E0321, \"{}\", msg).note(label).emit();\n+                    return Err(reported);\n                 }\n             }\n-            _ => Some((\n-                format!(\n-                    \"cross-crate traits with a default impl, like `{}`, can \\\n+        } else {\n+            if let Some((msg, label)) = match nonlocal_impl {\n+                NonlocalImpl::Allow => None,\n+                NonlocalImpl::DisallowBecauseNonlocal => Some((\n+                    format!(\n+                        \"cross-crate traits with a default impl, like `{}`, \\\n+                                can only be implemented for a struct/enum type \\\n+                                defined in the current crate\",\n+                        tcx.def_path_str(trait_def_id)\n+                    ),\n+                    \"can't implement cross-crate trait for type in another crate\",\n+                )),\n+                NonlocalImpl::DisallowOther => Some((\n+                    format!(\n+                        \"cross-crate traits with a default impl, like `{}`, can \\\n                                 only be implemented for a struct/enum type, not `{}`\",\n-                    tcx.def_path_str(trait_def_id),\n-                    self_ty\n-                ),\n-                \"can't implement cross-crate trait with a default impl for \\\n-                        non-struct/enum type\",\n-            )),\n-        };\n-\n-        if let Some((msg, label)) = msg {\n-            let reported =\n-                struct_span_err!(tcx.sess, sp, E0321, \"{}\", msg).span_label(sp, label).emit();\n-            return Err(reported);\n+                        tcx.def_path_str(trait_def_id),\n+                        self_ty\n+                    ),\n+                    \"can't implement cross-crate trait with a default impl for \\\n+                            non-struct/enum type\",\n+                )),\n+            } {\n+                let reported =\n+                    struct_span_err!(tcx.sess, sp, E0321, \"{}\", msg).span_label(sp, label).emit();\n+                return Err(reported);\n+            }\n         }\n     }\n "}, {"sha": "3f433a0928c5502f95003812771405aedd76bcc1", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -3,7 +3,7 @@ use super::FnCtxt;\n use crate::errors::{AddReturnTypeSuggestion, ExpectedReturnTypeLabel};\n use crate::method::probe::{IsSuggestion, Mode, ProbeScope};\n use rustc_ast::util::parser::{ExprPrecedence, PREC_POSTFIX};\n-use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n+use rustc_errors::{fluent, Applicability, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind};\n use rustc_hir::lang_items::LangItem;\n@@ -414,11 +414,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if let ty::Adt(adt, _) = peeled.kind()\n                     && Some(adt.did()) == self.tcx.lang_items().string()\n                 {\n+                    let sugg = if ref_cnt == 0 {\n+                        \".as_deref()\"\n+                    } else {\n+                        \".map(|x| x.as_str())\"\n+                    };\n                     err.span_suggestion_verbose(\n                         expr.span.shrink_to_hi(),\n-                        \"try converting the passed type into a `&str`\",\n-                        format!(\".map(|x| &*{}x)\", \"*\".repeat(ref_cnt)),\n-                        Applicability::MaybeIncorrect,\n+                        fluent::hir_typeck_convert_to_str,\n+                        sugg,\n+                        Applicability::MachineApplicable,\n                     );\n                     return true;\n                 }"}, {"sha": "d829ca43328fe651422bf31ad61ef2e955bbfe9c", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -495,6 +495,7 @@ enum UnusedDelimsCtx {\n     ArrayLenExpr,\n     AnonConst,\n     MatchArmExpr,\n+    IndexExpr,\n }\n \n impl From<UnusedDelimsCtx> for &'static str {\n@@ -514,6 +515,7 @@ impl From<UnusedDelimsCtx> for &'static str {\n             UnusedDelimsCtx::LetScrutineeExpr => \"`let` scrutinee expression\",\n             UnusedDelimsCtx::ArrayLenExpr | UnusedDelimsCtx::AnonConst => \"const expression\",\n             UnusedDelimsCtx::MatchArmExpr => \"match arm expression\",\n+            UnusedDelimsCtx::IndexExpr => \"index expression\",\n         }\n     }\n }\n@@ -733,6 +735,8 @@ trait UnusedDelimLint {\n                 (value, UnusedDelimsCtx::ReturnValue, false, Some(left), None)\n             }\n \n+            Index(_, ref value) => (value, UnusedDelimsCtx::IndexExpr, false, None, None),\n+\n             Assign(_, ref value, _) | AssignOp(.., ref value) => {\n                 (value, UnusedDelimsCtx::AssignedValue, false, None, None)\n             }"}, {"sha": "bbb4fd999bc76d38aac4c76668dc8c29cc8da9fa", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -675,8 +675,12 @@ pub trait PrettyPrinter<'tcx>:\n                 p!(\")\")\n             }\n             ty::FnDef(def_id, substs) => {\n-                let sig = self.tcx().fn_sig(def_id).subst(self.tcx(), substs);\n-                p!(print(sig), \" {{\", print_value_path(def_id, substs), \"}}\");\n+                if NO_QUERIES.with(|q| q.get()) {\n+                    p!(print_def_path(def_id, substs));\n+                } else {\n+                    let sig = self.tcx().fn_sig(def_id).subst(self.tcx(), substs);\n+                    p!(print(sig), \" {{\", print_value_path(def_id, substs), \"}}\");\n+                }\n             }\n             ty::FnPtr(ref bare_fn) => p!(print(bare_fn)),\n             ty::Infer(infer_ty) => {\n@@ -734,20 +738,22 @@ pub trait PrettyPrinter<'tcx>:\n             }\n             ty::Placeholder(placeholder) => p!(write(\"Placeholder({:?})\", placeholder)),\n             ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n-                // FIXME(eddyb) print this with `print_def_path`.\n                 // We use verbose printing in 'NO_QUERIES' mode, to\n                 // avoid needing to call `predicates_of`. This should\n                 // only affect certain debug messages (e.g. messages printed\n                 // from `rustc_middle::ty` during the computation of `tcx.predicates_of`),\n                 // and should have no effect on any compiler output.\n-                if self.should_print_verbose() || NO_QUERIES.with(|q| q.get()) {\n+                if self.should_print_verbose() {\n+                    // FIXME(eddyb) print this with `print_def_path`.\n                     p!(write(\"Opaque({:?}, {:?})\", def_id, substs));\n                     return Ok(self);\n                 }\n \n                 let parent = self.tcx().parent(def_id);\n                 match self.tcx().def_kind(parent) {\n                     DefKind::TyAlias | DefKind::AssocTy => {\n+                        // NOTE: I know we should check for NO_QUERIES here, but it's alright.\n+                        // `type_of` on a type alias or assoc type should never cause a cycle.\n                         if let ty::Alias(ty::Opaque, ty::AliasTy { def_id: d, .. }) =\n                             *self.tcx().type_of(parent).kind()\n                         {\n@@ -762,7 +768,14 @@ pub trait PrettyPrinter<'tcx>:\n                         p!(print_def_path(def_id, substs));\n                         return Ok(self);\n                     }\n-                    _ => return self.pretty_print_opaque_impl_type(def_id, substs),\n+                    _ => {\n+                        if NO_QUERIES.with(|q| q.get()) {\n+                            p!(print_def_path(def_id, &[]));\n+                            return Ok(self);\n+                        } else {\n+                            return self.pretty_print_opaque_impl_type(def_id, substs);\n+                        }\n+                    }\n                 }\n             }\n             ty::Str => p!(\"str\"),"}, {"sha": "dbd3b76786f42c56d67f44aee2c6d5f588212baa", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -469,6 +469,6 @@ mod size_asserts {\n     use rustc_data_structures::static_assert_size;\n     // tidy-alphabetical-start\n     static_assert_size!(AttrWrapper, 16);\n-    static_assert_size!(LazyAttrTokenStreamImpl, 144);\n+    static_assert_size!(LazyAttrTokenStreamImpl, 120);\n     // tidy-alphabetical-end\n }"}, {"sha": "8a6436b041b90c717b5eaa2d4a2abd055a2e1c6a", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -2141,7 +2141,7 @@ impl<'a> Parser<'a> {\n         }\n \n         if self.token.kind == TokenKind::Semi\n-            && matches!(self.token_cursor.frame.delim_sp, Some((Delimiter::Parenthesis, _)))\n+            && matches!(self.token_cursor.stack.last(), Some((_, Delimiter::Parenthesis, _)))\n             && self.may_recover()\n         {\n             // It is likely that the closure body is a block but where the"}, {"sha": "2ea55f838a37e3f1022476a98a91205e51a6466d", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 59, "deletions": 64, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -19,9 +19,8 @@ pub use path::PathStyle;\n \n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, Nonterminal, Token, TokenKind};\n-use rustc_ast::tokenstream::AttributesData;\n-use rustc_ast::tokenstream::{self, DelimSpan, Spacing};\n-use rustc_ast::tokenstream::{TokenStream, TokenTree};\n+use rustc_ast::tokenstream::{AttributesData, DelimSpan, Spacing};\n+use rustc_ast::tokenstream::{TokenStream, TokenTree, TokenTreeCursor};\n use rustc_ast::util::case::Case;\n use rustc_ast::AttrId;\n use rustc_ast::DUMMY_NODE_ID;\n@@ -168,7 +167,7 @@ pub struct Parser<'a> {\n // This type is used a lot, e.g. it's cloned when matching many declarative macro rules with nonterminals. Make sure\n // it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Parser<'_>, 336);\n+rustc_data_structures::static_assert_size!(Parser<'_>, 312);\n \n /// Stores span information about a closure.\n #[derive(Clone)]\n@@ -221,18 +220,27 @@ impl<'a> Drop for Parser<'a> {\n     }\n }\n \n+/// Iterator over a `TokenStream` that produces `Token`s. It's a bit odd that\n+/// we (a) lex tokens into a nice tree structure (`TokenStream`), and then (b)\n+/// use this type to emit them as a linear sequence. But a linear sequence is\n+/// what the parser expects, for the most part.\n #[derive(Clone)]\n struct TokenCursor {\n-    // The current (innermost) frame. `frame` and `stack` could be combined,\n-    // but it's faster to have them separately to access `frame` directly\n-    // rather than via something like `stack.last().unwrap()` or\n-    // `stack[stack.len() - 1]`.\n-    frame: TokenCursorFrame,\n-    // Additional frames that enclose `frame`.\n-    stack: Vec<TokenCursorFrame>,\n+    // Cursor for the current (innermost) token stream. The delimiters for this\n+    // token stream are found in `self.stack.last()`; when that is `None` then\n+    // we are in the outermost token stream which never has delimiters.\n+    tree_cursor: TokenTreeCursor,\n+\n+    // Token streams surrounding the current one. The delimiters for stack[n]'s\n+    // tokens are in `stack[n-1]`. `stack[0]` (when present) has no delimiters\n+    // because it's the outermost token stream which never has delimiters.\n+    stack: Vec<(TokenTreeCursor, Delimiter, DelimSpan)>,\n+\n     desugar_doc_comments: bool,\n+\n     // Counts the number of calls to `{,inlined_}next`.\n     num_next_calls: usize,\n+\n     // During parsing, we may sometimes need to 'unglue' a\n     // glued token into two component tokens\n     // (e.g. '>>' into '>' and '>), so that the parser\n@@ -257,18 +265,6 @@ struct TokenCursor {\n     break_last_token: bool,\n }\n \n-#[derive(Clone)]\n-struct TokenCursorFrame {\n-    delim_sp: Option<(Delimiter, DelimSpan)>,\n-    tree_cursor: tokenstream::Cursor,\n-}\n-\n-impl TokenCursorFrame {\n-    fn new(delim_sp: Option<(Delimiter, DelimSpan)>, tts: TokenStream) -> Self {\n-        TokenCursorFrame { delim_sp, tree_cursor: tts.into_trees() }\n-    }\n-}\n-\n impl TokenCursor {\n     fn next(&mut self, desugar_doc_comments: bool) -> (Token, Spacing) {\n         self.inlined_next(desugar_doc_comments)\n@@ -281,38 +277,47 @@ impl TokenCursor {\n             // FIXME: we currently don't return `Delimiter` open/close delims. To fix #67062 we will\n             // need to, whereupon the `delim != Delimiter::Invisible` conditions below can be\n             // removed.\n-            if let Some(tree) = self.frame.tree_cursor.next_ref() {\n+            if let Some(tree) = self.tree_cursor.next_ref() {\n                 match tree {\n                     &TokenTree::Token(ref token, spacing) => match (desugar_doc_comments, token) {\n                         (true, &Token { kind: token::DocComment(_, attr_style, data), span }) => {\n-                            return self.desugar(attr_style, data, span);\n+                            let desugared = self.desugar(attr_style, data, span);\n+                            self.tree_cursor.replace_prev_and_rewind(desugared);\n+                            // Continue to get the first token of the desugared doc comment.\n+                        }\n+                        _ => {\n+                            debug_assert!(!matches!(\n+                                token.kind,\n+                                token::OpenDelim(_) | token::CloseDelim(_)\n+                            ));\n+                            return (token.clone(), spacing);\n                         }\n-                        _ => return (token.clone(), spacing),\n                     },\n                     &TokenTree::Delimited(sp, delim, ref tts) => {\n-                        // Set `open_delim` to true here because we deal with it immediately.\n-                        let frame = TokenCursorFrame::new(Some((delim, sp)), tts.clone());\n-                        self.stack.push(mem::replace(&mut self.frame, frame));\n+                        let trees = tts.clone().into_trees();\n+                        self.stack.push((mem::replace(&mut self.tree_cursor, trees), delim, sp));\n                         if delim != Delimiter::Invisible {\n                             return (Token::new(token::OpenDelim(delim), sp.open), Spacing::Alone);\n                         }\n                         // No open delimiter to return; continue on to the next iteration.\n                     }\n                 };\n-            } else if let Some(frame) = self.stack.pop() {\n-                if let Some((delim, span)) = self.frame.delim_sp && delim != Delimiter::Invisible {\n-                    self.frame = frame;\n+            } else if let Some((tree_cursor, delim, span)) = self.stack.pop() {\n+                // We have exhausted this token stream. Move back to its parent token stream.\n+                self.tree_cursor = tree_cursor;\n+                if delim != Delimiter::Invisible {\n                     return (Token::new(token::CloseDelim(delim), span.close), Spacing::Alone);\n                 }\n-                self.frame = frame;\n                 // No close delimiter to return; continue on to the next iteration.\n             } else {\n+                // We have exhausted the outermost token stream.\n                 return (Token::new(token::Eof, DUMMY_SP), Spacing::Alone);\n             }\n         }\n     }\n \n-    fn desugar(&mut self, attr_style: AttrStyle, data: Symbol, span: Span) -> (Token, Spacing) {\n+    // Desugar a doc comment into something like `#[doc = r\"foo\"]`.\n+    fn desugar(&mut self, attr_style: AttrStyle, data: Symbol, span: Span) -> Vec<TokenTree> {\n         // Searches for the occurrences of `\"#*` and returns the minimum number of `#`s\n         // required to wrap the text. E.g.\n         // - `abc d` is wrapped as `r\"abc d\"` (num_of_hashes = 0)\n@@ -346,27 +351,15 @@ impl TokenCursor {\n             .collect::<TokenStream>(),\n         );\n \n-        self.stack.push(mem::replace(\n-            &mut self.frame,\n-            TokenCursorFrame::new(\n-                None,\n-                if attr_style == AttrStyle::Inner {\n-                    [\n-                        TokenTree::token_alone(token::Pound, span),\n-                        TokenTree::token_alone(token::Not, span),\n-                        body,\n-                    ]\n-                    .into_iter()\n-                    .collect::<TokenStream>()\n-                } else {\n-                    [TokenTree::token_alone(token::Pound, span), body]\n-                        .into_iter()\n-                        .collect::<TokenStream>()\n-                },\n-            ),\n-        ));\n-\n-        self.next(/* desugar_doc_comments */ false)\n+        if attr_style == AttrStyle::Inner {\n+            vec![\n+                TokenTree::token_alone(token::Pound, span),\n+                TokenTree::token_alone(token::Not, span),\n+                body,\n+            ]\n+        } else {\n+            vec![TokenTree::token_alone(token::Pound, span), body]\n+        }\n     }\n }\n \n@@ -475,7 +468,7 @@ impl<'a> Parser<'a> {\n             restrictions: Restrictions::empty(),\n             expected_tokens: Vec::new(),\n             token_cursor: TokenCursor {\n-                frame: TokenCursorFrame::new(None, tokens),\n+                tree_cursor: tokens.into_trees(),\n                 stack: Vec::new(),\n                 num_next_calls: 0,\n                 desugar_doc_comments,\n@@ -1142,14 +1135,16 @@ impl<'a> Parser<'a> {\n             return looker(&self.token);\n         }\n \n-        let frame = &self.token_cursor.frame;\n-        if let Some((delim, span)) = frame.delim_sp && delim != Delimiter::Invisible {\n+        let tree_cursor = &self.token_cursor.tree_cursor;\n+        if let Some(&(_, delim, span)) = self.token_cursor.stack.last()\n+            && delim != Delimiter::Invisible\n+        {\n             let all_normal = (0..dist).all(|i| {\n-                let token = frame.tree_cursor.look_ahead(i);\n+                let token = tree_cursor.look_ahead(i);\n                 !matches!(token, Some(TokenTree::Delimited(_, Delimiter::Invisible, _)))\n             });\n             if all_normal {\n-                return match frame.tree_cursor.look_ahead(dist - 1) {\n+                return match tree_cursor.look_ahead(dist - 1) {\n                     Some(tree) => match tree {\n                         TokenTree::Token(token, _) => looker(token),\n                         TokenTree::Delimited(dspan, delim, _) => {\n@@ -1310,10 +1305,10 @@ impl<'a> Parser<'a> {\n     pub(crate) fn parse_token_tree(&mut self) -> TokenTree {\n         match self.token.kind {\n             token::OpenDelim(..) => {\n-                // Grab the tokens from this frame.\n-                let frame = &self.token_cursor.frame;\n-                let stream = frame.tree_cursor.stream.clone();\n-                let (delim, span) = frame.delim_sp.unwrap();\n+                // Grab the tokens within the delimiters.\n+                let tree_cursor = &self.token_cursor.tree_cursor;\n+                let stream = tree_cursor.stream.clone();\n+                let (_, delim, span) = *self.token_cursor.stack.last().unwrap();\n \n                 // Advance the token cursor through the entire delimited\n                 // sequence. After getting the `OpenDelim` we are *within* the"}, {"sha": "4dea03c1ef6a260882b3d1ed46a5285c3b7cedb0", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -314,11 +314,14 @@ pub(crate) fn create_query_frame<\n     kind: DepKind,\n     name: &'static str,\n ) -> QueryStackFrame<DepKind> {\n-    // Disable visible paths printing for performance reasons.\n-    // Showing visible path instead of any path is not that important in production.\n-    let description = ty::print::with_no_visible_paths!(\n-        // Force filename-line mode to avoid invoking `type_of` query.\n-        ty::print::with_forced_impl_filename_line!(do_describe(tcx.tcx, key))\n+    // Avoid calling queries while formatting the description\n+    let description = ty::print::with_no_queries!(\n+        // Disable visible paths printing for performance reasons.\n+        // Showing visible path instead of any path is not that important in production.\n+        ty::print::with_no_visible_paths!(\n+            // Force filename-line mode to avoid invoking `type_of` query.\n+            ty::print::with_forced_impl_filename_line!(do_describe(tcx.tcx, key))\n+        )\n     );\n     let description =\n         if tcx.sess.verbose() { format!(\"{description} [{name:?}]\") } else { description };"}, {"sha": "ccdf6246083cc59787129366e46b47c2748edd91", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -81,6 +81,7 @@ pub(super) enum CandidateSource {\n     AliasBound,\n }\n \n+/// Methods used to assemble candidates for either trait or projection goals.\n pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy + Eq {\n     fn self_ty(self) -> Ty<'tcx>;\n \n@@ -188,6 +189,11 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy + Eq {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> Vec<CanonicalResponse<'tcx>>;\n+\n+    fn consider_builtin_discriminant_kind_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n@@ -320,6 +326,8 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             G::consider_builtin_generator_candidate(self, goal)\n         } else if lang_items.unsize_trait() == Some(trait_def_id) {\n             G::consider_builtin_unsize_candidate(self, goal)\n+        } else if lang_items.discriminant_kind_trait() == Some(trait_def_id) {\n+            G::consider_builtin_discriminant_kind_candidate(self, goal)\n         } else {\n             Err(NoSolution)\n         };"}, {"sha": "9f62f686af647f2c1a3f6a314954e89dbd804c81", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -581,6 +581,15 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n     ) -> Vec<super::CanonicalResponse<'tcx>> {\n         bug!(\"`Unsize` does not have an associated type: {:?}\", goal);\n     }\n+\n+    fn consider_builtin_discriminant_kind_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        let discriminant = goal.predicate.self_ty().discriminant_ty(ecx.tcx());\n+        ecx.infcx\n+            .probe(|_| ecx.eq_term_and_make_canonical_response(goal, Certainty::Yes, discriminant))\n+    }\n }\n \n /// This behavior is also implemented in `rustc_ty_utils` and in the old `project` code."}, {"sha": "0003dfeaee78117ca8a4426dfa48a052808c4ab2", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -439,6 +439,14 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n \n         responses\n     }\n+\n+    fn consider_builtin_discriminant_kind_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        _goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        // `DiscriminantKind` is automatically implemented for every type.\n+        ecx.make_canonical_response(Certainty::Yes)\n+    }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {"}, {"sha": "8f548acfd2eaccc8834f326f04cb201dcefd8e6d", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 50, "deletions": 10, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -547,16 +547,56 @@ fn virtual_call_violation_for_method<'tcx>(\n \n     // NOTE: This check happens last, because it results in a lint, and not a\n     // hard error.\n-    if tcx\n-        .predicates_of(method.def_id)\n-        .predicates\n-        .iter()\n-        // A trait object can't claim to live more than the concrete type,\n-        // so outlives predicates will always hold.\n-        .cloned()\n-        .filter(|(p, _)| p.to_opt_type_outlives().is_none())\n-        .any(|pred| contains_illegal_self_type_reference(tcx, trait_def_id, pred))\n-    {\n+    if tcx.predicates_of(method.def_id).predicates.iter().any(|&(pred, span)| {\n+        // dyn Trait is okay:\n+        //\n+        //     trait Trait {\n+        //         fn f(&self) where Self: 'static;\n+        //     }\n+        //\n+        // because a trait object can't claim to live longer than the concrete\n+        // type. If the lifetime bound holds on dyn Trait then it's guaranteed\n+        // to hold as well on the concrete type.\n+        if pred.to_opt_type_outlives().is_some() {\n+            return false;\n+        }\n+\n+        // dyn Trait is okay:\n+        //\n+        //     auto trait AutoTrait {}\n+        //\n+        //     trait Trait {\n+        //         fn f(&self) where Self: AutoTrait;\n+        //     }\n+        //\n+        // because `impl AutoTrait for dyn Trait` is disallowed by coherence.\n+        // Traits with a default impl are implemented for a trait object if and\n+        // only if the autotrait is one of the trait object's trait bounds, like\n+        // in `dyn Trait + AutoTrait`. This guarantees that trait objects only\n+        // implement auto traits if the underlying type does as well.\n+        if let ty::PredicateKind::Clause(ty::Clause::Trait(ty::TraitPredicate {\n+            trait_ref: pred_trait_ref,\n+            constness: ty::BoundConstness::NotConst,\n+            polarity: ty::ImplPolarity::Positive,\n+        })) = pred.kind().skip_binder()\n+            && pred_trait_ref.self_ty() == tcx.types.self_param\n+            && tcx.trait_is_auto(pred_trait_ref.def_id)\n+        {\n+            // Consider bounds like `Self: Bound<Self>`. Auto traits are not\n+            // allowed to have generic parameters so `auto trait Bound<T> {}`\n+            // would already have reported an error at the definition of the\n+            // auto trait.\n+            if pred_trait_ref.substs.len() != 1 {\n+                tcx.sess.diagnostic().delay_span_bug(\n+                    span,\n+                    \"auto traits cannot have generic parameters\",\n+                );\n+            }\n+            return false;\n+        }\n+\n+        contains_illegal_self_type_reference(tcx, trait_def_id, pred.clone())\n+    }) {\n         return Some(MethodViolationCode::WhereClauseReferencesSelf);\n     }\n "}, {"sha": "7978d8cba95412cb3ef9c51b8d1a40ec5b982294", "filename": "src/tools/rustfmt/src/macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -13,7 +13,7 @@ use std::collections::HashMap;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n \n use rustc_ast::token::{BinOpToken, Delimiter, Token, TokenKind};\n-use rustc_ast::tokenstream::{Cursor, TokenStream, TokenTree};\n+use rustc_ast::tokenstream::{TokenStream, TokenTree, TokenTreeCursor};\n use rustc_ast::{ast, ptr};\n use rustc_ast_pretty::pprust;\n use rustc_span::{\n@@ -736,7 +736,7 @@ impl MacroArgParser {\n         self.buf.clear();\n     }\n \n-    fn add_meta_variable(&mut self, iter: &mut Cursor) -> Option<()> {\n+    fn add_meta_variable(&mut self, iter: &mut TokenTreeCursor) -> Option<()> {\n         match iter.next() {\n             Some(TokenTree::Token(\n                 Token {\n@@ -768,7 +768,7 @@ impl MacroArgParser {\n         &mut self,\n         inner: Vec<ParsedMacroArg>,\n         delim: Delimiter,\n-        iter: &mut Cursor,\n+        iter: &mut TokenTreeCursor,\n     ) -> Option<()> {\n         let mut buffer = String::new();\n         let mut first = true;\n@@ -1121,7 +1121,7 @@ pub(crate) fn macro_style(mac: &ast::MacCall, context: &RewriteContext<'_>) -> D\n // Currently we do not attempt to parse any further than that.\n #[derive(new)]\n struct MacroParser {\n-    toks: Cursor,\n+    toks: TokenTreeCursor,\n }\n \n impl MacroParser {"}, {"sha": "71c228958f6fd8933a4d68375d1d474bebae12cf", "filename": "tests/ui/async-await/no-const-async.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Fasync-await%2Fno-const-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Fasync-await%2Fno-const-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fno-const-async.stderr?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -28,8 +28,8 @@ note: ...which requires const checking `x`...\n    |\n LL | pub const async fn x() {}\n    | ^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires computing whether `impl core::future::future::Future<Output = ()>` is freeze...\n-   = note: ...which requires evaluating trait selection obligation `impl core::future::future::Future<Output = ()>: core::marker::Freeze`...\n+   = note: ...which requires computing whether `x::{opaque#0}` is freeze...\n+   = note: ...which requires evaluating trait selection obligation `x::{opaque#0}: core::marker::Freeze`...\n    = note: ...which again requires computing type of `x::{opaque#0}`, completing the cycle\n note: cycle used when checking item types in top-level module\n   --> $DIR/no-const-async.rs:4:1"}, {"sha": "98f1558b7ffe18d5493f4628ac97cd3738feb44a", "filename": "tests/ui/coherence/coherence-impl-trait-for-marker-trait-negative.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-negative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-negative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-negative.rs?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -12,19 +12,26 @@ auto trait Marker2 {}\n trait Object: Marker1 {}\n \n // A supertrait marker is illegal...\n-impl !Marker1 for dyn Object + Marker2 { }   //~ ERROR E0371\n+impl !Marker1 for dyn Object + Marker2 {} //~ ERROR E0371\n+                                          //~^ ERROR 0321\n // ...and also a direct component.\n-impl !Marker2 for dyn Object + Marker2 { }   //~ ERROR E0371\n-\n-// But implementing a marker if it is not present is OK.\n-impl !Marker2 for dyn Object {} // OK\n+impl !Marker2 for dyn Object + Marker2 {} //~ ERROR E0371\n+                                          //~^ ERROR 0321\n \n // A non-principal trait-object type is orphan even in its crate.\n impl !Send for dyn Marker2 {} //~ ERROR E0117\n \n-// And impl'ing a remote marker for a local trait object is forbidden\n-// by one of these special orphan-like rules.\n+// Implementing a marker for a local trait object is forbidden by a special\n+// orphan-like rule.\n+impl !Marker2 for dyn Object {} //~ ERROR E0321\n impl !Send for dyn Object {} //~ ERROR E0321\n impl !Send for dyn Object + Marker2 {} //~ ERROR E0321\n \n-fn main() { }\n+// Blanket impl that applies to dyn Object is equally problematic.\n+auto trait Marker3 {}\n+impl<T: ?Sized> !Marker3 for T {} //~ ERROR E0321\n+\n+auto trait Marker4 {}\n+impl<T> !Marker4 for T {} // okay\n+\n+fn main() {}"}, {"sha": "ea38afc40ce80bf82ad8bf5702984152899b02e5", "filename": "tests/ui/coherence/coherence-impl-trait-for-marker-trait-negative.stderr", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-negative.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-negative.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-negative.stderr?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -1,17 +1,41 @@\n error[E0371]: the object type `(dyn Object + Marker2 + 'static)` automatically implements the trait `Marker1`\n   --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:15:1\n    |\n-LL | impl !Marker1 for dyn Object + Marker2 { }\n+LL | impl !Marker1 for dyn Object + Marker2 {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `(dyn Object + Marker2 + 'static)` automatically implements trait `Marker1`\n \n+error[E0321]: traits with a default impl, like `Marker1`, cannot be implemented for trait object `(dyn Object + Marker2 + 'static)`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:15:1\n+   |\n+LL | impl !Marker1 for dyn Object + Marker2 {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: a trait object implements `Marker1` if and only if `Marker1` is one of the trait object's trait bounds\n+\n error[E0371]: the object type `(dyn Object + Marker2 + 'static)` automatically implements the trait `Marker2`\n-  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:17:1\n+  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:18:1\n    |\n-LL | impl !Marker2 for dyn Object + Marker2 { }\n+LL | impl !Marker2 for dyn Object + Marker2 {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `(dyn Object + Marker2 + 'static)` automatically implements trait `Marker2`\n \n+error[E0321]: traits with a default impl, like `Marker2`, cannot be implemented for trait object `(dyn Object + Marker2 + 'static)`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:18:1\n+   |\n+LL | impl !Marker2 for dyn Object + Marker2 {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: a trait object implements `Marker2` if and only if `Marker2` is one of the trait object's trait bounds\n+\n+error[E0321]: traits with a default impl, like `Marker2`, cannot be implemented for trait object `(dyn Object + 'static)`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:26:1\n+   |\n+LL | impl !Marker2 for dyn Object {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: a trait object implements `Marker2` if and only if `Marker2` is one of the trait object's trait bounds\n+\n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n-  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:23:1\n+  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:22:1\n    |\n LL | impl !Send for dyn Marker2 {}\n    | ^^^^^^^^^^^^^^^-----------\n@@ -33,7 +57,15 @@ error[E0321]: cross-crate traits with a default impl, like `Send`, can only be i\n LL | impl !Send for dyn Object + Marker2 {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't implement cross-crate trait with a default impl for non-struct/enum type\n \n-error: aborting due to 5 previous errors\n+error[E0321]: traits with a default impl, like `Marker3`, cannot be implemented for generic type `T`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-negative.rs:32:1\n+   |\n+LL | impl<T: ?Sized> !Marker3 for T {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: a trait object implements `Marker3` if and only if `Marker3` is one of the trait object's trait bounds\n+\n+error: aborting due to 9 previous errors\n \n Some errors have detailed explanations: E0117, E0321, E0371.\n For more information about an error, try `rustc --explain E0117`."}, {"sha": "db2e2b4509a2af6f5c85d77d5722d8cae7355792", "filename": "tests/ui/coherence/coherence-impl-trait-for-marker-trait-positive.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-positive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-positive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-positive.rs?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -12,19 +12,26 @@ auto trait Marker2 {}\n trait Object: Marker1 {}\n \n // A supertrait marker is illegal...\n-impl Marker1 for dyn Object + Marker2 { }   //~ ERROR E0371\n+impl Marker1 for dyn Object + Marker2 {} //~ ERROR E0371\n+                                         //~^ ERROR E0321\n // ...and also a direct component.\n-impl Marker2 for dyn Object + Marker2 { }   //~ ERROR E0371\n-\n-// But implementing a marker if it is not present is OK.\n-impl Marker2 for dyn Object {} // OK\n+impl Marker2 for dyn Object + Marker2 {} //~ ERROR E0371\n+                                         //~^ ERROR E0321\n \n // A non-principal trait-object type is orphan even in its crate.\n unsafe impl Send for dyn Marker2 {} //~ ERROR E0117\n \n-// And impl'ing a remote marker for a local trait object is forbidden\n-// by one of these special orphan-like rules.\n+// Implementing a marker for a local trait object is forbidden by a special\n+// orphan-like rule.\n+impl Marker2 for dyn Object {} //~ ERROR E0321\n unsafe impl Send for dyn Object {} //~ ERROR E0321\n unsafe impl Send for dyn Object + Marker2 {} //~ ERROR E0321\n \n-fn main() { }\n+// Blanket impl that applies to dyn Object is equally problematic.\n+auto trait Marker3 {}\n+impl<T: ?Sized> Marker3 for T {} //~ ERROR E0321\n+\n+auto trait Marker4 {}\n+impl<T> Marker4 for T {} // okay\n+\n+fn main() {}"}, {"sha": "2a8713bc327942496550e57aa390781c10a741c2", "filename": "tests/ui/coherence/coherence-impl-trait-for-marker-trait-positive.stderr", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-positive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-positive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcoherence%2Fcoherence-impl-trait-for-marker-trait-positive.stderr?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -1,17 +1,41 @@\n error[E0371]: the object type `(dyn Object + Marker2 + 'static)` automatically implements the trait `Marker1`\n   --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:15:1\n    |\n-LL | impl Marker1 for dyn Object + Marker2 { }\n+LL | impl Marker1 for dyn Object + Marker2 {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `(dyn Object + Marker2 + 'static)` automatically implements trait `Marker1`\n \n+error[E0321]: traits with a default impl, like `Marker1`, cannot be implemented for trait object `(dyn Object + Marker2 + 'static)`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:15:1\n+   |\n+LL | impl Marker1 for dyn Object + Marker2 {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: a trait object implements `Marker1` if and only if `Marker1` is one of the trait object's trait bounds\n+\n error[E0371]: the object type `(dyn Object + Marker2 + 'static)` automatically implements the trait `Marker2`\n-  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:17:1\n+  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:18:1\n    |\n-LL | impl Marker2 for dyn Object + Marker2 { }\n+LL | impl Marker2 for dyn Object + Marker2 {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `(dyn Object + Marker2 + 'static)` automatically implements trait `Marker2`\n \n+error[E0321]: traits with a default impl, like `Marker2`, cannot be implemented for trait object `(dyn Object + Marker2 + 'static)`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:18:1\n+   |\n+LL | impl Marker2 for dyn Object + Marker2 {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: a trait object implements `Marker2` if and only if `Marker2` is one of the trait object's trait bounds\n+\n+error[E0321]: traits with a default impl, like `Marker2`, cannot be implemented for trait object `(dyn Object + 'static)`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:26:1\n+   |\n+LL | impl Marker2 for dyn Object {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: a trait object implements `Marker2` if and only if `Marker2` is one of the trait object's trait bounds\n+\n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n-  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:23:1\n+  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:22:1\n    |\n LL | unsafe impl Send for dyn Marker2 {}\n    | ^^^^^^^^^^^^^^^^^^^^^-----------\n@@ -33,7 +57,15 @@ error[E0321]: cross-crate traits with a default impl, like `Send`, can only be i\n LL | unsafe impl Send for dyn Object + Marker2 {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't implement cross-crate trait with a default impl for non-struct/enum type\n \n-error: aborting due to 5 previous errors\n+error[E0321]: traits with a default impl, like `Marker3`, cannot be implemented for generic type `T`\n+  --> $DIR/coherence-impl-trait-for-marker-trait-positive.rs:32:1\n+   |\n+LL | impl<T: ?Sized> Marker3 for T {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: a trait object implements `Marker3` if and only if `Marker3` is one of the trait object's trait bounds\n+\n+error: aborting due to 9 previous errors\n \n Some errors have detailed explanations: E0117, E0321, E0371.\n For more information about an error, try `rustc --explain E0117`."}, {"sha": "fd0358421ebf9599c9e6a13c685f1e77d4e36a7e", "filename": "tests/ui/impl-trait/auto-trait-leak.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -39,7 +39,7 @@ note: ...which requires type-checking `cycle1`...\n    |\n LL |     send(cycle2().clone());\n    |     ^^^^\n-   = note: ...which requires evaluating trait selection obligation `impl core::clone::Clone: core::marker::Send`...\n+   = note: ...which requires evaluating trait selection obligation `cycle2::{opaque#0}: core::marker::Send`...\n note: ...which requires computing type of `cycle2::{opaque#0}`...\n   --> $DIR/auto-trait-leak.rs:19:16\n    |\n@@ -80,7 +80,7 @@ note: ...which requires type-checking `cycle2`...\n    |\n LL |     send(cycle1().clone());\n    |     ^^^^\n-   = note: ...which requires evaluating trait selection obligation `impl core::clone::Clone: core::marker::Send`...\n+   = note: ...which requires evaluating trait selection obligation `cycle1::{opaque#0}: core::marker::Send`...\n    = note: ...which again requires computing type of `cycle1::{opaque#0}`, completing the cycle\n note: cycle used when checking item types in top-level module\n   --> $DIR/auto-trait-leak.rs:1:1"}, {"sha": "4e7c290fa2a0200602b2c975adac7696537b4ce6", "filename": "tests/ui/lint/unused/issue-96606.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Flint%2Funused%2Fissue-96606.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Flint%2Funused%2Fissue-96606.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Funused%2Fissue-96606.rs?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -0,0 +1,8 @@\n+#[deny(unused)]\n+fn main() {\n+    let arr = [0; 10];\n+    let _ = arr[(0)]; //~ ERROR unnecessary parentheses around index expression\n+    let _ = arr[{0}]; //~ ERROR unnecessary braces around index expression\n+    let _ = arr[1 + (0)];\n+    let _ = arr[{ let x = 0; x }];\n+}"}, {"sha": "e3627718116be11e01b5eba929532aeff856e4c8", "filename": "tests/ui/lint/unused/issue-96606.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Flint%2Funused%2Fissue-96606.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Flint%2Funused%2Fissue-96606.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Funused%2Fissue-96606.stderr?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -0,0 +1,33 @@\n+error: unnecessary parentheses around index expression\n+  --> $DIR/issue-96606.rs:4:17\n+   |\n+LL |     let _ = arr[(0)];\n+   |                 ^ ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-96606.rs:1:8\n+   |\n+LL | #[deny(unused)]\n+   |        ^^^^^^\n+   = note: `#[deny(unused_parens)]` implied by `#[deny(unused)]`\n+help: remove these parentheses\n+   |\n+LL -     let _ = arr[(0)];\n+LL +     let _ = arr[0];\n+   |\n+\n+error: unnecessary braces around index expression\n+  --> $DIR/issue-96606.rs:5:17\n+   |\n+LL |     let _ = arr[{0}];\n+   |                 ^ ^\n+   |\n+   = note: `#[deny(unused_braces)]` implied by `#[deny(unused)]`\n+help: remove these braces\n+   |\n+LL -     let _ = arr[{0}];\n+LL +     let _ = arr[0];\n+   |\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "2d8bd19a73108e5bf704b6d1561ab0268d9100e6", "filename": "tests/ui/parser/fn-header-semantic-fail.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -209,8 +209,8 @@ note: ...which requires const checking `main::ff5`...\n    |\n LL |     const async unsafe extern \"C\" fn ff5() {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires computing whether `impl core::future::future::Future<Output = ()>` is freeze...\n-   = note: ...which requires evaluating trait selection obligation `impl core::future::future::Future<Output = ()>: core::marker::Freeze`...\n+   = note: ...which requires computing whether `main::ff5::{opaque#0}` is freeze...\n+   = note: ...which requires evaluating trait selection obligation `main::ff5::{opaque#0}: core::marker::Freeze`...\n    = note: ...which again requires computing type of `main::ff5::{opaque#0}`, completing the cycle\n note: cycle used when checking item types in top-level module\n   --> $DIR/fn-header-semantic-fail.rs:5:1\n@@ -245,8 +245,8 @@ note: ...which requires const checking `main::<impl at $DIR/fn-header-semantic-f\n    |\n LL |         const async unsafe extern \"C\" fn ft5() {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires computing whether `impl core::future::future::Future<Output = ()>` is freeze...\n-   = note: ...which requires evaluating trait selection obligation `impl core::future::future::Future<Output = ()>: core::marker::Freeze`...\n+   = note: ...which requires computing whether `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 28:17>::ft5::{opaque#0}` is freeze...\n+   = note: ...which requires evaluating trait selection obligation `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 28:17>::ft5::{opaque#0}: core::marker::Freeze`...\n    = note: ...which again requires computing type of `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 28:17>::ft5::{opaque#0}`, completing the cycle\n note: cycle used when checking item types in top-level module\n   --> $DIR/fn-header-semantic-fail.rs:5:1\n@@ -281,8 +281,8 @@ note: ...which requires const checking `main::<impl at $DIR/fn-header-semantic-f\n    |\n LL |         const async unsafe extern \"C\" fn fi5() {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires computing whether `impl core::future::future::Future<Output = ()>` is freeze...\n-   = note: ...which requires evaluating trait selection obligation `impl core::future::future::Future<Output = ()>: core::marker::Freeze`...\n+   = note: ...which requires computing whether `main::<impl at $DIR/fn-header-semantic-fail.rs:40:5: 40:11>::fi5::{opaque#0}` is freeze...\n+   = note: ...which requires evaluating trait selection obligation `main::<impl at $DIR/fn-header-semantic-fail.rs:40:5: 40:11>::fi5::{opaque#0}: core::marker::Freeze`...\n    = note: ...which again requires computing type of `main::<impl at $DIR/fn-header-semantic-fail.rs:40:5: 40:11>::fi5::{opaque#0}`, completing the cycle\n note: cycle used when checking item types in top-level module\n   --> $DIR/fn-header-semantic-fail.rs:5:1"}, {"sha": "45b7043e2f6fdbd40d73eb61ed61d26a1347efa4", "filename": "tests/ui/query-system/no-query-in-printing-during-query-descr.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Fquery-system%2Fno-query-in-printing-during-query-descr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Fquery-system%2Fno-query-in-printing-during-query-descr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fquery-system%2Fno-query-in-printing-during-query-descr.rs?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -0,0 +1,6 @@\n+fn a() -> _ {\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for return types\n+    &a\n+}\n+\n+fn main() {}"}, {"sha": "35e608b6b232b6fe4d67d419aecefb07b2c8e39f", "filename": "tests/ui/query-system/no-query-in-printing-during-query-descr.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Fquery-system%2Fno-query-in-printing-during-query-descr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Fquery-system%2Fno-query-in-printing-during-query-descr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fquery-system%2Fno-query-in-printing-during-query-descr.stderr?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -0,0 +1,9 @@\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n+  --> $DIR/no-query-in-printing-during-query-descr.rs:1:11\n+   |\n+LL | fn a() -> _ {\n+   |           ^ not allowed in type signatures\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0121`."}, {"sha": "3e1a006efa06978f80d556ac290144762a0bf19a", "filename": "tests/ui/typeck/issue-89856.fixed", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Ftypeck%2Fissue-89856.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Ftypeck%2Fissue-89856.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-89856.fixed?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+\n+fn take_str_maybe(_: Option<&str>) { }\n+fn main() {\n+    let string = String::from(\"Hello, world\");\n+\n+    let option: Option<String> = Some(string.clone());\n+    take_str_maybe(option.as_deref());\n+    //~^ ERROR: mismatched types [E0308]\n+\n+    let option_ref = Some(&string);\n+    take_str_maybe(option_ref.map(|x| x.as_str()));\n+    //~^ ERROR: mismatched types [E0308]\n+\n+    let option_ref_ref = option_ref.as_ref();\n+    take_str_maybe(option_ref_ref.map(|x| x.as_str()));\n+    //~^ ERROR: mismatched types [E0308]\n+}"}, {"sha": "cfe6e19b303f3513578ae2d493f65f95d27911b5", "filename": "tests/ui/typeck/issue-89856.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Ftypeck%2Fissue-89856.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Ftypeck%2Fissue-89856.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-89856.rs?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -1,8 +1,18 @@\n-fn take_str_maybe(x: Option<&str>) -> Option<&str> { None }\n+// run-rustfix\n \n+fn take_str_maybe(_: Option<&str>) { }\n fn main() {\n     let string = String::from(\"Hello, world\");\n-    let option = Some(&string);\n+\n+    let option: Option<String> = Some(string.clone());\n     take_str_maybe(option);\n     //~^ ERROR: mismatched types [E0308]\n+\n+    let option_ref = Some(&string);\n+    take_str_maybe(option_ref);\n+    //~^ ERROR: mismatched types [E0308]\n+\n+    let option_ref_ref = option_ref.as_ref();\n+    take_str_maybe(option_ref_ref);\n+    //~^ ERROR: mismatched types [E0308]\n }"}, {"sha": "bd76f17246821cd0cbbc82ddfc731276ba072382", "filename": "tests/ui/typeck/issue-89856.stderr", "status": "modified", "additions": 47, "deletions": 7, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Ftypeck%2Fissue-89856.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Ftypeck%2Fissue-89856.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-89856.stderr?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -1,23 +1,63 @@\n error[E0308]: mismatched types\n-  --> $DIR/issue-89856.rs:6:20\n+  --> $DIR/issue-89856.rs:8:20\n    |\n LL |     take_str_maybe(option);\n-   |     -------------- ^^^^^^ expected `Option<&str>`, found `Option<&String>`\n+   |     -------------- ^^^^^^ expected `Option<&str>`, found `Option<String>`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+   = note: expected enum `Option<&str>`\n+              found enum `Option<String>`\n+note: function defined here\n+  --> $DIR/issue-89856.rs:3:4\n+   |\n+LL | fn take_str_maybe(_: Option<&str>) { }\n+   |    ^^^^^^^^^^^^^^ ---------------\n+help: try converting the passed type into a `&str`\n+   |\n+LL |     take_str_maybe(option.as_deref());\n+   |                          +++++++++++\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-89856.rs:12:20\n+   |\n+LL |     take_str_maybe(option_ref);\n+   |     -------------- ^^^^^^^^^^ expected `Option<&str>`, found `Option<&String>`\n    |     |\n    |     arguments to this function are incorrect\n    |\n    = note: expected enum `Option<&str>`\n               found enum `Option<&String>`\n note: function defined here\n-  --> $DIR/issue-89856.rs:1:4\n+  --> $DIR/issue-89856.rs:3:4\n+   |\n+LL | fn take_str_maybe(_: Option<&str>) { }\n+   |    ^^^^^^^^^^^^^^ ---------------\n+help: try converting the passed type into a `&str`\n+   |\n+LL |     take_str_maybe(option_ref.map(|x| x.as_str()));\n+   |                              ++++++++++++++++++++\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-89856.rs:16:20\n+   |\n+LL |     take_str_maybe(option_ref_ref);\n+   |     -------------- ^^^^^^^^^^^^^^ expected `Option<&str>`, found `Option<&&String>`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+   = note: expected enum `Option<&str>`\n+              found enum `Option<&&String>`\n+note: function defined here\n+  --> $DIR/issue-89856.rs:3:4\n    |\n-LL | fn take_str_maybe(x: Option<&str>) -> Option<&str> { None }\n+LL | fn take_str_maybe(_: Option<&str>) { }\n    |    ^^^^^^^^^^^^^^ ---------------\n help: try converting the passed type into a `&str`\n    |\n-LL |     take_str_maybe(option.map(|x| &**x));\n-   |                          ++++++++++++++\n+LL |     take_str_maybe(option_ref_ref.map(|x| x.as_str()));\n+   |                                  ++++++++++++++++++++\n \n-error: aborting due to previous error\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "6cf5ed2e46aecbe526d158afa903146d8e92bd82", "filename": "tests/ui/where-clauses/self-in-where-clause-allowed.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Fwhere-clauses%2Fself-in-where-clause-allowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Fwhere-clauses%2Fself-in-where-clause-allowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhere-clauses%2Fself-in-where-clause-allowed.rs?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -0,0 +1,23 @@\n+// check-fail\n+\n+#![feature(auto_traits)]\n+#![deny(where_clauses_object_safety)]\n+\n+auto trait AutoTrait {}\n+\n+trait Trait {\n+    fn static_lifetime_bound(&self) where Self: 'static {}\n+\n+    fn arg_lifetime_bound<'a>(&self, _arg: &'a ()) where Self: 'a {}\n+\n+    fn autotrait_bound(&self) where Self: AutoTrait {}\n+}\n+\n+impl Trait for () {}\n+\n+fn main() {\n+    let trait_object = &() as &dyn Trait;\n+    trait_object.static_lifetime_bound();\n+    trait_object.arg_lifetime_bound(&());\n+    trait_object.autotrait_bound(); //~ ERROR: the trait bound `dyn Trait: AutoTrait` is not satisfied\n+}"}, {"sha": "ea51f5084f8755e59cee5dcd91dbfcd15623797e", "filename": "tests/ui/where-clauses/self-in-where-clause-allowed.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Fwhere-clauses%2Fself-in-where-clause-allowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/658fad6c5506f41c35b64fb1a22ceb0992697ff3/tests%2Fui%2Fwhere-clauses%2Fself-in-where-clause-allowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhere-clauses%2Fself-in-where-clause-allowed.stderr?ref=658fad6c5506f41c35b64fb1a22ceb0992697ff3", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `dyn Trait: AutoTrait` is not satisfied\n+  --> $DIR/self-in-where-clause-allowed.rs:22:18\n+   |\n+LL |     trait_object.autotrait_bound();\n+   |                  ^^^^^^^^^^^^^^^ the trait `AutoTrait` is not implemented for `dyn Trait`\n+   |\n+note: required by a bound in `Trait::autotrait_bound`\n+  --> $DIR/self-in-where-clause-allowed.rs:13:43\n+   |\n+LL |     fn autotrait_bound(&self) where Self: AutoTrait {}\n+   |                                           ^^^^^^^^^ required by this bound in `Trait::autotrait_bound`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}