{"sha": "f457e6c3e0724ba3a7d37460ea7088cf67a6af4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0NTdlNmMzZTA3MjRiYTNhN2QzNzQ2MGVhNzA4OGNmNjdhNmFmNGI=", "commit": {"author": {"name": "Wang Xuerui", "email": "idontknw.wang@gmail.com", "date": "2016-05-21T08:00:01Z"}, "committer": {"name": "Wang Xuerui", "email": "idontknw.wang@gmail.com", "date": "2016-07-13T19:10:46Z"}, "message": "syntax_ext: format: process counts uniquely and separately", "tree": {"sha": "18b3855933149e1e400386ce4d35de9d40d964f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18b3855933149e1e400386ce4d35de9d40d964f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f457e6c3e0724ba3a7d37460ea7088cf67a6af4b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQIcBAABCAAGBQJXhpI2AAoJEHg5bO9pIxDs9hcQAL7TzxOgUxdJpoib2FEiaWFO\nTov3ghYH0Z1naRYQcAPwDWgbZ05E1rhJfRdQMjJNxRmvDnXvX4tfnr1OkWMizYjw\nsQEvKByTB/JeVXYVoUwfT/pbyBhiV2Y1vFDjII6jLH/y+KQ76HhuSm4wQW7rKPOM\nJCvF5m5trvv5VtAKZ8wVJiIGsIqNWn2nth/nuuvpf5lUHQBiY7eHEopU3k0OIkmA\nXDCRwcAilZP9dQ9M8I+P+r2KwWLu27n9Rb+e6RwpljqK6Dm32BcoYyLTdCRDNSuH\noCh+9pT7tLVBZ+C2tuNR6JgW52RR1ZB+vARF2rkstedST8ayEBPtcenW9OMVceFo\nfwhEOiH8OeeQbfCJwFV1Hq/RNgYrP7cKv6yEm7TpsR9lH+4kk3mzUn/FimwA0Usa\n5UPLi7iUdAMar/nQGTQTBswyUzptuj/8bAwYQDIfaQqYVGJjvrtMP8fJo/ttDmiT\nbNws7LJwN34B+kmkXfq6UveM1zT5vQTi+3PwRdqlgchIoPNi2kYdWQ90USXKciTG\nsCvz4H94XQ1n0wYewEwm5Gm1OU1CMGSOE1kKlD3Ih3sYXXGeAYEPlZ+YLmo0VYe6\n0lFSkO6HYZZXAl2GPRbY3h1v8PIYeJcT8j98lPJsXnA4sgJgQK867awxTBOmv3VU\nN3uKsxFCHsu8K4WFZzX6\n=ixSh\n-----END PGP SIGNATURE-----", "payload": "tree 18b3855933149e1e400386ce4d35de9d40d964f0\nparent 5e55a4411684a9cf3932b0597607cf82433ff3ba\nauthor Wang Xuerui <idontknw.wang@gmail.com> 1463817601 +0800\ncommitter Wang Xuerui <idontknw.wang@gmail.com> 1468437046 +0800\n\nsyntax_ext: format: process counts uniquely and separately\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f457e6c3e0724ba3a7d37460ea7088cf67a6af4b", "html_url": "https://github.com/rust-lang/rust/commit/f457e6c3e0724ba3a7d37460ea7088cf67a6af4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f457e6c3e0724ba3a7d37460ea7088cf67a6af4b/comments", "author": {"login": "xen0n", "id": 1175567, "node_id": "MDQ6VXNlcjExNzU1Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/1175567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xen0n", "html_url": "https://github.com/xen0n", "followers_url": "https://api.github.com/users/xen0n/followers", "following_url": "https://api.github.com/users/xen0n/following{/other_user}", "gists_url": "https://api.github.com/users/xen0n/gists{/gist_id}", "starred_url": "https://api.github.com/users/xen0n/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xen0n/subscriptions", "organizations_url": "https://api.github.com/users/xen0n/orgs", "repos_url": "https://api.github.com/users/xen0n/repos", "events_url": "https://api.github.com/users/xen0n/events{/privacy}", "received_events_url": "https://api.github.com/users/xen0n/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xen0n", "id": 1175567, "node_id": "MDQ6VXNlcjExNzU1Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/1175567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xen0n", "html_url": "https://github.com/xen0n", "followers_url": "https://api.github.com/users/xen0n/followers", "following_url": "https://api.github.com/users/xen0n/following{/other_user}", "gists_url": "https://api.github.com/users/xen0n/gists{/gist_id}", "starred_url": "https://api.github.com/users/xen0n/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xen0n/subscriptions", "organizations_url": "https://api.github.com/users/xen0n/orgs", "repos_url": "https://api.github.com/users/xen0n/repos", "events_url": "https://api.github.com/users/xen0n/events{/privacy}", "received_events_url": "https://api.github.com/users/xen0n/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e55a4411684a9cf3932b0597607cf82433ff3ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e55a4411684a9cf3932b0597607cf82433ff3ba", "html_url": "https://github.com/rust-lang/rust/commit/5e55a4411684a9cf3932b0597607cf82433ff3ba"}], "stats": {"total": 73, "additions": 62, "deletions": 11}, "files": [{"sha": "606840cd1cb8e16a95bed9a8636be55db210d445", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 62, "deletions": 11, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/f457e6c3e0724ba3a7d37460ea7088cf67a6af4b/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f457e6c3e0724ba3a7d37460ea7088cf67a6af4b/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=f457e6c3e0724ba3a7d37460ea7088cf67a6af4b", "patch": "@@ -24,6 +24,7 @@ use syntax_pos::{Span, DUMMY_SP};\n use syntax::tokenstream;\n \n use std::collections::HashMap;\n+use std::collections::hash_map::Entry;\n \n #[derive(PartialEq)]\n enum ArgumentType {\n@@ -70,6 +71,12 @@ struct Context<'a, 'b:'a> {\n     /// mapping in `trans_piece`.\n     arg_index_map: Vec<usize>,\n \n+    count_args_index_offset: usize,\n+\n+    count_args: Vec<Position>,\n+    count_positions: HashMap<usize, usize>,\n+    count_positions_count: usize,\n+\n     /// Current position of the implicit positional arg pointer, as if it\n     /// still existed in this phase of processing.\n     /// Used only for `all_pieces_simple` tracking in `trans_piece`.\n@@ -225,7 +232,22 @@ impl<'a, 'b> Context<'a, 'b> {\n                     self.ecx.span_err(self.fmtsp, &msg[..]);\n                     return;\n                 }\n-                self.arg_types[arg].push(ty);\n+                match ty {\n+                    Placeholder(_) => {\n+                        self.arg_types[arg].push(ty);\n+                    }\n+                    Count => {\n+                        match self.count_positions.entry(arg) {\n+                            Entry::Vacant(e) => {\n+                                let i = self.count_positions_count;\n+                                e.insert(i);\n+                                self.count_args.push(Exact(arg));\n+                                self.count_positions_count += 1;\n+                            }\n+                            Entry::Occupied(_) => {}\n+                        }\n+                    }\n+                }\n             }\n \n             Named(name) => {\n@@ -255,15 +277,17 @@ impl<'a, 'b> Context<'a, 'b> {\n             self.arg_index_map.push(sofar);\n             sofar += self.arg_types[i].len();\n         }\n+\n+        // Record starting index for counts, which appear just\n+        // after the positional args\n+        self.count_args_index_offset = sofar;\n     }\n \n     fn rtpath(ecx: &ExtCtxt, s: &str) -> Vec<ast::Ident> {\n         ecx.std_path(&[\"fmt\", \"rt\", \"v1\", s])\n     }\n \n-    fn trans_count(&self,\n-                   c: parse::Count,\n-                   arg_index_consumed: &mut Vec<usize>) -> P<ast::Expr> {\n+    fn trans_count(&self, c: parse::Count) -> P<ast::Expr> {\n         let sp = self.macsp;\n         let count = |c, arg| {\n             let mut path = Context::rtpath(self.ecx, \"Count\");\n@@ -278,9 +302,12 @@ impl<'a, 'b> Context<'a, 'b> {\n             parse::CountIsParam(i) => {\n                 // This needs mapping too, as `i` is referring to a macro\n                 // argument.\n-                let arg_idx = self.arg_index_map[i] + arg_index_consumed[i];\n-                arg_index_consumed[i] += 1;\n-                count(\"Param\", Some(self.ecx.expr_usize(sp, arg_idx)))\n+                let i = match self.count_positions.get(&i) {\n+                    Some(&i) => i,\n+                    None => 0, // error already emitted elsewhere\n+                };\n+                let i = i + self.count_args_index_offset;\n+                count(\"Param\", Some(self.ecx.expr_usize(sp, i)))\n             }\n             parse::CountImplied => count(\"Implied\", None),\n             // should never be the case, names are already resolved\n@@ -383,8 +410,8 @@ impl<'a, 'b> Context<'a, 'b> {\n                 };\n                 let align = self.ecx.expr_path(align);\n                 let flags = self.ecx.expr_u32(sp, arg.format.flags);\n-                let prec = self.trans_count(arg.format.precision, arg_index_consumed);\n-                let width = self.trans_count(arg.format.width, arg_index_consumed);\n+                let prec = self.trans_count(arg.format.precision);\n+                let width = self.trans_count(arg.format.width);\n                 let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"FormatSpec\"));\n                 let fmt = self.ecx.expr_struct(sp, path, vec!(\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"fill\"), fill),\n@@ -431,6 +458,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// to\n     fn into_expr(mut self) -> P<ast::Expr> {\n         let mut locals = Vec::new();\n+        let mut counts = Vec::new();\n         let mut pats = Vec::new();\n         let mut heads = Vec::new();\n \n@@ -447,6 +475,10 @@ impl<'a, 'b> Context<'a, 'b> {\n                                            piece_ty,\n                                            self.str_pieces);\n \n+        // Before consuming the expressions, we have to remember spans for\n+        // count arguments as they are now generated separate from other\n+        // arguments, hence have no access to the `P<ast::Expr>`'s.\n+        let spans_pos: Vec<_> = self.args.iter().map(|e| e.span.clone()).collect();\n \n         // Right now there is a bug such that for the expression:\n         //      foo(bar(&1))\n@@ -464,11 +496,23 @@ impl<'a, 'b> Context<'a, 'b> {\n             }\n             heads.push(self.ecx.expr_addr_of(e.span, e));\n         }\n+        for pos in self.count_args {\n+            let name = self.ecx.ident_of(&match pos {\n+                Exact(i) => format!(\"__arg{}\", i),\n+                _ => panic!(\"should never happen\"),\n+            });\n+            let span = match pos {\n+                Exact(i) => spans_pos[i],\n+                _ => panic!(\"should never happen\"),\n+            };\n+            counts.push(Context::format_arg(self.ecx, self.macsp, span, &Count,\n+                                            self.ecx.expr_ident(span, name)));\n+        }\n \n         // Now create a vector containing all the arguments\n-        let args = locals.into_iter().collect();\n+        let args = locals.into_iter().chain(counts.into_iter());\n \n-        let args_array = self.ecx.expr_vec(self.fmtsp, args);\n+        let args_array = self.ecx.expr_vec(self.fmtsp, args.collect());\n \n         // Constructs an AST equivalent to:\n         //\n@@ -594,6 +638,10 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         names: names,\n         curarg: 0,\n         arg_index_map: Vec::new(),\n+        count_args: Vec::new(),\n+        count_positions: HashMap::new(),\n+        count_positions_count: 0,\n+        count_args_index_offset: 0,\n         literal: String::new(),\n         pieces: Vec::new(),\n         str_pieces: Vec::new(),\n@@ -648,6 +696,9 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n     let num_pos_args = cx.args.len() - cx.names.len();\n     for (i, ty) in cx.arg_types.iter().enumerate() {\n         if ty.len() == 0 {\n+            if cx.count_positions.contains_key(&i) {\n+                continue;\n+            }\n             let msg = if i >= num_pos_args {\n                 // named argument\n                 \"named argument never used\""}]}