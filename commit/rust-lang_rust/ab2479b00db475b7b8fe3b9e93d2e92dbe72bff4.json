{"sha": "ab2479b00db475b7b8fe3b9e93d2e92dbe72bff4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiMjQ3OWIwMGRiNDc1YjdiOGZlM2I5ZTkzZDJlOTJkYmU3MmJmZjQ=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-01-21T23:13:59Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-01-21T23:13:59Z"}, "message": "Move logic to its own method", "tree": {"sha": "436607ac7b46ed55877aae0ff80f11804b02da31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/436607ac7b46ed55877aae0ff80f11804b02da31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab2479b00db475b7b8fe3b9e93d2e92dbe72bff4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab2479b00db475b7b8fe3b9e93d2e92dbe72bff4", "html_url": "https://github.com/rust-lang/rust/commit/ab2479b00db475b7b8fe3b9e93d2e92dbe72bff4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab2479b00db475b7b8fe3b9e93d2e92dbe72bff4/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e33f7f7de1df090f890063296608dca65be55ac0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e33f7f7de1df090f890063296608dca65be55ac0", "html_url": "https://github.com/rust-lang/rust/commit/e33f7f7de1df090f890063296608dca65be55ac0"}], "stats": {"total": 136, "additions": 63, "deletions": 73}, "files": [{"sha": "d1dfe9469fb774753afedee85e4c200ec058c8f5", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 63, "deletions": 73, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/ab2479b00db475b7b8fe3b9e93d2e92dbe72bff4/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2479b00db475b7b8fe3b9e93d2e92dbe72bff4/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=ab2479b00db475b7b8fe3b9e93d2e92dbe72bff4", "patch": "@@ -1208,83 +1208,20 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                         db.span_label(cause.span, \"return type is not `()`\");\n                     }\n                     ObligationCauseCode::BlockTailExpression(blk_id) => {\n-                        db = fcx.report_mismatched_types(cause, expected, found, err);\n-\n-                        let expr = expression.unwrap_or_else(|| {\n-                            span_bug!(cause.span,\n-                                      \"supposed to be part of a block tail expression, but the \\\n-                                       expression is empty\");\n-                        });\n-                        let pointing_at_return_type = fcx.suggest_mismatched_types_on_tail(\n-                            &mut db,\n-                            expr,\n+                        let parent_id = fcx.tcx.hir().get_parent_node(blk_id);\n+                        db = self.report_return_mismatched_types(\n+                            cause,\n                             expected,\n                             found,\n-                            cause.span,\n-                            blk_id,\n+                            err,\n+                            fcx,\n+                            parent_id,\n+                            expression.map(|expr| (expr, blk_id)),\n                         );\n-                        // FIXME: replace with navigating up the chain until hitting an fn or\n-                        // bailing if no \"pass-through\" Node is found, in order to provide a\n-                        // suggestion when encountering something like:\n-                        // ```\n-                        // fn foo(a: bool) -> impl Debug {\n-                        //     if a {\n-                        //         bar()?;\n-                        //     }\n-                        //     {\n-                        //         let x = unsafe { bar() };\n-                        //         x\n-                        //     }\n-                        // }\n-                        // ```\n-                        //\n-                        // Verify that this is a tail expression of a function, otherwise the\n-                        // label pointing out the cause for the type coercion will be wrong\n-                        // as prior return coercions would not be relevant (#57664).\n-                        let parent_id = fcx.tcx.hir().get_parent_node(blk_id);\n-                        let parent = fcx.tcx.hir().get(fcx.tcx.hir().get_parent_node(parent_id));\n-                        if let (Some((fn_decl, _, _)), false) = (\n-                            fcx.get_node_fn_decl(parent),\n-                            pointing_at_return_type,\n-                        ) {\n-                            if let Some(sp) = fcx.ret_coercion_span.borrow().as_ref() {\n-                                db.span_label(\n-                                    fn_decl.output.span(),\n-                                    \"expected because this return type...\",\n-                                );\n-                                db.span_label(*sp, format!(\n-                                    \"...is found to be `{}` here\",\n-                                    fcx.resolve_type_vars_with_obligations(expected),\n-                                ));\n-                            }\n-                        }\n                     }\n-                    ObligationCauseCode::ReturnType(_id) => {\n-                        db = fcx.report_mismatched_types(cause, expected, found, err);\n-                        let _id = fcx.tcx.hir().get_parent_node(_id);\n-                        let mut pointing_at_return_type = false;\n-                        let mut return_sp = None;\n-                        if let Some((fn_decl, can_suggest)) = fcx.get_fn_decl(_id) {\n-                            pointing_at_return_type = fcx.suggest_missing_return_type(\n-                                &mut db, &fn_decl, expected, found, can_suggest);\n-                            if !pointing_at_return_type {\n-                                return_sp = Some(fn_decl.output.span()); // `impl Trait` return type\n-                            }\n-                        }\n-                        if let (Some(sp), false) = (\n-                            fcx.ret_coercion_span.borrow().as_ref(),\n-                            pointing_at_return_type,\n-                        ) {\n-                            if let Some(return_sp) = return_sp {\n-                                db.span_label(return_sp, \"expected because this return type...\");\n-                                db.span_label( *sp, format!(\n-                                    \"...is found to be `{}` here\",\n-                                    fcx.resolve_type_vars_with_obligations(expected),\n-                                ));\n-                            } else if !sp.overlaps(cause.span) {\n-                                db.span_label(*sp, \"expected because of this statement\");\n-                            }\n-                        }\n+                    ObligationCauseCode::ReturnType(id) => {\n+                        db = self.report_return_mismatched_types(\n+                            cause, expected, found, err, fcx, id, None);\n                     }\n                     _ => {\n                         db = fcx.report_mismatched_types(cause, expected, found, err);\n@@ -1302,6 +1239,59 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n         }\n     }\n \n+    fn report_return_mismatched_types<'a>(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+        err: TypeError<'tcx>,\n+        fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n+        id: syntax::ast::NodeId,\n+        expression: Option<(&'gcx hir::Expr, syntax::ast::NodeId)>,\n+    ) -> DiagnosticBuilder<'a> {\n+        let mut db = fcx.report_mismatched_types(cause, expected, found, err);\n+\n+        let mut pointing_at_return_type = false;\n+        let mut return_sp = None;\n+\n+        // Verify that this is a tail expression of a function, otherwise the\n+        // label pointing out the cause for the type coercion will be wrong\n+        // as prior return coercions would not be relevant (#57664).\n+        let parent_id = fcx.tcx.hir().get_parent_node(id);\n+        let fn_decl = if let Some((expr, blk_id)) = expression {\n+            pointing_at_return_type = fcx.suggest_mismatched_types_on_tail(\n+                &mut db,\n+                expr,\n+                expected,\n+                found,\n+                cause.span,\n+                blk_id,\n+            );\n+            let parent = fcx.tcx.hir().get(parent_id);\n+            fcx.get_node_fn_decl(parent).map(|(fn_decl, _, is_main)| (fn_decl, is_main))\n+        } else {\n+            fcx.get_fn_decl(parent_id)\n+        };\n+\n+        if let (Some((fn_decl, can_suggest)), _) = (fn_decl, pointing_at_return_type) {\n+            if expression.is_none() {\n+                pointing_at_return_type |= fcx.suggest_missing_return_type(\n+                    &mut db, &fn_decl, expected, found, can_suggest);\n+            }\n+            if !pointing_at_return_type {\n+                return_sp = Some(fn_decl.output.span()); // `impl Trait` return type\n+            }\n+        }\n+        if let (Some(sp), Some(return_sp)) = (fcx.ret_coercion_span.borrow().as_ref(), return_sp) {\n+            db.span_label(return_sp, \"expected because this return type...\");\n+            db.span_label( *sp, format!(\n+                \"...is found to be `{}` here\",\n+                fcx.resolve_type_vars_with_obligations(expected),\n+            ));\n+        }\n+        db\n+    }\n+\n     pub fn complete<'a>(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         if let Some(final_ty) = self.final_ty {\n             final_ty"}]}