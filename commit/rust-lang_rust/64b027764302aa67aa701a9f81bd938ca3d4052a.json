{"sha": "64b027764302aa67aa701a9f81bd938ca3d4052a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0YjAyNzc2NDMwMmFhNjdhYTcwMWE5ZjgxYmQ5MzhjYTNkNDA1MmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-30T22:23:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-30T22:23:41Z"}, "message": "Auto merge of #29454 - stepancheg:vec-reserve, r=bluss\n\nBefore this patch `reserve` function allocated twice as requested\r\namount elements (not twice as capacity).  It leaded to unnecessary\r\nexcessive memory usage in scenarios like this:\r\n\r\n```\r\nlet mut v = Vec::new();\r\nv.push(17);\r\nv.extend(0..10);\r\nprintln!(\"{}\", v.capacity());\r\n```\r\n\r\n`Vec` allocated 22 elements, while it could allocate just 11.\r\n\r\n`reserve` function must have a property of keeping `push` operation\r\ncost (which calls `reserve`) `O(1)`. To achieve this `reserve` must\r\nexponentialy grow its capacity when it does reallocation.\r\n\r\nThere's better strategy to implement `reserve`:\r\n\r\n```\r\nlet new_capacity = max(current_capacity * 2, requested_capacity);\r\n```\r\n\r\nThis strategy still guarantees that capacity grows at `O(1)` with\r\n`reserve`, and fixes the issue with `extend`.\r\n\r\nPatch imlpements this strategy.", "tree": {"sha": "99fc863475771ccdf0a411c6e9ac9ceb3f9c483f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99fc863475771ccdf0a411c6e9ac9ceb3f9c483f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64b027764302aa67aa701a9f81bd938ca3d4052a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64b027764302aa67aa701a9f81bd938ca3d4052a", "html_url": "https://github.com/rust-lang/rust/commit/64b027764302aa67aa701a9f81bd938ca3d4052a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64b027764302aa67aa701a9f81bd938ca3d4052a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc8d398e28b6b1918ef85479c2d040dfd0fe582d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc8d398e28b6b1918ef85479c2d040dfd0fe582d", "html_url": "https://github.com/rust-lang/rust/commit/cc8d398e28b6b1918ef85479c2d040dfd0fe582d"}, {"sha": "46068c9dafe8cfa763ef855ec21f577a1e058de1", "url": "https://api.github.com/repos/rust-lang/rust/commits/46068c9dafe8cfa763ef855ec21f577a1e058de1", "html_url": "https://github.com/rust-lang/rust/commit/46068c9dafe8cfa763ef855ec21f577a1e058de1"}], "stats": {"total": 52, "additions": 49, "deletions": 3}, "files": [{"sha": "78deed0c84f7f817da9fd2eb3ecf2294d05ecef0", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 49, "deletions": 3, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/64b027764302aa67aa701a9f81bd938ca3d4052a/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64b027764302aa67aa701a9f81bd938ca3d4052a/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=64b027764302aa67aa701a9f81bd938ca3d4052a", "patch": "@@ -15,6 +15,7 @@ use heap;\n use super::oom;\n use super::boxed::Box;\n use core::ops::Drop;\n+use core::cmp;\n use core;\n \n /// A low-level utility for more ergonomically allocating, reallocating, and deallocating a\n@@ -360,9 +361,15 @@ impl<T> RawVec<T> {\n             }\n \n             // Nothing we can really do about these checks :(\n-            let new_cap = used_cap.checked_add(needed_extra_cap)\n-                                  .and_then(|cap| cap.checked_mul(2))\n-                                  .expect(\"capacity overflow\");\n+            let required_cap = used_cap.checked_add(needed_extra_cap)\n+                                       .expect(\"capacity overflow\");\n+\n+            // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n+            let double_cap = self.cap * 2;\n+\n+            // `double_cap` guarantees exponential growth.\n+            let new_cap = cmp::max(double_cap, required_cap);\n+\n             let new_alloc_size = new_cap.checked_mul(elem_size).expect(\"capacity overflow\");\n             // FIXME: may crash and burn on over-reserve\n             alloc_guard(new_alloc_size);\n@@ -486,3 +493,42 @@ fn alloc_guard(alloc_size: usize) {\n                 \"capacity overflow\");\n     }\n }\n+\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn reserve_does_not_overallocate() {\n+        {\n+            let mut v: RawVec<u32> = RawVec::new();\n+            // First `reserve` allocates like `reserve_exact`\n+            v.reserve(0, 9);\n+            assert_eq!(9, v.cap());\n+        }\n+\n+        {\n+            let mut v: RawVec<u32> = RawVec::new();\n+            v.reserve(0, 7);\n+            assert_eq!(7, v.cap());\n+            // 97 if more than double of 7, so `reserve` should work\n+            // like `reserve_exact`.\n+            v.reserve(7, 90);\n+            assert_eq!(97, v.cap());\n+        }\n+\n+        {\n+            let mut v: RawVec<u32> = RawVec::new();\n+            v.reserve(0, 12);\n+            assert_eq!(12, v.cap());\n+            v.reserve(12, 3);\n+            // 3 is less than half of 12, so `reserve` must grow\n+            // exponentially. At the time of writing this test grow\n+            // factor is 2, so new capacity is 24, however, grow factor\n+            // of 1.5 is OK too. Hence `>= 18` in assert.\n+            assert!(v.cap() >= 12 + 12 / 2);\n+        }\n+    }\n+\n+}"}]}