{"sha": "765700ba7a3743b9af5cb12092ea1293dbe07068", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2NTcwMGJhN2EzNzQzYjlhZjVjYjEyMDkyZWExMjkzZGJlMDcwNjg=", "commit": {"author": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2016-09-08T21:48:08Z"}, "committer": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2016-09-09T00:38:47Z"}, "message": "Work around pointer aliasing issue in Vec::extend_from_slice, extend_with_element\n\nDue to missing noalias annotations for &mut T in general (issue #31681),\nin larger programs extend_from_slice and extend_with_element may both\ncompile very poorly. What is observed is that the .set_len() calls are\nnot lifted out of the loop, even for `Vec<u8>`.\n\nUse a local length variable for the Vec length instead, and use a scope\nguard to write this value back to self.len when the scope ends or on\npanic. Then the alias analysis is easy.\n\nThis affects extend_from_slice, extend_with_element, the vec![x; n]\nmacro, Write impls for Vec<u8>, BufWriter, etc (but may / may not\nhave triggered since inlining can be enough for the compiler to get it right).", "tree": {"sha": "b66fd5073367107972f6f1479676d92d201e714e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b66fd5073367107972f6f1479676d92d201e714e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/765700ba7a3743b9af5cb12092ea1293dbe07068", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/765700ba7a3743b9af5cb12092ea1293dbe07068", "html_url": "https://github.com/rust-lang/rust/commit/765700ba7a3743b9af5cb12092ea1293dbe07068", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/765700ba7a3743b9af5cb12092ea1293dbe07068/comments", "author": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5dbf8a0f8843c5466c3866cc2a288c0ef7051d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5dbf8a0f8843c5466c3866cc2a288c0ef7051d2", "html_url": "https://github.com/rust-lang/rust/commit/a5dbf8a0f8843c5466c3866cc2a288c0ef7051d2"}], "stats": {"total": 68, "additions": 55, "deletions": 13}, "files": [{"sha": "7388e88343432934c0f28a3f077e93fb83a8f217", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 55, "deletions": 13, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/765700ba7a3743b9af5cb12092ea1293dbe07068/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/765700ba7a3743b9af5cb12092ea1293dbe07068/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=765700ba7a3743b9af5cb12092ea1293dbe07068", "patch": "@@ -1046,21 +1046,27 @@ impl<T: Clone> Vec<T> {\n         self.reserve(n);\n \n         unsafe {\n-            let len = self.len();\n-            let mut ptr = self.as_mut_ptr().offset(len as isize);\n+            let mut ptr = self.as_mut_ptr().offset(self.len() as isize);\n+            // Use SetLenOnDrop to work around bug where compiler\n+            // may not realize the store through `ptr` trough self.set_len()\n+            // don't alias.\n+            let mut local_len = SetLenOnDrop::new(&mut self.len);\n+\n             // Write all elements except the last one\n-            for i in 1..n {\n+            for _ in 1..n {\n                 ptr::write(ptr, value.clone());\n                 ptr = ptr.offset(1);\n                 // Increment the length in every step in case clone() panics\n-                self.set_len(len + i);\n+                local_len.increment_len(1);\n             }\n \n             if n > 0 {\n                 // We can write the last element directly without cloning needlessly\n                 ptr::write(ptr, value);\n-                self.set_len(len + n);\n+                local_len.increment_len(1);\n             }\n+\n+            // len set by scope guard\n         }\n     }\n \n@@ -1085,20 +1091,56 @@ impl<T: Clone> Vec<T> {\n     pub fn extend_from_slice(&mut self, other: &[T]) {\n         self.reserve(other.len());\n \n-        for i in 0..other.len() {\n+        // Unsafe code so this can be optimised to a memcpy (or something\n+        // similarly fast) when T is Copy. LLVM is easily confused, so any\n+        // extra operations during the loop can prevent this optimisation.\n+        unsafe {\n             let len = self.len();\n-\n-            // Unsafe code so this can be optimised to a memcpy (or something\n-            // similarly fast) when T is Copy. LLVM is easily confused, so any\n-            // extra operations during the loop can prevent this optimisation.\n-            unsafe {\n-                ptr::write(self.get_unchecked_mut(len), other.get_unchecked(i).clone());\n-                self.set_len(len + 1);\n+            let ptr = self.get_unchecked_mut(len) as *mut T;\n+            // Use SetLenOnDrop to work around bug where compiler\n+            // may not realize the store through `ptr` trough self.set_len()\n+            // don't alias.\n+            let mut local_len = SetLenOnDrop::new(&mut self.len);\n+\n+            for i in 0..other.len() {\n+                ptr::write(ptr.offset(i as isize), other.get_unchecked(i).clone());\n+                local_len.increment_len(1);\n             }\n+\n+            // len set by scope guard\n         }\n     }\n }\n \n+// Set the length of the vec when the `SetLenOnDrop` value goes out of scope.\n+//\n+// The idea is: The length field in SetLenOnDrop is a local variable\n+// that the optimizer will see does not alias with any stores through the Vec's data\n+// pointer. This is a workaround for alias analysis issue #32155\n+struct SetLenOnDrop<'a> {\n+    len: &'a mut usize,\n+    local_len: usize,\n+}\n+\n+impl<'a> SetLenOnDrop<'a> {\n+    #[inline]\n+    fn new(len: &'a mut usize) -> Self {\n+        SetLenOnDrop { local_len: *len, len: len }\n+    }\n+\n+    #[inline]\n+    fn increment_len(&mut self, increment: usize) {\n+        self.local_len += increment;\n+    }\n+}\n+\n+impl<'a> Drop for SetLenOnDrop<'a> {\n+    #[inline]\n+    fn drop(&mut self) {\n+        *self.len = self.local_len;\n+    }\n+}\n+\n impl<T: PartialEq> Vec<T> {\n     /// Removes consecutive repeated elements in the vector.\n     ///"}]}