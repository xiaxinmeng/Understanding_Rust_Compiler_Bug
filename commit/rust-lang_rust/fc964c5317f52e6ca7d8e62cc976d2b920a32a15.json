{"sha": "fc964c5317f52e6ca7d8e62cc976d2b920a32a15", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjOTY0YzUzMTdmNTJlNmNhN2Q4ZTYyY2M5NzZkMmI5MjBhMzJhMTU=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-05-06T18:38:59Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-05-20T00:50:05Z"}, "message": "Clean up generator live locals analysis\n\nInstead of using a bespoke dataflow analysis, `MaybeRequiresStorage`,\nfor computing locals that need to be stored across yield points and that\nhave conflicting storage, use a combination of simple, generally\napplicable dataflow analyses. In this case, the formula for locals\nthat are live at a yield point is:\n\n    live_across_yield := (live & init) | (!movable & borrowed)\n\nand the formula for locals that require storage (and thus may conflict\nwith others) at a given point is:\n\n    requires_storage := init | borrowed\n\n`init` is `MaybeInitializedLocals`, a direct equivalent of\n`MaybeInitializedPlaces` that works only on whole `Local`s. `borrowed`\nand `live` are the pre-existing `MaybeBorrowedLocals` and\n`MaybeLiveLocals` analyses respectively.", "tree": {"sha": "650a0ec96070b523451b0900afd925124da222b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/650a0ec96070b523451b0900afd925124da222b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc964c5317f52e6ca7d8e62cc976d2b920a32a15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc964c5317f52e6ca7d8e62cc976d2b920a32a15", "html_url": "https://github.com/rust-lang/rust/commit/fc964c5317f52e6ca7d8e62cc976d2b920a32a15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc964c5317f52e6ca7d8e62cc976d2b920a32a15/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "daea09cf91fdf50c03500784d0f1612db42afd2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/daea09cf91fdf50c03500784d0f1612db42afd2b", "html_url": "https://github.com/rust-lang/rust/commit/daea09cf91fdf50c03500784d0f1612db42afd2b"}], "stats": {"total": 250, "additions": 113, "deletions": 137}, "files": [{"sha": "60d2e865d6b83a9f83394dcb99bbd00a2165f651", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 113, "deletions": 137, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/fc964c5317f52e6ca7d8e62cc976d2b920a32a15/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc964c5317f52e6ca7d8e62cc976d2b920a32a15/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=fc964c5317f52e6ca7d8e62cc976d2b920a32a15", "patch": "@@ -50,7 +50,7 @@\n //! Otherwise it drops all the values in scope at the last suspension point.\n \n use crate::dataflow::impls::{\n-    MaybeBorrowedLocals, MaybeLiveLocals, MaybeRequiresStorage, MaybeStorageLive,\n+    MaybeBorrowedLocals, MaybeInitializedLocals, MaybeLiveLocals, MaybeStorageLive,\n };\n use crate::dataflow::{self, Analysis};\n use crate::transform::no_landing_pads::no_landing_pads;\n@@ -444,86 +444,74 @@ fn locals_live_across_suspend_points(\n     movable: bool,\n ) -> LivenessInfo {\n     let def_id = source.def_id();\n-    let body_ref: &Body<'_> = &body;\n \n     // Calculate when MIR locals have live storage. This gives us an upper bound of their\n     // lifetimes.\n     let mut storage_live = MaybeStorageLive::new(always_live_locals.clone())\n-        .into_engine(tcx, body_ref, def_id)\n+        .into_engine(tcx, body, def_id)\n         .iterate_to_fixpoint()\n-        .into_results_cursor(body_ref);\n-\n-    // Calculate the MIR locals which have been previously\n-    // borrowed (even if they are still active).\n-    let borrowed_locals_results =\n-        MaybeBorrowedLocals::all_borrows().into_engine(tcx, body_ref, def_id).iterate_to_fixpoint();\n-\n-    let mut borrowed_locals_cursor =\n-        dataflow::ResultsCursor::new(body_ref, &borrowed_locals_results);\n-\n-    // Calculate the MIR locals that we actually need to keep storage around\n-    // for.\n-    let requires_storage_results = MaybeRequiresStorage::new(body, &borrowed_locals_results)\n-        .into_engine(tcx, body_ref, def_id)\n-        .iterate_to_fixpoint();\n-    let mut requires_storage_cursor =\n-        dataflow::ResultsCursor::new(body_ref, &requires_storage_results);\n-\n-    // Calculate the liveness of MIR locals ignoring borrows.\n-    let mut liveness = MaybeLiveLocals\n-        .into_engine(tcx, body_ref, def_id)\n+        .into_results_cursor(body);\n+\n+    let mut init = MaybeInitializedLocals\n+        .into_engine(tcx, body, def_id)\n         .iterate_to_fixpoint()\n-        .into_results_cursor(body_ref);\n+        .into_results_cursor(body);\n \n-    let mut storage_liveness_map = IndexVec::from_elem(None, body.basic_blocks());\n-    let mut live_locals_at_suspension_points = Vec::new();\n-    let mut live_locals_at_any_suspension_point = BitSet::new_empty(body.local_decls.len());\n+    let mut live = MaybeLiveLocals\n+        .into_engine(tcx, body, def_id)\n+        .iterate_to_fixpoint()\n+        .into_results_cursor(body);\n \n-    for (block, data) in body.basic_blocks().iter_enumerated() {\n-        if let TerminatorKind::Yield { .. } = data.terminator().kind {\n-            let loc = Location { block, statement_index: data.statements.len() };\n-\n-            liveness.seek_to_block_end(block);\n-            let mut live_locals = liveness.get().clone();\n-\n-            if !movable {\n-                // The `liveness` variable contains the liveness of MIR locals ignoring borrows.\n-                // This is correct for movable generators since borrows cannot live across\n-                // suspension points. However for immovable generators we need to account for\n-                // borrows, so we conseratively assume that all borrowed locals are live until\n-                // we find a StorageDead statement referencing the locals.\n-                // To do this we just union our `liveness` result with `borrowed_locals`, which\n-                // contains all the locals which has been borrowed before this suspension point.\n-                // If a borrow is converted to a raw reference, we must also assume that it lives\n-                // forever. Note that the final liveness is still bounded by the storage liveness\n-                // of the local, which happens using the `intersect` operation below.\n-                borrowed_locals_cursor.seek_before_primary_effect(loc);\n-                live_locals.union(borrowed_locals_cursor.get());\n-            }\n+    let mut borrowed = MaybeBorrowedLocals::all_borrows()\n+        .into_engine(tcx, body, def_id)\n+        .iterate_to_fixpoint()\n+        .into_results_cursor(body);\n \n-            // Store the storage liveness for later use so we can restore the state\n-            // after a suspension point\n-            storage_live.seek_before_primary_effect(loc);\n-            storage_liveness_map[block] = Some(storage_live.get().clone());\n+    // Liveness across yield points is determined by the following boolean equation, where `live`,\n+    // `init` and `borrowed` come from dataflow and `movable` is a property of the generator.\n+    // Movable generators do not allow borrows to live across yield points, so they don't need to\n+    // store a local simply because it is borrowed.\n+    //\n+    //    live_across_yield := (live & init) | (!movable & borrowed)\n+    //\n+    let mut locals_live_across_yield_point = |block| {\n+        live.seek_to_block_end(block);\n+        let mut live_locals = live.get().clone();\n \n-            // Locals live are live at this point only if they are used across\n-            // suspension points (the `liveness` variable)\n-            // and their storage is required (the `storage_required` variable)\n-            requires_storage_cursor.seek_before_primary_effect(loc);\n-            live_locals.intersect(requires_storage_cursor.get());\n+        init.seek_to_block_end(block);\n+        live_locals.intersect(init.get());\n \n-            // The generator argument is ignored.\n-            live_locals.remove(SELF_ARG);\n+        if !movable {\n+            borrowed.seek_to_block_end(block);\n+            live_locals.union(borrowed.get());\n+        }\n \n-            debug!(\"loc = {:?}, live_locals = {:?}\", loc, live_locals);\n+        live_locals\n+    };\n \n-            // Add the locals live at this suspension point to the set of locals which live across\n-            // any suspension points\n-            live_locals_at_any_suspension_point.union(&live_locals);\n+    let mut storage_liveness_map = IndexVec::from_elem(None, body.basic_blocks());\n+    let mut live_locals_at_suspension_points = Vec::new();\n+    let mut live_locals_at_any_suspension_point = BitSet::new_empty(body.local_decls.len());\n \n-            live_locals_at_suspension_points.push(live_locals);\n+    for (block, data) in body.basic_blocks().iter_enumerated() {\n+        if !matches!(data.terminator().kind, TerminatorKind::Yield { ..  }) {\n+            continue;\n         }\n+\n+        // Store the storage liveness for later use so we can restore the state\n+        // after a suspension point\n+        storage_live.seek_to_block_end(block);\n+        storage_liveness_map[block] = Some(storage_live.get().clone());\n+\n+        let mut live_locals = locals_live_across_yield_point(block);\n+\n+        // Ignore the generator's `self` argument since it is handled seperately.\n+        live_locals.remove(SELF_ARG);\n+        debug!(\"block = {:?}, live_locals = {:?}\", block, live_locals);\n+        live_locals_at_any_suspension_point.union(&live_locals);\n+        live_locals_at_suspension_points.push(live_locals);\n     }\n+\n     debug!(\"live_locals_anywhere = {:?}\", live_locals_at_any_suspension_point);\n \n     // Renumber our liveness_map bitsets to include only the locals we are\n@@ -534,10 +522,11 @@ fn locals_live_across_suspend_points(\n         .collect();\n \n     let storage_conflicts = compute_storage_conflicts(\n-        body_ref,\n+        body,\n         &live_locals_at_any_suspension_point,\n         always_live_locals.clone(),\n-        requires_storage_results,\n+        init,\n+        borrowed,\n     );\n \n     LivenessInfo {\n@@ -569,6 +558,33 @@ fn renumber_bitset(\n     out\n }\n \n+/// Record conflicts between locals at the current dataflow cursor positions.\n+///\n+/// You need to seek the cursors before calling this function.\n+fn record_conflicts_at_curr_loc(\n+    local_conflicts: &mut BitMatrix<Local, Local>,\n+    init: &dataflow::ResultsCursor<'mir, 'tcx, MaybeInitializedLocals>,\n+    borrowed: &dataflow::ResultsCursor<'mir, 'tcx, MaybeBorrowedLocals>,\n+) {\n+    // A local requires storage if it is initialized or borrowed. For now, a local\n+    // becomes uninitialized if it is moved from, but is still considered \"borrowed\".\n+    //\n+    //     requires_storage := init | borrowed\n+    //\n+    // FIXME: This function is called in a loop, so it might be better to pass in a temporary\n+    // bitset rather than cloning here.\n+    let mut requires_storage = init.get().clone();\n+    requires_storage.union(borrowed.get());\n+\n+    for local in requires_storage.iter() {\n+        local_conflicts.union_row_with(&requires_storage, local);\n+    }\n+\n+    if requires_storage.count() > 1 {\n+        trace!(\"requires_storage={:?}\", requires_storage);\n+    }\n+}\n+\n /// For every saved local, looks for which locals are StorageLive at the same\n /// time. Generates a bitset for every local of all the other locals that may be\n /// StorageLive simultaneously with that local. This is used in the layout\n@@ -577,30 +593,40 @@ fn compute_storage_conflicts(\n     body: &'mir Body<'tcx>,\n     stored_locals: &BitSet<Local>,\n     always_live_locals: storage::AlwaysLiveLocals,\n-    requires_storage: dataflow::Results<'tcx, MaybeRequiresStorage<'mir, 'tcx>>,\n+    mut init: dataflow::ResultsCursor<'mir, 'tcx, MaybeInitializedLocals>,\n+    mut borrowed: dataflow::ResultsCursor<'mir, 'tcx, MaybeBorrowedLocals>,\n ) -> BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal> {\n-    assert_eq!(body.local_decls.len(), stored_locals.domain_size());\n-\n     debug!(\"compute_storage_conflicts({:?})\", body.span);\n-    debug!(\"always_live = {:?}\", always_live_locals);\n-\n-    // Locals that are always live or ones that need to be stored across\n-    // suspension points are not eligible for overlap.\n-    let mut ineligible_locals = always_live_locals.into_inner();\n-    ineligible_locals.intersect(stored_locals);\n+    assert_eq!(body.local_decls.len(), stored_locals.domain_size());\n \n-    // Compute the storage conflicts for all eligible locals.\n-    let mut visitor = StorageConflictVisitor {\n-        body,\n-        stored_locals: &stored_locals,\n-        local_conflicts: BitMatrix::from_row_n(&ineligible_locals, body.local_decls.len()),\n-    };\n+    // Locals that are always live conflict with all other locals.\n+    //\n+    // FIXME: Why do we need to handle locals without `Storage{Live,Dead}` specially here?\n+    // Shouldn't it be enough to know whether they are initialized?\n+    let always_live_locals = always_live_locals.into_inner();\n+    let mut local_conflicts = BitMatrix::from_row_n(&always_live_locals, body.local_decls.len());\n+\n+    // Visit every reachable statement and terminator. The exact order does not matter. When two\n+    // locals are live at the same point in time, add an entry in the conflict matrix.\n+    for (block, data) in traversal::preorder(body) {\n+        // Ignore unreachable blocks.\n+        if data.terminator().kind == TerminatorKind::Unreachable {\n+            continue;\n+        }\n \n-    // Visit only reachable basic blocks. The exact order is not important.\n-    let reachable_blocks = traversal::preorder(body).map(|(bb, _)| bb);\n-    requires_storage.visit_with(body, reachable_blocks, &mut visitor);\n+        for (statement_index, _) in data.statements.iter().enumerate() {\n+            let loc = Location { block, statement_index };\n+            trace!(\"record conflicts at {:?}\", loc);\n+            init.seek_before_primary_effect(loc);\n+            borrowed.seek_before_primary_effect(loc);\n+            record_conflicts_at_curr_loc(&mut local_conflicts, &init, &borrowed);\n+        }\n \n-    let local_conflicts = visitor.local_conflicts;\n+        trace!(\"record conflicts at end of {:?}\", block);\n+        init.seek_to_block_end(block);\n+        borrowed.seek_to_block_end(block);\n+        record_conflicts_at_curr_loc(&mut local_conflicts, &init, &borrowed);\n+    }\n \n     // Compress the matrix using only stored locals (Local -> GeneratorSavedLocal).\n     //\n@@ -612,7 +638,7 @@ fn compute_storage_conflicts(\n     let mut storage_conflicts = BitMatrix::new(stored_locals.count(), stored_locals.count());\n     for (idx_a, local_a) in stored_locals.iter().enumerate() {\n         let saved_local_a = GeneratorSavedLocal::new(idx_a);\n-        if ineligible_locals.contains(local_a) {\n+        if always_live_locals.contains(local_a) {\n             // Conflicts with everything.\n             storage_conflicts.insert_all_into_row(saved_local_a);\n         } else {\n@@ -628,56 +654,6 @@ fn compute_storage_conflicts(\n     storage_conflicts\n }\n \n-struct StorageConflictVisitor<'mir, 'tcx, 's> {\n-    body: &'mir Body<'tcx>,\n-    stored_locals: &'s BitSet<Local>,\n-    // FIXME(tmandry): Consider using sparse bitsets here once we have good\n-    // benchmarks for generators.\n-    local_conflicts: BitMatrix<Local, Local>,\n-}\n-\n-impl dataflow::ResultsVisitor<'mir, 'tcx> for StorageConflictVisitor<'mir, 'tcx, '_> {\n-    type FlowState = BitSet<Local>;\n-\n-    fn visit_statement_before_primary_effect(\n-        &mut self,\n-        state: &Self::FlowState,\n-        _statement: &'mir Statement<'tcx>,\n-        loc: Location,\n-    ) {\n-        self.apply_state(state, loc);\n-    }\n-\n-    fn visit_terminator_before_primary_effect(\n-        &mut self,\n-        state: &Self::FlowState,\n-        _terminator: &'mir Terminator<'tcx>,\n-        loc: Location,\n-    ) {\n-        self.apply_state(state, loc);\n-    }\n-}\n-\n-impl<'body, 'tcx, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n-    fn apply_state(&mut self, flow_state: &BitSet<Local>, loc: Location) {\n-        // Ignore unreachable blocks.\n-        if self.body.basic_blocks()[loc.block].terminator().kind == TerminatorKind::Unreachable {\n-            return;\n-        }\n-\n-        let mut eligible_storage_live = flow_state.clone();\n-        eligible_storage_live.intersect(&self.stored_locals);\n-\n-        for local in eligible_storage_live.iter() {\n-            self.local_conflicts.union_row_with(&eligible_storage_live, local);\n-        }\n-\n-        if eligible_storage_live.count() > 1 {\n-            trace!(\"at {:?}, eligible_storage_live={:?}\", loc, eligible_storage_live);\n-        }\n-    }\n-}\n-\n fn compute_layout<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     source: MirSource<'tcx>,"}]}