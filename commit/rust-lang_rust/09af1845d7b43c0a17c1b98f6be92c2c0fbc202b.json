{"sha": "09af1845d7b43c0a17c1b98f6be92c2c0fbc202b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5YWYxODQ1ZDdiNDNjMGExN2MxYjk4ZjZiZTkyYzJjMGZiYzIwMmI=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-06-24T21:16:41Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-06-24T21:23:45Z"}, "message": "review comments: clean up code\n\n* deduplicate logic\n* fix typos\n* remove unnecessary state", "tree": {"sha": "f32bbaa1e61dea701aa68e2471721df5ad04e54d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f32bbaa1e61dea701aa68e2471721df5ad04e54d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09af1845d7b43c0a17c1b98f6be92c2c0fbc202b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09af1845d7b43c0a17c1b98f6be92c2c0fbc202b", "html_url": "https://github.com/rust-lang/rust/commit/09af1845d7b43c0a17c1b98f6be92c2c0fbc202b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09af1845d7b43c0a17c1b98f6be92c2c0fbc202b/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5aab1a9a88dd30d622a5303f26d9ad213c551473", "url": "https://api.github.com/repos/rust-lang/rust/commits/5aab1a9a88dd30d622a5303f26d9ad213c551473", "html_url": "https://github.com/rust-lang/rust/commit/5aab1a9a88dd30d622a5303f26d9ad213c551473"}], "stats": {"total": 511, "additions": 214, "deletions": 297}, "files": [{"sha": "ad980fd2f121570b65f3c0f7ac19df6e6e9b32f4", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/09af1845d7b43c0a17c1b98f6be92c2c0fbc202b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09af1845d7b43c0a17c1b98f6be92c2c0fbc202b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=09af1845d7b43c0a17c1b98f6be92c2c0fbc202b", "patch": "@@ -296,8 +296,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         opt_input_types: Option<&[Ty<'tcx>]>,\n     ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n         debug!(\n-            \"lookup_in_trait_adjusted(self_ty={:?}, \\\n-                m_name={}, trait_def_id={:?})\",\n+            \"lookup_in_trait_adjusted(self_ty={:?}, m_name={}, trait_def_id={:?})\",\n             self_ty, m_name, trait_def_id\n         );\n "}, {"sha": "093f76be008653098efc9b660865a6277f042b80", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09af1845d7b43c0a17c1b98f6be92c2c0fbc202b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09af1845d7b43c0a17c1b98f6be92c2c0fbc202b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=09af1845d7b43c0a17c1b98f6be92c2c0fbc202b", "patch": "@@ -379,8 +379,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         self.tcx.sess,\n                         span,\n                         E0699,\n-                        \"the type of this value must be known \\\n-                               to call a method on a raw pointer on it\"\n+                        \"the type of this value must be known to call a method on a raw pointer on \\\n+                         it\"\n                     )\n                     .emit();\n                 } else {"}, {"sha": "0184c00c475b59386038d7ef761e0e27b9ab737a", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 210, "deletions": 292, "changes": 502, "blob_url": "https://github.com/rust-lang/rust/blob/09af1845d7b43c0a17c1b98f6be92c2c0fbc202b/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09af1845d7b43c0a17c1b98f6be92c2c0fbc202b/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=09af1845d7b43c0a17c1b98f6be92c2c0fbc202b", "patch": "@@ -251,303 +251,222 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 method.sig.output()\n             }\n+            // error types are considered \"builtin\"\n+            Err(()) if lhs_ty.references_error() || rhs_ty.references_error() => {\n+                self.tcx.ty_error()\n+            }\n             Err(()) => {\n-                // error types are considered \"builtin\"\n-                if !lhs_ty.references_error() && !rhs_ty.references_error() {\n-                    let source_map = self.tcx.sess.source_map();\n-\n-                    let note = |err: &mut DiagnosticBuilder<'_>, missing_trait| {\n-                        err.note(&format!(\n-                            \"the trait `{}` is not implemented for `{}`\",\n-                            missing_trait, lhs_ty\n-                        ));\n-                    };\n-                    match is_assign {\n-                        IsAssign::Yes => {\n-                            let mut err = struct_span_err!(\n-                                self.tcx.sess,\n-                                expr.span,\n-                                E0368,\n-                                \"binary assignment operation `{}=` cannot be applied to type `{}`\",\n-                                op.node.as_str(),\n+                let source_map = self.tcx.sess.source_map();\n+                let (mut err, missing_trait, use_output, involves_fn) = match is_assign {\n+                    IsAssign::Yes => {\n+                        let mut err = struct_span_err!(\n+                            self.tcx.sess,\n+                            expr.span,\n+                            E0368,\n+                            \"binary assignment operation `{}=` cannot be applied to type `{}`\",\n+                            op.node.as_str(),\n+                            lhs_ty,\n+                        );\n+                        err.span_label(\n+                            lhs_expr.span,\n+                            format!(\"cannot use `{}=` on type `{}`\", op.node.as_str(), lhs_ty),\n+                        );\n+                        let missing_trait = match op.node {\n+                            hir::BinOpKind::Add => Some(\"std::ops::AddAssign\"),\n+                            hir::BinOpKind::Sub => Some(\"std::ops::SubAssign\"),\n+                            hir::BinOpKind::Mul => Some(\"std::ops::MulAssign\"),\n+                            hir::BinOpKind::Div => Some(\"std::ops::DivAssign\"),\n+                            hir::BinOpKind::Rem => Some(\"std::ops::RemAssign\"),\n+                            hir::BinOpKind::BitAnd => Some(\"std::ops::BitAndAssign\"),\n+                            hir::BinOpKind::BitXor => Some(\"std::ops::BitXorAssign\"),\n+                            hir::BinOpKind::BitOr => Some(\"std::ops::BitOrAssign\"),\n+                            hir::BinOpKind::Shl => Some(\"std::ops::ShlAssign\"),\n+                            hir::BinOpKind::Shr => Some(\"std::ops::ShrAssign\"),\n+                            _ => None,\n+                        };\n+                        (err, missing_trait, false, false)\n+                    }\n+                    IsAssign::No => {\n+                        let (message, missing_trait, use_output) = match op.node {\n+                            hir::BinOpKind::Add => (\n+                                format!(\"cannot add `{}` to `{}`\", rhs_ty, lhs_ty),\n+                                Some(\"std::ops::Add\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::Sub => (\n+                                format!(\"cannot subtract `{}` from `{}`\", rhs_ty, lhs_ty),\n+                                Some(\"std::ops::Sub\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::Mul => (\n+                                format!(\"cannot multiply `{}` to `{}`\", rhs_ty, lhs_ty),\n+                                Some(\"std::ops::Mul\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::Div => (\n+                                format!(\"cannot divide `{}` by `{}`\", lhs_ty, rhs_ty),\n+                                Some(\"std::ops::Div\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::Rem => (\n+                                format!(\"cannot mod `{}` by `{}`\", lhs_ty, rhs_ty),\n+                                Some(\"std::ops::Rem\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::BitAnd => (\n+                                format!(\"no implementation for `{} & {}`\", lhs_ty, rhs_ty),\n+                                Some(\"std::ops::BitAnd\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::BitXor => (\n+                                format!(\"no implementation for `{} ^ {}`\", lhs_ty, rhs_ty),\n+                                Some(\"std::ops::BitXor\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::BitOr => (\n+                                format!(\"no implementation for `{} | {}`\", lhs_ty, rhs_ty),\n+                                Some(\"std::ops::BitOr\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::Shl => (\n+                                format!(\"no implementation for `{} << {}`\", lhs_ty, rhs_ty),\n+                                Some(\"std::ops::Shl\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::Shr => (\n+                                format!(\"no implementation for `{} >> {}`\", lhs_ty, rhs_ty),\n+                                Some(\"std::ops::Shr\"),\n+                                true,\n+                            ),\n+                            hir::BinOpKind::Eq | hir::BinOpKind::Ne => (\n+                                format!(\n+                                    \"binary operation `{}` cannot be applied to type `{}`\",\n+                                    op.node.as_str(),\n+                                    lhs_ty\n+                                ),\n+                                Some(\"std::cmp::PartialEq\"),\n+                                false,\n+                            ),\n+                            hir::BinOpKind::Lt\n+                            | hir::BinOpKind::Le\n+                            | hir::BinOpKind::Gt\n+                            | hir::BinOpKind::Ge => (\n+                                format!(\n+                                    \"binary operation `{}` cannot be applied to type `{}`\",\n+                                    op.node.as_str(),\n+                                    lhs_ty\n+                                ),\n+                                Some(\"std::cmp::PartialOrd\"),\n+                                false,\n+                            ),\n+                            _ => (\n+                                format!(\n+                                    \"binary operation `{}` cannot be applied to type `{}`\",\n+                                    op.node.as_str(),\n+                                    lhs_ty\n+                                ),\n+                                None,\n+                                false,\n+                            ),\n+                        };\n+                        let mut err =\n+                            struct_span_err!(self.tcx.sess, op.span, E0369, \"{}\", message.as_str());\n+                        let mut involves_fn = false;\n+                        if !lhs_expr.span.eq(&rhs_expr.span) {\n+                            involves_fn |= self.add_type_neq_err_label(\n+                                &mut err,\n+                                lhs_expr.span,\n                                 lhs_ty,\n+                                rhs_ty,\n+                                op,\n+                                is_assign,\n                             );\n-                            err.span_label(\n-                                lhs_expr.span,\n-                                format!(\"cannot use `{}=` on type `{}`\", op.node.as_str(), lhs_ty),\n+                            involves_fn |= self.add_type_neq_err_label(\n+                                &mut err,\n+                                rhs_expr.span,\n+                                rhs_ty,\n+                                lhs_ty,\n+                                op,\n+                                is_assign,\n                             );\n-                            let mut suggested_deref = false;\n-                            if let Ref(_, rty, _) = lhs_ty.kind {\n-                                if {\n-                                    self.infcx.type_is_copy_modulo_regions(\n-                                        self.param_env,\n-                                        rty,\n-                                        lhs_expr.span,\n-                                    ) && self\n-                                        .lookup_op_method(rty, &[rhs_ty], Op::Binary(op, is_assign))\n-                                        .is_ok()\n-                                } {\n-                                    if let Ok(lstring) = source_map.span_to_snippet(lhs_expr.span) {\n-                                        let msg = &format!(\n-                                            \"`{}=` can be used on '{}', you can dereference `{}`\",\n-                                            op.node.as_str(),\n-                                            rty.peel_refs(),\n-                                            lstring,\n-                                        );\n-                                        err.span_suggestion_verbose(\n-                                            lhs_expr.span.shrink_to_lo(),\n-                                            msg,\n-                                            \"*\".to_string(),\n-                                            rustc_errors::Applicability::MachineApplicable,\n-                                        );\n-                                        suggested_deref = true;\n-                                    }\n-                                }\n-                            }\n-                            let missing_trait = match op.node {\n-                                hir::BinOpKind::Add => Some(\"std::ops::AddAssign\"),\n-                                hir::BinOpKind::Sub => Some(\"std::ops::SubAssign\"),\n-                                hir::BinOpKind::Mul => Some(\"std::ops::MulAssign\"),\n-                                hir::BinOpKind::Div => Some(\"std::ops::DivAssign\"),\n-                                hir::BinOpKind::Rem => Some(\"std::ops::RemAssign\"),\n-                                hir::BinOpKind::BitAnd => Some(\"std::ops::BitAndAssign\"),\n-                                hir::BinOpKind::BitXor => Some(\"std::ops::BitXorAssign\"),\n-                                hir::BinOpKind::BitOr => Some(\"std::ops::BitOrAssign\"),\n-                                hir::BinOpKind::Shl => Some(\"std::ops::ShlAssign\"),\n-                                hir::BinOpKind::Shr => Some(\"std::ops::ShrAssign\"),\n-                                _ => None,\n-                            };\n-                            if let Some(missing_trait) = missing_trait {\n-                                let mut visitor = TypeParamVisitor(vec![]);\n-                                visitor.visit_ty(lhs_ty);\n-\n-                                let mut sugg = false;\n-                                if op.node == hir::BinOpKind::Add\n-                                    && self.check_str_addition(\n-                                        lhs_expr, rhs_expr, lhs_ty, rhs_ty, &mut err, true, op,\n-                                    )\n-                                {\n-                                    // This has nothing here because it means we did string\n-                                    // concatenation (e.g., \"Hello \" += \"World!\"). This means\n-                                    // we don't want the note in the else clause to be emitted\n-                                    sugg = true;\n-                                } else if let [ty] = &visitor.0[..] {\n-                                    if let ty::Param(p) = ty.kind {\n-                                        // FIXME: This *guesses* that constraining the type param\n-                                        // will make the operation available, but this is only true\n-                                        // when the corresponding trait has a blanked\n-                                        // implementation, like the following:\n-                                        // `impl<'a> PartialEq for &'a [T] where T: PartialEq {}`\n-                                        // The correct thing to do would be to verify this\n-                                        // projection would hold.\n-                                        if *ty != lhs_ty {\n-                                            note(&mut err, missing_trait);\n-                                        }\n-                                        suggest_constraining_param(\n-                                            self.tcx,\n-                                            self.body_id,\n-                                            &mut err,\n-                                            ty,\n-                                            rhs_ty,\n-                                            missing_trait,\n-                                            p,\n-                                            false,\n-                                        );\n-                                        sugg = true;\n-                                    }\n-                                }\n-                                if !sugg && !suggested_deref {\n-                                    suggest_impl_missing(&mut err, lhs_ty, &missing_trait);\n-                                }\n-                            }\n-                            err.emit();\n                         }\n-                        IsAssign::No => {\n-                            let (message, missing_trait, use_output) = match op.node {\n-                                hir::BinOpKind::Add => (\n-                                    format!(\"cannot add `{}` to `{}`\", rhs_ty, lhs_ty),\n-                                    Some(\"std::ops::Add\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::Sub => (\n-                                    format!(\"cannot subtract `{}` from `{}`\", rhs_ty, lhs_ty),\n-                                    Some(\"std::ops::Sub\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::Mul => (\n-                                    format!(\"cannot multiply `{}` to `{}`\", rhs_ty, lhs_ty),\n-                                    Some(\"std::ops::Mul\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::Div => (\n-                                    format!(\"cannot divide `{}` by `{}`\", lhs_ty, rhs_ty),\n-                                    Some(\"std::ops::Div\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::Rem => (\n-                                    format!(\"cannot mod `{}` by `{}`\", lhs_ty, rhs_ty),\n-                                    Some(\"std::ops::Rem\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::BitAnd => (\n-                                    format!(\"no implementation for `{} & {}`\", lhs_ty, rhs_ty),\n-                                    Some(\"std::ops::BitAnd\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::BitXor => (\n-                                    format!(\"no implementation for `{} ^ {}`\", lhs_ty, rhs_ty),\n-                                    Some(\"std::ops::BitXor\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::BitOr => (\n-                                    format!(\"no implementation for `{} | {}`\", lhs_ty, rhs_ty),\n-                                    Some(\"std::ops::BitOr\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::Shl => (\n-                                    format!(\"no implementation for `{} << {}`\", lhs_ty, rhs_ty),\n-                                    Some(\"std::ops::Shl\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::Shr => (\n-                                    format!(\"no implementation for `{} >> {}`\", lhs_ty, rhs_ty),\n-                                    Some(\"std::ops::Shr\"),\n-                                    true,\n-                                ),\n-                                hir::BinOpKind::Eq | hir::BinOpKind::Ne => (\n-                                    format!(\n-                                        \"binary operation `{}` cannot be applied to type `{}`\",\n-                                        op.node.as_str(),\n-                                        lhs_ty\n-                                    ),\n-                                    Some(\"std::cmp::PartialEq\"),\n-                                    false,\n-                                ),\n-                                hir::BinOpKind::Lt\n-                                | hir::BinOpKind::Le\n-                                | hir::BinOpKind::Gt\n-                                | hir::BinOpKind::Ge => (\n-                                    format!(\n-                                        \"binary operation `{}` cannot be applied to type `{}`\",\n-                                        op.node.as_str(),\n-                                        lhs_ty\n-                                    ),\n-                                    Some(\"std::cmp::PartialOrd\"),\n-                                    false,\n-                                ),\n-                                _ => (\n-                                    format!(\n-                                        \"binary operation `{}` cannot be applied to type `{}`\",\n-                                        op.node.as_str(),\n-                                        lhs_ty\n-                                    ),\n-                                    None,\n-                                    false,\n-                                ),\n-                            };\n-                            let mut err = struct_span_err!(\n-                                self.tcx.sess,\n-                                op.span,\n-                                E0369,\n-                                \"{}\",\n-                                message.as_str()\n+                        (err, missing_trait, use_output, involves_fn)\n+                    }\n+                };\n+                let mut suggested_deref = false;\n+                if let Ref(_, rty, _) = lhs_ty.kind {\n+                    if {\n+                        self.infcx.type_is_copy_modulo_regions(self.param_env, rty, lhs_expr.span)\n+                            && self\n+                                .lookup_op_method(rty, &[rhs_ty], Op::Binary(op, is_assign))\n+                                .is_ok()\n+                    } {\n+                        if let Ok(lstring) = source_map.span_to_snippet(lhs_expr.span) {\n+                            let msg = &format!(\n+                                \"`{}{}` can be used on `{}`, you can dereference `{}`\",\n+                                op.node.as_str(),\n+                                match is_assign {\n+                                    IsAssign::Yes => \"=\",\n+                                    IsAssign::No => \"\",\n+                                },\n+                                rty.peel_refs(),\n+                                lstring,\n                             );\n-\n-                            let mut involves_fn = false;\n-                            if !lhs_expr.span.eq(&rhs_expr.span) {\n-                                involves_fn |= self.add_type_neq_err_label(\n-                                    &mut err,\n-                                    lhs_expr.span,\n-                                    lhs_ty,\n-                                    rhs_ty,\n-                                    op,\n-                                    is_assign,\n-                                );\n-                                involves_fn |= self.add_type_neq_err_label(\n-                                    &mut err,\n-                                    rhs_expr.span,\n-                                    rhs_ty,\n-                                    lhs_ty,\n-                                    op,\n-                                    is_assign,\n-                                );\n-                            }\n-\n-                            let mut suggested_deref = false;\n-                            if let Ref(_, rty, _) = lhs_ty.kind {\n-                                if {\n-                                    self.infcx.type_is_copy_modulo_regions(\n-                                        self.param_env,\n-                                        rty,\n-                                        lhs_expr.span,\n-                                    ) && self\n-                                        .lookup_op_method(rty, &[rhs_ty], Op::Binary(op, is_assign))\n-                                        .is_ok()\n-                                } {\n-                                    if let Ok(lstring) = source_map.span_to_snippet(lhs_expr.span) {\n-                                        err.span_suggestion_verbose(\n-                                            lhs_expr.span.shrink_to_lo(),\n-                                            &format!(\n-                                                \"`{}` can be used on `{}`, you can dereference \\\n-                                                 `{}`\",\n-                                                op.node.as_str(),\n-                                                rty.peel_refs(),\n-                                                lstring,\n-                                            ),\n-                                            \"*\".to_string(),\n-                                            Applicability::MachineApplicable,\n-                                        );\n-                                        suggested_deref = true;\n-                                    }\n-                                }\n-                            }\n-                            if let Some(missing_trait) = missing_trait {\n-                                let mut visitor = TypeParamVisitor(vec![]);\n-                                visitor.visit_ty(lhs_ty);\n-\n-                                let mut sugg = false;\n-                                if op.node == hir::BinOpKind::Add\n-                                    && self.check_str_addition(\n-                                        lhs_expr, rhs_expr, lhs_ty, rhs_ty, &mut err, false, op,\n-                                    )\n-                                {\n-                                    // This has nothing here because it means we did string\n-                                    // concatenation (e.g., \"Hello \" + \"World!\"). This means\n-                                    // we don't want the note in the else clause to be emitted\n-                                    sugg = true;\n-                                } else if let [ty] = &visitor.0[..] {\n-                                    if let ty::Param(p) = ty.kind {\n-                                        // FIXME: This *guesses* that constraining the type param\n-                                        // will make the operation available, but this is only true\n-                                        // when the corresponding trait has a blanked\n-                                        // implementation, like the following:\n-                                        // `impl<'a> PartialEq for &'a [T] where T: PartialEq {}`\n-                                        // The correct thing to do would be to verify this\n-                                        // projection would hold.\n-                                        if *ty != lhs_ty {\n-                                            note(&mut err, missing_trait);\n-                                        }\n-                                        suggest_constraining_param(\n-                                            self.tcx,\n-                                            self.body_id,\n-                                            &mut err,\n-                                            ty,\n-                                            rhs_ty,\n-                                            missing_trait,\n-                                            p,\n-                                            use_output,\n-                                        );\n-                                        sugg = true;\n-                                    }\n-                                }\n-                                if !sugg && !suggested_deref && !involves_fn {\n-                                    suggest_impl_missing(&mut err, lhs_ty, &missing_trait);\n-                                }\n+                            err.span_suggestion_verbose(\n+                                lhs_expr.span.shrink_to_lo(),\n+                                msg,\n+                                \"*\".to_string(),\n+                                rustc_errors::Applicability::MachineApplicable,\n+                            );\n+                            suggested_deref = true;\n+                        }\n+                    }\n+                }\n+                if let Some(missing_trait) = missing_trait {\n+                    let mut visitor = TypeParamVisitor(vec![]);\n+                    visitor.visit_ty(lhs_ty);\n+\n+                    if op.node == hir::BinOpKind::Add\n+                        && self.check_str_addition(\n+                            lhs_expr, rhs_expr, lhs_ty, rhs_ty, &mut err, is_assign, op,\n+                        )\n+                    {\n+                        // This has nothing here because it means we did string\n+                        // concatenation (e.g., \"Hello \" + \"World!\"). This means\n+                        // we don't want the note in the else clause to be emitted\n+                    } else if let [ty] = &visitor.0[..] {\n+                        if let ty::Param(p) = ty.kind {\n+                            // FIXME: This *guesses* that constraining the type param\n+                            // will make the operation available, but this is only true\n+                            // when the corresponding trait has a blanket\n+                            // implementation, like the following:\n+                            // `impl<'a> PartialEq for &'a [T] where T: PartialEq {}`\n+                            // The correct thing to do would be to verify this\n+                            // projection would hold.\n+                            if *ty != lhs_ty {\n+                                err.note(&format!(\n+                                    \"the trait `{}` is not implemented for `{}`\",\n+                                    missing_trait, lhs_ty\n+                                ));\n                             }\n-                            err.emit();\n+                            suggest_constraining_param(\n+                                self.tcx,\n+                                self.body_id,\n+                                &mut err,\n+                                ty,\n+                                rhs_ty,\n+                                missing_trait,\n+                                p,\n+                                use_output,\n+                            );\n+                        } else {\n+                            bug!(\"type param visitor stored a non type param: {:?}\", ty.kind);\n                         }\n+                    } else if !suggested_deref && !involves_fn {\n+                        suggest_impl_missing(&mut err, lhs_ty, &missing_trait);\n                     }\n                 }\n+                err.emit();\n                 self.tcx.ty_error()\n             }\n         };\n@@ -621,7 +540,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         lhs_ty: Ty<'tcx>,\n         rhs_ty: Ty<'tcx>,\n         err: &mut rustc_errors::DiagnosticBuilder<'_>,\n-        is_assign: bool,\n+        is_assign: IsAssign,\n         op: hir::BinOp,\n     ) -> bool {\n         let source_map = self.tcx.sess.source_map();\n@@ -644,7 +563,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         &format!(\"{:?}\", rhs_ty) == \"&&str\"\n                     ) =>\n             {\n-                if !is_assign { // Do not supply this message if `&str += &str`\n+                if let IsAssign::No = is_assign { // Do not supply this message if `&str += &str`\n                     err.span_label(\n                         op.span,\n                         \"`+` cannot be used to concatenate two `&str` strings\",\n@@ -685,7 +604,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     source_map.span_to_snippet(rhs_expr.span),\n                     is_assign,\n                 ) {\n-                    (Ok(l), Ok(r), false) => {\n+                    (Ok(l), Ok(r), IsAssign::No) => {\n                         let to_string = if l.starts_with('&') {\n                             // let a = String::new(); let b = String::new();\n                             // let _ = &a + b;\n@@ -738,8 +657,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     err.span_label(\n                         ex.span,\n                         format!(\n-                            \"cannot apply unary \\\n-                                                    operator `{}`\",\n+                            \"cannot apply unary operator `{}`\",\n                             op.as_str()\n                         ),\n                     );"}, {"sha": "078a7ef2173bd349961bca1d9f8ff5eca58e788e", "filename": "src/test/ui/issues/issue-5239-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09af1845d7b43c0a17c1b98f6be92c2c0fbc202b/src%2Ftest%2Fui%2Fissues%2Fissue-5239-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09af1845d7b43c0a17c1b98f6be92c2c0fbc202b/src%2Ftest%2Fui%2Fissues%2Fissue-5239-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5239-1.stderr?ref=09af1845d7b43c0a17c1b98f6be92c2c0fbc202b", "patch": "@@ -6,7 +6,7 @@ LL |     let x = |ref x: isize| { x += 1; };\n    |                              |\n    |                              cannot use `+=` on type `&isize`\n    |\n-help: `+=` can be used on 'isize', you can dereference `x`\n+help: `+=` can be used on `isize`, you can dereference `x`\n    |\n LL |     let x = |ref x: isize| { *x += 1; };\n    |                              ^"}]}