{"sha": "8ee962f88e1be7e29482b13c7776c26b98a93bf7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlZTk2MmY4OGUxYmU3ZTI5NDgyYjEzYzc3NzZjMjZiOThhOTNiZjc=", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-08-06T16:46:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-06T16:46:33Z"}, "message": "Rollup merge of #87775 - Kobzol:single-associated-item-hint, r=oli-obk\n\nAdd hint for unresolved associated trait items if the trait has a single item\n\nThis PR introduces a special-cased hint for unresolved trait items paths. It is shown if:\n- the path was not resolved to any existing trait item\n- and no existing trait item's name was reasonably close with regard to edit distance\n- and the trait only has a single item in the corresponding namespace\n\nI didn't know where I should put tests, therefore so far I just managed to bless two existing tests. I would be glad for hints where should tests for a hint like this be created, how should they be named (with reference to the original issue?) and what tests should I create (is it enough to test it just for types? or create separate tests also for functions and constants?).\n\nIt could also be turned into a machine applicable suggestion I suppose.\n\nThis is my first `rustc` PR, so please go easy on me :)\n\nFixes: https://github.com/rust-lang/rust/issues/87638", "tree": {"sha": "2ffb547ab09085b2502bfdbf2b11d2445365c663", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ffb547ab09085b2502bfdbf2b11d2445365c663"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ee962f88e1be7e29482b13c7776c26b98a93bf7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhDWdpCRBK7hj4Ov3rIwAAt1wIAJlbiUY7nmF9bvZZZ+VV0Y0V\nLUC06M1yBfHCg3bBmgsS3mHhmXtHhrkK4ffvoqKOv2XZvT6EUxuksZnydUQNRJJ9\nWwt9j63JRW3ZSPWr85KxjxRLBtXzwAUA34wuAugZU+UbohhL4Zd5UExah0QbnTrM\nXXvKLlUTt4/gqlzTrlUYeDQMwgoH4QmevKPjxA1EuKk0JXMEQM6m6o44ZxASuomR\n16jQZa4FUkFZRFWP1Is996uZKHQEVslCUMvlyiD2or9xEtU8TJXMadtnmbpxZ7FV\nTd+ugg25YNHLFCbokfm3rD7PYMyfKViB/31mT/Ng4PJY4q5Sz2/50/oc11E02LQ=\n=BOZi\n-----END PGP SIGNATURE-----\n", "payload": "tree 2ffb547ab09085b2502bfdbf2b11d2445365c663\nparent 3b0e797ee6678175d1df9a01e944312b348d05b0\nparent d0d49477755cead57aa20a4958562e7ca6e8f805\nauthor Yuki Okushi <jtitor@2k36.org> 1628268393 +0900\ncommitter GitHub <noreply@github.com> 1628268393 +0900\n\nRollup merge of #87775 - Kobzol:single-associated-item-hint, r=oli-obk\n\nAdd hint for unresolved associated trait items if the trait has a single item\n\nThis PR introduces a special-cased hint for unresolved trait items paths. It is shown if:\n- the path was not resolved to any existing trait item\n- and no existing trait item's name was reasonably close with regard to edit distance\n- and the trait only has a single item in the corresponding namespace\n\nI didn't know where I should put tests, therefore so far I just managed to bless two existing tests. I would be glad for hints where should tests for a hint like this be created, how should they be named (with reference to the original issue?) and what tests should I create (is it enough to test it just for types? or create separate tests also for functions and constants?).\n\nIt could also be turned into a machine applicable suggestion I suppose.\n\nThis is my first `rustc` PR, so please go easy on me :)\n\nFixes: https://github.com/rust-lang/rust/issues/87638\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ee962f88e1be7e29482b13c7776c26b98a93bf7", "html_url": "https://github.com/rust-lang/rust/commit/8ee962f88e1be7e29482b13c7776c26b98a93bf7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ee962f88e1be7e29482b13c7776c26b98a93bf7/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b0e797ee6678175d1df9a01e944312b348d05b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b0e797ee6678175d1df9a01e944312b348d05b0", "html_url": "https://github.com/rust-lang/rust/commit/3b0e797ee6678175d1df9a01e944312b348d05b0"}, {"sha": "d0d49477755cead57aa20a4958562e7ca6e8f805", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0d49477755cead57aa20a4958562e7ca6e8f805", "html_url": "https://github.com/rust-lang/rust/commit/d0d49477755cead57aa20a4958562e7ca6e8f805"}], "stats": {"total": 200, "additions": 172, "deletions": 28}, "files": [{"sha": "0a5da653fab07de4a46799e4fa3feab4471d40f3", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 43, "deletions": 19, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/8ee962f88e1be7e29482b13c7776c26b98a93bf7/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee962f88e1be7e29482b13c7776c26b98a93bf7/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=8ee962f88e1be7e29482b13c7776c26b98a93bf7", "patch": "@@ -38,14 +38,25 @@ crate type Suggestion = (Vec<(Span, String)>, String, Applicability);\n /// similarly named label and whether or not it is reachable.\n crate type LabelSuggestion = (Ident, bool);\n \n+crate enum SuggestionTarget {\n+    /// The target has a similar name as the name used by the programmer (probably a typo)\n+    SimilarlyNamed,\n+    /// The target is the only valid item that can be used in the corresponding context\n+    SingleItem,\n+}\n+\n crate struct TypoSuggestion {\n     pub candidate: Symbol,\n     pub res: Res,\n+    pub target: SuggestionTarget,\n }\n \n impl TypoSuggestion {\n-    crate fn from_res(candidate: Symbol, res: Res) -> TypoSuggestion {\n-        TypoSuggestion { candidate, res }\n+    crate fn typo_from_res(candidate: Symbol, res: Res) -> TypoSuggestion {\n+        Self { candidate, res, target: SuggestionTarget::SimilarlyNamed }\n+    }\n+    crate fn single_item_from_res(candidate: Symbol, res: Res) -> TypoSuggestion {\n+        Self { candidate, res, target: SuggestionTarget::SingleItem }\n     }\n }\n \n@@ -80,7 +91,7 @@ impl<'a> Resolver<'a> {\n             if let Some(binding) = resolution.borrow().binding {\n                 let res = binding.res();\n                 if filter_fn(res) {\n-                    names.push(TypoSuggestion::from_res(key.ident.name, res));\n+                    names.push(TypoSuggestion::typo_from_res(key.ident.name, res));\n                 }\n             }\n         }\n@@ -623,7 +634,7 @@ impl<'a> Resolver<'a> {\n                                 .get(&expn_id)\n                                 .into_iter()\n                                 .flatten()\n-                                .map(|ident| TypoSuggestion::from_res(ident.name, res)),\n+                                .map(|ident| TypoSuggestion::typo_from_res(ident.name, res)),\n                         );\n                     }\n                 }\n@@ -642,7 +653,7 @@ impl<'a> Resolver<'a> {\n                                 suggestions.extend(\n                                     ext.helper_attrs\n                                         .iter()\n-                                        .map(|name| TypoSuggestion::from_res(*name, res)),\n+                                        .map(|name| TypoSuggestion::typo_from_res(*name, res)),\n                                 );\n                             }\n                         }\n@@ -652,8 +663,10 @@ impl<'a> Resolver<'a> {\n                     if let MacroRulesScope::Binding(macro_rules_binding) = macro_rules_scope.get() {\n                         let res = macro_rules_binding.binding.res();\n                         if filter_fn(res) {\n-                            suggestions\n-                                .push(TypoSuggestion::from_res(macro_rules_binding.ident.name, res))\n+                            suggestions.push(TypoSuggestion::typo_from_res(\n+                                macro_rules_binding.ident.name,\n+                                res,\n+                            ))\n                         }\n                     }\n                 }\n@@ -671,15 +684,15 @@ impl<'a> Resolver<'a> {\n                         suggestions.extend(\n                             this.registered_attrs\n                                 .iter()\n-                                .map(|ident| TypoSuggestion::from_res(ident.name, res)),\n+                                .map(|ident| TypoSuggestion::typo_from_res(ident.name, res)),\n                         );\n                     }\n                 }\n                 Scope::MacroUsePrelude => {\n                     suggestions.extend(this.macro_use_prelude.iter().filter_map(\n                         |(name, binding)| {\n                             let res = binding.res();\n-                            filter_fn(res).then_some(TypoSuggestion::from_res(*name, res))\n+                            filter_fn(res).then_some(TypoSuggestion::typo_from_res(*name, res))\n                         },\n                     ));\n                 }\n@@ -689,22 +702,22 @@ impl<'a> Resolver<'a> {\n                         suggestions.extend(\n                             BUILTIN_ATTRIBUTES\n                                 .iter()\n-                                .map(|(name, ..)| TypoSuggestion::from_res(*name, res)),\n+                                .map(|(name, ..)| TypoSuggestion::typo_from_res(*name, res)),\n                         );\n                     }\n                 }\n                 Scope::ExternPrelude => {\n                     suggestions.extend(this.extern_prelude.iter().filter_map(|(ident, _)| {\n                         let res = Res::Def(DefKind::Mod, DefId::local(CRATE_DEF_INDEX));\n-                        filter_fn(res).then_some(TypoSuggestion::from_res(ident.name, res))\n+                        filter_fn(res).then_some(TypoSuggestion::typo_from_res(ident.name, res))\n                     }));\n                 }\n                 Scope::ToolPrelude => {\n                     let res = Res::NonMacroAttr(NonMacroAttrKind::Tool);\n                     suggestions.extend(\n                         this.registered_tools\n                             .iter()\n-                            .map(|ident| TypoSuggestion::from_res(ident.name, res)),\n+                            .map(|ident| TypoSuggestion::typo_from_res(ident.name, res)),\n                     );\n                 }\n                 Scope::StdLibPrelude => {\n@@ -721,7 +734,7 @@ impl<'a> Resolver<'a> {\n                 Scope::BuiltinTypes => {\n                     suggestions.extend(PrimTy::ALL.iter().filter_map(|prim_ty| {\n                         let res = Res::PrimTy(*prim_ty);\n-                        filter_fn(res).then_some(TypoSuggestion::from_res(prim_ty.name(), res))\n+                        filter_fn(res).then_some(TypoSuggestion::typo_from_res(prim_ty.name(), res))\n                     }))\n                 }\n             }\n@@ -993,20 +1006,31 @@ impl<'a> Resolver<'a> {\n                 //    |              ^\n                 return false;\n             }\n+            let prefix = match suggestion.target {\n+                SuggestionTarget::SimilarlyNamed => \"similarly named \",\n+                SuggestionTarget::SingleItem => \"\",\n+            };\n+\n             err.span_label(\n                 self.session.source_map().guess_head_span(def_span),\n                 &format!(\n-                    \"similarly named {} `{}` defined here\",\n+                    \"{}{} `{}` defined here\",\n+                    prefix,\n                     suggestion.res.descr(),\n                     suggestion.candidate.as_str(),\n                 ),\n             );\n         }\n-        let msg = format!(\n-            \"{} {} with a similar name exists\",\n-            suggestion.res.article(),\n-            suggestion.res.descr()\n-        );\n+        let msg = match suggestion.target {\n+            SuggestionTarget::SimilarlyNamed => format!(\n+                \"{} {} with a similar name exists\",\n+                suggestion.res.article(),\n+                suggestion.res.descr()\n+            ),\n+            SuggestionTarget::SingleItem => {\n+                format!(\"maybe you meant this {}\", suggestion.res.descr())\n+            }\n+        };\n         err.span_suggestion(\n             span,\n             &msg,"}, {"sha": "7c97a17b454069c253f277429ccbcb8b14b093ec", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 45, "deletions": 7, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/8ee962f88e1be7e29482b13c7776c26b98a93bf7/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee962f88e1be7e29482b13c7776c26b98a93bf7/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=8ee962f88e1be7e29482b13c7776c26b98a93bf7", "patch": "@@ -541,6 +541,10 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                     }\n                     _ => {}\n                 }\n+\n+                // If the trait has a single item (which wasn't matched by Levenshtein), suggest it\n+                let suggestion = self.get_single_associated_item(&path, span, &source, is_expected);\n+                self.r.add_typo_suggestion(&mut err, suggestion, ident_span);\n             }\n             if fallback {\n                 // Fallback label.\n@@ -585,6 +589,40 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         (err, candidates)\n     }\n \n+    fn get_single_associated_item(\n+        &mut self,\n+        path: &[Segment],\n+        span: Span,\n+        source: &PathSource<'_>,\n+        filter_fn: &impl Fn(Res) -> bool,\n+    ) -> Option<TypoSuggestion> {\n+        if let crate::PathSource::TraitItem(_) = source {\n+            let mod_path = &path[..path.len() - 1];\n+            if let PathResult::Module(ModuleOrUniformRoot::Module(module)) =\n+                self.resolve_path(mod_path, None, false, span, CrateLint::No)\n+            {\n+                let resolutions = self.r.resolutions(module).borrow();\n+                let targets: Vec<_> =\n+                    resolutions\n+                        .iter()\n+                        .filter_map(|(key, resolution)| {\n+                            resolution.borrow().binding.map(|binding| binding.res()).and_then(\n+                                |res| if filter_fn(res) { Some((key, res)) } else { None },\n+                            )\n+                        })\n+                        .collect();\n+                if targets.len() == 1 {\n+                    let target = targets[0];\n+                    return Some(TypoSuggestion::single_item_from_res(\n+                        target.0.ident.name,\n+                        target.1,\n+                    ));\n+                }\n+            }\n+        }\n+        None\n+    }\n+\n     /// Given `where <T as Bar>::Baz: String`, suggest `where T: Bar<Baz = String>`.\n     fn restrict_assoc_type_in_where_clause(\n         &mut self,\n@@ -1208,7 +1246,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 // Locals and type parameters\n                 for (ident, &res) in &rib.bindings {\n                     if filter_fn(res) {\n-                        names.push(TypoSuggestion::from_res(ident.name, res));\n+                        names.push(TypoSuggestion::typo_from_res(ident.name, res));\n                     }\n                 }\n                 // Items in scope\n@@ -1231,7 +1269,9 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                                         );\n \n                                         if filter_fn(crate_mod) {\n-                                            Some(TypoSuggestion::from_res(ident.name, crate_mod))\n+                                            Some(TypoSuggestion::typo_from_res(\n+                                                ident.name, crate_mod,\n+                                            ))\n                                         } else {\n                                             None\n                                         }\n@@ -1249,11 +1289,9 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             }\n             // Add primitive types to the mix\n             if filter_fn(Res::PrimTy(PrimTy::Bool)) {\n-                names.extend(\n-                    PrimTy::ALL.iter().map(|prim_ty| {\n-                        TypoSuggestion::from_res(prim_ty.name(), Res::PrimTy(*prim_ty))\n-                    }),\n-                )\n+                names.extend(PrimTy::ALL.iter().map(|prim_ty| {\n+                    TypoSuggestion::typo_from_res(prim_ty.name(), Res::PrimTy(*prim_ty))\n+                }))\n             }\n         } else {\n             // Search in module."}, {"sha": "b689777685f3d1a2e18e9b572e1c1678f13463d4", "filename": "src/test/ui/associated-item/issue-87638.fixed", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8ee962f88e1be7e29482b13c7776c26b98a93bf7/src%2Ftest%2Fui%2Fassociated-item%2Fissue-87638.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8ee962f88e1be7e29482b13c7776c26b98a93bf7/src%2Ftest%2Fui%2Fassociated-item%2Fissue-87638.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-item%2Fissue-87638.fixed?ref=8ee962f88e1be7e29482b13c7776c26b98a93bf7", "patch": "@@ -0,0 +1,22 @@\n+// run-rustfix\n+\n+trait Trait {\n+    const FOO: usize;\n+\n+    type Target;\n+}\n+\n+struct S;\n+\n+impl Trait for S {\n+    const FOO: usize = 0;\n+    type Target = ();\n+}\n+\n+fn main() {\n+    let _: <S as Trait>::Target; //~ ERROR cannot find associated type `Output` in trait `Trait`\n+                                 //~^ HELP maybe you meant this associated type\n+\n+    let _ = <S as Trait>::FOO; //~ ERROR cannot find method or associated constant `BAR` in trait `Trait`\n+                               //~^ HELP maybe you meant this associated constant\n+}"}, {"sha": "5a60b20fdf382ab992dcb07510eeb7ed24977d8f", "filename": "src/test/ui/associated-item/issue-87638.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8ee962f88e1be7e29482b13c7776c26b98a93bf7/src%2Ftest%2Fui%2Fassociated-item%2Fissue-87638.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ee962f88e1be7e29482b13c7776c26b98a93bf7/src%2Ftest%2Fui%2Fassociated-item%2Fissue-87638.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-item%2Fissue-87638.rs?ref=8ee962f88e1be7e29482b13c7776c26b98a93bf7", "patch": "@@ -0,0 +1,22 @@\n+// run-rustfix\n+\n+trait Trait {\n+    const FOO: usize;\n+\n+    type Target;\n+}\n+\n+struct S;\n+\n+impl Trait for S {\n+    const FOO: usize = 0;\n+    type Target = ();\n+}\n+\n+fn main() {\n+    let _: <S as Trait>::Output; //~ ERROR cannot find associated type `Output` in trait `Trait`\n+                                 //~^ HELP maybe you meant this associated type\n+\n+    let _ = <S as Trait>::BAR; //~ ERROR cannot find method or associated constant `BAR` in trait `Trait`\n+                               //~^ HELP maybe you meant this associated constant\n+}"}, {"sha": "cf6083444b0e66fed9335d1455eafbbaec2bcefe", "filename": "src/test/ui/associated-item/issue-87638.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8ee962f88e1be7e29482b13c7776c26b98a93bf7/src%2Ftest%2Fui%2Fassociated-item%2Fissue-87638.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ee962f88e1be7e29482b13c7776c26b98a93bf7/src%2Ftest%2Fui%2Fassociated-item%2Fissue-87638.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-item%2Fissue-87638.stderr?ref=8ee962f88e1be7e29482b13c7776c26b98a93bf7", "patch": "@@ -0,0 +1,27 @@\n+error[E0576]: cannot find associated type `Output` in trait `Trait`\n+  --> $DIR/issue-87638.rs:17:26\n+   |\n+LL |     type Target;\n+   |     ------------ associated type `Target` defined here\n+...\n+LL |     let _: <S as Trait>::Output;\n+   |                          ^^^^^^\n+   |                          |\n+   |                          not found in `Trait`\n+   |                          help: maybe you meant this associated type: `Target`\n+\n+error[E0576]: cannot find method or associated constant `BAR` in trait `Trait`\n+  --> $DIR/issue-87638.rs:20:27\n+   |\n+LL |     const FOO: usize;\n+   |     ----------------- associated constant `FOO` defined here\n+...\n+LL |     let _ = <S as Trait>::BAR;\n+   |                           ^^^\n+   |                           |\n+   |                           not found in `Trait`\n+   |                           help: maybe you meant this associated constant: `FOO`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0576`."}, {"sha": "0e019f10f37f211c1aabf8ca3ddbb5db65d066fb", "filename": "src/test/ui/associated-types/issue-22037.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8ee962f88e1be7e29482b13c7776c26b98a93bf7/src%2Ftest%2Fui%2Fassociated-types%2Fissue-22037.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ee962f88e1be7e29482b13c7776c26b98a93bf7/src%2Ftest%2Fui%2Fassociated-types%2Fissue-22037.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-22037.stderr?ref=8ee962f88e1be7e29482b13c7776c26b98a93bf7", "patch": "@@ -1,8 +1,13 @@\n error[E0576]: cannot find associated type `X` in trait `A`\n   --> $DIR/issue-22037.rs:3:33\n    |\n+LL |     type Output;\n+   |     ------------ associated type `Output` defined here\n LL |     fn a(&self) -> <Self as A>::X;\n-   |                                 ^ not found in `A`\n+   |                                 ^\n+   |                                 |\n+   |                                 not found in `A`\n+   |                                 help: maybe you meant this associated type: `Output`\n \n error: aborting due to previous error\n "}, {"sha": "bd6a86b74208919176a7adf96794fe6628e7814d", "filename": "src/test/ui/issues/issue-19883.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ee962f88e1be7e29482b13c7776c26b98a93bf7/src%2Ftest%2Fui%2Fissues%2Fissue-19883.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ee962f88e1be7e29482b13c7776c26b98a93bf7/src%2Ftest%2Fui%2Fissues%2Fissue-19883.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-19883.stderr?ref=8ee962f88e1be7e29482b13c7776c26b98a93bf7", "patch": "@@ -1,8 +1,14 @@\n error[E0576]: cannot find associated type `Dst` in trait `From`\n   --> $DIR/issue-19883.rs:9:30\n    |\n+LL |     type Output;\n+   |     ------------ associated type `Output` defined here\n+...\n LL |         <Dst as From<Self>>::Dst\n-   |                              ^^^ not found in `From`\n+   |                              ^^^\n+   |                              |\n+   |                              not found in `From`\n+   |                              help: maybe you meant this associated type: `Output`\n \n error: aborting due to previous error\n "}]}