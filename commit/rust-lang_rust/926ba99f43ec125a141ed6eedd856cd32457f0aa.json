{"sha": "926ba99f43ec125a141ed6eedd856cd32457f0aa", "node_id": "C_kwDOAAsO6NoAKDkyNmJhOTlmNDNlYzEyNWExNDFlZDZlZWRkODU2Y2QzMjQ1N2YwYWE", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-01-08T10:11:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-08T10:11:37Z"}, "message": "Merge #11235\n\n11235: internal: Record attribute calls on assoc items in TraitData and ImplData r=Veykril a=Veykril\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/11228\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "2e47ae90a7db2cb9e2f3be8ed0879ac6f01df8fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e47ae90a7db2cb9e2f3be8ed0879ac6f01df8fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/926ba99f43ec125a141ed6eedd856cd32457f0aa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh2WNZCRBK7hj4Ov3rIwAACmMIAB3ibSgjXjhDMOFqS+nC58qr\n/rJtTZO80wh9r5BD9u/gWBsVtiVqEUlGPRu31HrxKuu3Ja4pSY9uYoymCHsLwmWu\nC+ylHSW2TRgesCyEtqKaqJVFlAnNgjCvcmOvmV9kCgszAqv+YBuVXYuulbjQVPxt\neMMbN77Zt1vw+6a/cy5tWiGzkJ/Lb5ZGln/RLiVTObAzqvcN0AYpiVSb7hJ70Nbv\nM8sQ8g4naKhxRvpzYoaDhUDV8+edBX94is5UH57458ywL4X/omRNFxejJGe78XhV\nJRciXQoxzu/KSfkhXGRe1MF1EmUBVouheHwAFU1y30e3N0gksLXO1bYDTd9IZVA=\n=sN0s\n-----END PGP SIGNATURE-----\n", "payload": "tree 2e47ae90a7db2cb9e2f3be8ed0879ac6f01df8fd\nparent c17db9fa5323a5e4d5f2ca7f8a04e05a1c779593\nparent 8d4f40e8815970d549ba31a47c3c5660e624d37f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1641636697 +0000\ncommitter GitHub <noreply@github.com> 1641636697 +0000\n\nMerge #11235\n\n11235: internal: Record attribute calls on assoc items in TraitData and ImplData r=Veykril a=Veykril\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/11228\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/926ba99f43ec125a141ed6eedd856cd32457f0aa", "html_url": "https://github.com/rust-lang/rust/commit/926ba99f43ec125a141ed6eedd856cd32457f0aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/926ba99f43ec125a141ed6eedd856cd32457f0aa/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c17db9fa5323a5e4d5f2ca7f8a04e05a1c779593", "url": "https://api.github.com/repos/rust-lang/rust/commits/c17db9fa5323a5e4d5f2ca7f8a04e05a1c779593", "html_url": "https://github.com/rust-lang/rust/commit/c17db9fa5323a5e4d5f2ca7f8a04e05a1c779593"}, {"sha": "8d4f40e8815970d549ba31a47c3c5660e624d37f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d4f40e8815970d549ba31a47c3c5660e624d37f", "html_url": "https://github.com/rust-lang/rust/commit/8d4f40e8815970d549ba31a47c3c5660e624d37f"}], "stats": {"total": 147, "additions": 105, "deletions": 42}, "files": [{"sha": "c0e8d0e082a31b743a8de5ae2cd58c6f72e0e236", "filename": "crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/926ba99f43ec125a141ed6eedd856cd32457f0aa/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/926ba99f43ec125a141ed6eedd856cd32457f0aa/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=926ba99f43ec125a141ed6eedd856cd32457f0aa", "patch": "@@ -316,8 +316,7 @@ impl SourceToDefCtx<'_, '_> {\n     }\n \n     pub(super) fn macro_to_def(&mut self, src: InFile<ast::Macro>) -> Option<MacroDefId> {\n-        let makro =\n-            self.dyn_map(src.as_ref()).and_then(|it| it[keys::MACRO_CALL].get(&src).copied());\n+        let makro = self.dyn_map(src.as_ref()).and_then(|it| it[keys::MACRO].get(&src).copied());\n         if let res @ Some(_) = makro {\n             return res;\n         }"}, {"sha": "545ae41edf5ddd19dbe0db4e889073e9f2a3d615", "filename": "crates/hir_def/src/child_by_source.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/926ba99f43ec125a141ed6eedd856cd32457f0aa/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/926ba99f43ec125a141ed6eedd856cd32457f0aa/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs?ref=926ba99f43ec125a141ed6eedd856cd32457f0aa", "patch": "@@ -30,20 +30,31 @@ pub trait ChildBySource {\n impl ChildBySource for TraitId {\n     fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap, file_id: HirFileId) {\n         let data = db.trait_data(*self);\n-        // FIXME attribute macros\n-        for &(_, item) in data.items.iter() {\n+\n+        data.attribute_calls().filter(|(ast_id, _)| ast_id.file_id == file_id).for_each(\n+            |(ast_id, call_id)| {\n+                let item = ast_id.with_value(ast_id.to_node(db.upcast()));\n+                res[keys::ATTR_MACRO_CALL].insert(item, call_id);\n+            },\n+        );\n+        data.items.iter().for_each(|&(_, item)| {\n             child_by_source_assoc_items(db, res, file_id, item);\n-        }\n+        });\n     }\n }\n \n impl ChildBySource for ImplId {\n     fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap, file_id: HirFileId) {\n         let data = db.impl_data(*self);\n-        // FIXME attribute macros\n-        for &item in data.items.iter() {\n+        data.attribute_calls().filter(|(ast_id, _)| ast_id.file_id == file_id).for_each(\n+            |(ast_id, call_id)| {\n+                let item = ast_id.with_value(ast_id.to_node(db.upcast()));\n+                res[keys::ATTR_MACRO_CALL].insert(item, call_id);\n+            },\n+        );\n+        data.items.iter().for_each(|&item| {\n             child_by_source_assoc_items(db, res, file_id, item);\n-        }\n+        });\n     }\n }\n \n@@ -97,7 +108,7 @@ impl ChildBySource for ItemScope {\n                     // FIXME: Do we need to add proc-macros into a PROCMACRO dynmap here?\n                     Either::Right(_fn) => return,\n                 };\n-                res[keys::MACRO_CALL].insert(src, makro);\n+                res[keys::MACRO].insert(src, makro);\n             }\n         });\n         self.unnamed_consts().for_each(|konst| {"}, {"sha": "471c7330d73d7807712caed066e8da37fcf32436", "filename": "crates/hir_def/src/data.rs", "status": "modified", "additions": 64, "deletions": 32, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/926ba99f43ec125a141ed6eedd856cd32457f0aa/crates%2Fhir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/926ba99f43ec125a141ed6eedd856cd32457f0aa/crates%2Fhir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdata.rs?ref=926ba99f43ec125a141ed6eedd856cd32457f0aa", "patch": "@@ -2,7 +2,7 @@\n \n use std::sync::Arc;\n \n-use hir_expand::{name::Name, AstId, ExpandResult, InFile};\n+use hir_expand::{name::Name, AstId, ExpandResult, InFile, MacroCallId};\n use syntax::ast;\n \n use crate::{\n@@ -184,6 +184,8 @@ pub struct TraitData {\n     /// method calls to this trait's methods when the receiver is an array and the crate edition is\n     /// 2015 or 2018.\n     pub skip_array_during_method_dispatch: bool,\n+    // box it as the vec is usually empty anyways\n+    pub attribute_calls: Option<Box<Vec<(AstId<ast::Item>, MacroCallId)>>>,\n }\n \n impl TraitData {\n@@ -207,15 +209,8 @@ impl TraitData {\n             .by_key(\"rustc_skip_array_during_method_dispatch\")\n             .exists();\n \n-        let items = collect_items(\n-            db,\n-            module_id,\n-            &mut expander,\n-            tr_def.items.iter().copied(),\n-            tr_loc.id.tree_id(),\n-            container,\n-            100,\n-        );\n+        let (items, attribute_calls) =\n+            do_collect(db, module_id, &mut expander, &tr_def.items, tr_loc.id.tree_id(), container);\n \n         Arc::new(TraitData {\n             name,\n@@ -224,6 +219,7 @@ impl TraitData {\n             is_unsafe,\n             visibility,\n             skip_array_during_method_dispatch,\n+            attribute_calls,\n         })\n     }\n \n@@ -247,6 +243,10 @@ impl TraitData {\n             _ => None,\n         })\n     }\n+\n+    pub fn attribute_calls(&self) -> impl Iterator<Item = (AstId<ast::Item>, MacroCallId)> + '_ {\n+        self.attribute_calls.iter().flat_map(|it| it.iter()).copied()\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -255,6 +255,8 @@ pub struct ImplData {\n     pub self_ty: Interned<TypeRef>,\n     pub items: Vec<AssocItemId>,\n     pub is_negative: bool,\n+    // box it as the vec is usually empty anyways\n+    pub attribute_calls: Option<Box<Vec<(AstId<ast::Item>, MacroCallId)>>>,\n }\n \n impl ImplData {\n@@ -271,18 +273,21 @@ impl ImplData {\n         let container = ItemContainerId::ImplId(id);\n         let mut expander = Expander::new(db, impl_loc.id.file_id(), module_id);\n \n-        let items = collect_items(\n+        let (items, attribute_calls) = do_collect(\n             db,\n             module_id,\n             &mut expander,\n-            impl_def.items.iter().copied(),\n+            &impl_def.items,\n             impl_loc.id.tree_id(),\n             container,\n-            100,\n         );\n         let items = items.into_iter().map(|(_, item)| item).collect();\n \n-        Arc::new(ImplData { target_trait, self_ty, items, is_negative })\n+        Arc::new(ImplData { target_trait, self_ty, items, is_negative, attribute_calls })\n+    }\n+\n+    pub fn attribute_calls(&self) -> impl Iterator<Item = (AstId<ast::Item>, MacroCallId)> + '_ {\n+        self.attribute_calls.iter().flat_map(|it| it.iter()).copied()\n     }\n }\n \n@@ -333,41 +338,70 @@ impl StaticData {\n     }\n }\n \n+fn do_collect(\n+    db: &dyn DefDatabase,\n+    module_id: ModuleId,\n+    expander: &mut Expander,\n+    assoc_items: &[AssocItem],\n+    tree_id: item_tree::TreeId,\n+    container: ItemContainerId,\n+) -> (Vec<(Name, AssocItemId)>, Option<Box<Vec<(AstId<ast::Item>, MacroCallId)>>>) {\n+    let mut items = Vec::new();\n+    let mut attribute_calls = Vec::new();\n+\n+    collect_items(\n+        db,\n+        &mut items,\n+        &mut attribute_calls,\n+        module_id,\n+        expander,\n+        assoc_items.iter().copied(),\n+        tree_id,\n+        container,\n+        100,\n+    );\n+\n+    let attribute_calls =\n+        if attribute_calls.is_empty() { None } else { Some(Box::new(attribute_calls)) };\n+    (items, attribute_calls)\n+}\n+\n fn collect_items(\n     db: &dyn DefDatabase,\n+    items: &mut Vec<(Name, AssocItemId)>,\n+    attr_calls: &mut Vec<(AstId<ast::Item>, MacroCallId)>,\n     module: ModuleId,\n     expander: &mut Expander,\n     assoc_items: impl Iterator<Item = AssocItem>,\n     tree_id: item_tree::TreeId,\n     container: ItemContainerId,\n     limit: usize,\n-) -> Vec<(Name, AssocItemId)> {\n+) {\n     if limit == 0 {\n-        return Vec::new();\n+        return;\n     }\n \n     let item_tree = tree_id.item_tree(db);\n     let crate_graph = db.crate_graph();\n     let cfg_options = &crate_graph[module.krate].cfg_options;\n     let def_map = module.def_map(db);\n \n-    let mut items = Vec::new();\n     'items: for item in assoc_items {\n         let attrs = item_tree.attrs(db, module.krate, ModItem::from(item).into());\n         if !attrs.is_cfg_enabled(cfg_options) {\n             continue;\n         }\n \n         for attr in &*attrs {\n-            let ast_id = AstIdWithPath {\n-                path: (*attr.path).clone(),\n-                ast_id: AstId::new(expander.current_file_id(), item.ast_id(&item_tree).upcast()),\n-            };\n+            let ast_id = AstId::new(expander.current_file_id(), item.ast_id(&item_tree).upcast());\n+            let ast_id_with_path = AstIdWithPath { path: (*attr.path).clone(), ast_id };\n+\n             if let Ok(ResolvedAttr::Macro(call_id)) =\n-                def_map.resolve_attr_macro(db, module.local_id, ast_id, attr)\n+                def_map.resolve_attr_macro(db, module.local_id, ast_id_with_path, attr)\n             {\n+                attr_calls.push((ast_id, call_id));\n                 let res = expander.enter_expand_id(db, call_id);\n-                items.extend(collect_macro_items(db, module, expander, container, limit, res));\n+                collect_macro_items(db, items, attr_calls, module, expander, container, limit, res);\n                 continue 'items;\n             }\n         }\n@@ -401,34 +435,32 @@ fn collect_items(\n                 let res = expander.enter_expand(db, call);\n \n                 if let Ok(res) = res {\n-                    items.extend(collect_macro_items(db, module, expander, container, limit, res));\n+                    collect_macro_items(\n+                        db, items, attr_calls, module, expander, container, limit, res,\n+                    );\n                 }\n             }\n         }\n     }\n-\n-    items\n }\n \n fn collect_macro_items(\n     db: &dyn DefDatabase,\n+    items: &mut Vec<(Name, AssocItemId)>,\n+    attr_calls: &mut Vec<(AstId<ast::Item>, MacroCallId)>,\n     module: ModuleId,\n     expander: &mut Expander,\n     container: ItemContainerId,\n     limit: usize,\n     res: ExpandResult<Option<(Mark, ast::MacroItems)>>,\n-) -> Vec<(Name, AssocItemId)> {\n+) {\n     if let Some((mark, mac)) = res.value {\n         let src: InFile<ast::MacroItems> = expander.to_source(mac);\n         let tree_id = item_tree::TreeId::new(src.file_id, None);\n         let item_tree = tree_id.item_tree(db);\n         let iter = item_tree.top_level_items().iter().filter_map(ModItem::as_assoc_item);\n-        let items = collect_items(db, module, expander, iter, tree_id, container, limit - 1);\n+        collect_items(db, items, attr_calls, module, expander, iter, tree_id, container, limit - 1);\n \n         expander.exit(db, mark);\n-\n-        return items;\n     }\n-\n-    Vec::new()\n }"}, {"sha": "eaa08a365a111d8d4b922a67c1054f64432e610a", "filename": "crates/hir_def/src/keys.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/926ba99f43ec125a141ed6eedd856cd32457f0aa/crates%2Fhir_def%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/926ba99f43ec125a141ed6eedd856cd32457f0aa/crates%2Fhir_def%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fkeys.rs?ref=926ba99f43ec125a141ed6eedd856cd32457f0aa", "patch": "@@ -32,7 +32,7 @@ pub const TYPE_PARAM: Key<ast::TypeParam, TypeParamId> = Key::new();\n pub const LIFETIME_PARAM: Key<ast::LifetimeParam, LifetimeParamId> = Key::new();\n pub const CONST_PARAM: Key<ast::ConstParam, ConstParamId> = Key::new();\n \n-pub const MACRO_CALL: Key<ast::Macro, MacroDefId> = Key::new();\n+pub const MACRO: Key<ast::Macro, MacroDefId> = Key::new();\n pub const ATTR_MACRO_CALL: Key<ast::Item, MacroCallId> = Key::new();\n pub const DERIVE_MACRO_CALL: Key<ast::Attr, (AttrId, Box<[Option<MacroCallId>]>)> = Key::new();\n "}, {"sha": "5e6f0ef6a57d54517855c43714d9b6981ff851e0", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/926ba99f43ec125a141ed6eedd856cd32457f0aa/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/926ba99f43ec125a141ed6eedd856cd32457f0aa/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=926ba99f43ec125a141ed6eedd856cd32457f0aa", "patch": "@@ -1514,4 +1514,25 @@ fn func$0() {\n             \"#]],\n         )\n     }\n+\n+    #[test]\n+    fn attr_assoc_item() {\n+        check(\n+            r#\"\n+//- proc_macros: identity\n+\n+trait Trait {\n+    #[proc_macros::identity]\n+    fn func() {\n+        Self::func$0();\n+    }\n+}\n+\"#,\n+            expect![[r#\"\n+                func Function FileId(0) 48..87 51..55\n+\n+                FileId(0) 74..78\n+            \"#]],\n+        )\n+    }\n }"}]}