{"sha": "ee7a9a8641b79329ed4c221a2ae0e1e0c3d3d75d", "node_id": "C_kwDOAAsO6NoAKGVlN2E5YTg2NDFiNzkzMjllZDRjMjIxYTJhZTBlMWUwYzNkM2Q3NWQ", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-09-04T20:42:05Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-11-29T18:41:55Z"}, "message": "Expand hash check.", "tree": {"sha": "63065734a4c9193e186c59f3411ec9f6d88ecb9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63065734a4c9193e186c59f3411ec9f6d88ecb9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee7a9a8641b79329ed4c221a2ae0e1e0c3d3d75d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee7a9a8641b79329ed4c221a2ae0e1e0c3d3d75d", "html_url": "https://github.com/rust-lang/rust/commit/ee7a9a8641b79329ed4c221a2ae0e1e0c3d3d75d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee7a9a8641b79329ed4c221a2ae0e1e0c3d3d75d/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "547138134992bfcf9171a781e4a4283cef350a89", "url": "https://api.github.com/repos/rust-lang/rust/commits/547138134992bfcf9171a781e4a4283cef350a89", "html_url": "https://github.com/rust-lang/rust/commit/547138134992bfcf9171a781e4a4283cef350a89"}], "stats": {"total": 49, "additions": 28, "deletions": 21}, "files": [{"sha": "e44857a023857f4a928062c44ca6d776defcf48b", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ee7a9a8641b79329ed4c221a2ae0e1e0c3d3d75d/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee7a9a8641b79329ed4c221a2ae0e1e0c3d3d75d/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=ee7a9a8641b79329ed4c221a2ae0e1e0c3d3d75d", "patch": "@@ -513,15 +513,18 @@ impl<K: DepKind> DepGraph<K> {\n         hash_result: fn(&mut StableHashingContext<'_>, &R) -> Fingerprint,\n     ) -> DepNodeIndex {\n         if let Some(data) = self.data.as_ref() {\n+            // The caller query has more dependencies than the node we are creating.  We may\n+            // encounter a case where this created node is marked as green, but the caller query is\n+            // subsequently marked as red or recomputed.  In this case, we will end up feeding a\n+            // value to an existing node.\n+            //\n+            // For sanity, we still check that the loaded stable hash and the new one match.\n             if let Some(dep_node_index) = self.dep_node_index_of_opt(&node) {\n+                let _current_fingerprint =\n+                    crate::query::incremental_verify_ich(cx, result, &node, Some(hash_result));\n+\n                 #[cfg(debug_assertions)]\n-                {\n-                    let hashing_timer = cx.profiler().incr_result_hashing();\n-                    let current_fingerprint =\n-                        cx.with_stable_hashing_context(|mut hcx| hash_result(&mut hcx, result));\n-                    hashing_timer.finish_with_query_invocation_id(dep_node_index.into());\n-                    data.current.record_edge(dep_node_index, node, current_fingerprint);\n-                }\n+                data.current.record_edge(dep_node_index, node, _current_fingerprint);\n \n                 return dep_node_index;\n             }"}, {"sha": "eb5a35b34491b6947a3346e0c0133d3d4a98215e", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ee7a9a8641b79329ed4c221a2ae0e1e0c3d3d75d/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee7a9a8641b79329ed4c221a2ae0e1e0c3d3d75d/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=ee7a9a8641b79329ed4c221a2ae0e1e0c3d3d75d", "patch": "@@ -3,6 +3,7 @@\n //! manage the caches, and so forth.\n \n use crate::dep_graph::{DepContext, DepNode, DepNodeIndex, DepNodeParams};\n+use crate::ich::StableHashingContext;\n use crate::query::caches::QueryCache;\n use crate::query::config::QueryVTable;\n use crate::query::job::{report_cycle, QueryInfo, QueryJob, QueryJobId, QueryJobInfo};\n@@ -525,7 +526,7 @@ where\n             if std::intrinsics::unlikely(\n                 try_verify || qcx.dep_context().sess().opts.unstable_opts.incremental_verify_ich,\n             ) {\n-                incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query);\n+                incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query.hash_result);\n             }\n \n             return Some((result, dep_node_index));\n@@ -558,39 +559,42 @@ where\n     //\n     // See issue #82920 for an example of a miscompilation that would get turned into\n     // an ICE by this check\n-    incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query);\n+    incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query.hash_result);\n \n     Some((result, dep_node_index))\n }\n \n-#[instrument(skip(qcx, result, query), level = \"debug\")]\n-fn incremental_verify_ich<Qcx, K, V: Debug>(\n-    qcx: Qcx::DepContext,\n+#[instrument(skip(tcx, result, hash_result), level = \"debug\")]\n+pub(crate) fn incremental_verify_ich<Tcx, V: Debug>(\n+    tcx: Tcx,\n     result: &V,\n-    dep_node: &DepNode<Qcx::DepKind>,\n-    query: &QueryVTable<Qcx, K, V>,\n-) where\n-    Qcx: QueryContext,\n+    dep_node: &DepNode<Tcx::DepKind>,\n+    hash_result: Option<fn(&mut StableHashingContext<'_>, &V) -> Fingerprint>,\n+) -> Fingerprint\n+where\n+    Tcx: DepContext,\n {\n     assert!(\n-        qcx.dep_graph().is_green(dep_node),\n+        tcx.dep_graph().is_green(dep_node),\n         \"fingerprint for green query instance not loaded from cache: {:?}\",\n         dep_node,\n     );\n \n-    let new_hash = query.hash_result.map_or(Fingerprint::ZERO, |f| {\n-        qcx.with_stable_hashing_context(|mut hcx| f(&mut hcx, result))\n+    let new_hash = hash_result.map_or(Fingerprint::ZERO, |f| {\n+        tcx.with_stable_hashing_context(|mut hcx| f(&mut hcx, result))\n     });\n \n-    let old_hash = qcx.dep_graph().prev_fingerprint_of(dep_node);\n+    let old_hash = tcx.dep_graph().prev_fingerprint_of(dep_node);\n \n     if Some(new_hash) != old_hash {\n         incremental_verify_ich_failed(\n-            qcx.sess(),\n+            tcx.sess(),\n             DebugArg::from(&dep_node),\n             DebugArg::from(&result),\n         );\n     }\n+\n+    new_hash\n }\n \n // This DebugArg business is largely a mirror of std::fmt::ArgumentV1, which is"}]}