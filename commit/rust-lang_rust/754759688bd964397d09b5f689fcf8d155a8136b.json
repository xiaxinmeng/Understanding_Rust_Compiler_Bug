{"sha": "754759688bd964397d09b5f689fcf8d155a8136b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1NDc1OTY4OGJkOTY0Mzk3ZDA5YjVmNjg5ZmNmOGQxNTVhODEzNmI=", "commit": {"author": {"name": "cgswords", "email": "cameronswords@gmail.com", "date": "2016-06-29T18:55:10Z"}, "committer": {"name": "cgswords", "email": "cameronswords@gmail.com", "date": "2016-07-07T18:44:04Z"}, "message": "Preliminary implementation for TokenStreams and TokenSlices, including unit tests and associated operations.", "tree": {"sha": "bc8749259ef6833fee064144838d627628a3c13e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc8749259ef6833fee064144838d627628a3c13e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/754759688bd964397d09b5f689fcf8d155a8136b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/754759688bd964397d09b5f689fcf8d155a8136b", "html_url": "https://github.com/rust-lang/rust/commit/754759688bd964397d09b5f689fcf8d155a8136b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/754759688bd964397d09b5f689fcf8d155a8136b/comments", "author": {"login": "cgswords", "id": 1130991, "node_id": "MDQ6VXNlcjExMzA5OTE=", "avatar_url": "https://avatars.githubusercontent.com/u/1130991?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cgswords", "html_url": "https://github.com/cgswords", "followers_url": "https://api.github.com/users/cgswords/followers", "following_url": "https://api.github.com/users/cgswords/following{/other_user}", "gists_url": "https://api.github.com/users/cgswords/gists{/gist_id}", "starred_url": "https://api.github.com/users/cgswords/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cgswords/subscriptions", "organizations_url": "https://api.github.com/users/cgswords/orgs", "repos_url": "https://api.github.com/users/cgswords/repos", "events_url": "https://api.github.com/users/cgswords/events{/privacy}", "received_events_url": "https://api.github.com/users/cgswords/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cgswords", "id": 1130991, "node_id": "MDQ6VXNlcjExMzA5OTE=", "avatar_url": "https://avatars.githubusercontent.com/u/1130991?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cgswords", "html_url": "https://github.com/cgswords", "followers_url": "https://api.github.com/users/cgswords/followers", "following_url": "https://api.github.com/users/cgswords/following{/other_user}", "gists_url": "https://api.github.com/users/cgswords/gists{/gist_id}", "starred_url": "https://api.github.com/users/cgswords/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cgswords/subscriptions", "organizations_url": "https://api.github.com/users/cgswords/orgs", "repos_url": "https://api.github.com/users/cgswords/repos", "events_url": "https://api.github.com/users/cgswords/events{/privacy}", "received_events_url": "https://api.github.com/users/cgswords/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c1783a3a0bff2bdc4992769d2bb2f12bc728477", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c1783a3a0bff2bdc4992769d2bb2f12bc728477", "html_url": "https://github.com/rust-lang/rust/commit/9c1783a3a0bff2bdc4992769d2bb2f12bc728477"}], "stats": {"total": 1160, "additions": 1121, "deletions": 39}, "files": [{"sha": "0ad09fd0f7dfba492e8146a64a17ed0a25eb1f69", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 1121, "deletions": 39, "changes": 1160, "blob_url": "https://github.com/rust-lang/rust/blob/754759688bd964397d09b5f689fcf8d155a8136b/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/754759688bd964397d09b5f689fcf8d155a8136b/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=754759688bd964397d09b5f689fcf8d155a8136b", "patch": "@@ -8,18 +8,34 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! # Token Trees\n-//! TokenTrees are syntactic forms for dealing with tokens. The description below is\n-//! more complete; in short a TokenTree is a single token, a delimited sequence of token\n-//! trees, or a sequence with repetition for list splicing as part of macro expansion.\n+//! # Token Streams\n+//!\n+//! TokenStreams represent syntactic objects before they are converted into ASTs.\n+//! A `TokenStream` is, roughly speaking, a sequence (eg stream) of `TokenTree`s,\n+//! which are themselves either a single Token, a Delimited subsequence of tokens,\n+//! or a SequenceRepetition specifier (for the purpose of sequence generation during macro\n+//! expansion).\n+//!\n+//! A TokenStream also has a slice view, `TokenSlice`, that is analogous to `str` for\n+//! `String`: it allows the programmer to divvy up, explore, and otherwise partition a\n+//! TokenStream as borrowed subsequences.\n \n-use ast::{AttrStyle};\n-use codemap::{Span};\n+use ast::{self, AttrStyle, LitKind};\n+use syntax_pos::{Span, DUMMY_SP, NO_EXPANSION};\n+use codemap::Spanned;\n use ext::base;\n use ext::tt::macro_parser;\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use parse::lexer;\n-use parse::token;\n+use parse;\n+use parse::token::{self, Token, Lit, InternedString, Nonterminal};\n+use parse::token::Lit as TokLit;\n+\n+use std::fmt;\n+use std::mem;\n+use std::ops::Index;\n+use std::ops;\n+use std::iter::*;\n \n use std::rc::Rc;\n \n@@ -56,6 +72,11 @@ impl Delimited {\n     pub fn close_tt(&self) -> TokenTree {\n         TokenTree::Token(self.close_span, self.close_token())\n     }\n+\n+    /// Returns the token trees inside the delimiters.\n+    pub fn subtrees(&self) -> &[TokenTree] {\n+        &self.tts\n+    }\n }\n \n /// A sequence of token trees\n@@ -91,17 +112,15 @@ pub enum KleeneOp {\n ///\n /// The RHS of an MBE macro is the only place `SubstNt`s are substituted.\n /// Nothing special happens to misnamed or misplaced `SubstNt`s.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub enum TokenTree {\n     /// A single token\n     Token(Span, token::Token),\n     /// A delimited sequence of token trees\n     Delimited(Span, Rc<Delimited>),\n \n     // This only makes sense in MBE macros.\n-\n     /// A kleene-style repetition sequence with a span\n-    // FIXME(eddyb) #12938 Use DST.\n     Sequence(Span, Rc<SequenceRepetition>),\n }\n \n@@ -111,45 +130,42 @@ impl TokenTree {\n             TokenTree::Token(_, token::DocComment(name)) => {\n                 match doc_comment_style(&name.as_str()) {\n                     AttrStyle::Outer => 2,\n-                    AttrStyle::Inner => 3\n+                    AttrStyle::Inner => 3,\n                 }\n             }\n             TokenTree::Token(_, token::SpecialVarNt(..)) => 2,\n             TokenTree::Token(_, token::MatchNt(..)) => 3,\n-            TokenTree::Delimited(_, ref delimed) => {\n-                delimed.tts.len() + 2\n-            }\n-            TokenTree::Sequence(_, ref seq) => {\n-                seq.tts.len()\n-            }\n-            TokenTree::Token(..) => 0\n+            TokenTree::Delimited(_, ref delimed) => delimed.tts.len() + 2,\n+            TokenTree::Sequence(_, ref seq) => seq.tts.len(),\n+            TokenTree::Token(..) => 0,\n         }\n     }\n \n     pub fn get_tt(&self, index: usize) -> TokenTree {\n         match (self, index) {\n-            (&TokenTree::Token(sp, token::DocComment(_)), 0) => {\n-                TokenTree::Token(sp, token::Pound)\n-            }\n+            (&TokenTree::Token(sp, token::DocComment(_)), 0) => TokenTree::Token(sp, token::Pound),\n             (&TokenTree::Token(sp, token::DocComment(name)), 1)\n-            if doc_comment_style(&name.as_str()) == AttrStyle::Inner => {\n+                if doc_comment_style(&name.as_str()) == AttrStyle::Inner => {\n                 TokenTree::Token(sp, token::Not)\n             }\n             (&TokenTree::Token(sp, token::DocComment(name)), _) => {\n                 let stripped = strip_doc_comment_decoration(&name.as_str());\n \n                 // Searches for the occurrences of `\"#*` and returns the minimum number of `#`s\n                 // required to wrap the text.\n-                let num_of_hashes = stripped.chars().scan(0, |cnt, x| {\n-                    *cnt = if x == '\"' {\n-                        1\n-                    } else if *cnt != 0 && x == '#' {\n-                        *cnt + 1\n-                    } else {\n-                        0\n-                    };\n-                    Some(*cnt)\n-                }).max().unwrap_or(0);\n+                let num_of_hashes = stripped.chars()\n+                    .scan(0, |cnt, x| {\n+                        *cnt = if x == '\"' {\n+                            1\n+                        } else if *cnt != 0 && x == '#' {\n+                            *cnt + 1\n+                        } else {\n+                            0\n+                        };\n+                        Some(*cnt)\n+                    })\n+                    .max()\n+                    .unwrap_or(0);\n \n                 TokenTree::Delimited(sp, Rc::new(Delimited {\n                     delim: token::Bracket,\n@@ -181,24 +197,24 @@ impl TokenTree {\n                          TokenTree::Token(sp, token::Ident(kind))];\n                 v[index].clone()\n             }\n-            (&TokenTree::Sequence(_, ref seq), _) => {\n-                seq.tts[index].clone()\n-            }\n-            _ => panic!(\"Cannot expand a token tree\")\n+            (&TokenTree::Sequence(_, ref seq), _) => seq.tts[index].clone(),\n+            _ => panic!(\"Cannot expand a token tree\"),\n         }\n     }\n \n     /// Returns the `Span` corresponding to this token tree.\n     pub fn get_span(&self) -> Span {\n         match *self {\n-            TokenTree::Token(span, _)     => span,\n+            TokenTree::Token(span, _) => span,\n             TokenTree::Delimited(span, _) => span,\n-            TokenTree::Sequence(span, _)  => span,\n+            TokenTree::Sequence(span, _) => span,\n         }\n     }\n \n     /// Use this token tree as a matcher to parse given tts.\n-    pub fn parse(cx: &base::ExtCtxt, mtch: &[TokenTree], tts: &[TokenTree])\n+    pub fn parse(cx: &base::ExtCtxt,\n+                 mtch: &[TokenTree],\n+                 tts: &[TokenTree])\n                  -> macro_parser::NamedParseResult {\n         // `None` is because we're not interpolating\n         let arg_rdr = lexer::new_tt_reader_with_doc_flag(&cx.parse_sess().span_diagnostic,\n@@ -208,5 +224,1071 @@ impl TokenTree {\n                                                          true);\n         macro_parser::parse(cx.parse_sess(), cx.cfg(), arg_rdr, mtch)\n     }\n+\n+    /// Check if this TokenTree is equal to the other, regardless of span information.\n+    pub fn eq_unspanned(&self, other: &TokenTree) -> bool {\n+        match (self, other) {\n+            (&TokenTree::Token(_, ref tk), &TokenTree::Token(_, ref tk2)) => tk == tk2,\n+            (&TokenTree::Delimited(_, ref dl), &TokenTree::Delimited(_, ref dl2)) => {\n+                (*dl).delim == (*dl2).delim && dl.tts.len() == dl2.tts.len() &&\n+                {\n+                    for (tt1, tt2) in dl.tts.iter().zip(dl2.tts.iter()) {\n+                        if !tt1.eq_unspanned(tt2) {\n+                            return false;\n+                        }\n+                    }\n+                    true\n+                }\n+            }\n+            (_, _) => false,\n+        }\n+    }\n+\n+    /// Retrieve the TokenTree's span.\n+    pub fn span(&self) -> Span {\n+        match *self {\n+            TokenTree::Token(sp, _) |\n+            TokenTree::Delimited(sp, _) |\n+            TokenTree::Sequence(sp, _) => sp,\n+        }\n+    }\n+\n+    /// Indicates if the stream is a token that is equal to the provided token.\n+    pub fn eq_token(&self, t: Token) -> bool {\n+        match *self {\n+            TokenTree::Token(_, ref tk) => *tk == t,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Indicates if the token is an identifier.\n+    pub fn is_ident(&self) -> bool {\n+        self.maybe_ident().is_some()\n+    }\n+\n+    /// Returns an identifier.\n+    pub fn maybe_ident(&self) -> Option<ast::Ident> {\n+        match *self {\n+            TokenTree::Token(_, Token::Ident(t)) => Some(t.clone()),\n+            TokenTree::Delimited(_, ref dl) => {\n+                let tts = dl.subtrees();\n+                if tts.len() != 1 {\n+                    return None;\n+                }\n+                tts[0].maybe_ident()\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    /// Returns a Token literal.\n+    pub fn maybe_lit(&self) -> Option<token::Lit> {\n+        match *self {\n+            TokenTree::Token(_, Token::Literal(l, _)) => Some(l.clone()),\n+            TokenTree::Delimited(_, ref dl) => {\n+                let tts = dl.subtrees();\n+                if tts.len() != 1 {\n+                    return None;\n+                }\n+                tts[0].maybe_lit()\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    /// Returns an AST string literal.\n+    pub fn maybe_str(&self) -> Option<ast::Lit> {\n+        match *self {\n+            TokenTree::Token(sp, Token::Literal(Lit::Str_(s), _)) => {\n+                let l = LitKind::Str(token::intern_and_get_ident(&parse::str_lit(&s.as_str())),\n+                                     ast::StrStyle::Cooked);\n+                Some(Spanned {\n+                    node: l,\n+                    span: sp,\n+                })\n+            }\n+            TokenTree::Token(sp, Token::Literal(Lit::StrRaw(s, n), _)) => {\n+                let l = LitKind::Str(token::intern_and_get_ident(&parse::raw_str_lit(&s.as_str())),\n+                                     ast::StrStyle::Raw(n));\n+                Some(Spanned {\n+                    node: l,\n+                    span: sp,\n+                })\n+            }\n+            _ => None,\n+        }\n+    }\n+}\n+\n+/// #Token Streams\n+///\n+/// TokenStreams are a syntactic abstraction over TokenTrees. The goal is for procedural\n+/// macros to work over TokenStreams instead of arbitrary syntax. For now, however, we\n+/// are going to cut a few corners (i.e., use some of the AST structure) when we need to\n+/// for backwards compatibility.\n+\n+/// TokenStreams are collections of TokenTrees that represent a syntactic structure. The\n+/// struct itself shouldn't be directly manipulated; the internal structure is not stable,\n+/// and may be changed at any time in the future. The operators will not, however (except\n+/// for signatures, later on).\n+#[derive(Eq,Clone,Hash,RustcEncodable,RustcDecodable)]\n+pub struct TokenStream {\n+    pub span: Span,\n+    pub tts: Vec<TokenTree>,\n+}\n+\n+impl fmt::Debug for TokenStream {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if self.tts.len() == 0 {\n+            write!(f, \"([empty\")?;\n+        } else {\n+            write!(f, \"([\")?;\n+            write!(f, \"{:?}\", self.tts[0])?;\n+\n+            for tt in self.tts.iter().skip(1) {\n+                write!(f, \",{:?}\", tt)?;\n+            }\n+        }\n+        write!(f, \"|\")?;\n+        self.span.fmt(f)?;\n+        write!(f, \"])\")\n+    }\n+}\n+\n+/// Checks if two TokenStreams are equivalent (including spans). For unspanned\n+/// equality, see `eq_unspanned`.\n+impl PartialEq<TokenStream> for TokenStream {\n+    fn eq(&self, other: &TokenStream) -> bool {\n+        self.tts == other.tts\n+    }\n+}\n+\n+// NB this will disregard gaps. if we have [a|{2,5} , b|{11,13}], the resultant span\n+// will be at {2,13}. Without finer-grained span structures, however, this seems to be\n+// our only recourse.\n+// FIXME Do something smarter to compute the expansion id.\n+fn covering_span(trees: &[TokenTree]) -> Span {\n+    // disregard any dummy spans we have\n+    let trees = trees.iter().filter(|t| t.span() != DUMMY_SP).collect::<Vec<&TokenTree>>();\n+\n+    // if we're out of spans, stop\n+    if trees.len() < 1 {\n+        return DUMMY_SP;\n+    }\n+\n+    // set up the initial values\n+    let fst_span = trees[0].span();\n+\n+    let mut lo_span = fst_span.lo;\n+    let mut hi_span = fst_span.hi;\n+    let mut expn_id = fst_span.expn_id;\n+\n+    // compute the spans iteratively\n+    for t in trees.iter().skip(1) {\n+        let sp = t.span();\n+        if sp.lo < lo_span {\n+            lo_span = sp.lo;\n+        }\n+        if hi_span < sp.hi {\n+            hi_span = sp.hi;\n+        }\n+        if expn_id != sp.expn_id {\n+            expn_id = NO_EXPANSION;\n+        }\n+    }\n+\n+    Span {\n+        lo: lo_span,\n+        hi: hi_span,\n+        expn_id: expn_id,\n+    }\n+}\n+\n+/// TokenStream operators include basic destructuring, boolean operations, `maybe_...`\n+/// operations, and `maybe_..._prefix` operations. Boolean operations are straightforward,\n+/// indicating information about the structure of the stream. The `maybe_...` operations\n+/// return `Some<...>` if the tokenstream contains the appropriate item.\n+///\n+/// Similarly, the `maybe_..._prefix` operations potentially return a\n+/// partially-destructured stream as a pair where the first element is the expected item\n+/// and the second is the remainder of the stream. As anb example,\n+///\n+///    `maybe_path_prefix(\"a::b::c(a,b,c).foo()\") -> (a::b::c, \"(a,b,c).foo()\")`\n+impl TokenStream {\n+    /// Convert a vector of `TokenTree`s into a `TokenStream`.\n+    pub fn from_tts(trees: Vec<TokenTree>) -> TokenStream {\n+        let span = covering_span(&trees);\n+        TokenStream {\n+            tts: trees,\n+            span: span,\n+        }\n+    }\n+\n+    /// Copies all of the TokenTrees from the TokenSlice, appending them to the stream.\n+    pub fn append_stream(mut self, ts2: &TokenSlice) {\n+        for tt in ts2.iter() {\n+            self.tts.push(tt.clone());\n+        }\n+        self.span = covering_span(&self.tts[..]);\n+    }\n+\n+    /// Manually change a TokenStream's span.\n+    pub fn respan(self, span: Span) -> TokenStream {\n+        TokenStream {\n+            tts: self.tts,\n+            span: span,\n+        }\n+    }\n+\n+    /// Construct a TokenStream from an ast literal.\n+    pub fn from_ast_lit_str(lit: ast::Lit) -> Option<TokenStream> {\n+        match lit.node {\n+            LitKind::Str(val, _) => {\n+                let val = TokLit::Str_(token::intern(&val));\n+                Some(TokenStream::from_tts(vec![TokenTree::Token(lit.span,\n+                                                                 Token::Literal(val, None))]))\n+            }\n+            _ => None,\n+        }\n+\n+    }\n+\n+    /// Convert a vector of TokenTrees into a parentheses-delimited TokenStream.\n+    pub fn as_paren_delimited_stream(tts: Vec<TokenTree>) -> TokenStream {\n+        let new_sp = covering_span(&tts);\n+\n+        let new_delim = Rc::new(Delimited {\n+            delim: token::DelimToken::Paren,\n+            open_span: DUMMY_SP,\n+            tts: tts,\n+            close_span: DUMMY_SP,\n+        });\n+\n+        TokenStream::from_tts(vec![TokenTree::Delimited(new_sp, new_delim)])\n+    }\n+\n+    /// Convert an interned string into a one-element TokenStream.\n+    pub fn from_interned_string_as_ident(s: InternedString) -> TokenStream {\n+        TokenStream::from_tts(vec![TokenTree::Token(DUMMY_SP,\n+                                                    Token::Ident(token::str_to_ident(&s[..])))])\n+    }\n }\n \n+/// TokenSlices are 'views' of `TokenStream's; they fit the same role as `str`s do for\n+/// `String`s. In general, most TokenStream manipulations will be refocusing their internal\n+/// contents by taking a TokenSlice and then using indexing and the provided operators.\n+#[derive(PartialEq, Eq, Debug)]\n+pub struct TokenSlice([TokenTree]);\n+\n+impl ops::Deref for TokenStream {\n+    type Target = TokenSlice;\n+\n+    fn deref(&self) -> &TokenSlice {\n+        let tts: &[TokenTree] = &*self.tts;\n+        unsafe { mem::transmute(tts) }\n+    }\n+}\n+\n+impl TokenSlice {\n+    /// Convert a borrowed TokenTree slice into a borrowed TokenSlice.\n+    fn from_tts(tts: &[TokenTree]) -> &TokenSlice {\n+        unsafe { mem::transmute(tts) }\n+    }\n+\n+    /// Indicates whether the `TokenStream` is empty.\n+    pub fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n+\n+    /// Return the `TokenSlice`'s length.\n+    pub fn len(&self) -> usize {\n+        self.0.len()\n+    }\n+\n+    /// Check equality versus another TokenStream, ignoring span information.\n+    pub fn eq_unspanned(&self, other: &TokenSlice) -> bool {\n+        if self.len() != other.len() {\n+            return false;\n+        }\n+        for (tt1, tt2) in self.iter().zip(other.iter()) {\n+            if !tt1.eq_unspanned(tt2) {\n+                return false;\n+            }\n+        }\n+        true\n+    }\n+\n+    /// Compute a span that covers the entire TokenSlice (eg, one wide enough to include\n+    /// the entire slice). If the inputs share expansion identification, it is preserved.\n+    /// If they do not, it is discarded.\n+    pub fn covering_span(&self) -> Span {\n+        covering_span(&self.0)\n+    }\n+\n+    /// Indicates where the stream is of the form `= <ts>`, where `<ts>` is a continued\n+    /// `TokenStream`.\n+    pub fn is_assignment(&self) -> bool {\n+        self.maybe_assignment().is_some()\n+    }\n+\n+    /// Returns the RHS of an assigment.\n+    pub fn maybe_assignment(&self) -> Option<&TokenSlice> {\n+        if !(self.len() > 1) {\n+            return None;\n+        }\n+\n+        Some(&self[1..])\n+    }\n+\n+    /// Indicates where the stream is a single, delimited expression (e.g., `(a,b,c)` or\n+    /// `{a,b,c}`).\n+    pub fn is_delimited(&self) -> bool {\n+        self.maybe_delimited().is_some()\n+    }\n+\n+    /// Returns the inside of the delimited term as a new TokenStream.\n+    pub fn maybe_delimited(&self) -> Option<&TokenSlice> {\n+        if !(self.len() == 1) {\n+            return None;\n+        }\n+\n+        match self[0] {\n+            TokenTree::Delimited(_, ref rc) => Some(TokenSlice::from_tts(&*rc.tts)),\n+            _ => None,\n+        }\n+    }\n+\n+    /// Returns a list of `TokenSlice`s if the stream is a delimited list, breaking the\n+    /// stream on commas.\n+    pub fn maybe_comma_list(&self) -> Option<Vec<&TokenSlice>> {\n+        let maybe_tts = self.maybe_delimited();\n+\n+        let ts: &TokenSlice;\n+        match maybe_tts {\n+            Some(t) => {\n+                ts = t;\n+            }\n+            None => {\n+                return None;\n+            }\n+        }\n+\n+        let splits: Vec<&TokenSlice> = ts.split(|x| match *x {\n+                TokenTree::Token(_, Token::Comma) => true,\n+                _ => false,\n+            })\n+            .filter(|x| x.len() > 0)\n+            .collect();\n+\n+        Some(splits)\n+    }\n+\n+    /// Returns a Nonterminal if it is Interpolated.\n+    pub fn maybe_interpolated_nonterminal(&self) -> Option<Nonterminal> {\n+        if !(self.len() == 1) {\n+            return None;\n+        }\n+\n+        match self[0] {\n+            TokenTree::Token(_, Token::Interpolated(ref nt)) => Some(nt.clone()),\n+            _ => None,\n+        }\n+    }\n+\n+    /// Indicates if the stream is exactly one identifier.\n+    pub fn is_ident(&self) -> bool {\n+        self.maybe_ident().is_some()\n+    }\n+\n+    /// Returns an identifier\n+    pub fn maybe_ident(&self) -> Option<ast::Ident> {\n+        if !(self.len() == 1) {\n+            return None;\n+        }\n+\n+        let tok = if let Some(tts) = self.maybe_delimited() {\n+            if tts.len() != 1 {\n+                return None;\n+            }\n+            &tts[0]\n+        } else {\n+            &self[0]\n+        };\n+\n+        match *tok {\n+            TokenTree::Token(_, Token::Ident(t)) => Some(t),\n+            _ => None,\n+        }\n+    }\n+\n+    /// Indicates if the stream is exactly one literal\n+    pub fn is_lit(&self) -> bool {\n+        self.maybe_lit().is_some()\n+    }\n+\n+    /// Returns a literal\n+    pub fn maybe_lit(&self) -> Option<token::Lit> {\n+        if !(self.len() == 1) {\n+            return None;\n+        }\n+\n+        let tok = if let Some(tts) = self.maybe_delimited() {\n+            if tts.len() != 1 {\n+                return None;\n+            }\n+            &tts[0]\n+        } else {\n+            &self[0]\n+        };\n+\n+        match *tok {\n+            TokenTree::Token(_, Token::Literal(l, _)) => Some(l),\n+            _ => None,\n+        }\n+    }\n+\n+    /// Returns an AST string literal if the TokenStream is either a normal ('cooked') or\n+    /// raw string literal.\n+    pub fn maybe_str(&self) -> Option<ast::Lit> {\n+        if !(self.len() == 1) {\n+            return None;\n+        }\n+\n+        match self[0] {\n+            TokenTree::Token(sp, Token::Literal(Lit::Str_(s), _)) => {\n+                let l = LitKind::Str(token::intern_and_get_ident(&parse::str_lit(&s.as_str())),\n+                                     ast::StrStyle::Cooked);\n+                Some(Spanned {\n+                    node: l,\n+                    span: sp,\n+                })\n+            }\n+            TokenTree::Token(sp, Token::Literal(Lit::StrRaw(s, n), _)) => {\n+                let l = LitKind::Str(token::intern_and_get_ident(&parse::raw_str_lit(&s.as_str())),\n+                                     ast::StrStyle::Raw(n));\n+                Some(Spanned {\n+                    node: l,\n+                    span: sp,\n+                })\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    /// This operation extracts the path prefix , returning an AST path struct and the remainder\n+    /// of the stream (if it finds one). To be more specific, a tokenstream that has a valid,\n+    /// non-global path as a prefix (eg `foo(bar, baz)`, `foo::bar(bar)`, but *not*\n+    /// `::foo::bar(baz)`) will yield the path and the remaining tokens (as a slice). The previous\n+    /// examples will yield\n+    /// `Some((Path { segments = vec![foo], ... }, [(bar, baz)]))`,\n+    /// `Some((Path { segments = vec![foo, bar] }, [(baz)]))`,\n+    /// and `None`, respectively.\n+    pub fn maybe_path_prefix(&self) -> Option<(ast::Path, &TokenSlice)> {\n+        let mut segments: Vec<ast::PathSegment> = Vec::new();\n+\n+        let path: Vec<&TokenTree> = self.iter()\n+            .take_while(|x| x.is_ident() || x.eq_token(Token::ModSep))\n+            .collect::<Vec<&TokenTree>>();\n+\n+        let path_size = path.len();\n+        if path_size == 0 {\n+            return None;\n+        }\n+\n+        let cov_span = self[..path_size].covering_span();\n+        let rst = &self[path_size..];\n+\n+        let fst_id = path[0];\n+\n+        if let Some(id) = fst_id.maybe_ident() {\n+            segments.push(ast::PathSegment {\n+                identifier: id,\n+                parameters: ast::PathParameters::none(),\n+            });\n+        } else {\n+            return None;\n+        }\n+\n+        // Let's use a state machine to parse out the rest.\n+        enum State {\n+            Mod, // Expect a `::`, or return None otherwise.\n+            Ident, // Expect an ident, or return None otherwise.\n+        }\n+        let mut state = State::Mod;\n+\n+        for p in &path[1..] {\n+            match state {\n+                State::Mod => {\n+                    // State 0: ['::' -> state 1, else return None]\n+                    if p.eq_token(Token::ModSep) {\n+                        state = State::Ident;\n+                    } else {\n+                        return None;\n+                    }\n+                }\n+                State::Ident => {\n+                    // State 1: [ident -> state 0, else return None]\n+                    if let Some(id) = p.maybe_ident() {\n+                        segments.push(ast::PathSegment {\n+                            identifier: id,\n+                            parameters: ast::PathParameters::none(),\n+                        });\n+                        state = State::Mod;\n+                    } else {\n+                        return None;\n+                    }\n+                }\n+            }\n+        }\n+\n+        let path = ast::Path {\n+            span: cov_span,\n+            global: false,\n+            segments: segments,\n+        };\n+        Some((path, rst))\n+    }\n+\n+    /// Returns an iterator over a TokenSlice (as a sequence of TokenStreams).\n+    fn iter(&self) -> Iter {\n+        Iter { vs: self }\n+    }\n+\n+    /// Splits a TokenSlice based on the provided `&TokenTree -> bool` predicate.\n+    fn split<P>(&self, pred: P) -> Split<P>\n+        where P: FnMut(&TokenTree) -> bool\n+    {\n+        Split {\n+            vs: self,\n+            pred: pred,\n+            finished: false,\n+        }\n+    }\n+}\n+\n+pub struct Iter<'a> {\n+    vs: &'a TokenSlice,\n+}\n+\n+impl<'a> Iterator for Iter<'a> {\n+    type Item = &'a TokenTree;\n+\n+    fn next(&mut self) -> Option<&'a TokenTree> {\n+        if self.vs.is_empty() {\n+            return None;\n+        }\n+\n+        let ret = Some(&self.vs[0]);\n+        self.vs = &self.vs[1..];\n+        ret\n+    }\n+}\n+\n+pub struct Split<'a, P>\n+    where P: FnMut(&TokenTree) -> bool\n+{\n+    vs: &'a TokenSlice,\n+    pred: P,\n+    finished: bool,\n+}\n+\n+impl<'a, P> Iterator for Split<'a, P>\n+    where P: FnMut(&TokenTree) -> bool\n+{\n+    type Item = &'a TokenSlice;\n+\n+    fn next(&mut self) -> Option<&'a TokenSlice> {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        match self.vs.iter().position(|x| (self.pred)(x)) {\n+            None => {\n+                self.finished = true;\n+                Some(&self.vs[..])\n+            }\n+            Some(idx) => {\n+                let ret = Some(&self.vs[..idx]);\n+                self.vs = &self.vs[idx + 1..];\n+                ret\n+            }\n+        }\n+    }\n+}\n+\n+impl Index<usize> for TokenStream {\n+    type Output = TokenTree;\n+\n+    fn index(&self, index: usize) -> &TokenTree {\n+        Index::index(&**self, index)\n+    }\n+}\n+\n+impl ops::Index<ops::Range<usize>> for TokenStream {\n+    type Output = TokenSlice;\n+\n+    fn index(&self, index: ops::Range<usize>) -> &TokenSlice {\n+        Index::index(&**self, index)\n+    }\n+}\n+\n+impl ops::Index<ops::RangeTo<usize>> for TokenStream {\n+    type Output = TokenSlice;\n+\n+    fn index(&self, index: ops::RangeTo<usize>) -> &TokenSlice {\n+        Index::index(&**self, index)\n+    }\n+}\n+\n+impl ops::Index<ops::RangeFrom<usize>> for TokenStream {\n+    type Output = TokenSlice;\n+\n+    fn index(&self, index: ops::RangeFrom<usize>) -> &TokenSlice {\n+        Index::index(&**self, index)\n+    }\n+}\n+\n+impl ops::Index<ops::RangeFull> for TokenStream {\n+    type Output = TokenSlice;\n+\n+    fn index(&self, _index: ops::RangeFull) -> &TokenSlice {\n+        Index::index(&**self, _index)\n+    }\n+}\n+\n+impl Index<usize> for TokenSlice {\n+    type Output = TokenTree;\n+\n+    fn index(&self, index: usize) -> &TokenTree {\n+        &self.0[index]\n+    }\n+}\n+\n+impl ops::Index<ops::Range<usize>> for TokenSlice {\n+    type Output = TokenSlice;\n+\n+    fn index(&self, index: ops::Range<usize>) -> &TokenSlice {\n+        TokenSlice::from_tts(&self.0[index])\n+    }\n+}\n+\n+impl ops::Index<ops::RangeTo<usize>> for TokenSlice {\n+    type Output = TokenSlice;\n+\n+    fn index(&self, index: ops::RangeTo<usize>) -> &TokenSlice {\n+        TokenSlice::from_tts(&self.0[index])\n+    }\n+}\n+\n+impl ops::Index<ops::RangeFrom<usize>> for TokenSlice {\n+    type Output = TokenSlice;\n+\n+    fn index(&self, index: ops::RangeFrom<usize>) -> &TokenSlice {\n+        TokenSlice::from_tts(&self.0[index])\n+    }\n+}\n+\n+impl ops::Index<ops::RangeFull> for TokenSlice {\n+    type Output = TokenSlice;\n+\n+    fn index(&self, _index: ops::RangeFull) -> &TokenSlice {\n+        TokenSlice::from_tts(&self.0[_index])\n+    }\n+}\n+\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use ast;\n+    use syntax_pos::{Span, BytePos, NO_EXPANSION, DUMMY_SP};\n+    use parse::token::{self, str_to_ident, Token, Lit};\n+    use util::parser_testing::string_to_tts;\n+    use std::rc::Rc;\n+\n+    fn sp(a: u32, b: u32) -> Span {\n+        Span {\n+            lo: BytePos(a),\n+            hi: BytePos(b),\n+            expn_id: NO_EXPANSION,\n+        }\n+    }\n+\n+    #[test]\n+    fn test_is_empty() {\n+        let test0 = TokenStream::from_tts(Vec::new());\n+        let test1 = TokenStream::from_tts(vec![TokenTree::Token(sp(0, 1),\n+                                                                Token::Ident(str_to_ident(\"a\")))]);\n+        let test2 = TokenStream::from_tts(string_to_tts(\"foo(bar::baz)\".to_string()));\n+\n+        assert_eq!(test0.is_empty(), true);\n+        assert_eq!(test1.is_empty(), false);\n+        assert_eq!(test2.is_empty(), false);\n+    }\n+\n+    #[test]\n+    fn test_is_delimited() {\n+        let test0 = TokenStream::from_tts(string_to_tts(\"foo(bar::baz)\".to_string()));\n+        let test1 = TokenStream::from_tts(string_to_tts(\"(bar::baz)\".to_string()));\n+        let test2 = TokenStream::from_tts(string_to_tts(\"(foo,bar,baz)\".to_string()));\n+        let test3 = TokenStream::from_tts(string_to_tts(\"(foo,bar,baz)(zab,rab,oof)\".to_string()));\n+        let test4 = TokenStream::from_tts(string_to_tts(\"(foo,bar,baz)foo\".to_string()));\n+        let test5 = TokenStream::from_tts(string_to_tts(\"\".to_string()));\n+\n+        assert_eq!(test0.is_delimited(), false);\n+        assert_eq!(test1.is_delimited(), true);\n+        assert_eq!(test2.is_delimited(), true);\n+        assert_eq!(test3.is_delimited(), false);\n+        assert_eq!(test4.is_delimited(), false);\n+        assert_eq!(test5.is_delimited(), false);\n+    }\n+\n+    #[test]\n+    fn test_is_assign() {\n+        let test0 = TokenStream::from_tts(string_to_tts(\"= bar::baz\".to_string()));\n+        let test1 = TokenStream::from_tts(string_to_tts(\"= \\\"5\\\"\".to_string()));\n+        let test2 = TokenStream::from_tts(string_to_tts(\"= 5\".to_string()));\n+        let test3 = TokenStream::from_tts(string_to_tts(\"(foo = 10)\".to_string()));\n+        let test4 = TokenStream::from_tts(string_to_tts(\"= (foo,bar,baz)\".to_string()));\n+        let test5 = TokenStream::from_tts(string_to_tts(\"\".to_string()));\n+\n+        assert_eq!(test0.is_assignment(), true);\n+        assert_eq!(test1.is_assignment(), true);\n+        assert_eq!(test2.is_assignment(), true);\n+        assert_eq!(test3.is_assignment(), false);\n+        assert_eq!(test4.is_assignment(), true);\n+        assert_eq!(test5.is_assignment(), false);\n+    }\n+\n+    #[test]\n+    fn test_is_lit() {\n+        let test0 = TokenStream::from_tts(string_to_tts(\"\\\"foo\\\"\".to_string()));\n+        let test1 = TokenStream::from_tts(string_to_tts(\"5\".to_string()));\n+        let test2 = TokenStream::from_tts(string_to_tts(\"foo\".to_string()));\n+        let test3 = TokenStream::from_tts(string_to_tts(\"foo::bar\".to_string()));\n+        let test4 = TokenStream::from_tts(string_to_tts(\"foo(bar)\".to_string()));\n+\n+        assert_eq!(test0.is_lit(), true);\n+        assert_eq!(test1.is_lit(), true);\n+        assert_eq!(test2.is_lit(), false);\n+        assert_eq!(test3.is_lit(), false);\n+        assert_eq!(test4.is_lit(), false);\n+    }\n+\n+    #[test]\n+    fn test_is_ident() {\n+        let test0 = TokenStream::from_tts(string_to_tts(\"\\\"foo\\\"\".to_string()));\n+        let test1 = TokenStream::from_tts(string_to_tts(\"5\".to_string()));\n+        let test2 = TokenStream::from_tts(string_to_tts(\"foo\".to_string()));\n+        let test3 = TokenStream::from_tts(string_to_tts(\"foo::bar\".to_string()));\n+        let test4 = TokenStream::from_tts(string_to_tts(\"foo(bar)\".to_string()));\n+\n+        assert_eq!(test0.is_ident(), false);\n+        assert_eq!(test1.is_ident(), false);\n+        assert_eq!(test2.is_ident(), true);\n+        assert_eq!(test3.is_ident(), false);\n+        assert_eq!(test4.is_ident(), false);\n+    }\n+\n+    #[test]\n+    fn test_maybe_assignment() {\n+        let test0_input = TokenStream::from_tts(string_to_tts(\"= bar::baz\".to_string()));\n+        let test1_input = TokenStream::from_tts(string_to_tts(\"= \\\"5\\\"\".to_string()));\n+        let test2_input = TokenStream::from_tts(string_to_tts(\"= 5\".to_string()));\n+        let test3_input = TokenStream::from_tts(string_to_tts(\"(foo = 10)\".to_string()));\n+        let test4_input = TokenStream::from_tts(string_to_tts(\"= (foo,bar,baz)\".to_string()));\n+        let test5_input = TokenStream::from_tts(string_to_tts(\"\".to_string()));\n+\n+        let test0 = test0_input.maybe_assignment();\n+        let test1 = test1_input.maybe_assignment();\n+        let test2 = test2_input.maybe_assignment();\n+        let test3 = test3_input.maybe_assignment();\n+        let test4 = test4_input.maybe_assignment();\n+        let test5 = test5_input.maybe_assignment();\n+\n+        let test0_expected = TokenStream::from_tts(vec![TokenTree::Token(sp(2, 5),\n+                                                        token::Ident(str_to_ident(\"bar\"))),\n+                                       TokenTree::Token(sp(5, 7), token::ModSep),\n+                                       TokenTree::Token(sp(7, 10),\n+                                                        token::Ident(str_to_ident(\"baz\")))]);\n+        assert_eq!(test0, Some(&test0_expected[..]));\n+\n+        let test1_expected = TokenStream::from_tts(vec![TokenTree::Token(sp(2, 5),\n+                                            token::Literal(Lit::Str_(token::intern(\"5\")), None))]);\n+        assert_eq!(test1, Some(&test1_expected[..]));\n+\n+        let test2_expected = TokenStream::from_tts(vec![TokenTree::Token( sp(2,3)\n+                                       , token::Literal(\n+                                           Lit::Integer(\n+                                             token::intern(&(5.to_string()))),\n+                                             None))]);\n+        assert_eq!(test2, Some(&test2_expected[..]));\n+\n+        assert_eq!(test3, None);\n+\n+\n+        let test4_tts = vec![TokenTree::Token(sp(3, 6), token::Ident(str_to_ident(\"foo\"))),\n+                             TokenTree::Token(sp(6, 7), token::Comma),\n+                             TokenTree::Token(sp(7, 10), token::Ident(str_to_ident(\"bar\"))),\n+                             TokenTree::Token(sp(10, 11), token::Comma),\n+                             TokenTree::Token(sp(11, 14), token::Ident(str_to_ident(\"baz\")))];\n+\n+        let test4_expected = TokenStream::from_tts(vec![TokenTree::Delimited(sp(2, 15),\n+                                                Rc::new(Delimited {\n+                                                    delim: token::DelimToken::Paren,\n+                                                    open_span: sp(2, 3),\n+                                                    tts: test4_tts,\n+                                                    close_span: sp(14, 15),\n+                                                }))]);\n+        assert_eq!(test4, Some(&test4_expected[..]));\n+\n+        assert_eq!(test5, None);\n+\n+    }\n+\n+    #[test]\n+    fn test_maybe_delimited() {\n+        let test0_input = TokenStream::from_tts(string_to_tts(\"foo(bar::baz)\".to_string()));\n+        let test1_input = TokenStream::from_tts(string_to_tts(\"(bar::baz)\".to_string()));\n+        let test2_input = TokenStream::from_tts(string_to_tts(\"(foo,bar,baz)\".to_string()));\n+        let test3_input = TokenStream::from_tts(string_to_tts(\"(foo,bar,baz)(zab,rab)\"\n+            .to_string()));\n+        let test4_input = TokenStream::from_tts(string_to_tts(\"(foo,bar,baz)foo\".to_string()));\n+        let test5_input = TokenStream::from_tts(string_to_tts(\"\".to_string()));\n+\n+        let test0 = test0_input.maybe_delimited();\n+        let test1 = test1_input.maybe_delimited();\n+        let test2 = test2_input.maybe_delimited();\n+        let test3 = test3_input.maybe_delimited();\n+        let test4 = test4_input.maybe_delimited();\n+        let test5 = test5_input.maybe_delimited();\n+\n+        assert_eq!(test0, None);\n+\n+        let test1_expected = TokenStream::from_tts(vec![TokenTree::Token(sp(1, 4),\n+                                                        token::Ident(str_to_ident(\"bar\"))),\n+                                       TokenTree::Token(sp(4, 6), token::ModSep),\n+                                       TokenTree::Token(sp(6, 9),\n+                                                        token::Ident(str_to_ident(\"baz\")))]);\n+        assert_eq!(test1, Some(&test1_expected[..]));\n+\n+        let test2_expected = TokenStream::from_tts(vec![TokenTree::Token(sp(1, 4),\n+                                                        token::Ident(str_to_ident(\"foo\"))),\n+                                       TokenTree::Token(sp(4, 5), token::Comma),\n+                                       TokenTree::Token(sp(5, 8),\n+                                                        token::Ident(str_to_ident(\"bar\"))),\n+                                       TokenTree::Token(sp(8, 9), token::Comma),\n+                                       TokenTree::Token(sp(9, 12),\n+                                                        token::Ident(str_to_ident(\"baz\")))]);\n+        assert_eq!(test2, Some(&test2_expected[..]));\n+\n+        assert_eq!(test3, None);\n+\n+        assert_eq!(test4, None);\n+\n+        assert_eq!(test5, None);\n+    }\n+\n+    #[test]\n+    fn test_maybe_comma_list() {\n+        let test0_input = TokenStream::from_tts(string_to_tts(\"foo(bar::baz)\".to_string()));\n+        let test1_input = TokenStream::from_tts(string_to_tts(\"(bar::baz)\".to_string()));\n+        let test2_input = TokenStream::from_tts(string_to_tts(\"(foo,bar,baz)\".to_string()));\n+        let test3_input = TokenStream::from_tts(string_to_tts(\"(foo::bar,bar,baz)\".to_string()));\n+        let test4_input = TokenStream::from_tts(string_to_tts(\"(foo,bar,baz)(zab,rab)\"\n+            .to_string()));\n+        let test5_input = TokenStream::from_tts(string_to_tts(\"(foo,bar,baz)foo\".to_string()));\n+        let test6_input = TokenStream::from_tts(string_to_tts(\"\".to_string()));\n+        // The following is supported behavior!\n+        let test7_input = TokenStream::from_tts(string_to_tts(\"(foo,bar,)\".to_string()));\n+\n+        let test0 = test0_input.maybe_comma_list();\n+        let test1 = test1_input.maybe_comma_list();\n+        let test2 = test2_input.maybe_comma_list();\n+        let test3 = test3_input.maybe_comma_list();\n+        let test4 = test4_input.maybe_comma_list();\n+        let test5 = test5_input.maybe_comma_list();\n+        let test6 = test6_input.maybe_comma_list();\n+        let test7 = test7_input.maybe_comma_list();\n+\n+        assert_eq!(test0, None);\n+\n+        let test1_stream = TokenStream::from_tts(vec![TokenTree::Token(sp(1, 4),\n+                                                        token::Ident(str_to_ident(\"bar\"))),\n+                                       TokenTree::Token(sp(4, 6), token::ModSep),\n+                                       TokenTree::Token(sp(6, 9),\n+                                                        token::Ident(str_to_ident(\"baz\")))]);\n+\n+        let test1_expected: Vec<&TokenSlice> = vec![&test1_stream[..]];\n+        assert_eq!(test1, Some(test1_expected));\n+\n+        let test2_foo = TokenStream::from_tts(vec![TokenTree::Token(sp(1, 4),\n+                                                        token::Ident(str_to_ident(\"foo\")))]);\n+        let test2_bar = TokenStream::from_tts(vec![TokenTree::Token(sp(5, 8),\n+                                                        token::Ident(str_to_ident(\"bar\")))]);\n+        let test2_baz = TokenStream::from_tts(vec![TokenTree::Token(sp(9, 12),\n+                                                        token::Ident(str_to_ident(\"baz\")))]);\n+        let test2_expected: Vec<&TokenSlice> = vec![&test2_foo[..], &test2_bar[..], &test2_baz[..]];\n+        assert_eq!(test2, Some(test2_expected));\n+\n+        let test3_path = TokenStream::from_tts(vec![TokenTree::Token(sp(1, 4),\n+                                                        token::Ident(str_to_ident(\"foo\"))),\n+                                       TokenTree::Token(sp(4, 6), token::ModSep),\n+                                       TokenTree::Token(sp(6, 9),\n+                                                        token::Ident(str_to_ident(\"bar\")))]);\n+        let test3_bar = TokenStream::from_tts(vec![TokenTree::Token(sp(10, 13),\n+                                                        token::Ident(str_to_ident(\"bar\")))]);\n+        let test3_baz = TokenStream::from_tts(vec![TokenTree::Token(sp(14, 17),\n+                                                        token::Ident(str_to_ident(\"baz\")))]);\n+        let test3_expected: Vec<&TokenSlice> =\n+            vec![&test3_path[..], &test3_bar[..], &test3_baz[..]];\n+        assert_eq!(test3, Some(test3_expected));\n+\n+        assert_eq!(test4, None);\n+\n+        assert_eq!(test5, None);\n+\n+        assert_eq!(test6, None);\n+\n+\n+        let test7_expected: Vec<&TokenSlice> = vec![&test2_foo[..], &test2_bar[..]];\n+        assert_eq!(test7, Some(test7_expected));\n+    }\n+\n+    // pub fn maybe_ident(&self) -> Option<ast::Ident>\n+    #[test]\n+    fn test_maybe_ident() {\n+        let test0 = TokenStream::from_tts(string_to_tts(\"\\\"foo\\\"\".to_string())).maybe_ident();\n+        let test1 = TokenStream::from_tts(string_to_tts(\"5\".to_string())).maybe_ident();\n+        let test2 = TokenStream::from_tts(string_to_tts(\"foo\".to_string())).maybe_ident();\n+        let test3 = TokenStream::from_tts(string_to_tts(\"foo::bar\".to_string())).maybe_ident();\n+        let test4 = TokenStream::from_tts(string_to_tts(\"foo(bar)\".to_string())).maybe_ident();\n+\n+        assert_eq!(test0, None);\n+        assert_eq!(test1, None);\n+        assert_eq!(test2, Some(str_to_ident(\"foo\")));\n+        assert_eq!(test3, None);\n+        assert_eq!(test4, None);\n+    }\n+\n+    // pub fn maybe_lit(&self) -> Option<token::Lit>\n+    #[test]\n+    fn test_maybe_lit() {\n+        let test0 = TokenStream::from_tts(string_to_tts(\"\\\"foo\\\"\".to_string())).maybe_lit();\n+        let test1 = TokenStream::from_tts(string_to_tts(\"5\".to_string())).maybe_lit();\n+        let test2 = TokenStream::from_tts(string_to_tts(\"foo\".to_string())).maybe_lit();\n+        let test3 = TokenStream::from_tts(string_to_tts(\"foo::bar\".to_string())).maybe_lit();\n+        let test4 = TokenStream::from_tts(string_to_tts(\"foo(bar)\".to_string())).maybe_lit();\n+\n+        assert_eq!(test0, Some(Lit::Str_(token::intern(\"foo\"))));\n+        assert_eq!(test1, Some(Lit::Integer(token::intern(&(5.to_string())))));\n+        assert_eq!(test2, None);\n+        assert_eq!(test3, None);\n+        assert_eq!(test4, None);\n+    }\n+\n+    #[test]\n+    fn test_maybe_path_prefix() {\n+        let test0_input = TokenStream::from_tts(string_to_tts(\"foo(bar::baz)\".to_string()));\n+        let test1_input = TokenStream::from_tts(string_to_tts(\"(bar::baz)\".to_string()));\n+        let test2_input = TokenStream::from_tts(string_to_tts(\"(foo,bar,baz)\".to_string()));\n+        let test3_input = TokenStream::from_tts(string_to_tts(\"foo::bar(bar,baz)\".to_string()));\n+\n+        let test0 = test0_input.maybe_path_prefix();\n+        let test1 = test1_input.maybe_path_prefix();\n+        let test2 = test2_input.maybe_path_prefix();\n+        let test3 = test3_input.maybe_path_prefix();\n+\n+        let test0_tts = vec![TokenTree::Token(sp(4, 7), token::Ident(str_to_ident(\"bar\"))),\n+                             TokenTree::Token(sp(7, 9), token::ModSep),\n+                             TokenTree::Token(sp(9, 12), token::Ident(str_to_ident(\"baz\")))];\n+\n+        let test0_stream = TokenStream::from_tts(vec![TokenTree::Delimited(sp(3, 13),\n+                                                               Rc::new(Delimited {\n+                                                                   delim: token::DelimToken::Paren,\n+                                                                   open_span: sp(3, 4),\n+                                                                   tts: test0_tts,\n+                                                                   close_span: sp(12, 13),\n+                                                               }))]);\n+\n+        let test0_expected = Some((ast::Path::from_ident(sp(0, 3), str_to_ident(\"foo\")),\n+                                   &test0_stream[..]));\n+        assert_eq!(test0, test0_expected);\n+\n+        assert_eq!(test1, None);\n+        assert_eq!(test2, None);\n+\n+        let test3_path = ast::Path {\n+            span: sp(0, 8),\n+            global: false,\n+            segments: vec![ast::PathSegment {\n+                               identifier: str_to_ident(\"foo\"),\n+                               parameters: ast::PathParameters::none(),\n+                           },\n+                           ast::PathSegment {\n+                               identifier: str_to_ident(\"bar\"),\n+                               parameters: ast::PathParameters::none(),\n+                           }],\n+        };\n+\n+        let test3_tts = vec![TokenTree::Token(sp(9, 12), token::Ident(str_to_ident(\"bar\"))),\n+                             TokenTree::Token(sp(12, 13), token::Comma),\n+                             TokenTree::Token(sp(13, 16), token::Ident(str_to_ident(\"baz\")))];\n+\n+        let test3_stream = TokenStream::from_tts(vec![TokenTree::Delimited(sp(8, 17),\n+                                                               Rc::new(Delimited {\n+                                                                   delim: token::DelimToken::Paren,\n+                                                                   open_span: sp(8, 9),\n+                                                                   tts: test3_tts,\n+                                                                   close_span: sp(16, 17),\n+                                                               }))]);\n+        let test3_expected = Some((test3_path, &test3_stream[..]));\n+        assert_eq!(test3, test3_expected);\n+    }\n+\n+    #[test]\n+    fn test_as_paren_delimited_stream() {\n+        let test0 = TokenStream::as_paren_delimited_stream(string_to_tts(\"foo,bar,\".to_string()));\n+        let test1 = TokenStream::as_paren_delimited_stream(string_to_tts(\"baz(foo,bar)\"\n+            .to_string()));\n+\n+        let test0_tts = vec![TokenTree::Token(sp(0, 3), token::Ident(str_to_ident(\"foo\"))),\n+                             TokenTree::Token(sp(3, 4), token::Comma),\n+                             TokenTree::Token(sp(4, 7), token::Ident(str_to_ident(\"bar\"))),\n+                             TokenTree::Token(sp(7, 8), token::Comma)];\n+        let test0_stream = TokenStream::from_tts(vec![TokenTree::Delimited(sp(0, 8),\n+                                                               Rc::new(Delimited {\n+                                                                   delim: token::DelimToken::Paren,\n+                                                                   open_span: DUMMY_SP,\n+                                                                   tts: test0_tts,\n+                                                                   close_span: DUMMY_SP,\n+                                                               }))]);\n+\n+        assert_eq!(test0, test0_stream);\n+\n+\n+        let test1_tts = vec![TokenTree::Token(sp(4, 7), token::Ident(str_to_ident(\"foo\"))),\n+                             TokenTree::Token(sp(7, 8), token::Comma),\n+                             TokenTree::Token(sp(8, 11), token::Ident(str_to_ident(\"bar\")))];\n+\n+        let test1_parse = vec![TokenTree::Token(sp(0, 3), token::Ident(str_to_ident(\"baz\"))),\n+                               TokenTree::Delimited(sp(3, 12),\n+                                                    Rc::new(Delimited {\n+                                                        delim: token::DelimToken::Paren,\n+                                                        open_span: sp(3, 4),\n+                                                        tts: test1_tts,\n+                                                        close_span: sp(11, 12),\n+                                                    }))];\n+\n+        let test1_stream = TokenStream::from_tts(vec![TokenTree::Delimited(sp(0, 12),\n+                                                               Rc::new(Delimited {\n+                                                                   delim: token::DelimToken::Paren,\n+                                                                   open_span: DUMMY_SP,\n+                                                                   tts: test1_parse,\n+                                                                   close_span: DUMMY_SP,\n+                                                               }))]);\n+\n+        assert_eq!(test1, test1_stream);\n+    }\n+\n+}"}]}