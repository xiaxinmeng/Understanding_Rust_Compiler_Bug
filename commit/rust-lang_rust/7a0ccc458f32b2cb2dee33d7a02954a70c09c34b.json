{"sha": "7a0ccc458f32b2cb2dee33d7a02954a70c09c34b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhMGNjYzQ1OGYzMmIyY2IyZGVlMzNkN2EwMjk1NGE3MGMwOWMzNGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-04T21:26:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-04T21:26:28Z"}, "message": "Auto merge of #33376 - Manishearth:rollup, r=Manishearth\n\nRollup of 14 pull requests\n\n- Successful merges: #33277, #33294, #33314, #33322, #33333, #33338, #33339, #33340, #33343, #33357, #33363, #33365, #33371, #33372\n- Failed merges:", "tree": {"sha": "2c12ee018b5234df94b78d8d60e88c4c4f207bd3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c12ee018b5234df94b78d8d60e88c4c4f207bd3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b", "html_url": "https://github.com/rust-lang/rust/commit/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3157691f963a86776cb7e6a7842f566032890aba", "url": "https://api.github.com/repos/rust-lang/rust/commits/3157691f963a86776cb7e6a7842f566032890aba", "html_url": "https://github.com/rust-lang/rust/commit/3157691f963a86776cb7e6a7842f566032890aba"}, {"sha": "631e7b4eaacc44c85ba528de838217233a61dc38", "url": "https://api.github.com/repos/rust-lang/rust/commits/631e7b4eaacc44c85ba528de838217233a61dc38", "html_url": "https://github.com/rust-lang/rust/commit/631e7b4eaacc44c85ba528de838217233a61dc38"}], "stats": {"total": 400, "additions": 305, "deletions": 95}, "files": [{"sha": "e61a76a2c37a91dc4fc5efb0a5f7c583eaf05f1b", "filename": "src/doc/book/getting-started.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Fdoc%2Fbook%2Fgetting-started.md", "raw_url": "https://github.com/rust-lang/rust/raw/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Fdoc%2Fbook%2Fgetting-started.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fgetting-started.md?ref=7a0ccc458f32b2cb2dee33d7a02954a70c09c34b", "patch": "@@ -8,7 +8,7 @@ we\u2019ll talk about Cargo, Rust\u2019s build system and package manager.\n \n The first step to using Rust is to install it. Generally speaking, you\u2019ll need\n an Internet connection to run the commands in this section, as we\u2019ll be\n-downloading Rust from the internet.\n+downloading Rust from the Internet.\n \n We\u2019ll be showing off a number of commands using a terminal, and those lines all\n start with `$`. We don't need to type in the `$`s, they are there to indicate\n@@ -399,13 +399,13 @@ Let\u2019s convert the Hello World program to Cargo. To Cargo-fy a project, you nee\n to do three things:\n \n 1. Put your source file in the right directory.\n-2. Get rid of the old executable (`main.exe` on Windows, `main` everywhere else)\n-   and make a new one.\n+2. Get rid of the old executable (`main.exe` on Windows, `main` everywhere\n+   else).\n 3. Make a Cargo configuration file.\n \n Let's get started!\n \n-### Creating a new Executable and Source Directory\n+### Creating a Source Directory and Removing the Old Executable\n \n First, go back to your terminal, move to your *hello_world* directory, and\n enter the following commands:"}, {"sha": "d58c26a72136b29d415af3695ac97ad088c2981c", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=7a0ccc458f32b2cb2dee33d7a02954a70c09c34b", "patch": "@@ -333,7 +333,7 @@\n //! precision := count | '*'\n //! type := identifier | ''\n //! count := parameter | integer\n-//! parameter := integer '$'\n+//! parameter := argument '$'\n //! ```\n //!\n //! # Formatting Parameters\n@@ -403,11 +403,12 @@\n //! println!(\"Hello {:5}!\", \"x\");\n //! println!(\"Hello {:1$}!\", \"x\", 5);\n //! println!(\"Hello {1:0$}!\", 5, \"x\");\n+//! println!(\"Hello {:width$}!\", \"x\", width = 5);\n //! ```\n //!\n //! Referring to an argument with the dollar syntax does not affect the \"next\n-//! argument\" counter, so it's usually a good idea to refer to all arguments by\n-//! their position explicitly.\n+//! argument\" counter, so it's usually a good idea to refer to arguments by\n+//! position, or use named arguments.\n //!\n //! ## Precision\n //!\n@@ -426,7 +427,7 @@\n //!\n //!    the integer `N` itself is the precision.\n //!\n-//! 2. An integer followed by dollar sign `.N$`:\n+//! 2. An integer or name followed by dollar sign `.N$`:\n //!\n //!    use format *argument* `N` (which must be a `usize`) as the precision.\n //!\n@@ -456,6 +457,10 @@\n //! // Hello {next arg (x)} is {arg 2 (0.01) with precision\n //! //                          specified in its predecessor (5)}\n //! println!(\"Hello {} is {2:.*}\",   \"x\", 5, 0.01);\n+//!\n+//! // Hello {next arg (x)} is {arg \"number\" (0.01) with precision specified\n+//! //                          in arg \"prec\" (5)}\n+//! println!(\"Hello {} is {number:.prec$}\", \"x\", prec = 5, number = 0.01);\n //! ```\n //!\n //! All print the same thing:"}, {"sha": "a0f2a2adcb62cb8cf2587af3170fa96eea412f51", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=7a0ccc458f32b2cb2dee33d7a02954a70c09c34b", "patch": "@@ -110,6 +110,7 @@ pub use intrinsics::transmute;\n ///     }\n /// }\n /// ```\n+#[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn forget<T>(t: T) {\n     unsafe { intrinsics::forget(t) }"}, {"sha": "e838921a831784f224b9d4c51653e391fee48ec9", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 76, "deletions": 1, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=7a0ccc458f32b2cb2dee33d7a02954a70c09c34b", "patch": "@@ -314,6 +314,82 @@ let c = &i; // still ok!\n ```\n \"##,\n \n+E0501: r##\"\n+This error indicates that a mutable variable is being used while it is still\n+captured by a closure. Because the closure has borrowed the variable, it is not\n+available for use until the closure goes out of scope.\n+\n+Note that a capture will either move or borrow a variable, but in this\n+situation, the closure is borrowing the variable. Take a look at\n+http://rustbyexample.com/fn/closures/capture.html for more information about\n+capturing.\n+\n+Example of erroneous code:\n+\n+```compile_fail\n+fn inside_closure(x: &mut i32) {\n+    // Actions which require unique access\n+}\n+\n+fn outside_closure(x: &mut i32) {\n+    // Actions which require unique access\n+}\n+\n+fn foo(a: &mut i32) {\n+    let bar = || {\n+        inside_closure(a)\n+    };\n+    outside_closure(a); // error: cannot borrow `*a` as mutable because previous\n+                        //        closure requires unique access.\n+}\n+```\n+\n+To fix this error, you can place the closure in its own scope:\n+\n+```\n+fn inside_closure(x: &mut i32) {}\n+fn outside_closure(x: &mut i32) {}\n+\n+fn foo(a: &mut i32) {\n+    {\n+        let bar = || {\n+            inside_closure(a)\n+        };\n+    } // borrow on `a` ends.\n+    outside_closure(a); // ok!\n+}\n+```\n+\n+Or you can pass the variable as a parameter to the closure:\n+\n+```\n+fn inside_closure(x: &mut i32) {}\n+fn outside_closure(x: &mut i32) {}\n+\n+fn foo(a: &mut i32) {\n+    let bar = |s: &mut i32| {\n+        inside_closure(s)\n+    };\n+    outside_closure(a);\n+    bar(a);\n+}\n+```\n+\n+It may be possible to define the closure later:\n+\n+```\n+fn inside_closure(x: &mut i32) {}\n+fn outside_closure(x: &mut i32) {}\n+\n+fn foo(a: &mut i32) {\n+    outside_closure(a);\n+    let bar = || {\n+        inside_closure(a)\n+    };\n+}\n+```\n+\"##,\n+\n E0507: r##\"\n You tried to move out of a value which was borrowed. Erroneous code example:\n \n@@ -436,7 +512,6 @@ register_diagnostics! {\n     E0388, // {} in a static location\n     E0389, // {} in a `&` reference\n     E0500, // closure requires unique access to `..` but .. is already borrowed\n-    E0501, // cannot borrow `..`.. as .. because previous closure requires unique access\n     E0502, // cannot borrow `..`.. as .. because .. is also borrowed as ...\n     E0503, // cannot use `..` because it was mutably borrowed\n     E0504, // cannot move `..` into closure because it is borrowed"}, {"sha": "06be29b90497657dd97fe307595605d7fdfade12", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 37, "deletions": 48, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=7a0ccc458f32b2cb2dee33d7a02954a70c09c34b", "patch": "@@ -377,13 +377,6 @@ pub enum ErrKind {\n     NotOn(ConstVal),\n     CallOn(ConstVal),\n \n-    NegateWithOverflow(i64),\n-    AddiWithOverflow(i64, i64),\n-    SubiWithOverflow(i64, i64),\n-    MuliWithOverflow(i64, i64),\n-    AdduWithOverflow(u64, u64),\n-    SubuWithOverflow(u64, u64),\n-    MuluWithOverflow(u64, u64),\n     DivideByZero,\n     DivideWithOverflow,\n     ModuloByZero,\n@@ -415,6 +408,7 @@ pub enum ErrKind {\n     TypeMismatch(String, ConstInt),\n     BadType(ConstVal),\n     ErroneousReferencedConstant(Box<ConstEvalErr>),\n+    CharCast(ConstInt),\n }\n \n impl From<ConstMathErr> for ErrKind {\n@@ -439,13 +433,6 @@ impl ConstEvalErr {\n             NotOn(ref const_val) => format!(\"not on {}\", const_val.description()).into_cow(),\n             CallOn(ref const_val) => format!(\"call on {}\", const_val.description()).into_cow(),\n \n-            NegateWithOverflow(..) => \"attempted to negate with overflow\".into_cow(),\n-            AddiWithOverflow(..) => \"attempted to add with overflow\".into_cow(),\n-            SubiWithOverflow(..) => \"attempted to sub with overflow\".into_cow(),\n-            MuliWithOverflow(..) => \"attempted to mul with overflow\".into_cow(),\n-            AdduWithOverflow(..) => \"attempted to add with overflow\".into_cow(),\n-            SubuWithOverflow(..) => \"attempted to sub with overflow\".into_cow(),\n-            MuluWithOverflow(..) => \"attempted to mul with overflow\".into_cow(),\n             DivideByZero         => \"attempted to divide by zero\".into_cow(),\n             DivideWithOverflow   => \"attempted to divide with overflow\".into_cow(),\n             ModuloByZero         => \"attempted remainder with a divisor of zero\".into_cow(),\n@@ -482,6 +469,9 @@ impl ConstEvalErr {\n             },\n             BadType(ref i) => format!(\"value of wrong type: {:?}\", i).into_cow(),\n             ErroneousReferencedConstant(_) => \"could not evaluate referenced constant\".into_cow(),\n+            CharCast(ref got) => {\n+                format!(\"only `u8` can be cast as `char`, not `{}`\", got.description()).into_cow()\n+            },\n         }\n     }\n }\n@@ -824,7 +814,10 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n           debug!(\"const call({:?})\", call_args);\n           eval_const_expr_partial(tcx, &result, ty_hint, Some(&call_args))?\n       },\n-      hir::ExprLit(ref lit) => lit_to_const(&lit.node, tcx, ety, lit.span)?,\n+      hir::ExprLit(ref lit) => match lit_to_const(&lit.node, tcx, ety, lit.span) {\n+          Ok(val) => val,\n+          Err(err) => signal!(e, err),\n+      },\n       hir::ExprBlock(ref block) => {\n         match block.expr {\n             Some(ref expr) => eval_const_expr_partial(tcx, &expr, ty_hint, fn_args)?,\n@@ -930,7 +923,10 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n     };\n \n     match (ety.map(|t| &t.sty), result) {\n-        (Some(ref ty_hint), Integral(i)) => Ok(Integral(infer(i, tcx, ty_hint, e.span)?)),\n+        (Some(ref ty_hint), Integral(i)) => match infer(i, tcx, ty_hint) {\n+            Ok(inferred) => Ok(Integral(inferred)),\n+            Err(err) => signal!(e, err),\n+        },\n         (_, result) => Ok(result),\n     }\n }\n@@ -939,15 +935,9 @@ fn infer<'tcx>(\n     i: ConstInt,\n     tcx: &TyCtxt<'tcx>,\n     ty_hint: &ty::TypeVariants<'tcx>,\n-    span: Span\n-) -> Result<ConstInt, ConstEvalErr> {\n+) -> Result<ConstInt, ErrKind> {\n     use syntax::ast::*;\n \n-    let err = |e| ConstEvalErr {\n-        span: span,\n-        kind: e,\n-    };\n-\n     match (ty_hint, i) {\n         (&ty::TyInt(IntTy::I8), result @ I8(_)) => Ok(result),\n         (&ty::TyInt(IntTy::I16), result @ I16(_)) => Ok(result),\n@@ -993,17 +983,17 @@ fn infer<'tcx>(\n                 Err(_) => Ok(Usize(ConstUsize::Us32(i as u32))),\n             }\n         },\n-        (&ty::TyUint(_), InferSigned(_)) => Err(err(IntermediateUnsignedNegative)),\n+        (&ty::TyUint(_), InferSigned(_)) => Err(IntermediateUnsignedNegative),\n \n-        (&ty::TyInt(ity), i) => Err(err(TypeMismatch(ity.to_string(), i))),\n-        (&ty::TyUint(ity), i) => Err(err(TypeMismatch(ity.to_string(), i))),\n+        (&ty::TyInt(ity), i) => Err(TypeMismatch(ity.to_string(), i)),\n+        (&ty::TyUint(ity), i) => Err(TypeMismatch(ity.to_string(), i)),\n \n         (&ty::TyEnum(ref adt, _), i) => {\n             let hints = tcx.lookup_repr_hints(adt.did);\n             let int_ty = tcx.enum_repr_type(hints.iter().next());\n-            infer(i, tcx, &int_ty.to_ty(tcx).sty, span)\n+            infer(i, tcx, &int_ty.to_ty(tcx).sty)\n         },\n-        (_, i) => Err(err(BadType(ConstVal::Integral(i)))),\n+        (_, i) => Err(BadType(ConstVal::Integral(i))),\n     }\n }\n \n@@ -1089,23 +1079,22 @@ fn cast_const_int<'tcx>(tcx: &TyCtxt<'tcx>, val: ConstInt, ty: ty::Ty) -> CastRe\n                 Err(_) => Ok(Integral(Usize(ConstUsize::Us32(v as u32)))),\n             }\n         },\n-        ty::TyFloat(ast::FloatTy::F64) if val.is_negative() => {\n-            // FIXME: this could probably be prettier\n-            // there's no easy way to turn an `Infer` into a f64\n-            let val = (-val).map_err(Math)?;\n-            let val = val.to_u64().unwrap() as f64;\n-            let val = -val;\n-            Ok(Float(val))\n+        ty::TyFloat(ast::FloatTy::F64) => match val.erase_type() {\n+            Infer(u) => Ok(Float(u as f64)),\n+            InferSigned(i) => Ok(Float(i as f64)),\n+            _ => bug!(\"ConstInt::erase_type returned something other than Infer/InferSigned\"),\n         },\n-        ty::TyFloat(ast::FloatTy::F64) => Ok(Float(val.to_u64().unwrap() as f64)),\n-        ty::TyFloat(ast::FloatTy::F32) if val.is_negative() => {\n-            let val = (-val).map_err(Math)?;\n-            let val = val.to_u64().unwrap() as f32;\n-            let val = -val;\n-            Ok(Float(val as f64))\n+        ty::TyFloat(ast::FloatTy::F32) => match val.erase_type() {\n+            Infer(u) => Ok(Float(u as f32 as f64)),\n+            InferSigned(i) => Ok(Float(i as f32 as f64)),\n+            _ => bug!(\"ConstInt::erase_type returned something other than Infer/InferSigned\"),\n         },\n-        ty::TyFloat(ast::FloatTy::F32) => Ok(Float(val.to_u64().unwrap() as f32 as f64)),\n         ty::TyRawPtr(_) => Err(ErrKind::UnimplementedConstVal(\"casting an address to a raw ptr\")),\n+        ty::TyChar => match infer(val, tcx, &ty::TyUint(ast::UintTy::U8)) {\n+            Ok(U8(u)) => Ok(Char(u as char)),\n+            // can only occur before typeck, typeck blocks `T as char` for `T` != `u8`\n+            _ => Err(CharCast(val)),\n+        },\n         _ => Err(CannotCast),\n     }\n }\n@@ -1136,36 +1125,36 @@ fn lit_to_const<'tcx>(lit: &ast::LitKind,\n                       tcx: &TyCtxt<'tcx>,\n                       ty_hint: Option<Ty<'tcx>>,\n                       span: Span,\n-                      ) -> Result<ConstVal, ConstEvalErr> {\n+                      ) -> Result<ConstVal, ErrKind> {\n     use syntax::ast::*;\n     use syntax::ast::LitIntType::*;\n     match *lit {\n         LitKind::Str(ref s, _) => Ok(Str((*s).clone())),\n         LitKind::ByteStr(ref data) => Ok(ByteStr(data.clone())),\n         LitKind::Byte(n) => Ok(Integral(U8(n))),\n         LitKind::Int(n, Signed(ity)) => {\n-            infer(InferSigned(n as i64), tcx, &ty::TyInt(ity), span).map(Integral)\n+            infer(InferSigned(n as i64), tcx, &ty::TyInt(ity)).map(Integral)\n         },\n \n         LitKind::Int(n, Unsuffixed) => {\n             match ty_hint.map(|t| &t.sty) {\n                 Some(&ty::TyInt(ity)) => {\n-                    infer(InferSigned(n as i64), tcx, &ty::TyInt(ity), span).map(Integral)\n+                    infer(InferSigned(n as i64), tcx, &ty::TyInt(ity)).map(Integral)\n                 },\n                 Some(&ty::TyUint(uty)) => {\n-                    infer(Infer(n), tcx, &ty::TyUint(uty), span).map(Integral)\n+                    infer(Infer(n), tcx, &ty::TyUint(uty)).map(Integral)\n                 },\n                 None => Ok(Integral(Infer(n))),\n                 Some(&ty::TyEnum(ref adt, _)) => {\n                     let hints = tcx.lookup_repr_hints(adt.did);\n                     let int_ty = tcx.enum_repr_type(hints.iter().next());\n-                    infer(Infer(n), tcx, &int_ty.to_ty(tcx).sty, span).map(Integral)\n+                    infer(Infer(n), tcx, &int_ty.to_ty(tcx).sty).map(Integral)\n                 },\n                 Some(ty_hint) => bug!(\"bad ty_hint: {:?}, {:?}\", ty_hint, lit),\n             }\n         },\n         LitKind::Int(n, Unsigned(ity)) => {\n-            infer(Infer(n), tcx, &ty::TyUint(ity), span).map(Integral)\n+            infer(Infer(n), tcx, &ty::TyUint(ity)).map(Integral)\n         },\n \n         LitKind::Float(ref n, _) |"}, {"sha": "b590cc91c5918d0e440dcb6c9f0bbde26d969b52", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7a0ccc458f32b2cb2dee33d7a02954a70c09c34b", "patch": "@@ -147,7 +147,7 @@ enum ResolutionError<'a> {\n     /// error E0416: identifier is bound more than once in the same pattern\n     IdentifierBoundMoreThanOnceInSamePattern(&'a str),\n     /// error E0417: static variables cannot be referenced in a pattern\n-    StaticVariableReference,\n+    StaticVariableReference(DefId, Option<Name>),\n     /// error E0418: is not an enum variant, struct or const\n     NotAnEnumVariantStructOrConst(&'a str),\n     /// error E0419: unresolved enum variant, struct or const\n@@ -352,12 +352,24 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n                              \"identifier `{}` is bound more than once in the same pattern\",\n                              identifier)\n         }\n-        ResolutionError::StaticVariableReference => {\n-            struct_span_err!(resolver.session,\n-                             span,\n-                             E0417,\n-                             \"static variables cannot be referenced in a pattern, use a \\\n-                              `const` instead\")\n+        ResolutionError::StaticVariableReference(did, name) => {\n+            let mut err = struct_span_err!(resolver.session,\n+                                           span,\n+                                           E0417,\n+                                           \"static variables cannot be referenced in a \\\n+                                            pattern, use a `const` instead\");\n+            if let Some(sp) = resolver.ast_map.span_if_local(did) {\n+                err.span_note(sp, \"static variable defined here\");\n+            }\n+            if let Some(name) = name {\n+                if let Some(binding) = resolver.current_module\n+                                               .resolve_name_in_lexical_scope(name, ValueNS) {\n+                    if binding.is_import() {\n+                        err.span_note(binding.span, \"static variable imported here\");\n+                    }\n+                }\n+            }\n+            err\n         }\n         ResolutionError::NotAnEnumVariantStructOrConst(name) => {\n             struct_span_err!(resolver.session,\n@@ -2313,10 +2325,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             Def::Variant(..) | Def::Const(..) => {\n                                 self.record_def(pattern.id, path_res);\n                             }\n-                            Def::Static(..) => {\n+                            Def::Static(did, _) => {\n                                 resolve_error(&self,\n                                               path.span,\n-                                              ResolutionError::StaticVariableReference);\n+                                              ResolutionError::StaticVariableReference(\n+                                                  did, None));\n                                 self.record_def(pattern.id, err_path_resolution());\n                             }\n                             _ => {\n@@ -2456,8 +2469,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Some(def @ Def::Const(..)) | Some(def @ Def::AssociatedConst(..)) => {\n                 FoundConst(def, ident.unhygienic_name)\n             }\n-            Some(Def::Static(..)) => {\n-                resolve_error(self, span, ResolutionError::StaticVariableReference);\n+            Some(Def::Static(did, _)) => {\n+                resolve_error(self, span, ResolutionError::StaticVariableReference(\n+                    did, Some(ident.unhygienic_name)));\n                 BareIdentifierPatternUnresolved\n             }\n             _ => BareIdentifierPatternUnresolved,"}, {"sha": "36eb1a1301c9ded4db01f9b8bccaac9546987330", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=7a0ccc458f32b2cb2dee33d7a02954a70c09c34b", "patch": "@@ -20,6 +20,7 @@ use rustc::hir;\n use rustc::middle::cstore::{self, CrateStore};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n+use rustc::hir::print as pprust;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::subst;\n use rustc::middle::stability;\n@@ -30,7 +31,7 @@ use core::{DocContext, DocAccessLevels};\n use doctree;\n use clean::{self, GetDefId};\n \n-use super::{Clean, ToSource};\n+use super::Clean;\n \n /// Attempt to inline the definition of a local node id into this AST.\n ///\n@@ -333,8 +334,8 @@ pub fn build_impl(cx: &DocContext,\n                 let did = assoc_const.def_id;\n                 let type_scheme = tcx.lookup_item_type(did);\n                 let default = if assoc_const.has_value {\n-                    Some(lookup_const_by_id(tcx, did, None)\n-                         .unwrap().0.span.to_src(cx))\n+                    Some(pprust::expr_to_string(\n+                        lookup_const_by_id(tcx, did, None).unwrap().0))\n                 } else {\n                     None\n                 };\n@@ -479,8 +480,6 @@ fn build_module(cx: &DocContext, tcx: &TyCtxt,\n \n fn build_const(cx: &DocContext, tcx: &TyCtxt,\n                did: DefId) -> clean::Constant {\n-    use rustc::hir::print as pprust;\n-\n     let (expr, ty) = lookup_const_by_id(tcx, did, None).unwrap_or_else(|| {\n         panic!(\"expected lookup_const_by_id to succeed for {:?}\", did);\n     });"}, {"sha": "0a606e1425c4552579b597d27a02d0c1ca733a3e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7a0ccc458f32b2cb2dee33d7a02954a70c09c34b", "patch": "@@ -39,6 +39,7 @@ use rustc::middle::cstore::{self, CrateStore};\n use rustc::middle::privacy::AccessLevels;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n+use rustc::hir::print as pprust;\n use rustc::ty::subst::{self, ParamSpace, VecPerParamSpace};\n use rustc::ty;\n use rustc::middle::stability;\n@@ -1285,8 +1286,7 @@ impl Clean<Item> for hir::TraitItem {\n         let inner = match self.node {\n             hir::ConstTraitItem(ref ty, ref default) => {\n                 AssociatedConstItem(ty.clean(cx),\n-                                    default.as_ref().map(|expr|\n-                                                         expr.span.to_src(cx)))\n+                                    default.as_ref().map(|e| pprust::expr_to_string(&e)))\n             }\n             hir::MethodTraitItem(ref sig, Some(_)) => {\n                 MethodItem(sig.clean(cx))\n@@ -1316,7 +1316,7 @@ impl Clean<Item> for hir::ImplItem {\n         let inner = match self.node {\n             hir::ImplItemKind::Const(ref ty, ref expr) => {\n                 AssociatedConstItem(ty.clean(cx),\n-                                    Some(expr.span.to_src(cx)))\n+                                    Some(pprust::expr_to_string(expr)))\n             }\n             hir::ImplItemKind::Method(ref sig, _) => {\n                 MethodItem(sig.clean(cx))\n@@ -1635,8 +1635,8 @@ impl Clean<Type> for hir::Ty {\n                 BorrowedRef {lifetime: l.clean(cx), mutability: m.mutbl.clean(cx),\n                              type_: box m.ty.clean(cx)},\n             TyVec(ref ty) => Vector(box ty.clean(cx)),\n-            TyFixedLengthVec(ref ty, ref e) => FixedVector(box ty.clean(cx),\n-                                                           e.span.to_src(cx)),\n+            TyFixedLengthVec(ref ty, ref e) =>\n+                FixedVector(box ty.clean(cx), pprust::expr_to_string(e)),\n             TyTup(ref tys) => Tuple(tys.clean(cx)),\n             TyPath(None, ref p) => {\n                 resolve_type(cx, p.clean(cx), self.id)\n@@ -2185,7 +2185,7 @@ impl Clean<Item> for doctree::Static {\n             inner: StaticItem(Static {\n                 type_: self.type_.clean(cx),\n                 mutability: self.mutability.clean(cx),\n-                expr: self.expr.span.to_src(cx),\n+                expr: pprust::expr_to_string(&self.expr),\n             }),\n         }\n     }\n@@ -2209,7 +2209,7 @@ impl Clean<Item> for doctree::Constant {\n             deprecation: self.depr.clean(cx),\n             inner: ConstantItem(Constant {\n                 type_: self.type_.clean(cx),\n-                expr: self.expr.span.to_src(cx),\n+                expr: pprust::expr_to_string(&self.expr),\n             }),\n         }\n     }"}, {"sha": "7af5322e7bdf16ea73449e4e5b94e775a1602db5", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=7a0ccc458f32b2cb2dee33d7a02954a70c09c34b", "patch": "@@ -26,6 +26,7 @@ use rustc::hir;\n use clean;\n use core::DocAccessLevels;\n use html::item_type::ItemType;\n+use html::escape::Escape;\n use html::render;\n use html::render::{cache, CURRENT_LOCATION_KEY};\n \n@@ -496,7 +497,7 @@ impl fmt::Display for clean::Type {\n                 primitive_link(f, clean::PrimitiveType::Array, \"[\")?;\n                 write!(f, \"{}\", t)?;\n                 primitive_link(f, clean::PrimitiveType::Array,\n-                               &format!(\"; {}]\", *s))\n+                               &format!(\"; {}]\", Escape(s)))\n             }\n             clean::Bottom => f.write_str(\"!\"),\n             clean::RawPointer(m, ref t) => {"}, {"sha": "36da95279fb24f7190666dd683ddb210eab207bd", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=7a0ccc458f32b2cb2dee33d7a02954a70c09c34b", "patch": "@@ -1866,7 +1866,7 @@ impl<'a> fmt::Display for Initializer<'a> {\n         let Initializer(s) = *self;\n         if s.is_empty() { return Ok(()); }\n         write!(f, \"<code> = </code>\")?;\n-        write!(f, \"<code>{}</code>\", s)\n+        write!(f, \"<code>{}</code>\", Escape(s))\n     }\n }\n \n@@ -2106,7 +2106,7 @@ fn assoc_const(w: &mut fmt::Formatter,\n \n     write!(w, \": {}\", ty)?;\n     if let Some(default) = default {\n-        write!(w, \" = {}\", default)?;\n+        write!(w, \" = {}\", Escape(default))?;\n     }\n     Ok(())\n }"}, {"sha": "9cd2e6ef7d695960b97e2a1ce00caa821e646923", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7a0ccc458f32b2cb2dee33d7a02954a70c09c34b", "patch": "@@ -4419,11 +4419,7 @@ impl<'a> Parser<'a> {\n                 p.forbid_lifetime()?;\n                 let lo = p.span.lo;\n                 let ident = p.parse_ident()?;\n-                let found_eq = p.eat(&token::Eq);\n-                if !found_eq {\n-                    let span = p.span;\n-                    p.span_warn(span, \"whoops, no =?\");\n-                }\n+                p.expect(&token::Eq)?;\n                 let ty = p.parse_ty()?;\n                 let hi = ty.span.hi;\n                 let span = mk_sp(lo, hi);"}, {"sha": "31e1a72967f4dcf4860574ce6f563503a3d2637d", "filename": "src/test/compile-fail/const-eval-overflow-4b.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs?ref=7a0ccc458f32b2cb2dee33d7a02954a70c09c34b", "patch": "@@ -15,7 +15,6 @@\n \n #![allow(unused_imports)]\n \n-use std::fmt;\n use std::{i8, i16, i32, i64, isize};\n use std::{u8, u16, u32, u64, usize};\n \n@@ -26,10 +25,15 @@ const A_I8_T\n     //~| found `u8` [E0250]\n     = [0; (i8::MAX as usize) + 1];\n \n-fn main() {\n-    foo(&A_I8_T[..]);\n-}\n \n-fn foo<T:fmt::Debug>(x: T) {\n-    println!(\"{:?}\", x);\n-}\n+const A_CHAR_USIZE\n+    : [u32; 5u8 as char as usize]\n+    = [0; 5];\n+\n+\n+const A_BAD_CHAR_USIZE\n+    : [u32; 5i8 as char as usize]\n+    //~^ ERROR only `u8` can be cast as `char`, not `i8`\n+    = [0; 5];\n+\n+fn main() {}"}, {"sha": "c54f901199b460c0e62d1dce4881819440e2bf0a", "filename": "src/test/compile-fail/issue-23716.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Ftest%2Fcompile-fail%2Fissue-23716.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Ftest%2Fcompile-fail%2Fissue-23716.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23716.rs?ref=7a0ccc458f32b2cb2dee33d7a02954a70c09c34b", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static foo: i32 = 0;\n+//~^ NOTE static variable defined here\n+\n+fn bar(foo: i32) {}\n+//~^ ERROR static variables cannot be referenced in a pattern, use a `const` instead\n+\n+mod submod {\n+    pub static answer: i32 = 42;\n+    //~^ NOTE static variable defined here\n+}\n+\n+use self::submod::answer;\n+//~^ NOTE static variable imported here\n+\n+fn question(answer: i32) {}\n+//~^ ERROR static variables cannot be referenced in a pattern, use a `const` instead\n+\n+fn main() {\n+}"}, {"sha": "3ba59c8ee946bfc792442a2a94a9f79aa43ab160", "filename": "src/test/parse-fail/issue-32214.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Ftest%2Fparse-fail%2Fissue-32214.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Ftest%2Fparse-fail%2Fissue-32214.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-32214.rs?ref=7a0ccc458f32b2cb2dee33d7a02954a70c09c34b", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only -Z continue-parse-after-error\n+\n+pub fn test<W, I: Iterator<Item=(), W> >() {\n+    //~^ ERROR expected `=`, found `>`\n+}\n+\n+fn main() { }"}, {"sha": "30641c1cb87b198e7ec30008843cc6a9720fa66e", "filename": "src/test/run-pass/const-err.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Ftest%2Frun-pass%2Fconst-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Ftest%2Frun-pass%2Fconst-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-err.rs?ref=7a0ccc458f32b2cb2dee33d7a02954a70c09c34b", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check for const_err regressions\n+\n+#![deny(const_err)]\n+\n+\n+fn main() {\n+    let _ = ((-1 as i8) << 8 - 1) as f32;\n+    let _ = 0u8 as char;\n+}"}, {"sha": "7f9a2bf175a5f96c7a23daf497665244f16b055e", "filename": "src/test/rustdoc/escape-rust-expr.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Ftest%2Frustdoc%2Fescape-rust-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Ftest%2Frustdoc%2Fescape-rust-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fescape-rust-expr.rs?ref=7a0ccc458f32b2cb2dee33d7a02954a70c09c34b", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we HTML-escape Rust expressions, where HTML special chars\n+// can occur, and we know it's definitely not markup.\n+\n+// @has escape_rust_expr/constant.CONST_S.html '//pre[@class=\"rust const\"]' '\"<script>\"'\n+pub const CONST_S: &'static str = \"<script>\";"}, {"sha": "b9188e8a4e9bacbb82a7507f72ee12a03a3f9cbf", "filename": "src/test/rustdoc/issue-33302.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Ftest%2Frustdoc%2Fissue-33302.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a0ccc458f32b2cb2dee33d7a02954a70c09c34b/src%2Ftest%2Frustdoc%2Fissue-33302.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-33302.rs?ref=7a0ccc458f32b2cb2dee33d7a02954a70c09c34b", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Ensure constant and array length values are not taken from source\n+// code, which wreaks havoc with macros.\n+\n+#![feature(associated_consts)]\n+\n+macro_rules! make {\n+    ($n:expr) => {\n+        pub struct S;\n+\n+        // @has issue_33302/constant.CST.html \\\n+        //        '//pre[@class=\"rust const\"]' 'pub const CST: i32 = 4 * 4'\n+        pub const CST: i32 = ($n * $n);\n+        // @has issue_33302/static.ST.html \\\n+        //        '//pre[@class=\"rust static\"]' 'pub static ST: i32 = 4 * 4'\n+        pub static ST: i32 = ($n * $n);\n+\n+        pub trait T<X> {\n+            fn ignore(_: &X) {}\n+            const C: X;\n+            // @has issue_33302/trait.T.html \\\n+            //        '//*[@class=\"rust trait\"]' 'const D: i32 = 4 * 4;'\n+            // @has - '//*[@id=\"associatedconstant.D\"]' 'const D: i32 = 4 * 4'\n+            const D: i32 = ($n * $n);\n+        }\n+\n+        // @has issue_33302/struct.S.html \\\n+        //        '//h3[@class=\"impl\"]' 'impl T<[i32; 4 * 4]> for S'\n+        // @has - '//*[@id=\"associatedconstant.C\"]' 'const C: [i32; 4 * 4] = [0; 4 * 4]'\n+        // @has - '//*[@id=\"associatedconstant.D\"]' 'const D: i32 = 4 * 4'\n+        impl T<[i32; ($n * $n)]> for S {\n+            const C: [i32; ($n * $n)] = [0; ($n * $n)];\n+        }\n+    }\n+}\n+\n+make!(4);"}]}