{"sha": "d7324631aed90a5a4182c1eac8f2670f586fb3b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3MzI0NjMxYWVkOTBhNWE0MTgyYzFlYWM4ZjI2NzBmNTg2ZmIzYjM=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-05-20T22:37:44Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-05-24T18:48:54Z"}, "message": "Rename MemoryPointer to Pointer", "tree": {"sha": "2e83f5546936d83f7b5ce995e7fd465fed0bb9c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e83f5546936d83f7b5ce995e7fd465fed0bb9c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7324631aed90a5a4182c1eac8f2670f586fb3b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7324631aed90a5a4182c1eac8f2670f586fb3b3", "html_url": "https://github.com/rust-lang/rust/commit/d7324631aed90a5a4182c1eac8f2670f586fb3b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7324631aed90a5a4182c1eac8f2670f586fb3b3/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03a92b61ec83c6bd37cbb7527ce5da68b6d247a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9", "html_url": "https://github.com/rust-lang/rust/commit/03a92b61ec83c6bd37cbb7527ce5da68b6d247a9"}], "stats": {"total": 162, "additions": 81, "deletions": 81}, "files": [{"sha": "155efd0c43e48237a136b31de8c8f9132371c250", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=d7324631aed90a5a4182c1eac8f2670f586fb3b3", "patch": "@@ -415,7 +415,7 @@ impl_stable_hash_for!(enum mir::interpret::Value {\n     ByRef(ptr, align)\n });\n \n-impl_stable_hash_for!(struct mir::interpret::MemoryPointer {\n+impl_stable_hash_for!(struct mir::interpret::Pointer {\n     alloc_id,\n     offset\n });"}, {"sha": "45819afca3f5c0dc9d840ec94caa04e8590a0550", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=d7324631aed90a5a4182c1eac8f2670f586fb3b3", "patch": "@@ -5,7 +5,7 @@ use ty::{FnSig, Ty, layout};\n use ty::layout::{Size, Align};\n \n use super::{\n-    MemoryPointer, Lock, AccessKind\n+    Pointer, Lock, AccessKind\n };\n \n use backtrace::Backtrace;\n@@ -38,15 +38,15 @@ pub enum EvalErrorKind<'tcx, O> {\n     MachineError(String),\n     FunctionPointerTyMismatch(FnSig<'tcx>, FnSig<'tcx>),\n     NoMirFor(String),\n-    UnterminatedCString(MemoryPointer),\n+    UnterminatedCString(Pointer),\n     DanglingPointerDeref,\n     DoubleFree,\n     InvalidMemoryAccess,\n     InvalidFunctionPointer,\n     InvalidBool,\n     InvalidDiscriminant,\n     PointerOutOfBounds {\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         access: bool,\n         allocation_size: Size,\n     },\n@@ -76,26 +76,26 @@ pub enum EvalErrorKind<'tcx, O> {\n         has: Align,\n     },\n     MemoryLockViolation {\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         len: u64,\n         frame: usize,\n         access: AccessKind,\n         lock: Lock,\n     },\n     MemoryAcquireConflict {\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         len: u64,\n         kind: AccessKind,\n         lock: Lock,\n     },\n     InvalidMemoryLockRelease {\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         len: u64,\n         frame: usize,\n         lock: Lock,\n     },\n     DeallocatedLockedMemory {\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         lock: Lock,\n     },\n     ValidationFailure(String),"}, {"sha": "397e4fdc9403b214ee10ee699f2707b2c3555756", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=d7324631aed90a5a4182c1eac8f2670f586fb3b3", "patch": "@@ -110,46 +110,46 @@ impl<T: layout::HasDataLayout> PointerArithmetic for T {}\n \n \n #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n-pub struct MemoryPointer {\n+pub struct Pointer {\n     pub alloc_id: AllocId,\n     pub offset: Size,\n }\n \n-impl<'tcx> MemoryPointer {\n+impl<'tcx> Pointer {\n     pub fn new(alloc_id: AllocId, offset: Size) -> Self {\n-        MemoryPointer { alloc_id, offset }\n+        Pointer { alloc_id, offset }\n     }\n \n     pub fn zero(alloc_id: AllocId) -> Self {\n-        MemoryPointer::new(alloc_id, Size::ZERO)\n+        Pointer::new(alloc_id, Size::ZERO)\n     }\n \n     pub(crate) fn wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> Self {\n-        MemoryPointer::new(\n+        Pointer::new(\n             self.alloc_id,\n             Size::from_bytes(cx.data_layout().wrapping_signed_offset(self.offset.bytes(), i)),\n         )\n     }\n \n     pub fn overflowing_signed_offset<C: HasDataLayout>(self, i: i128, cx: C) -> (Self, bool) {\n         let (res, over) = cx.data_layout().overflowing_signed_offset(self.offset.bytes(), i);\n-        (MemoryPointer::new(self.alloc_id, Size::from_bytes(res)), over)\n+        (Pointer::new(self.alloc_id, Size::from_bytes(res)), over)\n     }\n \n     pub(crate) fn signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n-        Ok(MemoryPointer::new(\n+        Ok(Pointer::new(\n             self.alloc_id,\n             Size::from_bytes(cx.data_layout().signed_offset(self.offset.bytes(), i)?),\n         ))\n     }\n \n     pub fn overflowing_offset<C: HasDataLayout>(self, i: Size, cx: C) -> (Self, bool) {\n         let (res, over) = cx.data_layout().overflowing_offset(self.offset.bytes(), i.bytes());\n-        (MemoryPointer::new(self.alloc_id, Size::from_bytes(res)), over)\n+        (Pointer::new(self.alloc_id, Size::from_bytes(res)), over)\n     }\n \n     pub fn offset<C: HasDataLayout>(self, i: Size, cx: C) -> EvalResult<'tcx, Self> {\n-        Ok(MemoryPointer::new(\n+        Ok(Pointer::new(\n             self.alloc_id,\n             Size::from_bytes(cx.data_layout().offset(self.offset.bytes(), i.bytes())?),\n         ))"}, {"sha": "53bc56cffe677bcbb1b44e3a1b06f00c9555dc55", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=d7324631aed90a5a4182c1eac8f2670f586fb3b3", "patch": "@@ -3,7 +3,7 @@\n use ty::layout::{Align, HasDataLayout, Size};\n use ty;\n \n-use super::{EvalResult, MemoryPointer, PointerArithmetic, Allocation};\n+use super::{EvalResult, Pointer, PointerArithmetic, Allocation};\n \n /// Represents a constant value in Rust. ByVal and ScalarPair are optimizations which\n /// matches Value's optimizations for easy conversions between these two types\n@@ -59,7 +59,7 @@ impl<'tcx> ConstValue<'tcx> {\n     }\n \n     #[inline]\n-    pub fn to_ptr(&self) -> Option<MemoryPointer> {\n+    pub fn to_ptr(&self) -> Option<Pointer> {\n         match self.to_primval() {\n             Some(Scalar::Ptr(ptr)) => Some(ptr),\n             _ => None,\n@@ -145,7 +145,7 @@ impl<'tcx> Scalar {\n         Value::ScalarPair(self, Scalar::from_u128(len as u128))\n     }\n \n-    pub fn to_value_with_vtable(self, vtable: MemoryPointer) -> Value {\n+    pub fn to_value_with_vtable(self, vtable: Pointer) -> Value {\n         Value::ScalarPair(self, Scalar::Ptr(vtable))\n     }\n \n@@ -154,8 +154,8 @@ impl<'tcx> Scalar {\n     }\n }\n \n-impl From<MemoryPointer> for Scalar {\n-    fn from(ptr: MemoryPointer) -> Self {\n+impl From<Pointer> for Scalar {\n+    fn from(ptr: Pointer) -> Self {\n         Scalar::Ptr(ptr)\n     }\n }\n@@ -171,8 +171,8 @@ pub enum Scalar {\n \n     /// A pointer into an `Allocation`. An `Allocation` in the `memory` module has a list of\n     /// relocations, but a `Scalar` is only large enough to contain one, so we just represent the\n-    /// relocation and its associated offset together as a `MemoryPointer` here.\n-    Ptr(MemoryPointer),\n+    /// relocation and its associated offset together as a `Pointer` here.\n+    Ptr(Pointer),\n \n     /// An undefined `Scalar`, for representing values that aren't safe to examine, but are safe\n     /// to copy around, just like undefined bytes in an `Allocation`.\n@@ -214,7 +214,7 @@ impl<'tcx> Scalar {\n         }\n     }\n \n-    pub fn to_ptr(self) -> EvalResult<'tcx, MemoryPointer> {\n+    pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n         match self {\n             Scalar::Bytes(_) => err!(ReadBytesAsPointer),\n             Scalar::Ptr(p) => Ok(p),"}, {"sha": "3095027b4efeee973d06bdad7d4e1e8da7eb83d2", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=d7324631aed90a5a4182c1eac8f2670f586fb3b3", "patch": "@@ -19,7 +19,7 @@ use ty::subst::{Substs, Subst, Kind, UnpackedKind};\n use ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use ty::{Slice, TyS};\n use util::captures::Captures;\n-use mir::interpret::{Scalar, MemoryPointer, Value, ConstValue};\n+use mir::interpret::{Scalar, Pointer, Value, ConstValue};\n \n use std::iter;\n use std::cmp::Ordering;\n@@ -1853,7 +1853,7 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n-    pub fn to_ptr(&self) -> Option<MemoryPointer> {\n+    pub fn to_ptr(&self) -> Option<Pointer> {\n         match self.val {\n             ConstVal::Value(val) => val.to_ptr(),\n             _ => None,"}, {"sha": "b1161a04128af3886e3e4f7e98c0af17669190d4", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=d7324631aed90a5a4182c1eac8f2670f586fb3b3", "patch": "@@ -14,7 +14,7 @@ use rustc_mir::interpret::{read_target_uint, const_val_field};\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc::mir::interpret::{GlobalId, MemoryPointer, Scalar, Allocation, ConstValue, AllocType};\n+use rustc::mir::interpret::{GlobalId, Pointer, Scalar, Allocation, ConstValue, AllocType};\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, HasDataLayout, LayoutOf, Size};\n use builder::Builder;\n@@ -96,7 +96,7 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx, alloc: &Allocation) -> ValueRef {\n         ).expect(\"const_alloc_to_llvm: could not read relocation pointer\") as u64;\n         llvals.push(primval_to_llvm(\n             cx,\n-            MemoryPointer { alloc_id, offset: Size::from_bytes(ptr_offset) }.into(),\n+            Pointer { alloc_id, offset: Size::from_bytes(ptr_offset) }.into(),\n             &layout::Scalar {\n                 value: layout::Primitive::Pointer,\n                 valid_range: 0..=!0"}, {"sha": "f633320e650b7e081dc475260f718ac95b79c7fa", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=d7324631aed90a5a4182c1eac8f2670f586fb3b3", "patch": "@@ -182,15 +182,15 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             LitKind::Str(ref s, _) => {\n                 let s = s.as_str();\n                 let id = self.tcx.allocate_bytes(s.as_bytes());\n-                let ptr = MemoryPointer::zero(id);\n+                let ptr = Pointer::zero(id);\n                 ConstValue::ScalarPair(\n                     Scalar::Ptr(ptr),\n                     Scalar::from_u128(s.len() as u128),\n                 )\n             },\n             LitKind::ByteStr(ref data) => {\n                 let id = self.tcx.allocate_bytes(data);\n-                let ptr = MemoryPointer::zero(id);\n+                let ptr = Pointer::zero(id);\n                 ConstValue::Scalar(ptr.into())\n             },\n             LitKind::Byte(n) => ConstValue::Scalar(Scalar::Bytes(n as u128)),"}, {"sha": "2172868523034852b90a3a321bffdc91d4a732b4", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=d7324631aed90a5a4182c1eac8f2670f586fb3b3", "patch": "@@ -1128,15 +1128,15 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n         LitKind::Str(ref s, _) => {\n             let s = s.as_str();\n             let id = tcx.allocate_bytes(s.as_bytes());\n-            let ptr = MemoryPointer::zero(id);\n+            let ptr = Pointer::zero(id);\n             ConstValue::ScalarPair(\n                 Scalar::Ptr(ptr),\n                 Scalar::from_u128(s.len() as u128),\n             )\n         },\n         LitKind::ByteStr(ref data) => {\n             let id = tcx.allocate_bytes(data);\n-            let ptr = MemoryPointer::zero(id);\n+            let ptr = Pointer::zero(id);\n             ConstValue::Scalar(ptr.into())\n         },\n         LitKind::Byte(n) => ConstValue::Scalar(Scalar::Bytes(n as u128)),"}, {"sha": "674f03691a889c46ce1d330083f950bade4f0998", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=d7324631aed90a5a4182c1eac8f2670f586fb3b3", "patch": "@@ -4,7 +4,7 @@ use syntax::ast::{FloatTy, IntTy, UintTy};\n \n use rustc_apfloat::ieee::{Single, Double};\n use super::{EvalContext, Machine};\n-use rustc::mir::interpret::{Scalar, EvalResult, MemoryPointer, PointerArithmetic};\n+use rustc::mir::interpret::{Scalar, EvalResult, Pointer, PointerArithmetic};\n use rustc_apfloat::Float;\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n@@ -101,7 +101,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    fn cast_from_ptr(&self, ptr: MemoryPointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Scalar> {\n+    fn cast_from_ptr(&self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Scalar> {\n         use rustc::ty::TypeVariants::*;\n         match ty.sty {\n             // Casting to a reference or fn pointer is not permitted by rustc, no need to support it here."}, {"sha": "2d14b817b8d4c8480b7fa31aa1a0b594403ac066", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=d7324631aed90a5a4182c1eac8f2670f586fb3b3", "patch": "@@ -15,7 +15,7 @@ use syntax::codemap::{self, Span};\n use syntax::ast::Mutability;\n use rustc::mir::interpret::{\n     GlobalId, Value, Scalar, ScalarKind,\n-    EvalError, EvalResult, EvalErrorKind, MemoryPointer, ConstValue,\n+    EvalError, EvalResult, EvalErrorKind, Pointer, ConstValue,\n };\n use std::mem;\n \n@@ -203,7 +203,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         r\n     }\n \n-    pub fn alloc_ptr(&mut self, ty: Ty<'tcx>) -> EvalResult<'tcx, MemoryPointer> {\n+    pub fn alloc_ptr(&mut self, ty: Ty<'tcx>) -> EvalResult<'tcx, Pointer> {\n         let layout = self.layout_of(ty)?;\n         assert!(!layout.is_unsized(), \"cannot alloc memory for unsized type\");\n \n@@ -245,7 +245,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             ConstValue::ByRef(alloc, offset) => {\n                 // FIXME: Allocate new AllocId for all constants inside\n                 let id = self.memory.allocate_value(alloc.clone(), Some(MemoryKind::Stack))?;\n-                Ok(Value::ByRef(MemoryPointer::new(id, offset).into(), alloc.align))\n+                Ok(Value::ByRef(Pointer::new(id, offset).into(), alloc.align))\n             },\n             ConstValue::ScalarPair(a, b) => Ok(Value::ScalarPair(a, b)),\n             ConstValue::Scalar(val) => Ok(Value::Scalar(val)),\n@@ -1019,7 +1019,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 .lock()\n                 .intern_static(gid.instance.def_id());\n             let layout = self.layout_of(ty)?;\n-            let ptr = MemoryPointer::zero(alloc_id);\n+            let ptr = Pointer::zero(alloc_id);\n             return Ok(Value::ByRef(ptr.into(), layout.align))\n         }\n         let cv = self.const_eval(gid)?;\n@@ -1329,7 +1329,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n     pub(crate) fn read_ptr(\n         &self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         ptr_align: Align,\n         pointee_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, Value> {\n@@ -1358,7 +1358,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n     pub fn validate_ptr_target(\n         &self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         ptr_align: Align,\n         ty: Ty<'tcx>\n     ) -> EvalResult<'tcx> {"}, {"sha": "4d04900320fe900553bfd28b67feb7ebb868effe", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=d7324631aed90a5a4182c1eac8f2670f586fb3b3", "patch": "@@ -2,7 +2,7 @@\n //! This separation exists to ensure that no fancy miri features like\n //! interpreting common C functions leak into CTFE.\n \n-use rustc::mir::interpret::{AllocId, EvalResult, Scalar, MemoryPointer, AccessKind, GlobalId};\n+use rustc::mir::interpret::{AllocId, EvalResult, Scalar, Pointer, AccessKind, GlobalId};\n use super::{EvalContext, Place, ValTy, Memory};\n \n use rustc::mir;\n@@ -92,7 +92,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n \n     fn check_locks<'a>(\n         _mem: &Memory<'a, 'mir, 'tcx, Self>,\n-        _ptr: MemoryPointer,\n+        _ptr: Pointer,\n         _size: Size,\n         _access: AccessKind,\n     ) -> EvalResult<'tcx> {"}, {"sha": "9278b08dff8af0d4d3f6c1ca4fa8f793820dc3cd", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=d7324631aed90a5a4182c1eac8f2670f586fb3b3", "patch": "@@ -10,7 +10,7 @@ use syntax::ast::Mutability;\n use rustc::middle::const_val::{ConstVal, ErrKind};\n \n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n-use rustc::mir::interpret::{MemoryPointer, AllocId, Allocation, AccessKind, Value,\n+use rustc::mir::interpret::{Pointer, AllocId, Allocation, AccessKind, Value,\n                             EvalResult, Scalar, EvalErrorKind, GlobalId, AllocType};\n pub use rustc::mir::interpret::{write_target_uint, write_target_int, read_target_uint};\n \n@@ -71,14 +71,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         self.alloc_map.iter().map(|(&id, alloc)| (id, alloc))\n     }\n \n-    pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> MemoryPointer {\n+    pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> Pointer {\n         let id = self.tcx.alloc_map.lock().create_fn_alloc(instance);\n-        MemoryPointer::zero(id)\n+        Pointer::zero(id)\n     }\n \n-    pub fn allocate_bytes(&mut self, bytes: &[u8]) -> MemoryPointer {\n+    pub fn allocate_bytes(&mut self, bytes: &[u8]) -> Pointer {\n         let id = self.tcx.allocate_bytes(bytes);\n-        MemoryPointer::zero(id)\n+        Pointer::zero(id)\n     }\n \n     /// kind is `None` for statics\n@@ -108,20 +108,20 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         size: Size,\n         align: Align,\n         kind: Option<MemoryKind<M::MemoryKinds>>,\n-    ) -> EvalResult<'tcx, MemoryPointer> {\n+    ) -> EvalResult<'tcx, Pointer> {\n         let id = self.allocate_value(Allocation::undef(size, align), kind)?;\n-        Ok(MemoryPointer::zero(id))\n+        Ok(Pointer::zero(id))\n     }\n \n     pub fn reallocate(\n         &mut self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         old_size: Size,\n         old_align: Align,\n         new_size: Size,\n         new_align: Align,\n         kind: MemoryKind<M::MemoryKinds>,\n-    ) -> EvalResult<'tcx, MemoryPointer> {\n+    ) -> EvalResult<'tcx, Pointer> {\n         if ptr.offset.bytes() != 0 {\n             return err!(ReallocateNonBasePtr);\n         }\n@@ -151,7 +151,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(new_ptr)\n     }\n \n-    pub fn deallocate_local(&mut self, ptr: MemoryPointer) -> EvalResult<'tcx> {\n+    pub fn deallocate_local(&mut self, ptr: Pointer) -> EvalResult<'tcx> {\n         match self.alloc_kind.get(&ptr.alloc_id).cloned() {\n             Some(MemoryKind::Stack) => self.deallocate(ptr, None, MemoryKind::Stack),\n             // Happens if the memory was interned into immutable memory\n@@ -162,7 +162,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     pub fn deallocate(\n         &mut self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         size_and_align: Option<(Size, Align)>,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx> {\n@@ -263,7 +263,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    pub fn check_bounds(&self, ptr: MemoryPointer, access: bool) -> EvalResult<'tcx> {\n+    pub fn check_bounds(&self, ptr: Pointer, access: bool) -> EvalResult<'tcx> {\n         let alloc = self.get(ptr.alloc_id)?;\n         let allocation_size = alloc.bytes.len() as u64;\n         if ptr.offset.bytes() > allocation_size {\n@@ -351,7 +351,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    pub fn get_fn(&self, ptr: MemoryPointer) -> EvalResult<'tcx, Instance<'tcx>> {\n+    pub fn get_fn(&self, ptr: Pointer) -> EvalResult<'tcx, Instance<'tcx>> {\n         if ptr.offset.bytes() != 0 {\n             return err!(InvalidFunctionPointer);\n         }\n@@ -479,7 +479,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     fn get_bytes_unchecked(\n         &self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         size: Size,\n         align: Align,\n     ) -> EvalResult<'tcx, &[u8]> {\n@@ -499,7 +499,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     fn get_bytes_unchecked_mut(\n         &mut self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         size: Size,\n         align: Align,\n     ) -> EvalResult<'tcx, &mut [u8]> {\n@@ -517,7 +517,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(&mut alloc.bytes[offset..offset + size.bytes() as usize])\n     }\n \n-    fn get_bytes(&self, ptr: MemoryPointer, size: Size, align: Align) -> EvalResult<'tcx, &[u8]> {\n+    fn get_bytes(&self, ptr: Pointer, size: Size, align: Align) -> EvalResult<'tcx, &[u8]> {\n         assert_ne!(size.bytes(), 0);\n         if self.relocations(ptr, size)?.len() != 0 {\n             return err!(ReadPointerAsBytes);\n@@ -528,7 +528,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     fn get_bytes_mut(\n         &mut self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         size: Size,\n         align: Align,\n     ) -> EvalResult<'tcx, &mut [u8]> {\n@@ -653,7 +653,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn read_c_str(&self, ptr: MemoryPointer) -> EvalResult<'tcx, &[u8]> {\n+    pub fn read_c_str(&self, ptr: Pointer) -> EvalResult<'tcx, &[u8]> {\n         let alloc = self.get(ptr.alloc_id)?;\n         assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n         let offset = ptr.offset.bytes() as usize;\n@@ -707,7 +707,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn read_primval(&self, ptr: MemoryPointer, ptr_align: Align, size: Size) -> EvalResult<'tcx, Scalar> {\n+    pub fn read_primval(&self, ptr: Pointer, ptr_align: Align, size: Size) -> EvalResult<'tcx, Scalar> {\n         self.check_relocation_edges(ptr, size)?; // Make sure we don't read part of a pointer as a pointer\n         let endianness = self.endianness();\n         let bytes = self.get_bytes_unchecked(ptr, size, ptr_align.min(self.int_align(size)))?;\n@@ -726,15 +726,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         } else {\n             let alloc = self.get(ptr.alloc_id)?;\n             match alloc.relocations.get(&ptr.offset) {\n-                Some(&alloc_id) => return Ok(MemoryPointer::new(alloc_id, Size::from_bytes(bytes as u64)).into()),\n+                Some(&alloc_id) => return Ok(Pointer::new(alloc_id, Size::from_bytes(bytes as u64)).into()),\n                 None => {},\n             }\n         }\n         // We don't. Just return the bytes.\n         Ok(Scalar::Bytes(bytes))\n     }\n \n-    pub fn read_ptr_sized(&self, ptr: MemoryPointer, ptr_align: Align) -> EvalResult<'tcx, Scalar> {\n+    pub fn read_ptr_sized(&self, ptr: Pointer, ptr_align: Align) -> EvalResult<'tcx, Scalar> {\n         self.read_primval(ptr, ptr_align, self.pointer_size())\n     }\n \n@@ -782,7 +782,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn write_ptr_sized_unsigned(&mut self, ptr: MemoryPointer, ptr_align: Align, val: Scalar) -> EvalResult<'tcx> {\n+    pub fn write_ptr_sized_unsigned(&mut self, ptr: Pointer, ptr_align: Align, val: Scalar) -> EvalResult<'tcx> {\n         let ptr_size = self.pointer_size();\n         self.write_primval(ptr.into(), ptr_align, val, ptr_size, false)\n     }\n@@ -806,15 +806,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     fn relocations(\n         &self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         size: Size,\n     ) -> EvalResult<'tcx, &[(Size, AllocId)]> {\n         let start = ptr.offset.bytes().saturating_sub(self.pointer_size().bytes() - 1);\n         let end = ptr.offset + size;\n         Ok(self.get(ptr.alloc_id)?.relocations.range(Size::from_bytes(start)..end))\n     }\n \n-    fn clear_relocations(&mut self, ptr: MemoryPointer, size: Size) -> EvalResult<'tcx> {\n+    fn clear_relocations(&mut self, ptr: Pointer, size: Size) -> EvalResult<'tcx> {\n         // Find the start and end of the given range and its outermost relocations.\n         let (first, last) = {\n             // Find all relocations overlapping the given range.\n@@ -846,7 +846,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    fn check_relocation_edges(&self, ptr: MemoryPointer, size: Size) -> EvalResult<'tcx> {\n+    fn check_relocation_edges(&self, ptr: Pointer, size: Size) -> EvalResult<'tcx> {\n         let overlapping_start = self.relocations(ptr, Size::ZERO)?.len();\n         let overlapping_end = self.relocations(ptr.offset(size, self)?, Size::ZERO)?.len();\n         if overlapping_start + overlapping_end != 0 {\n@@ -861,8 +861,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     // FIXME(solson): This is a very naive, slow version.\n     fn copy_undef_mask(\n         &mut self,\n-        src: MemoryPointer,\n-        dest: MemoryPointer,\n+        src: Pointer,\n+        dest: Pointer,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n         // The bits have to be saved locally before writing to dest in case src and dest overlap.\n@@ -882,7 +882,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    fn check_defined(&self, ptr: MemoryPointer, size: Size) -> EvalResult<'tcx> {\n+    fn check_defined(&self, ptr: Pointer, size: Size) -> EvalResult<'tcx> {\n         let alloc = self.get(ptr.alloc_id)?;\n         if !alloc.undef_mask.is_range_defined(\n             ptr.offset,\n@@ -940,7 +940,7 @@ pub trait HasMemory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     fn into_ptr_vtable_pair(\n         &self,\n         value: Value,\n-    ) -> EvalResult<'tcx, (Scalar, MemoryPointer)> {\n+    ) -> EvalResult<'tcx, (Scalar, Pointer)> {\n         match value {\n             Value::ByRef(ref_ptr, align) => {\n                 let mem = self.memory();"}, {"sha": "1c630491a9cd0e577a930076226184438aa20c7f", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=d7324631aed90a5a4182c1eac8f2670f586fb3b3", "patch": "@@ -3,7 +3,7 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n use rustc_data_structures::indexed_vec::Idx;\n \n-use rustc::mir::interpret::{GlobalId, Value, Scalar, EvalResult, MemoryPointer};\n+use rustc::mir::interpret::{GlobalId, Value, Scalar, EvalResult, Pointer};\n use super::{EvalContext, Machine, ValTy};\n use interpret::memory::HasMemory;\n \n@@ -28,7 +28,7 @@ pub enum Place {\n pub enum PlaceExtra {\n     None,\n     Length(u64),\n-    Vtable(MemoryPointer),\n+    Vtable(Pointer),\n     DowncastVariant(usize),\n }\n \n@@ -46,7 +46,7 @@ impl<'tcx> Place {\n         }\n     }\n \n-    pub fn from_ptr(ptr: MemoryPointer, align: Align) -> Self {\n+    pub fn from_ptr(ptr: Pointer, align: Align) -> Self {\n         Self::from_primval_ptr(ptr.into(), align)\n     }\n \n@@ -63,7 +63,7 @@ impl<'tcx> Place {\n         (ptr, align)\n     }\n \n-    pub fn to_ptr(self) -> EvalResult<'tcx, MemoryPointer> {\n+    pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n         // At this point, we forget about the alignment information -- the place has been turned into a reference,\n         // and no matter where it came from, it now must be aligned.\n         self.to_ptr_align().0.to_ptr()\n@@ -210,7 +210,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 };\n                 let alloc = Machine::init_static(self, cid)?;\n                 Place::Ptr {\n-                    ptr: MemoryPointer::zero(alloc).into(),\n+                    ptr: Pointer::zero(alloc).into(),\n                     align: layout.align,\n                     extra: PlaceExtra::None,\n                 }"}, {"sha": "c94592cf159514378b16e4a34d758c82570c60f4", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7324631aed90a5a4182c1eac8f2670f586fb3b3/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=d7324631aed90a5a4182c1eac8f2670f586fb3b3", "patch": "@@ -2,7 +2,7 @@ use rustc::ty::{self, Ty};\n use rustc::ty::layout::{Size, Align, LayoutOf};\n use syntax::ast::Mutability;\n \n-use rustc::mir::interpret::{Scalar, Value, MemoryPointer, EvalResult};\n+use rustc::mir::interpret::{Scalar, Value, Pointer, EvalResult};\n use super::{EvalContext, Machine};\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n@@ -16,7 +16,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         &mut self,\n         ty: Ty<'tcx>,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n-    ) -> EvalResult<'tcx, MemoryPointer> {\n+    ) -> EvalResult<'tcx, Pointer> {\n         debug!(\"get_vtable(trait_ref={:?})\", trait_ref);\n \n         let layout = self.layout_of(trait_ref.self_ty())?;\n@@ -61,7 +61,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n     pub fn read_drop_type_from_vtable(\n         &self,\n-        vtable: MemoryPointer,\n+        vtable: Pointer,\n     ) -> EvalResult<'tcx, Option<ty::Instance<'tcx>>> {\n         // we don't care about the pointee type, we just want a pointer\n         let pointer_align = self.tcx.data_layout.pointer_align;\n@@ -75,7 +75,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n     pub fn read_size_and_align_from_vtable(\n         &self,\n-        vtable: MemoryPointer,\n+        vtable: Pointer,\n     ) -> EvalResult<'tcx, (Size, Align)> {\n         let pointer_size = self.memory.pointer_size();\n         let pointer_align = self.tcx.data_layout.pointer_align;"}]}