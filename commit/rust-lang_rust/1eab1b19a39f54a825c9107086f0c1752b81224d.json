{"sha": "1eab1b19a39f54a825c9107086f0c1752b81224d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlYWIxYjE5YTM5ZjU0YTgyNWM5MTA3MDg2ZjBjMTc1MmI4MTIyNGQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-02-08T22:16:39Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-02-22T22:31:37Z"}, "message": "support unit tests with return values that implement `Terminaton`\n\nExtend `Termination` trait with a method to determine what happens\nwith a unit test.\n\nThis commit incorporates work by Bastian K\u00f6cher <git@kchr.de>.", "tree": {"sha": "53cc7dc5ef925bd678b2a431cf8b5900551befad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53cc7dc5ef925bd678b2a431cf8b5900551befad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1eab1b19a39f54a825c9107086f0c1752b81224d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1eab1b19a39f54a825c9107086f0c1752b81224d", "html_url": "https://github.com/rust-lang/rust/commit/1eab1b19a39f54a825c9107086f0c1752b81224d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1eab1b19a39f54a825c9107086f0c1752b81224d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1f8e6fb06d7362eeb2065347a7db94e76b1cb2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1f8e6fb06d7362eeb2065347a7db94e76b1cb2f", "html_url": "https://github.com/rust-lang/rust/commit/b1f8e6fb06d7362eeb2065347a7db94e76b1cb2f"}], "stats": {"total": 209, "additions": 166, "deletions": 43}, "files": [{"sha": "e4600f25ea70c40cc813f1831139027884ecff35", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1eab1b19a39f54a825c9107086f0c1752b81224d/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eab1b19a39f54a825c9107086f0c1752b81224d/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=1eab1b19a39f54a825c9107086f0c1752b81224d", "patch": "@@ -816,7 +816,8 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n                                          &mut resolver,\n                                          sess.opts.test,\n                                          krate,\n-                                         sess.diagnostic())\n+                                         sess.diagnostic(),\n+                                         &sess.features.borrow())\n     });\n \n     // If we're actually rustdoc then there's no need to actually compile"}, {"sha": "f02fad009d8a597547e03d0a3d27ad92476937a2", "filename": "src/libstd/termination.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1eab1b19a39f54a825c9107086f0c1752b81224d/src%2Flibstd%2Ftermination.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eab1b19a39f54a825c9107086f0c1752b81224d/src%2Flibstd%2Ftermination.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftermination.rs?ref=1eab1b19a39f54a825c9107086f0c1752b81224d", "patch": "@@ -37,6 +37,13 @@ pub trait Termination {\n     /// Is called to get the representation of the value as status code.\n     /// This status code is returned to the operating system.\n     fn report(self) -> i32;\n+\n+    /// Invoked when unit tests terminate. Should panic if the unit\n+    /// test is considered a failure. By default, invokes `report()`\n+    /// and checks for a `0` result.\n+    fn assert_unit_test_successful(self) where Self: Sized {\n+        assert_eq!(self.report(), 0);\n+    }\n }\n \n #[unstable(feature = \"termination_trait\", issue = \"43301\")]"}, {"sha": "53ff3ccd48ad94021993480a2368a131c32020d9", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1eab1b19a39f54a825c9107086f0c1752b81224d/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eab1b19a39f54a825c9107086f0c1752b81224d/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=1eab1b19a39f54a825c9107086f0c1752b81224d", "patch": "@@ -105,6 +105,7 @@ pub mod syntax {\n     pub use ext;\n     pub use parse;\n     pub use ast;\n+    pub use tokenstream;\n }\n \n pub mod abi;"}, {"sha": "094de6868a500348124e3fd3b616fd660cdd643c", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 128, "deletions": 42, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/1eab1b19a39f54a825c9107086f0c1752b81224d/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eab1b19a39f54a825c9107086f0c1752b81224d/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=1eab1b19a39f54a825c9107086f0c1752b81224d", "patch": "@@ -32,6 +32,7 @@ use ext::build::AstBuilder;\n use ext::expand::ExpansionConfig;\n use ext::hygiene::{Mark, SyntaxContext};\n use fold::Folder;\n+use feature_gate::Features;\n use util::move_map::MoveMap;\n use fold;\n use parse::{token, ParseSess};\n@@ -63,6 +64,7 @@ struct TestCtxt<'a> {\n     reexport_test_harness_main: Option<Symbol>,\n     is_libtest: bool,\n     ctxt: SyntaxContext,\n+    features: &'a Features,\n \n     // top-level re-export submodule, filled out after folding is finished\n     toplevel_reexport: Option<Ident>,\n@@ -74,7 +76,8 @@ pub fn modify_for_testing(sess: &ParseSess,\n                           resolver: &mut Resolver,\n                           should_test: bool,\n                           krate: ast::Crate,\n-                          span_diagnostic: &errors::Handler) -> ast::Crate {\n+                          span_diagnostic: &errors::Handler,\n+                          features: &Features) -> ast::Crate {\n     // Check for #[reexport_test_harness_main = \"some_name\"] which\n     // creates a `use some_name = __test::main;`. This needs to be\n     // unconditional, so that the attribute is still marked as used in\n@@ -84,7 +87,8 @@ pub fn modify_for_testing(sess: &ParseSess,\n                                            \"reexport_test_harness_main\");\n \n     if should_test {\n-        generate_test_harness(sess, resolver, reexport_test_harness_main, krate, span_diagnostic)\n+        generate_test_harness(sess, resolver, reexport_test_harness_main,\n+                              krate, span_diagnostic, features)\n     } else {\n         krate\n     }\n@@ -265,23 +269,28 @@ fn generate_test_harness(sess: &ParseSess,\n                          resolver: &mut Resolver,\n                          reexport_test_harness_main: Option<Symbol>,\n                          krate: ast::Crate,\n-                         sd: &errors::Handler) -> ast::Crate {\n+                         sd: &errors::Handler,\n+                         features: &Features) -> ast::Crate {\n     // Remove the entry points\n     let mut cleaner = EntryPointCleaner { depth: 0 };\n     let krate = cleaner.fold_crate(krate);\n \n     let mark = Mark::fresh(Mark::root());\n \n+    let mut econfig = ExpansionConfig::default(\"test\".to_string());\n+    econfig.features = Some(features);\n+\n     let cx = TestCtxt {\n         span_diagnostic: sd,\n-        ext_cx: ExtCtxt::new(sess, ExpansionConfig::default(\"test\".to_string()), resolver),\n+        ext_cx: ExtCtxt::new(sess, econfig, resolver),\n         path: Vec::new(),\n         testfns: Vec::new(),\n         reexport_test_harness_main,\n         // NB: doesn't consider the value of `--crate-name` passed on the command line.\n         is_libtest: attr::find_crate_name(&krate.attrs).map(|s| s == \"test\").unwrap_or(false),\n         toplevel_reexport: None,\n         ctxt: SyntaxContext::empty().apply_mark(mark),\n+        features,\n     };\n \n     mark.set_expn_info(ExpnInfo {\n@@ -318,71 +327,105 @@ enum HasTestSignature {\n fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n     let has_test_attr = attr::contains_name(&i.attrs, \"test\");\n \n-    fn has_test_signature(i: &ast::Item) -> HasTestSignature {\n+    fn has_test_signature(cx: &TestCtxt, i: &ast::Item) -> HasTestSignature {\n         match i.node {\n-          ast::ItemKind::Fn(ref decl, _, _, _, ref generics, _) => {\n-            let no_output = match decl.output {\n-                ast::FunctionRetTy::Default(..) => true,\n-                ast::FunctionRetTy::Ty(ref t) if t.node == ast::TyKind::Tup(vec![]) => true,\n-                _ => false\n-            };\n-            if decl.inputs.is_empty()\n-                   && no_output\n-                   && !generics.is_parameterized() {\n-                Yes\n-            } else {\n-                No\n+            ast::ItemKind::Fn(ref decl, _, _, _, ref generics, _) => {\n+                // If the termination trait is active, the compiler will check that the output\n+                // type implements the `Termination` trait as `libtest` enforces that.\n+                let output_matches = if cx.features.termination_trait {\n+                    true\n+                } else {\n+                    let no_output = match decl.output {\n+                        ast::FunctionRetTy::Default(..) => true,\n+                        ast::FunctionRetTy::Ty(ref t) if t.node == ast::TyKind::Tup(vec![]) => true,\n+                        _ => false\n+                    };\n+\n+                    no_output && !generics.is_parameterized()\n+                };\n+\n+                if decl.inputs.is_empty() && output_matches {\n+                    Yes\n+                } else {\n+                    No\n+                }\n             }\n-          }\n-          _ => NotEvenAFunction,\n+            _ => NotEvenAFunction,\n         }\n     }\n \n-    if has_test_attr {\n+    let has_test_signature = if has_test_attr {\n         let diag = cx.span_diagnostic;\n-        match has_test_signature(i) {\n-            Yes => {},\n-            No => diag.span_err(i.span, \"functions used as tests must have signature fn() -> ()\"),\n-            NotEvenAFunction => diag.span_err(i.span,\n-                                              \"only functions may be used as tests\"),\n+        match has_test_signature(cx, i) {\n+            Yes => true,\n+            No => {\n+                if cx.features.termination_trait {\n+                    diag.span_err(i.span, \"functions used as tests can not have any arguments\");\n+                } else {\n+                    diag.span_err(i.span, \"functions used as tests must have signature fn() -> ()\");\n+                }\n+                false\n+            },\n+            NotEvenAFunction => {\n+                diag.span_err(i.span, \"only functions may be used as tests\");\n+                false\n+            },\n         }\n-    }\n+    } else {\n+        false\n+    };\n \n-    has_test_attr && has_test_signature(i) == Yes\n+    has_test_attr && has_test_signature\n }\n \n fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n     let has_bench_attr = attr::contains_name(&i.attrs, \"bench\");\n \n-    fn has_test_signature(i: &ast::Item) -> bool {\n+    fn has_bench_signature(cx: &TestCtxt, i: &ast::Item) -> bool {\n         match i.node {\n             ast::ItemKind::Fn(ref decl, _, _, _, ref generics, _) => {\n                 let input_cnt = decl.inputs.len();\n-                let no_output = match decl.output {\n-                    ast::FunctionRetTy::Default(..) => true,\n-                    ast::FunctionRetTy::Ty(ref t) if t.node == ast::TyKind::Tup(vec![]) => true,\n-                    _ => false\n+\n+                // If the termination trait is active, the compiler will check that the output\n+                // type implements the `Termination` trait as `libtest` enforces that.\n+                let output_matches = if cx.features.termination_trait {\n+                    true\n+                } else {\n+                    let no_output = match decl.output {\n+                        ast::FunctionRetTy::Default(..) => true,\n+                        ast::FunctionRetTy::Ty(ref t) if t.node == ast::TyKind::Tup(vec![]) => true,\n+                        _ => false\n+                    };\n+                    let tparm_cnt = generics.params.iter()\n+                        .filter(|param| param.is_type_param())\n+                        .count();\n+\n+                    no_output && tparm_cnt == 0\n                 };\n-                let tparm_cnt = generics.params.iter()\n-                    .filter(|param| param.is_type_param())\n-                    .count();\n \n                 // NB: inadequate check, but we're running\n                 // well before resolve, can't get too deep.\n-                input_cnt == 1\n-                    && no_output && tparm_cnt == 0\n+                input_cnt == 1 && output_matches\n             }\n           _ => false\n         }\n     }\n \n-    if has_bench_attr && !has_test_signature(i) {\n+    let has_bench_signature = has_bench_signature(cx, i);\n+\n+    if has_bench_attr && !has_bench_signature {\n         let diag = cx.span_diagnostic;\n-        diag.span_err(i.span, \"functions used as benches must have signature \\\n-                      `fn(&mut Bencher) -> ()`\");\n+\n+        if cx.features.termination_trait {\n+            diag.span_err(i.span, \"functions used as benches must have signature \\\n+                                   `fn(&mut Bencher) -> impl Termination`\");\n+        } else {\n+            diag.span_err(i.span, \"functions used as benches must have signature \\\n+                                   `fn(&mut Bencher) -> ()`\");\n+        }\n     }\n \n-    has_bench_attr && has_test_signature(i)\n+    has_bench_attr && has_bench_signature\n }\n \n fn is_ignored(i: &ast::Item) -> bool {\n@@ -700,9 +743,52 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n     };\n     visible_path.extend(path);\n \n-    let fn_expr = ecx.expr_path(ecx.path_global(span, visible_path));\n+    // If termination feature is enabled, create a wrapper that invokes the fn\n+    // like this:\n+    //\n+    //     fn wrapper() {\n+    //         assert_eq!(0, real_function().report());\n+    //     }\n+    //\n+    // and then put a reference to `wrapper` into the test descriptor. Otherwise,\n+    // just put a direct reference to `real_function`.\n+    let fn_expr = {\n+        let base_fn_expr = ecx.expr_path(ecx.path_global(span, visible_path));\n+        if cx.features.termination_trait {\n+            // ::std::Termination::assert_unit_test_successful\n+            let assert_unit_test_successful = ecx.path_global(\n+                span,\n+                vec![\n+                    ecx.ident_of(\"std\"),\n+                    ecx.ident_of(\"Termination\"),\n+                    ecx.ident_of(\"assert_unit_test_successful\"),\n+                ],\n+            );\n+            // || {..}\n+            ecx.lambda(\n+                span,\n+                vec![],\n+                // ::std::Termination::assert_unit_test_successful(..)\n+                ecx.expr_call(\n+                    span,\n+                    ecx.expr_path(assert_unit_test_successful),\n+                    vec![\n+                        // $base_fn_expr()\n+                        ecx.expr_call(\n+                            span,\n+                            base_fn_expr,\n+                            vec![],\n+                        )\n+                    ],\n+                ),\n+            )\n+        } else {\n+            base_fn_expr\n+        }\n+    };\n \n     let variant_name = if test.bench { \"StaticBenchFn\" } else { \"StaticTestFn\" };\n+\n     // self::test::$variant_name($fn_expr)\n     let testfn_expr = ecx.expr_call(span, ecx.expr_path(test_path(variant_name)), vec![fn_expr]);\n "}, {"sha": "e67e0de5c318b5512a7728f3b483cef3d9c9f4ce", "filename": "src/test/run-pass/termination-trait-in-test.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1eab1b19a39f54a825c9107086f0c1752b81224d/src%2Ftest%2Frun-pass%2Ftermination-trait-in-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eab1b19a39f54a825c9107086f0c1752b81224d/src%2Ftest%2Frun-pass%2Ftermination-trait-in-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftermination-trait-in-test.rs?ref=1eab1b19a39f54a825c9107086f0c1752b81224d", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --test\n+\n+#![feature(termination_trait)]\n+\n+use std::num::ParseIntError;\n+\n+#[test]\n+fn is_a_num() -> Result<(), ParseIntError> {\n+    let _: u32 = \"22\".parse()?;\n+    Ok(())\n+}\n+\n+#[test]\n+#[should_panic]\n+fn not_a_num() -> Result<(), ParseIntError> {\n+    let _: u32 = \"abc\".parse()?;\n+    Ok(())\n+}"}]}