{"sha": "900cda2043654f0bf0bb4dabfb696f643dd1a3a6", "node_id": "C_kwDOAAsO6NoAKDkwMGNkYTIwNDM2NTRmMGJmMGJiNGRhYmZiNjk2ZjY0M2RkMWEzYTY", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-08-30T18:21:56Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-08-31T09:22:14Z"}, "message": "Print only blanket implementations on reference primitive type", "tree": {"sha": "de48b58e3b8c65c77675ef6922d2f47ed89ac307", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de48b58e3b8c65c77675ef6922d2f47ed89ac307"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/900cda2043654f0bf0bb4dabfb696f643dd1a3a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/900cda2043654f0bf0bb4dabfb696f643dd1a3a6", "html_url": "https://github.com/rust-lang/rust/commit/900cda2043654f0bf0bb4dabfb696f643dd1a3a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/900cda2043654f0bf0bb4dabfb696f643dd1a3a6/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c585fcce52f96b3bd7c5ab69599c02387716d03", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c585fcce52f96b3bd7c5ab69599c02387716d03", "html_url": "https://github.com/rust-lang/rust/commit/6c585fcce52f96b3bd7c5ab69599c02387716d03"}], "stats": {"total": 200, "additions": 133, "deletions": 67}, "files": [{"sha": "cf43033d1d29a0b40e82304a3da4e5a86615f323", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 118, "deletions": 62, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/900cda2043654f0bf0bb4dabfb696f643dd1a3a6/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900cda2043654f0bf0bb4dabfb696f643dd1a3a6/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=900cda2043654f0bf0bb4dabfb696f643dd1a3a6", "patch": "@@ -616,7 +616,7 @@ fn short_item_info(\n pub(crate) fn render_impls(\n     cx: &mut Context<'_>,\n     w: &mut Buffer,\n-    impls: &[&&Impl],\n+    impls: &[&Impl],\n     containing_item: &clean::Item,\n     toggle_open_by_default: bool,\n ) {\n@@ -1039,9 +1039,9 @@ pub(crate) fn render_all_impls(\n     w: &mut Buffer,\n     cx: &mut Context<'_>,\n     containing_item: &clean::Item,\n-    concrete: &[&&Impl],\n-    synthetic: &[&&Impl],\n-    blanket_impl: &[&&Impl],\n+    concrete: &[&Impl],\n+    synthetic: &[&Impl],\n+    blanket_impl: &[&Impl],\n ) {\n     let mut impls = Buffer::empty_from(w);\n     render_impls(cx, &mut impls, concrete, containing_item, true);\n@@ -1158,9 +1158,9 @@ fn render_assoc_items_inner(\n             return;\n         }\n \n-        let (synthetic, concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n-            traits.iter().partition(|t| t.inner_impl().kind.is_auto());\n-        let (blanket_impl, concrete): (Vec<&&Impl>, _) =\n+        let (synthetic, concrete): (Vec<&Impl>, Vec<&Impl>) =\n+            traits.into_iter().partition(|t| t.inner_impl().kind.is_auto());\n+        let (blanket_impl, concrete): (Vec<&Impl>, _) =\n             concrete.into_iter().partition(|t| t.inner_impl().kind.is_blanket());\n \n         render_all_impls(w, cx, containing_item, &concrete, &synthetic, &blanket_impl);\n@@ -1968,6 +1968,70 @@ fn small_url_encode(s: String) -> String {\n     }\n }\n \n+pub(crate) fn sidebar_render_assoc_items(\n+    cx: &Context<'_>,\n+    out: &mut Buffer,\n+    id_map: &mut IdMap,\n+    concrete: Vec<&Impl>,\n+    synthetic: Vec<&Impl>,\n+    blanket_impl: Vec<&Impl>,\n+) {\n+    let format_impls = |impls: Vec<&Impl>, id_map: &mut IdMap| {\n+        let mut links = FxHashSet::default();\n+\n+        let mut ret = impls\n+            .iter()\n+            .filter_map(|it| {\n+                let trait_ = it.inner_impl().trait_.as_ref()?;\n+                let encoded =\n+                    id_map.derive(get_id_for_impl(&it.inner_impl().for_, Some(trait_), cx));\n+\n+                let i_display = format!(\"{:#}\", trait_.print(cx));\n+                let out = Escape(&i_display);\n+                let prefix = match it.inner_impl().polarity {\n+                    ty::ImplPolarity::Positive | ty::ImplPolarity::Reservation => \"\",\n+                    ty::ImplPolarity::Negative => \"!\",\n+                };\n+                let generated = format!(\"<a href=\\\"#{}\\\">{}{}</a>\", encoded, prefix, out);\n+                if links.insert(generated.clone()) { Some(generated) } else { None }\n+            })\n+            .collect::<Vec<String>>();\n+        ret.sort();\n+        ret\n+    };\n+\n+    let concrete_format = format_impls(concrete, id_map);\n+    let synthetic_format = format_impls(synthetic, id_map);\n+    let blanket_format = format_impls(blanket_impl, id_map);\n+\n+    if !concrete_format.is_empty() {\n+        print_sidebar_block(\n+            out,\n+            \"trait-implementations\",\n+            \"Trait Implementations\",\n+            concrete_format.iter(),\n+        );\n+    }\n+\n+    if !synthetic_format.is_empty() {\n+        print_sidebar_block(\n+            out,\n+            \"synthetic-implementations\",\n+            \"Auto Trait Implementations\",\n+            synthetic_format.iter(),\n+        );\n+    }\n+\n+    if !blanket_format.is_empty() {\n+        print_sidebar_block(\n+            out,\n+            \"blanket-implementations\",\n+            \"Blanket Implementations\",\n+            blanket_format.iter(),\n+        );\n+    }\n+}\n+\n fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n     let did = it.item_id.expect_def_id();\n     let cache = cx.cache();\n@@ -2016,65 +2080,12 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n                 sidebar_deref_methods(cx, out, impl_, v, &mut derefs, &mut used_links);\n             }\n \n-            let format_impls = |impls: Vec<&Impl>, id_map: &mut IdMap| {\n-                let mut links = FxHashSet::default();\n-\n-                let mut ret = impls\n-                    .iter()\n-                    .filter_map(|it| {\n-                        let trait_ = it.inner_impl().trait_.as_ref()?;\n-                        let encoded =\n-                            id_map.derive(get_id_for_impl(&it.inner_impl().for_, Some(trait_), cx));\n-\n-                        let i_display = format!(\"{:#}\", trait_.print(cx));\n-                        let out = Escape(&i_display);\n-                        let prefix = match it.inner_impl().polarity {\n-                            ty::ImplPolarity::Positive | ty::ImplPolarity::Reservation => \"\",\n-                            ty::ImplPolarity::Negative => \"!\",\n-                        };\n-                        let generated = format!(\"<a href=\\\"#{}\\\">{}{}</a>\", encoded, prefix, out);\n-                        if links.insert(generated.clone()) { Some(generated) } else { None }\n-                    })\n-                    .collect::<Vec<String>>();\n-                ret.sort();\n-                ret\n-            };\n-\n             let (synthetic, concrete): (Vec<&Impl>, Vec<&Impl>) =\n                 v.iter().partition::<Vec<_>, _>(|i| i.inner_impl().kind.is_auto());\n             let (blanket_impl, concrete): (Vec<&Impl>, Vec<&Impl>) =\n                 concrete.into_iter().partition::<Vec<_>, _>(|i| i.inner_impl().kind.is_blanket());\n \n-            let concrete_format = format_impls(concrete, &mut id_map);\n-            let synthetic_format = format_impls(synthetic, &mut id_map);\n-            let blanket_format = format_impls(blanket_impl, &mut id_map);\n-\n-            if !concrete_format.is_empty() {\n-                print_sidebar_block(\n-                    out,\n-                    \"trait-implementations\",\n-                    \"Trait Implementations\",\n-                    concrete_format.iter(),\n-                );\n-            }\n-\n-            if !synthetic_format.is_empty() {\n-                print_sidebar_block(\n-                    out,\n-                    \"synthetic-implementations\",\n-                    \"Auto Trait Implementations\",\n-                    synthetic_format.iter(),\n-                );\n-            }\n-\n-            if !blanket_format.is_empty() {\n-                print_sidebar_block(\n-                    out,\n-                    \"blanket-implementations\",\n-                    \"Blanket Implementations\",\n-                    blanket_format.iter(),\n-                );\n-            }\n+            sidebar_render_assoc_items(cx, out, &mut id_map, concrete, synthetic, blanket_impl);\n         }\n     }\n }\n@@ -2344,9 +2355,54 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n     buf.push_str(\"</section>\")\n }\n \n+/// Returns the list of implementations for the primitive reference type, filtering out any\n+/// implementations that are on concrete or partially generic types, only keeping implementations\n+/// of the form `impl<T> Trait for &T`.\n+pub(crate) fn get_filtered_impls_for_reference<'a>(\n+    shared: &'a Rc<SharedContext<'_>>,\n+    it: &clean::Item,\n+) -> (Vec<&'a Impl>, Vec<&'a Impl>, Vec<&'a Impl>) {\n+    let def_id = it.item_id.expect_def_id();\n+    // If the reference primitive is somehow not defined, exit early.\n+    let Some(v) = shared.cache.impls.get(&def_id) else { return (Vec::new(), Vec::new(), Vec::new()) };\n+    // Since there is no \"direct implementation\" on the reference primitive type, we filter out\n+    // every implementation which isn't a trait implementation.\n+    let traits: Vec<_> = v.iter().filter(|i| i.inner_impl().trait_.is_some()).collect();\n+    let (synthetic, concrete): (Vec<&Impl>, Vec<&Impl>) =\n+        traits.into_iter().partition(|t| t.inner_impl().kind.is_auto());\n+\n+    let (blanket_impl, concrete): (Vec<&Impl>, _) =\n+        concrete.into_iter().partition(|t| t.inner_impl().kind.is_blanket());\n+    // Now we keep only references over full generic types.\n+    let concrete: Vec<_> = concrete\n+        .into_iter()\n+        .filter(|t| match t.inner_impl().for_ {\n+            clean::Type::BorrowedRef { ref type_, .. } => type_.is_full_generic(),\n+            _ => false,\n+        })\n+        .collect();\n+\n+    (concrete, synthetic, blanket_impl)\n+}\n+\n fn sidebar_primitive(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item) {\n     let mut sidebar = Buffer::new();\n-    sidebar_assoc_items(cx, &mut sidebar, it);\n+\n+    if it.name.map(|n| n.as_str() != \"reference\").unwrap_or(false) {\n+        sidebar_assoc_items(cx, &mut sidebar, it);\n+    } else {\n+        let shared = Rc::clone(&cx.shared);\n+        let (concrete, synthetic, blanket_impl) = get_filtered_impls_for_reference(&shared, it);\n+\n+        sidebar_render_assoc_items(\n+            cx,\n+            &mut sidebar,\n+            &mut IdMap::new(),\n+            concrete,\n+            synthetic,\n+            blanket_impl,\n+        );\n+    }\n \n     if !sidebar.is_empty() {\n         write!(buf, \"<section>{}</section>\", sidebar.into_inner());"}, {"sha": "e3c9dbf502f825afeda600248badf6bf41f94884", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/900cda2043654f0bf0bb4dabfb696f643dd1a3a6/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/900cda2043654f0bf0bb4dabfb696f643dd1a3a6/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=900cda2043654f0bf0bb4dabfb696f643dd1a3a6", "patch": "@@ -16,10 +16,10 @@ use std::fmt;\n use std::rc::Rc;\n \n use super::{\n-    collect_paths_for_type, document, ensure_trailing_slash, item_ty_to_section,\n-    notable_traits_decl, render_assoc_item, render_assoc_items, render_attributes_in_code,\n-    render_attributes_in_pre, render_impl, render_rightside, render_stability_since_raw,\n-    AssocItemLink, Context, ImplRenderingParameters,\n+    collect_paths_for_type, document, ensure_trailing_slash, get_filtered_impls_for_reference,\n+    item_ty_to_section, notable_traits_decl, render_all_impls, render_assoc_item,\n+    render_assoc_items, render_attributes_in_code, render_attributes_in_pre, render_impl,\n+    render_rightside, render_stability_since_raw, AssocItemLink, Context, ImplRenderingParameters,\n };\n use crate::clean;\n use crate::config::ModuleSorting;\n@@ -1371,8 +1371,18 @@ fn item_proc_macro(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, m: &c\n }\n \n fn item_primitive(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {\n+    let def_id = it.item_id.expect_def_id();\n     document(w, cx, it, None, HeadingOffset::H2);\n-    render_assoc_items(w, cx, it, it.item_id.expect_def_id(), AssocItemRender::All)\n+    if it.name.map(|n| n.as_str() != \"reference\").unwrap_or(false) {\n+        render_assoc_items(w, cx, it, def_id, AssocItemRender::All);\n+    } else {\n+        // We handle the \"reference\" primitive type on its own because we only want to list\n+        // implementations on generic types.\n+        let shared = Rc::clone(&cx.shared);\n+        let (concrete, synthetic, blanket_impl) = get_filtered_impls_for_reference(&shared, it);\n+\n+        render_all_impls(w, cx, it, &concrete, &synthetic, &blanket_impl);\n+    }\n }\n \n fn item_constant(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, c: &clean::Constant) {"}]}