{"sha": "9cf271fe96b474d514b1052935db70c4056cf076", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljZjI3MWZlOTZiNDc0ZDUxNGIxMDUyOTM1ZGI3MGM0MDU2Y2YwNzY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-19T04:41:37Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-19T17:52:59Z"}, "message": "De-mode vec::each() and many of the str iteration routines\n\nNote that the method foo.each() is not de-moded, nor the other\nvec routines.", "tree": {"sha": "7a6fb31efeaa4de91317c16aca824153aaaf988c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a6fb31efeaa4de91317c16aca824153aaaf988c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9cf271fe96b474d514b1052935db70c4056cf076", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9cf271fe96b474d514b1052935db70c4056cf076", "html_url": "https://github.com/rust-lang/rust/commit/9cf271fe96b474d514b1052935db70c4056cf076", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9cf271fe96b474d514b1052935db70c4056cf076/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62b7f4d800325b46002c47d23b58a9f2b7fabb9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/62b7f4d800325b46002c47d23b58a9f2b7fabb9b", "html_url": "https://github.com/rust-lang/rust/commit/62b7f4d800325b46002c47d23b58a9f2b7fabb9b"}], "stats": {"total": 1304, "additions": 555, "deletions": 749}, "files": [{"sha": "92b38c4fe377955f991837de9059ed470b1cd5c6", "filename": "doc/tutorial.md", "status": "modified", "additions": 37, "deletions": 28, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -1235,14 +1235,14 @@ let crayons = ~[Almond, AntiqueBrass, Apricot];\n assert crayons.len() == 3;\n assert !crayons.is_empty();\n \n-// Iterate over a vector\n+// Iterate over a vector, obtaining a pointer to each element\n for crayons.each |crayon| {\n     let delicious_crayon_wax = unwrap_crayon(crayon);\n     eat_crayon_wax(delicious_crayon_wax);\n }\n \n // Map vector elements\n-let crayon_names = crayons.map(crayon_to_str);\n+let crayon_names = crayons.map(|v| crayon_to_str(v));\n let favorite_crayon_name = crayon_names[0];\n \n // Remove whitespace from before and after the string\n@@ -1384,40 +1384,44 @@ call_twice(bare_function);\n Closures in Rust are frequently used in combination with higher-order\n functions to simulate control structures like `if` and\n `loop`. Consider this function that iterates over a vector of\n-integers, applying an operator to each:\n+integers, passing in a pointer to each integer in the vector:\n \n ~~~~\n-fn each(v: ~[int], op: fn(int)) {\n+fn each(v: ~[int], op: fn(v: &int)) {\n    let mut n = 0;\n    while n < v.len() {\n-       op(v[n]);\n+       op(&v[n]);\n        n += 1;\n    }\n }\n ~~~~\n \n-As a caller, if we use a closure to provide the final operator\n-argument, we can write it in a way that has a pleasant, block-like\n-structure.\n+The reason we pass in a *pointer* to an integer rather than the\n+integer itself is that this is how the actual `each()` function for\n+vectors works.  Using a pointer means that the function can be used\n+for vectors of any type, even large records that would be impractical\n+to copy out of the vector on each iteration.  As a caller, if we use a\n+closure to provide the final operator argument, we can write it in a\n+way that has a pleasant, block-like structure.\n \n ~~~~\n-# fn each(v: ~[int], op: fn(int)) {}\n+# fn each(v: ~[int], op: fn(v: &int)) { }\n # fn do_some_work(i: int) { }\n each(~[1, 2, 3], |n| {\n-    debug!(\"%i\", n);\n-    do_some_work(n);\n+    debug!(\"%i\", *n);\n+    do_some_work(*n);\n });\n ~~~~\n \n This is such a useful pattern that Rust has a special form of function\n call that can be written more like a built-in control structure:\n \n ~~~~\n-# fn each(v: ~[int], op: fn(int)) {}\n+# fn each(v: ~[int], op: fn(v: &int)) { }\n # fn do_some_work(i: int) { }\n do each(~[1, 2, 3]) |n| {\n-    debug!(\"%i\", n);\n-    do_some_work(n);\n+    debug!(\"%i\", *n);\n+    do_some_work(*n);\n }\n ~~~~\n \n@@ -1461,10 +1465,10 @@ Consider again our `each` function, this time improved to\n break early when the iteratee returns `false`:\n \n ~~~~\n-fn each(v: ~[int], op: fn(int) -> bool) {\n+fn each(v: ~[int], op: fn(v: &int) -> bool) {\n    let mut n = 0;\n    while n < v.len() {\n-       if !op(v[n]) {\n+       if !op(&v[n]) {\n            break;\n        }\n        n += 1;\n@@ -1478,7 +1482,7 @@ And using this function to iterate over a vector:\n # use each = vec::each;\n # use println = io::println;\n each(~[2, 4, 8, 5, 16], |n| {\n-    if n % 2 != 0 {\n+    if *n % 2 != 0 {\n         println(~\"found odd number!\");\n         false\n     } else { true }\n@@ -1495,7 +1499,7 @@ to the next iteration, write `again`.\n # use each = vec::each;\n # use println = io::println;\n for each(~[2, 4, 8, 5, 16]) |n| {\n-    if n % 2 != 0 {\n+    if *n % 2 != 0 {\n         println(~\"found odd number!\");\n         break;\n     }\n@@ -1511,7 +1515,7 @@ function, not just the loop body.\n # use each = vec::each;\n fn contains(v: ~[int], elt: int) -> bool {\n     for each(v) |x| {\n-        if (x == elt) { return true; }\n+        if (*x == elt) { return true; }\n     }\n     false\n }\n@@ -1529,9 +1533,9 @@ every type they apply to. Thus, Rust allows functions and datatypes to have\n type parameters.\n \n ~~~~\n-fn map<T, U>(vector: &[T], function: fn(T) -> U) -> ~[U] {\n+fn map<T, U>(vector: &[T], function: fn(v: &T) -> U) -> ~[U] {\n     let mut accumulator = ~[];\n-    for vector.each |element| {\n+    for vec::each(vector) |element| {\n         vec::push(accumulator, function(element));\n     }\n     return accumulator;\n@@ -1544,7 +1548,12 @@ type of the vector's content agree with each other.\n \n Inside a generic function, the names of the type parameters\n (capitalized by convention) stand for opaque types. You can't look\n-inside them, but you can pass them around.\n+inside them, but you can pass them around.  Note that instances of\n+generic types are almost always passed by pointer.  For example, the\n+parameter `function()` is supplied with a pointer to a value of type\n+`T` and not a value of type `T` itself.  This ensures that the\n+function works with the broadest set of types possible, since some\n+types are expensive or illegal to copy and pass by value.\n \n ## Generic datatypes\n \n@@ -1686,12 +1695,12 @@ generalized sequence types is:\n ~~~~\n trait Seq<T> {\n     fn len() -> uint;\n-    fn iter(fn(T));\n+    fn iter(b: fn(v: &T));\n }\n impl<T> ~[T]: Seq<T> {\n     fn len() -> uint { vec::len(self) }\n-    fn iter(b: fn(T)) {\n-        for self.each |elt| { b(elt); }\n+    fn iter(b: fn(v: &T)) {\n+        for vec::each(self) |elt| { b(elt); }\n     }\n }\n ~~~~\n@@ -2186,7 +2195,7 @@ Here is the function that implements the child task:\n ~~~~\n # use std::comm::DuplexStream;\n # use pipes::{Port, Chan};\n-fn stringifier(channel: DuplexStream<~str, uint>) {\n+fn stringifier(channel: &DuplexStream<~str, uint>) {\n     let mut value: uint;\n     loop {\n         value = channel.recv();\n@@ -2210,7 +2219,7 @@ Here is the code for the parent task:\n # use std::comm::DuplexStream;\n # use pipes::{Port, Chan};\n # use task::spawn;\n-# fn stringifier(channel: DuplexStream<~str, uint>) {\n+# fn stringifier(channel: &DuplexStream<~str, uint>) {\n #     let mut value: uint;\n #     loop {\n #         value = channel.recv();\n@@ -2223,7 +2232,7 @@ Here is the code for the parent task:\n let (from_child, to_child) = DuplexStream();\n \n do spawn || {\n-    stringifier(to_child);\n+    stringifier(&to_child);\n };\n \n from_child.send(22u);"}, {"sha": "94d89adb191f0cd7d91d43ed12eb6ed5e12f2c37", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -1502,7 +1502,7 @@ fn print_source(s: source) {\n     print(io::with_str_writer(|writer| {\n         let mut list = ~\"   >> \";\n \n-        do vec::iteri(pks) |i, pk| {\n+        for vec::eachi(pks) |i, pk| {\n             if str::len(list) > 78u {\n                 writer.write_line(list);\n                 list = ~\"   >> \";\n@@ -1518,16 +1518,17 @@ fn cmd_list(c: &cargo) {\n     sync(c);\n \n     if vec::len(c.opts.free) >= 3u {\n-        do vec::iter_between(c.opts.free, 2u, vec::len(c.opts.free)) |name| {\n-            if !valid_pkg_name(name) {\n-                error(fmt!(\"'%s' is an invalid source name\", name));\n+        let v = vec::view(c.opts.free, 2u, vec::len(c.opts.free));\n+        for vec::each(v) |name| {\n+            if !valid_pkg_name(*name) {\n+                error(fmt!(\"'%s' is an invalid source name\", *name));\n             } else {\n-                match c.sources.find(name) {\n+                match c.sources.find(*name) {\n                     Some(source) => {\n                         print_source(source);\n                     }\n                     None => {\n-                        error(fmt!(\"no such source: %s\", name));\n+                        error(fmt!(\"no such source: %s\", *name));\n                     }\n                 }\n             }"}, {"sha": "cae9801b6741e4ff070d5cba61ae753f994fcdbd", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -425,8 +425,8 @@ fn compose_and_run_compiler(\n     let extra_link_args = ~[~\"-L\",\n                             aux_output_dir_name(config, testfile).to_str()];\n \n-    do vec::iter(props.aux_builds) |rel_ab| {\n-        let abs_ab = config.aux_base.push_rel(&Path(rel_ab));\n+    for vec::each(props.aux_builds) |rel_ab| {\n+        let abs_ab = config.aux_base.push_rel(&Path(*rel_ab));\n         let aux_args =\n             make_compile_args(config, props, ~[~\"--lib\"] + extra_link_args,\n                               |a,b| make_lib_name(a, b, testfile), &abs_ab);"}, {"sha": "79ee44ac49c33d36b830b5985f8602e8adfbb427", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -91,7 +91,7 @@ pure fn build_sized_opt<A>(size: Option<uint>,\n #[inline(always)]\n pure fn append<T: Copy>(lhs: @[T], rhs: &[const T]) -> @[T] {\n     do build_sized(lhs.len() + rhs.len()) |push| {\n-        for vec::each(lhs) |x| { push(x); }\n+        for vec::each(lhs) |x| { push(*x); }\n         for uint::range(0, rhs.len()) |i| { push(rhs[i]); }\n     }\n }\n@@ -101,7 +101,7 @@ pure fn append<T: Copy>(lhs: @[T], rhs: &[const T]) -> @[T] {\n pure fn map<T, U>(v: &[T], f: fn(T) -> U) -> @[U] {\n     do build_sized(v.len()) |push| {\n         for vec::each(v) |elem| {\n-            push(f(elem));\n+            push(f(*elem));\n         }\n     }\n }"}, {"sha": "1f811b0fc050c0a92d19e34dbaafa535fe9ce68e", "filename": "src/libcore/cast.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -4,7 +4,7 @@ export reinterpret_cast, forget, bump_box_refcount, transmute;\n export transmute_mut, transmute_immut, transmute_region, transmute_mut_region;\n export transmute_mut_unsafe, transmute_immut_unsafe;\n \n-export copy_lifetime;\n+export copy_lifetime, copy_lifetime_vec;\n \n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n@@ -85,8 +85,9 @@ unsafe fn copy_lifetime<S,T>(_ptr: &a/S, ptr: &T) -> &a/T {\n }\n \n /// Transforms lifetime of the second pointer to match the first.\n-unsafe fn copy_lifetime_to_unsafe<S,T>(_ptr: &a/S, +ptr: *T) -> &a/T {\n-    transmute(ptr)\n+#[inline(always)]\n+unsafe fn copy_lifetime_vec<S,T>(_ptr: &a/[S], ptr: &T) -> &a/T {\n+    transmute_region(ptr)\n }\n \n "}, {"sha": "9f58f46f1a021e1d0a20690707aaaffeb5229657", "filename": "src/libcore/either.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -34,7 +34,7 @@ fn lefts<T: Copy, U>(eithers: &[Either<T, U>]) -> ~[T] {\n \n     let mut result: ~[T] = ~[];\n     for vec::each(eithers) |elt| {\n-        match elt {\n+        match *elt {\n           Left(l) => vec::push(result, l),\n           _ => { /* fallthrough */ }\n         }\n@@ -47,7 +47,7 @@ fn rights<T, U: Copy>(eithers: &[Either<T, U>]) -> ~[U] {\n \n     let mut result: ~[U] = ~[];\n     for vec::each(eithers) |elt| {\n-        match elt {\n+        match *elt {\n           Right(r) => vec::push(result, r),\n           _ => { /* fallthrough */ }\n         }\n@@ -67,7 +67,7 @@ fn partition<T: Copy, U: Copy>(eithers: &[Either<T, U>])\n     let mut lefts: ~[T] = ~[];\n     let mut rights: ~[U] = ~[];\n     for vec::each(eithers) |elt| {\n-        match elt {\n+        match *elt {\n           Left(l) => vec::push(lefts, l),\n           Right(r) => vec::push(rights, r)\n         }"}, {"sha": "7446332e2612bf720ac7d1ae5d484f9ef8d5f5ac", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -390,7 +390,9 @@ impl &SipState : Streaming {\n     fn result_str() -> ~str {\n         let r = self.result_bytes();\n         let mut s = ~\"\";\n-        for vec::each(r) |b| { s += uint::to_str(b as uint, 16u); }\n+        for vec::each(r) |b| {\n+            s += uint::to_str(*b as uint, 16u);\n+        }\n         move s\n     }\n \n@@ -483,7 +485,9 @@ fn test_siphash() {\n \n     fn to_hex_str(r:  &[u8]/8) -> ~str {\n         let mut s = ~\"\";\n-        for vec::each(*r) |b| { s += uint::to_str(b as uint, 16u); }\n+        for vec::each(*r) |b| {\n+            s += uint::to_str(*b as uint, 16u);\n+        }\n         return s;\n     }\n "}, {"sha": "2de7da0480e499c557116f097c25e9d2a65d6ff5", "filename": "src/libcore/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -451,7 +451,7 @@ fn mk_file_writer(path: &Path, flags: ~[FileFlag])\n \n     let mut fflags: c_int = wb();\n     for vec::each(flags) |f| {\n-        match f {\n+        match *f {\n           Append => fflags |= O_APPEND as c_int,\n           Create => fflags |= O_CREAT as c_int,\n           Truncate => fflags |= O_TRUNC as c_int,"}, {"sha": "7284d02d3ac637aa7ddf4a8833045ccf1841cde9", "filename": "src/libcore/iter-trait/dvec.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdvec.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -7,7 +7,12 @@ type IMPL_T<A> = dvec::DVec<A>;\n  * Attempts to access this dvec during iteration will fail.\n  */\n pure fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n-    unsafe { self.swap(|v| { vec::each(v, f); move v }) }\n+    unsafe {\n+        do self.swap |v| {\n+            v.each(f);\n+            move v\n+        }\n+    }\n }\n \n pure fn SIZE_HINT<A>(self: IMPL_T<A>) -> Option<uint> {"}, {"sha": "bce118e09af5f61c8a2db301c0a96a3469f5f0db", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 0, "deletions": 143, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -300,146 +300,3 @@ pure fn copy_seq<T: Copy,IT: BaseIter<T>,BT: Buildable<T>>(\n         for v.each |x| { push(x); }\n     }\n }\n-\n-\n-\n-/*\n-#[test]\n-fn test_enumerate() {\n-    enumerate([\"0\", \"1\", \"2\"]) {|i,j|\n-        assert fmt!(\"%u\",i) == j;\n-    }\n-}\n-\n-#[test]\n-fn test_map_and_to_vec() {\n-    let a = bind vec::iter(~[0, 1, 2], _);\n-    let b = bind map(a, {|i| 2*i}, _);\n-    let c = to_vec(b);\n-    assert c == ~[0, 2, 4];\n-}\n-\n-#[test]\n-fn test_map_directly_on_vec() {\n-    let b = bind map(~[0, 1, 2], {|i| 2*i}, _);\n-    let c = to_vec(b);\n-    assert c == ~[0, 2, 4];\n-}\n-\n-#[test]\n-fn test_filter_on_int_range() {\n-    fn is_even(&&i: int) -> bool {\n-        return (i % 2) == 0;\n-    }\n-\n-    let l = to_vec(bind filter(bind int::range(0, 10, _), is_even, _));\n-    assert l == ~[0, 2, 4, 6, 8];\n-}\n-\n-#[test]\n-fn test_filter_on_uint_range() {\n-    fn is_even(&&i: uint) -> bool {\n-        return (i % 2u) == 0u;\n-    }\n-\n-    let l = to_vec(bind filter(bind uint::range(0u, 10u, _), is_even, _));\n-    assert l == ~[0u, 2u, 4u, 6u, 8u];\n-}\n-\n-#[test]\n-fn test_filter_map() {\n-    fn negativate_the_evens(&&i: int) -> Option<int> {\n-        if i % 2 == 0 {\n-            Some(-i)\n-        } else {\n-            none\n-        }\n-    }\n-\n-    let l = to_vec(bind filter_map(\n-        bind int::range(0, 5, _), negativate_the_evens, _));\n-    assert l == ~[0, -2, -4];\n-}\n-\n-#[test]\n-fn test_flat_map_with_option() {\n-    fn if_even(&&i: int) -> Option<int> {\n-        if (i % 2) == 0 { Some(i) }\n-        else { none }\n-    }\n-\n-    let a = bind vec::iter(~[0, 1, 2], _);\n-    let b = bind flat_map(a, if_even, _);\n-    let c = to_vec(b);\n-    assert c == ~[0, 2];\n-}\n-\n-#[test]\n-fn test_flat_map_with_list() {\n-    fn repeat(&&i: int) -> ~[int] {\n-        let mut r = ~[];\n-        int::range(0, i) {|_j| r += ~[i]; }\n-        r\n-    }\n-\n-    let a = bind vec::iter(~[0, 1, 2, 3], _);\n-    let b = bind flat_map(a, repeat, _);\n-    let c = to_vec(b);\n-    debug!(\"c = %?\", c);\n-    assert c == ~[1, 2, 2, 3, 3, 3];\n-}\n-\n-#[test]\n-fn test_repeat() {\n-    let mut c = ~[], i = 0u;\n-    repeat(5u) {||\n-        c += ~[(i * i)];\n-        i += 1u;\n-    };\n-    debug!(\"c = %?\", c);\n-    assert c == ~[0u, 1u, 4u, 9u, 16u];\n-}\n-\n-#[test]\n-fn test_min() {\n-    assert min(~[5, 4, 1, 2, 3]) == 1;\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(windows))]\n-fn test_min_empty() {\n-    min::<int, ~[int]>(~[]);\n-}\n-\n-#[test]\n-fn test_max() {\n-    assert max(~[1, 2, 4, 2, 3]) == 4;\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(windows))]\n-fn test_max_empty() {\n-    max::<int, ~[int]>(~[]);\n-}\n-\n-#[test]\n-fn test_reversed() {\n-    assert to_vec(bind reversed(~[1, 2, 3], _)) == ~[3, 2, 1];\n-}\n-\n-#[test]\n-fn test_count() {\n-    assert count(~[1, 2, 1, 2, 1], 1) == 3u;\n-}\n-\n-#[test]\n-fn test_foldr() {\n-    fn sub(&&a: int, &&b: int) -> int {\n-        a - b\n-    }\n-    let sum = foldr(~[1, 2, 3, 4], 0, sub);\n-    assert sum == -2;\n-}\n-*/"}, {"sha": "6c6186459ac78a5e43a59cf42755cee175b7ca91", "filename": "src/libcore/os.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -211,7 +211,7 @@ mod global_env {\n         fn env() -> ~[(~str,~str)] {\n             let mut pairs = ~[];\n             for vec::each(rustrt::rust_env_pairs()) |p| {\n-                let vs = str::splitn_char(p, '=', 1u);\n+                let vs = str::splitn_char(*p, '=', 1u);\n                 assert vec::len(vs) == 2u;\n                 vec::push(pairs, (copy vs[0], copy vs[1]));\n             }\n@@ -893,7 +893,7 @@ mod tests {\n         let e = env();\n         assert vec::len(e) > 0u;\n         for vec::each(e) |p| {\n-            let (n, v) = copy p;\n+            let (n, v) = copy *p;\n             log(debug, n);\n             let v2 = getenv(n);\n             // MingW seems to set some funky environment variables like\n@@ -985,7 +985,9 @@ mod tests {\n         // Just assuming that we've got some contents in the current directory\n         assert (vec::len(dirs) > 0u);\n \n-        for vec::each(dirs) |dir| { log(debug, dir); }\n+        for vec::each(dirs) |dir| {\n+            log(debug, *dir);\n+        }\n     }\n \n     #[test]"}, {"sha": "435f1a5d18dad4d0da5b5ff45ac785cc7ee86436", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -158,7 +158,7 @@ impl ReprVisitor {\n \n     fn write_escaped_slice(slice: &str) {\n         self.writer.write_char('\"');\n-        do str::chars_iter(slice) |ch| {\n+        for str::chars_each(slice) |ch| {\n             self.writer.write_escaped_char(ch);\n         }\n         self.writer.write_char('\"');\n@@ -563,7 +563,7 @@ impl ReprPrinterWrapper {\n             let vec_repr = *vec_repr_ptr;\n             let data_ptr = ptr::to_unsafe_ptr(&(*vec_repr).unboxed.data);\n             let slice: &str = transmute((data_ptr, (*vec_repr).unboxed.fill));\n-            do str::chars_iter(slice) |ch| {\n+            for str::chars_each(slice) |ch| {\n                 self.printer.writer.write_escaped_char(ch);\n             }\n             self.printer.writer.write_char('\"');\n@@ -686,7 +686,7 @@ impl ReprPrinterWrapper : TyVisitor {\n             self.printer.writer.write_char('\"');\n             let slice_ptr: *&str = transmute(copy self.printer.ptr);\n             let slice = *slice_ptr;\n-            do str::chars_iter(slice) |ch| {\n+            for str::chars_each(slice) |ch| {\n                 self.printer.writer.write_escaped_char(ch);\n             }\n             self.printer.writer.write_char('\"');"}, {"sha": "ea1a91d7a84f8b1b1f6a18babc83b3f60adaad85", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -267,7 +267,7 @@ impl<T: Copy, E: Copy> Result<T, E> {\n  *     }\n  */\n fn map_vec<T,U:Copy,V:Copy>(\n-    ts: &[T], op: fn(T) -> Result<V,U>) -> Result<~[V],U> {\n+    ts: &[T], op: fn((&T)) -> Result<V,U>) -> Result<~[V],U> {\n \n     let mut vs: ~[V] = ~[];\n     vec::reserve(vs, vec::len(ts));"}, {"sha": "2eda9d536596bc9de4d086c088b99f6df2b19c20", "filename": "src/libcore/run.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -87,7 +87,7 @@ fn with_argv<T>(prog: &str, args: &[~str],\n     let mut argptrs = str::as_c_str(prog, |b| ~[b]);\n     let mut tmps = ~[];\n     for vec::each(args) |arg| {\n-        let t = @copy arg;\n+        let t = @copy *arg;\n         vec::push(tmps, t);\n         vec::push_all(argptrs, str::as_c_str(*t, |b| ~[b]));\n     }\n@@ -106,7 +106,7 @@ fn with_envp<T>(env: &Option<~[(~str,~str)]>,\n         let mut ptrs = ~[];\n \n         for vec::each(es) |e| {\n-            let (k,v) = copy e;\n+            let (k,v) = copy *e;\n             let t = @(fmt!(\"%s=%s\", k, v));\n             vec::push(tmps, t);\n             vec::push_all(ptrs, str::as_c_str(*t, |b| ~[b]));\n@@ -131,7 +131,7 @@ fn with_envp<T>(env: &Option<~[(~str,~str)]>,\n           Some(es) if !vec::is_empty(es) => {\n             let mut blk : ~[u8] = ~[];\n             for vec::each(es) |e| {\n-                let (k,v) = e;\n+                let (k,v) = *e;\n                 let t = fmt!(\"%s=%s\", k, v);\n                 let mut v : ~[u8] = ::cast::reinterpret_cast(&t);\n                 blk += v;"}, {"sha": "5dfc1f643675b208bd8b15248f93dde20d457fdc", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -17,7 +17,7 @@ trait SendMap<K:Eq Hash, V: Copy> {\n     pure fn len(&const self) -> uint;\n     pure fn is_empty(&const self) -> bool;\n     pure fn contains_key(&const self, k: &K) -> bool;\n-    pure fn each_ref(&self, blk: fn(k: &K, v: &V) -> bool);\n+    pure fn each(&self, blk: fn(k: &K, v: &V) -> bool);\n     pure fn each_key_ref(&self, blk: fn(k: &K) -> bool);\n     pure fn each_value_ref(&self, blk: fn(v: &V) -> bool);\n     pure fn find(&const self, k: &K) -> Option<V>;\n@@ -311,7 +311,7 @@ mod linear {\n             }\n         }\n \n-        pure fn each_ref(&self, blk: fn(k: &K, v: &V) -> bool) {\n+        pure fn each(&self, blk: fn(k: &K, v: &V) -> bool) {\n             for vec::each(self.buckets) |slot| {\n                 let mut broke = false;\n                 do slot.iter |bucket| {\n@@ -323,12 +323,12 @@ mod linear {\n             }\n         }\n \n-        pure fn each_key_ref(&self, blk: fn(k: &K) -> bool) {\n-            self.each_ref(|k, _v| blk(k))\n+        pure fn each_key(&self, blk: fn(k: &K) -> bool) {\n+            self.each(|k, _v| blk(k))\n         }\n \n-        pure fn each_value_ref(&self, blk: fn(v: &V) -> bool) {\n-            self.each_ref(|_k, v| blk(v))\n+        pure fn each_value(&self, blk: fn(v: &V) -> bool) {\n+            self.each(|_k, v| blk(v))\n         }\n     }\n \n@@ -358,22 +358,6 @@ mod linear {\n         }\n \n     }\n-\n-    impl<K: Hash IterBytes Eq Copy, V: Copy> LinearMap<K,V> {\n-        pure fn each(&self, blk: fn(+K,+V) -> bool) {\n-            self.each_ref(|k,v| blk(copy *k, copy *v));\n-        }\n-    }\n-    impl<K: Hash IterBytes Eq Copy, V> LinearMap<K,V> {\n-        pure fn each_key(&self, blk: fn(+K) -> bool) {\n-            self.each_key_ref(|k| blk(copy *k));\n-        }\n-    }\n-    impl<K: Hash IterBytes Eq, V: Copy> LinearMap<K,V> {\n-        pure fn each_value(&self, blk: fn(+V) -> bool) {\n-            self.each_value_ref(|v| blk(copy *v));\n-        }\n-    }\n }\n \n #[test]\n@@ -438,8 +422,8 @@ mod test {\n         }\n         let mut observed = 0;\n         for m.each |k, v| {\n-            assert v == k*2;\n-            observed |= (1 << k);\n+            assert *v == *k * 2;\n+            observed |= (1 << *k);\n         }\n         assert observed == 0xFFFF_FFFF;\n     }"}, {"sha": "f6baeb91be9301a1da07167c55e7f3fab71da860", "filename": "src/libcore/str.rs", "status": "modified", "additions": 70, "deletions": 60, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -72,12 +72,12 @@ export\n    map,\n    each, eachi,\n    each_char, each_chari,\n-   bytes_iter,\n-   chars_iter,\n-   split_char_iter,\n-   splitn_char_iter,\n-   words_iter,\n-   lines_iter,\n+   bytes_each,\n+   chars_each,\n+   split_char_each,\n+   splitn_char_each,\n+   words_each,\n+   lines_each,\n \n    // Searching\n    find, find_from, find_between,\n@@ -235,7 +235,9 @@ pure fn from_chars(chs: &[char]) -> ~str {\n     let mut buf = ~\"\";\n     unsafe {\n         reserve(buf, chs.len());\n-        for vec::each(chs) |ch| { push_char(buf, ch); }\n+        for vec::each(chs) |ch| {\n+            push_char(buf, *ch);\n+        }\n     }\n     move buf\n }\n@@ -289,7 +291,9 @@ pure fn append(+lhs: ~str, rhs: &str) -> ~str {\n /// Concatenate a vector of strings\n pure fn concat(v: &[~str]) -> ~str {\n     let mut s: ~str = ~\"\";\n-    for vec::each(v) |ss| { unsafe { push_str(s, ss) }; }\n+    for vec::each(v) |ss| {\n+        unsafe { push_str(s, *ss) };\n+    }\n     move s\n }\n \n@@ -298,7 +302,7 @@ pure fn connect(v: &[~str], sep: &str) -> ~str {\n     let mut s = ~\"\", first = true;\n     for vec::each(v) |ss| {\n         if first { first = false; } else { unsafe { push_str(s, sep); } }\n-        unsafe { push_str(s, ss) };\n+        unsafe { push_str(s, *ss) };\n     }\n     move s\n }\n@@ -879,20 +883,20 @@ pure fn map(ss: &str, ff: fn(char) -> char) -> ~str {\n     let mut result = ~\"\";\n     unsafe {\n         reserve(result, len(ss));\n-        do chars_iter(ss) |cc| {\n+        for chars_each(ss) |cc| {\n             str::push_char(result, ff(cc));\n         }\n     }\n     move result\n }\n \n /// Iterate over the bytes in a string\n-pure fn bytes_iter(ss: &str, it: fn(u8)) {\n+pure fn bytes_each(ss: &str, it: fn(u8) -> bool) {\n     let mut pos = 0u;\n     let len = len(ss);\n \n     while (pos < len) {\n-        it(ss[pos]);\n+        if !it(ss[pos]) { return; }\n         pos += 1u;\n     }\n }\n@@ -933,40 +937,40 @@ pure fn each_chari(s: &str, it: fn(uint, char) -> bool) {\n }\n \n /// Iterate over the characters in a string\n-pure fn chars_iter(s: &str, it: fn(char)) {\n+pure fn chars_each(s: &str, it: fn(char) -> bool) {\n     let mut pos = 0u;\n     let len = len(s);\n     while (pos < len) {\n         let {ch, next} = char_range_at(s, pos);\n         pos = next;\n-        it(ch);\n+        if !it(ch) { return; }\n     }\n }\n \n /// Apply a function to each substring after splitting by character\n-pure fn split_char_iter(ss: &str, cc: char, ff: fn(&&~str)) {\n-   vec::iter(split_char(ss, cc), ff)\n+pure fn split_char_each(ss: &str, cc: char, ff: fn(v: &str) -> bool) {\n+    vec::each(split_char(ss, cc), |s| ff(*s))\n }\n \n /**\n  * Apply a function to each substring after splitting by character, up to\n  * `count` times\n  */\n-pure fn splitn_char_iter(ss: &str, sep: char, count: uint,\n-                         ff: fn(&&~str)) {\n-   vec::iter(splitn_char(ss, sep, count), ff)\n+pure fn splitn_char_each(ss: &str, sep: char, count: uint,\n+                         ff: fn(v: &str) -> bool) {\n+    vec::each(splitn_char(ss, sep, count), |s| ff(*s))\n }\n \n /// Apply a function to each word\n-pure fn words_iter(ss: &str, ff: fn(&&~str)) {\n-    vec::iter(words(ss), ff)\n+pure fn words_each(ss: &str, ff: fn(v: &str) -> bool) {\n+    vec::each(words(ss), |s| ff(*s))\n }\n \n /**\n  * Apply a function to each line (by '\\n')\n  */\n-pure fn lines_iter(ss: &str, ff: fn(&&~str)) {\n-    vec::iter(lines(ss), ff)\n+pure fn lines_each(ss: &str, ff: fn(v: &str) -> bool) {\n+    vec::each(lines(ss), |s| ff(*s))\n }\n \n /*\n@@ -1518,7 +1522,7 @@ pure fn is_utf16(v: &[u16]) -> bool {\n /// Converts to a vector of `u16` encoded as UTF-16\n pure fn to_utf16(s: &str) -> ~[u16] {\n     let mut u = ~[];\n-    do chars_iter(s) |cch| {\n+    for chars_each(s) |cch| {\n         // Arithmetic with u32 literals is easier on the eyes than chars.\n         let mut ch = cch as u32;\n \n@@ -1947,7 +1951,9 @@ pure fn escape_default(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n     unsafe {\n         reserve_at_least(out, str::len(s));\n-        chars_iter(s, |c| push_str(out, char::escape_default(c)));\n+        for chars_each(s) |c| {\n+            push_str(out, char::escape_default(c));\n+        }\n     }\n     move out\n }\n@@ -1957,7 +1963,9 @@ pure fn escape_unicode(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n     unsafe {\n         reserve_at_least(out, str::len(s));\n-        chars_iter(s, |c| push_str(out, char::escape_unicode(c)));\n+        for chars_each(s) |c| {\n+            push_str(out, char::escape_unicode(c));\n+        }\n     }\n     move out\n }\n@@ -2094,7 +2102,7 @@ mod raw {\n     /// Appends a vector of bytes to a string. (Not UTF-8 safe).\n     unsafe fn push_bytes(&s: ~str, bytes: ~[u8]) {\n         reserve_at_least(s, s.len() + bytes.len());\n-        for vec::each(bytes) |byte| { push_byte(s, byte); }\n+        for vec::each(bytes) |byte| { push_byte(s, *byte); }\n     }\n \n     /// Removes the last byte from a string and returns it. (Not UTF-8 safe).\n@@ -3044,105 +3052,107 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_chars_iter() {\n+    fn test_chars_each() {\n         let mut i = 0;\n-        do chars_iter(~\"x\\u03c0y\") |ch| {\n+        for chars_each(~\"x\\u03c0y\") |ch| {\n             match i {\n               0 => assert ch == 'x',\n               1 => assert ch == '\\u03c0',\n               2 => assert ch == 'y',\n-              _ => fail ~\"test_chars_iter failed\"\n+              _ => fail ~\"test_chars_each failed\"\n             }\n             i += 1;\n         }\n \n-        chars_iter(~\"\", |_ch| fail ); // should not fail\n+        chars_each(~\"\", |_ch| fail ); // should not fail\n     }\n \n     #[test]\n-    fn test_bytes_iter() {\n+    fn test_bytes_each() {\n         let mut i = 0;\n \n-        do bytes_iter(~\"xyz\") |bb| {\n+        for bytes_each(~\"xyz\") |bb| {\n             match i {\n               0 => assert bb == 'x' as u8,\n               1 => assert bb == 'y' as u8,\n               2 => assert bb == 'z' as u8,\n-              _ => fail ~\"test_bytes_iter failed\"\n+              _ => fail ~\"test_bytes_each failed\"\n             }\n             i += 1;\n         }\n \n-        bytes_iter(~\"\", |bb| assert bb == 0u8);\n+        for bytes_each(~\"\") |bb| {\n+            assert bb == 0u8;\n+        }\n     }\n \n     #[test]\n-    fn test_split_char_iter() {\n+    fn test_split_char_each() {\n         let data = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n \n         let mut ii = 0;\n \n-        do split_char_iter(data, ' ') |xx| {\n+        for split_char_each(data, ' ') |xx| {\n             match ii {\n-              0 => assert ~\"\\nMary\" == xx,\n-              1 => assert ~\"had\"    == xx,\n-              2 => assert ~\"a\"      == xx,\n-              3 => assert ~\"little\" == xx,\n+              0 => assert \"\\nMary\" == xx,\n+              1 => assert \"had\"    == xx,\n+              2 => assert \"a\"      == xx,\n+              3 => assert \"little\" == xx,\n               _ => ()\n             }\n             ii += 1;\n         }\n     }\n \n     #[test]\n-    fn test_splitn_char_iter() {\n+    fn test_splitn_char_each() {\n         let data = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n \n         let mut ii = 0;\n \n-        do splitn_char_iter(data, ' ', 2u) |xx| {\n+        for splitn_char_each(data, ' ', 2u) |xx| {\n             match ii {\n-              0 => assert ~\"\\nMary\" == xx,\n-              1 => assert ~\"had\"    == xx,\n-              2 => assert ~\"a little lamb\\nLittle lamb\\n\" == xx,\n+              0 => assert \"\\nMary\" == xx,\n+              1 => assert \"had\"    == xx,\n+              2 => assert \"a little lamb\\nLittle lamb\\n\" == xx,\n               _ => ()\n             }\n             ii += 1;\n         }\n     }\n \n     #[test]\n-    fn test_words_iter() {\n+    fn test_words_each() {\n         let data = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n \n         let mut ii = 0;\n \n-        do words_iter(data) |ww| {\n+        for words_each(data) |ww| {\n             match ii {\n-              0 => assert ~\"Mary\"   == ww,\n-              1 => assert ~\"had\"    == ww,\n-              2 => assert ~\"a\"      == ww,\n-              3 => assert ~\"little\" == ww,\n+              0 => assert \"Mary\"   == ww,\n+              1 => assert \"had\"    == ww,\n+              2 => assert \"a\"      == ww,\n+              3 => assert \"little\" == ww,\n               _ => ()\n             }\n             ii += 1;\n         }\n \n-        words_iter(~\"\", |_x| fail); // should not fail\n+        words_each(~\"\", |_x| fail); // should not fail\n     }\n \n     #[test]\n-    fn test_lines_iter () {\n+    fn test_lines_each () {\n         let lf = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n \n         let mut ii = 0;\n \n-        do lines_iter(lf) |x| {\n+        for lines_each(lf) |x| {\n             match ii {\n-                0 => assert ~\"\" == x,\n-                1 => assert ~\"Mary had a little lamb\" == x,\n-                2 => assert ~\"Little lamb\" == x,\n-                3 => assert ~\"\" == x,\n+                0 => assert \"\" == x,\n+                1 => assert \"Mary had a little lamb\" == x,\n+                2 => assert \"Little lamb\" == x,\n+                3 => assert \"\" == x,\n                 _ => ()\n             }\n             ii += 1;\n@@ -3221,7 +3231,7 @@ mod tests {\n                0x000a_u16 ]) ];\n \n         for vec::each(pairs) |p| {\n-            let (s, u) = copy p;\n+            let (s, u) = copy *p;\n             assert to_utf16(s) == u;\n             assert from_utf16(u) == s;\n             assert from_utf16(to_utf16(s)) == s;"}, {"sha": "070da8ffd4a3b7af2a8cb40fb199620f5e78bcfd", "filename": "src/libcore/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -888,7 +888,7 @@ fn taskset_remove(tasks: &mut TaskSet, task: *rust_task) {\n     assert was_present;\n }\n fn taskset_each(tasks: &TaskSet, blk: fn(+*rust_task) -> bool) {\n-    tasks.each_key(blk)\n+    tasks.each_key(|k| blk(*k))\n }\n \n // One of these per group of linked-failure tasks."}, {"sha": "820e4df647ad618655866d87dce238949231fcc5", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 47, "deletions": 172, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -76,12 +76,8 @@ export zip, zip_slice;\n export swap;\n export reverse;\n export reversed;\n-export iter, iter_between, each, eachi, reach, reachi;\n-export each_ref, each_mut_ref, each_const_ref;\n+export each, each_mut, each_const, eachi, reach, reachi;\n export iter2;\n-export iteri;\n-export riter;\n-export riteri;\n export permute;\n export windowed;\n export as_imm_buf;\n@@ -755,7 +751,7 @@ fn grow_set<T: Copy>(&v: ~[mut T], index: uint, initval: T, val: T) {\n pure fn map<T, U>(v: &[T], f: fn(T) -> U) -> ~[U] {\n     let mut result = ~[];\n     unsafe{reserve(result, len(v));}\n-    for each(v) |elem| { unsafe { push(result, f(elem)); } }\n+    for each(v) |elem| { unsafe { push(result, f(*elem)); } }\n     move result\n }\n \n@@ -781,7 +777,7 @@ pure fn mapi<T, U>(v: &[T], f: fn(uint, T) -> U) -> ~[U] {\n  */\n pure fn flat_map<T, U>(v: &[T], f: fn(T) -> ~[U]) -> ~[U] {\n     let mut result = ~[];\n-    for each(v) |elem| { unsafe{ push_all_move(result, f(elem)); } }\n+    for each(v) |elem| { unsafe{ push_all_move(result, f(*elem)); } }\n     move result\n }\n \n@@ -809,7 +805,7 @@ pure fn filter_map<T, U: Copy>(v: &[T], f: fn(T) -> Option<U>)\n     -> ~[U] {\n     let mut result = ~[];\n     for each(v) |elem| {\n-        match f(elem) {\n+        match f(*elem) {\n           None => {/* no-op */ }\n           Some(result_elem) => unsafe { push(result, result_elem); }\n         }\n@@ -827,7 +823,7 @@ pure fn filter_map<T, U: Copy>(v: &[T], f: fn(T) -> Option<U>)\n pure fn filter<T: Copy>(v: &[T], f: fn(T) -> bool) -> ~[T] {\n     let mut result = ~[];\n     for each(v) |elem| {\n-        if f(elem) { unsafe { push(result, elem); } }\n+        if f(*elem) { unsafe { push(result, *elem); } }\n     }\n     move result\n }\n@@ -839,7 +835,7 @@ pure fn filter<T: Copy>(v: &[T], f: fn(T) -> bool) -> ~[T] {\n  */\n pure fn concat<T: Copy>(v: &[~[T]]) -> ~[T] {\n     let mut r = ~[];\n-    for each(v) |inner| { unsafe { push_all(r, inner); } }\n+    for each(v) |inner| { unsafe { push_all(r, *inner); } }\n     move r\n }\n \n@@ -849,24 +845,24 @@ pure fn connect<T: Copy>(v: &[~[T]], sep: T) -> ~[T] {\n     let mut first = true;\n     for each(v) |inner| {\n         if first { first = false; } else { unsafe { push(r, sep); } }\n-        unsafe { push_all(r, inner) };\n+        unsafe { push_all(r, *inner) };\n     }\n     move r\n }\n \n /// Reduce a vector from left to right\n pure fn foldl<T: Copy, U>(z: T, v: &[U], p: fn(T, U) -> T) -> T {\n     let mut accum = z;\n-    do iter(v) |elt| {\n-        accum = p(accum, elt);\n+    for each(v) |elt| {\n+        accum = p(accum, *elt);\n     }\n     return accum;\n }\n \n /// Reduce a vector from right to left\n pure fn foldr<T, U: Copy>(v: &[T], z: U, p: fn(T, U) -> U) -> U {\n     let mut accum = z;\n-    do riter(v) |elt| {\n+    for reach(v) |elt| {\n         accum = p(elt, accum);\n     }\n     return accum;\n@@ -878,7 +874,7 @@ pure fn foldr<T, U: Copy>(v: &[T], z: U, p: fn(T, U) -> U) -> U {\n  * If the vector contains no elements then false is returned.\n  */\n pure fn any<T>(v: &[T], f: fn(T) -> bool) -> bool {\n-    for each(v) |elem| { if f(elem) { return true; } }\n+    for each(v) |elem| { if f(*elem) { return true; } }\n     return false;\n }\n \n@@ -905,7 +901,7 @@ pure fn any2<T, U>(v0: &[T], v1: &[U],\n  * If the vector contains no elements then true is returned.\n  */\n pure fn all<T>(v: &[T], f: fn(T) -> bool) -> bool {\n-    for each(v) |elem| { if !f(elem) { return false; } }\n+    for each(v) |elem| { if !f(*elem) { return false; } }\n     return true;\n }\n \n@@ -935,14 +931,14 @@ pure fn all2<T, U>(v0: &[T], v1: &[U],\n \n /// Return true if a vector contains an element with the given value\n pure fn contains<T: Eq>(v: &[T], x: T) -> bool {\n-    for each(v) |elt| { if x == elt { return true; } }\n+    for each(v) |elt| { if x == *elt { return true; } }\n     return false;\n }\n \n /// Returns the number of elements that are equal to a given value\n pure fn count<T: Eq>(v: &[T], x: T) -> uint {\n     let mut cnt = 0u;\n-    for each(v) |elt| { if x == elt { cnt += 1u; } }\n+    for each(v) |elt| { if x == *elt { cnt += 1u; } }\n     return cnt;\n }\n \n@@ -1070,7 +1066,7 @@ pure fn rposition_between<T>(v: &[T], start: uint, end: uint,\n pure fn unzip_slice<T: Copy, U: Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n     let mut as_ = ~[], bs = ~[];\n     for each(v) |p| {\n-        let (a, b) = p;\n+        let (a, b) = *p;\n         unsafe {\n             vec::push(as_, a);\n             vec::push(bs, b);\n@@ -1150,7 +1146,6 @@ fn reverse<T>(v: &[mut T]) {\n     while i < ln / 2u { v[i] <-> v[ln - i - 1u]; i += 1u; }\n }\n \n-\n /// Returns a vector with the order of elements reversed\n pure fn reversed<T: Copy>(v: &[const T]) -> ~[T] {\n     let mut rs: ~[T] = ~[];\n@@ -1163,50 +1158,13 @@ pure fn reversed<T: Copy>(v: &[const T]) -> ~[T] {\n     move rs\n }\n \n-/**\n- * Iterates over a slice\n- *\n- * Iterates over slice `v` and, for each element, calls function `f` with the\n- * element's value.\n- */\n-#[inline(always)]\n-pure fn iter<T>(v: &[T], f: fn(T)) {\n-    iter_between(v, 0u, vec::len(v), f)\n-}\n-\n-/*\n-Function: iter_between\n-\n-Iterates over a slice\n-\n-Iterates over slice `v` and, for each element, calls function `f` with the\n-element's value.\n-\n-*/\n-#[inline(always)]\n-pure fn iter_between<T>(v: &[T], start: uint, end: uint, f: fn(T)) {\n-    do as_imm_buf(v) |base_ptr, len| {\n-        assert start <= end;\n-        assert end <= len;\n-        unsafe {\n-            let mut n = end;\n-            let mut p = ptr::offset(base_ptr, start);\n-            while n > start {\n-                f(*p);\n-                p = ptr::offset(p, 1u);\n-                n -= 1u;\n-            }\n-        }\n-    }\n-}\n-\n /**\n  * Iterates over a vector, with option to break\n  *\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pure fn each<T>(v: &[T], f: fn(T) -> bool) {\n+pure fn each<T>(v: &r/[T], f: fn((&r/T)) -> bool) {\n     //             ^^^^\n     // NB---this CANNOT be &[const T]!  The reason\n     // is that you are passing it to `f()` using\n@@ -1217,38 +1175,20 @@ pure fn each<T>(v: &[T], f: fn(T) -> bool) {\n         let mut p = p;\n         while n > 0u {\n             unsafe {\n-                if !f(*p) { break; }\n+                let q = cast::copy_lifetime_vec(v, &*p);\n+                if !f(q) { break; }\n                 p = ptr::offset(p, 1u);\n             }\n             n -= 1u;\n         }\n     }\n }\n \n-/**\n- * Iterates over a vector, with option to break\n- *\n- * Return true to continue, false to break.\n- */\n-#[inline(always)]\n-pure fn each_ref<T>(v: &r/[T], f: fn(v: &r/T) -> bool) {\n-    // this is not the most efficient impl, as it repeats the bound checks,\n-    // but it's good enough\n-    let mut i = 0;\n-    let n = v.len();\n-    while i < n {\n-        if !f(&v[i]) {\n-            return;\n-        }\n-        i += 1;\n-    }\n-}\n-\n /// Like `each()`, but for the case where you have\n /// a vector with mutable contents and you would like\n /// to mutate the contents as you iterate.\n #[inline(always)]\n-fn each_mut_ref<T>(v: &[mut T], f: fn(elem: &mut T) -> bool) {\n+fn each_mut<T>(v: &[mut T], f: fn(elem: &mut T) -> bool) {\n     let mut i = 0;\n     let n = v.len();\n     while i < n {\n@@ -1262,7 +1202,7 @@ fn each_mut_ref<T>(v: &[mut T], f: fn(elem: &mut T) -> bool) {\n /// Like `each()`, but for the case where you have a vector that *may or may\n /// not* have mutable contents.\n #[inline(always)]\n-pure fn each_const_ref<T>(v: &[const T], f: fn(elem: &const T) -> bool) {\n+pure fn each_const<T>(v: &[const T], f: fn(elem: &const T) -> bool) {\n     let mut i = 0;\n     let n = v.len();\n     while i < n {\n@@ -1344,43 +1284,6 @@ fn iter2<U, T>(v1: &[U], v2: &[T], f: fn(U, T)) {\n     }\n }\n \n-/**\n- * Iterates over a vector's elements and indexes\n- *\n- * Iterates over vector `v` and, for each element, calls function `f` with the\n- * element's value and index.\n- */\n-#[inline(always)]\n-pure fn iteri<T>(v: &[T], f: fn(uint, T)) {\n-    let mut i = 0u;\n-    let l = len(v);\n-    while i < l { f(i, v[i]); i += 1u; }\n-}\n-\n-/**\n- * Iterates over a vector in reverse\n- *\n- * Iterates over vector `v` and, for each element, calls function `f` with the\n- * element's value.\n- */\n-pure fn riter<T>(v: &[T], f: fn(T)) {\n-    riteri(v, |_i, v| f(v))\n-}\n-\n-/**\n- * Iterates over a vector's elements and indexes in reverse\n- *\n- * Iterates over vector `v` and, for each element, calls function `f` with the\n- * element's value and index.\n- */\n-pure fn riteri<T>(v: &[T], f: fn(uint, T)) {\n-    let mut i = len(v);\n-    while 0u < i {\n-        i -= 1u;\n-        f(i, v[i]);\n-    };\n-}\n-\n /**\n  * Iterate over all permutations of vector `v`.\n  *\n@@ -1414,12 +1317,12 @@ pure fn permute<T: Copy>(v: &[const T], put: fn(~[T])) {\n pure fn windowed<TT: Copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n     let mut ww = ~[];\n     assert 1u <= nn;\n-    vec::iteri (xx, |ii, _x| {\n+    for vec::eachi (xx) |ii, _x| {\n         let len = vec::len(xx);\n         if ii+nn <= len unsafe {\n             vec::push(ww, vec::slice(xx, ii, ii+nn));\n         }\n-    });\n+    }\n     move ww\n }\n \n@@ -1626,10 +1529,6 @@ impl<T: Copy> &[const T]: CopyableVector<T> {\n \n trait ImmutableVector<T> {\n     pure fn foldr<U: Copy>(z: U, p: fn(T, U) -> U) -> U;\n-    pure fn iter(f: fn(T));\n-    pure fn iteri(f: fn(uint, T));\n-    pure fn riter(f: fn(T));\n-    pure fn riteri(f: fn(uint, T));\n     pure fn map<U>(f: fn(T) -> U) -> ~[U];\n     pure fn mapi<U>(f: fn(uint, T) -> U) -> ~[U];\n     fn map_r<U>(f: fn(x: &T) -> U) -> ~[U];\n@@ -1650,38 +1549,6 @@ impl<T> &[T]: ImmutableVector<T> {\n     /// Reduce a vector from right to left\n     #[inline]\n     pure fn foldr<U: Copy>(z: U, p: fn(T, U) -> U) -> U { foldr(self, z, p) }\n-    /**\n-     * Iterates over a vector\n-     *\n-     * Iterates over vector `v` and, for each element, calls function `f` with\n-     * the element's value.\n-     */\n-    #[inline]\n-    pure fn iter(f: fn(T)) { iter(self, f) }\n-    /**\n-     * Iterates over a vector's elements and indexes\n-     *\n-     * Iterates over vector `v` and, for each element, calls function `f` with\n-     * the element's value and index.\n-     */\n-    #[inline]\n-    pure fn iteri(f: fn(uint, T)) { iteri(self, f) }\n-    /**\n-     * Iterates over a vector in reverse\n-     *\n-     * Iterates over vector `v` and, for each element, calls function `f` with\n-     * the element's value.\n-     */\n-    #[inline]\n-    pure fn riter(f: fn(T)) { riter(self, f) }\n-    /**\n-     * Iterates over a vector's elements and indexes in reverse\n-     *\n-     * Iterates over vector `v` and, for each element, calls function `f` with\n-     * the element's value and index.\n-     */\n-    #[inline]\n-    pure fn riteri(f: fn(uint, T)) { riteri(self, f) }\n     /// Apply a function to each element of a vector and return the results\n     #[inline]\n     pure fn map<U>(f: fn(T) -> U) -> ~[U] { map(self, f) }\n@@ -2013,7 +1880,13 @@ mod bytes {\n // required in the slice.\n \n impl<A> &[A]: iter::BaseIter<A> {\n-    pure fn each(blk: fn(A) -> bool) { each(self, blk) }\n+    pure fn each(blk: fn(A) -> bool) {\n+        for each(self) |e| {\n+            if (!blk(*e)) {\n+                return;\n+            }\n+        }\n+    }\n     pure fn size_hint() -> Option<uint> { Some(len(self)) }\n }\n \n@@ -2465,55 +2338,57 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_iter_empty() {\n-        let mut i = 0;\n-        iter::<int>(~[], |_v| i += 1);\n-        assert i == 0;\n+    fn test_each_empty() {\n+        for each::<int>(~[]) |_v| {\n+            fail; // should never be executed\n+        }\n     }\n \n     #[test]\n     fn test_iter_nonempty() {\n         let mut i = 0;\n-        iter(~[1, 2, 3], |v| i += v);\n+        for each(~[1, 2, 3]) |v| {\n+            i += *v;\n+        }\n         assert i == 6;\n     }\n \n     #[test]\n     fn test_iteri() {\n         let mut i = 0;\n-        iteri(~[1, 2, 3], |j, v| {\n+        for eachi(~[1, 2, 3]) |j, v| {\n             if i == 0 { assert v == 1; }\n             assert j + 1u == v as uint;\n             i += v;\n-        });\n+        }\n         assert i == 6;\n     }\n \n     #[test]\n-    fn test_riter_empty() {\n-        let mut i = 0;\n-        riter::<int>(~[], |_v| i += 1);\n-        assert i == 0;\n+    fn test_reach_empty() {\n+        for reach::<int>(~[]) |_v| {\n+            fail; // should never execute\n+        }\n     }\n \n     #[test]\n     fn test_riter_nonempty() {\n         let mut i = 0;\n-        riter(~[1, 2, 3], |v| {\n+        for reach(~[1, 2, 3]) |v| {\n             if i == 0 { assert v == 3; }\n             i += v\n-        });\n+        }\n         assert i == 6;\n     }\n \n     #[test]\n-    fn test_riteri() {\n+    fn test_reachi() {\n         let mut i = 0;\n-        riteri(~[0, 1, 2], |j, v| {\n+        for reachi(~[0, 1, 2]) |j, v| {\n             if i == 0 { assert v == 2; }\n             assert j == v as uint;\n             i += v;\n-        });\n+        }\n         assert i == 3;\n     }\n "}, {"sha": "5c4e1097fe227084435343edff2b3472afc5bd35", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -642,6 +642,7 @@ mod tests {\n                 c.send(());\n             }\n         }\n+\n         // Readers try to catch the writer in the act\n         let mut children = ~[];\n         for 5.times {\n@@ -652,8 +653,10 @@ mod tests {\n                 }\n             }\n         }\n+\n         // Wait for children to pass their asserts\n-        for vec::each(children) |r| { future::get(&r); }\n+        for vec::each(children) |r| { future::get(r); }\n+\n         // Wait for writer to finish\n         p.recv();\n         do arc.read |num| { assert *num == 10; }\n@@ -714,7 +717,7 @@ mod tests {\n                 *state = 31337;\n                 // send to other readers\n                 for vec::each(reader_convos) |x| {\n-                    match x {\n+                    match *x {\n                         (rc, _) => rc.send(()),\n                     }\n                 }\n@@ -723,7 +726,7 @@ mod tests {\n             do (&read_mode).read |state| {\n                 // complete handshake with other readers\n                 for vec::each(reader_convos) |x| {\n-                    match x {\n+                    match *x {\n                         (_, rp) => rp.recv(),\n                     }\n                 }"}, {"sha": "67d3619b0e21cf97ca4db2a46e3732441fffdbd6", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -294,14 +294,14 @@ fn getopts(args: &[~str], opts: &[Opt]) -> Result unsafe {\n             let mut name_pos = 0u;\n             for vec::each(names) |nm| {\n                 name_pos += 1u;\n-                let optid = match find_opt(opts, nm) {\n+                let optid = match find_opt(opts, *nm) {\n                   Some(id) => id,\n-                  None => return Err(UnrecognizedOption(name_str(&nm)))\n+                  None => return Err(UnrecognizedOption(name_str(nm)))\n                 };\n                 match opts[optid].hasarg {\n                   No => {\n                     if !option::is_none::<~str>(i_arg) {\n-                        return Err(UnexpectedArgument(name_str(&nm)));\n+                        return Err(UnexpectedArgument(name_str(nm)));\n                     }\n                     vec::push(vals[optid], Given);\n                   }\n@@ -318,7 +318,7 @@ fn getopts(args: &[~str], opts: &[Opt]) -> Result unsafe {\n                         vec::push(vals[optid],\n                                   Val(option::get::<~str>(i_arg)));\n                     } else if i + 1u == l {\n-                        return Err(ArgumentMissing(name_str(&nm)));\n+                        return Err(ArgumentMissing(name_str(nm)));\n                     } else { i += 1u; vec::push(vals[optid], Val(args[i])); }\n                   }\n                 }\n@@ -367,7 +367,7 @@ fn opt_present(+mm: Matches, nm: &str) -> bool {\n /// Returns true if any of several options were matched\n fn opts_present(+mm: Matches, names: &[~str]) -> bool {\n     for vec::each(names) |nm| {\n-        match find_opt(mm.opts, mkname(nm)) {\n+        match find_opt(mm.opts, mkname(*nm)) {\n           Some(_) => return true,\n           None    => ()\n         }\n@@ -394,7 +394,7 @@ fn opt_str(+mm: Matches, nm: &str) -> ~str {\n  */\n fn opts_str(+mm: Matches, names: &[~str]) -> ~str {\n     for vec::each(names) |nm| {\n-        match opt_val(mm, nm) {\n+        match opt_val(mm, *nm) {\n           Val(s) => return s,\n           _ => ()\n         }\n@@ -412,7 +412,7 @@ fn opts_str(+mm: Matches, names: &[~str]) -> ~str {\n fn opt_strs(+mm: Matches, nm: &str) -> ~[~str] {\n     let mut acc: ~[~str] = ~[];\n     for vec::each(opt_vals(mm, nm)) |v| {\n-        match v { Val(s) => vec::push(acc, s), _ => () }\n+        match *v { Val(s) => vec::push(acc, s), _ => () }\n     }\n     return acc;\n }"}, {"sha": "5b7c92f59fab9860082a71c6fdd39c0979fe7832", "filename": "src/libstd/json.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -179,7 +179,7 @@ fn to_writer_pretty(wr: io::Writer, j: Json, indent: uint) {\n \n fn escape_str(s: &str) -> ~str {\n     let mut escaped = ~\"\\\"\";\n-    do str::chars_iter(s) |c| {\n+    for str::chars_each(s) |c| {\n         match c {\n           '\"' => escaped += ~\"\\\\\\\"\",\n           '\\\\' => escaped += ~\"\\\\\\\\\",\n@@ -834,8 +834,8 @@ mod tests {\n     fn mk_dict(items: &[(~str, Json)]) -> Json {\n         let d = map::str_hash();\n \n-        do vec::iter(items) |item| {\n-            let (key, value) = copy item;\n+        for vec::each(items) |item| {\n+            let (key, value) = copy *item;\n             d.insert(key, value);\n         };\n "}, {"sha": "7d609a42ebd73786403a73f5fc16747ee528a096", "filename": "src/libstd/map.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -435,9 +435,12 @@ fn vec_from_set<T:Eq IterBytes Hash Copy>(s: Set<T>) -> ~[T] {\n fn hash_from_vec<K: Eq IterBytes Hash Const Copy, V: Copy>(\n     items: &[(K, V)]) -> HashMap<K, V> {\n     let map = HashMap();\n-    do vec::iter(items) |item| {\n-        let (key, value) = item;\n-        map.insert(key, value);\n+    for vec::each(items) |item| {\n+        match *item {\n+            (key, value) => {\n+                map.insert(key, value);\n+            }\n+        }\n     }\n     map\n }\n@@ -520,47 +523,47 @@ impl<K: Eq IterBytes Hash Copy, V: Copy> @Mut<LinearMap<K, V>>:\n     pure fn each(op: fn(+key: K, +value: V) -> bool) {\n         unsafe {\n             do self.borrow_imm |p| {\n-                p.each(op)\n+                p.each(|k, v| op(*k, *v))\n             }\n         }\n     }\n \n     pure fn each_key(op: fn(+key: K) -> bool) {\n         unsafe {\n             do self.borrow_imm |p| {\n-                p.each_key(op)\n+                p.each_key(|k| op(*k))\n             }\n         }\n     }\n \n     pure fn each_value(op: fn(+value: V) -> bool) {\n         unsafe {\n             do self.borrow_imm |p| {\n-                p.each_value(op)\n+                p.each_value(|v| op(*v))\n             }\n         }\n     }\n \n     pure fn each_ref(op: fn(key: &K, value: &V) -> bool) {\n         unsafe {\n             do self.borrow_imm |p| {\n-                p.each_ref(op)\n+                p.each(op)\n             }\n         }\n     }\n \n     pure fn each_key_ref(op: fn(key: &K) -> bool) {\n         unsafe {\n             do self.borrow_imm |p| {\n-                p.each_key_ref(op)\n+                p.each_key(op)\n             }\n         }\n     }\n \n     pure fn each_value_ref(op: fn(value: &V) -> bool) {\n         unsafe {\n             do self.borrow_imm |p| {\n-                p.each_value_ref(op)\n+                p.each_value(op)\n             }\n         }\n     }"}, {"sha": "c840d320375e73beb72a4c8f0b87c63ad5e6c0f2", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -364,12 +364,12 @@ mod test {\n         log(debug, fmt!(\"test_get_addr: Number of results for %s: %?\",\n                         localhost_name, vec::len(results)));\n         for vec::each(results) |r| {\n-            let ipv_prefix = match r {\n+            let ipv_prefix = match *r {\n               Ipv4(_) => ~\"IPv4\",\n               Ipv6(_) => ~\"IPv6\"\n             };\n             log(debug, fmt!(\"test_get_addr: result %s: '%s'\",\n-                            ipv_prefix, format_addr(&r)));\n+                            ipv_prefix, format_addr(r)));\n         }\n         // at least one result.. this is going to vary from system\n         // to system, based on stuff like the contents of /etc/hosts"}, {"sha": "72b3c747e35b354896d7d5adcbe388b21ffa6bc3", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -91,7 +91,7 @@ trait Deserializer {\n \n fn emit_from_vec<S: Serializer, T>(s: S, v: ~[T], f: fn(T)) {\n     do s.emit_vec(vec::len(v)) {\n-        do vec::iteri(v) |i,e| {\n+        for vec::eachi(v) |i,e| {\n             do s.emit_vec_elt(i) {\n                 f(e)\n             }"}, {"sha": "c16e29f27707b55da310ad1352ad4a1df1697c84", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -66,7 +66,7 @@ fn sha1() -> Sha1 {\n     fn add_input(st: &Sha1State, msg: &[u8]) {\n         assert (!st.computed);\n         for vec::each(msg) |element| {\n-            st.msg_block[st.msg_block_idx] = element;\n+            st.msg_block[st.msg_block_idx] = *element;\n             st.msg_block_idx += 1u;\n             st.len_low += 8u32;\n             if st.len_low == 0u32 {\n@@ -161,7 +161,7 @@ fn sha1() -> Sha1 {\n     fn mk_result(st: &Sha1State) -> ~[u8] {\n         if !(*st).computed { pad_msg(st); (*st).computed = true; }\n         let mut rs: ~[u8] = ~[];\n-        for vec::each_mut_ref((*st).h) |ptr_hpart| {\n+        for vec::each_mut((*st).h) |ptr_hpart| {\n             let hpart = *ptr_hpart;\n             let a = (hpart >> 24u32 & 0xFFu32) as u8;\n             let b = (hpart >> 16u32 & 0xFFu32) as u8;\n@@ -240,7 +240,9 @@ fn sha1() -> Sha1 {\n         fn result_str() -> ~str {\n             let rr = mk_result(&self);\n             let mut s = ~\"\";\n-            for vec::each(rr) |b| { s += uint::to_str(b as uint, 16u); }\n+            for vec::each(rr) |b| {\n+                s += uint::to_str(*b as uint, 16u);\n+            }\n             return s;\n         }\n     }"}, {"sha": "5366774db3732071a4b82f01a6766918212cb0b7", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -103,21 +103,15 @@ impl<V: Copy> SmallIntMap<V>: map::Map<uint, V> {\n     fn get(+key: uint) -> V { get(self, key) }\n     pure fn find(+key: uint) -> Option<V> { find(self, key) }\n     fn rehash() { fail }\n+\n     pure fn each(it: fn(+key: uint, +value: V) -> bool) {\n-        let mut idx = 0u, l = self.v.len();\n-        while idx < l {\n-            match self.v.get_elt(idx) {\n-              Some(elt) => if !it(idx, elt) { break },\n-              None => ()\n-            }\n-            idx += 1u;\n-        }\n+        self.each_ref(|k, v| it(*k, *v))\n     }\n     pure fn each_key(it: fn(+key: uint) -> bool) {\n-        self.each(|k, _v| it(k))\n+        self.each_ref(|k, _v| it(*k))\n     }\n     pure fn each_value(it: fn(+value: V) -> bool) {\n-        self.each(|_k, v| it(v))\n+        self.each_ref(|_k, v| it(*v))\n     }\n     pure fn each_ref(it: fn(key: &uint, value: &V) -> bool) {\n         let mut idx = 0u, l = self.v.len();"}, {"sha": "c32f7413a926257a2127db9748b87ca067fb25c6", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -260,7 +260,7 @@ mod test_qsort {\n \n         let pairs = vec::zip(expected, immut_names);\n         for vec::each(pairs) |p| {\n-            let (a, b) = p;\n+            let (a, b) = *p;\n             debug!(\"%d %d\", a, b);\n             assert (a == b);\n         }"}, {"sha": "6a264161bc75bb74dd3be5055a4b46562bcdb291", "filename": "src/libstd/term.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -40,7 +40,7 @@ fn color_supported() -> bool {\n     return match os::getenv(~\"TERM\") {\n           option::Some(env) => {\n             for vec::each(supported_terms) |term| {\n-                if term == env { return true; }\n+                if *term == env { return true; }\n             }\n             false\n           }"}, {"sha": "8692a9a440a08b863a15114943ba782d430be7f7", "filename": "src/libstd/test.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -227,7 +227,7 @@ fn print_failures(st: ConsoleTestState) {\n     let failures = vec::map(failures, |test| test.name);\n     let failures = sort::merge_sort(|x, y| str::le(*x, *y), failures);\n     for vec::each(failures) |name| {\n-        st.out.write_line(fmt!(\"    %s\", name));\n+        st.out.write_line(fmt!(\"    %s\", *name));\n     }\n }\n \n@@ -535,30 +535,34 @@ mod tests {\n              ~\"test::sort_tests\"];\n         let tests =\n         {\n-        let testfn = fn~() { };\n-        let mut tests = ~[];\n+            let testfn = fn~() { };\n+            let mut tests = ~[];\n             for vec::each(names) |name| {\n-            let test = {name: name, testfn: copy testfn, ignore: false,\n-                        should_fail: false};\n-            tests += ~[test];\n-        }\n-        tests\n-    };\n-    let filtered = filter_tests(opts, tests);\n+                let test = {name: *name, testfn: copy testfn, ignore: false,\n+                            should_fail: false};\n+                vec::push(tests, test);\n+            }\n+            tests\n+        };\n+        let filtered = filter_tests(opts, tests);\n \n-    let expected =\n-        ~[~\"int::test_pow\", ~\"int::test_to_str\", ~\"sha1::test\",\n-          ~\"test::do_not_run_ignored_tests\",\n-          ~\"test::filter_for_ignored_option\",\n-          ~\"test::first_free_arg_should_be_a_filter\",\n-          ~\"test::ignored_tests_result_in_ignored\",\n-          ~\"test::parse_ignored_flag\",\n-          ~\"test::sort_tests\"];\n+        let expected =\n+            ~[~\"int::test_pow\", ~\"int::test_to_str\", ~\"sha1::test\",\n+              ~\"test::do_not_run_ignored_tests\",\n+              ~\"test::filter_for_ignored_option\",\n+              ~\"test::first_free_arg_should_be_a_filter\",\n+              ~\"test::ignored_tests_result_in_ignored\",\n+              ~\"test::parse_ignored_flag\",\n+              ~\"test::sort_tests\"];\n \n-    let pairs = vec::zip(expected, filtered);\n+        let pairs = vec::zip(expected, filtered);\n \n-    for vec::each(pairs) |p| { let (a, b) = copy p; assert (a == b.name); }\n-}\n+        for vec::each(pairs) |p| {\n+            match *p {\n+                (a, b) => { assert (a == b.name); }\n+            }\n+        }\n+    }\n }\n \n "}, {"sha": "45ea25c385827dfeac7a3d189fd0e5eda67421c2", "filename": "src/libstd/time.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -1023,27 +1023,31 @@ mod tests {\n             }\n         }\n \n-        [\n+        for vec::each([\n             ~\"Sunday\",\n             ~\"Monday\",\n             ~\"Tuesday\",\n             ~\"Wednesday\",\n             ~\"Thursday\",\n             ~\"Friday\",\n             ~\"Saturday\"\n-        ]/_.iter(|day| assert test(day, ~\"%A\"));\n+        ]) |day| {\n+            assert test(*day, ~\"%A\");\n+        }\n \n-        [\n+        for vec::each([\n             ~\"Sun\",\n             ~\"Mon\",\n             ~\"Tue\",\n             ~\"Wed\",\n             ~\"Thu\",\n             ~\"Fri\",\n             ~\"Sat\"\n-        ]/_.iter(|day| assert test(day, ~\"%a\"));\n+        ]) |day| {\n+            assert test(*day, ~\"%a\");\n+        }\n \n-        [\n+        for vec::each([\n             ~\"January\",\n             ~\"February\",\n             ~\"March\",\n@@ -1056,9 +1060,11 @@ mod tests {\n             ~\"October\",\n             ~\"November\",\n             ~\"December\"\n-        ]/_.iter(|day| assert test(day, ~\"%B\"));\n+        ]) |day| {\n+            assert test(*day, ~\"%B\");\n+        }\n \n-        [\n+        for vec::each([\n             ~\"Jan\",\n             ~\"Feb\",\n             ~\"Mar\",\n@@ -1071,7 +1077,9 @@ mod tests {\n             ~\"Oct\",\n             ~\"Nov\",\n             ~\"Dec\"\n-        ]/_.iter(|day| assert test(day, ~\"%b\"));\n+        ]) |day| {\n+            assert test(*day, ~\"%b\");\n+        }\n \n         assert test(~\"19\", ~\"%C\");\n         assert test(~\"Fri Feb 13 23:31:30 2009\", ~\"%c\");"}, {"sha": "c110af491fcfddda7b47cc2213522f387b200adf", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -293,8 +293,10 @@ fn map_struct_def(struct_def: @ast::struct_def, parent_node: ast_node,\n     }\n     let d_id = ast_util::local_def(id);\n     let p = extend(cx, ident);\n-     // only need to handle methods\n-    do vec::iter(struct_def.methods) |m| { map_method(d_id, p, m, cx); }\n+    // only need to handle methods\n+    for vec::each(struct_def.methods) |m| {\n+        map_method(d_id, p, *m, cx);\n+    }\n }\n \n fn map_view_item(vi: @view_item, cx: ctx, _v: vt) {"}, {"sha": "e134f1cb805f5dfd794583643c2653c94a9f56e8", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -429,13 +429,13 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n             match vi.node {\n               view_item_use(_, _, id) => vfn(id),\n               view_item_import(vps) | view_item_export(vps) => {\n-                do vec::iter(vps) |vp| {\n-                    match vp.node {\n-                      view_path_simple(_, _, _, id) => vfn(id),\n-                      view_path_glob(_, id) => vfn(id),\n-                      view_path_list(_, _, id) => vfn(id)\n-                    }\n-                }\n+                  for vec::each(vps) |vp| {\n+                      match vp.node {\n+                          view_path_simple(_, _, _, id) => vfn(id),\n+                          view_path_glob(_, id) => vfn(id),\n+                          view_path_list(_, _, id) => vfn(id)\n+                      }\n+                  }\n               }\n             }\n         },\n@@ -490,42 +490,44 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n         },\n \n         visit_ty_params: fn@(ps: ~[ty_param]) {\n-            vec::iter(ps, |p| vfn(p.id))\n+            for vec::each(ps) |p| {\n+                vfn(p.id);\n+            }\n         },\n \n         visit_fn: fn@(fk: visit::fn_kind, d: ast::fn_decl,\n                       _b: ast::blk, _sp: span, id: ast::node_id) {\n             vfn(id);\n \n             match fk {\n-              visit::fk_ctor(_, _, tps, self_id, parent_id) => {\n-                vec::iter(tps, |tp| vfn(tp.id));\n-                vfn(id);\n-                vfn(self_id);\n-                vfn(parent_id.node);\n-              }\n-              visit::fk_dtor(tps, _, self_id, parent_id) => {\n-                vec::iter(tps, |tp| vfn(tp.id));\n-                vfn(id);\n-                vfn(self_id);\n-                vfn(parent_id.node);\n-              }\n-              visit::fk_item_fn(_, tps, _) => {\n-                vec::iter(tps, |tp| vfn(tp.id));\n-              }\n-              visit::fk_method(_, tps, m) => {\n-                vfn(m.self_id);\n-                vec::iter(tps, |tp| vfn(tp.id));\n-              }\n-              visit::fk_anon(_, capture_clause)\n-              | visit::fk_fn_block(capture_clause) => {\n-                for vec::each(*capture_clause) |clause| {\n-                    vfn(clause.id);\n+                visit::fk_ctor(_, _, tps, self_id, parent_id) => {\n+                    for vec::each(tps) |tp| { vfn(tp.id); }\n+                    vfn(id);\n+                    vfn(self_id);\n+                    vfn(parent_id.node);\n+                }\n+                visit::fk_dtor(tps, _, self_id, parent_id) => {\n+                    for vec::each(tps) |tp| { vfn(tp.id); }\n+                    vfn(id);\n+                    vfn(self_id);\n+                    vfn(parent_id.node);\n+                }\n+                visit::fk_item_fn(_, tps, _) => {\n+                    for vec::each(tps) |tp| { vfn(tp.id); }\n+                }\n+                visit::fk_method(_, tps, m) => {\n+                    vfn(m.self_id);\n+                    for vec::each(tps) |tp| { vfn(tp.id); }\n+                }\n+                visit::fk_anon(_, capture_clause) |\n+                visit::fk_fn_block(capture_clause) => {\n+                    for vec::each(*capture_clause) |clause| {\n+                        vfn(clause.id);\n+                    }\n                 }\n-              }\n             }\n \n-            do vec::iter(d.inputs) |arg| {\n+            for vec::each(d.inputs) |arg| {\n                 vfn(arg.id)\n             }\n         },"}, {"sha": "da37e44b58c63105601a07fd9d266edd86e10314", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -228,7 +228,7 @@ fn finish<T: qq_helper>\n     let mut state = active;\n     let mut i = 0u, j = 0u;\n     let g_len = cx.gather.len();\n-    do str::chars_iter(*str) |ch| {\n+    for str::chars_each(*str) |ch| {\n         if (j < g_len && i == cx.gather[j].lo) {\n             assert ch == '$';\n             let repl = fmt!(\"$%u \", j);"}, {"sha": "2061be58488b015ed8e79fa19807d12f136479b0", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -211,7 +211,7 @@ pure fn follow(m: arb_depth<matchable>, idx_path: &[uint]) ->\n     for vec::each(idx_path) |idx| {\n         res = match res {\n           leaf(_) => return res,/* end of the line */\n-          seq(new_ms, _) => new_ms[idx]\n+          seq(new_ms, _) => new_ms[*idx]\n         }\n     }\n     return res;"}, {"sha": "a87e3c4b52be913a7a913fb3955b76608fe8ab9d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -1674,7 +1674,7 @@ fn print_bounds(s: ps, bounds: @~[ast::ty_param_bound]) {\n         word(s.s, ~\":\");\n         for vec::each(*bounds) |bound| {\n             nbsp(s);\n-            match bound {\n+            match *bound {\n               ast::bound_copy => word(s.s, ~\"Copy\"),\n               ast::bound_send => word(s.s, ~\"Send\"),\n               ast::bound_const => word(s.s, ~\"Const\"),"}, {"sha": "4c48a2bea70ef6ca9a8a1c7f6d1a3a9768e95e87", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -263,7 +263,7 @@ fn visit_foreign_item<E>(ni: @foreign_item, e: E, v: vt<E>) {\n \n fn visit_ty_param_bounds<E>(bounds: @~[ty_param_bound], e: E, v: vt<E>) {\n     for vec::each(*bounds) |bound| {\n-        match bound {\n+        match *bound {\n           bound_trait(t) => v.visit_ty(t, e, v),\n           bound_copy | bound_send | bound_const | bound_owned => ()\n         }"}, {"sha": "c56cf30d68966ed42bb4630ebc7cbebf43c29a02", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -539,7 +539,7 @@ fn get_symbol_hash(ccx: @crate_ctxt, t: ty::t) -> ~str {\n // gas doesn't!\n fn sanitize(s: ~str) -> ~str {\n     let mut result = ~\"\";\n-    do str::chars_iter(s) |c| {\n+    for str::chars_each(s) |c| {\n         match c {\n           '@' => result += ~\"_sbox_\",\n           '~' => result += ~\"_ubox_\","}, {"sha": "937745eb3f6fba027daab43bb08306d98c62be75", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -99,8 +99,8 @@ fn get_crate_vers(cstore: cstore, cnum: ast::crate_num) -> ~str {\n fn set_crate_data(cstore: cstore, cnum: ast::crate_num,\n                   data: crate_metadata) {\n     p(cstore).metas.insert(cnum, data);\n-    do vec::iter(decoder::get_crate_module_paths(cstore.intr, data)) |dp| {\n-        let (did, path) = dp;\n+    for vec::each(decoder::get_crate_module_paths(cstore.intr, data)) |dp| {\n+        let (did, path) = *dp;\n         let d = {crate: cnum, node: did.node};\n         p(cstore).mod_path_map.insert(d, @path);\n     }"}, {"sha": "86ec0fe874791d5d0b5f99e7c7304472e430da29", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -267,7 +267,9 @@ fn encode_path(ecx: @encode_ctxt, ebml_w: ebml::Writer, path: ast_map::path,\n \n     do ebml_w.wr_tag(tag_path) {\n         ebml_w.wr_tagged_u32(tag_path_len, (vec::len(path) + 1u) as u32);\n-        do vec::iter(path) |pe| { encode_path_elt(ecx, ebml_w, pe); }\n+        for vec::each(path) |pe| {\n+            encode_path_elt(ecx, ebml_w, *pe);\n+        }\n         encode_path_elt(ecx, ebml_w, name);\n     }\n }\n@@ -768,7 +770,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Writer, item: @item,\n         // written. Here, we output the *real* type signatures. I feel like\n         // maybe we should only ever handle the real type signatures.\n         for vec::each(ms) |m| {\n-            let ty_m = ast_util::trait_method_to_ty_method(m);\n+            let ty_m = ast_util::trait_method_to_ty_method(*m);\n             if ty_m.self_ty.node != ast::sty_static { loop; }\n \n             vec::push(*index, {val: ty_m.id, pos: ebml_w.writer.tell()});"}, {"sha": "df67749bc08c33afa10a300d8a81609c24df6d49", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -366,7 +366,7 @@ fn enc_ty_fn(w: io::Writer, cx: @ctxt, ft: ty::FnTy) {\n \n fn enc_bounds(w: io::Writer, cx: @ctxt, bs: @~[ty::param_bound]) {\n     for vec::each(*bs) |bound| {\n-        match bound {\n+        match *bound {\n           ty::bound_send => w.write_char('S'),\n           ty::bound_copy => w.write_char('C'),\n           ty::bound_const => w.write_char('K'),"}, {"sha": "094e7e03a82dccc5ef0ca03e6a38532ba2133ff7", "filename": "src/rustc/middle/capture.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcapture.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -108,16 +108,16 @@ fn compute_capture_vars(tcx: ty::ctxt,\n         implicit_mode = cap_copy;\n     }\n \n-    do vec::iter(*freevars) |fvar| {\n+    for vec::each(*freevars) |fvar| {\n         let fvar_def_id = ast_util::def_id_of_def(fvar.def).node;\n         match cap_map.find(fvar_def_id) {\n-          option::Some(_) => { /* was explicitly named, do nothing */ }\n-          option::None => {\n-            cap_map.insert(fvar_def_id, {def:fvar.def,\n-                                         span: fvar.span,\n-                                         cap_item: None,\n-                                         mode:implicit_mode});\n-          }\n+            option::Some(_) => { /* was explicitly named, do nothing */ }\n+            option::None => {\n+                cap_map.insert(fvar_def_id, {def:fvar.def,\n+                                             span: fvar.span,\n+                                             cap_item: None,\n+                                             mode:implicit_mode});\n+            }\n         }\n     }\n "}, {"sha": "cafecf52761cfea460829314247578a2a13f2a5d", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -211,7 +211,7 @@ fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n             };\n \n             let ty = ty::node_id_to_type(cx.tcx, id);\n-            chk(cx, fn_id, Some(fv), is_move, ty, fv.span);\n+            chk(cx, fn_id, Some(*fv), is_move, ty, fv.span);\n         }\n     }\n \n@@ -228,7 +228,7 @@ fn check_block(b: blk, cx: ctx, v: visit::vt<ctx>) {\n \n fn check_arm(a: arm, cx: ctx, v: visit::vt<ctx>) {\n     for vec::each(a.pats) |p| {\n-        do pat_util::pat_bindings(cx.tcx.def_map, p) |mode, id, span, _path| {\n+        do pat_util::pat_bindings(cx.tcx.def_map, *p) |mode, id, span, _pth| {\n             if mode == bind_by_value {\n                 let t = ty::node_id_to_type(cx.tcx, id);\n                 let reason = \"consider binding with `ref` or `move` instead\";"}, {"sha": "faba978eef5003e8369653cd9be88460111d4764", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -124,13 +124,13 @@ fn macros() { include!(\"macros.rs\"); } // FIXME(#3114): Macro import/export.\n \n // An option identifying a branch (either a literal, a enum variant or a\n // range)\n-enum opt {\n+enum Opt {\n     lit(@ast::expr),\n     var(/* disr val */int, /* variant dids */{enm: def_id, var: def_id}),\n     range(@ast::expr, @ast::expr)\n }\n-fn opt_eq(tcx: ty::ctxt, a: opt, b: opt) -> bool {\n-    match (a, b) {\n+fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n+    match (*a, *b) {\n       (lit(a), lit(b)) => const_eval::compare_lit_exprs(tcx, a, b) == 0,\n       (range(a1, a2), range(b1, b2)) => {\n         const_eval::compare_lit_exprs(tcx, a1, b1) == 0 &&\n@@ -145,11 +145,11 @@ enum opt_result {\n     single_result(Result),\n     range_result(Result, Result),\n }\n-fn trans_opt(bcx: block, o: opt) -> opt_result {\n+fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n     let _icx = bcx.insn_ctxt(\"alt::trans_opt\");\n     let ccx = bcx.ccx();\n     let mut bcx = bcx;\n-    match o {\n+    match *o {\n         lit(lit_expr) => {\n             let datumblock = expr::trans_to_datum(bcx, lit_expr);\n             return single_result(datumblock.to_result());\n@@ -164,7 +164,7 @@ fn trans_opt(bcx: block, o: opt) -> opt_result {\n     }\n }\n \n-fn variant_opt(tcx: ty::ctxt, pat_id: ast::node_id) -> opt {\n+fn variant_opt(tcx: ty::ctxt, pat_id: ast::node_id) -> Opt {\n     let vdef = ast_util::variant_def_ids(tcx.def_map.get(pat_id));\n     let variants = ty::enum_variants(tcx, vdef.enm);\n     for vec::each(*variants) |v| {\n@@ -337,7 +337,7 @@ fn enter_default(bcx: block, dm: DefMap, m: &[@Match/&r],\n     }\n }\n \n-fn enter_opt(bcx: block, m: &[@Match/&r], opt: opt, col: uint,\n+fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n              variant_size: uint, val: ValueRef)\n     -> ~[@Match/&r]\n {\n@@ -353,7 +353,7 @@ fn enter_opt(bcx: block, m: &[@Match/&r], opt: opt, col: uint,\n     do enter_match(bcx, tcx.def_map, m, col, val) |p| {\n         match p.node {\n             ast::pat_enum(_, subpats) => {\n-                if opt_eq(tcx, variant_opt(tcx, p.id), opt) {\n+                if opt_eq(tcx, &variant_opt(tcx, p.id), opt) {\n                     Some(option::get_default(subpats,\n                                              vec::from_elem(variant_size,\n                                                             dummy)))\n@@ -362,17 +362,17 @@ fn enter_opt(bcx: block, m: &[@Match/&r], opt: opt, col: uint,\n                 }\n             }\n             ast::pat_ident(_, _, None) if pat_is_variant(tcx.def_map, p) => {\n-                if opt_eq(tcx, variant_opt(tcx, p.id), opt) {\n+                if opt_eq(tcx, &variant_opt(tcx, p.id), opt) {\n                     Some(~[])\n                 } else {\n                     None\n                 }\n             }\n             ast::pat_lit(l) => {\n-                if opt_eq(tcx, lit(l), opt) { Some(~[]) } else { None }\n+                if opt_eq(tcx, &lit(l), opt) {Some(~[])} else {None}\n             }\n             ast::pat_range(l1, l2) => {\n-                if opt_eq(tcx, range(l1, l2), opt) { Some(~[]) } else { None }\n+                if opt_eq(tcx, &range(l1, l2), opt) {Some(~[])} else {None}\n             }\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n@@ -397,7 +397,7 @@ fn enter_rec_or_struct(bcx: block, dm: DefMap, m: &[@Match/&r], col: uint,\n             ast::pat_rec(fpats, _) | ast::pat_struct(_, fpats, _) => {\n                 let mut pats = ~[];\n                 for vec::each(fields) |fname| {\n-                    match fpats.find(|p| p.ident == fname) {\n+                    match fpats.find(|p| p.ident == *fname) {\n                         None => vec::push(pats, dummy),\n                         Some(pat) => vec::push(pats, pat.pat)\n                     }\n@@ -487,9 +487,9 @@ fn enter_uniq(bcx: block, dm: DefMap, m: &[@Match/&r],\n     }\n }\n \n-fn get_options(ccx: @crate_ctxt, m: &[@Match], col: uint) -> ~[opt] {\n-    fn add_to_set(tcx: ty::ctxt, set: &DVec<opt>, val: opt) {\n-        if set.any(|l| opt_eq(tcx, l, val)) {return;}\n+fn get_options(ccx: @crate_ctxt, m: &[@Match], col: uint) -> ~[Opt] {\n+    fn add_to_set(tcx: ty::ctxt, set: &DVec<Opt>, val: Opt) {\n+        if set.any(|l| opt_eq(tcx, &l, &val)) {return;}\n         set.push(val);\n     }\n \n@@ -628,12 +628,14 @@ fn pick_col(m: &[@Match]) -> uint {\n     let scores = vec::to_mut(vec::from_elem(m[0].pats.len(), 0u));\n     for vec::each(m) |br| {\n         let mut i = 0u;\n-        for vec::each(br.pats) |p| { scores[i] += score(p); i += 1u; }\n+        for vec::each(br.pats) |p| { scores[i] += score(*p); i += 1u; }\n     }\n     let mut max_score = 0u;\n     let mut best_col = 0u;\n     let mut i = 0u;\n     for vec::each(scores) |score| {\n+        let score = *score;\n+\n         // Irrefutable columns always go first, they'd only be duplicated in\n         // the branches.\n         if score == 0u { return i; }\n@@ -959,7 +961,7 @@ fn compile_submatch(bcx: block,\n         }\n     }\n     for vec::each(opts) |o| {\n-        match o {\n+        match *o {\n             range(_, _) => { kind = compare; break }\n             _ => ()\n         }\n@@ -1037,7 +1039,7 @@ fn compile_submatch(bcx: block,\n \n         let mut size = 0u;\n         let mut unpacked = ~[];\n-        match opt {\n+        match *opt {\n             var(_, vdef) => {\n                 let args = extract_variant_args(opt_cx, pat_id, vdef, val);\n                 size = args.vals.len();\n@@ -1087,7 +1089,7 @@ fn trans_alt_inner(scope_cx: block,\n     }\n \n     let mut arm_datas = ~[], matches = ~[];\n-    for vec::each_ref(arms) |arm| {\n+    for vec::each(arms) |arm| {\n         let body = scope_block(bcx, arm.body.info(), ~\"case_body\");\n \n         // Create the bindings map, which is a mapping from each binding name\n@@ -1129,7 +1131,7 @@ fn trans_alt_inner(scope_cx: block,\n                                  bindings_map: bindings_map};\n         vec::push(arm_datas, arm_data);\n         for vec::each(arm.pats) |p| {\n-            vec::push(matches, @Match {pats: ~[p], data: arm_data});\n+            vec::push(matches, @Match {pats: ~[*p], data: arm_data});\n         }\n     }\n "}, {"sha": "47afe477287b2ceb80d1acf246cc116f08262e36", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -160,11 +160,7 @@ fn trans_foreign_call(cx: block, externs: HashMap<~str, ValueRef>,\n     let n = args.len() as int;\n     let llforeign: ValueRef =\n         get_simple_extern_fn(cx, externs, llmod, name, n);\n-    let mut call_args: ~[ValueRef] = ~[];\n-    for vec::each(args) |a| {\n-        vec::push(call_args, a);\n-    }\n-    return Call(cx, llforeign, call_args);\n+    return Call(cx, llforeign, args);\n }\n \n fn umax(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n@@ -599,7 +595,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n                                        int::to_str(variant.disr_val, 10u));\n             AddCase(llswitch, C_int(ccx, variant.disr_val), variant_cx.llbb);\n             let variant_cx =\n-                iter_variant(variant_cx, llunion_a_ptr, variant,\n+                iter_variant(variant_cx, llunion_a_ptr, *variant,\n                              substs.tps, tid, f);\n             Br(variant_cx, next_cx.llbb);\n         }\n@@ -748,7 +744,7 @@ fn need_invoke(bcx: block) -> bool {\n         match cur.kind {\n           block_scope(inf) => {\n             for vec::each(inf.cleanups) |cleanup| {\n-                match cleanup {\n+                match *cleanup {\n                   clean(_, cleanup_type) | clean_temp(_, _, cleanup_type) => {\n                     if cleanup_type == normal_exit_and_unwind {\n                         return true;\n@@ -1020,9 +1016,9 @@ fn trans_stmt(cx: block, s: ast::stmt) -> block {\n             match d.node {\n                 ast::decl_local(locals) => {\n                     for vec::each(locals) |local| {\n-                        bcx = init_local(bcx, local);\n+                        bcx = init_local(bcx, *local);\n                         if cx.sess().opts.extra_debuginfo {\n-                            debuginfo::create_local_var(bcx, local);\n+                            debuginfo::create_local_var(bcx, *local);\n                         }\n                     }\n                 }\n@@ -1118,7 +1114,7 @@ fn trans_block_cleanups_(bcx: block,\n         bcx.ccx().sess.opts.debugging_opts & session::no_landing_pads != 0;\n     if bcx.unreachable && !no_lpads { return bcx; }\n     let mut bcx = bcx;\n-    do vec::riter(cleanups) |cu| {\n+    for vec::reach(cleanups) |cu| {\n             match cu {\n               clean(cfn, cleanup_type) | clean_temp(_, cfn, cleanup_type) => {\n                 // Some types don't need to be cleaned up during\n@@ -1235,7 +1231,9 @@ fn block_locals(b: ast::blk, it: fn(@ast::local)) {\n           ast::stmt_decl(d, _) => {\n             match d.node {\n               ast::decl_local(locals) => {\n-                for vec::each(locals) |local| { it(local); }\n+                for vec::each(locals) |local| {\n+                    it(*local);\n+                }\n               }\n               _ => {/* fall through */ }\n             }\n@@ -1789,7 +1787,7 @@ fn trans_enum_def(ccx: @crate_ctxt, enum_definition: ast::enum_def,\n         match variant.node.kind {\n             ast::tuple_variant_kind(args) if args.len() > 0 => {\n                 let llfn = get_item_val(ccx, variant.node.id);\n-                trans_enum_variant(ccx, id, variant, args, disr_val,\n+                trans_enum_variant(ccx, id, *variant, args, disr_val,\n                                    degen, None, llfn);\n             }\n             ast::tuple_variant_kind(_) => {\n@@ -1910,7 +1908,9 @@ fn trans_trait(ccx: @crate_ctxt, tps: ~[ast::ty_param],\n // and control visibility.\n fn trans_mod(ccx: @crate_ctxt, m: ast::_mod) {\n     let _icx = ccx.insn_ctxt(\"trans_mod\");\n-    for vec::each(m.items) |item| { trans_item(ccx, *item); }\n+    for vec::each(m.items) |item| {\n+        trans_item(ccx, **item);\n+    }\n }\n \n fn get_pair_fn_ty(llpairty: TypeRef) -> TypeRef {\n@@ -2352,21 +2352,22 @@ fn push_rtcall(ccx: @crate_ctxt, name: ~str, did: ast::def_id) {\n fn gather_local_rtcalls(ccx: @crate_ctxt, crate: @ast::crate) {\n     visit::visit_crate(*crate, (), visit::mk_simple_visitor(@{\n         visit_item: |item| match item.node {\n-          ast::item_fn(*) => {\n-            let attr_metas = attr::attr_metas(\n-                attr::find_attrs_by_name(item.attrs, ~\"rt\"));\n-            do vec::iter(attr_metas) |attr_meta| {\n-                match attr::get_meta_item_list(attr_meta) {\n-                  Some(list) => {\n-                    let name = attr::get_meta_item_name(vec::head(list));\n-                    push_rtcall(ccx, name, {crate: ast::local_crate,\n-                                            node: item.id});\n-                  }\n-                  None => ()\n+            ast::item_fn(*) => {\n+                let attr_metas = attr::attr_metas(\n+                    attr::find_attrs_by_name(item.attrs, ~\"rt\"));\n+                for vec::each(attr_metas) |attr_meta| {\n+                    match attr::get_meta_item_list(*attr_meta) {\n+                        Some(list) => {\n+                            let head = vec::head(list);\n+                            let name = attr::get_meta_item_name(head);\n+                            push_rtcall(ccx, name, {crate: ast::local_crate,\n+                                                    node: item.id});\n+                        }\n+                        None => ()\n+                    }\n                 }\n             }\n-          }\n-          _ => ()\n+            _ => ()\n         },\n         ..*visit::default_simple_visitor()\n     }));\n@@ -2413,8 +2414,8 @@ fn gather_rtcalls(ccx: @crate_ctxt, crate: @ast::crate) {\n     let expected_rtcalls =\n         ~[~\"exchange_free\", ~\"exchange_malloc\", ~\"fail_\", ~\"free\", ~\"malloc\"];\n     for vec::each(expected_rtcalls) |name| {\n-        if !ccx.rtcalls.contains_key(name) {\n-            fail fmt!(\"no definition for runtime call %s\", name);\n+        if !ccx.rtcalls.contains_key(*name) {\n+            fail fmt!(\"no definition for runtime call %s\", *name);\n         }\n     }\n }"}, {"sha": "c669dcfbb0dd709d82c2034c56852c64c3a45b34", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -435,7 +435,7 @@ fn GEP(cx: block, Pointer: ValueRef, Indices: ~[ValueRef]) -> ValueRef {\n // XXX: Use a small-vector optimization to avoid allocations here.\n fn GEPi(cx: block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n     let mut v: ~[ValueRef] = ~[];\n-    for vec::each(ixs) |i| { vec::push(v, C_i32(i as i32)); }\n+    for vec::each(ixs) |i| { vec::push(v, C_i32(*i as i32)); }\n     count_insn(cx, \"gepi\");\n     return InBoundsGEP(cx, base, v);\n }"}, {"sha": "ea00d5aa46787bfa4dd82fe9ad267af94f814c4b", "filename": "src/rustc/middle/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -450,7 +450,7 @@ fn trans_args(cx: block, llenv: ValueRef, args: CallArgs, fn_ty: ty::t,\n     match args {\n       ArgExprs(arg_exprs) => {\n         let last = arg_exprs.len() - 1u;\n-        do vec::iteri(arg_exprs) |i, arg_expr| {\n+        for vec::eachi(arg_exprs) |i, arg_expr| {\n             let arg_val = unpack_result!(bcx, {\n                 trans_arg_expr(bcx, arg_tys[i], arg_expr, &mut temp_cleanups,\n                                if i == last { ret_flag } else { None })\n@@ -466,8 +466,8 @@ fn trans_args(cx: block, llenv: ValueRef, args: CallArgs, fn_ty: ty::t,\n     // now that all arguments have been successfully built, we can revoke any\n     // temporary cleanups, as they are only needed if argument construction\n     // should fail (for example, cleanup of copy mode args).\n-    do vec::iter(temp_cleanups) |c| {\n-        revoke_clean(bcx, c)\n+    for vec::each(temp_cleanups) |c| {\n+        revoke_clean(bcx, *c)\n     }\n \n     return {bcx: bcx, args: llargs, retslot: llretslot};"}, {"sha": "7bc97551e6e6604da7df911c0c5044f5901d1276", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -209,7 +209,7 @@ fn store_environment(bcx: block,\n \n     // Copy expr values into boxed bindings.\n     let mut bcx = bcx;\n-    do vec::iteri(bound_values) |i, bv| {\n+    for vec::eachi(bound_values) |i, bv| {\n         debug!(\"Copy %s into closure\", bv.to_str(ccx));\n \n         if !ccx.sess.no_asm_comments() {\n@@ -232,7 +232,9 @@ fn store_environment(bcx: block,\n         }\n \n     }\n-    for vec::each(temp_cleanups) |cleanup| { revoke_clean(bcx, cleanup); }\n+    for vec::each(temp_cleanups) |cleanup| {\n+        revoke_clean(bcx, *cleanup);\n+    }\n \n     return {llbox: llbox, cdata_ty: cdata_ty, bcx: bcx};\n }\n@@ -251,8 +253,8 @@ fn build_closure(bcx0: block,\n \n     // Package up the captured upvars\n     let mut env_vals = ~[];\n-    do vec::iter(cap_vars) |cap_var| {\n-        debug!(\"Building closure: captured variable %?\", cap_var);\n+    for vec::each(cap_vars) |cap_var| {\n+        debug!(\"Building closure: captured variable %?\", *cap_var);\n         let datum = expr::trans_local_var(bcx, id, cap_var.def);\n         match cap_var.mode {\n             capture::cap_ref => {\n@@ -316,7 +318,7 @@ fn load_environment(fcx: fn_ctxt,\n \n     // Populate the upvars from the environment.\n     let mut i = 0u;\n-    do vec::iter(cap_vars) |cap_var| {\n+    for vec::each(cap_vars) |cap_var| {\n         match cap_var.mode {\n           capture::cap_drop => { /* ignore */ }\n           _ => {"}, {"sha": "ee05a3bb4de405a4187f9f4e31a891cdf3009fef", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -1175,11 +1175,13 @@ fn align_to(cx: block, off: ValueRef, align: ValueRef) -> ValueRef {\n fn path_str(sess: session::session, p: path) -> ~str {\n     let mut r = ~\"\", first = true;\n     for vec::each(p) |e| {\n-        match e { ast_map::path_name(s) | ast_map::path_mod(s) => {\n-          if first { first = false; }\n-          else { r += ~\"::\"; }\n-          r += sess.str_of(s);\n-        } }\n+        match *e {\n+            ast_map::path_name(s) | ast_map::path_mod(s) => {\n+                if first { first = false; }\n+                else { r += ~\"::\"; }\n+                r += sess.str_of(s);\n+            }\n+        }\n     }\n     r\n }\n@@ -1269,8 +1271,8 @@ fn find_vtable(tcx: ty::ctxt, ps: &param_substs,\n     // somewhat awkward\n     for vec::each(*ps.bounds) |bounds| {\n         if i >= n_param { break; }\n-        for vec::each(*bounds) |bound| {\n-            match bound { ty::bound_trait(_) => vtable_off += 1u, _ => () }\n+        for vec::each(**bounds) |bound| {\n+            match *bound { ty::bound_trait(_) => vtable_off += 1u, _ => () }\n         }\n         i += 1u;\n     }"}, {"sha": "9570f37df754d1e105e4b759c25b0292e7d12001", "filename": "src/rustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -13,7 +13,7 @@ fn trans_block(bcx: block, b: ast::blk, dest: expr::Dest) -> block {\n     };\n     for vec::each(b.node.stmts) |s| {\n         debuginfo::update_source_pos(bcx, b.span);\n-        bcx = trans_stmt(bcx, *s);\n+        bcx = trans_stmt(bcx, **s);\n     }\n     match b.node.expr {\n         Some(e) => {\n@@ -85,7 +85,7 @@ fn join_blocks(parent_bcx: block, in_cxs: ~[block]) -> block {\n     let mut reachable = false;\n     for vec::each(in_cxs) |bcx| {\n         if !bcx.unreachable {\n-            Br(bcx, out.llbb);\n+            Br(*bcx, out.llbb);\n             reachable = true;\n         }\n     }"}, {"sha": "c5b31fe5492e8048fc1099ca63074115c06e371e", "filename": "src/rustc/middle/trans/expr.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -1027,7 +1027,9 @@ fn trans_tup(bcx: block, elts: ~[@ast::expr], dest: Dest) -> block {\n     let mut bcx = bcx;\n     let addr = match dest {\n         Ignore => {\n-            for vec::each(elts) |ex| { bcx = trans_into(bcx, ex, Ignore); }\n+            for vec::each(elts) |ex| {\n+                bcx = trans_into(bcx, *ex, Ignore);\n+            }\n             return bcx;\n         }\n         SaveIn(pos) => pos,\n@@ -1040,7 +1042,9 @@ fn trans_tup(bcx: block, elts: ~[@ast::expr], dest: Dest) -> block {\n         add_clean_temp_mem(bcx, dest, e_ty);\n         vec::push(temp_cleanups, dest);\n     }\n-    for vec::each(temp_cleanups) |cleanup| { revoke_clean(bcx, cleanup); }\n+    for vec::each(temp_cleanups) |cleanup| {\n+        revoke_clean(bcx, *cleanup);\n+    }\n     return bcx;\n }\n "}, {"sha": "cd762f135bb476563cf1afc406101e0e2955f7da", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -165,9 +165,9 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n         } else {\n             let mut field_off = off;\n             for vec::each(tys) |ty| {\n-                field_off = align(field_off, ty);\n-                classify(ty, cls, i, field_off);\n-                field_off += ty_size(ty);\n+                field_off = align(field_off, *ty);\n+                classify(*ty, cls, i, field_off);\n+                field_off += ty_size(*ty);\n             }\n         }\n     }\n@@ -283,7 +283,7 @@ fn llreg_ty(cls: ~[x86_64_reg_class]) -> TypeRef {\n     fn llvec_len(cls: ~[x86_64_reg_class]) -> uint {\n         let mut len = 1u;\n         for vec::each(cls) |c| {\n-            if c != sseup_class {\n+            if *c != sseup_class {\n                 break;\n             }\n             len += 1u;\n@@ -377,7 +377,7 @@ fn x86_64_tys(atys: ~[TypeRef],\n     let mut arg_tys = ~[];\n     let mut attrs = ~[];\n     for vec::each(atys) |t| {\n-        let (ty, attr) = x86_64_ty(t, is_pass_byval, ByValAttribute);\n+        let (ty, attr) = x86_64_ty(*t, is_pass_byval, ByValAttribute);\n         vec::push(arg_tys, ty);\n         vec::push(attrs, attr);\n     }\n@@ -410,7 +410,7 @@ fn decl_x86_64_fn(tys: x86_64_tys,\n     let fnty = T_fn(atys, rty);\n     let llfn = decl(fnty);\n \n-    do vec::iteri(tys.attrs) |i, a| {\n+    for vec::eachi(tys.attrs) |i, a| {\n         match a {\n             option::Some(attr) => {\n                 let llarg = get_param(llfn, i);\n@@ -640,7 +640,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n             let _icx = bcx.insn_ctxt(\"foreign::shim::build_ret\");\n             match tys.x86_64_tys {\n                 Some(x86_64) => {\n-                  do vec::iteri(x86_64.attrs) |i, a| {\n+                  for vec::eachi(x86_64.attrs) |i, a| {\n                         match a {\n                             Some(attr) => {\n                                 llvm::LLVMAddInstrAttribute(\n@@ -771,9 +771,9 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n               let tys = c_stack_tys(ccx, id);\n               if attr::attrs_contains_name(foreign_item.attrs,\n                                            ~\"rust_stack\") {\n-                  build_direct_fn(ccx, llwrapfn, foreign_item, tys, cc);\n+                  build_direct_fn(ccx, llwrapfn, *foreign_item, tys, cc);\n               } else {\n-                  let llshimfn = build_shim_fn(ccx, foreign_item, tys, cc);\n+                  let llshimfn = build_shim_fn(ccx, *foreign_item, tys, cc);\n                   build_wrap_fn(ccx, tys, llshimfn, llwrapfn);\n               }\n           } else {"}, {"sha": "d7a689c5c92b8e123deee9f6ddef02cfbb4977b1", "filename": "src/rustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -35,7 +35,7 @@ fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n         if method.tps.len() == 0u {\n             let llfn = get_item_val(ccx, method.id);\n             let path = vec::append_one(sub_path, path_name(method.ident));\n-            trans_method(ccx, path, method, None, llfn);\n+            trans_method(ccx, path, *method, None, llfn);\n         }\n     }\n }"}, {"sha": "fe5b1115ed89d1eb5d0a9ae148365ee1cfbc1899", "filename": "src/rustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -244,7 +244,7 @@ fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n         vec::map2(*bounds, substs, |bounds, subst| {\n             let mut v = ~[];\n             for vec::each(*bounds) |bound| {\n-                match bound {\n+                match *bound {\n                   ty::bound_trait(_) => {\n                     vec::push(v, meth::vtable_id(ccx, vts[i]));\n                     i += 1u;"}, {"sha": "d284cd840f12525826a47e0f71a4fb013106422e", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -54,7 +54,9 @@ fn traverse_exports(cx: ctx, vis: ~[@view_item]) -> bool {\n \n fn traverse_export(cx: ctx, exp_id: node_id) {\n     do option::iter(cx.exp_map.find(exp_id)) |defs| {\n-        for vec::each(defs) |def| { traverse_def_id(cx, def.id); }\n+        for vec::each(defs) |def| {\n+            traverse_def_id(cx, def.id);\n+        }\n     }\n }\n \n@@ -82,7 +84,9 @@ fn traverse_def_id(cx: ctx, did: def_id) {\n fn traverse_public_mod(cx: ctx, m: _mod) {\n     if !traverse_exports(cx, m.view_items) {\n         // No exports, so every local item is exported\n-        for vec::each(m.items) |item| { traverse_public_item(cx, item); }\n+        for vec::each(m.items) |item| {\n+            traverse_public_item(cx, *item);\n+        }\n     }\n }\n \n@@ -93,7 +97,9 @@ fn traverse_public_item(cx: ctx, item: @item) {\n       item_mod(m) => traverse_public_mod(cx, m),\n       item_foreign_mod(nm) => {\n           if !traverse_exports(cx, nm.view_items) {\n-              for vec::each(nm.items) |item| { cx.rmap.insert(item.id, ()); }\n+              for vec::each(nm.items) |item| {\n+                  cx.rmap.insert(item.id, ());\n+              }\n           }\n       }\n       item_fn(_, _, tps, blk) => {"}, {"sha": "44d4128b3885282480754a7a90b72abea259e61a", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -323,7 +323,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> ~[u8] {\n         ty::ty_tup(elts) => {\n             let mut s = ~[shape_struct], sub = ~[];\n             for vec::each(elts) |elt| {\n-                sub += shape_of(ccx, elt);\n+                sub += shape_of(ccx, *elt);\n             }\n             add_substr(s, sub);\n             s\n@@ -376,7 +376,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> ~[u8] {\n \n fn shape_of_variant(ccx: @crate_ctxt, v: ty::variant_info) -> ~[u8] {\n     let mut s = ~[];\n-    for vec::each(v.args) |t| { s += shape_of(ccx, t); }\n+    for vec::each(v.args) |t| { s += shape_of(ccx, *t); }\n     return s;\n }\n \n@@ -391,10 +391,10 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n     while i < ccx.shape_cx.tag_order.len() {\n         let {did, substs} = ccx.shape_cx.tag_order[i];\n         let variants = @ty::substd_enum_variants(ccx.tcx, did, &substs);\n-        do vec::iter(*variants) |v| {\n+        for vec::each(*variants) |v| {\n             offsets += ~[vec::len(data) as u16];\n \n-            let variant_shape = shape_of_variant(ccx, v);\n+            let variant_shape = shape_of_variant(ccx, *v);\n             add_substr(data, variant_shape);\n \n             let zname = str::to_bytes(ccx.sess.str_of(v.name)) + ~[0u8];\n@@ -435,7 +435,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n \n         let lv = largest_variants(ccx, variants);\n         add_u16(lv_table, vec::len(lv) as u16);\n-        for vec::each(lv) |v| { add_u16(lv_table, v as u16); }\n+        for vec::each(lv) |v| { add_u16(lv_table, *v as u16); }\n \n         // Determine whether the enum has dynamic size.\n         assert !vec::any(*variants, |v| {\n@@ -482,13 +482,13 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n             let mut bounded = true;\n             let mut min_size = 0u, min_align = 0u;\n             for vec::each(variant.args) |elem_t| {\n-                if ty::type_has_params(elem_t) {\n+                if ty::type_has_params(*elem_t) {\n                     // NB: We could do better here; this causes us to\n                     // conservatively assume that (int, T) has minimum size 0,\n                     // when in fact it has minimum size sizeof(int).\n                     bounded = false;\n                 } else {\n-                    let llty = type_of::type_of(ccx, elem_t);\n+                    let llty = type_of::type_of(ccx, *elem_t);\n                     min_size += llsize_of_real(ccx, llty);\n                     min_align += llalign_of_pref(ccx, llty);\n                 }\n@@ -553,8 +553,8 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n         for vec::each(largest_variants) |vid| {\n             // We increment a \"virtual data pointer\" to compute the size.\n             let mut lltys = ~[];\n-            for vec::each(variants[vid].args) |typ| {\n-                lltys += ~[type_of::type_of(ccx, typ)];\n+            for vec::each(variants[*vid].args) |typ| {\n+                lltys += ~[type_of::type_of(ccx, *typ)];\n             }\n \n             let llty = trans::common::T_struct(lltys);"}, {"sha": "8829257c33d84d8e8b2a3ba6d5a4924b622ac221", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -335,7 +335,7 @@ fn write_content(bcx: block,\n                         vec::push(temp_cleanups, lleltptr);\n                     }\n                     for vec::each(temp_cleanups) |cleanup| {\n-                        revoke_clean(bcx, cleanup);\n+                        revoke_clean(bcx, *cleanup);\n                     }\n                 }\n             }\n@@ -373,7 +373,7 @@ fn write_content(bcx: block,\n                     }\n \n                     for vec::each(temp_cleanups) |cleanup| {\n-                        revoke_clean(bcx, cleanup);\n+                        revoke_clean(bcx, *cleanup);\n                     }\n \n                     return bcx;"}, {"sha": "fa523a4ab9ef0993cc97c0d577197c504431da58", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -158,7 +158,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n       ty::ty_tup(elts) => {\n         let mut tys = ~[];\n         for vec::each(elts) |elt| {\n-            vec::push(tys, type_of(cx, elt));\n+            vec::push(tys, type_of(cx, *elt));\n         }\n         T_struct(tys)\n       }"}, {"sha": "ba99c8e396775fb175edd20542a42dc1f0d67362", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -118,7 +118,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n \n fn type_needs(cx: ctx, use_: uint, ty: ty::t) {\n     // Optimization -- don't descend type if all params already have this use\n-    for vec::each_mut_ref(cx.uses) |u| {\n+    for vec::each_mut(cx.uses) |u| {\n         if *u & use_ != use_ {\n             type_needs_inner(cx, use_, ty, @Nil);\n             return;\n@@ -144,7 +144,7 @@ fn type_needs_inner(cx: ctx, use_: uint, ty: ty::t,\n                     let seen = @Cons(did, enums_seen);\n                     for vec::each(*ty::enum_variants(cx.ccx.tcx, did)) |v| {\n                         for vec::each(v.args) |aty| {\n-                            let t = ty::subst(cx.ccx.tcx, &substs, aty);\n+                            let t = ty::subst(cx.ccx.tcx, &substs, *aty);\n                             type_needs_inner(cx, use_, t, seen);\n                         }\n                     }\n@@ -247,14 +247,16 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n         node_type_needs(cx, use_tydesc, val.id);\n       }\n       expr_call(f, _, _) => {\n-        vec::iter(ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx, f.id)), |a| {\n-            match a.mode {\n-              expl(by_move) | expl(by_copy) | expl(by_val) => {\n-                type_needs(cx, use_repr, a.ty);\n+          for vec::each(\n+              ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx, f.id))\n+          ) |a| {\n+              match a.mode {\n+                  expl(by_move) | expl(by_copy) | expl(by_val) => {\n+                      type_needs(cx, use_repr, a.ty);\n+                  }\n+                  _ => ()\n               }\n-              _ => ()\n-            }\n-        })\n+          }\n       }\n       expr_match(*) | expr_block(_) | expr_if(*) |\n       expr_while(*) | expr_fail(_) | expr_break(_) | expr_again(_) |"}, {"sha": "bae64f02fcc35a4996e68402df8deefbde822b0a", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -774,7 +774,7 @@ impl FnVid : to_bytes::IterBytes {\n fn param_bounds_to_kind(bounds: param_bounds) -> kind {\n     let mut kind = kind_noncopyable();\n     for vec::each(*bounds) |bound| {\n-        match bound {\n+        match *bound {\n           bound_copy => {\n             kind = raise_kind(kind, kind_implicitly_copyable());\n           }\n@@ -1615,9 +1615,9 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n          // Any class with a dtor needs a drop\n          option::is_some(ty_dtor(cx, did)) || {\n              for vec::each(ty::class_items_as_fields(cx, did, substs)) |f| {\n-             if type_needs_drop(cx, f.mt.ty) { accum = true; }\n-           }\n-           accum\n+                 if type_needs_drop(cx, f.mt.ty) { accum = true; }\n+             }\n+             accum\n          }\n       }\n       ty_tup(elts) => {\n@@ -2682,7 +2682,7 @@ pure fn hash_type_structure(st: &sty) -> uint {\n     }\n     pure fn hash_subtys(id: uint, subtys: ~[t]) -> uint {\n         let mut h = id;\n-        for vec::each(subtys) |s| { h = (h << 2u) + type_id(s) }\n+        for vec::each(subtys) |s| { h = (h << 2u) + type_id(*s) }\n         h\n     }\n     pure fn hash_substs(h: uint, substs: &substs) -> uint {"}, {"sha": "b9218c064f49af26ab6262e7b35c4d26f29bdd43", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -57,7 +57,6 @@ use std::smallintmap;\n use std::map;\n use std::map::{HashMap, int_hash};\n use std::serialization::{serialize_uint, deserialize_uint};\n-use vec::each;\n use syntax::print::pprust::*;\n use util::ppaux::{ty_to_str, tys_to_str, region_to_str,\n                   bound_region_to_str, vstore_to_str, expr_repr};"}, {"sha": "b37e8d5478906f90423f785633d914b81ac136e2", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -293,7 +293,7 @@ impl LookupContext {\n         let mut next_bound_idx = 0; // count only trait bounds\n         let bounds = tcx.ty_param_bounds.get(param_ty.def_id.node);\n         for vec::each(*bounds) |bound| {\n-            let bound_t = match bound {\n+            let bound_t = match *bound {\n                 ty::bound_trait(bound_t) => bound_t,\n \n                 ty::bound_copy | ty::bound_send |"}, {"sha": "f3aae4dad3daf9b06b3ded802a5353459f425c1c", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -49,7 +49,7 @@ fn lookup_vtables(fcx: @fn_ctxt,\n     let mut result = ~[], i = 0u;\n     for substs.tps.each |ty| {\n         for vec::each(*bounds[i]) |bound| {\n-            match bound {\n+            match *bound {\n               ty::bound_trait(i_ty) => {\n                 let i_ty = ty::subst(tcx, substs, i_ty);\n                 vec::push(result, lookup_vtable(fcx, expr, ty, i_ty,\n@@ -122,7 +122,7 @@ fn lookup_vtable(fcx: @fn_ctxt,\n         ty::ty_param({idx: n, def_id: did}) => {\n             let mut n_bound = 0;\n             for vec::each(*tcx.ty_param_bounds.get(did.node)) |bound| {\n-                match bound {\n+                match *bound {\n                     ty::bound_send | ty::bound_copy | ty::bound_const |\n                     ty::bound_owned => {\n                         /* ignore */\n@@ -215,7 +215,7 @@ fn lookup_vtable(fcx: @fn_ctxt,\n                         // unify it with trait_ty in order to get all\n                         // the ty vars sorted out.\n                         for vec::each(ty::impl_traits(tcx, im.did)) |of_ty| {\n-                            match ty::get(of_ty).sty {\n+                            match ty::get(*of_ty).sty {\n                                 ty::ty_trait(id, _, _) => {\n                                     // Not the trait we're looking for\n                                     if id != trait_id { loop; }\n@@ -271,8 +271,8 @@ fn lookup_vtable(fcx: @fn_ctxt,\n                             debug!(\"(checking vtable) @2 relating trait \\\n                                     ty %s to of_ty %s\",\n                                    fcx.infcx().ty_to_str(trait_ty),\n-                                   fcx.infcx().ty_to_str(of_ty));\n-                            let of_ty = ty::subst(tcx, &substs, of_ty);\n+                                   fcx.infcx().ty_to_str(*of_ty));\n+                            let of_ty = ty::subst(tcx, &substs, *of_ty);\n                             relate_trait_tys(fcx, expr, trait_ty, of_ty);\n \n                             // Recall that trait_ty -- the trait type"}, {"sha": "d7d6647e5bd6c360db694235014f986bac58d2cb", "filename": "src/rustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -137,20 +137,20 @@ fn visit_expr(e: @ast::expr, wbcx: wb_ctxt, v: wb_vt) {\n     match e.node {\n       ast::expr_fn(_, decl, _, _) |\n       ast::expr_fn_block(decl, _, _) => {\n-        do vec::iter(decl.inputs) |input| {\n-            let r_ty = resolve_type_vars_for_node(wbcx, e.span, input.id);\n-\n-            // Just in case we never constrained the mode to anything,\n-            // constrain it to the default for the type in question.\n-            match (r_ty, input.mode) {\n-              (Some(t), ast::infer(_)) => {\n-                let tcx = wbcx.fcx.ccx.tcx;\n-                let m_def = ty::default_arg_mode_for_ty(tcx, t);\n-                ty::set_default_mode(tcx, input.mode, m_def);\n+          for vec::each(decl.inputs) |input| {\n+              let r_ty = resolve_type_vars_for_node(wbcx, e.span, input.id);\n+\n+              // Just in case we never constrained the mode to anything,\n+              // constrain it to the default for the type in question.\n+              match (r_ty, input.mode) {\n+                  (Some(t), ast::infer(_)) => {\n+                      let tcx = wbcx.fcx.ccx.tcx;\n+                      let m_def = ty::default_arg_mode_for_ty(tcx, t);\n+                      ty::set_default_mode(tcx, input.mode, m_def);\n+                  }\n+                  _ => ()\n               }\n-              _ => ()\n-            }\n-        }\n+          }\n       }\n \n       ast::expr_binary(*) | ast::expr_unary(*) | ast::expr_assign_op(*)"}, {"sha": "ef557ebfa0d2086faee9969461953fc458b62500", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -363,7 +363,7 @@ fn check_methods_against_trait(ccx: @crate_ctxt,\n           Some({mty: impl_m, span, _}) => {\n             compare_impl_method(\n                 ccx.tcx, span, impl_m, vec::len(tps),\n-                trait_m, tpt.substs, selfty);\n+                *trait_m, tpt.substs, selfty);\n           }\n           None => {\n               // If we couldn't find an implementation for trait_m in"}, {"sha": "db79c07e71229fa914e624a3bb7ae48dd1c37111", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -314,8 +314,8 @@ fn write_desc(\n }\n \n fn write_sections(ctxt: Ctxt, sections: ~[doc::Section]) {\n-    do vec::iter(sections) |section| {\n-        write_section(ctxt, section);\n+    for vec::each(sections) |section| {\n+        write_section(ctxt, *section);\n     }\n }\n \n@@ -609,7 +609,9 @@ fn write_variants(\n \n     write_header_(ctxt, H4, ~\"Variants\");\n \n-    vec::iter(docs, |variant| write_variant(ctxt, variant) );\n+    for vec::each(docs) |variant| {\n+        write_variant(ctxt, *variant);\n+    }\n \n     ctxt.w.write_line(~\"\");\n }\n@@ -666,7 +668,9 @@ fn write_trait(ctxt: Ctxt, doc: doc::TraitDoc) {\n }\n \n fn write_methods(ctxt: Ctxt, docs: ~[doc::MethodDoc]) {\n-    do vec::iter(docs) |doc| { write_method(ctxt, doc) }\n+    for vec::each(docs) |doc| {\n+        write_method(ctxt, *doc);\n+    }\n }\n \n fn write_method(ctxt: Ctxt, doc: doc::MethodDoc) {"}, {"sha": "15ffbfc182ae5596f1e13b82adb8ba683f3b9afe", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -75,9 +75,12 @@ fn make_graph(N: uint, edges: ~[(node_id, node_id)]) -> graph {\n     };\n \n     do vec::each(edges) |e| {\n-        let (i, j) = e;\n-        map::set_add(graph[i], j);\n-        map::set_add(graph[j], i);\n+        match *e {\n+            (i, j) => {\n+                map::set_add(graph[i], j);\n+                map::set_add(graph[j], i);\n+            }\n+        }\n         true\n     }\n "}, {"sha": "0bae172f93c37162eab8e6477690c72bcd5b177b", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -73,7 +73,10 @@ fn run(args: &[~str]) {\n         server(from_parent, to_parent);\n     }\n \n-    vec::iter(worker_results, |r| { future::get(&r); } );\n+    for vec::each(worker_results) |r| {\n+        future::get(r);\n+    }\n+\n     //error!(\"sending stop message\");\n     to_child.send(stop);\n     move_out!(to_child);"}, {"sha": "b9be61edc21097a20f1f4a16436edcd42fc741b9", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -70,7 +70,10 @@ fn run(args: &[~str]) {\n         server(from_parent, to_parent);\n     }\n \n-    vec::iter(worker_results, |r| { future::get(&r); } );\n+    for vec::each(worker_results) |r| {\n+        future::get(r);\n+    }\n+\n     //error!(\"sending stop message\");\n     to_child.send(stop);\n     move_out!(to_child);"}, {"sha": "c19138acd284110174ef74fb1681d323cd3d84b8", "filename": "src/test/bench/msgsend.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Fbench%2Fmsgsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Fbench%2Fmsgsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -44,7 +44,9 @@ fn run(args: ~[~str]) {\n             }\n         };\n     }\n-    vec::iter(worker_results, |r| { future::get(&r); } );\n+    for vec::each(worker_results) |r| {\n+        future::get(r);\n+    }\n     comm::send(to_child, stop);\n     let result = comm::recv(from_child);\n     let end = std::time::precise_time_s();"}, {"sha": "3f8b44f8b9ee1a71f55cd1b3714a6fec1144ba33", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -9,8 +9,8 @@ fn print_complements() {\n     let all = ~[Blue, Red, Yellow];\n     for vec::each(all) |aa| {\n         for vec::each(all) |bb| {\n-            io::println(show_color(aa) + ~\" + \" + show_color(bb) +\n-                ~\" -> \" + show_color(transform(aa,bb)));\n+            io::println(show_color(*aa) + ~\" + \" + show_color(*bb) +\n+                ~\" -> \" + show_color(transform(*aa, *bb)));\n         }\n     }\n }\n@@ -171,7 +171,7 @@ fn rendezvous(nn: uint, set: ~[color]) {\n \n     // print each creature's stats\n     for vec::each(report) |rep| {\n-        io::println(rep);\n+        io::println(*rep);\n     }\n \n     // print the total number of creatures met"}, {"sha": "fb526ffd07fc82b0bcc90fa8c24be32ab3443a62", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -31,9 +31,9 @@ fn calc(children: uint, parent_ch: comm::Chan<msg>) {\n \n     match comm::recv(port) {\n         start => {\n-          do vec::iter (child_chs) |child_ch| {\n-              comm::send(child_ch, start);\n-          }\n+            for vec::each(child_chs) |child_ch| {\n+                comm::send(*child_ch, start);\n+            }\n         }\n         _ => fail ~\"task-perf-one-million failed (port not in start state)\"\n     }"}, {"sha": "1546ced962e101918d61196c094ccb2ed9c415fc", "filename": "src/test/compile-fail/borrowck-mut-vec-as-imm-slice-bad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -1,6 +1,6 @@\n fn want_slice(v: &[int]) -> int {\n     let mut sum = 0;\n-    for vec::each(v) |i| { sum += i; }\n+    for vec::each(v) |i| { sum += *i; }\n     return sum;\n }\n "}, {"sha": "02b7fb086003608506534a27f6e99ba8cc57af96", "filename": "src/test/compile-fail/issue-2151.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Fcompile-fail%2Fissue-2151.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Fcompile-fail%2Fissue-2151.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2151.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n-    do vec::iter(fail) |i| {\n+    for vec::each(fail) |i| {\n         log (debug, i * 2);\n         //~^ ERROR the type of this value must be known\n    };"}, {"sha": "aae67c1999deb975b9976dc166d0e731ae9eb44c", "filename": "src/test/compile-fail/liveness-issue-2163.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-issue-2163.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -1,5 +1,6 @@\n fn main() {\n     let a: ~[int] = ~[];\n-    vec::each(a, fn@(_x: int) -> bool { //~ ERROR not all control paths return a value\n+    vec::each(a, fn@(_x: &int) -> bool {\n+        //~^ ERROR not all control paths return a value\n     });\n }"}, {"sha": "b7a7f70d0a041019da839655071013ab7ecad82d", "filename": "src/test/compile-fail/vec-concat-bug.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -2,9 +2,9 @@ fn concat<T: Copy>(v: ~[const ~[const T]]) -> ~[T] {\n     let mut r = ~[];\n \n     // Earlier versions of our type checker accepted this:\n-    vec::iter(v, |&&inner: ~[T]| {\n+    vec::each(v, |inner: &~[T]| {\n         //~^ ERROR values differ in mutability\n-        r += inner;\n+        r += *inner; true\n     });\n \n     return r;"}, {"sha": "4652212ce5f4c028d50027cfb9b29e38a87c4945", "filename": "src/test/run-pass/assignability-trait.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassignability-trait.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -2,21 +2,23 @@\n // making method calls, but only if there aren't any matches without\n // it.\n \n-#[legacy_modes];\n-\n trait iterable<A> {\n-    fn iterate(blk: fn(A) -> bool);\n+    fn iterate(blk: fn(x: &A) -> bool);\n }\n \n impl<A> &[A]: iterable<A> {\n-    fn iterate(f: fn(A) -> bool) {\n-        vec::each(self, f);\n+    fn iterate(f: fn(x: &A) -> bool) {\n+        for vec::each(self) |e| {\n+            if !f(e) { break; }\n+        }\n     }\n }\n \n impl<A> ~[A]: iterable<A> {\n-    fn iterate(f: fn(A) -> bool) {\n-        vec::each(self, f);\n+    fn iterate(f: fn(x: &A) -> bool) {\n+        for vec::each(self) |e| {\n+            if !f(e) { break; }\n+        }\n     }\n }\n \n@@ -29,7 +31,7 @@ fn length<A, T: iterable<A>>(x: T) -> uint {\n fn main() {\n     let x = ~[0,1,2,3];\n     // Call a method\n-    for x.iterate() |y| { assert x[y] == y; }\n+    for x.iterate() |y| { assert x[*y] == *y; }\n     // Call a parameterized function\n     assert length(x) == vec::len(x);\n     // Call a parameterized function, with type arguments that require\n@@ -39,7 +41,7 @@ fn main() {\n     // Now try it with a type that *needs* to be borrowed\n     let z = [0,1,2,3]/_;\n     // Call a method\n-    for z.iterate() |y| { assert z[y] == y; }\n+    for z.iterate() |y| { assert z[*y] == *y; }\n     // Call a parameterized function\n     assert length::<int, &[int]>(z) == vec::len(z);\n }"}, {"sha": "aaea21c7e82eeab4ff1ac74bec27bc9aaf8256d7", "filename": "src/test/run-pass/auto-loop.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Frun-pass%2Fauto-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-loop.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -1,5 +1,7 @@\n fn main() {\n     let mut sum = 0;\n-    for vec::each(~[1, 2, 3, 4, 5]) |x| { sum += x; }\n+    for vec::each(~[1, 2, 3, 4, 5]) |x| {\n+        sum += *x;\n+    }\n     assert (sum == 15);\n }"}, {"sha": "6110fe9c3881654a8dd6eab5824ece3d190aa917", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -3,8 +3,8 @@ fn main() {\n     let v = ~[-1f, 0f, 1f, 2f, 3f];\n \n     // Statement form does not require parentheses:\n-    do vec::iter(v) |i| {\n-        log(info, i);\n+    for vec::each(v) |i| {\n+        log(info, *i);\n     }\n \n     // Usable at all:"}, {"sha": "26d8d6bbb736108ed33076d4fb639c857216a1f8", "filename": "src/test/run-pass/borrowck-mut-vec-as-imm-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -1,6 +1,6 @@\n fn want_slice(v: &[int]) -> int {\n     let mut sum = 0;\n-    for vec::each(v) |i| { sum += i; }\n+    for vec::each(v) |i| { sum += *i; }\n     return sum;\n }\n "}, {"sha": "57e72b43c0dfaf7e9eda5b2595418fddb2431c19", "filename": "src/test/run-pass/break.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Frun-pass%2Fbreak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Frun-pass%2Fbreak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbreak.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -7,7 +7,7 @@ fn main() {\n     loop { i += 1; if i == 20 { break; } }\n     assert (i == 20);\n     for vec::each(~[1, 2, 3, 4, 5, 6]) |x| {\n-        if x == 3 { break; } assert (x <= 3);\n+        if *x == 3 { break; } assert (*x <= 3);\n     }\n     i = 0;\n     while i < 10 { i += 1; if i % 2 == 0 { loop; } assert (i % 2 != 0); }\n@@ -17,7 +17,7 @@ fn main() {\n         if i >= 10 { break; }\n     }\n     for vec::each(~[1, 2, 3, 4, 5, 6]) |x| {\n-        if x % 2 == 0 { loop; }\n-        assert (x % 2 != 0);\n+        if *x % 2 == 0 { loop; }\n+        assert (*x % 2 != 0);\n     }\n }"}, {"sha": "84dabf5613337d28544118a6b8a5e1917fd73681", "filename": "src/test/run-pass/rcvr-borrowed-to-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cf271fe96b474d514b1052935db70c4056cf076/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs?ref=9cf271fe96b474d514b1052935db70c4056cf076", "patch": "@@ -6,7 +6,7 @@ trait sum {\n impl &[int]: sum {\n     fn sum() -> int {\n         let mut sum = 0;\n-        for vec::each(self) |e| { sum += e; }\n+        for vec::each(self) |e| { sum += *e; }\n         return sum;\n     }\n }"}]}