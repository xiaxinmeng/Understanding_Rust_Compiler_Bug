{"sha": "170d933d2f8a7d4787355a86136093af86b03077", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3MGQ5MzNkMmY4YTdkNDc4NzM1NWE4NjEzNjA5M2FmODZiMDMwNzc=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2019-07-06T19:52:15Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2019-08-16T15:11:18Z"}, "message": "Move constructors of boxed/rc\u2019ed slices to matching `impl` blocks", "tree": {"sha": "16944e63ddd8d3097c507e6210740e7a90b92fad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16944e63ddd8d3097c507e6210740e7a90b92fad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/170d933d2f8a7d4787355a86136093af86b03077", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/170d933d2f8a7d4787355a86136093af86b03077", "html_url": "https://github.com/rust-lang/rust/commit/170d933d2f8a7d4787355a86136093af86b03077", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/170d933d2f8a7d4787355a86136093af86b03077/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bde19240594c229a19ac928b823101965f4a0cd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/bde19240594c229a19ac928b823101965f4a0cd8", "html_url": "https://github.com/rust-lang/rust/commit/bde19240594c229a19ac928b823101965f4a0cd8"}], "stats": {"total": 206, "additions": 106, "deletions": 100}, "files": [{"sha": "6e296907ce8ae59fe76241d6d6efa644a27ad1b9", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/170d933d2f8a7d4787355a86136093af86b03077/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/170d933d2f8a7d4787355a86136093af86b03077/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=170d933d2f8a7d4787355a86136093af86b03077", "patch": "@@ -149,14 +149,24 @@ impl<T> Box<T> {\n         Box(unique.cast())\n     }\n \n+    /// Constructs a new `Pin<Box<T>>`. If `T` does not implement `Unpin`, then\n+    /// `x` will be pinned in memory and unable to be moved.\n+    #[stable(feature = \"pin\", since = \"1.33.0\")]\n+    #[inline(always)]\n+    pub fn pin(x: T) -> Pin<Box<T>> {\n+        (box x).into()\n+    }\n+}\n+\n+impl<T> Box<[T]> {\n     /// Construct a new boxed slice with uninitialized contents.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(new_uninit)]\n     ///\n-    /// let mut values = Box::<u32>::new_uninit_slice(3);\n+    /// let mut values = Box::<[u32]>::new_uninit_slice(3);\n     ///\n     /// let values = unsafe {\n     ///     // Deferred initialization:\n@@ -177,14 +187,6 @@ impl<T> Box<T> {\n         let slice = unsafe { slice::from_raw_parts_mut(unique.cast().as_ptr(), len) };\n         Box(Unique::from(slice))\n     }\n-\n-    /// Constructs a new `Pin<Box<T>>`. If `T` does not implement `Unpin`, then\n-    /// `x` will be pinned in memory and unable to be moved.\n-    #[stable(feature = \"pin\", since = \"1.33.0\")]\n-    #[inline(always)]\n-    pub fn pin(x: T) -> Pin<Box<T>> {\n-        (box x).into()\n-    }\n }\n \n impl<T> Box<mem::MaybeUninit<T>> {\n@@ -237,7 +239,7 @@ impl<T> Box<[mem::MaybeUninit<T>]> {\n     /// ```\n     /// #![feature(new_uninit)]\n     ///\n-    /// let mut values = Box::<u32>::new_uninit_slice(3);\n+    /// let mut values = Box::<[u32]>::new_uninit_slice(3);\n     ///\n     /// let values = unsafe {\n     ///     // Deferred initialization:"}, {"sha": "aa1268ec051162f9518ff79529eb68350bc01ebe", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 47, "deletions": 45, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/170d933d2f8a7d4787355a86136093af86b03077/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/170d933d2f8a7d4787355a86136093af86b03077/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=170d933d2f8a7d4787355a86136093af86b03077", "patch": "@@ -364,50 +364,6 @@ impl<T> Rc<T> {\n         }\n     }\n \n-    /// Construct a new reference-counted slice with uninitialized contents.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(new_uninit)]\n-    /// #![feature(get_mut_unchecked)]\n-    ///\n-    /// use std::rc::Rc;\n-    ///\n-    /// let mut values = Rc::<u32>::new_uninit_slice(3);\n-    ///\n-    /// let values = unsafe {\n-    ///     // Deferred initialization:\n-    ///     Rc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n-    ///     Rc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n-    ///     Rc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n-    ///\n-    ///     values.assume_init()\n-    /// };\n-    ///\n-    /// assert_eq!(*values, [1, 2, 3])\n-    /// ```\n-    #[unstable(feature = \"new_uninit\", issue = \"0\")]\n-    pub fn new_uninit_slice(len: usize) -> Rc<[mem::MaybeUninit<T>]> {\n-        let data_layout = Layout::array::<mem::MaybeUninit<T>>(len).unwrap();\n-        let (layout, offset) = Layout::new::<RcBox<()>>().extend(data_layout).unwrap();\n-        unsafe {\n-            let allocated_ptr = Global.alloc(layout)\n-                .unwrap_or_else(|_| handle_alloc_error(layout))\n-                .as_ptr();\n-            let data_ptr = allocated_ptr.add(offset) as *mut mem::MaybeUninit<T>;\n-            let slice: *mut [mem::MaybeUninit<T>] = from_raw_parts_mut(data_ptr, len);\n-            let wide_ptr = slice as *mut RcBox<[mem::MaybeUninit<T>]>;\n-            let wide_ptr = set_data_ptr(wide_ptr, allocated_ptr);\n-            ptr::write(&mut (*wide_ptr).strong, Cell::new(1));\n-            ptr::write(&mut (*wide_ptr).weak, Cell::new(1));\n-            Rc {\n-                ptr: NonNull::new_unchecked(wide_ptr),\n-                phantom: PhantomData,\n-            }\n-        }\n-    }\n-\n     /// Constructs a new `Pin<Rc<T>>`. If `T` does not implement `Unpin`, then\n     /// `value` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -458,6 +414,52 @@ impl<T> Rc<T> {\n     }\n }\n \n+impl<T> Rc<[T]> {\n+    /// Construct a new reference-counted slice with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut values = Rc::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Rc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n+    ///     Rc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n+    ///     Rc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"0\")]\n+    pub fn new_uninit_slice(len: usize) -> Rc<[mem::MaybeUninit<T>]> {\n+        let data_layout = Layout::array::<mem::MaybeUninit<T>>(len).unwrap();\n+        let (layout, offset) = Layout::new::<RcBox<()>>().extend(data_layout).unwrap();\n+        unsafe {\n+            let allocated_ptr = Global.alloc(layout)\n+                .unwrap_or_else(|_| handle_alloc_error(layout))\n+                .as_ptr();\n+            let data_ptr = allocated_ptr.add(offset) as *mut mem::MaybeUninit<T>;\n+            let slice: *mut [mem::MaybeUninit<T>] = from_raw_parts_mut(data_ptr, len);\n+            let wide_ptr = slice as *mut RcBox<[mem::MaybeUninit<T>]>;\n+            let wide_ptr = set_data_ptr(wide_ptr, allocated_ptr);\n+            ptr::write(&mut (*wide_ptr).strong, Cell::new(1));\n+            ptr::write(&mut (*wide_ptr).weak, Cell::new(1));\n+            Rc {\n+                ptr: NonNull::new_unchecked(wide_ptr),\n+                phantom: PhantomData,\n+            }\n+        }\n+    }\n+}\n+\n impl<T> Rc<mem::MaybeUninit<T>> {\n     /// Convert to `Rc<T>`.\n     ///\n@@ -519,7 +521,7 @@ impl<T> Rc<[mem::MaybeUninit<T>]> {\n     ///\n     /// use std::rc::Rc;\n     ///\n-    /// let mut values = Rc::<u32>::new_uninit_slice(3);\n+    /// let mut values = Rc::<[u32]>::new_uninit_slice(3);\n     ///\n     /// let values = unsafe {\n     ///     // Deferred initialization:"}, {"sha": "93441437e45f59fc30634bbf16fed6b1ce242560", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 47, "deletions": 45, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/170d933d2f8a7d4787355a86136093af86b03077/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/170d933d2f8a7d4787355a86136093af86b03077/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=170d933d2f8a7d4787355a86136093af86b03077", "patch": "@@ -348,50 +348,6 @@ impl<T> Arc<T> {\n         }\n     }\n \n-    /// Construct a new reference-counted slice with uninitialized contents.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(new_uninit)]\n-    /// #![feature(get_mut_unchecked)]\n-    ///\n-    /// use std::sync::Arc;\n-    ///\n-    /// let mut values = Arc::<u32>::new_uninit_slice(3);\n-    ///\n-    /// let values = unsafe {\n-    ///     // Deferred initialization:\n-    ///     Arc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n-    ///     Arc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n-    ///     Arc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n-    ///\n-    ///     values.assume_init()\n-    /// };\n-    ///\n-    /// assert_eq!(*values, [1, 2, 3])\n-    /// ```\n-    #[unstable(feature = \"new_uninit\", issue = \"0\")]\n-    pub fn new_uninit_slice(len: usize) -> Arc<[mem::MaybeUninit<T>]> {\n-        let data_layout = Layout::array::<mem::MaybeUninit<T>>(len).unwrap();\n-        let (layout, offset) = Layout::new::<ArcInner<()>>().extend(data_layout).unwrap();\n-        unsafe {\n-            let allocated_ptr = Global.alloc(layout)\n-                .unwrap_or_else(|_| handle_alloc_error(layout))\n-                .as_ptr();\n-            let data_ptr = allocated_ptr.add(offset) as *mut mem::MaybeUninit<T>;\n-            let slice: *mut [mem::MaybeUninit<T>] = from_raw_parts_mut(data_ptr, len);\n-            let wide_ptr = slice as *mut ArcInner<[mem::MaybeUninit<T>]>;\n-            let wide_ptr = set_data_ptr(wide_ptr, allocated_ptr);\n-            ptr::write(&mut (*wide_ptr).strong, atomic::AtomicUsize::new(1));\n-            ptr::write(&mut (*wide_ptr).weak, atomic::AtomicUsize::new(1));\n-            Arc {\n-                ptr: NonNull::new_unchecked(wide_ptr),\n-                phantom: PhantomData,\n-            }\n-        }\n-    }\n-\n     /// Constructs a new `Pin<Arc<T>>`. If `T` does not implement `Unpin`, then\n     /// `data` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -442,6 +398,52 @@ impl<T> Arc<T> {\n     }\n }\n \n+impl<T> Arc<[T]> {\n+    /// Construct a new reference-counted slice with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut values = Arc::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Arc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n+    ///     Arc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n+    ///     Arc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"0\")]\n+    pub fn new_uninit_slice(len: usize) -> Arc<[mem::MaybeUninit<T>]> {\n+        let data_layout = Layout::array::<mem::MaybeUninit<T>>(len).unwrap();\n+        let (layout, offset) = Layout::new::<ArcInner<()>>().extend(data_layout).unwrap();\n+        unsafe {\n+            let allocated_ptr = Global.alloc(layout)\n+                .unwrap_or_else(|_| handle_alloc_error(layout))\n+                .as_ptr();\n+            let data_ptr = allocated_ptr.add(offset) as *mut mem::MaybeUninit<T>;\n+            let slice: *mut [mem::MaybeUninit<T>] = from_raw_parts_mut(data_ptr, len);\n+            let wide_ptr = slice as *mut ArcInner<[mem::MaybeUninit<T>]>;\n+            let wide_ptr = set_data_ptr(wide_ptr, allocated_ptr);\n+            ptr::write(&mut (*wide_ptr).strong, atomic::AtomicUsize::new(1));\n+            ptr::write(&mut (*wide_ptr).weak, atomic::AtomicUsize::new(1));\n+            Arc {\n+                ptr: NonNull::new_unchecked(wide_ptr),\n+                phantom: PhantomData,\n+            }\n+        }\n+    }\n+}\n+\n impl<T> Arc<mem::MaybeUninit<T>> {\n     /// Convert to `Arc<T>`.\n     ///\n@@ -503,7 +505,7 @@ impl<T> Arc<[mem::MaybeUninit<T>]> {\n     ///\n     /// use std::sync::Arc;\n     ///\n-    /// let mut values = Arc::<u32>::new_uninit_slice(3);\n+    /// let mut values = Arc::<[u32]>::new_uninit_slice(3);\n     ///\n     /// let values = unsafe {\n     ///     // Deferred initialization:"}]}