{"sha": "4867968d22899395e6551f22641b3617e995140c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4Njc5NjhkMjI4OTkzOTVlNjU1MWYyMjY0MWIzNjE3ZTk5NTE0MGM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-05-06T16:45:35Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-05-07T14:27:54Z"}, "message": "Refactor assists API to be more convenient for adding new assists\n\nIt now duplicates completion API in its shape.", "tree": {"sha": "4f3ab3a70fbbb901ccec3cd162da00eaa9cbad09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f3ab3a70fbbb901ccec3cd162da00eaa9cbad09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4867968d22899395e6551f22641b3617e995140c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4867968d22899395e6551f22641b3617e995140c", "html_url": "https://github.com/rust-lang/rust/commit/4867968d22899395e6551f22641b3617e995140c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4867968d22899395e6551f22641b3617e995140c/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4cd75ac06dff7f5a95065a6c3868669e5c2ab27", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4cd75ac06dff7f5a95065a6c3868669e5c2ab27", "html_url": "https://github.com/rust-lang/rust/commit/f4cd75ac06dff7f5a95065a6c3868669e5c2ab27"}], "stats": {"total": 1114, "additions": 521, "deletions": 593}, "files": [{"sha": "203ad1273865d31d436806faf53066118314b145", "filename": "crates/ra_assists/src/assist_context.rs", "status": "renamed", "additions": 112, "deletions": 147, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fassist_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fassist_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_context.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -1,4 +1,6 @@\n-//! This module defines `AssistCtx` -- the API surface that is exposed to assists.\n+//! See `AssistContext`\n+\n+use algo::find_covering_element;\n use hir::Semantics;\n use ra_db::{FileId, FileRange};\n use ra_fmt::{leading_indent, reindent};\n@@ -7,54 +9,25 @@ use ra_ide_db::{\n     RootDatabase,\n };\n use ra_syntax::{\n-    algo::{self, find_covering_element, find_node_at_offset, SyntaxRewriter},\n+    algo::{self, find_node_at_offset, SyntaxRewriter},\n     AstNode, SourceFile, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken, TextRange, TextSize,\n     TokenAtOffset,\n };\n use ra_text_edit::TextEditBuilder;\n \n use crate::{AssistId, AssistLabel, GroupLabel, ResolvedAssist};\n \n-#[derive(Clone, Debug)]\n-pub(crate) struct Assist(pub(crate) Vec<AssistInfo>);\n-\n-#[derive(Clone, Debug)]\n-pub(crate) struct AssistInfo {\n-    pub(crate) label: AssistLabel,\n-    pub(crate) group_label: Option<GroupLabel>,\n-    pub(crate) source_change: Option<SourceChange>,\n-}\n-\n-impl AssistInfo {\n-    fn new(label: AssistLabel) -> AssistInfo {\n-        AssistInfo { label, group_label: None, source_change: None }\n-    }\n-\n-    fn resolved(self, source_change: SourceChange) -> AssistInfo {\n-        AssistInfo { source_change: Some(source_change), ..self }\n-    }\n-\n-    fn with_group(self, group_label: GroupLabel) -> AssistInfo {\n-        AssistInfo { group_label: Some(group_label), ..self }\n-    }\n-\n-    pub(crate) fn into_resolved(self) -> Option<ResolvedAssist> {\n-        let label = self.label;\n-        self.source_change.map(|source_change| ResolvedAssist { label, source_change })\n-    }\n-}\n-\n-/// `AssistCtx` allows to apply an assist or check if it could be applied.\n+/// `AssistContext` allows to apply an assist or check if it could be applied.\n ///\n-/// Assists use a somewhat over-engineered approach, given the current needs. The\n-/// assists workflow consists of two phases. In the first phase, a user asks for\n-/// the list of available assists. In the second phase, the user picks a\n+/// Assists use a somewhat over-engineered approach, given the current needs.\n+/// The assists workflow consists of two phases. In the first phase, a user asks\n+/// for the list of available assists. In the second phase, the user picks a\n /// particular assist and it gets applied.\n ///\n /// There are two peculiarities here:\n ///\n-/// * first, we ideally avoid computing more things then necessary to answer\n-///   \"is assist applicable\" in the first phase.\n+/// * first, we ideally avoid computing more things then necessary to answer \"is\n+///   assist applicable\" in the first phase.\n /// * second, when we are applying assist, we don't have a guarantee that there\n ///   weren't any changes between the point when user asked for assists and when\n ///   they applied a particular assist. So, when applying assist, we need to do\n@@ -63,152 +36,158 @@ impl AssistInfo {\n /// To avoid repeating the same code twice for both \"check\" and \"apply\"\n /// functions, we use an approach reminiscent of that of Django's function based\n /// views dealing with forms. Each assist receives a runtime parameter,\n-/// `should_compute_edit`. It first check if an edit is applicable (potentially\n-/// computing info required to compute the actual edit). If it is applicable,\n-/// and `should_compute_edit` is `true`, it then computes the actual edit.\n+/// `resolve`. It first check if an edit is applicable (potentially computing\n+/// info required to compute the actual edit). If it is applicable, and\n+/// `resolve` is `true`, it then computes the actual edit.\n ///\n /// So, to implement the original assists workflow, we can first apply each edit\n-/// with `should_compute_edit = false`, and then applying the selected edit\n-/// again, with `should_compute_edit = true` this time.\n+/// with `resolve = false`, and then applying the selected edit again, with\n+/// `resolve = true` this time.\n ///\n /// Note, however, that we don't actually use such two-phase logic at the\n /// moment, because the LSP API is pretty awkward in this place, and it's much\n /// easier to just compute the edit eagerly :-)\n-#[derive(Clone)]\n-pub(crate) struct AssistCtx<'a> {\n-    pub(crate) sema: &'a Semantics<'a, RootDatabase>,\n-    pub(crate) db: &'a RootDatabase,\n+pub(crate) struct AssistContext<'a> {\n+    pub(crate) sema: Semantics<'a, RootDatabase>,\n+    pub(super) db: &'a RootDatabase,\n     pub(crate) frange: FileRange,\n     source_file: SourceFile,\n-    should_compute_edit: bool,\n }\n \n-impl<'a> AssistCtx<'a> {\n-    pub fn new(\n-        sema: &'a Semantics<'a, RootDatabase>,\n-        frange: FileRange,\n-        should_compute_edit: bool,\n-    ) -> AssistCtx<'a> {\n+impl<'a> AssistContext<'a> {\n+    pub fn new(sema: Semantics<'a, RootDatabase>, frange: FileRange) -> AssistContext<'a> {\n         let source_file = sema.parse(frange.file_id);\n-        AssistCtx { sema, db: sema.db, frange, source_file, should_compute_edit }\n+        let db = sema.db;\n+        AssistContext { sema, db, frange, source_file }\n     }\n \n-    pub(crate) fn add_assist(\n-        self,\n-        id: AssistId,\n-        label: impl Into<String>,\n-        target: TextRange,\n-        f: impl FnOnce(&mut ActionBuilder),\n-    ) -> Option<Assist> {\n-        let label = AssistLabel::new(id, label.into(), None, target);\n-        let change_label = label.label.clone();\n-        let mut info = AssistInfo::new(label);\n-        if self.should_compute_edit {\n-            let source_change = {\n-                let mut edit = ActionBuilder::new(&self);\n-                f(&mut edit);\n-                edit.build(change_label)\n-            };\n-            info = info.resolved(source_change)\n-        };\n-\n-        Some(Assist(vec![info]))\n-    }\n-\n-    pub(crate) fn add_assist_group(self, group_name: impl Into<String>) -> AssistGroup<'a> {\n-        let group = GroupLabel(group_name.into());\n-        AssistGroup { ctx: self, group, assists: Vec::new() }\n+    // NB, this ignores active selection.\n+    pub(crate) fn offset(&self) -> TextSize {\n+        self.frange.range.start()\n     }\n \n     pub(crate) fn token_at_offset(&self) -> TokenAtOffset<SyntaxToken> {\n-        self.source_file.syntax().token_at_offset(self.frange.range.start())\n+        self.source_file.syntax().token_at_offset(self.offset())\n     }\n-\n     pub(crate) fn find_token_at_offset(&self, kind: SyntaxKind) -> Option<SyntaxToken> {\n         self.token_at_offset().find(|it| it.kind() == kind)\n     }\n-\n     pub(crate) fn find_node_at_offset<N: AstNode>(&self) -> Option<N> {\n-        find_node_at_offset(self.source_file.syntax(), self.frange.range.start())\n+        find_node_at_offset(self.source_file.syntax(), self.offset())\n     }\n-\n     pub(crate) fn find_node_at_offset_with_descend<N: AstNode>(&self) -> Option<N> {\n         self.sema\n             .find_node_at_offset_with_descend(self.source_file.syntax(), self.frange.range.start())\n     }\n-\n     pub(crate) fn covering_element(&self) -> SyntaxElement {\n         find_covering_element(self.source_file.syntax(), self.frange.range)\n     }\n+    // FIXME: remove\n     pub(crate) fn covering_node_for_range(&self, range: TextRange) -> SyntaxElement {\n         find_covering_element(self.source_file.syntax(), range)\n     }\n }\n \n-pub(crate) struct AssistGroup<'a> {\n-    ctx: AssistCtx<'a>,\n-    group: GroupLabel,\n-    assists: Vec<AssistInfo>,\n+pub(crate) struct Assists {\n+    resolve: bool,\n+    file: FileId,\n+    buf: Vec<(AssistLabel, Option<SourceChange>)>,\n }\n \n-impl<'a> AssistGroup<'a> {\n-    pub(crate) fn add_assist(\n+impl Assists {\n+    pub(crate) fn new_resolved(ctx: &AssistContext) -> Assists {\n+        Assists { resolve: true, file: ctx.frange.file_id, buf: Vec::new() }\n+    }\n+    pub(crate) fn new_unresolved(ctx: &AssistContext) -> Assists {\n+        Assists { resolve: false, file: ctx.frange.file_id, buf: Vec::new() }\n+    }\n+\n+    pub(crate) fn finish_unresolved(self) -> Vec<AssistLabel> {\n+        assert!(!self.resolve);\n+        self.finish()\n+            .into_iter()\n+            .map(|(label, edit)| {\n+                assert!(edit.is_none());\n+                label\n+            })\n+            .collect()\n+    }\n+\n+    pub(crate) fn finish_resolved(self) -> Vec<ResolvedAssist> {\n+        assert!(self.resolve);\n+        self.finish()\n+            .into_iter()\n+            .map(|(label, edit)| ResolvedAssist { label, source_change: edit.unwrap() })\n+            .collect()\n+    }\n+\n+    pub(crate) fn add(\n         &mut self,\n         id: AssistId,\n         label: impl Into<String>,\n         target: TextRange,\n-        f: impl FnOnce(&mut ActionBuilder),\n-    ) {\n-        let label = AssistLabel::new(id, label.into(), Some(self.group.clone()), target);\n+        f: impl FnOnce(&mut AssistBuilder),\n+    ) -> Option<()> {\n+        let label = AssistLabel::new(id, label.into(), None, target);\n+        self.add_impl(label, f)\n+    }\n+    pub(crate) fn add_group(\n+        &mut self,\n+        group: &GroupLabel,\n+        id: AssistId,\n+        label: impl Into<String>,\n+        target: TextRange,\n+        f: impl FnOnce(&mut AssistBuilder),\n+    ) -> Option<()> {\n+        let label = AssistLabel::new(id, label.into(), Some(group.clone()), target);\n+        self.add_impl(label, f)\n+    }\n+    fn add_impl(&mut self, label: AssistLabel, f: impl FnOnce(&mut AssistBuilder)) -> Option<()> {\n         let change_label = label.label.clone();\n-        let mut info = AssistInfo::new(label).with_group(self.group.clone());\n-        if self.ctx.should_compute_edit {\n-            let source_change = {\n-                let mut edit = ActionBuilder::new(&self.ctx);\n-                f(&mut edit);\n-                edit.build(change_label)\n-            };\n-            info = info.resolved(source_change)\n+        let source_change = if self.resolve {\n+            let mut builder = AssistBuilder::new(self.file);\n+            f(&mut builder);\n+            Some(builder.finish(change_label))\n+        } else {\n+            None\n         };\n \n-        self.assists.push(info)\n+        self.buf.push((label, source_change));\n+        Some(())\n     }\n \n-    pub(crate) fn finish(self) -> Option<Assist> {\n-        if self.assists.is_empty() {\n-            None\n-        } else {\n-            Some(Assist(self.assists))\n-        }\n+    fn finish(mut self) -> Vec<(AssistLabel, Option<SourceChange>)> {\n+        self.buf.sort_by_key(|(label, _edit)| label.target.len());\n+        self.buf\n     }\n }\n \n-pub(crate) struct ActionBuilder<'a, 'b> {\n+pub(crate) struct AssistBuilder {\n     edit: TextEditBuilder,\n     cursor_position: Option<TextSize>,\n     file: FileId,\n-    ctx: &'a AssistCtx<'b>,\n }\n \n-impl<'a, 'b> ActionBuilder<'a, 'b> {\n-    fn new(ctx: &'a AssistCtx<'b>) -> Self {\n-        Self {\n-            edit: TextEditBuilder::default(),\n-            cursor_position: None,\n-            file: ctx.frange.file_id,\n-            ctx,\n-        }\n+impl AssistBuilder {\n+    pub(crate) fn new(file: FileId) -> AssistBuilder {\n+        AssistBuilder { edit: TextEditBuilder::default(), cursor_position: None, file }\n     }\n \n-    pub(crate) fn ctx(&self) -> &AssistCtx<'b> {\n-        &self.ctx\n+    /// Remove specified `range` of text.\n+    pub(crate) fn delete(&mut self, range: TextRange) {\n+        self.edit.delete(range)\n+    }\n+    /// Append specified `text` at the given `offset`\n+    pub(crate) fn insert(&mut self, offset: TextSize, text: impl Into<String>) {\n+        self.edit.insert(offset, text.into())\n     }\n-\n     /// Replaces specified `range` of text with a given string.\n     pub(crate) fn replace(&mut self, range: TextRange, replace_with: impl Into<String>) {\n         self.edit.replace(range, replace_with.into())\n     }\n-\n+    pub(crate) fn replace_ast<N: AstNode>(&mut self, old: N, new: N) {\n+        algo::diff(old.syntax(), new.syntax()).into_text_edit(&mut self.edit)\n+    }\n     /// Replaces specified `node` of text with a given string, reindenting the\n     /// string to maintain `node`'s existing indent.\n     // FIXME: remove in favor of ra_syntax::edit::IndentLevel::increase_indent\n@@ -223,42 +202,28 @@ impl<'a, 'b> ActionBuilder<'a, 'b> {\n         }\n         self.replace(node.text_range(), replace_with)\n     }\n-\n-    /// Remove specified `range` of text.\n-    #[allow(unused)]\n-    pub(crate) fn delete(&mut self, range: TextRange) {\n-        self.edit.delete(range)\n-    }\n-\n-    /// Append specified `text` at the given `offset`\n-    pub(crate) fn insert(&mut self, offset: TextSize, text: impl Into<String>) {\n-        self.edit.insert(offset, text.into())\n+    pub(crate) fn rewrite(&mut self, rewriter: SyntaxRewriter) {\n+        let node = rewriter.rewrite_root().unwrap();\n+        let new = rewriter.rewrite(&node);\n+        algo::diff(&node, &new).into_text_edit(&mut self.edit)\n     }\n \n     /// Specify desired position of the cursor after the assist is applied.\n     pub(crate) fn set_cursor(&mut self, offset: TextSize) {\n         self.cursor_position = Some(offset)\n     }\n+    // FIXME: better API\n+    pub(crate) fn set_file(&mut self, assist_file: FileId) {\n+        self.file = assist_file;\n+    }\n \n+    // FIXME: kill this API\n     /// Get access to the raw `TextEditBuilder`.\n     pub(crate) fn text_edit_builder(&mut self) -> &mut TextEditBuilder {\n         &mut self.edit\n     }\n \n-    pub(crate) fn replace_ast<N: AstNode>(&mut self, old: N, new: N) {\n-        algo::diff(old.syntax(), new.syntax()).into_text_edit(&mut self.edit)\n-    }\n-    pub(crate) fn rewrite(&mut self, rewriter: SyntaxRewriter) {\n-        let node = rewriter.rewrite_root().unwrap();\n-        let new = rewriter.rewrite(&node);\n-        algo::diff(&node, &new).into_text_edit(&mut self.edit)\n-    }\n-\n-    pub(crate) fn set_file(&mut self, assist_file: FileId) {\n-        self.file = assist_file;\n-    }\n-\n-    fn build(self, change_label: String) -> SourceChange {\n+    fn finish(self, change_label: String) -> SourceChange {\n         let edit = self.edit.finish();\n         if edit.is_empty() && self.cursor_position.is_none() {\n             panic!(\"Only call `add_assist` if the assist can be applied\")", "previous_filename": "crates/ra_assists/src/assist_ctx.rs"}, {"sha": "795a225a4d8fc43ab12043c7ad40207a4ce370bf", "filename": "crates/ra_assists/src/handlers/add_custom_impl.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -6,7 +6,10 @@ use ra_syntax::{\n };\n use stdx::SepBy;\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    AssistId,\n+};\n \n // Assist: add_custom_impl\n //\n@@ -25,7 +28,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //\n // }\n // ```\n-pub(crate) fn add_custom_impl(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_custom_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let input = ctx.find_node_at_offset::<ast::AttrInput>()?;\n     let attr = input.syntax().parent().and_then(ast::Attr::cast)?;\n \n@@ -49,7 +52,7 @@ pub(crate) fn add_custom_impl(ctx: AssistCtx) -> Option<Assist> {\n         format!(\"Add custom impl '{}' for '{}'\", trait_token.text().as_str(), annotated_name);\n \n     let target = attr.syntax().text_range();\n-    ctx.add_assist(AssistId(\"add_custom_impl\"), label, target, |edit| {\n+    acc.add(AssistId(\"add_custom_impl\"), label, target, |edit| {\n         let new_attr_input = input\n             .syntax()\n             .descendants_with_tokens()"}, {"sha": "fb08c19e936145203eeb5955848434ce96d2a4bb", "filename": "crates/ra_assists/src/handlers/add_derive.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_derive.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -4,7 +4,7 @@ use ra_syntax::{\n     TextSize,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: add_derive\n //\n@@ -24,11 +24,11 @@ use crate::{Assist, AssistCtx, AssistId};\n //     y: u32,\n // }\n // ```\n-pub(crate) fn add_derive(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_derive(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let nominal = ctx.find_node_at_offset::<ast::NominalDef>()?;\n     let node_start = derive_insertion_offset(&nominal)?;\n     let target = nominal.syntax().text_range();\n-    ctx.add_assist(AssistId(\"add_derive\"), \"Add `#[derive]`\", target, |edit| {\n+    acc.add(AssistId(\"add_derive\"), \"Add `#[derive]`\", target, |edit| {\n         let derive_attr = nominal\n             .attrs()\n             .filter_map(|x| x.as_simple_call())\n@@ -57,9 +57,10 @@ fn derive_insertion_offset(nominal: &ast::NominalDef) -> Option<TextSize> {\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n     use crate::tests::{check_assist, check_assist_target};\n \n+    use super::*;\n+\n     #[test]\n     fn add_derive_new() {\n         check_assist("}, {"sha": "55409e5013c6300c04740449caae2223d0d24c22", "filename": "crates/ra_assists/src/handlers/add_explicit_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -4,7 +4,7 @@ use ra_syntax::{\n     TextRange,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: add_explicit_type\n //\n@@ -21,7 +21,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     let x: i32 = 92;\n // }\n // ```\n-pub(crate) fn add_explicit_type(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_explicit_type(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let stmt = ctx.find_node_at_offset::<LetStmt>()?;\n     let expr = stmt.initializer()?;\n     let pat = stmt.pat()?;\n@@ -59,7 +59,7 @@ pub(crate) fn add_explicit_type(ctx: AssistCtx) -> Option<Assist> {\n \n     let db = ctx.db;\n     let new_type_string = ty.display_truncated(db, None).to_string();\n-    ctx.add_assist(\n+    acc.add(\n         AssistId(\"add_explicit_type\"),\n         format!(\"Insert explicit type '{}'\", new_type_string),\n         pat_range,"}, {"sha": "275184e2466ca0db33f98bc1a6aa024fad83b1fb", "filename": "crates/ra_assists/src/handlers/add_from_impl_for_enum.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -4,10 +4,10 @@ use ra_syntax::{\n     TextSize,\n };\n use stdx::format_to;\n-\n-use crate::{utils::FamousDefs, Assist, AssistCtx, AssistId};\n use test_utils::tested_by;\n \n+use crate::{utils::FamousDefs, AssistContext, AssistId, Assists};\n+\n // Assist add_from_impl_for_enum\n //\n // Adds a From impl for an enum variant with one tuple field\n@@ -25,7 +25,7 @@ use test_utils::tested_by;\n //     }\n // }\n // ```\n-pub(crate) fn add_from_impl_for_enum(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_from_impl_for_enum(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let variant = ctx.find_node_at_offset::<ast::EnumVariant>()?;\n     let variant_name = variant.name()?;\n     let enum_name = variant.parent_enum().name()?;\n@@ -42,13 +42,13 @@ pub(crate) fn add_from_impl_for_enum(ctx: AssistCtx) -> Option<Assist> {\n         _ => return None,\n     };\n \n-    if existing_from_impl(ctx.sema, &variant).is_some() {\n+    if existing_from_impl(&ctx.sema, &variant).is_some() {\n         tested_by!(test_add_from_impl_already_exists);\n         return None;\n     }\n \n     let target = variant.syntax().text_range();\n-    ctx.add_assist(\n+    acc.add(\n         AssistId(\"add_from_impl_for_enum\"),\n         \"Add From impl for this enum variant\",\n         target,"}, {"sha": "6b5616aa9c8d7816e6f07d9e095cc961ec744a74", "filename": "crates/ra_assists/src/handlers/add_function.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -1,14 +1,13 @@\n+use hir::HirDisplay;\n+use ra_db::FileId;\n use ra_syntax::{\n-    ast::{self, AstNode},\n+    ast::{self, edit::IndentLevel, ArgListOwner, AstNode, ModuleItemOwner},\n     SyntaxKind, SyntaxNode, TextSize,\n };\n-\n-use crate::{Assist, AssistCtx, AssistId};\n-use ast::{edit::IndentLevel, ArgListOwner, ModuleItemOwner};\n-use hir::HirDisplay;\n-use ra_db::FileId;\n use rustc_hash::{FxHashMap, FxHashSet};\n \n+use crate::{AssistContext, AssistId, Assists};\n+\n // Assist: add_function\n //\n // Adds a stub function with a signature matching the function under the cursor.\n@@ -34,7 +33,7 @@ use rustc_hash::{FxHashMap, FxHashSet};\n // }\n //\n // ```\n-pub(crate) fn add_function(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let path_expr: ast::PathExpr = ctx.find_node_at_offset()?;\n     let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n     let path = path_expr.path()?;\n@@ -59,7 +58,7 @@ pub(crate) fn add_function(ctx: AssistCtx) -> Option<Assist> {\n     let function_builder = FunctionBuilder::from_call(&ctx, &call, &path, target_module)?;\n \n     let target = call.syntax().text_range();\n-    ctx.add_assist(AssistId(\"add_function\"), \"Add function\", target, |edit| {\n+    acc.add(AssistId(\"add_function\"), \"Add function\", target, |edit| {\n         let function_template = function_builder.render();\n         edit.set_file(function_template.file);\n         edit.set_cursor(function_template.cursor_offset);\n@@ -87,7 +86,7 @@ impl FunctionBuilder {\n     /// Prepares a generated function that matches `call` in `generate_in`\n     /// (or as close to `call` as possible, if `generate_in` is `None`)\n     fn from_call(\n-        ctx: &AssistCtx,\n+        ctx: &AssistContext,\n         call: &ast::CallExpr,\n         path: &ast::Path,\n         target_module: Option<hir::InFile<hir::ModuleSource>>,\n@@ -152,7 +151,7 @@ fn fn_name(call: &ast::Path) -> Option<ast::Name> {\n \n /// Computes the type variables and arguments required for the generated function\n fn fn_args(\n-    ctx: &AssistCtx,\n+    ctx: &AssistContext,\n     call: &ast::CallExpr,\n ) -> Option<(Option<ast::TypeParamList>, ast::ParamList)> {\n     let mut arg_names = Vec::new();\n@@ -219,7 +218,7 @@ fn fn_arg_name(fn_arg: &ast::Expr) -> Option<String> {\n     }\n }\n \n-fn fn_arg_type(ctx: &AssistCtx, fn_arg: &ast::Expr) -> Option<String> {\n+fn fn_arg_type(ctx: &AssistContext, fn_arg: &ast::Expr) -> Option<String> {\n     let ty = ctx.sema.type_of_expr(fn_arg)?;\n     if ty.is_unknown() {\n         return None;"}, {"sha": "df114a0d84dd40cfc9791ca3c5760834e6fc7e81", "filename": "crates/ra_assists/src/handlers/add_impl.rs", "status": "modified", "additions": 27, "deletions": 34, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_impl.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -4,7 +4,7 @@ use ra_syntax::{\n };\n use stdx::{format_to, SepBy};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: add_impl\n //\n@@ -25,43 +25,36 @@ use crate::{Assist, AssistCtx, AssistId};\n //\n // }\n // ```\n-pub(crate) fn add_impl(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let nominal = ctx.find_node_at_offset::<ast::NominalDef>()?;\n     let name = nominal.name()?;\n     let target = nominal.syntax().text_range();\n-    ctx.add_assist(\n-        AssistId(\"add_impl\"),\n-        format!(\"Implement {}\", name.text().as_str()),\n-        target,\n-        |edit| {\n-            let type_params = nominal.type_param_list();\n-            let start_offset = nominal.syntax().text_range().end();\n-            let mut buf = String::new();\n-            buf.push_str(\"\\n\\nimpl\");\n-            if let Some(type_params) = &type_params {\n-                format_to!(buf, \"{}\", type_params.syntax());\n-            }\n-            buf.push_str(\" \");\n-            buf.push_str(name.text().as_str());\n-            if let Some(type_params) = type_params {\n-                let lifetime_params = type_params\n-                    .lifetime_params()\n-                    .filter_map(|it| it.lifetime_token())\n-                    .map(|it| it.text().clone());\n-                let type_params = type_params\n-                    .type_params()\n-                    .filter_map(|it| it.name())\n-                    .map(|it| it.text().clone());\n+    acc.add(AssistId(\"add_impl\"), format!(\"Implement {}\", name.text().as_str()), target, |edit| {\n+        let type_params = nominal.type_param_list();\n+        let start_offset = nominal.syntax().text_range().end();\n+        let mut buf = String::new();\n+        buf.push_str(\"\\n\\nimpl\");\n+        if let Some(type_params) = &type_params {\n+            format_to!(buf, \"{}\", type_params.syntax());\n+        }\n+        buf.push_str(\" \");\n+        buf.push_str(name.text().as_str());\n+        if let Some(type_params) = type_params {\n+            let lifetime_params = type_params\n+                .lifetime_params()\n+                .filter_map(|it| it.lifetime_token())\n+                .map(|it| it.text().clone());\n+            let type_params =\n+                type_params.type_params().filter_map(|it| it.name()).map(|it| it.text().clone());\n \n-                let generic_params = lifetime_params.chain(type_params).sep_by(\", \");\n-                format_to!(buf, \"<{}>\", generic_params)\n-            }\n-            buf.push_str(\" {\\n\");\n-            edit.set_cursor(start_offset + TextSize::of(&buf));\n-            buf.push_str(\"\\n}\");\n-            edit.insert(start_offset, buf);\n-        },\n-    )\n+            let generic_params = lifetime_params.chain(type_params).sep_by(\", \");\n+            format_to!(buf, \"<{}>\", generic_params)\n+        }\n+        buf.push_str(\" {\\n\");\n+        edit.set_cursor(start_offset + TextSize::of(&buf));\n+        buf.push_str(\"\\n}\");\n+        edit.insert(start_offset, buf);\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "3482a75bfcfb2299f313bf6eb01e346a98953888", "filename": "crates/ra_assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -9,9 +9,10 @@ use ra_syntax::{\n };\n \n use crate::{\n+    assist_context::{AssistContext, Assists},\n     ast_transform::{self, AstTransform, QualifyPaths, SubstituteTypeParams},\n     utils::{get_missing_assoc_items, resolve_target_trait},\n-    Assist, AssistCtx, AssistId,\n+    AssistId,\n };\n \n #[derive(PartialEq)]\n@@ -50,8 +51,9 @@ enum AddMissingImplMembersMode {\n //\n // }\n // ```\n-pub(crate) fn add_missing_impl_members(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_missing_impl_members(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     add_missing_impl_members_inner(\n+        acc,\n         ctx,\n         AddMissingImplMembersMode::NoDefaultMethods,\n         \"add_impl_missing_members\",\n@@ -91,8 +93,9 @@ pub(crate) fn add_missing_impl_members(ctx: AssistCtx) -> Option<Assist> {\n //\n // }\n // ```\n-pub(crate) fn add_missing_default_members(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_missing_default_members(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     add_missing_impl_members_inner(\n+        acc,\n         ctx,\n         AddMissingImplMembersMode::DefaultMethodsOnly,\n         \"add_impl_default_members\",\n@@ -101,11 +104,12 @@ pub(crate) fn add_missing_default_members(ctx: AssistCtx) -> Option<Assist> {\n }\n \n fn add_missing_impl_members_inner(\n-    ctx: AssistCtx,\n+    acc: &mut Assists,\n+    ctx: &AssistContext,\n     mode: AddMissingImplMembersMode,\n     assist_id: &'static str,\n     label: &'static str,\n-) -> Option<Assist> {\n+) -> Option<()> {\n     let _p = ra_prof::profile(\"add_missing_impl_members_inner\");\n     let impl_def = ctx.find_node_at_offset::<ast::ImplDef>()?;\n     let impl_item_list = impl_def.item_list()?;\n@@ -142,12 +146,11 @@ fn add_missing_impl_members_inner(\n         return None;\n     }\n \n-    let sema = ctx.sema;\n     let target = impl_def.syntax().text_range();\n-    ctx.add_assist(AssistId(assist_id), label, target, |edit| {\n+    acc.add(AssistId(assist_id), label, target, |edit| {\n         let n_existing_items = impl_item_list.assoc_items().count();\n-        let source_scope = sema.scope_for_def(trait_);\n-        let target_scope = sema.scope(impl_item_list.syntax());\n+        let source_scope = ctx.sema.scope_for_def(trait_);\n+        let target_scope = ctx.sema.scope(impl_item_list.syntax());\n         let ast_transform = QualifyPaths::new(&target_scope, &source_scope)\n             .or(SubstituteTypeParams::for_trait_impl(&source_scope, trait_, impl_def));\n         let items = missing_items\n@@ -170,13 +173,12 @@ fn add_missing_impl_members_inner(\n }\n \n fn add_body(fn_def: ast::FnDef) -> ast::FnDef {\n-    if fn_def.body().is_none() {\n-        let body = make::block_expr(None, Some(make::expr_todo()));\n-        let body = IndentLevel(1).increase_indent(body);\n-        fn_def.with_body(body)\n-    } else {\n-        fn_def\n+    if fn_def.body().is_some() {\n+        return fn_def;\n     }\n+    let body = make::block_expr(None, Some(make::expr_todo()));\n+    let body = IndentLevel(1).increase_indent(body);\n+    fn_def.with_body(body)\n }\n \n #[cfg(test)]"}, {"sha": "fe7451dcfdf4186835cb677902e5cae522ba340c", "filename": "crates/ra_assists/src/handlers/add_new.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_new.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -7,7 +7,7 @@ use ra_syntax::{\n };\n use stdx::{format_to, SepBy};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: add_new\n //\n@@ -29,7 +29,7 @@ use crate::{Assist, AssistCtx, AssistId};\n // }\n //\n // ```\n-pub(crate) fn add_new(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_new(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let strukt = ctx.find_node_at_offset::<ast::StructDef>()?;\n \n     // We want to only apply this to non-union structs with named fields\n@@ -42,7 +42,7 @@ pub(crate) fn add_new(ctx: AssistCtx) -> Option<Assist> {\n     let impl_def = find_struct_impl(&ctx, &strukt)?;\n \n     let target = strukt.syntax().text_range();\n-    ctx.add_assist(AssistId(\"add_new\"), \"Add default constructor\", target, |edit| {\n+    acc.add(AssistId(\"add_new\"), \"Add default constructor\", target, |edit| {\n         let mut buf = String::with_capacity(512);\n \n         if impl_def.is_some() {\n@@ -123,7 +123,7 @@ fn generate_impl_text(strukt: &ast::StructDef, code: &str) -> String {\n //\n // FIXME: change the new fn checking to a more semantic approach when that's more\n // viable (e.g. we process proc macros, etc)\n-fn find_struct_impl(ctx: &AssistCtx, strukt: &ast::StructDef) -> Option<Option<ast::ImplDef>> {\n+fn find_struct_impl(ctx: &AssistContext, strukt: &ast::StructDef) -> Option<Option<ast::ImplDef>> {\n     let db = ctx.db;\n     let module = strukt.syntax().ancestors().find(|node| {\n         ast::Module::can_cast(node.kind()) || ast::SourceFile::can_cast(node.kind())"}, {"sha": "0feba5e11f6510a7dd7e78c9530899fb35b17a2c", "filename": "crates/ra_assists/src/handlers/apply_demorgan.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::ast::{self, AstNode};\n \n-use crate::{utils::invert_boolean_expression, Assist, AssistCtx, AssistId};\n+use crate::{utils::invert_boolean_expression, AssistContext, AssistId, Assists};\n \n // Assist: apply_demorgan\n //\n@@ -21,7 +21,7 @@ use crate::{utils::invert_boolean_expression, Assist, AssistCtx, AssistId};\n //     if !(x == 4 && y) {}\n // }\n // ```\n-pub(crate) fn apply_demorgan(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn apply_demorgan(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let expr = ctx.find_node_at_offset::<ast::BinExpr>()?;\n     let op = expr.op_kind()?;\n     let op_range = expr.op_token()?.text_range();\n@@ -39,7 +39,7 @@ pub(crate) fn apply_demorgan(ctx: AssistCtx) -> Option<Assist> {\n     let rhs_range = rhs.syntax().text_range();\n     let not_rhs = invert_boolean_expression(rhs);\n \n-    ctx.add_assist(AssistId(\"apply_demorgan\"), \"Apply De Morgan's law\", op_range, |edit| {\n+    acc.add(AssistId(\"apply_demorgan\"), \"Apply De Morgan's law\", op_range, |edit| {\n         edit.replace(op_range, opposite_op);\n         edit.replace(lhs_range, format!(\"!({}\", not_lhs.syntax().text()));\n         edit.replace(rhs_range, format!(\"{})\", not_rhs.syntax().text()));"}, {"sha": "78d23150d385be1ddc4581da32725da056ea3ef6", "filename": "crates/ra_assists/src/handlers/auto_import.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -1,5 +1,6 @@\n use std::collections::BTreeSet;\n \n+use either::Either;\n use hir::{\n     AsAssocItem, AssocItemContainer, ModPath, Module, ModuleDef, PathResolution, Semantics, Trait,\n     Type,\n@@ -12,12 +13,7 @@ use ra_syntax::{\n };\n use rustc_hash::FxHashSet;\n \n-use crate::{\n-    assist_ctx::{Assist, AssistCtx},\n-    utils::insert_use_statement,\n-    AssistId,\n-};\n-use either::Either;\n+use crate::{utils::insert_use_statement, AssistContext, AssistId, Assists, GroupLabel};\n \n // Assist: auto_import\n //\n@@ -38,21 +34,27 @@ use either::Either;\n // }\n // # pub mod std { pub mod collections { pub struct HashMap { } } }\n // ```\n-pub(crate) fn auto_import(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let auto_import_assets = AutoImportAssets::new(&ctx)?;\n     let proposed_imports = auto_import_assets.search_for_imports(ctx.db);\n     if proposed_imports.is_empty() {\n         return None;\n     }\n \n     let range = ctx.sema.original_range(&auto_import_assets.syntax_under_caret).range;\n-    let mut group = ctx.add_assist_group(auto_import_assets.get_import_group_message());\n+    let group = auto_import_assets.get_import_group_message();\n     for import in proposed_imports {\n-        group.add_assist(AssistId(\"auto_import\"), format!(\"Import `{}`\", &import), range, |edit| {\n-            insert_use_statement(&auto_import_assets.syntax_under_caret, &import, edit);\n-        });\n+        acc.add_group(\n+            &group,\n+            AssistId(\"auto_import\"),\n+            format!(\"Import `{}`\", &import),\n+            range,\n+            |builder| {\n+                insert_use_statement(&auto_import_assets.syntax_under_caret, &import, ctx, builder);\n+            },\n+        );\n     }\n-    group.finish()\n+    Some(())\n }\n \n #[derive(Debug)]\n@@ -63,15 +65,15 @@ struct AutoImportAssets {\n }\n \n impl AutoImportAssets {\n-    fn new(ctx: &AssistCtx) -> Option<Self> {\n+    fn new(ctx: &AssistContext) -> Option<Self> {\n         if let Some(path_under_caret) = ctx.find_node_at_offset_with_descend::<ast::Path>() {\n             Self::for_regular_path(path_under_caret, &ctx)\n         } else {\n             Self::for_method_call(ctx.find_node_at_offset_with_descend()?, &ctx)\n         }\n     }\n \n-    fn for_method_call(method_call: ast::MethodCallExpr, ctx: &AssistCtx) -> Option<Self> {\n+    fn for_method_call(method_call: ast::MethodCallExpr, ctx: &AssistContext) -> Option<Self> {\n         let syntax_under_caret = method_call.syntax().to_owned();\n         let module_with_name_to_import = ctx.sema.scope(&syntax_under_caret).module()?;\n         Some(Self {\n@@ -81,7 +83,7 @@ impl AutoImportAssets {\n         })\n     }\n \n-    fn for_regular_path(path_under_caret: ast::Path, ctx: &AssistCtx) -> Option<Self> {\n+    fn for_regular_path(path_under_caret: ast::Path, ctx: &AssistContext) -> Option<Self> {\n         let syntax_under_caret = path_under_caret.syntax().to_owned();\n         if syntax_under_caret.ancestors().find_map(ast::UseItem::cast).is_some() {\n             return None;\n@@ -104,8 +106,8 @@ impl AutoImportAssets {\n         }\n     }\n \n-    fn get_import_group_message(&self) -> String {\n-        match &self.import_candidate {\n+    fn get_import_group_message(&self) -> GroupLabel {\n+        let name = match &self.import_candidate {\n             ImportCandidate::UnqualifiedName(name) => format!(\"Import {}\", name),\n             ImportCandidate::QualifierStart(qualifier_start) => {\n                 format!(\"Import {}\", qualifier_start)\n@@ -116,7 +118,8 @@ impl AutoImportAssets {\n             ImportCandidate::TraitMethod(_, trait_method_name) => {\n                 format!(\"Import a trait for method {}\", trait_method_name)\n             }\n-        }\n+        };\n+        GroupLabel(name)\n     }\n \n     fn search_for_imports(&self, db: &RootDatabase) -> BTreeSet<ModPath> {\n@@ -383,7 +386,7 @@ mod tests {\n             }\n             \",\n             r\"\n-            use PubMod1::PubStruct;\n+            use PubMod3::PubStruct;\n \n             PubSt<|>ruct\n "}, {"sha": "5c907097e556a8ba8dbcc757db178a6f1c563632", "filename": "crates/ra_assists/src/handlers/change_return_type_to_result.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -1,11 +1,11 @@\n use ra_syntax::{\n-    ast, AstNode,\n+    ast::{self, BlockExpr, Expr, LoopBodyOwner},\n+    AstNode,\n     SyntaxKind::{COMMENT, WHITESPACE},\n     SyntaxNode, TextSize,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n-use ast::{BlockExpr, Expr, LoopBodyOwner};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: change_return_type_to_result\n //\n@@ -18,7 +18,7 @@ use ast::{BlockExpr, Expr, LoopBodyOwner};\n // ```\n // fn foo() -> Result<i32, > { Ok(42i32) }\n // ```\n-pub(crate) fn change_return_type_to_result(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn change_return_type_to_result(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let fn_def = ctx.find_node_at_offset::<ast::FnDef>();\n     let fn_def = &mut fn_def?;\n     let ret_type = &fn_def.ret_type()?.type_ref()?;\n@@ -33,7 +33,7 @@ pub(crate) fn change_return_type_to_result(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     }\n \n-    ctx.add_assist(\n+    acc.add(\n         AssistId(\"change_return_type_to_result\"),\n         \"Change return type to Result\",\n         ret_type.syntax().text_range(),"}, {"sha": "e631766eff14ab6ae6ca2720ac033ef423b3026d", "filename": "crates/ra_assists/src/handlers/change_visibility.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -7,10 +7,10 @@ use ra_syntax::{\n     },\n     SyntaxNode, TextSize, T,\n };\n-\n-use crate::{Assist, AssistCtx, AssistId};\n use test_utils::tested_by;\n \n+use crate::{AssistContext, AssistId, Assists};\n+\n // Assist: change_visibility\n //\n // Adds or changes existing visibility specifier.\n@@ -22,14 +22,14 @@ use test_utils::tested_by;\n // ```\n // pub(crate) fn frobnicate() {}\n // ```\n-pub(crate) fn change_visibility(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn change_visibility(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     if let Some(vis) = ctx.find_node_at_offset::<ast::Visibility>() {\n-        return change_vis(ctx, vis);\n+        return change_vis(acc, vis);\n     }\n-    add_vis(ctx)\n+    add_vis(acc, ctx)\n }\n \n-fn add_vis(ctx: AssistCtx) -> Option<Assist> {\n+fn add_vis(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let item_keyword = ctx.token_at_offset().find(|leaf| match leaf.kind() {\n         T![const] | T![fn] | T![mod] | T![struct] | T![enum] | T![trait] => true,\n         _ => false,\n@@ -66,15 +66,10 @@ fn add_vis(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     };\n \n-    ctx.add_assist(\n-        AssistId(\"change_visibility\"),\n-        \"Change visibility to pub(crate)\",\n-        target,\n-        |edit| {\n-            edit.insert(offset, \"pub(crate) \");\n-            edit.set_cursor(offset);\n-        },\n-    )\n+    acc.add(AssistId(\"change_visibility\"), \"Change visibility to pub(crate)\", target, |edit| {\n+        edit.insert(offset, \"pub(crate) \");\n+        edit.set_cursor(offset);\n+    })\n }\n \n fn vis_offset(node: &SyntaxNode) -> TextSize {\n@@ -88,10 +83,10 @@ fn vis_offset(node: &SyntaxNode) -> TextSize {\n         .unwrap_or_else(|| node.text_range().start())\n }\n \n-fn change_vis(ctx: AssistCtx, vis: ast::Visibility) -> Option<Assist> {\n+fn change_vis(acc: &mut Assists, vis: ast::Visibility) -> Option<()> {\n     if vis.syntax().text() == \"pub\" {\n         let target = vis.syntax().text_range();\n-        return ctx.add_assist(\n+        return acc.add(\n             AssistId(\"change_visibility\"),\n             \"Change Visibility to pub(crate)\",\n             target,\n@@ -103,7 +98,7 @@ fn change_vis(ctx: AssistCtx, vis: ast::Visibility) -> Option<Assist> {\n     }\n     if vis.syntax().text() == \"pub(crate)\" {\n         let target = vis.syntax().text_range();\n-        return ctx.add_assist(\n+        return acc.add(\n             AssistId(\"change_visibility\"),\n             \"Change visibility to pub\",\n             target,"}, {"sha": "ccf91797c68737e19548b1d827601e2d01aa0925", "filename": "crates/ra_assists/src/handlers/early_return.rs", "status": "modified", "additions": 78, "deletions": 83, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fearly_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fearly_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fearly_return.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -9,7 +9,7 @@ use ra_syntax::{\n };\n \n use crate::{\n-    assist_ctx::{Assist, AssistCtx},\n+    assist_context::{AssistContext, Assists},\n     utils::invert_boolean_expression,\n     AssistId,\n };\n@@ -36,7 +36,7 @@ use crate::{\n //     bar();\n // }\n // ```\n-pub(crate) fn convert_to_guarded_return(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let if_expr: ast::IfExpr = ctx.find_node_at_offset()?;\n     if if_expr.else_branch().is_some() {\n         return None;\n@@ -96,93 +96,88 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx) -> Option<Assist> {\n     let cursor_position = ctx.frange.range.start();\n \n     let target = if_expr.syntax().text_range();\n-    ctx.add_assist(\n-        AssistId(\"convert_to_guarded_return\"),\n-        \"Convert to guarded return\",\n-        target,\n-        |edit| {\n-            let if_indent_level = IndentLevel::from_node(&if_expr.syntax());\n-            let new_block = match if_let_pat {\n-                None => {\n-                    // If.\n-                    let new_expr = {\n-                        let then_branch =\n-                            make::block_expr(once(make::expr_stmt(early_expression).into()), None);\n-                        let cond = invert_boolean_expression(cond_expr);\n-                        let e = make::expr_if(make::condition(cond, None), then_branch);\n-                        if_indent_level.increase_indent(e)\n-                    };\n-                    replace(new_expr.syntax(), &then_block, &parent_block, &if_expr)\n-                }\n-                Some((path, bound_ident)) => {\n-                    // If-let.\n-                    let match_expr = {\n-                        let happy_arm = {\n-                            let pat = make::tuple_struct_pat(\n-                                path,\n-                                once(make::bind_pat(make::name(\"it\")).into()),\n-                            );\n-                            let expr = {\n-                                let name_ref = make::name_ref(\"it\");\n-                                let segment = make::path_segment(name_ref);\n-                                let path = make::path_unqualified(segment);\n-                                make::expr_path(path)\n-                            };\n-                            make::match_arm(once(pat.into()), expr)\n-                        };\n-\n-                        let sad_arm = make::match_arm(\n-                            // FIXME: would be cool to use `None` or `Err(_)` if appropriate\n-                            once(make::placeholder_pat().into()),\n-                            early_expression,\n+    acc.add(AssistId(\"convert_to_guarded_return\"), \"Convert to guarded return\", target, |edit| {\n+        let if_indent_level = IndentLevel::from_node(&if_expr.syntax());\n+        let new_block = match if_let_pat {\n+            None => {\n+                // If.\n+                let new_expr = {\n+                    let then_branch =\n+                        make::block_expr(once(make::expr_stmt(early_expression).into()), None);\n+                    let cond = invert_boolean_expression(cond_expr);\n+                    let e = make::expr_if(make::condition(cond, None), then_branch);\n+                    if_indent_level.increase_indent(e)\n+                };\n+                replace(new_expr.syntax(), &then_block, &parent_block, &if_expr)\n+            }\n+            Some((path, bound_ident)) => {\n+                // If-let.\n+                let match_expr = {\n+                    let happy_arm = {\n+                        let pat = make::tuple_struct_pat(\n+                            path,\n+                            once(make::bind_pat(make::name(\"it\")).into()),\n                         );\n-\n-                        make::expr_match(cond_expr, make::match_arm_list(vec![happy_arm, sad_arm]))\n+                        let expr = {\n+                            let name_ref = make::name_ref(\"it\");\n+                            let segment = make::path_segment(name_ref);\n+                            let path = make::path_unqualified(segment);\n+                            make::expr_path(path)\n+                        };\n+                        make::match_arm(once(pat.into()), expr)\n                     };\n \n-                    let let_stmt = make::let_stmt(\n-                        make::bind_pat(make::name(&bound_ident.syntax().to_string())).into(),\n-                        Some(match_expr),\n+                    let sad_arm = make::match_arm(\n+                        // FIXME: would be cool to use `None` or `Err(_)` if appropriate\n+                        once(make::placeholder_pat().into()),\n+                        early_expression,\n                     );\n-                    let let_stmt = if_indent_level.increase_indent(let_stmt);\n-                    replace(let_stmt.syntax(), &then_block, &parent_block, &if_expr)\n-                }\n-            };\n-            edit.replace_ast(parent_block, ast::BlockExpr::cast(new_block).unwrap());\n-            edit.set_cursor(cursor_position);\n-\n-            fn replace(\n-                new_expr: &SyntaxNode,\n-                then_block: &ast::BlockExpr,\n-                parent_block: &ast::BlockExpr,\n-                if_expr: &ast::IfExpr,\n-            ) -> SyntaxNode {\n-                let then_block_items = IndentLevel::from(1).decrease_indent(then_block.clone());\n-                let end_of_then = then_block_items.syntax().last_child_or_token().unwrap();\n-                let end_of_then =\n-                    if end_of_then.prev_sibling_or_token().map(|n| n.kind()) == Some(WHITESPACE) {\n-                        end_of_then.prev_sibling_or_token().unwrap()\n-                    } else {\n-                        end_of_then\n-                    };\n-                let mut then_statements = new_expr.children_with_tokens().chain(\n-                    then_block_items\n-                        .syntax()\n-                        .children_with_tokens()\n-                        .skip(1)\n-                        .take_while(|i| *i != end_of_then),\n+\n+                    make::expr_match(cond_expr, make::match_arm_list(vec![happy_arm, sad_arm]))\n+                };\n+\n+                let let_stmt = make::let_stmt(\n+                    make::bind_pat(make::name(&bound_ident.syntax().to_string())).into(),\n+                    Some(match_expr),\n                 );\n-                replace_children(\n-                    &parent_block.syntax(),\n-                    RangeInclusive::new(\n-                        if_expr.clone().syntax().clone().into(),\n-                        if_expr.syntax().clone().into(),\n-                    ),\n-                    &mut then_statements,\n-                )\n+                let let_stmt = if_indent_level.increase_indent(let_stmt);\n+                replace(let_stmt.syntax(), &then_block, &parent_block, &if_expr)\n             }\n-        },\n-    )\n+        };\n+        edit.replace_ast(parent_block, ast::BlockExpr::cast(new_block).unwrap());\n+        edit.set_cursor(cursor_position);\n+\n+        fn replace(\n+            new_expr: &SyntaxNode,\n+            then_block: &ast::BlockExpr,\n+            parent_block: &ast::BlockExpr,\n+            if_expr: &ast::IfExpr,\n+        ) -> SyntaxNode {\n+            let then_block_items = IndentLevel::from(1).decrease_indent(then_block.clone());\n+            let end_of_then = then_block_items.syntax().last_child_or_token().unwrap();\n+            let end_of_then =\n+                if end_of_then.prev_sibling_or_token().map(|n| n.kind()) == Some(WHITESPACE) {\n+                    end_of_then.prev_sibling_or_token().unwrap()\n+                } else {\n+                    end_of_then\n+                };\n+            let mut then_statements = new_expr.children_with_tokens().chain(\n+                then_block_items\n+                    .syntax()\n+                    .children_with_tokens()\n+                    .skip(1)\n+                    .take_while(|i| *i != end_of_then),\n+            );\n+            replace_children(\n+                &parent_block.syntax(),\n+                RangeInclusive::new(\n+                    if_expr.clone().syntax().clone().into(),\n+                    if_expr.syntax().clone().into(),\n+                ),\n+                &mut then_statements,\n+            )\n+        }\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "13c1e7e8014b1317aeebc4992a44a4261943b784", "filename": "crates/ra_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -5,7 +5,7 @@ use itertools::Itertools;\n use ra_ide_db::RootDatabase;\n use ra_syntax::ast::{self, make, AstNode, MatchArm, NameOwner, Pat};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: fill_match_arms\n //\n@@ -31,7 +31,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     }\n // }\n // ```\n-pub(crate) fn fill_match_arms(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let match_expr = ctx.find_node_at_offset::<ast::MatchExpr>()?;\n     let match_arm_list = match_expr.match_arm_list()?;\n \n@@ -93,7 +93,7 @@ pub(crate) fn fill_match_arms(ctx: AssistCtx) -> Option<Assist> {\n     }\n \n     let target = match_expr.syntax().text_range();\n-    ctx.add_assist(AssistId(\"fill_match_arms\"), \"Fill match arms\", target, |edit| {\n+    acc.add(AssistId(\"fill_match_arms\"), \"Fill match arms\", target, |edit| {\n         let new_arm_list = match_arm_list.remove_placeholder().append_arms(missing_arms);\n         edit.set_cursor(expr.syntax().text_range().start());\n         edit.replace_ast(match_arm_list, new_arm_list);"}, {"sha": "692ba4895cb2e917e428fc1e7355dc65da6cab8c", "filename": "crates/ra_assists/src/handlers/flip_binexpr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::ast::{AstNode, BinExpr, BinOp};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: flip_binexpr\n //\n@@ -17,7 +17,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     let _ = 2 + 90;\n // }\n // ```\n-pub(crate) fn flip_binexpr(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn flip_binexpr(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let expr = ctx.find_node_at_offset::<BinExpr>()?;\n     let lhs = expr.lhs()?.syntax().clone();\n     let rhs = expr.rhs()?.syntax().clone();\n@@ -33,7 +33,7 @@ pub(crate) fn flip_binexpr(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     }\n \n-    ctx.add_assist(AssistId(\"flip_binexpr\"), \"Flip binary expression\", op_range, |edit| {\n+    acc.add(AssistId(\"flip_binexpr\"), \"Flip binary expression\", op_range, |edit| {\n         if let FlipAction::FlipAndReplaceOp(new_op) = action {\n             edit.replace(op_range, new_op);\n         }"}, {"sha": "dfe2a7fedc0576a5a7adfa6176f9154abc68b95b", "filename": "crates/ra_assists/src/handlers/flip_comma.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_comma.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::{algo::non_trivia_sibling, Direction, T};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: flip_comma\n //\n@@ -17,7 +17,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     ((3, 4), (1, 2));\n // }\n // ```\n-pub(crate) fn flip_comma(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn flip_comma(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let comma = ctx.find_token_at_offset(T![,])?;\n     let prev = non_trivia_sibling(comma.clone().into(), Direction::Prev)?;\n     let next = non_trivia_sibling(comma.clone().into(), Direction::Next)?;\n@@ -28,7 +28,7 @@ pub(crate) fn flip_comma(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     }\n \n-    ctx.add_assist(AssistId(\"flip_comma\"), \"Flip comma\", comma.text_range(), |edit| {\n+    acc.add(AssistId(\"flip_comma\"), \"Flip comma\", comma.text_range(), |edit| {\n         edit.replace(prev.text_range(), next.to_string());\n         edit.replace(next.text_range(), prev.to_string());\n     })"}, {"sha": "8a08702ab29caf6694f46ebabccde4bf81c2189c", "filename": "crates/ra_assists/src/handlers/flip_trait_bound.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -4,7 +4,7 @@ use ra_syntax::{\n     Direction, T,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: flip_trait_bound\n //\n@@ -17,7 +17,7 @@ use crate::{Assist, AssistCtx, AssistId};\n // ```\n // fn foo<T: Copy + Clone>() { }\n // ```\n-pub(crate) fn flip_trait_bound(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn flip_trait_bound(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     // We want to replicate the behavior of `flip_binexpr` by only suggesting\n     // the assist when the cursor is on a `+`\n     let plus = ctx.find_token_at_offset(T![+])?;\n@@ -33,7 +33,7 @@ pub(crate) fn flip_trait_bound(ctx: AssistCtx) -> Option<Assist> {\n     );\n \n     let target = plus.text_range();\n-    ctx.add_assist(AssistId(\"flip_trait_bound\"), \"Flip trait bounds\", target, |edit| {\n+    acc.add(AssistId(\"flip_trait_bound\"), \"Flip trait bounds\", target, |edit| {\n         edit.replace(before.text_range(), after.to_string());\n         edit.replace(after.text_range(), before.to_string());\n     })"}, {"sha": "5b26814d30ad3d66ef847abe5b79fb0e555b1ac6", "filename": "crates/ra_assists/src/handlers/inline_local_variable.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -5,7 +5,10 @@ use ra_syntax::{\n };\n use test_utils::tested_by;\n \n-use crate::{assist_ctx::ActionBuilder, Assist, AssistCtx, AssistId};\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    AssistId,\n+};\n \n // Assist: inline_local_variable\n //\n@@ -23,7 +26,7 @@ use crate::{assist_ctx::ActionBuilder, Assist, AssistCtx, AssistId};\n //     (1 + 2) * 4;\n // }\n // ```\n-pub(crate) fn inline_local_variable(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let let_stmt = ctx.find_node_at_offset::<ast::LetStmt>()?;\n     let bind_pat = match let_stmt.pat()? {\n         ast::Pat::BindPat(pat) => pat,\n@@ -33,7 +36,7 @@ pub(crate) fn inline_local_variable(ctx: AssistCtx) -> Option<Assist> {\n         tested_by!(test_not_inline_mut_variable);\n         return None;\n     }\n-    if !bind_pat.syntax().text_range().contains_inclusive(ctx.frange.range.start()) {\n+    if !bind_pat.syntax().text_range().contains_inclusive(ctx.offset()) {\n         tested_by!(not_applicable_outside_of_bind_pat);\n         return None;\n     }\n@@ -107,20 +110,14 @@ pub(crate) fn inline_local_variable(ctx: AssistCtx) -> Option<Assist> {\n     let init_in_paren = format!(\"({})\", &init_str);\n \n     let target = bind_pat.syntax().text_range();\n-    ctx.add_assist(\n-        AssistId(\"inline_local_variable\"),\n-        \"Inline variable\",\n-        target,\n-        move |edit: &mut ActionBuilder| {\n-            edit.delete(delete_range);\n-            for (desc, should_wrap) in refs.iter().zip(wrap_in_parens) {\n-                let replacement =\n-                    if should_wrap { init_in_paren.clone() } else { init_str.clone() };\n-                edit.replace(desc.file_range.range, replacement)\n-            }\n-            edit.set_cursor(delete_range.start())\n-        },\n-    )\n+    acc.add(AssistId(\"inline_local_variable\"), \"Inline variable\", target, move |builder| {\n+        builder.delete(delete_range);\n+        for (desc, should_wrap) in refs.iter().zip(wrap_in_parens) {\n+            let replacement = if should_wrap { init_in_paren.clone() } else { init_str.clone() };\n+            builder.replace(desc.file_range.range, replacement)\n+        }\n+        builder.set_cursor(delete_range.start())\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "fdf3ada0d794a8638eeff6ed0f4e9ef92b2401cc", "filename": "crates/ra_assists/src/handlers/introduce_variable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fintroduce_variable.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -9,7 +9,7 @@ use ra_syntax::{\n use stdx::format_to;\n use test_utils::tested_by;\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: introduce_variable\n //\n@@ -27,7 +27,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     var_name * 4;\n // }\n // ```\n-pub(crate) fn introduce_variable(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn introduce_variable(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     if ctx.frange.range.is_empty() {\n         return None;\n     }\n@@ -43,7 +43,7 @@ pub(crate) fn introduce_variable(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     }\n     let target = expr.syntax().text_range();\n-    ctx.add_assist(AssistId(\"introduce_variable\"), \"Extract into variable\", target, move |edit| {\n+    acc.add(AssistId(\"introduce_variable\"), \"Extract into variable\", target, move |edit| {\n         let mut buf = String::new();\n \n         let cursor_offset = if wrap_in_block {"}, {"sha": "527c7caef1a3bf2c068c17588c4148816b51fa5a", "filename": "crates/ra_assists/src/handlers/invert_if.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finvert_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finvert_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Finvert_if.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -3,7 +3,11 @@ use ra_syntax::{\n     T,\n };\n \n-use crate::{utils::invert_boolean_expression, Assist, AssistCtx, AssistId};\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    utils::invert_boolean_expression,\n+    AssistId,\n+};\n \n // Assist: invert_if\n //\n@@ -24,7 +28,7 @@ use crate::{utils::invert_boolean_expression, Assist, AssistCtx, AssistId};\n // }\n // ```\n \n-pub(crate) fn invert_if(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn invert_if(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let if_keyword = ctx.find_token_at_offset(T![if])?;\n     let expr = ast::IfExpr::cast(if_keyword.parent())?;\n     let if_range = if_keyword.text_range();\n@@ -40,21 +44,21 @@ pub(crate) fn invert_if(ctx: AssistCtx) -> Option<Assist> {\n \n     let cond = expr.condition()?.expr()?;\n     let then_node = expr.then_branch()?.syntax().clone();\n+    let else_block = match expr.else_branch()? {\n+        ast::ElseBranch::Block(it) => it,\n+        ast::ElseBranch::IfExpr(_) => return None,\n+    };\n \n-    if let ast::ElseBranch::Block(else_block) = expr.else_branch()? {\n-        let cond_range = cond.syntax().text_range();\n-        let flip_cond = invert_boolean_expression(cond);\n-        let else_node = else_block.syntax();\n-        let else_range = else_node.text_range();\n-        let then_range = then_node.text_range();\n-        return ctx.add_assist(AssistId(\"invert_if\"), \"Invert if\", if_range, |edit| {\n-            edit.replace(cond_range, flip_cond.syntax().text());\n-            edit.replace(else_range, then_node.text());\n-            edit.replace(then_range, else_node.text());\n-        });\n-    }\n-\n-    None\n+    let cond_range = cond.syntax().text_range();\n+    let flip_cond = invert_boolean_expression(cond);\n+    let else_node = else_block.syntax();\n+    let else_range = else_node.text_range();\n+    let then_range = then_node.text_range();\n+    acc.add(AssistId(\"invert_if\"), \"Invert if\", if_range, |edit| {\n+        edit.replace(cond_range, flip_cond.syntax().text());\n+        edit.replace(else_range, then_node.text());\n+        edit.replace(then_range, else_node.text());\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "8e1d93312388bd712298e30c6a63d9dfaae2fad6", "filename": "crates/ra_assists/src/handlers/merge_imports.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -6,7 +6,10 @@ use ra_syntax::{\n     AstNode, Direction, InsertPosition, SyntaxElement, T,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    AssistId,\n+};\n \n // Assist: merge_imports\n //\n@@ -20,7 +23,7 @@ use crate::{Assist, AssistCtx, AssistId};\n // ```\n // use std::{fmt::Formatter, io};\n // ```\n-pub(crate) fn merge_imports(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn merge_imports(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let tree: ast::UseTree = ctx.find_node_at_offset()?;\n     let mut rewriter = SyntaxRewriter::default();\n     let mut offset = ctx.frange.range.start();\n@@ -53,10 +56,10 @@ pub(crate) fn merge_imports(ctx: AssistCtx) -> Option<Assist> {\n     };\n \n     let target = tree.syntax().text_range();\n-    ctx.add_assist(AssistId(\"merge_imports\"), \"Merge imports\", target, |edit| {\n-        edit.rewrite(rewriter);\n+    acc.add(AssistId(\"merge_imports\"), \"Merge imports\", target, |builder| {\n+        builder.rewrite(rewriter);\n         // FIXME: we only need because our diff is imprecise\n-        edit.set_cursor(offset);\n+        builder.set_cursor(offset);\n     })\n }\n "}, {"sha": "cfe4df47bce64d46080969876bde87a80c737734", "filename": "crates/ra_assists/src/handlers/merge_match_arms.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -6,7 +6,7 @@ use ra_syntax::{\n     Direction, TextSize,\n };\n \n-use crate::{Assist, AssistCtx, AssistId, TextRange};\n+use crate::{AssistContext, AssistId, Assists, TextRange};\n \n // Assist: merge_match_arms\n //\n@@ -32,7 +32,7 @@ use crate::{Assist, AssistCtx, AssistId, TextRange};\n //     }\n // }\n // ```\n-pub(crate) fn merge_match_arms(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn merge_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let current_arm = ctx.find_node_at_offset::<ast::MatchArm>()?;\n     // Don't try to handle arms with guards for now - can add support for this later\n     if current_arm.guard().is_some() {\n@@ -70,7 +70,7 @@ pub(crate) fn merge_match_arms(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     }\n \n-    ctx.add_assist(AssistId(\"merge_match_arms\"), \"Merge match arms\", current_text_range, |edit| {\n+    acc.add(AssistId(\"merge_match_arms\"), \"Merge match arms\", current_text_range, |edit| {\n         let pats = if arms_to_merge.iter().any(contains_placeholder) {\n             \"_\".into()\n         } else {"}, {"sha": "a41aacfc3dc39605282f5dd392692481d14e9ad5", "filename": "crates/ra_assists/src/handlers/move_bounds.rs", "status": "modified", "additions": 25, "deletions": 32, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{\n     T,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: move_bounds_to_where_clause\n //\n@@ -22,7 +22,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     f(x)\n // }\n // ```\n-pub(crate) fn move_bounds_to_where_clause(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn move_bounds_to_where_clause(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let type_param_list = ctx.find_node_at_offset::<ast::TypeParamList>()?;\n \n     let mut type_params = type_param_list.type_params();\n@@ -50,36 +50,29 @@ pub(crate) fn move_bounds_to_where_clause(ctx: AssistCtx) -> Option<Assist> {\n     };\n \n     let target = type_param_list.syntax().text_range();\n-    ctx.add_assist(\n-        AssistId(\"move_bounds_to_where_clause\"),\n-        \"Move to where clause\",\n-        target,\n-        |edit| {\n-            let new_params = type_param_list\n-                .type_params()\n-                .filter(|it| it.type_bound_list().is_some())\n-                .map(|type_param| {\n-                    let without_bounds = type_param.remove_bounds();\n-                    (type_param, without_bounds)\n-                });\n-\n-            let new_type_param_list = type_param_list.replace_descendants(new_params);\n-            edit.replace_ast(type_param_list.clone(), new_type_param_list);\n-\n-            let where_clause = {\n-                let predicates = type_param_list.type_params().filter_map(build_predicate);\n-                make::where_clause(predicates)\n-            };\n-\n-            let to_insert = match anchor.prev_sibling_or_token() {\n-                Some(ref elem) if elem.kind() == WHITESPACE => {\n-                    format!(\"{} \", where_clause.syntax())\n-                }\n-                _ => format!(\" {}\", where_clause.syntax()),\n-            };\n-            edit.insert(anchor.text_range().start(), to_insert);\n-        },\n-    )\n+    acc.add(AssistId(\"move_bounds_to_where_clause\"), \"Move to where clause\", target, |edit| {\n+        let new_params = type_param_list\n+            .type_params()\n+            .filter(|it| it.type_bound_list().is_some())\n+            .map(|type_param| {\n+                let without_bounds = type_param.remove_bounds();\n+                (type_param, without_bounds)\n+            });\n+\n+        let new_type_param_list = type_param_list.replace_descendants(new_params);\n+        edit.replace_ast(type_param_list.clone(), new_type_param_list);\n+\n+        let where_clause = {\n+            let predicates = type_param_list.type_params().filter_map(build_predicate);\n+            make::where_clause(predicates)\n+        };\n+\n+        let to_insert = match anchor.prev_sibling_or_token() {\n+            Some(ref elem) if elem.kind() == WHITESPACE => format!(\"{} \", where_clause.syntax()),\n+            _ => format!(\" {}\", where_clause.syntax()),\n+        };\n+        edit.insert(anchor.text_range().start(), to_insert);\n+    })\n }\n \n fn build_predicate(param: ast::TypeParam) -> Option<ast::WherePred> {"}, {"sha": "fc0335b5785d909179f9a6fdb2b4876c76521bee", "filename": "crates/ra_assists/src/handlers/move_guard.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmove_guard.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -4,7 +4,7 @@ use ra_syntax::{\n     TextSize,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: move_guard_to_arm_body\n //\n@@ -31,7 +31,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     }\n // }\n // ```\n-pub(crate) fn move_guard_to_arm_body(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn move_guard_to_arm_body(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let match_arm = ctx.find_node_at_offset::<MatchArm>()?;\n     let guard = match_arm.guard()?;\n     let space_before_guard = guard.syntax().prev_sibling_or_token();\n@@ -41,7 +41,7 @@ pub(crate) fn move_guard_to_arm_body(ctx: AssistCtx) -> Option<Assist> {\n     let buf = format!(\"if {} {{ {} }}\", guard_conditions.syntax().text(), arm_expr.syntax().text());\n \n     let target = guard.syntax().text_range();\n-    ctx.add_assist(AssistId(\"move_guard_to_arm_body\"), \"Move guard to arm body\", target, |edit| {\n+    acc.add(AssistId(\"move_guard_to_arm_body\"), \"Move guard to arm body\", target, |edit| {\n         let offseting_amount = match space_before_guard.and_then(|it| it.into_token()) {\n             Some(tok) => {\n                 if ast::Whitespace::cast(tok.clone()).is_some() {\n@@ -88,7 +88,7 @@ pub(crate) fn move_guard_to_arm_body(ctx: AssistCtx) -> Option<Assist> {\n //     }\n // }\n // ```\n-pub(crate) fn move_arm_cond_to_match_guard(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn move_arm_cond_to_match_guard(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let match_arm: MatchArm = ctx.find_node_at_offset::<MatchArm>()?;\n     let match_pat = match_arm.pat()?;\n \n@@ -109,7 +109,7 @@ pub(crate) fn move_arm_cond_to_match_guard(ctx: AssistCtx) -> Option<Assist> {\n     let buf = format!(\" if {}\", cond.syntax().text());\n \n     let target = if_expr.syntax().text_range();\n-    ctx.add_assist(\n+    acc.add(\n         AssistId(\"move_arm_cond_to_match_guard\"),\n         \"Move condition to match guard\",\n         target,"}, {"sha": "c20ffe0b30aba765e97876eb08c18710f0a4fa49", "filename": "crates/ra_assists/src/handlers/raw_string.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fraw_string.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{\n     TextSize,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: make_raw_string\n //\n@@ -22,11 +22,11 @@ use crate::{Assist, AssistCtx, AssistId};\n //     r#\"Hello, World!\"#;\n // }\n // ```\n-pub(crate) fn make_raw_string(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn make_raw_string(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let token = ctx.find_token_at_offset(STRING).and_then(ast::String::cast)?;\n     let value = token.value()?;\n     let target = token.syntax().text_range();\n-    ctx.add_assist(AssistId(\"make_raw_string\"), \"Rewrite as raw string\", target, |edit| {\n+    acc.add(AssistId(\"make_raw_string\"), \"Rewrite as raw string\", target, |edit| {\n         let max_hash_streak = count_hashes(&value);\n         let mut hashes = String::with_capacity(max_hash_streak + 1);\n         for _ in 0..hashes.capacity() {\n@@ -51,11 +51,11 @@ pub(crate) fn make_raw_string(ctx: AssistCtx) -> Option<Assist> {\n //     \"Hello, \\\"World!\\\"\";\n // }\n // ```\n-pub(crate) fn make_usual_string(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn make_usual_string(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let token = ctx.find_token_at_offset(RAW_STRING).and_then(ast::RawString::cast)?;\n     let value = token.value()?;\n     let target = token.syntax().text_range();\n-    ctx.add_assist(AssistId(\"make_usual_string\"), \"Rewrite as regular string\", target, |edit| {\n+    acc.add(AssistId(\"make_usual_string\"), \"Rewrite as regular string\", target, |edit| {\n         // parse inside string to escape `\"`\n         let escaped = value.escape_default().to_string();\n         edit.replace(token.syntax().text_range(), format!(\"\\\"{}\\\"\", escaped));\n@@ -77,10 +77,10 @@ pub(crate) fn make_usual_string(ctx: AssistCtx) -> Option<Assist> {\n //     r##\"Hello, World!\"##;\n // }\n // ```\n-pub(crate) fn add_hash(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_hash(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let token = ctx.find_token_at_offset(RAW_STRING)?;\n     let target = token.text_range();\n-    ctx.add_assist(AssistId(\"add_hash\"), \"Add # to raw string\", target, |edit| {\n+    acc.add(AssistId(\"add_hash\"), \"Add # to raw string\", target, |edit| {\n         edit.insert(token.text_range().start() + TextSize::of('r'), \"#\");\n         edit.insert(token.text_range().end(), \"#\");\n     })\n@@ -101,15 +101,15 @@ pub(crate) fn add_hash(ctx: AssistCtx) -> Option<Assist> {\n //     r\"Hello, World!\";\n // }\n // ```\n-pub(crate) fn remove_hash(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn remove_hash(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let token = ctx.find_token_at_offset(RAW_STRING)?;\n     let text = token.text().as_str();\n     if text.starts_with(\"r\\\"\") {\n         // no hash to remove\n         return None;\n     }\n     let target = token.text_range();\n-    ctx.add_assist(AssistId(\"remove_hash\"), \"Remove hash from raw string\", target, |edit| {\n+    acc.add(AssistId(\"remove_hash\"), \"Remove hash from raw string\", target, |edit| {\n         let result = &text[2..text.len() - 1];\n         let result = if result.starts_with('\\\"') {\n             // FIXME: this logic is wrong, not only the last has has to handled specially"}, {"sha": "8eef578cf40128ae2fafc658c451ac30150bbe44", "filename": "crates/ra_assists/src/handlers/remove_dbg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -3,7 +3,7 @@ use ra_syntax::{\n     TextSize, T,\n };\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: remove_dbg\n //\n@@ -20,7 +20,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     92;\n // }\n // ```\n-pub(crate) fn remove_dbg(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let macro_call = ctx.find_node_at_offset::<ast::MacroCall>()?;\n \n     if !is_valid_macrocall(&macro_call, \"dbg\")? {\n@@ -58,7 +58,7 @@ pub(crate) fn remove_dbg(ctx: AssistCtx) -> Option<Assist> {\n     };\n \n     let target = macro_call.syntax().text_range();\n-    ctx.add_assist(AssistId(\"remove_dbg\"), \"Remove dbg!()\", target, |edit| {\n+    acc.add(AssistId(\"remove_dbg\"), \"Remove dbg!()\", target, |edit| {\n         edit.replace(macro_range, macro_content);\n         edit.set_cursor(cursor_pos);\n     })"}, {"sha": "dce546db79d5607eb7cc1c9d3edf8ef15c98b6f9", "filename": "crates/ra_assists/src/handlers/remove_mut.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fremove_mut.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::{SyntaxKind, TextRange, T};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: remove_mut\n //\n@@ -17,7 +17,7 @@ use crate::{Assist, AssistCtx, AssistId};\n //     fn feed(&self, amount: u32) {}\n // }\n // ```\n-pub(crate) fn remove_mut(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn remove_mut(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let mut_token = ctx.find_token_at_offset(T![mut])?;\n     let delete_from = mut_token.text_range().start();\n     let delete_to = match mut_token.next_token() {\n@@ -26,7 +26,7 @@ pub(crate) fn remove_mut(ctx: AssistCtx) -> Option<Assist> {\n     };\n \n     let target = mut_token.text_range();\n-    ctx.add_assist(AssistId(\"remove_mut\"), \"Remove `mut` keyword\", target, |edit| {\n+    acc.add(AssistId(\"remove_mut\"), \"Remove `mut` keyword\", target, |edit| {\n         edit.set_cursor(delete_from);\n         edit.delete(TextRange::new(delete_from, delete_to));\n     })"}, {"sha": "757f6406e9185e7f7c05d4963ae536076fd4b293", "filename": "crates/ra_assists/src/handlers/reorder_fields.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -3,18 +3,9 @@ use std::collections::HashMap;\n use hir::{Adt, ModuleDef, PathResolution, Semantics, Struct};\n use itertools::Itertools;\n use ra_ide_db::RootDatabase;\n-use ra_syntax::{\n-    algo,\n-    ast::{self, Path, RecordLit, RecordPat},\n-    match_ast, AstNode, SyntaxKind,\n-    SyntaxKind::*,\n-    SyntaxNode,\n-};\n-\n-use crate::{\n-    assist_ctx::{Assist, AssistCtx},\n-    AssistId,\n-};\n+use ra_syntax::{algo, ast, match_ast, AstNode, SyntaxKind, SyntaxKind::*, SyntaxNode};\n+\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: reorder_fields\n //\n@@ -31,13 +22,13 @@ use crate::{\n // const test: Foo = Foo {foo: 1, bar: 0}\n // ```\n //\n-pub(crate) fn reorder_fields(ctx: AssistCtx) -> Option<Assist> {\n-    reorder::<RecordLit>(ctx.clone()).or_else(|| reorder::<RecordPat>(ctx))\n+pub(crate) fn reorder_fields(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    reorder::<ast::RecordLit>(acc, ctx.clone()).or_else(|| reorder::<ast::RecordPat>(acc, ctx))\n }\n \n-fn reorder<R: AstNode>(ctx: AssistCtx) -> Option<Assist> {\n+fn reorder<R: AstNode>(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let record = ctx.find_node_at_offset::<R>()?;\n-    let path = record.syntax().children().find_map(Path::cast)?;\n+    let path = record.syntax().children().find_map(ast::Path::cast)?;\n \n     let ranks = compute_fields_ranks(&path, &ctx)?;\n \n@@ -51,7 +42,7 @@ fn reorder<R: AstNode>(ctx: AssistCtx) -> Option<Assist> {\n     }\n \n     let target = record.syntax().text_range();\n-    ctx.add_assist(AssistId(\"reorder_fields\"), \"Reorder record fields\", target, |edit| {\n+    acc.add(AssistId(\"reorder_fields\"), \"Reorder record fields\", target, |edit| {\n         for (old, new) in fields.iter().zip(&sorted_fields) {\n             algo::diff(old, new).into_text_edit(edit.text_edit_builder());\n         }\n@@ -96,9 +87,9 @@ fn struct_definition(path: &ast::Path, sema: &Semantics<RootDatabase>) -> Option\n     }\n }\n \n-fn compute_fields_ranks(path: &Path, ctx: &AssistCtx) -> Option<HashMap<String, usize>> {\n+fn compute_fields_ranks(path: &ast::Path, ctx: &AssistContext) -> Option<HashMap<String, usize>> {\n     Some(\n-        struct_definition(path, ctx.sema)?\n+        struct_definition(path, &ctx.sema)?\n             .fields(ctx.db)\n             .iter()\n             .enumerate()"}, {"sha": "a59a06efa545abdbbf7c2f4493c0dc2c1c9985ad", "filename": "crates/ra_assists/src/handlers/replace_if_let_with_match.rs", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -4,7 +4,7 @@ use ra_syntax::{\n     AstNode,\n };\n \n-use crate::{utils::TryEnum, Assist, AssistCtx, AssistId};\n+use crate::{utils::TryEnum, AssistContext, AssistId, Assists};\n \n // Assist: replace_if_let_with_match\n //\n@@ -32,7 +32,7 @@ use crate::{utils::TryEnum, Assist, AssistCtx, AssistId};\n //     }\n // }\n // ```\n-pub(crate) fn replace_if_let_with_match(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn replace_if_let_with_match(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let if_expr: ast::IfExpr = ctx.find_node_at_offset()?;\n     let cond = if_expr.condition()?;\n     let pat = cond.pat()?;\n@@ -43,36 +43,31 @@ pub(crate) fn replace_if_let_with_match(ctx: AssistCtx) -> Option<Assist> {\n         ast::ElseBranch::IfExpr(_) => return None,\n     };\n \n-    let sema = ctx.sema;\n     let target = if_expr.syntax().text_range();\n-    ctx.add_assist(\n-        AssistId(\"replace_if_let_with_match\"),\n-        \"Replace with match\",\n-        target,\n-        move |edit| {\n-            let match_expr = {\n-                let then_arm = {\n-                    let then_expr = unwrap_trivial_block(then_block);\n-                    make::match_arm(vec![pat.clone()], then_expr)\n-                };\n-                let else_arm = {\n-                    let pattern = sema\n-                        .type_of_pat(&pat)\n-                        .and_then(|ty| TryEnum::from_ty(sema, &ty))\n-                        .map(|it| it.sad_pattern())\n-                        .unwrap_or_else(|| make::placeholder_pat().into());\n-                    let else_expr = unwrap_trivial_block(else_block);\n-                    make::match_arm(vec![pattern], else_expr)\n-                };\n-                make::expr_match(expr, make::match_arm_list(vec![then_arm, else_arm]))\n+    acc.add(AssistId(\"replace_if_let_with_match\"), \"Replace with match\", target, move |edit| {\n+        let match_expr = {\n+            let then_arm = {\n+                let then_expr = unwrap_trivial_block(then_block);\n+                make::match_arm(vec![pat.clone()], then_expr)\n             };\n+            let else_arm = {\n+                let pattern = ctx\n+                    .sema\n+                    .type_of_pat(&pat)\n+                    .and_then(|ty| TryEnum::from_ty(&ctx.sema, &ty))\n+                    .map(|it| it.sad_pattern())\n+                    .unwrap_or_else(|| make::placeholder_pat().into());\n+                let else_expr = unwrap_trivial_block(else_block);\n+                make::match_arm(vec![pattern], else_expr)\n+            };\n+            make::expr_match(expr, make::match_arm_list(vec![then_arm, else_arm]))\n+        };\n \n-            let match_expr = IndentLevel::from_node(if_expr.syntax()).increase_indent(match_expr);\n+        let match_expr = IndentLevel::from_node(if_expr.syntax()).increase_indent(match_expr);\n \n-            edit.set_cursor(if_expr.syntax().text_range().start());\n-            edit.replace_ast::<ast::Expr>(if_expr.into(), match_expr);\n-        },\n-    )\n+        edit.set_cursor(if_expr.syntax().text_range().start());\n+        edit.replace_ast::<ast::Expr>(if_expr.into(), match_expr);\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "d3f214591af058404a1ec60d482a8276da060cef", "filename": "crates/ra_assists/src/handlers/replace_let_with_if_let.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -9,11 +9,7 @@ use ra_syntax::{\n     AstNode, T,\n };\n \n-use crate::{\n-    assist_ctx::{Assist, AssistCtx},\n-    utils::TryEnum,\n-    AssistId,\n-};\n+use crate::{utils::TryEnum, AssistContext, AssistId, Assists};\n \n // Assist: replace_let_with_if_let\n //\n@@ -39,16 +35,16 @@ use crate::{\n //\n // fn compute() -> Option<i32> { None }\n // ```\n-pub(crate) fn replace_let_with_if_let(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn replace_let_with_if_let(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let let_kw = ctx.find_token_at_offset(T![let])?;\n     let let_stmt = let_kw.ancestors().find_map(ast::LetStmt::cast)?;\n     let init = let_stmt.initializer()?;\n     let original_pat = let_stmt.pat()?;\n     let ty = ctx.sema.type_of_expr(&init)?;\n-    let happy_variant = TryEnum::from_ty(ctx.sema, &ty).map(|it| it.happy_case());\n+    let happy_variant = TryEnum::from_ty(&ctx.sema, &ty).map(|it| it.happy_case());\n \n     let target = let_kw.text_range();\n-    ctx.add_assist(AssistId(\"replace_let_with_if_let\"), \"Replace with if-let\", target, |edit| {\n+    acc.add(AssistId(\"replace_let_with_if_let\"), \"Replace with if-let\", target, |edit| {\n         let with_placeholder: ast::Pat = match happy_variant {\n             None => make::placeholder_pat().into(),\n             Some(var_name) => make::tuple_struct_pat("}, {"sha": "1a81d8a0e0215ce3881642e44c21b5709e707dd8", "filename": "crates/ra_assists/src/handlers/replace_qualified_name_with_use.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -1,11 +1,7 @@\n use hir;\n use ra_syntax::{ast, AstNode, SmolStr, TextRange};\n \n-use crate::{\n-    assist_ctx::{Assist, AssistCtx},\n-    utils::insert_use_statement,\n-    AssistId,\n-};\n+use crate::{utils::insert_use_statement, AssistContext, AssistId, Assists};\n \n // Assist: replace_qualified_name_with_use\n //\n@@ -20,7 +16,10 @@ use crate::{\n //\n // fn process(map: HashMap<String, String>) {}\n // ```\n-pub(crate) fn replace_qualified_name_with_use(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn replace_qualified_name_with_use(\n+    acc: &mut Assists,\n+    ctx: &AssistContext,\n+) -> Option<()> {\n     let path: ast::Path = ctx.find_node_at_offset()?;\n     // We don't want to mess with use statements\n     if path.syntax().ancestors().find_map(ast::UseItem::cast).is_some() {\n@@ -34,18 +33,18 @@ pub(crate) fn replace_qualified_name_with_use(ctx: AssistCtx) -> Option<Assist>\n     }\n \n     let target = path.syntax().text_range();\n-    ctx.add_assist(\n+    acc.add(\n         AssistId(\"replace_qualified_name_with_use\"),\n         \"Replace qualified path with use\",\n         target,\n-        |edit| {\n+        |builder| {\n             let path_to_import = hir_path.mod_path().clone();\n-            insert_use_statement(path.syntax(), &path_to_import, edit);\n+            insert_use_statement(path.syntax(), &path_to_import, ctx, builder);\n \n             if let Some(last) = path.segment() {\n                 // Here we are assuming the assist will provide a correct use statement\n                 // so we can delete the path qualifier\n-                edit.delete(TextRange::new(\n+                builder.delete(TextRange::new(\n                     path.syntax().text_range().start(),\n                     last.syntax().text_range().start(),\n                 ));"}, {"sha": "a46998b8eb09f11e154b3e53c4639c10052b0f2e", "filename": "crates/ra_assists/src/handlers/replace_unwrap_with_match.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{\n     AstNode,\n };\n \n-use crate::{utils::TryEnum, Assist, AssistCtx, AssistId};\n+use crate::{utils::TryEnum, AssistContext, AssistId, Assists};\n \n // Assist: replace_unwrap_with_match\n //\n@@ -29,41 +29,34 @@ use crate::{utils::TryEnum, Assist, AssistCtx, AssistId};\n //     };\n // }\n // ```\n-pub(crate) fn replace_unwrap_with_match(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn replace_unwrap_with_match(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let method_call: ast::MethodCallExpr = ctx.find_node_at_offset()?;\n     let name = method_call.name_ref()?;\n     if name.text() != \"unwrap\" {\n         return None;\n     }\n     let caller = method_call.expr()?;\n     let ty = ctx.sema.type_of_expr(&caller)?;\n-    let happy_variant = TryEnum::from_ty(ctx.sema, &ty)?.happy_case();\n+    let happy_variant = TryEnum::from_ty(&ctx.sema, &ty)?.happy_case();\n     let target = method_call.syntax().text_range();\n-    ctx.add_assist(\n-        AssistId(\"replace_unwrap_with_match\"),\n-        \"Replace unwrap with match\",\n-        target,\n-        |edit| {\n-            let ok_path = make::path_unqualified(make::path_segment(make::name_ref(happy_variant)));\n-            let it = make::bind_pat(make::name(\"a\")).into();\n-            let ok_tuple = make::tuple_struct_pat(ok_path, iter::once(it)).into();\n+    acc.add(AssistId(\"replace_unwrap_with_match\"), \"Replace unwrap with match\", target, |edit| {\n+        let ok_path = make::path_unqualified(make::path_segment(make::name_ref(happy_variant)));\n+        let it = make::bind_pat(make::name(\"a\")).into();\n+        let ok_tuple = make::tuple_struct_pat(ok_path, iter::once(it)).into();\n \n-            let bind_path = make::path_unqualified(make::path_segment(make::name_ref(\"a\")));\n-            let ok_arm = make::match_arm(iter::once(ok_tuple), make::expr_path(bind_path));\n+        let bind_path = make::path_unqualified(make::path_segment(make::name_ref(\"a\")));\n+        let ok_arm = make::match_arm(iter::once(ok_tuple), make::expr_path(bind_path));\n \n-            let unreachable_call = make::unreachable_macro_call().into();\n-            let err_arm =\n-                make::match_arm(iter::once(make::placeholder_pat().into()), unreachable_call);\n+        let unreachable_call = make::unreachable_macro_call().into();\n+        let err_arm = make::match_arm(iter::once(make::placeholder_pat().into()), unreachable_call);\n \n-            let match_arm_list = make::match_arm_list(vec![ok_arm, err_arm]);\n-            let match_expr = make::expr_match(caller.clone(), match_arm_list);\n-            let match_expr =\n-                IndentLevel::from_node(method_call.syntax()).increase_indent(match_expr);\n+        let match_arm_list = make::match_arm_list(vec![ok_arm, err_arm]);\n+        let match_expr = make::expr_match(caller.clone(), match_arm_list);\n+        let match_expr = IndentLevel::from_node(method_call.syntax()).increase_indent(match_expr);\n \n-            edit.set_cursor(caller.syntax().text_range().start());\n-            edit.replace_ast::<ast::Expr>(method_call.into(), match_expr);\n-        },\n-    )\n+        edit.set_cursor(caller.syntax().text_range().start());\n+        edit.replace_ast::<ast::Expr>(method_call.into(), match_expr);\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "159033731f0d1ae0b3614a7b17f72176db46c2c8", "filename": "crates/ra_assists/src/handlers/split_import.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fsplit_import.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -2,7 +2,7 @@ use std::iter::successors;\n \n use ra_syntax::{ast, AstNode, T};\n \n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n // Assist: split_import\n //\n@@ -15,7 +15,7 @@ use crate::{Assist, AssistCtx, AssistId};\n // ```\n // use std::{collections::HashMap};\n // ```\n-pub(crate) fn split_import(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn split_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let colon_colon = ctx.find_token_at_offset(T![::])?;\n     let path = ast::Path::cast(colon_colon.parent())?.qualifier()?;\n     let top_path = successors(Some(path.clone()), |it| it.parent_path()).last()?;\n@@ -29,7 +29,7 @@ pub(crate) fn split_import(ctx: AssistCtx) -> Option<Assist> {\n     let cursor = ctx.frange.range.start();\n \n     let target = colon_colon.text_range();\n-    ctx.add_assist(AssistId(\"split_import\"), \"Split import\", target, |edit| {\n+    acc.add(AssistId(\"split_import\"), \"Split import\", target, |edit| {\n         edit.replace_ast(use_tree, new_tree);\n         edit.set_cursor(cursor);\n     })"}, {"sha": "eba0631a4c242c9a0d9544162a79774f60e49ef6", "filename": "crates/ra_assists/src/handlers/unwrap_block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -1,4 +1,4 @@\n-use crate::{Assist, AssistCtx, AssistId};\n+use crate::{AssistContext, AssistId, Assists};\n \n use ast::LoopBodyOwner;\n use ra_fmt::unwrap_trivial_block;\n@@ -21,7 +21,7 @@ use ra_syntax::{ast, match_ast, AstNode, TextRange, T};\n //     println!(\"foo\");\n // }\n // ```\n-pub(crate) fn unwrap_block(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn unwrap_block(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let l_curly_token = ctx.find_token_at_offset(T!['{'])?;\n     let block = ast::BlockExpr::cast(l_curly_token.parent())?;\n     let parent = block.syntax().parent()?;\n@@ -58,7 +58,7 @@ pub(crate) fn unwrap_block(ctx: AssistCtx) -> Option<Assist> {\n     };\n \n     let target = expr_to_unwrap.syntax().text_range();\n-    ctx.add_assist(AssistId(\"unwrap_block\"), \"Unwrap block\", target, |edit| {\n+    acc.add(AssistId(\"unwrap_block\"), \"Unwrap block\", target, |edit| {\n         edit.set_cursor(expr.syntax().text_range().start());\n \n         let pat_start: &[_] = &[' ', '{', '\\n'];"}, {"sha": "01161376276f7ceadf8ff7fd29a3d09909fa7d41", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -10,7 +10,7 @@ macro_rules! eprintln {\n     ($($tt:tt)*) => { stdx::eprintln!($($tt)*) };\n }\n \n-mod assist_ctx;\n+mod assist_context;\n mod marks;\n #[cfg(test)]\n mod tests;\n@@ -22,7 +22,7 @@ use ra_db::FileRange;\n use ra_ide_db::{source_change::SourceChange, RootDatabase};\n use ra_syntax::TextRange;\n \n-pub(crate) use crate::assist_ctx::{Assist, AssistCtx};\n+pub(crate) use crate::assist_context::{AssistContext, Assists};\n \n /// Unique identifier of the assist, should not be shown to the user\n /// directly.\n@@ -68,13 +68,12 @@ pub struct ResolvedAssist {\n /// returned, without actual edits.\n pub fn unresolved_assists(db: &RootDatabase, range: FileRange) -> Vec<AssistLabel> {\n     let sema = Semantics::new(db);\n-    let ctx = AssistCtx::new(&sema, range, false);\n-    handlers::all()\n-        .iter()\n-        .filter_map(|f| f(ctx.clone()))\n-        .flat_map(|it| it.0)\n-        .map(|a| a.label)\n-        .collect()\n+    let ctx = AssistContext::new(sema, range);\n+    let mut acc = Assists::new_unresolved(&ctx);\n+    handlers::all().iter().for_each(|handler| {\n+        handler(&mut acc, &ctx);\n+    });\n+    acc.finish_unresolved()\n }\n \n /// Return all the assists applicable at the given position.\n@@ -83,31 +82,30 @@ pub fn unresolved_assists(db: &RootDatabase, range: FileRange) -> Vec<AssistLabe\n /// computed.\n pub fn resolved_assists(db: &RootDatabase, range: FileRange) -> Vec<ResolvedAssist> {\n     let sema = Semantics::new(db);\n-    let ctx = AssistCtx::new(&sema, range, true);\n-    let mut a = handlers::all()\n-        .iter()\n-        .filter_map(|f| f(ctx.clone()))\n-        .flat_map(|it| it.0)\n-        .map(|it| it.into_resolved().unwrap())\n-        .collect::<Vec<_>>();\n-    a.sort_by_key(|it| it.label.target.len());\n-    a\n+    let ctx = AssistContext::new(sema, range);\n+    let mut acc = Assists::new_resolved(&ctx);\n+    handlers::all().iter().for_each(|handler| {\n+        handler(&mut acc, &ctx);\n+    });\n+    acc.finish_resolved()\n }\n \n mod handlers {\n-    use crate::{Assist, AssistCtx};\n+    use crate::{AssistContext, Assists};\n \n-    pub(crate) type Handler = fn(AssistCtx) -> Option<Assist>;\n+    pub(crate) type Handler = fn(&mut Assists, &AssistContext) -> Option<()>;\n \n     mod add_custom_impl;\n     mod add_derive;\n     mod add_explicit_type;\n+    mod add_from_impl_for_enum;\n     mod add_function;\n     mod add_impl;\n     mod add_missing_impl_members;\n     mod add_new;\n     mod apply_demorgan;\n     mod auto_import;\n+    mod change_return_type_to_result;\n     mod change_visibility;\n     mod early_return;\n     mod fill_match_arms;\n@@ -124,14 +122,12 @@ mod handlers {\n     mod raw_string;\n     mod remove_dbg;\n     mod remove_mut;\n+    mod reorder_fields;\n     mod replace_if_let_with_match;\n     mod replace_let_with_if_let;\n     mod replace_qualified_name_with_use;\n     mod replace_unwrap_with_match;\n     mod split_import;\n-    mod change_return_type_to_result;\n-    mod add_from_impl_for_enum;\n-    mod reorder_fields;\n     mod unwrap_block;\n \n     pub(crate) fn all() -> &'static [Handler] {"}, {"sha": "45b2d9733e0bb915ad7f925f36912266b2977a0b", "filename": "crates/ra_assists/src/tests.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ftests.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -11,7 +11,7 @@ use test_utils::{\n     RangeOrOffset,\n };\n \n-use crate::{handlers::Handler, resolved_assists, AssistCtx};\n+use crate::{handlers::Handler, resolved_assists, AssistContext, Assists};\n \n pub(crate) fn with_single_file(text: &str) -> (RootDatabase, FileId) {\n     let (mut db, file_id) = RootDatabase::with_single_file(text);\n@@ -71,7 +71,7 @@ enum ExpectedResult<'a> {\n     Target(&'a str),\n }\n \n-fn check(assist: Handler, before: &str, expected: ExpectedResult) {\n+fn check(handler: Handler, before: &str, expected: ExpectedResult) {\n     let (text_without_caret, file_with_caret_id, range_or_offset, db) = if before.contains(\"//-\") {\n         let (mut db, position) = RootDatabase::with_position(before);\n         db.set_local_roots(Arc::new(vec![db.file_source_root(position.file_id)]));\n@@ -90,17 +90,20 @@ fn check(assist: Handler, before: &str, expected: ExpectedResult) {\n     let frange = FileRange { file_id: file_with_caret_id, range: range_or_offset.into() };\n \n     let sema = Semantics::new(&db);\n-    let assist_ctx = AssistCtx::new(&sema, frange, true);\n-\n-    match (assist(assist_ctx), expected) {\n+    let ctx = AssistContext::new(sema, frange);\n+    let mut acc = Assists::new_resolved(&ctx);\n+    handler(&mut acc, &ctx);\n+    let mut res = acc.finish_resolved();\n+    let assist = res.pop();\n+    match (assist, expected) {\n         (Some(assist), ExpectedResult::After(after)) => {\n-            let mut action = assist.0[0].source_change.clone().unwrap();\n-            let change = action.source_file_edits.pop().unwrap();\n+            let mut source_change = assist.source_change;\n+            let change = source_change.source_file_edits.pop().unwrap();\n \n             let mut actual = db.file_text(change.file_id).as_ref().to_owned();\n             change.edit.apply(&mut actual);\n \n-            match action.cursor_position {\n+            match source_change.cursor_position {\n                 None => {\n                     if let RangeOrOffset::Offset(before_cursor_pos) = range_or_offset {\n                         let off = change\n@@ -116,7 +119,7 @@ fn check(assist: Handler, before: &str, expected: ExpectedResult) {\n             assert_eq_text!(after, &actual);\n         }\n         (Some(assist), ExpectedResult::Target(target)) => {\n-            let range = assist.0[0].label.target;\n+            let range = assist.label.target;\n             assert_eq_text!(&text_without_caret[range], target);\n         }\n         (Some(_), ExpectedResult::NotApplicable) => panic!(\"assist should not be applicable!\"),"}, {"sha": "1214e3cd47a66492234e0ad9fc1572612f807b37", "filename": "crates/ra_assists/src/utils/insert_use.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Futils%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4867968d22899395e6551f22641b3617e995140c/crates%2Fra_assists%2Fsrc%2Futils%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Futils%2Finsert_use.rs?ref=4867968d22899395e6551f22641b3617e995140c", "patch": "@@ -2,7 +2,6 @@\n // FIXME: rewrite according to the plan, outlined in\n // https://github.com/rust-analyzer/rust-analyzer/issues/3301#issuecomment-592931553\n \n-use crate::assist_ctx::ActionBuilder;\n use hir::{self, ModPath};\n use ra_syntax::{\n     ast::{self, NameOwner},\n@@ -12,17 +11,20 @@ use ra_syntax::{\n };\n use ra_text_edit::TextEditBuilder;\n \n+use crate::assist_context::{AssistBuilder, AssistContext};\n+\n /// Creates and inserts a use statement for the given path to import.\n /// The use statement is inserted in the scope most appropriate to the\n /// the cursor position given, additionally merged with the existing use imports.\n pub(crate) fn insert_use_statement(\n     // Ideally the position of the cursor, used to\n     position: &SyntaxNode,\n     path_to_import: &ModPath,\n-    edit: &mut ActionBuilder,\n+    ctx: &AssistContext,\n+    builder: &mut AssistBuilder,\n ) {\n     let target = path_to_import.to_string().split(\"::\").map(SmolStr::new).collect::<Vec<_>>();\n-    let container = edit.ctx().sema.ancestors_with_macros(position.clone()).find_map(|n| {\n+    let container = ctx.sema.ancestors_with_macros(position.clone()).find_map(|n| {\n         if let Some(module) = ast::Module::cast(n.clone()) {\n             return module.item_list().map(|it| it.syntax().clone());\n         }\n@@ -31,7 +33,7 @@ pub(crate) fn insert_use_statement(\n \n     if let Some(container) = container {\n         let action = best_action_for_target(container, position.clone(), &target);\n-        make_assist(&action, &target, edit.text_edit_builder());\n+        make_assist(&action, &target, builder.text_edit_builder());\n     }\n }\n "}]}