{"sha": "6df5ae4fb03734dd98db01a9f488998b1d4498ab", "node_id": "C_kwDOAAsO6NoAKDZkZjVhZTRmYjAzNzM0ZGQ5OGRiMDFhOWY0ODg5OThiMWQ0NDk4YWI", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2023-03-03T03:15:15Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2023-03-03T07:39:00Z"}, "message": "Match unmatched backticks in comments in compiler/", "tree": {"sha": "d5c0058297d36c2e830ad316af52183c0e423792", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5c0058297d36c2e830ad316af52183c0e423792"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6df5ae4fb03734dd98db01a9f488998b1d4498ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6df5ae4fb03734dd98db01a9f488998b1d4498ab", "html_url": "https://github.com/rust-lang/rust/commit/6df5ae4fb03734dd98db01a9f488998b1d4498ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6df5ae4fb03734dd98db01a9f488998b1d4498ab/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff2c609d662f0ffae9aafa6ff9f60441473e958e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff2c609d662f0ffae9aafa6ff9f60441473e958e", "html_url": "https://github.com/rust-lang/rust/commit/ff2c609d662f0ffae9aafa6ff9f60441473e958e"}], "stats": {"total": 53, "additions": 28, "deletions": 25}, "files": [{"sha": "3a0af04f9eb98c11304f140d06ba09d0763fc4a3", "filename": "compiler/rustc_ast/src/util/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs?ref=6df5ae4fb03734dd98db01a9f488998b1d4498ab", "patch": "@@ -225,7 +225,7 @@ impl AssocOp {\n             AssignOp(_) | // `{ 42 } +=`\n             As | // `{ 42 } as usize`\n             // Equal | // `{ 42 } == { 42 }`    Accepting these here would regress incorrect\n-            // NotEqual | // `{ 42 } != { 42 }  struct literals parser recovery.\n+            // NotEqual | // `{ 42 } != { 42 }` struct literals parser recovery.\n             Colon, // `{ 42 }: usize`\n         )\n     }"}, {"sha": "2cc009410f40753b3ba44378563a9123ddff3b63", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=6df5ae4fb03734dd98db01a9f488998b1d4498ab", "patch": "@@ -192,7 +192,7 @@ impl<'a> AstValidator<'a> {\n                 // We allow these:\n                 //  - `Option<impl Trait>`\n                 //  - `option::Option<impl Trait>`\n-                //  - `option::Option<T>::Foo<impl Trait>\n+                //  - `option::Option<T>::Foo<impl Trait>`\n                 //\n                 // But not these:\n                 //  - `<impl Trait>::Foo`"}, {"sha": "691d3f8d942b3f0c7806ab495444a7185d70070c", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=6df5ae4fb03734dd98db01a9f488998b1d4498ab", "patch": "@@ -1873,7 +1873,7 @@ pub(super) fn check_type_bounds<'tcx>(\n     //     type Bar<C> =...\n     // }\n     //\n-    // - `impl_trait_ref` would be `<(A, B) as Foo<u32>>\n+    // - `impl_trait_ref` would be `<(A, B) as Foo<u32>>`\n     // - `impl_ty_substs` would be `[A, B, ^0.0]` (`^0.0` here is the bound var with db 0 and index 0)\n     // - `rebased_substs` would be `[(A, B), u32, ^0.0]`, combining the substs from\n     //    the *trait* with the generic associated type parameters (as bound vars)."}, {"sha": "ffb68abf978de6a34c2360d02edd207c0ac3c658", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=6df5ae4fb03734dd98db01a9f488998b1d4498ab", "patch": "@@ -437,7 +437,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n             }\n \n             // Here we are considering a case of converting\n-            // `S<P0...Pn>` to S<Q0...Qn>`. As an example, let's imagine a struct `Foo<T, U>`,\n+            // `S<P0...Pn>` to `S<Q0...Qn>`. As an example, let's imagine a struct `Foo<T, U>`,\n             // which acts like a pointer to `U`, but carries along some extra data of type `T`:\n             //\n             //     struct Foo<T, U> {"}, {"sha": "4d3969d28aa2d6f95ab1f97fbc6e919eb85d64a4", "filename": "compiler/rustc_hir_typeck/src/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs?ref=6df5ae4fb03734dd98db01a9f488998b1d4498ab", "patch": "@@ -636,7 +636,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         // `&&Some(x,)` `place_foo`\n         //  `&Some(x,)` `deref { place_foo}`\n         //   `Some(x,)` `deref { deref { place_foo }}`\n-        //        (x,)` `field0 { deref { deref { place_foo }}}` <- resulting place\n+        //       `(x,)` `field0 { deref { deref { place_foo }}}` <- resulting place\n         //\n         // The above example has no adjustments. If the code were instead the (after adjustments,\n         // equivalent) version"}, {"sha": "3ab01f7809b041c1ec829500523977fd22687a1b", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=6df5ae4fb03734dd98db01a9f488998b1d4498ab", "patch": "@@ -1621,7 +1621,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     fn encode_info_for_closure(&mut self, def_id: LocalDefId) {\n         // NOTE(eddyb) `tcx.type_of(def_id)` isn't used because it's fully generic,\n-        // including on the signature, which is inferred in `typeck.\n+        // including on the signature, which is inferred in `typeck`.\n         let typeck_result: &'tcx ty::TypeckResults<'tcx> = self.tcx.typeck(def_id);\n         let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n         let ty = typeck_result.node_type(hir_id);"}, {"sha": "99cdb769da1e788ccb534844114937dbb5ef1665", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=6df5ae4fb03734dd98db01a9f488998b1d4498ab", "patch": "@@ -2908,7 +2908,7 @@ fn pretty_print_const_value<'tcx>(\n             // the `destructure_const` query with an empty `ty::ParamEnv` without\n             // introducing ICEs (e.g. via `layout_of`) from missing bounds.\n             // E.g. `transmute([0usize; 2]): (u8, *mut T)` needs to know `T: Sized`\n-            // to be able to destructure the tuple into `(0u8, *mut T)\n+            // to be able to destructure the tuple into `(0u8, *mut T)`\n             //\n             // FIXME(eddyb) for `--emit=mir`/`-Z dump-mir`, we should provide the\n             // correct `ty::ParamEnv` to allow printing *all* constant values."}, {"sha": "28a3b51b7fc925cfaa3bc3f0de86fdaf3cba0052", "filename": "compiler/rustc_middle/src/mir/spanview.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs?ref=6df5ae4fb03734dd98db01a9f488998b1d4498ab", "patch": "@@ -11,7 +11,7 @@ use std::io::{self, Write};\n pub const TOOLTIP_INDENT: &str = \"    \";\n \n const CARET: char = '\\u{2038}'; // Unicode `CARET`\n-const ANNOTATION_LEFT_BRACKET: char = '\\u{298a}'; // Unicode `Z NOTATION RIGHT BINDING BRACKET\n+const ANNOTATION_LEFT_BRACKET: char = '\\u{298a}'; // Unicode `Z NOTATION RIGHT BINDING BRACKET`\n const ANNOTATION_RIGHT_BRACKET: char = '\\u{2989}'; // Unicode `Z NOTATION LEFT BINDING BRACKET`\n const NEW_LINE_SPAN: &str = \"</span>\\n<span class=\\\"line\\\">\";\n const HEADER: &str = r#\"<!DOCTYPE html>"}, {"sha": "e9e121f9c9b0483962570ee54f05ca227851f70c", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=6df5ae4fb03734dd98db01a9f488998b1d4498ab", "patch": "@@ -2187,7 +2187,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // Actually intern type lists as lists of `GenericArg`s.\n         //\n         // Transmuting from `Ty<'tcx>` to `GenericArg<'tcx>` is sound\n-        // as explained in ty_slice_as_generic_arg`. With this,\n+        // as explained in `ty_slice_as_generic_arg`. With this,\n         // we guarantee that even when transmuting between `List<Ty<'tcx>>`\n         // and `List<GenericArg<'tcx>>`, the uniqueness requirement for\n         // lists is upheld."}, {"sha": "92a040068dd75833d5b51b0a5fe9fff786c96fa0", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=6df5ae4fb03734dd98db01a9f488998b1d4498ab", "patch": "@@ -105,7 +105,7 @@ impl<'tcx> VariantDef {\n impl<'tcx> Ty<'tcx> {\n     pub fn inhabited_predicate(self, tcx: TyCtxt<'tcx>) -> InhabitedPredicate<'tcx> {\n         match self.kind() {\n-            // For now, union`s are always considered inhabited\n+            // For now, unions are always considered inhabited\n             Adt(adt, _) if adt.is_union() => InhabitedPredicate::True,\n             // Non-exhaustive ADTs from other crates are always considered inhabited\n             Adt(adt, _) if adt.is_variant_list_non_exhaustive() && !adt.did().is_local() => {"}, {"sha": "dce18a5850f3fc2bb264e5793fc6b9192971bad0", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=6df5ae4fb03734dd98db01a9f488998b1d4498ab", "patch": "@@ -710,7 +710,7 @@ impl<'tcx> Predicate<'tcx> {\n         //   The substitution from the input trait-ref is therefore going to be\n         //   `'a => 'x` (where `'x` has a DB index of 1).\n         // - The supertrait-ref is `for<'b> Bar1<'a,'b>`, where `'a` is an\n-        //   early-bound parameter and `'b' is a late-bound parameter with a\n+        //   early-bound parameter and `'b` is a late-bound parameter with a\n         //   DB index of 1.\n         // - If we replace `'a` with `'x` from the input, it too will have\n         //   a DB index of 1, and thus we'll have `for<'x,'b> Bar1<'x,'b>`"}, {"sha": "536745d2cfea94de15c82bbe57654c1926d5dd11", "filename": "compiler/rustc_mir_transform/src/check_const_item_mutation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs?ref=6df5ae4fb03734dd98db01a9f488998b1d4498ab", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> ConstMutationChecker<'_, 'tcx> {\n         //\n         // `unsafe { *FOO = 0; *BAR.field = 1; }`\n         // `unsafe { &mut *FOO }`\n-        // `unsafe { (*ARRAY)[0] = val; }\n+        // `unsafe { (*ARRAY)[0] = val; }`\n         if !place.projection.iter().any(|p| matches!(p, PlaceElem::Deref)) {\n             let source_info = self.body.source_info(location);\n             let lint_root = self.body.source_scopes[source_info.scope]"}, {"sha": "8ee316773aeaf0daeef4f5428b381e9bce866278", "filename": "compiler/rustc_mir_transform/src/coverage/spans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs?ref=6df5ae4fb03734dd98db01a9f488998b1d4498ab", "patch": "@@ -407,7 +407,7 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n                 if self.prev().is_macro_expansion() && self.curr().is_macro_expansion() {\n                     // Macros that expand to include branching (such as\n                     // `assert_eq!()`, `assert_ne!()`, `info!()`, `debug!()`, or\n-                    // `trace!()) typically generate callee spans with identical\n+                    // `trace!()`) typically generate callee spans with identical\n                     // ranges (typically the full span of the macro) for all\n                     // `BasicBlocks`. This makes it impossible to distinguish\n                     // the condition (`if val1 != val2`) from the optional"}, {"sha": "cdd28ae0c0197df622981fb0221a8b4babfdd7ed", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=6df5ae4fb03734dd98db01a9f488998b1d4498ab", "patch": "@@ -248,7 +248,7 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) ->\n \n     // N.B., this `borrow()` is guaranteed to be valid (i.e., the value\n     // cannot yet be stolen), because `mir_promoted()`, which steals\n-    // from `mir_const(), forces this query to execute before\n+    // from `mir_const()`, forces this query to execute before\n     // performing the steal.\n     let body = &tcx.mir_const(def).borrow();\n "}, {"sha": "c6e7468aab4299424d3e36c9ed5ca763ba77be01", "filename": "compiler/rustc_mir_transform/src/lower_slice_len.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs?ref=6df5ae4fb03734dd98db01a9f488998b1d4498ab", "patch": "@@ -68,8 +68,11 @@ fn lower_slice_len_call<'tcx>(\n                 ty::FnDef(fn_def_id, _) if fn_def_id == &slice_len_fn_item_def_id => {\n                     // perform modifications\n                     // from something like `_5 = core::slice::<impl [u8]>::len(move _6) -> bb1`\n-                    // into `_5 = Len(*_6)\n+                    // into:\n+                    // ```\n+                    // _5 = Len(*_6)\n                     // goto bb1\n+                    // ```\n \n                     // make new RValue for Len\n                     let deref_arg = tcx.mk_place_deref(arg);"}, {"sha": "b0ab0f1062471523a87d3ccec098dbff86c1a6cd", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=6df5ae4fb03734dd98db01a9f488998b1d4498ab", "patch": "@@ -134,11 +134,11 @@ impl ToAttrTokenStream for LazyAttrTokenStreamImpl {\n             // Process the replace ranges, starting from the highest start\n             // position and working our way back. If have tokens like:\n             //\n-            // `#[cfg(FALSE)]` struct Foo { #[cfg(FALSE)] field: bool }`\n+            // `#[cfg(FALSE)] struct Foo { #[cfg(FALSE)] field: bool }`\n             //\n             // Then we will generate replace ranges for both\n             // the `#[cfg(FALSE)] field: bool` and the entire\n-            // `#[cfg(FALSE)]` struct Foo { #[cfg(FALSE)] field: bool }`\n+            // `#[cfg(FALSE)] struct Foo { #[cfg(FALSE)] field: bool }`\n             //\n             // By starting processing from the replace range with the greatest\n             // start position, we ensure that any replace range which encloses"}, {"sha": "da82e4724d1b5dba8bfb0ede4d17c2e315ae782f", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=6df5ae4fb03734dd98db01a9f488998b1d4498ab", "patch": "@@ -335,7 +335,7 @@ impl TokenCursor {\n             num_of_hashes = cmp::max(num_of_hashes, count);\n         }\n \n-        // `/// foo` becomes `doc = r\"foo\".\n+        // `/// foo` becomes `doc = r\"foo\"`.\n         let delim_span = DelimSpan::from_single(span);\n         let body = TokenTree::Delimited(\n             delim_span,"}, {"sha": "5e2d2d3e5a704aafc48bb2a2bef2f4e48fa90c2d", "filename": "compiler/rustc_passes/src/hir_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs?ref=6df5ae4fb03734dd98db01a9f488998b1d4498ab", "patch": "@@ -646,7 +646,7 @@ impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n     }\n \n     // `UseTree` has one inline use (in `ast::ItemKind::Use`) and one\n-    // non-inline use (in `ast::UseTreeKind::Nested). The former case is more\n+    // non-inline use (in `ast::UseTreeKind::Nested`). The former case is more\n     // common, so we don't implement `visit_use_tree` and tolerate the missed\n     // coverage in the latter case.\n "}, {"sha": "46e34462cf2252035e60be227dd30226c363013b", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=6df5ae4fb03734dd98db01a9f488998b1d4498ab", "patch": "@@ -333,7 +333,7 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n                 },\n             );\n \n-            // `Encode the file footer.\n+            // Encode the file footer.\n             let footer_pos = encoder.position() as u64;\n             encoder.encode_tagged(\n                 TAG_FILE_FOOTER,"}, {"sha": "b8ddc4552578bed8fdfbae84da939203a9d85e2e", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=6df5ae4fb03734dd98db01a9f488998b1d4498ab", "patch": "@@ -878,7 +878,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         );\n         let is_assoc_fn = self.self_type_is_available();\n         if let Some((fn_kind, span)) = &self.diagnostic_metadata.current_function {\n-            // The current function has a `self' parameter, but we were unable to resolve\n+            // The current function has a `self` parameter, but we were unable to resolve\n             // a reference to `self`. This can only happen if the `self` identifier we\n             // are resolving came from a different hygiene context.\n             if fn_kind.decl().inputs.get(0).map_or(false, |p| p.is_self()) {"}, {"sha": "162c15574b56ce8dd285f85228bf6795a2b2c949", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=6df5ae4fb03734dd98db01a9f488998b1d4498ab", "patch": "@@ -235,7 +235,7 @@ impl<D: Decoder> Decodable<D> for DefIndex {\n pub struct DefId {\n     // cfg-ing the order of fields so that the `DefIndex` which is high entropy always ends up in\n     // the lower bits no matter the endianness. This allows the compiler to turn that `Hash` impl\n-    // into a direct call to 'u64::hash(_)`.\n+    // into a direct call to `u64::hash(_)`.\n     #[cfg(not(all(target_pointer_width = \"64\", target_endian = \"big\")))]\n     pub index: DefIndex,\n     pub krate: CrateNum,"}, {"sha": "6272bf7f25eb102d81af5e0b1a1c7b14019b002c", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=6df5ae4fb03734dd98db01a9f488998b1d4498ab", "patch": "@@ -1954,7 +1954,7 @@ impl Interner {\n         let name = Symbol::new(inner.strings.len() as u32);\n \n         // SAFETY: we convert from `&str` to `&[u8]`, clone it into the arena,\n-        // and immediately convert the clone back to `&[u8], all because there\n+        // and immediately convert the clone back to `&[u8]`, all because there\n         // is no `inner.arena.alloc_str()` method. This is clearly safe.\n         let string: &str =\n             unsafe { str::from_utf8_unchecked(inner.arena.alloc_slice(string.as_bytes())) };"}, {"sha": "e91057356a2dc1a170f83a02b89d3eb931071dd9", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=6df5ae4fb03734dd98db01a9f488998b1d4498ab", "patch": "@@ -339,7 +339,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // Essentially any user-written impl will match with an error type,\n         // so creating `ImplCandidates` isn't useful. However, we might\n-        // end up finding a candidate elsewhere (e.g. a `BuiltinCandidate` for `Sized)\n+        // end up finding a candidate elsewhere (e.g. a `BuiltinCandidate` for `Sized`)\n         // This helps us avoid overflow: see issue #72839\n         // Since compilation is already guaranteed to fail, this is just\n         // to try to show the 'nicest' possible errors to the user."}, {"sha": "4377de158290a6a73fde8c810343efdcee388aa1", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df5ae4fb03734dd98db01a9f488998b1d4498ab/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=6df5ae4fb03734dd98db01a9f488998b1d4498ab", "patch": "@@ -727,7 +727,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             // Otherwise, we can say that `T: NonAutoTrait` is\n                             // true.\n                             // Let's imagine we have a predicate stack like\n-                            //         `Foo: Bar -> WF(T) -> T: NonAutoTrait -> T: Auto\n+                            //         `Foo: Bar -> WF(T) -> T: NonAutoTrait -> T: Auto`\n                             // depth   ^1                    ^2                 ^3\n                             // and the current predicate is `WF(T)`. `wf_args`\n                             // would contain `(T, 1)`. We want to check all"}]}