{"sha": "0d225bcf1eb270564297c1f094d54a685a5ed08e", "node_id": "C_kwDOAAsO6NoAKDBkMjI1YmNmMWViMjcwNTY0Mjk3YzFmMDk0ZDU0YTY4NWE1ZWQwOGU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-07T09:34:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-07T09:34:17Z"}, "message": "Auto merge of #2780 - RalfJung:rustup, r=RalfJung\n\nRustup", "tree": {"sha": "2e1b2e5e0a66252af9572ab6d810e41b9fa84b1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e1b2e5e0a66252af9572ab6d810e41b9fa84b1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d225bcf1eb270564297c1f094d54a685a5ed08e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d225bcf1eb270564297c1f094d54a685a5ed08e", "html_url": "https://github.com/rust-lang/rust/commit/0d225bcf1eb270564297c1f094d54a685a5ed08e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d225bcf1eb270564297c1f094d54a685a5ed08e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c8d4073a4490671b05f3b5f5e6810cfdc23a641", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c8d4073a4490671b05f3b5f5e6810cfdc23a641", "html_url": "https://github.com/rust-lang/rust/commit/6c8d4073a4490671b05f3b5f5e6810cfdc23a641"}, {"sha": "8461c0eb673e769cae656ce52dd662829437e200", "url": "https://api.github.com/repos/rust-lang/rust/commits/8461c0eb673e769cae656ce52dd662829437e200", "html_url": "https://github.com/rust-lang/rust/commit/8461c0eb673e769cae656ce52dd662829437e200"}], "stats": {"total": 13929, "additions": 8438, "deletions": 5491}, "files": [{"sha": "a992129773e2967f8f411fdf7fb33e58620a467f", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -37,6 +37,7 @@ jobs:\n     name: PR\n     env:\n       CI_JOB_NAME: \"${{ matrix.name }}\"\n+      CARGO_REGISTRIES_CRATES_IO_PROTOCOL: sparse\n       SCCACHE_BUCKET: rust-lang-ci-sccache2\n       TOOLSTATE_REPO: \"https://github.com/rust-lang-nursery/rust-toolstate\"\n       CACHE_DOMAIN: ci-caches.rust-lang.org\n@@ -162,6 +163,7 @@ jobs:\n     name: auto\n     env:\n       CI_JOB_NAME: \"${{ matrix.name }}\"\n+      CARGO_REGISTRIES_CRATES_IO_PROTOCOL: sparse\n       SCCACHE_BUCKET: rust-lang-ci-sccache2\n       DEPLOY_BUCKET: rust-lang-ci2\n       TOOLSTATE_REPO: \"https://github.com/rust-lang-nursery/rust-toolstate\"\n@@ -584,6 +586,7 @@ jobs:\n     name: try\n     env:\n       CI_JOB_NAME: \"${{ matrix.name }}\"\n+      CARGO_REGISTRIES_CRATES_IO_PROTOCOL: sparse\n       SCCACHE_BUCKET: rust-lang-ci-sccache2\n       DEPLOY_BUCKET: rust-lang-ci2\n       TOOLSTATE_REPO: \"https://github.com/rust-lang-nursery/rust-toolstate\""}, {"sha": "b814767786f2af8b235793fc32708fcda2459a55", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -166,6 +166,7 @@ Eduard-Mihai Burtescu <edy.burt@gmail.com>\n Eduardo Bautista <me@eduardobautista.com> <=>\n Eduardo Bautista <me@eduardobautista.com> <mail@eduardobautista.com>\n Eduardo Broto <ebroto@tutanota.com>\n+Edward Shen <code@eddie.sh> <xes@meta.com>\n Elliott Slaughter <elliottslaughter@gmail.com> <eslaughter@mozilla.com>\n Elly Fong-Jones <elly@leptoquark.net>\n Eric Holk <eric.holk@gmail.com> <eholk@cs.indiana.edu>"}, {"sha": "b2948fb38959e8df8c256f68ade4377609037f7f", "filename": "Cargo.lock", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -3567,6 +3567,7 @@ dependencies = [\n  \"jemalloc-sys\",\n  \"rustc_codegen_ssa\",\n  \"rustc_driver\",\n+ \"rustc_driver_impl\",\n  \"rustc_smir\",\n ]\n \n@@ -3688,7 +3689,6 @@ dependencies = [\n name = \"rustc_ast_lowering\"\n version = \"0.0.0\"\n dependencies = [\n- \"rustc_arena\",\n  \"rustc_ast\",\n  \"rustc_ast_pretty\",\n  \"rustc_data_structures\",\n@@ -3697,7 +3697,6 @@ dependencies = [\n  \"rustc_index\",\n  \"rustc_macros\",\n  \"rustc_middle\",\n- \"rustc_query_system\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -3730,7 +3729,6 @@ name = \"rustc_ast_pretty\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustc_ast\",\n- \"rustc_parse_format\",\n  \"rustc_span\",\n ]\n \n@@ -3837,7 +3835,6 @@ dependencies = [\n  \"rustc_metadata\",\n  \"rustc_middle\",\n  \"rustc_query_system\",\n- \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_symbol_mangling\",\n@@ -3863,7 +3860,6 @@ dependencies = [\n  \"rustc_arena\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n- \"rustc_const_eval\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_fs_util\",\n@@ -3904,7 +3900,6 @@ dependencies = [\n  \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_mir_dataflow\",\n- \"rustc_query_system\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -3946,6 +3941,13 @@ dependencies = [\n [[package]]\n name = \"rustc_driver\"\n version = \"0.0.0\"\n+dependencies = [\n+ \"rustc_driver_impl\",\n+]\n+\n+[[package]]\n+name = \"rustc_driver_impl\"\n+version = \"0.0.0\"\n dependencies = [\n  \"libc\",\n  \"rustc_ast\",\n@@ -4092,15 +4094,12 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_feature\",\n- \"rustc_graphviz\",\n  \"rustc_hir\",\n- \"rustc_hir_pretty\",\n  \"rustc_index\",\n  \"rustc_infer\",\n  \"rustc_lint\",\n  \"rustc_macros\",\n  \"rustc_middle\",\n- \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -4187,7 +4186,6 @@ dependencies = [\n  \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_serialize\",\n- \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"smallvec\",\n@@ -4230,7 +4228,6 @@ dependencies = [\n  \"rustc_privacy\",\n  \"rustc_query_impl\",\n  \"rustc_resolve\",\n- \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_symbol_mangling\",\n@@ -4396,7 +4393,6 @@ dependencies = [\n  \"rustc_apfloat\",\n  \"rustc_arena\",\n  \"rustc_ast\",\n- \"rustc_attr\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n@@ -4428,7 +4424,6 @@ dependencies = [\n  \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_serialize\",\n- \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"smallvec\",\n@@ -4559,7 +4554,6 @@ dependencies = [\n  \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n- \"rustc_trait_selection\",\n  \"tracing\",\n ]\n \n@@ -4580,7 +4574,6 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n- \"rustc_target\",\n  \"thin-vec\",\n  \"tracing\",\n ]\n@@ -4781,7 +4774,6 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_infer\",\n- \"rustc_lint_defs\",\n  \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_parse_format\",\n@@ -4803,7 +4795,6 @@ dependencies = [\n  \"chalk-ir\",\n  \"chalk-solve\",\n  \"rustc_ast\",\n- \"rustc_attr\",\n  \"rustc_data_structures\",\n  \"rustc_hir\",\n  \"rustc_index\","}, {"sha": "41003ad83f31152956dce55a9feb2623f6b4fcc9", "filename": "compiler/rustc/Cargo.toml", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc%2FCargo.toml?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -5,6 +5,7 @@ edition = \"2021\"\n \n [dependencies]\n rustc_driver = { path = \"../rustc_driver\" }\n+rustc_driver_impl = { path = \"../rustc_driver_impl\" }\n \n # Make sure rustc_codegen_ssa ends up in the sysroot, because this\n # crate is intended to be used by codegen backends, which may not be in-tree.\n@@ -20,6 +21,6 @@ features = ['unprefixed_malloc_on_supported_platforms']\n \n [features]\n jemalloc = ['jemalloc-sys']\n-llvm = ['rustc_driver/llvm']\n-max_level_info = ['rustc_driver/max_level_info']\n-rustc_use_parallel_compiler = ['rustc_driver/rustc_use_parallel_compiler']\n+llvm = ['rustc_driver_impl/llvm']\n+max_level_info = ['rustc_driver_impl/max_level_info']\n+rustc_use_parallel_compiler = ['rustc_driver_impl/rustc_use_parallel_compiler']"}, {"sha": "0306cb5ce6abd7615d068c093cff045333e2e26b", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1439,21 +1439,12 @@ impl<V: Idx> fmt::Debug for LayoutS<V> {\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum PointerKind {\n-    /// Most general case, we know no restrictions to tell LLVM.\n-    SharedMutable,\n-\n-    /// `&T` where `T` contains no `UnsafeCell`, is `dereferenceable`, `noalias` and `readonly`.\n-    Frozen,\n-\n-    /// `&mut T` which is `dereferenceable` and `noalias` but not `readonly`.\n-    UniqueBorrowed,\n-\n-    /// `&mut !Unpin`, which is `dereferenceable` but neither `noalias` nor `readonly`.\n-    UniqueBorrowedPinned,\n-\n-    /// `Box<T>`, which is `noalias` (even on return types, unlike the above) but neither `readonly`\n-    /// nor `dereferenceable`.\n-    UniqueOwned,\n+    /// Shared reference. `frozen` indicates the absence of any `UnsafeCell`.\n+    SharedRef { frozen: bool },\n+    /// Mutable reference. `unpin` indicates the absence of any pinned data.\n+    MutableRef { unpin: bool },\n+    /// Box. `unpin` indicates the absence of any pinned data.\n+    Box { unpin: bool },\n }\n \n /// Note that this information is advisory only, and backends are free to ignore it."}, {"sha": "f2258fecfeafc6645a4b78cdd142470f6328eeb2", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1826,6 +1826,13 @@ pub enum LitKind {\n }\n \n impl LitKind {\n+    pub fn str(&self) -> Option<Symbol> {\n+        match *self {\n+            LitKind::Str(s, _) => Some(s),\n+            _ => None,\n+        }\n+    }\n+\n     /// Returns `true` if this literal is a string.\n     pub fn is_str(&self) -> bool {\n         matches!(self, LitKind::Str(..))"}, {"sha": "cd60506dd80795b1e9314ec6aeaec8f668267526", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 43, "deletions": 23, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -140,17 +140,14 @@ impl Attribute {\n \n     pub fn value_str(&self) -> Option<Symbol> {\n         match &self.kind {\n-            AttrKind::Normal(normal) => normal.item.meta_kind().and_then(|kind| kind.value_str()),\n+            AttrKind::Normal(normal) => normal.item.value_str(),\n             AttrKind::DocComment(..) => None,\n         }\n     }\n \n     pub fn meta_item_list(&self) -> Option<Vec<NestedMetaItem>> {\n         match &self.kind {\n-            AttrKind::Normal(normal) => match normal.item.meta_kind() {\n-                Some(MetaItemKind::List(list)) => Some(list),\n-                _ => None,\n-            },\n+            AttrKind::Normal(normal) => normal.item.meta_item_list(),\n             AttrKind::DocComment(..) => None,\n         }\n     }\n@@ -216,6 +213,20 @@ impl MetaItem {\n     }\n }\n \n+impl AttrArgsEq {\n+    fn value_str(&self) -> Option<Symbol> {\n+        match self {\n+            AttrArgsEq::Ast(expr) => match expr.kind {\n+                ExprKind::Lit(token_lit) => {\n+                    LitKind::from_token_lit(token_lit).ok().and_then(|lit| lit.str())\n+                }\n+                _ => None,\n+            },\n+            AttrArgsEq::Hir(lit) => lit.kind.str(),\n+        }\n+    }\n+}\n+\n impl AttrItem {\n     pub fn span(&self) -> Span {\n         self.args.span().map_or(self.path.span, |args_span| self.path.span.to(args_span))\n@@ -228,6 +239,22 @@ impl AttrItem {\n     pub fn meta_kind(&self) -> Option<MetaItemKind> {\n         MetaItemKind::from_attr_args(&self.args)\n     }\n+\n+    fn meta_item_list(&self) -> Option<Vec<NestedMetaItem>> {\n+        match &self.args {\n+            AttrArgs::Delimited(args) if args.delim == MacDelimiter::Parenthesis => {\n+                MetaItemKind::list_from_tokens(args.tokens.clone())\n+            }\n+            AttrArgs::Delimited(_) | AttrArgs::Eq(..) | AttrArgs::Empty => None,\n+        }\n+    }\n+\n+    fn value_str(&self) -> Option<Symbol> {\n+        match &self.args {\n+            AttrArgs::Eq(_, args) => args.value_str(),\n+            AttrArgs::Delimited(_) | AttrArgs::Empty => None,\n+        }\n+    }\n }\n \n impl Attribute {\n@@ -247,13 +274,11 @@ impl Attribute {\n     /// * `#[doc = \"doc\"]` returns `Some((\"doc\", CommentKind::Line))`.\n     /// * `#[doc(...)]` returns `None`.\n     pub fn doc_str_and_comment_kind(&self) -> Option<(Symbol, CommentKind)> {\n-        match self.kind {\n-            AttrKind::DocComment(kind, data) => Some((data, kind)),\n-            AttrKind::Normal(ref normal) if normal.item.path == sym::doc => normal\n-                .item\n-                .meta_kind()\n-                .and_then(|kind| kind.value_str())\n-                .map(|data| (data, CommentKind::Line)),\n+        match &self.kind {\n+            AttrKind::DocComment(kind, data) => Some((*data, *kind)),\n+            AttrKind::Normal(normal) if normal.item.path == sym::doc => {\n+                normal.item.value_str().map(|s| (s, CommentKind::Line))\n+            }\n             _ => None,\n         }\n     }\n@@ -265,9 +290,7 @@ impl Attribute {\n     pub fn doc_str(&self) -> Option<Symbol> {\n         match &self.kind {\n             AttrKind::DocComment(.., data) => Some(*data),\n-            AttrKind::Normal(normal) if normal.item.path == sym::doc => {\n-                normal.item.meta_kind().and_then(|kind| kind.value_str())\n-            }\n+            AttrKind::Normal(normal) if normal.item.path == sym::doc => normal.item.value_str(),\n             _ => None,\n         }\n     }\n@@ -508,15 +531,12 @@ impl MetaItem {\n impl MetaItemKind {\n     pub fn value_str(&self) -> Option<Symbol> {\n         match self {\n-            MetaItemKind::NameValue(v) => match v.kind {\n-                LitKind::Str(s, _) => Some(s),\n-                _ => None,\n-            },\n+            MetaItemKind::NameValue(v) => v.kind.str(),\n             _ => None,\n         }\n     }\n \n-    fn list_from_tokens(tokens: TokenStream) -> Option<MetaItemKind> {\n+    fn list_from_tokens(tokens: TokenStream) -> Option<Vec<NestedMetaItem>> {\n         let mut tokens = tokens.into_trees().peekable();\n         let mut result = Vec::new();\n         while tokens.peek().is_some() {\n@@ -527,7 +547,7 @@ impl MetaItemKind {\n                 _ => return None,\n             }\n         }\n-        Some(MetaItemKind::List(result))\n+        Some(result)\n     }\n \n     fn name_value_from_tokens(\n@@ -551,7 +571,7 @@ impl MetaItemKind {\n                 dspan: _,\n                 delim: MacDelimiter::Parenthesis,\n                 tokens,\n-            }) => MetaItemKind::list_from_tokens(tokens.clone()),\n+            }) => MetaItemKind::list_from_tokens(tokens.clone()).map(MetaItemKind::List),\n             AttrArgs::Delimited(..) => None,\n             AttrArgs::Eq(_, AttrArgsEq::Ast(expr)) => match expr.kind {\n                 ExprKind::Lit(token_lit) => {\n@@ -573,7 +593,7 @@ impl MetaItemKind {\n             Some(TokenTree::Delimited(_, Delimiter::Parenthesis, inner_tokens)) => {\n                 let inner_tokens = inner_tokens.clone();\n                 tokens.next();\n-                MetaItemKind::list_from_tokens(inner_tokens)\n+                MetaItemKind::list_from_tokens(inner_tokens).map(MetaItemKind::List)\n             }\n             Some(TokenTree::Delimited(..)) => None,\n             Some(TokenTree::Token(Token { kind: token::Eq, .. }, _)) => {"}, {"sha": "f0a6a5e0725860b5f090f8f6a12223ad13b868f1", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -41,7 +41,8 @@ use std::{fmt, iter};\n /// Nothing special happens to misnamed or misplaced `SubstNt`s.\n #[derive(Debug, Clone, PartialEq, Encodable, Decodable, HashStable_Generic)]\n pub enum TokenTree {\n-    /// A single token.\n+    /// A single token. Should never be `OpenDelim` or `CloseDelim`, because\n+    /// delimiters are implicitly represented by `Delimited`.\n     Token(Token, Spacing),\n     /// A delimited sequence of token trees.\n     Delimited(DelimSpan, Delimiter, TokenStream),\n@@ -388,12 +389,12 @@ impl TokenStream {\n         self.0.len()\n     }\n \n-    pub fn trees(&self) -> CursorRef<'_> {\n-        CursorRef::new(self)\n+    pub fn trees(&self) -> RefTokenTreeCursor<'_> {\n+        RefTokenTreeCursor::new(self)\n     }\n \n-    pub fn into_trees(self) -> Cursor {\n-        Cursor::new(self)\n+    pub fn into_trees(self) -> TokenTreeCursor {\n+        TokenTreeCursor::new(self)\n     }\n \n     /// Compares two `TokenStream`s, checking equality without regarding span information.\n@@ -551,24 +552,25 @@ impl TokenStream {\n     }\n }\n \n-/// By-reference iterator over a [`TokenStream`].\n+/// By-reference iterator over a [`TokenStream`], that produces `&TokenTree`\n+/// items.\n #[derive(Clone)]\n-pub struct CursorRef<'t> {\n+pub struct RefTokenTreeCursor<'t> {\n     stream: &'t TokenStream,\n     index: usize,\n }\n \n-impl<'t> CursorRef<'t> {\n+impl<'t> RefTokenTreeCursor<'t> {\n     fn new(stream: &'t TokenStream) -> Self {\n-        CursorRef { stream, index: 0 }\n+        RefTokenTreeCursor { stream, index: 0 }\n     }\n \n     pub fn look_ahead(&self, n: usize) -> Option<&TokenTree> {\n         self.stream.0.get(self.index + n)\n     }\n }\n \n-impl<'t> Iterator for CursorRef<'t> {\n+impl<'t> Iterator for RefTokenTreeCursor<'t> {\n     type Item = &'t TokenTree;\n \n     fn next(&mut self) -> Option<&'t TokenTree> {\n@@ -579,15 +581,16 @@ impl<'t> Iterator for CursorRef<'t> {\n     }\n }\n \n-/// Owning by-value iterator over a [`TokenStream`].\n+/// Owning by-value iterator over a [`TokenStream`], that produces `TokenTree`\n+/// items.\n // FIXME: Many uses of this can be replaced with by-reference iterator to avoid clones.\n #[derive(Clone)]\n-pub struct Cursor {\n+pub struct TokenTreeCursor {\n     pub stream: TokenStream,\n     index: usize,\n }\n \n-impl Iterator for Cursor {\n+impl Iterator for TokenTreeCursor {\n     type Item = TokenTree;\n \n     fn next(&mut self) -> Option<TokenTree> {\n@@ -598,9 +601,9 @@ impl Iterator for Cursor {\n     }\n }\n \n-impl Cursor {\n+impl TokenTreeCursor {\n     fn new(stream: TokenStream) -> Self {\n-        Cursor { stream, index: 0 }\n+        TokenTreeCursor { stream, index: 0 }\n     }\n \n     #[inline]\n@@ -614,6 +617,15 @@ impl Cursor {\n     pub fn look_ahead(&self, n: usize) -> Option<&TokenTree> {\n         self.stream.0.get(self.index + n)\n     }\n+\n+    // Replace the previously obtained token tree with `tts`, and rewind to\n+    // just before them.\n+    pub fn replace_prev_and_rewind(&mut self, tts: Vec<TokenTree>) {\n+        assert!(self.index > 0);\n+        self.index -= 1;\n+        let stream = Lrc::make_mut(&mut self.stream.0);\n+        stream.splice(self.index..self.index + 1, tts);\n+    }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Encodable, Decodable, HashStable_Generic)]"}, {"sha": "bdb1879ec201d9c74fea9483e7ff19d3a8abf5eb", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -403,8 +403,8 @@ pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n             walk_list!(visitor, visit_lifetime, opt_lifetime, LifetimeCtxt::Ref);\n             visitor.visit_ty(&mutable_type.ty)\n         }\n-        TyKind::Tup(tys) => {\n-            walk_list!(visitor, visit_ty, tys);\n+        TyKind::Tup(tuple_element_types) => {\n+            walk_list!(visitor, visit_ty, tuple_element_types);\n         }\n         TyKind::BareFn(function_declaration) => {\n             walk_list!(visitor, visit_generic_param, &function_declaration.generic_params);"}, {"sha": "6e76c349a4a048bd2c4d8fb07b95db8774ec244f", "filename": "compiler/rustc_ast_lowering/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_ast_lowering%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_ast_lowering%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2FCargo.toml?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -7,7 +7,6 @@ edition = \"2021\"\n doctest = false\n \n [dependencies]\n-rustc_arena = { path = \"../rustc_arena\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n@@ -16,7 +15,6 @@ rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_macros = { path = \"../rustc_macros\" }\n-rustc_query_system = { path = \"../rustc_query_system\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }"}, {"sha": "d1513c114fef4a960558120c63d9c08188723e29", "filename": "compiler/rustc_ast_pretty/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_ast_pretty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_ast_pretty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2FCargo.toml?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -7,5 +7,4 @@ edition = \"2021\"\n \n [dependencies]\n rustc_ast = { path = \"../rustc_ast\" }\n-rustc_parse_format = { path = \"../rustc_parse_format\" }\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "d7767efa9841bc65383b76767c821ddae74379d0", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -131,7 +131,7 @@ pub fn print_crate<'a>(\n \n         // Currently, in Rust 2018 we don't have `extern crate std;` at the crate\n         // root, so this is not needed, and actually breaks things.\n-        if edition.rust_2015() {\n+        if edition.is_rust_2015() {\n             // `#![no_std]`\n             let fake_attr = attr::mk_attr_word(g, ast::AttrStyle::Inner, sym::no_std, DUMMY_SP);\n             s.print_attribute(&fake_attr);"}, {"sha": "b0a8188e5e04d92e085ccf1a5a5bbed0a52a87ca", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -2645,6 +2645,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             operands,\n                         ) = rvalue\n                         {\n+                            let def_id = def_id.expect_local();\n                             for operand in operands {\n                                 let (Operand::Copy(assigned_from) | Operand::Move(assigned_from)) = operand else {\n                                     continue;\n@@ -2667,7 +2668,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 // into a place then we should annotate the closure in\n                                 // case it ends up being assigned into the return place.\n                                 annotated_closure =\n-                                    self.annotate_fn_sig(*def_id, substs.as_closure().sig());\n+                                    self.annotate_fn_sig(def_id, substs.as_closure().sig());\n                                 debug!(\n                                     \"annotate_argument_and_return_for_borrow: \\\n                                      annotated_closure={:?} assigned_from_local={:?} \\"}, {"sha": "a75ec87be4cac0721b6cdfc58fa3b095c7959048", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -817,6 +817,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             && let AggregateKind::Closure(def_id, _) | AggregateKind::Generator(def_id, _, _) = **kind\n         {\n             debug!(\"move_spans: def_id={:?} places={:?}\", def_id, places);\n+            let def_id = def_id.expect_local();\n             if let Some((args_span, generator_kind, capture_kind_span, path_span)) =\n                 self.closure_span(def_id, moved_place, places)\n             {\n@@ -945,6 +946,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     box AggregateKind::Generator(def_id, _, _) => (def_id, true),\n                     _ => continue,\n                 };\n+                let def_id = def_id.expect_local();\n \n                 debug!(\n                     \"borrow_spans: def_id={:?} is_generator={:?} places={:?}\","}, {"sha": "9f37b915b773a7e611f1aa6d0bc48bcd4a7a5d41", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 57, "deletions": 6, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -606,12 +606,63 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                 }\n                             }\n                             Some((false, err_label_span, message)) => {\n-                                err.span_label(\n-                                    err_label_span,\n-                                    &format!(\n-                                        \"consider changing this binding's type to be: `{message}`\"\n-                                    ),\n-                                );\n+                                struct BindingFinder {\n+                                    span: Span,\n+                                    hir_id: Option<hir::HirId>,\n+                                }\n+\n+                                impl<'tcx> Visitor<'tcx> for BindingFinder {\n+                                    fn visit_stmt(&mut self, s: &'tcx hir::Stmt<'tcx>) {\n+                                        if let hir::StmtKind::Local(local) = s.kind {\n+                                            if local.pat.span == self.span {\n+                                                self.hir_id = Some(local.hir_id);\n+                                            }\n+                                        }\n+                                        hir::intravisit::walk_stmt(self, s);\n+                                    }\n+                                }\n+                                let hir_map = self.infcx.tcx.hir();\n+                                let def_id = self.body.source.def_id();\n+                                let hir_id = hir_map.local_def_id_to_hir_id(def_id.expect_local());\n+                                let node = hir_map.find(hir_id);\n+                                let hir_id = if let Some(hir::Node::Item(item)) = node\n+                                    && let hir::ItemKind::Fn(.., body_id) = item.kind\n+                                {\n+                                    let body = hir_map.body(body_id);\n+                                    let mut v = BindingFinder {\n+                                        span: err_label_span,\n+                                        hir_id: None,\n+                                    };\n+                                    v.visit_body(body);\n+                                    v.hir_id\n+                                } else {\n+                                    None\n+                                };\n+                                if let Some(hir_id) = hir_id\n+                                    && let Some(hir::Node::Local(local)) = hir_map.find(hir_id)\n+                                {\n+                                    let (changing, span, sugg) = match local.ty {\n+                                        Some(ty) => (\"changing\", ty.span, message),\n+                                        None => (\n+                                            \"specifying\",\n+                                            local.pat.span.shrink_to_hi(),\n+                                            format!(\": {message}\"),\n+                                        ),\n+                                    };\n+                                    err.span_suggestion_verbose(\n+                                        span,\n+                                        &format!(\"consider {changing} this binding's type\"),\n+                                        sugg,\n+                                        Applicability::HasPlaceholders,\n+                                    );\n+                                } else {\n+                                    err.span_label(\n+                                        err_label_span,\n+                                        &format!(\n+                                            \"consider changing this binding's type to be: `{message}`\"\n+                                        ),\n+                                    );\n+                                }\n                             }\n                             None => {}\n                         }"}, {"sha": "7901a5046abad12a466cf045b9591d4fe618f5f1", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -583,10 +583,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let err = FnMutError {\n             span: *span,\n             ty_err: match output_ty.kind() {\n-                ty::Closure(_, _) => FnMutReturnTypeErr::ReturnClosure { span: *span },\n                 ty::Generator(def, ..) if self.infcx.tcx.generator_is_async(*def) => {\n                     FnMutReturnTypeErr::ReturnAsyncBlock { span: *span }\n                 }\n+                _ if output_ty.contains_closure() => {\n+                    FnMutReturnTypeErr::ReturnClosure { span: *span }\n+                }\n                 _ => FnMutReturnTypeErr::ReturnRef { span: *span },\n             },\n         };\n@@ -997,7 +999,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     fn suggest_move_on_borrowing_closure(&self, diag: &mut Diagnostic) {\n         let map = self.infcx.tcx.hir();\n         let body_id = map.body_owned_by(self.mir_def_id());\n-        let expr = &map.body(body_id).value;\n+        let expr = &map.body(body_id).value.peel_blocks();\n         let mut closure_span = None::<rustc_span::Span>;\n         match expr.kind {\n             hir::ExprKind::MethodCall(.., args, _) => {\n@@ -1012,20 +1014,14 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ExprKind::Block(blk, _) => {\n-                if let Some(expr) = blk.expr {\n-                    // only when the block is a closure\n-                    if let hir::ExprKind::Closure(hir::Closure {\n-                        capture_clause: hir::CaptureBy::Ref,\n-                        body,\n-                        ..\n-                    }) = expr.kind\n-                    {\n-                        let body = map.body(*body);\n-                        if !matches!(body.generator_kind, Some(hir::GeneratorKind::Async(..))) {\n-                            closure_span = Some(expr.span.shrink_to_lo());\n-                        }\n-                    }\n+            hir::ExprKind::Closure(hir::Closure {\n+                capture_clause: hir::CaptureBy::Ref,\n+                body,\n+                ..\n+            }) => {\n+                let body = map.body(*body);\n+                if !matches!(body.generator_kind, Some(hir::GeneratorKind::Async(..))) {\n+                    closure_span = Some(expr.span.shrink_to_lo());\n                 }\n             }\n             _ => {}"}, {"sha": "98103af779d8b5fbc157abb6418f960bd0edc67f", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1278,6 +1278,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // in order to populate our used_mut set.\n                 match **aggregate_kind {\n                     AggregateKind::Closure(def_id, _) | AggregateKind::Generator(def_id, _, _) => {\n+                        let def_id = def_id.expect_local();\n                         let BorrowCheckResult { used_mut_upvars, .. } =\n                             self.infcx.tcx.mir_borrowck(def_id);\n                         debug!(\"{:?} used_mut_upvars={:?}\", def_id, used_mut_upvars);"}, {"sha": "5b52846562f87f64db5d65d5095c64850fd11904", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1484,7 +1484,10 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n             }\n             None => {\n-                if !sig.output().is_privately_uninhabited(self.tcx(), self.param_env) {\n+                // The signature in this call can reference region variables,\n+                // so erase them before calling a query.\n+                let output_ty = self.tcx().erase_regions(sig.output());\n+                if !output_ty.is_privately_uninhabited(self.tcx(), self.param_env) {\n                     span_mirbug!(self, term, \"call to converging function {:?} w/o dest\", sig);\n                 }\n             }\n@@ -2533,7 +2536,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             // clauses on the struct.\n             AggregateKind::Closure(def_id, substs)\n             | AggregateKind::Generator(def_id, substs, _) => {\n-                (def_id.to_def_id(), self.prove_closure_bounds(tcx, def_id, substs, location))\n+                (def_id, self.prove_closure_bounds(tcx, def_id.expect_local(), substs, location))\n             }\n \n             AggregateKind::Array(_) | AggregateKind::Tuple => {"}, {"sha": "74e2597830e7ed27a1fd0fae301052628d9ffb9e", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -76,6 +76,21 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     // The number of fields that can be handled without an array.\n     const CUTOFF: usize = 5;\n \n+    fn expr_for_field(\n+        cx: &ExtCtxt<'_>,\n+        field: &FieldInfo,\n+        index: usize,\n+        len: usize,\n+    ) -> ast::ptr::P<ast::Expr> {\n+        if index < len - 1 {\n+            field.self_expr.clone()\n+        } else {\n+            // Unsized types need an extra indirection, but only the last field\n+            // may be unsized.\n+            cx.expr_addr_of(field.span, field.self_expr.clone())\n+        }\n+    }\n+\n     if fields.is_empty() {\n         // Special case for no fields.\n         let fn_path_write_str = cx.std_path(&[sym::fmt, sym::Formatter, sym::write_str]);\n@@ -98,8 +113,8 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n                 let name = cx.expr_str(field.span, field.name.unwrap().name);\n                 args.push(name);\n             }\n-            // Use an extra indirection to make sure this works for unsized types.\n-            let field = cx.expr_addr_of(field.span, field.self_expr.clone());\n+\n+            let field = expr_for_field(cx, field, i, fields.len());\n             args.push(field);\n         }\n         let expr = cx.expr_call_global(span, fn_path_debug, args);\n@@ -109,13 +124,13 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n         let mut name_exprs = Vec::with_capacity(fields.len());\n         let mut value_exprs = Vec::with_capacity(fields.len());\n \n-        for field in fields {\n+        for i in 0..fields.len() {\n+            let field = &fields[i];\n             if is_struct {\n                 name_exprs.push(cx.expr_str(field.span, field.name.unwrap().name));\n             }\n \n-            // Use an extra indirection to make sure this works for unsized types.\n-            let field = cx.expr_addr_of(field.span, field.self_expr.clone());\n+            let field = expr_for_field(cx, field, i, fields.len());\n             value_exprs.push(field);\n         }\n "}, {"sha": "773c0ebbe59db8ce86121f8fd678368c0c1f8f9a", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -30,7 +30,6 @@ rustc_macros = { path = \"../rustc_macros\" }\n rustc_metadata = { path = \"../rustc_metadata\" }\n rustc_query_system = { path = \"../rustc_query_system\" }\n rustc_session = { path = \"../rustc_session\" }\n-rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_symbol_mangling = { path = \"../rustc_symbol_mangling\" }\n rustc_target = { path = \"../rustc_target\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "c55991e00d3ae864e0cab69dbc54b9b125a8910a", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -41,7 +41,6 @@ rustc_metadata = { path = \"../rustc_metadata\" }\n rustc_query_system = { path = \"../rustc_query_system\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_session = { path = \"../rustc_session\" }\n-rustc_const_eval = { path = \"../rustc_const_eval\" }\n \n [dependencies.object]\n version = \"0.30.1\""}, {"sha": "6fe8527ada62e0360f0cd23cba65016a96ff23c8", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 39, "deletions": 96, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -270,10 +270,9 @@ pub fn each_linked_rlib(\n \n /// Create an 'rlib'.\n ///\n-/// An rlib in its current incarnation is essentially a renamed .a file. The rlib primarily contains\n-/// the object file of the crate, but it also contains all of the object files from native\n-/// libraries. This is done by unzipping native libraries and inserting all of the contents into\n-/// this archive.\n+/// An rlib in its current incarnation is essentially a renamed .a file (with \"dummy\" object files).\n+/// The rlib primarily contains the object file of the crate, but it also some of the object files\n+/// from native libraries.\n fn link_rlib<'a>(\n     sess: &'a Session,\n     archive_builder_builder: &dyn ArchiveBuilderBuilder,\n@@ -347,44 +346,23 @@ fn link_rlib<'a>(\n     // loaded from the libraries found here and then encode that into the\n     // metadata of the rlib we're generating somehow.\n     for lib in codegen_results.crate_info.used_libraries.iter() {\n-        match lib.kind {\n-            NativeLibKind::Static { bundle: None | Some(true), whole_archive: Some(true) }\n-                if flavor == RlibFlavor::Normal && sess.opts.unstable_opts.packed_bundled_libs => {}\n-            NativeLibKind::Static { bundle: None | Some(true), whole_archive: Some(true) }\n-                if flavor == RlibFlavor::Normal =>\n-            {\n-                // Don't allow mixing +bundle with +whole_archive since an rlib may contain\n-                // multiple native libs, some of which are +whole-archive and some of which are\n-                // -whole-archive and it isn't clear how we can currently handle such a\n-                // situation correctly.\n-                // See https://github.com/rust-lang/rust/issues/88085#issuecomment-901050897\n-                sess.emit_err(errors::IncompatibleLinkingModifiers);\n-            }\n-            NativeLibKind::Static { bundle: None | Some(true), .. } => {}\n-            NativeLibKind::Static { bundle: Some(false), .. }\n-            | NativeLibKind::Dylib { .. }\n-            | NativeLibKind::Framework { .. }\n-            | NativeLibKind::RawDylib\n-            | NativeLibKind::LinkArg\n-            | NativeLibKind::Unspecified => continue,\n-        }\n-        if let Some(name) = lib.name {\n-            let location =\n+        let NativeLibKind::Static { bundle: None | Some(true), whole_archive } = lib.kind else {\n+            continue;\n+        };\n+        if whole_archive == Some(true) && !codegen_results.crate_info.feature_packed_bundled_libs {\n+            sess.emit_err(errors::IncompatibleLinkingModifiers);\n+        }\n+        if flavor == RlibFlavor::Normal && let Some(filename) = lib.filename {\n+            let path = find_native_static_library(filename.as_str(), true, &lib_search_paths, sess);\n+            let src = read(path).map_err(|e| sess.emit_fatal(errors::ReadFileError {message: e }))?;\n+            let (data, _) = create_wrapper_file(sess, b\".bundled_lib\".to_vec(), &src);\n+            let wrapper_file = emit_wrapper_file(sess, &data, tmpdir, filename.as_str());\n+            packed_bundled_libs.push(wrapper_file);\n+        } else if let Some(name) = lib.name {\n+            let path =\n                 find_native_static_library(name.as_str(), lib.verbatim, &lib_search_paths, sess);\n-            if sess.opts.unstable_opts.packed_bundled_libs && flavor == RlibFlavor::Normal {\n-                let filename = lib.filename.unwrap();\n-                let lib_path =\n-                    find_native_static_library(filename.as_str(), true, &lib_search_paths, sess);\n-                let src = read(lib_path)\n-                    .map_err(|e| sess.emit_fatal(errors::ReadFileError { message: e }))?;\n-                let (data, _) = create_wrapper_file(sess, b\".bundled_lib\".to_vec(), &src);\n-                let wrapper_file = emit_wrapper_file(sess, &data, tmpdir, filename.as_str());\n-                packed_bundled_libs.push(wrapper_file);\n-                continue;\n-            }\n-            ab.add_archive(&location, Box::new(|_| false)).unwrap_or_else(|error| {\n-                sess.emit_fatal(errors::AddNativeLibrary { library_path: location, error });\n-            });\n+            ab.add_archive(&path, Box::new(|_| false)).unwrap_or_else(|error| {\n+                sess.emit_fatal(errors::AddNativeLibrary { library_path: path, error })});\n         }\n     }\n \n@@ -516,36 +494,14 @@ fn link_staticlib<'a>(\n         &codegen_results.crate_info,\n         Some(CrateType::Staticlib),\n         &mut |cnum, path| {\n-            let name = codegen_results.crate_info.crate_name[&cnum];\n-            let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n-\n-            // Here when we include the rlib into our staticlib we need to make a\n-            // decision whether to include the extra object files along the way.\n-            // These extra object files come from statically included native\n-            // libraries, but they may be cfg'd away with #[link(cfg(..))].\n-            //\n-            // This unstable feature, though, only needs liblibc to work. The only\n-            // use case there is where musl is statically included in liblibc.rlib,\n-            // so if we don't want the included version we just need to skip it. As\n-            // a result the logic here is that if *any* linked library is cfg'd away\n-            // we just skip all object files.\n-            //\n-            // Clearly this is not sufficient for a general purpose feature, and\n-            // we'd want to read from the library's metadata to determine which\n-            // object files come from where and selectively skip them.\n-            let skip_object_files = native_libs.iter().any(|lib| {\n-                matches!(lib.kind, NativeLibKind::Static { bundle: None | Some(true), .. })\n-                    && !relevant_lib(sess, lib)\n-            });\n-\n             let lto = are_upstream_rust_objects_already_included(sess)\n                 && !ignored_for_lto(sess, &codegen_results.crate_info, cnum);\n \n-            // Ignoring obj file starting with the crate name\n-            // as simple comparison is not enough - there\n-            // might be also an extra name suffix\n-            let obj_start = name.as_str().to_owned();\n+            let native_libs = codegen_results.crate_info.native_libraries[&cnum].iter();\n+            let relevant = native_libs.clone().filter(|lib| relevant_lib(sess, &lib));\n+            let relevant_libs: FxHashSet<_> = relevant.filter_map(|lib| lib.filename).collect();\n \n+            let bundled_libs: FxHashSet<_> = native_libs.filter_map(|lib| lib.filename).collect();\n             ab.add_archive(\n                 path,\n                 Box::new(move |fname: &str| {\n@@ -559,20 +515,25 @@ fn link_staticlib<'a>(\n                         return true;\n                     }\n \n-                    // Otherwise if this is *not* a rust object and we're skipping\n-                    // objects then skip this file\n-                    if skip_object_files\n-                        && (!fname.starts_with(&obj_start) || !fname.ends_with(\".o\"))\n-                    {\n+                    // Skip objects for bundled libs.\n+                    if bundled_libs.contains(&Symbol::intern(fname)) {\n                         return true;\n                     }\n \n-                    // ok, don't skip this\n                     false\n                 }),\n             )\n             .unwrap();\n \n+            archive_builder_builder\n+                .extract_bundled_libs(path, tempdir.as_ref(), &relevant_libs)\n+                .unwrap_or_else(|e| sess.emit_fatal(e));\n+            for filename in relevant_libs {\n+                let joined = tempdir.as_ref().join(filename.as_str());\n+                let path = joined.as_path();\n+                ab.add_archive(path, Box::new(|_| false)).unwrap();\n+            }\n+\n             all_native_libs\n                 .extend(codegen_results.crate_info.native_libraries[&cnum].iter().cloned());\n         },\n@@ -2590,18 +2551,8 @@ fn add_static_crate<'a>(\n         cmd.link_rlib(&fix_windows_verbatim_for_gcc(path));\n     };\n \n-    // See the comment above in `link_staticlib` and `link_rlib` for why if\n-    // there's a static library that's not relevant we skip all object\n-    // files.\n-    let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n-    let skip_native = native_libs.iter().any(|lib| {\n-        matches!(lib.kind, NativeLibKind::Static { bundle: None | Some(true), .. })\n-            && !relevant_lib(sess, lib)\n-    });\n-\n-    if (!are_upstream_rust_objects_already_included(sess)\n-        || ignored_for_lto(sess, &codegen_results.crate_info, cnum))\n-        && !skip_native\n+    if !are_upstream_rust_objects_already_included(sess)\n+        || ignored_for_lto(sess, &codegen_results.crate_info, cnum)\n     {\n         link_upstream(cratepath);\n         return;\n@@ -2632,17 +2583,13 @@ fn add_static_crate<'a>(\n                 let is_rust_object =\n                     canonical.starts_with(&canonical_name) && looks_like_rust_object_file(&f);\n \n-                // If we've been requested to skip all native object files\n-                // (those not generated by the rust compiler) then we can skip\n-                // this file. See above for why we may want to do this.\n-                let skip_because_cfg_say_so = skip_native && !is_rust_object;\n-\n                 // If we're performing LTO and this is a rust-generated object\n                 // file, then we don't need the object file as it's part of the\n                 // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n                 // though, so we let that object file slide.\n-                let skip_because_lto =\n-                    upstream_rust_objects_already_included && is_rust_object && is_builtins;\n+                if upstream_rust_objects_already_included && is_rust_object && is_builtins {\n+                    return true;\n+                }\n \n                 // We skip native libraries because:\n                 // 1. This native libraries won't be used from the generated rlib,\n@@ -2653,10 +2600,6 @@ fn add_static_crate<'a>(\n                     return true;\n                 }\n \n-                if skip_because_cfg_say_so || skip_because_lto {\n-                    return true;\n-                }\n-\n                 false\n             }),\n         ) {"}, {"sha": "de2727c8a5dc3e0f6ccf09e07a6b52d658ffc81d", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -858,6 +858,7 @@ impl CrateInfo {\n             dependency_formats: tcx.dependency_formats(()).clone(),\n             windows_subsystem,\n             natvis_debugger_visualizers: Default::default(),\n+            feature_packed_bundled_libs: tcx.features().packed_bundled_libs,\n         };\n         let crates = tcx.crates(());\n "}, {"sha": "3ebbb2cbdfb8e239b0eeb7d20e806ab2ff1154ec", "filename": "compiler/rustc_codegen_ssa/src/codegen_attrs.rs", "status": "modified", "additions": 38, "deletions": 50, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -319,74 +319,62 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n                 }\n             }\n         } else if attr.has_name(sym::instruction_set) {\n-            codegen_fn_attrs.instruction_set = match attr.meta_kind() {\n-                Some(MetaItemKind::List(ref items)) => match items.as_slice() {\n-                    [NestedMetaItem::MetaItem(set)] => {\n-                        let segments =\n-                            set.path.segments.iter().map(|x| x.ident.name).collect::<Vec<_>>();\n-                        match segments.as_slice() {\n-                            [sym::arm, sym::a32] | [sym::arm, sym::t32] => {\n-                                if !tcx.sess.target.has_thumb_interworking {\n-                                    struct_span_err!(\n-                                        tcx.sess.diagnostic(),\n-                                        attr.span,\n-                                        E0779,\n-                                        \"target does not support `#[instruction_set]`\"\n-                                    )\n-                                    .emit();\n-                                    None\n-                                } else if segments[1] == sym::a32 {\n-                                    Some(InstructionSetAttr::ArmA32)\n-                                } else if segments[1] == sym::t32 {\n-                                    Some(InstructionSetAttr::ArmT32)\n-                                } else {\n-                                    unreachable!()\n-                                }\n-                            }\n-                            _ => {\n+            codegen_fn_attrs.instruction_set = attr.meta_item_list().and_then(|l| match &l[..] {\n+                [NestedMetaItem::MetaItem(set)] => {\n+                    let segments =\n+                        set.path.segments.iter().map(|x| x.ident.name).collect::<Vec<_>>();\n+                    match segments.as_slice() {\n+                        [sym::arm, sym::a32] | [sym::arm, sym::t32] => {\n+                            if !tcx.sess.target.has_thumb_interworking {\n                                 struct_span_err!(\n                                     tcx.sess.diagnostic(),\n                                     attr.span,\n                                     E0779,\n-                                    \"invalid instruction set specified\",\n+                                    \"target does not support `#[instruction_set]`\"\n                                 )\n                                 .emit();\n                                 None\n+                            } else if segments[1] == sym::a32 {\n+                                Some(InstructionSetAttr::ArmA32)\n+                            } else if segments[1] == sym::t32 {\n+                                Some(InstructionSetAttr::ArmT32)\n+                            } else {\n+                                unreachable!()\n                             }\n                         }\n+                        _ => {\n+                            struct_span_err!(\n+                                tcx.sess.diagnostic(),\n+                                attr.span,\n+                                E0779,\n+                                \"invalid instruction set specified\",\n+                            )\n+                            .emit();\n+                            None\n+                        }\n                     }\n-                    [] => {\n-                        struct_span_err!(\n-                            tcx.sess.diagnostic(),\n-                            attr.span,\n-                            E0778,\n-                            \"`#[instruction_set]` requires an argument\"\n-                        )\n-                        .emit();\n-                        None\n-                    }\n-                    _ => {\n-                        struct_span_err!(\n-                            tcx.sess.diagnostic(),\n-                            attr.span,\n-                            E0779,\n-                            \"cannot specify more than one instruction set\"\n-                        )\n-                        .emit();\n-                        None\n-                    }\n-                },\n-                _ => {\n+                }\n+                [] => {\n                     struct_span_err!(\n                         tcx.sess.diagnostic(),\n                         attr.span,\n                         E0778,\n-                        \"must specify an instruction set\"\n+                        \"`#[instruction_set]` requires an argument\"\n                     )\n                     .emit();\n                     None\n                 }\n-            };\n+                _ => {\n+                    struct_span_err!(\n+                        tcx.sess.diagnostic(),\n+                        attr.span,\n+                        E0779,\n+                        \"cannot specify more than one instruction set\"\n+                    )\n+                    .emit();\n+                    None\n+                }\n+            })\n         } else if attr.has_name(sym::repr) {\n             codegen_fn_attrs.alignment = match attr.meta_item_list() {\n                 Some(items) => match items.as_slice() {"}, {"sha": "d5530c476807ac9d6b2b24110cb82607eed66f6f", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -159,6 +159,7 @@ pub struct CrateInfo {\n     pub dependency_formats: Lrc<Dependencies>,\n     pub windows_subsystem: Option<String>,\n     pub natvis_debugger_visualizers: BTreeSet<DebuggerVisualizerFile>,\n+    pub feature_packed_bundled_libs: bool, // unstable feature flag.\n }\n \n #[derive(Encodable, Decodable)]"}, {"sha": "35948e50f48d0da28aa8e27f53936be7160df860", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -13,6 +13,7 @@ use rustc_middle::ty::cast::{CastTy, IntTy};\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf};\n use rustc_middle::ty::{self, adjustment::PointerCast, Instance, Ty, TyCtxt};\n use rustc_span::source_map::{Span, DUMMY_SP};\n+use rustc_target::abi::VariantIdx;\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     #[instrument(level = \"trace\", skip(self, bx))]\n@@ -106,31 +107,31 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::Rvalue::Aggregate(ref kind, ref operands) => {\n-                let (dest, active_field_index) = match **kind {\n-                    mir::AggregateKind::Adt(adt_did, variant_index, _, _, active_field_index) => {\n-                        dest.codegen_set_discr(bx, variant_index);\n-                        if bx.tcx().adt_def(adt_did).is_enum() {\n-                            (dest.project_downcast(bx, variant_index), active_field_index)\n-                        } else {\n-                            (dest, active_field_index)\n-                        }\n+                let (variant_index, variant_dest, active_field_index) = match **kind {\n+                    mir::AggregateKind::Adt(_, variant_index, _, _, active_field_index) => {\n+                        let variant_dest = dest.project_downcast(bx, variant_index);\n+                        (variant_index, variant_dest, active_field_index)\n                     }\n-                    _ => (dest, None),\n+                    _ => (VariantIdx::from_u32(0), dest, None),\n                 };\n+                if active_field_index.is_some() {\n+                    assert_eq!(operands.len(), 1);\n+                }\n                 for (i, operand) in operands.iter().enumerate() {\n                     let op = self.codegen_operand(bx, operand);\n                     // Do not generate stores and GEPis for zero-sized fields.\n                     if !op.layout.is_zst() {\n                         let field_index = active_field_index.unwrap_or(i);\n                         let field = if let mir::AggregateKind::Array(_) = **kind {\n                             let llindex = bx.cx().const_usize(field_index as u64);\n-                            dest.project_index(bx, llindex)\n+                            variant_dest.project_index(bx, llindex)\n                         } else {\n-                            dest.project_field(bx, field_index)\n+                            variant_dest.project_field(bx, field_index)\n                         };\n                         op.val.store(bx, field);\n                     }\n                 }\n+                dest.codegen_set_discr(bx, variant_index);\n             }\n \n             _ => {"}, {"sha": "98ac36c1ced73bf5d12e7565f54bdec939d96c62", "filename": "compiler/rustc_const_eval/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_const_eval%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_const_eval%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2FCargo.toml?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -19,7 +19,6 @@ rustc_infer = { path = \"../rustc_infer\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_mir_dataflow = { path = \"../rustc_mir_dataflow\" }\n-rustc_query_system = { path = \"../rustc_query_system\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }"}, {"sha": "557e721249d7f0c653fdabce5aa2fd4e4d6b0580", "filename": "compiler/rustc_const_eval/src/interpret/discriminant.rs", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fdiscriminant.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -0,0 +1,238 @@\n+//! Functions for reading and writing discriminants of multi-variant layouts (enums and generators).\n+\n+use rustc_middle::ty::layout::{LayoutOf, PrimitiveExt};\n+use rustc_middle::{mir, ty};\n+use rustc_target::abi::{self, TagEncoding};\n+use rustc_target::abi::{VariantIdx, Variants};\n+\n+use super::{ImmTy, InterpCx, InterpResult, Machine, OpTy, PlaceTy, Scalar};\n+\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n+    /// Writes the discriminant of the given variant.\n+    #[instrument(skip(self), level = \"trace\")]\n+    pub fn write_discriminant(\n+        &mut self,\n+        variant_index: VariantIdx,\n+        dest: &PlaceTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        // Layout computation excludes uninhabited variants from consideration\n+        // therefore there's no way to represent those variants in the given layout.\n+        // Essentially, uninhabited variants do not have a tag that corresponds to their\n+        // discriminant, so we cannot do anything here.\n+        // When evaluating we will always error before even getting here, but ConstProp 'executes'\n+        // dead code, so we cannot ICE here.\n+        if dest.layout.for_variant(self, variant_index).abi.is_uninhabited() {\n+            throw_ub!(UninhabitedEnumVariantWritten)\n+        }\n+\n+        match dest.layout.variants {\n+            abi::Variants::Single { index } => {\n+                assert_eq!(index, variant_index);\n+            }\n+            abi::Variants::Multiple {\n+                tag_encoding: TagEncoding::Direct,\n+                tag: tag_layout,\n+                tag_field,\n+                ..\n+            } => {\n+                // No need to validate that the discriminant here because the\n+                // `TyAndLayout::for_variant()` call earlier already checks the variant is valid.\n+\n+                let discr_val =\n+                    dest.layout.ty.discriminant_for_variant(*self.tcx, variant_index).unwrap().val;\n+\n+                // raw discriminants for enums are isize or bigger during\n+                // their computation, but the in-memory tag is the smallest possible\n+                // representation\n+                let size = tag_layout.size(self);\n+                let tag_val = size.truncate(discr_val);\n+\n+                let tag_dest = self.place_field(dest, tag_field)?;\n+                self.write_scalar(Scalar::from_uint(tag_val, size), &tag_dest)?;\n+            }\n+            abi::Variants::Multiple {\n+                tag_encoding:\n+                    TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start },\n+                tag: tag_layout,\n+                tag_field,\n+                ..\n+            } => {\n+                // No need to validate that the discriminant here because the\n+                // `TyAndLayout::for_variant()` call earlier already checks the variant is valid.\n+\n+                if variant_index != untagged_variant {\n+                    let variants_start = niche_variants.start().as_u32();\n+                    let variant_index_relative = variant_index\n+                        .as_u32()\n+                        .checked_sub(variants_start)\n+                        .expect(\"overflow computing relative variant idx\");\n+                    // We need to use machine arithmetic when taking into account `niche_start`:\n+                    // tag_val = variant_index_relative + niche_start_val\n+                    let tag_layout = self.layout_of(tag_layout.primitive().to_int_ty(*self.tcx))?;\n+                    let niche_start_val = ImmTy::from_uint(niche_start, tag_layout);\n+                    let variant_index_relative_val =\n+                        ImmTy::from_uint(variant_index_relative, tag_layout);\n+                    let tag_val = self.binary_op(\n+                        mir::BinOp::Add,\n+                        &variant_index_relative_val,\n+                        &niche_start_val,\n+                    )?;\n+                    // Write result.\n+                    let niche_dest = self.place_field(dest, tag_field)?;\n+                    self.write_immediate(*tag_val, &niche_dest)?;\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Read discriminant, return the runtime value as well as the variant index.\n+    /// Can also legally be called on non-enums (e.g. through the discriminant_value intrinsic)!\n+    #[instrument(skip(self), level = \"trace\")]\n+    pub fn read_discriminant(\n+        &self,\n+        op: &OpTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, (Scalar<M::Provenance>, VariantIdx)> {\n+        trace!(\"read_discriminant_value {:#?}\", op.layout);\n+        // Get type and layout of the discriminant.\n+        let discr_layout = self.layout_of(op.layout.ty.discriminant_ty(*self.tcx))?;\n+        trace!(\"discriminant type: {:?}\", discr_layout.ty);\n+\n+        // We use \"discriminant\" to refer to the value associated with a particular enum variant.\n+        // This is not to be confused with its \"variant index\", which is just determining its position in the\n+        // declared list of variants -- they can differ with explicitly assigned discriminants.\n+        // We use \"tag\" to refer to how the discriminant is encoded in memory, which can be either\n+        // straight-forward (`TagEncoding::Direct`) or with a niche (`TagEncoding::Niche`).\n+        let (tag_scalar_layout, tag_encoding, tag_field) = match op.layout.variants {\n+            Variants::Single { index } => {\n+                let discr = match op.layout.ty.discriminant_for_variant(*self.tcx, index) {\n+                    Some(discr) => {\n+                        // This type actually has discriminants.\n+                        assert_eq!(discr.ty, discr_layout.ty);\n+                        Scalar::from_uint(discr.val, discr_layout.size)\n+                    }\n+                    None => {\n+                        // On a type without actual discriminants, variant is 0.\n+                        assert_eq!(index.as_u32(), 0);\n+                        Scalar::from_uint(index.as_u32(), discr_layout.size)\n+                    }\n+                };\n+                return Ok((discr, index));\n+            }\n+            Variants::Multiple { tag, ref tag_encoding, tag_field, .. } => {\n+                (tag, tag_encoding, tag_field)\n+            }\n+        };\n+\n+        // There are *three* layouts that come into play here:\n+        // - The discriminant has a type for typechecking. This is `discr_layout`, and is used for\n+        //   the `Scalar` we return.\n+        // - The tag (encoded discriminant) has layout `tag_layout`. This is always an integer type,\n+        //   and used to interpret the value we read from the tag field.\n+        //   For the return value, a cast to `discr_layout` is performed.\n+        // - The field storing the tag has a layout, which is very similar to `tag_layout` but\n+        //   may be a pointer. This is `tag_val.layout`; we just use it for sanity checks.\n+\n+        // Get layout for tag.\n+        let tag_layout = self.layout_of(tag_scalar_layout.primitive().to_int_ty(*self.tcx))?;\n+\n+        // Read tag and sanity-check `tag_layout`.\n+        let tag_val = self.read_immediate(&self.operand_field(op, tag_field)?)?;\n+        assert_eq!(tag_layout.size, tag_val.layout.size);\n+        assert_eq!(tag_layout.abi.is_signed(), tag_val.layout.abi.is_signed());\n+        trace!(\"tag value: {}\", tag_val);\n+\n+        // Figure out which discriminant and variant this corresponds to.\n+        Ok(match *tag_encoding {\n+            TagEncoding::Direct => {\n+                let scalar = tag_val.to_scalar();\n+                // Generate a specific error if `tag_val` is not an integer.\n+                // (`tag_bits` itself is only used for error messages below.)\n+                let tag_bits = scalar\n+                    .try_to_int()\n+                    .map_err(|dbg_val| err_ub!(InvalidTag(dbg_val)))?\n+                    .assert_bits(tag_layout.size);\n+                // Cast bits from tag layout to discriminant layout.\n+                // After the checks we did above, this cannot fail, as\n+                // discriminants are int-like.\n+                let discr_val =\n+                    self.cast_from_int_like(scalar, tag_val.layout, discr_layout.ty).unwrap();\n+                let discr_bits = discr_val.assert_bits(discr_layout.size);\n+                // Convert discriminant to variant index, and catch invalid discriminants.\n+                let index = match *op.layout.ty.kind() {\n+                    ty::Adt(adt, _) => {\n+                        adt.discriminants(*self.tcx).find(|(_, var)| var.val == discr_bits)\n+                    }\n+                    ty::Generator(def_id, substs, _) => {\n+                        let substs = substs.as_generator();\n+                        substs\n+                            .discriminants(def_id, *self.tcx)\n+                            .find(|(_, var)| var.val == discr_bits)\n+                    }\n+                    _ => span_bug!(self.cur_span(), \"tagged layout for non-adt non-generator\"),\n+                }\n+                .ok_or_else(|| err_ub!(InvalidTag(Scalar::from_uint(tag_bits, tag_layout.size))))?;\n+                // Return the cast value, and the index.\n+                (discr_val, index.0)\n+            }\n+            TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start } => {\n+                let tag_val = tag_val.to_scalar();\n+                // Compute the variant this niche value/\"tag\" corresponds to. With niche layout,\n+                // discriminant (encoded in niche/tag) and variant index are the same.\n+                let variants_start = niche_variants.start().as_u32();\n+                let variants_end = niche_variants.end().as_u32();\n+                let variant = match tag_val.try_to_int() {\n+                    Err(dbg_val) => {\n+                        // So this is a pointer then, and casting to an int failed.\n+                        // Can only happen during CTFE.\n+                        // The niche must be just 0, and the ptr not null, then we know this is\n+                        // okay. Everything else, we conservatively reject.\n+                        let ptr_valid = niche_start == 0\n+                            && variants_start == variants_end\n+                            && !self.scalar_may_be_null(tag_val)?;\n+                        if !ptr_valid {\n+                            throw_ub!(InvalidTag(dbg_val))\n+                        }\n+                        untagged_variant\n+                    }\n+                    Ok(tag_bits) => {\n+                        let tag_bits = tag_bits.assert_bits(tag_layout.size);\n+                        // We need to use machine arithmetic to get the relative variant idx:\n+                        // variant_index_relative = tag_val - niche_start_val\n+                        let tag_val = ImmTy::from_uint(tag_bits, tag_layout);\n+                        let niche_start_val = ImmTy::from_uint(niche_start, tag_layout);\n+                        let variant_index_relative_val =\n+                            self.binary_op(mir::BinOp::Sub, &tag_val, &niche_start_val)?;\n+                        let variant_index_relative =\n+                            variant_index_relative_val.to_scalar().assert_bits(tag_val.layout.size);\n+                        // Check if this is in the range that indicates an actual discriminant.\n+                        if variant_index_relative <= u128::from(variants_end - variants_start) {\n+                            let variant_index_relative = u32::try_from(variant_index_relative)\n+                                .expect(\"we checked that this fits into a u32\");\n+                            // Then computing the absolute variant idx should not overflow any more.\n+                            let variant_index = variants_start\n+                                .checked_add(variant_index_relative)\n+                                .expect(\"overflow computing absolute variant idx\");\n+                            let variants_len = op\n+                                .layout\n+                                .ty\n+                                .ty_adt_def()\n+                                .expect(\"tagged layout for non adt\")\n+                                .variants()\n+                                .len();\n+                            assert!(usize::try_from(variant_index).unwrap() < variants_len);\n+                            VariantIdx::from_u32(variant_index)\n+                        } else {\n+                            untagged_variant\n+                        }\n+                    }\n+                };\n+                // Compute the size of the scalar we need to return.\n+                // No need to cast, because the variant index directly serves as discriminant and is\n+                // encoded in the tag.\n+                (Scalar::from_uint(variant.as_u32(), discr_layout.size), variant)\n+            }\n+        })\n+    }\n+}"}, {"sha": "86de4e4e32c2a5961c1871f420a9c92859ef7d04", "filename": "compiler/rustc_const_eval/src/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1,6 +1,7 @@\n //! An interpreter for MIR used in CTFE and by miri\n \n mod cast;\n+mod discriminant;\n mod eval_context;\n mod intern;\n mod intrinsics;"}, {"sha": "52613d5ca1f9b43c2ed532f398a368da5fabc6ea", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 151, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -4,13 +4,12 @@\n use either::{Either, Left, Right};\n \n use rustc_hir::def::Namespace;\n-use rustc_middle::ty::layout::{LayoutOf, PrimitiveExt, TyAndLayout};\n+use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};\n use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter};\n use rustc_middle::ty::{ConstInt, Ty, ValTree};\n use rustc_middle::{mir, ty};\n use rustc_span::Span;\n-use rustc_target::abi::{self, Abi, Align, HasDataLayout, Size, TagEncoding};\n-use rustc_target::abi::{VariantIdx, Variants};\n+use rustc_target::abi::{self, Abi, Align, HasDataLayout, Size};\n \n use super::{\n     alloc_range, from_known_layout, mir_assign_valid_types, AllocId, ConstValue, Frame, GlobalId,\n@@ -657,154 +656,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n         Ok(OpTy { op, layout, align: Some(layout.align.abi) })\n     }\n-\n-    /// Read discriminant, return the runtime value as well as the variant index.\n-    /// Can also legally be called on non-enums (e.g. through the discriminant_value intrinsic)!\n-    pub fn read_discriminant(\n-        &self,\n-        op: &OpTy<'tcx, M::Provenance>,\n-    ) -> InterpResult<'tcx, (Scalar<M::Provenance>, VariantIdx)> {\n-        trace!(\"read_discriminant_value {:#?}\", op.layout);\n-        // Get type and layout of the discriminant.\n-        let discr_layout = self.layout_of(op.layout.ty.discriminant_ty(*self.tcx))?;\n-        trace!(\"discriminant type: {:?}\", discr_layout.ty);\n-\n-        // We use \"discriminant\" to refer to the value associated with a particular enum variant.\n-        // This is not to be confused with its \"variant index\", which is just determining its position in the\n-        // declared list of variants -- they can differ with explicitly assigned discriminants.\n-        // We use \"tag\" to refer to how the discriminant is encoded in memory, which can be either\n-        // straight-forward (`TagEncoding::Direct`) or with a niche (`TagEncoding::Niche`).\n-        let (tag_scalar_layout, tag_encoding, tag_field) = match op.layout.variants {\n-            Variants::Single { index } => {\n-                let discr = match op.layout.ty.discriminant_for_variant(*self.tcx, index) {\n-                    Some(discr) => {\n-                        // This type actually has discriminants.\n-                        assert_eq!(discr.ty, discr_layout.ty);\n-                        Scalar::from_uint(discr.val, discr_layout.size)\n-                    }\n-                    None => {\n-                        // On a type without actual discriminants, variant is 0.\n-                        assert_eq!(index.as_u32(), 0);\n-                        Scalar::from_uint(index.as_u32(), discr_layout.size)\n-                    }\n-                };\n-                return Ok((discr, index));\n-            }\n-            Variants::Multiple { tag, ref tag_encoding, tag_field, .. } => {\n-                (tag, tag_encoding, tag_field)\n-            }\n-        };\n-\n-        // There are *three* layouts that come into play here:\n-        // - The discriminant has a type for typechecking. This is `discr_layout`, and is used for\n-        //   the `Scalar` we return.\n-        // - The tag (encoded discriminant) has layout `tag_layout`. This is always an integer type,\n-        //   and used to interpret the value we read from the tag field.\n-        //   For the return value, a cast to `discr_layout` is performed.\n-        // - The field storing the tag has a layout, which is very similar to `tag_layout` but\n-        //   may be a pointer. This is `tag_val.layout`; we just use it for sanity checks.\n-\n-        // Get layout for tag.\n-        let tag_layout = self.layout_of(tag_scalar_layout.primitive().to_int_ty(*self.tcx))?;\n-\n-        // Read tag and sanity-check `tag_layout`.\n-        let tag_val = self.read_immediate(&self.operand_field(op, tag_field)?)?;\n-        assert_eq!(tag_layout.size, tag_val.layout.size);\n-        assert_eq!(tag_layout.abi.is_signed(), tag_val.layout.abi.is_signed());\n-        trace!(\"tag value: {}\", tag_val);\n-\n-        // Figure out which discriminant and variant this corresponds to.\n-        Ok(match *tag_encoding {\n-            TagEncoding::Direct => {\n-                let scalar = tag_val.to_scalar();\n-                // Generate a specific error if `tag_val` is not an integer.\n-                // (`tag_bits` itself is only used for error messages below.)\n-                let tag_bits = scalar\n-                    .try_to_int()\n-                    .map_err(|dbg_val| err_ub!(InvalidTag(dbg_val)))?\n-                    .assert_bits(tag_layout.size);\n-                // Cast bits from tag layout to discriminant layout.\n-                // After the checks we did above, this cannot fail, as\n-                // discriminants are int-like.\n-                let discr_val =\n-                    self.cast_from_int_like(scalar, tag_val.layout, discr_layout.ty).unwrap();\n-                let discr_bits = discr_val.assert_bits(discr_layout.size);\n-                // Convert discriminant to variant index, and catch invalid discriminants.\n-                let index = match *op.layout.ty.kind() {\n-                    ty::Adt(adt, _) => {\n-                        adt.discriminants(*self.tcx).find(|(_, var)| var.val == discr_bits)\n-                    }\n-                    ty::Generator(def_id, substs, _) => {\n-                        let substs = substs.as_generator();\n-                        substs\n-                            .discriminants(def_id, *self.tcx)\n-                            .find(|(_, var)| var.val == discr_bits)\n-                    }\n-                    _ => span_bug!(self.cur_span(), \"tagged layout for non-adt non-generator\"),\n-                }\n-                .ok_or_else(|| err_ub!(InvalidTag(Scalar::from_uint(tag_bits, tag_layout.size))))?;\n-                // Return the cast value, and the index.\n-                (discr_val, index.0)\n-            }\n-            TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start } => {\n-                let tag_val = tag_val.to_scalar();\n-                // Compute the variant this niche value/\"tag\" corresponds to. With niche layout,\n-                // discriminant (encoded in niche/tag) and variant index are the same.\n-                let variants_start = niche_variants.start().as_u32();\n-                let variants_end = niche_variants.end().as_u32();\n-                let variant = match tag_val.try_to_int() {\n-                    Err(dbg_val) => {\n-                        // So this is a pointer then, and casting to an int failed.\n-                        // Can only happen during CTFE.\n-                        // The niche must be just 0, and the ptr not null, then we know this is\n-                        // okay. Everything else, we conservatively reject.\n-                        let ptr_valid = niche_start == 0\n-                            && variants_start == variants_end\n-                            && !self.scalar_may_be_null(tag_val)?;\n-                        if !ptr_valid {\n-                            throw_ub!(InvalidTag(dbg_val))\n-                        }\n-                        untagged_variant\n-                    }\n-                    Ok(tag_bits) => {\n-                        let tag_bits = tag_bits.assert_bits(tag_layout.size);\n-                        // We need to use machine arithmetic to get the relative variant idx:\n-                        // variant_index_relative = tag_val - niche_start_val\n-                        let tag_val = ImmTy::from_uint(tag_bits, tag_layout);\n-                        let niche_start_val = ImmTy::from_uint(niche_start, tag_layout);\n-                        let variant_index_relative_val =\n-                            self.binary_op(mir::BinOp::Sub, &tag_val, &niche_start_val)?;\n-                        let variant_index_relative =\n-                            variant_index_relative_val.to_scalar().assert_bits(tag_val.layout.size);\n-                        // Check if this is in the range that indicates an actual discriminant.\n-                        if variant_index_relative <= u128::from(variants_end - variants_start) {\n-                            let variant_index_relative = u32::try_from(variant_index_relative)\n-                                .expect(\"we checked that this fits into a u32\");\n-                            // Then computing the absolute variant idx should not overflow any more.\n-                            let variant_index = variants_start\n-                                .checked_add(variant_index_relative)\n-                                .expect(\"overflow computing absolute variant idx\");\n-                            let variants_len = op\n-                                .layout\n-                                .ty\n-                                .ty_adt_def()\n-                                .expect(\"tagged layout for non adt\")\n-                                .variants()\n-                                .len();\n-                            assert!(usize::try_from(variant_index).unwrap() < variants_len);\n-                            VariantIdx::from_u32(variant_index)\n-                        } else {\n-                            untagged_variant\n-                        }\n-                    }\n-                };\n-                // Compute the size of the scalar we need to return.\n-                // No need to cast, because the variant index directly serves as discriminant and is\n-                // encoded in the tag.\n-                (Scalar::from_uint(variant.as_u32(), discr_layout.size), variant)\n-            }\n-        })\n-    }\n }\n \n // Some nodes are used a lot. Make sure they don't unintentionally get bigger."}, {"sha": "f82a41078d153a4485c9585ef1b85257568e3c63", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 23, "deletions": 83, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -7,8 +7,8 @@ use either::{Either, Left, Right};\n use rustc_ast::Mutability;\n use rustc_middle::mir;\n use rustc_middle::ty;\n-use rustc_middle::ty::layout::{LayoutOf, PrimitiveExt, TyAndLayout};\n-use rustc_target::abi::{self, Abi, Align, HasDataLayout, Size, TagEncoding, VariantIdx};\n+use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};\n+use rustc_target::abi::{self, Abi, Align, HasDataLayout, Size, VariantIdx};\n \n use super::{\n     alloc_range, mir_assign_valid_types, AllocId, AllocRef, AllocRefMut, CheckInAllocMsg,\n@@ -767,92 +767,32 @@ where\n         MPlaceTy { mplace, layout, align: layout.align.abi }\n     }\n \n-    /// Writes the discriminant of the given variant.\n-    #[instrument(skip(self), level = \"debug\")]\n-    pub fn write_discriminant(\n+    /// Writes the aggregate to the destination.\n+    #[instrument(skip(self), level = \"trace\")]\n+    pub fn write_aggregate(\n         &mut self,\n-        variant_index: VariantIdx,\n+        kind: &mir::AggregateKind<'tcx>,\n+        operands: &[mir::Operand<'tcx>],\n         dest: &PlaceTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx> {\n-        // This must be an enum or generator.\n-        match dest.layout.ty.kind() {\n-            ty::Adt(adt, _) => assert!(adt.is_enum()),\n-            ty::Generator(..) => {}\n-            _ => span_bug!(\n-                self.cur_span(),\n-                \"write_discriminant called on non-variant-type (neither enum nor generator)\"\n-            ),\n-        }\n-        // Layout computation excludes uninhabited variants from consideration\n-        // therefore there's no way to represent those variants in the given layout.\n-        // Essentially, uninhabited variants do not have a tag that corresponds to their\n-        // discriminant, so we cannot do anything here.\n-        // When evaluating we will always error before even getting here, but ConstProp 'executes'\n-        // dead code, so we cannot ICE here.\n-        if dest.layout.for_variant(self, variant_index).abi.is_uninhabited() {\n-            throw_ub!(UninhabitedEnumVariantWritten)\n-        }\n-\n-        match dest.layout.variants {\n-            abi::Variants::Single { index } => {\n-                assert_eq!(index, variant_index);\n-            }\n-            abi::Variants::Multiple {\n-                tag_encoding: TagEncoding::Direct,\n-                tag: tag_layout,\n-                tag_field,\n-                ..\n-            } => {\n-                // No need to validate that the discriminant here because the\n-                // `TyAndLayout::for_variant()` call earlier already checks the variant is valid.\n-\n-                let discr_val =\n-                    dest.layout.ty.discriminant_for_variant(*self.tcx, variant_index).unwrap().val;\n-\n-                // raw discriminants for enums are isize or bigger during\n-                // their computation, but the in-memory tag is the smallest possible\n-                // representation\n-                let size = tag_layout.size(self);\n-                let tag_val = size.truncate(discr_val);\n-\n-                let tag_dest = self.place_field(dest, tag_field)?;\n-                self.write_scalar(Scalar::from_uint(tag_val, size), &tag_dest)?;\n-            }\n-            abi::Variants::Multiple {\n-                tag_encoding:\n-                    TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start },\n-                tag: tag_layout,\n-                tag_field,\n-                ..\n-            } => {\n-                // No need to validate that the discriminant here because the\n-                // `TyAndLayout::for_variant()` call earlier already checks the variant is valid.\n-\n-                if variant_index != untagged_variant {\n-                    let variants_start = niche_variants.start().as_u32();\n-                    let variant_index_relative = variant_index\n-                        .as_u32()\n-                        .checked_sub(variants_start)\n-                        .expect(\"overflow computing relative variant idx\");\n-                    // We need to use machine arithmetic when taking into account `niche_start`:\n-                    // tag_val = variant_index_relative + niche_start_val\n-                    let tag_layout = self.layout_of(tag_layout.primitive().to_int_ty(*self.tcx))?;\n-                    let niche_start_val = ImmTy::from_uint(niche_start, tag_layout);\n-                    let variant_index_relative_val =\n-                        ImmTy::from_uint(variant_index_relative, tag_layout);\n-                    let tag_val = self.binary_op(\n-                        mir::BinOp::Add,\n-                        &variant_index_relative_val,\n-                        &niche_start_val,\n-                    )?;\n-                    // Write result.\n-                    let niche_dest = self.place_field(dest, tag_field)?;\n-                    self.write_immediate(*tag_val, &niche_dest)?;\n-                }\n+        self.write_uninit(&dest)?;\n+        let (variant_index, variant_dest, active_field_index) = match *kind {\n+            mir::AggregateKind::Adt(_, variant_index, _, _, active_field_index) => {\n+                let variant_dest = self.place_downcast(&dest, variant_index)?;\n+                (variant_index, variant_dest, active_field_index)\n             }\n+            _ => (VariantIdx::from_u32(0), dest.clone(), None),\n+        };\n+        if active_field_index.is_some() {\n+            assert_eq!(operands.len(), 1);\n         }\n-\n-        Ok(())\n+        for (field_index, operand) in operands.iter().enumerate() {\n+            let field_index = active_field_index.unwrap_or(field_index);\n+            let field_dest = self.place_field(&variant_dest, field_index)?;\n+            let op = self.eval_operand(operand, Some(field_dest.layout))?;\n+            self.copy_op(&op, &field_dest, /*allow_transmute*/ false)?;\n+        }\n+        self.write_discriminant(variant_index, &dest)\n     }\n \n     pub fn raw_const_to_mplace("}, {"sha": "7d9a98da08a9a037ed104e5b55c9b4c49c524ef7", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -199,13 +199,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             Aggregate(box ref kind, ref operands) => {\n-                assert!(matches!(kind, mir::AggregateKind::Array(..)));\n-\n-                for (field_index, operand) in operands.iter().enumerate() {\n-                    let op = self.eval_operand(operand, None)?;\n-                    let field_dest = self.place_field(&dest, field_index)?;\n-                    self.copy_op(&op, &field_dest, /*allow_transmute*/ false)?;\n-                }\n+                self.write_aggregate(kind, operands, &dest)?;\n             }\n \n             Repeat(ref operand, _) => {"}, {"sha": "1a23b06d2e89cae1296d78b618a6e10cf5d5de30", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -453,7 +453,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n \n             Rvalue::Aggregate(kind, ..) => {\n                 if let AggregateKind::Generator(def_id, ..) = kind.as_ref()\n-                    && let Some(generator_kind @ hir::GeneratorKind::Async(..)) = self.tcx.generator_kind(def_id.to_def_id())\n+                    && let Some(generator_kind @ hir::GeneratorKind::Async(..)) = self.tcx.generator_kind(def_id)\n                 {\n                     self.check_op(ops::Generator(generator_kind));\n                 }"}, {"sha": "782a62accad9e984479cc4c1bd98d351dd6cb75b", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -22,13 +22,7 @@ use rustc_span::{BytePos, Pos, Span, Symbol};\n use rustc_trait_selection::traits::SelectionContext;\n \n use super::ConstCx;\n-use crate::errors::{\n-    InteriorMutabilityBorrow, InteriorMutableDataRefer, MutDerefErr, NonConstFmtMacroCall,\n-    NonConstFnCall, NonConstOpErr, PanicNonStrErr, RawPtrToIntErr, StaticAccessErr,\n-    TransientMutBorrowErr, TransientMutBorrowErrRaw, UnallowedFnPointerCall,\n-    UnallowedHeapAllocations, UnallowedInlineAsm, UnallowedMutableRefs, UnallowedMutableRefsRaw,\n-    UnallowedOpInConstContext, UnstableConstFn,\n-};\n+use crate::errors;\n use crate::util::{call_kind, CallDesugaringKind, CallKind};\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n@@ -99,7 +93,7 @@ impl<'tcx> NonConstOp<'tcx> for FnCallIndirect {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        ccx.tcx.sess.create_err(UnallowedFnPointerCall { span, kind: ccx.const_kind() })\n+        ccx.tcx.sess.create_err(errors::UnallowedFnPointerCall { span, kind: ccx.const_kind() })\n     }\n }\n \n@@ -303,10 +297,11 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                 diag_trait(&mut err, self_ty, tcx.require_lang_item(LangItem::Deref, Some(span)));\n                 err\n             }\n-            _ if tcx.opt_parent(callee) == tcx.get_diagnostic_item(sym::ArgumentV1Methods) => {\n-                ccx.tcx.sess.create_err(NonConstFmtMacroCall { span, kind: ccx.const_kind() })\n-            }\n-            _ => ccx.tcx.sess.create_err(NonConstFnCall {\n+            _ if tcx.opt_parent(callee) == tcx.get_diagnostic_item(sym::ArgumentV1Methods) => ccx\n+                .tcx\n+                .sess\n+                .create_err(errors::NonConstFmtMacroCall { span, kind: ccx.const_kind() }),\n+            _ => ccx.tcx.sess.create_err(errors::NonConstFnCall {\n                 span,\n                 def_path_str: ccx.tcx.def_path_str_with_substs(callee, substs),\n                 kind: ccx.const_kind(),\n@@ -351,7 +346,7 @@ impl<'tcx> NonConstOp<'tcx> for FnCallUnstable {\n         let mut err = ccx\n             .tcx\n             .sess\n-            .create_err(UnstableConstFn { span, def_path: ccx.tcx.def_path_str(def_id) });\n+            .create_err(errors::UnstableConstFn { span, def_path: ccx.tcx.def_path_str(def_id) });\n \n         if ccx.is_const_stable_const_fn() {\n             err.help(\"const-stable functions can only call other const-stable functions\");\n@@ -387,11 +382,11 @@ impl<'tcx> NonConstOp<'tcx> for Generator {\n         let msg = format!(\"{}s are not allowed in {}s\", self.0.descr(), ccx.const_kind());\n         if let hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) = self.0 {\n             ccx.tcx.sess.create_feature_err(\n-                UnallowedOpInConstContext { span, msg },\n+                errors::UnallowedOpInConstContext { span, msg },\n                 sym::const_async_blocks,\n             )\n         } else {\n-            ccx.tcx.sess.create_err(UnallowedOpInConstContext { span, msg })\n+            ccx.tcx.sess.create_err(errors::UnallowedOpInConstContext { span, msg })\n         }\n     }\n }\n@@ -404,7 +399,7 @@ impl<'tcx> NonConstOp<'tcx> for HeapAllocation {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        ccx.tcx.sess.create_err(UnallowedHeapAllocations {\n+        ccx.tcx.sess.create_err(errors::UnallowedHeapAllocations {\n             span,\n             kind: ccx.const_kind(),\n             teach: ccx.tcx.sess.teach(&error_code!(E0010)).then_some(()),\n@@ -420,7 +415,7 @@ impl<'tcx> NonConstOp<'tcx> for InlineAsm {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        ccx.tcx.sess.create_err(UnallowedInlineAsm { span, kind: ccx.const_kind() })\n+        ccx.tcx.sess.create_err(errors::UnallowedInlineAsm { span, kind: ccx.const_kind() })\n     }\n }\n \n@@ -471,7 +466,9 @@ impl<'tcx> NonConstOp<'tcx> for TransientCellBorrow {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        ccx.tcx.sess.create_feature_err(InteriorMutabilityBorrow { span }, sym::const_refs_to_cell)\n+        ccx.tcx\n+            .sess\n+            .create_feature_err(errors::InteriorMutabilityBorrow { span }, sym::const_refs_to_cell)\n     }\n }\n \n@@ -488,14 +485,14 @@ impl<'tcx> NonConstOp<'tcx> for CellBorrow {\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         // FIXME: Maybe a more elegant solution to this if else case\n         if let hir::ConstContext::Static(_) = ccx.const_kind() {\n-            ccx.tcx.sess.create_err(InteriorMutableDataRefer {\n+            ccx.tcx.sess.create_err(errors::InteriorMutableDataRefer {\n                 span,\n                 opt_help: Some(()),\n                 kind: ccx.const_kind(),\n                 teach: ccx.tcx.sess.teach(&error_code!(E0492)).then_some(()),\n             })\n         } else {\n-            ccx.tcx.sess.create_err(InteriorMutableDataRefer {\n+            ccx.tcx.sess.create_err(errors::InteriorMutableDataRefer {\n                 span,\n                 opt_help: None,\n                 kind: ccx.const_kind(),\n@@ -528,12 +525,12 @@ impl<'tcx> NonConstOp<'tcx> for MutBorrow {\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         match self.0 {\n-            hir::BorrowKind::Raw => ccx.tcx.sess.create_err(UnallowedMutableRefsRaw {\n+            hir::BorrowKind::Raw => ccx.tcx.sess.create_err(errors::UnallowedMutableRefsRaw {\n                 span,\n                 kind: ccx.const_kind(),\n                 teach: ccx.tcx.sess.teach(&error_code!(E0764)).then_some(()),\n             }),\n-            hir::BorrowKind::Ref => ccx.tcx.sess.create_err(UnallowedMutableRefs {\n+            hir::BorrowKind::Ref => ccx.tcx.sess.create_err(errors::UnallowedMutableRefs {\n                 span,\n                 kind: ccx.const_kind(),\n                 teach: ccx.tcx.sess.teach(&error_code!(E0764)).then_some(()),\n@@ -557,14 +554,14 @@ impl<'tcx> NonConstOp<'tcx> for TransientMutBorrow {\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let kind = ccx.const_kind();\n         match self.0 {\n-            hir::BorrowKind::Raw => ccx\n-                .tcx\n-                .sess\n-                .create_feature_err(TransientMutBorrowErrRaw { span, kind }, sym::const_mut_refs),\n-            hir::BorrowKind::Ref => ccx\n-                .tcx\n-                .sess\n-                .create_feature_err(TransientMutBorrowErr { span, kind }, sym::const_mut_refs),\n+            hir::BorrowKind::Raw => ccx.tcx.sess.create_feature_err(\n+                errors::TransientMutBorrowErrRaw { span, kind },\n+                sym::const_mut_refs,\n+            ),\n+            hir::BorrowKind::Ref => ccx.tcx.sess.create_feature_err(\n+                errors::TransientMutBorrowErr { span, kind },\n+                sym::const_mut_refs,\n+            ),\n         }\n     }\n }\n@@ -586,9 +583,10 @@ impl<'tcx> NonConstOp<'tcx> for MutDeref {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        ccx.tcx\n-            .sess\n-            .create_feature_err(MutDerefErr { span, kind: ccx.const_kind() }, sym::const_mut_refs)\n+        ccx.tcx.sess.create_feature_err(\n+            errors::MutDerefErr { span, kind: ccx.const_kind() },\n+            sym::const_mut_refs,\n+        )\n     }\n }\n \n@@ -601,7 +599,7 @@ impl<'tcx> NonConstOp<'tcx> for PanicNonStr {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        ccx.tcx.sess.create_err(PanicNonStrErr { span })\n+        ccx.tcx.sess.create_err(errors::PanicNonStrErr { span })\n     }\n }\n \n@@ -652,7 +650,7 @@ impl<'tcx> NonConstOp<'tcx> for RawPtrToIntCast {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        ccx.tcx.sess.create_err(RawPtrToIntErr { span })\n+        ccx.tcx.sess.create_err(errors::RawPtrToIntErr { span })\n     }\n }\n \n@@ -673,7 +671,7 @@ impl<'tcx> NonConstOp<'tcx> for StaticAccess {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        ccx.tcx.sess.create_err(StaticAccessErr {\n+        ccx.tcx.sess.create_err(errors::StaticAccessErr {\n             span,\n             kind: ccx.const_kind(),\n             teach: ccx.tcx.sess.teach(&error_code!(E0013)).then_some(()),\n@@ -690,7 +688,7 @@ impl<'tcx> NonConstOp<'tcx> for ThreadLocalAccess {\n         ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        ccx.tcx.sess.create_err(NonConstOpErr { span })\n+        ccx.tcx.sess.create_err(errors::NonConstOpErr { span })\n     }\n }\n "}, {"sha": "76b316cdf0c3fdecc5ccc061b251f3c8b878a96e", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -8,10 +8,10 @@ use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::mir::visit::NonUseContext::VarDebugInfo;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::{\n-    traversal, AggregateKind, BasicBlock, BinOp, Body, BorrowKind, CastKind, CopyNonOverlapping,\n-    Local, Location, MirPass, MirPhase, NonDivergingIntrinsic, Operand, Place, PlaceElem, PlaceRef,\n-    ProjectionElem, RetagKind, RuntimePhase, Rvalue, SourceScope, Statement, StatementKind,\n-    Terminator, TerminatorKind, UnOp, START_BLOCK,\n+    traversal, BasicBlock, BinOp, Body, BorrowKind, CastKind, CopyNonOverlapping, Local, Location,\n+    MirPass, MirPhase, NonDivergingIntrinsic, Operand, Place, PlaceElem, PlaceRef, ProjectionElem,\n+    RetagKind, RuntimePhase, Rvalue, SourceScope, Statement, StatementKind, Terminator,\n+    TerminatorKind, UnOp, START_BLOCK,\n };\n use rustc_middle::ty::{self, InstanceDef, ParamEnv, Ty, TyCtxt};\n use rustc_mir_dataflow::impls::MaybeStorageLive;\n@@ -423,19 +423,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n             };\n         }\n         match rvalue {\n-            Rvalue::Use(_) | Rvalue::CopyForDeref(_) => {}\n-            Rvalue::Aggregate(agg_kind, _) => {\n-                let disallowed = match **agg_kind {\n-                    AggregateKind::Array(..) => false,\n-                    _ => self.mir_phase >= MirPhase::Runtime(RuntimePhase::PostCleanup),\n-                };\n-                if disallowed {\n-                    self.fail(\n-                        location,\n-                        format!(\"{:?} have been lowered to field assignments\", rvalue),\n-                    )\n-                }\n-            }\n+            Rvalue::Use(_) | Rvalue::CopyForDeref(_) | Rvalue::Aggregate(..) => {}\n             Rvalue::Ref(_, BorrowKind::Shallow, _) => {\n                 if self.mir_phase >= MirPhase::Runtime(RuntimePhase::Initial) {\n                     self.fail("}, {"sha": "10783c5ed1d1cd7389fd67f5aa72e83f74763108", "filename": "compiler/rustc_const_eval/src/util/aggregate.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/6c8d4073a4490671b05f3b5f5e6810cfdc23a641/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Faggregate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8d4073a4490671b05f3b5f5e6810cfdc23a641/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Faggregate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Faggregate.rs?ref=6c8d4073a4490671b05f3b5f5e6810cfdc23a641", "patch": "@@ -1,77 +0,0 @@\n-use rustc_index::vec::Idx;\n-use rustc_middle::mir::*;\n-use rustc_middle::ty::{Ty, TyCtxt};\n-use rustc_target::abi::VariantIdx;\n-\n-use std::iter::TrustedLen;\n-\n-/// Expand `lhs = Rvalue::Aggregate(kind, operands)` into assignments to the fields.\n-///\n-/// Produces something like\n-/// ```ignore (ilustrative)\n-/// (lhs as Variant).field0 = arg0;     // We only have a downcast if this is an enum\n-/// (lhs as Variant).field1 = arg1;\n-/// discriminant(lhs) = variant_index;  // If lhs is an enum or generator.\n-/// ```\n-pub fn expand_aggregate<'tcx>(\n-    orig_lhs: Place<'tcx>,\n-    operands: impl Iterator<Item = (Operand<'tcx>, Ty<'tcx>)> + TrustedLen,\n-    kind: AggregateKind<'tcx>,\n-    source_info: SourceInfo,\n-    tcx: TyCtxt<'tcx>,\n-) -> impl Iterator<Item = Statement<'tcx>> + TrustedLen {\n-    let mut lhs = orig_lhs;\n-    let mut set_discriminant = None;\n-    let active_field_index = match kind {\n-        AggregateKind::Adt(adt_did, variant_index, _, _, active_field_index) => {\n-            let adt_def = tcx.adt_def(adt_did);\n-            if adt_def.is_enum() {\n-                set_discriminant = Some(Statement {\n-                    kind: StatementKind::SetDiscriminant {\n-                        place: Box::new(orig_lhs),\n-                        variant_index,\n-                    },\n-                    source_info,\n-                });\n-                lhs = tcx.mk_place_downcast(orig_lhs, adt_def, variant_index);\n-            }\n-            active_field_index\n-        }\n-        AggregateKind::Generator(..) => {\n-            // Right now we only support initializing generators to\n-            // variant 0 (Unresumed).\n-            let variant_index = VariantIdx::new(0);\n-            set_discriminant = Some(Statement {\n-                kind: StatementKind::SetDiscriminant { place: Box::new(orig_lhs), variant_index },\n-                source_info,\n-            });\n-\n-            // Operands are upvars stored on the base place, so no\n-            // downcast is necessary.\n-\n-            None\n-        }\n-        _ => None,\n-    };\n-\n-    let operands = operands.enumerate().map(move |(i, (op, ty))| {\n-        let lhs_field = if let AggregateKind::Array(_) = kind {\n-            let offset = u64::try_from(i).unwrap();\n-            tcx.mk_place_elem(\n-                lhs,\n-                ProjectionElem::ConstantIndex { offset, min_length: offset + 1, from_end: false },\n-            )\n-        } else {\n-            let field = Field::new(active_field_index.unwrap_or(i));\n-            tcx.mk_place_field(lhs, field, ty)\n-        };\n-        Statement {\n-            source_info,\n-            kind: StatementKind::Assign(Box::new((lhs_field, Rvalue::Use(op)))),\n-        }\n-    });\n-    [Statement { source_info, kind: StatementKind::Deinit(Box::new(orig_lhs)) }]\n-        .into_iter()\n-        .chain(operands)\n-        .chain(set_discriminant)\n-}"}, {"sha": "51735e33e0f7142c9536a9aec475ce764712ffd1", "filename": "compiler/rustc_const_eval/src/util/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1,4 +1,3 @@\n-pub mod aggregate;\n mod alignment;\n mod call_kind;\n pub mod collect_writes;\n@@ -7,7 +6,6 @@ mod find_self_call;\n mod might_permit_raw_init;\n mod type_name;\n \n-pub use self::aggregate::expand_aggregate;\n pub use self::alignment::is_disaligned;\n pub use self::call_kind::{call_kind, CallDesugaringKind, CallKind};\n pub use self::compare_types::{is_equal_up_to_subtyping, is_subtype};"}, {"sha": "ad71dcdf9d95384421a94cf71d35277e8dde8b03", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -31,8 +31,8 @@ cfg_if! {\n         pub auto trait Send {}\n         pub auto trait Sync {}\n \n-        impl<T: ?Sized> Send for T {}\n-        impl<T: ?Sized> Sync for T {}\n+        impl<T> Send for T {}\n+        impl<T> Sync for T {}\n \n         #[macro_export]\n         macro_rules! rustc_erase_owner {"}, {"sha": "d7c295418ba6d6d04688b046d494d9b12880b8c4", "filename": "compiler/rustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 36, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2FCargo.toml?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -7,39 +7,4 @@ edition = \"2021\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n-tracing = { version = \"0.1.35\" }\n-serde_json = \"1.0.59\"\n-rustc_log = { path = \"../rustc_log\" }\n-rustc_middle = { path = \"../rustc_middle\" }\n-rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n-rustc_target = { path = \"../rustc_target\" }\n-rustc_lint = { path = \"../rustc_lint\" }\n-rustc_data_structures = { path = \"../rustc_data_structures\" }\n-rustc_errors = { path = \"../rustc_errors\" }\n-rustc_feature = { path = \"../rustc_feature\" }\n-rustc_hir = { path = \"../rustc_hir\" }\n-rustc_hir_pretty = { path = \"../rustc_hir_pretty\" }\n-rustc_macros = { path = \"../rustc_macros\" }\n-rustc_metadata = { path = \"../rustc_metadata\" }\n-rustc_parse = { path = \"../rustc_parse\" }\n-rustc_plugin_impl = { path = \"../rustc_plugin_impl\" }\n-rustc_save_analysis = { path = \"../rustc_save_analysis\" }\n-rustc_codegen_ssa = { path = \"../rustc_codegen_ssa\" }\n-rustc_session = { path = \"../rustc_session\" }\n-rustc_error_codes = { path = \"../rustc_error_codes\" }\n-rustc_interface = { path = \"../rustc_interface\" }\n-rustc_ast = { path = \"../rustc_ast\" }\n-rustc_span = { path = \"../rustc_span\" }\n-rustc_hir_analysis = { path = \"../rustc_hir_analysis\" }\n-\n-[target.'cfg(unix)'.dependencies]\n-libc = \"0.2\"\n-\n-[target.'cfg(windows)'.dependencies]\n-winapi = { version = \"0.3\", features = [\"consoleapi\", \"debugapi\", \"processenv\"] }\n-\n-[features]\n-llvm = ['rustc_interface/llvm']\n-max_level_info = ['rustc_log/max_level_info']\n-rustc_use_parallel_compiler = ['rustc_data_structures/rustc_use_parallel_compiler', 'rustc_interface/rustc_use_parallel_compiler',\n-    'rustc_middle/rustc_use_parallel_compiler']\n+rustc_driver_impl = { path = \"../rustc_driver_impl\" }"}, {"sha": "4eabba575f42a425ef264e2d177e9178c9848af7", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1352, "changes": 1355, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1,1353 +1,4 @@\n-//! The Rust compiler.\n-//!\n-//! # Note\n-//!\n-//! This API is completely unstable and subject to change.\n+// This crate is intentionally empty and a rexport of `rustc_driver_impl` to allow the code in\n+// `rustc_driver_impl` to be compiled in parallel with other crates.\n \n-#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n-#![feature(is_terminal)]\n-#![feature(once_cell)]\n-#![feature(decl_macro)]\n-#![recursion_limit = \"256\"]\n-#![allow(rustc::potential_query_instability)]\n-#![deny(rustc::untranslatable_diagnostic)]\n-#![deny(rustc::diagnostic_outside_of_impl)]\n-\n-#[macro_use]\n-extern crate tracing;\n-\n-pub extern crate rustc_plugin_impl as plugin;\n-\n-use rustc_ast as ast;\n-use rustc_codegen_ssa::{traits::CodegenBackend, CodegenErrors, CodegenResults};\n-use rustc_data_structures::profiling::{get_resident_set_size, print_time_passes_entry};\n-use rustc_data_structures::sync::SeqCst;\n-use rustc_errors::registry::{InvalidErrorCode, Registry};\n-use rustc_errors::{ErrorGuaranteed, PResult};\n-use rustc_feature::find_gated_cfg;\n-use rustc_hir::def_id::LOCAL_CRATE;\n-use rustc_interface::util::{self, collect_crate_types, get_codegen_backend};\n-use rustc_interface::{interface, Queries};\n-use rustc_lint::LintStore;\n-use rustc_metadata::locator;\n-use rustc_save_analysis as save;\n-use rustc_save_analysis::DumpHandler;\n-use rustc_session::config::{nightly_options, CG_OPTIONS, Z_OPTIONS};\n-use rustc_session::config::{ErrorOutputType, Input, OutputType, PrintRequest, TrimmedDefPaths};\n-use rustc_session::cstore::MetadataLoader;\n-use rustc_session::getopts;\n-use rustc_session::lint::{Lint, LintId};\n-use rustc_session::{config, Session};\n-use rustc_session::{early_error, early_error_no_abort, early_warn};\n-use rustc_span::source_map::{FileLoader, FileName};\n-use rustc_span::symbol::sym;\n-use rustc_target::json::ToJson;\n-\n-use std::cmp::max;\n-use std::env;\n-use std::ffi::OsString;\n-use std::fs;\n-use std::io::{self, IsTerminal, Read, Write};\n-use std::panic::{self, catch_unwind};\n-use std::path::PathBuf;\n-use std::process::{self, Command, Stdio};\n-use std::str;\n-use std::sync::LazyLock;\n-use std::time::Instant;\n-\n-pub mod args;\n-pub mod pretty;\n-mod session_diagnostics;\n-\n-use crate::session_diagnostics::{\n-    RLinkEmptyVersionNumber, RLinkEncodingVersionMismatch, RLinkRustcVersionMismatch,\n-    RLinkWrongFileType, RlinkNotAFile, RlinkUnableToRead,\n-};\n-\n-/// Exit status code used for successful compilation and help output.\n-pub const EXIT_SUCCESS: i32 = 0;\n-\n-/// Exit status code used for compilation failures and invalid flags.\n-pub const EXIT_FAILURE: i32 = 1;\n-\n-const BUG_REPORT_URL: &str = \"https://github.com/rust-lang/rust/issues/new\\\n-    ?labels=C-bug%2C+I-ICE%2C+T-compiler&template=ice.md\";\n-\n-const ICE_REPORT_COMPILER_FLAGS: &[&str] = &[\"-Z\", \"-C\", \"--crate-type\"];\n-\n-const ICE_REPORT_COMPILER_FLAGS_EXCLUDE: &[&str] = &[\"metadata\", \"extra-filename\"];\n-\n-const ICE_REPORT_COMPILER_FLAGS_STRIP_VALUE: &[&str] = &[\"incremental\"];\n-\n-pub fn abort_on_err<T>(result: Result<T, ErrorGuaranteed>, sess: &Session) -> T {\n-    match result {\n-        Err(..) => {\n-            sess.abort_if_errors();\n-            panic!(\"error reported but abort_if_errors didn't abort???\");\n-        }\n-        Ok(x) => x,\n-    }\n-}\n-\n-pub trait Callbacks {\n-    /// Called before creating the compiler instance\n-    fn config(&mut self, _config: &mut interface::Config) {}\n-    /// Called after parsing. Return value instructs the compiler whether to\n-    /// continue the compilation afterwards (defaults to `Compilation::Continue`)\n-    fn after_parsing<'tcx>(\n-        &mut self,\n-        _compiler: &interface::Compiler,\n-        _queries: &'tcx Queries<'tcx>,\n-    ) -> Compilation {\n-        Compilation::Continue\n-    }\n-    /// Called after expansion. Return value instructs the compiler whether to\n-    /// continue the compilation afterwards (defaults to `Compilation::Continue`)\n-    fn after_expansion<'tcx>(\n-        &mut self,\n-        _compiler: &interface::Compiler,\n-        _queries: &'tcx Queries<'tcx>,\n-    ) -> Compilation {\n-        Compilation::Continue\n-    }\n-    /// Called after analysis. Return value instructs the compiler whether to\n-    /// continue the compilation afterwards (defaults to `Compilation::Continue`)\n-    fn after_analysis<'tcx>(\n-        &mut self,\n-        _compiler: &interface::Compiler,\n-        _queries: &'tcx Queries<'tcx>,\n-    ) -> Compilation {\n-        Compilation::Continue\n-    }\n-}\n-\n-#[derive(Default)]\n-pub struct TimePassesCallbacks {\n-    time_passes: bool,\n-}\n-\n-impl Callbacks for TimePassesCallbacks {\n-    // JUSTIFICATION: the session doesn't exist at this point.\n-    #[allow(rustc::bad_opt_access)]\n-    fn config(&mut self, config: &mut interface::Config) {\n-        // If a --print=... option has been given, we don't print the \"total\"\n-        // time because it will mess up the --print output. See #64339.\n-        //\n-        self.time_passes = config.opts.prints.is_empty() && config.opts.unstable_opts.time_passes;\n-        config.opts.trimmed_def_paths = TrimmedDefPaths::GoodPath;\n-    }\n-}\n-\n-pub fn diagnostics_registry() -> Registry {\n-    Registry::new(rustc_error_codes::DIAGNOSTICS)\n-}\n-\n-/// This is the primary entry point for rustc.\n-pub struct RunCompiler<'a, 'b> {\n-    at_args: &'a [String],\n-    callbacks: &'b mut (dyn Callbacks + Send),\n-    file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n-    make_codegen_backend:\n-        Option<Box<dyn FnOnce(&config::Options) -> Box<dyn CodegenBackend> + Send>>,\n-}\n-\n-impl<'a, 'b> RunCompiler<'a, 'b> {\n-    pub fn new(at_args: &'a [String], callbacks: &'b mut (dyn Callbacks + Send)) -> Self {\n-        Self { at_args, callbacks, file_loader: None, make_codegen_backend: None }\n-    }\n-\n-    /// Set a custom codegen backend.\n-    ///\n-    /// Has no uses within this repository, but is used by bjorn3 for \"the\n-    /// hotswapping branch of cg_clif\" for \"setting the codegen backend from a\n-    /// custom driver where the custom codegen backend has arbitrary data.\"\n-    /// (See #102759.)\n-    pub fn set_make_codegen_backend(\n-        &mut self,\n-        make_codegen_backend: Option<\n-            Box<dyn FnOnce(&config::Options) -> Box<dyn CodegenBackend> + Send>,\n-        >,\n-    ) -> &mut Self {\n-        self.make_codegen_backend = make_codegen_backend;\n-        self\n-    }\n-\n-    /// Load files from sources other than the file system.\n-    ///\n-    /// Has no uses within this repository, but may be used in the future by\n-    /// bjorn3 for \"hooking rust-analyzer's VFS into rustc at some point for\n-    /// running rustc without having to save\". (See #102759.)\n-    pub fn set_file_loader(\n-        &mut self,\n-        file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n-    ) -> &mut Self {\n-        self.file_loader = file_loader;\n-        self\n-    }\n-\n-    /// Parse args and run the compiler.\n-    pub fn run(self) -> interface::Result<()> {\n-        run_compiler(self.at_args, self.callbacks, self.file_loader, self.make_codegen_backend)\n-    }\n-}\n-\n-fn run_compiler(\n-    at_args: &[String],\n-    callbacks: &mut (dyn Callbacks + Send),\n-    file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n-    make_codegen_backend: Option<\n-        Box<dyn FnOnce(&config::Options) -> Box<dyn CodegenBackend> + Send>,\n-    >,\n-) -> interface::Result<()> {\n-    let args = args::arg_expand_all(at_args);\n-\n-    let Some(matches) = handle_options(&args) else { return Ok(()) };\n-\n-    let sopts = config::build_session_options(&matches);\n-\n-    if let Some(ref code) = matches.opt_str(\"explain\") {\n-        handle_explain(diagnostics_registry(), code, sopts.error_format);\n-        return Ok(());\n-    }\n-\n-    let cfg = interface::parse_cfgspecs(matches.opt_strs(\"cfg\"));\n-    let check_cfg = interface::parse_check_cfg(matches.opt_strs(\"check-cfg\"));\n-    let (odir, ofile) = make_output(&matches);\n-    let mut config = interface::Config {\n-        opts: sopts,\n-        crate_cfg: cfg,\n-        crate_check_cfg: check_cfg,\n-        input: Input::File(PathBuf::new()),\n-        output_file: ofile,\n-        output_dir: odir,\n-        file_loader,\n-        lint_caps: Default::default(),\n-        parse_sess_created: None,\n-        register_lints: None,\n-        override_queries: None,\n-        make_codegen_backend,\n-        registry: diagnostics_registry(),\n-    };\n-\n-    if !tracing::dispatcher::has_been_set() {\n-        init_rustc_env_logger_with_backtrace_option(&config.opts.unstable_opts.log_backtrace);\n-    }\n-\n-    match make_input(config.opts.error_format, &matches.free) {\n-        Err(reported) => return Err(reported),\n-        Ok(Some(input)) => {\n-            config.input = input;\n-\n-            callbacks.config(&mut config);\n-        }\n-        Ok(None) => match matches.free.len() {\n-            0 => {\n-                callbacks.config(&mut config);\n-                interface::run_compiler(config, |compiler| {\n-                    let sopts = &compiler.session().opts;\n-                    if sopts.describe_lints {\n-                        let mut lint_store =\n-                            rustc_lint::new_lint_store(compiler.session().enable_internal_lints());\n-                        let registered_lints =\n-                            if let Some(register_lints) = compiler.register_lints() {\n-                                register_lints(compiler.session(), &mut lint_store);\n-                                true\n-                            } else {\n-                                false\n-                            };\n-                        describe_lints(compiler.session(), &lint_store, registered_lints);\n-                        return;\n-                    }\n-                    let should_stop =\n-                        print_crate_info(&***compiler.codegen_backend(), compiler.session(), false);\n-\n-                    if should_stop == Compilation::Stop {\n-                        return;\n-                    }\n-                    early_error(sopts.error_format, \"no input filename given\")\n-                });\n-                return Ok(());\n-            }\n-            1 => panic!(\"make_input should have provided valid inputs\"),\n-            _ => early_error(\n-                config.opts.error_format,\n-                &format!(\n-                    \"multiple input filenames provided (first two filenames are `{}` and `{}`)\",\n-                    matches.free[0], matches.free[1],\n-                ),\n-            ),\n-        },\n-    };\n-\n-    interface::run_compiler(config, |compiler| {\n-        let sess = compiler.session();\n-        let should_stop = print_crate_info(&***compiler.codegen_backend(), sess, true)\n-            .and_then(|| list_metadata(sess, &*compiler.codegen_backend().metadata_loader()))\n-            .and_then(|| try_process_rlink(sess, compiler));\n-\n-        if should_stop == Compilation::Stop {\n-            return sess.compile_status();\n-        }\n-\n-        let linker = compiler.enter(|queries| {\n-            let early_exit = || sess.compile_status().map(|_| None);\n-            queries.parse()?;\n-\n-            if let Some(ppm) = &sess.opts.pretty {\n-                if ppm.needs_ast_map() {\n-                    queries.global_ctxt()?.enter(|tcx| {\n-                        pretty::print_after_hir_lowering(tcx, *ppm);\n-                        Ok(())\n-                    })?;\n-                } else {\n-                    let krate = queries.parse()?.steal();\n-                    pretty::print_after_parsing(sess, &krate, *ppm);\n-                }\n-                trace!(\"finished pretty-printing\");\n-                return early_exit();\n-            }\n-\n-            if callbacks.after_parsing(compiler, queries) == Compilation::Stop {\n-                return early_exit();\n-            }\n-\n-            if sess.opts.unstable_opts.parse_only || sess.opts.unstable_opts.show_span.is_some() {\n-                return early_exit();\n-            }\n-\n-            {\n-                let plugins = queries.register_plugins()?;\n-                let (_, lint_store) = &*plugins.borrow();\n-\n-                // Lint plugins are registered; now we can process command line flags.\n-                if sess.opts.describe_lints {\n-                    describe_lints(sess, lint_store, true);\n-                    return early_exit();\n-                }\n-            }\n-\n-            let mut gctxt = queries.global_ctxt()?;\n-            if callbacks.after_expansion(compiler, queries) == Compilation::Stop {\n-                return early_exit();\n-            }\n-\n-            // Make sure the `output_filenames` query is run for its side\n-            // effects of writing the dep-info and reporting errors.\n-            gctxt.enter(|tcx| tcx.output_filenames(()));\n-\n-            if sess.opts.output_types.contains_key(&OutputType::DepInfo)\n-                && sess.opts.output_types.len() == 1\n-            {\n-                return early_exit();\n-            }\n-\n-            if sess.opts.unstable_opts.no_analysis {\n-                return early_exit();\n-            }\n-\n-            gctxt.enter(|tcx| {\n-                let result = tcx.analysis(());\n-                if sess.opts.unstable_opts.save_analysis {\n-                    let crate_name = tcx.crate_name(LOCAL_CRATE);\n-                    sess.time(\"save_analysis\", || {\n-                        save::process_crate(\n-                            tcx,\n-                            crate_name,\n-                            &sess.io.input,\n-                            None,\n-                            DumpHandler::new(sess.io.output_dir.as_deref(), crate_name),\n-                        )\n-                    });\n-                }\n-                result\n-            })?;\n-\n-            drop(gctxt);\n-\n-            if callbacks.after_analysis(compiler, queries) == Compilation::Stop {\n-                return early_exit();\n-            }\n-\n-            queries.ongoing_codegen()?;\n-\n-            if sess.opts.unstable_opts.print_type_sizes {\n-                sess.code_stats.print_type_sizes();\n-            }\n-\n-            let linker = queries.linker()?;\n-            Ok(Some(linker))\n-        })?;\n-\n-        if let Some(linker) = linker {\n-            let _timer = sess.timer(\"link\");\n-            linker.link()?\n-        }\n-\n-        if sess.opts.unstable_opts.perf_stats {\n-            sess.print_perf_stats();\n-        }\n-\n-        if sess.opts.unstable_opts.print_fuel.is_some() {\n-            eprintln!(\n-                \"Fuel used by {}: {}\",\n-                sess.opts.unstable_opts.print_fuel.as_ref().unwrap(),\n-                sess.print_fuel.load(SeqCst)\n-            );\n-        }\n-\n-        Ok(())\n-    })\n-}\n-\n-// Extract output directory and file from matches.\n-fn make_output(matches: &getopts::Matches) -> (Option<PathBuf>, Option<PathBuf>) {\n-    let odir = matches.opt_str(\"out-dir\").map(|o| PathBuf::from(&o));\n-    let ofile = matches.opt_str(\"o\").map(|o| PathBuf::from(&o));\n-    (odir, ofile)\n-}\n-\n-// Extract input (string or file and optional path) from matches.\n-fn make_input(\n-    error_format: ErrorOutputType,\n-    free_matches: &[String],\n-) -> Result<Option<Input>, ErrorGuaranteed> {\n-    if free_matches.len() == 1 {\n-        let ifile = &free_matches[0];\n-        if ifile == \"-\" {\n-            let mut src = String::new();\n-            if io::stdin().read_to_string(&mut src).is_err() {\n-                // Immediately stop compilation if there was an issue reading\n-                // the input (for example if the input stream is not UTF-8).\n-                let reported = early_error_no_abort(\n-                    error_format,\n-                    \"couldn't read from stdin, as it did not contain valid UTF-8\",\n-                );\n-                return Err(reported);\n-            }\n-            if let Ok(path) = env::var(\"UNSTABLE_RUSTDOC_TEST_PATH\") {\n-                let line = env::var(\"UNSTABLE_RUSTDOC_TEST_LINE\").expect(\n-                    \"when UNSTABLE_RUSTDOC_TEST_PATH is set \\\n-                                    UNSTABLE_RUSTDOC_TEST_LINE also needs to be set\",\n-                );\n-                let line = isize::from_str_radix(&line, 10)\n-                    .expect(\"UNSTABLE_RUSTDOC_TEST_LINE needs to be an number\");\n-                let file_name = FileName::doc_test_source_code(PathBuf::from(path), line);\n-                Ok(Some(Input::Str { name: file_name, input: src }))\n-            } else {\n-                Ok(Some(Input::Str { name: FileName::anon_source_code(&src), input: src }))\n-            }\n-        } else {\n-            Ok(Some(Input::File(PathBuf::from(ifile))))\n-        }\n-    } else {\n-        Ok(None)\n-    }\n-}\n-\n-/// Whether to stop or continue compilation.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-pub enum Compilation {\n-    Stop,\n-    Continue,\n-}\n-\n-impl Compilation {\n-    pub fn and_then<F: FnOnce() -> Compilation>(self, next: F) -> Compilation {\n-        match self {\n-            Compilation::Stop => Compilation::Stop,\n-            Compilation::Continue => next(),\n-        }\n-    }\n-}\n-\n-fn handle_explain(registry: Registry, code: &str, output: ErrorOutputType) {\n-    let upper_cased_code = code.to_ascii_uppercase();\n-    let normalised =\n-        if upper_cased_code.starts_with('E') { upper_cased_code } else { format!(\"E{code:0>4}\") };\n-    match registry.try_find_description(&normalised) {\n-        Ok(Some(description)) => {\n-            let mut is_in_code_block = false;\n-            let mut text = String::new();\n-            // Slice off the leading newline and print.\n-            for line in description.lines() {\n-                let indent_level =\n-                    line.find(|c: char| !c.is_whitespace()).unwrap_or_else(|| line.len());\n-                let dedented_line = &line[indent_level..];\n-                if dedented_line.starts_with(\"```\") {\n-                    is_in_code_block = !is_in_code_block;\n-                    text.push_str(&line[..(indent_level + 3)]);\n-                } else if is_in_code_block && dedented_line.starts_with(\"# \") {\n-                    continue;\n-                } else {\n-                    text.push_str(line);\n-                }\n-                text.push('\\n');\n-            }\n-            if io::stdout().is_terminal() {\n-                show_content_with_pager(&text);\n-            } else {\n-                print!(\"{text}\");\n-            }\n-        }\n-        Ok(None) => {\n-            early_error(output, &format!(\"no extended information for {code}\"));\n-        }\n-        Err(InvalidErrorCode) => {\n-            early_error(output, &format!(\"{code} is not a valid error code\"));\n-        }\n-    }\n-}\n-\n-fn show_content_with_pager(content: &str) {\n-    let pager_name = env::var_os(\"PAGER\").unwrap_or_else(|| {\n-        if cfg!(windows) { OsString::from(\"more.com\") } else { OsString::from(\"less\") }\n-    });\n-\n-    let mut fallback_to_println = false;\n-\n-    match Command::new(pager_name).stdin(Stdio::piped()).spawn() {\n-        Ok(mut pager) => {\n-            if let Some(pipe) = pager.stdin.as_mut() {\n-                if pipe.write_all(content.as_bytes()).is_err() {\n-                    fallback_to_println = true;\n-                }\n-            }\n-\n-            if pager.wait().is_err() {\n-                fallback_to_println = true;\n-            }\n-        }\n-        Err(_) => {\n-            fallback_to_println = true;\n-        }\n-    }\n-\n-    // If pager fails for whatever reason, we should still print the content\n-    // to standard output\n-    if fallback_to_println {\n-        print!(\"{content}\");\n-    }\n-}\n-\n-pub fn try_process_rlink(sess: &Session, compiler: &interface::Compiler) -> Compilation {\n-    if sess.opts.unstable_opts.link_only {\n-        if let Input::File(file) = &sess.io.input {\n-            // FIXME: #![crate_type] and #![crate_name] support not implemented yet\n-            sess.init_crate_types(collect_crate_types(sess, &[]));\n-            let outputs = compiler.build_output_filenames(sess, &[]);\n-            let rlink_data = fs::read(file).unwrap_or_else(|err| {\n-                sess.emit_fatal(RlinkUnableToRead { err });\n-            });\n-            let codegen_results = match CodegenResults::deserialize_rlink(rlink_data) {\n-                Ok(codegen) => codegen,\n-                Err(err) => {\n-                    match err {\n-                        CodegenErrors::WrongFileType => sess.emit_fatal(RLinkWrongFileType),\n-                        CodegenErrors::EmptyVersionNumber => {\n-                            sess.emit_fatal(RLinkEmptyVersionNumber)\n-                        }\n-                        CodegenErrors::EncodingVersionMismatch { version_array, rlink_version } => {\n-                            sess.emit_fatal(RLinkEncodingVersionMismatch {\n-                                version_array,\n-                                rlink_version,\n-                            })\n-                        }\n-                        CodegenErrors::RustcVersionMismatch { rustc_version, current_version } => {\n-                            sess.emit_fatal(RLinkRustcVersionMismatch {\n-                                rustc_version,\n-                                current_version,\n-                            })\n-                        }\n-                    };\n-                }\n-            };\n-            let result = compiler.codegen_backend().link(sess, codegen_results, &outputs);\n-            abort_on_err(result, sess);\n-        } else {\n-            sess.emit_fatal(RlinkNotAFile {})\n-        }\n-        Compilation::Stop\n-    } else {\n-        Compilation::Continue\n-    }\n-}\n-\n-pub fn list_metadata(sess: &Session, metadata_loader: &dyn MetadataLoader) -> Compilation {\n-    if sess.opts.unstable_opts.ls {\n-        match sess.io.input {\n-            Input::File(ref ifile) => {\n-                let path = &(*ifile);\n-                let mut v = Vec::new();\n-                locator::list_file_metadata(&sess.target, path, metadata_loader, &mut v).unwrap();\n-                println!(\"{}\", String::from_utf8(v).unwrap());\n-            }\n-            Input::Str { .. } => {\n-                early_error(ErrorOutputType::default(), \"cannot list metadata for stdin\");\n-            }\n-        }\n-        return Compilation::Stop;\n-    }\n-\n-    Compilation::Continue\n-}\n-\n-fn print_crate_info(\n-    codegen_backend: &dyn CodegenBackend,\n-    sess: &Session,\n-    parse_attrs: bool,\n-) -> Compilation {\n-    use rustc_session::config::PrintRequest::*;\n-    // NativeStaticLibs and LinkArgs are special - printed during linking\n-    // (empty iterator returns true)\n-    if sess.opts.prints.iter().all(|&p| p == NativeStaticLibs || p == LinkArgs) {\n-        return Compilation::Continue;\n-    }\n-\n-    let attrs = if parse_attrs {\n-        let result = parse_crate_attrs(sess);\n-        match result {\n-            Ok(attrs) => Some(attrs),\n-            Err(mut parse_error) => {\n-                parse_error.emit();\n-                return Compilation::Stop;\n-            }\n-        }\n-    } else {\n-        None\n-    };\n-    for req in &sess.opts.prints {\n-        match *req {\n-            TargetList => {\n-                let mut targets = rustc_target::spec::TARGETS.to_vec();\n-                targets.sort_unstable();\n-                println!(\"{}\", targets.join(\"\\n\"));\n-            }\n-            Sysroot => println!(\"{}\", sess.sysroot.display()),\n-            TargetLibdir => println!(\"{}\", sess.target_tlib_path.dir.display()),\n-            TargetSpec => {\n-                println!(\"{}\", serde_json::to_string_pretty(&sess.target.to_json()).unwrap());\n-            }\n-            FileNames | CrateName => {\n-                let attrs = attrs.as_ref().unwrap();\n-                let t_outputs = rustc_interface::util::build_output_filenames(attrs, sess);\n-                let id = rustc_session::output::find_crate_name(sess, attrs);\n-                if *req == PrintRequest::CrateName {\n-                    println!(\"{id}\");\n-                    continue;\n-                }\n-                let crate_types = collect_crate_types(sess, attrs);\n-                for &style in &crate_types {\n-                    let fname =\n-                        rustc_session::output::filename_for_input(sess, style, id, &t_outputs);\n-                    println!(\"{}\", fname.file_name().unwrap().to_string_lossy());\n-                }\n-            }\n-            Cfg => {\n-                let mut cfgs = sess\n-                    .parse_sess\n-                    .config\n-                    .iter()\n-                    .filter_map(|&(name, value)| {\n-                        // Note that crt-static is a specially recognized cfg\n-                        // directive that's printed out here as part of\n-                        // rust-lang/rust#37406, but in general the\n-                        // `target_feature` cfg is gated under\n-                        // rust-lang/rust#29717. For now this is just\n-                        // specifically allowing the crt-static cfg and that's\n-                        // it, this is intended to get into Cargo and then go\n-                        // through to build scripts.\n-                        if (name != sym::target_feature || value != Some(sym::crt_dash_static))\n-                            && !sess.is_nightly_build()\n-                            && find_gated_cfg(|cfg_sym| cfg_sym == name).is_some()\n-                        {\n-                            return None;\n-                        }\n-\n-                        if let Some(value) = value {\n-                            Some(format!(\"{name}=\\\"{value}\\\"\"))\n-                        } else {\n-                            Some(name.to_string())\n-                        }\n-                    })\n-                    .collect::<Vec<String>>();\n-\n-                cfgs.sort();\n-                for cfg in cfgs {\n-                    println!(\"{cfg}\");\n-                }\n-            }\n-            CallingConventions => {\n-                let mut calling_conventions = rustc_target::spec::abi::all_names();\n-                calling_conventions.sort_unstable();\n-                println!(\"{}\", calling_conventions.join(\"\\n\"));\n-            }\n-            RelocationModels\n-            | CodeModels\n-            | TlsModels\n-            | TargetCPUs\n-            | StackProtectorStrategies\n-            | TargetFeatures => {\n-                codegen_backend.print(*req, sess);\n-            }\n-            // Any output here interferes with Cargo's parsing of other printed output\n-            NativeStaticLibs => {}\n-            LinkArgs => {}\n-            SplitDebuginfo => {\n-                use rustc_target::spec::SplitDebuginfo::{Off, Packed, Unpacked};\n-\n-                for split in &[Off, Packed, Unpacked] {\n-                    let stable = sess.target.options.supported_split_debuginfo.contains(split);\n-                    let unstable_ok = sess.unstable_options();\n-                    if stable || unstable_ok {\n-                        println!(\"{split}\");\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    Compilation::Stop\n-}\n-\n-/// Prints version information\n-///\n-/// NOTE: this is a macro to support drivers built at a different time than the main `rustc_driver` crate.\n-pub macro version($binary: literal, $matches: expr) {\n-    fn unw(x: Option<&str>) -> &str {\n-        x.unwrap_or(\"unknown\")\n-    }\n-    $crate::version_at_macro_invocation(\n-        $binary,\n-        $matches,\n-        unw(option_env!(\"CFG_VERSION\")),\n-        unw(option_env!(\"CFG_VER_HASH\")),\n-        unw(option_env!(\"CFG_VER_DATE\")),\n-        unw(option_env!(\"CFG_RELEASE\")),\n-    )\n-}\n-\n-#[doc(hidden)] // use the macro instead\n-pub fn version_at_macro_invocation(\n-    binary: &str,\n-    matches: &getopts::Matches,\n-    version: &str,\n-    commit_hash: &str,\n-    commit_date: &str,\n-    release: &str,\n-) {\n-    let verbose = matches.opt_present(\"verbose\");\n-\n-    println!(\"{binary} {version}\");\n-\n-    if verbose {\n-        println!(\"binary: {binary}\");\n-        println!(\"commit-hash: {commit_hash}\");\n-        println!(\"commit-date: {commit_date}\");\n-        println!(\"host: {}\", config::host_triple());\n-        println!(\"release: {release}\");\n-\n-        let debug_flags = matches.opt_strs(\"Z\");\n-        let backend_name = debug_flags.iter().find_map(|x| x.strip_prefix(\"codegen-backend=\"));\n-        get_codegen_backend(&None, backend_name).print_version();\n-    }\n-}\n-\n-fn usage(verbose: bool, include_unstable_options: bool, nightly_build: bool) {\n-    let groups = if verbose { config::rustc_optgroups() } else { config::rustc_short_optgroups() };\n-    let mut options = getopts::Options::new();\n-    for option in groups.iter().filter(|x| include_unstable_options || x.is_stable()) {\n-        (option.apply)(&mut options);\n-    }\n-    let message = \"Usage: rustc [OPTIONS] INPUT\";\n-    let nightly_help = if nightly_build {\n-        \"\\n    -Z help             Print unstable compiler options\"\n-    } else {\n-        \"\"\n-    };\n-    let verbose_help = if verbose {\n-        \"\"\n-    } else {\n-        \"\\n    --help -v           Print the full set of options rustc accepts\"\n-    };\n-    let at_path = if verbose {\n-        \"    @path               Read newline separated options from `path`\\n\"\n-    } else {\n-        \"\"\n-    };\n-    println!(\n-        \"{options}{at_path}\\nAdditional help:\n-    -C help             Print codegen options\n-    -W help             \\\n-              Print 'lint' options and default settings{nightly}{verbose}\\n\",\n-        options = options.usage(message),\n-        at_path = at_path,\n-        nightly = nightly_help,\n-        verbose = verbose_help\n-    );\n-}\n-\n-fn print_wall_help() {\n-    println!(\n-        \"\n-The flag `-Wall` does not exist in `rustc`. Most useful lints are enabled by\n-default. Use `rustc -W help` to see all available lints. It's more common to put\n-warning settings in the crate root using `#![warn(LINT_NAME)]` instead of using\n-the command line flag directly.\n-\"\n-    );\n-}\n-\n-/// Write to stdout lint command options, together with a list of all available lints\n-pub fn describe_lints(sess: &Session, lint_store: &LintStore, loaded_plugins: bool) {\n-    println!(\n-        \"\n-Available lint options:\n-    -W <foo>           Warn about <foo>\n-    -A <foo>           \\\n-              Allow <foo>\n-    -D <foo>           Deny <foo>\n-    -F <foo>           Forbid <foo> \\\n-              (deny <foo> and all attempts to override)\n-\n-\"\n-    );\n-\n-    fn sort_lints(sess: &Session, mut lints: Vec<&'static Lint>) -> Vec<&'static Lint> {\n-        // The sort doesn't case-fold but it's doubtful we care.\n-        lints.sort_by_cached_key(|x: &&Lint| (x.default_level(sess.edition()), x.name));\n-        lints\n-    }\n-\n-    fn sort_lint_groups(\n-        lints: Vec<(&'static str, Vec<LintId>, bool)>,\n-    ) -> Vec<(&'static str, Vec<LintId>)> {\n-        let mut lints: Vec<_> = lints.into_iter().map(|(x, y, _)| (x, y)).collect();\n-        lints.sort_by_key(|l| l.0);\n-        lints\n-    }\n-\n-    let (plugin, builtin): (Vec<_>, _) =\n-        lint_store.get_lints().iter().cloned().partition(|&lint| lint.is_plugin);\n-    let plugin = sort_lints(sess, plugin);\n-    let builtin = sort_lints(sess, builtin);\n-\n-    let (plugin_groups, builtin_groups): (Vec<_>, _) =\n-        lint_store.get_lint_groups().partition(|&(.., p)| p);\n-    let plugin_groups = sort_lint_groups(plugin_groups);\n-    let builtin_groups = sort_lint_groups(builtin_groups);\n-\n-    let max_name_len =\n-        plugin.iter().chain(&builtin).map(|&s| s.name.chars().count()).max().unwrap_or(0);\n-    let padded = |x: &str| {\n-        let mut s = \" \".repeat(max_name_len - x.chars().count());\n-        s.push_str(x);\n-        s\n-    };\n-\n-    println!(\"Lint checks provided by rustc:\\n\");\n-\n-    let print_lints = |lints: Vec<&Lint>| {\n-        println!(\"    {}  {:7.7}  {}\", padded(\"name\"), \"default\", \"meaning\");\n-        println!(\"    {}  {:7.7}  {}\", padded(\"----\"), \"-------\", \"-------\");\n-        for lint in lints {\n-            let name = lint.name_lower().replace('_', \"-\");\n-            println!(\n-                \"    {}  {:7.7}  {}\",\n-                padded(&name),\n-                lint.default_level(sess.edition()).as_str(),\n-                lint.desc\n-            );\n-        }\n-        println!(\"\\n\");\n-    };\n-\n-    print_lints(builtin);\n-\n-    let max_name_len = max(\n-        \"warnings\".len(),\n-        plugin_groups\n-            .iter()\n-            .chain(&builtin_groups)\n-            .map(|&(s, _)| s.chars().count())\n-            .max()\n-            .unwrap_or(0),\n-    );\n-\n-    let padded = |x: &str| {\n-        let mut s = \" \".repeat(max_name_len - x.chars().count());\n-        s.push_str(x);\n-        s\n-    };\n-\n-    println!(\"Lint groups provided by rustc:\\n\");\n-\n-    let print_lint_groups = |lints: Vec<(&'static str, Vec<LintId>)>, all_warnings| {\n-        println!(\"    {}  sub-lints\", padded(\"name\"));\n-        println!(\"    {}  ---------\", padded(\"----\"));\n-\n-        if all_warnings {\n-            println!(\"    {}  all lints that are set to issue warnings\", padded(\"warnings\"));\n-        }\n-\n-        for (name, to) in lints {\n-            let name = name.to_lowercase().replace('_', \"-\");\n-            let desc = to\n-                .into_iter()\n-                .map(|x| x.to_string().replace('_', \"-\"))\n-                .collect::<Vec<String>>()\n-                .join(\", \");\n-            println!(\"    {}  {}\", padded(&name), desc);\n-        }\n-        println!(\"\\n\");\n-    };\n-\n-    print_lint_groups(builtin_groups, true);\n-\n-    match (loaded_plugins, plugin.len(), plugin_groups.len()) {\n-        (false, 0, _) | (false, _, 0) => {\n-            println!(\"Lint tools like Clippy can provide additional lints and lint groups.\");\n-        }\n-        (false, ..) => panic!(\"didn't load lint plugins but got them anyway!\"),\n-        (true, 0, 0) => println!(\"This crate does not load any lint plugins or lint groups.\"),\n-        (true, l, g) => {\n-            if l > 0 {\n-                println!(\"Lint checks provided by plugins loaded by this crate:\\n\");\n-                print_lints(plugin);\n-            }\n-            if g > 0 {\n-                println!(\"Lint groups provided by plugins loaded by this crate:\\n\");\n-                print_lint_groups(plugin_groups, false);\n-            }\n-        }\n-    }\n-}\n-\n-fn describe_debug_flags() {\n-    println!(\"\\nAvailable options:\\n\");\n-    print_flag_list(\"-Z\", config::Z_OPTIONS);\n-}\n-\n-fn describe_codegen_flags() {\n-    println!(\"\\nAvailable codegen options:\\n\");\n-    print_flag_list(\"-C\", config::CG_OPTIONS);\n-}\n-\n-pub fn print_flag_list<T>(\n-    cmdline_opt: &str,\n-    flag_list: &[(&'static str, T, &'static str, &'static str)],\n-) {\n-    let max_len = flag_list.iter().map(|&(name, _, _, _)| name.chars().count()).max().unwrap_or(0);\n-\n-    for &(name, _, _, desc) in flag_list {\n-        println!(\n-            \"    {} {:>width$}=val -- {}\",\n-            cmdline_opt,\n-            name.replace('_', \"-\"),\n-            desc,\n-            width = max_len\n-        );\n-    }\n-}\n-\n-/// Process command line options. Emits messages as appropriate. If compilation\n-/// should continue, returns a getopts::Matches object parsed from args,\n-/// otherwise returns `None`.\n-///\n-/// The compiler's handling of options is a little complicated as it ties into\n-/// our stability story. The current intention of each compiler option is to\n-/// have one of two modes:\n-///\n-/// 1. An option is stable and can be used everywhere.\n-/// 2. An option is unstable, and can only be used on nightly.\n-///\n-/// Like unstable library and language features, however, unstable options have\n-/// always required a form of \"opt in\" to indicate that you're using them. This\n-/// provides the easy ability to scan a code base to check to see if anything\n-/// unstable is being used. Currently, this \"opt in\" is the `-Z` \"zed\" flag.\n-///\n-/// All options behind `-Z` are considered unstable by default. Other top-level\n-/// options can also be considered unstable, and they were unlocked through the\n-/// `-Z unstable-options` flag. Note that `-Z` remains to be the root of\n-/// instability in both cases, though.\n-///\n-/// So with all that in mind, the comments below have some more detail about the\n-/// contortions done here to get things to work out correctly.\n-pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n-    // Throw away the first argument, the name of the binary\n-    let args = &args[1..];\n-\n-    if args.is_empty() {\n-        // user did not write `-v` nor `-Z unstable-options`, so do not\n-        // include that extra information.\n-        let nightly_build =\n-            rustc_feature::UnstableFeatures::from_environment(None).is_nightly_build();\n-        usage(false, false, nightly_build);\n-        return None;\n-    }\n-\n-    // Parse with *all* options defined in the compiler, we don't worry about\n-    // option stability here we just want to parse as much as possible.\n-    let mut options = getopts::Options::new();\n-    for option in config::rustc_optgroups() {\n-        (option.apply)(&mut options);\n-    }\n-    let matches = options.parse(args).unwrap_or_else(|e| {\n-        let msg = match e {\n-            getopts::Fail::UnrecognizedOption(ref opt) => CG_OPTIONS\n-                .iter()\n-                .map(|&(name, ..)| ('C', name))\n-                .chain(Z_OPTIONS.iter().map(|&(name, ..)| ('Z', name)))\n-                .find(|&(_, name)| *opt == name.replace('_', \"-\"))\n-                .map(|(flag, _)| format!(\"{e}. Did you mean `-{flag} {opt}`?\")),\n-            _ => None,\n-        };\n-        early_error(ErrorOutputType::default(), &msg.unwrap_or_else(|| e.to_string()));\n-    });\n-\n-    // For all options we just parsed, we check a few aspects:\n-    //\n-    // * If the option is stable, we're all good\n-    // * If the option wasn't passed, we're all good\n-    // * If `-Z unstable-options` wasn't passed (and we're not a -Z option\n-    //   ourselves), then we require the `-Z unstable-options` flag to unlock\n-    //   this option that was passed.\n-    // * If we're a nightly compiler, then unstable options are now unlocked, so\n-    //   we're good to go.\n-    // * Otherwise, if we're an unstable option then we generate an error\n-    //   (unstable option being used on stable)\n-    nightly_options::check_nightly_options(&matches, &config::rustc_optgroups());\n-\n-    if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n-        // Only show unstable options in --help if we accept unstable options.\n-        let unstable_enabled = nightly_options::is_unstable_enabled(&matches);\n-        let nightly_build = nightly_options::match_is_nightly_build(&matches);\n-        usage(matches.opt_present(\"verbose\"), unstable_enabled, nightly_build);\n-        return None;\n-    }\n-\n-    // Handle the special case of -Wall.\n-    let wall = matches.opt_strs(\"W\");\n-    if wall.iter().any(|x| *x == \"all\") {\n-        print_wall_help();\n-        rustc_errors::FatalError.raise();\n-    }\n-\n-    // Don't handle -W help here, because we might first load plugins.\n-    let debug_flags = matches.opt_strs(\"Z\");\n-    if debug_flags.iter().any(|x| *x == \"help\") {\n-        describe_debug_flags();\n-        return None;\n-    }\n-\n-    let cg_flags = matches.opt_strs(\"C\");\n-\n-    if cg_flags.iter().any(|x| *x == \"help\") {\n-        describe_codegen_flags();\n-        return None;\n-    }\n-\n-    if cg_flags.iter().any(|x| *x == \"no-stack-check\") {\n-        early_warn(\n-            ErrorOutputType::default(),\n-            \"the --no-stack-check flag is deprecated and does nothing\",\n-        );\n-    }\n-\n-    if cg_flags.iter().any(|x| *x == \"passes=list\") {\n-        let backend_name = debug_flags.iter().find_map(|x| x.strip_prefix(\"codegen-backend=\"));\n-        get_codegen_backend(&None, backend_name).print_passes();\n-        return None;\n-    }\n-\n-    if matches.opt_present(\"version\") {\n-        version!(\"rustc\", &matches);\n-        return None;\n-    }\n-\n-    Some(matches)\n-}\n-\n-fn parse_crate_attrs<'a>(sess: &'a Session) -> PResult<'a, ast::AttrVec> {\n-    match &sess.io.input {\n-        Input::File(ifile) => rustc_parse::parse_crate_attrs_from_file(ifile, &sess.parse_sess),\n-        Input::Str { name, input } => rustc_parse::parse_crate_attrs_from_source_str(\n-            name.clone(),\n-            input.clone(),\n-            &sess.parse_sess,\n-        ),\n-    }\n-}\n-\n-/// Gets a list of extra command-line flags provided by the user, as strings.\n-///\n-/// This function is used during ICEs to show more information useful for\n-/// debugging, since some ICEs only happens with non-default compiler flags\n-/// (and the users don't always report them).\n-fn extra_compiler_flags() -> Option<(Vec<String>, bool)> {\n-    let mut args = env::args_os().map(|arg| arg.to_string_lossy().to_string()).peekable();\n-\n-    let mut result = Vec::new();\n-    let mut excluded_cargo_defaults = false;\n-    while let Some(arg) = args.next() {\n-        if let Some(a) = ICE_REPORT_COMPILER_FLAGS.iter().find(|a| arg.starts_with(*a)) {\n-            let content = if arg.len() == a.len() {\n-                // A space-separated option, like `-C incremental=foo` or `--crate-type rlib`\n-                match args.next() {\n-                    Some(arg) => arg.to_string(),\n-                    None => continue,\n-                }\n-            } else if arg.get(a.len()..a.len() + 1) == Some(\"=\") {\n-                // An equals option, like `--crate-type=rlib`\n-                arg[a.len() + 1..].to_string()\n-            } else {\n-                // A non-space option, like `-Cincremental=foo`\n-                arg[a.len()..].to_string()\n-            };\n-            let option = content.split_once('=').map(|s| s.0).unwrap_or(&content);\n-            if ICE_REPORT_COMPILER_FLAGS_EXCLUDE.iter().any(|exc| option == *exc) {\n-                excluded_cargo_defaults = true;\n-            } else {\n-                result.push(a.to_string());\n-                match ICE_REPORT_COMPILER_FLAGS_STRIP_VALUE.iter().find(|s| option == **s) {\n-                    Some(s) => result.push(format!(\"{s}=[REDACTED]\")),\n-                    None => result.push(content),\n-                }\n-            }\n-        }\n-    }\n-\n-    if !result.is_empty() { Some((result, excluded_cargo_defaults)) } else { None }\n-}\n-\n-/// Runs a closure and catches unwinds triggered by fatal errors.\n-///\n-/// The compiler currently unwinds with a special sentinel value to abort\n-/// compilation on fatal errors. This function catches that sentinel and turns\n-/// the panic into a `Result` instead.\n-pub fn catch_fatal_errors<F: FnOnce() -> R, R>(f: F) -> Result<R, ErrorGuaranteed> {\n-    catch_unwind(panic::AssertUnwindSafe(f)).map_err(|value| {\n-        if value.is::<rustc_errors::FatalErrorMarker>() {\n-            ErrorGuaranteed::unchecked_claim_error_was_emitted()\n-        } else {\n-            panic::resume_unwind(value);\n-        }\n-    })\n-}\n-\n-/// Variant of `catch_fatal_errors` for the `interface::Result` return type\n-/// that also computes the exit code.\n-pub fn catch_with_exit_code(f: impl FnOnce() -> interface::Result<()>) -> i32 {\n-    let result = catch_fatal_errors(f).and_then(|result| result);\n-    match result {\n-        Ok(()) => EXIT_SUCCESS,\n-        Err(_) => EXIT_FAILURE,\n-    }\n-}\n-\n-static DEFAULT_HOOK: LazyLock<Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send + 'static>> =\n-    LazyLock::new(|| {\n-        let hook = panic::take_hook();\n-        panic::set_hook(Box::new(|info| {\n-            // If the error was caused by a broken pipe then this is not a bug.\n-            // Write the error and return immediately. See #98700.\n-            #[cfg(windows)]\n-            if let Some(msg) = info.payload().downcast_ref::<String>() {\n-                if msg.starts_with(\"failed printing to stdout: \") && msg.ends_with(\"(os error 232)\")\n-                {\n-                    early_error_no_abort(ErrorOutputType::default(), &msg);\n-                    return;\n-                }\n-            };\n-\n-            // Invoke the default handler, which prints the actual panic message and optionally a backtrace\n-            // Don't do this for delayed bugs, which already emit their own more useful backtrace.\n-            if !info.payload().is::<rustc_errors::DelayedBugPanic>() {\n-                (*DEFAULT_HOOK)(info);\n-\n-                // Separate the output with an empty line\n-                eprintln!();\n-            }\n-\n-            // Print the ICE message\n-            report_ice(info, BUG_REPORT_URL);\n-        }));\n-        hook\n-    });\n-\n-/// Prints the ICE message, including query stack, but without backtrace.\n-///\n-/// The message will point the user at `bug_report_url` to report the ICE.\n-///\n-/// When `install_ice_hook` is called, this function will be called as the panic\n-/// hook.\n-pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n-    let fallback_bundle =\n-        rustc_errors::fallback_fluent_bundle(rustc_errors::DEFAULT_LOCALE_RESOURCES, false);\n-    let emitter = Box::new(rustc_errors::emitter::EmitterWriter::stderr(\n-        rustc_errors::ColorConfig::Auto,\n-        None,\n-        None,\n-        fallback_bundle,\n-        false,\n-        false,\n-        None,\n-        false,\n-        false,\n-    ));\n-    let handler = rustc_errors::Handler::with_emitter(true, None, emitter);\n-\n-    // a .span_bug or .bug call has already printed what\n-    // it wants to print.\n-    if !info.payload().is::<rustc_errors::ExplicitBug>()\n-        && !info.payload().is::<rustc_errors::DelayedBugPanic>()\n-    {\n-        let mut d = rustc_errors::Diagnostic::new(rustc_errors::Level::Bug, \"unexpected panic\");\n-        handler.emit_diagnostic(&mut d);\n-    }\n-\n-    handler.emit_note(session_diagnostics::Ice);\n-    handler.emit_note(session_diagnostics::IceBugReport { bug_report_url });\n-    handler.emit_note(session_diagnostics::IceVersion {\n-        version: util::version_str!().unwrap_or(\"unknown_version\"),\n-        triple: config::host_triple(),\n-    });\n-\n-    if let Some((flags, excluded_cargo_defaults)) = extra_compiler_flags() {\n-        handler.emit_note(session_diagnostics::IceFlags { flags: flags.join(\" \") });\n-        if excluded_cargo_defaults {\n-            handler.emit_note(session_diagnostics::IceExcludeCargoDefaults);\n-        }\n-    }\n-\n-    // If backtraces are enabled, also print the query stack\n-    let backtrace = env::var_os(\"RUST_BACKTRACE\").map_or(false, |x| &x != \"0\");\n-\n-    let num_frames = if backtrace { None } else { Some(2) };\n-\n-    interface::try_print_query_stack(&handler, num_frames);\n-\n-    #[cfg(windows)]\n-    unsafe {\n-        if env::var(\"RUSTC_BREAK_ON_ICE\").is_ok() {\n-            // Trigger a debugger if we crashed during bootstrap\n-            winapi::um::debugapi::DebugBreak();\n-        }\n-    }\n-}\n-\n-/// Installs a panic hook that will print the ICE message on unexpected panics.\n-///\n-/// A custom rustc driver can skip calling this to set up a custom ICE hook.\n-pub fn install_ice_hook() {\n-    // If the user has not explicitly overridden \"RUST_BACKTRACE\", then produce\n-    // full backtraces. When a compiler ICE happens, we want to gather\n-    // as much information as possible to present in the issue opened\n-    // by the user. Compiler developers and other rustc users can\n-    // opt in to less-verbose backtraces by manually setting \"RUST_BACKTRACE\"\n-    // (e.g. `RUST_BACKTRACE=1`)\n-    if std::env::var(\"RUST_BACKTRACE\").is_err() {\n-        std::env::set_var(\"RUST_BACKTRACE\", \"full\");\n-    }\n-    LazyLock::force(&DEFAULT_HOOK);\n-}\n-\n-/// This allows tools to enable rust logging without having to magically match rustc's\n-/// tracing crate version.\n-pub fn init_rustc_env_logger() {\n-    init_rustc_env_logger_with_backtrace_option(&None);\n-}\n-\n-/// This allows tools to enable rust logging without having to magically match rustc's\n-/// tracing crate version. In contrast to `init_rustc_env_logger` it allows you to\n-/// choose a target module you wish to show backtraces along with its logging.\n-pub fn init_rustc_env_logger_with_backtrace_option(backtrace_target: &Option<String>) {\n-    if let Err(error) = rustc_log::init_rustc_env_logger_with_backtrace_option(backtrace_target) {\n-        early_error(ErrorOutputType::default(), &error.to_string());\n-    }\n-}\n-\n-/// This allows tools to enable rust logging without having to magically match rustc's\n-/// tracing crate version. In contrast to `init_rustc_env_logger` it allows you to choose an env var\n-/// other than `RUSTC_LOG`.\n-pub fn init_env_logger(env: &str) {\n-    if let Err(error) = rustc_log::init_env_logger(env) {\n-        early_error(ErrorOutputType::default(), &error.to_string());\n-    }\n-}\n-\n-#[cfg(all(unix, any(target_env = \"gnu\", target_os = \"macos\")))]\n-mod signal_handler {\n-    extern \"C\" {\n-        fn backtrace_symbols_fd(\n-            buffer: *const *mut libc::c_void,\n-            size: libc::c_int,\n-            fd: libc::c_int,\n-        );\n-    }\n-\n-    extern \"C\" fn print_stack_trace(_: libc::c_int) {\n-        const MAX_FRAMES: usize = 256;\n-        static mut STACK_TRACE: [*mut libc::c_void; MAX_FRAMES] =\n-            [std::ptr::null_mut(); MAX_FRAMES];\n-        unsafe {\n-            let depth = libc::backtrace(STACK_TRACE.as_mut_ptr(), MAX_FRAMES as i32);\n-            if depth == 0 {\n-                return;\n-            }\n-            backtrace_symbols_fd(STACK_TRACE.as_ptr(), depth, 2);\n-        }\n-    }\n-\n-    /// When an error signal (such as SIGABRT or SIGSEGV) is delivered to the\n-    /// process, print a stack trace and then exit.\n-    pub(super) fn install() {\n-        unsafe {\n-            const ALT_STACK_SIZE: usize = libc::MINSIGSTKSZ + 64 * 1024;\n-            let mut alt_stack: libc::stack_t = std::mem::zeroed();\n-            alt_stack.ss_sp =\n-                std::alloc::alloc(std::alloc::Layout::from_size_align(ALT_STACK_SIZE, 1).unwrap())\n-                    as *mut libc::c_void;\n-            alt_stack.ss_size = ALT_STACK_SIZE;\n-            libc::sigaltstack(&alt_stack, std::ptr::null_mut());\n-\n-            let mut sa: libc::sigaction = std::mem::zeroed();\n-            sa.sa_sigaction = print_stack_trace as libc::sighandler_t;\n-            sa.sa_flags = libc::SA_NODEFER | libc::SA_RESETHAND | libc::SA_ONSTACK;\n-            libc::sigemptyset(&mut sa.sa_mask);\n-            libc::sigaction(libc::SIGSEGV, &sa, std::ptr::null_mut());\n-        }\n-    }\n-}\n-\n-#[cfg(not(all(unix, any(target_env = \"gnu\", target_os = \"macos\"))))]\n-mod signal_handler {\n-    pub(super) fn install() {}\n-}\n-\n-pub fn main() -> ! {\n-    let start_time = Instant::now();\n-    let start_rss = get_resident_set_size();\n-    signal_handler::install();\n-    let mut callbacks = TimePassesCallbacks::default();\n-    install_ice_hook();\n-    let exit_code = catch_with_exit_code(|| {\n-        let args = env::args_os()\n-            .enumerate()\n-            .map(|(i, arg)| {\n-                arg.into_string().unwrap_or_else(|arg| {\n-                    early_error(\n-                        ErrorOutputType::default(),\n-                        &format!(\"argument {i} is not valid Unicode: {arg:?}\"),\n-                    )\n-                })\n-            })\n-            .collect::<Vec<_>>();\n-        RunCompiler::new(&args, &mut callbacks).run()\n-    });\n-\n-    if callbacks.time_passes {\n-        let end_rss = get_resident_set_size();\n-        print_time_passes_entry(\"total\", start_time.elapsed(), start_rss, end_rss);\n-    }\n-\n-    process::exit(exit_code)\n-}\n+pub use rustc_driver_impl::*;"}, {"sha": "af85b12c52b20dc35362d84a6fb873f468a2947c", "filename": "compiler/rustc_driver_impl/Cargo.toml", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_driver_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_driver_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2FCargo.toml?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -0,0 +1,44 @@\n+[package]\n+name = \"rustc_driver_impl\"\n+version = \"0.0.0\"\n+edition = \"2021\"\n+\n+[lib]\n+\n+[dependencies]\n+tracing = { version = \"0.1.35\" }\n+serde_json = \"1.0.59\"\n+rustc_log = { path = \"../rustc_log\" }\n+rustc_middle = { path = \"../rustc_middle\" }\n+rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n+rustc_target = { path = \"../rustc_target\" }\n+rustc_lint = { path = \"../rustc_lint\" }\n+rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_errors = { path = \"../rustc_errors\" }\n+rustc_feature = { path = \"../rustc_feature\" }\n+rustc_hir = { path = \"../rustc_hir\" }\n+rustc_hir_pretty = { path = \"../rustc_hir_pretty\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n+rustc_metadata = { path = \"../rustc_metadata\" }\n+rustc_parse = { path = \"../rustc_parse\" }\n+rustc_plugin_impl = { path = \"../rustc_plugin_impl\" }\n+rustc_save_analysis = { path = \"../rustc_save_analysis\" }\n+rustc_codegen_ssa = { path = \"../rustc_codegen_ssa\" }\n+rustc_session = { path = \"../rustc_session\" }\n+rustc_error_codes = { path = \"../rustc_error_codes\" }\n+rustc_interface = { path = \"../rustc_interface\" }\n+rustc_ast = { path = \"../rustc_ast\" }\n+rustc_span = { path = \"../rustc_span\" }\n+rustc_hir_analysis = { path = \"../rustc_hir_analysis\" }\n+\n+[target.'cfg(unix)'.dependencies]\n+libc = \"0.2\"\n+\n+[target.'cfg(windows)'.dependencies]\n+winapi = { version = \"0.3\", features = [\"consoleapi\", \"debugapi\", \"processenv\"] }\n+\n+[features]\n+llvm = ['rustc_interface/llvm']\n+max_level_info = ['rustc_log/max_level_info']\n+rustc_use_parallel_compiler = ['rustc_data_structures/rustc_use_parallel_compiler', 'rustc_interface/rustc_use_parallel_compiler',\n+    'rustc_middle/rustc_use_parallel_compiler']"}, {"sha": "6d7fba36fb3d071f182ab20a105e485a0f2efc47", "filename": "compiler/rustc_driver_impl/README.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_driver_impl%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_driver_impl%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2FREADME.md?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "previous_filename": "compiler/rustc_driver/README.md"}, {"sha": "42c97cc6a9d7418be734945a66ed3009a5004337", "filename": "compiler/rustc_driver_impl/src/args.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_driver_impl%2Fsrc%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_driver_impl%2Fsrc%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Fargs.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "previous_filename": "compiler/rustc_driver/src/args.rs"}, {"sha": "02e0b042ad2631eadad94771b4a2dfab2c2defd4", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "added", "additions": 1353, "deletions": 0, "changes": 1353, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -0,0 +1,1353 @@\n+//! The Rust compiler.\n+//!\n+//! # Note\n+//!\n+//! This API is completely unstable and subject to change.\n+\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(is_terminal)]\n+#![feature(once_cell)]\n+#![feature(decl_macro)]\n+#![recursion_limit = \"256\"]\n+#![allow(rustc::potential_query_instability)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n+\n+#[macro_use]\n+extern crate tracing;\n+\n+pub extern crate rustc_plugin_impl as plugin;\n+\n+use rustc_ast as ast;\n+use rustc_codegen_ssa::{traits::CodegenBackend, CodegenErrors, CodegenResults};\n+use rustc_data_structures::profiling::{get_resident_set_size, print_time_passes_entry};\n+use rustc_data_structures::sync::SeqCst;\n+use rustc_errors::registry::{InvalidErrorCode, Registry};\n+use rustc_errors::{ErrorGuaranteed, PResult};\n+use rustc_feature::find_gated_cfg;\n+use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_interface::util::{self, collect_crate_types, get_codegen_backend};\n+use rustc_interface::{interface, Queries};\n+use rustc_lint::LintStore;\n+use rustc_metadata::locator;\n+use rustc_save_analysis as save;\n+use rustc_save_analysis::DumpHandler;\n+use rustc_session::config::{nightly_options, CG_OPTIONS, Z_OPTIONS};\n+use rustc_session::config::{ErrorOutputType, Input, OutputType, PrintRequest, TrimmedDefPaths};\n+use rustc_session::cstore::MetadataLoader;\n+use rustc_session::getopts;\n+use rustc_session::lint::{Lint, LintId};\n+use rustc_session::{config, Session};\n+use rustc_session::{early_error, early_error_no_abort, early_warn};\n+use rustc_span::source_map::{FileLoader, FileName};\n+use rustc_span::symbol::sym;\n+use rustc_target::json::ToJson;\n+\n+use std::cmp::max;\n+use std::env;\n+use std::ffi::OsString;\n+use std::fs;\n+use std::io::{self, IsTerminal, Read, Write};\n+use std::panic::{self, catch_unwind};\n+use std::path::PathBuf;\n+use std::process::{self, Command, Stdio};\n+use std::str;\n+use std::sync::LazyLock;\n+use std::time::Instant;\n+\n+pub mod args;\n+pub mod pretty;\n+mod session_diagnostics;\n+\n+use crate::session_diagnostics::{\n+    RLinkEmptyVersionNumber, RLinkEncodingVersionMismatch, RLinkRustcVersionMismatch,\n+    RLinkWrongFileType, RlinkNotAFile, RlinkUnableToRead,\n+};\n+\n+/// Exit status code used for successful compilation and help output.\n+pub const EXIT_SUCCESS: i32 = 0;\n+\n+/// Exit status code used for compilation failures and invalid flags.\n+pub const EXIT_FAILURE: i32 = 1;\n+\n+const BUG_REPORT_URL: &str = \"https://github.com/rust-lang/rust/issues/new\\\n+    ?labels=C-bug%2C+I-ICE%2C+T-compiler&template=ice.md\";\n+\n+const ICE_REPORT_COMPILER_FLAGS: &[&str] = &[\"-Z\", \"-C\", \"--crate-type\"];\n+\n+const ICE_REPORT_COMPILER_FLAGS_EXCLUDE: &[&str] = &[\"metadata\", \"extra-filename\"];\n+\n+const ICE_REPORT_COMPILER_FLAGS_STRIP_VALUE: &[&str] = &[\"incremental\"];\n+\n+pub fn abort_on_err<T>(result: Result<T, ErrorGuaranteed>, sess: &Session) -> T {\n+    match result {\n+        Err(..) => {\n+            sess.abort_if_errors();\n+            panic!(\"error reported but abort_if_errors didn't abort???\");\n+        }\n+        Ok(x) => x,\n+    }\n+}\n+\n+pub trait Callbacks {\n+    /// Called before creating the compiler instance\n+    fn config(&mut self, _config: &mut interface::Config) {}\n+    /// Called after parsing. Return value instructs the compiler whether to\n+    /// continue the compilation afterwards (defaults to `Compilation::Continue`)\n+    fn after_parsing<'tcx>(\n+        &mut self,\n+        _compiler: &interface::Compiler,\n+        _queries: &'tcx Queries<'tcx>,\n+    ) -> Compilation {\n+        Compilation::Continue\n+    }\n+    /// Called after expansion. Return value instructs the compiler whether to\n+    /// continue the compilation afterwards (defaults to `Compilation::Continue`)\n+    fn after_expansion<'tcx>(\n+        &mut self,\n+        _compiler: &interface::Compiler,\n+        _queries: &'tcx Queries<'tcx>,\n+    ) -> Compilation {\n+        Compilation::Continue\n+    }\n+    /// Called after analysis. Return value instructs the compiler whether to\n+    /// continue the compilation afterwards (defaults to `Compilation::Continue`)\n+    fn after_analysis<'tcx>(\n+        &mut self,\n+        _compiler: &interface::Compiler,\n+        _queries: &'tcx Queries<'tcx>,\n+    ) -> Compilation {\n+        Compilation::Continue\n+    }\n+}\n+\n+#[derive(Default)]\n+pub struct TimePassesCallbacks {\n+    time_passes: bool,\n+}\n+\n+impl Callbacks for TimePassesCallbacks {\n+    // JUSTIFICATION: the session doesn't exist at this point.\n+    #[allow(rustc::bad_opt_access)]\n+    fn config(&mut self, config: &mut interface::Config) {\n+        // If a --print=... option has been given, we don't print the \"total\"\n+        // time because it will mess up the --print output. See #64339.\n+        //\n+        self.time_passes = config.opts.prints.is_empty() && config.opts.unstable_opts.time_passes;\n+        config.opts.trimmed_def_paths = TrimmedDefPaths::GoodPath;\n+    }\n+}\n+\n+pub fn diagnostics_registry() -> Registry {\n+    Registry::new(rustc_error_codes::DIAGNOSTICS)\n+}\n+\n+/// This is the primary entry point for rustc.\n+pub struct RunCompiler<'a, 'b> {\n+    at_args: &'a [String],\n+    callbacks: &'b mut (dyn Callbacks + Send),\n+    file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n+    make_codegen_backend:\n+        Option<Box<dyn FnOnce(&config::Options) -> Box<dyn CodegenBackend> + Send>>,\n+}\n+\n+impl<'a, 'b> RunCompiler<'a, 'b> {\n+    pub fn new(at_args: &'a [String], callbacks: &'b mut (dyn Callbacks + Send)) -> Self {\n+        Self { at_args, callbacks, file_loader: None, make_codegen_backend: None }\n+    }\n+\n+    /// Set a custom codegen backend.\n+    ///\n+    /// Has no uses within this repository, but is used by bjorn3 for \"the\n+    /// hotswapping branch of cg_clif\" for \"setting the codegen backend from a\n+    /// custom driver where the custom codegen backend has arbitrary data.\"\n+    /// (See #102759.)\n+    pub fn set_make_codegen_backend(\n+        &mut self,\n+        make_codegen_backend: Option<\n+            Box<dyn FnOnce(&config::Options) -> Box<dyn CodegenBackend> + Send>,\n+        >,\n+    ) -> &mut Self {\n+        self.make_codegen_backend = make_codegen_backend;\n+        self\n+    }\n+\n+    /// Load files from sources other than the file system.\n+    ///\n+    /// Has no uses within this repository, but may be used in the future by\n+    /// bjorn3 for \"hooking rust-analyzer's VFS into rustc at some point for\n+    /// running rustc without having to save\". (See #102759.)\n+    pub fn set_file_loader(\n+        &mut self,\n+        file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n+    ) -> &mut Self {\n+        self.file_loader = file_loader;\n+        self\n+    }\n+\n+    /// Parse args and run the compiler.\n+    pub fn run(self) -> interface::Result<()> {\n+        run_compiler(self.at_args, self.callbacks, self.file_loader, self.make_codegen_backend)\n+    }\n+}\n+\n+fn run_compiler(\n+    at_args: &[String],\n+    callbacks: &mut (dyn Callbacks + Send),\n+    file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n+    make_codegen_backend: Option<\n+        Box<dyn FnOnce(&config::Options) -> Box<dyn CodegenBackend> + Send>,\n+    >,\n+) -> interface::Result<()> {\n+    let args = args::arg_expand_all(at_args);\n+\n+    let Some(matches) = handle_options(&args) else { return Ok(()) };\n+\n+    let sopts = config::build_session_options(&matches);\n+\n+    if let Some(ref code) = matches.opt_str(\"explain\") {\n+        handle_explain(diagnostics_registry(), code, sopts.error_format);\n+        return Ok(());\n+    }\n+\n+    let cfg = interface::parse_cfgspecs(matches.opt_strs(\"cfg\"));\n+    let check_cfg = interface::parse_check_cfg(matches.opt_strs(\"check-cfg\"));\n+    let (odir, ofile) = make_output(&matches);\n+    let mut config = interface::Config {\n+        opts: sopts,\n+        crate_cfg: cfg,\n+        crate_check_cfg: check_cfg,\n+        input: Input::File(PathBuf::new()),\n+        output_file: ofile,\n+        output_dir: odir,\n+        file_loader,\n+        lint_caps: Default::default(),\n+        parse_sess_created: None,\n+        register_lints: None,\n+        override_queries: None,\n+        make_codegen_backend,\n+        registry: diagnostics_registry(),\n+    };\n+\n+    if !tracing::dispatcher::has_been_set() {\n+        init_rustc_env_logger_with_backtrace_option(&config.opts.unstable_opts.log_backtrace);\n+    }\n+\n+    match make_input(config.opts.error_format, &matches.free) {\n+        Err(reported) => return Err(reported),\n+        Ok(Some(input)) => {\n+            config.input = input;\n+\n+            callbacks.config(&mut config);\n+        }\n+        Ok(None) => match matches.free.len() {\n+            0 => {\n+                callbacks.config(&mut config);\n+                interface::run_compiler(config, |compiler| {\n+                    let sopts = &compiler.session().opts;\n+                    if sopts.describe_lints {\n+                        let mut lint_store =\n+                            rustc_lint::new_lint_store(compiler.session().enable_internal_lints());\n+                        let registered_lints =\n+                            if let Some(register_lints) = compiler.register_lints() {\n+                                register_lints(compiler.session(), &mut lint_store);\n+                                true\n+                            } else {\n+                                false\n+                            };\n+                        describe_lints(compiler.session(), &lint_store, registered_lints);\n+                        return;\n+                    }\n+                    let should_stop =\n+                        print_crate_info(&***compiler.codegen_backend(), compiler.session(), false);\n+\n+                    if should_stop == Compilation::Stop {\n+                        return;\n+                    }\n+                    early_error(sopts.error_format, \"no input filename given\")\n+                });\n+                return Ok(());\n+            }\n+            1 => panic!(\"make_input should have provided valid inputs\"),\n+            _ => early_error(\n+                config.opts.error_format,\n+                &format!(\n+                    \"multiple input filenames provided (first two filenames are `{}` and `{}`)\",\n+                    matches.free[0], matches.free[1],\n+                ),\n+            ),\n+        },\n+    };\n+\n+    interface::run_compiler(config, |compiler| {\n+        let sess = compiler.session();\n+        let should_stop = print_crate_info(&***compiler.codegen_backend(), sess, true)\n+            .and_then(|| list_metadata(sess, &*compiler.codegen_backend().metadata_loader()))\n+            .and_then(|| try_process_rlink(sess, compiler));\n+\n+        if should_stop == Compilation::Stop {\n+            return sess.compile_status();\n+        }\n+\n+        let linker = compiler.enter(|queries| {\n+            let early_exit = || sess.compile_status().map(|_| None);\n+            queries.parse()?;\n+\n+            if let Some(ppm) = &sess.opts.pretty {\n+                if ppm.needs_ast_map() {\n+                    queries.global_ctxt()?.enter(|tcx| {\n+                        pretty::print_after_hir_lowering(tcx, *ppm);\n+                        Ok(())\n+                    })?;\n+                } else {\n+                    let krate = queries.parse()?.steal();\n+                    pretty::print_after_parsing(sess, &krate, *ppm);\n+                }\n+                trace!(\"finished pretty-printing\");\n+                return early_exit();\n+            }\n+\n+            if callbacks.after_parsing(compiler, queries) == Compilation::Stop {\n+                return early_exit();\n+            }\n+\n+            if sess.opts.unstable_opts.parse_only || sess.opts.unstable_opts.show_span.is_some() {\n+                return early_exit();\n+            }\n+\n+            {\n+                let plugins = queries.register_plugins()?;\n+                let (_, lint_store) = &*plugins.borrow();\n+\n+                // Lint plugins are registered; now we can process command line flags.\n+                if sess.opts.describe_lints {\n+                    describe_lints(sess, lint_store, true);\n+                    return early_exit();\n+                }\n+            }\n+\n+            let mut gctxt = queries.global_ctxt()?;\n+            if callbacks.after_expansion(compiler, queries) == Compilation::Stop {\n+                return early_exit();\n+            }\n+\n+            // Make sure the `output_filenames` query is run for its side\n+            // effects of writing the dep-info and reporting errors.\n+            gctxt.enter(|tcx| tcx.output_filenames(()));\n+\n+            if sess.opts.output_types.contains_key(&OutputType::DepInfo)\n+                && sess.opts.output_types.len() == 1\n+            {\n+                return early_exit();\n+            }\n+\n+            if sess.opts.unstable_opts.no_analysis {\n+                return early_exit();\n+            }\n+\n+            gctxt.enter(|tcx| {\n+                let result = tcx.analysis(());\n+                if sess.opts.unstable_opts.save_analysis {\n+                    let crate_name = tcx.crate_name(LOCAL_CRATE);\n+                    sess.time(\"save_analysis\", || {\n+                        save::process_crate(\n+                            tcx,\n+                            crate_name,\n+                            &sess.io.input,\n+                            None,\n+                            DumpHandler::new(sess.io.output_dir.as_deref(), crate_name),\n+                        )\n+                    });\n+                }\n+                result\n+            })?;\n+\n+            drop(gctxt);\n+\n+            if callbacks.after_analysis(compiler, queries) == Compilation::Stop {\n+                return early_exit();\n+            }\n+\n+            queries.ongoing_codegen()?;\n+\n+            if sess.opts.unstable_opts.print_type_sizes {\n+                sess.code_stats.print_type_sizes();\n+            }\n+\n+            let linker = queries.linker()?;\n+            Ok(Some(linker))\n+        })?;\n+\n+        if let Some(linker) = linker {\n+            let _timer = sess.timer(\"link\");\n+            linker.link()?\n+        }\n+\n+        if sess.opts.unstable_opts.perf_stats {\n+            sess.print_perf_stats();\n+        }\n+\n+        if sess.opts.unstable_opts.print_fuel.is_some() {\n+            eprintln!(\n+                \"Fuel used by {}: {}\",\n+                sess.opts.unstable_opts.print_fuel.as_ref().unwrap(),\n+                sess.print_fuel.load(SeqCst)\n+            );\n+        }\n+\n+        Ok(())\n+    })\n+}\n+\n+// Extract output directory and file from matches.\n+fn make_output(matches: &getopts::Matches) -> (Option<PathBuf>, Option<PathBuf>) {\n+    let odir = matches.opt_str(\"out-dir\").map(|o| PathBuf::from(&o));\n+    let ofile = matches.opt_str(\"o\").map(|o| PathBuf::from(&o));\n+    (odir, ofile)\n+}\n+\n+// Extract input (string or file and optional path) from matches.\n+fn make_input(\n+    error_format: ErrorOutputType,\n+    free_matches: &[String],\n+) -> Result<Option<Input>, ErrorGuaranteed> {\n+    if free_matches.len() == 1 {\n+        let ifile = &free_matches[0];\n+        if ifile == \"-\" {\n+            let mut src = String::new();\n+            if io::stdin().read_to_string(&mut src).is_err() {\n+                // Immediately stop compilation if there was an issue reading\n+                // the input (for example if the input stream is not UTF-8).\n+                let reported = early_error_no_abort(\n+                    error_format,\n+                    \"couldn't read from stdin, as it did not contain valid UTF-8\",\n+                );\n+                return Err(reported);\n+            }\n+            if let Ok(path) = env::var(\"UNSTABLE_RUSTDOC_TEST_PATH\") {\n+                let line = env::var(\"UNSTABLE_RUSTDOC_TEST_LINE\").expect(\n+                    \"when UNSTABLE_RUSTDOC_TEST_PATH is set \\\n+                                    UNSTABLE_RUSTDOC_TEST_LINE also needs to be set\",\n+                );\n+                let line = isize::from_str_radix(&line, 10)\n+                    .expect(\"UNSTABLE_RUSTDOC_TEST_LINE needs to be an number\");\n+                let file_name = FileName::doc_test_source_code(PathBuf::from(path), line);\n+                Ok(Some(Input::Str { name: file_name, input: src }))\n+            } else {\n+                Ok(Some(Input::Str { name: FileName::anon_source_code(&src), input: src }))\n+            }\n+        } else {\n+            Ok(Some(Input::File(PathBuf::from(ifile))))\n+        }\n+    } else {\n+        Ok(None)\n+    }\n+}\n+\n+/// Whether to stop or continue compilation.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+pub enum Compilation {\n+    Stop,\n+    Continue,\n+}\n+\n+impl Compilation {\n+    pub fn and_then<F: FnOnce() -> Compilation>(self, next: F) -> Compilation {\n+        match self {\n+            Compilation::Stop => Compilation::Stop,\n+            Compilation::Continue => next(),\n+        }\n+    }\n+}\n+\n+fn handle_explain(registry: Registry, code: &str, output: ErrorOutputType) {\n+    let upper_cased_code = code.to_ascii_uppercase();\n+    let normalised =\n+        if upper_cased_code.starts_with('E') { upper_cased_code } else { format!(\"E{code:0>4}\") };\n+    match registry.try_find_description(&normalised) {\n+        Ok(Some(description)) => {\n+            let mut is_in_code_block = false;\n+            let mut text = String::new();\n+            // Slice off the leading newline and print.\n+            for line in description.lines() {\n+                let indent_level =\n+                    line.find(|c: char| !c.is_whitespace()).unwrap_or_else(|| line.len());\n+                let dedented_line = &line[indent_level..];\n+                if dedented_line.starts_with(\"```\") {\n+                    is_in_code_block = !is_in_code_block;\n+                    text.push_str(&line[..(indent_level + 3)]);\n+                } else if is_in_code_block && dedented_line.starts_with(\"# \") {\n+                    continue;\n+                } else {\n+                    text.push_str(line);\n+                }\n+                text.push('\\n');\n+            }\n+            if io::stdout().is_terminal() {\n+                show_content_with_pager(&text);\n+            } else {\n+                print!(\"{text}\");\n+            }\n+        }\n+        Ok(None) => {\n+            early_error(output, &format!(\"no extended information for {code}\"));\n+        }\n+        Err(InvalidErrorCode) => {\n+            early_error(output, &format!(\"{code} is not a valid error code\"));\n+        }\n+    }\n+}\n+\n+fn show_content_with_pager(content: &str) {\n+    let pager_name = env::var_os(\"PAGER\").unwrap_or_else(|| {\n+        if cfg!(windows) { OsString::from(\"more.com\") } else { OsString::from(\"less\") }\n+    });\n+\n+    let mut fallback_to_println = false;\n+\n+    match Command::new(pager_name).stdin(Stdio::piped()).spawn() {\n+        Ok(mut pager) => {\n+            if let Some(pipe) = pager.stdin.as_mut() {\n+                if pipe.write_all(content.as_bytes()).is_err() {\n+                    fallback_to_println = true;\n+                }\n+            }\n+\n+            if pager.wait().is_err() {\n+                fallback_to_println = true;\n+            }\n+        }\n+        Err(_) => {\n+            fallback_to_println = true;\n+        }\n+    }\n+\n+    // If pager fails for whatever reason, we should still print the content\n+    // to standard output\n+    if fallback_to_println {\n+        print!(\"{content}\");\n+    }\n+}\n+\n+pub fn try_process_rlink(sess: &Session, compiler: &interface::Compiler) -> Compilation {\n+    if sess.opts.unstable_opts.link_only {\n+        if let Input::File(file) = &sess.io.input {\n+            // FIXME: #![crate_type] and #![crate_name] support not implemented yet\n+            sess.init_crate_types(collect_crate_types(sess, &[]));\n+            let outputs = compiler.build_output_filenames(sess, &[]);\n+            let rlink_data = fs::read(file).unwrap_or_else(|err| {\n+                sess.emit_fatal(RlinkUnableToRead { err });\n+            });\n+            let codegen_results = match CodegenResults::deserialize_rlink(rlink_data) {\n+                Ok(codegen) => codegen,\n+                Err(err) => {\n+                    match err {\n+                        CodegenErrors::WrongFileType => sess.emit_fatal(RLinkWrongFileType),\n+                        CodegenErrors::EmptyVersionNumber => {\n+                            sess.emit_fatal(RLinkEmptyVersionNumber)\n+                        }\n+                        CodegenErrors::EncodingVersionMismatch { version_array, rlink_version } => {\n+                            sess.emit_fatal(RLinkEncodingVersionMismatch {\n+                                version_array,\n+                                rlink_version,\n+                            })\n+                        }\n+                        CodegenErrors::RustcVersionMismatch { rustc_version, current_version } => {\n+                            sess.emit_fatal(RLinkRustcVersionMismatch {\n+                                rustc_version,\n+                                current_version,\n+                            })\n+                        }\n+                    };\n+                }\n+            };\n+            let result = compiler.codegen_backend().link(sess, codegen_results, &outputs);\n+            abort_on_err(result, sess);\n+        } else {\n+            sess.emit_fatal(RlinkNotAFile {})\n+        }\n+        Compilation::Stop\n+    } else {\n+        Compilation::Continue\n+    }\n+}\n+\n+pub fn list_metadata(sess: &Session, metadata_loader: &dyn MetadataLoader) -> Compilation {\n+    if sess.opts.unstable_opts.ls {\n+        match sess.io.input {\n+            Input::File(ref ifile) => {\n+                let path = &(*ifile);\n+                let mut v = Vec::new();\n+                locator::list_file_metadata(&sess.target, path, metadata_loader, &mut v).unwrap();\n+                println!(\"{}\", String::from_utf8(v).unwrap());\n+            }\n+            Input::Str { .. } => {\n+                early_error(ErrorOutputType::default(), \"cannot list metadata for stdin\");\n+            }\n+        }\n+        return Compilation::Stop;\n+    }\n+\n+    Compilation::Continue\n+}\n+\n+fn print_crate_info(\n+    codegen_backend: &dyn CodegenBackend,\n+    sess: &Session,\n+    parse_attrs: bool,\n+) -> Compilation {\n+    use rustc_session::config::PrintRequest::*;\n+    // NativeStaticLibs and LinkArgs are special - printed during linking\n+    // (empty iterator returns true)\n+    if sess.opts.prints.iter().all(|&p| p == NativeStaticLibs || p == LinkArgs) {\n+        return Compilation::Continue;\n+    }\n+\n+    let attrs = if parse_attrs {\n+        let result = parse_crate_attrs(sess);\n+        match result {\n+            Ok(attrs) => Some(attrs),\n+            Err(mut parse_error) => {\n+                parse_error.emit();\n+                return Compilation::Stop;\n+            }\n+        }\n+    } else {\n+        None\n+    };\n+    for req in &sess.opts.prints {\n+        match *req {\n+            TargetList => {\n+                let mut targets = rustc_target::spec::TARGETS.to_vec();\n+                targets.sort_unstable();\n+                println!(\"{}\", targets.join(\"\\n\"));\n+            }\n+            Sysroot => println!(\"{}\", sess.sysroot.display()),\n+            TargetLibdir => println!(\"{}\", sess.target_tlib_path.dir.display()),\n+            TargetSpec => {\n+                println!(\"{}\", serde_json::to_string_pretty(&sess.target.to_json()).unwrap());\n+            }\n+            FileNames | CrateName => {\n+                let attrs = attrs.as_ref().unwrap();\n+                let t_outputs = rustc_interface::util::build_output_filenames(attrs, sess);\n+                let id = rustc_session::output::find_crate_name(sess, attrs);\n+                if *req == PrintRequest::CrateName {\n+                    println!(\"{id}\");\n+                    continue;\n+                }\n+                let crate_types = collect_crate_types(sess, attrs);\n+                for &style in &crate_types {\n+                    let fname =\n+                        rustc_session::output::filename_for_input(sess, style, id, &t_outputs);\n+                    println!(\"{}\", fname.file_name().unwrap().to_string_lossy());\n+                }\n+            }\n+            Cfg => {\n+                let mut cfgs = sess\n+                    .parse_sess\n+                    .config\n+                    .iter()\n+                    .filter_map(|&(name, value)| {\n+                        // Note that crt-static is a specially recognized cfg\n+                        // directive that's printed out here as part of\n+                        // rust-lang/rust#37406, but in general the\n+                        // `target_feature` cfg is gated under\n+                        // rust-lang/rust#29717. For now this is just\n+                        // specifically allowing the crt-static cfg and that's\n+                        // it, this is intended to get into Cargo and then go\n+                        // through to build scripts.\n+                        if (name != sym::target_feature || value != Some(sym::crt_dash_static))\n+                            && !sess.is_nightly_build()\n+                            && find_gated_cfg(|cfg_sym| cfg_sym == name).is_some()\n+                        {\n+                            return None;\n+                        }\n+\n+                        if let Some(value) = value {\n+                            Some(format!(\"{name}=\\\"{value}\\\"\"))\n+                        } else {\n+                            Some(name.to_string())\n+                        }\n+                    })\n+                    .collect::<Vec<String>>();\n+\n+                cfgs.sort();\n+                for cfg in cfgs {\n+                    println!(\"{cfg}\");\n+                }\n+            }\n+            CallingConventions => {\n+                let mut calling_conventions = rustc_target::spec::abi::all_names();\n+                calling_conventions.sort_unstable();\n+                println!(\"{}\", calling_conventions.join(\"\\n\"));\n+            }\n+            RelocationModels\n+            | CodeModels\n+            | TlsModels\n+            | TargetCPUs\n+            | StackProtectorStrategies\n+            | TargetFeatures => {\n+                codegen_backend.print(*req, sess);\n+            }\n+            // Any output here interferes with Cargo's parsing of other printed output\n+            NativeStaticLibs => {}\n+            LinkArgs => {}\n+            SplitDebuginfo => {\n+                use rustc_target::spec::SplitDebuginfo::{Off, Packed, Unpacked};\n+\n+                for split in &[Off, Packed, Unpacked] {\n+                    let stable = sess.target.options.supported_split_debuginfo.contains(split);\n+                    let unstable_ok = sess.unstable_options();\n+                    if stable || unstable_ok {\n+                        println!(\"{split}\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    Compilation::Stop\n+}\n+\n+/// Prints version information\n+///\n+/// NOTE: this is a macro to support drivers built at a different time than the main `rustc_driver` crate.\n+pub macro version($binary: literal, $matches: expr) {\n+    fn unw(x: Option<&str>) -> &str {\n+        x.unwrap_or(\"unknown\")\n+    }\n+    $crate::version_at_macro_invocation(\n+        $binary,\n+        $matches,\n+        unw(option_env!(\"CFG_VERSION\")),\n+        unw(option_env!(\"CFG_VER_HASH\")),\n+        unw(option_env!(\"CFG_VER_DATE\")),\n+        unw(option_env!(\"CFG_RELEASE\")),\n+    )\n+}\n+\n+#[doc(hidden)] // use the macro instead\n+pub fn version_at_macro_invocation(\n+    binary: &str,\n+    matches: &getopts::Matches,\n+    version: &str,\n+    commit_hash: &str,\n+    commit_date: &str,\n+    release: &str,\n+) {\n+    let verbose = matches.opt_present(\"verbose\");\n+\n+    println!(\"{binary} {version}\");\n+\n+    if verbose {\n+        println!(\"binary: {binary}\");\n+        println!(\"commit-hash: {commit_hash}\");\n+        println!(\"commit-date: {commit_date}\");\n+        println!(\"host: {}\", config::host_triple());\n+        println!(\"release: {release}\");\n+\n+        let debug_flags = matches.opt_strs(\"Z\");\n+        let backend_name = debug_flags.iter().find_map(|x| x.strip_prefix(\"codegen-backend=\"));\n+        get_codegen_backend(&None, backend_name).print_version();\n+    }\n+}\n+\n+fn usage(verbose: bool, include_unstable_options: bool, nightly_build: bool) {\n+    let groups = if verbose { config::rustc_optgroups() } else { config::rustc_short_optgroups() };\n+    let mut options = getopts::Options::new();\n+    for option in groups.iter().filter(|x| include_unstable_options || x.is_stable()) {\n+        (option.apply)(&mut options);\n+    }\n+    let message = \"Usage: rustc [OPTIONS] INPUT\";\n+    let nightly_help = if nightly_build {\n+        \"\\n    -Z help             Print unstable compiler options\"\n+    } else {\n+        \"\"\n+    };\n+    let verbose_help = if verbose {\n+        \"\"\n+    } else {\n+        \"\\n    --help -v           Print the full set of options rustc accepts\"\n+    };\n+    let at_path = if verbose {\n+        \"    @path               Read newline separated options from `path`\\n\"\n+    } else {\n+        \"\"\n+    };\n+    println!(\n+        \"{options}{at_path}\\nAdditional help:\n+    -C help             Print codegen options\n+    -W help             \\\n+              Print 'lint' options and default settings{nightly}{verbose}\\n\",\n+        options = options.usage(message),\n+        at_path = at_path,\n+        nightly = nightly_help,\n+        verbose = verbose_help\n+    );\n+}\n+\n+fn print_wall_help() {\n+    println!(\n+        \"\n+The flag `-Wall` does not exist in `rustc`. Most useful lints are enabled by\n+default. Use `rustc -W help` to see all available lints. It's more common to put\n+warning settings in the crate root using `#![warn(LINT_NAME)]` instead of using\n+the command line flag directly.\n+\"\n+    );\n+}\n+\n+/// Write to stdout lint command options, together with a list of all available lints\n+pub fn describe_lints(sess: &Session, lint_store: &LintStore, loaded_plugins: bool) {\n+    println!(\n+        \"\n+Available lint options:\n+    -W <foo>           Warn about <foo>\n+    -A <foo>           \\\n+              Allow <foo>\n+    -D <foo>           Deny <foo>\n+    -F <foo>           Forbid <foo> \\\n+              (deny <foo> and all attempts to override)\n+\n+\"\n+    );\n+\n+    fn sort_lints(sess: &Session, mut lints: Vec<&'static Lint>) -> Vec<&'static Lint> {\n+        // The sort doesn't case-fold but it's doubtful we care.\n+        lints.sort_by_cached_key(|x: &&Lint| (x.default_level(sess.edition()), x.name));\n+        lints\n+    }\n+\n+    fn sort_lint_groups(\n+        lints: Vec<(&'static str, Vec<LintId>, bool)>,\n+    ) -> Vec<(&'static str, Vec<LintId>)> {\n+        let mut lints: Vec<_> = lints.into_iter().map(|(x, y, _)| (x, y)).collect();\n+        lints.sort_by_key(|l| l.0);\n+        lints\n+    }\n+\n+    let (plugin, builtin): (Vec<_>, _) =\n+        lint_store.get_lints().iter().cloned().partition(|&lint| lint.is_plugin);\n+    let plugin = sort_lints(sess, plugin);\n+    let builtin = sort_lints(sess, builtin);\n+\n+    let (plugin_groups, builtin_groups): (Vec<_>, _) =\n+        lint_store.get_lint_groups().partition(|&(.., p)| p);\n+    let plugin_groups = sort_lint_groups(plugin_groups);\n+    let builtin_groups = sort_lint_groups(builtin_groups);\n+\n+    let max_name_len =\n+        plugin.iter().chain(&builtin).map(|&s| s.name.chars().count()).max().unwrap_or(0);\n+    let padded = |x: &str| {\n+        let mut s = \" \".repeat(max_name_len - x.chars().count());\n+        s.push_str(x);\n+        s\n+    };\n+\n+    println!(\"Lint checks provided by rustc:\\n\");\n+\n+    let print_lints = |lints: Vec<&Lint>| {\n+        println!(\"    {}  {:7.7}  {}\", padded(\"name\"), \"default\", \"meaning\");\n+        println!(\"    {}  {:7.7}  {}\", padded(\"----\"), \"-------\", \"-------\");\n+        for lint in lints {\n+            let name = lint.name_lower().replace('_', \"-\");\n+            println!(\n+                \"    {}  {:7.7}  {}\",\n+                padded(&name),\n+                lint.default_level(sess.edition()).as_str(),\n+                lint.desc\n+            );\n+        }\n+        println!(\"\\n\");\n+    };\n+\n+    print_lints(builtin);\n+\n+    let max_name_len = max(\n+        \"warnings\".len(),\n+        plugin_groups\n+            .iter()\n+            .chain(&builtin_groups)\n+            .map(|&(s, _)| s.chars().count())\n+            .max()\n+            .unwrap_or(0),\n+    );\n+\n+    let padded = |x: &str| {\n+        let mut s = \" \".repeat(max_name_len - x.chars().count());\n+        s.push_str(x);\n+        s\n+    };\n+\n+    println!(\"Lint groups provided by rustc:\\n\");\n+\n+    let print_lint_groups = |lints: Vec<(&'static str, Vec<LintId>)>, all_warnings| {\n+        println!(\"    {}  sub-lints\", padded(\"name\"));\n+        println!(\"    {}  ---------\", padded(\"----\"));\n+\n+        if all_warnings {\n+            println!(\"    {}  all lints that are set to issue warnings\", padded(\"warnings\"));\n+        }\n+\n+        for (name, to) in lints {\n+            let name = name.to_lowercase().replace('_', \"-\");\n+            let desc = to\n+                .into_iter()\n+                .map(|x| x.to_string().replace('_', \"-\"))\n+                .collect::<Vec<String>>()\n+                .join(\", \");\n+            println!(\"    {}  {}\", padded(&name), desc);\n+        }\n+        println!(\"\\n\");\n+    };\n+\n+    print_lint_groups(builtin_groups, true);\n+\n+    match (loaded_plugins, plugin.len(), plugin_groups.len()) {\n+        (false, 0, _) | (false, _, 0) => {\n+            println!(\"Lint tools like Clippy can provide additional lints and lint groups.\");\n+        }\n+        (false, ..) => panic!(\"didn't load lint plugins but got them anyway!\"),\n+        (true, 0, 0) => println!(\"This crate does not load any lint plugins or lint groups.\"),\n+        (true, l, g) => {\n+            if l > 0 {\n+                println!(\"Lint checks provided by plugins loaded by this crate:\\n\");\n+                print_lints(plugin);\n+            }\n+            if g > 0 {\n+                println!(\"Lint groups provided by plugins loaded by this crate:\\n\");\n+                print_lint_groups(plugin_groups, false);\n+            }\n+        }\n+    }\n+}\n+\n+fn describe_debug_flags() {\n+    println!(\"\\nAvailable options:\\n\");\n+    print_flag_list(\"-Z\", config::Z_OPTIONS);\n+}\n+\n+fn describe_codegen_flags() {\n+    println!(\"\\nAvailable codegen options:\\n\");\n+    print_flag_list(\"-C\", config::CG_OPTIONS);\n+}\n+\n+pub fn print_flag_list<T>(\n+    cmdline_opt: &str,\n+    flag_list: &[(&'static str, T, &'static str, &'static str)],\n+) {\n+    let max_len = flag_list.iter().map(|&(name, _, _, _)| name.chars().count()).max().unwrap_or(0);\n+\n+    for &(name, _, _, desc) in flag_list {\n+        println!(\n+            \"    {} {:>width$}=val -- {}\",\n+            cmdline_opt,\n+            name.replace('_', \"-\"),\n+            desc,\n+            width = max_len\n+        );\n+    }\n+}\n+\n+/// Process command line options. Emits messages as appropriate. If compilation\n+/// should continue, returns a getopts::Matches object parsed from args,\n+/// otherwise returns `None`.\n+///\n+/// The compiler's handling of options is a little complicated as it ties into\n+/// our stability story. The current intention of each compiler option is to\n+/// have one of two modes:\n+///\n+/// 1. An option is stable and can be used everywhere.\n+/// 2. An option is unstable, and can only be used on nightly.\n+///\n+/// Like unstable library and language features, however, unstable options have\n+/// always required a form of \"opt in\" to indicate that you're using them. This\n+/// provides the easy ability to scan a code base to check to see if anything\n+/// unstable is being used. Currently, this \"opt in\" is the `-Z` \"zed\" flag.\n+///\n+/// All options behind `-Z` are considered unstable by default. Other top-level\n+/// options can also be considered unstable, and they were unlocked through the\n+/// `-Z unstable-options` flag. Note that `-Z` remains to be the root of\n+/// instability in both cases, though.\n+///\n+/// So with all that in mind, the comments below have some more detail about the\n+/// contortions done here to get things to work out correctly.\n+pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n+    // Throw away the first argument, the name of the binary\n+    let args = &args[1..];\n+\n+    if args.is_empty() {\n+        // user did not write `-v` nor `-Z unstable-options`, so do not\n+        // include that extra information.\n+        let nightly_build =\n+            rustc_feature::UnstableFeatures::from_environment(None).is_nightly_build();\n+        usage(false, false, nightly_build);\n+        return None;\n+    }\n+\n+    // Parse with *all* options defined in the compiler, we don't worry about\n+    // option stability here we just want to parse as much as possible.\n+    let mut options = getopts::Options::new();\n+    for option in config::rustc_optgroups() {\n+        (option.apply)(&mut options);\n+    }\n+    let matches = options.parse(args).unwrap_or_else(|e| {\n+        let msg = match e {\n+            getopts::Fail::UnrecognizedOption(ref opt) => CG_OPTIONS\n+                .iter()\n+                .map(|&(name, ..)| ('C', name))\n+                .chain(Z_OPTIONS.iter().map(|&(name, ..)| ('Z', name)))\n+                .find(|&(_, name)| *opt == name.replace('_', \"-\"))\n+                .map(|(flag, _)| format!(\"{e}. Did you mean `-{flag} {opt}`?\")),\n+            _ => None,\n+        };\n+        early_error(ErrorOutputType::default(), &msg.unwrap_or_else(|| e.to_string()));\n+    });\n+\n+    // For all options we just parsed, we check a few aspects:\n+    //\n+    // * If the option is stable, we're all good\n+    // * If the option wasn't passed, we're all good\n+    // * If `-Z unstable-options` wasn't passed (and we're not a -Z option\n+    //   ourselves), then we require the `-Z unstable-options` flag to unlock\n+    //   this option that was passed.\n+    // * If we're a nightly compiler, then unstable options are now unlocked, so\n+    //   we're good to go.\n+    // * Otherwise, if we're an unstable option then we generate an error\n+    //   (unstable option being used on stable)\n+    nightly_options::check_nightly_options(&matches, &config::rustc_optgroups());\n+\n+    if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n+        // Only show unstable options in --help if we accept unstable options.\n+        let unstable_enabled = nightly_options::is_unstable_enabled(&matches);\n+        let nightly_build = nightly_options::match_is_nightly_build(&matches);\n+        usage(matches.opt_present(\"verbose\"), unstable_enabled, nightly_build);\n+        return None;\n+    }\n+\n+    // Handle the special case of -Wall.\n+    let wall = matches.opt_strs(\"W\");\n+    if wall.iter().any(|x| *x == \"all\") {\n+        print_wall_help();\n+        rustc_errors::FatalError.raise();\n+    }\n+\n+    // Don't handle -W help here, because we might first load plugins.\n+    let debug_flags = matches.opt_strs(\"Z\");\n+    if debug_flags.iter().any(|x| *x == \"help\") {\n+        describe_debug_flags();\n+        return None;\n+    }\n+\n+    let cg_flags = matches.opt_strs(\"C\");\n+\n+    if cg_flags.iter().any(|x| *x == \"help\") {\n+        describe_codegen_flags();\n+        return None;\n+    }\n+\n+    if cg_flags.iter().any(|x| *x == \"no-stack-check\") {\n+        early_warn(\n+            ErrorOutputType::default(),\n+            \"the --no-stack-check flag is deprecated and does nothing\",\n+        );\n+    }\n+\n+    if cg_flags.iter().any(|x| *x == \"passes=list\") {\n+        let backend_name = debug_flags.iter().find_map(|x| x.strip_prefix(\"codegen-backend=\"));\n+        get_codegen_backend(&None, backend_name).print_passes();\n+        return None;\n+    }\n+\n+    if matches.opt_present(\"version\") {\n+        version!(\"rustc\", &matches);\n+        return None;\n+    }\n+\n+    Some(matches)\n+}\n+\n+fn parse_crate_attrs<'a>(sess: &'a Session) -> PResult<'a, ast::AttrVec> {\n+    match &sess.io.input {\n+        Input::File(ifile) => rustc_parse::parse_crate_attrs_from_file(ifile, &sess.parse_sess),\n+        Input::Str { name, input } => rustc_parse::parse_crate_attrs_from_source_str(\n+            name.clone(),\n+            input.clone(),\n+            &sess.parse_sess,\n+        ),\n+    }\n+}\n+\n+/// Gets a list of extra command-line flags provided by the user, as strings.\n+///\n+/// This function is used during ICEs to show more information useful for\n+/// debugging, since some ICEs only happens with non-default compiler flags\n+/// (and the users don't always report them).\n+fn extra_compiler_flags() -> Option<(Vec<String>, bool)> {\n+    let mut args = env::args_os().map(|arg| arg.to_string_lossy().to_string()).peekable();\n+\n+    let mut result = Vec::new();\n+    let mut excluded_cargo_defaults = false;\n+    while let Some(arg) = args.next() {\n+        if let Some(a) = ICE_REPORT_COMPILER_FLAGS.iter().find(|a| arg.starts_with(*a)) {\n+            let content = if arg.len() == a.len() {\n+                // A space-separated option, like `-C incremental=foo` or `--crate-type rlib`\n+                match args.next() {\n+                    Some(arg) => arg.to_string(),\n+                    None => continue,\n+                }\n+            } else if arg.get(a.len()..a.len() + 1) == Some(\"=\") {\n+                // An equals option, like `--crate-type=rlib`\n+                arg[a.len() + 1..].to_string()\n+            } else {\n+                // A non-space option, like `-Cincremental=foo`\n+                arg[a.len()..].to_string()\n+            };\n+            let option = content.split_once('=').map(|s| s.0).unwrap_or(&content);\n+            if ICE_REPORT_COMPILER_FLAGS_EXCLUDE.iter().any(|exc| option == *exc) {\n+                excluded_cargo_defaults = true;\n+            } else {\n+                result.push(a.to_string());\n+                match ICE_REPORT_COMPILER_FLAGS_STRIP_VALUE.iter().find(|s| option == **s) {\n+                    Some(s) => result.push(format!(\"{s}=[REDACTED]\")),\n+                    None => result.push(content),\n+                }\n+            }\n+        }\n+    }\n+\n+    if !result.is_empty() { Some((result, excluded_cargo_defaults)) } else { None }\n+}\n+\n+/// Runs a closure and catches unwinds triggered by fatal errors.\n+///\n+/// The compiler currently unwinds with a special sentinel value to abort\n+/// compilation on fatal errors. This function catches that sentinel and turns\n+/// the panic into a `Result` instead.\n+pub fn catch_fatal_errors<F: FnOnce() -> R, R>(f: F) -> Result<R, ErrorGuaranteed> {\n+    catch_unwind(panic::AssertUnwindSafe(f)).map_err(|value| {\n+        if value.is::<rustc_errors::FatalErrorMarker>() {\n+            ErrorGuaranteed::unchecked_claim_error_was_emitted()\n+        } else {\n+            panic::resume_unwind(value);\n+        }\n+    })\n+}\n+\n+/// Variant of `catch_fatal_errors` for the `interface::Result` return type\n+/// that also computes the exit code.\n+pub fn catch_with_exit_code(f: impl FnOnce() -> interface::Result<()>) -> i32 {\n+    let result = catch_fatal_errors(f).and_then(|result| result);\n+    match result {\n+        Ok(()) => EXIT_SUCCESS,\n+        Err(_) => EXIT_FAILURE,\n+    }\n+}\n+\n+static DEFAULT_HOOK: LazyLock<Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send + 'static>> =\n+    LazyLock::new(|| {\n+        let hook = panic::take_hook();\n+        panic::set_hook(Box::new(|info| {\n+            // If the error was caused by a broken pipe then this is not a bug.\n+            // Write the error and return immediately. See #98700.\n+            #[cfg(windows)]\n+            if let Some(msg) = info.payload().downcast_ref::<String>() {\n+                if msg.starts_with(\"failed printing to stdout: \") && msg.ends_with(\"(os error 232)\")\n+                {\n+                    early_error_no_abort(ErrorOutputType::default(), &msg);\n+                    return;\n+                }\n+            };\n+\n+            // Invoke the default handler, which prints the actual panic message and optionally a backtrace\n+            // Don't do this for delayed bugs, which already emit their own more useful backtrace.\n+            if !info.payload().is::<rustc_errors::DelayedBugPanic>() {\n+                (*DEFAULT_HOOK)(info);\n+\n+                // Separate the output with an empty line\n+                eprintln!();\n+            }\n+\n+            // Print the ICE message\n+            report_ice(info, BUG_REPORT_URL);\n+        }));\n+        hook\n+    });\n+\n+/// Prints the ICE message, including query stack, but without backtrace.\n+///\n+/// The message will point the user at `bug_report_url` to report the ICE.\n+///\n+/// When `install_ice_hook` is called, this function will be called as the panic\n+/// hook.\n+pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n+    let fallback_bundle =\n+        rustc_errors::fallback_fluent_bundle(rustc_errors::DEFAULT_LOCALE_RESOURCES, false);\n+    let emitter = Box::new(rustc_errors::emitter::EmitterWriter::stderr(\n+        rustc_errors::ColorConfig::Auto,\n+        None,\n+        None,\n+        fallback_bundle,\n+        false,\n+        false,\n+        None,\n+        false,\n+        false,\n+    ));\n+    let handler = rustc_errors::Handler::with_emitter(true, None, emitter);\n+\n+    // a .span_bug or .bug call has already printed what\n+    // it wants to print.\n+    if !info.payload().is::<rustc_errors::ExplicitBug>()\n+        && !info.payload().is::<rustc_errors::DelayedBugPanic>()\n+    {\n+        let mut d = rustc_errors::Diagnostic::new(rustc_errors::Level::Bug, \"unexpected panic\");\n+        handler.emit_diagnostic(&mut d);\n+    }\n+\n+    handler.emit_note(session_diagnostics::Ice);\n+    handler.emit_note(session_diagnostics::IceBugReport { bug_report_url });\n+    handler.emit_note(session_diagnostics::IceVersion {\n+        version: util::version_str!().unwrap_or(\"unknown_version\"),\n+        triple: config::host_triple(),\n+    });\n+\n+    if let Some((flags, excluded_cargo_defaults)) = extra_compiler_flags() {\n+        handler.emit_note(session_diagnostics::IceFlags { flags: flags.join(\" \") });\n+        if excluded_cargo_defaults {\n+            handler.emit_note(session_diagnostics::IceExcludeCargoDefaults);\n+        }\n+    }\n+\n+    // If backtraces are enabled, also print the query stack\n+    let backtrace = env::var_os(\"RUST_BACKTRACE\").map_or(false, |x| &x != \"0\");\n+\n+    let num_frames = if backtrace { None } else { Some(2) };\n+\n+    interface::try_print_query_stack(&handler, num_frames);\n+\n+    #[cfg(windows)]\n+    unsafe {\n+        if env::var(\"RUSTC_BREAK_ON_ICE\").is_ok() {\n+            // Trigger a debugger if we crashed during bootstrap\n+            winapi::um::debugapi::DebugBreak();\n+        }\n+    }\n+}\n+\n+/// Installs a panic hook that will print the ICE message on unexpected panics.\n+///\n+/// A custom rustc driver can skip calling this to set up a custom ICE hook.\n+pub fn install_ice_hook() {\n+    // If the user has not explicitly overridden \"RUST_BACKTRACE\", then produce\n+    // full backtraces. When a compiler ICE happens, we want to gather\n+    // as much information as possible to present in the issue opened\n+    // by the user. Compiler developers and other rustc users can\n+    // opt in to less-verbose backtraces by manually setting \"RUST_BACKTRACE\"\n+    // (e.g. `RUST_BACKTRACE=1`)\n+    if std::env::var(\"RUST_BACKTRACE\").is_err() {\n+        std::env::set_var(\"RUST_BACKTRACE\", \"full\");\n+    }\n+    LazyLock::force(&DEFAULT_HOOK);\n+}\n+\n+/// This allows tools to enable rust logging without having to magically match rustc's\n+/// tracing crate version.\n+pub fn init_rustc_env_logger() {\n+    init_rustc_env_logger_with_backtrace_option(&None);\n+}\n+\n+/// This allows tools to enable rust logging without having to magically match rustc's\n+/// tracing crate version. In contrast to `init_rustc_env_logger` it allows you to\n+/// choose a target module you wish to show backtraces along with its logging.\n+pub fn init_rustc_env_logger_with_backtrace_option(backtrace_target: &Option<String>) {\n+    if let Err(error) = rustc_log::init_rustc_env_logger_with_backtrace_option(backtrace_target) {\n+        early_error(ErrorOutputType::default(), &error.to_string());\n+    }\n+}\n+\n+/// This allows tools to enable rust logging without having to magically match rustc's\n+/// tracing crate version. In contrast to `init_rustc_env_logger` it allows you to choose an env var\n+/// other than `RUSTC_LOG`.\n+pub fn init_env_logger(env: &str) {\n+    if let Err(error) = rustc_log::init_env_logger(env) {\n+        early_error(ErrorOutputType::default(), &error.to_string());\n+    }\n+}\n+\n+#[cfg(all(unix, any(target_env = \"gnu\", target_os = \"macos\")))]\n+mod signal_handler {\n+    extern \"C\" {\n+        fn backtrace_symbols_fd(\n+            buffer: *const *mut libc::c_void,\n+            size: libc::c_int,\n+            fd: libc::c_int,\n+        );\n+    }\n+\n+    extern \"C\" fn print_stack_trace(_: libc::c_int) {\n+        const MAX_FRAMES: usize = 256;\n+        static mut STACK_TRACE: [*mut libc::c_void; MAX_FRAMES] =\n+            [std::ptr::null_mut(); MAX_FRAMES];\n+        unsafe {\n+            let depth = libc::backtrace(STACK_TRACE.as_mut_ptr(), MAX_FRAMES as i32);\n+            if depth == 0 {\n+                return;\n+            }\n+            backtrace_symbols_fd(STACK_TRACE.as_ptr(), depth, 2);\n+        }\n+    }\n+\n+    /// When an error signal (such as SIGABRT or SIGSEGV) is delivered to the\n+    /// process, print a stack trace and then exit.\n+    pub(super) fn install() {\n+        unsafe {\n+            const ALT_STACK_SIZE: usize = libc::MINSIGSTKSZ + 64 * 1024;\n+            let mut alt_stack: libc::stack_t = std::mem::zeroed();\n+            alt_stack.ss_sp =\n+                std::alloc::alloc(std::alloc::Layout::from_size_align(ALT_STACK_SIZE, 1).unwrap())\n+                    as *mut libc::c_void;\n+            alt_stack.ss_size = ALT_STACK_SIZE;\n+            libc::sigaltstack(&alt_stack, std::ptr::null_mut());\n+\n+            let mut sa: libc::sigaction = std::mem::zeroed();\n+            sa.sa_sigaction = print_stack_trace as libc::sighandler_t;\n+            sa.sa_flags = libc::SA_NODEFER | libc::SA_RESETHAND | libc::SA_ONSTACK;\n+            libc::sigemptyset(&mut sa.sa_mask);\n+            libc::sigaction(libc::SIGSEGV, &sa, std::ptr::null_mut());\n+        }\n+    }\n+}\n+\n+#[cfg(not(all(unix, any(target_env = \"gnu\", target_os = \"macos\"))))]\n+mod signal_handler {\n+    pub(super) fn install() {}\n+}\n+\n+pub fn main() -> ! {\n+    let start_time = Instant::now();\n+    let start_rss = get_resident_set_size();\n+    signal_handler::install();\n+    let mut callbacks = TimePassesCallbacks::default();\n+    install_ice_hook();\n+    let exit_code = catch_with_exit_code(|| {\n+        let args = env::args_os()\n+            .enumerate()\n+            .map(|(i, arg)| {\n+                arg.into_string().unwrap_or_else(|arg| {\n+                    early_error(\n+                        ErrorOutputType::default(),\n+                        &format!(\"argument {i} is not valid Unicode: {arg:?}\"),\n+                    )\n+                })\n+            })\n+            .collect::<Vec<_>>();\n+        RunCompiler::new(&args, &mut callbacks).run()\n+    });\n+\n+    if callbacks.time_passes {\n+        let end_rss = get_resident_set_size();\n+        print_time_passes_entry(\"total\", start_time.elapsed(), start_rss, end_rss);\n+    }\n+\n+    process::exit(exit_code)\n+}"}, {"sha": "446c6832cb7b607657a23a63e4c628d0123867cc", "filename": "compiler/rustc_driver_impl/src/pretty.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_driver_impl%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_driver_impl%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Fpretty.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "previous_filename": "compiler/rustc_driver/src/pretty.rs"}, {"sha": "638b368f702145586b9ca3e109fa2d261944b56e", "filename": "compiler/rustc_driver_impl/src/session_diagnostics.rs", "status": "renamed", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_driver_impl%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_driver_impl%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Fsession_diagnostics.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1,67 +1,67 @@\n use rustc_macros::Diagnostic;\n \n #[derive(Diagnostic)]\n-#[diag(driver_rlink_unable_to_read)]\n+#[diag(driver_impl_rlink_unable_to_read)]\n pub(crate) struct RlinkUnableToRead {\n     pub err: std::io::Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(driver_rlink_wrong_file_type)]\n+#[diag(driver_impl_rlink_wrong_file_type)]\n pub(crate) struct RLinkWrongFileType;\n \n #[derive(Diagnostic)]\n-#[diag(driver_rlink_empty_version_number)]\n+#[diag(driver_impl_rlink_empty_version_number)]\n pub(crate) struct RLinkEmptyVersionNumber;\n \n #[derive(Diagnostic)]\n-#[diag(driver_rlink_encoding_version_mismatch)]\n+#[diag(driver_impl_rlink_encoding_version_mismatch)]\n pub(crate) struct RLinkEncodingVersionMismatch {\n     pub version_array: String,\n     pub rlink_version: u32,\n }\n \n #[derive(Diagnostic)]\n-#[diag(driver_rlink_rustc_version_mismatch)]\n+#[diag(driver_impl_rlink_rustc_version_mismatch)]\n pub(crate) struct RLinkRustcVersionMismatch<'a> {\n     pub rustc_version: String,\n     pub current_version: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(driver_rlink_no_a_file)]\n+#[diag(driver_impl_rlink_no_a_file)]\n pub(crate) struct RlinkNotAFile;\n \n #[derive(Diagnostic)]\n-#[diag(driver_unpretty_dump_fail)]\n+#[diag(driver_impl_unpretty_dump_fail)]\n pub(crate) struct UnprettyDumpFail {\n     pub path: String,\n     pub err: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(driver_ice)]\n+#[diag(driver_impl_ice)]\n pub(crate) struct Ice;\n \n #[derive(Diagnostic)]\n-#[diag(driver_ice_bug_report)]\n+#[diag(driver_impl_ice_bug_report)]\n pub(crate) struct IceBugReport<'a> {\n     pub bug_report_url: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(driver_ice_version)]\n+#[diag(driver_impl_ice_version)]\n pub(crate) struct IceVersion<'a> {\n     pub version: &'a str,\n     pub triple: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(driver_ice_flags)]\n+#[diag(driver_impl_ice_flags)]\n pub(crate) struct IceFlags {\n     pub flags: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(driver_ice_exclude_cargo_defaults)]\n+#[diag(driver_impl_ice_exclude_cargo_defaults)]\n pub(crate) struct IceExcludeCargoDefaults;", "previous_filename": "compiler/rustc_driver/src/session_diagnostics.rs"}, {"sha": "fe77cf23e8f942fee238c71e3ca30ce2b85e7d66", "filename": "compiler/rustc_error_messages/locales/en-US/borrowck.ftl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -33,7 +33,7 @@ borrowck_var_here_defined = variable defined here\n \n borrowck_var_here_captured = variable captured here\n \n-borrowck_closure_inferred_mut =  inferred to be a `FnMut` closure\n+borrowck_closure_inferred_mut = inferred to be a `FnMut` closure\n \n borrowck_returned_closure_escaped =\n     returns a closure that contains a reference to a captured variable, which then escapes the closure body"}, {"sha": "8fe5f8d50abe2aa9696ccb519f2c4e7b7b3079db", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_ssa.ftl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -22,7 +22,7 @@ codegen_ssa_ignoring_output = ignoring -o because multiple .{$extension} files w\n \n codegen_ssa_create_temp_dir = couldn't create a temp dir: {$error}\n \n-codegen_ssa_incompatible_linking_modifiers = the linking modifiers `+bundle` and `+whole-archive` are not compatible with each other when generating rlibs\n+codegen_ssa_incompatible_linking_modifiers = link modifiers combination `+bundle,+whole-archive` is unstable when generating rlibs\n \n codegen_ssa_add_native_library = failed to add native library {$library_path}: {$error}\n "}, {"sha": "f19b1ff6426177c16eb24dd9093bfa268cb21464", "filename": "compiler/rustc_error_messages/locales/en-US/driver.ftl", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdriver.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdriver.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdriver.ftl?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1,19 +1,19 @@\n-driver_rlink_unable_to_read = failed to read rlink file: `{$err}`\n+driver_impl_rlink_unable_to_read = failed to read rlink file: `{$err}`\n \n-driver_rlink_wrong_file_type = The input does not look like a .rlink file\n+driver_impl_rlink_wrong_file_type = The input does not look like a .rlink file\n \n-driver_rlink_empty_version_number = The input does not contain version number\n+driver_impl_rlink_empty_version_number = The input does not contain version number\n \n-driver_rlink_encoding_version_mismatch = .rlink file was produced with encoding version `{$version_array}`, but the current version is `{$rlink_version}`\n+driver_impl_rlink_encoding_version_mismatch = .rlink file was produced with encoding version `{$version_array}`, but the current version is `{$rlink_version}`\n \n-driver_rlink_rustc_version_mismatch = .rlink file was produced by rustc version `{$rustc_version}`, but the current version is `{$current_version}`\n+driver_impl_rlink_rustc_version_mismatch = .rlink file was produced by rustc version `{$rustc_version}`, but the current version is `{$current_version}`\n \n-driver_rlink_no_a_file = rlink must be a file\n+driver_impl_rlink_no_a_file = rlink must be a file\n \n-driver_unpretty_dump_fail = pretty-print failed to write `{$path}` due to error `{$err}`\n+driver_impl_unpretty_dump_fail = pretty-print failed to write `{$path}` due to error `{$err}`\n \n-driver_ice = the compiler unexpectedly panicked. this is a bug.\n-driver_ice_bug_report = we would appreciate a bug report: {$bug_report_url}\n-driver_ice_version = rustc {$version} running on {$triple}\n-driver_ice_flags = compiler flags: {$flags}\n-driver_ice_exclude_cargo_defaults = some of the compiler flags provided by cargo are hidden\n+driver_impl_ice = the compiler unexpectedly panicked. this is a bug.\n+driver_impl_ice_bug_report = we would appreciate a bug report: {$bug_report_url}\n+driver_impl_ice_version = rustc {$version} running on {$triple}\n+driver_impl_ice_flags = compiler flags: {$flags}\n+driver_impl_ice_exclude_cargo_defaults = some of the compiler flags provided by cargo are hidden"}, {"sha": "05ac8db0db88f893d64604f50fd86de7fa542026", "filename": "compiler/rustc_error_messages/locales/en-US/hir_typeck.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_typeck.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_typeck.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_typeck.ftl?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -61,3 +61,5 @@ hir_typeck_lang_start_incorrect_ret_ty = the return type of the `start` lang ite\n hir_typeck_help_set_edition_cargo = set `edition = \"{$edition}\"` in `Cargo.toml`\n hir_typeck_help_set_edition_standalone = pass `--edition {$edition}` to `rustc`\n hir_typeck_note_edition_guide = for more on editions, read https://doc.rust-lang.org/edition-guide\n+\n+hir_typeck_convert_to_str = try converting the passed type into a `&str`"}, {"sha": "b1e7cc69a809b269ca9a5608656736490b1225bf", "filename": "compiler/rustc_error_messages/locales/en-US/lint.ftl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -309,6 +309,7 @@ lint_unused_generator =\n     .note = generators are lazy and do nothing unless resumed\n \n lint_unused_def = unused {$pre}`{$def}`{$post} that must be used\n+    .suggestion = use `let _ = ...` to ignore the resulting value\n \n lint_path_statement_drop = path statement drops value\n     .suggestion = use `drop` to clarify the intent"}, {"sha": "581bb9a766e20640b50b5a279712f27fe4d2b35c", "filename": "compiler/rustc_error_messages/locales/en-US/parse.ftl", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -128,6 +128,9 @@ parse_missing_in_in_for_loop = missing `in` in `for` loop\n     .use_in_not_of = try using `in` here instead\n     .add_in = try adding `in` here\n \n+parse_missing_expression_in_for_loop = missing expression to iterate on in `for` loop\n+    .suggestion = try adding an expression to the `for` loop\n+\n parse_missing_comma_after_match_arm = expected `,` following `match` arm\n     .suggestion = missing a comma here to end this `match` arm\n \n@@ -203,8 +206,9 @@ parse_inclusive_range_extra_equals = unexpected `=` after inclusive range\n     .suggestion_remove_eq = use `..=` instead\n     .note = inclusive ranges end with a single equals sign (`..=`)\n \n-parse_inclusive_range_match_arrow = unexpected `=>` after open range\n-    .suggestion_add_space = add a space between the pattern and `=>`\n+parse_inclusive_range_match_arrow = unexpected `>` after inclusive range\n+    .label = this is parsed as an inclusive range `..=`\n+    .suggestion = add a space between the pattern and `=>`\n \n parse_inclusive_range_no_end = inclusive range with no end\n     .suggestion_open_range = use `..` instead\n@@ -471,6 +475,9 @@ parse_unexpected_token_after_struct_name_found_other = expected `where`, `{\"{\"}`\n parse_unexpected_self_in_generic_parameters = unexpected keyword `Self` in generic parameters\n     .note = you cannot use `Self` as a generic parameter because it is reserved for associated items\n \n+parse_unexpected_default_value_for_lifetime_in_generic_parameters = unexpected default lifetime parameter\n+    .label = lifetime parameters cannot have default values\n+\n parse_multiple_where_clauses = cannot define duplicate `where` clauses on an item\n     .label = previous `where` clause starts here\n     .suggestion = consider joining the two `where` clauses into one\n@@ -535,8 +542,8 @@ parse_dot_dot_dot_range_to_pattern_not_allowed = range-to patterns with `...` ar\n \n parse_enum_pattern_instead_of_identifier = expected identifier, found enum pattern\n \n-parse_dot_dot_dot_for_remaining_fields = expected field pattern, found `...`\n-    .suggestion = to omit remaining fields, use one fewer `.`\n+parse_dot_dot_dot_for_remaining_fields = expected field pattern, found `{$token_str}`\n+    .suggestion = to omit remaining fields, use `..`\n \n parse_expected_comma_after_pattern_field = expected `,`\n "}, {"sha": "cf7cff739b340f346ac59d75309c3a13f4fd109c", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1,11 +1,6 @@\n #![deny(rustc::untranslatable_diagnostic)]\n \n-use crate::errors::{\n-    ArgumentNotAttributes, AttrNoArguments, AttributeMetaItem, AttributeSingleWord,\n-    AttributesWrongForm, CannotBeNameOfMacro, ExpectedCommaInList, HelperAttributeNameInvalid,\n-    MacroBodyStability, MacroConstStability, NotAMetaItem, OnlyOneArgument, OnlyOneWord,\n-    ResolveRelativePath, TakesNoArguments, TraceMacro,\n-};\n+use crate::errors;\n use crate::expand::{self, AstFragment, Invocation};\n use crate::module::DirOwnership;\n \n@@ -796,13 +791,13 @@ impl SyntaxExtension {\n             .unwrap_or_else(|| (None, helper_attrs));\n         let (stability, const_stability, body_stability) = attr::find_stability(&sess, attrs, span);\n         if let Some((_, sp)) = const_stability {\n-            sess.emit_err(MacroConstStability {\n+            sess.emit_err(errors::MacroConstStability {\n                 span: sp,\n                 head_span: sess.source_map().guess_head_span(span),\n             });\n         }\n         if let Some((_, sp)) = body_stability {\n-            sess.emit_err(MacroBodyStability {\n+            sess.emit_err(errors::MacroBodyStability {\n                 span: sp,\n                 head_span: sess.source_map().guess_head_span(span),\n             });\n@@ -1143,7 +1138,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n     pub fn trace_macros_diag(&mut self) {\n         for (span, notes) in self.expansions.iter() {\n-            let mut db = self.sess.parse_sess.create_note(TraceMacro { span: *span });\n+            let mut db = self.sess.parse_sess.create_note(errors::TraceMacro { span: *span });\n             for note in notes {\n                 db.note(note);\n             }\n@@ -1197,7 +1192,7 @@ pub fn resolve_path(\n                 .expect(\"attempting to resolve a file path in an external file\"),\n             FileName::DocTest(path, _) => path,\n             other => {\n-                return Err(ResolveRelativePath {\n+                return Err(errors::ResolveRelativePath {\n                     span,\n                     path: parse_sess.source_map().filename_for_diagnostics(&other).to_string(),\n                 }\n@@ -1279,7 +1274,7 @@ pub fn expr_to_string(\n /// done as rarely as possible).\n pub fn check_zero_tts(cx: &ExtCtxt<'_>, span: Span, tts: TokenStream, name: &str) {\n     if !tts.is_empty() {\n-        cx.emit_err(TakesNoArguments { span, name });\n+        cx.emit_err(errors::TakesNoArguments { span, name });\n     }\n }\n \n@@ -1307,14 +1302,14 @@ pub fn get_single_str_from_tts(\n ) -> Option<Symbol> {\n     let mut p = cx.new_parser_from_tts(tts);\n     if p.token == token::Eof {\n-        cx.emit_err(OnlyOneArgument { span, name });\n+        cx.emit_err(errors::OnlyOneArgument { span, name });\n         return None;\n     }\n     let ret = parse_expr(&mut p)?;\n     let _ = p.eat(&token::Comma);\n \n     if p.token != token::Eof {\n-        cx.emit_err(OnlyOneArgument { span, name });\n+        cx.emit_err(errors::OnlyOneArgument { span, name });\n     }\n     expr_to_string(cx, ret, \"argument must be a string literal\").map(|(s, _)| s)\n }\n@@ -1336,7 +1331,7 @@ pub fn get_exprs_from_tts(cx: &mut ExtCtxt<'_>, tts: TokenStream) -> Option<Vec<\n             continue;\n         }\n         if p.token != token::Eof {\n-            cx.emit_err(ExpectedCommaInList { span: p.token.span });\n+            cx.emit_err(errors::ExpectedCommaInList { span: p.token.span });\n             return None;\n         }\n     }\n@@ -1353,51 +1348,58 @@ pub fn parse_macro_name_and_helper_attrs(\n     // `#[proc_macro_derive(Foo, attributes(A, ..))]`\n     let list = attr.meta_item_list()?;\n     if list.len() != 1 && list.len() != 2 {\n-        diag.emit_err(AttrNoArguments { span: attr.span });\n+        diag.emit_err(errors::AttrNoArguments { span: attr.span });\n         return None;\n     }\n     let Some(trait_attr) = list[0].meta_item() else {\n-        diag.emit_err(NotAMetaItem {span: list[0].span()});\n+        diag.emit_err(errors::NotAMetaItem {span: list[0].span()});\n         return None;\n     };\n     let trait_ident = match trait_attr.ident() {\n         Some(trait_ident) if trait_attr.is_word() => trait_ident,\n         _ => {\n-            diag.emit_err(OnlyOneWord { span: trait_attr.span });\n+            diag.emit_err(errors::OnlyOneWord { span: trait_attr.span });\n             return None;\n         }\n     };\n \n     if !trait_ident.name.can_be_raw() {\n-        diag.emit_err(CannotBeNameOfMacro { span: trait_attr.span, trait_ident, macro_type });\n+        diag.emit_err(errors::CannotBeNameOfMacro {\n+            span: trait_attr.span,\n+            trait_ident,\n+            macro_type,\n+        });\n     }\n \n     let attributes_attr = list.get(1);\n     let proc_attrs: Vec<_> = if let Some(attr) = attributes_attr {\n         if !attr.has_name(sym::attributes) {\n-            diag.emit_err(ArgumentNotAttributes { span: attr.span() });\n+            diag.emit_err(errors::ArgumentNotAttributes { span: attr.span() });\n         }\n         attr.meta_item_list()\n             .unwrap_or_else(|| {\n-                diag.emit_err(AttributesWrongForm { span: attr.span() });\n+                diag.emit_err(errors::AttributesWrongForm { span: attr.span() });\n                 &[]\n             })\n             .iter()\n             .filter_map(|attr| {\n                 let Some(attr) = attr.meta_item() else {\n-                    diag.emit_err(AttributeMetaItem { span: attr.span() });\n+                    diag.emit_err(errors::AttributeMetaItem { span: attr.span() });\n                     return None;\n                 };\n \n                 let ident = match attr.ident() {\n                     Some(ident) if attr.is_word() => ident,\n                     _ => {\n-                        diag.emit_err(AttributeSingleWord { span: attr.span });\n+                        diag.emit_err(errors::AttributeSingleWord { span: attr.span });\n                         return None;\n                     }\n                 };\n                 if !ident.name.can_be_raw() {\n-                    diag.emit_err(HelperAttributeNameInvalid { span: attr.span, name: ident });\n+                    diag.emit_err(errors::HelperAttributeNameInvalid {\n+                        span: attr.span,\n+                        name: ident,\n+                    });\n                 }\n \n                 Some(ident.name)"}, {"sha": "de34df0114a743c2f89327d94c2cd7f13fbad9a9", "filename": "compiler/rustc_expand/src/mbe/metavar_expr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1,5 +1,5 @@\n use rustc_ast::token::{self, Delimiter};\n-use rustc_ast::tokenstream::{CursorRef, TokenStream, TokenTree};\n+use rustc_ast::tokenstream::{RefTokenTreeCursor, TokenStream, TokenTree};\n use rustc_ast::{LitIntType, LitKind};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{Applicability, PResult};\n@@ -72,7 +72,7 @@ impl MetaVarExpr {\n \n // Checks if there are any remaining tokens. For example, `${ignore(ident ... a b c ...)}`\n fn check_trailing_token<'sess>(\n-    iter: &mut CursorRef<'_>,\n+    iter: &mut RefTokenTreeCursor<'_>,\n     sess: &'sess ParseSess,\n ) -> PResult<'sess, ()> {\n     if let Some(tt) = iter.next() {\n@@ -88,7 +88,7 @@ fn check_trailing_token<'sess>(\n \n /// Parse a meta-variable `count` expression: `count(ident[, depth])`\n fn parse_count<'sess>(\n-    iter: &mut CursorRef<'_>,\n+    iter: &mut RefTokenTreeCursor<'_>,\n     sess: &'sess ParseSess,\n     span: Span,\n ) -> PResult<'sess, MetaVarExpr> {\n@@ -99,7 +99,7 @@ fn parse_count<'sess>(\n \n /// Parses the depth used by index(depth) and length(depth).\n fn parse_depth<'sess>(\n-    iter: &mut CursorRef<'_>,\n+    iter: &mut RefTokenTreeCursor<'_>,\n     sess: &'sess ParseSess,\n     span: Span,\n ) -> PResult<'sess, usize> {\n@@ -126,7 +126,7 @@ fn parse_depth<'sess>(\n \n /// Parses an generic ident\n fn parse_ident<'sess>(\n-    iter: &mut CursorRef<'_>,\n+    iter: &mut RefTokenTreeCursor<'_>,\n     sess: &'sess ParseSess,\n     span: Span,\n ) -> PResult<'sess, Ident> {\n@@ -152,7 +152,7 @@ fn parse_ident<'sess>(\n \n /// Tries to move the iterator forward returning `true` if there is a comma. If not, then the\n /// iterator is not modified and the result is `false`.\n-fn try_eat_comma(iter: &mut CursorRef<'_>) -> bool {\n+fn try_eat_comma(iter: &mut RefTokenTreeCursor<'_>) -> bool {\n     if let Some(TokenTree::Token(token::Token { kind: token::Comma, .. }, _)) = iter.look_ahead(0) {\n         let _ = iter.next();\n         return true;"}, {"sha": "21d211eefbef373a65150f5ab44030e8544f4388", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -164,6 +164,8 @@ declare_features! (\n     (active, multiple_supertrait_upcastable, \"CURRENT_RUSTC_VERSION\", None, None),\n     /// Allows using `#[omit_gdb_pretty_printer_section]`.\n     (active, omit_gdb_pretty_printer_section, \"1.5.0\", None, None),\n+    /// Allows using `+bundled,+whole-archive` native libs.\n+    (active, packed_bundled_libs, \"1.67.0\", None, None),\n     /// Allows using `#[prelude_import]` on glob `use` items.\n     (active, prelude_import, \"1.2.0\", None, None),\n     /// Used to identify crates that contain the profiler runtime."}, {"sha": "c939c8303bf200e4d7a2b7c981356d943ba9c8cf", "filename": "compiler/rustc_hir_analysis/Cargo.toml", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_hir_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_hir_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2FCargo.toml?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -15,9 +15,7 @@ rustc_middle = { path = \"../rustc_middle\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n-rustc_graphviz = { path = \"../rustc_graphviz\" }\n rustc_hir = { path = \"../rustc_hir\" }\n-rustc_hir_pretty = { path = \"../rustc_hir_pretty\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_session = { path = \"../rustc_session\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n@@ -27,6 +25,5 @@ rustc_index = { path = \"../rustc_index\" }\n rustc_infer = { path = \"../rustc_infer\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_lint = { path = \"../rustc_lint\" }\n-rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_type_ir = { path = \"../rustc_type_ir\" }\n rustc_feature = { path = \"../rustc_feature\" }"}, {"sha": "3d5f189e233bb5f8f87753898f1bd89ba3f4c8cd", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -2945,12 +2945,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     if r.is_erased() { tcx.lifetimes.re_static } else { r }\n                 });\n                 let span = ast_ty.span;\n-                tcx.sess.emit_err(TypeofReservedKeywordUsed {\n-                    span,\n-                    ty,\n-                    opt_sugg: Some((span, Applicability::MachineApplicable))\n-                        .filter(|_| ty.is_suggestable(tcx, false)),\n-                });\n+                let (ty, opt_sugg) = if let Some(ty) = ty.make_suggestable(tcx, false) {\n+                    (ty, Some((span, Applicability::MachineApplicable)))\n+                } else {\n+                    (ty, None)\n+                };\n+                tcx.sess.emit_err(TypeofReservedKeywordUsed { span, ty, opt_sugg });\n \n                 ty\n             }"}, {"sha": "7d381d8902ac2f10ee913ac96fe7c98ec0d01613", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 183, "deletions": 40, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -8,7 +8,7 @@ use rustc_hir as hir;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::IgnoreRegions;\n use rustc_middle::ty::{\n-    self, ImplPolarity, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n+    self, AliasKind, ImplPolarity, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n };\n use rustc_session::lint;\n use rustc_span::def_id::{DefId, LocalDefId};\n@@ -86,7 +86,7 @@ fn do_orphan_check_impl<'tcx>(\n     // struct B { }\n     // impl Foo for A { }\n     // impl Foo for B { }\n-    // impl !Send for (A, B) { }\n+    // impl !Foo for (A, B) { }\n     // ```\n     //\n     // This final impl is legal according to the orphan\n@@ -99,50 +99,193 @@ fn do_orphan_check_impl<'tcx>(\n         tcx.trait_is_auto(trait_def_id)\n     );\n \n-    if tcx.trait_is_auto(trait_def_id) && !trait_def_id.is_local() {\n+    if tcx.trait_is_auto(trait_def_id) {\n         let self_ty = trait_ref.self_ty();\n-        let opt_self_def_id = match *self_ty.kind() {\n-            ty::Adt(self_def, _) => Some(self_def.did()),\n-            ty::Foreign(did) => Some(did),\n-            _ => None,\n-        };\n \n-        let msg = match opt_self_def_id {\n-            // We only want to permit nominal types, but not *all* nominal types.\n-            // They must be local to the current crate, so that people\n-            // can't do `unsafe impl Send for Rc<SomethingLocal>` or\n-            // `impl !Send for Box<SomethingLocalAndSend>`.\n-            Some(self_def_id) => {\n-                if self_def_id.is_local() {\n-                    None\n+        // If the impl is in the same crate as the auto-trait, almost anything\n+        // goes.\n+        //\n+        //     impl MyAuto for Rc<Something> {}  // okay\n+        //     impl<T> !MyAuto for *const T {}   // okay\n+        //     impl<T> MyAuto for T {}           // okay\n+        //\n+        // But there is one important exception: implementing for a trait object\n+        // is not allowed.\n+        //\n+        //     impl MyAuto for dyn Trait {}      // NOT OKAY\n+        //     impl<T: ?Sized> MyAuto for T {}   // NOT OKAY\n+        //\n+        // With this restriction, it's guaranteed that an auto-trait is\n+        // implemented for a trait object if and only if the auto-trait is one\n+        // of the trait object's trait bounds (or a supertrait of a bound). In\n+        // other words `dyn Trait + AutoTrait` always implements AutoTrait,\n+        // while `dyn Trait` never implements AutoTrait.\n+        //\n+        // This is necessary in order for autotrait bounds on methods of trait\n+        // objects to be sound.\n+        //\n+        //     auto trait AutoTrait {}\n+        //\n+        //     trait ObjectSafeTrait {\n+        //         fn f(&self) where Self: AutoTrait;\n+        //     }\n+        //\n+        // We can allow f to be called on `dyn ObjectSafeTrait + AutoTrait`.\n+        //\n+        // If we didn't deny `impl AutoTrait for dyn Trait`, it would be unsound\n+        // for the ObjectSafeTrait shown above to be object safe because someone\n+        // could take some type implementing ObjectSafeTrait but not AutoTrait,\n+        // unsize it to `dyn ObjectSafeTrait`, and call .f() which has no\n+        // concrete implementation (issue #50781).\n+        enum LocalImpl {\n+            Allow,\n+            Disallow { problematic_kind: &'static str },\n+        }\n+\n+        // If the auto-trait is from a dependency, it must only be getting\n+        // implemented for a nominal type, and specifically one local to the\n+        // current crate.\n+        //\n+        //     impl<T> Sync for MyStruct<T> {}   // okay\n+        //\n+        //     impl Sync for Rc<MyStruct> {}     // NOT OKAY\n+        enum NonlocalImpl {\n+            Allow,\n+            DisallowBecauseNonlocal,\n+            DisallowOther,\n+        }\n+\n+        // Exhaustive match considering that this logic is essential for\n+        // soundness.\n+        let (local_impl, nonlocal_impl) = match self_ty.kind() {\n+            // struct Struct<T>;\n+            // impl AutoTrait for Struct<Foo> {}\n+            ty::Adt(self_def, _) => (\n+                LocalImpl::Allow,\n+                if self_def.did().is_local() {\n+                    NonlocalImpl::Allow\n+                } else {\n+                    NonlocalImpl::DisallowBecauseNonlocal\n+                },\n+            ),\n+\n+            // extern { type OpaqueType; }\n+            // impl AutoTrait for OpaqueType {}\n+            ty::Foreign(did) => (\n+                LocalImpl::Allow,\n+                if did.is_local() {\n+                    NonlocalImpl::Allow\n                 } else {\n-                    Some((\n-                        format!(\n-                            \"cross-crate traits with a default impl, like `{}`, \\\n-                                    can only be implemented for a struct/enum type \\\n-                                    defined in the current crate\",\n-                            tcx.def_path_str(trait_def_id)\n-                        ),\n-                        \"can't implement cross-crate trait for type in another crate\",\n-                    ))\n+                    NonlocalImpl::DisallowBecauseNonlocal\n+                },\n+            ),\n+\n+            // impl AutoTrait for dyn Trait {}\n+            ty::Dynamic(..) => (\n+                LocalImpl::Disallow { problematic_kind: \"trait object\" },\n+                NonlocalImpl::DisallowOther,\n+            ),\n+\n+            // impl<T> AutoTrait for T {}\n+            // impl<T: ?Sized> AutoTrait for T {}\n+            ty::Param(..) => (\n+                if self_ty.is_sized(tcx, tcx.param_env(def_id)) {\n+                    LocalImpl::Allow\n+                } else {\n+                    LocalImpl::Disallow { problematic_kind: \"generic type\" }\n+                },\n+                NonlocalImpl::DisallowOther,\n+            ),\n+\n+            // trait Id { type This: ?Sized; }\n+            // impl<T: ?Sized> Id for T {\n+            //     type This = T;\n+            // }\n+            // impl<T: ?Sized> AutoTrait for <T as Id>::This {}\n+            ty::Alias(AliasKind::Projection, _) => (\n+                LocalImpl::Disallow { problematic_kind: \"associated type\" },\n+                NonlocalImpl::DisallowOther,\n+            ),\n+\n+            // type Opaque = impl Trait;\n+            // impl AutoTrait for Opaque {}\n+            ty::Alias(AliasKind::Opaque, _) => (\n+                LocalImpl::Disallow { problematic_kind: \"opaque type\" },\n+                NonlocalImpl::DisallowOther,\n+            ),\n+\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(..)\n+            | ty::Uint(..)\n+            | ty::Float(..)\n+            | ty::Str\n+            | ty::Array(..)\n+            | ty::Slice(..)\n+            | ty::RawPtr(..)\n+            | ty::Ref(..)\n+            | ty::FnDef(..)\n+            | ty::FnPtr(..)\n+            | ty::Never\n+            | ty::Tuple(..) => (LocalImpl::Allow, NonlocalImpl::DisallowOther),\n+\n+            ty::Closure(..)\n+            | ty::Generator(..)\n+            | ty::GeneratorWitness(..)\n+            | ty::GeneratorWitnessMIR(..)\n+            | ty::Bound(..)\n+            | ty::Placeholder(..)\n+            | ty::Infer(..) => span_bug!(sp, \"weird self type for autotrait impl\"),\n+\n+            ty::Error(..) => (LocalImpl::Allow, NonlocalImpl::Allow),\n+        };\n+\n+        if trait_def_id.is_local() {\n+            match local_impl {\n+                LocalImpl::Allow => {}\n+                LocalImpl::Disallow { problematic_kind } => {\n+                    let msg = format!(\n+                        \"traits with a default impl, like `{trait}`, \\\n+                                cannot be implemented for {problematic_kind} `{self_ty}`\",\n+                        trait = tcx.def_path_str(trait_def_id),\n+                    );\n+                    let label = format!(\n+                        \"a trait object implements `{trait}` if and only if `{trait}` \\\n+                                is one of the trait object's trait bounds\",\n+                        trait = tcx.def_path_str(trait_def_id),\n+                    );\n+                    let reported =\n+                        struct_span_err!(tcx.sess, sp, E0321, \"{}\", msg).note(label).emit();\n+                    return Err(reported);\n                 }\n             }\n-            _ => Some((\n-                format!(\n-                    \"cross-crate traits with a default impl, like `{}`, can \\\n+        } else {\n+            if let Some((msg, label)) = match nonlocal_impl {\n+                NonlocalImpl::Allow => None,\n+                NonlocalImpl::DisallowBecauseNonlocal => Some((\n+                    format!(\n+                        \"cross-crate traits with a default impl, like `{}`, \\\n+                                can only be implemented for a struct/enum type \\\n+                                defined in the current crate\",\n+                        tcx.def_path_str(trait_def_id)\n+                    ),\n+                    \"can't implement cross-crate trait for type in another crate\",\n+                )),\n+                NonlocalImpl::DisallowOther => Some((\n+                    format!(\n+                        \"cross-crate traits with a default impl, like `{}`, can \\\n                                 only be implemented for a struct/enum type, not `{}`\",\n-                    tcx.def_path_str(trait_def_id),\n-                    self_ty\n-                ),\n-                \"can't implement cross-crate trait with a default impl for \\\n-                        non-struct/enum type\",\n-            )),\n-        };\n-\n-        if let Some((msg, label)) = msg {\n-            let reported =\n-                struct_span_err!(tcx.sess, sp, E0321, \"{}\", msg).span_label(sp, label).emit();\n-            return Err(reported);\n+                        tcx.def_path_str(trait_def_id),\n+                        self_ty\n+                    ),\n+                    \"can't implement cross-crate trait with a default impl for \\\n+                            non-struct/enum type\",\n+                )),\n+            } {\n+                let reported =\n+                    struct_span_err!(tcx.sess, sp, E0321, \"{}\", msg).span_label(sp, label).emit();\n+                return Err(reported);\n+            }\n         }\n     }\n "}, {"sha": "80426c239ac8b8f9ab6506324aa685e10583197c", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1199,28 +1199,22 @@ fn infer_return_ty_for_fn_sig<'tcx>(\n             visitor.visit_ty(ty);\n             let mut diag = bad_placeholder(tcx, visitor.0, \"return type\");\n             let ret_ty = fn_sig.output();\n-            if ret_ty.is_suggestable(tcx, false) {\n+            if let Some(ret_ty) = ret_ty.make_suggestable(tcx, false) {\n                 diag.span_suggestion(\n                     ty.span,\n                     \"replace with the correct return type\",\n                     ret_ty,\n                     Applicability::MachineApplicable,\n                 );\n-            } else if matches!(ret_ty.kind(), ty::FnDef(..)) {\n-                let fn_sig = ret_ty.fn_sig(tcx);\n-                if fn_sig\n-                    .skip_binder()\n-                    .inputs_and_output\n-                    .iter()\n-                    .all(|t| t.is_suggestable(tcx, false))\n-                {\n-                    diag.span_suggestion(\n-                        ty.span,\n-                        \"replace with the correct return type\",\n-                        fn_sig,\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n+            } else if matches!(ret_ty.kind(), ty::FnDef(..))\n+                && let Some(fn_sig) = ret_ty.fn_sig(tcx).make_suggestable(tcx, false)\n+            {\n+                diag.span_suggestion(\n+                    ty.span,\n+                    \"replace with the correct return type\",\n+                    fn_sig,\n+                    Applicability::MachineApplicable,\n+                );\n             } else if let Some(sugg) = suggest_impl_trait(tcx, ret_ty, ty.span, hir_id, def_id) {\n                 diag.span_suggestion(\n                     ty.span,\n@@ -1280,9 +1274,7 @@ fn suggest_impl_trait<'tcx>(\n             let trait_name = tcx.item_name(trait_def_id);\n             let args_tuple = substs.type_at(1);\n             let ty::Tuple(types) = *args_tuple.kind() else { return None; };\n-            if !types.is_suggestable(tcx, false) {\n-                return None;\n-            }\n+            let types = types.make_suggestable(tcx, false)?;\n             let maybe_ret =\n                 if item_ty.is_unit() { String::new() } else { format!(\" -> {item_ty}\") };\n             Some(format!(\n@@ -1337,7 +1329,7 @@ fn suggest_impl_trait<'tcx>(\n         // FIXME(compiler-errors): We may benefit from resolving regions here.\n         if ocx.select_where_possible().is_empty()\n             && let item_ty = infcx.resolve_vars_if_possible(item_ty)\n-            && item_ty.is_suggestable(tcx, false)\n+            && let Some(item_ty) = item_ty.make_suggestable(tcx, false)\n             && let Some(sugg) = formatter(tcx, infcx.resolve_vars_if_possible(substs), trait_def_id, assoc_item_def_id, item_ty)\n         {\n             return Some(sugg);"}, {"sha": "c5522c94874dd3c3421e3a20e6f71f67be3d7780", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 14, "deletions": 33, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -8,7 +8,9 @@ use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::print::with_forced_trimmed_paths;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::IntTypeExt;\n-use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeVisitable};\n+use rustc_middle::ty::{\n+    self, DefIdTree, IsSuggestable, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeVisitable,\n+};\n use rustc_span::symbol::Ident;\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -845,37 +847,23 @@ fn infer_placeholder_type<'a>(\n ) -> Ty<'a> {\n     // Attempts to make the type nameable by turning FnDefs into FnPtrs.\n     struct MakeNameable<'tcx> {\n-        success: bool,\n         tcx: TyCtxt<'tcx>,\n     }\n \n-    impl<'tcx> MakeNameable<'tcx> {\n-        fn new(tcx: TyCtxt<'tcx>) -> Self {\n-            MakeNameable { success: true, tcx }\n-        }\n-    }\n-\n     impl<'tcx> TypeFolder<'tcx> for MakeNameable<'tcx> {\n         fn tcx(&self) -> TyCtxt<'tcx> {\n             self.tcx\n         }\n \n         fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-            if !self.success {\n-                return ty;\n-            }\n-\n-            match ty.kind() {\n+            let ty = match *ty.kind() {\n                 ty::FnDef(def_id, substs) => {\n-                    self.tcx.mk_fn_ptr(self.tcx.fn_sig(*def_id).subst(self.tcx, substs))\n+                    self.tcx.mk_fn_ptr(self.tcx.fn_sig(def_id).subst(self.tcx, substs))\n                 }\n-                // FIXME: non-capturing closures should also suggest a function pointer\n-                ty::Closure(..) | ty::Generator(..) => {\n-                    self.success = false;\n-                    ty\n-                }\n-                _ => ty.super_fold_with(self),\n-            }\n+                _ => ty,\n+            };\n+\n+            ty.super_fold_with(self)\n         }\n     }\n \n@@ -898,15 +886,11 @@ fn infer_placeholder_type<'a>(\n                     suggestions.clear();\n                 }\n \n-                // Suggesting unnameable types won't help.\n-                let mut mk_nameable = MakeNameable::new(tcx);\n-                let ty = mk_nameable.fold_ty(ty);\n-                let sugg_ty = if mk_nameable.success { Some(ty) } else { None };\n-                if let Some(sugg_ty) = sugg_ty {\n+                if let Some(ty) = ty.make_suggestable(tcx, false) {\n                     err.span_suggestion(\n                         span,\n                         &format!(\"provide a type for the {item}\", item = kind),\n-                        format!(\"{colon} {sugg_ty}\"),\n+                        format!(\"{colon} {ty}\"),\n                         Applicability::MachineApplicable,\n                     );\n                 } else {\n@@ -923,15 +907,12 @@ fn infer_placeholder_type<'a>(\n             let mut diag = bad_placeholder(tcx, vec![span], kind);\n \n             if !ty.references_error() {\n-                let mut mk_nameable = MakeNameable::new(tcx);\n-                let ty = mk_nameable.fold_ty(ty);\n-                let sugg_ty = if mk_nameable.success { Some(ty) } else { None };\n-                if let Some(sugg_ty) = sugg_ty {\n+                if let Some(ty) = ty.make_suggestable(tcx, false) {\n                     diag.span_suggestion(\n                         span,\n                         \"replace with the correct type\",\n-                        sugg_ty,\n-                        Applicability::MaybeIncorrect,\n+                        ty,\n+                        Applicability::MachineApplicable,\n                     );\n                 } else {\n                     with_forced_trimmed_paths!(diag.span_note("}, {"sha": "c4905a934cb4eb7beba493edd756951ea5983a8c", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -60,6 +60,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             || self.suggest_clone_for_ref(err, expr, expr_ty, expected)\n             || self.suggest_into(err, expr, expr_ty, expected)\n             || self.suggest_floating_point_literal(err, expr, expected)\n+            || self.suggest_null_ptr_for_literal_zero_given_to_ptr_arg(err, expr, expected)\n             || self.note_result_coercion(err, expr, expected, expr_ty);\n         if !suggested {\n             self.point_at_expr_source_of_inferred_type(err, expr, expr_ty, expected, expr.span);"}, {"sha": "e84b3de124c58070388d3b741de2630569a215ff", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -921,6 +921,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 kind: hir::ImplItemKind::Fn(ref sig, ..),\n                 ..\n             }) => Some((&sig.decl, ident, false)),\n+            Node::Expr(&hir::Expr {\n+                hir_id,\n+                kind: hir::ExprKind::Closure(..),\n+                ..\n+            }) if let Some(Node::Expr(&hir::Expr {\n+                hir_id,\n+                kind: hir::ExprKind::Call(..),\n+                ..\n+            })) = self.tcx.hir().find_parent(hir_id) &&\n+            let Some(Node::Item(&hir::Item {\n+                ident,\n+                kind: hir::ItemKind::Fn(ref sig, ..),\n+                ..\n+            })) = self.tcx.hir().find_parent(hir_id) => {\n+                Some((&sig.decl, ident, ident.name != sym::main))\n+            },\n             _ => None,\n         }\n     }"}, {"sha": "2eab68050d43043d6395205cbb863cb908445677", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "added", "additions": 457, "deletions": 0, "changes": 457, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -0,0 +1,457 @@\n+use crate::FnCtxt;\n+use rustc_hir as hir;\n+use rustc_hir::def::Res;\n+use rustc_middle::ty::{self, DefIdTree, Ty};\n+use rustc_trait_selection::traits;\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    /**\n+     * Recursively searches for the most-specific blamable expression.\n+     * For example, if you have a chain of constraints like:\n+     * - want `Vec<i32>: Copy`\n+     * - because `Option<Vec<i32>>: Copy` needs `Vec<i32>: Copy` because `impl <T: Copy> Copy for Option<T>`\n+     * - because `(Option<Vec<i32>, bool)` needs `Option<Vec<i32>>: Copy` because `impl <A: Copy, B: Copy> Copy for (A, B)`\n+     * then if you pass in `(Some(vec![1, 2, 3]), false)`, this helper `point_at_specific_expr_if_possible`\n+     * will find the expression `vec![1, 2, 3]` as the \"most blameable\" reason for this missing constraint.\n+     *\n+     * This function only updates the error span.\n+     */\n+    pub fn blame_specific_expr_if_possible(\n+        &self,\n+        error: &mut traits::FulfillmentError<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n+    ) {\n+        // Whether it succeeded or failed, it likely made some amount of progress.\n+        // In the very worst case, it's just the same `expr` we originally passed in.\n+        let expr = match self.blame_specific_expr_if_possible_for_obligation_cause_code(\n+            &error.obligation.cause.code(),\n+            expr,\n+        ) {\n+            Ok(expr) => expr,\n+            Err(expr) => expr,\n+        };\n+\n+        // Either way, use this expression to update the error span.\n+        // If it doesn't overlap the existing span at all, use the original span.\n+        // FIXME: It would possibly be better to do this more continuously, at each level...\n+        error.obligation.cause.span = expr\n+            .span\n+            .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n+            .unwrap_or(error.obligation.cause.span);\n+    }\n+\n+    fn blame_specific_expr_if_possible_for_obligation_cause_code(\n+        &self,\n+        obligation_cause_code: &traits::ObligationCauseCode<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n+    ) -> Result<&'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>> {\n+        match obligation_cause_code {\n+            traits::ObligationCauseCode::ExprBindingObligation(_, _, _, _) => {\n+                // This is the \"root\"; we assume that the `expr` is already pointing here.\n+                // Therefore, we return `Ok` so that this `expr` can be refined further.\n+                Ok(expr)\n+            }\n+            traits::ObligationCauseCode::ImplDerivedObligation(impl_derived) => self\n+                .blame_specific_expr_if_possible_for_derived_predicate_obligation(\n+                    impl_derived,\n+                    expr,\n+                ),\n+            _ => {\n+                // We don't recognize this kind of constraint, so we cannot refine the expression\n+                // any further.\n+                Err(expr)\n+            }\n+        }\n+    }\n+\n+    /// We want to achieve the error span in the following example:\n+    ///\n+    /// ```ignore (just for demonstration)\n+    /// struct Burrito<Filling> {\n+    ///   filling: Filling,\n+    /// }\n+    /// impl <Filling: Delicious> Delicious for Burrito<Filling> {}\n+    /// fn eat_delicious_food<Food: Delicious>(_food: Food) {}\n+    ///\n+    /// fn will_type_error() {\n+    ///   eat_delicious_food(Burrito { filling: Kale });\n+    /// } //                                    ^--- The trait bound `Kale: Delicious`\n+    ///   //                                         is not satisfied\n+    /// ```\n+    ///\n+    /// Without calling this function, the error span will cover the entire argument expression.\n+    ///\n+    /// Before we do any of this logic, we recursively call `point_at_specific_expr_if_possible` on the parent\n+    /// obligation. Hence we refine the `expr` \"outwards-in\" and bail at the first kind of expression/impl we don't recognize.\n+    ///\n+    /// This function returns a `Result<&Expr, &Expr>` - either way, it returns the `Expr` whose span should be\n+    /// reported as an error. If it is `Ok`, then it means it refined successfull. If it is `Err`, then it may be\n+    /// only a partial success - but it cannot be refined even further.\n+    fn blame_specific_expr_if_possible_for_derived_predicate_obligation(\n+        &self,\n+        obligation: &traits::ImplDerivedObligationCause<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n+    ) -> Result<&'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>> {\n+        // First, we attempt to refine the `expr` for our span using the parent obligation.\n+        // If this cannot be done, then we are already stuck, so we stop early (hence the use\n+        // of the `?` try operator here).\n+        let expr = self.blame_specific_expr_if_possible_for_obligation_cause_code(\n+            &*obligation.derived.parent_code,\n+            expr,\n+        )?;\n+\n+        // This is the \"trait\" (meaning, the predicate \"proved\" by this `impl`) which provides the `Self` type we care about.\n+        // For the purposes of this function, we hope that it is a `struct` type, and that our current `expr` is a literal of\n+        // that struct type.\n+        let impl_trait_self_ref: Option<ty::TraitRef<'tcx>> =\n+            self.tcx.impl_trait_ref(obligation.impl_def_id).map(|impl_def| impl_def.skip_binder());\n+\n+        let Some(impl_trait_self_ref) = impl_trait_self_ref else {\n+            // It is possible that this is absent. In this case, we make no progress.\n+            return Err(expr);\n+        };\n+\n+        // We only really care about the `Self` type itself, which we extract from the ref.\n+        let impl_self_ty: Ty<'tcx> = impl_trait_self_ref.self_ty();\n+\n+        let impl_predicates: ty::GenericPredicates<'tcx> =\n+            self.tcx.predicates_of(obligation.impl_def_id);\n+        let Some(impl_predicate_index) = obligation.impl_def_predicate_index else {\n+            // We don't have the index, so we can only guess.\n+            return Err(expr);\n+        };\n+\n+        if impl_predicate_index >= impl_predicates.predicates.len() {\n+            // This shouldn't happen, but since this is only a diagnostic improvement, avoid breaking things.\n+            return Err(expr);\n+        }\n+        let relevant_broken_predicate: ty::PredicateKind<'tcx> =\n+            impl_predicates.predicates[impl_predicate_index].0.kind().skip_binder();\n+\n+        match relevant_broken_predicate {\n+            ty::PredicateKind::Clause(ty::Clause::Trait(broken_trait)) => {\n+                // ...\n+                self.blame_specific_part_of_expr_corresponding_to_generic_param(\n+                    broken_trait.trait_ref.self_ty().into(),\n+                    expr,\n+                    impl_self_ty.into(),\n+                )\n+            }\n+            _ => Err(expr),\n+        }\n+    }\n+\n+    /// Drills into `expr` to arrive at the equivalent location of `find_generic_param` in `in_ty`.\n+    /// For example, given\n+    /// - expr: `(Some(vec![1, 2, 3]), false)`\n+    /// - param: `T`\n+    /// - in_ty: `(Option<Vec<T>, bool)`\n+    /// we would drill until we arrive at `vec![1, 2, 3]`.\n+    ///\n+    /// If successful, we return `Ok(refined_expr)`. If unsuccesful, we return `Err(partially_refined_expr`),\n+    /// which will go as far as possible. For example, given `(foo(), false)` instead, we would drill to\n+    /// `foo()` and then return `Err(\"foo()\")`.\n+    ///\n+    /// This means that you can (and should) use the `?` try operator to chain multiple calls to this\n+    /// function with different types, since you can only continue drilling the second time if you\n+    /// succeeded the first time.\n+    fn blame_specific_part_of_expr_corresponding_to_generic_param(\n+        &self,\n+        param: ty::GenericArg<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n+        in_ty: ty::GenericArg<'tcx>,\n+    ) -> Result<&'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>> {\n+        if param == in_ty {\n+            // The types match exactly, so we have drilled as far as we can.\n+            return Ok(expr);\n+        }\n+\n+        let ty::GenericArgKind::Type(in_ty) = in_ty.unpack() else {\n+            return Err(expr);\n+        };\n+\n+        if let (hir::ExprKind::Tup(expr_elements), ty::Tuple(in_ty_elements)) =\n+            (&expr.kind, in_ty.kind())\n+        {\n+            if in_ty_elements.len() != expr_elements.len() {\n+                return Err(expr);\n+            }\n+            // Find out which of `in_ty_elements` refer to `param`.\n+            // FIXME: It may be better to take the first if there are multiple,\n+            // just so that the error points to a smaller expression.\n+            let Some((drill_expr, drill_ty)) = Self::is_iterator_singleton(expr_elements.iter().zip( in_ty_elements.iter()).filter(|(_expr_elem, in_ty_elem)| {\n+                Self::find_param_in_ty((*in_ty_elem).into(), param)\n+            })) else {\n+                // The param is not mentioned, or it is mentioned in multiple indexes.\n+                return Err(expr);\n+            };\n+\n+            return self.blame_specific_part_of_expr_corresponding_to_generic_param(\n+                param,\n+                drill_expr,\n+                drill_ty.into(),\n+            );\n+        }\n+\n+        if let (\n+            hir::ExprKind::Struct(expr_struct_path, expr_struct_fields, _expr_struct_rest),\n+            ty::Adt(in_ty_adt, in_ty_adt_generic_args),\n+        ) = (&expr.kind, in_ty.kind())\n+        {\n+            // First, confirm that this struct is the same one as in the types, and if so,\n+            // find the right variant.\n+            let Res::Def(expr_struct_def_kind, expr_struct_def_id) = self.typeck_results.borrow().qpath_res(expr_struct_path, expr.hir_id) else {\n+                return Err(expr);\n+            };\n+\n+            let variant_def_id = match expr_struct_def_kind {\n+                hir::def::DefKind::Struct => {\n+                    if in_ty_adt.did() != expr_struct_def_id {\n+                        // FIXME: Deal with type aliases?\n+                        return Err(expr);\n+                    }\n+                    expr_struct_def_id\n+                }\n+                hir::def::DefKind::Variant => {\n+                    // If this is a variant, its parent is the type definition.\n+                    if in_ty_adt.did() != self.tcx.parent(expr_struct_def_id) {\n+                        // FIXME: Deal with type aliases?\n+                        return Err(expr);\n+                    }\n+                    expr_struct_def_id\n+                }\n+                _ => {\n+                    return Err(expr);\n+                }\n+            };\n+\n+            // We need to know which of the generic parameters mentions our target param.\n+            // We expect that at least one of them does, since it is expected to be mentioned.\n+            let Some((drill_generic_index, generic_argument_type)) =\n+                Self::is_iterator_singleton(\n+                    in_ty_adt_generic_args.iter().enumerate().filter(\n+                        |(_index, in_ty_generic)| {\n+                            Self::find_param_in_ty(*in_ty_generic, param)\n+                        },\n+                    ),\n+                ) else {\n+                    return Err(expr);\n+                };\n+\n+            let struct_generic_parameters: &ty::Generics = self.tcx.generics_of(in_ty_adt.did());\n+            if drill_generic_index >= struct_generic_parameters.params.len() {\n+                return Err(expr);\n+            }\n+\n+            let param_to_point_at_in_struct = self.tcx.mk_param_from_def(\n+                struct_generic_parameters.param_at(drill_generic_index, self.tcx),\n+            );\n+\n+            // We make 3 steps:\n+            // Suppose we have a type like\n+            // ```ignore (just for demonstration)\n+            // struct ExampleStruct<T> {\n+            //   enabled: bool,\n+            //   item: Option<(usize, T, bool)>,\n+            // }\n+            //\n+            // f(ExampleStruct {\n+            //   enabled: false,\n+            //   item: Some((0, Box::new(String::new()), 1) }, true)),\n+            // });\n+            // ```\n+            // Here, `f` is passed a `ExampleStruct<Box<String>>`, but it wants\n+            // for `String: Copy`, which isn't true here.\n+            //\n+            // (1) First, we drill into `.item` and highlight that expression\n+            // (2) Then we use the template type `Option<(usize, T, bool)>` to\n+            //     drill into the `T`, arriving at a `Box<String>` expression.\n+            // (3) Then we keep going, drilling into this expression using our\n+            //     outer contextual information.\n+\n+            // (1) Find the (unique) field which mentions the type in our constraint:\n+            let (field_expr, field_type) = self\n+                .point_at_field_if_possible(\n+                    in_ty_adt.did(),\n+                    param_to_point_at_in_struct,\n+                    variant_def_id,\n+                    expr_struct_fields,\n+                )\n+                .ok_or(expr)?;\n+\n+            // (2) Continue drilling into the struct, ignoring the struct's\n+            // generic argument types.\n+            let expr = self.blame_specific_part_of_expr_corresponding_to_generic_param(\n+                param_to_point_at_in_struct,\n+                field_expr,\n+                field_type.into(),\n+            )?;\n+\n+            // (3) Continue drilling into the expression, having \"passed\n+            // through\" the struct entirely.\n+            return self.blame_specific_part_of_expr_corresponding_to_generic_param(\n+                param,\n+                expr,\n+                generic_argument_type,\n+            );\n+        }\n+\n+        if let (\n+            hir::ExprKind::Call(expr_callee, expr_args),\n+            ty::Adt(in_ty_adt, in_ty_adt_generic_args),\n+        ) = (&expr.kind, in_ty.kind())\n+        {\n+            let hir::ExprKind::Path(expr_callee_path) = &expr_callee.kind else {\n+                // FIXME: This case overlaps with another one worth handling,\n+                // which should happen above since it applies to non-ADTs:\n+                // we can drill down into regular generic functions.\n+                return Err(expr);\n+            };\n+            // This is (possibly) a constructor call, like `Some(...)` or `MyStruct(a, b, c)`.\n+\n+            let Res::Def(expr_struct_def_kind, expr_ctor_def_id) = self.typeck_results.borrow().qpath_res(expr_callee_path, expr_callee.hir_id) else {\n+                return Err(expr);\n+            };\n+\n+            let variant_def_id = match expr_struct_def_kind {\n+                hir::def::DefKind::Ctor(hir::def::CtorOf::Struct, hir::def::CtorKind::Fn) => {\n+                    if in_ty_adt.did() != self.tcx.parent(expr_ctor_def_id) {\n+                        // FIXME: Deal with type aliases?\n+                        return Err(expr);\n+                    }\n+                    self.tcx.parent(expr_ctor_def_id)\n+                }\n+                hir::def::DefKind::Ctor(hir::def::CtorOf::Variant, hir::def::CtorKind::Fn) => {\n+                    // If this is a variant, its parent is the type definition.\n+                    if in_ty_adt.did() != self.tcx.parent(expr_ctor_def_id) {\n+                        // FIXME: Deal with type aliases?\n+                        return Err(expr);\n+                    }\n+                    expr_ctor_def_id\n+                }\n+                _ => {\n+                    return Err(expr);\n+                }\n+            };\n+\n+            // We need to know which of the generic parameters mentions our target param.\n+            // We expect that at least one of them does, since it is expected to be mentioned.\n+            let Some((drill_generic_index, generic_argument_type)) =\n+                Self::is_iterator_singleton(\n+                    in_ty_adt_generic_args.iter().enumerate().filter(\n+                        |(_index, in_ty_generic)| {\n+                            Self::find_param_in_ty(*in_ty_generic, param)\n+                        },\n+                    ),\n+                ) else {\n+                    return Err(expr);\n+                };\n+\n+            let struct_generic_parameters: &ty::Generics = self.tcx.generics_of(in_ty_adt.did());\n+            if drill_generic_index >= struct_generic_parameters.params.len() {\n+                return Err(expr);\n+            }\n+\n+            let param_to_point_at_in_struct = self.tcx.mk_param_from_def(\n+                struct_generic_parameters.param_at(drill_generic_index, self.tcx),\n+            );\n+\n+            // We make 3 steps:\n+            // Suppose we have a type like\n+            // ```ignore (just for demonstration)\n+            // struct ExampleStruct<T> {\n+            //   enabled: bool,\n+            //   item: Option<(usize, T, bool)>,\n+            // }\n+            //\n+            // f(ExampleStruct {\n+            //   enabled: false,\n+            //   item: Some((0, Box::new(String::new()), 1) }, true)),\n+            // });\n+            // ```\n+            // Here, `f` is passed a `ExampleStruct<Box<String>>`, but it wants\n+            // for `String: Copy`, which isn't true here.\n+            //\n+            // (1) First, we drill into `.item` and highlight that expression\n+            // (2) Then we use the template type `Option<(usize, T, bool)>` to\n+            //     drill into the `T`, arriving at a `Box<String>` expression.\n+            // (3) Then we keep going, drilling into this expression using our\n+            //     outer contextual information.\n+\n+            // (1) Find the (unique) field index which mentions the type in our constraint:\n+            let Some((field_index, field_type)) = Self::is_iterator_singleton(\n+                in_ty_adt\n+                    .variant_with_id(variant_def_id)\n+                    .fields\n+                    .iter()\n+                    .map(|field| field.ty(self.tcx, *in_ty_adt_generic_args))\n+                    .enumerate()\n+                    .filter(|(_index, field_type)| Self::find_param_in_ty((*field_type).into(), param))\n+            ) else {\n+                return Err(expr);\n+            };\n+\n+            if field_index >= expr_args.len() {\n+                return Err(expr);\n+            }\n+\n+            // (2) Continue drilling into the struct, ignoring the struct's\n+            // generic argument types.\n+            let expr = self.blame_specific_part_of_expr_corresponding_to_generic_param(\n+                param_to_point_at_in_struct,\n+                &expr_args[field_index],\n+                field_type.into(),\n+            )?;\n+\n+            // (3) Continue drilling into the expression, having \"passed\n+            // through\" the struct entirely.\n+            return self.blame_specific_part_of_expr_corresponding_to_generic_param(\n+                param,\n+                expr,\n+                generic_argument_type,\n+            );\n+        }\n+\n+        // At this point, none of the basic patterns matched.\n+        // One major possibility which remains is that we have a function call.\n+        // In this case, it's often possible to dive deeper into the call to find something to blame,\n+        // but this is not always possible.\n+\n+        Err(expr)\n+    }\n+\n+    // FIXME: This can be made into a private, non-impl function later.\n+    /// Traverses the given ty (either a `ty::Ty` or a `ty::GenericArg`) and searches for references\n+    /// to the given `param_to_point_at`. Returns `true` if it finds any use of the param.\n+    pub fn find_param_in_ty(\n+        ty: ty::GenericArg<'tcx>,\n+        param_to_point_at: ty::GenericArg<'tcx>,\n+    ) -> bool {\n+        let mut walk = ty.walk();\n+        while let Some(arg) = walk.next() {\n+            if arg == param_to_point_at {\n+            return true;\n+        } else if let ty::GenericArgKind::Type(ty) = arg.unpack()\n+            && let ty::Alias(ty::Projection, ..) = ty.kind()\n+        {\n+            // This logic may seem a bit strange, but typically when\n+            // we have a projection type in a function signature, the\n+            // argument that's being passed into that signature is\n+            // not actually constraining that projection's substs in\n+            // a meaningful way. So we skip it, and see improvements\n+            // in some UI tests.\n+            walk.skip_current_subtree();\n+        }\n+        }\n+        false\n+    }\n+\n+    // FIXME: This can be made into a private, non-impl function later.\n+    /// Returns `Some(iterator.next())` if it has exactly one item, and `None` otherwise.\n+    pub fn is_iterator_singleton<T>(mut iterator: impl Iterator<Item = T>) -> Option<T> {\n+        match (iterator.next(), iterator.next()) {\n+            (_, Some(_)) => None,\n+            (first, _) => first,\n+        }\n+    }\n+}"}, {"sha": "1055ee953eae6f554036ddd90007e0813e7f312a", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -34,9 +34,10 @@ use rustc_trait_selection::traits::{self, ObligationCauseCode, SelectionContext}\n \n use std::iter;\n use std::mem;\n-use std::ops::ControlFlow;\n use std::slice;\n \n+use std::ops::ControlFlow;\n+\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(in super::super) fn check_casts(&mut self) {\n         // don't hold the borrow to deferred_cast_checks while checking to avoid borrow checker errors\n@@ -1843,7 +1844,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .into_iter()\n                         .flatten()\n                     {\n-                        if self.point_at_arg_if_possible(\n+                        if self.blame_specific_arg_if_possible(\n                                 error,\n                                 def_id,\n                                 param,\n@@ -1873,7 +1874,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .into_iter()\n                     .flatten()\n                 {\n-                    if self.point_at_arg_if_possible(\n+                    if self.blame_specific_arg_if_possible(\n                         error,\n                         def_id,\n                         param,\n@@ -1898,16 +1899,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     for param in\n                         [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n                     {\n-                        if let Some(param) = param\n-                            && self.point_at_field_if_possible(\n-                                error,\n+                        if let Some(param) = param {\n+                            let refined_expr = self.point_at_field_if_possible(\n                                 def_id,\n                                 param,\n                                 variant_def_id,\n                                 fields,\n-                            )\n-                        {\n-                            return true;\n+                            );\n+\n+                            match refined_expr {\n+                                None => {}\n+                                Some((refined_expr, _)) => {\n+                                    error.obligation.cause.span = refined_expr\n+                                        .span\n+                                        .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n+                                        .unwrap_or(refined_expr.span);\n+                                    return true;\n+                                }\n+                            }\n                         }\n                     }\n                 }\n@@ -1940,7 +1949,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn point_at_arg_if_possible(\n+    /// - `blame_specific_*` means that the function will recursively traverse the expression,\n+    /// looking for the most-specific-possible span to blame.\n+    ///\n+    /// - `point_at_*` means that the function will only go \"one level\", pointing at the specific\n+    /// expression mentioned.\n+    ///\n+    /// `blame_specific_arg_if_possible` will find the most-specific expression anywhere inside\n+    /// the provided function call expression, and mark it as responsible for the fullfillment\n+    /// error.\n+    fn blame_specific_arg_if_possible(\n         &self,\n         error: &mut traits::FulfillmentError<'tcx>,\n         def_id: DefId,\n@@ -1959,13 +1977,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .inputs()\n             .iter()\n             .enumerate()\n-            .filter(|(_, ty)| find_param_in_ty(**ty, param_to_point_at))\n+            .filter(|(_, ty)| Self::find_param_in_ty((**ty).into(), param_to_point_at))\n             .collect();\n         // If there's one field that references the given generic, great!\n         if let [(idx, _)] = args_referencing_param.as_slice()\n             && let Some(arg) = receiver\n                 .map_or(args.get(*idx), |rcvr| if *idx == 0 { Some(rcvr) } else { args.get(*idx - 1) }) {\n+\n             error.obligation.cause.span = arg.span.find_ancestor_in_same_ctxt(error.obligation.cause.span).unwrap_or(arg.span);\n+\n+            if let hir::Node::Expr(arg_expr) = self.tcx.hir().get(arg.hir_id) {\n+                // This is more specific than pointing at the entire argument.\n+                self.blame_specific_expr_if_possible(error, arg_expr)\n+            }\n+\n             error.obligation.cause.map_code(|parent_code| {\n                 ObligationCauseCode::FunctionArgumentObligation {\n                     arg_hir_id: arg.hir_id,\n@@ -1983,14 +2008,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         false\n     }\n \n-    fn point_at_field_if_possible(\n+    // FIXME: Make this private and move to mod adjust_fulfillment_errors\n+    pub fn point_at_field_if_possible(\n         &self,\n-        error: &mut traits::FulfillmentError<'tcx>,\n         def_id: DefId,\n         param_to_point_at: ty::GenericArg<'tcx>,\n         variant_def_id: DefId,\n         expr_fields: &[hir::ExprField<'tcx>],\n-    ) -> bool {\n+    ) -> Option<(&'tcx hir::Expr<'tcx>, Ty<'tcx>)> {\n         let def = self.tcx.adt_def(def_id);\n \n         let identity_substs = ty::InternalSubsts::identity_for_item(self.tcx, def_id);\n@@ -2000,7 +2025,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .iter()\n             .filter(|field| {\n                 let field_ty = field.ty(self.tcx, identity_substs);\n-                find_param_in_ty(field_ty, param_to_point_at)\n+                Self::find_param_in_ty(field_ty.into(), param_to_point_at)\n             })\n             .collect();\n \n@@ -2010,17 +2035,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // same rules that check_expr_struct uses for macro hygiene.\n                 if self.tcx.adjust_ident(expr_field.ident, variant_def_id) == field.ident(self.tcx)\n                 {\n-                    error.obligation.cause.span = expr_field\n-                        .expr\n-                        .span\n-                        .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n-                        .unwrap_or(expr_field.span);\n-                    return true;\n+                    return Some((expr_field.expr, self.tcx.type_of(field.did)));\n                 }\n             }\n         }\n \n-        false\n+        None\n     }\n \n     fn point_at_path_if_possible(\n@@ -2240,23 +2260,3 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n }\n-\n-fn find_param_in_ty<'tcx>(ty: Ty<'tcx>, param_to_point_at: ty::GenericArg<'tcx>) -> bool {\n-    let mut walk = ty.walk();\n-    while let Some(arg) = walk.next() {\n-        if arg == param_to_point_at {\n-            return true;\n-        } else if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-            && let ty::Alias(ty::Projection, ..) = ty.kind()\n-        {\n-            // This logic may seem a bit strange, but typically when\n-            // we have a projection type in a function signature, the\n-            // argument that's being passed into that signature is\n-            // not actually constraining that projection's substs in\n-            // a meaningful way. So we skip it, and see improvements\n-            // in some UI tests.\n-            walk.skip_current_subtree();\n-        }\n-    }\n-    false\n-}"}, {"sha": "1e14eddd4c86ef511732e116a9dfeafe69b2ba8e", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1,4 +1,5 @@\n mod _impl;\n+mod adjust_fulfillment_errors;\n mod arg_matrix;\n mod checks;\n mod suggestions;"}, {"sha": "51e3e3ec73db9d994a84c512645bd2ffbc2abca2", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 83, "deletions": 6, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -3,7 +3,7 @@ use super::FnCtxt;\n use crate::errors::{AddReturnTypeSuggestion, ExpectedReturnTypeLabel};\n use crate::method::probe::{IsSuggestion, Mode, ProbeScope};\n use rustc_ast::util::parser::{ExprPrecedence, PREC_POSTFIX};\n-use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n+use rustc_errors::{fluent, Applicability, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind};\n use rustc_hir::lang_items::LangItem;\n@@ -13,6 +13,7 @@ use rustc_hir::{\n use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::traits::{self, StatementAsExpression};\n use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{\n     self, suggest_constraining_type_params, Binder, DefIdTree, IsSuggestable, ToPredicate, Ty,\n     TypeVisitable,\n@@ -414,11 +415,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if let ty::Adt(adt, _) = peeled.kind()\n                     && Some(adt.did()) == self.tcx.lang_items().string()\n                 {\n+                    let sugg = if ref_cnt == 0 {\n+                        \".as_deref()\"\n+                    } else {\n+                        \".map(|x| x.as_str())\"\n+                    };\n                     err.span_suggestion_verbose(\n                         expr.span.shrink_to_hi(),\n-                        \"try converting the passed type into a `&str`\",\n-                        format!(\".map(|x| &*{}x)\", \"*\".repeat(ref_cnt)),\n-                        Applicability::MaybeIncorrect,\n+                        fluent::hir_typeck_convert_to_str,\n+                        sugg,\n+                        Applicability::MachineApplicable,\n                     );\n                     return true;\n                 }\n@@ -682,7 +688,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 return true;\n             }\n             &hir::FnRetTy::DefaultReturn(span) if expected.is_unit() => {\n-                if found.is_suggestable(self.tcx, false) {\n+                if let Some(found) = found.make_suggestable(self.tcx, false) {\n                     err.subdiagnostic(AddReturnTypeSuggestion::Add { span, found: found.to_string() });\n                     return true;\n                 } else if let ty::Closure(_, substs) = found.kind()\n@@ -699,10 +705,38 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n             hir::FnRetTy::Return(ty) => {\n+                let span = ty.span;\n+\n+                if let hir::TyKind::OpaqueDef(item_id, ..) = ty.kind\n+                && let hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::OpaqueTy(op_ty),\n+                    ..\n+                }) = self.tcx.hir().get(item_id.hir_id())\n+                && let hir::OpaqueTy {\n+                    bounds: [bound], ..\n+                } = op_ty\n+                && let hir::GenericBound::LangItemTrait(\n+                    hir::LangItem::Future, _, _, generic_args) = bound\n+                && let hir::GenericArgs { bindings: [ty_binding], .. } = generic_args\n+                && let hir::TypeBinding { kind, .. } = ty_binding\n+                && let hir::TypeBindingKind::Equality { term } = kind\n+                && let hir::Term::Ty(term_ty) = term {\n+                    // Check if async function's return type was omitted.\n+                    // Don't emit suggestions if the found type is `impl Future<...>`.\n+                    debug!(\"suggest_missing_return_type: found = {:?}\", found);\n+                    if found.is_suggestable(self.tcx, false) {\n+                        if term_ty.span.is_empty() {\n+                            err.subdiagnostic(AddReturnTypeSuggestion::Add { span, found: found.to_string() });\n+                            return true;\n+                        } else {\n+                            err.subdiagnostic(ExpectedReturnTypeLabel::Other { span, expected });\n+                        }\n+                    }\n+                }\n+\n                 // Only point to return type if the expected type is the return type, as if they\n                 // are not, the expectation must have been caused by something else.\n                 debug!(\"suggest_missing_return_type: return type {:?} node {:?}\", ty, ty.kind);\n-                let span = ty.span;\n                 let ty = self.astconv().ast_ty_to_ty(ty);\n                 debug!(\"suggest_missing_return_type: return type {:?}\", ty);\n                 debug!(\"suggest_missing_return_type: expected type {:?}\", ty);\n@@ -1239,6 +1273,49 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// Suggest providing `std::ptr::null()` or `std::ptr::null_mut()` if they\n+    /// pass in a literal 0 to an raw pointer.\n+    #[instrument(skip(self, err))]\n+    pub(crate) fn suggest_null_ptr_for_literal_zero_given_to_ptr_arg(\n+        &self,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+        expected_ty: Ty<'tcx>,\n+    ) -> bool {\n+        // Expected type needs to be a raw pointer.\n+        let ty::RawPtr(ty::TypeAndMut { mutbl, .. }) = expected_ty.kind() else {\n+            return false;\n+        };\n+\n+        // Provided expression needs to be a literal `0`.\n+        let ExprKind::Lit(Spanned {\n+            node: rustc_ast::LitKind::Int(0, _),\n+            span,\n+        }) = expr.kind else {\n+            return false;\n+        };\n+\n+        // We need to find a null pointer symbol to suggest\n+        let null_sym = match mutbl {\n+            hir::Mutability::Not => sym::ptr_null,\n+            hir::Mutability::Mut => sym::ptr_null_mut,\n+        };\n+        let Some(null_did) = self.tcx.get_diagnostic_item(null_sym) else {\n+            return false;\n+        };\n+        let null_path_str = with_no_trimmed_paths!(self.tcx.def_path_str(null_did));\n+\n+        // We have satisfied all requirements to provide a suggestion. Emit it.\n+        err.span_suggestion(\n+            span,\n+            format!(\"if you meant to create a null pointer, use `{null_path_str}()`\"),\n+            null_path_str + \"()\",\n+            Applicability::MachineApplicable,\n+        );\n+\n+        true\n+    }\n+\n     pub(crate) fn suggest_associated_const(\n         &self,\n         err: &mut Diagnostic,"}, {"sha": "9ab29a6778fc91eceb2a99bd4ae9f9cbba5683ca", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1563,6 +1563,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                                     traits::ImplDerivedObligationCause {\n                                         derived,\n                                         impl_def_id,\n+                                        impl_def_predicate_index: None,\n                                         span,\n                                     },\n                                 ))"}, {"sha": "ba72aefe39c169f7472b3860dca791fe644b5e5d", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -490,9 +490,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                             if let Some(output_def_id) = output_def_id\n                                                 && let Some(trait_def_id) = trait_def_id\n                                                 && self.tcx.parent(output_def_id) == trait_def_id\n-                                                && output_ty.is_suggestable(self.tcx, false)\n+                                                && let Some(output_ty) = output_ty.make_suggestable(self.tcx, false)\n                                             {\n-                                                Some((\"Output\", *output_ty))\n+                                                Some((\"Output\", output_ty))\n                                             } else {\n                                                 None\n                                             }"}, {"sha": "02ac83a5e8b25b3f32ecdbfb62d81013c34a71f3", "filename": "compiler/rustc_infer/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_infer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_infer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2FCargo.toml?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -15,7 +15,6 @@ rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n-rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "2355234637c40790013f90ef4a521190aa2cee7c", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 61, "deletions": 68, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -140,79 +140,21 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n         }\n     }\n \n+    #[inline]\n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         if !t.needs_infer() && !t.has_erasable_regions() {\n-            return t;\n-        }\n-\n-        let tcx = self.infcx.tcx;\n-\n-        match *t.kind() {\n-            ty::Infer(ty::TyVar(v)) => {\n-                let opt_ty = self.infcx.inner.borrow_mut().type_variables().probe(v).known();\n-                self.freshen_ty(opt_ty, ty::TyVar(v), ty::FreshTy)\n-            }\n+            t\n+        } else {\n+            match *t.kind() {\n+                ty::Infer(v) => self.fold_infer_ty(v).unwrap_or(t),\n \n-            ty::Infer(ty::IntVar(v)) => self.freshen_ty(\n-                self.infcx\n-                    .inner\n-                    .borrow_mut()\n-                    .int_unification_table()\n-                    .probe_value(v)\n-                    .map(|v| v.to_type(tcx)),\n-                ty::IntVar(v),\n-                ty::FreshIntTy,\n-            ),\n+                // This code is hot enough that a non-debug assertion here makes a noticeable\n+                // difference on benchmarks like `wg-grammar`.\n+                #[cfg(debug_assertions)]\n+                ty::Placeholder(..) | ty::Bound(..) => bug!(\"unexpected type {:?}\", t),\n \n-            ty::Infer(ty::FloatVar(v)) => self.freshen_ty(\n-                self.infcx\n-                    .inner\n-                    .borrow_mut()\n-                    .float_unification_table()\n-                    .probe_value(v)\n-                    .map(|v| v.to_type(tcx)),\n-                ty::FloatVar(v),\n-                ty::FreshFloatTy,\n-            ),\n-\n-            ty::Infer(ty::FreshTy(ct) | ty::FreshIntTy(ct) | ty::FreshFloatTy(ct)) => {\n-                if ct >= self.ty_freshen_count {\n-                    bug!(\n-                        \"Encountered a freshend type with id {} \\\n-                          but our counter is only at {}\",\n-                        ct,\n-                        self.ty_freshen_count\n-                    );\n-                }\n-                t\n+                _ => t.super_fold_with(self),\n             }\n-\n-            ty::Generator(..)\n-            | ty::Bool\n-            | ty::Char\n-            | ty::Int(..)\n-            | ty::Uint(..)\n-            | ty::Float(..)\n-            | ty::Adt(..)\n-            | ty::Str\n-            | ty::Error(_)\n-            | ty::Array(..)\n-            | ty::Slice(..)\n-            | ty::RawPtr(..)\n-            | ty::Ref(..)\n-            | ty::FnDef(..)\n-            | ty::FnPtr(_)\n-            | ty::Dynamic(..)\n-            | ty::Never\n-            | ty::Tuple(..)\n-            | ty::Alias(..)\n-            | ty::Foreign(..)\n-            | ty::Param(..)\n-            | ty::Closure(..)\n-            | ty::GeneratorWitnessMIR(..)\n-            | ty::GeneratorWitness(..) => t.super_fold_with(self),\n-\n-            ty::Placeholder(..) | ty::Bound(..) => bug!(\"unexpected type {:?}\", t),\n         }\n     }\n \n@@ -253,3 +195,54 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n         }\n     }\n }\n+\n+impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n+    // This is separate from `fold_ty` to keep that method small and inlinable.\n+    #[inline(never)]\n+    fn fold_infer_ty(&mut self, v: ty::InferTy) -> Option<Ty<'tcx>> {\n+        match v {\n+            ty::TyVar(v) => {\n+                let opt_ty = self.infcx.inner.borrow_mut().type_variables().probe(v).known();\n+                Some(self.freshen_ty(opt_ty, ty::TyVar(v), ty::FreshTy))\n+            }\n+\n+            ty::IntVar(v) => Some(\n+                self.freshen_ty(\n+                    self.infcx\n+                        .inner\n+                        .borrow_mut()\n+                        .int_unification_table()\n+                        .probe_value(v)\n+                        .map(|v| v.to_type(self.infcx.tcx)),\n+                    ty::IntVar(v),\n+                    ty::FreshIntTy,\n+                ),\n+            ),\n+\n+            ty::FloatVar(v) => Some(\n+                self.freshen_ty(\n+                    self.infcx\n+                        .inner\n+                        .borrow_mut()\n+                        .float_unification_table()\n+                        .probe_value(v)\n+                        .map(|v| v.to_type(self.infcx.tcx)),\n+                    ty::FloatVar(v),\n+                    ty::FreshFloatTy,\n+                ),\n+            ),\n+\n+            ty::FreshTy(ct) | ty::FreshIntTy(ct) | ty::FreshFloatTy(ct) => {\n+                if ct >= self.ty_freshen_count {\n+                    bug!(\n+                        \"Encountered a freshend type with id {} \\\n+                          but our counter is only at {}\",\n+                        ct,\n+                        self.ty_freshen_count\n+                    );\n+                }\n+                None\n+            }\n+        }\n+    }\n+}"}, {"sha": "8e0bcff8d0a89cd794fd77d8902dd7d05fb970b7", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -30,7 +30,7 @@ use rustc_middle::ty::relate::RelateResult;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef};\n use rustc_middle::ty::visit::TypeVisitable;\n pub use rustc_middle::ty::IntVarValue;\n-use rustc_middle::ty::{self, GenericParamDefKind, InferConst, Ty, TyCtxt};\n+use rustc_middle::ty::{self, GenericParamDefKind, InferConst, InferTy, Ty, TyCtxt};\n use rustc_middle::ty::{ConstVid, FloatVid, IntVid, TyVid};\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n@@ -1389,8 +1389,8 @@ impl<'tcx> InferCtxt<'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        if !value.needs_infer() {\n-            return value; // Avoid duplicated subst-folding.\n+        if !value.has_non_region_infer() {\n+            return value;\n         }\n         let mut r = resolve::OpportunisticVarResolver::new(self);\n         value.fold_with(&mut r)\n@@ -1870,9 +1870,33 @@ impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n     /// If `ty` is a type variable of some kind, resolve it one level\n     /// (but do not resolve types found in the result). If `typ` is\n     /// not a type variable, just return it unmodified.\n+    #[inline]\n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        match *ty.kind() {\n-            ty::Infer(ty::TyVar(v)) => {\n+        if let ty::Infer(v) = ty.kind() { self.fold_infer_ty(*v).unwrap_or(ty) } else { ty }\n+    }\n+\n+    fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+        if let ty::ConstKind::Infer(InferConst::Var(vid)) = ct.kind() {\n+            self.infcx\n+                .inner\n+                .borrow_mut()\n+                .const_unification_table()\n+                .probe_value(vid)\n+                .val\n+                .known()\n+                .unwrap_or(ct)\n+        } else {\n+            ct\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n+    // This is separate from `fold_ty` to keep that method small and inlinable.\n+    #[inline(never)]\n+    fn fold_infer_ty(&mut self, v: InferTy) -> Option<Ty<'tcx>> {\n+        match v {\n+            ty::TyVar(v) => {\n                 // Not entirely obvious: if `typ` is a type variable,\n                 // it can be resolved to an int/float variable, which\n                 // can then be recursively resolved, hence the\n@@ -1886,41 +1910,26 @@ impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n                 // Note: if these two lines are combined into one we get\n                 // dynamic borrow errors on `self.inner`.\n                 let known = self.infcx.inner.borrow_mut().type_variables().probe(v).known();\n-                known.map_or(ty, |t| self.fold_ty(t))\n+                known.map(|t| self.fold_ty(t))\n             }\n \n-            ty::Infer(ty::IntVar(v)) => self\n+            ty::IntVar(v) => self\n                 .infcx\n                 .inner\n                 .borrow_mut()\n                 .int_unification_table()\n                 .probe_value(v)\n-                .map_or(ty, |v| v.to_type(self.infcx.tcx)),\n+                .map(|v| v.to_type(self.infcx.tcx)),\n \n-            ty::Infer(ty::FloatVar(v)) => self\n+            ty::FloatVar(v) => self\n                 .infcx\n                 .inner\n                 .borrow_mut()\n                 .float_unification_table()\n                 .probe_value(v)\n-                .map_or(ty, |v| v.to_type(self.infcx.tcx)),\n+                .map(|v| v.to_type(self.infcx.tcx)),\n \n-            _ => ty,\n-        }\n-    }\n-\n-    fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n-        if let ty::ConstKind::Infer(InferConst::Var(vid)) = ct.kind() {\n-            self.infcx\n-                .inner\n-                .borrow_mut()\n-                .const_unification_table()\n-                .probe_value(vid)\n-                .val\n-                .known()\n-                .unwrap_or(ct)\n-        } else {\n-            ct\n+            ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_) => None,\n         }\n     }\n }"}, {"sha": "a2cfe8d88816cb076d97005521da1f0796e0047e", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -817,12 +817,13 @@ impl<'tcx, D> ConstEquateRelation<'tcx> for TypeRelating<'_, 'tcx, D>\n where\n     D: TypeRelatingDelegate<'tcx>,\n {\n-    fn const_equate_obligation(&mut self, _a: ty::Const<'tcx>, _b: ty::Const<'tcx>) {\n-        // We don't have to worry about the equality of consts during borrow checking\n-        // as consts always have a static lifetime.\n-        // FIXME(oli-obk): is this really true? We can at least have HKL and with\n-        // inline consts we may have further lifetimes that may be unsound to treat as\n-        // 'static.\n+    fn const_equate_obligation(&mut self, a: ty::Const<'tcx>, b: ty::Const<'tcx>) {\n+        self.delegate.register_obligations(vec![Obligation::new(\n+            self.tcx(),\n+            ObligationCause::dummy(),\n+            self.param_env(),\n+            ty::Binder::dummy(ty::PredicateKind::ConstEquate(a, b)),\n+        )]);\n     }\n }\n "}, {"sha": "a39a40cf9abe242f22408b62c077e2d7ef32160e", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -16,26 +16,29 @@ use std::ops::ControlFlow;\n /// useful for printing messages etc but also required at various\n /// points for correctness.\n pub struct OpportunisticVarResolver<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'tcx>,\n+    // The shallow resolver is used to resolve inference variables at every\n+    // level of the type.\n+    shallow_resolver: crate::infer::ShallowResolver<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> OpportunisticVarResolver<'a, 'tcx> {\n     #[inline]\n     pub fn new(infcx: &'a InferCtxt<'tcx>) -> Self {\n-        OpportunisticVarResolver { infcx }\n+        OpportunisticVarResolver { shallow_resolver: crate::infer::ShallowResolver { infcx } }\n     }\n }\n \n impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticVarResolver<'a, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n-        self.infcx.tcx\n+        TypeFolder::tcx(&self.shallow_resolver)\n     }\n \n+    #[inline]\n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         if !t.has_non_region_infer() {\n             t // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n-            let t = self.infcx.shallow_resolve(t);\n+            let t = self.shallow_resolver.fold_ty(t);\n             t.super_fold_with(self)\n         }\n     }\n@@ -44,7 +47,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticVarResolver<'a, 'tcx> {\n         if !ct.has_non_region_infer() {\n             ct // micro-optimize -- if there is nothing in this const that this fold affects...\n         } else {\n-            let ct = self.infcx.shallow_resolve(ct);\n+            let ct = self.shallow_resolver.fold_const(ct);\n             ct.super_fold_with(self)\n         }\n     }"}, {"sha": "18a966449aa72f2e9432ab3c833d8bdc1ba22bae", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -145,30 +145,32 @@ impl<'tcx> Elaborator<'tcx> {\n                 // Get predicates declared on the trait.\n                 let predicates = tcx.super_predicates_of(data.def_id());\n \n-                let obligations = predicates.predicates.iter().map(|&(mut pred, span)| {\n-                    // when parent predicate is non-const, elaborate it to non-const predicates.\n-                    if data.constness == ty::BoundConstness::NotConst {\n-                        pred = pred.without_const(tcx);\n-                    }\n-\n-                    let cause = obligation.cause.clone().derived_cause(\n-                        bound_predicate.rebind(data),\n-                        |derived| {\n-                            traits::ImplDerivedObligation(Box::new(\n-                                traits::ImplDerivedObligationCause {\n-                                    derived,\n-                                    impl_def_id: data.def_id(),\n-                                    span,\n-                                },\n-                            ))\n-                        },\n-                    );\n-                    predicate_obligation(\n-                        pred.subst_supertrait(tcx, &bound_predicate.rebind(data.trait_ref)),\n-                        obligation.param_env,\n-                        cause,\n-                    )\n-                });\n+                let obligations =\n+                    predicates.predicates.iter().enumerate().map(|(index, &(mut pred, span))| {\n+                        // when parent predicate is non-const, elaborate it to non-const predicates.\n+                        if data.constness == ty::BoundConstness::NotConst {\n+                            pred = pred.without_const(tcx);\n+                        }\n+\n+                        let cause = obligation.cause.clone().derived_cause(\n+                            bound_predicate.rebind(data),\n+                            |derived| {\n+                                traits::ImplDerivedObligation(Box::new(\n+                                    traits::ImplDerivedObligationCause {\n+                                        derived,\n+                                        impl_def_id: data.def_id(),\n+                                        impl_def_predicate_index: Some(index),\n+                                        span,\n+                                    },\n+                                ))\n+                            },\n+                        );\n+                        predicate_obligation(\n+                            pred.subst_supertrait(tcx, &bound_predicate.rebind(data.trait_ref)),\n+                            obligation.param_env,\n+                            cause,\n+                        )\n+                    });\n                 debug!(?data, ?obligations, \"super_predicates\");\n \n                 // Only keep those bounds that we haven't already seen."}, {"sha": "955ab3c4680abded5dbdf0c1782c0a9d73a6749a", "filename": "compiler/rustc_interface/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2FCargo.toml?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -20,7 +20,6 @@ rustc_macros = { path = \"../rustc_macros\" }\n rustc_parse = { path = \"../rustc_parse\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n-rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_ast_lowering = { path = \"../rustc_ast_lowering\" }\n rustc_ast_passes = { path = \"../rustc_ast_passes\" }"}, {"sha": "2a373ebc1324da0112c47002f85b2b1e86e62b5f", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1,9 +1,4 @@\n-use crate::errors::{\n-    CantEmitMIR, EmojiIdentifier, ErrorWritingDependencies, FerrisIdentifier,\n-    GeneratedFileConflictsWithDirectory, InputFileWouldBeOverWritten, MixedBinCrate,\n-    MixedProcMacroCrate, OutDirError, ProcMacroCratePanicAbort, ProcMacroDocWithoutArg,\n-    TempsDirError,\n-};\n+use crate::errors;\n use crate::interface::{Compiler, Result};\n use crate::proc_macro_decls;\n use crate::util;\n@@ -374,15 +369,15 @@ pub fn configure_and_expand(\n \n     if crate_types.len() > 1 {\n         if is_executable_crate {\n-            sess.emit_err(MixedBinCrate);\n+            sess.emit_err(errors::MixedBinCrate);\n         }\n         if is_proc_macro_crate {\n-            sess.emit_err(MixedProcMacroCrate);\n+            sess.emit_err(errors::MixedProcMacroCrate);\n         }\n     }\n \n     if is_proc_macro_crate && sess.panic_strategy() == PanicStrategy::Abort {\n-        sess.emit_warning(ProcMacroCratePanicAbort);\n+        sess.emit_warning(errors::ProcMacroCratePanicAbort);\n     }\n \n     // For backwards compatibility, we don't try to run proc macro injection\n@@ -392,7 +387,7 @@ pub fn configure_and_expand(\n     // However, we do emit a warning, to let such users know that they should\n     // start passing '--crate-type proc-macro'\n     if has_proc_macro_decls && sess.opts.actually_rustdoc && !is_proc_macro_crate {\n-        sess.emit_warning(ProcMacroDocWithoutArg);\n+        sess.emit_warning(errors::ProcMacroDocWithoutArg);\n     } else {\n         krate = sess.time(\"maybe_create_a_macro_crate\", || {\n             let is_test_crate = sess.opts.test;\n@@ -441,9 +436,9 @@ pub fn configure_and_expand(\n             spans.sort();\n             if ident == sym::ferris {\n                 let first_span = spans[0];\n-                sess.emit_err(FerrisIdentifier { spans, first_span });\n+                sess.emit_err(errors::FerrisIdentifier { spans, first_span });\n             } else {\n-                sess.emit_err(EmojiIdentifier { spans, ident });\n+                sess.emit_err(errors::EmojiIdentifier { spans, ident });\n             }\n         }\n     });\n@@ -655,7 +650,7 @@ fn write_out_deps(\n             }\n         }\n         Err(error) => {\n-            sess.emit_fatal(ErrorWritingDependencies { path: &deps_filename, error });\n+            sess.emit_fatal(errors::ErrorWritingDependencies { path: &deps_filename, error });\n         }\n     }\n }\n@@ -676,17 +671,20 @@ fn output_filenames(tcx: TyCtxt<'_>, (): ()) -> Arc<OutputFilenames> {\n     if let Some(ref input_path) = sess.io.input.opt_path() {\n         if sess.opts.will_create_output_file() {\n             if output_contains_path(&output_paths, input_path) {\n-                sess.emit_fatal(InputFileWouldBeOverWritten { path: input_path });\n+                sess.emit_fatal(errors::InputFileWouldBeOverWritten { path: input_path });\n             }\n             if let Some(ref dir_path) = output_conflicts_with_dir(&output_paths) {\n-                sess.emit_fatal(GeneratedFileConflictsWithDirectory { input_path, dir_path });\n+                sess.emit_fatal(errors::GeneratedFileConflictsWithDirectory {\n+                    input_path,\n+                    dir_path,\n+                });\n             }\n         }\n     }\n \n     if let Some(ref dir) = sess.io.temps_dir {\n         if fs::create_dir_all(dir).is_err() {\n-            sess.emit_fatal(TempsDirError);\n+            sess.emit_fatal(errors::TempsDirError);\n         }\n     }\n \n@@ -698,7 +696,7 @@ fn output_filenames(tcx: TyCtxt<'_>, (): ()) -> Arc<OutputFilenames> {\n     if !only_dep_info {\n         if let Some(ref dir) = sess.io.output_dir {\n             if fs::create_dir_all(dir).is_err() {\n-                sess.emit_fatal(OutDirError);\n+                sess.emit_fatal(errors::OutDirError);\n             }\n         }\n     }\n@@ -977,7 +975,7 @@ pub fn start_codegen<'tcx>(\n \n     if tcx.sess.opts.output_types.contains_key(&OutputType::Mir) {\n         if let Err(error) = rustc_mir_transform::dump_mir::emit_mir(tcx) {\n-            tcx.sess.emit_err(CantEmitMIR { error });\n+            tcx.sess.emit_err(errors::CantEmitMIR { error });\n             tcx.sess.abort_if_errors();\n         }\n     }"}, {"sha": "2e447b900e1174b79ed142bb3c1cbf0d664e34ba", "filename": "compiler/rustc_lint/src/lints.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flints.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1402,6 +1402,21 @@ pub struct UnusedDef<'a, 'b> {\n     pub cx: &'a LateContext<'b>,\n     pub def_id: DefId,\n     pub note: Option<Symbol>,\n+    pub suggestion: Option<UnusedDefSuggestion>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum UnusedDefSuggestion {\n+    #[suggestion(\n+        suggestion,\n+        style = \"verbose\",\n+        code = \"let _ = \",\n+        applicability = \"machine-applicable\"\n+    )]\n+    Default {\n+        #[primary_span]\n+        span: Span,\n+    },\n }\n \n // Needed because of def_path_str\n@@ -1417,6 +1432,9 @@ impl<'a> DecorateLint<'a, ()> for UnusedDef<'_, '_> {\n         if let Some(note) = self.note {\n             diag.note(note.as_str());\n         }\n+        if let Some(sugg) = self.suggestion {\n+            diag.subdiagnostic(sugg);\n+        }\n         diag\n     }\n "}, {"sha": "88ea293444c1758e5e28a5e420323116e600d2f7", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1,7 +1,7 @@\n use crate::lints::{\n     PathStatementDrop, PathStatementDropSub, PathStatementNoEffect, UnusedAllocationDiag,\n-    UnusedAllocationMutDiag, UnusedClosure, UnusedDef, UnusedDelim, UnusedDelimSuggestion,\n-    UnusedGenerator, UnusedImportBracesDiag, UnusedOp, UnusedResult,\n+    UnusedAllocationMutDiag, UnusedClosure, UnusedDef, UnusedDefSuggestion, UnusedDelim,\n+    UnusedDelimSuggestion, UnusedGenerator, UnusedImportBracesDiag, UnusedOp, UnusedResult,\n };\n use crate::Lint;\n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n@@ -418,6 +418,19 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                     );\n                 }\n                 MustUsePath::Def(span, def_id, reason) => {\n+                    let suggestion = if matches!(\n+                        cx.tcx.get_diagnostic_name(*def_id),\n+                        Some(sym::add)\n+                            | Some(sym::sub)\n+                            | Some(sym::mul)\n+                            | Some(sym::div)\n+                            | Some(sym::rem)\n+                            | Some(sym::neg),\n+                    ) {\n+                        Some(UnusedDefSuggestion::Default { span: span.shrink_to_lo() })\n+                    } else {\n+                        None\n+                    };\n                     cx.emit_spanned_lint(\n                         UNUSED_MUST_USE,\n                         *span,\n@@ -427,6 +440,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                             cx,\n                             def_id: *def_id,\n                             note: *reason,\n+                            suggestion,\n                         },\n                     );\n                 }\n@@ -495,6 +509,7 @@ enum UnusedDelimsCtx {\n     ArrayLenExpr,\n     AnonConst,\n     MatchArmExpr,\n+    IndexExpr,\n }\n \n impl From<UnusedDelimsCtx> for &'static str {\n@@ -514,6 +529,7 @@ impl From<UnusedDelimsCtx> for &'static str {\n             UnusedDelimsCtx::LetScrutineeExpr => \"`let` scrutinee expression\",\n             UnusedDelimsCtx::ArrayLenExpr | UnusedDelimsCtx::AnonConst => \"const expression\",\n             UnusedDelimsCtx::MatchArmExpr => \"match arm expression\",\n+            UnusedDelimsCtx::IndexExpr => \"index expression\",\n         }\n     }\n }\n@@ -661,6 +677,10 @@ trait UnusedDelimLint {\n         keep_space: (bool, bool),\n     ) {\n         let primary_span = if let Some((lo, hi)) = spans {\n+            if hi.is_empty() {\n+                // do not point at delims that do not exist\n+                return;\n+            }\n             MultiSpan::from(vec![lo, hi])\n         } else {\n             MultiSpan::from(value_span)\n@@ -733,6 +753,8 @@ trait UnusedDelimLint {\n                 (value, UnusedDelimsCtx::ReturnValue, false, Some(left), None)\n             }\n \n+            Index(_, ref value) => (value, UnusedDelimsCtx::IndexExpr, false, None, None),\n+\n             Assign(_, ref value, _) | AssignOp(.., ref value) => {\n                 (value, UnusedDelimsCtx::AssignedValue, false, None, None)\n             }"}, {"sha": "15a4273fc5918e682a97dcb78e53439737b091f4", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -21,6 +21,9 @@\n #include \"llvm/Passes/StandardInstrumentations.h\"\n #include \"llvm/Support/CBindingWrapping.h\"\n #include \"llvm/Support/FileSystem.h\"\n+#if LLVM_VERSION_GE(17, 0)\n+#include \"llvm/Support/VirtualFileSystem.h\"\n+#endif\n #include \"llvm/Support/Host.h\"\n #if LLVM_VERSION_LT(14, 0)\n #include \"llvm/Support/TargetRegistry.h\"\n@@ -651,21 +654,40 @@ LLVMRustOptimize(\n   Optional<PGOOptions> PGOOpt;\n #else\n   std::optional<PGOOptions> PGOOpt;\n+#endif\n+#if LLVM_VERSION_GE(17, 0)\n+  auto FS = vfs::getRealFileSystem();\n #endif\n   if (PGOGenPath) {\n     assert(!PGOUsePath && !PGOSampleUsePath);\n-    PGOOpt = PGOOptions(PGOGenPath, \"\", \"\", PGOOptions::IRInstr,\n-                        PGOOptions::NoCSAction, DebugInfoForProfiling);\n+    PGOOpt = PGOOptions(PGOGenPath, \"\", \"\",\n+#if LLVM_VERSION_GE(17, 0)\n+                        FS,\n+#endif\n+                        PGOOptions::IRInstr, PGOOptions::NoCSAction,\n+                        DebugInfoForProfiling);\n   } else if (PGOUsePath) {\n     assert(!PGOSampleUsePath);\n-    PGOOpt = PGOOptions(PGOUsePath, \"\", \"\", PGOOptions::IRUse,\n-                        PGOOptions::NoCSAction, DebugInfoForProfiling);\n+    PGOOpt = PGOOptions(PGOUsePath, \"\", \"\",\n+#if LLVM_VERSION_GE(17, 0)\n+                        FS,\n+#endif\n+                        PGOOptions::IRUse, PGOOptions::NoCSAction,\n+                        DebugInfoForProfiling);\n   } else if (PGOSampleUsePath) {\n-    PGOOpt = PGOOptions(PGOSampleUsePath, \"\", \"\", PGOOptions::SampleUse,\n-                        PGOOptions::NoCSAction, DebugInfoForProfiling);\n+    PGOOpt = PGOOptions(PGOSampleUsePath, \"\", \"\",\n+#if LLVM_VERSION_GE(17, 0)\n+                        FS,\n+#endif\n+                        PGOOptions::SampleUse, PGOOptions::NoCSAction,\n+                        DebugInfoForProfiling);\n   } else if (DebugInfoForProfiling) {\n-    PGOOpt = PGOOptions(\"\", \"\", \"\", PGOOptions::NoAction,\n-                        PGOOptions::NoCSAction, DebugInfoForProfiling);\n+    PGOOpt = PGOOptions(\"\", \"\", \"\",\n+#if LLVM_VERSION_GE(17, 0)\n+                        FS,\n+#endif\n+                        PGOOptions::NoAction, PGOOptions::NoCSAction,\n+                        DebugInfoForProfiling);\n   }\n \n   PassBuilder PB(TM, PTO, PGOOpt, &PIC);"}, {"sha": "21652063b47167585124ef8f3293cc7acf031985", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 53, "deletions": 17, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1,10 +1,6 @@\n //! Validates all used crates and extern libraries and loads their metadata\n \n-use crate::errors::{\n-    ConflictingAllocErrorHandler, ConflictingGlobalAlloc, CrateNotPanicRuntime,\n-    GlobalAllocRequired, NoMultipleAllocErrorHandler, NoMultipleGlobalAlloc, NoPanicStrategy,\n-    NoTransitiveNeedsDep, NotProfilerRuntime, ProfilerBuiltinsNeedsCore,\n-};\n+use crate::errors;\n use crate::locator::{CrateError, CrateLocator, CratePaths};\n use crate::rmeta::{CrateDep, CrateMetadata, CrateNumMap, CrateRoot, MetadataBlob};\n \n@@ -33,6 +29,7 @@ use rustc_target::spec::{PanicStrategy, TargetTriple};\n use proc_macro::bridge::client::ProcMacro;\n use std::ops::Fn;\n use std::path::Path;\n+use std::time::Duration;\n use std::{cmp, env};\n \n #[derive(Clone)]\n@@ -689,8 +686,7 @@ impl<'a> CrateLoader<'a> {\n     ) -> Result<&'static [ProcMacro], CrateError> {\n         // Make sure the path contains a / or the linker will search for it.\n         let path = env::current_dir().unwrap().join(path);\n-        let lib = unsafe { libloading::Library::new(path) }\n-            .map_err(|err| CrateError::DlOpen(err.to_string()))?;\n+        let lib = load_dylib(&path, 5).map_err(|err| CrateError::DlOpen(err))?;\n \n         let sym_name = self.sess.generate_proc_macro_decls_symbol(stable_crate_id);\n         let sym = unsafe { lib.get::<*const &[ProcMacro]>(sym_name.as_bytes()) }\n@@ -768,10 +764,11 @@ impl<'a> CrateLoader<'a> {\n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n         // and the panic strategy is indeed what we thought it was.\n         if !data.is_panic_runtime() {\n-            self.sess.emit_err(CrateNotPanicRuntime { crate_name: name });\n+            self.sess.emit_err(errors::CrateNotPanicRuntime { crate_name: name });\n         }\n         if data.required_panic_strategy() != Some(desired_strategy) {\n-            self.sess.emit_err(NoPanicStrategy { crate_name: name, strategy: desired_strategy });\n+            self.sess\n+                .emit_err(errors::NoPanicStrategy { crate_name: name, strategy: desired_strategy });\n         }\n \n         self.cstore.injected_panic_runtime = Some(cnum);\n@@ -791,29 +788,30 @@ impl<'a> CrateLoader<'a> {\n \n         let name = Symbol::intern(&self.sess.opts.unstable_opts.profiler_runtime);\n         if name == sym::profiler_builtins && self.sess.contains_name(&krate.attrs, sym::no_core) {\n-            self.sess.emit_err(ProfilerBuiltinsNeedsCore);\n+            self.sess.emit_err(errors::ProfilerBuiltinsNeedsCore);\n         }\n \n         let Some(cnum) = self.resolve_crate(name, DUMMY_SP, CrateDepKind::Implicit) else { return; };\n         let data = self.cstore.get_crate_data(cnum);\n \n         // Sanity check the loaded crate to ensure it is indeed a profiler runtime\n         if !data.is_profiler_runtime() {\n-            self.sess.emit_err(NotProfilerRuntime { crate_name: name });\n+            self.sess.emit_err(errors::NotProfilerRuntime { crate_name: name });\n         }\n     }\n \n     fn inject_allocator_crate(&mut self, krate: &ast::Crate) {\n         self.cstore.has_global_allocator = match &*global_allocator_spans(&self.sess, krate) {\n             [span1, span2, ..] => {\n-                self.sess.emit_err(NoMultipleGlobalAlloc { span2: *span2, span1: *span1 });\n+                self.sess.emit_err(errors::NoMultipleGlobalAlloc { span2: *span2, span1: *span1 });\n                 true\n             }\n             spans => !spans.is_empty(),\n         };\n         self.cstore.has_alloc_error_handler = match &*alloc_error_handler_spans(&self.sess, krate) {\n             [span1, span2, ..] => {\n-                self.sess.emit_err(NoMultipleAllocErrorHandler { span2: *span2, span1: *span1 });\n+                self.sess\n+                    .emit_err(errors::NoMultipleAllocErrorHandler { span2: *span2, span1: *span1 });\n                 true\n             }\n             spans => !spans.is_empty(),\n@@ -849,7 +847,7 @@ impl<'a> CrateLoader<'a> {\n             if data.has_global_allocator() {\n                 match global_allocator {\n                     Some(other_crate) => {\n-                        self.sess.emit_err(ConflictingGlobalAlloc {\n+                        self.sess.emit_err(errors::ConflictingGlobalAlloc {\n                             crate_name: data.name(),\n                             other_crate_name: other_crate,\n                         });\n@@ -864,7 +862,7 @@ impl<'a> CrateLoader<'a> {\n             if data.has_alloc_error_handler() {\n                 match alloc_error_handler {\n                     Some(other_crate) => {\n-                        self.sess.emit_err(ConflictingAllocErrorHandler {\n+                        self.sess.emit_err(errors::ConflictingAllocErrorHandler {\n                             crate_name: data.name(),\n                             other_crate_name: other_crate,\n                         });\n@@ -884,7 +882,7 @@ impl<'a> CrateLoader<'a> {\n             if !self.sess.contains_name(&krate.attrs, sym::default_lib_allocator)\n                 && !self.cstore.iter_crate_data().any(|(_, data)| data.has_default_lib_allocator())\n             {\n-                self.sess.emit_err(GlobalAllocRequired);\n+                self.sess.emit_err(errors::GlobalAllocRequired);\n             }\n             self.cstore.allocator_kind = Some(AllocatorKind::Default);\n         }\n@@ -917,7 +915,7 @@ impl<'a> CrateLoader<'a> {\n         for dep in self.cstore.crate_dependencies_in_reverse_postorder(krate) {\n             let data = self.cstore.get_crate_data(dep);\n             if needs_dep(&data) {\n-                self.sess.emit_err(NoTransitiveNeedsDep {\n+                self.sess.emit_err(errors::NoTransitiveNeedsDep {\n                     crate_name: self.cstore.get_crate_data(krate).name(),\n                     needs_crate_name: what,\n                     deps_crate_name: data.name(),\n@@ -1093,3 +1091,41 @@ fn alloc_error_handler_spans(sess: &Session, krate: &ast::Crate) -> Vec<Span> {\n     visit::walk_crate(&mut f, krate);\n     f.spans\n }\n+\n+// On Windows the compiler would sometimes intermittently fail to open the\n+// proc-macro DLL with `Error::LoadLibraryExW`. It is suspected that something in the\n+// system still holds a lock on the file, so we retry a few times before calling it\n+// an error.\n+fn load_dylib(path: &Path, max_attempts: usize) -> Result<libloading::Library, String> {\n+    assert!(max_attempts > 0);\n+\n+    let mut last_error = None;\n+\n+    for attempt in 0..max_attempts {\n+        match unsafe { libloading::Library::new(&path) } {\n+            Ok(lib) => {\n+                if attempt > 0 {\n+                    debug!(\n+                        \"Loaded proc-macro `{}` after {} attempts.\",\n+                        path.display(),\n+                        attempt + 1\n+                    );\n+                }\n+                return Ok(lib);\n+            }\n+            Err(err) => {\n+                // Only try to recover from this specific error.\n+                if !matches!(err, libloading::Error::LoadLibraryExW { .. }) {\n+                    return Err(err.to_string());\n+                }\n+\n+                last_error = Some(err);\n+                std::thread::sleep(Duration::from_millis(100));\n+                debug!(\"Failed to load proc-macro `{}`. Retrying.\", path.display());\n+            }\n+        }\n+    }\n+\n+    debug!(\"Failed to load proc-macro `{}` even after {} attempts.\", path.display(), max_attempts);\n+    Err(format!(\"{} (retried {} times)\", last_error.unwrap(), max_attempts))\n+}"}, {"sha": "74f91a14ea9ae742c2e93a338fa8e050b62f23d9", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -213,12 +213,7 @@\n //! metadata::locator or metadata::creader for all the juicy details!\n \n use crate::creader::Library;\n-use crate::errors::{\n-    CannotFindCrate, CrateLocationUnknownType, DlError, ExternLocationNotExist,\n-    ExternLocationNotFile, FoundStaticlib, IncompatibleRustc, InvalidMetadataFiles,\n-    LibFilenameForm, MultipleCandidates, NewerCrateVersion, NoCrateWithTriple, NoDylibPlugin,\n-    NonAsciiName, StableCrateIdCollision, SymbolConflictsCurrent, SymbolConflictsOthers,\n-};\n+use crate::errors;\n use crate::rmeta::{rustc_version, MetadataBlob, METADATA_HEADER};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -980,28 +975,28 @@ impl CrateError {\n     pub(crate) fn report(self, sess: &Session, span: Span, missing_core: bool) {\n         match self {\n             CrateError::NonAsciiName(crate_name) => {\n-                sess.emit_err(NonAsciiName { span, crate_name });\n+                sess.emit_err(errors::NonAsciiName { span, crate_name });\n             }\n             CrateError::ExternLocationNotExist(crate_name, loc) => {\n-                sess.emit_err(ExternLocationNotExist { span, crate_name, location: &loc });\n+                sess.emit_err(errors::ExternLocationNotExist { span, crate_name, location: &loc });\n             }\n             CrateError::ExternLocationNotFile(crate_name, loc) => {\n-                sess.emit_err(ExternLocationNotFile { span, crate_name, location: &loc });\n+                sess.emit_err(errors::ExternLocationNotFile { span, crate_name, location: &loc });\n             }\n             CrateError::MultipleCandidates(crate_name, flavor, candidates) => {\n-                sess.emit_err(MultipleCandidates { span, crate_name, flavor, candidates });\n+                sess.emit_err(errors::MultipleCandidates { span, crate_name, flavor, candidates });\n             }\n             CrateError::SymbolConflictsCurrent(root_name) => {\n-                sess.emit_err(SymbolConflictsCurrent { span, crate_name: root_name });\n+                sess.emit_err(errors::SymbolConflictsCurrent { span, crate_name: root_name });\n             }\n             CrateError::SymbolConflictsOthers(root_name) => {\n-                sess.emit_err(SymbolConflictsOthers { span, crate_name: root_name });\n+                sess.emit_err(errors::SymbolConflictsOthers { span, crate_name: root_name });\n             }\n             CrateError::StableCrateIdCollision(crate_name0, crate_name1) => {\n-                sess.emit_err(StableCrateIdCollision { span, crate_name0, crate_name1 });\n+                sess.emit_err(errors::StableCrateIdCollision { span, crate_name0, crate_name1 });\n             }\n             CrateError::DlOpen(s) | CrateError::DlSym(s) => {\n-                sess.emit_err(DlError { span, err: s });\n+                sess.emit_err(errors::DlError { span, err: s });\n             }\n             CrateError::LocatorCombined(locator) => {\n                 let crate_name = locator.crate_name;\n@@ -1012,8 +1007,12 @@ impl CrateError {\n                 if !locator.crate_rejections.via_filename.is_empty() {\n                     let mismatches = locator.crate_rejections.via_filename.iter();\n                     for CrateMismatch { path, .. } in mismatches {\n-                        sess.emit_err(CrateLocationUnknownType { span, path: &path, crate_name });\n-                        sess.emit_err(LibFilenameForm {\n+                        sess.emit_err(errors::CrateLocationUnknownType {\n+                            span,\n+                            path: &path,\n+                            crate_name,\n+                        });\n+                        sess.emit_err(errors::LibFilenameForm {\n                             span,\n                             dll_prefix: &locator.dll_prefix,\n                             dll_suffix: &locator.dll_suffix,\n@@ -1039,7 +1038,7 @@ impl CrateError {\n                             ));\n                         }\n                     }\n-                    sess.emit_err(NewerCrateVersion {\n+                    sess.emit_err(errors::NewerCrateVersion {\n                         span,\n                         crate_name: crate_name,\n                         add_info,\n@@ -1055,7 +1054,7 @@ impl CrateError {\n                             path.display(),\n                         ));\n                     }\n-                    sess.emit_err(NoCrateWithTriple {\n+                    sess.emit_err(errors::NoCrateWithTriple {\n                         span,\n                         crate_name,\n                         locator_triple: locator.triple.triple(),\n@@ -1071,7 +1070,12 @@ impl CrateError {\n                             path.display()\n                         ));\n                     }\n-                    sess.emit_err(FoundStaticlib { span, crate_name, add_info, found_crates });\n+                    sess.emit_err(errors::FoundStaticlib {\n+                        span,\n+                        crate_name,\n+                        add_info,\n+                        found_crates,\n+                    });\n                 } else if !locator.crate_rejections.via_version.is_empty() {\n                     let mismatches = locator.crate_rejections.via_version.iter();\n                     for CrateMismatch { path, got } in mismatches {\n@@ -1082,7 +1086,7 @@ impl CrateError {\n                             path.display(),\n                         ));\n                     }\n-                    sess.emit_err(IncompatibleRustc {\n+                    sess.emit_err(errors::IncompatibleRustc {\n                         span,\n                         crate_name,\n                         add_info,\n@@ -1094,14 +1098,14 @@ impl CrateError {\n                     for CrateMismatch { path: _, got } in locator.crate_rejections.via_invalid {\n                         crate_rejections.push(got);\n                     }\n-                    sess.emit_err(InvalidMetadataFiles {\n+                    sess.emit_err(errors::InvalidMetadataFiles {\n                         span,\n                         crate_name,\n                         add_info,\n                         crate_rejections,\n                     });\n                 } else {\n-                    sess.emit_err(CannotFindCrate {\n+                    sess.emit_err(errors::CannotFindCrate {\n                         span,\n                         crate_name,\n                         add_info,\n@@ -1118,7 +1122,7 @@ impl CrateError {\n                 }\n             }\n             CrateError::NonDylibPlugin(crate_name) => {\n-                sess.emit_err(NoDylibPlugin { span, crate_name });\n+                sess.emit_err(errors::NoDylibPlugin { span, crate_name });\n             }\n         }\n     }"}, {"sha": "a8514c69d1c5a2e0c2ea020648e05d974484230a", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 63, "deletions": 67, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -13,17 +13,7 @@ use rustc_session::Session;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_target::spec::abi::Abi;\n \n-use crate::errors::{\n-    AsNeededCompatibility, BundleNeedsStatic, EmptyLinkName, EmptyRenamingTarget,\n-    FrameworkOnlyWindows, ImportNameTypeForm, ImportNameTypeRaw, ImportNameTypeX86,\n-    IncompatibleWasmLink, InvalidLinkModifier, LibFrameworkApple, LinkCfgForm,\n-    LinkCfgSinglePredicate, LinkFrameworkApple, LinkKindForm, LinkModifiersForm, LinkNameForm,\n-    LinkOrdinalRawDylib, LinkRequiresName, MissingNativeLibrary, MultipleCfgs,\n-    MultipleImportNameType, MultipleKindsInLink, MultipleLinkModifiers, MultipleModifiers,\n-    MultipleNamesInLink, MultipleRenamings, MultipleWasmImport, NoLinkModOverride, RawDylibNoNul,\n-    RenamingNoLink, UnexpectedLinkArg, UnknownImportNameType, UnknownLinkKind, UnknownLinkModifier,\n-    UnsupportedAbi, UnsupportedAbiI686, WasmImportForm, WholeArchiveNeedsStatic,\n-};\n+use crate::errors;\n \n use std::path::PathBuf;\n \n@@ -52,27 +42,28 @@ pub fn find_native_static_library(\n         }\n     }\n \n-    sess.emit_fatal(MissingNativeLibrary::new(name, verbatim));\n+    sess.emit_fatal(errors::MissingNativeLibrary::new(name, verbatim));\n }\n \n fn find_bundled_library(\n     name: Option<Symbol>,\n     verbatim: Option<bool>,\n     kind: NativeLibKind,\n+    has_cfg: bool,\n     sess: &Session,\n ) -> Option<Symbol> {\n-    if sess.opts.unstable_opts.packed_bundled_libs &&\n-            sess.crate_types().iter().any(|ct| ct == &CrateType::Rlib || ct == &CrateType::Staticlib) &&\n-            let NativeLibKind::Static { bundle: Some(true) | None, .. } = kind {\n-        find_native_static_library(\n-            name.unwrap().as_str(),\n-            verbatim.unwrap_or(false),\n-            &sess.target_filesearch(PathKind::Native).search_path_dirs(),\n-            sess,\n-        ).file_name().and_then(|s| s.to_str()).map(Symbol::intern)\n-    } else {\n-        None\n+    if let NativeLibKind::Static { bundle: Some(true) | None, whole_archive } = kind\n+        && sess.crate_types().iter().any(|t| matches!(t, &CrateType::Rlib | CrateType::Staticlib))\n+        && (sess.opts.unstable_opts.packed_bundled_libs || has_cfg || whole_archive == Some(true))\n+    {\n+        let verbatim = verbatim.unwrap_or(false);\n+        let search_paths = &sess.target_filesearch(PathKind::Native).search_path_dirs();\n+        return find_native_static_library(name.unwrap().as_str(), verbatim, search_paths, sess)\n+            .file_name()\n+            .and_then(|s| s.to_str())\n+            .map(Symbol::intern);\n     }\n+    None\n }\n \n pub(crate) fn collect(tcx: TyCtxt<'_>) -> Vec<NativeLib> {\n@@ -129,26 +120,26 @@ impl<'tcx> Collector<'tcx> {\n                 match item.name_or_empty() {\n                     sym::name => {\n                         if name.is_some() {\n-                            sess.emit_err(MultipleNamesInLink { span: item.span() });\n+                            sess.emit_err(errors::MultipleNamesInLink { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_name) = item.value_str() else {\n-                            sess.emit_err(LinkNameForm { span: item.span() });\n+                            sess.emit_err(errors::LinkNameForm { span: item.span() });\n                             continue;\n                         };\n                         let span = item.name_value_literal_span().unwrap();\n                         if link_name.is_empty() {\n-                            sess.emit_err(EmptyLinkName { span });\n+                            sess.emit_err(errors::EmptyLinkName { span });\n                         }\n                         name = Some((link_name, span));\n                     }\n                     sym::kind => {\n                         if kind.is_some() {\n-                            sess.emit_err(MultipleKindsInLink { span: item.span() });\n+                            sess.emit_err(errors::MultipleKindsInLink { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_kind) = item.value_str() else {\n-                            sess.emit_err(LinkKindForm { span: item.span() });\n+                            sess.emit_err(errors::LinkKindForm { span: item.span() });\n                             continue;\n                         };\n \n@@ -158,13 +149,13 @@ impl<'tcx> Collector<'tcx> {\n                             \"dylib\" => NativeLibKind::Dylib { as_needed: None },\n                             \"framework\" => {\n                                 if !sess.target.is_like_osx {\n-                                    sess.emit_err(LinkFrameworkApple { span });\n+                                    sess.emit_err(errors::LinkFrameworkApple { span });\n                                 }\n                                 NativeLibKind::Framework { as_needed: None }\n                             }\n                             \"raw-dylib\" => {\n                                 if !sess.target.is_like_windows {\n-                                    sess.emit_err(FrameworkOnlyWindows { span });\n+                                    sess.emit_err(errors::FrameworkOnlyWindows { span });\n                                 } else if !features.raw_dylib && sess.target.arch == \"x86\" {\n                                     feature_err(\n                                         &sess.parse_sess,\n@@ -177,34 +168,34 @@ impl<'tcx> Collector<'tcx> {\n                                 NativeLibKind::RawDylib\n                             }\n                             kind => {\n-                                sess.emit_err(UnknownLinkKind { span, kind });\n+                                sess.emit_err(errors::UnknownLinkKind { span, kind });\n                                 continue;\n                             }\n                         };\n                         kind = Some(link_kind);\n                     }\n                     sym::modifiers => {\n                         if modifiers.is_some() {\n-                            sess.emit_err(MultipleLinkModifiers { span: item.span() });\n+                            sess.emit_err(errors::MultipleLinkModifiers { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_modifiers) = item.value_str() else {\n-                            sess.emit_err(LinkModifiersForm { span: item.span() });\n+                            sess.emit_err(errors::LinkModifiersForm { span: item.span() });\n                             continue;\n                         };\n                         modifiers = Some((link_modifiers, item.name_value_literal_span().unwrap()));\n                     }\n                     sym::cfg => {\n                         if cfg.is_some() {\n-                            sess.emit_err(MultipleCfgs { span: item.span() });\n+                            sess.emit_err(errors::MultipleCfgs { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_cfg) = item.meta_item_list() else {\n-                            sess.emit_err(LinkCfgForm { span: item.span() });\n+                            sess.emit_err(errors::LinkCfgForm { span: item.span() });\n                             continue;\n                         };\n                         let [NestedMetaItem::MetaItem(link_cfg)] = link_cfg else {\n-                            sess.emit_err(LinkCfgSinglePredicate { span: item.span() });\n+                            sess.emit_err(errors::LinkCfgSinglePredicate { span: item.span() });\n                             continue;\n                         };\n                         if !features.link_cfg {\n@@ -220,26 +211,26 @@ impl<'tcx> Collector<'tcx> {\n                     }\n                     sym::wasm_import_module => {\n                         if wasm_import_module.is_some() {\n-                            sess.emit_err(MultipleWasmImport { span: item.span() });\n+                            sess.emit_err(errors::MultipleWasmImport { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_wasm_import_module) = item.value_str() else {\n-                            sess.emit_err(WasmImportForm { span: item.span() });\n+                            sess.emit_err(errors::WasmImportForm { span: item.span() });\n                             continue;\n                         };\n                         wasm_import_module = Some((link_wasm_import_module, item.span()));\n                     }\n                     sym::import_name_type => {\n                         if import_name_type.is_some() {\n-                            sess.emit_err(MultipleImportNameType { span: item.span() });\n+                            sess.emit_err(errors::MultipleImportNameType { span: item.span() });\n                             continue;\n                         }\n                         let Some(link_import_name_type) = item.value_str() else {\n-                            sess.emit_err(ImportNameTypeForm { span: item.span() });\n+                            sess.emit_err(errors::ImportNameTypeForm { span: item.span() });\n                             continue;\n                         };\n                         if self.tcx.sess.target.arch != \"x86\" {\n-                            sess.emit_err(ImportNameTypeX86 { span: item.span() });\n+                            sess.emit_err(errors::ImportNameTypeX86 { span: item.span() });\n                             continue;\n                         }\n \n@@ -248,7 +239,7 @@ impl<'tcx> Collector<'tcx> {\n                             \"noprefix\" => PeImportNameType::NoPrefix,\n                             \"undecorated\" => PeImportNameType::Undecorated,\n                             import_name_type => {\n-                                sess.emit_err(UnknownImportNameType {\n+                                sess.emit_err(errors::UnknownImportNameType {\n                                     span: item.span(),\n                                     import_name_type,\n                                 });\n@@ -268,7 +259,7 @@ impl<'tcx> Collector<'tcx> {\n                         import_name_type = Some((link_import_name_type, item.span()));\n                     }\n                     _ => {\n-                        sess.emit_err(UnexpectedLinkArg { span: item.span() });\n+                        sess.emit_err(errors::UnexpectedLinkArg { span: item.span() });\n                     }\n                 }\n             }\n@@ -280,7 +271,7 @@ impl<'tcx> Collector<'tcx> {\n                     let (modifier, value) = match modifier.strip_prefix(&['+', '-']) {\n                         Some(m) => (m, modifier.starts_with('+')),\n                         None => {\n-                            sess.emit_err(InvalidLinkModifier { span });\n+                            sess.emit_err(errors::InvalidLinkModifier { span });\n                             continue;\n                         }\n                     };\n@@ -298,7 +289,7 @@ impl<'tcx> Collector<'tcx> {\n                     }\n                     let assign_modifier = |dst: &mut Option<bool>| {\n                         if dst.is_some() {\n-                            sess.emit_err(MultipleModifiers { span, modifier });\n+                            sess.emit_err(errors::MultipleModifiers { span, modifier });\n                         } else {\n                             *dst = Some(value);\n                         }\n@@ -308,7 +299,7 @@ impl<'tcx> Collector<'tcx> {\n                             assign_modifier(bundle)\n                         }\n                         (\"bundle\", _) => {\n-                            sess.emit_err(BundleNeedsStatic { span });\n+                            sess.emit_err(errors::BundleNeedsStatic { span });\n                         }\n \n                         (\"verbatim\", _) => assign_modifier(&mut verbatim),\n@@ -317,7 +308,7 @@ impl<'tcx> Collector<'tcx> {\n                             assign_modifier(whole_archive)\n                         }\n                         (\"whole-archive\", _) => {\n-                            sess.emit_err(WholeArchiveNeedsStatic { span });\n+                            sess.emit_err(errors::WholeArchiveNeedsStatic { span });\n                         }\n \n                         (\"as-needed\", Some(NativeLibKind::Dylib { as_needed }))\n@@ -326,35 +317,35 @@ impl<'tcx> Collector<'tcx> {\n                             assign_modifier(as_needed)\n                         }\n                         (\"as-needed\", _) => {\n-                            sess.emit_err(AsNeededCompatibility { span });\n+                            sess.emit_err(errors::AsNeededCompatibility { span });\n                         }\n \n                         _ => {\n-                            sess.emit_err(UnknownLinkModifier { span, modifier });\n+                            sess.emit_err(errors::UnknownLinkModifier { span, modifier });\n                         }\n                     }\n                 }\n             }\n \n             if let Some((_, span)) = wasm_import_module {\n                 if name.is_some() || kind.is_some() || modifiers.is_some() || cfg.is_some() {\n-                    sess.emit_err(IncompatibleWasmLink { span });\n+                    sess.emit_err(errors::IncompatibleWasmLink { span });\n                 }\n             } else if name.is_none() {\n-                sess.emit_err(LinkRequiresName { span: m.span });\n+                sess.emit_err(errors::LinkRequiresName { span: m.span });\n             }\n \n             // Do this outside of the loop so that `import_name_type` can be specified before `kind`.\n             if let Some((_, span)) = import_name_type {\n                 if kind != Some(NativeLibKind::RawDylib) {\n-                    sess.emit_err(ImportNameTypeRaw { span });\n+                    sess.emit_err(errors::ImportNameTypeRaw { span });\n                 }\n             }\n \n             let dll_imports = match kind {\n                 Some(NativeLibKind::RawDylib) => {\n                     if let Some((name, span)) = name && name.as_str().contains('\\0') {\n-                        sess.emit_err(RawDylibNoNul { span });\n+                        sess.emit_err(errors::RawDylibNoNul { span });\n                     }\n                     foreign_mod_items\n                         .iter()\n@@ -383,7 +374,9 @@ impl<'tcx> Collector<'tcx> {\n                                 .iter()\n                                 .find(|a| a.has_name(sym::link_ordinal))\n                                 .unwrap();\n-                            sess.emit_err(LinkOrdinalRawDylib { span: link_ordinal_attr.span });\n+                            sess.emit_err(errors::LinkOrdinalRawDylib {\n+                                span: link_ordinal_attr.span,\n+                            });\n                         }\n                     }\n \n@@ -393,7 +386,7 @@ impl<'tcx> Collector<'tcx> {\n \n             let name = name.map(|(name, _)| name);\n             let kind = kind.unwrap_or(NativeLibKind::Unspecified);\n-            let filename = find_bundled_library(name, verbatim, kind, sess);\n+            let filename = find_bundled_library(name, verbatim, kind, cfg.is_some(), sess);\n             self.libs.push(NativeLib {\n                 name,\n                 filename,\n@@ -414,7 +407,7 @@ impl<'tcx> Collector<'tcx> {\n         for lib in &self.tcx.sess.opts.libs {\n             if let NativeLibKind::Framework { .. } = lib.kind && !self.tcx.sess.target.is_like_osx {\n                 // Cannot check this when parsing options because the target is not yet available.\n-                self.tcx.sess.emit_err(LibFrameworkApple);\n+                self.tcx.sess.emit_err(errors::LibFrameworkApple);\n             }\n             if let Some(ref new_name) = lib.new_name {\n                 let any_duplicate = self\n@@ -423,11 +416,11 @@ impl<'tcx> Collector<'tcx> {\n                     .filter_map(|lib| lib.name.as_ref())\n                     .any(|n| n.as_str() == lib.name);\n                 if new_name.is_empty() {\n-                    self.tcx.sess.emit_err(EmptyRenamingTarget { lib_name: &lib.name });\n+                    self.tcx.sess.emit_err(errors::EmptyRenamingTarget { lib_name: &lib.name });\n                 } else if !any_duplicate {\n-                    self.tcx.sess.emit_err(RenamingNoLink { lib_name: &lib.name });\n+                    self.tcx.sess.emit_err(errors::RenamingNoLink { lib_name: &lib.name });\n                 } else if !renames.insert(&lib.name) {\n-                    self.tcx.sess.emit_err(MultipleRenamings { lib_name: &lib.name });\n+                    self.tcx.sess.emit_err(errors::MultipleRenamings { lib_name: &lib.name });\n                 }\n             }\n         }\n@@ -453,12 +446,15 @@ impl<'tcx> Collector<'tcx> {\n                             // explicit `:rename` in particular.\n                             if lib.has_modifiers() || passed_lib.has_modifiers() {\n                                 match lib.foreign_module {\n-                                    Some(def_id) => self.tcx.sess.emit_err(NoLinkModOverride {\n-                                        span: Some(self.tcx.def_span(def_id)),\n-                                    }),\n-                                    None => {\n-                                        self.tcx.sess.emit_err(NoLinkModOverride { span: None })\n+                                    Some(def_id) => {\n+                                        self.tcx.sess.emit_err(errors::NoLinkModOverride {\n+                                            span: Some(self.tcx.def_span(def_id)),\n+                                        })\n                                     }\n+                                    None => self\n+                                        .tcx\n+                                        .sess\n+                                        .emit_err(errors::NoLinkModOverride { span: None }),\n                                 };\n                             }\n                             if passed_lib.kind != NativeLibKind::Unspecified {\n@@ -480,7 +476,7 @@ impl<'tcx> Collector<'tcx> {\n                 let name = Some(Symbol::intern(new_name.unwrap_or(&passed_lib.name)));\n                 let sess = self.tcx.sess;\n                 let filename =\n-                    find_bundled_library(name, passed_lib.verbatim, passed_lib.kind, sess);\n+                    find_bundled_library(name, passed_lib.verbatim, passed_lib.kind, false, sess);\n                 self.libs.push(NativeLib {\n                     name,\n                     filename,\n@@ -542,14 +538,14 @@ impl<'tcx> Collector<'tcx> {\n                     DllCallingConvention::Vectorcall(self.i686_arg_list_size(item))\n                 }\n                 _ => {\n-                    self.tcx.sess.emit_fatal(UnsupportedAbiI686 { span: item.span });\n+                    self.tcx.sess.emit_fatal(errors::UnsupportedAbiI686 { span: item.span });\n                 }\n             }\n         } else {\n             match abi {\n                 Abi::C { .. } | Abi::Win64 { .. } | Abi::System { .. } => DllCallingConvention::C,\n                 _ => {\n-                    self.tcx.sess.emit_fatal(UnsupportedAbi { span: item.span });\n+                    self.tcx.sess.emit_fatal(errors::UnsupportedAbi { span: item.span });\n                 }\n             }\n         };"}, {"sha": "e2b07fad6e782ee24ed5e65f8889a15e1bea3516", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -654,7 +654,7 @@ impl<'a, 'tcx, T> Decodable<DecodeContext<'a, 'tcx>> for LazyValue<T> {\n impl<'a, 'tcx, T> Decodable<DecodeContext<'a, 'tcx>> for LazyArray<T> {\n     fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Self {\n         let len = decoder.read_usize();\n-        if len == 0 { LazyArray::empty() } else { decoder.read_lazy_array(len) }\n+        if len == 0 { LazyArray::default() } else { decoder.read_lazy_array(len) }\n     }\n }\n \n@@ -864,7 +864,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .tables\n                 .children\n                 .get(self, index)\n-                .unwrap_or_else(LazyArray::empty)\n+                .expect(\"fields are not encoded for a variant\")\n                 .decode(self)\n                 .map(|index| ty::FieldDef {\n                     did: self.local_def_id(index),\n@@ -896,7 +896,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .tables\n                 .children\n                 .get(self, item_id)\n-                .unwrap_or_else(LazyArray::empty)\n+                .expect(\"variants are not encoded for an enum\")\n                 .decode(self)\n                 .filter_map(|index| {\n                     let kind = self.def_kind(index);\n@@ -1045,7 +1045,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .tables\n             .fn_arg_names\n             .get(self, id)\n-            .unwrap_or_else(LazyArray::empty)\n+            .expect(\"argument names not encoded for a function\")\n             .decode((self, sess))\n             .nth(0)\n             .map_or(false, |ident| ident.name == kw::SelfLower)\n@@ -1060,21 +1060,20 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .tables\n             .children\n             .get(self, id)\n-            .unwrap_or_else(LazyArray::empty)\n+            .expect(\"associated items not encoded for an item\")\n             .decode((self, sess))\n             .map(move |child_index| self.local_def_id(child_index))\n     }\n \n     fn get_associated_item(self, id: DefIndex, sess: &'a Session) -> ty::AssocItem {\n         let name = self.item_name(id);\n \n-        let kind = match self.def_kind(id) {\n-            DefKind::AssocConst => ty::AssocKind::Const,\n-            DefKind::AssocFn => ty::AssocKind::Fn,\n-            DefKind::AssocTy => ty::AssocKind::Type,\n+        let (kind, has_self) = match self.def_kind(id) {\n+            DefKind::AssocConst => (ty::AssocKind::Const, false),\n+            DefKind::AssocFn => (ty::AssocKind::Fn, self.get_fn_has_self_parameter(id, sess)),\n+            DefKind::AssocTy => (ty::AssocKind::Type, false),\n             _ => bug!(\"cannot get associated-item of `{:?}`\", self.def_key(id)),\n         };\n-        let has_self = self.get_fn_has_self_parameter(id, sess);\n         let container = self.root.tables.assoc_container.get(self, id).unwrap();\n \n         ty::AssocItem {\n@@ -1131,7 +1130,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .tables\n             .children\n             .get(self, id)\n-            .unwrap_or_else(LazyArray::empty)\n+            .expect(\"fields not encoded for a struct\")\n             .decode(self)\n             .map(move |index| respan(self.get_span(index, sess), self.item_name(index)))\n     }\n@@ -1144,7 +1143,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .tables\n             .children\n             .get(self, id)\n-            .unwrap_or_else(LazyArray::empty)\n+            .expect(\"fields not encoded for a struct\")\n             .decode(self)\n             .map(move |field_index| self.get_visibility(field_index))\n     }\n@@ -1159,7 +1158,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .tables\n                 .inherent_impls\n                 .get(self, id)\n-                .unwrap_or_else(LazyArray::empty)\n                 .decode(self)\n                 .map(|index| self.local_def_id(index)),\n         )\n@@ -1174,7 +1172,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .tables\n                 .inherent_impls\n                 .get(self, ty_index)\n-                .unwrap_or_else(LazyArray::empty)\n                 .decode(self)\n                 .map(move |impl_index| (ty_def_id, self.local_def_id(impl_index)))\n         })\n@@ -1322,7 +1319,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     ) -> DefPathHash {\n         *def_path_hashes\n             .entry(index)\n-            .or_insert_with(|| self.root.tables.def_path_hashes.get(self, index).unwrap())\n+            .or_insert_with(|| self.root.tables.def_path_hashes.get(self, index))\n     }\n \n     #[inline]"}, {"sha": "07cc84ab95368480a2ec09b80fe0bad29ed63e0c", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1,6 +1,7 @@\n use crate::creader::{CStore, LoadedMacro};\n use crate::foreign_modules;\n use crate::native_libs;\n+use crate::rmeta::table::IsDefault;\n use crate::rmeta::AttrFlags;\n \n use rustc_ast as ast;\n@@ -88,6 +89,14 @@ macro_rules! provide_one {\n             }\n         }\n     };\n+    ($tcx:ident, $def_id:ident, $other:ident, $cdata:ident, $name:ident => { table_defaulted_array }) => {\n+        provide_one! {\n+            $tcx, $def_id, $other, $cdata, $name => {\n+                let lazy = $cdata.root.tables.$name.get($cdata, $def_id.index);\n+                if lazy.is_default() { &[] } else { $tcx.arena.alloc_from_iter(lazy.decode(($cdata, $tcx))) }\n+            }\n+        }\n+    };\n     ($tcx:ident, $def_id:ident, $other:ident, $cdata:ident, $name:ident => { table_direct }) => {\n         provide_one! {\n             $tcx, $def_id, $other, $cdata, $name => {\n@@ -187,10 +196,10 @@ impl IntoArgs for (CrateNum, SimplifiedType) {\n }\n \n provide! { tcx, def_id, other, cdata,\n-    explicit_item_bounds => { table }\n+    explicit_item_bounds => { table_defaulted_array }\n     explicit_predicates_of => { table }\n     generics_of => { table }\n-    inferred_outlives_of => { table }\n+    inferred_outlives_of => { table_defaulted_array }\n     super_predicates_of => { table }\n     type_of => { table }\n     variances_of => { table }"}, {"sha": "85e9ae9a98302bb780f1866295e0768970998982", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 60, "deletions": 67, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -76,13 +76,13 @@ pub(super) struct EncodeContext<'a, 'tcx> {\n     symbol_table: FxHashMap<Symbol, usize>,\n }\n \n-/// If the current crate is a proc-macro, returns early with `LazyArray::empty()`.\n+/// If the current crate is a proc-macro, returns early with `LazyArray::default()`.\n /// This is useful for skipping the encoding of things that aren't needed\n /// for proc-macro crates.\n macro_rules! empty_proc_macro {\n     ($self:ident) => {\n         if $self.is_proc_macro {\n-            return LazyArray::empty();\n+            return LazyArray::default();\n         }\n     };\n }\n@@ -365,21 +365,31 @@ impl<'a, 'tcx> TyEncoder for EncodeContext<'a, 'tcx> {\n     }\n }\n \n-// Shorthand for `$self.$tables.$table.set($def_id.index, $self.lazy_value($value))`, which would\n+// Shorthand for `$self.$tables.$table.set_some($def_id.index, $self.lazy_value($value))`, which would\n // normally need extra variables to avoid errors about multiple mutable borrows.\n macro_rules! record {\n     ($self:ident.$tables:ident.$table:ident[$def_id:expr] <- $value:expr) => {{\n         {\n             let value = $value;\n             let lazy = $self.lazy(value);\n-            $self.$tables.$table.set($def_id.index, lazy);\n+            $self.$tables.$table.set_some($def_id.index, lazy);\n         }\n     }};\n }\n \n-// Shorthand for `$self.$tables.$table.set($def_id.index, $self.lazy_value($value))`, which would\n+// Shorthand for `$self.$tables.$table.set_some($def_id.index, $self.lazy_value($value))`, which would\n // normally need extra variables to avoid errors about multiple mutable borrows.\n macro_rules! record_array {\n+    ($self:ident.$tables:ident.$table:ident[$def_id:expr] <- $value:expr) => {{\n+        {\n+            let value = $value;\n+            let lazy = $self.lazy_array(value);\n+            $self.$tables.$table.set_some($def_id.index, lazy);\n+        }\n+    }};\n+}\n+\n+macro_rules! record_defaulted_array {\n     ($self:ident.$tables:ident.$table:ident[$def_id:expr] <- $value:expr) => {{\n         {\n             let value = $value;\n@@ -467,13 +477,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             {\n                 let def_key = self.lazy(table.def_key(def_index));\n                 let def_path_hash = table.def_path_hash(def_index);\n-                self.tables.def_keys.set(def_index, def_key);\n+                self.tables.def_keys.set_some(def_index, def_key);\n                 self.tables.def_path_hashes.set(def_index, def_path_hash);\n             }\n         } else {\n             for (def_index, def_key, def_path_hash) in table.enumerated_keys_and_path_hashes() {\n                 let def_key = self.lazy(def_key);\n-                self.tables.def_keys.set(def_index, def_key);\n+                self.tables.def_keys.set_some(def_index, def_key);\n                 self.tables.def_path_hashes.set(def_index, *def_path_hash);\n             }\n         }\n@@ -548,7 +558,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n             let on_disk_index: u32 =\n                 on_disk_index.try_into().expect(\"cannot export more than U32_MAX files\");\n-            adapted.set(on_disk_index, self.lazy(source_file));\n+            adapted.set_some(on_disk_index, self.lazy(source_file));\n         }\n \n         adapted.encode(&mut self.opaque)\n@@ -1147,9 +1157,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         if state.is_doc_hidden {\n             attr_flags |= AttrFlags::IS_DOC_HIDDEN;\n         }\n-        if !attr_flags.is_empty() {\n-            self.tables.attr_flags.set_nullable(def_id.local_def_index, attr_flags);\n-        }\n+        self.tables.attr_flags.set(def_id.local_def_index, attr_flags);\n     }\n \n     fn encode_def_ids(&mut self) {\n@@ -1161,7 +1169,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let def_id = local_id.to_def_id();\n             let def_kind = tcx.opt_def_kind(local_id);\n             let Some(def_kind) = def_kind else { continue };\n-            self.tables.opt_def_kind.set(def_id.index, def_kind);\n+            self.tables.opt_def_kind.set_some(def_id.index, def_kind);\n             let def_span = tcx.def_span(local_id);\n             record!(self.tables.def_span[def_id] <- def_span);\n             self.encode_attrs(local_id);\n@@ -1192,9 +1200,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.generics_of[def_id] <- g);\n                 record!(self.tables.explicit_predicates_of[def_id] <- self.tcx.explicit_predicates_of(def_id));\n                 let inferred_outlives = self.tcx.inferred_outlives_of(def_id);\n-                if !inferred_outlives.is_empty() {\n-                    record_array!(self.tables.inferred_outlives_of[def_id] <- inferred_outlives);\n-                }\n+                record_defaulted_array!(self.tables.inferred_outlives_of[def_id] <- inferred_outlives);\n             }\n             if should_encode_type(tcx, local_id, def_kind) {\n                 record!(self.tables.type_of[def_id] <- self.tcx.type_of(def_id));\n@@ -1215,15 +1221,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.trait_impl_trait_tys[def_id] <- table);\n             }\n         }\n+\n         let inherent_impls = tcx.with_stable_hashing_context(|hcx| {\n             tcx.crate_inherent_impls(()).inherent_impls.to_sorted(&hcx, true)\n         });\n-\n-        for (def_id, implementations) in inherent_impls {\n-            if implementations.is_empty() {\n-                continue;\n-            }\n-            record_array!(self.tables.inherent_impls[def_id.to_def_id()] <- implementations.iter().map(|&def_id| {\n+        for (def_id, impls) in inherent_impls {\n+            record_defaulted_array!(self.tables.inherent_impls[def_id.to_def_id()] <- impls.iter().map(|def_id| {\n                 assert!(def_id.is_local());\n                 def_id.index\n             }));\n@@ -1264,14 +1267,14 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             };\n             record!(self.tables.variant_data[variant.def_id] <- data);\n \n-            self.tables.constness.set(variant.def_id.index, hir::Constness::Const);\n+            self.tables.constness.set_some(variant.def_id.index, hir::Constness::Const);\n             record_array!(self.tables.children[variant.def_id] <- variant.fields.iter().map(|f| {\n                 assert!(f.did.is_local());\n                 f.did.index\n             }));\n \n             if let Some((CtorKind::Fn, ctor_def_id)) = variant.ctor {\n-                self.tables.constness.set(ctor_def_id.index, hir::Constness::Const);\n+                self.tables.constness.set_some(ctor_def_id.index, hir::Constness::Const);\n                 let fn_sig = tcx.fn_sig(ctor_def_id);\n                 record!(self.tables.fn_sig[ctor_def_id] <- fn_sig);\n                 // FIXME only encode signature for ctor_def_id\n@@ -1332,26 +1335,24 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_explicit_item_bounds(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_explicit_item_bounds({:?})\", def_id);\n         let bounds = self.tcx.explicit_item_bounds(def_id);\n-        if !bounds.is_empty() {\n-            record_array!(self.tables.explicit_item_bounds[def_id] <- bounds);\n-        }\n+        record_defaulted_array!(self.tables.explicit_item_bounds[def_id] <- bounds);\n     }\n \n     fn encode_info_for_trait_item(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_trait_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n         let impl_defaultness = tcx.impl_defaultness(def_id.expect_local());\n-        self.tables.impl_defaultness.set(def_id.index, impl_defaultness);\n+        self.tables.impl_defaultness.set_some(def_id.index, impl_defaultness);\n         let trait_item = tcx.associated_item(def_id);\n-        self.tables.assoc_container.set(def_id.index, trait_item.container);\n+        self.tables.assoc_container.set_some(def_id.index, trait_item.container);\n \n         match trait_item.kind {\n             ty::AssocKind::Const => {}\n             ty::AssocKind::Fn => {\n                 record_array!(self.tables.fn_arg_names[def_id] <- tcx.fn_arg_names(def_id));\n-                self.tables.asyncness.set(def_id.index, tcx.asyncness(def_id));\n-                self.tables.constness.set(def_id.index, hir::Constness::NotConst);\n+                self.tables.asyncness.set_some(def_id.index, tcx.asyncness(def_id));\n+                self.tables.constness.set_some(def_id.index, hir::Constness::NotConst);\n             }\n             ty::AssocKind::Type => {\n                 self.encode_explicit_item_bounds(def_id);\n@@ -1367,33 +1368,31 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let tcx = self.tcx;\n \n         let ast_item = self.tcx.hir().expect_impl_item(def_id.expect_local());\n-        self.tables.impl_defaultness.set(def_id.index, ast_item.defaultness);\n+        self.tables.impl_defaultness.set_some(def_id.index, ast_item.defaultness);\n         let impl_item = self.tcx.associated_item(def_id);\n-        self.tables.assoc_container.set(def_id.index, impl_item.container);\n+        self.tables.assoc_container.set_some(def_id.index, impl_item.container);\n \n         match impl_item.kind {\n             ty::AssocKind::Fn => {\n                 let hir::ImplItemKind::Fn(ref sig, body) = ast_item.kind else { bug!() };\n-                self.tables.asyncness.set(def_id.index, sig.header.asyncness);\n+                self.tables.asyncness.set_some(def_id.index, sig.header.asyncness);\n                 record_array!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n                 // Can be inside `impl const Trait`, so using sig.header.constness is not reliable\n                 let constness = if self.tcx.is_const_fn_raw(def_id) {\n                     hir::Constness::Const\n                 } else {\n                     hir::Constness::NotConst\n                 };\n-                self.tables.constness.set(def_id.index, constness);\n+                self.tables.constness.set_some(def_id.index, constness);\n             }\n             ty::AssocKind::Const | ty::AssocKind::Type => {}\n         }\n         if let Some(trait_item_def_id) = impl_item.trait_item_def_id {\n-            self.tables.trait_item_def_id.set(def_id.index, trait_item_def_id.into());\n+            self.tables.trait_item_def_id.set_some(def_id.index, trait_item_def_id.into());\n         }\n         if impl_item.kind == ty::AssocKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n-            if tcx.is_intrinsic(def_id) {\n-                self.tables.is_intrinsic.set_nullable(def_id.index, true);\n-            }\n+            self.tables.is_intrinsic.set(def_id.index, tcx.is_intrinsic(def_id));\n         }\n     }\n \n@@ -1522,35 +1521,33 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         match item.kind {\n             hir::ItemKind::Fn(ref sig, .., body) => {\n-                self.tables.asyncness.set(def_id.index, sig.header.asyncness);\n+                self.tables.asyncness.set_some(def_id.index, sig.header.asyncness);\n                 record_array!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n-                self.tables.constness.set(def_id.index, sig.header.constness);\n+                self.tables.constness.set_some(def_id.index, sig.header.constness);\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n-                if macro_def.macro_rules {\n-                    self.tables.is_macro_rules.set_nullable(def_id.index, true);\n-                }\n+                self.tables.is_macro_rules.set(def_id.index, macro_def.macro_rules);\n                 record!(self.tables.macro_definition[def_id] <- &*macro_def.body);\n             }\n             hir::ItemKind::Mod(ref m) => {\n                 return self.encode_info_for_mod(item.owner_id.def_id, m);\n             }\n             hir::ItemKind::OpaqueTy(ref opaque) => {\n                 self.encode_explicit_item_bounds(def_id);\n-                if matches!(opaque.origin, hir::OpaqueTyOrigin::TyAlias) {\n-                    self.tables.is_type_alias_impl_trait.set_nullable(def_id.index, true);\n-                }\n+                self.tables\n+                    .is_type_alias_impl_trait\n+                    .set(def_id.index, matches!(opaque.origin, hir::OpaqueTyOrigin::TyAlias));\n             }\n             hir::ItemKind::Impl(hir::Impl { defaultness, constness, .. }) => {\n-                self.tables.impl_defaultness.set(def_id.index, *defaultness);\n-                self.tables.constness.set(def_id.index, *constness);\n+                self.tables.impl_defaultness.set_some(def_id.index, *defaultness);\n+                self.tables.constness.set_some(def_id.index, *constness);\n \n                 let trait_ref = self.tcx.impl_trait_ref(def_id).map(ty::EarlyBinder::skip_binder);\n                 if let Some(trait_ref) = trait_ref {\n                     let trait_def = self.tcx.trait_def(trait_ref.def_id);\n                     if let Ok(mut an) = trait_def.ancestors(self.tcx, def_id) {\n                         if let Some(specialization_graph::Node::Impl(parent)) = an.nth(1) {\n-                            self.tables.impl_parent.set(def_id.index, parent.into());\n+                            self.tables.impl_parent.set_some(def_id.index, parent.into());\n                         }\n                     }\n \n@@ -1564,7 +1561,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 }\n \n                 let polarity = self.tcx.impl_polarity(def_id);\n-                self.tables.impl_polarity.set(def_id.index, polarity);\n+                self.tables.impl_polarity.set_some(def_id.index, polarity);\n             }\n             hir::ItemKind::Trait(..) => {\n                 let trait_def = self.tcx.trait_def(def_id);\n@@ -1601,9 +1598,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n         if let hir::ItemKind::Fn(..) = item.kind {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n-            if tcx.is_intrinsic(def_id) {\n-                self.tables.is_intrinsic.set_nullable(def_id.index, true);\n-            }\n+            self.tables.is_intrinsic.set(def_id.index, tcx.is_intrinsic(def_id));\n         }\n         if let hir::ItemKind::Impl { .. } = item.kind {\n             if let Some(trait_ref) = self.tcx.impl_trait_ref(def_id) {\n@@ -1650,7 +1645,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n             ty::Closure(_, substs) => {\n                 let constness = self.tcx.constness(def_id.to_def_id());\n-                self.tables.constness.set(def_id.to_def_id().index, constness);\n+                self.tables.constness.set_some(def_id.to_def_id().index, constness);\n                 record!(self.tables.fn_sig[def_id.to_def_id()] <- ty::EarlyBinder(substs.as_closure().sig()));\n             }\n \n@@ -1678,12 +1673,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.hygiene_ctxt.encode(\n             &mut (&mut *self, &mut syntax_contexts, &mut expn_data_table, &mut expn_hash_table),\n             |(this, syntax_contexts, _, _), index, ctxt_data| {\n-                syntax_contexts.set(index, this.lazy(ctxt_data));\n+                syntax_contexts.set_some(index, this.lazy(ctxt_data));\n             },\n             |(this, _, expn_data_table, expn_hash_table), index, expn_data, hash| {\n                 if let Some(index) = index.as_local() {\n-                    expn_data_table.set(index.as_raw(), this.lazy(expn_data));\n-                    expn_hash_table.set(index.as_raw(), this.lazy(hash));\n+                    expn_data_table.set_some(index.as_raw(), this.lazy(expn_data));\n+                    expn_hash_table.set_some(index.as_raw(), this.lazy(hash));\n                 }\n             },\n         );\n@@ -1708,10 +1703,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let spans = self.tcx.sess.parse_sess.proc_macro_quoted_spans();\n             for (i, span) in spans.into_iter().enumerate() {\n                 let span = self.lazy(span);\n-                self.tables.proc_macro_quoted_spans.set(i, span);\n+                self.tables.proc_macro_quoted_spans.set_some(i, span);\n             }\n \n-            self.tables.opt_def_kind.set(LOCAL_CRATE.as_def_id().index, DefKind::Mod);\n+            self.tables.opt_def_kind.set_some(LOCAL_CRATE.as_def_id().index, DefKind::Mod);\n             record!(self.tables.def_span[LOCAL_CRATE.as_def_id()] <- tcx.def_span(LOCAL_CRATE.as_def_id()));\n             self.encode_attrs(LOCAL_CRATE.as_def_id().expect_local());\n             let vis = tcx.local_visibility(CRATE_DEF_ID).map_id(|def_id| def_id.local_def_index);\n@@ -1753,8 +1748,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 def_key.disambiguated_data.data = DefPathData::MacroNs(name);\n \n                 let def_id = id.to_def_id();\n-                self.tables.opt_def_kind.set(def_id.index, DefKind::Macro(macro_kind));\n-                self.tables.proc_macro.set(def_id.index, macro_kind);\n+                self.tables.opt_def_kind.set_some(def_id.index, DefKind::Macro(macro_kind));\n+                self.tables.proc_macro.set_some(def_id.index, macro_kind);\n                 self.encode_attrs(id);\n                 record!(self.tables.def_keys[def_id] <- def_key);\n                 record!(self.tables.def_ident_span[def_id] <- span);\n@@ -1969,7 +1964,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 Linkage::Static => Some(LinkagePreference::RequireStatic),\n             }));\n         }\n-        LazyArray::empty()\n+        LazyArray::default()\n     }\n \n     fn encode_info_for_foreign_item(&mut self, def_id: DefId, nitem: &hir::ForeignItem<'_>) {\n@@ -1979,22 +1974,20 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         match nitem.kind {\n             hir::ForeignItemKind::Fn(_, ref names, _) => {\n-                self.tables.asyncness.set(def_id.index, hir::IsAsync::NotAsync);\n+                self.tables.asyncness.set_some(def_id.index, hir::IsAsync::NotAsync);\n                 record_array!(self.tables.fn_arg_names[def_id] <- *names);\n                 let constness = if self.tcx.is_const_fn_raw(def_id) {\n                     hir::Constness::Const\n                 } else {\n                     hir::Constness::NotConst\n                 };\n-                self.tables.constness.set(def_id.index, constness);\n+                self.tables.constness.set_some(def_id.index, constness);\n                 record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             }\n             hir::ForeignItemKind::Static(..) | hir::ForeignItemKind::Type => {}\n         }\n         if let hir::ForeignItemKind::Fn(..) = nitem.kind {\n-            if tcx.is_intrinsic(def_id) {\n-                self.tables.is_intrinsic.set_nullable(def_id.index, true);\n-            }\n+            self.tables.is_intrinsic.set(def_id.index, tcx.is_intrinsic(def_id));\n         }\n     }\n }"}, {"sha": "a74aa381d9eb829097c219163db4f04750a3d098", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -115,14 +115,16 @@ impl<T: ParameterizedOverTcx> ParameterizedOverTcx for LazyArray<T> {\n     type Value<'tcx> = LazyArray<T::Value<'tcx>>;\n }\n \n+impl<T> Default for LazyArray<T> {\n+    fn default() -> LazyArray<T> {\n+        LazyArray::from_position_and_num_elems(NonZeroUsize::new(1).unwrap(), 0)\n+    }\n+}\n+\n impl<T> LazyArray<T> {\n     fn from_position_and_num_elems(position: NonZeroUsize, num_elems: usize) -> LazyArray<T> {\n         LazyArray { position, num_elems, _marker: PhantomData }\n     }\n-\n-    fn empty() -> LazyArray<T> {\n-        LazyArray::from_position_and_num_elems(NonZeroUsize::new(1).unwrap(), 0)\n-    }\n }\n \n /// A list of lazily-decoded values, with the added capability of random access.\n@@ -316,7 +318,7 @@ pub(crate) struct IncoherentImpls {\n /// Define `LazyTables` and `TableBuilders` at the same time.\n macro_rules! define_tables {\n     (\n-        - nullable: $($name1:ident: Table<$IDX1:ty, $T1:ty>,)+\n+        - defaulted: $($name1:ident: Table<$IDX1:ty, $T1:ty>,)+\n         - optional: $($name2:ident: Table<$IDX2:ty, $T2:ty>,)+\n     ) => {\n         #[derive(MetadataEncodable, MetadataDecodable)]\n@@ -343,11 +345,15 @@ macro_rules! define_tables {\n }\n \n define_tables! {\n-- nullable:\n+- defaulted:\n     is_intrinsic: Table<DefIndex, bool>,\n     is_macro_rules: Table<DefIndex, bool>,\n     is_type_alias_impl_trait: Table<DefIndex, bool>,\n     attr_flags: Table<DefIndex, AttrFlags>,\n+    def_path_hashes: Table<DefIndex, DefPathHash>,\n+    explicit_item_bounds: Table<DefIndex, LazyArray<(ty::Predicate<'static>, Span)>>,\n+    inferred_outlives_of: Table<DefIndex, LazyArray<(ty::Clause<'static>, Span)>>,\n+    inherent_impls: Table<DefIndex, LazyArray<DefIndex>>,\n \n - optional:\n     attributes: Table<DefIndex, LazyArray<ast::Attribute>>,\n@@ -360,12 +366,8 @@ define_tables! {\n     lookup_const_stability: Table<DefIndex, LazyValue<attr::ConstStability>>,\n     lookup_default_body_stability: Table<DefIndex, LazyValue<attr::DefaultBodyStability>>,\n     lookup_deprecation_entry: Table<DefIndex, LazyValue<attr::Deprecation>>,\n-    // As an optimization, a missing entry indicates an empty `&[]`.\n-    explicit_item_bounds: Table<DefIndex, LazyArray<(ty::Predicate<'static>, Span)>>,\n     explicit_predicates_of: Table<DefIndex, LazyValue<ty::GenericPredicates<'static>>>,\n     generics_of: Table<DefIndex, LazyValue<ty::Generics>>,\n-    // As an optimization, a missing entry indicates an empty `&[]`.\n-    inferred_outlives_of: Table<DefIndex, LazyArray<(ty::Clause<'static>, Span)>>,\n     super_predicates_of: Table<DefIndex, LazyValue<ty::GenericPredicates<'static>>>,\n     type_of: Table<DefIndex, LazyValue<Ty<'static>>>,\n     variances_of: Table<DefIndex, LazyArray<ty::Variance>>,\n@@ -393,7 +395,6 @@ define_tables! {\n     generator_kind: Table<DefIndex, LazyValue<hir::GeneratorKind>>,\n     trait_def: Table<DefIndex, LazyValue<ty::TraitDef>>,\n     trait_item_def_id: Table<DefIndex, RawDefId>,\n-    inherent_impls: Table<DefIndex, LazyArray<DefIndex>>,\n     expn_that_defined: Table<DefIndex, LazyValue<ExpnId>>,\n     unused_generic_params: Table<DefIndex, LazyValue<UnusedGenericParams>>,\n     params_in_repr: Table<DefIndex, LazyValue<BitSet<u32>>>,\n@@ -403,7 +404,6 @@ define_tables! {\n     // `DefPathTable` up front, since we may only ever use a few\n     // definitions from any given crate.\n     def_keys: Table<DefIndex, LazyValue<DefKey>>,\n-    def_path_hashes: Table<DefIndex, DefPathHash>,\n     proc_macro_quoted_spans: Table<usize, LazyValue<Span>>,\n     generator_diagnostic_data: Table<DefIndex, LazyValue<GeneratorDiagnosticData<'static>>>,\n     variant_data: Table<DefIndex, LazyValue<VariantData>>,"}, {"sha": "99bec570600a0faae76c4afb1479ce834e1702c1", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 122, "deletions": 38, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -10,11 +10,51 @@ use rustc_span::hygiene::MacroKind;\n use std::marker::PhantomData;\n use std::num::NonZeroUsize;\n \n+pub(super) trait IsDefault: Default {\n+    fn is_default(&self) -> bool;\n+}\n+\n+impl<T> IsDefault for Option<T> {\n+    fn is_default(&self) -> bool {\n+        self.is_none()\n+    }\n+}\n+\n+impl IsDefault for AttrFlags {\n+    fn is_default(&self) -> bool {\n+        self.is_empty()\n+    }\n+}\n+\n+impl IsDefault for bool {\n+    fn is_default(&self) -> bool {\n+        !self\n+    }\n+}\n+\n+impl IsDefault for u32 {\n+    fn is_default(&self) -> bool {\n+        *self == 0\n+    }\n+}\n+\n+impl<T> IsDefault for LazyArray<T> {\n+    fn is_default(&self) -> bool {\n+        self.num_elems == 0\n+    }\n+}\n+\n+impl IsDefault for DefPathHash {\n+    fn is_default(&self) -> bool {\n+        self.0 == Fingerprint::ZERO\n+    }\n+}\n+\n /// Helper trait, for encoding to, and decoding from, a fixed number of bytes.\n /// Used mainly for Lazy positions and lengths.\n /// Unchecked invariant: `Self::default()` should encode as `[0; BYTE_LEN]`,\n /// but this has no impact on safety.\n-pub(super) trait FixedSizeEncoding: Default {\n+pub(super) trait FixedSizeEncoding: IsDefault {\n     /// This should be `[u8; BYTE_LEN]`;\n     /// Cannot use an associated `const BYTE_LEN: usize` instead due to const eval limitations.\n     type ByteArray;\n@@ -23,6 +63,8 @@ pub(super) trait FixedSizeEncoding: Default {\n     fn write_to_bytes(self, b: &mut Self::ByteArray);\n }\n \n+/// This implementation is not used generically, but for reading/writing\n+/// concrete `u32` fields in `Lazy*` structures, which may be zero.\n impl FixedSizeEncoding for u32 {\n     type ByteArray = [u8; 4];\n \n@@ -58,7 +100,7 @@ macro_rules! fixed_size_enum {\n             fn write_to_bytes(self, b: &mut [u8;1]) {\n                 use $ty::*;\n                 b[0] = match self {\n-                    None => 0,\n+                    None => unreachable!(),\n                     $(Some($($pat)*) => 1 + ${index()},)*\n                 }\n             }\n@@ -155,20 +197,18 @@ fixed_size_enum! {\n }\n \n // We directly encode `DefPathHash` because a `LazyValue` would incur a 25% cost.\n-impl FixedSizeEncoding for Option<DefPathHash> {\n+impl FixedSizeEncoding for DefPathHash {\n     type ByteArray = [u8; 16];\n \n     #[inline]\n     fn from_bytes(b: &[u8; 16]) -> Self {\n-        Some(DefPathHash(Fingerprint::from_le_bytes(*b)))\n+        DefPathHash(Fingerprint::from_le_bytes(*b))\n     }\n \n     #[inline]\n     fn write_to_bytes(self, b: &mut [u8; 16]) {\n-        let Some(DefPathHash(fingerprint)) = self else {\n-            panic!(\"Trying to encode absent DefPathHash.\")\n-        };\n-        *b = fingerprint.to_le_bytes();\n+        debug_assert!(!self.is_default());\n+        *b = self.0.to_le_bytes();\n     }\n }\n \n@@ -179,17 +219,17 @@ impl FixedSizeEncoding for Option<RawDefId> {\n     #[inline]\n     fn from_bytes(b: &[u8; 8]) -> Self {\n         let krate = u32::from_le_bytes(b[0..4].try_into().unwrap());\n-        let index = u32::from_le_bytes(b[4..8].try_into().unwrap());\n         if krate == 0 {\n             return None;\n         }\n+        let index = u32::from_le_bytes(b[4..8].try_into().unwrap());\n         Some(RawDefId { krate: krate - 1, index })\n     }\n \n     #[inline]\n     fn write_to_bytes(self, b: &mut [u8; 8]) {\n         match self {\n-            None => *b = [0; 8],\n+            None => unreachable!(),\n             Some(RawDefId { krate, index }) => {\n                 // CrateNum is less than `CrateNum::MAX_AS_U32`.\n                 debug_assert!(krate < u32::MAX);\n@@ -210,6 +250,7 @@ impl FixedSizeEncoding for AttrFlags {\n \n     #[inline]\n     fn write_to_bytes(self, b: &mut [u8; 1]) {\n+        debug_assert!(!self.is_default());\n         b[0] = self.bits();\n     }\n }\n@@ -224,6 +265,7 @@ impl FixedSizeEncoding for bool {\n \n     #[inline]\n     fn write_to_bytes(self, b: &mut [u8; 1]) {\n+        debug_assert!(!self.is_default());\n         b[0] = self as u8\n     }\n }\n@@ -242,34 +284,72 @@ impl<T> FixedSizeEncoding for Option<LazyValue<T>> {\n \n     #[inline]\n     fn write_to_bytes(self, b: &mut [u8; 4]) {\n-        let position = self.map_or(0, |lazy| lazy.position.get());\n+        match self {\n+            None => unreachable!(),\n+            Some(lazy) => {\n+                let position = lazy.position.get();\n+                let position: u32 = position.try_into().unwrap();\n+                position.write_to_bytes(b)\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> LazyArray<T> {\n+    #[inline]\n+    fn write_to_bytes_impl(self, b: &mut [u8; 8]) {\n+        let ([position_bytes, meta_bytes],[])= b.as_chunks_mut::<4>() else { panic!() };\n+\n+        let position = self.position.get();\n         let position: u32 = position.try_into().unwrap();\n-        position.write_to_bytes(b)\n+        position.write_to_bytes(position_bytes);\n+\n+        let len = self.num_elems;\n+        let len: u32 = len.try_into().unwrap();\n+        len.write_to_bytes(meta_bytes);\n+    }\n+\n+    fn from_bytes_impl(position_bytes: &[u8; 4], meta_bytes: &[u8; 4]) -> Option<LazyArray<T>> {\n+        let position = NonZeroUsize::new(u32::from_bytes(position_bytes) as usize)?;\n+        let len = u32::from_bytes(meta_bytes) as usize;\n+        Some(LazyArray::from_position_and_num_elems(position, len))\n     }\n }\n \n-impl<T> FixedSizeEncoding for Option<LazyArray<T>> {\n+impl<T> FixedSizeEncoding for LazyArray<T> {\n     type ByteArray = [u8; 8];\n \n     #[inline]\n     fn from_bytes(b: &[u8; 8]) -> Self {\n-        let ([ref position_bytes, ref meta_bytes],[])= b.as_chunks::<4>() else { panic!() };\n-        let position = NonZeroUsize::new(u32::from_bytes(position_bytes) as usize)?;\n-        let len = u32::from_bytes(meta_bytes) as usize;\n-        Some(LazyArray::from_position_and_num_elems(position, len))\n+        let ([position_bytes, meta_bytes],[])= b.as_chunks::<4>() else { panic!() };\n+        if *meta_bytes == [0; 4] {\n+            return Default::default();\n+        }\n+        LazyArray::from_bytes_impl(position_bytes, meta_bytes).unwrap()\n     }\n \n     #[inline]\n     fn write_to_bytes(self, b: &mut [u8; 8]) {\n-        let ([ref mut position_bytes, ref mut meta_bytes],[])= b.as_chunks_mut::<4>() else { panic!() };\n+        assert!(!self.is_default());\n+        self.write_to_bytes_impl(b)\n+    }\n+}\n \n-        let position = self.map_or(0, |lazy| lazy.position.get());\n-        let position: u32 = position.try_into().unwrap();\n-        position.write_to_bytes(position_bytes);\n+impl<T> FixedSizeEncoding for Option<LazyArray<T>> {\n+    type ByteArray = [u8; 8];\n \n-        let len = self.map_or(0, |lazy| lazy.num_elems);\n-        let len: u32 = len.try_into().unwrap();\n-        len.write_to_bytes(meta_bytes);\n+    #[inline]\n+    fn from_bytes(b: &[u8; 8]) -> Self {\n+        let ([position_bytes, meta_bytes],[])= b.as_chunks::<4>() else { panic!() };\n+        LazyArray::from_bytes_impl(position_bytes, meta_bytes)\n+    }\n+\n+    #[inline]\n+    fn write_to_bytes(self, b: &mut [u8; 8]) {\n+        match self {\n+            None => unreachable!(),\n+            Some(lazy) => lazy.write_to_bytes_impl(b),\n+        }\n     }\n }\n \n@@ -289,20 +369,27 @@ impl<I: Idx, const N: usize, T> TableBuilder<I, Option<T>>\n where\n     Option<T>: FixedSizeEncoding<ByteArray = [u8; N]>,\n {\n-    pub(crate) fn set(&mut self, i: I, value: T) {\n-        self.set_nullable(i, Some(value))\n+    pub(crate) fn set_some(&mut self, i: I, value: T) {\n+        self.set(i, Some(value))\n     }\n }\n \n impl<I: Idx, const N: usize, T: FixedSizeEncoding<ByteArray = [u8; N]>> TableBuilder<I, T> {\n-    pub(crate) fn set_nullable(&mut self, i: I, value: T) {\n-        // FIXME(eddyb) investigate more compact encodings for sparse tables.\n-        // On the PR @michaelwoerister mentioned:\n-        // > Space requirements could perhaps be optimized by using the HAMT `popcnt`\n-        // > trick (i.e. divide things into buckets of 32 or 64 items and then\n-        // > store bit-masks of which item in each bucket is actually serialized).\n-        self.blocks.ensure_contains_elem(i, || [0; N]);\n-        value.write_to_bytes(&mut self.blocks[i]);\n+    /// Sets the table value if it is not default.\n+    /// ATTENTION: For optimization default values are simply ignored by this function, because\n+    /// right now metadata tables never need to reset non-default values to default. If such need\n+    /// arises in the future then a new method (e.g. `clear` or `reset`) will need to be introduced\n+    /// for doing that explicitly.\n+    pub(crate) fn set(&mut self, i: I, value: T) {\n+        if !value.is_default() {\n+            // FIXME(eddyb) investigate more compact encodings for sparse tables.\n+            // On the PR @michaelwoerister mentioned:\n+            // > Space requirements could perhaps be optimized by using the HAMT `popcnt`\n+            // > trick (i.e. divide things into buckets of 32 or 64 items and then\n+            // > store bit-masks of which item in each bucket is actually serialized).\n+            self.blocks.ensure_contains_elem(i, || [0; N]);\n+            value.write_to_bytes(&mut self.blocks[i]);\n+        }\n     }\n \n     pub(crate) fn encode(&self, buf: &mut FileEncoder) -> LazyTable<I, T> {\n@@ -331,10 +418,7 @@ where\n         let start = self.position.get();\n         let bytes = &metadata.blob()[start..start + self.encoded_size];\n         let (bytes, []) = bytes.as_chunks::<N>() else { panic!() };\n-        match bytes.get(i.index()) {\n-            Some(bytes) => FixedSizeEncoding::from_bytes(bytes),\n-            None => FixedSizeEncoding::from_bytes(&[0; N]),\n-        }\n+        bytes.get(i.index()).map_or_else(Default::default, FixedSizeEncoding::from_bytes)\n     }\n \n     /// Size of the table in entries, including possible gaps."}, {"sha": "2ba7ec5b151929ebd00d96a0f2d7355778f43f0a", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -112,6 +112,7 @@ macro_rules! arena_types {\n \n             [decode] trait_impl_trait_tys: rustc_data_structures::fx::FxHashMap<rustc_hir::def_id::DefId, rustc_middle::ty::Ty<'tcx>>,\n             [] bit_set_u32: rustc_index::bit_set::BitSet<u32>,\n+            [] external_constraints: rustc_middle::traits::solve::ExternalConstraintsData<'tcx>,\n         ]);\n     )\n }"}, {"sha": "10ac7e0d39af6ca89d849eb539a9410a9dd9c7f1", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -2098,10 +2098,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                     AggregateKind::Closure(def_id, substs) => ty::tls::with(|tcx| {\n                         let name = if tcx.sess.opts.unstable_opts.span_free_formats {\n                             let substs = tcx.lift(substs).unwrap();\n-                            format!(\n-                                \"[closure@{}]\",\n-                                tcx.def_path_str_with_substs(def_id.to_def_id(), substs),\n-                            )\n+                            format!(\"[closure@{}]\", tcx.def_path_str_with_substs(def_id, substs),)\n                         } else {\n                             let span = tcx.def_span(def_id);\n                             format!(\n@@ -2112,11 +2109,17 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                         let mut struct_fmt = fmt.debug_struct(&name);\n \n                         // FIXME(project-rfc-2229#48): This should be a list of capture names/places\n-                        if let Some(upvars) = tcx.upvars_mentioned(def_id) {\n+                        if let Some(def_id) = def_id.as_local()\n+                            && let Some(upvars) = tcx.upvars_mentioned(def_id)\n+                        {\n                             for (&var_id, place) in iter::zip(upvars.keys(), places) {\n                                 let var_name = tcx.hir().name(var_id);\n                                 struct_fmt.field(var_name.as_str(), place);\n                             }\n+                        } else {\n+                            for (index, place) in places.iter().enumerate() {\n+                                struct_fmt.field(&format!(\"{index}\"), place);\n+                            }\n                         }\n \n                         struct_fmt.finish()\n@@ -2127,11 +2130,17 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                         let mut struct_fmt = fmt.debug_struct(&name);\n \n                         // FIXME(project-rfc-2229#48): This should be a list of capture names/places\n-                        if let Some(upvars) = tcx.upvars_mentioned(def_id) {\n+                        if let Some(def_id) = def_id.as_local()\n+                            && let Some(upvars) = tcx.upvars_mentioned(def_id)\n+                        {\n                             for (&var_id, place) in iter::zip(upvars.keys(), places) {\n                                 let var_name = tcx.hir().name(var_id);\n                                 struct_fmt.field(var_name.as_str(), place);\n                             }\n+                        } else {\n+                            for (index, place) in places.iter().enumerate() {\n+                                struct_fmt.field(&format!(\"{index}\"), place);\n+                            }\n                         }\n \n                         struct_fmt.finish()"}, {"sha": "66ee68187896f54d7466442a18cb55a76d1270d5", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1203,10 +1203,8 @@ pub enum AggregateKind<'tcx> {\n     /// active field index would identity the field `c`\n     Adt(DefId, VariantIdx, SubstsRef<'tcx>, Option<UserTypeAnnotationIndex>, Option<usize>),\n \n-    // Note: We can use LocalDefId since closures and generators a deaggregated\n-    // before codegen.\n-    Closure(LocalDefId, SubstsRef<'tcx>),\n-    Generator(LocalDefId, SubstsRef<'tcx>, hir::Movability),\n+    Closure(DefId, SubstsRef<'tcx>),\n+    Generator(DefId, SubstsRef<'tcx>, hir::Movability),\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, Hash, HashStable)]"}, {"sha": "b5e0b88bbe52dbf79ff94f109d4b52f960d17311", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -205,9 +205,9 @@ impl<'tcx> Rvalue<'tcx> {\n                 AggregateKind::Adt(did, _, substs, _, _) => {\n                     tcx.bound_type_of(did).subst(tcx, substs)\n                 }\n-                AggregateKind::Closure(did, substs) => tcx.mk_closure(did.to_def_id(), substs),\n+                AggregateKind::Closure(did, substs) => tcx.mk_closure(did, substs),\n                 AggregateKind::Generator(did, substs, movability) => {\n-                    tcx.mk_generator(did.to_def_id(), substs, movability)\n+                    tcx.mk_generator(did, substs, movability)\n                 }\n             },\n             Rvalue::ShallowInitBox(_, ty) => tcx.mk_box(ty),"}, {"sha": "c528929e7561dacb8572e7185a1d2dd3a6bacb5d", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -5,6 +5,7 @@\n mod chalk;\n pub mod query;\n pub mod select;\n+pub mod solve;\n pub mod specialization_graph;\n mod structural_impls;\n pub mod util;\n@@ -474,6 +475,8 @@ pub enum WellFormedLoc {\n pub struct ImplDerivedObligationCause<'tcx> {\n     pub derived: DerivedObligationCause<'tcx>,\n     pub impl_def_id: DefId,\n+    /// The index of the derived predicate in the parent impl's predicates.\n+    pub impl_def_predicate_index: Option<usize>,\n     pub span: Span,\n }\n "}, {"sha": "63f9c32f0a74b2ff4c5bfa8d7e4817947015e2e1", "filename": "compiler/rustc_middle/src/traits/solve.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -0,0 +1,55 @@\n+use std::ops::ControlFlow;\n+\n+use rustc_data_structures::intern::Interned;\n+\n+use crate::ty::{FallibleTypeFolder, Ty, TypeFoldable, TypeFolder, TypeVisitable, TypeVisitor};\n+\n+#[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n+pub struct ExternalConstraints<'tcx>(pub(crate) Interned<'tcx, ExternalConstraintsData<'tcx>>);\n+\n+impl<'tcx> std::ops::Deref for ExternalConstraints<'tcx> {\n+    type Target = ExternalConstraintsData<'tcx>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &*self.0\n+    }\n+}\n+\n+/// Additional constraints returned on success.\n+#[derive(Debug, PartialEq, Eq, Clone, Hash, Default)]\n+pub struct ExternalConstraintsData<'tcx> {\n+    // FIXME: implement this.\n+    pub regions: (),\n+    pub opaque_types: Vec<(Ty<'tcx>, Ty<'tcx>)>,\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ExternalConstraints<'tcx> {\n+    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(FallibleTypeFolder::tcx(folder).intern_external_constraints(ExternalConstraintsData {\n+            regions: (),\n+            opaque_types: self\n+                .opaque_types\n+                .iter()\n+                .map(|opaque| opaque.try_fold_with(folder))\n+                .collect::<Result<_, F::Error>>()?,\n+        }))\n+    }\n+\n+    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+        TypeFolder::tcx(folder).intern_external_constraints(ExternalConstraintsData {\n+            regions: (),\n+            opaque_types: self.opaque_types.iter().map(|opaque| opaque.fold_with(folder)).collect(),\n+        })\n+    }\n+}\n+\n+impl<'tcx> TypeVisitable<'tcx> for ExternalConstraints<'tcx> {\n+    fn visit_with<V: TypeVisitor<'tcx>>(\n+        &self,\n+        visitor: &mut V,\n+    ) -> std::ops::ControlFlow<V::BreakTy> {\n+        self.regions.visit_with(visitor)?;\n+        self.opaque_types.visit_with(visitor)?;\n+        ControlFlow::Continue(())\n+    }\n+}"}, {"sha": "9205a8a0ffed801859efae523f76cceaa6aa4b60", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -17,6 +17,7 @@ use crate::mir::{\n };\n use crate::thir::Thir;\n use crate::traits;\n+use crate::traits::solve::{ExternalConstraints, ExternalConstraintsData};\n use crate::ty::query::{self, TyCtxtAt};\n use crate::ty::{\n     self, AdtDef, AdtDefData, AdtKind, Binder, Const, ConstData, DefIdTree, FloatTy, FloatVar,\n@@ -148,6 +149,7 @@ pub struct CtxtInterners<'tcx> {\n     bound_variable_kinds: InternedSet<'tcx, List<ty::BoundVariableKind>>,\n     layout: InternedSet<'tcx, LayoutS<VariantIdx>>,\n     adt_def: InternedSet<'tcx, AdtDefData>,\n+    external_constraints: InternedSet<'tcx, ExternalConstraintsData<'tcx>>,\n }\n \n impl<'tcx> CtxtInterners<'tcx> {\n@@ -169,6 +171,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n             bound_variable_kinds: Default::default(),\n             layout: Default::default(),\n             adt_def: Default::default(),\n+            external_constraints: Default::default(),\n         }\n     }\n \n@@ -1449,6 +1452,7 @@ direct_interners! {\n     const_allocation: intern_const_alloc(Allocation): ConstAllocation -> ConstAllocation<'tcx>,\n     layout: intern_layout(LayoutS<VariantIdx>): Layout -> Layout<'tcx>,\n     adt_def: intern_adt_def(AdtDefData): AdtDef -> AdtDef<'tcx>,\n+    external_constraints: intern_external_constraints(ExternalConstraintsData<'tcx>): ExternalConstraints -> ExternalConstraints<'tcx>,\n }\n \n macro_rules! slice_interners {"}, {"sha": "cd9b927014077190b973197824728c565181329c", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 91, "deletions": 4, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -3,8 +3,9 @@\n use std::ops::ControlFlow;\n \n use crate::ty::{\n-    visit::TypeVisitable, AliasTy, Const, ConstKind, DefIdTree, InferConst, InferTy, Opaque,\n-    PolyTraitPredicate, Projection, Ty, TyCtxt, TypeSuperVisitable, TypeVisitor,\n+    visit::TypeVisitable, AliasTy, Const, ConstKind, DefIdTree, FallibleTypeFolder, InferConst,\n+    InferTy, Opaque, PolyTraitPredicate, Projection, Ty, TyCtxt, TypeFoldable, TypeSuperFoldable,\n+    TypeSuperVisitable, TypeVisitor,\n };\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -76,7 +77,7 @@ impl<'tcx> Ty<'tcx> {\n     }\n }\n \n-pub trait IsSuggestable<'tcx> {\n+pub trait IsSuggestable<'tcx>: Sized {\n     /// Whether this makes sense to suggest in a diagnostic.\n     ///\n     /// We filter out certain types and constants since they don't provide\n@@ -87,15 +88,21 @@ pub trait IsSuggestable<'tcx> {\n     /// Only if `infer_suggestable` is true, we consider type and const\n     /// inference variables to be suggestable.\n     fn is_suggestable(self, tcx: TyCtxt<'tcx>, infer_suggestable: bool) -> bool;\n+\n+    fn make_suggestable(self, tcx: TyCtxt<'tcx>, infer_suggestable: bool) -> Option<Self>;\n }\n \n impl<'tcx, T> IsSuggestable<'tcx> for T\n where\n-    T: TypeVisitable<'tcx>,\n+    T: TypeVisitable<'tcx> + TypeFoldable<'tcx>,\n {\n     fn is_suggestable(self, tcx: TyCtxt<'tcx>, infer_suggestable: bool) -> bool {\n         self.visit_with(&mut IsSuggestableVisitor { tcx, infer_suggestable }).is_continue()\n     }\n+\n+    fn make_suggestable(self, tcx: TyCtxt<'tcx>, infer_suggestable: bool) -> Option<T> {\n+        self.try_fold_with(&mut MakeSuggestableFolder { tcx, infer_suggestable }).ok()\n+    }\n }\n \n pub fn suggest_arbitrary_trait_bound<'tcx>(\n@@ -509,3 +516,83 @@ impl<'tcx> TypeVisitor<'tcx> for IsSuggestableVisitor<'tcx> {\n         c.super_visit_with(self)\n     }\n }\n+\n+pub struct MakeSuggestableFolder<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    infer_suggestable: bool,\n+}\n+\n+impl<'tcx> FallibleTypeFolder<'tcx> for MakeSuggestableFolder<'tcx> {\n+    type Error = ();\n+\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn try_fold_ty(&mut self, t: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+        let t = match *t.kind() {\n+            Infer(InferTy::TyVar(_)) if self.infer_suggestable => t,\n+\n+            FnDef(def_id, substs) => {\n+                self.tcx.mk_fn_ptr(self.tcx.fn_sig(def_id).subst(self.tcx, substs))\n+            }\n+\n+            // FIXME(compiler-errors): We could replace these with infer, I guess.\n+            Closure(..)\n+            | Infer(..)\n+            | Generator(..)\n+            | GeneratorWitness(..)\n+            | Bound(_, _)\n+            | Placeholder(_)\n+            | Error(_) => {\n+                return Err(());\n+            }\n+\n+            Alias(Opaque, AliasTy { def_id, .. }) => {\n+                let parent = self.tcx.parent(def_id);\n+                if let hir::def::DefKind::TyAlias | hir::def::DefKind::AssocTy = self.tcx.def_kind(parent)\n+                    && let Alias(Opaque, AliasTy { def_id: parent_opaque_def_id, .. }) = *self.tcx.type_of(parent).kind()\n+                    && parent_opaque_def_id == def_id\n+                {\n+                    t\n+                } else {\n+                    return Err(());\n+                }\n+            }\n+\n+            Param(param) => {\n+                // FIXME: It would be nice to make this not use string manipulation,\n+                // but it's pretty hard to do this, since `ty::ParamTy` is missing\n+                // sufficient info to determine if it is synthetic, and we don't\n+                // always have a convenient way of getting `ty::Generics` at the call\n+                // sites we invoke `IsSuggestable::is_suggestable`.\n+                if param.name.as_str().starts_with(\"impl \") {\n+                    return Err(());\n+                }\n+\n+                t\n+            }\n+\n+            _ => t,\n+        };\n+\n+        t.try_super_fold_with(self)\n+    }\n+\n+    fn try_fold_const(&mut self, c: Const<'tcx>) -> Result<Const<'tcx>, ()> {\n+        let c = match c.kind() {\n+            ConstKind::Infer(InferConst::Var(_)) if self.infer_suggestable => c,\n+\n+            ConstKind::Infer(..)\n+            | ConstKind::Bound(..)\n+            | ConstKind::Placeholder(..)\n+            | ConstKind::Error(..) => {\n+                return Err(());\n+            }\n+\n+            _ => c,\n+        };\n+\n+        c.try_super_fold_with(self)\n+    }\n+}"}, {"sha": "8a0019bc0127c9df4ee2e224d30567bf194d4992", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -105,7 +105,7 @@ pub trait TypeSuperFoldable<'tcx>: TypeFoldable<'tcx> {\n /// the infallible methods of this trait to ensure that the two APIs\n /// are coherent.\n pub trait TypeFolder<'tcx>: FallibleTypeFolder<'tcx, Error = !> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'tcx>;\n+    fn tcx(&self) -> TyCtxt<'tcx>;\n \n     fn fold_binder<T>(&mut self, t: Binder<'tcx, T>) -> Binder<'tcx, T>\n     where"}, {"sha": "4c2855821384bcf4ed35bda7e3635eaacdcc1e7d", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 95, "deletions": 106, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -818,125 +818,114 @@ where\n         let tcx = cx.tcx();\n         let param_env = cx.param_env();\n \n-        let pointee_info =\n-            match *this.ty.kind() {\n-                ty::RawPtr(mt) if offset.bytes() == 0 => {\n-                    tcx.layout_of(param_env.and(mt.ty)).ok().map(|layout| PointeeInfo {\n-                        size: layout.size,\n-                        align: layout.align.abi,\n-                        safe: None,\n-                    })\n-                }\n-                ty::FnPtr(fn_sig) if offset.bytes() == 0 => {\n-                    tcx.layout_of(param_env.and(tcx.mk_fn_ptr(fn_sig))).ok().map(|layout| {\n-                        PointeeInfo { size: layout.size, align: layout.align.abi, safe: None }\n-                    })\n-                }\n-                ty::Ref(_, ty, mt) if offset.bytes() == 0 => {\n-                    let kind = if tcx.sess.opts.optimize == OptLevel::No {\n-                        // Use conservative pointer kind if not optimizing. This saves us the\n-                        // Freeze/Unpin queries, and can save time in the codegen backend (noalias\n-                        // attributes in LLVM have compile-time cost even in unoptimized builds).\n-                        PointerKind::SharedMutable\n-                    } else {\n-                        match mt {\n-                            hir::Mutability::Not => {\n-                                if ty.is_freeze(tcx, cx.param_env()) {\n-                                    PointerKind::Frozen\n-                                } else {\n-                                    PointerKind::SharedMutable\n-                                }\n-                            }\n-                            hir::Mutability::Mut => {\n-                                // References to self-referential structures should not be considered\n-                                // noalias, as another pointer to the structure can be obtained, that\n-                                // is not based-on the original reference. We consider all !Unpin\n-                                // types to be potentially self-referential here.\n-                                if ty.is_unpin(tcx, cx.param_env()) {\n-                                    PointerKind::UniqueBorrowed\n-                                } else {\n-                                    PointerKind::UniqueBorrowedPinned\n-                                }\n-                            }\n-                        }\n-                    };\n+        let pointee_info = match *this.ty.kind() {\n+            ty::RawPtr(mt) if offset.bytes() == 0 => {\n+                tcx.layout_of(param_env.and(mt.ty)).ok().map(|layout| PointeeInfo {\n+                    size: layout.size,\n+                    align: layout.align.abi,\n+                    safe: None,\n+                })\n+            }\n+            ty::FnPtr(fn_sig) if offset.bytes() == 0 => {\n+                tcx.layout_of(param_env.and(tcx.mk_fn_ptr(fn_sig))).ok().map(|layout| PointeeInfo {\n+                    size: layout.size,\n+                    align: layout.align.abi,\n+                    safe: None,\n+                })\n+            }\n+            ty::Ref(_, ty, mt) if offset.bytes() == 0 => {\n+                // Use conservative pointer kind if not optimizing. This saves us the\n+                // Freeze/Unpin queries, and can save time in the codegen backend (noalias\n+                // attributes in LLVM have compile-time cost even in unoptimized builds).\n+                let optimize = tcx.sess.opts.optimize != OptLevel::No;\n+                let kind = match mt {\n+                    hir::Mutability::Not => PointerKind::SharedRef {\n+                        frozen: optimize && ty.is_freeze(tcx, cx.param_env()),\n+                    },\n+                    hir::Mutability::Mut => PointerKind::MutableRef {\n+                        unpin: optimize && ty.is_unpin(tcx, cx.param_env()),\n+                    },\n+                };\n \n-                    tcx.layout_of(param_env.and(ty)).ok().map(|layout| PointeeInfo {\n-                        size: layout.size,\n-                        align: layout.align.abi,\n-                        safe: Some(kind),\n-                    })\n-                }\n+                tcx.layout_of(param_env.and(ty)).ok().map(|layout| PointeeInfo {\n+                    size: layout.size,\n+                    align: layout.align.abi,\n+                    safe: Some(kind),\n+                })\n+            }\n \n-                _ => {\n-                    let mut data_variant = match this.variants {\n-                        // Within the discriminant field, only the niche itself is\n-                        // always initialized, so we only check for a pointer at its\n-                        // offset.\n-                        //\n-                        // If the niche is a pointer, it's either valid (according\n-                        // to its type), or null (which the niche field's scalar\n-                        // validity range encodes). This allows using\n-                        // `dereferenceable_or_null` for e.g., `Option<&T>`, and\n-                        // this will continue to work as long as we don't start\n-                        // using more niches than just null (e.g., the first page of\n-                        // the address space, or unaligned pointers).\n-                        Variants::Multiple {\n-                            tag_encoding: TagEncoding::Niche { untagged_variant, .. },\n-                            tag_field,\n-                            ..\n-                        } if this.fields.offset(tag_field) == offset => {\n-                            Some(this.for_variant(cx, untagged_variant))\n-                        }\n-                        _ => Some(this),\n-                    };\n+            _ => {\n+                let mut data_variant = match this.variants {\n+                    // Within the discriminant field, only the niche itself is\n+                    // always initialized, so we only check for a pointer at its\n+                    // offset.\n+                    //\n+                    // If the niche is a pointer, it's either valid (according\n+                    // to its type), or null (which the niche field's scalar\n+                    // validity range encodes). This allows using\n+                    // `dereferenceable_or_null` for e.g., `Option<&T>`, and\n+                    // this will continue to work as long as we don't start\n+                    // using more niches than just null (e.g., the first page of\n+                    // the address space, or unaligned pointers).\n+                    Variants::Multiple {\n+                        tag_encoding: TagEncoding::Niche { untagged_variant, .. },\n+                        tag_field,\n+                        ..\n+                    } if this.fields.offset(tag_field) == offset => {\n+                        Some(this.for_variant(cx, untagged_variant))\n+                    }\n+                    _ => Some(this),\n+                };\n \n-                    if let Some(variant) = data_variant {\n-                        // We're not interested in any unions.\n-                        if let FieldsShape::Union(_) = variant.fields {\n-                            data_variant = None;\n-                        }\n+                if let Some(variant) = data_variant {\n+                    // We're not interested in any unions.\n+                    if let FieldsShape::Union(_) = variant.fields {\n+                        data_variant = None;\n                     }\n+                }\n \n-                    let mut result = None;\n-\n-                    if let Some(variant) = data_variant {\n-                        // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n-                        // (requires passing in the expected address space from the caller)\n-                        let ptr_end = offset + Pointer(AddressSpace::DATA).size(cx);\n-                        for i in 0..variant.fields.count() {\n-                            let field_start = variant.fields.offset(i);\n-                            if field_start <= offset {\n-                                let field = variant.field(cx, i);\n-                                result = field.to_result().ok().and_then(|field| {\n-                                    if ptr_end <= field_start + field.size {\n-                                        // We found the right field, look inside it.\n-                                        let field_info =\n-                                            field.pointee_info_at(cx, offset - field_start);\n-                                        field_info\n-                                    } else {\n-                                        None\n-                                    }\n-                                });\n-                                if result.is_some() {\n-                                    break;\n+                let mut result = None;\n+\n+                if let Some(variant) = data_variant {\n+                    // FIXME(erikdesjardins): handle non-default addrspace ptr sizes\n+                    // (requires passing in the expected address space from the caller)\n+                    let ptr_end = offset + Pointer(AddressSpace::DATA).size(cx);\n+                    for i in 0..variant.fields.count() {\n+                        let field_start = variant.fields.offset(i);\n+                        if field_start <= offset {\n+                            let field = variant.field(cx, i);\n+                            result = field.to_result().ok().and_then(|field| {\n+                                if ptr_end <= field_start + field.size {\n+                                    // We found the right field, look inside it.\n+                                    let field_info =\n+                                        field.pointee_info_at(cx, offset - field_start);\n+                                    field_info\n+                                } else {\n+                                    None\n                                 }\n+                            });\n+                            if result.is_some() {\n+                                break;\n                             }\n                         }\n                     }\n+                }\n \n-                    // FIXME(eddyb) This should be for `ptr::Unique<T>`, not `Box<T>`.\n-                    if let Some(ref mut pointee) = result {\n-                        if let ty::Adt(def, _) = this.ty.kind() {\n-                            if def.is_box() && offset.bytes() == 0 {\n-                                pointee.safe = Some(PointerKind::UniqueOwned);\n-                            }\n+                // FIXME(eddyb) This should be for `ptr::Unique<T>`, not `Box<T>`.\n+                if let Some(ref mut pointee) = result {\n+                    if let ty::Adt(def, _) = this.ty.kind() {\n+                        if def.is_box() && offset.bytes() == 0 {\n+                            let optimize = tcx.sess.opts.optimize != OptLevel::No;\n+                            pointee.safe = Some(PointerKind::Box {\n+                                unpin: optimize && this.ty.boxed_ty().is_unpin(tcx, cx.param_env()),\n+                            });\n                         }\n                     }\n-\n-                    result\n                 }\n-            };\n+\n+                result\n+            }\n+        };\n \n         debug!(\n             \"pointee_info_at (offset={:?}, type kind: {:?}) => {:?}\","}, {"sha": "bbb4fd999bc76d38aac4c76668dc8c29cc8da9fa", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -675,8 +675,12 @@ pub trait PrettyPrinter<'tcx>:\n                 p!(\")\")\n             }\n             ty::FnDef(def_id, substs) => {\n-                let sig = self.tcx().fn_sig(def_id).subst(self.tcx(), substs);\n-                p!(print(sig), \" {{\", print_value_path(def_id, substs), \"}}\");\n+                if NO_QUERIES.with(|q| q.get()) {\n+                    p!(print_def_path(def_id, substs));\n+                } else {\n+                    let sig = self.tcx().fn_sig(def_id).subst(self.tcx(), substs);\n+                    p!(print(sig), \" {{\", print_value_path(def_id, substs), \"}}\");\n+                }\n             }\n             ty::FnPtr(ref bare_fn) => p!(print(bare_fn)),\n             ty::Infer(infer_ty) => {\n@@ -734,20 +738,22 @@ pub trait PrettyPrinter<'tcx>:\n             }\n             ty::Placeholder(placeholder) => p!(write(\"Placeholder({:?})\", placeholder)),\n             ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n-                // FIXME(eddyb) print this with `print_def_path`.\n                 // We use verbose printing in 'NO_QUERIES' mode, to\n                 // avoid needing to call `predicates_of`. This should\n                 // only affect certain debug messages (e.g. messages printed\n                 // from `rustc_middle::ty` during the computation of `tcx.predicates_of`),\n                 // and should have no effect on any compiler output.\n-                if self.should_print_verbose() || NO_QUERIES.with(|q| q.get()) {\n+                if self.should_print_verbose() {\n+                    // FIXME(eddyb) print this with `print_def_path`.\n                     p!(write(\"Opaque({:?}, {:?})\", def_id, substs));\n                     return Ok(self);\n                 }\n \n                 let parent = self.tcx().parent(def_id);\n                 match self.tcx().def_kind(parent) {\n                     DefKind::TyAlias | DefKind::AssocTy => {\n+                        // NOTE: I know we should check for NO_QUERIES here, but it's alright.\n+                        // `type_of` on a type alias or assoc type should never cause a cycle.\n                         if let ty::Alias(ty::Opaque, ty::AliasTy { def_id: d, .. }) =\n                             *self.tcx().type_of(parent).kind()\n                         {\n@@ -762,7 +768,14 @@ pub trait PrettyPrinter<'tcx>:\n                         p!(print_def_path(def_id, substs));\n                         return Ok(self);\n                     }\n-                    _ => return self.pretty_print_opaque_impl_type(def_id, substs),\n+                    _ => {\n+                        if NO_QUERIES.with(|q| q.get()) {\n+                            p!(print_def_path(def_id, &[]));\n+                            return Ok(self);\n+                        } else {\n+                            return self.pretty_print_opaque_impl_type(def_id, substs);\n+                        }\n+                    }\n                 }\n             }\n             ty::Str => p!(\"str\"),"}, {"sha": "7151b79c5ab63f4b4b7ba8a56a4e5cd275320889", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 20, "deletions": 40, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -106,16 +106,6 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-/// Helper for `TyCtxtEnsure` to avoid a closure.\n-#[inline(always)]\n-fn noop<T>(_: &T) {}\n-\n-/// Helper to ensure that queries only return `Copy` types.\n-#[inline(always)]\n-fn copy<T: Copy>(x: &T) -> T {\n-    *x\n-}\n-\n macro_rules! query_helper_param_ty {\n     (DefId) => { impl IntoQueryParam<DefId> };\n     (LocalDefId) => { impl IntoQueryParam<LocalDefId> };\n@@ -225,14 +215,10 @@ macro_rules! define_callbacks {\n                 let key = key.into_query_param();\n                 opt_remap_env_constness!([$($modifiers)*][key]);\n \n-                let cached = try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key, noop);\n-\n-                match cached {\n-                    Ok(()) => return,\n-                    Err(()) => (),\n-                }\n-\n-                self.tcx.queries.$name(self.tcx, DUMMY_SP, key, QueryMode::Ensure);\n+                match try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key) {\n+                    Some(_) => return,\n+                    None => self.tcx.queries.$name(self.tcx, DUMMY_SP, key, QueryMode::Ensure),\n+                };\n             })*\n         }\n \n@@ -254,14 +240,10 @@ macro_rules! define_callbacks {\n                 let key = key.into_query_param();\n                 opt_remap_env_constness!([$($modifiers)*][key]);\n \n-                let cached = try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key, copy);\n-\n-                match cached {\n-                    Ok(value) => return value,\n-                    Err(()) => (),\n+                match try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key) {\n+                    Some(value) => value,\n+                    None => self.tcx.queries.$name(self.tcx, self.span, key, QueryMode::Get).unwrap(),\n                 }\n-\n-                self.tcx.queries.$name(self.tcx, self.span, key, QueryMode::Get).unwrap()\n             })*\n         }\n \n@@ -353,27 +335,25 @@ macro_rules! define_feedable {\n                 let tcx = self.tcx;\n                 let cache = &tcx.query_caches.$name;\n \n-                let cached = try_get_cached(tcx, cache, &key, copy);\n-\n-                match cached {\n-                    Ok(old) => {\n+                match try_get_cached(tcx, cache, &key) {\n+                    Some(old) => {\n                         bug!(\n                             \"Trying to feed an already recorded value for query {} key={key:?}:\\nold value: {old:?}\\nnew value: {value:?}\",\n                             stringify!($name),\n+                        )\n+                    }\n+                    None => {\n+                        let dep_node = dep_graph::DepNode::construct(tcx, dep_graph::DepKind::$name, &key);\n+                        let dep_node_index = tcx.dep_graph.with_feed_task(\n+                            dep_node,\n+                            tcx,\n+                            key,\n+                            &value,\n+                            hash_result!([$($modifiers)*]),\n                         );\n+                        cache.complete(key, value, dep_node_index)\n                     }\n-                    Err(()) => (),\n                 }\n-\n-                let dep_node = dep_graph::DepNode::construct(tcx, dep_graph::DepKind::$name, &key);\n-                let dep_node_index = tcx.dep_graph.with_feed_task(\n-                    dep_node,\n-                    tcx,\n-                    key,\n-                    &value,\n-                    hash_result!([$($modifiers)*]),\n-                );\n-                cache.complete(key, value, dep_node_index)\n             }\n         })*\n     }"}, {"sha": "890dabde1f73d4fe2967aec911a9f3ac469019a0", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -629,6 +629,8 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n         b = tcx.expand_abstract_consts(b);\n     }\n \n+    debug!(\"{}.super_relate_consts(normed_a = {:?}, normed_b = {:?})\", relation.tag(), a, b);\n+\n     // Currently, the values that can be unified are primitive types,\n     // and those that derive both `PartialEq` and `Eq`, corresponding\n     // to structural-match types.\n@@ -665,30 +667,28 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n \n             // FIXME(generic_const_exprs): is it possible to relate two consts which are not identical\n             // exprs? Should we care about that?\n+            // FIXME(generic_const_exprs): relating the `ty()`s is a little weird since it is supposed to\n+            // ICE If they mismatch. Unfortunately `ConstKind::Expr` is a little special and can be thought\n+            // of as being generic over the argument types, however this is implicit so these types don't get\n+            // related when we relate the substs of the item this const arg is for.\n             let expr = match (ae, be) {\n-                (Expr::Binop(a_op, al, ar), Expr::Binop(b_op, bl, br))\n-                    if a_op == b_op && al.ty() == bl.ty() && ar.ty() == br.ty() =>\n-                {\n+                (Expr::Binop(a_op, al, ar), Expr::Binop(b_op, bl, br)) if a_op == b_op => {\n+                    r.relate(al.ty(), bl.ty())?;\n+                    r.relate(ar.ty(), br.ty())?;\n                     Expr::Binop(a_op, r.consts(al, bl)?, r.consts(ar, br)?)\n                 }\n-                (Expr::UnOp(a_op, av), Expr::UnOp(b_op, bv))\n-                    if a_op == b_op && av.ty() == bv.ty() =>\n-                {\n+                (Expr::UnOp(a_op, av), Expr::UnOp(b_op, bv)) if a_op == b_op => {\n+                    r.relate(av.ty(), bv.ty())?;\n                     Expr::UnOp(a_op, r.consts(av, bv)?)\n                 }\n-                (Expr::Cast(ak, av, at), Expr::Cast(bk, bv, bt))\n-                    if ak == bk && av.ty() == bv.ty() =>\n-                {\n+                (Expr::Cast(ak, av, at), Expr::Cast(bk, bv, bt)) if ak == bk => {\n+                    r.relate(av.ty(), bv.ty())?;\n                     Expr::Cast(ak, r.consts(av, bv)?, r.tys(at, bt)?)\n                 }\n                 (Expr::FunctionCall(af, aa), Expr::FunctionCall(bf, ba))\n-                    if aa.len() == ba.len()\n-                        && af.ty() == bf.ty()\n-                        && aa\n-                            .iter()\n-                            .zip(ba.iter())\n-                            .all(|(a_arg, b_arg)| a_arg.ty() == b_arg.ty()) =>\n+                    if aa.len() == ba.len() =>\n                 {\n+                    r.relate(af.ty(), bf.ty())?;\n                     let func = r.consts(af, bf)?;\n                     let mut related_args = Vec::with_capacity(aa.len());\n                     for (a_arg, b_arg) in aa.iter().zip(ba.iter()) {"}, {"sha": "98d6b68356368c14e06717b05a5c4ccc72e05915", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -2043,6 +2043,28 @@ impl<'tcx> Ty<'tcx> {\n         cf.is_break()\n     }\n \n+    /// Checks whether a type recursively contains any closure\n+    ///\n+    /// Example: `Option<[closure@file.rs:4:20]>` returns true\n+    pub fn contains_closure(self) -> bool {\n+        struct ContainsClosureVisitor;\n+\n+        impl<'tcx> TypeVisitor<'tcx> for ContainsClosureVisitor {\n+            type BreakTy = ();\n+\n+            fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+                if let ty::Closure(_, _) = t.kind() {\n+                    ControlFlow::Break(())\n+                } else {\n+                    t.super_visit_with(self)\n+                }\n+            }\n+        }\n+\n+        let cf = self.visit_with(&mut ContainsClosureVisitor);\n+        cf.is_break()\n+    }\n+\n     /// Returns the type and mutability of `*ty`.\n     ///\n     /// The parameter `explicit` indicates if this is an *explicit* dereference."}, {"sha": "f24b165d7c239345b13c7ac2647d89d6c20f10b7", "filename": "compiler/rustc_mir_build/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_mir_build%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_mir_build%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2FCargo.toml?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -11,7 +11,6 @@ tracing = \"0.1\"\n either = \"1\"\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_apfloat = { path = \"../rustc_apfloat\" }\n-rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_errors = { path = \"../rustc_errors\" }"}, {"sha": "cd0e69328634b33e2b70785e6f13fd75b865240f", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -439,10 +439,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         // We implicitly set the discriminant to 0. See\n                         // librustc_mir/transform/deaggregator.rs for details.\n                         let movability = movability.unwrap();\n-                        Box::new(AggregateKind::Generator(closure_id, substs, movability))\n+                        Box::new(AggregateKind::Generator(\n+                            closure_id.to_def_id(),\n+                            substs,\n+                            movability,\n+                        ))\n                     }\n                     UpvarSubsts::Closure(substs) => {\n-                        Box::new(AggregateKind::Closure(closure_id, substs))\n+                        Box::new(AggregateKind::Closure(closure_id.to_def_id(), substs))\n                     }\n                 };\n                 block.and(Rvalue::Aggregate(result, operands))"}, {"sha": "68c61a18d72fcde55c03c9e37ed6de8a8bd5c5d3", "filename": "compiler/rustc_mir_dataflow/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_mir_dataflow%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_mir_dataflow%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2FCargo.toml?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -19,6 +19,5 @@ rustc_index = { path = \"../rustc_index\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n-rustc_session = { path = \"../rustc_session\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "8bf6493be4b0168ba6e78d8be9d0cbb7c038382c", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -790,7 +790,7 @@ impl<V, T> TryFrom<ProjectionElem<V, T>> for TrackElem {\n }\n \n /// Invokes `f` on all direct fields of `ty`.\n-fn iter_fields<'tcx>(\n+pub fn iter_fields<'tcx>(\n     ty: Ty<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     mut f: impl FnMut(Option<VariantIdx>, Field, Ty<'tcx>),\n@@ -824,7 +824,7 @@ fn iter_fields<'tcx>(\n }\n \n /// Returns all locals with projections that have their reference or address taken.\n-fn excluded_locals(body: &Body<'_>) -> IndexVec<Local, bool> {\n+pub fn excluded_locals(body: &Body<'_>) -> IndexVec<Local, bool> {\n     struct Collector {\n         result: IndexVec<Local, bool>,\n     }"}, {"sha": "d00ee1f4babe8b3aed8b835ab633fca0db04c2e0", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -126,6 +126,7 @@ impl<'tcx> Visitor<'tcx> for UnsafetyChecker<'_, 'tcx> {\n                     }\n                 }\n                 &AggregateKind::Closure(def_id, _) | &AggregateKind::Generator(def_id, _, _) => {\n+                    let def_id = def_id.expect_local();\n                     let UnsafetyCheckResult { violations, used_unsafe_blocks, .. } =\n                         self.tcx.unsafety_check_result(def_id);\n                     self.register_violations(violations, used_unsafe_blocks.iter().copied());"}, {"sha": "4c7d45be0753e1944d25e60434463fb964a462b2", "filename": "compiler/rustc_mir_transform/src/copy_prop.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_mir_transform%2Fsrc%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_mir_transform%2Fsrc%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcopy_prop.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -162,17 +162,20 @@ impl<'tcx> MutVisitor<'tcx> for Replacer<'_, 'tcx> {\n     }\n \n     fn visit_statement(&mut self, stmt: &mut Statement<'tcx>, loc: Location) {\n-        if let StatementKind::StorageDead(l) = stmt.kind\n-            && self.storage_to_remove.contains(l)\n-        {\n-            stmt.make_nop();\n-        } else if let StatementKind::Assign(box (ref place, ref mut rvalue)) = stmt.kind\n-            && place.as_local().is_some()\n-        {\n-            // Do not replace assignments.\n-            self.visit_rvalue(rvalue, loc)\n-        } else {\n-            self.super_statement(stmt, loc);\n+        match stmt.kind {\n+            // When removing storage statements, we need to remove both (#107511).\n+            StatementKind::StorageLive(l) | StatementKind::StorageDead(l)\n+                if self.storage_to_remove.contains(l) =>\n+            {\n+                stmt.make_nop()\n+            }\n+            StatementKind::Assign(box (ref place, ref mut rvalue))\n+                if place.as_local().is_some() =>\n+            {\n+                // Do not replace assignments.\n+                self.visit_rvalue(rvalue, loc)\n+            }\n+            _ => self.super_statement(stmt, loc),\n         }\n     }\n }"}, {"sha": "949a59a97bfb6a6e56b75d88d31f84c092530b61", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -5,6 +5,7 @@\n use rustc_const_eval::const_eval::CheckAlignment;\n use rustc_const_eval::interpret::{ConstValue, ImmTy, Immediate, InterpCx, Scalar};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::def::DefKind;\n use rustc_middle::mir::visit::{MutVisitor, Visitor};\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -85,6 +86,30 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n         state: &mut State<Self::Value>,\n     ) {\n         match rvalue {\n+            Rvalue::Aggregate(kind, operands) => {\n+                let target = self.map().find(target.as_ref());\n+                if let Some(target) = target {\n+                    state.flood_idx_with(target, self.map(), FlatSet::Bottom);\n+                    let field_based = match **kind {\n+                        AggregateKind::Tuple | AggregateKind::Closure(..) => true,\n+                        AggregateKind::Adt(def_id, ..) => {\n+                            matches!(self.tcx.def_kind(def_id), DefKind::Struct)\n+                        }\n+                        _ => false,\n+                    };\n+                    if field_based {\n+                        for (field_index, operand) in operands.iter().enumerate() {\n+                            if let Some(field) = self\n+                                .map()\n+                                .apply(target, TrackElem::Field(Field::from_usize(field_index)))\n+                            {\n+                                let result = self.handle_operand(operand, state);\n+                                state.assign_idx(field, result, self.map());\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n             Rvalue::CheckedBinaryOp(op, box (left, right)) => {\n                 let target = self.map().find(target.as_ref());\n                 if let Some(target) = target {"}, {"sha": "fe272de20f8d085e7d0c88548f16382791209e0a", "filename": "compiler/rustc_mir_transform/src/deaggregator.rs", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6c8d4073a4490671b05f3b5f5e6810cfdc23a641/compiler%2Frustc_mir_transform%2Fsrc%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8d4073a4490671b05f3b5f5e6810cfdc23a641/compiler%2Frustc_mir_transform%2Fsrc%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdeaggregator.rs?ref=6c8d4073a4490671b05f3b5f5e6810cfdc23a641", "patch": "@@ -1,45 +0,0 @@\n-use crate::util::expand_aggregate;\n-use crate::MirPass;\n-use rustc_middle::mir::*;\n-use rustc_middle::ty::TyCtxt;\n-\n-pub struct Deaggregator;\n-\n-impl<'tcx> MirPass<'tcx> for Deaggregator {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        let basic_blocks = body.basic_blocks.as_mut_preserves_cfg();\n-        for bb in basic_blocks {\n-            bb.expand_statements(|stmt| {\n-                // FIXME(eddyb) don't match twice on `stmt.kind` (post-NLL).\n-                match stmt.kind {\n-                    // FIXME(#48193) Deaggregate arrays when it's cheaper to do so.\n-                    StatementKind::Assign(box (\n-                        _,\n-                        Rvalue::Aggregate(box AggregateKind::Array(_), _),\n-                    )) => {\n-                        return None;\n-                    }\n-                    StatementKind::Assign(box (_, Rvalue::Aggregate(_, _))) => {}\n-                    _ => return None,\n-                }\n-\n-                let stmt = stmt.replace_nop();\n-                let source_info = stmt.source_info;\n-                let StatementKind::Assign(box (lhs, Rvalue::Aggregate(kind, operands))) = stmt.kind else {\n-                    bug!();\n-                };\n-\n-                Some(expand_aggregate(\n-                    lhs,\n-                    operands.into_iter().map(|op| {\n-                        let ty = op.ty(&body.local_decls, tcx);\n-                        (op, ty)\n-                    }),\n-                    *kind,\n-                    source_info,\n-                    tcx,\n-                ))\n-            });\n-        }\n-    }\n-}"}, {"sha": "47f9d35a4f7ec5e7101fadb5bb3a04a0721d2aea", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -52,7 +52,6 @@\n \n use crate::deref_separator::deref_finder;\n use crate::simplify;\n-use crate::util::expand_aggregate;\n use crate::MirPass;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::pluralize;\n@@ -272,31 +271,26 @@ impl<'tcx> TransformVisitor<'tcx> {\n             assert_eq!(self.state_adt_ref.variant(idx).fields.len(), 0);\n \n             // FIXME(swatinem): assert that `val` is indeed unit?\n-            statements.extend(expand_aggregate(\n-                Place::return_place(),\n-                std::iter::empty(),\n-                kind,\n+            statements.push(Statement {\n+                kind: StatementKind::Assign(Box::new((\n+                    Place::return_place(),\n+                    Rvalue::Aggregate(Box::new(kind), vec![]),\n+                ))),\n                 source_info,\n-                self.tcx,\n-            ));\n+            });\n             return;\n         }\n \n         // else: `Poll::Ready(x)`, `GeneratorState::Yielded(x)` or `GeneratorState::Complete(x)`\n         assert_eq!(self.state_adt_ref.variant(idx).fields.len(), 1);\n \n-        let ty = self\n-            .tcx\n-            .bound_type_of(self.state_adt_ref.variant(idx).fields[0].did)\n-            .subst(self.tcx, self.state_substs);\n-\n-        statements.extend(expand_aggregate(\n-            Place::return_place(),\n-            std::iter::once((val, ty)),\n-            kind,\n+        statements.push(Statement {\n+            kind: StatementKind::Assign(Box::new((\n+                Place::return_place(),\n+                Rvalue::Aggregate(Box::new(kind), vec![val]),\n+            ))),\n             source_info,\n-            self.tcx,\n-        ));\n+        });\n     }\n \n     // Create a Place referencing a generator struct field"}, {"sha": "9070a7368b168049c6bae014116324261b1d490e", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -60,7 +60,6 @@ mod coverage;\n mod ctfe_limit;\n mod dataflow_const_prop;\n mod dead_store_elimination;\n-mod deaggregator;\n mod deduce_param_attrs;\n mod deduplicate_blocks;\n mod deref_separator;\n@@ -523,9 +522,6 @@ fn run_runtime_lowering_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         &elaborate_box_derefs::ElaborateBoxDerefs,\n         &generator::StateTransform,\n         &add_retag::AddRetag,\n-        // Deaggregator is necessary for const prop. We may want to consider implementing\n-        // CTFE support for aggregates.\n-        &deaggregator::Deaggregator,\n         &Lint(const_prop_lint::ConstProp),\n     ];\n     pm::run_passes_no_validate(tcx, body, passes, Some(MirPhase::Runtime(RuntimePhase::Initial)));"}, {"sha": "551422386f6e012aaa28ed75abcb76f210f38713", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -15,7 +15,6 @@ use rustc_target::spec::abi::Abi;\n use std::fmt;\n use std::iter;\n \n-use crate::util::expand_aggregate;\n use crate::{\n     abort_unwinding_calls, add_call_guards, add_moves_for_packed_drops, deref_separator,\n     pass_manager as pm, remove_noop_landing_pads, simplify,\n@@ -831,19 +830,23 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> Body<'_> {\n     // return;\n     debug!(\"build_ctor: variant_index={:?}\", variant_index);\n \n-    let statements = expand_aggregate(\n-        Place::return_place(),\n-        adt_def.variant(variant_index).fields.iter().enumerate().map(|(idx, field_def)| {\n-            (Operand::Move(Place::from(Local::new(idx + 1))), field_def.ty(tcx, substs))\n-        }),\n-        AggregateKind::Adt(adt_def.did(), variant_index, substs, None, None),\n+    let kind = AggregateKind::Adt(adt_def.did(), variant_index, substs, None, None);\n+    let variant = adt_def.variant(variant_index);\n+    let statement = Statement {\n+        kind: StatementKind::Assign(Box::new((\n+            Place::return_place(),\n+            Rvalue::Aggregate(\n+                Box::new(kind),\n+                (0..variant.fields.len())\n+                    .map(|idx| Operand::Move(Place::from(Local::new(idx + 1))))\n+                    .collect(),\n+            ),\n+        ))),\n         source_info,\n-        tcx,\n-    )\n-    .collect();\n+    };\n \n     let start_block = BasicBlockData {\n-        statements,\n+        statements: vec![statement],\n         terminator: Some(Terminator { source_info, kind: TerminatorKind::Return }),\n         is_cleanup: false,\n     };"}, {"sha": "26acd406ed8a9f81616240e55d6b533d680ed79c", "filename": "compiler/rustc_mir_transform/src/sroa.rs", "status": "modified", "additions": 253, "deletions": 178, "changes": 431, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1,10 +1,11 @@\n use crate::MirPass;\n-use rustc_data_structures::fx::{FxIndexMap, IndexEntry};\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n+use rustc_middle::mir::patch::MirPatch;\n use rustc_middle::mir::visit::*;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{Ty, TyCtxt};\n+use rustc_mir_dataflow::value_analysis::{excluded_locals, iter_fields};\n \n pub struct ScalarReplacementOfAggregates;\n \n@@ -13,27 +14,41 @@ impl<'tcx> MirPass<'tcx> for ScalarReplacementOfAggregates {\n         sess.mir_opt_level() >= 3\n     }\n \n+    #[instrument(level = \"debug\", skip(self, tcx, body))]\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        let escaping = escaping_locals(&*body);\n-        debug!(?escaping);\n-        let replacements = compute_flattening(tcx, body, escaping);\n-        debug!(?replacements);\n-        replace_flattened_locals(tcx, body, replacements);\n+        debug!(def_id = ?body.source.def_id());\n+        let mut excluded = excluded_locals(body);\n+        loop {\n+            debug!(?excluded);\n+            let escaping = escaping_locals(&excluded, body);\n+            debug!(?escaping);\n+            let replacements = compute_flattening(tcx, body, escaping);\n+            debug!(?replacements);\n+            let all_dead_locals = replace_flattened_locals(tcx, body, replacements);\n+            if !all_dead_locals.is_empty() {\n+                for local in excluded.indices() {\n+                    excluded[local] |= all_dead_locals.contains(local);\n+                }\n+                excluded.raw.resize(body.local_decls.len(), false);\n+            } else {\n+                break;\n+            }\n+        }\n     }\n }\n \n /// Identify all locals that are not eligible for SROA.\n ///\n /// There are 3 cases:\n-/// - the aggegated local is used or passed to other code (function parameters and arguments);\n+/// - the aggregated local is used or passed to other code (function parameters and arguments);\n /// - the locals is a union or an enum;\n /// - the local's address is taken, and thus the relative addresses of the fields are observable to\n ///   client code.\n-fn escaping_locals(body: &Body<'_>) -> BitSet<Local> {\n+fn escaping_locals(excluded: &IndexVec<Local, bool>, body: &Body<'_>) -> BitSet<Local> {\n     let mut set = BitSet::new_empty(body.local_decls.len());\n     set.insert_range(RETURN_PLACE..=Local::from_usize(body.arg_count));\n     for (local, decl) in body.local_decls().iter_enumerated() {\n-        if decl.ty.is_union() || decl.ty.is_enum() {\n+        if decl.ty.is_union() || decl.ty.is_enum() || excluded[local] {\n             set.insert(local);\n         }\n     }\n@@ -58,41 +73,33 @@ fn escaping_locals(body: &Body<'_>) -> BitSet<Local> {\n             self.super_place(place, context, location);\n         }\n \n-        fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n-            if let Rvalue::AddressOf(.., place) | Rvalue::Ref(.., place) = rvalue {\n-                if !place.is_indirect() {\n-                    // Raw pointers may be used to access anything inside the enclosing place.\n-                    self.set.insert(place.local);\n-                    return;\n+        fn visit_assign(\n+            &mut self,\n+            lvalue: &Place<'tcx>,\n+            rvalue: &Rvalue<'tcx>,\n+            location: Location,\n+        ) {\n+            if lvalue.as_local().is_some() {\n+                match rvalue {\n+                    // Aggregate assignments are expanded in run_pass.\n+                    Rvalue::Aggregate(..) | Rvalue::Use(..) => {\n+                        self.visit_rvalue(rvalue, location);\n+                        return;\n+                    }\n+                    _ => {}\n                 }\n             }\n-            self.super_rvalue(rvalue, location)\n+            self.super_assign(lvalue, rvalue, location)\n         }\n \n         fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n-            if let StatementKind::StorageLive(..)\n-            | StatementKind::StorageDead(..)\n-            | StatementKind::Deinit(..) = statement.kind\n-            {\n+            match statement.kind {\n                 // Storage statements are expanded in run_pass.\n-                return;\n+                StatementKind::StorageLive(..)\n+                | StatementKind::StorageDead(..)\n+                | StatementKind::Deinit(..) => return,\n+                _ => self.super_statement(statement, location),\n             }\n-            self.super_statement(statement, location)\n-        }\n-\n-        fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n-            // Drop implicitly calls `drop_in_place`, which takes a `&mut`.\n-            // This implies that `Drop` implicitly takes the address of the place.\n-            if let TerminatorKind::Drop { place, .. }\n-            | TerminatorKind::DropAndReplace { place, .. } = terminator.kind\n-            {\n-                if !place.is_indirect() {\n-                    // Raw pointers may be used to access anything inside the enclosing place.\n-                    self.set.insert(place.local);\n-                    return;\n-                }\n-            }\n-            self.super_terminator(terminator, location);\n         }\n \n         // We ignore anything that happens in debuginfo, since we expand it using\n@@ -103,7 +110,30 @@ fn escaping_locals(body: &Body<'_>) -> BitSet<Local> {\n \n #[derive(Default, Debug)]\n struct ReplacementMap<'tcx> {\n-    fields: FxIndexMap<PlaceRef<'tcx>, Local>,\n+    /// Pre-computed list of all \"new\" locals for each \"old\" local. This is used to expand storage\n+    /// and deinit statement and debuginfo.\n+    fragments: IndexVec<Local, Option<IndexVec<Field, Option<(Ty<'tcx>, Local)>>>>,\n+}\n+\n+impl<'tcx> ReplacementMap<'tcx> {\n+    fn replace_place(&self, tcx: TyCtxt<'tcx>, place: PlaceRef<'tcx>) -> Option<Place<'tcx>> {\n+        let &[PlaceElem::Field(f, _), ref rest @ ..] = place.projection else { return None; };\n+        let fields = self.fragments[place.local].as_ref()?;\n+        let (_, new_local) = fields[f]?;\n+        Some(Place { local: new_local, projection: tcx.intern_place_elems(&rest) })\n+    }\n+\n+    fn place_fragments(\n+        &self,\n+        place: Place<'tcx>,\n+    ) -> Option<impl Iterator<Item = (Field, Ty<'tcx>, Local)> + '_> {\n+        let local = place.as_local()?;\n+        let fields = self.fragments[local].as_ref()?;\n+        Some(fields.iter_enumerated().filter_map(|(field, &opt_ty_local)| {\n+            let (ty, local) = opt_ty_local?;\n+            Some((field, ty, local))\n+        }))\n+    }\n }\n \n /// Compute the replacement of flattened places into locals.\n@@ -115,83 +145,50 @@ fn compute_flattening<'tcx>(\n     body: &mut Body<'tcx>,\n     escaping: BitSet<Local>,\n ) -> ReplacementMap<'tcx> {\n-    let mut visitor = PreFlattenVisitor {\n-        tcx,\n-        escaping,\n-        local_decls: &mut body.local_decls,\n-        map: Default::default(),\n-    };\n-    for (block, bbdata) in body.basic_blocks.iter_enumerated() {\n-        visitor.visit_basic_block_data(block, bbdata);\n-    }\n-    return visitor.map;\n-\n-    struct PreFlattenVisitor<'tcx, 'll> {\n-        tcx: TyCtxt<'tcx>,\n-        local_decls: &'ll mut LocalDecls<'tcx>,\n-        escaping: BitSet<Local>,\n-        map: ReplacementMap<'tcx>,\n-    }\n-\n-    impl<'tcx, 'll> PreFlattenVisitor<'tcx, 'll> {\n-        fn create_place(&mut self, place: PlaceRef<'tcx>) {\n-            if self.escaping.contains(place.local) {\n-                return;\n-            }\n+    let mut fragments = IndexVec::from_elem(None, &body.local_decls);\n \n-            match self.map.fields.entry(place) {\n-                IndexEntry::Occupied(_) => {}\n-                IndexEntry::Vacant(v) => {\n-                    let ty = place.ty(&*self.local_decls, self.tcx).ty;\n-                    let local = self.local_decls.push(LocalDecl {\n-                        ty,\n-                        user_ty: None,\n-                        ..self.local_decls[place.local].clone()\n-                    });\n-                    v.insert(local);\n-                }\n-            }\n-        }\n-    }\n-\n-    impl<'tcx, 'll> Visitor<'tcx> for PreFlattenVisitor<'tcx, 'll> {\n-        fn visit_place(&mut self, place: &Place<'tcx>, _: PlaceContext, _: Location) {\n-            if let &[PlaceElem::Field(..), ..] = &place.projection[..] {\n-                let pr = PlaceRef { local: place.local, projection: &place.projection[..1] };\n-                self.create_place(pr)\n-            }\n+    for local in body.local_decls.indices() {\n+        if escaping.contains(local) {\n+            continue;\n         }\n+        let decl = body.local_decls[local].clone();\n+        let ty = decl.ty;\n+        iter_fields(ty, tcx, |variant, field, field_ty| {\n+            if variant.is_some() {\n+                // Downcasts are currently not supported.\n+                return;\n+            };\n+            let new_local =\n+                body.local_decls.push(LocalDecl { ty: field_ty, user_ty: None, ..decl.clone() });\n+            fragments.get_or_insert_with(local, IndexVec::new).insert(field, (field_ty, new_local));\n+        });\n     }\n+    ReplacementMap { fragments }\n }\n \n /// Perform the replacement computed by `compute_flattening`.\n fn replace_flattened_locals<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &mut Body<'tcx>,\n     replacements: ReplacementMap<'tcx>,\n-) {\n+) -> BitSet<Local> {\n     let mut all_dead_locals = BitSet::new_empty(body.local_decls.len());\n-    for p in replacements.fields.keys() {\n-        all_dead_locals.insert(p.local);\n+    for (local, replacements) in replacements.fragments.iter_enumerated() {\n+        if replacements.is_some() {\n+            all_dead_locals.insert(local);\n+        }\n     }\n     debug!(?all_dead_locals);\n     if all_dead_locals.is_empty() {\n-        return;\n+        return all_dead_locals;\n     }\n \n-    let mut fragments = IndexVec::new();\n-    for (k, v) in &replacements.fields {\n-        fragments.ensure_contains_elem(k.local, || Vec::new());\n-        fragments[k.local].push((k.projection, *v));\n-    }\n-    debug!(?fragments);\n-\n     let mut visitor = ReplacementVisitor {\n         tcx,\n         local_decls: &body.local_decls,\n-        replacements,\n+        replacements: &replacements,\n         all_dead_locals,\n-        fragments,\n+        patch: MirPatch::new(body),\n     };\n     for (bb, data) in body.basic_blocks.as_mut_preserves_cfg().iter_enumerated_mut() {\n         visitor.visit_basic_block_data(bb, data);\n@@ -205,47 +202,33 @@ fn replace_flattened_locals<'tcx>(\n     for var_debug_info in &mut body.var_debug_info {\n         visitor.visit_var_debug_info(var_debug_info);\n     }\n+    let ReplacementVisitor { patch, all_dead_locals, .. } = visitor;\n+    patch.apply(body);\n+    all_dead_locals\n }\n \n struct ReplacementVisitor<'tcx, 'll> {\n     tcx: TyCtxt<'tcx>,\n     /// This is only used to compute the type for `VarDebugInfoContents::Composite`.\n     local_decls: &'ll LocalDecls<'tcx>,\n     /// Work to do.\n-    replacements: ReplacementMap<'tcx>,\n+    replacements: &'ll ReplacementMap<'tcx>,\n     /// This is used to check that we are not leaving references to replaced locals behind.\n     all_dead_locals: BitSet<Local>,\n-    /// Pre-computed list of all \"new\" locals for each \"old\" local. This is used to expand storage\n-    /// and deinit statement and debuginfo.\n-    fragments: IndexVec<Local, Vec<(&'tcx [PlaceElem<'tcx>], Local)>>,\n+    patch: MirPatch<'tcx>,\n }\n \n-impl<'tcx, 'll> ReplacementVisitor<'tcx, 'll> {\n-    fn gather_debug_info_fragments(\n-        &self,\n-        place: PlaceRef<'tcx>,\n-    ) -> Vec<VarDebugInfoFragment<'tcx>> {\n+impl<'tcx> ReplacementVisitor<'tcx, '_> {\n+    fn gather_debug_info_fragments(&self, local: Local) -> Option<Vec<VarDebugInfoFragment<'tcx>>> {\n         let mut fragments = Vec::new();\n-        let parts = &self.fragments[place.local];\n-        for (proj, replacement_local) in parts {\n-            if proj.starts_with(place.projection) {\n-                fragments.push(VarDebugInfoFragment {\n-                    projection: proj[place.projection.len()..].to_vec(),\n-                    contents: Place::from(*replacement_local),\n-                });\n-            }\n-        }\n-        fragments\n-    }\n-\n-    fn replace_place(&self, place: PlaceRef<'tcx>) -> Option<Place<'tcx>> {\n-        if let &[PlaceElem::Field(..), ref rest @ ..] = place.projection {\n-            let pr = PlaceRef { local: place.local, projection: &place.projection[..1] };\n-            let local = self.replacements.fields.get(&pr)?;\n-            Some(Place { local: *local, projection: self.tcx.intern_place_elems(&rest) })\n-        } else {\n-            None\n+        let parts = self.replacements.place_fragments(local.into())?;\n+        for (field, ty, replacement_local) in parts {\n+            fragments.push(VarDebugInfoFragment {\n+                projection: vec![PlaceElem::Field(field, ty)],\n+                contents: Place::from(replacement_local),\n+            });\n         }\n+        Some(fragments)\n     }\n }\n \n@@ -254,94 +237,186 @@ impl<'tcx, 'll> MutVisitor<'tcx> for ReplacementVisitor<'tcx, 'll> {\n         self.tcx\n     }\n \n-    fn visit_statement(&mut self, statement: &mut Statement<'tcx>, location: Location) {\n-        if let StatementKind::StorageLive(..)\n-        | StatementKind::StorageDead(..)\n-        | StatementKind::Deinit(..) = statement.kind\n-        {\n-            // Storage statements are expanded in run_pass.\n-            return;\n-        }\n-        self.super_statement(statement, location)\n-    }\n-\n     fn visit_place(&mut self, place: &mut Place<'tcx>, context: PlaceContext, location: Location) {\n-        if let Some(repl) = self.replace_place(place.as_ref()) {\n+        if let Some(repl) = self.replacements.replace_place(self.tcx, place.as_ref()) {\n             *place = repl\n         } else {\n             self.super_place(place, context, location)\n         }\n     }\n \n+    #[instrument(level = \"trace\", skip(self))]\n+    fn visit_statement(&mut self, statement: &mut Statement<'tcx>, location: Location) {\n+        match statement.kind {\n+            // Duplicate storage and deinit statements, as they pretty much apply to all fields.\n+            StatementKind::StorageLive(l) => {\n+                if let Some(final_locals) = self.replacements.place_fragments(l.into()) {\n+                    for (_, _, fl) in final_locals {\n+                        self.patch.add_statement(location, StatementKind::StorageLive(fl));\n+                    }\n+                    statement.make_nop();\n+                }\n+                return;\n+            }\n+            StatementKind::StorageDead(l) => {\n+                if let Some(final_locals) = self.replacements.place_fragments(l.into()) {\n+                    for (_, _, fl) in final_locals {\n+                        self.patch.add_statement(location, StatementKind::StorageDead(fl));\n+                    }\n+                    statement.make_nop();\n+                }\n+                return;\n+            }\n+            StatementKind::Deinit(box place) => {\n+                if let Some(final_locals) = self.replacements.place_fragments(place) {\n+                    for (_, _, fl) in final_locals {\n+                        self.patch\n+                            .add_statement(location, StatementKind::Deinit(Box::new(fl.into())));\n+                    }\n+                    statement.make_nop();\n+                    return;\n+                }\n+            }\n+\n+            // We have `a = Struct { 0: x, 1: y, .. }`.\n+            // We replace it by\n+            // ```\n+            // a_0 = x\n+            // a_1 = y\n+            // ...\n+            // ```\n+            StatementKind::Assign(box (place, Rvalue::Aggregate(_, ref mut operands))) => {\n+                if let Some(local) = place.as_local()\n+                    && let Some(final_locals) = &self.replacements.fragments[local]\n+                {\n+                    // This is ok as we delete the statement later.\n+                    let operands = std::mem::take(operands);\n+                    for (&opt_ty_local, mut operand) in final_locals.iter().zip(operands) {\n+                        if let Some((_, new_local)) = opt_ty_local {\n+                            // Replace mentions of SROA'd locals that appear in the operand.\n+                            self.visit_operand(&mut operand, location);\n+\n+                            let rvalue = Rvalue::Use(operand);\n+                            self.patch.add_statement(\n+                                location,\n+                                StatementKind::Assign(Box::new((new_local.into(), rvalue))),\n+                            );\n+                        }\n+                    }\n+                    statement.make_nop();\n+                    return;\n+                }\n+            }\n+\n+            // We have `a = some constant`\n+            // We add the projections.\n+            // ```\n+            // a_0 = a.0\n+            // a_1 = a.1\n+            // ...\n+            // ```\n+            // ConstProp will pick up the pieces and replace them by actual constants.\n+            StatementKind::Assign(box (place, Rvalue::Use(Operand::Constant(_)))) => {\n+                if let Some(final_locals) = self.replacements.place_fragments(place) {\n+                    for (field, ty, new_local) in final_locals {\n+                        let rplace = self.tcx.mk_place_field(place, field, ty);\n+                        let rvalue = Rvalue::Use(Operand::Move(rplace));\n+                        self.patch.add_statement(\n+                            location,\n+                            StatementKind::Assign(Box::new((new_local.into(), rvalue))),\n+                        );\n+                    }\n+                    // We still need `place.local` to exist, so don't make it nop.\n+                    return;\n+                }\n+            }\n+\n+            // We have `a = move? place`\n+            // We replace it by\n+            // ```\n+            // a_0 = move? place.0\n+            // a_1 = move? place.1\n+            // ...\n+            // ```\n+            StatementKind::Assign(box (lhs, Rvalue::Use(ref op))) => {\n+                let (rplace, copy) = match *op {\n+                    Operand::Copy(rplace) => (rplace, true),\n+                    Operand::Move(rplace) => (rplace, false),\n+                    Operand::Constant(_) => bug!(),\n+                };\n+                if let Some(final_locals) = self.replacements.place_fragments(lhs) {\n+                    for (field, ty, new_local) in final_locals {\n+                        let rplace = self.tcx.mk_place_field(rplace, field, ty);\n+                        debug!(?rplace);\n+                        let rplace = self\n+                            .replacements\n+                            .replace_place(self.tcx, rplace.as_ref())\n+                            .unwrap_or(rplace);\n+                        debug!(?rplace);\n+                        let rvalue = if copy {\n+                            Rvalue::Use(Operand::Copy(rplace))\n+                        } else {\n+                            Rvalue::Use(Operand::Move(rplace))\n+                        };\n+                        self.patch.add_statement(\n+                            location,\n+                            StatementKind::Assign(Box::new((new_local.into(), rvalue))),\n+                        );\n+                    }\n+                    statement.make_nop();\n+                    return;\n+                }\n+            }\n+\n+            _ => {}\n+        }\n+        self.super_statement(statement, location)\n+    }\n+\n+    #[instrument(level = \"trace\", skip(self))]\n     fn visit_var_debug_info(&mut self, var_debug_info: &mut VarDebugInfo<'tcx>) {\n         match &mut var_debug_info.value {\n             VarDebugInfoContents::Place(ref mut place) => {\n-                if let Some(repl) = self.replace_place(place.as_ref()) {\n+                if let Some(repl) = self.replacements.replace_place(self.tcx, place.as_ref()) {\n                     *place = repl;\n-                } else if self.all_dead_locals.contains(place.local) {\n+                } else if let Some(local) = place.as_local()\n+                    && let Some(fragments) = self.gather_debug_info_fragments(local)\n+                {\n                     let ty = place.ty(self.local_decls, self.tcx).ty;\n-                    let fragments = self.gather_debug_info_fragments(place.as_ref());\n                     var_debug_info.value = VarDebugInfoContents::Composite { ty, fragments };\n                 }\n             }\n             VarDebugInfoContents::Composite { ty: _, ref mut fragments } => {\n                 let mut new_fragments = Vec::new();\n+                debug!(?fragments);\n                 fragments\n                     .drain_filter(|fragment| {\n-                        if let Some(repl) = self.replace_place(fragment.contents.as_ref()) {\n+                        if let Some(repl) =\n+                            self.replacements.replace_place(self.tcx, fragment.contents.as_ref())\n+                        {\n                             fragment.contents = repl;\n-                            true\n-                        } else if self.all_dead_locals.contains(fragment.contents.local) {\n-                            let frg = self.gather_debug_info_fragments(fragment.contents.as_ref());\n+                            false\n+                        } else if let Some(local) = fragment.contents.as_local()\n+                            && let Some(frg) = self.gather_debug_info_fragments(local)\n+                        {\n                             new_fragments.extend(frg.into_iter().map(|mut f| {\n                                 f.projection.splice(0..0, fragment.projection.iter().copied());\n                                 f\n                             }));\n-                            false\n-                        } else {\n                             true\n+                        } else {\n+                            false\n                         }\n                     })\n                     .for_each(drop);\n+                debug!(?fragments);\n+                debug!(?new_fragments);\n                 fragments.extend(new_fragments);\n             }\n             VarDebugInfoContents::Const(_) => {}\n         }\n     }\n \n-    fn visit_basic_block_data(&mut self, bb: BasicBlock, bbdata: &mut BasicBlockData<'tcx>) {\n-        self.super_basic_block_data(bb, bbdata);\n-\n-        #[derive(Debug)]\n-        enum Stmt {\n-            StorageLive,\n-            StorageDead,\n-            Deinit,\n-        }\n-\n-        bbdata.expand_statements(|stmt| {\n-            let source_info = stmt.source_info;\n-            let (stmt, origin_local) = match &stmt.kind {\n-                StatementKind::StorageLive(l) => (Stmt::StorageLive, *l),\n-                StatementKind::StorageDead(l) => (Stmt::StorageDead, *l),\n-                StatementKind::Deinit(p) if let Some(l) = p.as_local() => (Stmt::Deinit, l),\n-                _ => return None,\n-            };\n-            if !self.all_dead_locals.contains(origin_local) {\n-                return None;\n-            }\n-            let final_locals = self.fragments.get(origin_local)?;\n-            Some(final_locals.iter().map(move |&(_, l)| {\n-                let kind = match stmt {\n-                    Stmt::StorageLive => StatementKind::StorageLive(l),\n-                    Stmt::StorageDead => StatementKind::StorageDead(l),\n-                    Stmt::Deinit => StatementKind::Deinit(Box::new(l.into())),\n-                };\n-                Statement { source_info, kind }\n-            }))\n-        });\n-    }\n-\n     fn visit_local(&mut self, local: &mut Local, _: PlaceContext, _: Location) {\n         assert!(!self.all_dead_locals.contains(*local));\n     }"}, {"sha": "0c11e0026900e4c2f5b5c6abb931ca3a460f8cc4", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1,3 +1,5 @@\n+use std::borrow::Cow;\n+\n use rustc_ast::token::Token;\n use rustc_ast::{Path, Visibility};\n use rustc_errors::{fluent, AddToDiagnostic, Applicability, EmissionGuarantee, IntoDiagnostic};\n@@ -431,6 +433,18 @@ pub(crate) enum MissingInInForLoopSub {\n     AddIn(#[primary_span] Span),\n }\n \n+#[derive(Diagnostic)]\n+#[diag(parse_missing_expression_in_for_loop)]\n+pub(crate) struct MissingExpressionInForLoop {\n+    #[primary_span]\n+    #[suggestion(\n+        code = \"/* expression */ \",\n+        applicability = \"has-placeholders\",\n+        style = \"verbose\"\n+    )]\n+    pub span: Span,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(parse_missing_comma_after_match_arm)]\n pub(crate) struct MissingCommaAfterMatchArm {\n@@ -668,13 +682,10 @@ pub(crate) struct InclusiveRangeExtraEquals {\n #[diag(parse_inclusive_range_match_arrow)]\n pub(crate) struct InclusiveRangeMatchArrow {\n     #[primary_span]\n+    pub arrow: Span,\n+    #[label]\n     pub span: Span,\n-    #[suggestion(\n-        suggestion_add_space,\n-        style = \"verbose\",\n-        code = \" \",\n-        applicability = \"machine-applicable\"\n-    )]\n+    #[suggestion(style = \"verbose\", code = \" \", applicability = \"machine-applicable\")]\n     pub after_pat: Span,\n }\n \n@@ -1590,6 +1601,14 @@ pub(crate) struct UnexpectedSelfInGenericParameters {\n     pub span: Span,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(parse_unexpected_default_value_for_lifetime_in_generic_parameters)]\n+pub(crate) struct UnexpectedDefaultValueForLifetimeInGenericParameters {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(parse_multiple_where_clauses)]\n pub(crate) struct MultipleWhereClauses {\n@@ -1802,8 +1821,9 @@ pub(crate) struct EnumPatternInsteadOfIdentifier {\n #[diag(parse_dot_dot_dot_for_remaining_fields)]\n pub(crate) struct DotDotDotForRemainingFields {\n     #[primary_span]\n-    #[suggestion(code = \"..\", applicability = \"machine-applicable\")]\n+    #[suggestion(code = \"..\", style = \"verbose\", applicability = \"machine-applicable\")]\n     pub span: Span,\n+    pub token_str: Cow<'static, str>,\n }\n \n #[derive(Diagnostic)]"}, {"sha": "dbd3b76786f42c56d67f44aee2c6d5f588212baa", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -469,6 +469,6 @@ mod size_asserts {\n     use rustc_data_structures::static_assert_size;\n     // tidy-alphabetical-start\n     static_assert_size!(AttrWrapper, 16);\n-    static_assert_size!(LazyAttrTokenStreamImpl, 144);\n+    static_assert_size!(LazyAttrTokenStreamImpl, 120);\n     // tidy-alphabetical-end\n }"}, {"sha": "cd9d85b1d919c9c3f45541e83a9223857550be9c", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -2394,7 +2394,7 @@ impl<'a> Parser<'a> {\n \n     /// Some special error handling for the \"top-level\" patterns in a match arm,\n     /// `for` loop, `let`, &c. (in contrast to subpatterns within such).\n-    pub(crate) fn maybe_recover_colon_colon_in_pat_typo_or_anon_enum(\n+    pub(crate) fn maybe_recover_colon_colon_in_pat_typo(\n         &mut self,\n         mut first_pat: P<Pat>,\n         expected: Option<Expected>,\n@@ -2435,8 +2435,9 @@ impl<'a> Parser<'a> {\n         // Create error for \"unexpected `:`\".\n         match self.expected_one_of_not_found(&[], &[]) {\n             Err(mut err) => {\n-                snapshot_pat.bump(); // Skip the `:`.\n-                snapshot_type.bump(); // Skip the `:`.\n+                // Skip the `:`.\n+                snapshot_pat.bump();\n+                snapshot_type.bump();\n                 match snapshot_pat.parse_pat_no_top_alt(expected) {\n                     Err(inner_err) => {\n                         inner_err.cancel();"}, {"sha": "c37808f8c3d19b244e01abe806ef5f50e59ccba9", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 113, "deletions": 100, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -5,26 +5,7 @@ use super::{\n     AttrWrapper, BlockMode, ClosureSpans, ForceCollect, Parser, PathStyle, Restrictions,\n     SemiColonMode, SeqSep, TokenExpectType, TokenType, TrailingToken,\n };\n-use crate::errors::{\n-    ArrayBracketsInsteadOfSpaces, ArrayBracketsInsteadOfSpacesSugg, AsyncBlockIn2015,\n-    AsyncMoveOrderIncorrect, BracesForStructLiteral, CatchAfterTry, CommaAfterBaseStruct,\n-    ComparisonInterpretedAsGeneric, ComparisonOrShiftInterpretedAsGenericSugg,\n-    DoCatchSyntaxRemoved, DotDotDot, EqFieldInit, ExpectedElseBlock, ExpectedEqForLetExpr,\n-    ExpectedExpressionFoundLet, FieldExpressionWithGeneric, FloatLiteralRequiresIntegerPart,\n-    FoundExprWouldBeStmt, HelpUseLatestEdition, IfExpressionLetSomeSub,\n-    IfExpressionMissingCondition, IfExpressionMissingThenBlock, IfExpressionMissingThenBlockSub,\n-    InvalidBlockMacroSegment, InvalidComparisonOperator, InvalidComparisonOperatorSub,\n-    InvalidInterpolatedExpression, InvalidLiteralSuffixOnTupleIndex, InvalidLogicalOperator,\n-    InvalidLogicalOperatorSub, LabeledLoopInBreak, LeadingPlusNotSupported, LeftArrowOperator,\n-    LifetimeInBorrowExpression, MacroInvocationWithQualifiedPath, MalformedLoopLabel,\n-    MatchArmBodyWithoutBraces, MatchArmBodyWithoutBracesSugg, MissingCommaAfterMatchArm,\n-    MissingDotDot, MissingInInForLoop, MissingInInForLoopSub, MissingSemicolonBeforeArray,\n-    NoFieldsForFnCall, NotAsNegationOperator, NotAsNegationOperatorSub,\n-    OuterAttributeNotAllowedOnIfElse, ParenthesesWithStructFields,\n-    RequireColonAfterLabeledExpression, ShiftInterpretedAsGeneric, StructLiteralNotAllowedHere,\n-    StructLiteralNotAllowedHereSugg, TildeAsUnaryOperator, UnexpectedIfWithIf,\n-    UnexpectedTokenAfterLabel, UnexpectedTokenAfterLabelSugg, WrapExpressionInParentheses,\n-};\n+use crate::errors;\n use crate::maybe_recover_from_interpolated_ty_qpath;\n use core::mem;\n use rustc_ast::ptr::P;\n@@ -244,10 +225,10 @@ impl<'a> Parser<'a> {\n                 }\n                 .into();\n                 let invalid = format!(\"{}=\", &sugg);\n-                self.sess.emit_err(InvalidComparisonOperator {\n+                self.sess.emit_err(errors::InvalidComparisonOperator {\n                     span: sp,\n                     invalid: invalid.clone(),\n-                    sub: InvalidComparisonOperatorSub::Correctable {\n+                    sub: errors::InvalidComparisonOperatorSub::Correctable {\n                         span: sp,\n                         invalid,\n                         correct: sugg,\n@@ -262,10 +243,10 @@ impl<'a> Parser<'a> {\n                 && self.prev_token.span.hi() == self.token.span.lo()\n             {\n                 let sp = op.span.to(self.token.span);\n-                self.sess.emit_err(InvalidComparisonOperator {\n+                self.sess.emit_err(errors::InvalidComparisonOperator {\n                     span: sp,\n                     invalid: \"<>\".into(),\n-                    sub: InvalidComparisonOperatorSub::Correctable {\n+                    sub: errors::InvalidComparisonOperatorSub::Correctable {\n                         span: sp,\n                         invalid: \"<>\".into(),\n                         correct: \"!=\".into(),\n@@ -280,10 +261,10 @@ impl<'a> Parser<'a> {\n                 && self.prev_token.span.hi() == self.token.span.lo()\n             {\n                 let sp = op.span.to(self.token.span);\n-                self.sess.emit_err(InvalidComparisonOperator {\n+                self.sess.emit_err(errors::InvalidComparisonOperator {\n                     span: sp,\n                     invalid: \"<=>\".into(),\n-                    sub: InvalidComparisonOperatorSub::Spaceship(sp),\n+                    sub: errors::InvalidComparisonOperatorSub::Spaceship(sp),\n                 });\n                 self.bump();\n             }\n@@ -420,7 +401,7 @@ impl<'a> Parser<'a> {\n     /// but the next token implies this should be parsed as an expression.\n     /// For example: `if let Some(x) = x { x } else { 0 } / 2`.\n     fn error_found_expr_would_be_stmt(&self, lhs: &Expr) {\n-        self.sess.emit_err(FoundExprWouldBeStmt {\n+        self.sess.emit_err(errors::FoundExprWouldBeStmt {\n             span: self.token.span,\n             token: self.token.clone(),\n             suggestion: ExprParenthesesNeeded::surrounding(lhs.span),\n@@ -447,18 +428,18 @@ impl<'a> Parser<'a> {\n             }\n             (Some(op), _) => (op, self.token.span),\n             (None, Some((Ident { name: sym::and, span }, false))) if self.may_recover() => {\n-                self.sess.emit_err(InvalidLogicalOperator {\n+                self.sess.emit_err(errors::InvalidLogicalOperator {\n                     span: self.token.span,\n                     incorrect: \"and\".into(),\n-                    sub: InvalidLogicalOperatorSub::Conjunction(self.token.span),\n+                    sub: errors::InvalidLogicalOperatorSub::Conjunction(self.token.span),\n                 });\n                 (AssocOp::LAnd, span)\n             }\n             (None, Some((Ident { name: sym::or, span }, false))) if self.may_recover() => {\n-                self.sess.emit_err(InvalidLogicalOperator {\n+                self.sess.emit_err(errors::InvalidLogicalOperator {\n                     span: self.token.span,\n                     incorrect: \"or\".into(),\n-                    sub: InvalidLogicalOperatorSub::Disjunction(self.token.span),\n+                    sub: errors::InvalidLogicalOperatorSub::Disjunction(self.token.span),\n                 });\n                 (AssocOp::LOr, span)\n             }\n@@ -581,8 +562,11 @@ impl<'a> Parser<'a> {\n             }\n             // `+lit`\n             token::BinOp(token::Plus) if this.look_ahead(1, |tok| tok.is_numeric_lit()) => {\n-                let mut err =\n-                    LeadingPlusNotSupported { span: lo, remove_plus: None, add_parentheses: None };\n+                let mut err = errors::LeadingPlusNotSupported {\n+                    span: lo,\n+                    remove_plus: None,\n+                    add_parentheses: None,\n+                };\n \n                 // a block on the LHS might have been intended to be an expression instead\n                 if let Some(sp) = this.sess.ambiguous_block_expr_parse.borrow().get(&lo) {\n@@ -633,7 +617,7 @@ impl<'a> Parser<'a> {\n \n     /// Recover on `~expr` in favor of `!expr`.\n     fn recover_tilde_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n-        self.sess.emit_err(TildeAsUnaryOperator(lo));\n+        self.sess.emit_err(errors::TildeAsUnaryOperator(lo));\n \n         self.parse_unary_expr(lo, UnOp::Not)\n     }\n@@ -661,14 +645,14 @@ impl<'a> Parser<'a> {\n         let negated_token = self.look_ahead(1, |t| t.clone());\n \n         let sub_diag = if negated_token.is_numeric_lit() {\n-            NotAsNegationOperatorSub::SuggestNotBitwise\n+            errors::NotAsNegationOperatorSub::SuggestNotBitwise\n         } else if negated_token.is_bool_lit() {\n-            NotAsNegationOperatorSub::SuggestNotLogical\n+            errors::NotAsNegationOperatorSub::SuggestNotLogical\n         } else {\n-            NotAsNegationOperatorSub::SuggestNotDefault\n+            errors::NotAsNegationOperatorSub::SuggestNotDefault\n         };\n \n-        self.sess.emit_err(NotAsNegationOperator {\n+        self.sess.emit_err(errors::NotAsNegationOperator {\n             negated: negated_token.span,\n             negated_desc: super::token_descr(&negated_token),\n             // Span the `not` plus trailing whitespace to avoid\n@@ -739,7 +723,7 @@ impl<'a> Parser<'a> {\n                         match self.parse_labeled_expr(label, false) {\n                             Ok(expr) => {\n                                 type_err.cancel();\n-                                self.sess.emit_err(MalformedLoopLabel {\n+                                self.sess.emit_err(errors::MalformedLoopLabel {\n                                     span: label.ident.span,\n                                     correct_label: label.ident,\n                                 });\n@@ -764,20 +748,22 @@ impl<'a> Parser<'a> {\n                         );\n \n                         let args_span = self.look_ahead(1, |t| t.span).to(span_after_type);\n-                        let suggestion = ComparisonOrShiftInterpretedAsGenericSugg {\n+                        let suggestion = errors::ComparisonOrShiftInterpretedAsGenericSugg {\n                             left: expr.span.shrink_to_lo(),\n                             right: expr.span.shrink_to_hi(),\n                         };\n \n                         match self.token.kind {\n-                            token::Lt => self.sess.emit_err(ComparisonInterpretedAsGeneric {\n-                                comparison: self.token.span,\n-                                r#type: path,\n-                                args: args_span,\n-                                suggestion,\n-                            }),\n+                            token::Lt => {\n+                                self.sess.emit_err(errors::ComparisonInterpretedAsGeneric {\n+                                    comparison: self.token.span,\n+                                    r#type: path,\n+                                    args: args_span,\n+                                    suggestion,\n+                                })\n+                            }\n                             token::BinOp(token::Shl) => {\n-                                self.sess.emit_err(ShiftInterpretedAsGeneric {\n+                                self.sess.emit_err(errors::ShiftInterpretedAsGeneric {\n                                     shift: self.token.span,\n                                     r#type: path,\n                                     args: args_span,\n@@ -918,7 +904,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn error_remove_borrow_lifetime(&self, span: Span, lt_span: Span) {\n-        self.sess.emit_err(LifetimeInBorrowExpression { span, lifetime_span: lt_span });\n+        self.sess.emit_err(errors::LifetimeInBorrowExpression { span, lifetime_span: lt_span });\n     }\n \n     /// Parse `mut?` or `raw [ const | mut ]`.\n@@ -1212,14 +1198,14 @@ impl<'a> Parser<'a> {\n                         let close_paren = self.prev_token.span;\n                         let span = lo.to(self.prev_token.span);\n                         if !fields.is_empty() {\n-                            let mut replacement_err = ParenthesesWithStructFields {\n+                            let mut replacement_err = errors::ParenthesesWithStructFields {\n                                 span,\n                                 r#type: path,\n-                                braces_for_struct: BracesForStructLiteral {\n+                                braces_for_struct: errors::BracesForStructLiteral {\n                                     first: open_paren,\n                                     second: close_paren,\n                                 },\n-                                no_fields_for_fn: NoFieldsForFnCall {\n+                                no_fields_for_fn: errors::NoFieldsForFnCall {\n                                     fields: fields\n                                         .into_iter()\n                                         .map(|field| field.span.until(field.expr.span))\n@@ -1286,7 +1272,7 @@ impl<'a> Parser<'a> {\n         } else {\n             // Field access `expr.f`\n             if let Some(args) = seg.args {\n-                self.sess.emit_err(FieldExpressionWithGeneric(args.span()));\n+                self.sess.emit_err(errors::FieldExpressionWithGeneric(args.span()));\n             }\n \n             let span = lo.to(self.prev_token.span);\n@@ -1500,7 +1486,7 @@ impl<'a> Parser<'a> {\n         let (span, kind) = if self.eat(&token::Not) {\n             // MACRO INVOCATION expression\n             if qself.is_some() {\n-                self.sess.emit_err(MacroInvocationWithQualifiedPath(path.span));\n+                self.sess.emit_err(errors::MacroInvocationWithQualifiedPath(path.span));\n             }\n             let lo = path.span;\n             let mac = P(MacCall {\n@@ -1550,7 +1536,7 @@ impl<'a> Parser<'a> {\n         {\n             let (lit, _) =\n                 self.recover_unclosed_char(label_.ident, Parser::mk_token_lit_char, |self_| {\n-                    self_.sess.create_err(UnexpectedTokenAfterLabel {\n+                    self_.sess.create_err(errors::UnexpectedTokenAfterLabel {\n                         span: self_.token.span,\n                         remove_label: None,\n                         enclose_in_block: None,\n@@ -1562,15 +1548,15 @@ impl<'a> Parser<'a> {\n             && (self.check_noexpect(&TokenKind::Comma) || self.check_noexpect(&TokenKind::Gt))\n         {\n             // We're probably inside of a `Path<'a>` that needs a turbofish\n-            self.sess.emit_err(UnexpectedTokenAfterLabel {\n+            self.sess.emit_err(errors::UnexpectedTokenAfterLabel {\n                 span: self.token.span,\n                 remove_label: None,\n                 enclose_in_block: None,\n             });\n             consume_colon = false;\n             Ok(self.mk_expr_err(lo))\n         } else {\n-            let mut err = UnexpectedTokenAfterLabel {\n+            let mut err = errors::UnexpectedTokenAfterLabel {\n                 span: self.token.span,\n                 remove_label: None,\n                 enclose_in_block: None,\n@@ -1606,7 +1592,7 @@ impl<'a> Parser<'a> {\n                     return expr;\n                 }\n \n-                err.enclose_in_block = Some(UnexpectedTokenAfterLabelSugg {\n+                err.enclose_in_block = Some(errors::UnexpectedTokenAfterLabelSugg {\n                     left: span.shrink_to_lo(),\n                     right: span.shrink_to_hi(),\n                 });\n@@ -1622,7 +1608,7 @@ impl<'a> Parser<'a> {\n         }?;\n \n         if !ate_colon && consume_colon {\n-            self.sess.emit_err(RequireColonAfterLabeledExpression {\n+            self.sess.emit_err(errors::RequireColonAfterLabeledExpression {\n                 span: expr.span,\n                 label: lo,\n                 label_end: lo.shrink_to_hi(),\n@@ -1671,7 +1657,7 @@ impl<'a> Parser<'a> {\n         self.bump(); // `catch`\n \n         let span = lo.to(self.prev_token.span);\n-        self.sess.emit_err(DoCatchSyntaxRemoved { span });\n+        self.sess.emit_err(errors::DoCatchSyntaxRemoved { span });\n \n         self.parse_try_block(lo)\n     }\n@@ -1719,9 +1705,9 @@ impl<'a> Parser<'a> {\n             // The value expression can be a labeled loop, see issue #86948, e.g.:\n             // `loop { break 'label: loop { break 'label 42; }; }`\n             let lexpr = self.parse_labeled_expr(label, true)?;\n-            self.sess.emit_err(LabeledLoopInBreak {\n+            self.sess.emit_err(errors::LabeledLoopInBreak {\n                 span: lexpr.span,\n-                sub: WrapExpressionInParentheses {\n+                sub: errors::WrapExpressionInParentheses {\n                     left: lexpr.span.shrink_to_lo(),\n                     right: lexpr.span.shrink_to_hi(),\n                 },\n@@ -1841,7 +1827,7 @@ impl<'a> Parser<'a> {\n             };\n             if let Some(expr) = expr {\n                 if matches!(expr.kind, ExprKind::Err) {\n-                    let mut err = InvalidInterpolatedExpression { span: self.token.span }\n+                    let mut err = errors::InvalidInterpolatedExpression { span: self.token.span }\n                         .into_diagnostic(&self.sess.span_diagnostic);\n                     err.downgrade_to_delayed_bug();\n                     return Err(err);\n@@ -1902,7 +1888,7 @@ impl<'a> Parser<'a> {\n             });\n             if let Some(token) = &recovered {\n                 self.bump();\n-                self.sess.emit_err(FloatLiteralRequiresIntegerPart {\n+                self.sess.emit_err(errors::FloatLiteralRequiresIntegerPart {\n                     span: token.span,\n                     correct: pprust::token_to_string(token).into_owned(),\n                 });\n@@ -1963,13 +1949,17 @@ impl<'a> Parser<'a> {\n         if [sym::i32, sym::u32, sym::isize, sym::usize].contains(&suffix) {\n             // #59553: warn instead of reject out of hand to allow the fix to percolate\n             // through the ecosystem when people fix their macros\n-            self.sess.emit_warning(InvalidLiteralSuffixOnTupleIndex {\n+            self.sess.emit_warning(errors::InvalidLiteralSuffixOnTupleIndex {\n                 span,\n                 suffix,\n                 exception: Some(()),\n             });\n         } else {\n-            self.sess.emit_err(InvalidLiteralSuffixOnTupleIndex { span, suffix, exception: None });\n+            self.sess.emit_err(errors::InvalidLiteralSuffixOnTupleIndex {\n+                span,\n+                suffix,\n+                exception: None,\n+            });\n         }\n     }\n \n@@ -2003,9 +1993,9 @@ impl<'a> Parser<'a> {\n         let mut snapshot = self.create_snapshot_for_diagnostic();\n         match snapshot.parse_array_or_repeat_expr(Delimiter::Brace) {\n             Ok(arr) => {\n-                self.sess.emit_err(ArrayBracketsInsteadOfSpaces {\n+                self.sess.emit_err(errors::ArrayBracketsInsteadOfSpaces {\n                     span: arr.span,\n-                    sub: ArrayBracketsInsteadOfSpacesSugg {\n+                    sub: errors::ArrayBracketsInsteadOfSpacesSugg {\n                         left: lo,\n                         right: snapshot.prev_token.span,\n                     },\n@@ -2051,7 +2041,7 @@ impl<'a> Parser<'a> {\n                         .span_to_snippet(snapshot.token.span)\n                         .map_or(false, |snippet| snippet == \"]\") =>\n                 {\n-                    return Err(MissingSemicolonBeforeArray {\n+                    return Err(errors::MissingSemicolonBeforeArray {\n                         open_delim: open_delim_span,\n                         semicolon: prev_span.shrink_to_hi(),\n                     }.into_diagnostic(&self.sess.span_diagnostic));\n@@ -2077,7 +2067,7 @@ impl<'a> Parser<'a> {\n         }\n \n         if self.token.is_whole_block() {\n-            self.sess.emit_err(InvalidBlockMacroSegment {\n+            self.sess.emit_err(errors::InvalidBlockMacroSegment {\n                 span: self.token.span,\n                 context: lo.to(self.token.span),\n             });\n@@ -2109,7 +2099,7 @@ impl<'a> Parser<'a> {\n             ClosureBinder::NotPresent\n         };\n \n-        let constness = self.parse_constness(Case::Sensitive);\n+        let constness = self.parse_closure_constness(Case::Sensitive);\n \n         let movability =\n             if self.eat_keyword(kw::Static) { Movability::Static } else { Movability::Movable };\n@@ -2141,7 +2131,7 @@ impl<'a> Parser<'a> {\n         }\n \n         if self.token.kind == TokenKind::Semi\n-            && matches!(self.token_cursor.frame.delim_sp, Some((Delimiter::Parenthesis, _)))\n+            && matches!(self.token_cursor.stack.last(), Some((_, Delimiter::Parenthesis, _)))\n             && self.may_recover()\n         {\n             // It is likely that the closure body is a block but where the\n@@ -2181,7 +2171,7 @@ impl<'a> Parser<'a> {\n             // Check for `move async` and recover\n             if self.check_keyword(kw::Async) {\n                 let move_async_span = self.token.span.with_lo(self.prev_token.span.data().lo);\n-                Err(AsyncMoveOrderIncorrect { span: move_async_span }\n+                Err(errors::AsyncMoveOrderIncorrect { span: move_async_span }\n                     .into_diagnostic(&self.sess.span_diagnostic))\n             } else {\n                 Ok(CaptureBy::Value)\n@@ -2259,17 +2249,17 @@ impl<'a> Parser<'a> {\n             let block = match &mut cond.kind {\n                 ExprKind::Binary(Spanned { span: binop_span, .. }, _, right)\n                     if let ExprKind::Block(_, None) = right.kind => {\n-                        self.sess.emit_err(IfExpressionMissingThenBlock {\n+                        self.sess.emit_err(errors::IfExpressionMissingThenBlock {\n                             if_span: lo,\n                             missing_then_block_sub:\n-                                IfExpressionMissingThenBlockSub::UnfinishedCondition(cond_span.shrink_to_lo().to(*binop_span)),\n+                                errors::IfExpressionMissingThenBlockSub::UnfinishedCondition(cond_span.shrink_to_lo().to(*binop_span)),\n                                 let_else_sub: None,\n \n                         });\n                         std::mem::replace(right, this.mk_expr_err(binop_span.shrink_to_hi()))\n                     },\n                 ExprKind::Block(_, None) => {\n-                    self.sess.emit_err(IfExpressionMissingCondition {\n+                    self.sess.emit_err(errors::IfExpressionMissingCondition {\n                         if_span: lo.shrink_to_hi(),\n                         block_span: self.sess.source_map().start_point(cond_span),\n                     });\n@@ -2291,11 +2281,11 @@ impl<'a> Parser<'a> {\n                 block\n             } else {\n                 let let_else_sub = matches!(cond.kind, ExprKind::Let(..))\n-                    .then(|| IfExpressionLetSomeSub { if_span: lo.until(cond_span) });\n+                    .then(|| errors::IfExpressionLetSomeSub { if_span: lo.until(cond_span) });\n \n-                self.sess.emit_err(IfExpressionMissingThenBlock {\n+                self.sess.emit_err(errors::IfExpressionMissingThenBlock {\n                     if_span: lo,\n-                    missing_then_block_sub: IfExpressionMissingThenBlockSub::AddThenBlock(\n+                    missing_then_block_sub: errors::IfExpressionMissingThenBlockSub::AddThenBlock(\n                         cond_span.shrink_to_hi(),\n                     ),\n                     let_else_sub,\n@@ -2351,7 +2341,7 @@ impl<'a> Parser<'a> {\n             TokenKind::AndAnd | TokenKind::Ident(kw::If, _) | TokenKind::Ident(kw::While, _)\n         );\n         if !self.restrictions.contains(Restrictions::ALLOW_LET) || not_in_chain {\n-            self.sess.emit_err(ExpectedExpressionFoundLet { span: self.token.span });\n+            self.sess.emit_err(errors::ExpectedExpressionFoundLet { span: self.token.span });\n         }\n \n         self.bump(); // Eat `let` token\n@@ -2363,7 +2353,7 @@ impl<'a> Parser<'a> {\n             CommaRecoveryMode::LikelyTuple,\n         )?;\n         if self.token == token::EqEq {\n-            self.sess.emit_err(ExpectedEqForLetExpr {\n+            self.sess.emit_err(errors::ExpectedEqForLetExpr {\n                 span: self.token.span,\n                 sugg_span: self.token.span,\n             });\n@@ -2398,7 +2388,7 @@ impl<'a> Parser<'a> {\n                     if self.check(&TokenKind::OpenDelim(Delimiter::Brace))\n                         && classify::expr_requires_semi_to_be_stmt(&cond) =>\n                 {\n-                    self.sess.emit_err(ExpectedElseBlock {\n+                    self.sess.emit_err(errors::ExpectedElseBlock {\n                         first_tok_span,\n                         first_tok,\n                         else_span,\n@@ -2438,7 +2428,7 @@ impl<'a> Parser<'a> {\n             [x0 @ xn] | [x0, .., xn] => (x0.span.to(xn.span), xn.span),\n         };\n         let ctx = if is_ctx_else { \"else\" } else { \"if\" };\n-        self.sess.emit_err(OuterAttributeNotAllowedOnIfElse {\n+        self.sess.emit_err(errors::OuterAttributeNotAllowedOnIfElse {\n             last,\n             branch_span,\n             ctx_span,\n@@ -2451,7 +2441,7 @@ impl<'a> Parser<'a> {\n         if let ExprKind::Binary(Spanned { span: binop_span, node: binop}, _, right) = &cond.kind &&\n             let BinOpKind::And = binop &&\n             let ExprKind::If(cond, ..) = &right.kind {\n-                    Err(self.sess.create_err(UnexpectedIfWithIf(binop_span.shrink_to_hi().to(cond.span.shrink_to_lo()))))\n+                    Err(self.sess.create_err(errors::UnexpectedIfWithIf(binop_span.shrink_to_hi().to(cond.span.shrink_to_lo()))))\n             } else {\n                 Ok(())\n             }\n@@ -2481,6 +2471,21 @@ impl<'a> Parser<'a> {\n \n         let pat = self.recover_parens_around_for_head(pat, begin_paren);\n \n+        // Recover from missing expression in `for` loop\n+        if matches!(expr.kind, ExprKind::Block(..))\n+            && !matches!(self.token.kind, token::OpenDelim(token::Delimiter::Brace))\n+            && self.may_recover()\n+        {\n+            self.sess\n+                .emit_err(errors::MissingExpressionInForLoop { span: expr.span.shrink_to_lo() });\n+            let err_expr = self.mk_expr(expr.span, ExprKind::Err);\n+            let block = self.mk_block(vec![], BlockCheckMode::Default, self.prev_token.span);\n+            return Ok(self.mk_expr(\n+                lo.to(self.prev_token.span),\n+                ExprKind::ForLoop(pat, err_expr, block, opt_label),\n+            ));\n+        }\n+\n         let (attrs, loop_block) = self.parse_inner_attrs_and_block()?;\n \n         let kind = ExprKind::ForLoop(pat, expr, loop_block, opt_label);\n@@ -2492,12 +2497,12 @@ impl<'a> Parser<'a> {\n             // Possibly using JS syntax (#75311).\n             let span = self.token.span;\n             self.bump();\n-            (span, MissingInInForLoopSub::InNotOf)\n+            (span, errors::MissingInInForLoopSub::InNotOf)\n         } else {\n-            (self.prev_token.span.between(self.token.span), MissingInInForLoopSub::AddIn)\n+            (self.prev_token.span.between(self.token.span), errors::MissingInInForLoopSub::AddIn)\n         };\n \n-        self.sess.emit_err(MissingInInForLoop { span, sub: sub(span) });\n+        self.sess.emit_err(errors::MissingInInForLoop { span, sub: sub(span) });\n     }\n \n     /// Parses a `while` or `while let` expression (`while` token already eaten).\n@@ -2601,17 +2606,17 @@ impl<'a> Parser<'a> {\n         let err = |this: &Parser<'_>, stmts: Vec<ast::Stmt>| {\n             let span = stmts[0].span.to(stmts[stmts.len() - 1].span);\n \n-            this.sess.emit_err(MatchArmBodyWithoutBraces {\n+            this.sess.emit_err(errors::MatchArmBodyWithoutBraces {\n                 statements: span,\n                 arrow: arrow_span,\n                 num_statements: stmts.len(),\n                 sub: if stmts.len() > 1 {\n-                    MatchArmBodyWithoutBracesSugg::AddBraces {\n+                    errors::MatchArmBodyWithoutBracesSugg::AddBraces {\n                         left: span.shrink_to_lo(),\n                         right: span.shrink_to_hi(),\n                     }\n                 } else {\n-                    MatchArmBodyWithoutBracesSugg::UseComma { semicolon: semi_sp }\n+                    errors::MatchArmBodyWithoutBracesSugg::UseComma { semicolon: semi_sp }\n                 },\n             });\n             this.mk_expr_err(span)\n@@ -2717,6 +2722,14 @@ impl<'a> Parser<'a> {\n                     );\n                     err.emit();\n                     this.bump();\n+                } else if matches!(\n+                    (&this.prev_token.kind, &this.token.kind),\n+                    (token::DotDotEq, token::Gt)\n+                ) {\n+                    // `error_inclusive_range_match_arrow` handles cases like `0..=> {}`,\n+                    // so we supress the error here\n+                    err.delay_as_bug();\n+                    this.bump();\n                 } else {\n                     return Err(err);\n                 }\n@@ -2794,7 +2807,7 @@ impl<'a> Parser<'a> {\n                                 .is_ok();\n                             if pattern_follows && snapshot.check(&TokenKind::FatArrow) {\n                                 err.cancel();\n-                                this.sess.emit_err(MissingCommaAfterMatchArm {\n+                                this.sess.emit_err(errors::MissingCommaAfterMatchArm {\n                                     span: hi.shrink_to_hi(),\n                                 });\n                                 return Ok(true);\n@@ -2826,7 +2839,7 @@ impl<'a> Parser<'a> {\n     fn parse_try_block(&mut self, span_lo: Span) -> PResult<'a, P<Expr>> {\n         let (attrs, body) = self.parse_inner_attrs_and_block()?;\n         if self.eat_keyword(kw::Catch) {\n-            Err(CatchAfterTry { span: self.prev_token.span }\n+            Err(errors::CatchAfterTry { span: self.prev_token.span }\n                 .into_diagnostic(&self.sess.span_diagnostic))\n         } else {\n             let span = span_lo.to(body.span);\n@@ -2902,9 +2915,9 @@ impl<'a> Parser<'a> {\n             let expr = self.parse_struct_expr(qself.clone(), path.clone(), true);\n             if let (Ok(expr), false) = (&expr, struct_allowed) {\n                 // This is a struct literal, but we don't can't accept them here.\n-                self.sess.emit_err(StructLiteralNotAllowedHere {\n+                self.sess.emit_err(errors::StructLiteralNotAllowedHere {\n                     span: expr.span,\n-                    sub: StructLiteralNotAllowedHereSugg {\n+                    sub: errors::StructLiteralNotAllowedHereSugg {\n                         left: path.span.shrink_to_lo(),\n                         right: expr.span.shrink_to_hi(),\n                     },\n@@ -2927,8 +2940,8 @@ impl<'a> Parser<'a> {\n \n         let mut async_block_err = |e: &mut Diagnostic, span: Span| {\n             recover_async = true;\n-            AsyncBlockIn2015 { span }.add_to_diagnostic(e);\n-            HelpUseLatestEdition::new().add_to_diagnostic(e);\n+            errors::AsyncBlockIn2015 { span }.add_to_diagnostic(e);\n+            errors::HelpUseLatestEdition::new().add_to_diagnostic(e);\n         };\n \n         while self.token != token::CloseDelim(close_delim) {\n@@ -3072,7 +3085,7 @@ impl<'a> Parser<'a> {\n         if self.token != token::Comma {\n             return;\n         }\n-        self.sess.emit_err(CommaAfterBaseStruct {\n+        self.sess.emit_err(errors::CommaAfterBaseStruct {\n             span: span.to(self.prev_token.span),\n             comma: self.token.span,\n         });\n@@ -3085,7 +3098,7 @@ impl<'a> Parser<'a> {\n         {\n             // recover from typo of `...`, suggest `..`\n             let span = self.prev_token.span;\n-            self.sess.emit_err(MissingDotDot { token_span: span, sugg_span: span });\n+            self.sess.emit_err(errors::MissingDotDot { token_span: span, sugg_span: span });\n             return true;\n         }\n         false\n@@ -3153,18 +3166,18 @@ impl<'a> Parser<'a> {\n             return;\n         }\n \n-        self.sess.emit_err(EqFieldInit {\n+        self.sess.emit_err(errors::EqFieldInit {\n             span: self.token.span,\n             eq: field_name.span.shrink_to_hi().to(self.token.span),\n         });\n     }\n \n     fn err_dotdotdot_syntax(&self, span: Span) {\n-        self.sess.emit_err(DotDotDot { span });\n+        self.sess.emit_err(errors::DotDotDot { span });\n     }\n \n     fn err_larrow_operator(&self, span: Span) {\n-        self.sess.emit_err(LeftArrowOperator { span });\n+        self.sess.emit_err(errors::LeftArrowOperator { span });\n     }\n \n     fn mk_assign_op(&self, binop: BinOp, lhs: P<Expr>, rhs: P<Expr>) -> ExprKind {"}, {"sha": "23f49ec55a18ddda7a413b3de172b7df7b05cc01", "filename": "compiler/rustc_parse/src/parser/generics.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1,5 +1,6 @@\n use crate::errors::{\n-    MultipleWhereClauses, UnexpectedSelfInGenericParameters, WhereClauseBeforeTupleStructBody,\n+    MultipleWhereClauses, UnexpectedDefaultValueForLifetimeInGenericParameters,\n+    UnexpectedSelfInGenericParameters, WhereClauseBeforeTupleStructBody,\n     WhereClauseBeforeTupleStructBodySugg,\n };\n \n@@ -145,6 +146,20 @@ impl<'a> Parser<'a> {\n                         } else {\n                             (None, Vec::new())\n                         };\n+\n+                        if this.check_noexpect(&token::Eq)\n+                            && this.look_ahead(1, |t| t.is_lifetime())\n+                        {\n+                            let lo = this.token.span;\n+                            // Parse `= 'lifetime`.\n+                            this.bump(); // `=`\n+                            this.bump(); // `'lifetime`\n+                            let span = lo.to(this.prev_token.span);\n+                            this.sess.emit_err(\n+                                UnexpectedDefaultValueForLifetimeInGenericParameters { span },\n+                            );\n+                        }\n+\n                         Some(ast::GenericParam {\n                             ident: lifetime.ident,\n                             id: lifetime.id,"}, {"sha": "628e9d88cf1df27451b7811dc010fc9b08ed5cdd", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -2247,7 +2247,7 @@ impl<'a> Parser<'a> {\n         let ext = self.parse_extern(case);\n \n         if let Async::Yes { span, .. } = asyncness {\n-            if span.rust_2015() {\n+            if span.is_rust_2015() {\n                 self.sess.emit_err(AsyncFnIn2015 { span, help: HelpUseLatestEdition::new() });\n             }\n         }"}, {"sha": "0cb88f3c3a91697726fd3cde44b7774a7cea8c3d", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 75, "deletions": 69, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -19,9 +19,8 @@ pub use path::PathStyle;\n \n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, Nonterminal, Token, TokenKind};\n-use rustc_ast::tokenstream::AttributesData;\n-use rustc_ast::tokenstream::{self, DelimSpan, Spacing};\n-use rustc_ast::tokenstream::{TokenStream, TokenTree};\n+use rustc_ast::tokenstream::{AttributesData, DelimSpan, Spacing};\n+use rustc_ast::tokenstream::{TokenStream, TokenTree, TokenTreeCursor};\n use rustc_ast::util::case::Case;\n use rustc_ast::AttrId;\n use rustc_ast::DUMMY_NODE_ID;\n@@ -168,7 +167,7 @@ pub struct Parser<'a> {\n // This type is used a lot, e.g. it's cloned when matching many declarative macro rules with nonterminals. Make sure\n // it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Parser<'_>, 336);\n+rustc_data_structures::static_assert_size!(Parser<'_>, 312);\n \n /// Stores span information about a closure.\n #[derive(Clone)]\n@@ -221,18 +220,27 @@ impl<'a> Drop for Parser<'a> {\n     }\n }\n \n+/// Iterator over a `TokenStream` that produces `Token`s. It's a bit odd that\n+/// we (a) lex tokens into a nice tree structure (`TokenStream`), and then (b)\n+/// use this type to emit them as a linear sequence. But a linear sequence is\n+/// what the parser expects, for the most part.\n #[derive(Clone)]\n struct TokenCursor {\n-    // The current (innermost) frame. `frame` and `stack` could be combined,\n-    // but it's faster to have them separately to access `frame` directly\n-    // rather than via something like `stack.last().unwrap()` or\n-    // `stack[stack.len() - 1]`.\n-    frame: TokenCursorFrame,\n-    // Additional frames that enclose `frame`.\n-    stack: Vec<TokenCursorFrame>,\n+    // Cursor for the current (innermost) token stream. The delimiters for this\n+    // token stream are found in `self.stack.last()`; when that is `None` then\n+    // we are in the outermost token stream which never has delimiters.\n+    tree_cursor: TokenTreeCursor,\n+\n+    // Token streams surrounding the current one. The delimiters for stack[n]'s\n+    // tokens are in `stack[n-1]`. `stack[0]` (when present) has no delimiters\n+    // because it's the outermost token stream which never has delimiters.\n+    stack: Vec<(TokenTreeCursor, Delimiter, DelimSpan)>,\n+\n     desugar_doc_comments: bool,\n+\n     // Counts the number of calls to `{,inlined_}next`.\n     num_next_calls: usize,\n+\n     // During parsing, we may sometimes need to 'unglue' a\n     // glued token into two component tokens\n     // (e.g. '>>' into '>' and '>), so that the parser\n@@ -257,18 +265,6 @@ struct TokenCursor {\n     break_last_token: bool,\n }\n \n-#[derive(Clone)]\n-struct TokenCursorFrame {\n-    delim_sp: Option<(Delimiter, DelimSpan)>,\n-    tree_cursor: tokenstream::Cursor,\n-}\n-\n-impl TokenCursorFrame {\n-    fn new(delim_sp: Option<(Delimiter, DelimSpan)>, tts: TokenStream) -> Self {\n-        TokenCursorFrame { delim_sp, tree_cursor: tts.into_trees() }\n-    }\n-}\n-\n impl TokenCursor {\n     fn next(&mut self, desugar_doc_comments: bool) -> (Token, Spacing) {\n         self.inlined_next(desugar_doc_comments)\n@@ -281,38 +277,47 @@ impl TokenCursor {\n             // FIXME: we currently don't return `Delimiter` open/close delims. To fix #67062 we will\n             // need to, whereupon the `delim != Delimiter::Invisible` conditions below can be\n             // removed.\n-            if let Some(tree) = self.frame.tree_cursor.next_ref() {\n+            if let Some(tree) = self.tree_cursor.next_ref() {\n                 match tree {\n                     &TokenTree::Token(ref token, spacing) => match (desugar_doc_comments, token) {\n                         (true, &Token { kind: token::DocComment(_, attr_style, data), span }) => {\n-                            return self.desugar(attr_style, data, span);\n+                            let desugared = self.desugar(attr_style, data, span);\n+                            self.tree_cursor.replace_prev_and_rewind(desugared);\n+                            // Continue to get the first token of the desugared doc comment.\n+                        }\n+                        _ => {\n+                            debug_assert!(!matches!(\n+                                token.kind,\n+                                token::OpenDelim(_) | token::CloseDelim(_)\n+                            ));\n+                            return (token.clone(), spacing);\n                         }\n-                        _ => return (token.clone(), spacing),\n                     },\n                     &TokenTree::Delimited(sp, delim, ref tts) => {\n-                        // Set `open_delim` to true here because we deal with it immediately.\n-                        let frame = TokenCursorFrame::new(Some((delim, sp)), tts.clone());\n-                        self.stack.push(mem::replace(&mut self.frame, frame));\n+                        let trees = tts.clone().into_trees();\n+                        self.stack.push((mem::replace(&mut self.tree_cursor, trees), delim, sp));\n                         if delim != Delimiter::Invisible {\n                             return (Token::new(token::OpenDelim(delim), sp.open), Spacing::Alone);\n                         }\n                         // No open delimiter to return; continue on to the next iteration.\n                     }\n                 };\n-            } else if let Some(frame) = self.stack.pop() {\n-                if let Some((delim, span)) = self.frame.delim_sp && delim != Delimiter::Invisible {\n-                    self.frame = frame;\n+            } else if let Some((tree_cursor, delim, span)) = self.stack.pop() {\n+                // We have exhausted this token stream. Move back to its parent token stream.\n+                self.tree_cursor = tree_cursor;\n+                if delim != Delimiter::Invisible {\n                     return (Token::new(token::CloseDelim(delim), span.close), Spacing::Alone);\n                 }\n-                self.frame = frame;\n                 // No close delimiter to return; continue on to the next iteration.\n             } else {\n+                // We have exhausted the outermost token stream.\n                 return (Token::new(token::Eof, DUMMY_SP), Spacing::Alone);\n             }\n         }\n     }\n \n-    fn desugar(&mut self, attr_style: AttrStyle, data: Symbol, span: Span) -> (Token, Spacing) {\n+    // Desugar a doc comment into something like `#[doc = r\"foo\"]`.\n+    fn desugar(&mut self, attr_style: AttrStyle, data: Symbol, span: Span) -> Vec<TokenTree> {\n         // Searches for the occurrences of `\"#*` and returns the minimum number of `#`s\n         // required to wrap the text. E.g.\n         // - `abc d` is wrapped as `r\"abc d\"` (num_of_hashes = 0)\n@@ -346,27 +351,15 @@ impl TokenCursor {\n             .collect::<TokenStream>(),\n         );\n \n-        self.stack.push(mem::replace(\n-            &mut self.frame,\n-            TokenCursorFrame::new(\n-                None,\n-                if attr_style == AttrStyle::Inner {\n-                    [\n-                        TokenTree::token_alone(token::Pound, span),\n-                        TokenTree::token_alone(token::Not, span),\n-                        body,\n-                    ]\n-                    .into_iter()\n-                    .collect::<TokenStream>()\n-                } else {\n-                    [TokenTree::token_alone(token::Pound, span), body]\n-                        .into_iter()\n-                        .collect::<TokenStream>()\n-                },\n-            ),\n-        ));\n-\n-        self.next(/* desugar_doc_comments */ false)\n+        if attr_style == AttrStyle::Inner {\n+            vec![\n+                TokenTree::token_alone(token::Pound, span),\n+                TokenTree::token_alone(token::Not, span),\n+                body,\n+            ]\n+        } else {\n+            vec![TokenTree::token_alone(token::Pound, span), body]\n+        }\n     }\n }\n \n@@ -475,7 +468,7 @@ impl<'a> Parser<'a> {\n             restrictions: Restrictions::empty(),\n             expected_tokens: Vec::new(),\n             token_cursor: TokenCursor {\n-                frame: TokenCursorFrame::new(None, tokens),\n+                tree_cursor: tokens.into_trees(),\n                 stack: Vec::new(),\n                 num_next_calls: 0,\n                 desugar_doc_comments,\n@@ -739,9 +732,10 @@ impl<'a> Parser<'a> {\n     fn check_const_closure(&self) -> bool {\n         self.is_keyword_ahead(0, &[kw::Const])\n             && self.look_ahead(1, |t| match &t.kind {\n-                token::Ident(kw::Move | kw::Static | kw::Async, _)\n-                | token::OrOr\n-                | token::BinOp(token::Or) => true,\n+                // async closures do not work with const closures, so we do not parse that here.\n+                token::Ident(kw::Move | kw::Static, _) | token::OrOr | token::BinOp(token::Or) => {\n+                    true\n+                }\n                 _ => false,\n             })\n     }\n@@ -1142,14 +1136,16 @@ impl<'a> Parser<'a> {\n             return looker(&self.token);\n         }\n \n-        let frame = &self.token_cursor.frame;\n-        if let Some((delim, span)) = frame.delim_sp && delim != Delimiter::Invisible {\n+        let tree_cursor = &self.token_cursor.tree_cursor;\n+        if let Some(&(_, delim, span)) = self.token_cursor.stack.last()\n+            && delim != Delimiter::Invisible\n+        {\n             let all_normal = (0..dist).all(|i| {\n-                let token = frame.tree_cursor.look_ahead(i);\n+                let token = tree_cursor.look_ahead(i);\n                 !matches!(token, Some(TokenTree::Delimited(_, Delimiter::Invisible, _)))\n             });\n             if all_normal {\n-                return match frame.tree_cursor.look_ahead(dist - 1) {\n+                return match tree_cursor.look_ahead(dist - 1) {\n                     Some(tree) => match tree {\n                         TokenTree::Token(token, _) => looker(token),\n                         TokenTree::Delimited(dspan, delim, _) => {\n@@ -1203,8 +1199,18 @@ impl<'a> Parser<'a> {\n \n     /// Parses constness: `const` or nothing.\n     fn parse_constness(&mut self, case: Case) -> Const {\n-        // Avoid const blocks to be parsed as const items\n-        if self.look_ahead(1, |t| t != &token::OpenDelim(Delimiter::Brace))\n+        self.parse_constness_(case, false)\n+    }\n+\n+    /// Parses constness for closures\n+    fn parse_closure_constness(&mut self, case: Case) -> Const {\n+        self.parse_constness_(case, true)\n+    }\n+\n+    fn parse_constness_(&mut self, case: Case, is_closure: bool) -> Const {\n+        // Avoid const blocks and const closures to be parsed as const items\n+        if (self.check_const_closure() == is_closure)\n+            && self.look_ahead(1, |t| t != &token::OpenDelim(Delimiter::Brace))\n             && self.eat_keyword_case(kw::Const, case)\n         {\n             Const::Yes(self.prev_token.uninterpolated_span())\n@@ -1310,10 +1316,10 @@ impl<'a> Parser<'a> {\n     pub(crate) fn parse_token_tree(&mut self) -> TokenTree {\n         match self.token.kind {\n             token::OpenDelim(..) => {\n-                // Grab the tokens from this frame.\n-                let frame = &self.token_cursor.frame;\n-                let stream = frame.tree_cursor.stream.clone();\n-                let (delim, span) = frame.delim_sp.unwrap();\n+                // Grab the tokens within the delimiters.\n+                let tree_cursor = &self.token_cursor.tree_cursor;\n+                let stream = tree_cursor.stream.clone();\n+                let (_, delim, span) = *self.token_cursor.stack.last().unwrap();\n \n                 // Advance the token cursor through the entire delimited\n                 // sequence. After getting the `OpenDelim` we are *within* the"}, {"sha": "b054dc59a0c9d93b43d1b2a365a4ec12d23c22ea", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -148,8 +148,7 @@ impl<'a> Parser<'a> {\n \n             // Check if the user wrote `foo:bar` instead of `foo::bar`.\n             if ra == RecoverColon::Yes {\n-                first_pat =\n-                    self.maybe_recover_colon_colon_in_pat_typo_or_anon_enum(first_pat, expected);\n+                first_pat = self.maybe_recover_colon_colon_in_pat_typo(first_pat, expected);\n             }\n \n             if let Some(leading_vert_span) = leading_vert_span {\n@@ -744,7 +743,7 @@ impl<'a> Parser<'a> {\n             }\n             token::Gt if no_space => {\n                 let after_pat = span.with_hi(span.hi() - rustc_span::BytePos(1)).shrink_to_hi();\n-                self.sess.emit_err(InclusiveRangeMatchArrow { span, after_pat });\n+                self.sess.emit_err(InclusiveRangeMatchArrow { span, arrow: tok.span, after_pat });\n             }\n             _ => {\n                 self.sess.emit_err(InclusiveRangeNoEnd { span });\n@@ -963,12 +962,15 @@ impl<'a> Parser<'a> {\n             }\n             ate_comma = false;\n \n-            if self.check(&token::DotDot) || self.token == token::DotDotDot {\n+            if self.check(&token::DotDot)\n+                || self.check_noexpect(&token::DotDotDot)\n+                || self.check_keyword(kw::Underscore)\n+            {\n                 etc = true;\n                 let mut etc_sp = self.token.span;\n \n-                self.recover_one_fewer_dotdot();\n-                self.bump(); // `..` || `...`\n+                self.recover_bad_dot_dot();\n+                self.bump(); // `..` || `...` || `_`\n \n                 if self.token == token::CloseDelim(Delimiter::Brace) {\n                     etc_span = Some(etc_sp);\n@@ -1061,14 +1063,15 @@ impl<'a> Parser<'a> {\n         Ok((fields, etc))\n     }\n \n-    /// Recover on `...` as if it were `..` to avoid further errors.\n+    /// Recover on `...` or `_` as if it were `..` to avoid further errors.\n     /// See issue #46718.\n-    fn recover_one_fewer_dotdot(&self) {\n-        if self.token != token::DotDotDot {\n+    fn recover_bad_dot_dot(&self) {\n+        if self.token == token::DotDot {\n             return;\n         }\n \n-        self.sess.emit_err(DotDotDotForRemainingFields { span: self.token.span });\n+        let token_str = pprust::token_to_string(&self.token);\n+        self.sess.emit_err(DotDotDotForRemainingFields { span: self.token.span, token_str });\n     }\n \n     fn parse_pat_field(&mut self, lo: Span, attrs: AttrVec) -> PResult<'a, PatField> {"}, {"sha": "3afda5f69f0e1f4eceb99a29858507af08b1071c", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -7,12 +7,7 @@ use super::TrailingToken;\n use super::{\n     AttrWrapper, BlockMode, FnParseMode, ForceCollect, Parser, Restrictions, SemiColonMode,\n };\n-use crate::errors::{\n-    AssignmentElseNotAllowed, CompoundAssignmentExpressionInLet, ConstLetMutuallyExclusive,\n-    DocCommentDoesNotDocumentAnything, ExpectedStatementAfterOuterAttr, InvalidCurlyInLetElse,\n-    InvalidExpressionInLetElse, InvalidIdentiferStartsWithNumber, InvalidVariableDeclaration,\n-    InvalidVariableDeclarationSub, WrapExpressionInParentheses,\n-};\n+use crate::errors;\n use crate::maybe_whole;\n \n use rustc_ast as ast;\n@@ -64,29 +59,33 @@ impl<'a> Parser<'a> {\n         if self.token.is_keyword(kw::Mut) && self.is_keyword_ahead(1, &[kw::Let]) {\n             self.bump();\n             let mut_let_span = lo.to(self.token.span);\n-            self.sess.emit_err(InvalidVariableDeclaration {\n+            self.sess.emit_err(errors::InvalidVariableDeclaration {\n                 span: mut_let_span,\n-                sub: InvalidVariableDeclarationSub::SwitchMutLetOrder(mut_let_span),\n+                sub: errors::InvalidVariableDeclarationSub::SwitchMutLetOrder(mut_let_span),\n             });\n         }\n \n         Ok(Some(if self.token.is_keyword(kw::Let) {\n             self.parse_local_mk(lo, attrs, capture_semi, force_collect)?\n         } else if self.is_kw_followed_by_ident(kw::Mut) && self.may_recover() {\n-            self.recover_stmt_local_after_let(lo, attrs, InvalidVariableDeclarationSub::MissingLet)?\n+            self.recover_stmt_local_after_let(\n+                lo,\n+                attrs,\n+                errors::InvalidVariableDeclarationSub::MissingLet,\n+            )?\n         } else if self.is_kw_followed_by_ident(kw::Auto) && self.may_recover() {\n             self.bump(); // `auto`\n             self.recover_stmt_local_after_let(\n                 lo,\n                 attrs,\n-                InvalidVariableDeclarationSub::UseLetNotAuto,\n+                errors::InvalidVariableDeclarationSub::UseLetNotAuto,\n             )?\n         } else if self.is_kw_followed_by_ident(sym::var) && self.may_recover() {\n             self.bump(); // `var`\n             self.recover_stmt_local_after_let(\n                 lo,\n                 attrs,\n-                InvalidVariableDeclarationSub::UseLetNotVar,\n+                errors::InvalidVariableDeclarationSub::UseLetNotVar,\n             )?\n         } else if self.check_path() && !self.token.is_qpath_start() && !self.is_path_start_item() {\n             // We have avoided contextual keywords like `union`, items with `crate` visibility,\n@@ -124,7 +123,7 @@ impl<'a> Parser<'a> {\n                 let bl = self.parse_block()?;\n                 // Destructuring assignment ... else.\n                 // This is not allowed, but point it out in a nice way.\n-                self.sess.emit_err(AssignmentElseNotAllowed { span: e.span.to(bl.span) });\n+                self.sess.emit_err(errors::AssignmentElseNotAllowed { span: e.span.to(bl.span) });\n             }\n             self.mk_stmt(lo.to(e.span), StmtKind::Expr(e))\n         } else {\n@@ -217,12 +216,12 @@ impl<'a> Parser<'a> {\n         && let attrs = attrs.take_for_recovery(self.sess)\n         && let attrs @ [.., last] = &*attrs {\n             if last.is_doc_comment() {\n-                self.sess.emit_err(DocCommentDoesNotDocumentAnything {\n+                self.sess.emit_err(errors::DocCommentDoesNotDocumentAnything {\n                     span: last.span,\n                     missing_comma: None,\n                 });\n             } else if attrs.iter().any(|a| a.style == AttrStyle::Outer) {\n-                self.sess.emit_err(ExpectedStatementAfterOuterAttr { span: last.span });\n+                self.sess.emit_err(errors::ExpectedStatementAfterOuterAttr { span: last.span });\n             }\n         }\n     }\n@@ -231,7 +230,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         lo: Span,\n         attrs: AttrWrapper,\n-        subdiagnostic: fn(Span) -> InvalidVariableDeclarationSub,\n+        subdiagnostic: fn(Span) -> errors::InvalidVariableDeclarationSub,\n     ) -> PResult<'a, Stmt> {\n         let stmt =\n             self.collect_tokens_trailing_token(attrs, ForceCollect::Yes, |this, attrs| {\n@@ -242,7 +241,7 @@ impl<'a> Parser<'a> {\n                     TrailingToken::None,\n                 ))\n             })?;\n-        self.sess.emit_err(InvalidVariableDeclaration { span: lo, sub: subdiagnostic(lo) });\n+        self.sess.emit_err(errors::InvalidVariableDeclaration { span: lo, sub: subdiagnostic(lo) });\n         Ok(stmt)\n     }\n \n@@ -270,7 +269,7 @@ impl<'a> Parser<'a> {\n         let lo = self.prev_token.span;\n \n         if self.token.is_keyword(kw::Const) && self.look_ahead(1, |t| t.is_ident()) {\n-            self.sess.emit_err(ConstLetMutuallyExclusive { span: lo.to(self.token.span) });\n+            self.sess.emit_err(errors::ConstLetMutuallyExclusive { span: lo.to(self.token.span) });\n             self.bump();\n         }\n \n@@ -373,18 +372,18 @@ impl<'a> Parser<'a> {\n             rustc_ast::MetaItemLit::from_token(&self.token).is_none() &&\n             (lit.kind == token::LitKind::Integer || lit.kind == token::LitKind::Float) &&\n             self.look_ahead(1, |t| matches!(t.kind, token::Eq) || matches!(t.kind, token::Colon ) ) {\n-                return Err(self.sess.create_err(InvalidIdentiferStartsWithNumber { span: self.token.span }));\n+                return Err(self.sess.create_err(errors::InvalidIdentiferStartsWithNumber { span: self.token.span }));\n         }\n         Ok(())\n     }\n \n     fn check_let_else_init_bool_expr(&self, init: &ast::Expr) {\n         if let ast::ExprKind::Binary(op, ..) = init.kind {\n             if op.node.lazy() {\n-                self.sess.emit_err(InvalidExpressionInLetElse {\n+                self.sess.emit_err(errors::InvalidExpressionInLetElse {\n                     span: init.span,\n                     operator: op.node.to_string(),\n-                    sugg: WrapExpressionInParentheses {\n+                    sugg: errors::WrapExpressionInParentheses {\n                         left: init.span.shrink_to_lo(),\n                         right: init.span.shrink_to_hi(),\n                     },\n@@ -395,9 +394,9 @@ impl<'a> Parser<'a> {\n \n     fn check_let_else_init_trailing_brace(&self, init: &ast::Expr) {\n         if let Some(trailing) = classify::expr_trailing_brace(init) {\n-            self.sess.emit_err(InvalidCurlyInLetElse {\n+            self.sess.emit_err(errors::InvalidCurlyInLetElse {\n                 span: trailing.span.with_lo(trailing.span.hi() - BytePos(1)),\n-                sugg: WrapExpressionInParentheses {\n+                sugg: errors::WrapExpressionInParentheses {\n                     left: trailing.span.shrink_to_lo(),\n                     right: trailing.span.shrink_to_hi(),\n                 },\n@@ -410,7 +409,8 @@ impl<'a> Parser<'a> {\n         let eq_consumed = match self.token.kind {\n             token::BinOpEq(..) => {\n                 // Recover `let x <op>= 1` as `let x = 1`\n-                self.sess.emit_err(CompoundAssignmentExpressionInLet { span: self.token.span });\n+                self.sess\n+                    .emit_err(errors::CompoundAssignmentExpressionInLet { span: self.token.span });\n                 self.bump();\n                 true\n             }"}, {"sha": "a19ea04fa5e75e47128fa769952be3b6083a68c6", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 4, "deletions": 63, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -17,7 +17,6 @@ use rustc_ast::{\n     self as ast, BareFnTy, FnRetTy, GenericBound, GenericBounds, GenericParam, Generics, Lifetime,\n     MacCall, MutTy, Mutability, PolyTraitRef, TraitBoundModifier, TraitObjectSyntax, Ty, TyKind,\n };\n-use rustc_ast_pretty::pprust;\n use rustc_errors::{Applicability, PResult};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym, Ident};\n@@ -50,24 +49,17 @@ pub(super) enum AllowPlus {\n     No,\n }\n \n-#[derive(PartialEq, Clone, Copy)]\n+#[derive(PartialEq)]\n pub(super) enum RecoverQPath {\n     Yes,\n     No,\n }\n \n-#[derive(PartialEq, Clone, Copy)]\n pub(super) enum RecoverQuestionMark {\n     Yes,\n     No,\n }\n \n-#[derive(PartialEq, Clone, Copy)]\n-pub(super) enum RecoverAnonEnum {\n-    Yes,\n-    No,\n-}\n-\n /// Signals whether parsing a type should recover `->`.\n ///\n /// More specifically, when parsing a function like:\n@@ -100,7 +92,7 @@ impl RecoverReturnSign {\n }\n \n // Is `...` (`CVarArgs`) legal at this level of type parsing?\n-#[derive(PartialEq, Clone, Copy)]\n+#[derive(PartialEq)]\n enum AllowCVariadic {\n     Yes,\n     No,\n@@ -125,7 +117,6 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::Yes,\n             None,\n             RecoverQuestionMark::Yes,\n-            RecoverAnonEnum::No,\n         )\n     }\n \n@@ -140,7 +131,6 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::Yes,\n             Some(ty_params),\n             RecoverQuestionMark::Yes,\n-            RecoverAnonEnum::No,\n         )\n     }\n \n@@ -155,7 +145,6 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::Yes,\n             None,\n             RecoverQuestionMark::Yes,\n-            RecoverAnonEnum::Yes,\n         )\n     }\n \n@@ -173,7 +162,6 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::Yes,\n             None,\n             RecoverQuestionMark::Yes,\n-            RecoverAnonEnum::No,\n         )\n     }\n \n@@ -187,7 +175,6 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::Yes,\n             None,\n             RecoverQuestionMark::No,\n-            RecoverAnonEnum::No,\n         )\n     }\n \n@@ -199,7 +186,6 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::Yes,\n             None,\n             RecoverQuestionMark::No,\n-            RecoverAnonEnum::No,\n         )\n     }\n \n@@ -212,7 +198,6 @@ impl<'a> Parser<'a> {\n             RecoverReturnSign::OnlyFatArrow,\n             None,\n             RecoverQuestionMark::Yes,\n-            RecoverAnonEnum::No,\n         )\n     }\n \n@@ -232,7 +217,6 @@ impl<'a> Parser<'a> {\n                 recover_return_sign,\n                 None,\n                 RecoverQuestionMark::Yes,\n-                RecoverAnonEnum::Yes,\n             )?;\n             FnRetTy::Ty(ty)\n         } else if recover_return_sign.can_recover(&self.token.kind) {\n@@ -247,7 +231,6 @@ impl<'a> Parser<'a> {\n                 recover_return_sign,\n                 None,\n                 RecoverQuestionMark::Yes,\n-                RecoverAnonEnum::Yes,\n             )?;\n             FnRetTy::Ty(ty)\n         } else {\n@@ -263,7 +246,6 @@ impl<'a> Parser<'a> {\n         recover_return_sign: RecoverReturnSign,\n         ty_generics: Option<&Generics>,\n         recover_question_mark: RecoverQuestionMark,\n-        recover_anon_enum: RecoverAnonEnum,\n     ) -> PResult<'a, P<Ty>> {\n         let allow_qpath_recovery = recover_qpath == RecoverQPath::Yes;\n         maybe_recover_from_interpolated_ty_qpath!(self, allow_qpath_recovery);\n@@ -347,50 +329,9 @@ impl<'a> Parser<'a> {\n             AllowPlus::Yes => self.maybe_recover_from_bad_type_plus(&ty)?,\n             AllowPlus::No => self.maybe_report_ambiguous_plus(impl_dyn_multi, &ty),\n         }\n-        if RecoverQuestionMark::Yes == recover_question_mark {\n+        if let RecoverQuestionMark::Yes = recover_question_mark {\n             ty = self.maybe_recover_from_question_mark(ty);\n         }\n-        if recover_anon_enum == RecoverAnonEnum::Yes\n-            && self.check_noexpect(&token::BinOp(token::Or))\n-            && self.look_ahead(1, |t| t.can_begin_type())\n-        {\n-            let mut pipes = vec![self.token.span];\n-            let mut types = vec![ty];\n-            loop {\n-                if !self.eat(&token::BinOp(token::Or)) {\n-                    break;\n-                }\n-                pipes.push(self.prev_token.span);\n-                types.push(self.parse_ty_common(\n-                    allow_plus,\n-                    allow_c_variadic,\n-                    recover_qpath,\n-                    recover_return_sign,\n-                    ty_generics,\n-                    recover_question_mark,\n-                    RecoverAnonEnum::No,\n-                )?);\n-            }\n-            let mut err = self.struct_span_err(pipes, \"anonymous enums are not supported\");\n-            for ty in &types {\n-                err.span_label(ty.span, \"\");\n-            }\n-            err.help(&format!(\n-                \"create a named `enum` and use it here instead:\\nenum Name {{\\n{}\\n}}\",\n-                types\n-                    .iter()\n-                    .enumerate()\n-                    .map(|(i, t)| format!(\n-                        \"    Variant{}({}),\",\n-                        i + 1, // Lets not confuse people with zero-indexing :)\n-                        pprust::to_string(|s| s.print_type(&t)),\n-                    ))\n-                    .collect::<Vec<_>>()\n-                    .join(\"\\n\"),\n-            ));\n-            err.emit();\n-            return Ok(self.mk_ty(lo.to(self.prev_token.span), TyKind::Err));\n-        }\n         if allow_qpath_recovery { self.maybe_recover_from_bad_qpath(ty) } else { Ok(ty) }\n     }\n \n@@ -673,7 +614,7 @@ impl<'a> Parser<'a> {\n     /// Is a `dyn B0 + ... + Bn` type allowed here?\n     fn is_explicit_dyn_type(&mut self) -> bool {\n         self.check_keyword(kw::Dyn)\n-            && (!self.token.uninterpolated_span().rust_2015()\n+            && (self.token.uninterpolated_span().rust_2018()\n                 || self.look_ahead(1, |t| {\n                     (t.can_begin_bound() || t.kind == TokenKind::BinOp(token::Star))\n                         && !can_continue_type_after_non_fn_ident(t)"}, {"sha": "088a87ca5710457386e77017260650aa8cfb4daf", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -273,7 +273,13 @@ impl<'a> Iterator for Parser<'a> {\n                                 );\n                             }\n                         } else {\n-                            self.suggest_positional_arg_instead_of_captured_arg(arg);\n+                            if let Some(&(_, maybe)) = self.cur.peek() {\n+                                if maybe == '?' {\n+                                    self.suggest_format();\n+                                } else {\n+                                    self.suggest_positional_arg_instead_of_captured_arg(arg);\n+                                }\n+                            }\n                         }\n                         Some(NextArgument(Box::new(arg)))\n                     }\n@@ -832,6 +838,27 @@ impl<'a> Parser<'a> {\n         if found { Some(cur) } else { None }\n     }\n \n+    fn suggest_format(&mut self) {\n+        if let (Some(pos), Some(_)) = (self.consume_pos('?'), self.consume_pos(':')) {\n+            let word = self.word();\n+            let _end = self.current_pos();\n+            let pos = self.to_span_index(pos);\n+            self.errors.insert(\n+                0,\n+                ParseError {\n+                    description: \"expected format parameter to occur after `:`\".to_owned(),\n+                    note: Some(\n+                        format!(\"`?` comes after `:`, try `{}:{}` instead\", word, \"?\").to_owned(),\n+                    ),\n+                    label: \"expected `?` to occur after `:`\".to_owned(),\n+                    span: pos.to(pos),\n+                    secondary_label: None,\n+                    should_be_replaced_with_positional_argument: false,\n+                },\n+            );\n+        }\n+    }\n+\n     fn suggest_positional_arg_instead_of_captured_arg(&mut self, arg: Argument<'a>) {\n         if let Some(end) = self.consume_pos('.') {\n             let byte_pos = self.to_span_index(end);"}, {"sha": "238ec9ca30f704a99b0e72eb65e8d58454180062", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -4,11 +4,7 @@\n //! conflicts between multiple such attributes attached to the same\n //! item.\n \n-use crate::errors::{\n-    self, AttrApplication, DebugVisualizerUnreadable, InvalidAttrAtCrateLevel, ObjectLifetimeErr,\n-    OnlyHasEffectOn, ProcMacroDiffArguments, ProcMacroInvalidAbi, ProcMacroMissingArguments,\n-    ProcMacroTypeError, ProcMacroUnsafe, TransparentIncompatible, UnrecognizedReprHint,\n-};\n+use crate::errors;\n use rustc_ast::{ast, AttrStyle, Attribute, LitKind, MetaItemKind, MetaItemLit, NestedMetaItem};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{fluent, Applicability, IntoDiagnosticArg, MultiSpan};\n@@ -399,7 +395,7 @@ impl CheckAttrVisitor<'_> {\n                 UNUSED_ATTRIBUTES,\n                 hir_id,\n                 attr.span,\n-                OnlyHasEffectOn {\n+                errors::OnlyHasEffectOn {\n                     attr_name: attr.name_or_empty(),\n                     target_name: allowed_target.name().replace(' ', \"_\"),\n                 },\n@@ -468,7 +464,7 @@ impl CheckAttrVisitor<'_> {\n                     ObjectLifetimeDefault::Param(def_id) => tcx.item_name(def_id).to_string(),\n                     ObjectLifetimeDefault::Ambiguous => \"Ambiguous\".to_owned(),\n                 };\n-                tcx.sess.emit_err(ObjectLifetimeErr { span: p.span, repr });\n+                tcx.sess.emit_err(errors::ObjectLifetimeErr { span: p.span, repr });\n             }\n         }\n     }\n@@ -1715,7 +1711,7 @@ impl CheckAttrVisitor<'_> {\n                     match target {\n                         Target::Struct | Target::Union | Target::Enum => continue,\n                         _ => {\n-                            self.tcx.sess.emit_err(AttrApplication::StructEnumUnion {\n+                            self.tcx.sess.emit_err(errors::AttrApplication::StructEnumUnion {\n                                 hint_span: hint.span(),\n                                 span,\n                             });\n@@ -1736,16 +1732,18 @@ impl CheckAttrVisitor<'_> {\n                     match target {\n                         Target::Struct | Target::Union | Target::Enum | Target::Fn => continue,\n                         _ => {\n-                            self.tcx.sess.emit_err(AttrApplication::StructEnumFunctionUnion {\n-                                hint_span: hint.span(),\n-                                span,\n-                            });\n+                            self.tcx.sess.emit_err(\n+                                errors::AttrApplication::StructEnumFunctionUnion {\n+                                    hint_span: hint.span(),\n+                                    span,\n+                                },\n+                            );\n                         }\n                     }\n                 }\n                 sym::packed => {\n                     if target != Target::Struct && target != Target::Union {\n-                        self.tcx.sess.emit_err(AttrApplication::StructUnion {\n+                        self.tcx.sess.emit_err(errors::AttrApplication::StructUnion {\n                             hint_span: hint.span(),\n                             span,\n                         });\n@@ -1756,9 +1754,10 @@ impl CheckAttrVisitor<'_> {\n                 sym::simd => {\n                     is_simd = true;\n                     if target != Target::Struct {\n-                        self.tcx\n-                            .sess\n-                            .emit_err(AttrApplication::Struct { hint_span: hint.span(), span });\n+                        self.tcx.sess.emit_err(errors::AttrApplication::Struct {\n+                            hint_span: hint.span(),\n+                            span,\n+                        });\n                     } else {\n                         continue;\n                     }\n@@ -1768,7 +1767,7 @@ impl CheckAttrVisitor<'_> {\n                     match target {\n                         Target::Struct | Target::Union | Target::Enum => continue,\n                         _ => {\n-                            self.tcx.sess.emit_err(AttrApplication::StructEnumUnion {\n+                            self.tcx.sess.emit_err(errors::AttrApplication::StructEnumUnion {\n                                 hint_span: hint.span(),\n                                 span,\n                             });\n@@ -1789,15 +1788,16 @@ impl CheckAttrVisitor<'_> {\n                 | sym::usize => {\n                     int_reprs += 1;\n                     if target != Target::Enum {\n-                        self.tcx\n-                            .sess\n-                            .emit_err(AttrApplication::Enum { hint_span: hint.span(), span });\n+                        self.tcx.sess.emit_err(errors::AttrApplication::Enum {\n+                            hint_span: hint.span(),\n+                            span,\n+                        });\n                     } else {\n                         continue;\n                     }\n                 }\n                 _ => {\n-                    self.tcx.sess.emit_err(UnrecognizedReprHint { span: hint.span() });\n+                    self.tcx.sess.emit_err(errors::UnrecognizedReprHint { span: hint.span() });\n                     continue;\n                 }\n             };\n@@ -1810,9 +1810,10 @@ impl CheckAttrVisitor<'_> {\n         // Error on repr(transparent, <anything else>).\n         if is_transparent && hints.len() > 1 {\n             let hint_spans: Vec<_> = hint_spans.clone().collect();\n-            self.tcx\n-                .sess\n-                .emit_err(TransparentIncompatible { hint_spans, target: target.to_string() });\n+            self.tcx.sess.emit_err(errors::TransparentIncompatible {\n+                hint_spans,\n+                target: target.to_string(),\n+            });\n         }\n         // Warn on repr(u8, u16), repr(C, simd), and c-like-enum-repr(C, u8)\n         if (int_reprs > 1)\n@@ -1965,7 +1966,7 @@ impl CheckAttrVisitor<'_> {\n         match std::fs::File::open(&file) {\n             Ok(_) => true,\n             Err(error) => {\n-                self.tcx.sess.emit_err(DebugVisualizerUnreadable {\n+                self.tcx.sess.emit_err(errors::DebugVisualizerUnreadable {\n                     span: meta_item.span,\n                     file: &file,\n                     error,\n@@ -2175,20 +2176,23 @@ impl CheckAttrVisitor<'_> {\n             let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsInfer };\n \n             if sig.abi != Abi::Rust {\n-                tcx.sess.emit_err(ProcMacroInvalidAbi { span: hir_sig.span, abi: sig.abi.name() });\n+                tcx.sess.emit_err(errors::ProcMacroInvalidAbi {\n+                    span: hir_sig.span,\n+                    abi: sig.abi.name(),\n+                });\n                 self.abort.set(true);\n             }\n \n             if sig.unsafety == Unsafety::Unsafe {\n-                tcx.sess.emit_err(ProcMacroUnsafe { span: hir_sig.span });\n+                tcx.sess.emit_err(errors::ProcMacroUnsafe { span: hir_sig.span });\n                 self.abort.set(true);\n             }\n \n             let output = sig.output();\n \n             // Typecheck the output\n             if !drcx.types_may_unify(output, tokenstream) {\n-                tcx.sess.emit_err(ProcMacroTypeError {\n+                tcx.sess.emit_err(errors::ProcMacroTypeError {\n                     span: hir_sig.decl.output.span(),\n                     found: output,\n                     kind,\n@@ -2198,7 +2202,7 @@ impl CheckAttrVisitor<'_> {\n             }\n \n             if sig.inputs().len() < expected_input_count {\n-                tcx.sess.emit_err(ProcMacroMissingArguments {\n+                tcx.sess.emit_err(errors::ProcMacroMissingArguments {\n                     expected_input_count,\n                     span: hir_sig.span,\n                     kind,\n@@ -2213,7 +2217,7 @@ impl CheckAttrVisitor<'_> {\n                     sig.inputs().iter().zip(hir_sig.decl.inputs).take(expected_input_count)\n                 {\n                     if !drcx.types_may_unify(*arg, tokenstream) {\n-                        tcx.sess.emit_err(ProcMacroTypeError {\n+                        tcx.sess.emit_err(errors::ProcMacroTypeError {\n                             span: input.span,\n                             found: *arg,\n                             kind,\n@@ -2228,7 +2232,7 @@ impl CheckAttrVisitor<'_> {\n             let body_id = tcx.hir().body_owned_by(id.def_id);\n             let excess = tcx.hir().body(body_id).params.get(expected_input_count..);\n             if let Some(excess @ [begin @ end] | excess @ [begin, .., end]) = excess {\n-                tcx.sess.emit_err(ProcMacroDiffArguments {\n+                tcx.sess.emit_err(errors::ProcMacroDiffArguments {\n                     span: begin.span.to(end.span),\n                     count: excess.len(),\n                     kind,\n@@ -2378,7 +2382,7 @@ fn check_invalid_crate_level_attr(tcx: TyCtxt<'_>, attrs: &[Attribute]) {\n         if attr.style == AttrStyle::Inner {\n             for attr_to_check in ATTRS_TO_CHECK {\n                 if attr.has_name(*attr_to_check) {\n-                    tcx.sess.emit_err(InvalidAttrAtCrateLevel {\n+                    tcx.sess.emit_err(errors::InvalidAttrAtCrateLevel {\n                         span: attr.span,\n                         snippet: tcx.sess.source_map().span_to_snippet(attr.span).ok(),\n                         name: *attr_to_check,"}, {"sha": "f4da1aaec11301ff44e303f7e8c316f01dcf3478", "filename": "compiler/rustc_passes/src/lib_features.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -4,7 +4,7 @@\n //! but are not declared in one single location (unlike lang features), which means we need to\n //! collect them instead.\n \n-use rustc_ast::{Attribute, MetaItemKind};\n+use rustc_ast::Attribute;\n use rustc_attr::{rust_version_symbol, VERSION_PLACEHOLDER};\n use rustc_hir::intravisit::Visitor;\n use rustc_middle::hir::nested_filter;\n@@ -42,8 +42,7 @@ impl<'tcx> LibFeatureCollector<'tcx> {\n         // Find a stability attribute: one of #[stable(\u2026)], #[unstable(\u2026)],\n         // #[rustc_const_stable(\u2026)], #[rustc_const_unstable(\u2026)] or #[rustc_default_body_unstable].\n         if let Some(stab_attr) = stab_attrs.iter().find(|stab_attr| attr.has_name(**stab_attr)) {\n-            let meta_kind = attr.meta_kind();\n-            if let Some(MetaItemKind::List(ref metas)) = meta_kind {\n+            if let Some(metas) = attr.meta_item_list() {\n                 let mut feature = None;\n                 let mut since = None;\n                 for meta in metas {"}, {"sha": "7299fc9705cc6036046b3d3036b561042931f123", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1,12 +1,7 @@\n //! A pass that annotates every item and method with its stability level,\n //! propagating default levels lexically from parent to children ast nodes.\n \n-use crate::errors::{\n-    self, CannotStabilizeDeprecated, DeprecatedAttribute, DuplicateFeatureErr,\n-    FeatureOnlyOnNightly, ImpliedFeatureNotExist, InvalidDeprecationVersion, InvalidStability,\n-    MissingConstErr, MissingConstStabAttr, MissingStabilityAttr, TraitImplConstStable,\n-    UnknownFeature, UselessStability,\n-};\n+use crate::errors;\n use rustc_attr::{\n     self as attr, rust_version_symbol, ConstStability, Stability, StabilityLevel, Unstable,\n     UnstableReason, VERSION_PLACEHOLDER,\n@@ -185,7 +180,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n                 {\n                     self.tcx\n                         .sess\n-                        .emit_err(MissingConstErr { fn_sig_span: fn_sig.span, const_span });\n+                        .emit_err(errors::MissingConstErr { fn_sig_span: fn_sig.span, const_span });\n                 }\n             }\n         }\n@@ -203,7 +198,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n \n         if let Some((rustc_attr::Deprecation { is_since_rustc_version: true, .. }, span)) = &depr {\n             if stab.is_none() {\n-                self.tcx.sess.emit_err(DeprecatedAttribute { span: *span });\n+                self.tcx.sess.emit_err(errors::DeprecatedAttribute { span: *span });\n             }\n         }\n \n@@ -219,7 +214,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             if kind == AnnotationKind::Prohibited\n                 || (kind == AnnotationKind::Container && stab.level.is_stable() && is_deprecated)\n             {\n-                self.tcx.sess.emit_err(UselessStability { span, item_sp });\n+                self.tcx.sess.emit_err(errors::UselessStability { span, item_sp });\n             }\n \n             debug!(\"annotate: found {:?}\", stab);\n@@ -235,25 +230,27 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n                 {\n                     match stab_v.parse::<u64>() {\n                         Err(_) => {\n-                            self.tcx.sess.emit_err(InvalidStability { span, item_sp });\n+                            self.tcx.sess.emit_err(errors::InvalidStability { span, item_sp });\n                             break;\n                         }\n                         Ok(stab_vp) => match dep_v.parse::<u64>() {\n                             Ok(dep_vp) => match dep_vp.cmp(&stab_vp) {\n                                 Ordering::Less => {\n-                                    self.tcx\n-                                        .sess\n-                                        .emit_err(CannotStabilizeDeprecated { span, item_sp });\n+                                    self.tcx.sess.emit_err(errors::CannotStabilizeDeprecated {\n+                                        span,\n+                                        item_sp,\n+                                    });\n                                     break;\n                                 }\n                                 Ordering::Equal => continue,\n                                 Ordering::Greater => break,\n                             },\n                             Err(_) => {\n                                 if dep_v != \"TBD\" {\n-                                    self.tcx\n-                                        .sess\n-                                        .emit_err(InvalidDeprecationVersion { span, item_sp });\n+                                    self.tcx.sess.emit_err(errors::InvalidDeprecationVersion {\n+                                        span,\n+                                        item_sp,\n+                                    });\n                                 }\n                                 break;\n                             }\n@@ -527,7 +524,7 @@ impl<'tcx> MissingStabilityAnnotations<'tcx> {\n             && self.effective_visibilities.is_reachable(def_id)\n         {\n             let descr = self.tcx.def_kind(def_id).descr(def_id.to_def_id());\n-            self.tcx.sess.emit_err(MissingStabilityAttr { span, descr });\n+            self.tcx.sess.emit_err(errors::MissingStabilityAttr { span, descr });\n         }\n     }\n \n@@ -555,7 +552,7 @@ impl<'tcx> MissingStabilityAnnotations<'tcx> {\n \n         if is_const && is_stable && missing_const_stability_attribute && is_reachable {\n             let descr = self.tcx.def_kind(def_id).descr(def_id.to_def_id());\n-            self.tcx.sess.emit_err(MissingConstStabAttr { span, descr });\n+            self.tcx.sess.emit_err(errors::MissingConstStabAttr { span, descr });\n         }\n     }\n }\n@@ -768,7 +765,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n                         && *constness == hir::Constness::Const\n                         && const_stab.map_or(false, |(stab, _)| stab.is_const_stable())\n                     {\n-                        self.tcx.sess.emit_err(TraitImplConstStable { span: item.span });\n+                        self.tcx.sess.emit_err(errors::TraitImplConstStable { span: item.span });\n                     }\n                 }\n \n@@ -947,22 +944,22 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n         }\n         if !lang_features.insert(feature) {\n             // Warn if the user enables a lang feature multiple times.\n-            tcx.sess.emit_err(DuplicateFeatureErr { span, feature });\n+            tcx.sess.emit_err(errors::DuplicateFeatureErr { span, feature });\n         }\n     }\n \n     let declared_lib_features = &tcx.features().declared_lib_features;\n     let mut remaining_lib_features = FxIndexMap::default();\n     for (feature, span) in declared_lib_features {\n         if !tcx.sess.opts.unstable_features.is_nightly_build() {\n-            tcx.sess.emit_err(FeatureOnlyOnNightly {\n+            tcx.sess.emit_err(errors::FeatureOnlyOnNightly {\n                 span: *span,\n                 release_channel: env!(\"CFG_RELEASE_CHANNEL\"),\n             });\n         }\n         if remaining_lib_features.contains_key(&feature) {\n             // Warn if the user enables a lib feature multiple times.\n-            tcx.sess.emit_err(DuplicateFeatureErr { span: *span, feature: *feature });\n+            tcx.sess.emit_err(errors::DuplicateFeatureErr { span: *span, feature: *feature });\n         }\n         remaining_lib_features.insert(feature, *span);\n     }\n@@ -1063,7 +1060,7 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n     }\n \n     for (feature, span) in remaining_lib_features {\n-        tcx.sess.emit_err(UnknownFeature { span, feature: *feature });\n+        tcx.sess.emit_err(errors::UnknownFeature { span, feature: *feature });\n     }\n \n     for (implied_by, feature) in remaining_implications {\n@@ -1074,7 +1071,7 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n             .map(|(_, span)| span)\n             .or_else(|| local_defined_features.unstable.get(&feature))\n             .expect(\"feature that implied another does not exist\");\n-        tcx.sess.emit_err(ImpliedFeatureNotExist { span, feature, implied_by });\n+        tcx.sess.emit_err(errors::ImpliedFeatureNotExist { span, feature, implied_by });\n     }\n \n     // FIXME(#44232): the `used_features` table no longer exists, so we"}, {"sha": "744cb77dd00cd1c7b5a2a9131a626eb63d952cb8", "filename": "compiler/rustc_privacy/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_privacy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_privacy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2FCargo.toml?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -13,6 +13,5 @@ rustc_macros = { path = \"../rustc_macros\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n-rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_hir_analysis = { path = \"../rustc_hir_analysis\" }\n tracing = \"0.1\""}, {"sha": "21732d260354d995daa6185af1f183d4f95c61ad", "filename": "compiler/rustc_query_impl/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_query_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_query_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2FCargo.toml?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -20,7 +20,6 @@ rustc-rayon-core = { version = \"0.4.0\", optional = true }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n-rustc_target = { path = \"../rustc_target\" }\n thin-vec = \"0.2.9\"\n tracing = \"0.1\"\n "}, {"sha": "4dea03c1ef6a260882b3d1ed46a5285c3b7cedb0", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -314,11 +314,14 @@ pub(crate) fn create_query_frame<\n     kind: DepKind,\n     name: &'static str,\n ) -> QueryStackFrame<DepKind> {\n-    // Disable visible paths printing for performance reasons.\n-    // Showing visible path instead of any path is not that important in production.\n-    let description = ty::print::with_no_visible_paths!(\n-        // Force filename-line mode to avoid invoking `type_of` query.\n-        ty::print::with_forced_impl_filename_line!(do_describe(tcx.tcx, key))\n+    // Avoid calling queries while formatting the description\n+    let description = ty::print::with_no_queries!(\n+        // Disable visible paths printing for performance reasons.\n+        // Showing visible path instead of any path is not that important in production.\n+        ty::print::with_no_visible_paths!(\n+            // Force filename-line mode to avoid invoking `type_of` query.\n+            ty::print::with_forced_impl_filename_line!(do_describe(tcx.tcx, key))\n+        )\n     );\n     let description =\n         if tcx.sess.verbose() { format!(\"{description} [{name:?}]\") } else { description };"}, {"sha": "21c89cbc4f19da63e3e793815ef71d1e2922fc12", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 17, "deletions": 56, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -16,13 +16,13 @@ use std::marker::PhantomData;\n pub trait CacheSelector<'tcx, V> {\n     type Cache\n     where\n-        V: Clone;\n+        V: Copy;\n     type ArenaCache;\n }\n \n pub trait QueryStorage {\n     type Value: Debug;\n-    type Stored: Clone;\n+    type Stored: Copy;\n \n     /// Store a value without putting it in the cache.\n     /// This is meant to be used with cycle errors.\n@@ -36,14 +36,7 @@ pub trait QueryCache: QueryStorage + Sized {\n     /// It returns the shard index and a lock guard to the shard,\n     /// which will be used if the query is not in the cache and we need\n     /// to compute it.\n-    fn lookup<R, OnHit>(\n-        &self,\n-        key: &Self::Key,\n-        // `on_hit` can be called while holding a lock to the query state shard.\n-        on_hit: OnHit,\n-    ) -> Result<R, ()>\n-    where\n-        OnHit: FnOnce(&Self::Stored, DepNodeIndex) -> R;\n+    fn lookup(&self, key: &Self::Key) -> Option<(Self::Stored, DepNodeIndex)>;\n \n     fn complete(&self, key: Self::Key, value: Self::Value, index: DepNodeIndex) -> Self::Stored;\n \n@@ -55,7 +48,7 @@ pub struct DefaultCacheSelector<K>(PhantomData<K>);\n impl<'tcx, K: Eq + Hash, V: 'tcx> CacheSelector<'tcx, V> for DefaultCacheSelector<K> {\n     type Cache = DefaultCache<K, V>\n     where\n-        V: Clone;\n+        V: Copy;\n     type ArenaCache = ArenaCache<'tcx, K, V>;\n }\n \n@@ -72,7 +65,7 @@ impl<K, V> Default for DefaultCache<K, V> {\n     }\n }\n \n-impl<K: Eq + Hash, V: Clone + Debug> QueryStorage for DefaultCache<K, V> {\n+impl<K: Eq + Hash, V: Copy + Debug> QueryStorage for DefaultCache<K, V> {\n     type Value = V;\n     type Stored = V;\n \n@@ -86,28 +79,20 @@ impl<K: Eq + Hash, V: Clone + Debug> QueryStorage for DefaultCache<K, V> {\n impl<K, V> QueryCache for DefaultCache<K, V>\n where\n     K: Eq + Hash + Clone + Debug,\n-    V: Clone + Debug,\n+    V: Copy + Debug,\n {\n     type Key = K;\n \n     #[inline(always)]\n-    fn lookup<R, OnHit>(&self, key: &K, on_hit: OnHit) -> Result<R, ()>\n-    where\n-        OnHit: FnOnce(&V, DepNodeIndex) -> R,\n-    {\n+    fn lookup(&self, key: &K) -> Option<(V, DepNodeIndex)> {\n         let key_hash = sharded::make_hash(key);\n         #[cfg(parallel_compiler)]\n         let lock = self.cache.get_shard_by_hash(key_hash).lock();\n         #[cfg(not(parallel_compiler))]\n         let lock = self.cache.lock();\n         let result = lock.raw_entry().from_key_hashed_nocheck(key_hash, key);\n \n-        if let Some((_, value)) = result {\n-            let hit_result = on_hit(&value.0, value.1);\n-            Ok(hit_result)\n-        } else {\n-            Err(())\n-        }\n+        if let Some((_, value)) = result { Some(*value) } else { None }\n     }\n \n     #[inline]\n@@ -176,23 +161,15 @@ where\n     type Key = K;\n \n     #[inline(always)]\n-    fn lookup<R, OnHit>(&self, key: &K, on_hit: OnHit) -> Result<R, ()>\n-    where\n-        OnHit: FnOnce(&&'tcx V, DepNodeIndex) -> R,\n-    {\n+    fn lookup(&self, key: &K) -> Option<(&'tcx V, DepNodeIndex)> {\n         let key_hash = sharded::make_hash(key);\n         #[cfg(parallel_compiler)]\n         let lock = self.cache.get_shard_by_hash(key_hash).lock();\n         #[cfg(not(parallel_compiler))]\n         let lock = self.cache.lock();\n         let result = lock.raw_entry().from_key_hashed_nocheck(key_hash, key);\n \n-        if let Some((_, value)) = result {\n-            let hit_result = on_hit(&&value.0, value.1);\n-            Ok(hit_result)\n-        } else {\n-            Err(())\n-        }\n+        if let Some((_, value)) = result { Some((&value.0, value.1)) } else { None }\n     }\n \n     #[inline]\n@@ -234,7 +211,7 @@ pub struct VecCacheSelector<K>(PhantomData<K>);\n impl<'tcx, K: Idx, V: 'tcx> CacheSelector<'tcx, V> for VecCacheSelector<K> {\n     type Cache = VecCache<K, V>\n     where\n-        V: Clone;\n+        V: Copy;\n     type ArenaCache = VecArenaCache<'tcx, K, V>;\n }\n \n@@ -251,7 +228,7 @@ impl<K: Idx, V> Default for VecCache<K, V> {\n     }\n }\n \n-impl<K: Eq + Idx, V: Clone + Debug> QueryStorage for VecCache<K, V> {\n+impl<K: Eq + Idx, V: Copy + Debug> QueryStorage for VecCache<K, V> {\n     type Value = V;\n     type Stored = V;\n \n@@ -265,25 +242,17 @@ impl<K: Eq + Idx, V: Clone + Debug> QueryStorage for VecCache<K, V> {\n impl<K, V> QueryCache for VecCache<K, V>\n where\n     K: Eq + Idx + Clone + Debug,\n-    V: Clone + Debug,\n+    V: Copy + Debug,\n {\n     type Key = K;\n \n     #[inline(always)]\n-    fn lookup<R, OnHit>(&self, key: &K, on_hit: OnHit) -> Result<R, ()>\n-    where\n-        OnHit: FnOnce(&V, DepNodeIndex) -> R,\n-    {\n+    fn lookup(&self, key: &K) -> Option<(V, DepNodeIndex)> {\n         #[cfg(parallel_compiler)]\n         let lock = self.cache.get_shard_by_hash(key.index() as u64).lock();\n         #[cfg(not(parallel_compiler))]\n         let lock = self.cache.lock();\n-        if let Some(Some(value)) = lock.get(*key) {\n-            let hit_result = on_hit(&value.0, value.1);\n-            Ok(hit_result)\n-        } else {\n-            Err(())\n-        }\n+        if let Some(Some(value)) = lock.get(*key) { Some(*value) } else { None }\n     }\n \n     #[inline]\n@@ -357,20 +326,12 @@ where\n     type Key = K;\n \n     #[inline(always)]\n-    fn lookup<R, OnHit>(&self, key: &K, on_hit: OnHit) -> Result<R, ()>\n-    where\n-        OnHit: FnOnce(&&'tcx V, DepNodeIndex) -> R,\n-    {\n+    fn lookup(&self, key: &K) -> Option<(&'tcx V, DepNodeIndex)> {\n         #[cfg(parallel_compiler)]\n         let lock = self.cache.get_shard_by_hash(key.index() as u64).lock();\n         #[cfg(not(parallel_compiler))]\n         let lock = self.cache.lock();\n-        if let Some(Some(value)) = lock.get(*key) {\n-            let hit_result = on_hit(&&value.0, value.1);\n-            Ok(hit_result)\n-        } else {\n-            Err(())\n-        }\n+        if let Some(Some(value)) = lock.get(*key) { Some((&value.0, value.1)) } else { None }\n     }\n \n     #[inline]"}, {"sha": "a28e45a5c086dc66805730ad804b22df8dfb38fa", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -21,7 +21,7 @@ pub trait QueryConfig<Qcx: QueryContext> {\n \n     type Key: DepNodeParams<Qcx::DepContext> + Eq + Hash + Clone + Debug;\n     type Value: Debug;\n-    type Stored: Debug + Clone + std::borrow::Borrow<Self::Value>;\n+    type Stored: Debug + Copy + std::borrow::Borrow<Self::Value>;\n \n     type Cache: QueryCache<Key = Self::Key, Stored = Self::Stored, Value = Self::Value>;\n "}, {"sha": "ffc413d15f52b0528d7c294b554be089940df5fc", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -130,7 +130,7 @@ fn mk_cycle<Qcx, V, R, D: DepKind>(\n where\n     Qcx: QueryContext + crate::query::HasDepContext<DepKind = D>,\n     V: std::fmt::Debug + Value<Qcx::DepContext, Qcx::DepKind>,\n-    R: Clone,\n+    R: Copy,\n {\n     let error = report_cycle(qcx.dep_context().sess(), &cycle_error);\n     let value = handle_cycle_error(*qcx.dep_context(), &cycle_error, error, handler);\n@@ -339,25 +339,21 @@ where\n /// which will be used if the query is not in the cache and we need\n /// to compute it.\n #[inline]\n-pub fn try_get_cached<Tcx, C, R, OnHit>(\n-    tcx: Tcx,\n-    cache: &C,\n-    key: &C::Key,\n-    // `on_hit` can be called while holding a lock to the query cache\n-    on_hit: OnHit,\n-) -> Result<R, ()>\n+pub fn try_get_cached<Tcx, C>(tcx: Tcx, cache: &C, key: &C::Key) -> Option<C::Stored>\n where\n     C: QueryCache,\n     Tcx: DepContext,\n-    OnHit: FnOnce(&C::Stored) -> R,\n {\n-    cache.lookup(&key, |value, index| {\n-        if std::intrinsics::unlikely(tcx.profiler().enabled()) {\n-            tcx.profiler().query_cache_hit(index.into());\n+    match cache.lookup(&key) {\n+        Some((value, index)) => {\n+            if std::intrinsics::unlikely(tcx.profiler().enabled()) {\n+                tcx.profiler().query_cache_hit(index.into());\n+            }\n+            tcx.dep_graph().read_index(index);\n+            Some(value)\n         }\n-        tcx.dep_graph().read_index(index);\n-        on_hit(value)\n-    })\n+        None => None,\n+    }\n }\n \n fn try_execute_query<Q, Qcx>(\n@@ -379,17 +375,25 @@ where\n             if Q::FEEDABLE {\n                 // We may have put a value inside the cache from inside the execution.\n                 // Verify that it has the same hash as what we have now, to ensure consistency.\n-                let _ = cache.lookup(&key, |cached_result, _| {\n+                if let Some((cached_result, _)) = cache.lookup(&key) {\n                     let hasher = Q::HASH_RESULT.expect(\"feedable forbids no_hash\");\n \n-                    let old_hash = qcx.dep_context().with_stable_hashing_context(|mut hcx| hasher(&mut hcx, cached_result.borrow()));\n-                    let new_hash = qcx.dep_context().with_stable_hashing_context(|mut hcx| hasher(&mut hcx, &result));\n+                    let old_hash = qcx.dep_context().with_stable_hashing_context(|mut hcx| {\n+                        hasher(&mut hcx, cached_result.borrow())\n+                    });\n+                    let new_hash = qcx\n+                        .dep_context()\n+                        .with_stable_hashing_context(|mut hcx| hasher(&mut hcx, &result));\n                     debug_assert_eq!(\n-                        old_hash, new_hash,\n+                        old_hash,\n+                        new_hash,\n                         \"Computed query value for {:?}({:?}) is inconsistent with fed value,\\ncomputed={:#?}\\nfed={:#?}\",\n-                        Q::DEP_KIND, key, result, cached_result,\n+                        Q::DEP_KIND,\n+                        key,\n+                        result,\n+                        cached_result,\n                     );\n-                });\n+                }\n             }\n             let result = job.complete(cache, result, dep_node_index);\n             (result, Some(dep_node_index))\n@@ -400,9 +404,9 @@ where\n         }\n         #[cfg(parallel_compiler)]\n         TryGetJob::JobCompleted(query_blocked_prof_timer) => {\n-            let (v, index) = cache\n-                .lookup(&key, |value, index| (value.clone(), index))\n-                .unwrap_or_else(|_| panic!(\"value must be in cache after waiting\"));\n+            let Some((v, index)) = cache.lookup(&key) else {\n+                panic!(\"value must be in cache after waiting\")\n+            };\n \n             if std::intrinsics::unlikely(qcx.dep_context().profiler().enabled()) {\n                 qcx.dep_context().profiler().query_cache_hit(index.into());\n@@ -771,15 +775,11 @@ where\n     // We may be concurrently trying both execute and force a query.\n     // Ensure that only one of them runs the query.\n     let cache = Q::query_cache(qcx);\n-    let cached = cache.lookup(&key, |_, index| {\n+    if let Some((_, index)) = cache.lookup(&key) {\n         if std::intrinsics::unlikely(qcx.dep_context().profiler().enabled()) {\n             qcx.dep_context().profiler().query_cache_hit(index.into());\n         }\n-    });\n-\n-    match cached {\n-        Ok(()) => return,\n-        Err(()) => {}\n+        return;\n     }\n \n     let state = Q::query_state(qcx);"}, {"sha": "2fb62ce53ba6e357b0f4be8d04eef0fa949b949d", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -265,7 +265,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 let ident = path.segments.get(0).expect(\"empty path in visibility\").ident;\n                 let crate_root = if ident.is_path_segment_keyword() {\n                     None\n-                } else if ident.span.rust_2015() {\n+                } else if ident.span.is_rust_2015() {\n                     Some(Segment::from_ident(Ident::new(\n                         kw::PathRoot,\n                         path.span.shrink_to_lo().with_ctxt(ident.span.ctxt()),\n@@ -435,10 +435,10 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         // appears, so imports in braced groups can have roots prepended independently.\n         let is_glob = matches!(use_tree.kind, ast::UseTreeKind::Glob);\n         let crate_root = match prefix_iter.peek() {\n-            Some(seg) if !seg.ident.is_path_segment_keyword() && seg.ident.span.rust_2015() => {\n+            Some(seg) if !seg.ident.is_path_segment_keyword() && seg.ident.span.is_rust_2015() => {\n                 Some(seg.ident.span.ctxt())\n             }\n-            None if is_glob && use_tree.span.rust_2015() => Some(use_tree.span.ctxt()),\n+            None if is_glob && use_tree.span.is_rust_2015() => Some(use_tree.span.ctxt()),\n             _ => None,\n         }\n         .map(|ctxt| {"}, {"sha": "a08ae0f184bb2f62cb7400353a063e6e417ed998", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -462,7 +462,9 @@ impl<'a> Resolver<'a> {\n \n         let first_name = match path.get(0) {\n             // In the 2018 edition this lint is a hard error, so nothing to do\n-            Some(seg) if seg.ident.span.rust_2015() && self.session.rust_2015() => seg.ident.name,\n+            Some(seg) if seg.ident.span.is_rust_2015() && self.session.is_rust_2015() => {\n+                seg.ident.name\n+            }\n             _ => return,\n         };\n \n@@ -1717,7 +1719,7 @@ impl<'a> Resolver<'a> {\n                         Applicability::MaybeIncorrect,\n                     )),\n                 )\n-            } else if self.session.rust_2015() {\n+            } else if self.session.is_rust_2015() {\n                 (\n                     format!(\"maybe a missing crate `{ident}`?\"),\n                     Some((\n@@ -1996,7 +1998,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n     ) -> Option<(Vec<Segment>, Option<String>)> {\n-        if path[1].ident.span.rust_2015() {\n+        if path[1].ident.span.is_rust_2015() {\n             return None;\n         }\n "}, {"sha": "d03ccf256fad79f2ddc6a1d48e002e821a67e7fe", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -85,7 +85,7 @@ impl<'a> Resolver<'a> {\n         // 4c. Standard library prelude (de-facto closed, controlled).\n         // 6. Language prelude: builtin attributes (closed, controlled).\n \n-        let rust_2015 = ctxt.edition().rust_2015();\n+        let rust_2015 = ctxt.edition().is_rust_2015();\n         let (ns, macro_kind, is_absolute_path) = match scope_set {\n             ScopeSet::All(ns, _) => (ns, None, false),\n             ScopeSet::AbsolutePath(ns) => (ns, None, true),\n@@ -1397,7 +1397,8 @@ impl<'a> Resolver<'a> {\n                         module = Some(ModuleOrUniformRoot::ExternPrelude);\n                         continue;\n                     }\n-                    if name == kw::PathRoot && ident.span.rust_2015() && self.session.rust_2018() {\n+                    if name == kw::PathRoot && ident.span.is_rust_2015() && self.session.rust_2018()\n+                    {\n                         // `::a::b` from 2015 macro on 2018 global edition\n                         module = Some(ModuleOrUniformRoot::CrateRootAndExternPrelude);\n                         continue;"}, {"sha": "3ca10ac50baa6392ed0fcf47f46de5ad34b9871e", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -2145,7 +2145,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         let segments = &use_tree.prefix.segments;\n         if !segments.is_empty() {\n             let ident = segments[0].ident;\n-            if ident.is_path_segment_keyword() || ident.span.rust_2015() {\n+            if ident.is_path_segment_keyword() || ident.span.is_rust_2015() {\n                 return;\n             }\n "}, {"sha": "cee0a7f3c203d8e4eeb871f99f978ccfac100839", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1343,7 +1343,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                     \"!\",\n                     Applicability::MaybeIncorrect,\n                 );\n-                if path_str == \"try\" && span.rust_2015() {\n+                if path_str == \"try\" && span.is_rust_2015() {\n                     err.note(\"if you want the `try` keyword, you need Rust 2018 or later\");\n                 }\n             }"}, {"sha": "55178250472ef94bc08d45ba429ea02f7f83458b", "filename": "compiler/rustc_session/src/code_stats.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_session%2Fsrc%2Fcode_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_session%2Fsrc%2Fcode_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fcode_stats.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -84,7 +84,11 @@ impl CodeStats {\n         // Sort variants so the largest ones are shown first. A stable sort is\n         // used here so that source code order is preserved for all variants\n         // that have the same size.\n-        variants.sort_by(|info1, info2| info2.size.cmp(&info1.size));\n+        // Except for Generators, whose variants are already sorted according to\n+        // their yield points in `variant_info_for_generator`.\n+        if kind != DataTypeKind::Generator {\n+            variants.sort_by(|info1, info2| info2.size.cmp(&info1.size));\n+        }\n         let info = TypeSizeInfo {\n             kind,\n             type_description: type_desc.to_string(),"}, {"sha": "8a0176f6391743adb6a17ccf30a3fc49223b92b3", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 25, "deletions": 31, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -3,15 +3,7 @@ use crate::code_stats::CodeStats;\n pub use crate::code_stats::{DataTypeKind, FieldInfo, FieldKind, SizeKind, VariantInfo};\n use crate::config::Input;\n use crate::config::{self, CrateType, InstrumentCoverage, OptLevel, OutputType, SwitchWithOptPath};\n-use crate::errors::{\n-    BranchProtectionRequiresAArch64, CannotEnableCrtStaticLinux, CannotMixAndMatchSanitizers,\n-    LinkerPluginToWindowsNotSupported, NotCircumventFeature, OptimisationFuelExhausted,\n-    ProfileSampleUseFileDoesNotExist, ProfileUseFileDoesNotExist, SanitizerCfiEnabled,\n-    SanitizerNotSupported, SanitizersNotSupported, SkippingConstChecks,\n-    SplitDebugInfoUnstablePlatform, StackProtectorNotSupportedForTarget,\n-    TargetRequiresUnwindTables, UnleashedFeatureHelp, UnstableVirtualFunctionElimination,\n-    UnsupportedDwarfVersion,\n-};\n+use crate::errors;\n use crate::parse::{add_feature_diagnostics, ParseSess};\n use crate::search_paths::{PathKind, SearchPath};\n use crate::{filesearch, lint};\n@@ -246,23 +238,23 @@ impl Session {\n         if !unleashed_features.is_empty() {\n             let mut must_err = false;\n             // Create a diagnostic pointing at where things got unleashed.\n-            self.emit_warning(SkippingConstChecks {\n+            self.emit_warning(errors::SkippingConstChecks {\n                 unleashed_features: unleashed_features\n                     .iter()\n                     .map(|(span, gate)| {\n                         gate.map(|gate| {\n                             must_err = true;\n-                            UnleashedFeatureHelp::Named { span: *span, gate }\n+                            errors::UnleashedFeatureHelp::Named { span: *span, gate }\n                         })\n-                        .unwrap_or(UnleashedFeatureHelp::Unnamed { span: *span })\n+                        .unwrap_or(errors::UnleashedFeatureHelp::Unnamed { span: *span })\n                     })\n                     .collect(),\n             });\n \n             // If we should err, make sure we did.\n             if must_err && self.has_errors().is_none() {\n                 // We have skipped a feature gate, and not run into other errors... reject.\n-                self.emit_err(NotCircumventFeature);\n+                self.emit_err(errors::NotCircumventFeature);\n             }\n         }\n     }\n@@ -901,7 +893,7 @@ impl Session {\n                         // We only call `msg` in case we can actually emit warnings.\n                         // Otherwise, this could cause a `delay_good_path_bug` to\n                         // trigger (issue #79546).\n-                        self.emit_warning(OptimisationFuelExhausted { msg: msg() });\n+                        self.emit_warning(errors::OptimisationFuelExhausted { msg: msg() });\n                     }\n                     fuel.out_of_fuel = true;\n                 } else if fuel.remaining > 0 {\n@@ -919,8 +911,8 @@ impl Session {\n     }\n \n     /// Is this edition 2015?\n-    pub fn rust_2015(&self) -> bool {\n-        self.edition().rust_2015()\n+    pub fn is_rust_2015(&self) -> bool {\n+        self.edition().is_rust_2015()\n     }\n \n     /// Are we allowed to use features from the Rust 2018 edition?\n@@ -1502,28 +1494,28 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n         && sess.opts.cg.prefer_dynamic\n         && sess.target.is_like_windows\n     {\n-        sess.emit_err(LinkerPluginToWindowsNotSupported);\n+        sess.emit_err(errors::LinkerPluginToWindowsNotSupported);\n     }\n \n     // Make sure that any given profiling data actually exists so LLVM can't\n     // decide to silently skip PGO.\n     if let Some(ref path) = sess.opts.cg.profile_use {\n         if !path.exists() {\n-            sess.emit_err(ProfileUseFileDoesNotExist { path });\n+            sess.emit_err(errors::ProfileUseFileDoesNotExist { path });\n         }\n     }\n \n     // Do the same for sample profile data.\n     if let Some(ref path) = sess.opts.unstable_opts.profile_sample_use {\n         if !path.exists() {\n-            sess.emit_err(ProfileSampleUseFileDoesNotExist { path });\n+            sess.emit_err(errors::ProfileSampleUseFileDoesNotExist { path });\n         }\n     }\n \n     // Unwind tables cannot be disabled if the target requires them.\n     if let Some(include_uwtables) = sess.opts.cg.force_unwind_tables {\n         if sess.target.requires_uwtable && !include_uwtables {\n-            sess.emit_err(TargetRequiresUnwindTables);\n+            sess.emit_err(errors::TargetRequiresUnwindTables);\n         }\n     }\n \n@@ -1533,67 +1525,69 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n     match unsupported_sanitizers.into_iter().count() {\n         0 => {}\n         1 => {\n-            sess.emit_err(SanitizerNotSupported { us: unsupported_sanitizers.to_string() });\n+            sess.emit_err(errors::SanitizerNotSupported { us: unsupported_sanitizers.to_string() });\n         }\n         _ => {\n-            sess.emit_err(SanitizersNotSupported { us: unsupported_sanitizers.to_string() });\n+            sess.emit_err(errors::SanitizersNotSupported {\n+                us: unsupported_sanitizers.to_string(),\n+            });\n         }\n     }\n     // Cannot mix and match sanitizers.\n     let mut sanitizer_iter = sess.opts.unstable_opts.sanitizer.into_iter();\n     if let (Some(first), Some(second)) = (sanitizer_iter.next(), sanitizer_iter.next()) {\n-        sess.emit_err(CannotMixAndMatchSanitizers {\n+        sess.emit_err(errors::CannotMixAndMatchSanitizers {\n             first: first.to_string(),\n             second: second.to_string(),\n         });\n     }\n \n     // Cannot enable crt-static with sanitizers on Linux\n     if sess.crt_static(None) && !sess.opts.unstable_opts.sanitizer.is_empty() {\n-        sess.emit_err(CannotEnableCrtStaticLinux);\n+        sess.emit_err(errors::CannotEnableCrtStaticLinux);\n     }\n \n     // LLVM CFI and VFE both require LTO.\n     if sess.lto() != config::Lto::Fat {\n         if sess.is_sanitizer_cfi_enabled() {\n-            sess.emit_err(SanitizerCfiEnabled);\n+            sess.emit_err(errors::SanitizerCfiEnabled);\n         }\n         if sess.opts.unstable_opts.virtual_function_elimination {\n-            sess.emit_err(UnstableVirtualFunctionElimination);\n+            sess.emit_err(errors::UnstableVirtualFunctionElimination);\n         }\n     }\n \n     // LLVM CFI and KCFI are mutually exclusive\n     if sess.is_sanitizer_cfi_enabled() && sess.is_sanitizer_kcfi_enabled() {\n-        sess.emit_err(CannotMixAndMatchSanitizers {\n+        sess.emit_err(errors::CannotMixAndMatchSanitizers {\n             first: \"cfi\".to_string(),\n             second: \"kcfi\".to_string(),\n         });\n     }\n \n     if sess.opts.unstable_opts.stack_protector != StackProtector::None {\n         if !sess.target.options.supports_stack_protector {\n-            sess.emit_warning(StackProtectorNotSupportedForTarget {\n+            sess.emit_warning(errors::StackProtectorNotSupportedForTarget {\n                 stack_protector: sess.opts.unstable_opts.stack_protector,\n                 target_triple: &sess.opts.target_triple,\n             });\n         }\n     }\n \n     if sess.opts.unstable_opts.branch_protection.is_some() && sess.target.arch != \"aarch64\" {\n-        sess.emit_err(BranchProtectionRequiresAArch64);\n+        sess.emit_err(errors::BranchProtectionRequiresAArch64);\n     }\n \n     if let Some(dwarf_version) = sess.opts.unstable_opts.dwarf_version {\n         if dwarf_version > 5 {\n-            sess.emit_err(UnsupportedDwarfVersion { dwarf_version });\n+            sess.emit_err(errors::UnsupportedDwarfVersion { dwarf_version });\n         }\n     }\n \n     if !sess.target.options.supported_split_debuginfo.contains(&sess.split_debuginfo())\n         && !sess.opts.unstable_opts.unstable_options\n     {\n-        sess.emit_err(SplitDebugInfoUnstablePlatform { debuginfo: sess.split_debuginfo() });\n+        sess.emit_err(errors::SplitDebugInfoUnstablePlatform { debuginfo: sess.split_debuginfo() });\n     }\n }\n "}, {"sha": "cdda052f529067a27f4c82d49c04bef4a8d7df6e", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -119,6 +119,12 @@ impl DefPathHash {\n     }\n }\n \n+impl Default for DefPathHash {\n+    fn default() -> Self {\n+        DefPathHash(Fingerprint::ZERO)\n+    }\n+}\n+\n impl Borrow<Fingerprint> for DefPathHash {\n     #[inline]\n     fn borrow(&self) -> &Fingerprint {"}, {"sha": "f16db69aae2323d6efef2998b64dc43ee307837a", "filename": "compiler/rustc_span/src/edition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_span%2Fsrc%2Fedition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_span%2Fsrc%2Fedition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fedition.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -77,7 +77,7 @@ impl Edition {\n     }\n \n     /// Is this edition 2015?\n-    pub fn rust_2015(self) -> bool {\n+    pub fn is_rust_2015(self) -> bool {\n         self == Edition::Edition2015\n     }\n "}, {"sha": "e095cf3fda20d53cef6edd184b5c29d998d74b99", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -705,8 +705,8 @@ impl Span {\n     }\n \n     #[inline]\n-    pub fn rust_2015(self) -> bool {\n-        self.edition().rust_2015()\n+    pub fn is_rust_2015(self) -> bool {\n+        self.edition().is_rust_2015()\n     }\n \n     #[inline]"}, {"sha": "1933360f722a04bb53178175c387adef0fa62776", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1049,6 +1049,7 @@ symbols! {\n         overlapping_marker_traits,\n         owned_box,\n         packed,\n+        packed_bundled_libs,\n         panic,\n         panic_2015,\n         panic_2021,"}, {"sha": "3f863038efb3769f6b0968ce25ebc55331c8f2f1", "filename": "compiler/rustc_trait_selection/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_trait_selection%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_trait_selection%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2FCargo.toml?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -16,7 +16,6 @@ rustc_errors = { path = \"../rustc_errors\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_infer = { path = \"../rustc_infer\" }\n-rustc_lint_defs = { path = \"../rustc_lint_defs\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_query_system = { path = \"../rustc_query_system\" }\n rustc_serialize = { path = \"../rustc_serialize\" }"}, {"sha": "ccdf6246083cc59787129366e46b47c2748edd91", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -81,6 +81,7 @@ pub(super) enum CandidateSource {\n     AliasBound,\n }\n \n+/// Methods used to assemble candidates for either trait or projection goals.\n pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy + Eq {\n     fn self_ty(self) -> Ty<'tcx>;\n \n@@ -188,6 +189,11 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy + Eq {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> Vec<CanonicalResponse<'tcx>>;\n+\n+    fn consider_builtin_discriminant_kind_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n@@ -320,6 +326,8 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             G::consider_builtin_generator_candidate(self, goal)\n         } else if lang_items.unsize_trait() == Some(trait_def_id) {\n             G::consider_builtin_unsize_candidate(self, goal)\n+        } else if lang_items.discriminant_kind_trait() == Some(trait_def_id) {\n+            G::consider_builtin_discriminant_kind_candidate(self, goal)\n         } else {\n             Err(NoSolution)\n         };"}, {"sha": "e4725c0a1b7326895344eeb0a31dcefe967ca4e7", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -24,7 +24,8 @@ use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::Obligation;\n use rustc_middle::infer::canonical::Certainty as OldCertainty;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::traits::solve::{ExternalConstraints, ExternalConstraintsData};\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_middle::ty::{\n     CoercePredicate, RegionOutlivesPredicate, SubtypePredicate, ToPredicate, TypeOutlivesPredicate,\n };\n@@ -72,8 +73,7 @@ impl<'tcx, P> From<Obligation<'tcx, P>> for Goal<'tcx, P> {\n         Goal { param_env: obligation.param_env, predicate: obligation.predicate }\n     }\n }\n-\n-#[derive(Debug, PartialEq, Eq, Clone, Hash, TypeFoldable, TypeVisitable)]\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n pub struct Response<'tcx> {\n     pub var_values: CanonicalVarValues<'tcx>,\n     /// Additional constraints returned by this query.\n@@ -121,14 +121,6 @@ pub enum MaybeCause {\n     Overflow,\n }\n \n-/// Additional constraints returned on success.\n-#[derive(Debug, PartialEq, Eq, Clone, Hash, TypeFoldable, TypeVisitable, Default)]\n-pub struct ExternalConstraints<'tcx> {\n-    // FIXME: implement this.\n-    regions: (),\n-    opaque_types: Vec<(Ty<'tcx>, Ty<'tcx>)>,\n-}\n-\n type CanonicalGoal<'tcx, T = ty::Predicate<'tcx>> = Canonical<'tcx, Goal<'tcx, T>>;\n type CanonicalResponse<'tcx> = Canonical<'tcx, Response<'tcx>>;\n /// The result of evaluating a canonical query.\n@@ -218,15 +210,14 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 EvalCtxt { infcx, var_values, search_graph, in_projection_eq_hack: false };\n             let result = ecx.compute_goal(goal);\n \n-            // FIXME: `Response` should be `Copy`\n-            if search_graph.try_finalize_goal(tcx, canonical_goal, result.clone()) {\n+            if search_graph.try_finalize_goal(tcx, canonical_goal, result) {\n                 return result;\n             }\n         }\n     }\n \n     fn make_canonical_response(&self, certainty: Certainty) -> QueryResult<'tcx> {\n-        let external_constraints = take_external_constraints(self.infcx)?;\n+        let external_constraints = compute_external_query_constraints(self.infcx)?;\n \n         Ok(self.infcx.canonicalize_response(Response {\n             var_values: self.var_values,\n@@ -461,18 +452,18 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n }\n \n #[instrument(level = \"debug\", skip(infcx), ret)]\n-fn take_external_constraints<'tcx>(\n+fn compute_external_query_constraints<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n ) -> Result<ExternalConstraints<'tcx>, NoSolution> {\n     let region_obligations = infcx.take_registered_region_obligations();\n     let opaque_types = infcx.take_opaque_types_for_query_response();\n-    Ok(ExternalConstraints {\n+    Ok(infcx.tcx.intern_external_constraints(ExternalConstraintsData {\n         // FIXME: Now that's definitely wrong :)\n         //\n         // Should also do the leak check here I think\n         regions: drop(region_obligations),\n         opaque_types,\n-    })\n+    }))\n }\n \n fn instantiate_canonical_query_response<'tcx>(\n@@ -492,7 +483,10 @@ fn instantiate_canonical_query_response<'tcx>(\n                     Certainty::Yes => OldCertainty::Proven,\n                     Certainty::Maybe(_) => OldCertainty::Ambiguous,\n                 },\n-                opaque_types: resp.external_constraints.opaque_types,\n+                // FIXME: This to_owned makes me sad, but we should eventually impl\n+                // `instantiate_query_response_and_region_obligations` separately\n+                // instead of piggybacking off of the old implementation.\n+                opaque_types: resp.external_constraints.opaque_types.to_owned(),\n                 value: resp.certainty,\n             }),\n         ) else { bug!(); };\n@@ -510,7 +504,10 @@ pub(super) fn response_no_constraints<'tcx>(\n         variables: goal.variables,\n         value: Response {\n             var_values: CanonicalVarValues::make_identity(tcx, goal.variables),\n-            external_constraints: Default::default(),\n+            // FIXME: maybe we should store the \"no response\" version in tcx, like\n+            // we do for tcx.types and stuff.\n+            external_constraints: tcx\n+                .intern_external_constraints(ExternalConstraintsData::default()),\n             certainty,\n         },\n     })"}, {"sha": "9f62f686af647f2c1a3f6a314954e89dbd804c81", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -581,6 +581,15 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n     ) -> Vec<super::CanonicalResponse<'tcx>> {\n         bug!(\"`Unsize` does not have an associated type: {:?}\", goal);\n     }\n+\n+    fn consider_builtin_discriminant_kind_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        let discriminant = goal.predicate.self_ty().discriminant_ty(ecx.tcx());\n+        ecx.infcx\n+            .probe(|_| ecx.eq_term_and_make_canonical_response(goal, Certainty::Yes, discriminant))\n+    }\n }\n \n /// This behavior is also implemented in `rustc_ty_utils` and in the old `project` code."}, {"sha": "86b13c05f76aa16a7706601514b6dd1ea5327ce9", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/cache.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -95,8 +95,7 @@ impl<'tcx> ProvisionalCache<'tcx> {\n     }\n \n     pub(super) fn provisional_result(&self, entry_index: EntryIndex) -> QueryResult<'tcx> {\n-        // FIXME: Responses should probably be `Copy` as well\n-        self.entries[entry_index].response.clone()\n+        self.entries[entry_index].response\n     }\n }\n "}, {"sha": "0003dfeaee78117ca8a4426dfa48a052808c4ab2", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -439,6 +439,14 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n \n         responses\n     }\n+\n+    fn consider_builtin_discriminant_kind_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        _goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        // `DiscriminantKind` is automatically implemented for every type.\n+        ecx.make_canonical_response(Certainty::Yes)\n+    }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {"}, {"sha": "8f548acfd2eaccc8834f326f04cb201dcefd8e6d", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 50, "deletions": 10, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -547,16 +547,56 @@ fn virtual_call_violation_for_method<'tcx>(\n \n     // NOTE: This check happens last, because it results in a lint, and not a\n     // hard error.\n-    if tcx\n-        .predicates_of(method.def_id)\n-        .predicates\n-        .iter()\n-        // A trait object can't claim to live more than the concrete type,\n-        // so outlives predicates will always hold.\n-        .cloned()\n-        .filter(|(p, _)| p.to_opt_type_outlives().is_none())\n-        .any(|pred| contains_illegal_self_type_reference(tcx, trait_def_id, pred))\n-    {\n+    if tcx.predicates_of(method.def_id).predicates.iter().any(|&(pred, span)| {\n+        // dyn Trait is okay:\n+        //\n+        //     trait Trait {\n+        //         fn f(&self) where Self: 'static;\n+        //     }\n+        //\n+        // because a trait object can't claim to live longer than the concrete\n+        // type. If the lifetime bound holds on dyn Trait then it's guaranteed\n+        // to hold as well on the concrete type.\n+        if pred.to_opt_type_outlives().is_some() {\n+            return false;\n+        }\n+\n+        // dyn Trait is okay:\n+        //\n+        //     auto trait AutoTrait {}\n+        //\n+        //     trait Trait {\n+        //         fn f(&self) where Self: AutoTrait;\n+        //     }\n+        //\n+        // because `impl AutoTrait for dyn Trait` is disallowed by coherence.\n+        // Traits with a default impl are implemented for a trait object if and\n+        // only if the autotrait is one of the trait object's trait bounds, like\n+        // in `dyn Trait + AutoTrait`. This guarantees that trait objects only\n+        // implement auto traits if the underlying type does as well.\n+        if let ty::PredicateKind::Clause(ty::Clause::Trait(ty::TraitPredicate {\n+            trait_ref: pred_trait_ref,\n+            constness: ty::BoundConstness::NotConst,\n+            polarity: ty::ImplPolarity::Positive,\n+        })) = pred.kind().skip_binder()\n+            && pred_trait_ref.self_ty() == tcx.types.self_param\n+            && tcx.trait_is_auto(pred_trait_ref.def_id)\n+        {\n+            // Consider bounds like `Self: Bound<Self>`. Auto traits are not\n+            // allowed to have generic parameters so `auto trait Bound<T> {}`\n+            // would already have reported an error at the definition of the\n+            // auto trait.\n+            if pred_trait_ref.substs.len() != 1 {\n+                tcx.sess.diagnostic().delay_span_bug(\n+                    span,\n+                    \"auto traits cannot have generic parameters\",\n+                );\n+            }\n+            return false;\n+        }\n+\n+        contains_illegal_self_type_reference(tcx, trait_def_id, pred.clone())\n+    }) {\n         return Some(MethodViolationCode::WhereClauseReferencesSelf);\n     }\n "}, {"sha": "94d9eb8f587a70ebbd9383cccdab5c516cdbca04", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1190,6 +1190,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ImplDerivedObligation(Box::new(ImplDerivedObligationCause {\n                     derived,\n                     impl_def_id,\n+                    impl_def_predicate_index: None,\n                     span: obligation.cause.span,\n                 }))\n             });"}, {"sha": "0c6b2406bbdafb0cd0e547a405e72cc988e9a494", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -2608,11 +2608,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         assert_eq!(predicates.parent, None);\n         let predicates = predicates.instantiate_own(tcx, substs);\n         let mut obligations = Vec::with_capacity(predicates.len());\n-        for (predicate, span) in predicates {\n+        for (index, (predicate, span)) in predicates.into_iter().enumerate() {\n             let cause = cause.clone().derived_cause(parent_trait_pred, |derived| {\n                 ImplDerivedObligation(Box::new(ImplDerivedObligationCause {\n                     derived,\n                     impl_def_id: def_id,\n+                    impl_def_predicate_index: Some(index),\n                     span,\n                 }))\n             });"}, {"sha": "eff6fb26dd4c503f8091b224acc24e9f3be40597", "filename": "compiler/rustc_traits/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2FCargo.toml?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -5,7 +5,6 @@ edition = \"2021\"\n \n [dependencies]\n tracing = \"0.1\"\n-rustc_attr = { path = \"../rustc_attr\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_hir = { path = \"../rustc_hir\" }"}, {"sha": "ad5527f5a778b89bb11ba49c9f95c23f3b307491", "filename": "compiler/rustc_ty_utils/src/abi.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -254,15 +254,18 @@ fn adjust_for_rust_scalar<'tcx>(\n         if let Some(kind) = pointee.safe {\n             attrs.pointee_align = Some(pointee.align);\n \n-            // `Box` (`UniqueBorrowed`) are not necessarily dereferenceable\n-            // for the entire duration of the function as they can be deallocated\n-            // at any time. Same for shared mutable references. If LLVM had a\n-            // way to say \"dereferenceable on entry\" we could use it here.\n+            // `Box` are not necessarily dereferenceable for the entire duration of the function as\n+            // they can be deallocated at any time. Same for non-frozen shared references (see\n+            // <https://github.com/rust-lang/rust/pull/98017>), and for mutable references to\n+            // potentially self-referential types (see\n+            // <https://github.com/rust-lang/unsafe-code-guidelines/issues/381>). If LLVM had a way\n+            // to say \"dereferenceable on entry\" we could use it here.\n             attrs.pointee_size = match kind {\n-                PointerKind::UniqueBorrowed\n-                | PointerKind::UniqueBorrowedPinned\n-                | PointerKind::Frozen => pointee.size,\n-                PointerKind::SharedMutable | PointerKind::UniqueOwned => Size::ZERO,\n+                PointerKind::Box { .. }\n+                | PointerKind::SharedRef { frozen: false }\n+                | PointerKind::MutableRef { unpin: false } => Size::ZERO,\n+                PointerKind::SharedRef { frozen: true }\n+                | PointerKind::MutableRef { unpin: true } => pointee.size,\n             };\n \n             // The aliasing rules for `Box<T>` are still not decided, but currently we emit\n@@ -275,26 +278,24 @@ fn adjust_for_rust_scalar<'tcx>(\n             // versions at all anymore. We still support turning it off using -Zmutable-noalias.\n             let noalias_mut_ref = cx.tcx.sess.opts.unstable_opts.mutable_noalias;\n \n-            // `&mut` pointer parameters never alias other parameters,\n-            // or mutable global data\n+            // `&T` where `T` contains no `UnsafeCell<U>` is immutable, and can be marked as both\n+            // `readonly` and `noalias`, as LLVM's definition of `noalias` is based solely on memory\n+            // dependencies rather than pointer equality. However this only applies to arguments,\n+            // not return values.\n             //\n-            // `&T` where `T` contains no `UnsafeCell<U>` is immutable,\n-            // and can be marked as both `readonly` and `noalias`, as\n-            // LLVM's definition of `noalias` is based solely on memory\n-            // dependencies rather than pointer equality\n+            // `&mut T` and `Box<T>` where `T: Unpin` are unique and hence `noalias`.\n             let no_alias = match kind {\n-                PointerKind::SharedMutable | PointerKind::UniqueBorrowedPinned => false,\n-                PointerKind::UniqueBorrowed => noalias_mut_ref,\n-                PointerKind::UniqueOwned => noalias_for_box,\n-                PointerKind::Frozen => true,\n+                PointerKind::SharedRef { frozen } => frozen,\n+                PointerKind::MutableRef { unpin } => unpin && noalias_mut_ref,\n+                PointerKind::Box { unpin } => unpin && noalias_for_box,\n             };\n             // We can never add `noalias` in return position; that LLVM attribute has some very surprising semantics\n             // (see <https://github.com/rust-lang/unsafe-code-guidelines/issues/385#issuecomment-1368055745>).\n             if no_alias && !is_return {\n                 attrs.set(ArgAttribute::NoAlias);\n             }\n \n-            if kind == PointerKind::Frozen && !is_return {\n+            if matches!(kind, PointerKind::SharedRef { frozen: true }) && !is_return {\n                 attrs.set(ArgAttribute::ReadOnly);\n             }\n         }"}, {"sha": "a6e0f13f69830350d8c55611c635841edc461212", "filename": "compiler/rustc_ty_utils/src/assoc.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -22,14 +22,17 @@ fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n         hir::ItemKind::Impl(ref impl_) => tcx.arena.alloc_from_iter(\n             impl_.items.iter().map(|impl_item_ref| impl_item_ref.id.owner_id.to_def_id()),\n         ),\n-        hir::ItemKind::TraitAlias(..) => &[],\n         _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\"),\n     }\n }\n \n fn associated_items(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItems<'_> {\n-    let items = tcx.associated_item_def_ids(def_id).iter().map(|did| tcx.associated_item(*did));\n-    ty::AssocItems::new(items)\n+    if tcx.is_trait_alias(def_id) {\n+        ty::AssocItems::new(Vec::new())\n+    } else {\n+        let items = tcx.associated_item_def_ids(def_id).iter().map(|did| tcx.associated_item(*did));\n+        ty::AssocItems::new(items)\n+    }\n }\n \n fn impl_item_implementor_ids(tcx: TyCtxt<'_>, impl_id: DefId) -> FxHashMap<DefId, DefId> {"}, {"sha": "2aeb255c1641c61b6329110582aa8bd8ea06808d", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -970,7 +970,7 @@ fn variant_info_for_generator<'tcx>(\n         })\n         .collect();\n \n-    let variant_infos: Vec<_> = generator\n+    let mut variant_infos: Vec<_> = generator\n         .variant_fields\n         .iter_enumerated()\n         .map(|(variant_idx, variant_def)| {\n@@ -1033,6 +1033,15 @@ fn variant_info_for_generator<'tcx>(\n             }\n         })\n         .collect();\n+\n+    // The first three variants are hardcoded to be `UNRESUMED`, `RETURNED` and `POISONED`.\n+    // We will move the `RETURNED` and `POISONED` elements to the end so we\n+    // are left with a sorting order according to the generators yield points:\n+    // First `Unresumed`, then the `SuspendN` followed by `Returned` and `Panicked` (POISONED).\n+    let end_states = variant_infos.drain(1..=2);\n+    let end_states: Vec<_> = end_states.collect();\n+    variant_infos.extend(end_states);\n+\n     (\n         variant_infos,\n         match tag_encoding {"}, {"sha": "df4478bb0cb85ac75cfb31fbc78349d30fcfa96b", "filename": "config.toml.example", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -662,7 +662,8 @@ changelog-seen = 2\n \n # Select LTO mode that will be used for compiling rustc. By default, thin local LTO\n # (LTO within a single crate) is used (like for any Rust crate). You can also select\n-# \"thin\" or \"fat\" to apply Thin/Fat LTO to the `rustc_driver` dylib.\n+# \"thin\" or \"fat\" to apply Thin/Fat LTO to the `rustc_driver` dylib, or \"off\" to disable\n+# LTO entirely.\n #lto = \"thin-local\"\n \n # ============================================================================="}, {"sha": "5d4df1ac8bd5883b5539539f7f11db2316d84a50", "filename": "library/core/benches/char/methods.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fcore%2Fbenches%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fcore%2Fbenches%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Fchar%2Fmethods.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1,26 +1,26 @@\n-use test::Bencher;\n+use test::{black_box, Bencher};\n \n const CHARS: [char; 9] = ['0', 'x', '2', '5', 'A', 'f', '7', '8', '9'];\n const RADIX: [u32; 5] = [2, 8, 10, 16, 32];\n \n #[bench]\n fn bench_to_digit_radix_2(b: &mut Bencher) {\n-    b.iter(|| CHARS.iter().cycle().take(10_000).map(|c| c.to_digit(2)).min())\n+    b.iter(|| CHARS.iter().cycle().take(10_000).map(|c| black_box(c).to_digit(2)).min())\n }\n \n #[bench]\n fn bench_to_digit_radix_10(b: &mut Bencher) {\n-    b.iter(|| CHARS.iter().cycle().take(10_000).map(|c| c.to_digit(10)).min())\n+    b.iter(|| CHARS.iter().cycle().take(10_000).map(|c| black_box(c).to_digit(10)).min())\n }\n \n #[bench]\n fn bench_to_digit_radix_16(b: &mut Bencher) {\n-    b.iter(|| CHARS.iter().cycle().take(10_000).map(|c| c.to_digit(16)).min())\n+    b.iter(|| CHARS.iter().cycle().take(10_000).map(|c| black_box(c).to_digit(16)).min())\n }\n \n #[bench]\n fn bench_to_digit_radix_36(b: &mut Bencher) {\n-    b.iter(|| CHARS.iter().cycle().take(10_000).map(|c| c.to_digit(36)).min())\n+    b.iter(|| CHARS.iter().cycle().take(10_000).map(|c| black_box(c).to_digit(36)).min())\n }\n \n #[bench]\n@@ -31,47 +31,59 @@ fn bench_to_digit_radix_var(b: &mut Bencher) {\n             .cycle()\n             .zip(RADIX.iter().cycle())\n             .take(10_000)\n-            .map(|(c, radix)| c.to_digit(*radix))\n+            .map(|(c, radix)| black_box(c).to_digit(*radix))\n             .min()\n     })\n }\n \n #[bench]\n fn bench_to_ascii_uppercase(b: &mut Bencher) {\n-    b.iter(|| CHARS.iter().cycle().take(10_000).map(|c| c.to_ascii_uppercase()).min())\n+    b.iter(|| CHARS.iter().cycle().take(10_000).map(|c| black_box(c).to_ascii_uppercase()).min())\n }\n \n #[bench]\n fn bench_to_ascii_lowercase(b: &mut Bencher) {\n-    b.iter(|| CHARS.iter().cycle().take(10_000).map(|c| c.to_ascii_lowercase()).min())\n+    b.iter(|| CHARS.iter().cycle().take(10_000).map(|c| black_box(c).to_ascii_lowercase()).min())\n }\n \n #[bench]\n fn bench_ascii_mix_to_uppercase(b: &mut Bencher) {\n-    b.iter(|| (0..=255).cycle().take(10_000).map(|b| char::from(b).to_uppercase()).count())\n+    b.iter(|| {\n+        (0..=255).cycle().take(10_000).map(|b| black_box(char::from(b)).to_uppercase()).count()\n+    })\n }\n \n #[bench]\n fn bench_ascii_mix_to_lowercase(b: &mut Bencher) {\n-    b.iter(|| (0..=255).cycle().take(10_000).map(|b| char::from(b).to_lowercase()).count())\n+    b.iter(|| {\n+        (0..=255).cycle().take(10_000).map(|b| black_box(char::from(b)).to_lowercase()).count()\n+    })\n }\n \n #[bench]\n fn bench_ascii_char_to_uppercase(b: &mut Bencher) {\n-    b.iter(|| (0..=127).cycle().take(10_000).map(|b| char::from(b).to_uppercase()).count())\n+    b.iter(|| {\n+        (0..=127).cycle().take(10_000).map(|b| black_box(char::from(b)).to_uppercase()).count()\n+    })\n }\n \n #[bench]\n fn bench_ascii_char_to_lowercase(b: &mut Bencher) {\n-    b.iter(|| (0..=127).cycle().take(10_000).map(|b| char::from(b).to_lowercase()).count())\n+    b.iter(|| {\n+        (0..=127).cycle().take(10_000).map(|b| black_box(char::from(b)).to_lowercase()).count()\n+    })\n }\n \n #[bench]\n fn bench_non_ascii_char_to_uppercase(b: &mut Bencher) {\n-    b.iter(|| (128..=255).cycle().take(10_000).map(|b| char::from(b).to_uppercase()).count())\n+    b.iter(|| {\n+        (128..=255).cycle().take(10_000).map(|b| black_box(char::from(b)).to_uppercase()).count()\n+    })\n }\n \n #[bench]\n fn bench_non_ascii_char_to_lowercase(b: &mut Bencher) {\n-    b.iter(|| (128..=255).cycle().take(10_000).map(|b| char::from(b).to_lowercase()).count())\n+    b.iter(|| {\n+        (128..=255).cycle().take(10_000).map(|b| black_box(char::from(b)).to_lowercase()).count()\n+    })\n }"}, {"sha": "377c99effd03c7b0f58435f4013aa88ce46470af", "filename": "library/core/benches/num/flt2dec/strategy/dragon.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1,14 +1,14 @@\n use super::super::*;\n use core::num::flt2dec::strategy::dragon::*;\n use std::mem::MaybeUninit;\n-use test::Bencher;\n+use test::{black_box, Bencher};\n \n #[bench]\n fn bench_small_shortest(b: &mut Bencher) {\n     let decoded = decode_finite(3.141592f64);\n     let mut buf = [MaybeUninit::new(0); MAX_SIG_DIGITS];\n     b.iter(|| {\n-        format_shortest(&decoded, &mut buf);\n+        format_shortest(black_box(&decoded), &mut buf);\n     });\n }\n \n@@ -17,7 +17,7 @@ fn bench_big_shortest(b: &mut Bencher) {\n     let decoded = decode_finite(f64::MAX);\n     let mut buf = [MaybeUninit::new(0); MAX_SIG_DIGITS];\n     b.iter(|| {\n-        format_shortest(&decoded, &mut buf);\n+        format_shortest(black_box(&decoded), &mut buf);\n     });\n }\n \n@@ -26,7 +26,7 @@ fn bench_small_exact_3(b: &mut Bencher) {\n     let decoded = decode_finite(3.141592f64);\n     let mut buf = [MaybeUninit::new(0); 3];\n     b.iter(|| {\n-        format_exact(&decoded, &mut buf, i16::MIN);\n+        format_exact(black_box(&decoded), &mut buf, i16::MIN);\n     });\n }\n \n@@ -35,7 +35,7 @@ fn bench_big_exact_3(b: &mut Bencher) {\n     let decoded = decode_finite(f64::MAX);\n     let mut buf = [MaybeUninit::new(0); 3];\n     b.iter(|| {\n-        format_exact(&decoded, &mut buf, i16::MIN);\n+        format_exact(black_box(&decoded), &mut buf, i16::MIN);\n     });\n }\n \n@@ -44,7 +44,7 @@ fn bench_small_exact_12(b: &mut Bencher) {\n     let decoded = decode_finite(3.141592f64);\n     let mut buf = [MaybeUninit::new(0); 12];\n     b.iter(|| {\n-        format_exact(&decoded, &mut buf, i16::MIN);\n+        format_exact(black_box(&decoded), &mut buf, i16::MIN);\n     });\n }\n \n@@ -53,7 +53,7 @@ fn bench_big_exact_12(b: &mut Bencher) {\n     let decoded = decode_finite(f64::MAX);\n     let mut buf = [MaybeUninit::new(0); 12];\n     b.iter(|| {\n-        format_exact(&decoded, &mut buf, i16::MIN);\n+        format_exact(black_box(&decoded), &mut buf, i16::MIN);\n     });\n }\n \n@@ -62,7 +62,7 @@ fn bench_small_exact_inf(b: &mut Bencher) {\n     let decoded = decode_finite(3.141592f64);\n     let mut buf = [MaybeUninit::new(0); 1024];\n     b.iter(|| {\n-        format_exact(&decoded, &mut buf, i16::MIN);\n+        format_exact(black_box(&decoded), &mut buf, i16::MIN);\n     });\n }\n \n@@ -71,6 +71,6 @@ fn bench_big_exact_inf(b: &mut Bencher) {\n     let decoded = decode_finite(f64::MAX);\n     let mut buf = [MaybeUninit::new(0); 1024];\n     b.iter(|| {\n-        format_exact(&decoded, &mut buf, i16::MIN);\n+        format_exact(black_box(&decoded), &mut buf, i16::MIN);\n     });\n }"}, {"sha": "6bea5e55d37bbc1bafad53c1ac0c98a4eafe5d15", "filename": "library/core/benches/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1,7 +1,7 @@\n use super::super::*;\n use core::num::flt2dec::strategy::grisu::*;\n use std::mem::MaybeUninit;\n-use test::Bencher;\n+use test::{black_box, Bencher};\n \n pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n     match decode(v).1 {\n@@ -15,7 +15,7 @@ fn bench_small_shortest(b: &mut Bencher) {\n     let decoded = decode_finite(3.141592f64);\n     let mut buf = [MaybeUninit::new(0); MAX_SIG_DIGITS];\n     b.iter(|| {\n-        format_shortest(&decoded, &mut buf);\n+        format_shortest(black_box(&decoded), &mut buf);\n     });\n }\n \n@@ -24,7 +24,7 @@ fn bench_big_shortest(b: &mut Bencher) {\n     let decoded = decode_finite(f64::MAX);\n     let mut buf = [MaybeUninit::new(0); MAX_SIG_DIGITS];\n     b.iter(|| {\n-        format_shortest(&decoded, &mut buf);\n+        format_shortest(black_box(&decoded), &mut buf);\n     });\n }\n \n@@ -33,7 +33,7 @@ fn bench_small_exact_3(b: &mut Bencher) {\n     let decoded = decode_finite(3.141592f64);\n     let mut buf = [MaybeUninit::new(0); 3];\n     b.iter(|| {\n-        format_exact(&decoded, &mut buf, i16::MIN);\n+        format_exact(black_box(&decoded), &mut buf, i16::MIN);\n     });\n }\n \n@@ -42,7 +42,7 @@ fn bench_big_exact_3(b: &mut Bencher) {\n     let decoded = decode_finite(f64::MAX);\n     let mut buf = [MaybeUninit::new(0); 3];\n     b.iter(|| {\n-        format_exact(&decoded, &mut buf, i16::MIN);\n+        format_exact(black_box(&decoded), &mut buf, i16::MIN);\n     });\n }\n \n@@ -51,7 +51,7 @@ fn bench_small_exact_12(b: &mut Bencher) {\n     let decoded = decode_finite(3.141592f64);\n     let mut buf = [MaybeUninit::new(0); 12];\n     b.iter(|| {\n-        format_exact(&decoded, &mut buf, i16::MIN);\n+        format_exact(black_box(&decoded), &mut buf, i16::MIN);\n     });\n }\n \n@@ -60,7 +60,7 @@ fn bench_big_exact_12(b: &mut Bencher) {\n     let decoded = decode_finite(f64::MAX);\n     let mut buf = [MaybeUninit::new(0); 12];\n     b.iter(|| {\n-        format_exact(&decoded, &mut buf, i16::MIN);\n+        format_exact(black_box(&decoded), &mut buf, i16::MIN);\n     });\n }\n \n@@ -69,7 +69,7 @@ fn bench_small_exact_inf(b: &mut Bencher) {\n     let decoded = decode_finite(3.141592f64);\n     let mut buf = [MaybeUninit::new(0); 1024];\n     b.iter(|| {\n-        format_exact(&decoded, &mut buf, i16::MIN);\n+        format_exact(black_box(&decoded), &mut buf, i16::MIN);\n     });\n }\n \n@@ -78,6 +78,6 @@ fn bench_big_exact_inf(b: &mut Bencher) {\n     let decoded = decode_finite(f64::MAX);\n     let mut buf = [MaybeUninit::new(0); 1024];\n     b.iter(|| {\n-        format_exact(&decoded, &mut buf, i16::MIN);\n+        format_exact(black_box(&decoded), &mut buf, i16::MIN);\n     });\n }"}, {"sha": "f290e5baf9dd3c21ccdd9c4f979daea388d8e459", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -22,7 +22,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::const_closure::ConstFnMutClosure;\n use crate::marker::Destruct;\n \n use self::Ordering::*;\n@@ -1291,17 +1290,7 @@ where\n     F: ~const Destruct,\n     K: ~const Destruct,\n {\n-    const fn imp<T, F: ~const FnMut(&T) -> K, K: ~const Ord>(\n-        f: &mut F,\n-        (v1, v2): (&T, &T),\n-    ) -> Ordering\n-    where\n-        T: ~const Destruct,\n-        K: ~const Destruct,\n-    {\n-        f(v1).cmp(&f(v2))\n-    }\n-    max_by(v1, v2, ConstFnMutClosure::new(&mut f, imp))\n+    max_by(v1, v2, const |v1, v2| f(v1).cmp(&f(v2)))\n }\n \n // Implementation of PartialEq, Eq, PartialOrd and Ord for primitive types"}, {"sha": "97900a4862f5653fc49c537fdc95c3690d71d9a0", "filename": "library/core/src/const_closure.rs", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/6c8d4073a4490671b05f3b5f5e6810cfdc23a641/library%2Fcore%2Fsrc%2Fconst_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8d4073a4490671b05f3b5f5e6810cfdc23a641/library%2Fcore%2Fsrc%2Fconst_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconst_closure.rs?ref=6c8d4073a4490671b05f3b5f5e6810cfdc23a641", "patch": "@@ -1,78 +0,0 @@\n-use crate::marker::Destruct;\n-use crate::marker::Tuple;\n-\n-/// Struct representing a closure with mutably borrowed data.\n-///\n-/// Example:\n-/// ```no_build\n-/// #![feature(const_mut_refs)]\n-/// use crate::const_closure::ConstFnMutClosure;\n-/// const fn imp(state: &mut i32, (arg,): (i32,)) -> i32 {\n-///   *state += arg;\n-///   *state\n-/// }\n-/// let mut i = 5;\n-/// let mut cl = ConstFnMutClosure::new(&mut i, imp);\n-///\n-/// assert!(7 == cl(2));\n-/// assert!(8 == cl(1));\n-/// ```\n-pub(crate) struct ConstFnMutClosure<CapturedData, Function> {\n-    /// The Data captured by the Closure.\n-    /// Must be either a (mutable) reference or a tuple of (mutable) references.\n-    pub data: CapturedData,\n-    /// The Function of the Closure, must be: Fn(CapturedData, ClosureArgs) -> ClosureReturn\n-    pub func: Function,\n-}\n-impl<'a, CapturedData: ?Sized, Function> ConstFnMutClosure<&'a mut CapturedData, Function> {\n-    /// Function for creating a new closure.\n-    ///\n-    /// `data` is the a mutable borrow of data that is captured from the environment.\n-    /// If you want Data to be a tuple of mutable Borrows, the struct must be constructed manually.\n-    ///\n-    /// `func` is the function of the closure, it gets the data and a tuple of the arguments closure\n-    ///   and return the return value of the closure.\n-    pub(crate) const fn new<ClosureArguments, ClosureReturnValue>(\n-        data: &'a mut CapturedData,\n-        func: Function,\n-    ) -> Self\n-    where\n-        Function: ~const Fn(&mut CapturedData, ClosureArguments) -> ClosureReturnValue,\n-    {\n-        Self { data, func }\n-    }\n-}\n-\n-macro_rules! impl_fn_mut_tuple {\n-    ($($var:ident)*) => {\n-        #[allow(unused_parens)]\n-        impl<'a, $($var,)* ClosureArguments: Tuple, Function, ClosureReturnValue> const\n-            FnOnce<ClosureArguments> for ConstFnMutClosure<($(&'a mut $var),*), Function>\n-        where\n-            Function: ~const Fn(($(&mut $var),*), ClosureArguments) -> ClosureReturnValue+ ~const Destruct,\n-        {\n-            type Output = ClosureReturnValue;\n-\n-            extern \"rust-call\" fn call_once(mut self, args: ClosureArguments) -> Self::Output {\n-            self.call_mut(args)\n-            }\n-        }\n-        #[allow(unused_parens)]\n-        impl<'a, $($var,)* ClosureArguments: Tuple, Function, ClosureReturnValue> const\n-            FnMut<ClosureArguments> for ConstFnMutClosure<($(&'a mut $var),*), Function>\n-        where\n-            Function: ~const Fn(($(&mut $var),*), ClosureArguments)-> ClosureReturnValue,\n-        {\n-            extern \"rust-call\" fn call_mut(&mut self, args: ClosureArguments) -> Self::Output {\n-                #[allow(non_snake_case)]\n-                let ($($var),*) = &mut self.data;\n-                (self.func)(($($var),*), args)\n-            }\n-        }\n-    };\n-}\n-impl_fn_mut_tuple!(A);\n-impl_fn_mut_tuple!(A B);\n-impl_fn_mut_tuple!(A B C);\n-impl_fn_mut_tuple!(A B C D);\n-impl_fn_mut_tuple!(A B C D E);"}, {"sha": "af786609757b1325d85c166a3a382929bba74634", "filename": "library/core/src/iter/adapters/array_chunks.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1,5 +1,4 @@\n use crate::array;\n-use crate::const_closure::ConstFnMutClosure;\n use crate::iter::{ByRefSized, FusedIterator, Iterator, TrustedRandomAccessNoCoerce};\n use crate::mem::{self, MaybeUninit};\n use crate::ops::{ControlFlow, NeverShortCircuit, Try};\n@@ -189,13 +188,12 @@ where\n     I: Iterator,\n {\n     #[inline]\n-    default fn fold<B, F>(mut self, init: B, mut f: F) -> B\n+    default fn fold<B, F>(mut self, init: B, f: F) -> B\n     where\n         Self: Sized,\n         F: FnMut(B, Self::Item) -> B,\n     {\n-        let fold = ConstFnMutClosure::new(&mut f, NeverShortCircuit::wrap_mut_2_imp);\n-        self.try_fold(init, fold).0\n+        self.try_fold(init, NeverShortCircuit::wrap_mut_2(f)).0\n     }\n }\n "}, {"sha": "477e7117c3ea125973252685d8bded87ab93686f", "filename": "library/core/src/iter/adapters/by_ref_sized.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fby_ref_sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fby_ref_sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fby_ref_sized.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1,7 +1,4 @@\n-use crate::{\n-    const_closure::ConstFnMutClosure,\n-    ops::{NeverShortCircuit, Try},\n-};\n+use crate::ops::{NeverShortCircuit, Try};\n \n /// Like `Iterator::by_ref`, but requiring `Sized` so it can forward generics.\n ///\n@@ -39,13 +36,12 @@ impl<I: Iterator> Iterator for ByRefSized<'_, I> {\n     }\n \n     #[inline]\n-    fn fold<B, F>(self, init: B, mut f: F) -> B\n+    fn fold<B, F>(self, init: B, f: F) -> B\n     where\n         F: FnMut(B, Self::Item) -> B,\n     {\n         // `fold` needs ownership, so this can't forward directly.\n-        I::try_fold(self.0, init, ConstFnMutClosure::new(&mut f, NeverShortCircuit::wrap_mut_2_imp))\n-            .0\n+        I::try_fold(self.0, init, NeverShortCircuit::wrap_mut_2(f)).0\n     }\n \n     #[inline]\n@@ -76,17 +72,12 @@ impl<I: DoubleEndedIterator> DoubleEndedIterator for ByRefSized<'_, I> {\n     }\n \n     #[inline]\n-    fn rfold<B, F>(self, init: B, mut f: F) -> B\n+    fn rfold<B, F>(self, init: B, f: F) -> B\n     where\n         F: FnMut(B, Self::Item) -> B,\n     {\n         // `rfold` needs ownership, so this can't forward directly.\n-        I::try_rfold(\n-            self.0,\n-            init,\n-            ConstFnMutClosure::new(&mut f, NeverShortCircuit::wrap_mut_2_imp),\n-        )\n-        .0\n+        I::try_rfold(self.0, init, NeverShortCircuit::wrap_mut_2(f)).0\n     }\n \n     #[inline]"}, {"sha": "00f57fbcc6162abd5e591edc85766a7711153225", "filename": "library/core/src/iter/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -362,15 +362,13 @@ macro_rules! impl_fold_via_try_fold {\n     };\n     (@internal $fold:ident -> $try_fold:ident) => {\n         #[inline]\n-        fn $fold<AAA, FFF>(mut self, init: AAA, mut fold: FFF) -> AAA\n+        fn $fold<AAA, FFF>(mut self, init: AAA, fold: FFF) -> AAA\n         where\n             FFF: FnMut(AAA, Self::Item) -> AAA,\n         {\n-            use crate::const_closure::ConstFnMutClosure;\n             use crate::ops::NeverShortCircuit;\n \n-            let fold = ConstFnMutClosure::new(&mut fold, NeverShortCircuit::wrap_mut_2_imp);\n-            self.$try_fold(init, fold).0\n+            self.$try_fold(init, NeverShortCircuit::wrap_mut_2(fold)).0\n         }\n     };\n }"}, {"sha": "dc0702c467a4ea1d3c69d2ce21504c114a91fc13", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -376,8 +376,6 @@ mod bool;\n mod tuple;\n mod unit;\n \n-mod const_closure;\n-\n #[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n pub mod primitive;\n "}, {"sha": "dcc0835ecd6d2c6b22a777e96eac9ce925eff8d0", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -18,7 +18,7 @@ macro_rules! uint_impl {\n         pub const MIN: Self = 0;\n \n         /// The largest value that can be represented by this integer type\n-        #[doc = concat!(\"(2<sup>\", $BITS, \"</sup> &minus; 1\", $bound_condition, \")\")]\n+        #[doc = concat!(\"(2<sup>\", $BITS, \"</sup> &minus; 1\", $bound_condition, \").\")]\n         ///\n         /// # Examples\n         ///"}, {"sha": "0c7ee9630c6ee560127731249ef633dd2823578f", "filename": "library/core/src/ops/arith.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fcore%2Fsrc%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fcore%2Fsrc%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Farith.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -86,7 +86,8 @@ pub trait Add<Rhs = Self> {\n     /// ```\n     /// assert_eq!(12 + 1, 13);\n     /// ```\n-    #[must_use]\n+    #[must_use = \"this returns the result of the operation, without modifying the original\"]\n+    #[rustc_diagnostic_item = \"add\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn add(self, rhs: Rhs) -> Self::Output;\n }\n@@ -195,7 +196,8 @@ pub trait Sub<Rhs = Self> {\n     /// ```\n     /// assert_eq!(12 - 1, 11);\n     /// ```\n-    #[must_use]\n+    #[must_use = \"this returns the result of the operation, without modifying the original\"]\n+    #[rustc_diagnostic_item = \"sub\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sub(self, rhs: Rhs) -> Self::Output;\n }\n@@ -325,7 +327,8 @@ pub trait Mul<Rhs = Self> {\n     /// ```\n     /// assert_eq!(12 * 2, 24);\n     /// ```\n-    #[must_use]\n+    #[must_use = \"this returns the result of the operation, without modifying the original\"]\n+    #[rustc_diagnostic_item = \"mul\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn mul(self, rhs: Rhs) -> Self::Output;\n }\n@@ -459,7 +462,8 @@ pub trait Div<Rhs = Self> {\n     /// ```\n     /// assert_eq!(12 / 2, 6);\n     /// ```\n-    #[must_use]\n+    #[must_use = \"this returns the result of the operation, without modifying the original\"]\n+    #[rustc_diagnostic_item = \"div\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn div(self, rhs: Rhs) -> Self::Output;\n }\n@@ -562,7 +566,8 @@ pub trait Rem<Rhs = Self> {\n     /// ```\n     /// assert_eq!(12 % 10, 2);\n     /// ```\n-    #[must_use]\n+    #[must_use = \"this returns the result of the operation, without modifying the original\"]\n+    #[rustc_diagnostic_item = \"rem\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rem(self, rhs: Rhs) -> Self::Output;\n }\n@@ -678,7 +683,8 @@ pub trait Neg {\n     /// let x: i32 = 12;\n     /// assert_eq!(-x, -12);\n     /// ```\n-    #[must_use]\n+    #[must_use = \"this returns the result of the operation, without modifying the original\"]\n+    #[rustc_diagnostic_item = \"neg\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn neg(self) -> Self::Output;\n }"}, {"sha": "9108fc63045250d5369d2d63d4fc6581cc18ad9e", "filename": "library/core/src/ops/try_trait.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -379,13 +379,18 @@ pub(crate) type ChangeOutputType<T, V> = <<T as Try>::Residual as Residual<V>>::\n pub(crate) struct NeverShortCircuit<T>(pub T);\n \n impl<T> NeverShortCircuit<T> {\n-    /// Implementation for building `ConstFnMutClosure` for wrapping the output of a ~const FnMut in a `NeverShortCircuit`.\n     #[inline]\n-    pub const fn wrap_mut_2_imp<A, B, F: ~const FnMut(A, B) -> T>(\n-        f: &mut F,\n-        (a, b): (A, B),\n-    ) -> NeverShortCircuit<T> {\n-        NeverShortCircuit(f(a, b))\n+    pub fn wrap_mut_2<A, B>(\n+        mut f: impl ~const FnMut(A, B) -> T,\n+    ) -> impl ~const FnMut(A, B) -> Self {\n+        cfg_if! {\n+            if #[cfg(bootstrap)] {\n+                #[allow(unused_parens)]\n+                (const move |a, b| NeverShortCircuit(f(a, b)))\n+            } else {\n+                const move |a, b| NeverShortCircuit(f(a, b))\n+            }\n+        }\n     }\n }\n "}, {"sha": "5d5e95590344ad44672d7c57295cb052f2b32d1f", "filename": "library/core/src/option.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -943,7 +943,7 @@ impl<T> Option<T> {\n     // Transforming contained values\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Maps an `Option<T>` to `Option<U>` by applying a function to a contained value.\n+    /// Maps an `Option<T>` to `Option<U>` by applying a function to a contained value (if `Some`) or returns `None` (if `None`).\n     ///\n     /// # Examples\n     ///\n@@ -955,8 +955,10 @@ impl<T> Option<T> {\n     /// let maybe_some_string = Some(String::from(\"Hello, World!\"));\n     /// // `Option::map` takes self *by value*, consuming `maybe_some_string`\n     /// let maybe_some_len = maybe_some_string.map(|s| s.len());\n-    ///\n     /// assert_eq!(maybe_some_len, Some(13));\n+    ///\n+    /// let x: Option<&str> = None;\n+    /// assert_eq!(x.map(|s| s.len()), None);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "742c4cc7c5539d9a4b5175e70d7b3371f3917b64", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -238,7 +238,7 @@ impl<K, V> HashMap<K, V, RandomState> {\n     ///\n     /// The hash map will be able to hold at least `capacity` elements without\n     /// reallocating. This method is allowed to allocate for more elements than\n-    /// `capacity`. If `capacity` is 0, the hash set will not allocate.\n+    /// `capacity`. If `capacity` is 0, the hash map will not allocate.\n     ///\n     /// # Examples\n     ///"}, {"sha": "6b1f0cba82dfc877cddfba31465fcb28af5798ad", "filename": "library/std/src/f32.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fstd%2Fsrc%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fstd%2Fsrc%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -69,8 +69,8 @@ impl f32 {\n         unsafe { intrinsics::ceilf32(self) }\n     }\n \n-    /// Returns the nearest integer to `self`. Round half-way cases away from\n-    /// `0.0`.\n+    /// Returns the nearest integer to `self`. If a value is half-way between two\n+    /// integers, round away from `0.0`.\n     ///\n     /// # Examples\n     ///"}, {"sha": "16359766b510d865e6c8846fe5a6c966fa488429", "filename": "library/std/src/f64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fstd%2Fsrc%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fstd%2Fsrc%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff64.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -69,8 +69,8 @@ impl f64 {\n         unsafe { intrinsics::ceilf64(self) }\n     }\n \n-    /// Returns the nearest integer to `self`. Round half-way cases away from\n-    /// `0.0`.\n+    /// Returns the nearest integer to `self`. If a value is half-way between two\n+    /// integers, round away from `0.0`.\n     ///\n     /// # Examples\n     ///"}, {"sha": "324d698eaeb1d129a772f7bb31db616aee342b62", "filename": "library/std/src/io/error.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -88,12 +88,23 @@ impl From<alloc::ffi::NulError> for Error {\n // doesn't accidentally get printed.\n #[cfg_attr(test, derive(Debug))]\n enum ErrorData<C> {\n-    Os(i32),\n+    Os(RawOsError),\n     Simple(ErrorKind),\n     SimpleMessage(&'static SimpleMessage),\n     Custom(C),\n }\n \n+/// The type of raw OS error codes returned by [`Error::raw_os_error`].\n+///\n+/// This is an [`i32`] on all currently supported platforms, but platforms\n+/// added in the future (such as UEFI) may use a different primitive type like\n+/// [`usize`]. Use `as`or [`into`] conversions where applicable to ensure maximum\n+/// portability.\n+///\n+/// [`into`]: Into::into\n+#[unstable(feature = \"raw_os_error_ty\", issue = \"none\")]\n+pub type RawOsError = i32;\n+\n // `#[repr(align(4))]` is probably redundant, it should have that value or\n // higher already. We include it just because repr_bitpacked.rs's encoding\n // requires an alignment >= 4 (note that `#[repr(align)]` will not reduce the\n@@ -579,7 +590,7 @@ impl Error {\n     #[must_use]\n     #[inline]\n     pub fn last_os_error() -> Error {\n-        Error::from_raw_os_error(sys::os::errno() as i32)\n+        Error::from_raw_os_error(sys::os::errno())\n     }\n \n     /// Creates a new instance of an [`Error`] from a particular OS error code.\n@@ -610,7 +621,7 @@ impl Error {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use]\n     #[inline]\n-    pub fn from_raw_os_error(code: i32) -> Error {\n+    pub fn from_raw_os_error(code: RawOsError) -> Error {\n         Error { repr: Repr::new_os(code) }\n     }\n \n@@ -646,7 +657,7 @@ impl Error {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use]\n     #[inline]\n-    pub fn raw_os_error(&self) -> Option<i32> {\n+    pub fn raw_os_error(&self) -> Option<RawOsError> {\n         match self.repr.data() {\n             ErrorData::Os(i) => Some(i),\n             ErrorData::Custom(..) => None,"}, {"sha": "f94f88bac417ef1d1c9086263bda11a6ba5ce382", "filename": "library/std/src/io/error/repr_bitpacked.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_bitpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_bitpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_bitpacked.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -102,7 +102,7 @@\n //! to use a pointer type to store something that may hold an integer, some of\n //! the time.\n \n-use super::{Custom, ErrorData, ErrorKind, SimpleMessage};\n+use super::{Custom, ErrorData, ErrorKind, RawOsError, SimpleMessage};\n use alloc::boxed::Box;\n use core::marker::PhantomData;\n use core::mem::{align_of, size_of};\n@@ -172,7 +172,7 @@ impl Repr {\n     }\n \n     #[inline]\n-    pub(super) fn new_os(code: i32) -> Self {\n+    pub(super) fn new_os(code: RawOsError) -> Self {\n         let utagged = ((code as usize) << 32) | TAG_OS;\n         // Safety: `TAG_OS` is not zero, so the result of the `|` is not 0.\n         let res = Self(unsafe { NonNull::new_unchecked(ptr::invalid_mut(utagged)) }, PhantomData);\n@@ -250,7 +250,7 @@ where\n     let bits = ptr.as_ptr().addr();\n     match bits & TAG_MASK {\n         TAG_OS => {\n-            let code = ((bits as i64) >> 32) as i32;\n+            let code = ((bits as i64) >> 32) as RawOsError;\n             ErrorData::Os(code)\n         }\n         TAG_SIMPLE => {\n@@ -374,6 +374,9 @@ static_assert!((TAG_MASK + 1).is_power_of_two());\n static_assert!(align_of::<SimpleMessage>() >= TAG_MASK + 1);\n static_assert!(align_of::<Custom>() >= TAG_MASK + 1);\n \n+// `RawOsError` must be an alias for `i32`.\n+const _: fn(RawOsError) -> i32 = |os| os;\n+\n static_assert!(@usize_eq: TAG_MASK & TAG_SIMPLE_MESSAGE, TAG_SIMPLE_MESSAGE);\n static_assert!(@usize_eq: TAG_MASK & TAG_CUSTOM, TAG_CUSTOM);\n static_assert!(@usize_eq: TAG_MASK & TAG_OS, TAG_OS);"}, {"sha": "093fde33757eb6e8cfe694b7ef36b07004319a38", "filename": "library/std/src/io/error/repr_unpacked.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_unpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_unpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_unpacked.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -2,7 +2,7 @@\n //! non-64bit targets, where the packed 64 bit representation wouldn't work, and\n //! would have no benefit.\n \n-use super::{Custom, ErrorData, ErrorKind, SimpleMessage};\n+use super::{Custom, ErrorData, ErrorKind, RawOsError, SimpleMessage};\n use alloc::boxed::Box;\n \n type Inner = ErrorData<Box<Custom>>;\n@@ -18,7 +18,7 @@ impl Repr {\n         Self(Inner::Custom(b))\n     }\n     #[inline]\n-    pub(super) fn new_os(code: i32) -> Self {\n+    pub(super) fn new_os(code: RawOsError) -> Self {\n         Self(Inner::Os(code))\n     }\n     #[inline]"}, {"sha": "36d52aef03cb7b211f382af9136817c0b2f667b9", "filename": "library/std/src/io/error/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fstd%2Fsrc%2Fio%2Ferror%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fstd%2Fsrc%2Fio%2Ferror%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror%2Ftests.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -71,7 +71,7 @@ fn test_const() {\n \n #[test]\n fn test_os_packing() {\n-    for code in -20i32..20i32 {\n+    for code in -20..20 {\n         let e = Error::from_raw_os_error(code);\n         assert_eq!(e.raw_os_error(), Some(code));\n         assert_matches!("}, {"sha": "5907ba5d5fbf3ab8dd8495cd2619aa25f5b7de09", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -262,6 +262,8 @@ use crate::sys_common::memchr;\n \n #[stable(feature = \"bufwriter_into_parts\", since = \"1.56.0\")]\n pub use self::buffered::WriterPanicked;\n+#[unstable(feature = \"raw_os_error_ty\", issue = \"none\")]\n+pub use self::error::RawOsError;\n pub(crate) use self::stdio::attempt_print_to_stderr;\n #[unstable(feature = \"internal_output_capture\", issue = \"none\")]\n #[doc(no_inline, hidden)]"}, {"sha": "71eee8968e272e66593286e252455c53460c265c", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 38, "deletions": 161, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -4,105 +4,31 @@ This is an in-progress README which is targeted at helping to explain how Rust\n is bootstrapped and in general, some of the technical details of the build\n system.\n \n-## Using rustbuild\n+Note that this README only covers internal information, not how to use the tool.\n+Please check [bootstrapping dev guide][bootstrapping-dev-guide] for further information.\n \n-The rustbuild build system has a primary entry point, a top level `x.py` script:\n+[bootstrapping-dev-guide]: https://rustc-dev-guide.rust-lang.org/building/bootstrapping.html\n \n-```sh\n-$ python ./x.py build\n-```\n-\n-Note that if you're on Unix, you should be able to execute the script directly:\n-\n-```sh\n-$ ./x.py build\n-```\n-\n-The script accepts commands, flags, and arguments to determine what to do:\n-\n-* `build` - a general purpose command for compiling code. Alone, `build` will\n-  bootstrap the entire compiler, and otherwise, arguments passed indicate what to\n-  build. For example:\n-\n-  ```\n-  # build the whole compiler\n-  ./x.py build --stage 2\n-\n-  # build the stage1 compiler\n-  ./x.py build\n-\n-  # build stage0 libstd\n-  ./x.py build --stage 0 library/std\n-\n-  # build a particular crate in stage0\n-  ./x.py build --stage 0 library/test\n-  ```\n-\n-  If files that would normally be rebuilt from stage 0 are dirty, the rebuild can be\n-  overridden using `--keep-stage 0`. Using `--keep-stage n` will skip all steps\n-  that belong to stage n or earlier:\n-\n-  ```\n-  # build stage 1, keeping old build products for stage 0\n-  ./x.py build --keep-stage 0\n-  ```\n-\n-* `test` - a command for executing unit tests. Like the `build` command, this\n-  will execute the entire test suite by default, and otherwise, it can be used to\n-  select which test suite is run:\n-\n-  ```\n-  # run all unit tests\n-  ./x.py test\n-\n-  # execute tool tests\n-  ./x.py test tidy\n-\n-  # execute the UI test suite\n-  ./x.py test tests/ui\n-\n-  # execute only some tests in the UI test suite\n-  ./x.py test tests/ui --test-args substring-of-test-name\n-\n-  # execute tests in the standard library in stage0\n-  ./x.py test --stage 0 library/std\n-\n-  # execute tests in the core and standard library in stage0,\n-  # without running doc tests (thus avoid depending on building the compiler)\n-  ./x.py test --stage 0 --no-doc library/core library/std\n+## Introduction\n \n-  # execute all doc tests\n-  ./x.py test src/doc\n-  ```\n+The build system defers most of the complicated logic managing invocations\n+of rustc and rustdoc to Cargo itself. However, moving through various stages\n+and copying artifacts is still necessary for it to do. Each time rustbuild\n+is invoked, it will iterate through the list of predefined steps and execute\n+each serially in turn if it matches the paths passed or is a default rule.\n+For each step rustbuild relies on the step internally being incremental and\n+parallel. Note, though, that the `-j` parameter to rustbuild gets forwarded\n+to appropriate test harnesses and such.\n \n-* `doc` - a command for building documentation. Like above, can take arguments\n-  for what to document.\n-\n-## Configuring rustbuild\n-\n-rustbuild offers a TOML-based configuration system with a `config.toml`\n-file. An example of this configuration can be found at `config.toml.example`,\n-and the configuration file can also be passed as `--config path/to/config.toml`\n-if the build system is being invoked manually (via the python script).\n-\n-You can generate a config.toml using `./configure` options if you want to automate creating the file without having to edit it.\n-\n-Finally, rustbuild makes use of the [cc-rs crate] which has [its own\n-method][env-vars] of configuring C compilers and C flags via environment\n-variables.\n-\n-[cc-rs crate]: https://github.com/alexcrichton/cc-rs\n-[env-vars]: https://github.com/alexcrichton/cc-rs#external-configuration-via-environment-variables\n-\n-## Build stages\n+## Build phases\n \n The rustbuild build system goes through a few phases to actually build the\n compiler. What actually happens when you invoke rustbuild is:\n \n-1. The entry point script, `x.py` is run. This script is\n-   responsible for downloading the stage0 compiler/Cargo binaries, and it then\n-   compiles the build system itself (this folder). Finally, it then invokes the\n-   actual `bootstrap` binary build system.\n+1. The entry point script(`x` for unix like systems, `x.ps1` for windows systems,\n+   `x.py` cross-platform) is run. This script is responsible for downloading the stage0\n+   compiler/Cargo binaries, and it then compiles the build system itself (this folder).\n+   Finally, it then invokes the actual `bootstrap` binary build system.\n 2. In Rust, `bootstrap` will slurp up all configuration, perform a number of\n    sanity checks (whether compilers exist, for example), and then start building the\n    stage0 artifacts.\n@@ -115,24 +41,6 @@ compiler. What actually happens when you invoke rustbuild is:\n The goal of each stage is to (a) leverage Cargo as much as possible and failing\n that (b) leverage Rust as much as possible!\n \n-## Incremental builds\n-\n-You can configure rustbuild to use incremental compilation with the\n-`--incremental` flag:\n-\n-```sh\n-$ ./x.py build --incremental\n-```\n-\n-The `--incremental` flag will store incremental compilation artifacts\n-in `build/<host>/stage0-incremental`. Note that we only use incremental\n-compilation for the stage0 -> stage1 compilation -- this is because\n-the stage1 compiler is changing, and we don't try to cache and reuse\n-incremental artifacts across different versions of the compiler.\n-\n-You can always drop the `--incremental` to build as normal (but you\n-will still be using the local nightly as your bootstrap).\n-\n ## Directory Layout\n \n This build system houses all output under the `build` directory, which looks\n@@ -236,63 +144,31 @@ build/\n     # system will link (using hard links) output from stageN-{std,rustc} into\n     # each of these directories.\n     #\n-    # In theory, there is no extra build output in these directories.\n+    # In theory these are working rustc sysroot directories, meaning there is\n+    # no extra build output in these directories.\n     stage1/\n     stage2/\n     stage3/\n ```\n \n-## Cargo projects\n-\n-The current build is unfortunately not quite as simple as `cargo build` in a\n-directory, but rather the compiler is split into three different Cargo projects:\n-\n-* `library/std` - the standard library\n-* `library/test` - testing support, depends on libstd\n-* `compiler/rustc` - the actual compiler itself\n-\n-Each \"project\" has a corresponding Cargo.lock file with all dependencies, and\n-this means that building the compiler involves running Cargo three times. The\n-structure here serves two goals:\n-\n-1. Facilitating dependencies coming from crates.io. These dependencies don't\n-   depend on `std`, so libstd is a separate project compiled ahead of time\n-   before the actual compiler builds.\n-2. Splitting \"host artifacts\" from \"target artifacts\". That is, when building\n-   code for an arbitrary target, you don't need the entire compiler, but you'll\n-   end up needing libraries like libtest that depend on std but also want to use\n-   crates.io dependencies. Hence, libtest is split out as its own project that\n-   is sequenced after `std` but before `rustc`. This project is built for all\n-   targets.\n-\n-There is some loss in build parallelism here because libtest can be compiled in\n-parallel with a number of rustc artifacts, but in theory, the loss isn't too bad!\n-\n-## Build tools\n-\n-We've actually got quite a few tools that we use in the compiler's build system\n-and for testing. To organize these, each tool is a project in `src/tools` with a\n-corresponding `Cargo.toml`. All tools are compiled with Cargo (currently having\n-independent `Cargo.lock` files) and do not currently explicitly depend on the\n-compiler or standard library. Compiling each tool is sequenced after the\n-appropriate libstd/libtest/librustc compile above.\n-\n ## Extending rustbuild\n \n-So, you'd like to add a feature to the rustbuild build system or just fix a bug.\n-Great! One of the major motivational factors for moving away from `make` is that\n-Rust is in theory much easier to read, modify, and write. If you find anything\n-excessively confusing, please open an issue on this, and we'll try to get it\n-documented or simplified, pronto.\n+When you use the bootstrap system, you'll call it through the entry point script\n+(`x`, `x.ps1`, or `x.py`). However, most of the code lives in `src/bootstrap`.\n+`bootstrap` has a difficult problem: it is written in Rust, but yet it is run\n+before the Rust compiler is built! To work around this, there are two components\n+of bootstrap: the main one written in rust, and `bootstrap.py`. `bootstrap.py`\n+is what gets run by entry point script. It takes care of downloading the `stage0`\n+compiler, which will then build the bootstrap binary written in Rust.\n \n-First up, you'll probably want to read over the documentation above, as that'll\n-give you a high level overview of what rustbuild is doing. You also probably\n-want to play around a bit yourself by just getting it up and running before you\n-dive too much into the actual build system itself.\n+Because there are two separate codebases behind `x.py`, they need to\n+be kept in sync. In particular, both `bootstrap.py` and the bootstrap binary\n+parse `config.toml` and read the same command line arguments. `bootstrap.py`\n+keeps these in sync by setting various environment variables, and the\n+programs sometimes have to add arguments that are explicitly ignored, to be\n+read by the other.\n \n-After that, each module in rustbuild should have enough documentation to keep\n-you up and running. Some general areas that you may be interested in modifying\n-are:\n+Some general areas that you may be interested in modifying are:\n \n * Adding a new build tool? Take a look at `bootstrap/tool.rs` for examples of\n   other tools.\n@@ -320,8 +196,9 @@ A 'major change' includes\n Changes that do not affect contributors to the compiler or users\n building rustc from source don't need an update to `VERSION`.\n \n-If you have any questions, feel free to reach out on the `#t-infra` channel in\n-the [Rust Zulip server][rust-zulip] or ask on internals.rust-lang.org. When\n-you encounter bugs, please file issues on the rust-lang/rust issue tracker.\n+If you have any questions, feel free to reach out on the `#t-infra/bootstrap` channel\n+at [Rust Bootstrap Zulip server][rust-bootstrap-zulip]. When you encounter bugs,\n+please file issues on the [Rust issue tracker][rust-issue-tracker].\n \n-[rust-zulip]: https://rust-lang.zulipchat.com/#narrow/stream/242791-t-infra\n+[rust-bootstrap-zulip]: https://rust-lang.zulipchat.com/#narrow/stream/t-infra.2Fbootstrap\n+[rust-issue-tracker]: https://github.com/rust-lang/rust/issues"}, {"sha": "07c0d2233caeb29f8a74d03a5963e25dafdcc8c0", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -379,6 +379,9 @@ pub fn std_cargo(builder: &Builder<'_>, target: TargetSelection, stage: u32, car\n     if stage >= 1 {\n         cargo.rustflag(\"-Cembed-bitcode=yes\");\n     }\n+    if builder.config.rust_lto == RustcLto::Off {\n+        cargo.rustflag(\"-Clto=off\");\n+    }\n \n     // By default, rustc does not include unwind tables unless they are required\n     // for a particular target. They are not required by RISC-V targets, but\n@@ -722,6 +725,13 @@ impl Step for Rustc {\n                     cargo.rustflag(\"-Cembed-bitcode=yes\");\n                 }\n                 RustcLto::ThinLocal => { /* Do nothing, this is the default */ }\n+                RustcLto::Off => {\n+                    cargo.rustflag(\"-Clto=off\");\n+                }\n+            }\n+        } else {\n+            if builder.config.rust_lto == RustcLto::Off {\n+                cargo.rustflag(\"-Clto=off\");\n             }\n         }\n "}, {"sha": "e5fad538969711ce0516fe242b9cbd5e654d3c34", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -333,8 +333,9 @@ impl SplitDebuginfo {\n }\n \n /// LTO mode used for compiling rustc itself.\n-#[derive(Default, Clone)]\n+#[derive(Default, Clone, PartialEq)]\n pub enum RustcLto {\n+    Off,\n     #[default]\n     ThinLocal,\n     Thin,\n@@ -349,6 +350,7 @@ impl std::str::FromStr for RustcLto {\n             \"thin-local\" => Ok(RustcLto::ThinLocal),\n             \"thin\" => Ok(RustcLto::Thin),\n             \"fat\" => Ok(RustcLto::Fat),\n+            \"off\" => Ok(RustcLto::Off),\n             _ => Err(format!(\"Invalid value for rustc LTO: {}\", s)),\n         }\n     }"}, {"sha": "b98b13119e8ad56b8c44c73ba4c5e26020ebff20", "filename": "src/bootstrap/defaults/config.compiler.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Fbootstrap%2Fdefaults%2Fconfig.compiler.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Fbootstrap%2Fdefaults%2Fconfig.compiler.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdefaults%2Fconfig.compiler.toml?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -12,6 +12,8 @@ debug-logging = true\n incremental = true\n # Print backtrace on internal compiler errors during bootstrap\n backtrace-on-ice = true\n+# Make the compiler and standard library faster to build, at the expense of a ~20% runtime slowdown.\n+lto = \"off\"\n \n [llvm]\n # Will download LLVM from CI if available on your platform."}, {"sha": "f362c4111f107f99c8d6ee14b2dd559d4e11a6a0", "filename": "src/bootstrap/defaults/config.library.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Fbootstrap%2Fdefaults%2Fconfig.library.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Fbootstrap%2Fdefaults%2Fconfig.library.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdefaults%2Fconfig.library.toml?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -8,6 +8,8 @@ bench-stage = 0\n [rust]\n # This greatly increases the speed of rebuilds, especially when there are only minor changes. However, it makes the initial build slightly slower.\n incremental = true\n+# Make the compiler and standard library faster to build, at the expense of a ~20% runtime slowdown.\n+lto = \"off\"\n \n [llvm]\n # Will download LLVM from CI if available on your platform."}, {"sha": "f4abdf1cc57589e51c8c8aec36e07e48dfdecac9", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -11,93 +11,6 @@\n //!   crates.io and Cargo.\n //! * A standard interface to build across all platforms, including MSVC\n //!\n-//! ## Architecture\n-//!\n-//! The build system defers most of the complicated logic managing invocations\n-//! of rustc and rustdoc to Cargo itself. However, moving through various stages\n-//! and copying artifacts is still necessary for it to do. Each time rustbuild\n-//! is invoked, it will iterate through the list of predefined steps and execute\n-//! each serially in turn if it matches the paths passed or is a default rule.\n-//! For each step rustbuild relies on the step internally being incremental and\n-//! parallel. Note, though, that the `-j` parameter to rustbuild gets forwarded\n-//! to appropriate test harnesses and such.\n-//!\n-//! Most of the \"meaty\" steps that matter are backed by Cargo, which does indeed\n-//! have its own parallelism and incremental management. Later steps, like\n-//! tests, aren't incremental and simply run the entire suite currently.\n-//! However, compiletest itself tries to avoid running tests when the artifacts\n-//! that are involved (mainly the compiler) haven't changed.\n-//!\n-//! When you execute `x.py build`, the steps executed are:\n-//!\n-//! * First, the python script is run. This will automatically download the\n-//!   stage0 rustc and cargo according to `src/stage0.json`, or use the cached\n-//!   versions if they're available. These are then used to compile rustbuild\n-//!   itself (using Cargo). Finally, control is then transferred to rustbuild.\n-//!\n-//! * Rustbuild takes over, performs sanity checks, probes the environment,\n-//!   reads configuration, and starts executing steps as it reads the command\n-//!   line arguments (paths) or going through the default rules.\n-//!\n-//!   The build output will be something like the following:\n-//!\n-//!   Building stage0 std artifacts\n-//!   Copying stage0 std\n-//!   Building stage0 test artifacts\n-//!   Copying stage0 test\n-//!   Building stage0 compiler artifacts\n-//!   Copying stage0 rustc\n-//!   Assembling stage1 compiler\n-//!   Building stage1 std artifacts\n-//!   Copying stage1 std\n-//!   Building stage1 test artifacts\n-//!   Copying stage1 test\n-//!   Building stage1 compiler artifacts\n-//!   Copying stage1 rustc\n-//!   Assembling stage2 compiler\n-//!   Uplifting stage1 std\n-//!   Uplifting stage1 test\n-//!   Uplifting stage1 rustc\n-//!\n-//! Let's disect that a little:\n-//!\n-//! ## Building stage0 {std,test,compiler} artifacts\n-//!\n-//! These steps use the provided (downloaded, usually) compiler to compile the\n-//! local Rust source into libraries we can use.\n-//!\n-//! ## Copying stage0 {std,test,rustc}\n-//!\n-//! This copies the build output from Cargo into\n-//! `build/$HOST/stage0-sysroot/lib/rustlib/$ARCH/lib`. FIXME: this step's\n-//! documentation should be expanded -- the information already here may be\n-//! incorrect.\n-//!\n-//! ## Assembling stage1 compiler\n-//!\n-//! This copies the libraries we built in \"building stage0 ... artifacts\" into\n-//! the stage1 compiler's lib directory. These are the host libraries that the\n-//! compiler itself uses to run. These aren't actually used by artifacts the new\n-//! compiler generates. This step also copies the rustc and rustdoc binaries we\n-//! generated into build/$HOST/stage/bin.\n-//!\n-//! The stage1/bin/rustc is a fully functional compiler, but it doesn't yet have\n-//! any libraries to link built binaries or libraries to. The next 3 steps will\n-//! provide those libraries for it; they are mostly equivalent to constructing\n-//! the stage1/bin compiler so we don't go through them individually.\n-//!\n-//! ## Uplifting stage1 {std,test,rustc}\n-//!\n-//! This step copies the libraries from the stage1 compiler sysroot into the\n-//! stage2 compiler. This is done to avoid rebuilding the compiler; libraries\n-//! we'd build in this step should be identical (in function, if not necessarily\n-//! identical on disk) so there's no need to recompile the compiler again. Note\n-//! that if you want to, you can enable the full-bootstrap option to change this\n-//! behavior.\n-//!\n-//! Each step is driven by a separate Cargo project and rustbuild orchestrates\n-//! copying files between steps and otherwise preparing for Cargo to run.\n-//!\n //! ## Further information\n //!\n //! More documentation can be found in each respective module below, and you can"}, {"sha": "a6d84a3c18a5f2802597b6d751cb8e95c95b53ee", "filename": "src/ci/docker/scripts/fuchsia-test-runner.py", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Fci%2Fdocker%2Fscripts%2Ffuchsia-test-runner.py", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Fci%2Fdocker%2Fscripts%2Ffuchsia-test-runner.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Ffuchsia-test-runner.py?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -19,18 +19,18 @@\n import signal\n import subprocess\n import sys\n-from typing import ClassVar, List\n+from typing import ClassVar, List, Optional\n \n \n @dataclass\n class TestEnvironment:\n     rust_dir: str\n     sdk_dir: str\n-    target_arch: str\n-    package_server_pid: int = None\n-    emu_addr: str = None\n-    libstd_name: str = None\n-    libtest_name: str = None\n+    target: str\n+    package_server_pid: Optional[int] = None\n+    emu_addr: Optional[str] = None\n+    libstd_name: Optional[str] = None\n+    libtest_name: Optional[str] = None\n     verbose: bool = False\n \n     @staticmethod\n@@ -40,6 +40,15 @@ def tmp_dir():\n             return os.path.abspath(tmp_dir)\n         return os.path.join(os.path.dirname(__file__), \"tmp~\")\n \n+    @staticmethod\n+    def triple_to_arch(triple):\n+        if \"x86_64\" in triple:\n+            return \"x64\"\n+        elif \"aarch64\" in triple:\n+            return \"arm64\"\n+        else:\n+            raise Exception(f\"Unrecognized target triple {triple}\")\n+\n     @classmethod\n     def env_file_path(cls):\n         return os.path.join(cls.tmp_dir(), \"test_env.json\")\n@@ -49,7 +58,7 @@ def from_args(cls, args):\n         return cls(\n             os.path.abspath(args.rust),\n             os.path.abspath(args.sdk),\n-            args.target_arch,\n+            args.target,\n             verbose=args.verbose,\n         )\n \n@@ -60,21 +69,14 @@ def read_from_file(cls):\n             return cls(\n                 test_env[\"rust_dir\"],\n                 test_env[\"sdk_dir\"],\n-                test_env[\"target_arch\"],\n+                test_env[\"target\"],\n                 libstd_name=test_env[\"libstd_name\"],\n                 libtest_name=test_env[\"libtest_name\"],\n                 emu_addr=test_env[\"emu_addr\"],\n                 package_server_pid=test_env[\"package_server_pid\"],\n                 verbose=test_env[\"verbose\"],\n             )\n \n-    def image_name(self):\n-        if self.target_arch == \"x64\":\n-            return \"qemu-x64\"\n-        if self.target_arch == \"arm64\":\n-            return \"qemu-arm64\"\n-        raise Exception(f\"Unrecognized target architecture {self.target_arch}\")\n-\n     def write_to_file(self):\n         with open(self.env_file_path(), \"w\", encoding=\"utf-8\") as f:\n             f.write(json.dumps(self.__dict__))\n@@ -108,13 +110,6 @@ def output_dir(self):\n     def repo_dir(self):\n         return os.path.join(self.tmp_dir(), self.TEST_REPO_NAME)\n \n-    def rustlib_dir(self):\n-        if self.target_arch == \"x64\":\n-            return \"x86_64-unknown-fuchsia\"\n-        if self.target_arch == \"arm64\":\n-            return \"aarch64-unknown-fuchsia\"\n-        raise Exception(f\"Unrecognized target architecture {self.target_arch}\")\n-\n     def libs_dir(self):\n         return os.path.join(\n             self.rust_dir,\n@@ -125,7 +120,7 @@ def rustlibs_dir(self):\n         return os.path.join(\n             self.libs_dir(),\n             \"rustlib\",\n-            self.rustlib_dir(),\n+            self.target,\n             \"lib\",\n         )\n \n@@ -384,7 +379,7 @@ def start(self):\n                 \"--emulator-log\",\n                 self.emulator_log_path(),\n                 \"--image-name\",\n-                self.image_name(),\n+                \"qemu-\" + self.triple_to_arch(self.target),\n             ],\n             stdout=self.subprocess_output(),\n             stderr=self.subprocess_output(),\n@@ -642,11 +637,11 @@ def log(msg):\n                         package_dir=package_dir,\n                         package_name=package_name,\n                         rust_dir=self.rust_dir,\n-                        rustlib_dir=self.rustlib_dir(),\n+                        rustlib_dir=self.target,\n                         sdk_dir=self.sdk_dir,\n                         libstd_name=self.libstd_name,\n                         libtest_name=self.libtest_name,\n-                        target_arch=self.target_arch,\n+                        target_arch=self.triple_to_arch(self.target),\n                     )\n                 )\n                 for shared_lib in shared_libs:\n@@ -969,8 +964,8 @@ def print_help(args):\n         action=\"store_true\",\n     )\n     start_parser.add_argument(\n-        \"--target-arch\",\n-        help=\"the architecture of the image to test\",\n+        \"--target\",\n+        help=\"the target platform to test\",\n         required=True,\n     )\n     start_parser.set_defaults(func=start)"}, {"sha": "c0a1341ebca5c3b24347e2705368444df8a77d73", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -33,6 +33,7 @@ x--expand-yaml-anchors--remove:\n \n   - &shared-ci-variables\n     CI_JOB_NAME: ${{ matrix.name }}\n+    CARGO_REGISTRIES_CRATES_IO_PROTOCOL: sparse\n \n   - &public-variables\n     SCCACHE_BUCKET: rust-lang-ci-sccache2"}, {"sha": "93dccb54c4e38463f07e9b013229868566199b9f", "filename": "src/ci/run.sh", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -45,6 +45,8 @@ fi\n ci_dir=`cd $(dirname $0) && pwd`\n source \"$ci_dir/shared.sh\"\n \n+export CARGO_REGISTRIES_CRATES_IO_PROTOCOL=sparse\n+\n if ! isCI || isCiBranch auto || isCiBranch beta || isCiBranch try || isCiBranch try-perf; then\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set build.print-step-timings --enable-verbose-tests\"\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set build.metrics\""}, {"sha": "662c9e36694c652d31f932e668054c5ec35c846f", "filename": "src/ci/stage-build.py", "status": "modified", "additions": 123, "deletions": 49, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Fci%2Fstage-build.py", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Fci%2Fstage-build.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fstage-build.py?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -15,10 +15,9 @@\n import time\n import traceback\n import urllib.request\n-from collections import OrderedDict\n from io import StringIO\n from pathlib import Path\n-from typing import Callable, Dict, Iterable, List, Optional, Union\n+from typing import Callable, Dict, Iterable, Iterator, List, Optional, Tuple, Union\n \n PGO_HOST = os.environ[\"PGO_HOST\"]\n \n@@ -204,48 +203,105 @@ def supports_bolt(self) -> bool:\n         return False\n \n \n+def get_timestamp() -> float:\n+    return time.time()\n+\n+\n+Duration = float\n+TimerSection = Union[Duration, \"Timer\"]\n+\n+\n+def iterate_sections(section: TimerSection, name: str, level: int = 0) -> Iterator[Tuple[int, str, Duration]]:\n+    \"\"\"\n+    Hierarchically iterate the sections of a timer, in a depth-first order.\n+    \"\"\"\n+    if isinstance(section, Duration):\n+        yield (level, name, section)\n+    elif isinstance(section, Timer):\n+        yield (level, name, section.total_duration())\n+        for (child_name, child_section) in section.sections:\n+            yield from iterate_sections(child_section, child_name, level=level + 1)\n+    else:\n+        assert False\n+\n+\n class Timer:\n-    def __init__(self):\n-        # We want this dictionary to be ordered by insertion.\n-        # We use `OrderedDict` for compatibility with older Python versions.\n-        self.stages = OrderedDict()\n+    def __init__(self, parent_names: Tuple[str, ...] = ()):\n+        self.sections: List[Tuple[str, TimerSection]] = []\n+        self.section_active = False\n+        self.parent_names = parent_names\n \n     @contextlib.contextmanager\n-    def stage(self, name: str):\n-        assert name not in self.stages\n+    def section(self, name: str) -> \"Timer\":\n+        assert not self.section_active\n+        self.section_active = True\n \n-        start = time.time()\n+        start = get_timestamp()\n         exc = None\n+\n+        child_timer = Timer(parent_names=self.parent_names + (name, ))\n+        full_name = \" > \".join(child_timer.parent_names)\n         try:\n-            LOGGER.info(f\"Stage `{name}` starts\")\n-            yield\n+            LOGGER.info(f\"Section `{full_name}` starts\")\n+            yield child_timer\n         except BaseException as exception:\n             exc = exception\n             raise\n         finally:\n-            end = time.time()\n+            end = get_timestamp()\n             duration = end - start\n-            self.stages[name] = duration\n+\n+            if child_timer.has_children():\n+                self.sections.append((name, child_timer))\n+            else:\n+                self.sections.append((name, duration))\n             if exc is None:\n-                LOGGER.info(f\"Stage `{name}` ended: OK ({duration:.2f}s)\")\n+                LOGGER.info(f\"Section `{full_name}` ended: OK ({duration:.2f}s)\")\n+            else:\n+                LOGGER.info(f\"Section `{full_name}` ended: FAIL ({duration:.2f}s)\")\n+            self.section_active = False\n+\n+    def total_duration(self) -> Duration:\n+        duration = 0\n+        for (_, section) in self.sections:\n+            if isinstance(section, Duration):\n+                duration += section\n             else:\n-                LOGGER.info(f\"Stage `{name}` ended: FAIL ({duration:.2f}s)\")\n+                duration += section.total_duration()\n+        return duration\n+\n+    def has_children(self) -> bool:\n+        return len(self.sections) > 0\n \n     def print_stats(self):\n-        total_duration = sum(self.stages.values())\n+        rows = []\n+        for (child_name, child_section) in self.sections:\n+            for (level, name, duration) in iterate_sections(child_section, child_name, level=0):\n+                label = f\"{' ' * level}{name}:\"\n+                rows.append((label, duration))\n \n-        # 57 is the width of the whole table\n-        divider = \"-\" * 57\n+        # Empty row\n+        rows.append((\"\", \"\"))\n+\n+        total_duration_label = \"Total duration:\"\n+        total_duration = self.total_duration()\n+        rows.append((total_duration_label, humantime(total_duration)))\n+\n+        space_after_label = 2\n+        max_label_length = max(16, max(len(label) for (label, _) in rows)) + space_after_label\n+\n+        table_width = max_label_length + 23\n+        divider = \"-\" * table_width\n \n         with StringIO() as output:\n             print(divider, file=output)\n-            for (name, duration) in self.stages.items():\n-                pct = (duration / total_duration) * 100\n-                name_str = f\"{name}:\"\n-                print(f\"{name_str:<34} {duration:>12.2f}s ({pct:>5.2f}%)\", file=output)\n-\n-            total_duration_label = \"Total duration:\"\n-            print(f\"{total_duration_label:<34} {total_duration:>12.2f}s\", file=output)\n+            for (label, duration) in rows:\n+                if isinstance(duration, Duration):\n+                    pct = (duration / total_duration) * 100\n+                    value = f\"{duration:>12.2f}s ({pct:>5.2f}%)\"\n+                else:\n+                    value = f\"{duration:>{len(total_duration_label) + 7}}\"\n+                print(f\"{label:<{max_label_length}} {value}\", file=output)\n             print(divider, file=output, end=\"\")\n             LOGGER.info(f\"Timer results\\n{output.getvalue()}\")\n \n@@ -265,6 +321,21 @@ def change_cwd(dir: Path):\n         os.chdir(cwd)\n \n \n+def humantime(time_s: float) -> str:\n+    hours = time_s // 3600\n+    time_s = time_s % 3600\n+    minutes = time_s // 60\n+    seconds = time_s % 60\n+\n+    result = \"\"\n+    if hours > 0:\n+        result += f\"{int(hours)}h \"\n+    if minutes > 0:\n+        result += f\"{int(minutes)}m \"\n+    result += f\"{round(seconds)}s\"\n+    return result\n+\n+\n def move_path(src: Path, dst: Path):\n     LOGGER.info(f\"Moving `{src}` to `{dst}`\")\n     shutil.move(src, dst)\n@@ -585,15 +656,16 @@ def execute_build_pipeline(timer: Timer, pipeline: Pipeline, final_build_args: L\n     pipeline.build_rustc_perf()\n \n     # Stage 1: Build rustc + PGO instrumented LLVM\n-    with timer.stage(\"Build rustc (LLVM PGO)\"):\n-        build_rustc(pipeline, args=[\n-            \"--llvm-profile-generate\"\n-        ], env=dict(\n-            LLVM_PROFILE_DIR=str(pipeline.llvm_profile_dir_root() / \"prof-%p\")\n-        ))\n+    with timer.section(\"Stage 1 (LLVM PGO)\") as stage1:\n+        with stage1.section(\"Build rustc and LLVM\"):\n+            build_rustc(pipeline, args=[\n+                \"--llvm-profile-generate\"\n+            ], env=dict(\n+                LLVM_PROFILE_DIR=str(pipeline.llvm_profile_dir_root() / \"prof-%p\")\n+            ))\n \n-    with timer.stage(\"Gather profiles (LLVM PGO)\"):\n-        gather_llvm_profiles(pipeline)\n+        with stage1.section(\"Gather profiles\"):\n+            gather_llvm_profiles(pipeline)\n \n     clear_llvm_files(pipeline)\n     final_build_args += [\n@@ -602,14 +674,15 @@ def execute_build_pipeline(timer: Timer, pipeline: Pipeline, final_build_args: L\n     ]\n \n     # Stage 2: Build PGO instrumented rustc + LLVM\n-    with timer.stage(\"Build rustc (rustc PGO)\"):\n-        build_rustc(pipeline, args=[\n-            \"--rust-profile-generate\",\n-            pipeline.rustc_profile_dir_root()\n-        ])\n+    with timer.section(\"Stage 2 (rustc PGO)\") as stage2:\n+        with stage2.section(\"Build rustc and LLVM\"):\n+            build_rustc(pipeline, args=[\n+                \"--rust-profile-generate\",\n+                pipeline.rustc_profile_dir_root()\n+            ])\n \n-    with timer.stage(\"Gather profiles (rustc PGO)\"):\n-        gather_rustc_profiles(pipeline)\n+        with stage2.section(\"Gather profiles\"):\n+            gather_rustc_profiles(pipeline)\n \n     clear_llvm_files(pipeline)\n     final_build_args += [\n@@ -619,14 +692,15 @@ def execute_build_pipeline(timer: Timer, pipeline: Pipeline, final_build_args: L\n \n     # Stage 3: Build rustc + BOLT instrumented LLVM\n     if pipeline.supports_bolt():\n-        with timer.stage(\"Build rustc (LLVM BOLT)\"):\n-            build_rustc(pipeline, args=[\n-                \"--llvm-profile-use\",\n-                pipeline.llvm_profile_merged_file(),\n-                \"--llvm-bolt-profile-generate\",\n-            ])\n-        with timer.stage(\"Gather profiles (LLVM BOLT)\"):\n-            gather_llvm_bolt_profiles(pipeline)\n+        with timer.section(\"Stage 3 (LLVM BOLT)\") as stage3:\n+            with stage3.section(\"Build rustc and LLVM\"):\n+                build_rustc(pipeline, args=[\n+                    \"--llvm-profile-use\",\n+                    pipeline.llvm_profile_merged_file(),\n+                    \"--llvm-bolt-profile-generate\",\n+                ])\n+            with stage3.section(\"Gather profiles\"):\n+                gather_llvm_bolt_profiles(pipeline)\n \n         clear_llvm_files(pipeline)\n         final_build_args += [\n@@ -635,7 +709,7 @@ def execute_build_pipeline(timer: Timer, pipeline: Pipeline, final_build_args: L\n         ]\n \n     # Stage 4: Build PGO optimized rustc + PGO/BOLT optimized LLVM\n-    with timer.stage(\"Final build\"):\n+    with timer.section(\"Stage 4 (final build)\"):\n         cmd(final_build_args)\n \n "}, {"sha": "0f165b268ba3b9d01091d8d6f9e09870b172ea3a", "filename": "src/doc/rustc/src/platform-support/fuchsia.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Ffuchsia.md", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Ffuchsia.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Ffuchsia.md?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -697,7 +697,7 @@ test environment with:\n src/ci/docker/scripts/fuchsia-test-runner.py start\n     --rust ${RUST_SRC_PATH}/install\n     --sdk ${SDK_PATH}\n-    --target-arch {x64,arm64}\n+    --target-triple {x86_64-unknown-fuchsia|aarch64-unknown-fuchsia}\n ```\n \n Where `${RUST_SRC_PATH}/install` is the `prefix` set in `config.toml` and"}, {"sha": "80493b100bb45cecf4271e01c6be350b655d150e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -2213,21 +2213,17 @@ fn clean_maybe_renamed_item<'tcx>(\n             get_all_import_attributes(use_node, cx.tcx, item.owner_id.def_id, &mut extra_attrs);\n         }\n \n-        if !extra_attrs.is_empty() {\n+        let mut item = if !extra_attrs.is_empty() {\n             extra_attrs.extend_from_slice(inline::load_attrs(cx, def_id));\n             let attrs = Attributes::from_ast(&extra_attrs);\n             let cfg = extra_attrs.cfg(cx.tcx, &cx.cache.hidden_cfg);\n \n-            vec![Item::from_def_id_and_attrs_and_parts(\n-                def_id,\n-                Some(name),\n-                kind,\n-                Box::new(attrs),\n-                cfg,\n-            )]\n+            Item::from_def_id_and_attrs_and_parts(def_id, Some(name), kind, Box::new(attrs), cfg)\n         } else {\n-            vec![Item::from_def_id_and_parts(def_id, Some(name), kind, cx)]\n-        }\n+            Item::from_def_id_and_parts(def_id, Some(name), kind, cx)\n+        };\n+        item.inline_stmt_id = import_id.map(|def_id| def_id.to_def_id());\n+        vec![item]\n     })\n }\n "}, {"sha": "a59cfbea8853e5428f4a4adf1682eea10d7a0fef", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -208,15 +208,15 @@ impl clean::GenericParamDef {\n                     if f.alternate() {\n                         write!(f, \": {:#}\", print_generic_bounds(bounds, cx))?;\n                     } else {\n-                        write!(f, \":&nbsp;{}\", print_generic_bounds(bounds, cx))?;\n+                        write!(f, \": {}\", print_generic_bounds(bounds, cx))?;\n                     }\n                 }\n \n                 if let Some(ref ty) = default {\n                     if f.alternate() {\n                         write!(f, \" = {:#}\", ty.print(cx))?;\n                     } else {\n-                        write!(f, \"&nbsp;=&nbsp;{}\", ty.print(cx))?;\n+                        write!(f, \" = {}\", ty.print(cx))?;\n                     }\n                 }\n \n@@ -226,14 +226,14 @@ impl clean::GenericParamDef {\n                 if f.alternate() {\n                     write!(f, \"const {}: {:#}\", self.name, ty.print(cx))?;\n                 } else {\n-                    write!(f, \"const {}:&nbsp;{}\", self.name, ty.print(cx))?;\n+                    write!(f, \"const {}: {}\", self.name, ty.print(cx))?;\n                 }\n \n                 if let Some(default) = default {\n                     if f.alternate() {\n                         write!(f, \" = {:#}\", default)?;\n                     } else {\n-                        write!(f, \"&nbsp;=&nbsp;{}\", default)?;\n+                        write!(f, \" = {}\", default)?;\n                     }\n                 }\n \n@@ -353,22 +353,30 @@ pub(crate) fn print_where_clause<'a, 'tcx: 'a>(\n         } else {\n             let mut br_with_padding = String::with_capacity(6 * indent + 28);\n             br_with_padding.push_str(\"<br>\");\n-            for _ in 0..indent + 4 {\n-                br_with_padding.push_str(\"&nbsp;\");\n+\n+            let padding_amout =\n+                if ending == Ending::Newline { indent + 4 } else { indent + \"fn where \".len() };\n+\n+            for _ in 0..padding_amout {\n+                br_with_padding.push_str(\" \");\n             }\n             let where_preds = where_preds.to_string().replace(\"<br>\", &br_with_padding);\n \n             if ending == Ending::Newline {\n-                let mut clause = \"&nbsp;\".repeat(indent.saturating_sub(1));\n+                let mut clause = \" \".repeat(indent.saturating_sub(1));\n                 write!(clause, \"<span class=\\\"where fmt-newline\\\">where{where_preds},</span>\")?;\n                 clause\n             } else {\n                 // insert a <br> tag after a single space but before multiple spaces at the start\n                 if indent == 0 {\n                     format!(\"<br><span class=\\\"where\\\">where{where_preds}</span>\")\n                 } else {\n+                    // put the first one on the same line as the 'where' keyword\n+                    let where_preds = where_preds.replacen(&br_with_padding, \" \", 1);\n+\n                     let mut clause = br_with_padding;\n-                    clause.truncate(clause.len() - 4 * \"&nbsp;\".len());\n+                    clause.truncate(clause.len() - \"where \".len());\n+\n                     write!(clause, \"<span class=\\\"where\\\">where{where_preds}</span>\")?;\n                     clause\n                 }\n@@ -1391,8 +1399,8 @@ impl clean::FnDecl {\n \n         let declaration_len = header_len + args_plain.len() + arrow_plain.len();\n         let output = if declaration_len > 80 {\n-            let full_pad = format!(\"<br>{}\", \"&nbsp;\".repeat(indent + 4));\n-            let close_pad = format!(\"<br>{}\", \"&nbsp;\".repeat(indent));\n+            let full_pad = format!(\"<br>{}\", \" \".repeat(indent + 4));\n+            let close_pad = format!(\"<br>{}\", \" \".repeat(indent));\n             format!(\n                 \"({pad}{args}{close}){arrow}\",\n                 pad = if self.inputs.values.is_empty() { \"\" } else { &full_pad },\n@@ -1611,7 +1619,7 @@ impl clean::TypeBinding {\n                         if f.alternate() {\n                             write!(f, \": {:#}\", print_generic_bounds(bounds, cx))?;\n                         } else {\n-                            write!(f, \":&nbsp;{}\", print_generic_bounds(bounds, cx))?;\n+                            write!(f, \": {}\", print_generic_bounds(bounds, cx))?;\n                         }\n                     }\n                 }"}, {"sha": "fb7c34118a4913569671e2d714334ae3ed36b438", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -102,14 +102,14 @@ pub struct Markdown<'a> {\n     /// E.g. if `heading_offset: HeadingOffset::H2`, then `# something` renders an `<h2>`.\n     pub heading_offset: HeadingOffset,\n }\n-/// A tuple struct like `Markdown` that renders the markdown with a table of contents.\n-pub(crate) struct MarkdownWithToc<'a>(\n-    pub(crate) &'a str,\n-    pub(crate) &'a mut IdMap,\n-    pub(crate) ErrorCodes,\n-    pub(crate) Edition,\n-    pub(crate) &'a Option<Playground>,\n-);\n+/// A struct like `Markdown` that renders the markdown with a table of contents.\n+pub(crate) struct MarkdownWithToc<'a> {\n+    pub(crate) content: &'a str,\n+    pub(crate) ids: &'a mut IdMap,\n+    pub(crate) error_codes: ErrorCodes,\n+    pub(crate) edition: Edition,\n+    pub(crate) playground: &'a Option<Playground>,\n+}\n /// A tuple struct like `Markdown` that renders the markdown escaping HTML tags\n /// and includes no paragraph tags.\n pub(crate) struct MarkdownItemInfo<'a>(pub(crate) &'a str, pub(crate) &'a mut IdMap);\n@@ -1048,7 +1048,7 @@ impl Markdown<'_> {\n \n impl MarkdownWithToc<'_> {\n     pub(crate) fn into_string(self) -> String {\n-        let MarkdownWithToc(md, ids, codes, edition, playground) = self;\n+        let MarkdownWithToc { content: md, ids, error_codes: codes, edition, playground } = self;\n \n         let p = Parser::new_ext(md, main_body_opts()).into_offset_iter();\n "}, {"sha": "c2d24e514845e0ba1aafe7cf379dd4a23c035141", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -645,6 +645,10 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n             if count_consts != 0 && count_methods != 0 {\n                 w.write_str(\"\\n\");\n             }\n+\n+            if !required_methods.is_empty() {\n+                write!(w, \"    // Required method{}\\n\", pluralize(required_methods.len()));\n+            }\n             for (pos, m) in required_methods.iter().enumerate() {\n                 render_assoc_item(\n                     w,\n@@ -663,6 +667,10 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n             if !required_methods.is_empty() && !provided_methods.is_empty() {\n                 w.write_str(\"\\n\");\n             }\n+\n+            if !provided_methods.is_empty() {\n+                write!(w, \"    // Provided method{}\\n\", pluralize(provided_methods.len()));\n+            }\n             for (pos, m) in provided_methods.iter().enumerate() {\n                 render_assoc_item(\n                     w,\n@@ -672,16 +680,8 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n                     cx,\n                     RenderMode::Normal,\n                 );\n-                match *m.kind {\n-                    clean::MethodItem(ref inner, _)\n-                        if !inner.generics.where_predicates.is_empty() =>\n-                    {\n-                        w.write_str(\",\\n    { ... }\\n\");\n-                    }\n-                    _ => {\n-                        w.write_str(\" { ... }\\n\");\n-                    }\n-                }\n+\n+                w.write_str(\" { ... }\\n\");\n \n                 if pos < provided_methods.len() - 1 {\n                     w.write_str(\"<span class=\\\"item-spacer\\\"></span>\");\n@@ -1157,7 +1157,7 @@ fn item_union(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean:\n fn print_tuple_struct_fields(w: &mut Buffer, cx: &Context<'_>, s: &[clean::Item]) {\n     for (i, ty) in s.iter().enumerate() {\n         if i > 0 {\n-            w.write_str(\",&nbsp;\");\n+            w.write_str(\", \");\n         }\n         match *ty.kind {\n             clean::StrippedItem(box clean::StructFieldItem(_)) => w.write_str(\"_\"),\n@@ -1297,7 +1297,7 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n                                 \"<div class=\\\"sub-variant-field\\\">\\\n                                  <span id=\\\"{id}\\\" class=\\\"small-section-header\\\">\\\n                                      <a href=\\\"#{id}\\\" class=\\\"anchor field\\\">\u00a7</a>\\\n-                                     <code>{f}:&nbsp;{t}</code>\\\n+                                     <code>{f}: {t}</code>\\\n                                  </span>\",\n                                 id = id,\n                                 f = field.name.unwrap(),"}, {"sha": "54749e9a3171856b0ef735ac240fc0b21225de59", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -138,7 +138,7 @@ pub(super) fn write_shared(\n         Ok((ret, krates))\n     }\n \n-    /// Read a file and return all lines that match the <code>\"{crate}\":{data},\\</code> format,\n+    /// Read a file and return all lines that match the <code>\"{crate}\":{data},\\ </code> format,\n     /// and return a tuple `(Vec<DataString>, Vec<CrateNameString>)`.\n     ///\n     /// This forms the payload of files that look like this:"}, {"sha": "2a9548712f08637a264d613a7811660d6a5aaf2f", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -184,6 +184,7 @@ h4.code-header {\n \tfont-weight: 600;\n \tmargin: 0;\n \tpadding: 0;\n+\twhite-space: pre-wrap;\n }\n \n #crate-search,\n@@ -642,6 +643,7 @@ pre, .rustdoc.source .example-wrap {\n .fn .where,\n .where.fmt-newline {\n \tdisplay: block;\n+\twhite-space: pre-wrap;\n \tfont-size: 0.875rem;\n }\n \n@@ -1174,6 +1176,7 @@ a.test-arrow:hover {\n .item-spacer {\n \twidth: 100%;\n \theight: 12px;\n+\tdisplay: block;\n }\n \n .out-of-band > span.since {"}, {"sha": "b5a2cf7f28bf310114eac2ff44f8b6ebd23ac4e4", "filename": "src/librustdoc/html/static/css/themes/ayu.css", "status": "modified", "additions": 14, "deletions": 34, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -105,10 +105,9 @@ Original by Dempfi (https://github.com/dempfi/ayu)\n \t--scrape-example-code-wrapper-background-end: rgba(15, 20, 25, 0);\n }\n \n-h1, h2, h3, h4 {\n-\tcolor: white;\n-}\n-h1 a {\n+h1, h2, h3, h4,\n+h1 a, .sidebar h2 a, .sidebar h3 a,\n+#source-sidebar > .title {\n \tcolor: #fff;\n }\n h4 {\n@@ -118,24 +117,22 @@ h4 {\n .docblock code {\n \tcolor: #ffb454;\n }\n-.code-header {\n-\tcolor: #e6e1cf;\n-}\n-.docblock pre > code, pre > code {\n-\tcolor: #e6e1cf;\n-}\n-.item-info code {\n-\tcolor: #e6e1cf;\n-}\n .docblock a > code {\n \tcolor: #39AFD7 !important;\n }\n-pre, .rustdoc.source .example-wrap {\n+.code-header,\n+.docblock pre > code,\n+pre, pre > code,\n+.item-info code,\n+.rustdoc.source .example-wrap {\n \tcolor: #e6e1cf;\n }\n \n .sidebar .current,\n-.sidebar a:hover {\n+.sidebar a:hover,\n+#source-sidebar div.files > a:hover, details.dir-entry summary:hover,\n+#source-sidebar div.files > a:focus, details.dir-entry summary:focus,\n+#source-sidebar div.files > a.selected {\n \tcolor: #ffb44c;\n }\n \n@@ -149,27 +146,19 @@ pre, .rustdoc.source .example-wrap {\n \tborder-right: 1px solid #ffb44c;\n }\n \n-.search-results a:hover {\n-\tcolor: #fff !important;\n-\tbackground-color: #3c3c3c;\n-}\n-\n+.search-results a:hover,\n .search-results a:focus {\n \tcolor: #fff !important;\n \tbackground-color: #3c3c3c;\n }\n+\n .search-results a {\n \tcolor: #0096cf;\n }\n .search-results a div.desc {\n \tcolor: #c5c5c5;\n }\n \n-.sidebar h2 a,\n-.sidebar h3 a {\n-\tcolor: white;\n-}\n-\n .result-name .primitive > i, .result-name .keyword > i {\n \tcolor: #788797;\n }\n@@ -189,12 +178,3 @@ pre, .rustdoc.source .example-wrap {\n #settings-menu > a img {\n \tfilter: invert(100);\n }\n-\n-#source-sidebar > .title {\n-\tcolor: #fff;\n-}\n-#source-sidebar div.files > a:hover, details.dir-entry summary:hover,\n-#source-sidebar div.files > a:focus, details.dir-entry summary:focus,\n-#source-sidebar div.files > a.selected {\n-\tcolor: #ffb44c;\n-}"}, {"sha": "251e806c2d90d086c5bec0a25ba4769ec3a7ba46", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 84, "deletions": 65, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -112,7 +112,6 @@ function levenshtein(s1, s2) {\n }\n \n function initSearch(rawSearchIndex) {\n-    const MAX_LEV_DISTANCE = 3;\n     const MAX_RESULTS = 200;\n     const NO_TYPE_FILTER = -1;\n     /**\n@@ -897,13 +896,13 @@ function initSearch(rawSearchIndex) {\n          * @param {QueryElement} elem  - The element from the parsed query.\n          * @param {integer} defaultLev - This is the value to return in case there are no generics.\n          *\n-         * @return {integer}           - Returns the best match (if any) or `MAX_LEV_DISTANCE + 1`.\n+         * @return {integer}           - Returns the best match (if any) or `maxLevDistance + 1`.\n          */\n-        function checkGenerics(row, elem, defaultLev) {\n+        function checkGenerics(row, elem, defaultLev, maxLevDistance) {\n             if (row.generics.length === 0) {\n-                return elem.generics.length === 0 ? defaultLev : MAX_LEV_DISTANCE + 1;\n+                return elem.generics.length === 0 ? defaultLev : maxLevDistance + 1;\n             } else if (row.generics.length > 0 && row.generics[0].name === null) {\n-                return checkGenerics(row.generics[0], elem, defaultLev);\n+                return checkGenerics(row.generics[0], elem, defaultLev, maxLevDistance);\n             }\n             // The names match, but we need to be sure that all generics kinda\n             // match as well.\n@@ -914,8 +913,8 @@ function initSearch(rawSearchIndex) {\n                     elem_name = entry.name;\n                     if (elem_name === \"\") {\n                         // Pure generic, needs to check into it.\n-                        if (checkGenerics(entry, elem, MAX_LEV_DISTANCE + 1) !== 0) {\n-                            return MAX_LEV_DISTANCE + 1;\n+                        if (checkGenerics(entry, elem, maxLevDistance + 1, maxLevDistance) !== 0) {\n+                            return maxLevDistance + 1;\n                         }\n                         continue;\n                     }\n@@ -942,7 +941,7 @@ function initSearch(rawSearchIndex) {\n                         }\n                     }\n                     if (match === null) {\n-                        return MAX_LEV_DISTANCE + 1;\n+                        return maxLevDistance + 1;\n                     }\n                     elems[match] -= 1;\n                     if (elems[match] === 0) {\n@@ -951,7 +950,7 @@ function initSearch(rawSearchIndex) {\n                 }\n                 return 0;\n             }\n-            return MAX_LEV_DISTANCE + 1;\n+            return maxLevDistance + 1;\n         }\n \n         /**\n@@ -963,10 +962,10 @@ function initSearch(rawSearchIndex) {\n           *\n           * @return {integer} - Returns a Levenshtein distance to the best match.\n           */\n-        function checkIfInGenerics(row, elem) {\n-            let lev = MAX_LEV_DISTANCE + 1;\n+        function checkIfInGenerics(row, elem, maxLevDistance) {\n+            let lev = maxLevDistance + 1;\n             for (const entry of row.generics) {\n-                lev = Math.min(checkType(entry, elem, true), lev);\n+                lev = Math.min(checkType(entry, elem, true, maxLevDistance), lev);\n                 if (lev === 0) {\n                     break;\n                 }\n@@ -983,15 +982,15 @@ function initSearch(rawSearchIndex) {\n           * @param {boolean} literalSearch\n           *\n           * @return {integer} - Returns a Levenshtein distance to the best match. If there is\n-          *                     no match, returns `MAX_LEV_DISTANCE + 1`.\n+          *                     no match, returns `maxLevDistance + 1`.\n           */\n-        function checkType(row, elem, literalSearch) {\n+        function checkType(row, elem, literalSearch, maxLevDistance) {\n             if (row.name === null) {\n                 // This is a pure \"generic\" search, no need to run other checks.\n                 if (row.generics.length > 0) {\n-                    return checkIfInGenerics(row, elem);\n+                    return checkIfInGenerics(row, elem, maxLevDistance);\n                 }\n-                return MAX_LEV_DISTANCE + 1;\n+                return maxLevDistance + 1;\n             }\n \n             let lev = levenshtein(row.name, elem.name);\n@@ -1005,9 +1004,9 @@ function initSearch(rawSearchIndex) {\n                             return 0;\n                         }\n                     }\n-                    return MAX_LEV_DISTANCE + 1;\n+                    return maxLevDistance + 1;\n                 } else if (elem.generics.length > 0) {\n-                    return checkGenerics(row, elem, MAX_LEV_DISTANCE + 1);\n+                    return checkGenerics(row, elem, maxLevDistance + 1, maxLevDistance);\n                 }\n                 return 0;\n             } else if (row.generics.length > 0) {\n@@ -1017,30 +1016,28 @@ function initSearch(rawSearchIndex) {\n                     }\n                     // The name didn't match so we now check if the type we're looking for is inside\n                     // the generics!\n-                    lev = checkIfInGenerics(row, elem);\n-                    // Now whatever happens, the returned distance is \"less good\" so we should mark\n-                    // it as such, and so we add 0.5 to the distance to make it \"less good\".\n-                    return lev + 0.5;\n-                } else if (lev > MAX_LEV_DISTANCE) {\n+                    lev = Math.min(lev, checkIfInGenerics(row, elem, maxLevDistance));\n+                    return lev;\n+                } else if (lev > maxLevDistance) {\n                     // So our item's name doesn't match at all and has generics.\n                     //\n                     // Maybe it's present in a sub generic? For example \"f<A<B<C>>>()\", if we're\n                     // looking for \"B<C>\", we'll need to go down.\n-                    return checkIfInGenerics(row, elem);\n+                    return checkIfInGenerics(row, elem, maxLevDistance);\n                 } else {\n                     // At this point, the name kinda match and we have generics to check, so\n                     // let's go!\n-                    const tmp_lev = checkGenerics(row, elem, lev);\n-                    if (tmp_lev > MAX_LEV_DISTANCE) {\n-                        return MAX_LEV_DISTANCE + 1;\n+                    const tmp_lev = checkGenerics(row, elem, lev, maxLevDistance);\n+                    if (tmp_lev > maxLevDistance) {\n+                        return maxLevDistance + 1;\n                     }\n                     // We compute the median value of both checks and return it.\n                     return (tmp_lev + lev) / 2;\n                 }\n             } else if (elem.generics.length > 0) {\n                 // In this case, we were expecting generics but there isn't so we simply reject this\n                 // one.\n-                return MAX_LEV_DISTANCE + 1;\n+                return maxLevDistance + 1;\n             }\n             // No generics on our query or on the target type so we can return without doing\n             // anything else.\n@@ -1055,23 +1052,26 @@ function initSearch(rawSearchIndex) {\n          * @param {integer} typeFilter\n          *\n          * @return {integer} - Returns a Levenshtein distance to the best match. If there is no\n-         *                      match, returns `MAX_LEV_DISTANCE + 1`.\n+         *                      match, returns `maxLevDistance + 1`.\n          */\n-        function findArg(row, elem, typeFilter) {\n-            let lev = MAX_LEV_DISTANCE + 1;\n+        function findArg(row, elem, typeFilter, maxLevDistance) {\n+            let lev = maxLevDistance + 1;\n \n             if (row && row.type && row.type.inputs && row.type.inputs.length > 0) {\n                 for (const input of row.type.inputs) {\n                     if (!typePassesFilter(typeFilter, input.ty)) {\n                         continue;\n                     }\n-                    lev = Math.min(lev, checkType(input, elem, parsedQuery.literalSearch));\n+                    lev = Math.min(\n+                        lev,\n+                        checkType(input, elem, parsedQuery.literalSearch, maxLevDistance)\n+                    );\n                     if (lev === 0) {\n                         return 0;\n                     }\n                 }\n             }\n-            return parsedQuery.literalSearch ? MAX_LEV_DISTANCE + 1 : lev;\n+            return parsedQuery.literalSearch ? maxLevDistance + 1 : lev;\n         }\n \n         /**\n@@ -1082,31 +1082,34 @@ function initSearch(rawSearchIndex) {\n          * @param {integer} typeFilter\n          *\n          * @return {integer} - Returns a Levenshtein distance to the best match. If there is no\n-         *                      match, returns `MAX_LEV_DISTANCE + 1`.\n+         *                      match, returns `maxLevDistance + 1`.\n          */\n-        function checkReturned(row, elem, typeFilter) {\n-            let lev = MAX_LEV_DISTANCE + 1;\n+        function checkReturned(row, elem, typeFilter, maxLevDistance) {\n+            let lev = maxLevDistance + 1;\n \n             if (row && row.type && row.type.output.length > 0) {\n                 const ret = row.type.output;\n                 for (const ret_ty of ret) {\n                     if (!typePassesFilter(typeFilter, ret_ty.ty)) {\n                         continue;\n                     }\n-                    lev = Math.min(lev, checkType(ret_ty, elem, parsedQuery.literalSearch));\n+                    lev = Math.min(\n+                        lev,\n+                        checkType(ret_ty, elem, parsedQuery.literalSearch, maxLevDistance)\n+                    );\n                     if (lev === 0) {\n                         return 0;\n                     }\n                 }\n             }\n-            return parsedQuery.literalSearch ? MAX_LEV_DISTANCE + 1 : lev;\n+            return parsedQuery.literalSearch ? maxLevDistance + 1 : lev;\n         }\n \n-        function checkPath(contains, ty) {\n+        function checkPath(contains, ty, maxLevDistance) {\n             if (contains.length === 0) {\n                 return 0;\n             }\n-            let ret_lev = MAX_LEV_DISTANCE + 1;\n+            let ret_lev = maxLevDistance + 1;\n             const path = ty.path.split(\"::\");\n \n             if (ty.parent && ty.parent.name) {\n@@ -1116,7 +1119,7 @@ function initSearch(rawSearchIndex) {\n             const length = path.length;\n             const clength = contains.length;\n             if (clength > length) {\n-                return MAX_LEV_DISTANCE + 1;\n+                return maxLevDistance + 1;\n             }\n             for (let i = 0; i < length; ++i) {\n                 if (i + clength > length) {\n@@ -1126,7 +1129,7 @@ function initSearch(rawSearchIndex) {\n                 let aborted = false;\n                 for (let x = 0; x < clength; ++x) {\n                     const lev = levenshtein(path[i + x], contains[x]);\n-                    if (lev > MAX_LEV_DISTANCE) {\n+                    if (lev > maxLevDistance) {\n                         aborted = true;\n                         break;\n                     }\n@@ -1231,7 +1234,7 @@ function initSearch(rawSearchIndex) {\n          * following condition:\n          *\n          * * If it is a \"literal search\" (`parsedQuery.literalSearch`), then `lev` must be 0.\n-         * * If it is not a \"literal search\", `lev` must be <= `MAX_LEV_DISTANCE`.\n+         * * If it is not a \"literal search\", `lev` must be <= `maxLevDistance`.\n          *\n          * The `results` map contains information which will be used to sort the search results:\n          *\n@@ -1249,8 +1252,8 @@ function initSearch(rawSearchIndex) {\n          * @param {integer} lev\n          * @param {integer} path_lev\n          */\n-        function addIntoResults(results, fullId, id, index, lev, path_lev) {\n-            const inBounds = lev <= MAX_LEV_DISTANCE || index !== -1;\n+        function addIntoResults(results, fullId, id, index, lev, path_lev, maxLevDistance) {\n+            const inBounds = lev <= maxLevDistance || index !== -1;\n             if (lev === 0 || (!parsedQuery.literalSearch && inBounds)) {\n                 if (results[fullId] !== undefined) {\n                     const result = results[fullId];\n@@ -1289,7 +1292,8 @@ function initSearch(rawSearchIndex) {\n             elem,\n             results_others,\n             results_in_args,\n-            results_returned\n+            results_returned,\n+            maxLevDistance\n         ) {\n             if (!row || (filterCrates !== null && row.crate !== filterCrates)) {\n                 return;\n@@ -1298,13 +1302,13 @@ function initSearch(rawSearchIndex) {\n             const fullId = row.id;\n             const searchWord = searchWords[pos];\n \n-            const in_args = findArg(row, elem, parsedQuery.typeFilter);\n-            const returned = checkReturned(row, elem, parsedQuery.typeFilter);\n+            const in_args = findArg(row, elem, parsedQuery.typeFilter, maxLevDistance);\n+            const returned = checkReturned(row, elem, parsedQuery.typeFilter, maxLevDistance);\n \n             // path_lev is 0 because no parent path information is currently stored\n             // in the search index\n-            addIntoResults(results_in_args, fullId, pos, -1, in_args, 0);\n-            addIntoResults(results_returned, fullId, pos, -1, returned, 0);\n+            addIntoResults(results_in_args, fullId, pos, -1, in_args, 0, maxLevDistance);\n+            addIntoResults(results_returned, fullId, pos, -1, returned, 0, maxLevDistance);\n \n             if (!typePassesFilter(parsedQuery.typeFilter, row.ty)) {\n                 return;\n@@ -1328,16 +1332,16 @@ function initSearch(rawSearchIndex) {\n             // No need to check anything else if it's a \"pure\" generics search.\n             if (elem.name.length === 0) {\n                 if (row.type !== null) {\n-                    lev = checkGenerics(row.type, elem, MAX_LEV_DISTANCE + 1);\n+                    lev = checkGenerics(row.type, elem, maxLevDistance + 1, maxLevDistance);\n                     // path_lev is 0 because we know it's empty\n-                    addIntoResults(results_others, fullId, pos, index, lev, 0);\n+                    addIntoResults(results_others, fullId, pos, index, lev, 0, maxLevDistance);\n                 }\n                 return;\n             }\n \n             if (elem.fullPath.length > 1) {\n-                path_lev = checkPath(elem.pathWithoutLast, row);\n-                if (path_lev > MAX_LEV_DISTANCE) {\n+                path_lev = checkPath(elem.pathWithoutLast, row, maxLevDistance);\n+                if (path_lev > maxLevDistance) {\n                     return;\n                 }\n             }\n@@ -1351,11 +1355,11 @@ function initSearch(rawSearchIndex) {\n \n             lev = levenshtein(searchWord, elem.pathLast);\n \n-            if (index === -1 && lev + path_lev > MAX_LEV_DISTANCE) {\n+            if (index === -1 && lev + path_lev > maxLevDistance) {\n                 return;\n             }\n \n-            addIntoResults(results_others, fullId, pos, index, lev, path_lev);\n+            addIntoResults(results_others, fullId, pos, index, lev, path_lev, maxLevDistance);\n         }\n \n         /**\n@@ -1367,7 +1371,7 @@ function initSearch(rawSearchIndex) {\n          * @param {integer} pos      - Position in the `searchIndex`.\n          * @param {Object} results\n          */\n-        function handleArgs(row, pos, results) {\n+        function handleArgs(row, pos, results, maxLevDistance) {\n             if (!row || (filterCrates !== null && row.crate !== filterCrates)) {\n                 return;\n             }\n@@ -1379,7 +1383,7 @@ function initSearch(rawSearchIndex) {\n             function checkArgs(elems, callback) {\n                 for (const elem of elems) {\n                     // There is more than one parameter to the query so all checks should be \"exact\"\n-                    const lev = callback(row, elem, NO_TYPE_FILTER);\n+                    const lev = callback(row, elem, NO_TYPE_FILTER, maxLevDistance);\n                     if (lev <= 1) {\n                         nbLev += 1;\n                         totalLev += lev;\n@@ -1400,12 +1404,21 @@ function initSearch(rawSearchIndex) {\n                 return;\n             }\n             const lev = Math.round(totalLev / nbLev);\n-            addIntoResults(results, row.id, pos, 0, lev, 0);\n+            addIntoResults(results, row.id, pos, 0, lev, 0, maxLevDistance);\n         }\n \n         function innerRunQuery() {\n             let elem, i, nSearchWords, in_returned, row;\n \n+            let queryLen = 0;\n+            for (const elem of parsedQuery.elems) {\n+                queryLen += elem.name.length;\n+            }\n+            for (const elem of parsedQuery.returned) {\n+                queryLen += elem.name.length;\n+            }\n+            const maxLevDistance = Math.floor(queryLen / 3);\n+\n             if (parsedQuery.foundElems === 1) {\n                 if (parsedQuery.elems.length === 1) {\n                     elem = parsedQuery.elems[0];\n@@ -1418,21 +1431,27 @@ function initSearch(rawSearchIndex) {\n                             elem,\n                             results_others,\n                             results_in_args,\n-                            results_returned\n+                            results_returned,\n+                            maxLevDistance\n                         );\n                     }\n                 } else if (parsedQuery.returned.length === 1) {\n                     // We received one returned argument to check, so looking into returned values.\n                     elem = parsedQuery.returned[0];\n                     for (i = 0, nSearchWords = searchWords.length; i < nSearchWords; ++i) {\n                         row = searchIndex[i];\n-                        in_returned = checkReturned(row, elem, parsedQuery.typeFilter);\n-                        addIntoResults(results_others, row.id, i, -1, in_returned);\n+                        in_returned = checkReturned(\n+                            row,\n+                            elem,\n+                            parsedQuery.typeFilter,\n+                            maxLevDistance\n+                        );\n+                        addIntoResults(results_others, row.id, i, -1, in_returned, maxLevDistance);\n                     }\n                 }\n             } else if (parsedQuery.foundElems > 0) {\n                 for (i = 0, nSearchWords = searchWords.length; i < nSearchWords; ++i) {\n-                    handleArgs(searchIndex[i], i, results_others);\n+                    handleArgs(searchIndex[i], i, results_others, maxLevDistance);\n                 }\n             }\n         }\n@@ -1470,7 +1489,7 @@ function initSearch(rawSearchIndex) {\n      *\n      * @return {boolean}       - Whether the result is valid or not\n      */\n-    function validateResult(name, path, keys, parent) {\n+    function validateResult(name, path, keys, parent, maxLevDistance) {\n         if (!keys || !keys.length) {\n             return true;\n         }\n@@ -1485,7 +1504,7 @@ function initSearch(rawSearchIndex) {\n                 (parent !== undefined && parent.name !== undefined &&\n                     parent.name.toLowerCase().indexOf(key) > -1) ||\n                 // lastly check to see if the name was a levenshtein match\n-                levenshtein(name, key) <= MAX_LEV_DISTANCE)) {\n+                levenshtein(name, key) <= maxLevDistance)) {\n                 return false;\n             }\n         }"}, {"sha": "4321d4aa343dcd8f7065ee0134975e5740b7add8", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -72,7 +72,14 @@ pub(crate) fn render<P: AsRef<Path>>(\n     let mut ids = IdMap::new();\n     let error_codes = ErrorCodes::from(options.unstable_features.is_nightly_build());\n     let text = if !options.markdown_no_toc {\n-        MarkdownWithToc(text, &mut ids, error_codes, edition, &playground).into_string()\n+        MarkdownWithToc {\n+            content: text,\n+            ids: &mut ids,\n+            error_codes,\n+            edition,\n+            playground: &playground,\n+        }\n+        .into_string()\n     } else {\n         Markdown {\n             content: text,"}, {"sha": "8c733ddefc0a5a1efe02dd3d95647f85533a297b", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 83, "deletions": 26, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1,4 +1,6 @@\n //! Strip all doc(hidden) items from the output.\n+\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::sym;\n use std::mem;\n \n@@ -7,6 +9,7 @@ use crate::clean::{Item, ItemIdSet, NestedAttributesExt};\n use crate::core::DocContext;\n use crate::fold::{strip_item, DocFolder};\n use crate::passes::{ImplStripper, Pass};\n+use crate::visit_ast::inherits_doc_hidden;\n \n pub(crate) const STRIP_HIDDEN: Pass = Pass {\n     name: \"strip-hidden\",\n@@ -21,7 +24,12 @@ pub(crate) fn strip_hidden(krate: clean::Crate, cx: &mut DocContext<'_>) -> clea\n \n     // strip all #[doc(hidden)] items\n     let krate = {\n-        let mut stripper = Stripper { retained: &mut retained, update_retained: true };\n+        let mut stripper = Stripper {\n+            retained: &mut retained,\n+            update_retained: true,\n+            tcx: cx.tcx,\n+            is_in_hidden_item: false,\n+        };\n         stripper.fold_crate(krate)\n     };\n \n@@ -36,40 +44,89 @@ pub(crate) fn strip_hidden(krate: clean::Crate, cx: &mut DocContext<'_>) -> clea\n     stripper.fold_crate(krate)\n }\n \n-struct Stripper<'a> {\n+struct Stripper<'a, 'tcx> {\n     retained: &'a mut ItemIdSet,\n     update_retained: bool,\n+    tcx: TyCtxt<'tcx>,\n+    is_in_hidden_item: bool,\n+}\n+\n+impl<'a, 'tcx> Stripper<'a, 'tcx> {\n+    fn set_is_in_hidden_item_and_fold(&mut self, is_in_hidden_item: bool, i: Item) -> Item {\n+        let prev = self.is_in_hidden_item;\n+        self.is_in_hidden_item |= is_in_hidden_item;\n+        let ret = self.fold_item_recur(i);\n+        self.is_in_hidden_item = prev;\n+        ret\n+    }\n+\n+    /// In case `i` is a non-hidden impl block, then we special-case it by changing the value\n+    /// of `is_in_hidden_item` to `true` because the impl children inherit its visibility.\n+    fn recurse_in_impl(&mut self, i: Item) -> Item {\n+        let prev = mem::replace(&mut self.is_in_hidden_item, false);\n+        let ret = self.fold_item_recur(i);\n+        self.is_in_hidden_item = prev;\n+        ret\n+    }\n }\n \n-impl<'a> DocFolder for Stripper<'a> {\n+impl<'a, 'tcx> DocFolder for Stripper<'a, 'tcx> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        if i.attrs.lists(sym::doc).has_word(sym::hidden) {\n-            debug!(\"strip_hidden: stripping {:?} {:?}\", i.type_(), i.name);\n-            // Use a dedicated hidden item for fields, variants, and modules.\n-            // We need to keep private fields and variants, so that the docs\n-            // can show a placeholder \"// some variants omitted\". We need to keep\n-            // private modules, because they can contain impl blocks, and impl\n-            // block privacy is inherited from the type and trait, not from the\n-            // module it's defined in. Both of these are marked \"stripped,\" and\n-            // not included in the final docs, but since they still have an effect\n-            // on the final doc, cannot be completely removed from the Clean IR.\n-            match *i.kind {\n-                clean::StructFieldItem(..) | clean::ModuleItem(..) | clean::VariantItem(..) => {\n-                    // We need to recurse into stripped modules to\n-                    // strip things like impl methods but when doing so\n-                    // we must not add any items to the `retained` set.\n-                    let old = mem::replace(&mut self.update_retained, false);\n-                    let ret = strip_item(self.fold_item_recur(i));\n-                    self.update_retained = old;\n-                    return Some(ret);\n-                }\n-                _ => return None,\n+        let has_doc_hidden = i.attrs.lists(sym::doc).has_word(sym::hidden);\n+        let is_impl = matches!(*i.kind, clean::ImplItem(..));\n+        let mut is_hidden = has_doc_hidden;\n+        if !is_impl {\n+            is_hidden = self.is_in_hidden_item || has_doc_hidden;\n+            if !is_hidden && i.inline_stmt_id.is_none() {\n+                // We don't need to check if it's coming from a reexport since the reexport itself was\n+                // already checked.\n+                is_hidden = i\n+                    .item_id\n+                    .as_def_id()\n+                    .and_then(|def_id| def_id.as_local())\n+                    .map(|def_id| inherits_doc_hidden(self.tcx, def_id))\n+                    .unwrap_or(false);\n             }\n-        } else {\n+        }\n+        if !is_hidden {\n             if self.update_retained {\n                 self.retained.insert(i.item_id);\n             }\n+            return Some(if is_impl {\n+                self.recurse_in_impl(i)\n+            } else {\n+                self.set_is_in_hidden_item_and_fold(false, i)\n+            });\n+        }\n+        debug!(\"strip_hidden: stripping {:?} {:?}\", i.type_(), i.name);\n+        // Use a dedicated hidden item for fields, variants, and modules.\n+        // We need to keep private fields and variants, so that the docs\n+        // can show a placeholder \"// some variants omitted\". We need to keep\n+        // private modules, because they can contain impl blocks, and impl\n+        // block privacy is inherited from the type and trait, not from the\n+        // module it's defined in. Both of these are marked \"stripped,\" and\n+        // not included in the final docs, but since they still have an effect\n+        // on the final doc, cannot be completely removed from the Clean IR.\n+        match *i.kind {\n+            clean::StructFieldItem(..) | clean::ModuleItem(..) | clean::VariantItem(..) => {\n+                // We need to recurse into stripped modules to\n+                // strip things like impl methods but when doing so\n+                // we must not add any items to the `retained` set.\n+                let old = mem::replace(&mut self.update_retained, false);\n+                let ret = strip_item(self.set_is_in_hidden_item_and_fold(true, i));\n+                self.update_retained = old;\n+                Some(ret)\n+            }\n+            _ => {\n+                let ret = self.set_is_in_hidden_item_and_fold(true, i);\n+                if has_doc_hidden {\n+                    // If the item itself has `#[doc(hidden)]`, then we simply remove it.\n+                    None\n+                } else {\n+                    // However if it's a \"descendant\" of a `#[doc(hidden)]` item, then we strip it.\n+                    Some(strip_item(ret))\n+                }\n+            }\n         }\n-        Some(self.fold_item_recur(i))\n     }\n }"}, {"sha": "088cb3f339492be74fc4e8091b5693f7e2427fdc", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 138, "deletions": 66, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -5,7 +5,9 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId, LocalDefIdSet};\n+use rustc_hir::intravisit::{walk_item, Visitor};\n use rustc_hir::{Node, CRATE_HIR_ID};\n+use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::{DefIdTree, TyCtxt};\n use rustc_span::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_span::symbol::{kw, sym, Symbol};\n@@ -53,39 +55,54 @@ fn def_id_to_path(tcx: TyCtxt<'_>, did: DefId) -> Vec<Symbol> {\n     std::iter::once(crate_name).chain(relative).collect()\n }\n \n-pub(crate) fn inherits_doc_hidden(tcx: TyCtxt<'_>, mut node: LocalDefId) -> bool {\n-    while let Some(id) = tcx.opt_local_parent(node) {\n-        node = id;\n-        if tcx.is_doc_hidden(node.to_def_id()) {\n+pub(crate) fn inherits_doc_hidden(tcx: TyCtxt<'_>, mut def_id: LocalDefId) -> bool {\n+    let hir = tcx.hir();\n+    while let Some(id) = tcx.opt_local_parent(def_id) {\n+        def_id = id;\n+        if tcx.is_doc_hidden(def_id.to_def_id()) {\n             return true;\n+        } else if let Some(node) = hir.find_by_def_id(def_id) &&\n+            matches!(\n+                node,\n+                hir::Node::Item(hir::Item { kind: hir::ItemKind::Impl(_), .. }),\n+            )\n+        {\n+            // `impl` blocks stand a bit on their own: unless they have `#[doc(hidden)]` directly\n+            // on them, they don't inherit it from the parent context.\n+            return false;\n         }\n     }\n     false\n }\n \n-// Also, is there some reason that this doesn't use the 'visit'\n-// framework from syntax?.\n-\n pub(crate) struct RustdocVisitor<'a, 'tcx> {\n     cx: &'a mut core::DocContext<'tcx>,\n     view_item_stack: LocalDefIdSet,\n     inlining: bool,\n     /// Are the current module and all of its parents public?\n     inside_public_path: bool,\n     exact_paths: DefIdMap<Vec<Symbol>>,\n+    modules: Vec<Module<'tcx>>,\n }\n \n impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     pub(crate) fn new(cx: &'a mut core::DocContext<'tcx>) -> RustdocVisitor<'a, 'tcx> {\n         // If the root is re-exported, terminate all recursion.\n         let mut stack = LocalDefIdSet::default();\n         stack.insert(CRATE_DEF_ID);\n+        let om = Module::new(\n+            cx.tcx.crate_name(LOCAL_CRATE),\n+            CRATE_DEF_ID,\n+            cx.tcx.hir().root_module().spans.inner_span,\n+        );\n+\n         RustdocVisitor {\n             cx,\n             view_item_stack: stack,\n             inlining: false,\n             inside_public_path: true,\n             exact_paths: Default::default(),\n+            modules: vec![om],\n         }\n     }\n \n@@ -95,12 +112,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     pub(crate) fn visit(mut self) -> Module<'tcx> {\n-        let mut top_level_module = self.visit_mod_contents(\n-            CRATE_DEF_ID,\n-            self.cx.tcx.hir().root_module(),\n-            self.cx.tcx.crate_name(LOCAL_CRATE),\n-            None,\n-        );\n+        let root_module = self.cx.tcx.hir().root_module();\n+        self.visit_mod_contents(CRATE_DEF_ID, root_module);\n+\n+        let mut top_level_module = self.modules.pop().unwrap();\n \n         // `#[macro_export] macro_rules!` items are reexported at the top level of the\n         // crate, regardless of where they're defined. We want to document the\n@@ -115,15 +130,13 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         // macro in the same module.\n         let mut inserted = FxHashSet::default();\n         for export in self.cx.tcx.module_reexports(CRATE_DEF_ID).unwrap_or(&[]) {\n-            if let Res::Def(DefKind::Macro(_), def_id) = export.res {\n-                if let Some(local_def_id) = def_id.as_local() {\n-                    if self.cx.tcx.has_attr(def_id, sym::macro_export) {\n-                        if inserted.insert(def_id) {\n-                            let item = self.cx.tcx.hir().expect_item(local_def_id);\n-                            top_level_module.items.push((item, None, None));\n-                        }\n-                    }\n-                }\n+            if let Res::Def(DefKind::Macro(_), def_id) = export.res &&\n+                let Some(local_def_id) = def_id.as_local() &&\n+                self.cx.tcx.has_attr(def_id, sym::macro_export) &&\n+                inserted.insert(def_id)\n+            {\n+                    let item = self.cx.tcx.hir().expect_item(local_def_id);\n+                    top_level_module.items.push((item, None, None));\n             }\n         }\n \n@@ -157,35 +170,34 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         top_level_module\n     }\n \n-    fn visit_mod_contents(\n-        &mut self,\n-        def_id: LocalDefId,\n-        m: &'tcx hir::Mod<'tcx>,\n-        name: Symbol,\n-        parent_id: Option<LocalDefId>,\n-    ) -> Module<'tcx> {\n-        let mut om = Module::new(name, def_id, m.spans.inner_span);\n+    /// This method will go through the given module items in two passes:\n+    /// 1. The items which are not glob imports/reexports.\n+    /// 2. The glob imports/reexports.\n+    fn visit_mod_contents(&mut self, def_id: LocalDefId, m: &'tcx hir::Mod<'tcx>) {\n+        debug!(\"Going through module {:?}\", m);\n         // Keep track of if there were any private modules in the path.\n         let orig_inside_public_path = self.inside_public_path;\n         self.inside_public_path &= self.cx.tcx.local_visibility(def_id).is_public();\n+\n+        // Reimplementation of `walk_mod` because we need to do it in two passes (explanations in\n+        // the second loop):\n         for &i in m.item_ids {\n             let item = self.cx.tcx.hir().item(i);\n-            if matches!(item.kind, hir::ItemKind::Use(_, hir::UseKind::Glob)) {\n-                continue;\n+            if !matches!(item.kind, hir::ItemKind::Use(_, hir::UseKind::Glob)) {\n+                self.visit_item(item);\n             }\n-            self.visit_item(item, None, &mut om, parent_id);\n         }\n         for &i in m.item_ids {\n             let item = self.cx.tcx.hir().item(i);\n             // To match the way import precedence works, visit glob imports last.\n             // Later passes in rustdoc will de-duplicate by name and kind, so if glob-\n             // imported items appear last, then they'll be the ones that get discarded.\n             if matches!(item.kind, hir::ItemKind::Use(_, hir::UseKind::Glob)) {\n-                self.visit_item(item, None, &mut om, parent_id);\n+                self.visit_item(item);\n             }\n         }\n         self.inside_public_path = orig_inside_public_path;\n-        om\n+        debug!(\"Leaving module {:?}\", m);\n     }\n \n     /// Tries to resolve the target of a `pub use` statement and inlines the\n@@ -203,7 +215,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         res: Res,\n         renamed: Option<Symbol>,\n         glob: bool,\n-        om: &mut Module<'tcx>,\n         please_inline: bool,\n     ) -> bool {\n         debug!(\"maybe_inline_local res: {:?}\", res);\n@@ -213,33 +224,30 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         }\n \n         let tcx = self.cx.tcx;\n-        let Some(res_did) = res.opt_def_id() else {\n+        let Some(ori_res_did) = res.opt_def_id() else {\n             return false;\n         };\n \n         let use_attrs = tcx.hir().attrs(tcx.hir().local_def_id_to_hir_id(def_id));\n         // Don't inline `doc(hidden)` imports so they can be stripped at a later stage.\n         let is_no_inline = use_attrs.lists(sym::doc).has_word(sym::no_inline)\n-            || tcx.is_doc_hidden(def_id.to_def_id());\n+            || use_attrs.lists(sym::doc).has_word(sym::hidden);\n \n         // For cross-crate impl inlining we need to know whether items are\n         // reachable in documentation -- a previously unreachable item can be\n         // made reachable by cross-crate inlining which we're checking here.\n         // (this is done here because we need to know this upfront).\n-        if !res_did.is_local() && !is_no_inline {\n-            crate::visit_lib::lib_embargo_visit_item(self.cx, res_did);\n+        if !ori_res_did.is_local() && !is_no_inline {\n+            crate::visit_lib::lib_embargo_visit_item(self.cx, ori_res_did);\n             return false;\n         }\n \n-        let Some(res_did) = res_did.as_local() else {\n+        let Some(res_did) = ori_res_did.as_local() else {\n             return false;\n         };\n \n-        let is_private = !self\n-            .cx\n-            .cache\n-            .effective_visibilities\n-            .is_directly_public(self.cx.tcx, res_did.to_def_id());\n+        let is_private =\n+            !self.cx.cache.effective_visibilities.is_directly_public(self.cx.tcx, ori_res_did);\n         let is_hidden = inherits_doc_hidden(self.cx.tcx, res_did);\n \n         // Only inline if requested or if the item would otherwise be stripped.\n@@ -256,20 +264,20 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for &i in m.item_ids {\n                     let i = self.cx.tcx.hir().item(i);\n-                    self.visit_item(i, None, om, Some(def_id));\n+                    self.visit_item_inner(i, None, Some(def_id));\n                 }\n                 self.inlining = prev;\n                 true\n             }\n             Node::Item(it) if !glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n-                self.visit_item(it, renamed, om, Some(def_id));\n+                self.visit_item_inner(it, renamed, Some(def_id));\n                 self.inlining = prev;\n                 true\n             }\n             Node::ForeignItem(it) if !glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n-                self.visit_foreign_item(it, renamed, om);\n+                self.visit_foreign_item_inner(it, renamed);\n                 self.inlining = prev;\n                 true\n             }\n@@ -279,18 +287,28 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         ret\n     }\n \n-    fn visit_item(\n+    #[inline]\n+    fn add_to_current_mod(\n         &mut self,\n         item: &'tcx hir::Item<'_>,\n         renamed: Option<Symbol>,\n-        om: &mut Module<'tcx>,\n         parent_id: Option<LocalDefId>,\n     ) {\n+        self.modules.last_mut().unwrap().items.push((item, renamed, parent_id))\n+    }\n+\n+    fn visit_item_inner(\n+        &mut self,\n+        item: &'tcx hir::Item<'_>,\n+        renamed: Option<Symbol>,\n+        import_id: Option<LocalDefId>,\n+    ) -> bool {\n         debug!(\"visiting item {:?}\", item);\n         let name = renamed.unwrap_or(item.ident.name);\n+        let tcx = self.cx.tcx;\n \n         let def_id = item.owner_id.to_def_id();\n-        let is_pub = self.cx.tcx.visibility(def_id).is_public();\n+        let is_pub = tcx.visibility(def_id).is_public();\n \n         if is_pub {\n             self.store_path(item.owner_id.to_def_id());\n@@ -299,8 +317,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         match item.kind {\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for item in items {\n-                    let item = self.cx.tcx.hir().foreign_item(item.id);\n-                    self.visit_foreign_item(item, None, om);\n+                    let item = tcx.hir().foreign_item(item.id);\n+                    self.visit_foreign_item_inner(item, None);\n                 }\n             }\n             // If we're inlining, skip private items or item reexported as \"_\".\n@@ -315,7 +333,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                         continue;\n                     }\n \n-                    let attrs = self.cx.tcx.hir().attrs(item.hir_id());\n+                    let attrs =\n+                        tcx.hir().attrs(tcx.hir().local_def_id_to_hir_id(item.owner_id.def_id));\n \n                     // If there was a private module in the current path then don't bother inlining\n                     // anything as it will probably be stripped anyway.\n@@ -333,14 +352,13 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                             res,\n                             ident,\n                             is_glob,\n-                            om,\n                             please_inline,\n                         ) {\n                             continue;\n                         }\n                     }\n \n-                    om.items.push((item, renamed, parent_id))\n+                    self.add_to_current_mod(item, renamed, import_id);\n                 }\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n@@ -357,14 +375,14 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n                 let def_id = item.owner_id.to_def_id();\n                 let is_macro_2_0 = !macro_def.macro_rules;\n-                let nonexported = !self.cx.tcx.has_attr(def_id, sym::macro_export);\n+                let nonexported = !tcx.has_attr(def_id, sym::macro_export);\n \n                 if is_macro_2_0 || nonexported || self.inlining {\n-                    om.items.push((item, renamed, None));\n+                    self.add_to_current_mod(item, renamed, None);\n                 }\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                om.mods.push(self.visit_mod_contents(item.owner_id.def_id, m, name, parent_id));\n+                self.enter_mod(item.owner_id.def_id, m, name);\n             }\n             hir::ItemKind::Fn(..)\n             | hir::ItemKind::ExternCrate(..)\n@@ -375,33 +393,87 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             | hir::ItemKind::OpaqueTy(..)\n             | hir::ItemKind::Static(..)\n             | hir::ItemKind::Trait(..)\n-            | hir::ItemKind::TraitAlias(..) => om.items.push((item, renamed, parent_id)),\n+            | hir::ItemKind::TraitAlias(..) => {\n+                self.add_to_current_mod(item, renamed, import_id);\n+            }\n             hir::ItemKind::Const(..) => {\n                 // Underscore constants do not correspond to a nameable item and\n                 // so are never useful in documentation.\n                 if name != kw::Underscore {\n-                    om.items.push((item, renamed, parent_id));\n+                    self.add_to_current_mod(item, renamed, import_id);\n                 }\n             }\n             hir::ItemKind::Impl(impl_) => {\n                 // Don't duplicate impls when inlining or if it's implementing a trait, we'll pick\n                 // them up regardless of where they're located.\n                 if !self.inlining && impl_.of_trait.is_none() {\n-                    om.items.push((item, None, None));\n+                    self.add_to_current_mod(item, None, None);\n                 }\n             }\n         }\n+        true\n     }\n \n-    fn visit_foreign_item(\n+    fn visit_foreign_item_inner(\n         &mut self,\n         item: &'tcx hir::ForeignItem<'_>,\n         renamed: Option<Symbol>,\n-        om: &mut Module<'tcx>,\n     ) {\n         // If inlining we only want to include public functions.\n         if !self.inlining || self.cx.tcx.visibility(item.owner_id).is_public() {\n-            om.foreigns.push((item, renamed));\n+            self.modules.last_mut().unwrap().foreigns.push((item, renamed));\n+        }\n+    }\n+\n+    /// This method will create a new module and push it onto the \"modules stack\" then call\n+    /// `visit_mod_contents`. Once done, it'll remove it from the \"modules stack\" and instead\n+    /// add into the list of modules of the current module.\n+    fn enter_mod(&mut self, id: LocalDefId, m: &'tcx hir::Mod<'tcx>, name: Symbol) {\n+        self.modules.push(Module::new(name, id, m.spans.inner_span));\n+\n+        self.visit_mod_contents(id, m);\n+\n+        let last = self.modules.pop().unwrap();\n+        self.modules.last_mut().unwrap().mods.push(last);\n+    }\n+}\n+\n+// We need to implement this visitor so it'll go everywhere and retrieve items we're interested in\n+// such as impl blocks in const blocks.\n+impl<'a, 'tcx> Visitor<'tcx> for RustdocVisitor<'a, 'tcx> {\n+    type NestedFilter = nested_filter::All;\n+\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.cx.tcx.hir()\n+    }\n+\n+    fn visit_item(&mut self, i: &'tcx hir::Item<'tcx>) {\n+        if self.visit_item_inner(i, None, None) {\n+            walk_item(self, i);\n         }\n     }\n+\n+    fn visit_mod(&mut self, _: &hir::Mod<'tcx>, _: Span, _: hir::HirId) {\n+        // Handled in `visit_item_inner`\n+    }\n+\n+    fn visit_use(&mut self, _: &hir::UsePath<'tcx>, _: hir::HirId) {\n+        // Handled in `visit_item_inner`\n+    }\n+\n+    fn visit_path(&mut self, _: &hir::Path<'tcx>, _: hir::HirId) {\n+        // Handled in `visit_item_inner`\n+    }\n+\n+    fn visit_label(&mut self, _: &rustc_ast::Label) {\n+        // Unneeded.\n+    }\n+\n+    fn visit_infer(&mut self, _: &hir::InferArg) {\n+        // Unneeded.\n+    }\n+\n+    fn visit_lifetime(&mut self, _: &hir::Lifetime) {\n+        // Unneeded.\n+    }\n }"}, {"sha": "7bea079bb84babeff35a6b708ca3b3225582d7b5", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -1 +1 @@\n-f3126500f25114ba4e0ac3e76694dd45a22de56d\n+dffea43fc1102bdfe16d88ed412c23d4f0f08d9d"}, {"sha": "4e6ff28d6ec73dbab24073d176782e09dd1a7011", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/mod.rs", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -81,21 +81,18 @@ impl NewPermission {\n                         protector: None,\n                     }\n                 } else if pointee.is_unpin(*cx.tcx, cx.param_env()) {\n-                    // A regular full mutable reference.\n+                    // A regular full mutable reference. On `FnEntry` this is `noalias` and `dereferenceable`.\n                     NewPermission::Uniform {\n                         perm: Permission::Unique,\n                         access: Some(AccessKind::Write),\n                         protector,\n                     }\n                 } else {\n+                    // `!Unpin` dereferences do not get `noalias` nor `dereferenceable`.\n                     NewPermission::Uniform {\n                         perm: Permission::SharedReadWrite,\n-                        // FIXME: We emit `dereferenceable` for `!Unpin` mutable references, so we\n-                        // should do fake accesses here. But then we run into\n-                        // <https://github.com/rust-lang/unsafe-code-guidelines/issues/381>, so for now\n-                        // we don't do that.\n                         access: None,\n-                        protector,\n+                        protector: None,\n                     }\n                 }\n             }\n@@ -109,6 +106,7 @@ impl NewPermission {\n                 }\n             }\n             ty::Ref(_, _pointee, Mutability::Not) => {\n+                // Shared references. If frozen, these get `noalias` and `dereferenceable`; otherwise neither.\n                 NewPermission::FreezeSensitive {\n                     freeze_perm: Permission::SharedReadOnly,\n                     freeze_access: Some(AccessKind::Read),\n@@ -137,6 +135,31 @@ impl NewPermission {\n         }\n     }\n \n+    fn from_box_ty<'tcx>(\n+        ty: Ty<'tcx>,\n+        kind: RetagKind,\n+        cx: &crate::MiriInterpCx<'_, 'tcx>,\n+    ) -> Self {\n+        // `ty` is not the `Box` but the field of the Box with this pointer (due to allocator handling).\n+        let pointee = ty.builtin_deref(true).unwrap().ty;\n+        if pointee.is_unpin(*cx.tcx, cx.param_env()) {\n+            // A regular box. On `FnEntry` this is `noalias`, but not `dereferenceable` (hence only\n+            // a weak protector).\n+            NewPermission::Uniform {\n+                perm: Permission::Unique,\n+                access: Some(AccessKind::Write),\n+                protector: (kind == RetagKind::FnEntry).then_some(ProtectorKind::WeakProtector),\n+            }\n+        } else {\n+            // `!Unpin` boxes do not get `noalias` nor `dereferenceable`.\n+            NewPermission::Uniform {\n+                perm: Permission::SharedReadWrite,\n+                access: None,\n+                protector: None,\n+            }\n+        }\n+    }\n+\n     fn protector(&self) -> Option<ProtectorKind> {\n         match self {\n             NewPermission::Uniform { protector, .. } => *protector,\n@@ -916,12 +939,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n             fn visit_box(&mut self, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n                 // Boxes get a weak protectors, since they may be deallocated.\n-                let new_perm = NewPermission::Uniform {\n-                    perm: Permission::Unique,\n-                    access: Some(AccessKind::Write),\n-                    protector: (self.kind == RetagKind::FnEntry)\n-                        .then_some(ProtectorKind::WeakProtector),\n-                };\n+                let new_perm = NewPermission::from_box_ty(place.layout.ty, self.kind, self.ecx);\n                 self.retag_ptr_inplace(place, new_perm, self.retag_cause)\n             }\n "}, {"sha": "fd67dccd14df6d826b0767b726fd31f827d37f3d", "filename": "src/tools/miri/tests/fail/stacked_borrows/deallocate_against_protector2.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c8d4073a4490671b05f3b5f5e6810cfdc23a641/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8d4073a4490671b05f3b5f5e6810cfdc23a641/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.rs?ref=6c8d4073a4490671b05f3b5f5e6810cfdc23a641", "patch": "@@ -1,16 +0,0 @@\n-//@error-pattern: /deallocating while item \\[SharedReadWrite for .*\\] is strongly protected/\n-use std::marker::PhantomPinned;\n-\n-pub struct NotUnpin(i32, PhantomPinned);\n-\n-fn inner(x: &mut NotUnpin, f: fn(&mut NotUnpin)) {\n-    // `f` may mutate, but it may not deallocate!\n-    f(x)\n-}\n-\n-fn main() {\n-    inner(Box::leak(Box::new(NotUnpin(0, PhantomPinned))), |x| {\n-        let raw = x as *mut _;\n-        drop(unsafe { Box::from_raw(raw) });\n-    });\n-}"}, {"sha": "47cfa0de7258c1fe0263442c8387a6d7b3d7a7d9", "filename": "src/tools/miri/tests/fail/stacked_borrows/deallocate_against_protector2.stderr", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6c8d4073a4490671b05f3b5f5e6810cfdc23a641/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c8d4073a4490671b05f3b5f5e6810cfdc23a641/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.stderr?ref=6c8d4073a4490671b05f3b5f5e6810cfdc23a641", "patch": "@@ -1,38 +0,0 @@\n-error: Undefined Behavior: deallocating while item [SharedReadWrite for <TAG>] is strongly protected by call ID\n-  --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n-   |\n-LL |     unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item [SharedReadWrite for <TAG>] is strongly protected by call ID\n-   |\n-   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n-   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-   = note: BACKTRACE:\n-   = note: inside `std::alloc::dealloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n-   = note: inside `<std::alloc::Global as std::alloc::Allocator>::deallocate` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n-   = note: inside `alloc::alloc::box_free::<NotUnpin, std::alloc::Global>` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n-   = note: inside `std::ptr::drop_in_place::<std::boxed::Box<NotUnpin>> - shim(Some(std::boxed::Box<NotUnpin>))` at RUSTLIB/core/src/ptr/mod.rs:LL:CC\n-   = note: inside `std::mem::drop::<std::boxed::Box<NotUnpin>>` at RUSTLIB/core/src/mem/mod.rs:LL:CC\n-note: inside closure\n-  --> $DIR/deallocate_against_protector2.rs:LL:CC\n-   |\n-LL |         drop(unsafe { Box::from_raw(raw) });\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: inside `<[closure@$DIR/deallocate_against_protector2.rs:LL:CC] as std::ops::FnOnce<(&mut NotUnpin,)>>::call_once - shim` at RUSTLIB/core/src/ops/function.rs:LL:CC\n-note: inside `inner`\n-  --> $DIR/deallocate_against_protector2.rs:LL:CC\n-   |\n-LL |     f(x)\n-   |     ^^^^\n-note: inside `main`\n-  --> $DIR/deallocate_against_protector2.rs:LL:CC\n-   |\n-LL | /     inner(Box::leak(Box::new(NotUnpin(0, PhantomPinned))), |x| {\n-LL | |         let raw = x as *mut _;\n-LL | |         drop(unsafe { Box::from_raw(raw) });\n-LL | |     });\n-   | |______^\n-\n-note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n-\n-error: aborting due to previous error\n-"}, {"sha": "6994def16a1da3f537c9fb78bdc4a8622c2d13d5", "filename": "src/tools/miri/tests/pass/stacked-borrows/future-self-referential.rs", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Ffuture-self-referential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Ffuture-self-referential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Ffuture-self-referential.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -26,6 +26,19 @@ impl Future for Delay {\n     }\n }\n \n+fn mk_waker() -> Waker {\n+    use std::sync::Arc;\n+\n+    struct MyWaker;\n+    impl Wake for MyWaker {\n+        fn wake(self: Arc<Self>) {\n+            unimplemented!()\n+        }\n+    }\n+\n+    Waker::from(Arc::new(MyWaker))\n+}\n+\n async fn do_stuff() {\n     (&mut Delay::new(1)).await;\n }\n@@ -73,16 +86,7 @@ impl Future for DoStuff {\n }\n \n fn run_fut<T>(fut: impl Future<Output = T>) -> T {\n-    use std::sync::Arc;\n-\n-    struct MyWaker;\n-    impl Wake for MyWaker {\n-        fn wake(self: Arc<Self>) {\n-            unimplemented!()\n-        }\n-    }\n-\n-    let waker = Waker::from(Arc::new(MyWaker));\n+    let waker = mk_waker();\n     let mut context = Context::from_waker(&waker);\n \n     let mut pinned = pin!(fut);\n@@ -94,7 +98,37 @@ fn run_fut<T>(fut: impl Future<Output = T>) -> T {\n     }\n }\n \n+fn self_referential_box() {\n+    let waker = mk_waker();\n+    let cx = &mut Context::from_waker(&waker);\n+\n+    async fn my_fut() -> i32 {\n+        let val = 10;\n+        let val_ref = &val;\n+\n+        let _ = Delay::new(1).await;\n+\n+        *val_ref\n+    }\n+\n+    fn box_poll<F: Future>(\n+        mut f: Pin<Box<F>>,\n+        cx: &mut Context<'_>,\n+    ) -> (Pin<Box<F>>, Poll<F::Output>) {\n+        let p = f.as_mut().poll(cx);\n+        (f, p)\n+    }\n+\n+    let my_fut = Box::pin(my_fut());\n+    let (my_fut, p1) = box_poll(my_fut, cx);\n+    assert!(p1.is_pending());\n+    let (my_fut, p2) = box_poll(my_fut, cx);\n+    assert!(p2.is_ready());\n+    drop(my_fut);\n+}\n+\n fn main() {\n     run_fut(do_stuff());\n     run_fut(DoStuff::new());\n+    self_referential_box();\n }"}, {"sha": "8e78efa73c751578c9c3b7849553bb62fcd32e31", "filename": "src/tools/miri/tests/pass/stacked-borrows/stacked-borrows.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstacked-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstacked-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstacked-borrows.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -19,6 +19,7 @@ fn main() {\n     array_casts();\n     mut_below_shr();\n     wide_raw_ptr_in_tuple();\n+    not_unpin_not_protected();\n }\n \n // Make sure that reading from an `&mut` does, like reborrowing to `&`,\n@@ -219,3 +220,22 @@ fn wide_raw_ptr_in_tuple() {\n     // Make sure the fn ptr part of the vtable is still fine.\n     r.type_id();\n }\n+\n+fn not_unpin_not_protected() {\n+    // `&mut !Unpin`, at least for now, does not get `noalias` nor `dereferenceable`, so we also\n+    // don't add protectors. (We could, but until we have a better idea for where we want to go with\n+    // the self-referntial-generator situation, it does not seem worth the potential trouble.)\n+    use std::marker::PhantomPinned;\n+\n+    pub struct NotUnpin(i32, PhantomPinned);\n+\n+    fn inner(x: &mut NotUnpin, f: fn(&mut NotUnpin)) {\n+        // `f` may mutate, but it may not deallocate!\n+        f(x)\n+    }\n+\n+    inner(Box::leak(Box::new(NotUnpin(0, PhantomPinned))), |x| {\n+        let raw = x as *mut _;\n+        drop(unsafe { Box::from_raw(raw) });\n+    });\n+}"}, {"sha": "7978d8cba95412cb3ef9c51b8d1a40ec5b982294", "filename": "src/tools/rustfmt/src/macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -13,7 +13,7 @@ use std::collections::HashMap;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n \n use rustc_ast::token::{BinOpToken, Delimiter, Token, TokenKind};\n-use rustc_ast::tokenstream::{Cursor, TokenStream, TokenTree};\n+use rustc_ast::tokenstream::{TokenStream, TokenTree, TokenTreeCursor};\n use rustc_ast::{ast, ptr};\n use rustc_ast_pretty::pprust;\n use rustc_span::{\n@@ -736,7 +736,7 @@ impl MacroArgParser {\n         self.buf.clear();\n     }\n \n-    fn add_meta_variable(&mut self, iter: &mut Cursor) -> Option<()> {\n+    fn add_meta_variable(&mut self, iter: &mut TokenTreeCursor) -> Option<()> {\n         match iter.next() {\n             Some(TokenTree::Token(\n                 Token {\n@@ -768,7 +768,7 @@ impl MacroArgParser {\n         &mut self,\n         inner: Vec<ParsedMacroArg>,\n         delim: Delimiter,\n-        iter: &mut Cursor,\n+        iter: &mut TokenTreeCursor,\n     ) -> Option<()> {\n         let mut buffer = String::new();\n         let mut first = true;\n@@ -1121,7 +1121,7 @@ pub(crate) fn macro_style(mac: &ast::MacCall, context: &RewriteContext<'_>) -> D\n // Currently we do not attempt to parse any further than that.\n #[derive(new)]\n struct MacroParser {\n-    toks: Cursor,\n+    toks: TokenTreeCursor,\n }\n \n impl MacroParser {"}, {"sha": "0c62e0d35e36d91624e2ac519e56f1cc72d9c91e", "filename": "tests/codegen/function-arguments-noopt.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fcodegen%2Ffunction-arguments-noopt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fcodegen%2Ffunction-arguments-noopt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Ffunction-arguments-noopt.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -29,6 +29,12 @@ pub fn borrow(x: &i32) -> &i32 {\n   x\n }\n \n+// CHECK: align 4 {{i32\\*|ptr}} @borrow_mut({{i32\\*|ptr}} align 4 %x)\n+#[no_mangle]\n+pub fn borrow_mut(x: &mut i32) -> &mut i32 {\n+  x\n+}\n+\n // CHECK-LABEL: @borrow_call\n #[no_mangle]\n pub fn borrow_call(x: &i32, f: fn(&i32) -> &i32) -> &i32 {"}, {"sha": "96dfde18683e34b2c3ab452a79920edd040a72a1", "filename": "tests/codegen/function-arguments.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Ffunction-arguments.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -85,6 +85,12 @@ pub fn option_nonzero_int(x: Option<NonZeroU64>) -> Option<NonZeroU64> {\n pub fn readonly_borrow(_: &i32) {\n }\n \n+// CHECK: noundef align 4 dereferenceable(4) {{i32\\*|ptr}} @readonly_borrow_ret()\n+#[no_mangle]\n+pub fn readonly_borrow_ret() -> &'static i32 {\n+  loop {}\n+}\n+\n // CHECK: @static_borrow({{i32\\*|ptr}} noalias noundef readonly align 4 dereferenceable(4) %_1)\n // static borrow may be captured\n #[no_mangle]\n@@ -115,9 +121,17 @@ pub fn mutable_unsafe_borrow(_: &mut UnsafeInner) {\n pub fn mutable_borrow(_: &mut i32) {\n }\n \n+// CHECK: noundef align 4 dereferenceable(4) {{i32\\*|ptr}} @mutable_borrow_ret()\n+#[no_mangle]\n+pub fn mutable_borrow_ret() -> &'static mut i32 {\n+  loop {}\n+}\n+\n #[no_mangle]\n-// CHECK: @mutable_notunpin_borrow({{i32\\*|ptr}} noundef align 4 dereferenceable(4) %_1)\n+// CHECK: @mutable_notunpin_borrow({{i32\\*|ptr}} noundef nonnull align 4 %_1)\n // This one is *not* `noalias` because it might be self-referential.\n+// It is also not `dereferenceable` due to\n+// <https://github.com/rust-lang/unsafe-code-guidelines/issues/381>.\n pub fn mutable_notunpin_borrow(_: &mut NotUnpin) {\n }\n \n@@ -167,6 +181,12 @@ pub fn _box(x: Box<i32>) -> Box<i32> {\n   x\n }\n \n+// CHECK: noundef nonnull align 4 {{i32\\*|ptr}} @notunpin_box({{i32\\*|ptr}} noundef nonnull align 4 %x)\n+#[no_mangle]\n+pub fn notunpin_box(x: Box<NotUnpin>) -> Box<NotUnpin> {\n+  x\n+}\n+\n // CHECK: @struct_return({{%S\\*|ptr}} noalias nocapture noundef sret(%S) dereferenceable(32){{( %0)?}})\n #[no_mangle]\n pub fn struct_return() -> S {\n@@ -233,12 +253,12 @@ pub fn trait_raw(_: *const dyn Drop) {\n \n // CHECK: @trait_box({{\\{\\}\\*|ptr}} noalias noundef nonnull align 1{{( %0)?}}, {{.+}} noalias noundef readonly align {{.*}} dereferenceable({{.*}}){{( %1)?}})\n #[no_mangle]\n-pub fn trait_box(_: Box<dyn Drop>) {\n+pub fn trait_box(_: Box<dyn Drop + Unpin>) {\n }\n \n // CHECK: { {{i8\\*|ptr}}, {{i8\\*|ptr}} } @trait_option({{i8\\*|ptr}} noalias noundef align 1 %x.0, {{i8\\*|ptr}} %x.1)\n #[no_mangle]\n-pub fn trait_option(x: Option<Box<dyn Drop>>) -> Option<Box<dyn Drop>> {\n+pub fn trait_option(x: Option<Box<dyn Drop + Unpin>>) -> Option<Box<dyn Drop + Unpin>> {\n   x\n }\n "}, {"sha": "accb504c088ef83a59712586f62a954d1e2084c4", "filename": "tests/mir-opt/building/async_await.a-{closure#0}.generator_resume.0.mir", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fbuilding%2Fasync_await.a-%7Bclosure%230%7D.generator_resume.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fbuilding%2Fasync_await.a-%7Bclosure%230%7D.generator_resume.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fasync_await.a-%7Bclosure%230%7D.generator_resume.0.mir?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -24,9 +24,7 @@ fn a::{closure#0}(_1: Pin<&mut [async fn body@$DIR/async_await.rs:11:14: 11:16]>\n     bb1: {\n         _4 = move _2;                    // scope 0 at $DIR/async_await.rs:+0:14: +0:16\n         _3 = const ();                   // scope 0 at $DIR/async_await.rs:+0:14: +0:16\n-        Deinit(_0);                      // scope 0 at $DIR/async_await.rs:+0:16: +0:16\n-        ((_0 as Ready).0: ()) = move _3; // scope 0 at $DIR/async_await.rs:+0:16: +0:16\n-        discriminant(_0) = 0;            // scope 0 at $DIR/async_await.rs:+0:16: +0:16\n+        _0 = Poll::<()>::Ready(move _3); // scope 0 at $DIR/async_await.rs:+0:16: +0:16\n         discriminant((*(_1.0: &mut [async fn body@$DIR/async_await.rs:11:14: 11:16]))) = 1; // scope 0 at $DIR/async_await.rs:+0:16: +0:16\n         return;                          // scope 0 at $DIR/async_await.rs:+0:16: +0:16\n     }"}, {"sha": "ad4e5c6fcfd72e99795e0ac6bff1a69e51b7a54a", "filename": "tests/mir-opt/building/async_await.b-{closure#0}.generator_resume.0.mir", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fbuilding%2Fasync_await.b-%7Bclosure%230%7D.generator_resume.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fbuilding%2Fasync_await.b-%7Bclosure%230%7D.generator_resume.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fasync_await.b-%7Bclosure%230%7D.generator_resume.0.mir?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -167,8 +167,7 @@ fn b::{closure#0}(_1: Pin<&mut [async fn body@$DIR/async_await.rs:14:18: 17:2]>,\n         StorageLive(_19);                // scope 1 at $DIR/async_await.rs:+1:8: +1:14\n         StorageLive(_20);                // scope 1 at $DIR/async_await.rs:+1:8: +1:14\n         _20 = ();                        // scope 1 at $DIR/async_await.rs:+1:8: +1:14\n-        Deinit(_0);                      // scope 1 at $DIR/async_await.rs:+1:8: +1:14\n-        discriminant(_0) = 1;            // scope 1 at $DIR/async_await.rs:+1:8: +1:14\n+        _0 = Poll::<()>::Pending;        // scope 1 at $DIR/async_await.rs:+1:8: +1:14\n         discriminant((*(_1.0: &mut [async fn body@$DIR/async_await.rs:14:18: 17:2]))) = 3; // scope 1 at $DIR/async_await.rs:+1:8: +1:14\n         return;                          // scope 1 at $DIR/async_await.rs:+1:8: +1:14\n     }\n@@ -276,8 +275,7 @@ fn b::{closure#0}(_1: Pin<&mut [async fn body@$DIR/async_await.rs:14:18: 17:2]>,\n         StorageLive(_35);                // scope 4 at $DIR/async_await.rs:+2:8: +2:14\n         StorageLive(_36);                // scope 4 at $DIR/async_await.rs:+2:8: +2:14\n         _36 = ();                        // scope 4 at $DIR/async_await.rs:+2:8: +2:14\n-        Deinit(_0);                      // scope 4 at $DIR/async_await.rs:+2:8: +2:14\n-        discriminant(_0) = 1;            // scope 4 at $DIR/async_await.rs:+2:8: +2:14\n+        _0 = Poll::<()>::Pending;        // scope 4 at $DIR/async_await.rs:+2:8: +2:14\n         discriminant((*(_1.0: &mut [async fn body@$DIR/async_await.rs:14:18: 17:2]))) = 4; // scope 4 at $DIR/async_await.rs:+2:8: +2:14\n         return;                          // scope 4 at $DIR/async_await.rs:+2:8: +2:14\n     }\n@@ -317,9 +315,7 @@ fn b::{closure#0}(_1: Pin<&mut [async fn body@$DIR/async_await.rs:14:18: 17:2]>,\n     }\n \n     bb26: {\n-        Deinit(_0);                      // scope 0 at $DIR/async_await.rs:+3:2: +3:2\n-        ((_0 as Ready).0: ()) = move _37; // scope 0 at $DIR/async_await.rs:+3:2: +3:2\n-        discriminant(_0) = 0;            // scope 0 at $DIR/async_await.rs:+3:2: +3:2\n+        _0 = Poll::<()>::Ready(move _37); // scope 0 at $DIR/async_await.rs:+3:2: +3:2\n         discriminant((*(_1.0: &mut [async fn body@$DIR/async_await.rs:14:18: 17:2]))) = 1; // scope 0 at $DIR/async_await.rs:+3:2: +3:2\n         return;                          // scope 0 at $DIR/async_await.rs:+3:2: +3:2\n     }"}, {"sha": "20b0fb9643ee622bf73b10d3981f15769d9a7e73", "filename": "tests/mir-opt/combine_clone_of_primitives.{impl#0}-clone.InstCombine.diff", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fcombine_clone_of_primitives.%7Bimpl%230%7D-clone.InstCombine.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fcombine_clone_of_primitives.%7Bimpl%230%7D-clone.InstCombine.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcombine_clone_of_primitives.%7Bimpl%230%7D-clone.InstCombine.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -61,10 +61,7 @@\n   \n       bb3: {\n           StorageDead(_9);                 // scope 0 at $DIR/combine_clone_of_primitives.rs:10:15: 10:16\n-          Deinit(_0);                      // scope 0 at $DIR/combine_clone_of_primitives.rs:+0:10: +0:15\n-          (_0.0: T) = move _2;             // scope 0 at $DIR/combine_clone_of_primitives.rs:+0:10: +0:15\n-          (_0.1: u64) = move _5;           // scope 0 at $DIR/combine_clone_of_primitives.rs:+0:10: +0:15\n-          (_0.2: [f32; 3]) = move _8;      // scope 0 at $DIR/combine_clone_of_primitives.rs:+0:10: +0:15\n+          _0 = MyThing::<T> { v: move _2, i: move _5, a: move _8 }; // scope 0 at $DIR/combine_clone_of_primitives.rs:+0:10: +0:15\n           StorageDead(_8);                 // scope 0 at $DIR/combine_clone_of_primitives.rs:+0:14: +0:15\n           StorageDead(_5);                 // scope 0 at $DIR/combine_clone_of_primitives.rs:+0:14: +0:15\n           StorageDead(_2);                 // scope 0 at $DIR/combine_clone_of_primitives.rs:+0:14: +0:15"}, {"sha": "9b69f79c28ee72978d69625ae1371f73926e350e", "filename": "tests/mir-opt/const_allocation.main.ConstProp.after.32bit.mir", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.32bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.32bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.32bit.mir?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -26,30 +26,30 @@ alloc1 (static: FOO, size: 8, align: 4) {\n \n alloc18 (size: 48, align: 4) {\n     0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc5\u2500\u2500\u257c 00 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x10 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc9\u2500\u2500\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500alloc14\u2500\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n+    0x10 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc8\u2500\u2500\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500alloc13\u2500\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n }\n \n alloc5 (size: 0, align: 4) {}\n \n-alloc9 (size: 16, align: 4) {\n-    \u257e\u2500alloc8\u2500\u2500\u257c 03 00 00 00 \u257e\u2500alloc10\u2500\u257c 03 00 00 00 \u2502 \u257e\u2500\u2500\u257c....\u257e\u2500\u2500\u257c....\n+alloc8 (size: 16, align: 4) {\n+    \u257e\u2500alloc9\u2500\u2500\u257c 03 00 00 00 \u257e\u2500alloc10\u2500\u257c 03 00 00 00 \u2502 \u257e\u2500\u2500\u257c....\u257e\u2500\u2500\u257c....\n }\n \n-alloc8 (size: 3, align: 1) {\n+alloc9 (size: 3, align: 1) {\n     66 6f 6f                                        \u2502 foo\n }\n \n alloc10 (size: 3, align: 1) {\n     62 61 72                                        \u2502 bar\n }\n \n-alloc14 (size: 24, align: 4) {\n-    0x00 \u2502 \u257e\u2500alloc13\u2500\u257c 03 00 00 00 \u257e\u2500alloc15\u2500\u257c 03 00 00 00 \u2502 \u257e\u2500\u2500\u257c....\u257e\u2500\u2500\u257c....\n+alloc13 (size: 24, align: 4) {\n+    0x00 \u2502 \u257e\u2500alloc14\u2500\u257c 03 00 00 00 \u257e\u2500alloc15\u2500\u257c 03 00 00 00 \u2502 \u257e\u2500\u2500\u257c....\u257e\u2500\u2500\u257c....\n     0x10 \u2502 \u257e\u2500alloc16\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n }\n \n-alloc13 (size: 3, align: 1) {\n+alloc14 (size: 3, align: 1) {\n     6d 65 68                                        \u2502 meh\n }\n "}, {"sha": "d0f196e724581e0a1a0a2512864220d50d7bcde8", "filename": "tests/mir-opt/const_allocation.main.ConstProp.after.64bit.mir", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.64bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.64bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.64bit.mir?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -27,33 +27,33 @@ alloc1 (static: FOO, size: 16, align: 8) {\n alloc18 (size: 72, align: 8) {\n     0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc5\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x10 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 __ __ __ __ \u2502 ............\u2591\u2591\u2591\u2591\n-    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc9\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc14\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc8\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc13\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x40 \u2502 03 00 00 00 00 00 00 00                         \u2502 ........\n }\n \n alloc5 (size: 0, align: 8) {}\n \n-alloc9 (size: 32, align: 8) {\n-    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc8\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+alloc8 (size: 32, align: 8) {\n+    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc9\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n     0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc10\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n }\n \n-alloc8 (size: 3, align: 1) {\n+alloc9 (size: 3, align: 1) {\n     66 6f 6f                                        \u2502 foo\n }\n \n alloc10 (size: 3, align: 1) {\n     62 61 72                                        \u2502 bar\n }\n \n-alloc14 (size: 48, align: 8) {\n-    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc13\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+alloc13 (size: 48, align: 8) {\n+    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc14\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n     0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc15\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n     0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc16\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n }\n \n-alloc13 (size: 3, align: 1) {\n+alloc14 (size: 3, align: 1) {\n     6d 65 68                                        \u2502 meh\n }\n "}, {"sha": "f1f53a481655ca6e3ec7685527f2c440acec5ff8", "filename": "tests/mir-opt/const_debuginfo.main.ConstDebugInfo.diff", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_debuginfo.main.ConstDebugInfo.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_debuginfo.main.ConstDebugInfo.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_debuginfo.main.ConstDebugInfo.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -56,11 +56,8 @@\n       }\n   \n       bb0: {\n-          StorageLive(_1);                 // scope 0 at $DIR/const_debuginfo.rs:+1:9: +1:10\n           _1 = const 1_u8;                 // scope 0 at $DIR/const_debuginfo.rs:+1:13: +1:16\n-          StorageLive(_2);                 // scope 1 at $DIR/const_debuginfo.rs:+2:9: +2:10\n           _2 = const 2_u8;                 // scope 1 at $DIR/const_debuginfo.rs:+2:13: +2:16\n-          StorageLive(_3);                 // scope 2 at $DIR/const_debuginfo.rs:+3:9: +3:10\n           _3 = const 3_u8;                 // scope 2 at $DIR/const_debuginfo.rs:+3:13: +3:16\n           StorageLive(_4);                 // scope 3 at $DIR/const_debuginfo.rs:+4:9: +4:12\n           StorageLive(_5);                 // scope 3 at $DIR/const_debuginfo.rs:+4:15: +4:20\n@@ -75,33 +72,16 @@\n           StorageLive(_14);                // scope 5 at $DIR/const_debuginfo.rs:+8:9: +8:10\n           StorageLive(_15);                // scope 5 at $DIR/const_debuginfo.rs:+8:9: +8:10\n           StorageLive(_16);                // scope 5 at $DIR/const_debuginfo.rs:+8:9: +8:10\n-          Deinit(_14);                     // scope 5 at $DIR/const_debuginfo.rs:+8:13: +8:34\n-          Deinit(_15);                     // scope 5 at $DIR/const_debuginfo.rs:+8:13: +8:34\n-          Deinit(_16);                     // scope 5 at $DIR/const_debuginfo.rs:+8:13: +8:34\n           _14 = const true;                // scope 5 at $DIR/const_debuginfo.rs:+8:13: +8:34\n           _15 = const false;               // scope 5 at $DIR/const_debuginfo.rs:+8:13: +8:34\n           _16 = const 123_u32;             // scope 5 at $DIR/const_debuginfo.rs:+8:13: +8:34\n           StorageLive(_10);                // scope 6 at $DIR/const_debuginfo.rs:+10:9: +10:10\n-          Deinit(_10);                     // scope 6 at $DIR/const_debuginfo.rs:+10:13: +10:24\n-          ((_10 as Some).0: u16) = const 99_u16; // scope 6 at $DIR/const_debuginfo.rs:+10:13: +10:24\n-          discriminant(_10) = 1;           // scope 6 at $DIR/const_debuginfo.rs:+10:13: +10:24\n-          StorageLive(_17);                // scope 7 at $DIR/const_debuginfo.rs:+12:9: +12:10\n-          StorageLive(_18);                // scope 7 at $DIR/const_debuginfo.rs:+12:9: +12:10\n-          Deinit(_17);                     // scope 7 at $DIR/const_debuginfo.rs:+12:13: +12:35\n-          Deinit(_18);                     // scope 7 at $DIR/const_debuginfo.rs:+12:13: +12:35\n+          _10 = Option::<u16>::Some(const 99_u16); // scope 6 at $DIR/const_debuginfo.rs:+10:13: +10:24\n           _17 = const 32_u32;              // scope 7 at $DIR/const_debuginfo.rs:+12:13: +12:35\n           _18 = const 32_u32;              // scope 7 at $DIR/const_debuginfo.rs:+12:13: +12:35\n           StorageLive(_11);                // scope 8 at $DIR/const_debuginfo.rs:+13:9: +13:10\n-          StorageLive(_12);                // scope 8 at $DIR/const_debuginfo.rs:+13:13: +13:16\n-          _12 = const 32_u32;              // scope 8 at $DIR/const_debuginfo.rs:+13:13: +13:16\n-          StorageLive(_13);                // scope 8 at $DIR/const_debuginfo.rs:+13:19: +13:22\n-          _13 = const 32_u32;              // scope 8 at $DIR/const_debuginfo.rs:+13:19: +13:22\n           _11 = const 64_u32;              // scope 8 at $DIR/const_debuginfo.rs:+13:13: +13:22\n-          StorageDead(_13);                // scope 8 at $DIR/const_debuginfo.rs:+13:21: +13:22\n-          StorageDead(_12);                // scope 8 at $DIR/const_debuginfo.rs:+13:21: +13:22\n           StorageDead(_11);                // scope 8 at $DIR/const_debuginfo.rs:+14:1: +14:2\n-          StorageDead(_17);                // scope 7 at $DIR/const_debuginfo.rs:+14:1: +14:2\n-          StorageDead(_18);                // scope 7 at $DIR/const_debuginfo.rs:+14:1: +14:2\n           StorageDead(_10);                // scope 6 at $DIR/const_debuginfo.rs:+14:1: +14:2\n           StorageDead(_14);                // scope 5 at $DIR/const_debuginfo.rs:+14:1: +14:2\n           StorageDead(_15);                // scope 5 at $DIR/const_debuginfo.rs:+14:1: +14:2"}, {"sha": "4dc98f8567402fc05bc9f2261f68ffce550cf7e4", "filename": "tests/mir-opt/const_goto_storage.match_nested_if.ConstGoto.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_goto_storage.match_nested_if.ConstGoto.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_goto_storage.match_nested_if.ConstGoto.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_goto_storage.match_nested_if.ConstGoto.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -17,7 +17,7 @@\n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/const_goto_storage.rs:+1:9: +1:12\n -         StorageLive(_2);                 // scope 0 at $DIR/const_goto_storage.rs:+1:21: +1:23\n--         Deinit(_2);                      // scope 0 at $DIR/const_goto_storage.rs:+1:21: +1:23\n+-         _2 = ();                         // scope 0 at $DIR/const_goto_storage.rs:+1:21: +1:23\n -         StorageLive(_3);                 // scope 0 at $DIR/const_goto_storage.rs:+2:15: +6:10\n -         StorageLive(_4);                 // scope 0 at $DIR/const_goto_storage.rs:+2:18: +2:76\n -         StorageLive(_5);                 // scope 0 at $DIR/const_goto_storage.rs:+2:21: +2:52"}, {"sha": "6ac460db86f8114e9e8c3ae6c0e18edfe36064e2", "filename": "tests/mir-opt/const_prop/aggregate.foo.ConstProp.diff", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Faggregate.foo.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Faggregate.foo.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Faggregate.foo.ConstProp.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -0,0 +1,55 @@\n+- // MIR for `foo` before ConstProp\n++ // MIR for `foo` after ConstProp\n+  \n+  fn foo(_1: u8) -> () {\n+      debug x => _1;                       // in scope 0 at $DIR/aggregate.rs:+0:8: +0:9\n+      let mut _0: ();                      // return place in scope 0 at $DIR/aggregate.rs:+0:15: +0:15\n+      let _2: i32;                         // in scope 0 at $DIR/aggregate.rs:+2:9: +2:14\n+      let mut _3: i32;                     // in scope 0 at $DIR/aggregate.rs:+2:17: +2:25\n+      let mut _4: (i32, u8);               // in scope 0 at $DIR/aggregate.rs:+2:17: +2:23\n+      let mut _5: u8;                      // in scope 0 at $DIR/aggregate.rs:+2:21: +2:22\n+      let mut _7: i32;                     // in scope 0 at $DIR/aggregate.rs:+3:18: +3:26\n+      let mut _8: (u8, i32);               // in scope 0 at $DIR/aggregate.rs:+3:18: +3:24\n+      let mut _9: u8;                      // in scope 0 at $DIR/aggregate.rs:+3:19: +3:20\n+      scope 1 {\n+          debug first => _2;               // in scope 1 at $DIR/aggregate.rs:+2:9: +2:14\n+          let _6: i32;                     // in scope 1 at $DIR/aggregate.rs:+3:9: +3:15\n+          scope 2 {\n+              debug second => _6;          // in scope 2 at $DIR/aggregate.rs:+3:9: +3:15\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/aggregate.rs:+2:9: +2:14\n+          StorageLive(_3);                 // scope 0 at $DIR/aggregate.rs:+2:17: +2:25\n+          StorageLive(_4);                 // scope 0 at $DIR/aggregate.rs:+2:17: +2:23\n+          StorageLive(_5);                 // scope 0 at $DIR/aggregate.rs:+2:21: +2:22\n+          _5 = _1;                         // scope 0 at $DIR/aggregate.rs:+2:21: +2:22\n+          _4 = (const 0_i32, move _5);     // scope 0 at $DIR/aggregate.rs:+2:17: +2:23\n+          StorageDead(_5);                 // scope 0 at $DIR/aggregate.rs:+2:22: +2:23\n+-         _3 = (_4.0: i32);                // scope 0 at $DIR/aggregate.rs:+2:17: +2:25\n+-         _2 = Add(move _3, const 1_i32);  // scope 0 at $DIR/aggregate.rs:+2:17: +2:29\n++         _3 = const 0_i32;                // scope 0 at $DIR/aggregate.rs:+2:17: +2:25\n++         _2 = const 1_i32;                // scope 0 at $DIR/aggregate.rs:+2:17: +2:29\n+          StorageDead(_3);                 // scope 0 at $DIR/aggregate.rs:+2:28: +2:29\n+          StorageDead(_4);                 // scope 0 at $DIR/aggregate.rs:+2:29: +2:30\n+          StorageLive(_6);                 // scope 1 at $DIR/aggregate.rs:+3:9: +3:15\n+          StorageLive(_7);                 // scope 1 at $DIR/aggregate.rs:+3:18: +3:26\n+          StorageLive(_8);                 // scope 1 at $DIR/aggregate.rs:+3:18: +3:24\n+          StorageLive(_9);                 // scope 1 at $DIR/aggregate.rs:+3:19: +3:20\n+          _9 = _1;                         // scope 1 at $DIR/aggregate.rs:+3:19: +3:20\n+          _8 = (move _9, const 1_i32);     // scope 1 at $DIR/aggregate.rs:+3:18: +3:24\n+          StorageDead(_9);                 // scope 1 at $DIR/aggregate.rs:+3:23: +3:24\n+-         _7 = (_8.1: i32);                // scope 1 at $DIR/aggregate.rs:+3:18: +3:26\n+-         _6 = Add(move _7, const 2_i32);  // scope 1 at $DIR/aggregate.rs:+3:18: +3:30\n++         _7 = const 1_i32;                // scope 1 at $DIR/aggregate.rs:+3:18: +3:26\n++         _6 = const 3_i32;                // scope 1 at $DIR/aggregate.rs:+3:18: +3:30\n+          StorageDead(_7);                 // scope 1 at $DIR/aggregate.rs:+3:29: +3:30\n+          StorageDead(_8);                 // scope 1 at $DIR/aggregate.rs:+3:30: +3:31\n+          _0 = const ();                   // scope 0 at $DIR/aggregate.rs:+0:15: +4:2\n+          StorageDead(_6);                 // scope 1 at $DIR/aggregate.rs:+4:1: +4:2\n+          StorageDead(_2);                 // scope 0 at $DIR/aggregate.rs:+4:1: +4:2\n+          return;                          // scope 0 at $DIR/aggregate.rs:+4:2: +4:2\n+      }\n+  }\n+  "}, {"sha": "2ef6d74e52846abc966636764c231d6284b16110", "filename": "tests/mir-opt/const_prop/aggregate.foo.PreCodegen.after.mir", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Faggregate.foo.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Faggregate.foo.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Faggregate.foo.PreCodegen.after.mir?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -0,0 +1,49 @@\n+// MIR for `foo` after PreCodegen\n+\n+fn foo(_1: u8) -> () {\n+    debug x => _1;                       // in scope 0 at $DIR/aggregate.rs:+0:8: +0:9\n+    let mut _0: ();                      // return place in scope 0 at $DIR/aggregate.rs:+0:15: +0:15\n+    let _2: i32;                         // in scope 0 at $DIR/aggregate.rs:+2:9: +2:14\n+    let mut _3: i32;                     // in scope 0 at $DIR/aggregate.rs:+2:17: +2:25\n+    let mut _4: (i32, u8);               // in scope 0 at $DIR/aggregate.rs:+2:17: +2:23\n+    let mut _5: u8;                      // in scope 0 at $DIR/aggregate.rs:+2:21: +2:22\n+    let mut _7: i32;                     // in scope 0 at $DIR/aggregate.rs:+3:18: +3:26\n+    let mut _8: (u8, i32);               // in scope 0 at $DIR/aggregate.rs:+3:18: +3:24\n+    let mut _9: u8;                      // in scope 0 at $DIR/aggregate.rs:+3:19: +3:20\n+    scope 1 {\n+        debug first => _2;               // in scope 1 at $DIR/aggregate.rs:+2:9: +2:14\n+        let _6: i32;                     // in scope 1 at $DIR/aggregate.rs:+3:9: +3:15\n+        scope 2 {\n+            debug second => _6;          // in scope 2 at $DIR/aggregate.rs:+3:9: +3:15\n+        }\n+    }\n+\n+    bb0: {\n+        StorageLive(_2);                 // scope 0 at $DIR/aggregate.rs:+2:9: +2:14\n+        StorageLive(_3);                 // scope 0 at $DIR/aggregate.rs:+2:17: +2:25\n+        StorageLive(_4);                 // scope 0 at $DIR/aggregate.rs:+2:17: +2:23\n+        StorageLive(_5);                 // scope 0 at $DIR/aggregate.rs:+2:21: +2:22\n+        _5 = _1;                         // scope 0 at $DIR/aggregate.rs:+2:21: +2:22\n+        _4 = (const 0_i32, move _5);     // scope 0 at $DIR/aggregate.rs:+2:17: +2:23\n+        StorageDead(_5);                 // scope 0 at $DIR/aggregate.rs:+2:22: +2:23\n+        _3 = const 0_i32;                // scope 0 at $DIR/aggregate.rs:+2:17: +2:25\n+        _2 = const 1_i32;                // scope 0 at $DIR/aggregate.rs:+2:17: +2:29\n+        StorageDead(_3);                 // scope 0 at $DIR/aggregate.rs:+2:28: +2:29\n+        StorageDead(_4);                 // scope 0 at $DIR/aggregate.rs:+2:29: +2:30\n+        StorageLive(_6);                 // scope 1 at $DIR/aggregate.rs:+3:9: +3:15\n+        StorageLive(_7);                 // scope 1 at $DIR/aggregate.rs:+3:18: +3:26\n+        StorageLive(_8);                 // scope 1 at $DIR/aggregate.rs:+3:18: +3:24\n+        StorageLive(_9);                 // scope 1 at $DIR/aggregate.rs:+3:19: +3:20\n+        _9 = _1;                         // scope 1 at $DIR/aggregate.rs:+3:19: +3:20\n+        _8 = (move _9, const 1_i32);     // scope 1 at $DIR/aggregate.rs:+3:18: +3:24\n+        StorageDead(_9);                 // scope 1 at $DIR/aggregate.rs:+3:23: +3:24\n+        _7 = const 1_i32;                // scope 1 at $DIR/aggregate.rs:+3:18: +3:26\n+        _6 = const 3_i32;                // scope 1 at $DIR/aggregate.rs:+3:18: +3:30\n+        StorageDead(_7);                 // scope 1 at $DIR/aggregate.rs:+3:29: +3:30\n+        StorageDead(_8);                 // scope 1 at $DIR/aggregate.rs:+3:30: +3:31\n+        _0 = const ();                   // scope 0 at $DIR/aggregate.rs:+0:15: +4:2\n+        StorageDead(_6);                 // scope 1 at $DIR/aggregate.rs:+4:1: +4:2\n+        StorageDead(_2);                 // scope 0 at $DIR/aggregate.rs:+4:1: +4:2\n+        return;                          // scope 0 at $DIR/aggregate.rs:+4:2: +4:2\n+    }\n+}"}, {"sha": "f6e58955b4f607bda88d14caaad97155edd15853", "filename": "tests/mir-opt/const_prop/aggregate.main.ConstProp.diff", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Faggregate.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Faggregate.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Faggregate.main.ConstProp.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -3,9 +3,11 @@\n   \n   fn main() -> () {\n       let mut _0: ();                      // return place in scope 0 at $DIR/aggregate.rs:+0:11: +0:11\n-      let _1: i32;                         // in scope 0 at $DIR/aggregate.rs:+1:9: +1:10\n-      let mut _2: i32;                     // in scope 0 at $DIR/aggregate.rs:+1:13: +1:24\n-      let mut _3: (i32, i32, i32);         // in scope 0 at $DIR/aggregate.rs:+1:13: +1:22\n+      let _1: u8;                          // in scope 0 at $DIR/aggregate.rs:+1:9: +1:10\n+      let mut _2: u8;                      // in scope 0 at $DIR/aggregate.rs:+1:13: +1:24\n+      let mut _3: (i32, u8, i32);          // in scope 0 at $DIR/aggregate.rs:+1:13: +1:22\n+      let _4: ();                          // in scope 0 at $DIR/aggregate.rs:+2:5: +2:11\n+      let mut _5: u8;                      // in scope 0 at $DIR/aggregate.rs:+2:9: +2:10\n       scope 1 {\n           debug x => _1;                   // in scope 1 at $DIR/aggregate.rs:+1:9: +1:10\n       }\n@@ -14,19 +16,29 @@\n           StorageLive(_1);                 // scope 0 at $DIR/aggregate.rs:+1:9: +1:10\n           StorageLive(_2);                 // scope 0 at $DIR/aggregate.rs:+1:13: +1:24\n           StorageLive(_3);                 // scope 0 at $DIR/aggregate.rs:+1:13: +1:22\n-          Deinit(_3);                      // scope 0 at $DIR/aggregate.rs:+1:13: +1:22\n-          (_3.0: i32) = const 0_i32;       // scope 0 at $DIR/aggregate.rs:+1:13: +1:22\n-          (_3.1: i32) = const 1_i32;       // scope 0 at $DIR/aggregate.rs:+1:13: +1:22\n-          (_3.2: i32) = const 2_i32;       // scope 0 at $DIR/aggregate.rs:+1:13: +1:22\n--         _2 = (_3.1: i32);                // scope 0 at $DIR/aggregate.rs:+1:13: +1:24\n--         _1 = Add(move _2, const 0_i32);  // scope 0 at $DIR/aggregate.rs:+1:13: +1:28\n-+         _2 = const 1_i32;                // scope 0 at $DIR/aggregate.rs:+1:13: +1:24\n-+         _1 = const 1_i32;                // scope 0 at $DIR/aggregate.rs:+1:13: +1:28\n+          _3 = (const 0_i32, const 1_u8, const 2_i32); // scope 0 at $DIR/aggregate.rs:+1:13: +1:22\n+-         _2 = (_3.1: u8);                 // scope 0 at $DIR/aggregate.rs:+1:13: +1:24\n+-         _1 = Add(move _2, const 0_u8);   // scope 0 at $DIR/aggregate.rs:+1:13: +1:28\n++         _2 = const 1_u8;                 // scope 0 at $DIR/aggregate.rs:+1:13: +1:24\n++         _1 = const 1_u8;                 // scope 0 at $DIR/aggregate.rs:+1:13: +1:28\n           StorageDead(_2);                 // scope 0 at $DIR/aggregate.rs:+1:27: +1:28\n           StorageDead(_3);                 // scope 0 at $DIR/aggregate.rs:+1:28: +1:29\n-          _0 = const ();                   // scope 0 at $DIR/aggregate.rs:+0:11: +2:2\n-          StorageDead(_1);                 // scope 0 at $DIR/aggregate.rs:+2:1: +2:2\n-          return;                          // scope 0 at $DIR/aggregate.rs:+2:2: +2:2\n+          StorageLive(_4);                 // scope 1 at $DIR/aggregate.rs:+2:5: +2:11\n+          StorageLive(_5);                 // scope 1 at $DIR/aggregate.rs:+2:9: +2:10\n+-         _5 = _1;                         // scope 1 at $DIR/aggregate.rs:+2:9: +2:10\n++         _5 = const 1_u8;                 // scope 1 at $DIR/aggregate.rs:+2:9: +2:10\n+          _4 = foo(move _5) -> bb1;        // scope 1 at $DIR/aggregate.rs:+2:5: +2:11\n+                                           // mir::Constant\n+                                           // + span: $DIR/aggregate.rs:8:5: 8:8\n+                                           // + literal: Const { ty: fn(u8) {foo}, val: Value(<ZST>) }\n+      }\n+  \n+      bb1: {\n+          StorageDead(_5);                 // scope 1 at $DIR/aggregate.rs:+2:10: +2:11\n+          StorageDead(_4);                 // scope 1 at $DIR/aggregate.rs:+2:11: +2:12\n+          _0 = const ();                   // scope 0 at $DIR/aggregate.rs:+0:11: +3:2\n+          StorageDead(_1);                 // scope 0 at $DIR/aggregate.rs:+3:1: +3:2\n+          return;                          // scope 0 at $DIR/aggregate.rs:+3:2: +3:2\n       }\n   }\n   "}, {"sha": "4706af92cba982460cb000b76ce91829be11aa13", "filename": "tests/mir-opt/const_prop/aggregate.main.PreCodegen.after.mir", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Faggregate.main.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Faggregate.main.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Faggregate.main.PreCodegen.after.mir?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -2,9 +2,11 @@\n \n fn main() -> () {\n     let mut _0: ();                      // return place in scope 0 at $DIR/aggregate.rs:+0:11: +0:11\n-    let _1: i32;                         // in scope 0 at $DIR/aggregate.rs:+1:9: +1:10\n-    let mut _2: i32;                     // in scope 0 at $DIR/aggregate.rs:+1:13: +1:24\n-    let mut _3: (i32, i32, i32);         // in scope 0 at $DIR/aggregate.rs:+1:13: +1:22\n+    let _1: u8;                          // in scope 0 at $DIR/aggregate.rs:+1:9: +1:10\n+    let mut _2: u8;                      // in scope 0 at $DIR/aggregate.rs:+1:13: +1:24\n+    let mut _3: (i32, u8, i32);          // in scope 0 at $DIR/aggregate.rs:+1:13: +1:22\n+    let _4: ();                          // in scope 0 at $DIR/aggregate.rs:+2:5: +2:11\n+    let mut _5: u8;                      // in scope 0 at $DIR/aggregate.rs:+2:9: +2:10\n     scope 1 {\n         debug x => _1;                   // in scope 1 at $DIR/aggregate.rs:+1:9: +1:10\n     }\n@@ -13,16 +15,25 @@ fn main() -> () {\n         StorageLive(_1);                 // scope 0 at $DIR/aggregate.rs:+1:9: +1:10\n         StorageLive(_2);                 // scope 0 at $DIR/aggregate.rs:+1:13: +1:24\n         StorageLive(_3);                 // scope 0 at $DIR/aggregate.rs:+1:13: +1:22\n-        Deinit(_3);                      // scope 0 at $DIR/aggregate.rs:+1:13: +1:22\n-        (_3.0: i32) = const 0_i32;       // scope 0 at $DIR/aggregate.rs:+1:13: +1:22\n-        (_3.1: i32) = const 1_i32;       // scope 0 at $DIR/aggregate.rs:+1:13: +1:22\n-        (_3.2: i32) = const 2_i32;       // scope 0 at $DIR/aggregate.rs:+1:13: +1:22\n-        _2 = const 1_i32;                // scope 0 at $DIR/aggregate.rs:+1:13: +1:24\n-        _1 = const 1_i32;                // scope 0 at $DIR/aggregate.rs:+1:13: +1:28\n+        _3 = (const 0_i32, const 1_u8, const 2_i32); // scope 0 at $DIR/aggregate.rs:+1:13: +1:22\n+        _2 = const 1_u8;                 // scope 0 at $DIR/aggregate.rs:+1:13: +1:24\n+        _1 = const 1_u8;                 // scope 0 at $DIR/aggregate.rs:+1:13: +1:28\n         StorageDead(_2);                 // scope 0 at $DIR/aggregate.rs:+1:27: +1:28\n         StorageDead(_3);                 // scope 0 at $DIR/aggregate.rs:+1:28: +1:29\n-        _0 = const ();                   // scope 0 at $DIR/aggregate.rs:+0:11: +2:2\n-        StorageDead(_1);                 // scope 0 at $DIR/aggregate.rs:+2:1: +2:2\n-        return;                          // scope 0 at $DIR/aggregate.rs:+2:2: +2:2\n+        StorageLive(_4);                 // scope 1 at $DIR/aggregate.rs:+2:5: +2:11\n+        StorageLive(_5);                 // scope 1 at $DIR/aggregate.rs:+2:9: +2:10\n+        _5 = const 1_u8;                 // scope 1 at $DIR/aggregate.rs:+2:9: +2:10\n+        _4 = foo(move _5) -> bb1;        // scope 1 at $DIR/aggregate.rs:+2:5: +2:11\n+                                         // mir::Constant\n+                                         // + span: $DIR/aggregate.rs:8:5: 8:8\n+                                         // + literal: Const { ty: fn(u8) {foo}, val: Value(<ZST>) }\n+    }\n+\n+    bb1: {\n+        StorageDead(_5);                 // scope 1 at $DIR/aggregate.rs:+2:10: +2:11\n+        StorageDead(_4);                 // scope 1 at $DIR/aggregate.rs:+2:11: +2:12\n+        _0 = const ();                   // scope 0 at $DIR/aggregate.rs:+0:11: +3:2\n+        StorageDead(_1);                 // scope 0 at $DIR/aggregate.rs:+3:1: +3:2\n+        return;                          // scope 0 at $DIR/aggregate.rs:+3:2: +3:2\n     }\n }"}, {"sha": "aa123b7a8664dfb839013275b03e6b92f55d22f7", "filename": "tests/mir-opt/const_prop/aggregate.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Faggregate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Faggregate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Faggregate.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -5,4 +5,13 @@\n // EMIT_MIR aggregate.main.PreCodegen.after.mir\n fn main() {\n     let x = (0, 1, 2).1 + 0;\n+    foo(x);\n+}\n+\n+// EMIT_MIR aggregate.foo.ConstProp.diff\n+// EMIT_MIR aggregate.foo.PreCodegen.after.mir\n+fn foo(x: u8) {\n+    // Verify that we still propagate if part of the aggregate is not known.\n+    let first = (0, x).0 + 1;\n+    let second = (x, 1).1 + 2;\n }"}, {"sha": "ae9ffd519a148ec6efd25eed5dbe487e231ee483", "filename": "tests/mir-opt/const_prop/bad_op_mod_by_zero.main.ConstProp.diff", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_mod_by_zero.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_mod_by_zero.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_mod_by_zero.main.ConstProp.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -18,7 +18,6 @@\n       }\n   \n       bb0: {\n-          StorageLive(_1);                 // scope 0 at $DIR/bad_op_mod_by_zero.rs:+1:9: +1:10\n           _1 = const 0_i32;                // scope 0 at $DIR/bad_op_mod_by_zero.rs:+1:13: +1:14\n           StorageLive(_2);                 // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:9: +2:11\n -         _4 = Eq(_1, const 0_i32);        // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19"}, {"sha": "b9a10704be0dcd6914b0349e38a43d88e8dff653", "filename": "tests/mir-opt/const_prop/discriminant.main.ConstProp.32bit.diff", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Fdiscriminant.main.ConstProp.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Fdiscriminant.main.ConstProp.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fdiscriminant.main.ConstProp.32bit.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -17,17 +17,20 @@\n           StorageLive(_1);                 // scope 0 at $DIR/discriminant.rs:+1:9: +1:10\n           StorageLive(_2);                 // scope 0 at $DIR/discriminant.rs:+1:13: +1:64\n           StorageLive(_3);                 // scope 2 at $DIR/discriminant.rs:+1:34: +1:44\n-          Deinit(_3);                      // scope 2 at $DIR/discriminant.rs:+1:34: +1:44\n-          ((_3 as Some).0: bool) = const true; // scope 2 at $DIR/discriminant.rs:+1:34: +1:44\n-          discriminant(_3) = 1;            // scope 2 at $DIR/discriminant.rs:+1:34: +1:44\n+-         _3 = Option::<bool>::Some(const true); // scope 2 at $DIR/discriminant.rs:+1:34: +1:44\n -         _4 = discriminant(_3);           // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n -         switchInt(move _4) -> [1: bb1, otherwise: bb3]; // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n++         _3 = const Option::<bool>::Some(true); // scope 2 at $DIR/discriminant.rs:+1:34: +1:44\n++                                          // mir::Constant\n++                                          // + span: $DIR/discriminant.rs:12:34: 12:44\n++                                          // + literal: Const { ty: Option<bool>, val: Value(Scalar(0x01)) }\n +         _4 = const 1_isize;              // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n +         switchInt(const 1_isize) -> [1: bb1, otherwise: bb3]; // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n       }\n   \n       bb1: {\n-          switchInt(((_3 as Some).0: bool)) -> [0: bb3, otherwise: bb2]; // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n+-         switchInt(((_3 as Some).0: bool)) -> [0: bb3, otherwise: bb2]; // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n++         switchInt(const true) -> [0: bb3, otherwise: bb2]; // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n       }\n   \n       bb2: {"}, {"sha": "b9a10704be0dcd6914b0349e38a43d88e8dff653", "filename": "tests/mir-opt/const_prop/discriminant.main.ConstProp.64bit.diff", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Fdiscriminant.main.ConstProp.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Fdiscriminant.main.ConstProp.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fdiscriminant.main.ConstProp.64bit.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -17,17 +17,20 @@\n           StorageLive(_1);                 // scope 0 at $DIR/discriminant.rs:+1:9: +1:10\n           StorageLive(_2);                 // scope 0 at $DIR/discriminant.rs:+1:13: +1:64\n           StorageLive(_3);                 // scope 2 at $DIR/discriminant.rs:+1:34: +1:44\n-          Deinit(_3);                      // scope 2 at $DIR/discriminant.rs:+1:34: +1:44\n-          ((_3 as Some).0: bool) = const true; // scope 2 at $DIR/discriminant.rs:+1:34: +1:44\n-          discriminant(_3) = 1;            // scope 2 at $DIR/discriminant.rs:+1:34: +1:44\n+-         _3 = Option::<bool>::Some(const true); // scope 2 at $DIR/discriminant.rs:+1:34: +1:44\n -         _4 = discriminant(_3);           // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n -         switchInt(move _4) -> [1: bb1, otherwise: bb3]; // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n++         _3 = const Option::<bool>::Some(true); // scope 2 at $DIR/discriminant.rs:+1:34: +1:44\n++                                          // mir::Constant\n++                                          // + span: $DIR/discriminant.rs:12:34: 12:44\n++                                          // + literal: Const { ty: Option<bool>, val: Value(Scalar(0x01)) }\n +         _4 = const 1_isize;              // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n +         switchInt(const 1_isize) -> [1: bb1, otherwise: bb3]; // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n       }\n   \n       bb1: {\n-          switchInt(((_3 as Some).0: bool)) -> [0: bb3, otherwise: bb2]; // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n+-         switchInt(((_3 as Some).0: bool)) -> [0: bb3, otherwise: bb2]; // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n++         switchInt(const true) -> [0: bb3, otherwise: bb2]; // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n       }\n   \n       bb2: {"}, {"sha": "4f056dd85e3f7999faa7851adeb2e15c52d1ad77", "filename": "tests/mir-opt/const_prop/invalid_constant.main.ConstProp.diff", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Finvalid_constant.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Finvalid_constant.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Finvalid_constant.main.ConstProp.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -32,16 +32,14 @@\n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/invalid_constant.rs:+6:9: +6:22\n           StorageLive(_2);                 // scope 2 at $DIR/invalid_constant.rs:+6:34: +6:63\n-          Deinit(_2);                      // scope 2 at $DIR/invalid_constant.rs:+6:34: +6:63\n-          (_2.0: u32) = const 1114113_u32; // scope 2 at $DIR/invalid_constant.rs:+6:34: +6:63\n+          _2 = InvalidChar { int: const 1114113_u32 }; // scope 2 at $DIR/invalid_constant.rs:+6:34: +6:63\n -         _1 = (_2.1: char);               // scope 2 at $DIR/invalid_constant.rs:+6:34: +6:67\n +         _1 = const {transmute(0x00110001): char}; // scope 2 at $DIR/invalid_constant.rs:+6:34: +6:67\n           StorageDead(_2);                 // scope 0 at $DIR/invalid_constant.rs:+6:69: +6:70\n           StorageLive(_3);                 // scope 1 at $DIR/invalid_constant.rs:+13:9: +13:21\n           StorageLive(_4);                 // scope 1 at $DIR/invalid_constant.rs:+13:25: +13:59\n           StorageLive(_5);                 // scope 4 at $DIR/invalid_constant.rs:+13:34: +13:55\n-          Deinit(_5);                      // scope 4 at $DIR/invalid_constant.rs:+13:34: +13:55\n-          (_5.0: u32) = const 4_u32;       // scope 4 at $DIR/invalid_constant.rs:+13:34: +13:55\n+          _5 = InvalidTag { int: const 4_u32 }; // scope 4 at $DIR/invalid_constant.rs:+13:34: +13:55\n -         _4 = (_5.1: E);                  // scope 4 at $DIR/invalid_constant.rs:+13:34: +13:57\n -         _3 = [move _4];                  // scope 1 at $DIR/invalid_constant.rs:+13:24: +13:60\n +         _4 = const Scalar(0x00000004): E; // scope 4 at $DIR/invalid_constant.rs:+13:34: +13:57"}, {"sha": "964dd3080749abdd9a20c9efe82196cb3f025111", "filename": "tests/mir-opt/const_prop/issue_66971.main.ConstProp.diff", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Fissue_66971.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Fissue_66971.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fissue_66971.main.ConstProp.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -5,13 +5,14 @@\n       let mut _0: ();                      // return place in scope 0 at $DIR/issue_66971.rs:+0:11: +0:11\n       let _1: ();                          // in scope 0 at $DIR/issue_66971.rs:+1:5: +1:23\n       let mut _2: ((), u8, u8);            // in scope 0 at $DIR/issue_66971.rs:+1:12: +1:22\n+      let mut _3: ();                      // in scope 0 at $DIR/issue_66971.rs:+1:13: +1:15\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/issue_66971.rs:+1:5: +1:23\n           StorageLive(_2);                 // scope 0 at $DIR/issue_66971.rs:+1:12: +1:22\n-          Deinit(_2);                      // scope 0 at $DIR/issue_66971.rs:+1:12: +1:22\n-          (_2.1: u8) = const 0_u8;         // scope 0 at $DIR/issue_66971.rs:+1:12: +1:22\n-          (_2.2: u8) = const 0_u8;         // scope 0 at $DIR/issue_66971.rs:+1:12: +1:22\n+          StorageLive(_3);                 // scope 0 at $DIR/issue_66971.rs:+1:13: +1:15\n+          _2 = (move _3, const 0_u8, const 0_u8); // scope 0 at $DIR/issue_66971.rs:+1:12: +1:22\n+          StorageDead(_3);                 // scope 0 at $DIR/issue_66971.rs:+1:21: +1:22\n           _1 = encode(move _2) -> bb1;     // scope 0 at $DIR/issue_66971.rs:+1:5: +1:23\n                                            // mir::Constant\n                                            // + span: $DIR/issue_66971.rs:17:5: 17:11"}, {"sha": "a631cb310904ba8d34699681ea8c015dec276c42", "filename": "tests/mir-opt/const_prop/issue_67019.main.ConstProp.diff", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Fissue_67019.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Fissue_67019.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fissue_67019.main.ConstProp.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -11,12 +11,9 @@\n           StorageLive(_1);                 // scope 0 at $DIR/issue_67019.rs:+1:5: +1:20\n           StorageLive(_2);                 // scope 0 at $DIR/issue_67019.rs:+1:10: +1:19\n           StorageLive(_3);                 // scope 0 at $DIR/issue_67019.rs:+1:11: +1:17\n-          Deinit(_3);                      // scope 0 at $DIR/issue_67019.rs:+1:11: +1:17\n-          (_3.0: u8) = const 1_u8;         // scope 0 at $DIR/issue_67019.rs:+1:11: +1:17\n-          (_3.1: u8) = const 2_u8;         // scope 0 at $DIR/issue_67019.rs:+1:11: +1:17\n-          Deinit(_2);                      // scope 0 at $DIR/issue_67019.rs:+1:10: +1:19\n--         (_2.0: (u8, u8)) = move _3;      // scope 0 at $DIR/issue_67019.rs:+1:10: +1:19\n-+         (_2.0: (u8, u8)) = const (1_u8, 2_u8); // scope 0 at $DIR/issue_67019.rs:+1:10: +1:19\n+-         _3 = (const 1_u8, const 2_u8);   // scope 0 at $DIR/issue_67019.rs:+1:11: +1:17\n++         _3 = const (1_u8, 2_u8);         // scope 0 at $DIR/issue_67019.rs:+1:11: +1:17\n+          _2 = (move _3,);                 // scope 0 at $DIR/issue_67019.rs:+1:10: +1:19\n           StorageDead(_3);                 // scope 0 at $DIR/issue_67019.rs:+1:18: +1:19\n           _1 = test(move _2) -> bb1;       // scope 0 at $DIR/issue_67019.rs:+1:5: +1:20\n                                            // mir::Constant"}, {"sha": "d088c4f662b7b21ab64582b7507623fb7a124bd1", "filename": "tests/mir-opt/const_prop/mutable_variable_aggregate.main.ConstProp.diff", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate.main.ConstProp.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -3,26 +3,27 @@\n   \n   fn main() -> () {\n       let mut _0: ();                      // return place in scope 0 at $DIR/mutable_variable_aggregate.rs:+0:11: +0:11\n-      let mut _1: (i32, i32);              // in scope 0 at $DIR/mutable_variable_aggregate.rs:+1:9: +1:14\n+      let mut _3: i32;                     // in scope 0 at $DIR/mutable_variable_aggregate.rs:+1:9: +1:14\n+      let mut _4: i32;                     // in scope 0 at $DIR/mutable_variable_aggregate.rs:+1:9: +1:14\n       scope 1 {\n-          debug x => _1;                   // in scope 1 at $DIR/mutable_variable_aggregate.rs:+1:9: +1:14\n-          let _2: (i32, i32);              // in scope 1 at $DIR/mutable_variable_aggregate.rs:+3:9: +3:10\n+          debug x => (i32, i32){ .0 => _3, .1 => _4, }; // in scope 1 at $DIR/mutable_variable_aggregate.rs:+1:9: +1:14\n+          let _1: i32;                     // in scope 1 at $DIR/mutable_variable_aggregate.rs:+3:9: +3:10\n+          let _2: i32;                     // in scope 1 at $DIR/mutable_variable_aggregate.rs:+3:9: +3:10\n           scope 2 {\n-              debug y => _2;               // in scope 2 at $DIR/mutable_variable_aggregate.rs:+3:9: +3:10\n+              debug y => (i32, i32){ .0 => _3, .1 => _2, }; // in scope 2 at $DIR/mutable_variable_aggregate.rs:+3:9: +3:10\n           }\n       }\n   \n       bb0: {\n-          StorageLive(_1);                 // scope 0 at $DIR/mutable_variable_aggregate.rs:+1:9: +1:14\n-          Deinit(_1);                      // scope 0 at $DIR/mutable_variable_aggregate.rs:+1:17: +1:25\n-          (_1.0: i32) = const 42_i32;      // scope 0 at $DIR/mutable_variable_aggregate.rs:+1:17: +1:25\n-          (_1.1: i32) = const 43_i32;      // scope 0 at $DIR/mutable_variable_aggregate.rs:+1:17: +1:25\n-          (_1.1: i32) = const 99_i32;      // scope 1 at $DIR/mutable_variable_aggregate.rs:+2:5: +2:13\n+          StorageLive(_4);                 // scope 0 at $DIR/mutable_variable_aggregate.rs:+1:9: +1:14\n+          _3 = const 42_i32;               // scope 0 at $DIR/mutable_variable_aggregate.rs:+1:17: +1:25\n+          _4 = const 43_i32;               // scope 0 at $DIR/mutable_variable_aggregate.rs:+1:17: +1:25\n+          _4 = const 99_i32;               // scope 1 at $DIR/mutable_variable_aggregate.rs:+2:5: +2:13\n           StorageLive(_2);                 // scope 1 at $DIR/mutable_variable_aggregate.rs:+3:9: +3:10\n--         _2 = _1;                         // scope 1 at $DIR/mutable_variable_aggregate.rs:+3:13: +3:14\n-+         _2 = const (42_i32, 99_i32);     // scope 1 at $DIR/mutable_variable_aggregate.rs:+3:13: +3:14\n+-         _2 = _4;                         // scope 1 at $DIR/mutable_variable_aggregate.rs:+3:13: +3:14\n++         _2 = const 99_i32;               // scope 1 at $DIR/mutable_variable_aggregate.rs:+3:13: +3:14\n           StorageDead(_2);                 // scope 1 at $DIR/mutable_variable_aggregate.rs:+4:1: +4:2\n-          StorageDead(_1);                 // scope 0 at $DIR/mutable_variable_aggregate.rs:+4:1: +4:2\n+          StorageDead(_4);                 // scope 0 at $DIR/mutable_variable_aggregate.rs:+4:1: +4:2\n           return;                          // scope 0 at $DIR/mutable_variable_aggregate.rs:+4:2: +4:2\n       }\n   }"}, {"sha": "134f0c080bf8118d8a3c26ec452720bd09c7c72e", "filename": "tests/mir-opt/const_prop/mutable_variable_aggregate_mut_ref.main.ConstProp.diff", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_mut_ref.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_mut_ref.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_mut_ref.main.ConstProp.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -9,24 +9,26 @@\n           let _2: &mut (i32, i32);         // in scope 1 at $DIR/mutable_variable_aggregate_mut_ref.rs:+2:9: +2:10\n           scope 2 {\n               debug z => _2;               // in scope 2 at $DIR/mutable_variable_aggregate_mut_ref.rs:+2:9: +2:10\n-              let _3: (i32, i32);          // in scope 2 at $DIR/mutable_variable_aggregate_mut_ref.rs:+4:9: +4:10\n+              let _3: i32;                 // in scope 2 at $DIR/mutable_variable_aggregate_mut_ref.rs:+4:9: +4:10\n+              let _4: i32;                 // in scope 2 at $DIR/mutable_variable_aggregate_mut_ref.rs:+4:9: +4:10\n               scope 3 {\n-                  debug y => _3;           // in scope 3 at $DIR/mutable_variable_aggregate_mut_ref.rs:+4:9: +4:10\n+                  debug y => (i32, i32){ .0 => _3, .1 => _4, }; // in scope 3 at $DIR/mutable_variable_aggregate_mut_ref.rs:+4:9: +4:10\n               }\n           }\n       }\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/mutable_variable_aggregate_mut_ref.rs:+1:9: +1:14\n-          Deinit(_1);                      // scope 0 at $DIR/mutable_variable_aggregate_mut_ref.rs:+1:17: +1:25\n-          (_1.0: i32) = const 42_i32;      // scope 0 at $DIR/mutable_variable_aggregate_mut_ref.rs:+1:17: +1:25\n-          (_1.1: i32) = const 43_i32;      // scope 0 at $DIR/mutable_variable_aggregate_mut_ref.rs:+1:17: +1:25\n+          _1 = (const 42_i32, const 43_i32); // scope 0 at $DIR/mutable_variable_aggregate_mut_ref.rs:+1:17: +1:25\n           StorageLive(_2);                 // scope 1 at $DIR/mutable_variable_aggregate_mut_ref.rs:+2:9: +2:10\n           _2 = &mut _1;                    // scope 1 at $DIR/mutable_variable_aggregate_mut_ref.rs:+2:13: +2:19\n           ((*_2).1: i32) = const 99_i32;   // scope 2 at $DIR/mutable_variable_aggregate_mut_ref.rs:+3:5: +3:13\n           StorageLive(_3);                 // scope 2 at $DIR/mutable_variable_aggregate_mut_ref.rs:+4:9: +4:10\n-          _3 = _1;                         // scope 2 at $DIR/mutable_variable_aggregate_mut_ref.rs:+4:13: +4:14\n+          StorageLive(_4);                 // scope 2 at $DIR/mutable_variable_aggregate_mut_ref.rs:+4:9: +4:10\n+          _3 = (_1.0: i32);                // scope 2 at $DIR/mutable_variable_aggregate_mut_ref.rs:+4:13: +4:14\n+          _4 = (_1.1: i32);                // scope 2 at $DIR/mutable_variable_aggregate_mut_ref.rs:+4:13: +4:14\n           StorageDead(_3);                 // scope 2 at $DIR/mutable_variable_aggregate_mut_ref.rs:+5:1: +5:2\n+          StorageDead(_4);                 // scope 2 at $DIR/mutable_variable_aggregate_mut_ref.rs:+5:1: +5:2\n           StorageDead(_2);                 // scope 1 at $DIR/mutable_variable_aggregate_mut_ref.rs:+5:1: +5:2\n           StorageDead(_1);                 // scope 0 at $DIR/mutable_variable_aggregate_mut_ref.rs:+5:1: +5:2\n           return;                          // scope 0 at $DIR/mutable_variable_aggregate_mut_ref.rs:+5:2: +5:2"}, {"sha": "4010dd6c6d0d8518a55625090c90d496455f41b9", "filename": "tests/mir-opt/const_prop/mutable_variable_unprop_assign.main.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Fmutable_variable_unprop_assign.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Fmutable_variable_unprop_assign.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fmutable_variable_unprop_assign.main.ConstProp.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -16,7 +16,7 @@\n                   debug y => _3;           // in scope 3 at $DIR/mutable_variable_unprop_assign.rs:+4:9: +4:10\n                   let _4: i32;             // in scope 3 at $DIR/mutable_variable_unprop_assign.rs:+5:9: +5:10\n                   scope 4 {\n-                      debug z => _4;       // in scope 4 at $DIR/mutable_variable_unprop_assign.rs:+5:9: +5:10\n+                      debug z => _5;       // in scope 4 at $DIR/mutable_variable_unprop_assign.rs:+5:9: +5:10\n                   }\n               }\n           }\n@@ -31,10 +31,7 @@\n       }\n   \n       bb1: {\n-          StorageLive(_5);                 // scope 1 at $DIR/mutable_variable_unprop_assign.rs:+2:9: +2:14\n           StorageLive(_6);                 // scope 1 at $DIR/mutable_variable_unprop_assign.rs:+2:9: +2:14\n-          Deinit(_5);                      // scope 1 at $DIR/mutable_variable_unprop_assign.rs:+2:29: +2:35\n-          Deinit(_6);                      // scope 1 at $DIR/mutable_variable_unprop_assign.rs:+2:29: +2:35\n           _5 = const 1_i32;                // scope 1 at $DIR/mutable_variable_unprop_assign.rs:+2:29: +2:35\n           _6 = const 2_i32;                // scope 1 at $DIR/mutable_variable_unprop_assign.rs:+2:29: +2:35\n           StorageLive(_2);                 // scope 2 at $DIR/mutable_variable_unprop_assign.rs:+3:11: +3:12\n@@ -43,12 +40,7 @@\n           StorageDead(_2);                 // scope 2 at $DIR/mutable_variable_unprop_assign.rs:+3:11: +3:12\n           StorageLive(_3);                 // scope 2 at $DIR/mutable_variable_unprop_assign.rs:+4:9: +4:10\n           _3 = _6;                         // scope 2 at $DIR/mutable_variable_unprop_assign.rs:+4:13: +4:16\n-          StorageLive(_4);                 // scope 3 at $DIR/mutable_variable_unprop_assign.rs:+5:9: +5:10\n--         _4 = _5;                         // scope 3 at $DIR/mutable_variable_unprop_assign.rs:+5:13: +5:16\n-+         _4 = const 1_i32;                // scope 3 at $DIR/mutable_variable_unprop_assign.rs:+5:13: +5:16\n-          StorageDead(_4);                 // scope 3 at $DIR/mutable_variable_unprop_assign.rs:+6:1: +6:2\n           StorageDead(_3);                 // scope 2 at $DIR/mutable_variable_unprop_assign.rs:+6:1: +6:2\n-          StorageDead(_5);                 // scope 1 at $DIR/mutable_variable_unprop_assign.rs:+6:1: +6:2\n           StorageDead(_6);                 // scope 1 at $DIR/mutable_variable_unprop_assign.rs:+6:1: +6:2\n           StorageDead(_1);                 // scope 0 at $DIR/mutable_variable_unprop_assign.rs:+6:1: +6:2\n           return;                          // scope 0 at $DIR/mutable_variable_unprop_assign.rs:+6:2: +6:2"}, {"sha": "691aa01a564080d31e64c2000fbbdff0394a91b4", "filename": "tests/mir-opt/const_prop/optimizes_into_variable.main.ConstProp.32bit.diff", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.ConstProp.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.ConstProp.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.ConstProp.32bit.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -17,7 +17,7 @@\n               debug y => _3;               // in scope 2 at $DIR/optimizes_into_variable.rs:+2:9: +2:10\n               let _8: u32;                 // in scope 2 at $DIR/optimizes_into_variable.rs:+3:9: +3:10\n               scope 3 {\n-                  debug z => _8;           // in scope 3 at $DIR/optimizes_into_variable.rs:+3:9: +3:10\n+                  debug z => _9;           // in scope 3 at $DIR/optimizes_into_variable.rs:+3:9: +3:10\n               }\n           }\n       }\n@@ -50,14 +50,7 @@\n +         _3 = const 3_i32;                // scope 1 at $DIR/optimizes_into_variable.rs:+2:13: +2:34\n           StorageDead(_5);                 // scope 1 at $DIR/optimizes_into_variable.rs:+2:34: +2:35\n           StorageDead(_4);                 // scope 1 at $DIR/optimizes_into_variable.rs:+2:34: +2:35\n-          StorageLive(_8);                 // scope 2 at $DIR/optimizes_into_variable.rs:+3:9: +3:10\n-          StorageLive(_9);                 // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n-          Deinit(_9);                      // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n           _9 = const 42_u32;               // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n--         _8 = _9;                         // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:38\n-+         _8 = const 42_u32;               // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:38\n-          StorageDead(_9);                 // scope 2 at $DIR/optimizes_into_variable.rs:+3:38: +3:39\n-          StorageDead(_8);                 // scope 2 at $DIR/optimizes_into_variable.rs:+4:1: +4:2\n           StorageDead(_3);                 // scope 1 at $DIR/optimizes_into_variable.rs:+4:1: +4:2\n           StorageDead(_1);                 // scope 0 at $DIR/optimizes_into_variable.rs:+4:1: +4:2\n           return;                          // scope 0 at $DIR/optimizes_into_variable.rs:+4:2: +4:2"}, {"sha": "691aa01a564080d31e64c2000fbbdff0394a91b4", "filename": "tests/mir-opt/const_prop/optimizes_into_variable.main.ConstProp.64bit.diff", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.ConstProp.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.ConstProp.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.ConstProp.64bit.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -17,7 +17,7 @@\n               debug y => _3;               // in scope 2 at $DIR/optimizes_into_variable.rs:+2:9: +2:10\n               let _8: u32;                 // in scope 2 at $DIR/optimizes_into_variable.rs:+3:9: +3:10\n               scope 3 {\n-                  debug z => _8;           // in scope 3 at $DIR/optimizes_into_variable.rs:+3:9: +3:10\n+                  debug z => _9;           // in scope 3 at $DIR/optimizes_into_variable.rs:+3:9: +3:10\n               }\n           }\n       }\n@@ -50,14 +50,7 @@\n +         _3 = const 3_i32;                // scope 1 at $DIR/optimizes_into_variable.rs:+2:13: +2:34\n           StorageDead(_5);                 // scope 1 at $DIR/optimizes_into_variable.rs:+2:34: +2:35\n           StorageDead(_4);                 // scope 1 at $DIR/optimizes_into_variable.rs:+2:34: +2:35\n-          StorageLive(_8);                 // scope 2 at $DIR/optimizes_into_variable.rs:+3:9: +3:10\n-          StorageLive(_9);                 // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n-          Deinit(_9);                      // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n           _9 = const 42_u32;               // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n--         _8 = _9;                         // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:38\n-+         _8 = const 42_u32;               // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:38\n-          StorageDead(_9);                 // scope 2 at $DIR/optimizes_into_variable.rs:+3:38: +3:39\n-          StorageDead(_8);                 // scope 2 at $DIR/optimizes_into_variable.rs:+4:1: +4:2\n           StorageDead(_3);                 // scope 1 at $DIR/optimizes_into_variable.rs:+4:1: +4:2\n           StorageDead(_1);                 // scope 0 at $DIR/optimizes_into_variable.rs:+4:1: +4:2\n           return;                          // scope 0 at $DIR/optimizes_into_variable.rs:+4:2: +4:2"}, {"sha": "81cfd22db6c5078732613b9243f7e4dfacc22d2a", "filename": "tests/mir-opt/const_prop/optimizes_into_variable.main.PreCodegen.after.32bit.mir", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.PreCodegen.after.32bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.PreCodegen.after.32bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.PreCodegen.after.32bit.mir?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -3,12 +3,12 @@\n fn main() -> () {\n     let mut _0: ();                      // return place in scope 0 at $DIR/optimizes_into_variable.rs:+0:11: +0:11\n     let _1: i32;                         // in scope 0 at $DIR/optimizes_into_variable.rs:+1:9: +1:10\n+    let mut _3: u32;                     // in scope 0 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n     scope 1 {\n         debug x => _1;                   // in scope 1 at $DIR/optimizes_into_variable.rs:+1:9: +1:10\n         let _2: i32;                     // in scope 1 at $DIR/optimizes_into_variable.rs:+2:9: +2:10\n         scope 2 {\n             debug y => _2;               // in scope 2 at $DIR/optimizes_into_variable.rs:+2:9: +2:10\n-            let _3: u32;                 // in scope 2 at $DIR/optimizes_into_variable.rs:+3:9: +3:10\n             scope 3 {\n                 debug z => _3;           // in scope 3 at $DIR/optimizes_into_variable.rs:+3:9: +3:10\n             }\n@@ -18,8 +18,6 @@ fn main() -> () {\n     bb0: {\n         StorageLive(_1);                 // scope 0 at $DIR/optimizes_into_variable.rs:+1:9: +1:10\n         StorageLive(_2);                 // scope 1 at $DIR/optimizes_into_variable.rs:+2:9: +2:10\n-        StorageLive(_3);                 // scope 2 at $DIR/optimizes_into_variable.rs:+3:9: +3:10\n-        StorageDead(_3);                 // scope 2 at $DIR/optimizes_into_variable.rs:+4:1: +4:2\n         StorageDead(_2);                 // scope 1 at $DIR/optimizes_into_variable.rs:+4:1: +4:2\n         StorageDead(_1);                 // scope 0 at $DIR/optimizes_into_variable.rs:+4:1: +4:2\n         return;                          // scope 0 at $DIR/optimizes_into_variable.rs:+4:2: +4:2"}, {"sha": "81cfd22db6c5078732613b9243f7e4dfacc22d2a", "filename": "tests/mir-opt/const_prop/optimizes_into_variable.main.PreCodegen.after.64bit.mir", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.PreCodegen.after.64bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.PreCodegen.after.64bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.PreCodegen.after.64bit.mir?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -3,12 +3,12 @@\n fn main() -> () {\n     let mut _0: ();                      // return place in scope 0 at $DIR/optimizes_into_variable.rs:+0:11: +0:11\n     let _1: i32;                         // in scope 0 at $DIR/optimizes_into_variable.rs:+1:9: +1:10\n+    let mut _3: u32;                     // in scope 0 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n     scope 1 {\n         debug x => _1;                   // in scope 1 at $DIR/optimizes_into_variable.rs:+1:9: +1:10\n         let _2: i32;                     // in scope 1 at $DIR/optimizes_into_variable.rs:+2:9: +2:10\n         scope 2 {\n             debug y => _2;               // in scope 2 at $DIR/optimizes_into_variable.rs:+2:9: +2:10\n-            let _3: u32;                 // in scope 2 at $DIR/optimizes_into_variable.rs:+3:9: +3:10\n             scope 3 {\n                 debug z => _3;           // in scope 3 at $DIR/optimizes_into_variable.rs:+3:9: +3:10\n             }\n@@ -18,8 +18,6 @@ fn main() -> () {\n     bb0: {\n         StorageLive(_1);                 // scope 0 at $DIR/optimizes_into_variable.rs:+1:9: +1:10\n         StorageLive(_2);                 // scope 1 at $DIR/optimizes_into_variable.rs:+2:9: +2:10\n-        StorageLive(_3);                 // scope 2 at $DIR/optimizes_into_variable.rs:+3:9: +3:10\n-        StorageDead(_3);                 // scope 2 at $DIR/optimizes_into_variable.rs:+4:1: +4:2\n         StorageDead(_2);                 // scope 1 at $DIR/optimizes_into_variable.rs:+4:1: +4:2\n         StorageDead(_1);                 // scope 0 at $DIR/optimizes_into_variable.rs:+4:1: +4:2\n         return;                          // scope 0 at $DIR/optimizes_into_variable.rs:+4:2: +4:2"}, {"sha": "98cd020dade4ba0665d1836e53e3de6ef1d41030", "filename": "tests/mir-opt/const_prop/optimizes_into_variable.main.ScalarReplacementOfAggregates.32bit.diff", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.ScalarReplacementOfAggregates.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.ScalarReplacementOfAggregates.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.ScalarReplacementOfAggregates.32bit.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -48,20 +48,19 @@\n           StorageDead(_4);                 // scope 1 at $DIR/optimizes_into_variable.rs:+2:34: +2:35\n           StorageLive(_8);                 // scope 2 at $DIR/optimizes_into_variable.rs:+3:9: +3:10\n -         StorageLive(_9);                 // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n--         Deinit(_9);                      // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n--         (_9.0: u32) = const 12_u32;      // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n--         (_9.1: u32) = const 42_u32;      // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n+-         _9 = Point { x: const 12_u32, y: const 42_u32 }; // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n -         _8 = (_9.1: u32);                // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:38\n -         StorageDead(_9);                 // scope 2 at $DIR/optimizes_into_variable.rs:+3:38: +3:39\n +         StorageLive(_10);                // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n +         StorageLive(_11);                // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n-+         Deinit(_10);                     // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n-+         Deinit(_11);                     // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n++         nop;                             // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n +         _10 = const 12_u32;              // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n +         _11 = const 42_u32;              // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n++         nop;                             // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n +         _8 = _11;                        // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:38\n +         StorageDead(_10);                // scope 2 at $DIR/optimizes_into_variable.rs:+3:38: +3:39\n +         StorageDead(_11);                // scope 2 at $DIR/optimizes_into_variable.rs:+3:38: +3:39\n++         nop;                             // scope 2 at $DIR/optimizes_into_variable.rs:+3:38: +3:39\n           nop;                             // scope 0 at $DIR/optimizes_into_variable.rs:+0:11: +4:2\n           StorageDead(_8);                 // scope 2 at $DIR/optimizes_into_variable.rs:+4:1: +4:2\n           StorageDead(_3);                 // scope 1 at $DIR/optimizes_into_variable.rs:+4:1: +4:2"}, {"sha": "98cd020dade4ba0665d1836e53e3de6ef1d41030", "filename": "tests/mir-opt/const_prop/optimizes_into_variable.main.ScalarReplacementOfAggregates.64bit.diff", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.ScalarReplacementOfAggregates.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.ScalarReplacementOfAggregates.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.ScalarReplacementOfAggregates.64bit.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -48,20 +48,19 @@\n           StorageDead(_4);                 // scope 1 at $DIR/optimizes_into_variable.rs:+2:34: +2:35\n           StorageLive(_8);                 // scope 2 at $DIR/optimizes_into_variable.rs:+3:9: +3:10\n -         StorageLive(_9);                 // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n--         Deinit(_9);                      // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n--         (_9.0: u32) = const 12_u32;      // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n--         (_9.1: u32) = const 42_u32;      // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n+-         _9 = Point { x: const 12_u32, y: const 42_u32 }; // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n -         _8 = (_9.1: u32);                // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:38\n -         StorageDead(_9);                 // scope 2 at $DIR/optimizes_into_variable.rs:+3:38: +3:39\n +         StorageLive(_10);                // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n +         StorageLive(_11);                // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n-+         Deinit(_10);                     // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n-+         Deinit(_11);                     // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n++         nop;                             // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n +         _10 = const 12_u32;              // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n +         _11 = const 42_u32;              // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n++         nop;                             // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n +         _8 = _11;                        // scope 2 at $DIR/optimizes_into_variable.rs:+3:13: +3:38\n +         StorageDead(_10);                // scope 2 at $DIR/optimizes_into_variable.rs:+3:38: +3:39\n +         StorageDead(_11);                // scope 2 at $DIR/optimizes_into_variable.rs:+3:38: +3:39\n++         nop;                             // scope 2 at $DIR/optimizes_into_variable.rs:+3:38: +3:39\n           nop;                             // scope 0 at $DIR/optimizes_into_variable.rs:+0:11: +4:2\n           StorageDead(_8);                 // scope 2 at $DIR/optimizes_into_variable.rs:+4:1: +4:2\n           StorageDead(_3);                 // scope 1 at $DIR/optimizes_into_variable.rs:+4:1: +4:2"}, {"sha": "002e914e8fa165b75ec467e5ddc10d15522fb26e", "filename": "tests/mir-opt/const_prop/optimizes_into_variable.main.SimplifyLocals-final.after.32bit.mir", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.SimplifyLocals-final.after.32bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.SimplifyLocals-final.after.32bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.SimplifyLocals-final.after.32bit.mir?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -3,12 +3,12 @@\n fn main() -> () {\n     let mut _0: ();                      // return place in scope 0 at $DIR/optimizes_into_variable.rs:+0:11: +0:11\n     let _1: i32;                         // in scope 0 at $DIR/optimizes_into_variable.rs:+1:9: +1:10\n+    let mut _3: u32;                     // in scope 0 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n     scope 1 {\n         debug x => _1;                   // in scope 1 at $DIR/optimizes_into_variable.rs:+1:9: +1:10\n         let _2: i32;                     // in scope 1 at $DIR/optimizes_into_variable.rs:+2:9: +2:10\n         scope 2 {\n             debug y => _2;               // in scope 2 at $DIR/optimizes_into_variable.rs:+2:9: +2:10\n-            let _3: u32;                 // in scope 2 at $DIR/optimizes_into_variable.rs:+3:9: +3:10\n             scope 3 {\n                 debug z => _3;           // in scope 3 at $DIR/optimizes_into_variable.rs:+3:9: +3:10\n             }\n@@ -18,8 +18,6 @@ fn main() -> () {\n     bb0: {\n         StorageLive(_1);                 // scope 0 at $DIR/optimizes_into_variable.rs:+1:9: +1:10\n         StorageLive(_2);                 // scope 1 at $DIR/optimizes_into_variable.rs:+2:9: +2:10\n-        StorageLive(_3);                 // scope 2 at $DIR/optimizes_into_variable.rs:+3:9: +3:10\n-        StorageDead(_3);                 // scope 2 at $DIR/optimizes_into_variable.rs:+4:1: +4:2\n         StorageDead(_2);                 // scope 1 at $DIR/optimizes_into_variable.rs:+4:1: +4:2\n         StorageDead(_1);                 // scope 0 at $DIR/optimizes_into_variable.rs:+4:1: +4:2\n         return;                          // scope 0 at $DIR/optimizes_into_variable.rs:+4:2: +4:2"}, {"sha": "002e914e8fa165b75ec467e5ddc10d15522fb26e", "filename": "tests/mir-opt/const_prop/optimizes_into_variable.main.SimplifyLocals-final.after.64bit.mir", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.SimplifyLocals-final.after.64bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.SimplifyLocals-final.after.64bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Foptimizes_into_variable.main.SimplifyLocals-final.after.64bit.mir?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -3,12 +3,12 @@\n fn main() -> () {\n     let mut _0: ();                      // return place in scope 0 at $DIR/optimizes_into_variable.rs:+0:11: +0:11\n     let _1: i32;                         // in scope 0 at $DIR/optimizes_into_variable.rs:+1:9: +1:10\n+    let mut _3: u32;                     // in scope 0 at $DIR/optimizes_into_variable.rs:+3:13: +3:36\n     scope 1 {\n         debug x => _1;                   // in scope 1 at $DIR/optimizes_into_variable.rs:+1:9: +1:10\n         let _2: i32;                     // in scope 1 at $DIR/optimizes_into_variable.rs:+2:9: +2:10\n         scope 2 {\n             debug y => _2;               // in scope 2 at $DIR/optimizes_into_variable.rs:+2:9: +2:10\n-            let _3: u32;                 // in scope 2 at $DIR/optimizes_into_variable.rs:+3:9: +3:10\n             scope 3 {\n                 debug z => _3;           // in scope 3 at $DIR/optimizes_into_variable.rs:+3:9: +3:10\n             }\n@@ -18,8 +18,6 @@ fn main() -> () {\n     bb0: {\n         StorageLive(_1);                 // scope 0 at $DIR/optimizes_into_variable.rs:+1:9: +1:10\n         StorageLive(_2);                 // scope 1 at $DIR/optimizes_into_variable.rs:+2:9: +2:10\n-        StorageLive(_3);                 // scope 2 at $DIR/optimizes_into_variable.rs:+3:9: +3:10\n-        StorageDead(_3);                 // scope 2 at $DIR/optimizes_into_variable.rs:+4:1: +4:2\n         StorageDead(_2);                 // scope 1 at $DIR/optimizes_into_variable.rs:+4:1: +4:2\n         StorageDead(_1);                 // scope 0 at $DIR/optimizes_into_variable.rs:+4:1: +4:2\n         return;                          // scope 0 at $DIR/optimizes_into_variable.rs:+4:2: +4:2"}, {"sha": "22f710387db71d8321606cc4c303f361bfd09a65", "filename": "tests/mir-opt/const_prop/scalar_literal_propagation.main.ConstProp.diff", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Fscalar_literal_propagation.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Fscalar_literal_propagation.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fscalar_literal_propagation.main.ConstProp.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -11,7 +11,6 @@\n       }\n   \n       bb0: {\n-          StorageLive(_1);                 // scope 0 at $DIR/scalar_literal_propagation.rs:+1:9: +1:10\n           _1 = const 1_u32;                // scope 0 at $DIR/scalar_literal_propagation.rs:+1:13: +1:14\n           StorageLive(_2);                 // scope 1 at $DIR/scalar_literal_propagation.rs:+2:5: +2:15\n -         _2 = consume(_1) -> bb1;         // scope 1 at $DIR/scalar_literal_propagation.rs:+2:5: +2:15"}, {"sha": "270a1ccf560f1e5de0b078884a2e1bd0d5683021", "filename": "tests/mir-opt/const_prop/tuple_literal_propagation.main.ConstProp.diff", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Ftuple_literal_propagation.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop%2Ftuple_literal_propagation.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Ftuple_literal_propagation.main.ConstProp.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -11,24 +11,17 @@\n       }\n   \n       bb0: {\n-          StorageLive(_1);                 // scope 0 at $DIR/tuple_literal_propagation.rs:+1:9: +1:10\n-          Deinit(_1);                      // scope 0 at $DIR/tuple_literal_propagation.rs:+1:13: +1:19\n-          (_1.0: u32) = const 1_u32;       // scope 0 at $DIR/tuple_literal_propagation.rs:+1:13: +1:19\n-          (_1.1: u32) = const 2_u32;       // scope 0 at $DIR/tuple_literal_propagation.rs:+1:13: +1:19\n+-         _1 = (const 1_u32, const 2_u32); // scope 0 at $DIR/tuple_literal_propagation.rs:+1:13: +1:19\n++         _1 = const (1_u32, 2_u32);       // scope 0 at $DIR/tuple_literal_propagation.rs:+1:13: +1:19\n           StorageLive(_2);                 // scope 1 at $DIR/tuple_literal_propagation.rs:+3:5: +3:15\n-          StorageLive(_3);                 // scope 1 at $DIR/tuple_literal_propagation.rs:+3:13: +3:14\n--         _3 = _1;                         // scope 1 at $DIR/tuple_literal_propagation.rs:+3:13: +3:14\n-+         _3 = const (1_u32, 2_u32);       // scope 1 at $DIR/tuple_literal_propagation.rs:+3:13: +3:14\n-          _2 = consume(move _3) -> bb1;    // scope 1 at $DIR/tuple_literal_propagation.rs:+3:5: +3:15\n+          _2 = consume(_1) -> bb1;         // scope 1 at $DIR/tuple_literal_propagation.rs:+3:5: +3:15\n                                            // mir::Constant\n                                            // + span: $DIR/tuple_literal_propagation.rs:5:5: 5:12\n                                            // + literal: Const { ty: fn((u32, u32)) {consume}, val: Value(<ZST>) }\n       }\n   \n       bb1: {\n-          StorageDead(_3);                 // scope 1 at $DIR/tuple_literal_propagation.rs:+3:14: +3:15\n           StorageDead(_2);                 // scope 1 at $DIR/tuple_literal_propagation.rs:+3:15: +3:16\n-          StorageDead(_1);                 // scope 0 at $DIR/tuple_literal_propagation.rs:+4:1: +4:2\n           return;                          // scope 0 at $DIR/tuple_literal_propagation.rs:+4:2: +4:2\n       }\n   }"}, {"sha": "def9fc6428fb63e8f02cd104db629c54aaa9c90f", "filename": "tests/mir-opt/const_prop_miscompile.bar.ConstProp.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop_miscompile.bar.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop_miscompile.bar.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop_miscompile.bar.ConstProp.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -19,8 +19,8 @@\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/const_prop_miscompile.rs:+1:9: +1:14\n-          Deinit(_1);                      // scope 0 at $DIR/const_prop_miscompile.rs:+1:17: +1:21\n-          (_1.0: i32) = const 1_i32;       // scope 0 at $DIR/const_prop_miscompile.rs:+1:17: +1:21\n+-         _1 = (const 1_i32,);             // scope 0 at $DIR/const_prop_miscompile.rs:+1:17: +1:21\n++         _1 = const (1_i32,);             // scope 0 at $DIR/const_prop_miscompile.rs:+1:17: +1:21\n           StorageLive(_2);                 // scope 1 at $DIR/const_prop_miscompile.rs:+2:5: +4:6\n           StorageLive(_3);                 // scope 2 at $DIR/const_prop_miscompile.rs:+3:10: +3:22\n           _3 = &raw mut (_1.0: i32);       // scope 2 at $DIR/const_prop_miscompile.rs:+3:10: +3:22"}, {"sha": "b54c10a140f2cb30b529fa34c4929f1bcb634aab", "filename": "tests/mir-opt/const_prop_miscompile.foo.ConstProp.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop_miscompile.foo.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fconst_prop_miscompile.foo.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop_miscompile.foo.ConstProp.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -16,8 +16,8 @@\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/const_prop_miscompile.rs:+1:9: +1:14\n-          Deinit(_1);                      // scope 0 at $DIR/const_prop_miscompile.rs:+1:17: +1:21\n-          (_1.0: i32) = const 1_i32;       // scope 0 at $DIR/const_prop_miscompile.rs:+1:17: +1:21\n+-         _1 = (const 1_i32,);             // scope 0 at $DIR/const_prop_miscompile.rs:+1:17: +1:21\n++         _1 = const (1_i32,);             // scope 0 at $DIR/const_prop_miscompile.rs:+1:17: +1:21\n           StorageLive(_2);                 // scope 1 at $DIR/const_prop_miscompile.rs:+2:6: +2:14\n           _2 = &mut (_1.0: i32);           // scope 1 at $DIR/const_prop_miscompile.rs:+2:6: +2:14\n           (*_2) = const 5_i32;             // scope 1 at $DIR/const_prop_miscompile.rs:+2:5: +2:18"}, {"sha": "3e61869e82f11f2085a133825c7ea62b86d52ed9", "filename": "tests/mir-opt/copy-prop/cycle.main.CopyProp.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fcopy-prop%2Fcycle.main.CopyProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fcopy-prop%2Fcycle.main.CopyProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcopy-prop%2Fcycle.main.CopyProp.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -29,7 +29,7 @@\n       }\n   \n       bb1: {\n-          StorageLive(_2);                 // scope 1 at $DIR/cycle.rs:+2:9: +2:10\n+-         StorageLive(_2);                 // scope 1 at $DIR/cycle.rs:+2:9: +2:10\n           _2 = _1;                         // scope 1 at $DIR/cycle.rs:+2:13: +2:14\n -         StorageLive(_3);                 // scope 2 at $DIR/cycle.rs:+3:9: +3:10\n -         _3 = _2;                         // scope 2 at $DIR/cycle.rs:+3:13: +3:14"}, {"sha": "d48b04e2de273887ca85aa141f8812c1a36be817", "filename": "tests/mir-opt/copy-prop/dead_stores_79191.f.CopyProp.after.mir", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fcopy-prop%2Fdead_stores_79191.f.CopyProp.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fcopy-prop%2Fdead_stores_79191.f.CopyProp.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcopy-prop%2Fdead_stores_79191.f.CopyProp.after.mir?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -11,7 +11,6 @@ fn f(_1: usize) -> usize {\n     }\n \n     bb0: {\n-        StorageLive(_2);                 // scope 0 at $DIR/dead_stores_79191.rs:+1:9: +1:10\n         _2 = _1;                         // scope 0 at $DIR/dead_stores_79191.rs:+1:13: +1:14\n         _1 = const 5_usize;              // scope 1 at $DIR/dead_stores_79191.rs:+2:5: +2:10\n         _1 = _2;                         // scope 1 at $DIR/dead_stores_79191.rs:+3:5: +3:10"}, {"sha": "727791f50a4ef67b0b15283df8ff7677ebbea1d5", "filename": "tests/mir-opt/copy-prop/dead_stores_better.f.CopyProp.after.mir", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fcopy-prop%2Fdead_stores_better.f.CopyProp.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fcopy-prop%2Fdead_stores_better.f.CopyProp.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcopy-prop%2Fdead_stores_better.f.CopyProp.after.mir?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -11,7 +11,6 @@ fn f(_1: usize) -> usize {\n     }\n \n     bb0: {\n-        StorageLive(_2);                 // scope 0 at $DIR/dead_stores_better.rs:+1:9: +1:10\n         _2 = _1;                         // scope 0 at $DIR/dead_stores_better.rs:+1:13: +1:14\n         _1 = const 5_usize;              // scope 1 at $DIR/dead_stores_better.rs:+2:5: +2:10\n         _1 = _2;                         // scope 1 at $DIR/dead_stores_better.rs:+3:5: +3:10"}, {"sha": "97d0a01e00bc4fd725769dfb1cc601b264026b22", "filename": "tests/mir-opt/copy-prop/issue_107511.main.CopyProp.diff", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fcopy-prop%2Fissue_107511.main.CopyProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fcopy-prop%2Fissue_107511.main.CopyProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcopy-prop%2Fissue_107511.main.CopyProp.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -0,0 +1,138 @@\n+- // MIR for `main` before CopyProp\n++ // MIR for `main` after CopyProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/issue_107511.rs:+0:11: +0:11\n+      let mut _1: i32;                     // in scope 0 at $DIR/issue_107511.rs:+1:9: +1:16\n+      let mut _3: std::ops::Range<usize>;  // in scope 0 at $DIR/issue_107511.rs:+6:14: +6:24\n+      let mut _4: std::ops::Range<usize>;  // in scope 0 at $DIR/issue_107511.rs:+6:14: +6:24\n+      let mut _5: usize;                   // in scope 0 at $DIR/issue_107511.rs:+6:17: +6:24\n+      let mut _6: &[i32];                  // in scope 0 at $DIR/issue_107511.rs:+6:17: +6:24\n+      let mut _7: &[i32; 4];               // in scope 0 at $DIR/issue_107511.rs:+6:17: +6:24\n+      let mut _9: ();                      // in scope 0 at $DIR/issue_107511.rs:+0:1: +9:2\n+      let _10: ();                         // in scope 0 at $DIR/issue_107511.rs:+6:14: +6:24\n+      let mut _11: std::option::Option<usize>; // in scope 0 at $DIR/issue_107511.rs:+6:14: +6:24\n+      let mut _12: &mut std::ops::Range<usize>; // in scope 0 at $DIR/issue_107511.rs:+6:14: +6:24\n+      let mut _13: &mut std::ops::Range<usize>; // in scope 0 at $DIR/issue_107511.rs:+6:14: +6:24\n+      let mut _14: isize;                  // in scope 0 at $DIR/issue_107511.rs:+6:5: +8:6\n+      let mut _15: !;                      // in scope 0 at $DIR/issue_107511.rs:+6:5: +8:6\n+      let mut _17: i32;                    // in scope 0 at $DIR/issue_107511.rs:+7:16: +7:20\n+      let _18: usize;                      // in scope 0 at $DIR/issue_107511.rs:+7:18: +7:19\n+      let mut _19: usize;                  // in scope 0 at $DIR/issue_107511.rs:+7:16: +7:20\n+      let mut _20: bool;                   // in scope 0 at $DIR/issue_107511.rs:+7:16: +7:20\n+      scope 1 {\n+          debug sum => _1;                 // in scope 1 at $DIR/issue_107511.rs:+1:9: +1:16\n+          let _2: [i32; 4];                // in scope 1 at $DIR/issue_107511.rs:+2:9: +2:10\n+          scope 2 {\n+              debug a => _2;               // in scope 2 at $DIR/issue_107511.rs:+2:9: +2:10\n+              let mut _8: std::ops::Range<usize>; // in scope 2 at $DIR/issue_107511.rs:+6:14: +6:24\n+              scope 3 {\n+                  debug iter => _8;        // in scope 3 at $DIR/issue_107511.rs:+6:14: +6:24\n+                  let _16: usize;          // in scope 3 at $DIR/issue_107511.rs:+6:9: +6:10\n+                  scope 4 {\n+                      debug i => _16;      // in scope 4 at $DIR/issue_107511.rs:+6:9: +6:10\n+                  }\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/issue_107511.rs:+1:9: +1:16\n+          _1 = const 0_i32;                // scope 0 at $DIR/issue_107511.rs:+1:19: +1:20\n+          StorageLive(_2);                 // scope 1 at $DIR/issue_107511.rs:+2:9: +2:10\n+          _2 = [const 0_i32, const 10_i32, const 20_i32, const 30_i32]; // scope 1 at $DIR/issue_107511.rs:+2:13: +2:28\n+          StorageLive(_3);                 // scope 2 at $DIR/issue_107511.rs:+6:14: +6:24\n+          StorageLive(_4);                 // scope 2 at $DIR/issue_107511.rs:+6:14: +6:24\n+          StorageLive(_5);                 // scope 2 at $DIR/issue_107511.rs:+6:17: +6:24\n+          StorageLive(_6);                 // scope 2 at $DIR/issue_107511.rs:+6:17: +6:24\n+          StorageLive(_7);                 // scope 2 at $DIR/issue_107511.rs:+6:17: +6:24\n+          _7 = &_2;                        // scope 2 at $DIR/issue_107511.rs:+6:17: +6:24\n+          _6 = move _7 as &[i32] (Pointer(Unsize)); // scope 2 at $DIR/issue_107511.rs:+6:17: +6:24\n+          StorageDead(_7);                 // scope 2 at $DIR/issue_107511.rs:+6:17: +6:18\n+          _5 = core::slice::<impl [i32]>::len(move _6) -> bb1; // scope 2 at $DIR/issue_107511.rs:+6:17: +6:24\n+                                           // mir::Constant\n+                                           // + span: $DIR/issue_107511.rs:10:19: 10:22\n+                                           // + literal: Const { ty: for<'a> fn(&'a [i32]) -> usize {core::slice::<impl [i32]>::len}, val: Value(<ZST>) }\n+      }\n+  \n+      bb1: {\n+          StorageDead(_6);                 // scope 2 at $DIR/issue_107511.rs:+6:23: +6:24\n+          _4 = std::ops::Range::<usize> { start: const 0_usize, end: move _5 }; // scope 2 at $DIR/issue_107511.rs:+6:14: +6:24\n+          StorageDead(_5);                 // scope 2 at $DIR/issue_107511.rs:+6:23: +6:24\n+          _3 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _4) -> bb2; // scope 2 at $DIR/issue_107511.rs:+6:14: +6:24\n+                                           // mir::Constant\n+                                           // + span: $DIR/issue_107511.rs:10:14: 10:24\n+                                           // + literal: Const { ty: fn(std::ops::Range<usize>) -> <std::ops::Range<usize> as IntoIterator>::IntoIter {<std::ops::Range<usize> as IntoIterator>::into_iter}, val: Value(<ZST>) }\n+      }\n+  \n+      bb2: {\n+          StorageDead(_4);                 // scope 2 at $DIR/issue_107511.rs:+6:23: +6:24\n+          StorageLive(_8);                 // scope 2 at $DIR/issue_107511.rs:+6:14: +6:24\n+          _8 = move _3;                    // scope 2 at $DIR/issue_107511.rs:+6:14: +6:24\n+          goto -> bb3;                     // scope 3 at $DIR/issue_107511.rs:+6:5: +8:6\n+      }\n+  \n+      bb3: {\n+-         StorageLive(_10);                // scope 3 at $DIR/issue_107511.rs:+6:14: +6:24\n+          StorageLive(_11);                // scope 3 at $DIR/issue_107511.rs:+6:14: +6:24\n+          StorageLive(_12);                // scope 3 at $DIR/issue_107511.rs:+6:14: +6:24\n+          StorageLive(_13);                // scope 3 at $DIR/issue_107511.rs:+6:14: +6:24\n+          _13 = &mut _8;                   // scope 3 at $DIR/issue_107511.rs:+6:14: +6:24\n+          _12 = &mut (*_13);               // scope 3 at $DIR/issue_107511.rs:+6:14: +6:24\n+          _11 = <std::ops::Range<usize> as Iterator>::next(move _12) -> bb4; // scope 3 at $DIR/issue_107511.rs:+6:14: +6:24\n+                                           // mir::Constant\n+                                           // + span: $DIR/issue_107511.rs:10:14: 10:24\n+                                           // + literal: Const { ty: for<'a> fn(&'a mut std::ops::Range<usize>) -> Option<<std::ops::Range<usize> as Iterator>::Item> {<std::ops::Range<usize> as Iterator>::next}, val: Value(<ZST>) }\n+      }\n+  \n+      bb4: {\n+          StorageDead(_12);                // scope 3 at $DIR/issue_107511.rs:+6:23: +6:24\n+          _14 = discriminant(_11);         // scope 3 at $DIR/issue_107511.rs:+6:14: +6:24\n+          switchInt(move _14) -> [0: bb7, 1: bb5, otherwise: bb6]; // scope 3 at $DIR/issue_107511.rs:+6:14: +6:24\n+      }\n+  \n+      bb5: {\n+-         StorageLive(_16);                // scope 3 at $DIR/issue_107511.rs:+6:9: +6:10\n+          _16 = ((_11 as Some).0: usize);  // scope 3 at $DIR/issue_107511.rs:+6:9: +6:10\n+          StorageLive(_17);                // scope 4 at $DIR/issue_107511.rs:+7:16: +7:20\n+-         StorageLive(_18);                // scope 4 at $DIR/issue_107511.rs:+7:18: +7:19\n+-         _18 = _16;                       // scope 4 at $DIR/issue_107511.rs:+7:18: +7:19\n+          _19 = Len(_2);                   // scope 4 at $DIR/issue_107511.rs:+7:16: +7:20\n+-         _20 = Lt(_18, _19);              // scope 4 at $DIR/issue_107511.rs:+7:16: +7:20\n+-         assert(move _20, \"index out of bounds: the length is {} but the index is {}\", move _19, _18) -> bb8; // scope 4 at $DIR/issue_107511.rs:+7:16: +7:20\n++         _20 = Lt(_16, _19);              // scope 4 at $DIR/issue_107511.rs:+7:16: +7:20\n++         assert(move _20, \"index out of bounds: the length is {} but the index is {}\", move _19, _16) -> bb8; // scope 4 at $DIR/issue_107511.rs:+7:16: +7:20\n+      }\n+  \n+      bb6: {\n+          unreachable;                     // scope 3 at $DIR/issue_107511.rs:+6:14: +6:24\n+      }\n+  \n+      bb7: {\n+          _0 = const ();                   // scope 3 at $DIR/issue_107511.rs:+6:5: +8:6\n+          StorageDead(_13);                // scope 3 at $DIR/issue_107511.rs:+8:5: +8:6\n+          StorageDead(_11);                // scope 3 at $DIR/issue_107511.rs:+8:5: +8:6\n+-         StorageDead(_10);                // scope 3 at $DIR/issue_107511.rs:+8:5: +8:6\n+          StorageDead(_8);                 // scope 2 at $DIR/issue_107511.rs:+8:5: +8:6\n+          StorageDead(_3);                 // scope 2 at $DIR/issue_107511.rs:+8:5: +8:6\n+          StorageDead(_2);                 // scope 1 at $DIR/issue_107511.rs:+9:1: +9:2\n+          StorageDead(_1);                 // scope 0 at $DIR/issue_107511.rs:+9:1: +9:2\n+          return;                          // scope 0 at $DIR/issue_107511.rs:+9:2: +9:2\n+      }\n+  \n+      bb8: {\n+-         _17 = _2[_18];                   // scope 4 at $DIR/issue_107511.rs:+7:16: +7:20\n++         _17 = _2[_16];                   // scope 4 at $DIR/issue_107511.rs:+7:16: +7:20\n+          _1 = Add(_1, move _17);          // scope 4 at $DIR/issue_107511.rs:+7:9: +7:20\n+          StorageDead(_17);                // scope 4 at $DIR/issue_107511.rs:+7:19: +7:20\n+-         StorageDead(_18);                // scope 4 at $DIR/issue_107511.rs:+7:20: +7:21\n+-         _10 = const ();                  // scope 4 at $DIR/issue_107511.rs:+6:25: +8:6\n+-         StorageDead(_16);                // scope 3 at $DIR/issue_107511.rs:+8:5: +8:6\n+          StorageDead(_13);                // scope 3 at $DIR/issue_107511.rs:+8:5: +8:6\n+          StorageDead(_11);                // scope 3 at $DIR/issue_107511.rs:+8:5: +8:6\n+-         StorageDead(_10);                // scope 3 at $DIR/issue_107511.rs:+8:5: +8:6\n+-         _9 = const ();                   // scope 3 at $DIR/issue_107511.rs:+6:5: +8:6\n+          goto -> bb3;                     // scope 3 at $DIR/issue_107511.rs:+6:5: +8:6\n+      }\n+  }\n+  "}, {"sha": "d593f2872ea40b950ad36978db8b63acbc5319a5", "filename": "tests/mir-opt/copy-prop/issue_107511.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fcopy-prop%2Fissue_107511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fcopy-prop%2Fissue_107511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcopy-prop%2Fissue_107511.rs?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -0,0 +1,13 @@\n+// unit-test: CopyProp\n+\n+// EMIT_MIR issue_107511.main.CopyProp.diff\n+fn main() {\n+    let mut sum = 0;\n+    let a = [0, 10, 20, 30];\n+\n+    // `i` is assigned in a loop. Only removing its `StorageDead` would mean that\n+    // execution sees repeated `StorageLive`. This would be UB.\n+    for i in 0..a.len() {\n+        sum += a[i];\n+    }\n+}"}, {"sha": "d049c79d78deff2502ead980cb2ae0f4e45de9e5", "filename": "tests/mir-opt/dataflow-const-prop/enum.main.DataflowConstProp.diff", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.main.DataflowConstProp.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -23,9 +23,7 @@\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/enum.rs:+1:9: +1:10\n-          Deinit(_1);                      // scope 0 at $DIR/enum.rs:+1:13: +1:21\n-          ((_1 as V1).0: i32) = const 0_i32; // scope 0 at $DIR/enum.rs:+1:13: +1:21\n-          discriminant(_1) = 0;            // scope 0 at $DIR/enum.rs:+1:13: +1:21\n+          _1 = E::V1(const 0_i32);         // scope 0 at $DIR/enum.rs:+1:13: +1:21\n           StorageLive(_2);                 // scope 1 at $DIR/enum.rs:+2:9: +2:10\n           _3 = discriminant(_1);           // scope 1 at $DIR/enum.rs:+2:19: +2:20\n           switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2]; // scope 1 at $DIR/enum.rs:+2:13: +2:20"}, {"sha": "9c3f87f47c12c0ebab94e7691ada61e6f4ca4e79", "filename": "tests/mir-opt/dataflow-const-prop/inherit_overflow.main.DataflowConstProp.diff", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdataflow-const-prop%2Finherit_overflow.main.DataflowConstProp.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -16,9 +16,7 @@\n       }\n   \n       bb0: {\n-          StorageLive(_1);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n           _1 = const u8::MAX;              // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n-          StorageLive(_2);                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n           _2 = const 1_u8;                 // scope 0 at $DIR/inherit_overflow.rs:+3:13: +3:47\n           _5 = CheckedAdd(const u8::MAX, const 1_u8); // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL\n           assert(!move (_5.1: bool), \"attempt to compute `{} + {}`, which would overflow\", const u8::MAX, const 1_u8) -> bb1; // scope 2 at $SRC_DIR/core/src/ops/arith.rs:LL:COL"}, {"sha": "8f045eedfb05801413d24cb49b8faf8a6fe2bfc4", "filename": "tests/mir-opt/dataflow-const-prop/repr_transparent.main.DataflowConstProp.diff", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fdataflow-const-prop%2Frepr_transparent.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fdataflow-const-prop%2Frepr_transparent.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdataflow-const-prop%2Frepr_transparent.main.DataflowConstProp.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -17,8 +17,7 @@\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/repr_transparent.rs:+1:9: +1:10\n-          Deinit(_1);                      // scope 0 at $DIR/repr_transparent.rs:+1:13: +1:19\n-          (_1.0: i32) = const 0_i32;       // scope 0 at $DIR/repr_transparent.rs:+1:13: +1:19\n+          _1 = I32(const 0_i32);           // scope 0 at $DIR/repr_transparent.rs:+1:13: +1:19\n           StorageLive(_2);                 // scope 1 at $DIR/repr_transparent.rs:+2:9: +2:10\n           StorageLive(_3);                 // scope 1 at $DIR/repr_transparent.rs:+2:17: +2:26\n           StorageLive(_4);                 // scope 1 at $DIR/repr_transparent.rs:+2:17: +2:20\n@@ -31,9 +30,8 @@\n +         _3 = const 0_i32;                // scope 1 at $DIR/repr_transparent.rs:+2:17: +2:26\n           StorageDead(_5);                 // scope 1 at $DIR/repr_transparent.rs:+2:25: +2:26\n           StorageDead(_4);                 // scope 1 at $DIR/repr_transparent.rs:+2:25: +2:26\n-          Deinit(_2);                      // scope 1 at $DIR/repr_transparent.rs:+2:13: +2:27\n--         (_2.0: i32) = move _3;           // scope 1 at $DIR/repr_transparent.rs:+2:13: +2:27\n-+         (_2.0: i32) = const 0_i32;       // scope 1 at $DIR/repr_transparent.rs:+2:13: +2:27\n+-         _2 = I32(move _3);               // scope 1 at $DIR/repr_transparent.rs:+2:13: +2:27\n++         _2 = I32(const 0_i32);           // scope 1 at $DIR/repr_transparent.rs:+2:13: +2:27\n           StorageDead(_3);                 // scope 1 at $DIR/repr_transparent.rs:+2:26: +2:27\n           _0 = const ();                   // scope 0 at $DIR/repr_transparent.rs:+0:11: +3:2\n           StorageDead(_2);                 // scope 1 at $DIR/repr_transparent.rs:+3:1: +3:2"}, {"sha": "a91a755830d1507b651cd3ecd26ea9dde64df7f7", "filename": "tests/mir-opt/dataflow-const-prop/sibling_ptr.main.DataflowConstProp.diff", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fdataflow-const-prop%2Fsibling_ptr.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fdataflow-const-prop%2Fsibling_ptr.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdataflow-const-prop%2Fsibling_ptr.main.DataflowConstProp.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -23,9 +23,7 @@\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/sibling_ptr.rs:+1:9: +1:14\n-          Deinit(_1);                      // scope 0 at $DIR/sibling_ptr.rs:+1:27: +1:33\n-          (_1.0: u8) = const 0_u8;         // scope 0 at $DIR/sibling_ptr.rs:+1:27: +1:33\n-          (_1.1: u8) = const 0_u8;         // scope 0 at $DIR/sibling_ptr.rs:+1:27: +1:33\n+          _1 = (const 0_u8, const 0_u8);   // scope 0 at $DIR/sibling_ptr.rs:+1:27: +1:33\n           StorageLive(_2);                 // scope 1 at $DIR/sibling_ptr.rs:+2:5: +5:6\n           StorageLive(_3);                 // scope 2 at $DIR/sibling_ptr.rs:+3:13: +3:14\n           _3 = &raw mut (_1.0: u8);        // scope 2 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL"}, {"sha": "53c62c0817391d51705e060ad9b1b1c811eebb6e", "filename": "tests/mir-opt/dataflow-const-prop/struct.main.DataflowConstProp.diff", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fdataflow-const-prop%2Fstruct.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fdataflow-const-prop%2Fstruct.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdataflow-const-prop%2Fstruct.main.DataflowConstProp.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -21,8 +21,7 @@\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/struct.rs:+1:9: +1:14\n-          Deinit(_1);                      // scope 0 at $DIR/struct.rs:+1:17: +1:21\n-          (_1.0: i32) = const 1_i32;       // scope 0 at $DIR/struct.rs:+1:17: +1:21\n+          _1 = S(const 1_i32);             // scope 0 at $DIR/struct.rs:+1:17: +1:21\n           StorageLive(_2);                 // scope 1 at $DIR/struct.rs:+2:9: +2:10\n           StorageLive(_3);                 // scope 1 at $DIR/struct.rs:+2:13: +2:16\n -         _3 = (_1.0: i32);                // scope 1 at $DIR/struct.rs:+2:13: +2:16"}, {"sha": "8ce4ce4ba976d1e42ffd78480ad38793037520e5", "filename": "tests/mir-opt/dataflow-const-prop/tuple.main.DataflowConstProp.diff", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fdataflow-const-prop%2Ftuple.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fdataflow-const-prop%2Ftuple.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdataflow-const-prop%2Ftuple.main.DataflowConstProp.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -25,9 +25,7 @@\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/tuple.rs:+1:9: +1:14\n-          Deinit(_1);                      // scope 0 at $DIR/tuple.rs:+1:17: +1:23\n-          (_1.0: i32) = const 1_i32;       // scope 0 at $DIR/tuple.rs:+1:17: +1:23\n-          (_1.1: i32) = const 2_i32;       // scope 0 at $DIR/tuple.rs:+1:17: +1:23\n+          _1 = (const 1_i32, const 2_i32); // scope 0 at $DIR/tuple.rs:+1:17: +1:23\n           StorageLive(_2);                 // scope 1 at $DIR/tuple.rs:+2:9: +2:10\n           StorageLive(_3);                 // scope 1 at $DIR/tuple.rs:+2:13: +2:22\n           StorageLive(_4);                 // scope 1 at $DIR/tuple.rs:+2:13: +2:16\n@@ -43,9 +41,7 @@\n -         _2 = Add(move _3, const 3_i32);  // scope 1 at $DIR/tuple.rs:+2:13: +2:26\n +         _2 = const 6_i32;                // scope 1 at $DIR/tuple.rs:+2:13: +2:26\n           StorageDead(_3);                 // scope 1 at $DIR/tuple.rs:+2:25: +2:26\n-          Deinit(_1);                      // scope 2 at $DIR/tuple.rs:+3:5: +3:15\n-          (_1.0: i32) = const 2_i32;       // scope 2 at $DIR/tuple.rs:+3:5: +3:15\n-          (_1.1: i32) = const 3_i32;       // scope 2 at $DIR/tuple.rs:+3:5: +3:15\n+          _1 = (const 2_i32, const 3_i32); // scope 2 at $DIR/tuple.rs:+3:5: +3:15\n           StorageLive(_6);                 // scope 2 at $DIR/tuple.rs:+4:9: +4:10\n           StorageLive(_7);                 // scope 2 at $DIR/tuple.rs:+4:13: +4:22\n           StorageLive(_8);                 // scope 2 at $DIR/tuple.rs:+4:13: +4:16"}, {"sha": "db136485a21152e886ed324af07dbd29e414c95c", "filename": "tests/mir-opt/deaggregator_test.bar.Deaggregator.diff", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6c8d4073a4490671b05f3b5f5e6810cfdc23a641/tests%2Fmir-opt%2Fdeaggregator_test.bar.Deaggregator.diff", "raw_url": "https://github.com/rust-lang/rust/raw/6c8d4073a4490671b05f3b5f5e6810cfdc23a641/tests%2Fmir-opt%2Fdeaggregator_test.bar.Deaggregator.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdeaggregator_test.bar.Deaggregator.diff?ref=6c8d4073a4490671b05f3b5f5e6810cfdc23a641", "patch": "@@ -1,21 +0,0 @@\n-- // MIR for `bar` before Deaggregator\n-+ // MIR for `bar` after Deaggregator\n-  \n-  fn bar(_1: usize) -> Baz {\n-      debug a => _1;                       // in scope 0 at $DIR/deaggregator_test.rs:+0:8: +0:9\n-      let mut _0: Baz;                     // return place in scope 0 at $DIR/deaggregator_test.rs:+0:21: +0:24\n-      let mut _2: usize;                   // in scope 0 at $DIR/deaggregator_test.rs:+1:14: +1:15\n-  \n-      bb0: {\n-          StorageLive(_2);                 // scope 0 at $DIR/deaggregator_test.rs:+1:14: +1:15\n-          _2 = _1;                         // scope 0 at $DIR/deaggregator_test.rs:+1:14: +1:15\n--         _0 = Baz { x: move _2, y: const 0f32, z: const false }; // scope 0 at $DIR/deaggregator_test.rs:+1:5: +1:35\n-+         Deinit(_0);                      // scope 0 at $DIR/deaggregator_test.rs:+1:5: +1:35\n-+         (_0.0: usize) = move _2;         // scope 0 at $DIR/deaggregator_test.rs:+1:5: +1:35\n-+         (_0.1: f32) = const 0f32;        // scope 0 at $DIR/deaggregator_test.rs:+1:5: +1:35\n-+         (_0.2: bool) = const false;      // scope 0 at $DIR/deaggregator_test.rs:+1:5: +1:35\n-          StorageDead(_2);                 // scope 0 at $DIR/deaggregator_test.rs:+1:34: +1:35\n-          return;                          // scope 0 at $DIR/deaggregator_test.rs:+2:2: +2:2\n-      }\n-  }\n-  "}, {"sha": "ee59402af386ba1d16ec8ffd93edfd1889acc608", "filename": "tests/mir-opt/deaggregator_test.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6c8d4073a4490671b05f3b5f5e6810cfdc23a641/tests%2Fmir-opt%2Fdeaggregator_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8d4073a4490671b05f3b5f5e6810cfdc23a641/tests%2Fmir-opt%2Fdeaggregator_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdeaggregator_test.rs?ref=6c8d4073a4490671b05f3b5f5e6810cfdc23a641", "patch": "@@ -1,17 +0,0 @@\n-// unit-test: Deaggregator\n-\n-struct Baz {\n-    x: usize,\n-    y: f32,\n-    z: bool,\n-}\n-\n-// EMIT_MIR deaggregator_test.bar.Deaggregator.diff\n-fn bar(a: usize) -> Baz {\n-    Baz { x: a, y: 0.0, z: false }\n-}\n-\n-fn main() {\n-    // Make sure the function actually gets instantiated.\n-    bar(0);\n-}"}, {"sha": "f28c2b482af2dd6dc03d729651af0454a8466713", "filename": "tests/mir-opt/deaggregator_test_enum.bar.Deaggregator.diff", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6c8d4073a4490671b05f3b5f5e6810cfdc23a641/tests%2Fmir-opt%2Fdeaggregator_test_enum.bar.Deaggregator.diff", "raw_url": "https://github.com/rust-lang/rust/raw/6c8d4073a4490671b05f3b5f5e6810cfdc23a641/tests%2Fmir-opt%2Fdeaggregator_test_enum.bar.Deaggregator.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdeaggregator_test_enum.bar.Deaggregator.diff?ref=6c8d4073a4490671b05f3b5f5e6810cfdc23a641", "patch": "@@ -1,20 +0,0 @@\n-- // MIR for `bar` before Deaggregator\n-+ // MIR for `bar` after Deaggregator\n-  \n-  fn bar(_1: usize) -> Baz {\n-      debug a => _1;                       // in scope 0 at $DIR/deaggregator_test_enum.rs:+0:8: +0:9\n-      let mut _0: Baz;                     // return place in scope 0 at $DIR/deaggregator_test_enum.rs:+0:21: +0:24\n-      let mut _2: usize;                   // in scope 0 at $DIR/deaggregator_test_enum.rs:+1:19: +1:20\n-  \n-      bb0: {\n-          StorageLive(_2);                 // scope 0 at $DIR/deaggregator_test_enum.rs:+1:19: +1:20\n-          _2 = _1;                         // scope 0 at $DIR/deaggregator_test_enum.rs:+1:19: +1:20\n--         _0 = Baz::Foo { x: move _2 };    // scope 0 at $DIR/deaggregator_test_enum.rs:+1:5: +1:22\n-+         Deinit(_0);                      // scope 0 at $DIR/deaggregator_test_enum.rs:+1:5: +1:22\n-+         ((_0 as Foo).0: usize) = move _2; // scope 0 at $DIR/deaggregator_test_enum.rs:+1:5: +1:22\n-+         discriminant(_0) = 1;            // scope 0 at $DIR/deaggregator_test_enum.rs:+1:5: +1:22\n-          StorageDead(_2);                 // scope 0 at $DIR/deaggregator_test_enum.rs:+1:21: +1:22\n-          return;                          // scope 0 at $DIR/deaggregator_test_enum.rs:+2:2: +2:2\n-      }\n-  }\n-  "}, {"sha": "ea402dafdec7a8f23cebe29f036f1f05aea64d1c", "filename": "tests/mir-opt/deaggregator_test_enum.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6c8d4073a4490671b05f3b5f5e6810cfdc23a641/tests%2Fmir-opt%2Fdeaggregator_test_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8d4073a4490671b05f3b5f5e6810cfdc23a641/tests%2Fmir-opt%2Fdeaggregator_test_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdeaggregator_test_enum.rs?ref=6c8d4073a4490671b05f3b5f5e6810cfdc23a641", "patch": "@@ -1,19 +0,0 @@\n-// unit-test: Deaggregator\n-\n-enum Baz {\n-    Empty,\n-    Foo { x: usize },\n-}\n-\n-// EMIT_MIR deaggregator_test_enum.bar.Deaggregator.diff\n-fn bar(a: usize) -> Baz {\n-    Baz::Foo { x: a }\n-}\n-\n-fn main() {\n-    let x = bar(10);\n-    match x {\n-        Baz::Empty => println!(\"empty\"),\n-        Baz::Foo { x } => println!(\"{}\", x),\n-    };\n-}"}, {"sha": "955c317324aa8418059bfc7635dda5521e825df8", "filename": "tests/mir-opt/deaggregator_test_enum_2.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6c8d4073a4490671b05f3b5f5e6810cfdc23a641/tests%2Fmir-opt%2Fdeaggregator_test_enum_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8d4073a4490671b05f3b5f5e6810cfdc23a641/tests%2Fmir-opt%2Fdeaggregator_test_enum_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdeaggregator_test_enum_2.rs?ref=6c8d4073a4490671b05f3b5f5e6810cfdc23a641", "patch": "@@ -1,21 +0,0 @@\n-// unit-test: Deaggregator\n-// Test that deaggregate fires in more than one basic block\n-\n-enum Foo {\n-    A(i32),\n-    B(i32),\n-}\n-\n-// EMIT_MIR deaggregator_test_enum_2.test1.Deaggregator.diff\n-fn test1(x: bool, y: i32) -> Foo {\n-    if x {\n-        Foo::A(y)\n-    } else {\n-        Foo::B(y)\n-    }\n-}\n-\n-fn main() {\n-    // Make sure the function actually gets instantiated.\n-    test1(false, 0);\n-}"}, {"sha": "210d3849e18a106bb1e76987b5934588e335ba34", "filename": "tests/mir-opt/deaggregator_test_enum_2.test1.Deaggregator.diff", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6c8d4073a4490671b05f3b5f5e6810cfdc23a641/tests%2Fmir-opt%2Fdeaggregator_test_enum_2.test1.Deaggregator.diff", "raw_url": "https://github.com/rust-lang/rust/raw/6c8d4073a4490671b05f3b5f5e6810cfdc23a641/tests%2Fmir-opt%2Fdeaggregator_test_enum_2.test1.Deaggregator.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdeaggregator_test_enum_2.test1.Deaggregator.diff?ref=6c8d4073a4490671b05f3b5f5e6810cfdc23a641", "patch": "@@ -1,45 +0,0 @@\n-- // MIR for `test1` before Deaggregator\n-+ // MIR for `test1` after Deaggregator\n-  \n-  fn test1(_1: bool, _2: i32) -> Foo {\n-      debug x => _1;                       // in scope 0 at $DIR/deaggregator_test_enum_2.rs:+0:10: +0:11\n-      debug y => _2;                       // in scope 0 at $DIR/deaggregator_test_enum_2.rs:+0:19: +0:20\n-      let mut _0: Foo;                     // return place in scope 0 at $DIR/deaggregator_test_enum_2.rs:+0:30: +0:33\n-      let mut _3: bool;                    // in scope 0 at $DIR/deaggregator_test_enum_2.rs:+1:8: +1:9\n-      let mut _4: i32;                     // in scope 0 at $DIR/deaggregator_test_enum_2.rs:+2:16: +2:17\n-      let mut _5: i32;                     // in scope 0 at $DIR/deaggregator_test_enum_2.rs:+4:16: +4:17\n-  \n-      bb0: {\n-          StorageLive(_3);                 // scope 0 at $DIR/deaggregator_test_enum_2.rs:+1:8: +1:9\n-          _3 = _1;                         // scope 0 at $DIR/deaggregator_test_enum_2.rs:+1:8: +1:9\n-          switchInt(move _3) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/deaggregator_test_enum_2.rs:+1:8: +1:9\n-      }\n-  \n-      bb1: {\n-          StorageLive(_4);                 // scope 0 at $DIR/deaggregator_test_enum_2.rs:+2:16: +2:17\n-          _4 = _2;                         // scope 0 at $DIR/deaggregator_test_enum_2.rs:+2:16: +2:17\n--         _0 = Foo::A(move _4);            // scope 0 at $DIR/deaggregator_test_enum_2.rs:+2:9: +2:18\n-+         Deinit(_0);                      // scope 0 at $DIR/deaggregator_test_enum_2.rs:+2:9: +2:18\n-+         ((_0 as A).0: i32) = move _4;    // scope 0 at $DIR/deaggregator_test_enum_2.rs:+2:9: +2:18\n-+         discriminant(_0) = 0;            // scope 0 at $DIR/deaggregator_test_enum_2.rs:+2:9: +2:18\n-          StorageDead(_4);                 // scope 0 at $DIR/deaggregator_test_enum_2.rs:+2:17: +2:18\n-          goto -> bb3;                     // scope 0 at $DIR/deaggregator_test_enum_2.rs:+1:5: +5:6\n-      }\n-  \n-      bb2: {\n-          StorageLive(_5);                 // scope 0 at $DIR/deaggregator_test_enum_2.rs:+4:16: +4:17\n-          _5 = _2;                         // scope 0 at $DIR/deaggregator_test_enum_2.rs:+4:16: +4:17\n--         _0 = Foo::B(move _5);            // scope 0 at $DIR/deaggregator_test_enum_2.rs:+4:9: +4:18\n-+         Deinit(_0);                      // scope 0 at $DIR/deaggregator_test_enum_2.rs:+4:9: +4:18\n-+         ((_0 as B).0: i32) = move _5;    // scope 0 at $DIR/deaggregator_test_enum_2.rs:+4:9: +4:18\n-+         discriminant(_0) = 1;            // scope 0 at $DIR/deaggregator_test_enum_2.rs:+4:9: +4:18\n-          StorageDead(_5);                 // scope 0 at $DIR/deaggregator_test_enum_2.rs:+4:17: +4:18\n-          goto -> bb3;                     // scope 0 at $DIR/deaggregator_test_enum_2.rs:+1:5: +5:6\n-      }\n-  \n-      bb3: {\n-          StorageDead(_3);                 // scope 0 at $DIR/deaggregator_test_enum_2.rs:+5:5: +5:6\n-          return;                          // scope 0 at $DIR/deaggregator_test_enum_2.rs:+6:2: +6:2\n-      }\n-  }\n-  "}, {"sha": "46305fe21d28c2c33d325974fb8f6cd1e7bb4b53", "filename": "tests/mir-opt/deaggregator_test_multiple.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6c8d4073a4490671b05f3b5f5e6810cfdc23a641/tests%2Fmir-opt%2Fdeaggregator_test_multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8d4073a4490671b05f3b5f5e6810cfdc23a641/tests%2Fmir-opt%2Fdeaggregator_test_multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdeaggregator_test_multiple.rs?ref=6c8d4073a4490671b05f3b5f5e6810cfdc23a641", "patch": "@@ -1,17 +0,0 @@\n-// unit-test: Deaggregator\n-// Test that deaggregate fires more than once per block\n-\n-enum Foo {\n-    A(i32),\n-    B,\n-}\n-\n-// EMIT_MIR deaggregator_test_multiple.test.Deaggregator.diff\n-fn test(x: i32) -> [Foo; 2] {\n-    [Foo::A(x), Foo::A(x)]\n-}\n-\n-fn main() {\n-    // Make sure the function actually gets instantiated.\n-    test(0);\n-}"}, {"sha": "cf5da273c2894ffa4112404a37b28a536703702e", "filename": "tests/mir-opt/deaggregator_test_multiple.test.Deaggregator.diff", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6c8d4073a4490671b05f3b5f5e6810cfdc23a641/tests%2Fmir-opt%2Fdeaggregator_test_multiple.test.Deaggregator.diff", "raw_url": "https://github.com/rust-lang/rust/raw/6c8d4073a4490671b05f3b5f5e6810cfdc23a641/tests%2Fmir-opt%2Fdeaggregator_test_multiple.test.Deaggregator.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdeaggregator_test_multiple.test.Deaggregator.diff?ref=6c8d4073a4490671b05f3b5f5e6810cfdc23a641", "patch": "@@ -1,35 +0,0 @@\n-- // MIR for `test` before Deaggregator\n-+ // MIR for `test` after Deaggregator\n-  \n-  fn test(_1: i32) -> [Foo; 2] {\n-      debug x => _1;                       // in scope 0 at $DIR/deaggregator_test_multiple.rs:+0:9: +0:10\n-      let mut _0: [Foo; 2];                // return place in scope 0 at $DIR/deaggregator_test_multiple.rs:+0:20: +0:28\n-      let mut _2: Foo;                     // in scope 0 at $DIR/deaggregator_test_multiple.rs:+1:6: +1:15\n-      let mut _3: i32;                     // in scope 0 at $DIR/deaggregator_test_multiple.rs:+1:13: +1:14\n-      let mut _4: Foo;                     // in scope 0 at $DIR/deaggregator_test_multiple.rs:+1:17: +1:26\n-      let mut _5: i32;                     // in scope 0 at $DIR/deaggregator_test_multiple.rs:+1:24: +1:25\n-  \n-      bb0: {\n-          StorageLive(_2);                 // scope 0 at $DIR/deaggregator_test_multiple.rs:+1:6: +1:15\n-          StorageLive(_3);                 // scope 0 at $DIR/deaggregator_test_multiple.rs:+1:13: +1:14\n-          _3 = _1;                         // scope 0 at $DIR/deaggregator_test_multiple.rs:+1:13: +1:14\n--         _2 = Foo::A(move _3);            // scope 0 at $DIR/deaggregator_test_multiple.rs:+1:6: +1:15\n-+         Deinit(_2);                      // scope 0 at $DIR/deaggregator_test_multiple.rs:+1:6: +1:15\n-+         ((_2 as A).0: i32) = move _3;    // scope 0 at $DIR/deaggregator_test_multiple.rs:+1:6: +1:15\n-+         discriminant(_2) = 0;            // scope 0 at $DIR/deaggregator_test_multiple.rs:+1:6: +1:15\n-          StorageDead(_3);                 // scope 0 at $DIR/deaggregator_test_multiple.rs:+1:14: +1:15\n-          StorageLive(_4);                 // scope 0 at $DIR/deaggregator_test_multiple.rs:+1:17: +1:26\n-          StorageLive(_5);                 // scope 0 at $DIR/deaggregator_test_multiple.rs:+1:24: +1:25\n-          _5 = _1;                         // scope 0 at $DIR/deaggregator_test_multiple.rs:+1:24: +1:25\n--         _4 = Foo::A(move _5);            // scope 0 at $DIR/deaggregator_test_multiple.rs:+1:17: +1:26\n-+         Deinit(_4);                      // scope 0 at $DIR/deaggregator_test_multiple.rs:+1:17: +1:26\n-+         ((_4 as A).0: i32) = move _5;    // scope 0 at $DIR/deaggregator_test_multiple.rs:+1:17: +1:26\n-+         discriminant(_4) = 0;            // scope 0 at $DIR/deaggregator_test_multiple.rs:+1:17: +1:26\n-          StorageDead(_5);                 // scope 0 at $DIR/deaggregator_test_multiple.rs:+1:25: +1:26\n-          _0 = [move _2, move _4];         // scope 0 at $DIR/deaggregator_test_multiple.rs:+1:5: +1:27\n-          StorageDead(_4);                 // scope 0 at $DIR/deaggregator_test_multiple.rs:+1:26: +1:27\n-          StorageDead(_2);                 // scope 0 at $DIR/deaggregator_test_multiple.rs:+1:26: +1:27\n-          return;                          // scope 0 at $DIR/deaggregator_test_multiple.rs:+2:2: +2:2\n-      }\n-  }\n-  "}, {"sha": "5383d1be129823618bb50b694a8d9bda6e56d624", "filename": "tests/mir-opt/early_otherwise_branch.opt1.EarlyOtherwiseBranch.diff", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fearly_otherwise_branch.opt1.EarlyOtherwiseBranch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fearly_otherwise_branch.opt1.EarlyOtherwiseBranch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fearly_otherwise_branch.opt1.EarlyOtherwiseBranch.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -25,9 +25,7 @@\n           _4 = _1;                         // scope 0 at $DIR/early_otherwise_branch.rs:+1:12: +1:13\n           StorageLive(_5);                 // scope 0 at $DIR/early_otherwise_branch.rs:+1:15: +1:16\n           _5 = _2;                         // scope 0 at $DIR/early_otherwise_branch.rs:+1:15: +1:16\n-          Deinit(_3);                      // scope 0 at $DIR/early_otherwise_branch.rs:+1:11: +1:17\n-          (_3.0: std::option::Option<u32>) = move _4; // scope 0 at $DIR/early_otherwise_branch.rs:+1:11: +1:17\n-          (_3.1: std::option::Option<u32>) = move _5; // scope 0 at $DIR/early_otherwise_branch.rs:+1:11: +1:17\n+          _3 = (move _4, move _5);         // scope 0 at $DIR/early_otherwise_branch.rs:+1:11: +1:17\n           StorageDead(_5);                 // scope 0 at $DIR/early_otherwise_branch.rs:+1:16: +1:17\n           StorageDead(_4);                 // scope 0 at $DIR/early_otherwise_branch.rs:+1:16: +1:17\n           _7 = discriminant((_3.0: std::option::Option<u32>)); // scope 0 at $DIR/early_otherwise_branch.rs:+1:11: +1:17"}, {"sha": "b3e21ff49bdf3a0a652e73d7c20d9d892f20ffeb", "filename": "tests/mir-opt/early_otherwise_branch.opt2.EarlyOtherwiseBranch.diff", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fearly_otherwise_branch.opt2.EarlyOtherwiseBranch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fearly_otherwise_branch.opt2.EarlyOtherwiseBranch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fearly_otherwise_branch.opt2.EarlyOtherwiseBranch.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -26,9 +26,7 @@\n           _4 = _1;                         // scope 0 at $DIR/early_otherwise_branch.rs:+1:12: +1:13\n           StorageLive(_5);                 // scope 0 at $DIR/early_otherwise_branch.rs:+1:15: +1:16\n           _5 = _2;                         // scope 0 at $DIR/early_otherwise_branch.rs:+1:15: +1:16\n-          Deinit(_3);                      // scope 0 at $DIR/early_otherwise_branch.rs:+1:11: +1:17\n-          (_3.0: std::option::Option<u32>) = move _4; // scope 0 at $DIR/early_otherwise_branch.rs:+1:11: +1:17\n-          (_3.1: std::option::Option<u32>) = move _5; // scope 0 at $DIR/early_otherwise_branch.rs:+1:11: +1:17\n+          _3 = (move _4, move _5);         // scope 0 at $DIR/early_otherwise_branch.rs:+1:11: +1:17\n           StorageDead(_5);                 // scope 0 at $DIR/early_otherwise_branch.rs:+1:16: +1:17\n           StorageDead(_4);                 // scope 0 at $DIR/early_otherwise_branch.rs:+1:16: +1:17\n           _8 = discriminant((_3.0: std::option::Option<u32>)); // scope 0 at $DIR/early_otherwise_branch.rs:+1:11: +1:17"}, {"sha": "e098a88eb5578555b8642cc43d6b1e40f1c12098", "filename": "tests/mir-opt/early_otherwise_branch.opt3.EarlyOtherwiseBranch.diff", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fearly_otherwise_branch.opt3.EarlyOtherwiseBranch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fearly_otherwise_branch.opt3.EarlyOtherwiseBranch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fearly_otherwise_branch.opt3.EarlyOtherwiseBranch.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -25,9 +25,7 @@\n           _4 = _1;                         // scope 0 at $DIR/early_otherwise_branch.rs:+1:12: +1:13\n           StorageLive(_5);                 // scope 0 at $DIR/early_otherwise_branch.rs:+1:15: +1:16\n           _5 = _2;                         // scope 0 at $DIR/early_otherwise_branch.rs:+1:15: +1:16\n-          Deinit(_3);                      // scope 0 at $DIR/early_otherwise_branch.rs:+1:11: +1:17\n-          (_3.0: std::option::Option<u32>) = move _4; // scope 0 at $DIR/early_otherwise_branch.rs:+1:11: +1:17\n-          (_3.1: std::option::Option<bool>) = move _5; // scope 0 at $DIR/early_otherwise_branch.rs:+1:11: +1:17\n+          _3 = (move _4, move _5);         // scope 0 at $DIR/early_otherwise_branch.rs:+1:11: +1:17\n           StorageDead(_5);                 // scope 0 at $DIR/early_otherwise_branch.rs:+1:16: +1:17\n           StorageDead(_4);                 // scope 0 at $DIR/early_otherwise_branch.rs:+1:16: +1:17\n           _7 = discriminant((_3.0: std::option::Option<u32>)); // scope 0 at $DIR/early_otherwise_branch.rs:+1:11: +1:17"}, {"sha": "ec3b4bbdff42f394790b6befc07f15161066ca4a", "filename": "tests/mir-opt/early_otherwise_branch_3_element_tuple.opt1.EarlyOtherwiseBranch.diff", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fearly_otherwise_branch_3_element_tuple.opt1.EarlyOtherwiseBranch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fearly_otherwise_branch_3_element_tuple.opt1.EarlyOtherwiseBranch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fearly_otherwise_branch_3_element_tuple.opt1.EarlyOtherwiseBranch.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -34,10 +34,7 @@\n           _6 = _2;                         // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:15: +1:16\n           StorageLive(_7);                 // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:18: +1:19\n           _7 = _3;                         // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:18: +1:19\n-          Deinit(_4);                      // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:11: +1:20\n-          (_4.0: std::option::Option<u32>) = move _5; // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:11: +1:20\n-          (_4.1: std::option::Option<u32>) = move _6; // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:11: +1:20\n-          (_4.2: std::option::Option<u32>) = move _7; // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:11: +1:20\n+          _4 = (move _5, move _6, move _7); // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:11: +1:20\n           StorageDead(_7);                 // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:19: +1:20\n           StorageDead(_6);                 // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:19: +1:20\n           StorageDead(_5);                 // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:19: +1:20"}, {"sha": "a91d0d7cf730fc5959209fd654b15e91d6cacd51", "filename": "tests/mir-opt/early_otherwise_branch_68867.try_sum.EarlyOtherwiseBranch.diff", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fearly_otherwise_branch_68867.try_sum.EarlyOtherwiseBranch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fearly_otherwise_branch_68867.try_sum.EarlyOtherwiseBranch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fearly_otherwise_branch_68867.try_sum.EarlyOtherwiseBranch.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -73,9 +73,7 @@\n           _5 = _1;                         // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:15: +5:16\n           StorageLive(_6);                 // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:18: +5:23\n           _6 = _2;                         // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:18: +5:23\n-          Deinit(_4);                      // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:14: +5:24\n-          (_4.0: &ViewportPercentageLength) = move _5; // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:14: +5:24\n-          (_4.1: &ViewportPercentageLength) = move _6; // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:14: +5:24\n+          _4 = (move _5, move _6);         // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:14: +5:24\n           StorageDead(_6);                 // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:23: +5:24\n           StorageDead(_5);                 // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:23: +5:24\n           _34 = deref_copy (_4.0: &ViewportPercentageLength); // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:14: +5:24\n@@ -91,10 +89,8 @@\n   \n       bb2: {\n           StorageLive(_33);                // scope 0 at $DIR/early_otherwise_branch_68867.rs:+10:25: +10:27\n-          Deinit(_33);                     // scope 0 at $DIR/early_otherwise_branch_68867.rs:+10:25: +10:27\n-          Deinit(_0);                      // scope 0 at $DIR/early_otherwise_branch_68867.rs:+10:21: +10:28\n-          ((_0 as Err).0: ()) = move _33;  // scope 0 at $DIR/early_otherwise_branch_68867.rs:+10:21: +10:28\n-          discriminant(_0) = 1;            // scope 0 at $DIR/early_otherwise_branch_68867.rs:+10:21: +10:28\n+          _33 = ();                        // scope 0 at $DIR/early_otherwise_branch_68867.rs:+10:25: +10:27\n+          _0 = Result::<ViewportPercentageLength, ()>::Err(move _33); // scope 0 at $DIR/early_otherwise_branch_68867.rs:+10:21: +10:28\n           StorageDead(_33);                // scope 0 at $DIR/early_otherwise_branch_68867.rs:+10:27: +10:28\n           StorageDead(_3);                 // scope 0 at $DIR/early_otherwise_branch_68867.rs:+11:6: +11:7\n           StorageDead(_4);                 // scope 0 at $DIR/early_otherwise_branch_68867.rs:+12:1: +12:2\n@@ -134,9 +130,7 @@\n           _14 = Add(move _15, move _16);   // scope 1 at $DIR/early_otherwise_branch_68867.rs:+6:38: +6:49\n           StorageDead(_16);                // scope 1 at $DIR/early_otherwise_branch_68867.rs:+6:48: +6:49\n           StorageDead(_15);                // scope 1 at $DIR/early_otherwise_branch_68867.rs:+6:48: +6:49\n-          Deinit(_3);                      // scope 1 at $DIR/early_otherwise_branch_68867.rs:+6:35: +6:50\n-          ((_3 as Vw).0: f32) = move _14;  // scope 1 at $DIR/early_otherwise_branch_68867.rs:+6:35: +6:50\n-          discriminant(_3) = 0;            // scope 1 at $DIR/early_otherwise_branch_68867.rs:+6:35: +6:50\n+          _3 = ViewportPercentageLength::Vw(move _14); // scope 1 at $DIR/early_otherwise_branch_68867.rs:+6:35: +6:50\n           StorageDead(_14);                // scope 1 at $DIR/early_otherwise_branch_68867.rs:+6:49: +6:50\n           StorageDead(_13);                // scope 0 at $DIR/early_otherwise_branch_68867.rs:+6:49: +6:50\n           StorageDead(_12);                // scope 0 at $DIR/early_otherwise_branch_68867.rs:+6:49: +6:50\n@@ -158,9 +152,7 @@\n           _19 = Add(move _20, move _21);   // scope 2 at $DIR/early_otherwise_branch_68867.rs:+7:38: +7:49\n           StorageDead(_21);                // scope 2 at $DIR/early_otherwise_branch_68867.rs:+7:48: +7:49\n           StorageDead(_20);                // scope 2 at $DIR/early_otherwise_branch_68867.rs:+7:48: +7:49\n-          Deinit(_3);                      // scope 2 at $DIR/early_otherwise_branch_68867.rs:+7:35: +7:50\n-          ((_3 as Vh).0: f32) = move _19;  // scope 2 at $DIR/early_otherwise_branch_68867.rs:+7:35: +7:50\n-          discriminant(_3) = 1;            // scope 2 at $DIR/early_otherwise_branch_68867.rs:+7:35: +7:50\n+          _3 = ViewportPercentageLength::Vh(move _19); // scope 2 at $DIR/early_otherwise_branch_68867.rs:+7:35: +7:50\n           StorageDead(_19);                // scope 2 at $DIR/early_otherwise_branch_68867.rs:+7:49: +7:50\n           StorageDead(_18);                // scope 0 at $DIR/early_otherwise_branch_68867.rs:+7:49: +7:50\n           StorageDead(_17);                // scope 0 at $DIR/early_otherwise_branch_68867.rs:+7:49: +7:50\n@@ -182,9 +174,7 @@\n           _24 = Add(move _25, move _26);   // scope 3 at $DIR/early_otherwise_branch_68867.rs:+8:44: +8:55\n           StorageDead(_26);                // scope 3 at $DIR/early_otherwise_branch_68867.rs:+8:54: +8:55\n           StorageDead(_25);                // scope 3 at $DIR/early_otherwise_branch_68867.rs:+8:54: +8:55\n-          Deinit(_3);                      // scope 3 at $DIR/early_otherwise_branch_68867.rs:+8:39: +8:56\n-          ((_3 as Vmin).0: f32) = move _24; // scope 3 at $DIR/early_otherwise_branch_68867.rs:+8:39: +8:56\n-          discriminant(_3) = 2;            // scope 3 at $DIR/early_otherwise_branch_68867.rs:+8:39: +8:56\n+          _3 = ViewportPercentageLength::Vmin(move _24); // scope 3 at $DIR/early_otherwise_branch_68867.rs:+8:39: +8:56\n           StorageDead(_24);                // scope 3 at $DIR/early_otherwise_branch_68867.rs:+8:55: +8:56\n           StorageDead(_23);                // scope 0 at $DIR/early_otherwise_branch_68867.rs:+8:55: +8:56\n           StorageDead(_22);                // scope 0 at $DIR/early_otherwise_branch_68867.rs:+8:55: +8:56\n@@ -206,19 +196,15 @@\n           _29 = Add(move _30, move _31);   // scope 4 at $DIR/early_otherwise_branch_68867.rs:+9:44: +9:55\n           StorageDead(_31);                // scope 4 at $DIR/early_otherwise_branch_68867.rs:+9:54: +9:55\n           StorageDead(_30);                // scope 4 at $DIR/early_otherwise_branch_68867.rs:+9:54: +9:55\n-          Deinit(_3);                      // scope 4 at $DIR/early_otherwise_branch_68867.rs:+9:39: +9:56\n-          ((_3 as Vmax).0: f32) = move _29; // scope 4 at $DIR/early_otherwise_branch_68867.rs:+9:39: +9:56\n-          discriminant(_3) = 3;            // scope 4 at $DIR/early_otherwise_branch_68867.rs:+9:39: +9:56\n+          _3 = ViewportPercentageLength::Vmax(move _29); // scope 4 at $DIR/early_otherwise_branch_68867.rs:+9:39: +9:56\n           StorageDead(_29);                // scope 4 at $DIR/early_otherwise_branch_68867.rs:+9:55: +9:56\n           StorageDead(_28);                // scope 0 at $DIR/early_otherwise_branch_68867.rs:+9:55: +9:56\n           StorageDead(_27);                // scope 0 at $DIR/early_otherwise_branch_68867.rs:+9:55: +9:56\n           goto -> bb10;                    // scope 0 at $DIR/early_otherwise_branch_68867.rs:+9:55: +9:56\n       }\n   \n       bb10: {\n-          Deinit(_0);                      // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:5: +11:7\n-          ((_0 as Ok).0: ViewportPercentageLength) = move _3; // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:5: +11:7\n-          discriminant(_0) = 0;            // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:5: +11:7\n+          _0 = Result::<ViewportPercentageLength, ()>::Ok(move _3); // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:5: +11:7\n           StorageDead(_3);                 // scope 0 at $DIR/early_otherwise_branch_68867.rs:+11:6: +11:7\n           StorageDead(_4);                 // scope 0 at $DIR/early_otherwise_branch_68867.rs:+12:1: +12:2\n           goto -> bb11;                    // scope 0 at $DIR/early_otherwise_branch_68867.rs:+12:2: +12:2"}, {"sha": "6468eb5f8dde590946844314f7fef99d55e4e188", "filename": "tests/mir-opt/early_otherwise_branch_noopt.noopt1.EarlyOtherwiseBranch.diff", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fearly_otherwise_branch_noopt.noopt1.EarlyOtherwiseBranch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fearly_otherwise_branch_noopt.noopt1.EarlyOtherwiseBranch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fearly_otherwise_branch_noopt.noopt1.EarlyOtherwiseBranch.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -32,9 +32,7 @@\n           _4 = _1;                         // scope 0 at $DIR/early_otherwise_branch_noopt.rs:+1:12: +1:13\n           StorageLive(_5);                 // scope 0 at $DIR/early_otherwise_branch_noopt.rs:+1:15: +1:16\n           _5 = _2;                         // scope 0 at $DIR/early_otherwise_branch_noopt.rs:+1:15: +1:16\n-          Deinit(_3);                      // scope 0 at $DIR/early_otherwise_branch_noopt.rs:+1:11: +1:17\n-          (_3.0: std::option::Option<u32>) = move _4; // scope 0 at $DIR/early_otherwise_branch_noopt.rs:+1:11: +1:17\n-          (_3.1: std::option::Option<u32>) = move _5; // scope 0 at $DIR/early_otherwise_branch_noopt.rs:+1:11: +1:17\n+          _3 = (move _4, move _5);         // scope 0 at $DIR/early_otherwise_branch_noopt.rs:+1:11: +1:17\n           StorageDead(_5);                 // scope 0 at $DIR/early_otherwise_branch_noopt.rs:+1:16: +1:17\n           StorageDead(_4);                 // scope 0 at $DIR/early_otherwise_branch_noopt.rs:+1:16: +1:17\n           _8 = discriminant((_3.0: std::option::Option<u32>)); // scope 0 at $DIR/early_otherwise_branch_noopt.rs:+1:11: +1:17"}, {"sha": "5ebaacd4ba91d71d7469fd621a8f56091d090dda", "filename": "tests/mir-opt/funky_arms.float_to_exponential_common.ConstProp.diff", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Ffunky_arms.float_to_exponential_common.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Ffunky_arms.float_to_exponential_common.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Ffunky_arms.float_to_exponential_common.ConstProp.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -51,14 +51,20 @@\n       }\n   \n       bb2: {\n-          Deinit(_6);                      // scope 1 at $DIR/funky_arms.rs:+10:17: +10:41\n-          discriminant(_6) = 1;            // scope 1 at $DIR/funky_arms.rs:+10:17: +10:41\n+-         _6 = MinusPlus;                  // scope 1 at $DIR/funky_arms.rs:+10:17: +10:41\n++         _6 = const MinusPlus;            // scope 1 at $DIR/funky_arms.rs:+10:17: +10:41\n++                                          // mir::Constant\n++                                          // + span: $DIR/funky_arms.rs:21:17: 21:41\n++                                          // + literal: Const { ty: Sign, val: Value(Scalar(0x01)) }\n           goto -> bb4;                     // scope 1 at $DIR/funky_arms.rs:+10:17: +10:41\n       }\n   \n       bb3: {\n-          Deinit(_6);                      // scope 1 at $DIR/funky_arms.rs:+9:18: +9:38\n-          discriminant(_6) = 0;            // scope 1 at $DIR/funky_arms.rs:+9:18: +9:38\n+-         _6 = Minus;                      // scope 1 at $DIR/funky_arms.rs:+9:18: +9:38\n++         _6 = const Minus;                // scope 1 at $DIR/funky_arms.rs:+9:18: +9:38\n++                                          // mir::Constant\n++                                          // + span: $DIR/funky_arms.rs:20:18: 20:38\n++                                          // + literal: Const { ty: Sign, val: Value(Scalar(0x00)) }\n           goto -> bb4;                     // scope 1 at $DIR/funky_arms.rs:+9:18: +9:38\n       }\n   \n@@ -79,7 +85,6 @@\n       }\n   \n       bb6: {\n-          StorageLive(_10);                // scope 3 at $DIR/funky_arms.rs:+13:17: +13:26\n           _10 = ((_7 as Some).0: usize);   // scope 3 at $DIR/funky_arms.rs:+13:17: +13:26\n           StorageLive(_11);                // scope 3 at $DIR/funky_arms.rs:+15:43: +15:46\n           _11 = &mut (*_1);                // scope 3 at $DIR/funky_arms.rs:+15:43: +15:46"}, {"sha": "7efda05d2b88143ac8ceda6b8a0711c3cc4d6e10", "filename": "tests/mir-opt/generator_tiny.main-{closure#0}.generator_resume.0.mir", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fgenerator_tiny.main-%7Bclosure%230%7D.generator_resume.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fgenerator_tiny.main-%7Bclosure%230%7D.generator_resume.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fgenerator_tiny.main-%7Bclosure%230%7D.generator_resume.0.mir?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -54,9 +54,7 @@ fn main::{closure#0}(_1: Pin<&mut [generator@$DIR/generator_tiny.rs:19:16: 19:24\n         StorageLive(_6);                 // scope 1 at $DIR/generator_tiny.rs:+3:13: +3:18\n         StorageLive(_7);                 // scope 1 at $DIR/generator_tiny.rs:+3:13: +3:18\n         _7 = ();                         // scope 1 at $DIR/generator_tiny.rs:+3:13: +3:18\n-        Deinit(_0);                      // scope 1 at $DIR/generator_tiny.rs:+3:13: +3:18\n-        ((_0 as Yielded).0: ()) = move _7; // scope 1 at $DIR/generator_tiny.rs:+3:13: +3:18\n-        discriminant(_0) = 0;            // scope 1 at $DIR/generator_tiny.rs:+3:13: +3:18\n+        _0 = GeneratorState::<(), ()>::Yielded(move _7); // scope 1 at $DIR/generator_tiny.rs:+3:13: +3:18\n         discriminant((*(_1.0: &mut [generator@$DIR/generator_tiny.rs:19:16: 19:24]))) = 3; // scope 1 at $DIR/generator_tiny.rs:+3:13: +3:18\n         return;                          // scope 1 at $DIR/generator_tiny.rs:+3:13: +3:18\n     }"}, {"sha": "501390c3bf1016066a95e879f238ceee402ec00a", "filename": "tests/mir-opt/inline/cycle.f.Inline.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Finline%2Fcycle.f.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Finline%2Fcycle.f.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Fcycle.f.Inline.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -13,7 +13,7 @@\n           StorageLive(_3);                 // scope 0 at $DIR/cycle.rs:+1:5: +1:6\n           _3 = &_1;                        // scope 0 at $DIR/cycle.rs:+1:5: +1:6\n           StorageLive(_4);                 // scope 0 at $DIR/cycle.rs:+1:5: +1:8\n-          Deinit(_4);                      // scope 0 at $DIR/cycle.rs:+1:5: +1:8\n+          _4 = ();                         // scope 0 at $DIR/cycle.rs:+1:5: +1:8\n           _2 = <impl Fn() as Fn<()>>::call(move _3, move _4) -> [return: bb1, unwind: bb3]; // scope 0 at $DIR/cycle.rs:+1:5: +1:8\n                                            // mir::Constant\n                                            // + span: $DIR/cycle.rs:6:5: 6:6"}, {"sha": "fff8d01712770dc85d2b52cffc49675421b55be0", "filename": "tests/mir-opt/inline/inline_closure.foo.Inline.after.mir", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Finline%2Finline_closure.foo.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Finline%2Finline_closure.foo.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Finline_closure.foo.Inline.after.mir?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -21,17 +21,23 @@ fn foo(_1: T, _2: i32) -> i32 {\n \n     bb0: {\n         StorageLive(_3);                 // scope 0 at $DIR/inline_closure.rs:+1:9: +1:10\n-        Deinit(_3);                      // scope 0 at $DIR/inline_closure.rs:+1:13: +1:24\n+        _3 = [closure@foo::<T>::{closure#0}]; // scope 0 at $DIR/inline_closure.rs:+1:13: +1:24\n+                                         // closure\n+                                         // + def_id: DefId(0:6 ~ inline_closure[92ba]::foo::{closure#0})\n+                                         // + substs: [\n+                                         //     T,\n+                                         //     i8,\n+                                         //     extern \"rust-call\" fn((i32, i32)) -> i32,\n+                                         //     (),\n+                                         // ]\n         StorageLive(_4);                 // scope 1 at $DIR/inline_closure.rs:+2:5: +2:6\n         _4 = &_3;                        // scope 1 at $DIR/inline_closure.rs:+2:5: +2:6\n         StorageLive(_5);                 // scope 1 at $DIR/inline_closure.rs:+2:5: +2:12\n         StorageLive(_6);                 // scope 1 at $DIR/inline_closure.rs:+2:7: +2:8\n         _6 = _2;                         // scope 1 at $DIR/inline_closure.rs:+2:7: +2:8\n         StorageLive(_7);                 // scope 1 at $DIR/inline_closure.rs:+2:10: +2:11\n         _7 = _2;                         // scope 1 at $DIR/inline_closure.rs:+2:10: +2:11\n-        Deinit(_5);                      // scope 1 at $DIR/inline_closure.rs:+2:5: +2:12\n-        (_5.0: i32) = move _6;           // scope 1 at $DIR/inline_closure.rs:+2:5: +2:12\n-        (_5.1: i32) = move _7;           // scope 1 at $DIR/inline_closure.rs:+2:5: +2:12\n+        _5 = (move _6, move _7);         // scope 1 at $DIR/inline_closure.rs:+2:5: +2:12\n         StorageLive(_8);                 // scope 1 at $DIR/inline_closure.rs:+2:5: +2:12\n         _8 = move (_5.0: i32);           // scope 1 at $DIR/inline_closure.rs:+2:5: +2:12\n         StorageLive(_9);                 // scope 1 at $DIR/inline_closure.rs:+2:5: +2:12"}, {"sha": "dab2043064f39802d924604ba1874f3a4f4fd5ad", "filename": "tests/mir-opt/inline/inline_closure_borrows_arg.foo.Inline.after.mir", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Finline%2Finline_closure_borrows_arg.foo.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Finline%2Finline_closure_borrows_arg.foo.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Finline_closure_borrows_arg.foo.Inline.after.mir?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -24,17 +24,23 @@ fn foo(_1: T, _2: &i32) -> i32 {\n \n     bb0: {\n         StorageLive(_3);                 // scope 0 at $DIR/inline_closure_borrows_arg.rs:+1:9: +1:10\n-        Deinit(_3);                      // scope 0 at $DIR/inline_closure_borrows_arg.rs:+1:13: +4:6\n+        _3 = [closure@foo::<T>::{closure#0}]; // scope 0 at $DIR/inline_closure_borrows_arg.rs:+1:13: +4:6\n+                                         // closure\n+                                         // + def_id: DefId(0:6 ~ inline_closure_borrows_arg[96e9]::foo::{closure#0})\n+                                         // + substs: [\n+                                         //     T,\n+                                         //     i8,\n+                                         //     for<'a, 'b> extern \"rust-call\" fn((&'a i32, &'b i32)) -> i32,\n+                                         //     (),\n+                                         // ]\n         StorageLive(_4);                 // scope 1 at $DIR/inline_closure_borrows_arg.rs:+5:5: +5:6\n         _4 = &_3;                        // scope 1 at $DIR/inline_closure_borrows_arg.rs:+5:5: +5:6\n         StorageLive(_5);                 // scope 1 at $DIR/inline_closure_borrows_arg.rs:+5:5: +5:12\n         StorageLive(_6);                 // scope 1 at $DIR/inline_closure_borrows_arg.rs:+5:7: +5:8\n         _6 = &(*_2);                     // scope 1 at $DIR/inline_closure_borrows_arg.rs:+5:7: +5:8\n         StorageLive(_7);                 // scope 1 at $DIR/inline_closure_borrows_arg.rs:+5:10: +5:11\n         _7 = &(*_2);                     // scope 1 at $DIR/inline_closure_borrows_arg.rs:+5:10: +5:11\n-        Deinit(_5);                      // scope 1 at $DIR/inline_closure_borrows_arg.rs:+5:5: +5:12\n-        (_5.0: &i32) = move _6;          // scope 1 at $DIR/inline_closure_borrows_arg.rs:+5:5: +5:12\n-        (_5.1: &i32) = move _7;          // scope 1 at $DIR/inline_closure_borrows_arg.rs:+5:5: +5:12\n+        _5 = (move _6, move _7);         // scope 1 at $DIR/inline_closure_borrows_arg.rs:+5:5: +5:12\n         StorageLive(_8);                 // scope 1 at $DIR/inline_closure_borrows_arg.rs:+5:5: +5:12\n         _8 = move (_5.0: &i32);          // scope 1 at $DIR/inline_closure_borrows_arg.rs:+5:5: +5:12\n         StorageLive(_9);                 // scope 1 at $DIR/inline_closure_borrows_arg.rs:+5:5: +5:12"}, {"sha": "84fd051e0a3518280555a38dbfa40c4581752187", "filename": "tests/mir-opt/inline/inline_closure_captures.foo.Inline.after.mir", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Finline%2Finline_closure_captures.foo.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Finline%2Finline_closure_captures.foo.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Finline_closure_captures.foo.Inline.after.mir?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -30,18 +30,23 @@ fn foo(_1: T, _2: i32) -> (i32, T) {\n         _4 = &_2;                        // scope 0 at $DIR/inline_closure_captures.rs:+1:13: +1:24\n         StorageLive(_5);                 // scope 0 at $DIR/inline_closure_captures.rs:+1:13: +1:24\n         _5 = &_1;                        // scope 0 at $DIR/inline_closure_captures.rs:+1:13: +1:24\n-        Deinit(_3);                      // scope 0 at $DIR/inline_closure_captures.rs:+1:13: +1:24\n-        (_3.0: &i32) = move _4;          // scope 0 at $DIR/inline_closure_captures.rs:+1:13: +1:24\n-        (_3.1: &T) = move _5;            // scope 0 at $DIR/inline_closure_captures.rs:+1:13: +1:24\n+        _3 = [closure@foo::<T>::{closure#0}] { q: move _4, t: move _5 }; // scope 0 at $DIR/inline_closure_captures.rs:+1:13: +1:24\n+                                         // closure\n+                                         // + def_id: DefId(0:6 ~ inline_closure_captures[8bc0]::foo::{closure#0})\n+                                         // + substs: [\n+                                         //     T,\n+                                         //     i8,\n+                                         //     extern \"rust-call\" fn((i32,)) -> (i32, T),\n+                                         //     (&i32, &T),\n+                                         // ]\n         StorageDead(_5);                 // scope 0 at $DIR/inline_closure_captures.rs:+1:16: +1:17\n         StorageDead(_4);                 // scope 0 at $DIR/inline_closure_captures.rs:+1:16: +1:17\n         StorageLive(_6);                 // scope 1 at $DIR/inline_closure_captures.rs:+2:5: +2:6\n         _6 = &_3;                        // scope 1 at $DIR/inline_closure_captures.rs:+2:5: +2:6\n         StorageLive(_7);                 // scope 1 at $DIR/inline_closure_captures.rs:+2:5: +2:9\n         StorageLive(_8);                 // scope 1 at $DIR/inline_closure_captures.rs:+2:7: +2:8\n         _8 = _2;                         // scope 1 at $DIR/inline_closure_captures.rs:+2:7: +2:8\n-        Deinit(_7);                      // scope 1 at $DIR/inline_closure_captures.rs:+2:5: +2:9\n-        (_7.0: i32) = move _8;           // scope 1 at $DIR/inline_closure_captures.rs:+2:5: +2:9\n+        _7 = (move _8,);                 // scope 1 at $DIR/inline_closure_captures.rs:+2:5: +2:9\n         StorageLive(_9);                 // scope 1 at $DIR/inline_closure_captures.rs:+2:5: +2:9\n         _9 = move (_7.0: i32);           // scope 1 at $DIR/inline_closure_captures.rs:+2:5: +2:9\n         StorageLive(_10);                // scope 2 at $DIR/inline_closure_captures.rs:+1:19: +1:20\n@@ -50,9 +55,7 @@ fn foo(_1: T, _2: i32) -> (i32, T) {\n         StorageLive(_11);                // scope 2 at $DIR/inline_closure_captures.rs:+1:22: +1:23\n         _13 = deref_copy ((*_6).1: &T);  // scope 2 at $DIR/inline_closure_captures.rs:+1:22: +1:23\n         _11 = (*_13);                    // scope 2 at $DIR/inline_closure_captures.rs:+1:22: +1:23\n-        Deinit(_0);                      // scope 2 at $DIR/inline_closure_captures.rs:+1:18: +1:24\n-        (_0.0: i32) = move _10;          // scope 2 at $DIR/inline_closure_captures.rs:+1:18: +1:24\n-        (_0.1: T) = move _11;            // scope 2 at $DIR/inline_closure_captures.rs:+1:18: +1:24\n+        _0 = (move _10, move _11);       // scope 2 at $DIR/inline_closure_captures.rs:+1:18: +1:24\n         StorageDead(_11);                // scope 2 at $DIR/inline_closure_captures.rs:+1:23: +1:24\n         StorageDead(_10);                // scope 2 at $DIR/inline_closure_captures.rs:+1:23: +1:24\n         StorageDead(_9);                 // scope 1 at $DIR/inline_closure_captures.rs:+2:5: +2:9"}, {"sha": "e1b2f7dbf358d0117473f706aae225250a667f5e", "filename": "tests/mir-opt/inline/inline_diverging.h.Inline.diff", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -48,9 +48,7 @@\n +         StorageDead(_6);                 // scope 2 at $DIR/inline_diverging.rs:28:15: 28:16\n +         StorageLive(_8);                 // scope 3 at $DIR/inline_diverging.rs:29:6: 29:7\n +         _8 = move _3;                    // scope 3 at $DIR/inline_diverging.rs:29:6: 29:7\n-+         Deinit(_1);                      // scope 3 at $DIR/inline_diverging.rs:29:5: 29:11\n-+         (_1.0: !) = move _8;             // scope 3 at $DIR/inline_diverging.rs:29:5: 29:11\n-+         (_1.1: !) = move _9;             // scope 3 at $DIR/inline_diverging.rs:29:5: 29:11\n++         _1 = (move _8, move _9);         // scope 3 at $DIR/inline_diverging.rs:29:5: 29:11\n +         StorageDead(_8);                 // scope 3 at $DIR/inline_diverging.rs:29:10: 29:11\n +         StorageDead(_3);                 // scope 1 at $DIR/inline_diverging.rs:30:1: 30:2\n +         drop(_2) -> bb2;                 // scope 1 at $DIR/inline_diverging.rs:30:1: 30:2"}, {"sha": "95d649f89ba6b34d73095dda74cb4dc67dfd4cb4", "filename": "tests/mir-opt/inline/inline_generator.main.Inline.diff", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Finline%2Finline_generator.main.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Finline%2Finline_generator.main.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Finline_generator.main.Inline.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -44,8 +44,17 @@\n -     }\n - \n -     bb1: {\n-+         Deinit(_4);                      // scope 2 at $DIR/inline_generator.rs:15:5: 15:41\n-+         discriminant(_4) = 0;            // scope 2 at $DIR/inline_generator.rs:15:5: 15:41\n++         _4 = [generator@$DIR/inline_generator.rs:15:5: 15:8 (#0)]; // scope 2 at $DIR/inline_generator.rs:15:5: 15:41\n++                                          // generator\n++                                          // + def_id: DefId(0:7 ~ inline_generator[ea31]::g::{closure#0})\n++                                          // + substs: [\n++                                          //     bool,\n++                                          //     i32,\n++                                          //     bool,\n++                                          //     {bool, i32},\n++                                          //     (),\n++                                          // ]\n++                                          // + movability: Movable\n           _3 = &mut _4;                    // scope 0 at $DIR/inline_generator.rs:+1:23: +1:31\n -         _2 = Pin::<&mut [generator@$DIR/inline_generator.rs:15:5: 15:8]>::new(move _3) -> [return: bb2, unwind: bb4]; // scope 0 at $DIR/inline_generator.rs:+1:14: +1:32\n -                                          // mir::Constant\n@@ -59,8 +68,7 @@\n +         _5 = move _3;                    // scope 4 at $SRC_DIR/core/src/pin.rs:LL:COL\n +         StorageLive(_6);                 // scope 5 at $SRC_DIR/core/src/pin.rs:LL:COL\n +         _6 = move _5;                    // scope 5 at $SRC_DIR/core/src/pin.rs:LL:COL\n-+         Deinit(_2);                      // scope 5 at $SRC_DIR/core/src/pin.rs:LL:COL\n-+         (_2.0: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]) = move _6; // scope 5 at $SRC_DIR/core/src/pin.rs:LL:COL\n++         _2 = Pin::<&mut [generator@$DIR/inline_generator.rs:15:5: 15:8]> { pointer: move _6 }; // scope 5 at $SRC_DIR/core/src/pin.rs:LL:COL\n +         StorageDead(_6);                 // scope 5 at $SRC_DIR/core/src/pin.rs:LL:COL\n +         StorageDead(_5);                 // scope 4 at $SRC_DIR/core/src/pin.rs:LL:COL\n           StorageDead(_3);                 // scope 0 at $DIR/inline_generator.rs:+1:31: +1:32\n@@ -106,9 +114,7 @@\n +     }\n + \n +     bb6: {\n-+         Deinit(_1);                      // scope 6 at $DIR/inline_generator.rs:15:11: 15:39\n-+         ((_1 as Yielded).0: i32) = move _8; // scope 6 at $DIR/inline_generator.rs:15:11: 15:39\n-+         discriminant(_1) = 0;            // scope 6 at $DIR/inline_generator.rs:15:11: 15:39\n++         _1 = GeneratorState::<i32, bool>::Yielded(move _8); // scope 6 at $DIR/inline_generator.rs:15:11: 15:39\n +         _11 = deref_copy (_2.0: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]); // scope 6 at $DIR/inline_generator.rs:15:11: 15:39\n +         discriminant((*_11)) = 3;        // scope 6 at $DIR/inline_generator.rs:15:11: 15:39\n +         goto -> bb1;                     // scope 0 at $DIR/inline_generator.rs:15:11: 15:39\n@@ -117,9 +123,7 @@\n +     bb7: {\n +         StorageLive(_8);                 // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n +         StorageDead(_8);                 // scope 6 at $DIR/inline_generator.rs:15:38: 15:39\n-+         Deinit(_1);                      // scope 6 at $DIR/inline_generator.rs:15:41: 15:41\n-+         ((_1 as Complete).0: bool) = _7; // scope 6 at $DIR/inline_generator.rs:15:41: 15:41\n-+         discriminant(_1) = 1;            // scope 6 at $DIR/inline_generator.rs:15:41: 15:41\n++         _1 = GeneratorState::<i32, bool>::Complete(_7); // scope 6 at $DIR/inline_generator.rs:15:41: 15:41\n +         _12 = deref_copy (_2.0: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]); // scope 6 at $DIR/inline_generator.rs:15:41: 15:41\n +         discriminant((*_12)) = 1;        // scope 6 at $DIR/inline_generator.rs:15:41: 15:41\n +         goto -> bb1;                     // scope 0 at $DIR/inline_generator.rs:15:41: 15:41"}, {"sha": "a1cbf0d3e0ddea636215f47eb8220bece8d79c82", "filename": "tests/mir-opt/inline/inline_into_box_place.main.Inline.diff", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Finline_into_box_place.main.Inline.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -51,9 +51,7 @@\n +                                          // + span: $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n +                                          // + user_ty: UserType(0)\n +                                          // + literal: Const { ty: alloc::raw_vec::RawVec<u32>, val: Unevaluated(alloc::raw_vec::RawVec::<T>::NEW, [u32], None) }\n-+         Deinit(_9);                      // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-+         (_9.0: alloc::raw_vec::RawVec<u32>) = move _10; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n-+         (_9.1: usize) = const 0_usize;   // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n++         _9 = Vec::<u32> { buf: move _10, len: const 0_usize }; // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n +         StorageDead(_10);                // scope 3 at $SRC_DIR/alloc/src/vec/mod.rs:LL:COL\n +         (*_8) = move _9;                 // scope 0 at $DIR/inline_into_box_place.rs:+1:33: +1:43\n +         StorageDead(_9);                 // scope 0 at $DIR/inline_into_box_place.rs:+1:33: +1:43"}, {"sha": "4dd1aad489dd48e919b08e9e38715b5fe1a2f8bc", "filename": "tests/mir-opt/inline/issue_76997_inline_scopes_parenting.main.Inline.after.mir", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Finline%2Fissue_76997_inline_scopes_parenting.main.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Finline%2Fissue_76997_inline_scopes_parenting.main.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Fissue_76997_inline_scopes_parenting.main.Inline.after.mir?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -20,14 +20,20 @@ fn main() -> () {\n \n     bb0: {\n         StorageLive(_1);                 // scope 0 at $DIR/issue_76997_inline_scopes_parenting.rs:+1:9: +1:10\n-        Deinit(_1);                      // scope 0 at $DIR/issue_76997_inline_scopes_parenting.rs:+1:13: +1:33\n+        _1 = [closure@$DIR/issue_76997_inline_scopes_parenting.rs:5:13: 5:16]; // scope 0 at $DIR/issue_76997_inline_scopes_parenting.rs:+1:13: +1:33\n+                                         // closure\n+                                         // + def_id: DefId(0:4 ~ issue_76997_inline_scopes_parenting[bc59]::main::{closure#0})\n+                                         // + substs: [\n+                                         //     i8,\n+                                         //     extern \"rust-call\" fn(((),)),\n+                                         //     (),\n+                                         // ]\n         StorageLive(_2);                 // scope 1 at $DIR/issue_76997_inline_scopes_parenting.rs:+2:5: +2:6\n         _2 = &_1;                        // scope 1 at $DIR/issue_76997_inline_scopes_parenting.rs:+2:5: +2:6\n         StorageLive(_3);                 // scope 1 at $DIR/issue_76997_inline_scopes_parenting.rs:+2:5: +2:10\n         StorageLive(_4);                 // scope 1 at $DIR/issue_76997_inline_scopes_parenting.rs:+2:7: +2:9\n-        Deinit(_4);                      // scope 1 at $DIR/issue_76997_inline_scopes_parenting.rs:+2:7: +2:9\n-        Deinit(_3);                      // scope 1 at $DIR/issue_76997_inline_scopes_parenting.rs:+2:5: +2:10\n-        (_3.0: ()) = move _4;            // scope 1 at $DIR/issue_76997_inline_scopes_parenting.rs:+2:5: +2:10\n+        _4 = ();                         // scope 1 at $DIR/issue_76997_inline_scopes_parenting.rs:+2:7: +2:9\n+        _3 = (move _4,);                 // scope 1 at $DIR/issue_76997_inline_scopes_parenting.rs:+2:5: +2:10\n         StorageLive(_5);                 // scope 1 at $DIR/issue_76997_inline_scopes_parenting.rs:+2:5: +2:10\n         _5 = move (_3.0: ());            // scope 1 at $DIR/issue_76997_inline_scopes_parenting.rs:+2:5: +2:10\n         StorageLive(_6);                 // scope 2 at $DIR/issue_76997_inline_scopes_parenting.rs:+1:23: +1:24"}, {"sha": "aa62e4a165e197d811e4f90cd9fe027132fe9827", "filename": "tests/mir-opt/inline/issue_78442.bar.Inline.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Finline%2Fissue_78442.bar.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Finline%2Fissue_78442.bar.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Fissue_78442.bar.Inline.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -25,7 +25,7 @@\n       bb1: {\n           _3 = &_4;                        // scope 0 at $DIR/issue_78442.rs:+4:5: +4:15\n           StorageLive(_5);                 // scope 0 at $DIR/issue_78442.rs:+4:5: +4:17\n-          Deinit(_5);                      // scope 0 at $DIR/issue_78442.rs:+4:5: +4:17\n+          _5 = ();                         // scope 0 at $DIR/issue_78442.rs:+4:5: +4:17\n -         _2 = <fn() {foo} as Fn<()>>::call(move _3, move _5) -> [return: bb2, unwind: bb4]; // scope 0 at $DIR/issue_78442.rs:+4:5: +4:17\n -                                          // mir::Constant\n -                                          // + span: $DIR/issue_78442.rs:11:5: 11:15"}, {"sha": "21055c6bfb57f4e3eb21546d374d8ca122528cad", "filename": "tests/mir-opt/inline/issue_78442.bar.RevealAll.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Finline%2Fissue_78442.bar.RevealAll.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Finline%2Fissue_78442.bar.RevealAll.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Fissue_78442.bar.RevealAll.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -24,7 +24,7 @@\n       bb1: {\n           _3 = &_4;                        // scope 0 at $DIR/issue_78442.rs:+4:5: +4:15\n           StorageLive(_5);                 // scope 0 at $DIR/issue_78442.rs:+4:5: +4:17\n-          Deinit(_5);                      // scope 0 at $DIR/issue_78442.rs:+4:5: +4:17\n+          _5 = ();                         // scope 0 at $DIR/issue_78442.rs:+4:5: +4:17\n -         _2 = <impl Fn() as Fn<()>>::call(move _3, move _5) -> [return: bb2, unwind: bb4]; // scope 0 at $DIR/issue_78442.rs:+4:5: +4:17\n +         _2 = <fn() {foo} as Fn<()>>::call(move _3, move _5) -> [return: bb2, unwind: bb4]; // scope 0 at $DIR/issue_78442.rs:+4:5: +4:17\n                                            // mir::Constant"}, {"sha": "002392c5cf81a24c59eb8b600647cda96a1427a9", "filename": "tests/mir-opt/issue_101973.inner.ConstProp.diff", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -33,7 +33,6 @@\n       bb0: {\n           StorageLive(_2);                 // scope 0 at $DIR/issue_101973.rs:+1:5: +1:65\n           StorageLive(_3);                 // scope 0 at $DIR/issue_101973.rs:+1:5: +1:58\n-          StorageLive(_4);                 // scope 0 at $DIR/issue_101973.rs:+1:5: +1:17\n           StorageLive(_12);                // scope 2 at $DIR/issue_101973.rs:7:12: 7:27\n           StorageLive(_13);                // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n           _14 = CheckedShr(_1, const 0_i32); // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n@@ -63,7 +62,6 @@\n           StorageDead(_13);                // scope 2 at $DIR/issue_101973.rs:7:26: 7:27\n           _4 = BitOr(const 0_u32, move _12); // scope 2 at $DIR/issue_101973.rs:7:5: 7:27\n           StorageDead(_12);                // scope 2 at $DIR/issue_101973.rs:7:26: 7:27\n-          StorageLive(_6);                 // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n           StorageLive(_7);                 // scope 0 at $DIR/issue_101973.rs:+1:31: +1:52\n           StorageLive(_8);                 // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n           _10 = CheckedShr(_1, const 8_i32); // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45"}, {"sha": "cc4f7cc06991f6b77ce66f0cee3f33c8789ede9e", "filename": "tests/mir-opt/issue_76432.test.SimplifyComparisonIntegral.diff", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fissue_76432.test.SimplifyComparisonIntegral.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fissue_76432.test.SimplifyComparisonIntegral.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fissue_76432.test.SimplifyComparisonIntegral.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -29,7 +29,6 @@\n   \n       bb0: {\n           StorageLive(_2);                 // scope 0 at $DIR/issue_76432.rs:+1:9: +1:10\n-          StorageLive(_4);                 // scope 0 at $DIR/issue_76432.rs:+1:19: +1:29\n           StorageLive(_5);                 // scope 0 at $DIR/issue_76432.rs:+1:20: +1:29\n           _5 = [_1, _1, _1];               // scope 0 at $DIR/issue_76432.rs:+1:20: +1:29\n           _4 = &_5;                        // scope 0 at $DIR/issue_76432.rs:+1:19: +1:29"}, {"sha": "bcda1288045664ae98db4fb45b0a140b6767788e", "filename": "tests/mir-opt/issues/issue_75439.foo.MatchBranchSimplification.diff", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fissues%2Fissue_75439.foo.MatchBranchSimplification.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fissues%2Fissue_75439.foo.MatchBranchSimplification.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fissues%2Fissue_75439.foo.MatchBranchSimplification.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -67,17 +67,14 @@\n   \n       bb7: {\n           StorageDead(_6);                 // scope 4 at $DIR/issue_75439.rs:+5:35: +5:36\n-          Deinit(_0);                      // scope 3 at $DIR/issue_75439.rs:+5:9: +5:39\n-          ((_0 as Some).0: [u8; 4]) = move _5; // scope 3 at $DIR/issue_75439.rs:+5:9: +5:39\n-          discriminant(_0) = 1;            // scope 3 at $DIR/issue_75439.rs:+5:9: +5:39\n+          _0 = Option::<[u8; 4]>::Some(move _5); // scope 3 at $DIR/issue_75439.rs:+5:9: +5:39\n           StorageDead(_5);                 // scope 3 at $DIR/issue_75439.rs:+5:38: +5:39\n           StorageDead(_4);                 // scope 1 at $DIR/issue_75439.rs:+6:5: +6:6\n           goto -> bb9;                     // scope 1 at $DIR/issue_75439.rs:+4:5: +8:6\n       }\n   \n       bb8: {\n-          Deinit(_0);                      // scope 1 at $DIR/issue_75439.rs:+7:9: +7:13\n-          discriminant(_0) = 0;            // scope 1 at $DIR/issue_75439.rs:+7:9: +7:13\n+          _0 = Option::<[u8; 4]>::None;    // scope 1 at $DIR/issue_75439.rs:+7:9: +7:13\n           goto -> bb9;                     // scope 1 at $DIR/issue_75439.rs:+4:5: +8:6\n       }\n   "}, {"sha": "5c972a00e464d846ba03d11487e6cc69639fc3e4", "filename": "tests/mir-opt/lower_intrinsics.f_copy_nonoverlapping.LowerIntrinsics.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Flower_intrinsics.f_copy_nonoverlapping.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Flower_intrinsics.f_copy_nonoverlapping.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.f_copy_nonoverlapping.LowerIntrinsics.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -25,9 +25,9 @@\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/lower_intrinsics.rs:+1:9: +1:12\n-          Deinit(_1);                      // scope 0 at $DIR/lower_intrinsics.rs:+1:15: +1:17\n+          _1 = ();                         // scope 0 at $DIR/lower_intrinsics.rs:+1:15: +1:17\n           StorageLive(_2);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:9: +2:16\n-          Deinit(_2);                      // scope 1 at $DIR/lower_intrinsics.rs:+2:19: +2:21\n+          _2 = ();                         // scope 1 at $DIR/lower_intrinsics.rs:+2:19: +2:21\n           StorageLive(_3);                 // scope 3 at $DIR/lower_intrinsics.rs:+4:9: +4:95\n           StorageLive(_4);                 // scope 3 at $DIR/lower_intrinsics.rs:+4:29: +4:59\n           StorageLive(_5);                 // scope 3 at $DIR/lower_intrinsics.rs:+4:29: +4:45"}, {"sha": "92f8d4e14abbde628f7c54d700f7078b952b6466", "filename": "tests/mir-opt/matches_reduce_branches.bar.MatchBranchSimplification.diff", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fmatches_reduce_branches.bar.MatchBranchSimplification.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fmatches_reduce_branches.bar.MatchBranchSimplification.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fmatches_reduce_branches.bar.MatchBranchSimplification.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -41,7 +41,7 @@\n -         _3 = const false;                // scope 4 at $DIR/matches_reduce_branches.rs:+16:13: +16:22\n -         _4 = const false;                // scope 4 at $DIR/matches_reduce_branches.rs:+17:13: +17:22\n -         _5 = const true;                 // scope 4 at $DIR/matches_reduce_branches.rs:+18:13: +18:21\n--         Deinit(_6);                      // scope 4 at $DIR/matches_reduce_branches.rs:+19:13: +19:15\n+-         _6 = ();                         // scope 4 at $DIR/matches_reduce_branches.rs:+19:13: +19:15\n -         goto -> bb3;                     // scope 4 at $DIR/matches_reduce_branches.rs:+19:13: +19:15\n -     }\n - \n@@ -54,7 +54,7 @@\n +         _3 = Eq(_11, const 7_i32);       // scope 4 at $DIR/matches_reduce_branches.rs:+9:13: +9:21\n           _4 = const false;                // scope 4 at $DIR/matches_reduce_branches.rs:+10:13: +10:22\n           _5 = const true;                 // scope 4 at $DIR/matches_reduce_branches.rs:+11:13: +11:21\n-          Deinit(_6);                      // scope 4 at $DIR/matches_reduce_branches.rs:+12:13: +12:15\n+          _6 = ();                         // scope 4 at $DIR/matches_reduce_branches.rs:+12:13: +12:15\n -         goto -> bb3;                     // scope 4 at $DIR/matches_reduce_branches.rs:+12:13: +12:15\n -     }\n - \n@@ -69,11 +69,7 @@\n           _9 = _4;                         // scope 4 at $DIR/matches_reduce_branches.rs:+23:12: +23:13\n           StorageLive(_10);                // scope 4 at $DIR/matches_reduce_branches.rs:+23:15: +23:16\n           _10 = _5;                        // scope 4 at $DIR/matches_reduce_branches.rs:+23:15: +23:16\n-          Deinit(_0);                      // scope 4 at $DIR/matches_reduce_branches.rs:+23:5: +23:17\n-          (_0.0: bool) = move _7;          // scope 4 at $DIR/matches_reduce_branches.rs:+23:5: +23:17\n-          (_0.1: bool) = move _8;          // scope 4 at $DIR/matches_reduce_branches.rs:+23:5: +23:17\n-          (_0.2: bool) = move _9;          // scope 4 at $DIR/matches_reduce_branches.rs:+23:5: +23:17\n-          (_0.3: bool) = move _10;         // scope 4 at $DIR/matches_reduce_branches.rs:+23:5: +23:17\n+          _0 = (move _7, move _8, move _9, move _10); // scope 4 at $DIR/matches_reduce_branches.rs:+23:5: +23:17\n           StorageDead(_10);                // scope 4 at $DIR/matches_reduce_branches.rs:+23:16: +23:17\n           StorageDead(_9);                 // scope 4 at $DIR/matches_reduce_branches.rs:+23:16: +23:17\n           StorageDead(_8);                 // scope 4 at $DIR/matches_reduce_branches.rs:+23:16: +23:17"}, {"sha": "0580f73341d21fdf5ae84496bd47e143db3ce163", "filename": "tests/mir-opt/matches_reduce_branches.foo.MatchBranchSimplification.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fmatches_reduce_branches.foo.MatchBranchSimplification.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fmatches_reduce_branches.foo.MatchBranchSimplification.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fmatches_reduce_branches.foo.MatchBranchSimplification.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -34,7 +34,7 @@\n -     }\n - \n -     bb4: {\n-          Deinit(_0);                      // scope 0 at $DIR/matches_reduce_branches.rs:+2:9: +2:11\n+          _0 = ();                         // scope 0 at $DIR/matches_reduce_branches.rs:+2:9: +2:11\n -         goto -> bb6;                     // scope 0 at $DIR/matches_reduce_branches.rs:+1:5: +3:6\n +         goto -> bb3;                     // scope 0 at $DIR/matches_reduce_branches.rs:+1:5: +3:6\n       }"}, {"sha": "20e8ef2f72029daf9e512f55e3e7601080cca4dd", "filename": "tests/mir-opt/matches_reduce_branches.match_nested_if.MatchBranchSimplification.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fmatches_reduce_branches.match_nested_if.MatchBranchSimplification.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fmatches_reduce_branches.match_nested_if.MatchBranchSimplification.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fmatches_reduce_branches.match_nested_if.MatchBranchSimplification.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -20,7 +20,7 @@\n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/matches_reduce_branches.rs:+1:9: +1:12\n           StorageLive(_2);                 // scope 0 at $DIR/matches_reduce_branches.rs:+1:21: +1:23\n-          Deinit(_2);                      // scope 0 at $DIR/matches_reduce_branches.rs:+1:21: +1:23\n+          _2 = ();                         // scope 0 at $DIR/matches_reduce_branches.rs:+1:21: +1:23\n           StorageLive(_3);                 // scope 0 at $DIR/matches_reduce_branches.rs:+2:15: +6:10\n           StorageLive(_4);                 // scope 0 at $DIR/matches_reduce_branches.rs:+2:18: +2:76\n           StorageLive(_5);                 // scope 0 at $DIR/matches_reduce_branches.rs:+2:21: +2:52"}, {"sha": "210f178a0a9e5d32e7068dd5c6cd933c7a28a128", "filename": "tests/mir-opt/packed_struct_drop_aligned.main.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fpacked_struct_drop_aligned.main.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fpacked_struct_drop_aligned.main.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fpacked_struct_drop_aligned.main.SimplifyCfg-elaborate-drops.after.mir?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -16,20 +16,15 @@ fn main() -> () {\n         StorageLive(_1);                 // scope 0 at $DIR/packed_struct_drop_aligned.rs:+1:9: +1:14\n         StorageLive(_2);                 // scope 0 at $DIR/packed_struct_drop_aligned.rs:+1:24: +1:42\n         StorageLive(_3);                 // scope 0 at $DIR/packed_struct_drop_aligned.rs:+1:32: +1:41\n-        Deinit(_3);                      // scope 0 at $DIR/packed_struct_drop_aligned.rs:+1:32: +1:41\n-        (_3.0: usize) = const 0_usize;   // scope 0 at $DIR/packed_struct_drop_aligned.rs:+1:32: +1:41\n-        Deinit(_2);                      // scope 0 at $DIR/packed_struct_drop_aligned.rs:+1:24: +1:42\n-        (_2.0: Droppy) = move _3;        // scope 0 at $DIR/packed_struct_drop_aligned.rs:+1:24: +1:42\n+        _3 = Droppy(const 0_usize);      // scope 0 at $DIR/packed_struct_drop_aligned.rs:+1:32: +1:41\n+        _2 = Aligned(move _3);           // scope 0 at $DIR/packed_struct_drop_aligned.rs:+1:24: +1:42\n         StorageDead(_3);                 // scope 0 at $DIR/packed_struct_drop_aligned.rs:+1:41: +1:42\n-        Deinit(_1);                      // scope 0 at $DIR/packed_struct_drop_aligned.rs:+1:17: +1:43\n-        (_1.0: Aligned) = move _2;       // scope 0 at $DIR/packed_struct_drop_aligned.rs:+1:17: +1:43\n+        _1 = Packed(move _2);            // scope 0 at $DIR/packed_struct_drop_aligned.rs:+1:17: +1:43\n         StorageDead(_2);                 // scope 0 at $DIR/packed_struct_drop_aligned.rs:+1:42: +1:43\n         StorageLive(_4);                 // scope 1 at $DIR/packed_struct_drop_aligned.rs:+2:11: +2:29\n         StorageLive(_5);                 // scope 1 at $DIR/packed_struct_drop_aligned.rs:+2:19: +2:28\n-        Deinit(_5);                      // scope 1 at $DIR/packed_struct_drop_aligned.rs:+2:19: +2:28\n-        (_5.0: usize) = const 0_usize;   // scope 1 at $DIR/packed_struct_drop_aligned.rs:+2:19: +2:28\n-        Deinit(_4);                      // scope 1 at $DIR/packed_struct_drop_aligned.rs:+2:11: +2:29\n-        (_4.0: Droppy) = move _5;        // scope 1 at $DIR/packed_struct_drop_aligned.rs:+2:11: +2:29\n+        _5 = Droppy(const 0_usize);      // scope 1 at $DIR/packed_struct_drop_aligned.rs:+2:19: +2:28\n+        _4 = Aligned(move _5);           // scope 1 at $DIR/packed_struct_drop_aligned.rs:+2:11: +2:29\n         StorageDead(_5);                 // scope 1 at $DIR/packed_struct_drop_aligned.rs:+2:28: +2:29\n         StorageLive(_6);                 // scope 1 at $DIR/packed_struct_drop_aligned.rs:+2:5: +2:8\n         _6 = move (_1.0: Aligned);       // scope 1 at $DIR/packed_struct_drop_aligned.rs:+2:5: +2:8"}, {"sha": "a8dd91efc379f86fef4c776c80d2a693f00d806a", "filename": "tests/mir-opt/remove_storage_markers.main.RemoveStorageMarkers.diff", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fremove_storage_markers.main.RemoveStorageMarkers.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fremove_storage_markers.main.RemoveStorageMarkers.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fremove_storage_markers.main.RemoveStorageMarkers.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -31,9 +31,7 @@\n           _1 = const 0_i32;                // scope 0 at $DIR/remove_storage_markers.rs:+1:19: +1:20\n -         StorageLive(_2);                 // scope 1 at $DIR/remove_storage_markers.rs:+2:14: +2:19\n -         StorageLive(_3);                 // scope 1 at $DIR/remove_storage_markers.rs:+2:14: +2:19\n-          Deinit(_3);                      // scope 1 at $DIR/remove_storage_markers.rs:+2:14: +2:19\n-          (_3.0: i32) = const 0_i32;       // scope 1 at $DIR/remove_storage_markers.rs:+2:14: +2:19\n-          (_3.1: i32) = const 10_i32;      // scope 1 at $DIR/remove_storage_markers.rs:+2:14: +2:19\n+          _3 = std::ops::Range::<i32> { start: const 0_i32, end: const 10_i32 }; // scope 1 at $DIR/remove_storage_markers.rs:+2:14: +2:19\n           _2 = <std::ops::Range<i32> as IntoIterator>::into_iter(move _3) -> bb1; // scope 1 at $DIR/remove_storage_markers.rs:+2:14: +2:19\n                                            // mir::Constant\n                                            // + span: $DIR/remove_storage_markers.rs:10:14: 10:19"}, {"sha": "af34bc5edb7fe640fcde983caf154d8ce5a21ef1", "filename": "tests/mir-opt/remove_zsts.get_union.PreCodegen.after.mir", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fremove_zsts.get_union.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fremove_zsts.get_union.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fremove_zsts.get_union.PreCodegen.after.mir?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -2,9 +2,12 @@\n \n fn get_union() -> Foo {\n     let mut _0: Foo;                     // return place in scope 0 at $DIR/remove_zsts.rs:+0:19: +0:22\n+    let mut _1: ();                      // in scope 0 at $DIR/remove_zsts.rs:+1:14: +1:16\n \n     bb0: {\n-        Deinit(_0);                      // scope 0 at $DIR/remove_zsts.rs:+1:5: +1:18\n+        StorageLive(_1);                 // scope 0 at $DIR/remove_zsts.rs:+1:14: +1:16\n+        _0 = Foo { x: move _1 };         // scope 0 at $DIR/remove_zsts.rs:+1:5: +1:18\n+        StorageDead(_1);                 // scope 0 at $DIR/remove_zsts.rs:+1:17: +1:18\n         return;                          // scope 0 at $DIR/remove_zsts.rs:+2:2: +2:2\n     }\n }"}, {"sha": "0af29b2babc2b114aa841f6432c9b2a616c99754", "filename": "tests/mir-opt/remove_zsts.get_union.RemoveZsts.diff", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fremove_zsts.get_union.RemoveZsts.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fremove_zsts.get_union.RemoveZsts.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fremove_zsts.get_union.RemoveZsts.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -7,11 +7,9 @@\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/remove_zsts.rs:+1:14: +1:16\n--         Deinit(_1);                      // scope 0 at $DIR/remove_zsts.rs:+1:14: +1:16\n+-         _1 = ();                         // scope 0 at $DIR/remove_zsts.rs:+1:14: +1:16\n +         nop;                             // scope 0 at $DIR/remove_zsts.rs:+1:14: +1:16\n-          Deinit(_0);                      // scope 0 at $DIR/remove_zsts.rs:+1:5: +1:18\n--         (_0.0: ()) = move _1;            // scope 0 at $DIR/remove_zsts.rs:+1:5: +1:18\n-+         nop;                             // scope 0 at $DIR/remove_zsts.rs:+1:5: +1:18\n+          _0 = Foo { x: move _1 };         // scope 0 at $DIR/remove_zsts.rs:+1:5: +1:18\n           StorageDead(_1);                 // scope 0 at $DIR/remove_zsts.rs:+1:17: +1:18\n           return;                          // scope 0 at $DIR/remove_zsts.rs:+2:2: +2:2\n       }"}, {"sha": "3b479710b4f2d3af3f6b2f42deb80dfdddcd0811", "filename": "tests/mir-opt/retag.array_casts.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fretag.array_casts.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fretag.array_casts.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fretag.array_casts.SimplifyCfg-elaborate-drops.after.mir?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -122,9 +122,7 @@ fn array_casts() -> () {\n                                          // + literal: Const { ty: &usize, val: Unevaluated(array_casts, [], Some(promoted[0])) }\n         Retag(_35);                      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _18 = &(*_35);                   // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        Deinit(_13);                     // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        (_13.0: &usize) = move _14;      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        (_13.1: &usize) = move _18;      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _13 = (move _14, move _18);      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         Retag(_13);                      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageDead(_18);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageDead(_14);                // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n@@ -150,8 +148,7 @@ fn array_casts() -> () {\n \n     bb3: {\n         StorageLive(_27);                // scope 7 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        Deinit(_27);                     // scope 7 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        discriminant(_27) = 0;           // scope 7 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _27 = core::panicking::AssertKind::Eq; // scope 7 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageLive(_28);                // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageLive(_29);                // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _29 = move _27;                  // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n@@ -164,8 +161,7 @@ fn array_casts() -> () {\n         _33 = &(*_21);                   // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _32 = &(*_33);                   // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageLive(_34);                // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        Deinit(_34);                     // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        discriminant(_34) = 0;           // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        _34 = Option::<Arguments<'_>>::None; // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         Retag(_34);                      // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _28 = core::panicking::assert_failed::<usize, usize>(move _29, move _30, move _32, move _34); // scope 8 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                          // mir::Constant"}, {"sha": "d7b6d64b6b7b7abb655d0cb729df2f36a4c19445", "filename": "tests/mir-opt/retag.main.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fretag.main.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fretag.main.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fretag.main.SimplifyCfg-elaborate-drops.after.mir?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -62,8 +62,7 @@ fn main() -> () {\n         StorageLive(_3);                 // scope 1 at $DIR/retag.rs:+3:13: +3:14\n         StorageLive(_4);                 // scope 1 at $DIR/retag.rs:+3:17: +3:36\n         StorageLive(_5);                 // scope 1 at $DIR/retag.rs:+3:17: +3:24\n-        Deinit(_5);                      // scope 1 at $DIR/retag.rs:+3:17: +3:24\n-        (_5.0: i32) = const 0_i32;       // scope 1 at $DIR/retag.rs:+3:17: +3:24\n+        _5 = Test(const 0_i32);          // scope 1 at $DIR/retag.rs:+3:17: +3:24\n         _4 = &_5;                        // scope 1 at $DIR/retag.rs:+3:17: +3:36\n         StorageLive(_6);                 // scope 1 at $DIR/retag.rs:+3:29: +3:35\n         StorageLive(_7);                 // scope 1 at $DIR/retag.rs:+3:29: +3:35\n@@ -107,7 +106,14 @@ fn main() -> () {\n         StorageDead(_2);                 // scope 1 at $DIR/retag.rs:+8:5: +8:6\n         StorageLive(_13);                // scope 1 at $DIR/retag.rs:+11:9: +11:10\n         StorageLive(_14);                // scope 1 at $DIR/retag.rs:+11:31: +14:6\n-        Deinit(_14);                     // scope 1 at $DIR/retag.rs:+11:31: +14:6\n+        _14 = [closure@main::{closure#0}]; // scope 1 at $DIR/retag.rs:+11:31: +14:6\n+                                         // closure\n+                                         // + def_id: DefId(0:14 ~ retag[4622]::main::{closure#0})\n+                                         // + substs: [\n+                                         //     i8,\n+                                         //     for<'a> extern \"rust-call\" fn((&'a i32,)) -> &'a i32,\n+                                         //     (),\n+                                         // ]\n         Retag(_14);                      // scope 1 at $DIR/retag.rs:+11:31: +14:6\n         _13 = move _14 as for<'a> fn(&'a i32) -> &'a i32 (Pointer(ClosureFnPointer(Normal))); // scope 1 at $DIR/retag.rs:+11:31: +14:6\n         StorageDead(_14);                // scope 1 at $DIR/retag.rs:+11:47: +11:48\n@@ -129,8 +135,7 @@ fn main() -> () {\n         StorageLive(_19);                // scope 7 at $DIR/retag.rs:+18:5: +18:24\n         StorageLive(_20);                // scope 7 at $DIR/retag.rs:+18:5: +18:24\n         StorageLive(_21);                // scope 7 at $DIR/retag.rs:+18:5: +18:12\n-        Deinit(_21);                     // scope 7 at $DIR/retag.rs:+18:5: +18:12\n-        (_21.0: i32) = const 0_i32;      // scope 7 at $DIR/retag.rs:+18:5: +18:12\n+        _21 = Test(const 0_i32);         // scope 7 at $DIR/retag.rs:+18:5: +18:12\n         _20 = &_21;                      // scope 7 at $DIR/retag.rs:+18:5: +18:24\n         StorageLive(_22);                // scope 7 at $DIR/retag.rs:+18:21: +18:23\n         StorageLive(_23);                // scope 7 at $DIR/retag.rs:+18:21: +18:23"}, {"sha": "cb89d6340760f9ebc022d6b0f2ca9ad654d501e2", "filename": "tests/mir-opt/separate_const_switch.identity.SeparateConstSwitch.diff", "status": "modified", "additions": 19, "deletions": 41, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fseparate_const_switch.identity.SeparateConstSwitch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fseparate_const_switch.identity.SeparateConstSwitch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fseparate_const_switch.identity.SeparateConstSwitch.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -56,36 +56,31 @@\n           StorageLive(_4);                 // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:9\n           _4 = _1;                         // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:9\n           _10 = discriminant(_4);          // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n--         switchInt(move _10) -> [0: bb7, 1: bb5, otherwise: bb6]; // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-+         switchInt(move _10) -> [0: bb6, 1: bb4, otherwise: bb5]; // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n+          switchInt(move _10) -> [0: bb7, 1: bb5, otherwise: bb6]; // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n       }\n   \n       bb1: {\n--         StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n--         _5 = discriminant(_3);           // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n--         switchInt(move _5) -> [0: bb2, 1: bb4, otherwise: bb3]; // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n--     }\n-- \n--     bb2: {\n+          StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n+          _5 = discriminant(_3);           // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n+          switchInt(move _5) -> [0: bb2, 1: bb4, otherwise: bb3]; // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n+      }\n+  \n+      bb2: {\n           StorageLive(_9);                 // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n           _9 = ((_3 as Continue).0: i32);  // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n           _2 = _9;                         // scope 4 at $DIR/separate_const_switch.rs:+1:8: +1:10\n           StorageDead(_9);                 // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-          Deinit(_0);                      // scope 0 at $DIR/separate_const_switch.rs:+1:5: +1:11\n-          ((_0 as Ok).0: i32) = move _2;   // scope 0 at $DIR/separate_const_switch.rs:+1:5: +1:11\n-          discriminant(_0) = 0;            // scope 0 at $DIR/separate_const_switch.rs:+1:5: +1:11\n+          _0 = Result::<i32, i32>::Ok(move _2); // scope 0 at $DIR/separate_const_switch.rs:+1:5: +1:11\n           StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:+1:10: +1:11\n           StorageDead(_3);                 // scope 0 at $DIR/separate_const_switch.rs:+2:1: +2:2\n           return;                          // scope 0 at $DIR/separate_const_switch.rs:+2:2: +2:2\n       }\n   \n--     bb3: {\n-+     bb2: {\n+      bb3: {\n           unreachable;                     // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n       }\n   \n--     bb4: {\n-+     bb3: {\n+      bb4: {\n           StorageLive(_6);                 // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n           _6 = ((_3 as Break).0: std::result::Result<std::convert::Infallible, i32>); // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n           StorageLive(_8);                 // scope 2 at $DIR/separate_const_switch.rs:+1:9: +1:10\n@@ -97,9 +92,7 @@\n           _18 = move _16;                  // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n           _17 = move _18;                  // scope 10 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n           StorageDead(_18);                // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-          Deinit(_0);                      // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-          ((_0 as Err).0: i32) = move _17; // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n-          discriminant(_0) = 1;            // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n+          _0 = Result::<i32, i32>::Err(move _17); // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n           StorageDead(_17);                // scope 9 at $SRC_DIR/core/src/result.rs:LL:COL\n           StorageDead(_16);                // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n           StorageDead(_8);                 // scope 2 at $DIR/separate_const_switch.rs:+1:9: +1:10\n@@ -109,48 +102,33 @@\n           return;                          // scope 0 at $DIR/separate_const_switch.rs:+2:2: +2:2\n       }\n   \n--     bb5: {\n-+     bb4: {\n+      bb5: {\n           StorageLive(_13);                // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n           _13 = move ((_4 as Err).0: i32); // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n           StorageLive(_14);                // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n           StorageLive(_15);                // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n           _15 = move _13;                  // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          Deinit(_14);                     // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          ((_14 as Err).0: i32) = move _15; // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          discriminant(_14) = 1;           // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+          _14 = Result::<Infallible, i32>::Err(move _15); // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n           StorageDead(_15);                // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          Deinit(_3);                      // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          ((_3 as Break).0: std::result::Result<std::convert::Infallible, i32>) = move _14; // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n-          discriminant(_3) = 1;            // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n+          _3 = ControlFlow::<Result<Infallible, i32>, i32>::Break(move _14); // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n           StorageDead(_14);                // scope 7 at $SRC_DIR/core/src/result.rs:LL:COL\n           StorageDead(_13);                // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n--         goto -> bb1;                     // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-+         StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-+         _5 = discriminant(_3);           // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-+         switchInt(move _5) -> [0: bb1, 1: bb3, otherwise: bb2]; // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n+          goto -> bb1;                     // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n       }\n   \n--     bb6: {\n-+     bb5: {\n+      bb6: {\n           unreachable;                     // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n       }\n   \n--     bb7: {\n-+     bb6: {\n+      bb7: {\n           StorageLive(_11);                // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n           _11 = move ((_4 as Ok).0: i32);  // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n           StorageLive(_12);                // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n           _12 = move _11;                  // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-          Deinit(_3);                      // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-          ((_3 as Continue).0: i32) = move _12; // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-          discriminant(_3) = 0;            // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n+          _3 = ControlFlow::<Result<Infallible, i32>, i32>::Continue(move _12); // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n           StorageDead(_12);                // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n           StorageDead(_11);                // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n--         goto -> bb1;                     // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-+         StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n-+         _5 = discriminant(_3);           // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-+         switchInt(move _5) -> [0: bb1, 1: bb3, otherwise: bb2]; // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n+          goto -> bb1;                     // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n       }\n   }\n   "}, {"sha": "3c7e9dc6131523601efb5e967f447dec60005f5e", "filename": "tests/mir-opt/separate_const_switch.too_complex.SeparateConstSwitch.diff", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fseparate_const_switch.too_complex.SeparateConstSwitch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fseparate_const_switch.too_complex.SeparateConstSwitch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fseparate_const_switch.too_complex.SeparateConstSwitch.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -38,14 +38,10 @@\n           _6 = ((_1 as Err).0: usize);     // scope 0 at $DIR/separate_const_switch.rs:+8:17: +8:18\n           StorageLive(_7);                 // scope 2 at $DIR/separate_const_switch.rs:+8:42: +8:43\n           _7 = _6;                         // scope 2 at $DIR/separate_const_switch.rs:+8:42: +8:43\n-          Deinit(_2);                      // scope 2 at $DIR/separate_const_switch.rs:+8:23: +8:44\n-          ((_2 as Break).0: usize) = move _7; // scope 2 at $DIR/separate_const_switch.rs:+8:23: +8:44\n-          discriminant(_2) = 1;            // scope 2 at $DIR/separate_const_switch.rs:+8:23: +8:44\n+          _2 = ControlFlow::<usize, i32>::Break(move _7); // scope 2 at $DIR/separate_const_switch.rs:+8:23: +8:44\n           StorageDead(_7);                 // scope 2 at $DIR/separate_const_switch.rs:+8:43: +8:44\n           StorageDead(_6);                 // scope 0 at $DIR/separate_const_switch.rs:+8:43: +8:44\n--         goto -> bb4;                     // scope 0 at $DIR/separate_const_switch.rs:+8:43: +8:44\n-+         _8 = discriminant(_2);           // scope 0 at $DIR/separate_const_switch.rs:+5:11: +10:6\n-+         switchInt(move _8) -> [0: bb6, 1: bb4, otherwise: bb5]; // scope 0 at $DIR/separate_const_switch.rs:+5:5: +10:6\n+          goto -> bb4;                     // scope 0 at $DIR/separate_const_switch.rs:+8:43: +8:44\n       }\n   \n       bb2: {\n@@ -57,53 +53,41 @@\n           _4 = ((_1 as Ok).0: i32);        // scope 0 at $DIR/separate_const_switch.rs:+7:16: +7:17\n           StorageLive(_5);                 // scope 1 at $DIR/separate_const_switch.rs:+7:44: +7:45\n           _5 = _4;                         // scope 1 at $DIR/separate_const_switch.rs:+7:44: +7:45\n-          Deinit(_2);                      // scope 1 at $DIR/separate_const_switch.rs:+7:22: +7:46\n-          ((_2 as Continue).0: i32) = move _5; // scope 1 at $DIR/separate_const_switch.rs:+7:22: +7:46\n-          discriminant(_2) = 0;            // scope 1 at $DIR/separate_const_switch.rs:+7:22: +7:46\n+          _2 = ControlFlow::<usize, i32>::Continue(move _5); // scope 1 at $DIR/separate_const_switch.rs:+7:22: +7:46\n           StorageDead(_5);                 // scope 1 at $DIR/separate_const_switch.rs:+7:45: +7:46\n           StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:+7:45: +7:46\n--         goto -> bb4;                     // scope 0 at $DIR/separate_const_switch.rs:+7:45: +7:46\n--     }\n-- \n--     bb4: {\n+          goto -> bb4;                     // scope 0 at $DIR/separate_const_switch.rs:+7:45: +7:46\n+      }\n+  \n+      bb4: {\n           _8 = discriminant(_2);           // scope 0 at $DIR/separate_const_switch.rs:+5:11: +10:6\n--         switchInt(move _8) -> [0: bb7, 1: bb5, otherwise: bb6]; // scope 0 at $DIR/separate_const_switch.rs:+5:5: +10:6\n-+         switchInt(move _8) -> [0: bb6, 1: bb4, otherwise: bb5]; // scope 0 at $DIR/separate_const_switch.rs:+5:5: +10:6\n+          switchInt(move _8) -> [0: bb7, 1: bb5, otherwise: bb6]; // scope 0 at $DIR/separate_const_switch.rs:+5:5: +10:6\n       }\n   \n--     bb5: {\n-+     bb4: {\n+      bb5: {\n           StorageLive(_11);                // scope 0 at $DIR/separate_const_switch.rs:+12:28: +12:29\n           _11 = ((_2 as Break).0: usize);  // scope 0 at $DIR/separate_const_switch.rs:+12:28: +12:29\n-          Deinit(_0);                      // scope 4 at $DIR/separate_const_switch.rs:+12:34: +12:38\n-          discriminant(_0) = 0;            // scope 4 at $DIR/separate_const_switch.rs:+12:34: +12:38\n+          _0 = Option::<i32>::None;        // scope 4 at $DIR/separate_const_switch.rs:+12:34: +12:38\n           StorageDead(_11);                // scope 0 at $DIR/separate_const_switch.rs:+12:37: +12:38\n--         goto -> bb8;                     // scope 0 at $DIR/separate_const_switch.rs:+12:37: +12:38\n-+         goto -> bb7;                     // scope 0 at $DIR/separate_const_switch.rs:+12:37: +12:38\n+          goto -> bb8;                     // scope 0 at $DIR/separate_const_switch.rs:+12:37: +12:38\n       }\n   \n--     bb6: {\n-+     bb5: {\n+      bb6: {\n           unreachable;                     // scope 0 at $DIR/separate_const_switch.rs:+5:11: +10:6\n       }\n   \n--     bb7: {\n-+     bb6: {\n+      bb7: {\n           StorageLive(_9);                 // scope 0 at $DIR/separate_const_switch.rs:+11:31: +11:32\n           _9 = ((_2 as Continue).0: i32);  // scope 0 at $DIR/separate_const_switch.rs:+11:31: +11:32\n           StorageLive(_10);                // scope 3 at $DIR/separate_const_switch.rs:+11:42: +11:43\n           _10 = _9;                        // scope 3 at $DIR/separate_const_switch.rs:+11:42: +11:43\n-          Deinit(_0);                      // scope 3 at $DIR/separate_const_switch.rs:+11:37: +11:44\n-          ((_0 as Some).0: i32) = move _10; // scope 3 at $DIR/separate_const_switch.rs:+11:37: +11:44\n-          discriminant(_0) = 1;            // scope 3 at $DIR/separate_const_switch.rs:+11:37: +11:44\n+          _0 = Option::<i32>::Some(move _10); // scope 3 at $DIR/separate_const_switch.rs:+11:37: +11:44\n           StorageDead(_10);                // scope 3 at $DIR/separate_const_switch.rs:+11:43: +11:44\n           StorageDead(_9);                 // scope 0 at $DIR/separate_const_switch.rs:+11:43: +11:44\n--         goto -> bb8;                     // scope 0 at $DIR/separate_const_switch.rs:+11:43: +11:44\n-+         goto -> bb7;                     // scope 0 at $DIR/separate_const_switch.rs:+11:43: +11:44\n+          goto -> bb8;                     // scope 0 at $DIR/separate_const_switch.rs:+11:43: +11:44\n       }\n   \n--     bb8: {\n-+     bb7: {\n+      bb8: {\n           StorageDead(_2);                 // scope 0 at $DIR/separate_const_switch.rs:+14:1: +14:2\n           return;                          // scope 0 at $DIR/separate_const_switch.rs:+14:2: +14:2\n       }"}, {"sha": "e338f15b4853144be1b1019369f36759a6572516", "filename": "tests/mir-opt/simple_option_map_e2e.ezmap.PreCodegen.after.mir", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fsimple_option_map_e2e.ezmap.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fsimple_option_map_e2e.ezmap.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fsimple_option_map_e2e.ezmap.PreCodegen.after.mir?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -8,12 +8,12 @@ fn ezmap(_1: Option<i32>) -> Option<i32> {\n         debug slf => _1;                 // in scope 1 at $DIR/simple_option_map_e2e.rs:2:17: 2:20\n         debug f => _2;                   // in scope 1 at $DIR/simple_option_map_e2e.rs:2:33: 2:34\n         let mut _3: isize;               // in scope 1 at $DIR/simple_option_map_e2e.rs:7:9: 7:16\n-        let mut _4: i32;                 // in scope 1 at $DIR/simple_option_map_e2e.rs:7:25: 7:29\n+        let _4: i32;                     // in scope 1 at $DIR/simple_option_map_e2e.rs:7:14: 7:15\n         let mut _5: i32;                 // in scope 1 at $DIR/simple_option_map_e2e.rs:7:25: 7:29\n         scope 2 {\n-            debug x => _5;               // in scope 2 at $DIR/simple_option_map_e2e.rs:7:14: 7:15\n+            debug x => _4;               // in scope 2 at $DIR/simple_option_map_e2e.rs:7:14: 7:15\n             scope 3 (inlined ezmap::{closure#0}) { // at $DIR/simple_option_map_e2e.rs:7:25: 7:29\n-                debug n => _5;           // in scope 3 at $DIR/simple_option_map_e2e.rs:+1:13: +1:14\n+                debug n => _4;           // in scope 3 at $DIR/simple_option_map_e2e.rs:+1:13: +1:14\n             }\n         }\n     }\n@@ -25,8 +25,7 @@ fn ezmap(_1: Option<i32>) -> Option<i32> {\n     }\n \n     bb1: {\n-        Deinit(_0);                      // scope 1 at $DIR/simple_option_map_e2e.rs:8:17: 8:21\n-        discriminant(_0) = 0;            // scope 1 at $DIR/simple_option_map_e2e.rs:8:17: 8:21\n+        _0 = Option::<i32>::None;        // scope 1 at $DIR/simple_option_map_e2e.rs:8:17: 8:21\n         goto -> bb4;                     // scope 1 at $DIR/simple_option_map_e2e.rs:8:17: 8:21\n     }\n \n@@ -35,13 +34,11 @@ fn ezmap(_1: Option<i32>) -> Option<i32> {\n     }\n \n     bb3: {\n-        _5 = move ((_1 as Some).0: i32); // scope 1 at $DIR/simple_option_map_e2e.rs:7:14: 7:15\n-        StorageLive(_4);                 // scope 2 at $DIR/simple_option_map_e2e.rs:7:25: 7:29\n-        _4 = Add(_5, const 1_i32);       // scope 3 at $DIR/simple_option_map_e2e.rs:+1:16: +1:21\n-        Deinit(_0);                      // scope 2 at $DIR/simple_option_map_e2e.rs:7:20: 7:30\n-        ((_0 as Some).0: i32) = move _4; // scope 2 at $DIR/simple_option_map_e2e.rs:7:20: 7:30\n-        discriminant(_0) = 1;            // scope 2 at $DIR/simple_option_map_e2e.rs:7:20: 7:30\n-        StorageDead(_4);                 // scope 2 at $DIR/simple_option_map_e2e.rs:7:29: 7:30\n+        _4 = move ((_1 as Some).0: i32); // scope 1 at $DIR/simple_option_map_e2e.rs:7:14: 7:15\n+        StorageLive(_5);                 // scope 2 at $DIR/simple_option_map_e2e.rs:7:25: 7:29\n+        _5 = Add(_4, const 1_i32);       // scope 3 at $DIR/simple_option_map_e2e.rs:+1:16: +1:21\n+        _0 = Option::<i32>::Some(move _5); // scope 2 at $DIR/simple_option_map_e2e.rs:7:20: 7:30\n+        StorageDead(_5);                 // scope 2 at $DIR/simple_option_map_e2e.rs:7:29: 7:30\n         goto -> bb4;                     // scope 1 at $DIR/simple_option_map_e2e.rs:10:1: 10:2\n     }\n "}, {"sha": "946595e322e1889c1889d834acdbd1745fc683d4", "filename": "tests/mir-opt/simplify_locals.d1.SimplifyLocals-before-const-prop.diff", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fsimplify_locals.d1.SimplifyLocals-before-const-prop.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fsimplify_locals.d1.SimplifyLocals-before-const-prop.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fsimplify_locals.d1.SimplifyLocals-before-const-prop.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -9,8 +9,7 @@\n   \n       bb0: {\n -         StorageLive(_1);                 // scope 0 at $DIR/simplify_locals.rs:+2:13: +2:17\n--         Deinit(_1);                      // scope 0 at $DIR/simplify_locals.rs:+2:13: +2:17\n--         discriminant(_1) = 0;            // scope 0 at $DIR/simplify_locals.rs:+2:13: +2:17\n+-         _1 = E::A;                       // scope 0 at $DIR/simplify_locals.rs:+2:13: +2:17\n -         StorageDead(_1);                 // scope 0 at $DIR/simplify_locals.rs:+2:17: +2:18\n           _0 = const ();                   // scope 0 at $DIR/simplify_locals.rs:+0:9: +3:2\n           return;                          // scope 0 at $DIR/simplify_locals.rs:+3:2: +3:2"}, {"sha": "6a5dc56e211ce59b007e7ed26ee6c65e57aaf2a0", "filename": "tests/mir-opt/simplify_locals.d2.SimplifyLocals-before-const-prop.diff", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fsimplify_locals.d2.SimplifyLocals-before-const-prop.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fsimplify_locals.d2.SimplifyLocals-before-const-prop.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fsimplify_locals.d2.SimplifyLocals-before-const-prop.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -9,15 +9,11 @@\n   \n       bb0: {\n -         StorageLive(_1);                 // scope 0 at $DIR/simplify_locals.rs:+2:22: +2:26\n--         Deinit(_1);                      // scope 0 at $DIR/simplify_locals.rs:+2:22: +2:26\n--         discriminant(_1) = 1;            // scope 0 at $DIR/simplify_locals.rs:+2:22: +2:26\n+-         _1 = E::B;                       // scope 0 at $DIR/simplify_locals.rs:+2:22: +2:26\n -         StorageLive(_2);                 // scope 0 at $DIR/simplify_locals.rs:+2:5: +2:17\n -         StorageLive(_3);                 // scope 0 at $DIR/simplify_locals.rs:+2:11: +2:15\n--         Deinit(_3);                      // scope 0 at $DIR/simplify_locals.rs:+2:11: +2:15\n--         discriminant(_3) = 0;            // scope 0 at $DIR/simplify_locals.rs:+2:11: +2:15\n--         Deinit(_2);                      // scope 0 at $DIR/simplify_locals.rs:+2:6: +2:16\n--         (_2.0: i32) = const 10_i32;      // scope 0 at $DIR/simplify_locals.rs:+2:6: +2:16\n--         (_2.1: E) = move _3;             // scope 0 at $DIR/simplify_locals.rs:+2:6: +2:16\n+-         _3 = E::A;                       // scope 0 at $DIR/simplify_locals.rs:+2:11: +2:15\n+-         _2 = (const 10_i32, move _3);    // scope 0 at $DIR/simplify_locals.rs:+2:6: +2:16\n -         StorageDead(_3);                 // scope 0 at $DIR/simplify_locals.rs:+2:15: +2:16\n -         (_2.1: E) = move _1;             // scope 0 at $DIR/simplify_locals.rs:+2:5: +2:26\n -         StorageDead(_1);                 // scope 0 at $DIR/simplify_locals.rs:+2:25: +2:26"}, {"sha": "9b7dd733820344ffe78e7db64e1445947b934f5c", "filename": "tests/mir-opt/simplify_locals_fixedpoint.foo.SimplifyLocals-final.diff", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fsimplify_locals_fixedpoint.foo.SimplifyLocals-final.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fsimplify_locals_fixedpoint.foo.SimplifyLocals-final.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fsimplify_locals_fixedpoint.foo.SimplifyLocals-final.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -18,14 +18,10 @@\n       bb0: {\n           StorageLive(_1);                 // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:30: +1:69\n           StorageLive(_2);                 // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:31: +1:49\n-          Deinit(_2);                      // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:31: +1:49\n-          discriminant(_2) = 0;            // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:31: +1:49\n+          _2 = Option::<u8>::None;         // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:31: +1:49\n           StorageLive(_3);                 // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:51: +1:68\n-          Deinit(_3);                      // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:51: +1:68\n-          discriminant(_3) = 0;            // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:51: +1:68\n-          Deinit(_1);                      // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:30: +1:69\n-          (_1.0: std::option::Option<u8>) = move _2; // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:30: +1:69\n-          (_1.1: std::option::Option<T>) = move _3; // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:30: +1:69\n+          _3 = Option::<T>::None;          // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:51: +1:68\n+          _1 = (move _2, move _3);         // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:30: +1:69\n           StorageDead(_3);                 // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:68: +1:69\n           StorageDead(_2);                 // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:68: +1:69\n           _5 = discriminant((_1.0: std::option::Option<u8>)); // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:12: +1:27"}, {"sha": "0f8866f9c2f4eecfa9b91b76dea8df0b5a19347e", "filename": "tests/mir-opt/simplify_locals_removes_unused_consts.main.SimplifyLocals-before-const-prop.diff", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fsimplify_locals_removes_unused_consts.main.SimplifyLocals-before-const-prop.diff", "raw_url": "https://github.com/rust-lang/rust/raw/0d225bcf1eb270564297c1f094d54a685a5ed08e/tests%2Fmir-opt%2Fsimplify_locals_removes_unused_consts.main.SimplifyLocals-before-const-prop.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fsimplify_locals_removes_unused_consts.main.SimplifyLocals-before-const-prop.diff?ref=0d225bcf1eb270564297c1f094d54a685a5ed08e", "patch": "@@ -28,36 +28,30 @@\n       bb0: {\n -         StorageLive(_1);                 // scope 0 at $DIR/simplify_locals_removes_unused_consts.rs:+1:20: +1:28\n -         StorageLive(_2);                 // scope 0 at $DIR/simplify_locals_removes_unused_consts.rs:+1:21: +1:23\n--         Deinit(_2);                      // scope 0 at $DIR/simplify_locals_removes_unused_consts.rs:+1:21: +1:23\n+-         _2 = ();                         // scope 0 at $DIR/simplify_locals_removes_unused_consts.rs:+1:21: +1:23\n -         StorageLive(_3);                 // scope 0 at $DIR/simplify_locals_removes_unused_consts.rs:+1:25: +1:27\n--         Deinit(_3);                      // scope 0 at $DIR/simplify_locals_removes_unused_consts.rs:+1:25: +1:27\n--         Deinit(_1);                      // scope 0 at $DIR/simplify_locals_removes_unused_consts.rs:+1:20: +1:28\n--         (_1.0: ()) = move _2;            // scope 0 at $DIR/simplify_locals_removes_unused_consts.rs:+1:20: +1:28\n--         (_1.1: ()) = move _3;            // scope 0 at $DIR/simplify_locals_removes_unused_consts.rs:+1:20: +1:28\n+-         _3 = ();                         // scope 0 at $DIR/simplify_locals_removes_unused_consts.rs:+1:25: +1:27\n+-         _1 = (move _2, move _3);         // scope 0 at $DIR/simplify_locals_removes_unused_consts.rs:+1:20: +1:28\n -         StorageDead(_3);                 // scope 0 at $DIR/simplify_locals_removes_unused_consts.rs:+1:27: +1:28\n -         StorageDead(_2);                 // scope 0 at $DIR/simplify_locals_removes_unused_consts.rs:+1:27: +1:28\n -         StorageDead(_1);                 // scope 0 at $DIR/simplify_locals_removes_unused_consts.rs:+1:28: +1:29\n -         StorageLive(_4);                 // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:5: +2:22\n -         StorageLive(_5);                 // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:13: +2:21\n -         StorageLive(_6);                 // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:14: +2:16\n--         Deinit(_6);                      // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:14: +2:16\n+-         _6 = ();                         // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:14: +2:16\n -         StorageLive(_7);                 // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:18: +2:20\n--         Deinit(_7);                      // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:18: +2:20\n--         Deinit(_5);                      // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:13: +2:21\n--         (_5.0: ()) = move _6;            // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:13: +2:21\n--         (_5.1: ()) = move _7;            // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:13: +2:21\n+-         _7 = ();                         // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:18: +2:20\n+-         _5 = (move _6, move _7);         // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:13: +2:21\n -         StorageDead(_7);                 // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:20: +2:21\n -         StorageDead(_6);                 // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:20: +2:21\n -         _4 = use_zst(move _5) -> bb1;    // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:5: +2:22\n +         StorageLive(_1);                 // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:5: +2:22\n +         StorageLive(_2);                 // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:13: +2:21\n +         StorageLive(_3);                 // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:14: +2:16\n-+         Deinit(_3);                      // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:14: +2:16\n++         _3 = ();                         // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:14: +2:16\n +         StorageLive(_4);                 // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:18: +2:20\n-+         Deinit(_4);                      // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:18: +2:20\n-+         Deinit(_2);                      // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:13: +2:21\n-+         (_2.0: ()) = move _3;            // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:13: +2:21\n-+         (_2.1: ()) = move _4;            // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:13: +2:21\n++         _4 = ();                         // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:18: +2:20\n++         _2 = (move _3, move _4);         // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:13: +2:21\n +         StorageDead(_4);                 // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:20: +2:21\n +         StorageDead(_3);                 // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:20: +2:21\n +         _1 = use_zst(move _2) -> bb1;    // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+2:5: +2:22\n@@ -73,8 +67,7 @@\n -         StorageLive(_9);                 // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+4:12: +4:34\n -         StorageLive(_10);                // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+4:12: +4:30\n -         StorageLive(_11);                // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+4:12: +4:28\n--         Deinit(_11);                     // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+4:12: +4:28\n--         (_11.0: u8) = const 40_u8;       // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+4:12: +4:28\n+-         _11 = Temp { x: const 40_u8 };   // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+4:12: +4:28\n -         _10 = (_11.0: u8);               // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+4:12: +4:30\n -         _9 = Add(move _10, const 2_u8);  // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+4:12: +4:34\n -         StorageDead(_10);                // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+4:33: +4:34\n@@ -85,8 +78,7 @@\n +         StorageLive(_6);                 // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+4:12: +4:34\n +         StorageLive(_7);                 // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+4:12: +4:30\n +         StorageLive(_8);                 // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+4:12: +4:28\n-+         Deinit(_8);                      // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+4:12: +4:28\n-+         (_8.0: u8) = const 40_u8;        // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+4:12: +4:28\n++         _8 = Temp { x: const 40_u8 };    // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+4:12: +4:28\n +         _7 = (_8.0: u8);                 // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+4:12: +4:30\n +         _6 = Add(move _7, const 2_u8);   // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+4:12: +4:34\n +         StorageDead(_7);                 // scope 1 at $DIR/simplify_locals_removes_unused_consts.rs:+4:33: +4:34"}]}