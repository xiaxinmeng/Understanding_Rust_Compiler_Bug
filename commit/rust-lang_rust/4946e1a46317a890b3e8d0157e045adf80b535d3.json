{"sha": "4946e1a46317a890b3e8d0157e045adf80b535d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5NDZlMWE0NjMxN2E4OTBiM2U4ZDAxNTdlMDQ1YWRmODBiNTM1ZDM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-18T14:26:10Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-30T14:32:42Z"}, "message": "Move the TypeContents-based \"Sized\" queries into trans, where the full\ntypes are always known and hence the ParameterEnvironment is not\nnecessary. For other `Sized` queries, use the trait infrastructure\njust like `Copy`.", "tree": {"sha": "ca0d88d978a05054d81c7be244e251ed4a3315ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca0d88d978a05054d81c7be244e251ed4a3315ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4946e1a46317a890b3e8d0157e045adf80b535d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4946e1a46317a890b3e8d0157e045adf80b535d3", "html_url": "https://github.com/rust-lang/rust/commit/4946e1a46317a890b3e8d0157e045adf80b535d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4946e1a46317a890b3e8d0157e045adf80b535d3/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b64e5796ba3f501042f02d416a7a625802e9e44", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b64e5796ba3f501042f02d416a7a625802e9e44", "html_url": "https://github.com/rust-lang/rust/commit/0b64e5796ba3f501042f02d416a7a625802e9e44"}], "stats": {"total": 326, "additions": 207, "deletions": 119}, "files": [{"sha": "3b4ea5234f43fda4e0b4f42c3d56a7f248a84db3", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4946e1a46317a890b3e8d0157e045adf80b535d3/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4946e1a46317a890b3e8d0157e045adf80b535d3/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=4946e1a46317a890b3e8d0157e045adf80b535d3", "patch": "@@ -28,7 +28,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n }\n \n struct RvalueContext<'a, 'tcx: 'a> {\n-    tcx: &'a ty::ctxt<'tcx>\n+    tcx: &'a ty::ctxt<'tcx>,\n }\n \n impl<'a, 'tcx, 'v> visit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n@@ -40,21 +40,27 @@ impl<'a, 'tcx, 'v> visit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n                 fn_id: ast::NodeId) {\n         {\n             let param_env = ParameterEnvironment::for_item(self.tcx, fn_id);\n-            let mut euv = euv::ExprUseVisitor::new(self, self.tcx, &param_env);\n+            let mut delegate = RvalueContextDelegate { tcx: self.tcx, param_env: &param_env };\n+            let mut euv = euv::ExprUseVisitor::new(&mut delegate, self.tcx, &param_env);\n             euv.walk_fn(fd, b);\n         }\n         visit::walk_fn(self, fk, fd, b, s)\n     }\n }\n \n-impl<'a, 'tcx> euv::Delegate<'tcx> for RvalueContext<'a, 'tcx> {\n+struct RvalueContextDelegate<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+    param_env: &'a ty::ParameterEnvironment<'tcx>,\n+}\n+\n+impl<'a, 'tcx> euv::Delegate<'tcx> for RvalueContextDelegate<'a, 'tcx> {\n     fn consume(&mut self,\n                _: ast::NodeId,\n                span: Span,\n                cmt: mc::cmt<'tcx>,\n                _: euv::ConsumeMode) {\n         debug!(\"consume; cmt: {}; type: {}\", *cmt, ty_to_string(self.tcx, cmt.ty));\n-        if !ty::type_is_sized(self.tcx, cmt.ty) {\n+        if !ty::type_is_sized(self.tcx, cmt.ty, self.param_env) {\n             span_err!(self.tcx.sess, span, E0161,\n                 \"cannot move a value of type {0}: the size of {0} cannot be statically determined\",\n                 ty_to_string(self.tcx, cmt.ty));"}, {"sha": "5676ba6f6652b218f942a896a3e203c2a606c624", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4946e1a46317a890b3e8d0157e045adf80b535d3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4946e1a46317a890b3e8d0157e045adf80b535d3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=4946e1a46317a890b3e8d0157e045adf80b535d3", "patch": "@@ -22,6 +22,7 @@ use std::rc::Rc;\n use std::slice::Iter;\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n+use util::ppaux::Repr;\n \n pub use self::error_reporting::report_fulfillment_errors;\n pub use self::fulfill::{FulfillmentContext, RegionObligation};\n@@ -265,6 +266,43 @@ pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n     util::predicates_for_generics(tcx, cause, 0, generic_bounds)\n }\n \n+/// Determines whether the type `ty` is known to meet `bound` and\n+/// returns true if so. Returns false if `ty` either does not meet\n+/// `bound` or is not known to meet bound (note that this is\n+/// conservative towards *no impl*, which is the opposite of the\n+/// `evaluate` methods).\n+pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                                                 param_env: &ty::ParameterEnvironment<'tcx>,\n+                                                 ty: Ty<'tcx>,\n+                                                 bound: ty::BuiltinBound)\n+                                                 -> bool\n+{\n+    debug!(\"type_known_to_meet_builtin_bound(ty={}, bound={})\",\n+           ty.repr(infcx.tcx),\n+           bound);\n+\n+    let mut fulfill_cx = FulfillmentContext::new();\n+\n+    // We can use dummy values here because we won't report any errors\n+    // that result nor will we pay any mind to region obligations that arise\n+    // (there shouldn't really be any anyhow).\n+    let cause = ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID);\n+\n+    fulfill_cx.register_builtin_bound(infcx.tcx, ty, bound, cause);\n+\n+    // Note: we only assume something is `Copy` if we can\n+    // *definitively* show that it implements `Copy`. Otherwise,\n+    // assume it is move; linear is always ok.\n+    let result = fulfill_cx.select_all_or_error(infcx, param_env, infcx.tcx).is_ok();\n+\n+    debug!(\"type_known_to_meet_builtin_bound: ty={} bound={} result={}\",\n+           ty.repr(infcx.tcx),\n+           bound,\n+           result);\n+\n+    result\n+}\n+\n impl<'tcx,O> Obligation<'tcx,O> {\n     pub fn new(cause: ObligationCause<'tcx>,\n                trait_ref: O)"}, {"sha": "731ad64799e3a1f041eee16b59cbd00b72602cb1", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 49, "deletions": 71, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/4946e1a46317a890b3e8d0157e045adf80b535d3/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4946e1a46317a890b3e8d0157e045adf80b535d3/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4946e1a46317a890b3e8d0157e045adf80b535d3", "patch": "@@ -56,7 +56,6 @@ use middle::resolve_lifetime;\n use middle::infer;\n use middle::stability;\n use middle::subst::{mod, Subst, Substs, VecPerParamSpace};\n-use middle::traits::ObligationCause;\n use middle::traits;\n use middle::ty;\n use middle::ty_fold::{mod, TypeFoldable, TypeFolder};\n@@ -65,7 +64,7 @@ use util::ppaux::{trait_store_to_string, ty_to_string};\n use util::ppaux::{Repr, UserString};\n use util::common::{indenter, memoized, ErrorReported};\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n-use util::nodemap::{FnvHashMap, FnvHashSet};\n+use util::nodemap::{FnvHashMap};\n \n use arena::TypedArena;\n use std::borrow::BorrowFrom;\n@@ -80,13 +79,13 @@ use collections::enum_set::{EnumSet, CLike};\n use std::collections::{HashMap, HashSet};\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use syntax::abi;\n-use syntax::ast::{CrateNum, DefId, DUMMY_NODE_ID, Ident, ItemTrait, LOCAL_CRATE};\n+use syntax::ast::{CrateNum, DefId, Ident, ItemTrait, LOCAL_CRATE};\n use syntax::ast::{MutImmutable, MutMutable, Name, NamedField, NodeId};\n use syntax::ast::{Onceness, StmtExpr, StmtSemi, StructField, UnnamedField};\n use syntax::ast::{Visibility};\n use syntax::ast_util::{mod, is_local, lit_is_str, local_def, PostExpansionMethod};\n use syntax::attr::{mod, AttrMetaMethods};\n-use syntax::codemap::{DUMMY_SP, Span};\n+use syntax::codemap::Span;\n use syntax::parse::token::{mod, InternedString};\n use syntax::{ast, ast_map};\n \n@@ -780,8 +779,15 @@ pub struct ctxt<'tcx> {\n     /// Caches the representation hints for struct definitions.\n     pub repr_hint_cache: RefCell<DefIdMap<Rc<Vec<attr::ReprAttr>>>>,\n \n-    /// Caches whether types move by default.\n-    pub type_moves_by_default_cache: RefCell<HashMap<Ty<'tcx>,bool>>,\n+    /// Caches whether types are known to impl Copy. Note that type\n+    /// parameters are never placed into this cache, because their\n+    /// results are dependent on the parameter environment.\n+    pub type_impls_copy_cache: RefCell<HashMap<Ty<'tcx>,bool>>,\n+\n+    /// Caches whether types are known to impl Sized. Note that type\n+    /// parameters are never placed into this cache, because their\n+    /// results are dependent on the parameter environment.\n+    pub type_impls_sized_cache: RefCell<HashMap<Ty<'tcx>,bool>>,\n }\n \n // Flags that we track on types. These flags are propagated upwards\n@@ -2142,7 +2148,8 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         associated_types: RefCell::new(DefIdMap::new()),\n         selection_cache: traits::SelectionCache::new(),\n         repr_hint_cache: RefCell::new(DefIdMap::new()),\n-        type_moves_by_default_cache: RefCell::new(HashMap::new()),\n+        type_impls_copy_cache: RefCell::new(HashMap::new()),\n+        type_impls_sized_cache: RefCell::new(HashMap::new()),\n    }\n }\n \n@@ -2791,14 +2798,6 @@ pub fn type_is_unique(ty: Ty) -> bool {\n     }\n }\n \n-pub fn type_is_fat_ptr<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.sty {\n-        ty_ptr(mt{ty, ..}) | ty_rptr(_, mt{ty, ..})\n-        | ty_uniq(ty) if !type_is_sized(cx, ty) => true,\n-        _ => false,\n-    }\n-}\n-\n /*\n  A scalar type is one that denotes an atomic datum, with no sub-components.\n  (A ty_ptr is scalar because it represents a non-managed pointer, so its\n@@ -3289,45 +3288,58 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n     }\n }\n \n-pub fn type_moves_by_default<'tcx>(cx: &ctxt<'tcx>,\n-                                   ty: Ty<'tcx>,\n-                                   param_env: &ParameterEnvironment<'tcx>)\n-                                   -> bool\n+fn type_impls_bound<'tcx>(cx: &ctxt<'tcx>,\n+                          cache: &RefCell<HashMap<Ty<'tcx>,bool>>,\n+                          param_env: &ParameterEnvironment<'tcx>,\n+                          ty: Ty<'tcx>,\n+                          bound: ty::BuiltinBound)\n+                          -> bool\n {\n+    assert!(!ty::type_needs_infer(ty));\n+\n     if !type_has_params(ty) && !type_has_self(ty) {\n-        match cx.type_moves_by_default_cache.borrow().get(&ty) {\n+        match cache.borrow().get(&ty) {\n             None => {}\n             Some(&result) => {\n-                debug!(\"determined whether {} moves by default (cached): {}\",\n+                debug!(\"type_impls_bound({}, {}) = {} (cached)\",\n                        ty_to_string(cx, ty),\n+                       bound,\n                        result);\n                 return result\n             }\n         }\n     }\n \n     let infcx = infer::new_infer_ctxt(cx);\n-    let mut fulfill_cx = traits::FulfillmentContext::new();\n+    let is_impld = traits::type_known_to_meet_builtin_bound(&infcx, param_env, ty, bound);\n \n-    // we can use dummy values here because we won't report any errors\n-    // that result nor will we pay any mind to region obligations that arise\n-    // (there shouldn't really be any anyhow)\n-    let cause = ObligationCause::misc(DUMMY_SP, DUMMY_NODE_ID);\n+    debug!(\"type_impls_bound({}, {}) = {}\",\n+           ty_to_string(cx, ty),\n+           bound,\n+           is_impld);\n \n-    fulfill_cx.register_builtin_bound(cx, ty, ty::BoundCopy, cause);\n+    if !type_has_params(ty) && !type_has_self(ty) {\n+        let old_value = cache.borrow_mut().insert(ty, is_impld);\n+        assert!(old_value.is_none());\n+    }\n \n-    // Note: we only assuming something is `Copy` if we can\n-    // *definitively* show that it implements `Copy`. Otherwise,\n-    // assume it is move; linear is always ok.\n-    let is_copy = fulfill_cx.select_all_or_error(&infcx, param_env, cx).is_ok();\n-    let is_move = !is_copy;\n+    is_impld\n+}\n \n-    debug!(\"determined whether {} moves by default: {}\",\n-           ty_to_string(cx, ty),\n-           is_move);\n+pub fn type_moves_by_default<'tcx>(cx: &ctxt<'tcx>,\n+                                   ty: Ty<'tcx>,\n+                                   param_env: &ParameterEnvironment<'tcx>)\n+                                   -> bool\n+{\n+    !type_impls_bound(cx, &cx.type_impls_copy_cache, param_env, ty, ty::BoundCopy)\n+}\n \n-    cx.type_moves_by_default_cache.borrow_mut().insert(ty, is_move);\n-    is_move\n+pub fn type_is_sized<'tcx>(cx: &ctxt<'tcx>,\n+                           ty: Ty<'tcx>,\n+                           param_env: &ParameterEnvironment<'tcx>)\n+                           -> bool\n+{\n+    type_impls_bound(cx, &cx.type_impls_sized_cache, param_env, ty, ty::BoundSized)\n }\n \n pub fn is_ffi_safe<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -3699,40 +3711,6 @@ pub fn type_is_machine(ty: Ty) -> bool {\n     }\n }\n \n-// Is the type's representation size known at compile time?\n-pub fn type_is_sized<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    type_contents(cx, ty).is_sized(cx)\n-}\n-\n-pub fn lltype_is_sized<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.sty {\n-        ty_open(_) => true,\n-        _ => type_contents(cx, ty).is_sized(cx)\n-    }\n-}\n-\n-// Return the smallest part of `ty` which is unsized. Fails if `ty` is sized.\n-// 'Smallest' here means component of the static representation of the type; not\n-// the size of an object at runtime.\n-pub fn unsized_part_of_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    match ty.sty {\n-        ty_str | ty_trait(..) | ty_vec(..) => ty,\n-        ty_struct(def_id, substs) => {\n-            let unsized_fields: Vec<_> = struct_fields(cx, def_id, substs).iter()\n-                .map(|f| f.mt.ty).filter(|ty| !type_is_sized(cx, *ty)).collect();\n-            // Exactly one of the fields must be unsized.\n-            assert!(unsized_fields.len() == 1);\n-\n-            unsized_part_of_type(cx, unsized_fields[0])\n-        }\n-        _ => {\n-            assert!(type_is_sized(cx, ty),\n-                    \"unsized_part_of_type failed even though ty is unsized\");\n-            panic!(\"called unsized_part_of_type with sized ty\");\n-        }\n-    }\n-}\n-\n // Whether a type is enum like, that is an enum type with only nullary\n // constructors\n pub fn type_is_c_like_enum(cx: &ctxt, ty: Ty) -> bool {"}, {"sha": "717c2af2beb9635d24de8f86b0d75ca9c12716be", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4946e1a46317a890b3e8d0157e045adf80b535d3/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4946e1a46317a890b3e8d0157e045adf80b535d3/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=4946e1a46317a890b3e8d0157e045adf80b535d3", "patch": "@@ -343,7 +343,7 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                     mut path: DiscrField) -> Option<DiscrField> {\n     match ty.sty {\n         // Fat &T/&mut T/Box<T> i.e. T is [T], str, or Trait\n-        ty::ty_rptr(_, ty::mt { ty, .. }) | ty::ty_uniq(ty) if !ty::type_is_sized(tcx, ty) => {\n+        ty::ty_rptr(_, ty::mt { ty, .. }) | ty::ty_uniq(ty) if !type_is_sized(tcx, ty) => {\n             path.push(FAT_PTR_ADDR);\n             Some(path)\n         },\n@@ -447,12 +447,12 @@ fn mk_struct<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                        tys: &[Ty<'tcx>], packed: bool,\n                        scapegoat: Ty<'tcx>)\n                        -> Struct<'tcx> {\n-    let sized = tys.iter().all(|&ty| ty::type_is_sized(cx.tcx(), ty));\n+    let sized = tys.iter().all(|&ty| type_is_sized(cx.tcx(), ty));\n     let lltys : Vec<Type> = if sized {\n         tys.iter()\n            .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n     } else {\n-        tys.iter().filter(|&ty| ty::type_is_sized(cx.tcx(), *ty))\n+        tys.iter().filter(|&ty| type_is_sized(cx.tcx(), *ty))\n            .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n     };\n \n@@ -704,7 +704,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, st: &Struct<'tcx>,\n                              sizing: bool, dst: bool) -> Vec<Type> {\n     if sizing {\n-        st.fields.iter().filter(|&ty| !dst || ty::type_is_sized(cx.tcx(), *ty))\n+        st.fields.iter().filter(|&ty| !dst || type_is_sized(cx.tcx(), *ty))\n             .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n     } else {\n         st.fields.iter().map(|&ty| type_of::type_of(cx, ty)).collect()"}, {"sha": "397baac960d2453153e9d81eeb72b757dd36882d", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4946e1a46317a890b3e8d0157e045adf80b535d3/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4946e1a46317a890b3e8d0157e045adf80b535d3/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=4946e1a46317a890b3e8d0157e045adf80b535d3", "patch": "@@ -581,7 +581,7 @@ pub fn compare_scalar_types<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     match t.sty {\n         ty::ty_tup(ref tys) if tys.is_empty() => f(nil_type),\n         ty::ty_bool | ty::ty_uint(_) | ty::ty_char => f(unsigned_int),\n-        ty::ty_ptr(mt) if ty::type_is_sized(cx.tcx(), mt.ty) => f(unsigned_int),\n+        ty::ty_ptr(mt) if common::type_is_sized(cx.tcx(), mt.ty) => f(unsigned_int),\n         ty::ty_int(_) => f(signed_int),\n         ty::ty_float(_) => f(floating_point),\n             // Should never get here, because t is scalar.\n@@ -719,7 +719,7 @@ pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n         return cx;\n     }\n \n-    let (data_ptr, info) = if ty::type_is_sized(cx.tcx(), t) {\n+    let (data_ptr, info) = if common::type_is_sized(cx.tcx(), t) {\n         (av, None)\n     } else {\n         let data = GEPi(cx, av, &[0, abi::FAT_PTR_ADDR]);\n@@ -736,7 +736,7 @@ pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                   let field_ty = field_ty.mt.ty;\n                   let llfld_a = adt::trans_field_ptr(cx, &*repr, data_ptr, discr, i);\n \n-                  let val = if ty::type_is_sized(cx.tcx(), field_ty) {\n+                  let val = if common::type_is_sized(cx.tcx(), field_ty) {\n                       llfld_a\n                   } else {\n                       let boxed_ty = ty::mk_open(cx.tcx(), field_ty);\n@@ -2522,7 +2522,7 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n             match ret_ty.sty {\n                 // `~` pointer return values never alias because ownership\n                 // is transferred\n-                ty::ty_uniq(it) if !ty::type_is_sized(ccx.tcx(), it) => {}\n+                ty::ty_uniq(it) if !common::type_is_sized(ccx.tcx(), it) => {}\n                 ty::ty_uniq(_) => {\n                     attrs.ret(llvm::NoAliasAttribute);\n                 }\n@@ -2533,7 +2533,7 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n             match ret_ty.sty {\n                 // These are not really pointers but pairs, (pointer, len)\n                 ty::ty_uniq(it) |\n-                ty::ty_rptr(_, ty::mt { ty: it, .. }) if !ty::type_is_sized(ccx.tcx(), it) => {}\n+                ty::ty_rptr(_, ty::mt { ty: it, .. }) if !common::type_is_sized(ccx.tcx(), it) => {}\n                 ty::ty_uniq(inner) | ty::ty_rptr(_, ty::mt { ty: inner, .. }) => {\n                     let llret_sz = llsize_of_real(ccx, type_of::type_of(ccx, inner));\n                     attrs.ret(llvm::DereferenceableAttribute(llret_sz));"}, {"sha": "f052a20bc89eb67c73d7fcf266a24969141474be", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4946e1a46317a890b3e8d0157e045adf80b535d3/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4946e1a46317a890b3e8d0157e045adf80b535d3/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=4946e1a46317a890b3e8d0157e045adf80b535d3", "patch": "@@ -58,6 +58,58 @@ use util::nodemap::FnvHashSet;\n \n pub use trans::context::CrateContext;\n \n+// Is the type's representation size known at compile time?\n+pub fn type_is_sized<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n+    ty::type_contents(cx, ty).is_sized(cx)\n+}\n+\n+pub fn lltype_is_sized<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n+    match ty.sty {\n+        ty::ty_open(_) => true,\n+        _ => type_is_sized(cx, ty),\n+    }\n+}\n+\n+pub fn type_is_fat_ptr<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n+    match ty.sty {\n+        ty::ty_ptr(ty::mt{ty, ..}) |\n+        ty::ty_rptr(_, ty::mt{ty, ..}) |\n+        ty::ty_uniq(ty) => {\n+            !type_is_sized(cx, ty)\n+        }\n+        _ => {\n+            false\n+        }\n+    }\n+}\n+\n+// Return the smallest part of `ty` which is unsized. Fails if `ty` is sized.\n+// 'Smallest' here means component of the static representation of the type; not\n+// the size of an object at runtime.\n+pub fn unsized_part_of_type<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    match ty.sty {\n+        ty::ty_str | ty::ty_trait(..) | ty::ty_vec(..) => ty,\n+        ty::ty_struct(def_id, substs) => {\n+            let unsized_fields: Vec<_> =\n+                ty::struct_fields(cx, def_id, substs)\n+                .iter()\n+                .map(|f| f.mt.ty)\n+                .filter(|ty| !type_is_sized(cx, *ty))\n+                .collect();\n+\n+            // Exactly one of the fields must be unsized.\n+            assert!(unsized_fields.len() == 1);\n+\n+            unsized_part_of_type(cx, unsized_fields[0])\n+        }\n+        _ => {\n+            assert!(type_is_sized(cx, ty),\n+                    \"unsized_part_of_type failed even though ty is unsized\");\n+            panic!(\"called unsized_part_of_type with sized ty\");\n+        }\n+    }\n+}\n+\n // Some things don't need cleanups during unwinding because the\n // task can free them all at once later. Currently only things\n // that only contain scalars and shared boxes can avoid unwind\n@@ -128,10 +180,10 @@ pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n         ty::type_is_unique(ty) || ty::type_is_region_ptr(ty) ||\n         type_is_newtype_immediate(ccx, ty) ||\n         ty::type_is_simd(tcx, ty);\n-    if simple && !ty::type_is_fat_ptr(tcx, ty) {\n+    if simple && !type_is_fat_ptr(tcx, ty) {\n         return true;\n     }\n-    if !ty::type_is_sized(tcx, ty) {\n+    if !type_is_sized(tcx, ty) {\n         return false;\n     }\n     match ty.sty {"}, {"sha": "0fd6d286e8b2de2dff8be49bcabc325d69491440", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4946e1a46317a890b3e8d0157e045adf80b535d3/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4946e1a46317a890b3e8d0157e045adf80b535d3/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=4946e1a46317a890b3e8d0157e045adf80b535d3", "patch": "@@ -138,7 +138,7 @@ fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, v: ValueRef,\n         Some(ref mt) => {\n             match t.sty {\n                 ty::ty_ptr(mt) | ty::ty_rptr(_, mt) => {\n-                    if ty::type_is_sized(cx.tcx(), mt.ty) {\n+                    if type_is_sized(cx.tcx(), mt.ty) {\n                         (const_deref_ptr(cx, v), mt.ty)\n                     } else {\n                         // Derefing a fat pointer does not change the representation,"}, {"sha": "83bf06383a89cef9649279dbc3c2f8e8bff6064e", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4946e1a46317a890b3e8d0157e045adf80b535d3/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4946e1a46317a890b3e8d0157e045adf80b535d3/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=4946e1a46317a890b3e8d0157e045adf80b535d3", "patch": "@@ -398,7 +398,7 @@ impl<'tcx> Datum<'tcx, Expr> {\n                                  -> DatumBlock<'blk, 'tcx, Lvalue> {\n         debug!(\"to_lvalue_datum self: {}\", self.to_string(bcx.ccx()));\n \n-        assert!(ty::lltype_is_sized(bcx.tcx(), self.ty),\n+        assert!(lltype_is_sized(bcx.tcx(), self.ty),\n                 \"Trying to convert unsized value to lval\");\n         self.match_kind(\n             |l| DatumBlock::new(bcx, l),\n@@ -456,7 +456,7 @@ impl<'tcx> Datum<'tcx, Lvalue> {\n         F: FnOnce(ValueRef) -> ValueRef,\n     {\n         let val = match self.ty.sty {\n-            _ if ty::type_is_sized(bcx.tcx(), self.ty) => gep(self.val),\n+            _ if type_is_sized(bcx.tcx(), self.ty) => gep(self.val),\n             ty::ty_open(_) => {\n                 let base = Load(bcx, expr::get_dataptr(bcx, self.val));\n                 gep(base)"}, {"sha": "fc2e6c7b7fddb5a7adf5f48eb5ba6e57e019f474", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4946e1a46317a890b3e8d0157e045adf80b535d3/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4946e1a46317a890b3e8d0157e045adf80b535d3/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=4946e1a46317a890b3e8d0157e045adf80b535d3", "patch": "@@ -280,7 +280,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                expr.repr(bcx.tcx()),\n                datum.to_string(bcx.ccx()));\n \n-        if !ty::type_is_sized(bcx.tcx(), datum.ty) {\n+        if !type_is_sized(bcx.tcx(), datum.ty) {\n             debug!(\"Taking address of unsized type {}\",\n                    bcx.ty_to_string(datum.ty));\n             ref_fat_ptr(bcx, expr, datum)\n@@ -693,7 +693,7 @@ fn trans_field<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             field_tys[ix].mt.ty,\n             |srcval| adt::trans_field_ptr(bcx, &*repr, srcval, discr, ix));\n \n-        if ty::type_is_sized(bcx.tcx(), d.ty) {\n+        if type_is_sized(bcx.tcx(), d.ty) {\n             DatumBlock { datum: d.to_expr_datum(), bcx: bcx }\n         } else {\n             let scratch = rvalue_scratch_datum(bcx, ty::mk_open(bcx.tcx(), d.ty), \"\");\n@@ -773,7 +773,7 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                Some(SaveIn(scratch.val)),\n                                                true));\n             let datum = scratch.to_expr_datum();\n-            if ty::type_is_sized(bcx.tcx(), elt_ty) {\n+            if type_is_sized(bcx.tcx(), elt_ty) {\n                 Datum::new(datum.to_llscalarish(bcx), elt_ty, LvalueExpr)\n             } else {\n                 Datum::new(datum.val, ty::mk_open(bcx.tcx(), elt_ty), LvalueExpr)\n@@ -1522,7 +1522,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 for &(i, t) in base.fields.iter() {\n                     let datum = base_datum.get_element(\n                             bcx, t, |srcval| adt::trans_field_ptr(bcx, &*repr, srcval, discr, i));\n-                    assert!(ty::type_is_sized(bcx.tcx(), datum.ty));\n+                    assert!(type_is_sized(bcx.tcx(), datum.ty));\n                     let dest = adt::trans_field_ptr(bcx, &*repr, addr, discr, i);\n                     bcx = datum.store_to(bcx, dest);\n                 }\n@@ -1650,7 +1650,7 @@ fn trans_uniq_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                -> DatumBlock<'blk, 'tcx, Expr> {\n     let _icx = push_ctxt(\"trans_uniq_expr\");\n     let fcx = bcx.fcx;\n-    assert!(ty::type_is_sized(bcx.tcx(), contents_ty));\n+    assert!(type_is_sized(bcx.tcx(), contents_ty));\n     let llty = type_of::type_of(bcx.ccx(), contents_ty);\n     let size = llsize_of(bcx.ccx(), llty);\n     let align = C_uint(bcx.ccx(), type_of::align_of(bcx.ccx(), contents_ty));\n@@ -1985,7 +1985,7 @@ pub fn cast_type_kind<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> cast_kind {\n         ty::ty_char        => cast_integral,\n         ty::ty_float(..)   => cast_float,\n         ty::ty_rptr(_, mt) | ty::ty_ptr(mt) => {\n-            if ty::type_is_sized(tcx, mt.ty) {\n+            if type_is_sized(tcx, mt.ty) {\n                 cast_pointer\n             } else {\n                 cast_other\n@@ -2217,7 +2217,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let r = match datum.ty.sty {\n         ty::ty_uniq(content_ty) => {\n-            if ty::type_is_sized(bcx.tcx(), content_ty) {\n+            if type_is_sized(bcx.tcx(), content_ty) {\n                 deref_owned_pointer(bcx, expr, datum, content_ty)\n             } else {\n                 // A fat pointer and an opened DST value have the same\n@@ -2236,7 +2236,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         ty::ty_ptr(ty::mt { ty: content_ty, .. }) |\n         ty::ty_rptr(_, ty::mt { ty: content_ty, .. }) => {\n-            if ty::type_is_sized(bcx.tcx(), content_ty) {\n+            if type_is_sized(bcx.tcx(), content_ty) {\n                 let ptr = datum.to_llscalarish(bcx);\n \n                 // Always generate an lvalue datum, even if datum.mode is"}, {"sha": "31455920c1097bfe5fdea2f53d3b9313a9b309f1", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4946e1a46317a890b3e8d0157e045adf80b535d3/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4946e1a46317a890b3e8d0157e045adf80b535d3/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=4946e1a46317a890b3e8d0157e045adf80b535d3", "patch": "@@ -63,7 +63,7 @@ pub fn trans_exchange_free<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef,\n \n pub fn trans_exchange_free_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ptr: ValueRef,\n                                           content_ty: Ty<'tcx>) -> Block<'blk, 'tcx> {\n-    assert!(ty::type_is_sized(bcx.ccx().tcx(), content_ty));\n+    assert!(type_is_sized(bcx.ccx().tcx(), content_ty));\n     let sizing_type = sizing_type_of(bcx.ccx(), content_ty);\n     let content_size = llsize_of_alloc(bcx.ccx(), sizing_type);\n \n@@ -81,15 +81,15 @@ pub fn get_drop_glue_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let tcx = ccx.tcx();\n     // Even if there is no dtor for t, there might be one deeper down and we\n     // might need to pass in the vtable ptr.\n-    if !ty::type_is_sized(tcx, t) {\n+    if !type_is_sized(tcx, t) {\n         return t\n     }\n     if !type_needs_drop(tcx, t) {\n         return ty::mk_i8();\n     }\n     match t.sty {\n         ty::ty_uniq(typ) if !type_needs_drop(tcx, typ)\n-                         && ty::type_is_sized(tcx, typ) => {\n+                         && type_is_sized(tcx, typ) => {\n             let llty = sizing_type_of(ccx, typ);\n             // `Box<ZeroSizeType>` does not allocate.\n             if llsize_of_alloc(ccx, llty) == 0 {\n@@ -150,7 +150,7 @@ pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Val\n         _ => { }\n     }\n \n-    let llty = if ty::type_is_sized(ccx.tcx(), t) {\n+    let llty = if type_is_sized(ccx.tcx(), t) {\n         type_of(ccx, t).ptr_to()\n     } else {\n         type_of(ccx, ty::mk_uniq(ccx.tcx(), t)).ptr_to()\n@@ -193,7 +193,7 @@ fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                       substs: &subst::Substs<'tcx>)\n                                       -> Block<'blk, 'tcx> {\n     let repr = adt::represent_type(bcx.ccx(), t);\n-    let struct_data = if ty::type_is_sized(bcx.tcx(), t) {\n+    let struct_data = if type_is_sized(bcx.tcx(), t) {\n         v0\n     } else {\n         let llval = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n@@ -234,7 +234,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     bcx.ty_to_string(fty))[])\n     };\n \n-    let (struct_data, info) = if ty::type_is_sized(bcx.tcx(), t) {\n+    let (struct_data, info) = if type_is_sized(bcx.tcx(), t) {\n         (v0, None)\n     } else {\n         let data = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n@@ -251,7 +251,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // Class dtors have no explicit args, so the params should\n         // just consist of the environment (self).\n         assert_eq!(params.len(), 1);\n-        let self_arg = if ty::type_is_fat_ptr(bcx.tcx(), self_ty) {\n+        let self_arg = if type_is_fat_ptr(bcx.tcx(), self_ty) {\n             // The dtor expects a fat pointer, so make one, even if we have to fake it.\n             let boxed_ty = ty::mk_open(bcx.tcx(), t);\n             let scratch = datum::rvalue_scratch_datum(bcx, boxed_ty, \"__fat_ptr_drop_self\");\n@@ -275,7 +275,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         for (i, ty) in st.fields.iter().enumerate().rev() {\n             let llfld_a = adt::struct_field_ptr(variant_cx, &*st, value, i, false);\n \n-            let val = if ty::type_is_sized(bcx.tcx(), *ty) {\n+            let val = if type_is_sized(bcx.tcx(), *ty) {\n                 llfld_a\n             } else {\n                 let boxed_ty = ty::mk_open(bcx.tcx(), *ty);\n@@ -303,7 +303,7 @@ fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info:\n                                      -> (ValueRef, ValueRef) {\n     debug!(\"calculate size of DST: {}; with lost info: {}\",\n            bcx.ty_to_string(t), bcx.val_to_string(info));\n-    if ty::type_is_sized(bcx.tcx(), t) {\n+    if type_is_sized(bcx.tcx(), t) {\n         let sizing_type = sizing_type_of(bcx.ccx(), t);\n         let size = C_uint(bcx.ccx(), llsize_of_alloc(bcx.ccx(), sizing_type));\n         let align = C_uint(bcx.ccx(), align_of(bcx.ccx(), t));\n@@ -383,7 +383,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                         bcx\n                     })\n                 }\n-                ty::ty_struct(..) if !ty::type_is_sized(bcx.tcx(), content_ty) => {\n+                ty::ty_struct(..) if !type_is_sized(bcx.tcx(), content_ty) => {\n                     let llval = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n                     let llbox = Load(bcx, llval);\n                     let not_null = IsNotNull(bcx, llbox);\n@@ -396,7 +396,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                     })\n                 }\n                 _ => {\n-                    assert!(ty::type_is_sized(bcx.tcx(), content_ty));\n+                    assert!(type_is_sized(bcx.tcx(), content_ty));\n                     let llval = v0;\n                     let llbox = Load(bcx, llval);\n                     let not_null = IsNotNull(bcx, llbox);\n@@ -415,7 +415,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                     // find the drop flag (which is at the end of the struct).\n                     // Lets just ignore the flag and pretend everything will be\n                     // OK.\n-                    if ty::type_is_sized(bcx.tcx(), t) {\n+                    if type_is_sized(bcx.tcx(), t) {\n                         trans_struct_drop_flag(bcx, t, v0, dtor, did, substs)\n                     } else {\n                         // Give the user a heads up that we are doing something\n@@ -468,7 +468,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n         }\n         ty::ty_vec(ty, None) => tvec::make_drop_glue_unboxed(bcx, v0, ty, false),\n         _ => {\n-            assert!(ty::type_is_sized(bcx.tcx(), t));\n+            assert!(type_is_sized(bcx.tcx(), t));\n             if type_needs_drop(bcx.tcx(), t) &&\n                 ty::type_is_structural(t) {\n                 iter_structural_ty(bcx, v0, t, |bb, vv, tt| drop_ty(bb, vv, tt, None))"}, {"sha": "6b0baa5d05e292c86547baddca2af8d8cd692898", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4946e1a46317a890b3e8d0157e045adf80b535d3/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4946e1a46317a890b3e8d0157e045adf80b535d3/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=4946e1a46317a890b3e8d0157e045adf80b535d3", "patch": "@@ -120,8 +120,8 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n                             \"s\"\n                         })[]);\n         }\n-        if ty::type_is_fat_ptr(ccx.tcx(), transmute_restriction.to) ||\n-           ty::type_is_fat_ptr(ccx.tcx(), transmute_restriction.from) {\n+        if type_is_fat_ptr(ccx.tcx(), transmute_restriction.to) ||\n+           type_is_fat_ptr(ccx.tcx(), transmute_restriction.from) {\n             ccx.sess()\n                .add_lint(::lint::builtin::FAT_PTR_TRANSMUTES,\n                          transmute_restriction.id,"}, {"sha": "aaec82bb1771d58e980fdc586d411368747b527c", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4946e1a46317a890b3e8d0157e045adf80b535d3/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4946e1a46317a890b3e8d0157e045adf80b535d3/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=4946e1a46317a890b3e8d0157e045adf80b535d3", "patch": "@@ -187,7 +187,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n     }\n \n     let llsizingty = match t.sty {\n-        _ if !ty::lltype_is_sized(cx.tcx(), t) => {\n+        _ if !lltype_is_sized(cx.tcx(), t) => {\n             cx.sess().bug(format!(\"trying to take the sizing type of {}, an unsized type\",\n                                   ppaux::ty_to_string(cx.tcx(), t))[])\n         }\n@@ -199,7 +199,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n         ty::ty_float(t) => Type::float_from_ty(cx, t),\n \n         ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) | ty::ty_ptr(ty::mt{ty, ..}) => {\n-            if ty::type_is_sized(cx.tcx(), ty) {\n+            if type_is_sized(cx.tcx(), ty) {\n                 Type::i8p(cx)\n             } else {\n                 Type::struct_(cx, &[Type::i8p(cx), Type::i8p(cx)], false)\n@@ -267,11 +267,11 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n         // struct which might be unsized, but is monomorphised to a sized type.\n         // In this case we'll fake a fat pointer with no unsize info (we use 0).\n         // However, its still a fat pointer, so we need some type use.\n-        if ty::type_is_sized(cx.tcx(), t) {\n+        if type_is_sized(cx.tcx(), t) {\n             return Type::i8p(cx);\n         }\n \n-        match ty::unsized_part_of_type(cx.tcx(), t).sty {\n+        match unsized_part_of_type(cx.tcx(), t).sty {\n             ty::ty_str | ty::ty_vec(..) => Type::uint_from_ty(cx, ast::TyU),\n             ty::ty_trait(_) => Type::vtable_ptr(cx),\n             _ => panic!(\"Unexpected type returned from unsized_part_of_type : {}\",\n@@ -342,7 +342,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n                   cx.tn().find_type(\"str_slice\").unwrap()\n               }\n               ty::ty_trait(..) => Type::opaque_trait(cx),\n-              _ if !ty::type_is_sized(cx.tcx(), ty) => {\n+              _ if !type_is_sized(cx.tcx(), ty) => {\n                   let p_ty = type_of(cx, ty).ptr_to();\n                   Type::struct_(cx, &[p_ty, type_of_unsize_info(cx, ty)], false)\n               }"}, {"sha": "dfa41c2707e8e3161bb5301d1eec81ea0d54de6a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4946e1a46317a890b3e8d0157e045adf80b535d3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4946e1a46317a890b3e8d0157e045adf80b535d3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4946e1a46317a890b3e8d0157e045adf80b535d3", "patch": "@@ -1356,7 +1356,7 @@ fn check_cast(fcx: &FnCtxt,\n         return\n     }\n \n-    if !ty::type_is_sized(fcx.tcx(), t_1) {\n+    if !fcx.type_is_known_to_be_sized(t_1) {\n         let tstr = fcx.infcx().ty_to_string(t_1);\n         fcx.type_error_message(span, |actual| {\n             format!(\"cast to unsized type: `{}` as `{}`\", actual, tstr)\n@@ -1545,10 +1545,14 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.ccx.tcx }\n \n-    pub fn infcx<'b>(&'b self) -> &'b infer::InferCtxt<'a, 'tcx> {\n+    pub fn infcx(&self) -> &infer::InferCtxt<'a, 'tcx> {\n         &self.inh.infcx\n     }\n \n+    pub fn param_env(&self) -> &ty::ParameterEnvironment<'tcx> {\n+        &self.inh.param_env\n+    }\n+\n     pub fn sess(&self) -> &Session {\n         &self.tcx().sess\n     }\n@@ -1792,6 +1796,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.require_type_is_sized(self.expr_ty(expr), expr.span, code);\n     }\n \n+    pub fn type_is_known_to_be_sized(&self,\n+                                     ty: Ty<'tcx>)\n+                                     -> bool\n+    {\n+        traits::type_known_to_meet_builtin_bound(self.infcx(),\n+                                                 self.param_env(),\n+                                                 ty,\n+                                                 ty::BoundSized)\n+    }\n+\n     pub fn register_builtin_bound(&self,\n                                   ty: Ty<'tcx>,\n                                   builtin_bound: ty::BuiltinBound,"}]}