{"sha": "6c534c316fd75f04b128116abdde46f4f036b306", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNTM0YzMxNmZkNzVmMDRiMTI4MTE2YWJkZGU0NmY0ZjAzNmIzMDY=", "commit": {"author": {"name": "Jason Shirk", "email": "jason@truewheels.net", "date": "2019-05-30T18:00:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-30T18:00:21Z"}, "message": "Merge branch 'master' into iwr_progress", "tree": {"sha": "aebe0d0465ce751b3ed4c876287cb5442c5d380b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aebe0d0465ce751b3ed4c876287cb5442c5d380b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c534c316fd75f04b128116abdde46f4f036b306", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc8Bo1CRBK7hj4Ov3rIwAAdHIIAKG28rmLN/plfvJ28J2fipDy\nK0+ELoxkBE9WUOXuGrejkjZj8zCpjfzT8s2354S0JKvyTBLDkPmP4jZ+1iPfizWZ\nb+fL+v/0bELPiSQ+yN0n6nv9rVqlfD9IQYxzzhE6EcdaBPWj/5lu2HAr7t8QStiP\nK74TCkt4VLRKLXLU4A0dgC/rNEsSogrMJs0Grf5oyOEKpF3alnNMVcdjF1hNqFby\n3dUzCJ+APLpj7Rnc8TY8TwMyKrVHys5sSbS/9aI4gcTyFwCQdLguXw9Cq36MOnvZ\n4nY1+qmN5PdOdt/R/j0tj754VVrmAU4zcDpJyDpds0qV/7fgvlUrgpRvZgDHHnA=\n=7BI5\n-----END PGP SIGNATURE-----\n", "payload": "tree aebe0d0465ce751b3ed4c876287cb5442c5d380b\nparent 642e8d4434c4f6214a908eea0019b3185323431f\nparent aee7012fab26d5e307a2fe767e4e7c847c5a45ee\nauthor Jason Shirk <jason@truewheels.net> 1559239221 -0700\ncommitter GitHub <noreply@github.com> 1559239221 -0700\n\nMerge branch 'master' into iwr_progress"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c534c316fd75f04b128116abdde46f4f036b306", "html_url": "https://github.com/rust-lang/rust/commit/6c534c316fd75f04b128116abdde46f4f036b306", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c534c316fd75f04b128116abdde46f4f036b306/comments", "author": {"login": "lzybkr", "id": 2148248, "node_id": "MDQ6VXNlcjIxNDgyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/2148248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lzybkr", "html_url": "https://github.com/lzybkr", "followers_url": "https://api.github.com/users/lzybkr/followers", "following_url": "https://api.github.com/users/lzybkr/following{/other_user}", "gists_url": "https://api.github.com/users/lzybkr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lzybkr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lzybkr/subscriptions", "organizations_url": "https://api.github.com/users/lzybkr/orgs", "repos_url": "https://api.github.com/users/lzybkr/repos", "events_url": "https://api.github.com/users/lzybkr/events{/privacy}", "received_events_url": "https://api.github.com/users/lzybkr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "642e8d4434c4f6214a908eea0019b3185323431f", "url": "https://api.github.com/repos/rust-lang/rust/commits/642e8d4434c4f6214a908eea0019b3185323431f", "html_url": "https://github.com/rust-lang/rust/commit/642e8d4434c4f6214a908eea0019b3185323431f"}, {"sha": "aee7012fab26d5e307a2fe767e4e7c847c5a45ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/aee7012fab26d5e307a2fe767e4e7c847c5a45ee", "html_url": "https://github.com/rust-lang/rust/commit/aee7012fab26d5e307a2fe767e4e7c847c5a45ee"}], "stats": {"total": 10055, "additions": 5480, "deletions": 4575}, "files": [{"sha": "c824c918280377aab0742a2627c6cb362b4f12e8", "filename": ".azure-pipelines/auto.yml", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/.azure-pipelines%2Fauto.yml", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/.azure-pipelines%2Fauto.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.azure-pipelines%2Fauto.yml?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -274,7 +274,7 @@ jobs:\n         MSYS_BITS: 32\n         RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n         SCRIPT: make ci-subset-1\n-        MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n+        MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n         MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n         MINGW_DIR: mingw32\n         # FIXME(#59637)\n@@ -284,14 +284,14 @@ jobs:\n         MSYS_BITS: 32\n         RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n         SCRIPT: make ci-subset-2\n-        MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n+        MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n         MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n         MINGW_DIR: mingw32\n       x86_64-mingw-1:\n         MSYS_BITS: 64\n         SCRIPT: make ci-subset-1\n         RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n-        MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n+        MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n         MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n         MINGW_DIR: mingw64\n         # FIXME(#59637)\n@@ -301,7 +301,7 @@ jobs:\n         MSYS_BITS: 64\n         SCRIPT: make ci-subset-2\n         RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n-        MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n+        MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n         MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n         MINGW_DIR: mingw64\n \n@@ -328,7 +328,7 @@ jobs:\n         MSYS_BITS: 32\n         RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu --enable-full-tools\n         SCRIPT: python x.py dist\n-        MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n+        MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n         MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n         MINGW_DIR: mingw32\n         DIST_REQUIRE_ALL_TOOLS: 1\n@@ -337,7 +337,7 @@ jobs:\n         MSYS_BITS: 64\n         SCRIPT: python x.py dist\n         RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu --enable-full-tools\n-        MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n+        MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n         MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n         MINGW_DIR: mingw64\n         DIST_REQUIRE_ALL_TOOLS: 1"}, {"sha": "0cd6f24e32c7cf186416366fa415724f1306100e", "filename": ".azure-pipelines/steps/install-clang.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/.azure-pipelines%2Fsteps%2Finstall-clang.yml", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/.azure-pipelines%2Fsteps%2Finstall-clang.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.azure-pipelines%2Fsteps%2Finstall-clang.yml?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -27,7 +27,7 @@ steps:\n # Original downloaded here came from\n # http://releases.llvm.org/7.0.0/LLVM-7.0.0-win64.exe\n - script: |\n-    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf %TEMP%\\LLVM-7.0.0-win64.exe https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/LLVM-7.0.0-win64.exe\"\n+    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf %TEMP%\\LLVM-7.0.0-win64.exe https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/LLVM-7.0.0-win64.exe\"\n     set CLANG_DIR=%CD%\\citools\\clang-rust\n     %TEMP%\\LLVM-7.0.0-win64.exe /S /NCRC /D=%CLANG_DIR%\n     set RUST_CONFIGURE_ARGS=%RUST_CONFIGURE_ARGS% --set llvm.clang-cl=%CLANG_DIR%\\bin\\clang-cl.exe"}, {"sha": "427e50f571f764197cfca484c0e93fd6da670808", "filename": ".azure-pipelines/steps/install-sccache.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/.azure-pipelines%2Fsteps%2Finstall-sccache.yml", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/.azure-pipelines%2Fsteps%2Finstall-sccache.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.azure-pipelines%2Fsteps%2Finstall-sccache.yml?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -2,14 +2,14 @@ steps:\n \n - bash: |\n     set -e\n-    curl -fo /usr/local/bin/sccache https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2018-04-02-sccache-x86_64-apple-darwin\n+    curl -fo /usr/local/bin/sccache https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2018-04-02-sccache-x86_64-apple-darwin\n     chmod +x /usr/local/bin/sccache\n   displayName: Install sccache (OSX)\n   condition: and(succeeded(), eq(variables['Agent.OS'], 'Darwin'))\n \n - script: |\n     md sccache\n-    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf sccache\\sccache.exe https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2018-04-26-sccache-x86_64-pc-windows-msvc\"\n+    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf sccache\\sccache.exe https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2018-04-26-sccache-x86_64-pc-windows-msvc\"\n     echo ##vso[task.prependpath]%CD%\\sccache\n   displayName: Install sccache (Windows)\n   condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))"}, {"sha": "04662a69c87477a16d807449512e62d3daba6ab0", "filename": ".azure-pipelines/steps/install-windows-build-deps.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/.azure-pipelines%2Fsteps%2Finstall-windows-build-deps.yml", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/.azure-pipelines%2Fsteps%2Finstall-windows-build-deps.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.azure-pipelines%2Fsteps%2Finstall-windows-build-deps.yml?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -81,7 +81,7 @@ steps:\n # Note that this is originally from the github releases patch of Ninja\n - script: |\n     md ninja\n-    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf 2017-03-15-ninja-win.zip https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-03-15-ninja-win.zip\"\n+    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf 2017-03-15-ninja-win.zip https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2017-03-15-ninja-win.zip\"\n     7z x -oninja 2017-03-15-ninja-win.zip\n     del 2017-03-15-ninja-win.zip\n     set RUST_CONFIGURE_ARGS=%RUST_CONFIGURE_ARGS% --enable-ninja"}, {"sha": "4bee0e0e2ad2f31d25d73115ff04efe537c7dc9e", "filename": "Cargo.lock", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -421,7 +421,7 @@ dependencies = [\n  \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"matches 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"pulldown-cmark 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"pulldown-cmark 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quine-mc_cluskey 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex-syntax 0.6.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -860,7 +860,7 @@ dependencies = [\n  \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syn 0.15.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"synstructure 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"synstructure 0.10.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -2014,23 +2014,13 @@ dependencies = [\n \n [[package]]\n name = \"pulldown-cmark\"\n-version = \"0.4.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"memchr 2.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unicase 2.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"pulldown-cmark\"\n-version = \"0.5.0\"\n+version = \"0.5.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"memchr 2.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unicase 2.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicase 2.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -2875,7 +2865,7 @@ dependencies = [\n  \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syn 0.15.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"synstructure 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"synstructure 0.10.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -3077,7 +3067,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"minifier 0.0.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"pulldown-cmark 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"pulldown-cmark 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -3428,7 +3418,7 @@ dependencies = [\n \n [[package]]\n name = \"synstructure\"\n-version = \"0.10.1\"\n+version = \"0.10.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3854,7 +3844,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"unicase\"\n-version = \"2.3.0\"\n+version = \"2.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"version_check 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -4285,8 +4275,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"77619697826f31a02ae974457af0b29b723e5619e113e9397b8b82c6bd253f09\"\n \"checksum proptest 0.9.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"24f5844db2f839e97e3021980975f6ebf8691d9b9b2ca67ed3feb38dc3edb52c\"\n \"checksum pulldown-cmark 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d6fdf85cda6cadfae5428a54661d431330b312bc767ddbc57adbedc24da66e32\"\n-\"checksum pulldown-cmark 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d1b74cc784b038a9921fd1a48310cc2e238101aa8ae0b94201e2d85121dd68b5\"\n-\"checksum pulldown-cmark 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"157737d41407de9c5e0563a991d085117d60ae729af2cc1bf28d6dfbc97bcc1f\"\n+\"checksum pulldown-cmark 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"051e60ace841b3bfecd402fe5051c06cb3bec4a6e6fdd060a37aa8eb829a1db3\"\n \"checksum quick-error 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9274b940887ce9addde99c4eee6b5c44cc494b182b97e73dc8ffdcb3397fd3f0\"\n \"checksum quine-mc_cluskey 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"07589615d719a60c8dd8a4622e7946465dfef20d1a428f969e3443e7386d5f45\"\n \"checksum quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6e920b65c65f10b2ae65c831a81a073a89edd28c7cce89475bff467ab4167a\"\n@@ -4367,7 +4356,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d3b891b9015c88c576343b9b3e41c2c11a51c219ef067b264bd9c8aa9b441dad\"\n \"checksum syn 0.15.22 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ae8b29eb5210bc5cf63ed6149cbf9adfc82ac0be023d8735c176ee74a2db4da7\"\n \"checksum synom 0.11.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a393066ed9010ebaed60b9eafa373d4b1baac186dd7e008555b0f702b51945b6\"\n-\"checksum synstructure 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"73687139bf99285483c96ac0add482c3776528beac1d97d444f6e91f203a2015\"\n+\"checksum synstructure 0.10.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"02353edf96d6e4dc81aea2d8490a7e9db177bf8acb0e951c24940bf866cb313f\"\n \"checksum tar 0.4.20 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a303ba60a099fcd2aaa646b14d2724591a96a75283e4b7ed3d1a1658909d9ae2\"\n \"checksum tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7e91405c14320e5c79b3d148e1c86f40749a36e490642202a31689cb1a3452b2\"\n \"checksum tendril 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9de21546595a0873061940d994bbbc5c35f024ae4fd61ec5c5b159115684f508\"\n@@ -4400,7 +4389,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum typenum 1.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"612d636f949607bdf9b123b4a6f6d966dedf3ff669f7f045890d3a4a73948169\"\n \"checksum ucd-trie 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"71a9c5b1fe77426cf144cc30e49e955270f5086e31a6441dfa8b32efc09b9d77\"\n \"checksum ucd-util 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"535c204ee4d8434478593480b8f86ab45ec9aae0e83c568ca81abf0fd0e88f86\"\n-\"checksum unicase 2.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"41d17211f887da8e4a70a45b9536f26fc5de166b81e2d5d80de4a17fd22553bd\"\n+\"checksum unicase 2.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a84e5511b2a947f3ae965dcb29b13b7b1691b6e7332cf5dbc1744138d5acb7f6\"\n \"checksum unicode-bidi 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"49f2bd0c6468a8230e1db229cff8029217cf623c767ea5d60bfbd42729ea54d5\"\n \"checksum unicode-normalization 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6a0180bc61fc5a987082bfa111f4cc95c4caff7f9799f3e46df09163a937aa25\"\n \"checksum unicode-segmentation 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aa6024fc12ddfd1c6dbc14a80fa2324d4568849869b779f6bd37e5e4c03344d1\""}, {"sha": "cd9011730aafb679f9b07b5ef390919fd15f9b0f", "filename": "appveyor.yml", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -59,7 +59,7 @@ environment:\n     MSYS_BITS: 32\n     RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n     SCRIPT: make ci-subset-1\n-    MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n+    MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n     MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n     MINGW_DIR: mingw32\n     # FIXME(#59637)\n@@ -69,14 +69,14 @@ environment:\n     MSYS_BITS: 32\n     RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n     SCRIPT: make ci-subset-2\n-    MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n+    MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n     MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n     MINGW_DIR: mingw32\n   - CI_JOB_NAME: x86_64-mingw\n     MSYS_BITS: 64\n     SCRIPT: python x.py test\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n-    MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n+    MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n     MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n     MINGW_DIR: mingw64\n     # FIXME(#59637)\n@@ -106,7 +106,7 @@ environment:\n     MSYS_BITS: 32\n     RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu --enable-full-tools --enable-profiler\n     SCRIPT: python x.py dist\n-    MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n+    MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n     MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n     MINGW_DIR: mingw32\n     DIST_REQUIRE_ALL_TOOLS: 1\n@@ -115,7 +115,7 @@ environment:\n     MSYS_BITS: 64\n     SCRIPT: python x.py dist\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu --enable-full-tools --enable-profiler\n-    MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n+    MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n     MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n     MINGW_DIR: mingw64\n     DIST_REQUIRE_ALL_TOOLS: 1\n@@ -159,7 +159,7 @@ install:\n   #\n   # Original downloaded here came from\n   # http://releases.llvm.org/8.0.0/LLVM-8.0.0-win64.exe\n-  - if NOT defined MINGW_URL appveyor-retry appveyor DownloadFile https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/LLVM-8.0.0-win64.exe\n+  - if NOT defined MINGW_URL appveyor-retry appveyor DownloadFile https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/LLVM-8.0.0-win64.exe\n   - if NOT defined MINGW_URL .\\LLVM-8.0.0-win64.exe /S /NCRC /D=C:\\clang-rust\n   - if NOT defined MINGW_URL set RUST_CONFIGURE_ARGS=%RUST_CONFIGURE_ARGS% --set llvm.clang-cl=C:\\clang-rust\\bin\\clang-cl.exe\n \n@@ -191,25 +191,25 @@ install:\n   - set PATH=C:\\Python27;%PATH%\n \n   # Download and install sccache\n-  - appveyor-retry appveyor DownloadFile https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2018-04-26-sccache-x86_64-pc-windows-msvc\n+  - appveyor-retry appveyor DownloadFile https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2018-04-26-sccache-x86_64-pc-windows-msvc\n   - mv 2018-04-26-sccache-x86_64-pc-windows-msvc sccache.exe\n   - set PATH=%PATH%;%CD%\n \n   # Download and install ninja\n   #\n   # Note that this is originally from the github releases patch of Ninja\n-  - appveyor-retry appveyor DownloadFile https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-03-15-ninja-win.zip\n+  - appveyor-retry appveyor DownloadFile https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2017-03-15-ninja-win.zip\n   - 7z x 2017-03-15-ninja-win.zip\n   - set RUST_CONFIGURE_ARGS=%RUST_CONFIGURE_ARGS% --enable-ninja\n   # - set PATH=%PATH%;%CD% -- this already happens above for sccache\n \n   # Install InnoSetup to get `iscc` used to produce installers\n-  - appveyor-retry appveyor DownloadFile https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-08-22-is.exe\n+  - appveyor-retry appveyor DownloadFile https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2017-08-22-is.exe\n   - 2017-08-22-is.exe /VERYSILENT /SUPPRESSMSGBOXES /NORESTART /SP-\n   - set PATH=\"C:\\Program Files (x86)\\Inno Setup 5\";%PATH%\n \n   # Help debug some handle issues on AppVeyor\n-  - appveyor-retry appveyor DownloadFile https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-05-15-Handle.zip\n+  - appveyor-retry appveyor DownloadFile https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2017-05-15-Handle.zip\n   - mkdir handle\n   - 7z x -ohandle 2017-05-15-Handle.zip\n   - set PATH=%PATH%;%CD%\\handle"}, {"sha": "1d3b4fe33c8119b40cea14d1ba1c9cee96331311", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 82, "deletions": 51, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -581,6 +581,30 @@ impl<'a> Builder<'a> {\n         })\n     }\n \n+    /// Similar to `compiler`, except handles the full-bootstrap option to\n+    /// silently use the stage1 compiler instead of a stage2 compiler if one is\n+    /// requested.\n+    ///\n+    /// Note that this does *not* have the side effect of creating\n+    /// `compiler(stage, host)`, unlike `compiler` above which does have such\n+    /// a side effect. The returned compiler here can only be used to compile\n+    /// new artifacts, it can't be used to rely on the presence of a particular\n+    /// sysroot.\n+    ///\n+    /// See `force_use_stage1` for documentation on what each argument is.\n+    pub fn compiler_for(\n+        &self,\n+        stage: u32,\n+        host: Interned<String>,\n+        target: Interned<String>,\n+    ) -> Compiler {\n+        if self.build.force_use_stage1(Compiler { stage, host }, target) {\n+            self.compiler(1, self.config.build)\n+        } else {\n+            self.compiler(stage, host)\n+        }\n+    }\n+\n     pub fn sysroot(&self, compiler: Compiler) -> Interned<PathBuf> {\n         self.ensure(compile::Sysroot { compiler })\n     }\n@@ -754,11 +778,7 @@ impl<'a> Builder<'a> {\n         // This is for the original compiler, but if we're forced to use stage 1, then\n         // std/test/rustc stamps won't exist in stage 2, so we need to get those from stage 1, since\n         // we copy the libs forward.\n-        let cmp = if self.force_use_stage1(compiler, target) {\n-            self.compiler(1, compiler.host)\n-        } else {\n-            compiler\n-        };\n+        let cmp = self.compiler_for(compiler.stage, compiler.host, target);\n \n         let libstd_stamp = match cmd {\n             \"check\" | \"clippy\" | \"fix\" => check::libstd_stamp(self, cmp, target),\n@@ -1358,7 +1378,7 @@ mod __test {\n \n         assert_eq!(\n             first(builder.cache.all::<dist::Docs>()),\n-            &[dist::Docs { stage: 2, host: a },]\n+            &[dist::Docs { host: a },]\n         );\n         assert_eq!(\n             first(builder.cache.all::<dist::Mingw>()),\n@@ -1373,7 +1393,7 @@ mod __test {\n         assert_eq!(\n             first(builder.cache.all::<dist::Std>()),\n             &[dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n+                compiler: Compiler { host: a, stage: 1 },\n                 target: a,\n             },]\n         );\n@@ -1392,8 +1412,8 @@ mod __test {\n         assert_eq!(\n             first(builder.cache.all::<dist::Docs>()),\n             &[\n-                dist::Docs { stage: 2, host: a },\n-                dist::Docs { stage: 2, host: b },\n+                dist::Docs { host: a },\n+                dist::Docs { host: b },\n             ]\n         );\n         assert_eq!(\n@@ -1410,7 +1430,7 @@ mod __test {\n             first(builder.cache.all::<dist::Std>()),\n             &[\n                 dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n+                    compiler: Compiler { host: a, stage: 1 },\n                     target: a,\n                 },\n                 dist::Std {\n@@ -1434,8 +1454,8 @@ mod __test {\n         assert_eq!(\n             first(builder.cache.all::<dist::Docs>()),\n             &[\n-                dist::Docs { stage: 2, host: a },\n-                dist::Docs { stage: 2, host: b },\n+                dist::Docs { host: a },\n+                dist::Docs { host: b },\n             ]\n         );\n         assert_eq!(\n@@ -1457,18 +1477,52 @@ mod __test {\n             first(builder.cache.all::<dist::Std>()),\n             &[\n                 dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n+                    compiler: Compiler { host: a, stage: 1 },\n                     target: a,\n                 },\n                 dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n+                    compiler: Compiler { host: a, stage: 1 },\n                     target: b,\n                 },\n             ]\n         );\n         assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n     }\n \n+    #[test]\n+    fn dist_only_cross_host() {\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+        let mut build = Build::new(configure(&[\"B\"], &[]));\n+        build.config.docs = false;\n+        build.config.extended = true;\n+        build.hosts = vec![b];\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[\n+                dist::Rustc {\n+                    compiler: Compiler { host: b, stage: 2 }\n+                },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Rustc>()),\n+            &[\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: a,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: b,\n+                },\n+            ]\n+        );\n+    }\n+\n     #[test]\n     fn dist_with_targets_and_hosts() {\n         let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n@@ -1482,9 +1536,9 @@ mod __test {\n         assert_eq!(\n             first(builder.cache.all::<dist::Docs>()),\n             &[\n-                dist::Docs { stage: 2, host: a },\n-                dist::Docs { stage: 2, host: b },\n-                dist::Docs { stage: 2, host: c },\n+                dist::Docs { host: a },\n+                dist::Docs { host: b },\n+                dist::Docs { host: c },\n             ]\n         );\n         assert_eq!(\n@@ -1510,11 +1564,11 @@ mod __test {\n             first(builder.cache.all::<dist::Std>()),\n             &[\n                 dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n+                    compiler: Compiler { host: a, stage: 1 },\n                     target: a,\n                 },\n                 dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n+                    compiler: Compiler { host: a, stage: 1 },\n                     target: b,\n                 },\n                 dist::Std {\n@@ -1541,9 +1595,9 @@ mod __test {\n         assert_eq!(\n             first(builder.cache.all::<dist::Docs>()),\n             &[\n-                dist::Docs { stage: 2, host: a },\n-                dist::Docs { stage: 2, host: b },\n-                dist::Docs { stage: 2, host: c },\n+                dist::Docs { host: a },\n+                dist::Docs { host: b },\n+                dist::Docs { host: c },\n             ]\n         );\n         assert_eq!(\n@@ -1559,11 +1613,11 @@ mod __test {\n             first(builder.cache.all::<dist::Std>()),\n             &[\n                 dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n+                    compiler: Compiler { host: a, stage: 1 },\n                     target: a,\n                 },\n                 dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n+                    compiler: Compiler { host: a, stage: 1 },\n                     target: b,\n                 },\n                 dist::Std {\n@@ -1587,8 +1641,8 @@ mod __test {\n         assert_eq!(\n             first(builder.cache.all::<dist::Docs>()),\n             &[\n-                dist::Docs { stage: 2, host: a },\n-                dist::Docs { stage: 2, host: b },\n+                dist::Docs { host: a },\n+                dist::Docs { host: b },\n             ]\n         );\n         assert_eq!(\n@@ -1610,11 +1664,11 @@ mod __test {\n             first(builder.cache.all::<dist::Std>()),\n             &[\n                 dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n+                    compiler: Compiler { host: a, stage: 1 },\n                     target: a,\n                 },\n                 dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n+                    compiler: Compiler { host: a, stage: 1 },\n                     target: b,\n                 },\n             ]\n@@ -1664,10 +1718,6 @@ mod __test {\n                     compiler: Compiler { host: a, stage: 1 },\n                     target: b,\n                 },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n             ]\n         );\n         assert_eq!(\n@@ -1720,10 +1770,6 @@ mod __test {\n                     compiler: Compiler { host: b, stage: 2 },\n                     target: a,\n                 },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: b,\n-                },\n                 compile::Rustc {\n                     compiler: Compiler { host: a, stage: 1 },\n                     target: b,\n@@ -1758,10 +1804,6 @@ mod __test {\n                     compiler: Compiler { host: b, stage: 2 },\n                     target: a,\n                 },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: b,\n-                },\n                 compile::Test {\n                     compiler: Compiler { host: a, stage: 1 },\n                     target: b,\n@@ -1808,9 +1850,6 @@ mod __test {\n                 compile::Assemble {\n                     target_compiler: Compiler { host: a, stage: 1 },\n                 },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: b, stage: 1 },\n-                },\n                 compile::Assemble {\n                     target_compiler: Compiler { host: a, stage: 2 },\n                 },\n@@ -1830,10 +1869,6 @@ mod __test {\n                     compiler: Compiler { host: a, stage: 1 },\n                     target: a,\n                 },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: b,\n-                },\n                 compile::Rustc {\n                     compiler: Compiler { host: a, stage: 1 },\n                     target: b,\n@@ -1860,10 +1895,6 @@ mod __test {\n                     compiler: Compiler { host: b, stage: 2 },\n                     target: a,\n                 },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: b,\n-                },\n                 compile::Test {\n                     compiler: Compiler { host: a, stage: 1 },\n                     target: b,"}, {"sha": "4515c7d672d8a5652f0949bcd76e2c78141d401d", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -70,20 +70,20 @@ impl Step for Std {\n \n         builder.ensure(StartupObjects { compiler, target });\n \n-        if builder.force_use_stage1(compiler, target) {\n-            let from = builder.compiler(1, builder.config.build);\n+        let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n+        if compiler_to_use != compiler {\n             builder.ensure(Std {\n-                compiler: from,\n+                compiler: compiler_to_use,\n                 target,\n             });\n-            builder.info(&format!(\"Uplifting stage1 std ({} -> {})\", from.host, target));\n+            builder.info(&format!(\"Uplifting stage1 std ({} -> {})\", compiler_to_use.host, target));\n \n             // Even if we're not building std this stage, the new sysroot must\n             // still contain the third party objects needed by various targets.\n             copy_third_party_objects(builder, &compiler, target);\n \n             builder.ensure(StdLink {\n-                compiler: from,\n+                compiler: compiler_to_use,\n                 target_compiler: compiler,\n                 target,\n             });\n@@ -403,15 +403,16 @@ impl Step for Test {\n             return;\n         }\n \n-        if builder.force_use_stage1(compiler, target) {\n+        let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n+        if compiler_to_use != compiler {\n             builder.ensure(Test {\n-                compiler: builder.compiler(1, builder.config.build),\n+                compiler: compiler_to_use,\n                 target,\n             });\n             builder.info(\n                 &format!(\"Uplifting stage1 test ({} -> {})\", builder.config.build, target));\n             builder.ensure(TestLink {\n-                compiler: builder.compiler(1, builder.config.build),\n+                compiler: compiler_to_use,\n                 target_compiler: compiler,\n                 target,\n             });\n@@ -529,15 +530,16 @@ impl Step for Rustc {\n             return;\n         }\n \n-        if builder.force_use_stage1(compiler, target) {\n+        let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n+        if compiler_to_use != compiler {\n             builder.ensure(Rustc {\n-                compiler: builder.compiler(1, builder.config.build),\n+                compiler: compiler_to_use,\n                 target,\n             });\n             builder.info(&format!(\"Uplifting stage1 rustc ({} -> {})\",\n                 builder.config.build, target));\n             builder.ensure(RustcLink {\n-                compiler: builder.compiler(1, builder.config.build),\n+                compiler: compiler_to_use,\n                 target_compiler: compiler,\n                 target,\n             });\n@@ -687,9 +689,10 @@ impl Step for CodegenBackend {\n             return;\n         }\n \n-        if builder.force_use_stage1(compiler, target) {\n+        let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n+        if compiler_to_use != compiler {\n             builder.ensure(CodegenBackend {\n-                compiler: builder.compiler(1, builder.config.build),\n+                compiler: compiler_to_use,\n                 target,\n                 backend,\n             });"}, {"sha": "274961916183afff56f22f5a704553dcb770fa49", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 88, "deletions": 71, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -68,7 +68,6 @@ fn missing_tool(tool_name: &str, skip: bool) {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Docs {\n-    pub stage: u32,\n     pub host: Interned<String>,\n }\n \n@@ -82,7 +81,6 @@ impl Step for Docs {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Docs {\n-            stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n@@ -130,7 +128,6 @@ impl Step for Docs {\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct RustcDocs {\n-    pub stage: u32,\n     pub host: Interned<String>,\n }\n \n@@ -144,7 +141,6 @@ impl Step for RustcDocs {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(RustcDocs {\n-            stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n@@ -647,7 +643,11 @@ impl Step for Std {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Std {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n@@ -737,7 +737,14 @@ impl Step for Analysis {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Analysis {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n+            // Find the actual compiler (handling the full bootstrap option) which\n+            // produced the save-analysis data because that data isn't copied\n+            // through the sysroot uplifting.\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n@@ -757,14 +764,6 @@ impl Step for Analysis {\n \n         builder.ensure(Std { compiler, target });\n \n-        // Package save-analysis from stage1 if not doing a full bootstrap, as the\n-        // stage2 artifacts is simply copied from stage1 in that case.\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler.clone()\n-        };\n-\n         let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, target));\n \n         let src = builder.stage_out(compiler, Mode::Std)\n@@ -1066,7 +1065,7 @@ pub fn sanitize_sh(path: &Path) -> String {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Cargo {\n-    pub stage: u32,\n+    pub compiler: Compiler,\n     pub target: Interned<String>,\n }\n \n@@ -1080,16 +1079,20 @@ impl Step for Cargo {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Cargo {\n-            stage: run.builder.top_stage,\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n-        let stage = self.stage;\n+        let compiler = self.compiler;\n         let target = self.target;\n \n-        builder.info(&format!(\"Dist cargo stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist cargo stage{} ({})\", compiler.stage, target));\n         let src = builder.src.join(\"src/tools/cargo\");\n         let etc = src.join(\"src/etc\");\n         let release_num = builder.release_num(\"cargo\");\n@@ -1104,10 +1107,7 @@ impl Step for Cargo {\n         // Prepare the image directory\n         builder.create_dir(&image.join(\"share/zsh/site-functions\"));\n         builder.create_dir(&image.join(\"etc/bash_completion.d\"));\n-        let cargo = builder.ensure(tool::Cargo {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target\n-        });\n+        let cargo = builder.ensure(tool::Cargo { compiler, target });\n         builder.install(&cargo, &image.join(\"bin\"), 0o755);\n         for man in t!(etc.join(\"man\").read_dir()) {\n             let man = t!(man);\n@@ -1152,7 +1152,7 @@ impl Step for Cargo {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rls {\n-    pub stage: u32,\n+    pub compiler: Compiler,\n     pub target: Interned<String>,\n }\n \n@@ -1166,17 +1166,21 @@ impl Step for Rls {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rls {\n-            stage: run.builder.top_stage,\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n-        let stage = self.stage;\n+        let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n \n-        builder.info(&format!(\"Dist RLS stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist RLS stage{} ({})\", compiler.stage, target));\n         let src = builder.src.join(\"src/tools/rls\");\n         let release_num = builder.release_num(\"rls\");\n         let name = pkgname(builder, \"rls\");\n@@ -1191,8 +1195,9 @@ impl Step for Rls {\n         // We expect RLS to build, because we've exited this step above if tool\n         // state for RLS isn't testing.\n         let rls = builder.ensure(tool::Rls {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target, extra_features: Vec::new()\n+            compiler,\n+            target,\n+            extra_features: Vec::new(),\n         }).or_else(|| { missing_tool(\"RLS\", builder.build.config.missing_tools); None })?;\n \n         builder.install(&rls, &image.join(\"bin\"), 0o755);\n@@ -1231,7 +1236,7 @@ impl Step for Rls {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Clippy {\n-    pub stage: u32,\n+    pub compiler: Compiler,\n     pub target: Interned<String>,\n }\n \n@@ -1245,17 +1250,21 @@ impl Step for Clippy {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Clippy {\n-            stage: run.builder.top_stage,\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n-        let stage = self.stage;\n+        let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n \n-        builder.info(&format!(\"Dist clippy stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist clippy stage{} ({})\", compiler.stage, target));\n         let src = builder.src.join(\"src/tools/clippy\");\n         let release_num = builder.release_num(\"clippy\");\n         let name = pkgname(builder, \"clippy\");\n@@ -1270,11 +1279,12 @@ impl Step for Clippy {\n         // We expect clippy to build, because we've exited this step above if tool\n         // state for clippy isn't testing.\n         let clippy = builder.ensure(tool::Clippy {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target, extra_features: Vec::new()\n+            compiler,\n+            target,\n+            extra_features: Vec::new(),\n         }).or_else(|| { missing_tool(\"clippy\", builder.build.config.missing_tools); None })?;\n         let cargoclippy = builder.ensure(tool::CargoClippy {\n-            compiler: builder.compiler(stage, builder.config.build),\n+            compiler,\n             target, extra_features: Vec::new()\n         }).or_else(|| { missing_tool(\"cargo clippy\", builder.build.config.missing_tools); None })?;\n \n@@ -1315,7 +1325,7 @@ impl Step for Clippy {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Miri {\n-    pub stage: u32,\n+    pub compiler: Compiler,\n     pub target: Interned<String>,\n }\n \n@@ -1329,17 +1339,21 @@ impl Step for Miri {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Miri {\n-            stage: run.builder.top_stage,\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n-        let stage = self.stage;\n+        let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n \n-        builder.info(&format!(\"Dist miri stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist miri stage{} ({})\", compiler.stage, target));\n         let src = builder.src.join(\"src/tools/miri\");\n         let release_num = builder.release_num(\"miri\");\n         let name = pkgname(builder, \"miri\");\n@@ -1354,12 +1368,14 @@ impl Step for Miri {\n         // We expect miri to build, because we've exited this step above if tool\n         // state for miri isn't testing.\n         let miri = builder.ensure(tool::Miri {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target, extra_features: Vec::new()\n+            compiler,\n+            target,\n+            extra_features: Vec::new(),\n         }).or_else(|| { missing_tool(\"miri\", builder.build.config.missing_tools); None })?;\n         let cargomiri = builder.ensure(tool::CargoMiri {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target, extra_features: Vec::new()\n+            compiler,\n+            target,\n+            extra_features: Vec::new()\n         }).or_else(|| { missing_tool(\"cargo miri\", builder.build.config.missing_tools); None })?;\n \n         builder.install(&miri, &image.join(\"bin\"), 0o755);\n@@ -1399,7 +1415,7 @@ impl Step for Miri {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustfmt {\n-    pub stage: u32,\n+    pub compiler: Compiler,\n     pub target: Interned<String>,\n }\n \n@@ -1413,16 +1429,20 @@ impl Step for Rustfmt {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rustfmt {\n-            stage: run.builder.top_stage,\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n-        let stage = self.stage;\n+        let compiler = self.compiler;\n         let target = self.target;\n \n-        builder.info(&format!(\"Dist Rustfmt stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist Rustfmt stage{} ({})\", compiler.stage, target));\n         let src = builder.src.join(\"src/tools/rustfmt\");\n         let release_num = builder.release_num(\"rustfmt\");\n         let name = pkgname(builder, \"rustfmt\");\n@@ -1435,12 +1455,14 @@ impl Step for Rustfmt {\n \n         // Prepare the image directory\n         let rustfmt = builder.ensure(tool::Rustfmt {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target, extra_features: Vec::new()\n+            compiler,\n+            target,\n+            extra_features: Vec::new(),\n         }).or_else(|| { missing_tool(\"Rustfmt\", builder.build.config.missing_tools); None })?;\n         let cargofmt = builder.ensure(tool::Cargofmt {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target, extra_features: Vec::new()\n+            compiler,\n+            target,\n+            extra_features: Vec::new(),\n         }).or_else(|| { missing_tool(\"Cargofmt\", builder.build.config.missing_tools); None })?;\n \n         builder.install(&rustfmt, &image.join(\"bin\"), 0o755);\n@@ -1505,30 +1527,28 @@ impl Step for Extended {\n \n     /// Creates a combined installer for the specified target in the provided stage.\n     fn run(self, builder: &Builder<'_>) {\n-        let stage = self.stage;\n         let target = self.target;\n+        let stage = self.stage;\n+        let compiler = builder.compiler_for(self.stage, self.host, self.target);\n \n-        builder.info(&format!(\"Dist extended stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist extended stage{} ({})\", compiler.stage, target));\n \n         let rustc_installer = builder.ensure(Rustc {\n             compiler: builder.compiler(stage, target),\n         });\n-        let cargo_installer = builder.ensure(Cargo { stage, target });\n-        let rustfmt_installer = builder.ensure(Rustfmt { stage, target });\n-        let rls_installer = builder.ensure(Rls { stage, target });\n-        let llvm_tools_installer = builder.ensure(LlvmTools { stage, target });\n-        let clippy_installer = builder.ensure(Clippy { stage, target });\n-        let miri_installer = builder.ensure(Miri { stage, target });\n+        let cargo_installer = builder.ensure(Cargo { compiler, target });\n+        let rustfmt_installer = builder.ensure(Rustfmt { compiler, target });\n+        let rls_installer = builder.ensure(Rls { compiler, target });\n+        let llvm_tools_installer = builder.ensure(LlvmTools { target });\n+        let clippy_installer = builder.ensure(Clippy { compiler, target });\n+        let miri_installer = builder.ensure(Miri { compiler, target });\n         let lldb_installer = builder.ensure(Lldb { target });\n         let mingw_installer = builder.ensure(Mingw { host: target });\n-        let analysis_installer = builder.ensure(Analysis {\n-            compiler: builder.compiler(stage, self.host),\n-            target\n-        });\n+        let analysis_installer = builder.ensure(Analysis { compiler, target });\n \n-        let docs_installer = builder.ensure(Docs { stage, host: target, });\n+        let docs_installer = builder.ensure(Docs { host: target, });\n         let std_installer = builder.ensure(Std {\n-            compiler: builder.compiler(stage, self.host),\n+            compiler: builder.compiler(stage, target),\n             target,\n         });\n \n@@ -2076,7 +2096,6 @@ pub fn maybe_install_llvm_dylib(builder: &Builder<'_>,\n \n #[derive(Clone, Debug, Eq, Hash, PartialEq)]\n pub struct LlvmTools {\n-    pub stage: u32,\n     pub target: Interned<String>,\n }\n \n@@ -2090,26 +2109,24 @@ impl Step for LlvmTools {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(LlvmTools {\n-            stage: run.builder.top_stage,\n             target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n-        let stage = self.stage;\n         let target = self.target;\n         assert!(builder.config.extended);\n \n         /* run only if llvm-config isn't used */\n         if let Some(config) = builder.config.target_config.get(&target) {\n             if let Some(ref _s) = config.llvm_config {\n-                builder.info(&format!(\"Skipping LlvmTools stage{} ({}): external LLVM\",\n-                    stage, target));\n+                builder.info(&format!(\"Skipping LlvmTools ({}): external LLVM\",\n+                    target));\n                 return None;\n             }\n         }\n \n-        builder.info(&format!(\"Dist LlvmTools stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist LlvmTools ({})\", target));\n         let src = builder.src.join(\"src/llvm-project/llvm\");\n         let name = pkgname(builder, \"llvm-tools\");\n "}, {"sha": "12bdfa5691dc744a7479a6074d6d546ccb3965b0", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 6, "deletions": 31, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -475,12 +475,7 @@ impl Step for Std {\n         builder.info(&format!(\"Documenting stage{} std ({})\", stage, target));\n         let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler(stage, builder.config.build);\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler\n-        };\n+        let compiler = builder.compiler_for(stage, builder.config.build, target);\n \n         builder.ensure(compile::Std { compiler, target });\n         let out_dir = builder.stage_out(compiler, Mode::Std)\n@@ -563,12 +558,7 @@ impl Step for Test {\n         builder.info(&format!(\"Documenting stage{} test ({})\", stage, target));\n         let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler(stage, builder.config.build);\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler\n-        };\n+        let compiler = builder.compiler_for(stage, builder.config.build, target);\n \n         // Build libstd docs so that we generate relative links\n         builder.ensure(Std { stage, target });\n@@ -632,12 +622,7 @@ impl Step for WhitelistedRustc {\n         builder.info(&format!(\"Documenting stage{} whitelisted compiler ({})\", stage, target));\n         let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler(stage, builder.config.build);\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler\n-        };\n+        let compiler = builder.compiler_for(stage, builder.config.build, target);\n \n         // Build libstd docs so that we generate relative links\n         builder.ensure(Std { stage, target });\n@@ -706,12 +691,7 @@ impl Step for Rustc {\n         t!(fs::create_dir_all(&out));\n \n         // Get the correct compiler for this stage.\n-        let compiler = builder.compiler(stage, builder.config.build);\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler\n-        };\n+        let compiler = builder.compiler_for(stage, builder.config.build, target);\n \n         if !builder.config.compiler_docs {\n             builder.info(\"\\tskipping - compiler/librustdoc docs disabled\");\n@@ -728,7 +708,7 @@ impl Step for Rustc {\n \n         // Build cargo command.\n         let mut cargo = builder.cargo(compiler, Mode::Rustc, target, \"doc\");\n-        cargo.env(\"RUSTDOCFLAGS\", \"--document-private-items\");\n+        cargo.env(\"RUSTDOCFLAGS\", \"--document-private-items --passes strip-hidden\");\n         compile::rustc_cargo(builder, &mut cargo);\n \n         // Only include compiler crates, no dependencies of those, such as `libc`.\n@@ -807,12 +787,7 @@ impl Step for Rustdoc {\n         t!(fs::create_dir_all(&out));\n \n         // Get the correct compiler for this stage.\n-        let compiler = builder.compiler(stage, builder.config.build);\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler\n-        };\n+        let compiler = builder.compiler_for(stage, builder.config.build, target);\n \n         if !builder.config.compiler_docs {\n             builder.info(\"\\tskipping - compiler/librustdoc docs disabled\");"}, {"sha": "0047be4d5951b95a4fbc77bcdac5e6f902f1827b", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 42, "deletions": 35, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -5,12 +5,13 @@\n \n use std::env;\n use std::fs;\n-use std::path::{Path, PathBuf, Component};\n+use std::path::{Component, Path, PathBuf};\n use std::process::Command;\n \n use build_helper::t;\n \n use crate::dist::{self, pkgname, sanitize_sh, tmpdir};\n+use crate::Compiler;\n \n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::cache::Interned;\n@@ -58,7 +59,7 @@ fn install_sh(\n     package: &str,\n     name: &str,\n     stage: u32,\n-    host: Option<Interned<String>>\n+    host: Option<Interned<String>>,\n ) {\n     builder.info(&format!(\"Install {} stage{} ({:?})\", package, stage, host));\n \n@@ -144,9 +145,8 @@ macro_rules! install {\n         $(\n             #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n         pub struct $name {\n-            pub stage: u32,\n+            pub compiler: Compiler,\n             pub target: Interned<String>,\n-            pub host: Interned<String>,\n         }\n \n         impl $name {\n@@ -175,9 +175,8 @@ macro_rules! install {\n \n             fn make_run(run: RunConfig<'_>) {\n                 run.builder.ensure($name {\n-                    stage: run.builder.top_stage,\n+                    compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n                     target: run.target,\n-                    host: run.builder.config.build,\n                 });\n             }\n \n@@ -190,67 +189,78 @@ macro_rules! install {\n \n install!((self, builder, _config),\n     Docs, \"src/doc\", _config.docs, only_hosts: false, {\n-        builder.ensure(dist::Docs { stage: self.stage, host: self.target });\n-        install_docs(builder, self.stage, self.target);\n+        builder.ensure(dist::Docs { host: self.target });\n+        install_docs(builder, self.compiler.stage, self.target);\n     };\n     Std, \"src/libstd\", true, only_hosts: true, {\n         for target in &builder.targets {\n             builder.ensure(dist::Std {\n-                compiler: builder.compiler(self.stage, self.host),\n+                compiler: self.compiler,\n                 target: *target\n             });\n-            install_std(builder, self.stage, *target);\n+            install_std(builder, self.compiler.stage, *target);\n         }\n     };\n     Cargo, \"cargo\", Self::should_build(_config), only_hosts: true, {\n-        builder.ensure(dist::Cargo { stage: self.stage, target: self.target });\n-        install_cargo(builder, self.stage, self.target);\n+        builder.ensure(dist::Cargo { compiler: self.compiler, target: self.target });\n+        install_cargo(builder, self.compiler.stage, self.target);\n     };\n     Rls, \"rls\", Self::should_build(_config), only_hosts: true, {\n-        if builder.ensure(dist::Rls { stage: self.stage, target: self.target }).is_some() ||\n+        if builder.ensure(dist::Rls { compiler: self.compiler, target: self.target }).is_some() ||\n             Self::should_install(builder) {\n-            install_rls(builder, self.stage, self.target);\n+            install_rls(builder, self.compiler.stage, self.target);\n         } else {\n-            builder.info(&format!(\"skipping Install RLS stage{} ({})\", self.stage, self.target));\n+            builder.info(\n+                &format!(\"skipping Install RLS stage{} ({})\", self.compiler.stage, self.target),\n+            );\n         }\n     };\n     Clippy, \"clippy\", Self::should_build(_config), only_hosts: true, {\n-        if builder.ensure(dist::Clippy { stage: self.stage, target: self.target }).is_some() ||\n-            Self::should_install(builder) {\n-            install_clippy(builder, self.stage, self.target);\n+        if builder.ensure(dist::Clippy {\n+            compiler: self.compiler,\n+            target: self.target,\n+        }).is_some() || Self::should_install(builder) {\n+            install_clippy(builder, self.compiler.stage, self.target);\n         } else {\n-            builder.info(&format!(\"skipping Install clippy stage{} ({})\", self.stage, self.target));\n+            builder.info(\n+                &format!(\"skipping Install clippy stage{} ({})\", self.compiler.stage, self.target),\n+            );\n         }\n     };\n     Miri, \"miri\", Self::should_build(_config), only_hosts: true, {\n-        if builder.ensure(dist::Miri { stage: self.stage, target: self.target }).is_some() ||\n+        if builder.ensure(dist::Miri { compiler: self.compiler, target: self.target }).is_some() ||\n             Self::should_install(builder) {\n-            install_miri(builder, self.stage, self.target);\n+            install_miri(builder, self.compiler.stage, self.target);\n         } else {\n-            builder.info(&format!(\"skipping Install miri stage{} ({})\", self.stage, self.target));\n+            builder.info(\n+                &format!(\"skipping Install miri stage{} ({})\", self.compiler.stage, self.target),\n+            );\n         }\n     };\n     Rustfmt, \"rustfmt\", Self::should_build(_config), only_hosts: true, {\n-        if builder.ensure(dist::Rustfmt { stage: self.stage, target: self.target }).is_some() ||\n-            Self::should_install(builder) {\n-            install_rustfmt(builder, self.stage, self.target);\n+        if builder.ensure(dist::Rustfmt {\n+            compiler: self.compiler,\n+            target: self.target\n+        }).is_some() || Self::should_install(builder) {\n+            install_rustfmt(builder, self.compiler.stage, self.target);\n         } else {\n             builder.info(\n-                &format!(\"skipping Install Rustfmt stage{} ({})\", self.stage, self.target));\n+                &format!(\"skipping Install Rustfmt stage{} ({})\", self.compiler.stage, self.target),\n+            );\n         }\n     };\n     Analysis, \"analysis\", Self::should_build(_config), only_hosts: false, {\n         builder.ensure(dist::Analysis {\n-            compiler: builder.compiler(self.stage, self.host),\n+            compiler: self.compiler,\n             target: self.target\n         });\n-        install_analysis(builder, self.stage, self.target);\n+        install_analysis(builder, self.compiler.stage, self.target);\n     };\n     Rustc, \"src/librustc\", true, only_hosts: true, {\n         builder.ensure(dist::Rustc {\n-            compiler: builder.compiler(self.stage, self.target),\n+            compiler: self.compiler,\n         });\n-        install_rustc(builder, self.stage, self.target);\n+        install_rustc(builder, self.compiler.stage, self.target);\n     };\n );\n \n@@ -266,15 +276,12 @@ impl Step for Src {\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let config = &run.builder.config;\n-        let cond = config.extended &&\n-            config.tools.as_ref().map_or(true, |t| t.contains(\"src\"));\n+        let cond = config.extended && config.tools.as_ref().map_or(true, |t| t.contains(\"src\"));\n         run.path(\"src\").default_condition(cond)\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Src {\n-            stage: run.builder.top_stage,\n-        });\n+        run.builder.ensure(Src { stage: run.builder.top_stage });\n     }\n \n     fn run(self, builder: &Builder<'_>) {"}, {"sha": "74caaae2840c5b2b88b2b960321ef12e241d3a94", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -1690,15 +1690,11 @@ impl Step for Crate {\n         builder.ensure(compile::Test { compiler, target });\n         builder.ensure(RemoteCopyLibs { compiler, target });\n \n-        // If we're not doing a full bootstrap but we're testing a stage2 version of\n-        // libstd, then what we're actually testing is the libstd produced in\n-        // stage1. Reflect that here by updating the compiler that we're working\n-        // with automatically.\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler.clone()\n-        };\n+        // If we're not doing a full bootstrap but we're testing a stage2\n+        // version of libstd, then what we're actually testing is the libstd\n+        // produced in stage1. Reflect that here by updating the compiler that\n+        // we're working with automatically.\n+        let compiler = builder.compiler_for(compiler.stage, compiler.host, target);\n \n         let mut cargo = builder.cargo(compiler, mode, target, test_kind.subcommand());\n         match mode {"}, {"sha": "3b6f02c9368c9570eac86af2bd92566df32de586", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -535,9 +535,9 @@ impl Step for Cargo {\n     }\n \n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n-        // Cargo depends on procedural macros, which requires a full host\n-        // compiler to be available, so we need to depend on that.\n-        builder.ensure(compile::Rustc {\n+        // Cargo depends on procedural macros, so make sure the host\n+        // libstd/libproc_macro is available.\n+        builder.ensure(compile::Test {\n             compiler: self.compiler,\n             target: builder.config.build,\n         });\n@@ -609,26 +609,26 @@ macro_rules! tool_extended {\n tool_extended!((self, builder),\n     Cargofmt, rustfmt, \"src/tools/rustfmt\", \"cargo-fmt\", {};\n     CargoClippy, clippy, \"src/tools/clippy\", \"cargo-clippy\", {\n-        // Clippy depends on procedural macros (serde), which requires a full host\n-        // compiler to be available, so we need to depend on that.\n-        builder.ensure(compile::Rustc {\n+        // Clippy depends on procedural macros, so make sure that's built for\n+        // the compiler itself.\n+        builder.ensure(compile::Test {\n             compiler: self.compiler,\n             target: builder.config.build,\n         });\n     };\n     Clippy, clippy, \"src/tools/clippy\", \"clippy-driver\", {\n-        // Clippy depends on procedural macros (serde), which requires a full host\n-        // compiler to be available, so we need to depend on that.\n-        builder.ensure(compile::Rustc {\n+        // Clippy depends on procedural macros, so make sure that's built for\n+        // the compiler itself.\n+        builder.ensure(compile::Test {\n             compiler: self.compiler,\n             target: builder.config.build,\n         });\n     };\n     Miri, miri, \"src/tools/miri\", \"miri\", {};\n     CargoMiri, miri, \"src/tools/miri\", \"cargo-miri\", {\n-        // Miri depends on procedural macros (serde), which requires a full host\n-        // compiler to be available, so we need to depend on that.\n-        builder.ensure(compile::Rustc {\n+        // Miri depends on procedural macros, so make sure that's built for\n+        // the compiler itself.\n+        builder.ensure(compile::Test {\n             compiler: self.compiler,\n             target: builder.config.build,\n         });\n@@ -642,9 +642,9 @@ tool_extended!((self, builder),\n         if clippy.is_some() {\n             self.extra_features.push(\"clippy\".to_owned());\n         }\n-        // RLS depends on procedural macros, which requires a full host\n-        // compiler to be available, so we need to depend on that.\n-        builder.ensure(compile::Rustc {\n+        // RLS depends on procedural macros, so make sure that's built for\n+        // the compiler itself.\n+        builder.ensure(compile::Test {\n             compiler: self.compiler,\n             target: builder.config.build,\n         });"}, {"sha": "235920833f83980cf89acdbe1e6fcc1969cfebd0", "filename": "src/ci/docker/armhf-gnu/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -72,7 +72,7 @@ RUN arm-linux-gnueabihf-gcc addentropy.c -o rootfs/addentropy -static\n \n # TODO: What is this?!\n # Source of the file: https://github.com/vfdev-5/qemu-rpi2-vexpress/raw/master/vexpress-v2p-ca15-tc1.dtb\n-RUN curl -O https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/vexpress-v2p-ca15-tc1.dtb\n+RUN curl -O https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/vexpress-v2p-ca15-tc1.dtb\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "60a96e3b8e9524e5d951249ae58649ae4b23cea6", "filename": "src/ci/docker/dist-various-1/install-mips-musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mips-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mips-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mips-musl.sh?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -5,7 +5,7 @@ mkdir /usr/local/mips-linux-musl\n # originally from\n # https://downloads.openwrt.org/snapshots/trunk/ar71xx/generic/\n # OpenWrt-Toolchain-ar71xx-generic_gcc-5.3.0_musl-1.1.16.Linux-x86_64.tar.bz2\n-URL=\"https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\"\n+URL=\"https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\"\n FILE=\"OpenWrt-Toolchain-ar71xx-generic_gcc-5.3.0_musl-1.1.16.Linux-x86_64.tar.bz2\"\n curl -L \"$URL/$FILE\" | tar xjf - -C /usr/local/mips-linux-musl --strip-components=2\n "}, {"sha": "9ae41218ee4fbf2f429510d50fb7f8b475aa4c07", "filename": "src/ci/docker/dist-various-1/install-mipsel-musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mipsel-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mipsel-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mipsel-musl.sh?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -5,7 +5,7 @@ mkdir /usr/local/mipsel-linux-musl\n # Note that this originally came from:\n # https://downloads.openwrt.org/snapshots/trunk/malta/generic/\n # OpenWrt-Toolchain-malta-le_gcc-5.3.0_musl-1.1.15.Linux-x86_64.tar.bz2\n-URL=\"https://s3-us-west-1.amazonaws.com/rust-lang-ci2/libc\"\n+URL=\"https://rust-lang-ci2.s3.amazonaws.com/libc\"\n FILE=\"OpenWrt-Toolchain-malta-le_gcc-5.3.0_musl-1.1.15.Linux-x86_64.tar.bz2\"\n curl -L \"$URL/$FILE\" | tar xjf - -C /usr/local/mipsel-linux-musl --strip-components=2\n "}, {"sha": "53523d41a55804510cfd2933d79a06048442c1cb", "filename": "src/ci/docker/dist-various-2/Dockerfile", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -32,10 +32,9 @@ COPY dist-various-2/build-cloudabi-toolchain.sh /tmp/\n RUN /tmp/build-cloudabi-toolchain.sh x86_64-unknown-cloudabi\n COPY dist-various-2/build-fuchsia-toolchain.sh /tmp/\n RUN /tmp/build-fuchsia-toolchain.sh\n-# FIXME(#61022) - reenable solaris\n-# COPY dist-various-2/build-solaris-toolchain.sh /tmp/\n-# RUN /tmp/build-solaris-toolchain.sh x86_64  amd64   solaris-i386\n-# RUN /tmp/build-solaris-toolchain.sh sparcv9 sparcv9 solaris-sparc\n+COPY dist-various-2/build-solaris-toolchain.sh /tmp/\n+RUN /tmp/build-solaris-toolchain.sh x86_64  amd64   solaris-i386\n+RUN /tmp/build-solaris-toolchain.sh sparcv9 sparcv9 solaris-sparc\n COPY dist-various-2/build-x86_64-fortanix-unknown-sgx-toolchain.sh /tmp/\n # We pass the commit id of the port of LLVM's libunwind to the build script.\n # Any update to the commit id here, should cause the container image to be re-built from this point on.\n@@ -76,9 +75,8 @@ ENV TARGETS=x86_64-fuchsia\n ENV TARGETS=$TARGETS,aarch64-fuchsia\n ENV TARGETS=$TARGETS,wasm32-unknown-unknown\n ENV TARGETS=$TARGETS,wasm32-wasi\n-# FIXME(#61022) - reenable solaris\n-# ENV TARGETS=$TARGETS,sparcv9-sun-solaris\n-# ENV TARGETS=$TARGETS,x86_64-sun-solaris\n+ENV TARGETS=$TARGETS,sparcv9-sun-solaris\n+ENV TARGETS=$TARGETS,x86_64-sun-solaris\n ENV TARGETS=$TARGETS,x86_64-unknown-linux-gnux32\n ENV TARGETS=$TARGETS,x86_64-unknown-cloudabi\n ENV TARGETS=$TARGETS,x86_64-fortanix-unknown-sgx"}, {"sha": "7bf8946c4f136a4d3b7b09206bd3b3404701232c", "filename": "src/ci/docker/dist-various-2/build-wasi-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -5,7 +5,7 @@\n set -ex\n \n # Originally from https://releases.llvm.org/8.0.0/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-14.04.tar.xz\n-curl https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/clang%2Bllvm-8.0.0-x86_64-linux-gnu-ubuntu-14.04.tar.xz | \\\n+curl https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/clang%2Bllvm-8.0.0-x86_64-linux-gnu-ubuntu-14.04.tar.xz | \\\n   tar xJf -\n export PATH=`pwd`/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-14.04/bin:$PATH\n "}, {"sha": "13dae6169053a09a3eedd892180c11da48d8aba5", "filename": "src/ci/docker/dist-x86_64-linux/build-openssl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-openssl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-openssl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-openssl.sh?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -4,7 +4,7 @@ set -ex\n source shared.sh\n \n VERSION=1.0.2k\n-URL=https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/openssl-$VERSION.tar.gz\n+URL=https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/openssl-$VERSION.tar.gz\n \n curl $URL | tar xzf -\n "}, {"sha": "2e9b9dcc2344ed2d1c38f30c53bf18f5e348381e", "filename": "src/ci/docker/dist-x86_64-netbsd/build-netbsd-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -25,7 +25,7 @@ cd netbsd\n \n mkdir -p /x-tools/x86_64-unknown-netbsd/sysroot\n \n-URL=https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n+URL=https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n \n # Originally from ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-$BSD/source/sets/*.tgz\n curl $URL/2018-03-01-netbsd-src.tgz | tar xzf -"}, {"sha": "47196e8939626a69bc82255bac116f0a68981459", "filename": "src/ci/docker/scripts/emscripten.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fci%2Fdocker%2Fscripts%2Femscripten.sh", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fci%2Fdocker%2Fscripts%2Femscripten.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Femscripten.sh?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -18,7 +18,7 @@ exit 1\n }\n \n cd /\n-curl -fL https://s3.amazonaws.com/mozilla-games/emscripten/releases/emsdk-portable.tar.gz | \\\n+curl -fL https://mozilla-games.s3.amazonaws.com/emscripten/releases/emsdk-portable.tar.gz | \\\n     tar -xz\n \n cd /emsdk-portable"}, {"sha": "8cef69d9c26bb5b34c4f726d541ffe5985cb9a5f", "filename": "src/ci/docker/scripts/freebsd-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fci%2Fdocker%2Fscripts%2Ffreebsd-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fci%2Fdocker%2Fscripts%2Ffreebsd-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Ffreebsd-toolchain.sh?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -59,7 +59,7 @@ done\n \n # Originally downloaded from:\n # https://download.freebsd.org/ftp/releases/${freebsd_arch}/${freebsd_version}-RELEASE/base.txz\n-URL=https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2019-04-04-freebsd-${freebsd_arch}-${freebsd_version}-RELEASE-base.txz\n+URL=https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2019-04-04-freebsd-${freebsd_arch}-${freebsd_version}-RELEASE-base.txz\n curl \"$URL\" | tar xJf - -C \"$sysroot\" --wildcards \"${files_to_extract[@]}\"\n \n # Fix up absolute symlinks from the system image.  This can be removed"}, {"sha": "194de3c339f8c4ef22ef574214237e1013ac1a2b", "filename": "src/ci/docker/scripts/sccache.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -1,6 +1,6 @@\n set -ex\n \n curl -fo /usr/local/bin/sccache \\\n-  https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2018-04-02-sccache-x86_64-unknown-linux-musl\n+  https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2018-04-02-sccache-x86_64-unknown-linux-musl\n \n chmod +x /usr/local/bin/sccache"}, {"sha": "8b635810825f176d18cb5853c649556ea41e0cdc", "filename": "src/ci/init_repo.sh", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fci%2Finit_repo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fci%2Finit_repo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Finit_repo.sh?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -1,5 +1,9 @@\n #!/usr/bin/env bash\n \n+# FIXME(61301): we need to debug spurious failures with this on Windows on\n+# Azure, so let's print more information in the logs.\n+set -x\n+\n set -o errexit\n set -o pipefail\n set -o nounset"}, {"sha": "a896ce819aeb7e389c03d6aa7987e18940727435", "filename": "src/doc/rustdoc/src/documentation-tests.md", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -253,6 +253,19 @@ conversion, so type inference fails because the type is not unique. Please note\n that you must write the `(())` in one sequence without intermediate whitespace\n so that rustdoc understands you want an implicit `Result`-returning function.\n \n+As of version 1.37.0, this simplification also works with `Option`s, which can\n+be handy to test e.g. iterators or checked arithmetic, for example:\n+\n+```ignore\n+/// ```\n+/// let _ = &[].iter().next()?;\n+///# Some(())\n+/// ```\n+```\n+\n+Note that the result must be a `Some(())` and this has to be written in one go.\n+In this case disambiguating the result isn't required.\n+\n ## Documenting macros\n \n Here\u2019s an example of documenting a macro:"}, {"sha": "304b8dffe98679c9f6fea3e7d2558757c1797563", "filename": "src/doc/unstable-book/src/library-features/borrow-state.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/642e8d4434c4f6214a908eea0019b3185323431f/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fborrow-state.md", "raw_url": "https://github.com/rust-lang/rust/raw/642e8d4434c4f6214a908eea0019b3185323431f/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fborrow-state.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fborrow-state.md?ref=642e8d4434c4f6214a908eea0019b3185323431f", "patch": "@@ -1,7 +0,0 @@\n-# `borrow_state`\n-\n-The tracking issue for this feature is: [#27733]\n-\n-[#27733]: https://github.com/rust-lang/rust/issues/27733\n-\n-------------------------"}, {"sha": "1f357a719bb43880725e51309349591dd1777156", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 156, "deletions": 6, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -239,7 +239,7 @@ use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::intrinsics::abort;\n use core::marker::{self, Unpin, Unsize, PhantomData};\n-use core::mem::{self, align_of_val, forget, size_of_val};\n+use core::mem::{self, align_of, align_of_val, forget, size_of_val};\n use core::ops::{Deref, Receiver, CoerceUnsized, DispatchFromDyn};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n@@ -416,11 +416,7 @@ impl<T: ?Sized> Rc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n-        // Align the unsized value to the end of the RcBox.\n-        // Because it is ?Sized, it will always be the last field in memory.\n-        let align = align_of_val(&*ptr);\n-        let layout = Layout::new::<RcBox<()>>();\n-        let offset = (layout.size() + layout.padding_needed_for(align)) as isize;\n+        let offset = data_offset(ptr);\n \n         // Reverse the offset to find the original RcBox.\n         let fake_ptr = ptr as *mut RcBox<T>;\n@@ -1262,6 +1258,143 @@ impl<T> Weak<T> {\n             ptr: NonNull::new(usize::MAX as *mut RcBox<T>).expect(\"MAX is not 0\"),\n         }\n     }\n+\n+    /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n+    ///\n+    /// It is up to the caller to ensure that the object is still alive when accessing it through\n+    /// the pointer.\n+    ///\n+    /// The pointer may be [`null`] or be dangling in case the object has already been destroyed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::rc::{Rc, Weak};\n+    /// use std::ptr;\n+    ///\n+    /// let strong = Rc::new(42);\n+    /// let weak = Rc::downgrade(&strong);\n+    /// // Both point to the same object\n+    /// assert!(ptr::eq(&*strong, Weak::as_raw(&weak)));\n+    /// // The strong here keeps it alive, so we can still access the object.\n+    /// assert_eq!(42, unsafe { *Weak::as_raw(&weak) });\n+    ///\n+    /// drop(strong);\n+    /// // But not any more. We can do Weak::as_raw(&weak), but accessing the pointer would lead to\n+    /// // undefined behaviour.\n+    /// // assert_eq!(42, unsafe { *Weak::as_raw(&weak) });\n+    /// ```\n+    ///\n+    /// [`null`]: ../../std/ptr/fn.null.html\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn as_raw(this: &Self) -> *const T {\n+        match this.inner() {\n+            None => ptr::null(),\n+            Some(inner) => {\n+                let offset = data_offset_sized::<T>();\n+                let ptr = inner as *const RcBox<T>;\n+                // Note: while the pointer we create may already point to dropped value, the\n+                // allocation still lives (it must hold the weak point as long as we are alive).\n+                // Therefore, the offset is OK to do, it won't get out of the allocation.\n+                let ptr = unsafe { (ptr as *const u8).offset(offset) };\n+                ptr as *const T\n+            }\n+        }\n+    }\n+\n+    /// Consumes the `Weak<T>` and turns it into a raw pointer.\n+    ///\n+    /// This converts the weak pointer into a raw pointer, preserving the original weak count. It\n+    /// can be turned back into the `Weak<T>` with [`from_raw`].\n+    ///\n+    /// The same restrictions of accessing the target of the pointer as with\n+    /// [`as_raw`] apply.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::rc::{Rc, Weak};\n+    ///\n+    /// let strong = Rc::new(42);\n+    /// let weak = Rc::downgrade(&strong);\n+    /// let raw = Weak::into_raw(weak);\n+    ///\n+    /// assert_eq!(1, Rc::weak_count(&strong));\n+    /// assert_eq!(42, unsafe { *raw });\n+    ///\n+    /// drop(unsafe { Weak::from_raw(raw) });\n+    /// assert_eq!(0, Rc::weak_count(&strong));\n+    /// ```\n+    ///\n+    /// [`from_raw`]: struct.Weak.html#method.from_raw\n+    /// [`as_raw`]: struct.Weak.html#method.as_raw\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn into_raw(this: Self) -> *const T {\n+        let result = Self::as_raw(&this);\n+        mem::forget(this);\n+        result\n+    }\n+\n+    /// Converts a raw pointer previously created by [`into_raw`] back into `Weak<T>`.\n+    ///\n+    /// This can be used to safely get a strong reference (by calling [`upgrade`]\n+    /// later) or to deallocate the weak count by dropping the `Weak<T>`.\n+    ///\n+    /// It takes ownership of one weak count. In case a [`null`] is passed, a dangling [`Weak`] is\n+    /// returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The pointer must represent one valid weak count. In other words, it must point to `T` which\n+    /// is or *was* managed by an [`Rc`] and the weak count of that [`Rc`] must not have reached\n+    /// 0. It is allowed for the strong count to be 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::rc::{Rc, Weak};\n+    ///\n+    /// let strong = Rc::new(42);\n+    ///\n+    /// let raw_1 = Weak::into_raw(Rc::downgrade(&strong));\n+    /// let raw_2 = Weak::into_raw(Rc::downgrade(&strong));\n+    ///\n+    /// assert_eq!(2, Rc::weak_count(&strong));\n+    ///\n+    /// assert_eq!(42, *Weak::upgrade(&unsafe { Weak::from_raw(raw_1) }).unwrap());\n+    /// assert_eq!(1, Rc::weak_count(&strong));\n+    ///\n+    /// drop(strong);\n+    ///\n+    /// // Decrement the last weak count.\n+    /// assert!(Weak::upgrade(&unsafe { Weak::from_raw(raw_2) }).is_none());\n+    /// ```\n+    ///\n+    /// [`null`]: ../../std/ptr/fn.null.html\n+    /// [`into_raw`]: struct.Weak.html#method.into_raw\n+    /// [`upgrade`]: struct.Weak.html#method.upgrade\n+    /// [`Rc`]: struct.Rc.html\n+    /// [`Weak`]: struct.Weak.html\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub unsafe fn from_raw(ptr: *const T) -> Self {\n+        if ptr.is_null() {\n+            Self::new()\n+        } else {\n+            // See Rc::from_raw for details\n+            let offset = data_offset(ptr);\n+            let fake_ptr = ptr as *mut RcBox<T>;\n+            let ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n+            Weak {\n+                ptr: NonNull::new(ptr).expect(\"Invalid pointer passed to from_raw\"),\n+            }\n+        }\n+    }\n }\n \n pub(crate) fn is_dangling<T: ?Sized>(ptr: NonNull<T>) -> bool {\n@@ -2007,3 +2140,20 @@ impl<T: ?Sized> AsRef<T> for Rc<T> {\n \n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T: ?Sized> Unpin for Rc<T> { }\n+\n+unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n+    // Align the unsized value to the end of the RcBox.\n+    // Because it is ?Sized, it will always be the last field in memory.\n+    let align = align_of_val(&*ptr);\n+    let layout = Layout::new::<RcBox<()>>();\n+    (layout.size() + layout.padding_needed_for(align)) as isize\n+}\n+\n+/// Computes the offset of the data field within ArcInner.\n+///\n+/// Unlike [`data_offset`], this doesn't need the pointer, but it works only on `T: Sized`.\n+fn data_offset_sized<T>() -> isize {\n+    let align = align_of::<T>();\n+    let layout = Layout::new::<RcBox<()>>();\n+    (layout.size() + layout.padding_needed_for(align)) as isize\n+}"}, {"sha": "aeb7f90d3e60e946d0d0e8efc19948bb8b2ef6a0", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -137,17 +137,16 @@ pub use hack::to_vec;\n // `core::slice::SliceExt` - we need to supply these functions for the\n // `test_permutations` test\n mod hack {\n-    use core::mem;\n-\n     use crate::boxed::Box;\n     use crate::vec::Vec;\n     #[cfg(test)]\n     use crate::string::ToString;\n \n-    pub fn into_vec<T>(mut b: Box<[T]>) -> Vec<T> {\n+    pub fn into_vec<T>(b: Box<[T]>) -> Vec<T> {\n         unsafe {\n-            let xs = Vec::from_raw_parts(b.as_mut_ptr(), b.len(), b.len());\n-            mem::forget(b);\n+            let len = b.len();\n+            let b = Box::into_raw(b);\n+            let xs = Vec::from_raw_parts(b as *mut T, len, len);\n             xs\n         }\n     }"}, {"sha": "70865656c510ee7b988d28ad86254a2e6b643f73", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 158, "deletions": 6, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -13,7 +13,7 @@ use core::borrow;\n use core::fmt;\n use core::cmp::{self, Ordering};\n use core::intrinsics::abort;\n-use core::mem::{self, align_of_val, size_of_val};\n+use core::mem::{self, align_of, align_of_val, size_of_val};\n use core::ops::{Deref, Receiver, CoerceUnsized, DispatchFromDyn};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n@@ -397,11 +397,7 @@ impl<T: ?Sized> Arc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n-        // Align the unsized value to the end of the ArcInner.\n-        // Because it is ?Sized, it will always be the last field in memory.\n-        let align = align_of_val(&*ptr);\n-        let layout = Layout::new::<ArcInner<()>>();\n-        let offset = (layout.size() + layout.padding_needed_for(align)) as isize;\n+        let offset = data_offset(ptr);\n \n         // Reverse the offset to find the original ArcInner.\n         let fake_ptr = ptr as *mut ArcInner<T>;\n@@ -1071,6 +1067,144 @@ impl<T> Weak<T> {\n             ptr: NonNull::new(usize::MAX as *mut ArcInner<T>).expect(\"MAX is not 0\"),\n         }\n     }\n+\n+    /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n+    ///\n+    /// It is up to the caller to ensure that the object is still alive when accessing it through\n+    /// the pointer.\n+    ///\n+    /// The pointer may be [`null`] or be dangling in case the object has already been destroyed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::sync::{Arc, Weak};\n+    /// use std::ptr;\n+    ///\n+    /// let strong = Arc::new(42);\n+    /// let weak = Arc::downgrade(&strong);\n+    /// // Both point to the same object\n+    /// assert!(ptr::eq(&*strong, Weak::as_raw(&weak)));\n+    /// // The strong here keeps it alive, so we can still access the object.\n+    /// assert_eq!(42, unsafe { *Weak::as_raw(&weak) });\n+    ///\n+    /// drop(strong);\n+    /// // But not any more. We can do Weak::as_raw(&weak), but accessing the pointer would lead to\n+    /// // undefined behaviour.\n+    /// // assert_eq!(42, unsafe { *Weak::as_raw(&weak) });\n+    /// ```\n+    ///\n+    /// [`null`]: ../../std/ptr/fn.null.html\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn as_raw(this: &Self) -> *const T {\n+        match this.inner() {\n+            None => ptr::null(),\n+            Some(inner) => {\n+                let offset = data_offset_sized::<T>();\n+                let ptr = inner as *const ArcInner<T>;\n+                // Note: while the pointer we create may already point to dropped value, the\n+                // allocation still lives (it must hold the weak point as long as we are alive).\n+                // Therefore, the offset is OK to do, it won't get out of the allocation.\n+                let ptr = unsafe { (ptr as *const u8).offset(offset) };\n+                ptr as *const T\n+            }\n+        }\n+    }\n+\n+    /// Consumes the `Weak<T>` and turns it into a raw pointer.\n+    ///\n+    /// This converts the weak pointer into a raw pointer, preserving the original weak count. It\n+    /// can be turned back into the `Weak<T>` with [`from_raw`].\n+    ///\n+    /// The same restrictions of accessing the target of the pointer as with\n+    /// [`as_raw`] apply.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::sync::{Arc, Weak};\n+    ///\n+    /// let strong = Arc::new(42);\n+    /// let weak = Arc::downgrade(&strong);\n+    /// let raw = Weak::into_raw(weak);\n+    ///\n+    /// assert_eq!(1, Arc::weak_count(&strong));\n+    /// assert_eq!(42, unsafe { *raw });\n+    ///\n+    /// drop(unsafe { Weak::from_raw(raw) });\n+    /// assert_eq!(0, Arc::weak_count(&strong));\n+    /// ```\n+    ///\n+    /// [`from_raw`]: struct.Weak.html#method.from_raw\n+    /// [`as_raw`]: struct.Weak.html#method.as_raw\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn into_raw(this: Self) -> *const T {\n+        let result = Self::as_raw(&this);\n+        mem::forget(this);\n+        result\n+    }\n+\n+    /// Converts a raw pointer previously created by [`into_raw`] back into\n+    /// `Weak<T>`.\n+    ///\n+    /// This can be used to safely get a strong reference (by calling [`upgrade`]\n+    /// later) or to deallocate the weak count by dropping the `Weak<T>`.\n+    ///\n+    /// It takes ownership of one weak count. In case a [`null`] is passed, a dangling [`Weak`] is\n+    /// returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The pointer must represent one valid weak count. In other words, it must point to `T` which\n+    /// is or *was* managed by an [`Arc`] and the weak count of that [`Arc`] must not have reached\n+    /// 0. It is allowed for the strong count to be 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::sync::{Arc, Weak};\n+    ///\n+    /// let strong = Arc::new(42);\n+    ///\n+    /// let raw_1 = Weak::into_raw(Arc::downgrade(&strong));\n+    /// let raw_2 = Weak::into_raw(Arc::downgrade(&strong));\n+    ///\n+    /// assert_eq!(2, Arc::weak_count(&strong));\n+    ///\n+    /// assert_eq!(42, *Weak::upgrade(&unsafe { Weak::from_raw(raw_1) }).unwrap());\n+    /// assert_eq!(1, Arc::weak_count(&strong));\n+    ///\n+    /// drop(strong);\n+    ///\n+    /// // Decrement the last weak count.\n+    /// assert!(Weak::upgrade(&unsafe { Weak::from_raw(raw_2) }).is_none());\n+    /// ```\n+    ///\n+    /// [`null`]: ../../std/ptr/fn.null.html\n+    /// [`into_raw`]: struct.Weak.html#method.into_raw\n+    /// [`upgrade`]: struct.Weak.html#method.upgrade\n+    /// [`Weak`]: struct.Weak.html\n+    /// [`Arc`]: struct.Arc.html\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub unsafe fn from_raw(ptr: *const T) -> Self {\n+        if ptr.is_null() {\n+            Self::new()\n+        } else {\n+            // See Arc::from_raw for details\n+            let offset = data_offset(ptr);\n+            let fake_ptr = ptr as *mut ArcInner<T>;\n+            let ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n+            Weak {\n+                ptr: NonNull::new(ptr).expect(\"Invalid pointer passed to from_raw\"),\n+            }\n+        }\n+    }\n }\n \n impl<T: ?Sized> Weak<T> {\n@@ -2150,3 +2284,21 @@ impl<T: ?Sized> AsRef<T> for Arc<T> {\n \n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T: ?Sized> Unpin for Arc<T> { }\n+\n+/// Computes the offset of the data field within ArcInner.\n+unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n+    // Align the unsized value to the end of the ArcInner.\n+    // Because it is ?Sized, it will always be the last field in memory.\n+    let align = align_of_val(&*ptr);\n+    let layout = Layout::new::<ArcInner<()>>();\n+    (layout.size() + layout.padding_needed_for(align)) as isize\n+}\n+\n+/// Computes the offset of the data field within ArcInner.\n+///\n+/// Unlike [`data_offset`], this doesn't need the pointer, but it works only on `T: Sized`.\n+fn data_offset_sized<T>() -> isize {\n+    let align = align_of::<T>();\n+    let layout = Layout::new::<ArcInner<()>>();\n+    (layout.size() + layout.padding_needed_for(align)) as isize\n+}"}, {"sha": "9d26ecbacdcbbad1802e727b706cd2a5821450ad", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -967,7 +967,6 @@ impl<T: ?Sized> RefCell<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(borrow_state)]\n     /// use std::cell::RefCell;\n     ///\n     /// let c = RefCell::new(5);\n@@ -982,7 +981,7 @@ impl<T: ?Sized> RefCell<T> {\n     ///     assert!(unsafe { c.try_borrow_unguarded() }.is_ok());\n     /// }\n     /// ```\n-    #[unstable(feature = \"borrow_state\", issue = \"27733\")]\n+    #[stable(feature = \"borrow_state\", since = \"1.37.0\")]\n     #[inline]\n     pub unsafe fn try_borrow_unguarded(&self) -> Result<&T, BorrowError> {\n         if !is_writing(self.borrow.get()) {"}, {"sha": "6bbf776fb8f17bb7d6f14266e398ad3fc9e029bc", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -34,6 +34,13 @@ pub trait Step: Clone + PartialOrd + Sized {\n \n     /// Adds a `usize`, returning `None` on overflow.\n     fn add_usize(&self, n: usize) -> Option<Self>;\n+\n+    /// Subtracts a `usize`, returning `None` on underflow.\n+    fn sub_usize(&self, n: usize) -> Option<Self> {\n+        // this default implementation makes the addition of `sub_usize` a non-breaking change\n+        let _ = n;\n+        unimplemented!()\n+    }\n }\n \n // These are still macro-generated because the integer literals resolve to different types.\n@@ -85,6 +92,15 @@ macro_rules! step_impl_unsigned {\n                 }\n             }\n \n+            #[inline]\n+            #[allow(unreachable_patterns)]\n+            fn sub_usize(&self, n: usize) -> Option<Self> {\n+                match <$t>::try_from(n) {\n+                    Ok(n_as_t) => self.checked_sub(n_as_t),\n+                    Err(_) => None,\n+                }\n+            }\n+\n             step_identical_methods!();\n         }\n     )*)\n@@ -125,6 +141,25 @@ macro_rules! step_impl_signed {\n                 }\n             }\n \n+            #[inline]\n+            #[allow(unreachable_patterns)]\n+            fn sub_usize(&self, n: usize) -> Option<Self> {\n+                match <$unsigned>::try_from(n) {\n+                    Ok(n_as_unsigned) => {\n+                        // Wrapping in unsigned space handles cases like\n+                        // `80_i8.sub_usize(200) == Some(-120_i8)`,\n+                        // even though 200_usize is out of range for i8.\n+                        let wrapped = (*self as $unsigned).wrapping_sub(n_as_unsigned) as $t;\n+                        if wrapped <= *self {\n+                            Some(wrapped)\n+                        } else {\n+                            None  // Subtraction underflowed\n+                        }\n+                    }\n+                    Err(_) => None,\n+                }\n+            }\n+\n             step_identical_methods!();\n         }\n     )*)"}, {"sha": "4eac5cbc8e6623142563d8e3186994e4ceb3bfe1", "filename": "src/libcore/iter/traits/accum.rs", "status": "modified", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -223,3 +223,113 @@ impl<T, U, E> Product<Result<U, E>> for Result<T, E>\n         ResultShunt::process(iter, |i| i.product())\n     }\n }\n+\n+/// An iterator adapter that produces output as long as the underlying\n+/// iterator produces `Option::Some` values.\n+struct OptionShunt<I> {\n+    iter: I,\n+    exited_early: bool,\n+}\n+\n+impl<I, T> OptionShunt<I>\n+where\n+    I: Iterator<Item = Option<T>>,\n+{\n+    /// Process the given iterator as if it yielded a `T` instead of a\n+    /// `Option<T>`. Any `None` value will stop the inner iterator and\n+    /// the overall result will be a `None`.\n+    pub fn process<F, U>(iter: I, mut f: F) -> Option<U>\n+    where\n+        F: FnMut(&mut Self) -> U,\n+    {\n+        let mut shunt = OptionShunt::new(iter);\n+        let value = f(shunt.by_ref());\n+        shunt.reconstruct(value)\n+    }\n+\n+    fn new(iter: I) -> Self {\n+        OptionShunt {\n+            iter,\n+            exited_early: false,\n+        }\n+    }\n+\n+    /// Consume the adapter and rebuild a `Option` value.\n+    fn reconstruct<U>(self, val: U) -> Option<U> {\n+        if self.exited_early {\n+            None\n+        } else {\n+            Some(val)\n+        }\n+    }\n+}\n+\n+impl<I, T> Iterator for OptionShunt<I>\n+where\n+    I: Iterator<Item = Option<T>>,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        match self.iter.next() {\n+            Some(Some(v)) => Some(v),\n+            Some(None) => {\n+                self.exited_early = true;\n+                None\n+            }\n+            None => None,\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.exited_early {\n+            (0, Some(0))\n+        } else {\n+            let (_, upper) = self.iter.size_hint();\n+            (0, upper)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"iter_arith_traits_option\", since = \"1.37.0\")]\n+impl<T, U> Sum<Option<U>> for Option<T>\n+where\n+    T: Sum<U>,\n+{\n+    /// Takes each element in the `Iterator`: if it is a `None`, no further\n+    /// elements are taken, and the `None` is returned. Should no `None` occur,\n+    /// the sum of all elements is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// This sums up the position of the character 'a' in a vector of strings,\n+    /// if a word did not have the character 'a' the operation returns `None`:\n+    ///\n+    /// ```\n+    /// let words = vec![\"have\", \"a\", \"great\", \"day\"];\n+    /// let total: Option<usize> = words.iter().map(|w| w.find('a')).sum();\n+    /// assert_eq!(total, Some(5));\n+    /// ```\n+    fn sum<I>(iter: I) -> Option<T>\n+    where\n+        I: Iterator<Item = Option<U>>,\n+    {\n+        OptionShunt::process(iter, |i| i.sum())\n+    }\n+}\n+\n+#[stable(feature = \"iter_arith_traits_option\", since = \"1.37.0\")]\n+impl<T, U> Product<Option<U>> for Option<T>\n+where\n+    T: Product<U>,\n+{\n+    /// Takes each element in the `Iterator`: if it is a `None`, no further\n+    /// elements are taken, and the `None` is returned. Should no `None` occur,\n+    /// the product of all elements is returned.\n+    fn product<I>(iter: I) -> Option<T>\n+    where\n+        I: Iterator<Item = Option<U>>,\n+    {\n+        OptionShunt::process(iter, |i| i.product())\n+    }\n+}"}, {"sha": "40f4354213b40849bf253c7d1bb10bab04a86761", "filename": "src/libcore/mem.rs", "status": "removed", "additions": 0, "deletions": 1406, "changes": 1406, "blob_url": "https://github.com/rust-lang/rust/blob/642e8d4434c4f6214a908eea0019b3185323431f/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/642e8d4434c4f6214a908eea0019b3185323431f/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=642e8d4434c4f6214a908eea0019b3185323431f", "patch": "@@ -1,1406 +0,0 @@\n-//! Basic functions for dealing with memory.\n-//!\n-//! This module contains functions for querying the size and alignment of\n-//! types, initializing and manipulating memory.\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-use crate::clone;\n-use crate::cmp;\n-use crate::fmt;\n-use crate::hash;\n-use crate::intrinsics;\n-use crate::marker::{Copy, PhantomData, Sized};\n-use crate::ptr;\n-use crate::ops::{Deref, DerefMut};\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[doc(inline)]\n-pub use crate::intrinsics::transmute;\n-\n-/// Takes ownership and \"forgets\" about the value **without running its destructor**.\n-///\n-/// Any resources the value manages, such as heap memory or a file handle, will linger\n-/// forever in an unreachable state. However, it does not guarantee that pointers\n-/// to this memory will remain valid.\n-///\n-/// * If you want to leak memory, see [`Box::leak`][leak].\n-/// * If you want to obtain a raw pointer to the memory, see [`Box::into_raw`][into_raw].\n-/// * If you want to dispose of a value properly, running its destructor, see\n-/// [`mem::drop`][drop].\n-///\n-/// # Safety\n-///\n-/// `forget` is not marked as `unsafe`, because Rust's safety guarantees\n-/// do not include a guarantee that destructors will always run. For example,\n-/// a program can create a reference cycle using [`Rc`][rc], or call\n-/// [`process::exit`][exit] to exit without running destructors. Thus, allowing\n-/// `mem::forget` from safe code does not fundamentally change Rust's safety\n-/// guarantees.\n-///\n-/// That said, leaking resources such as memory or I/O objects is usually undesirable,\n-/// so `forget` is only recommended for specialized use cases like those shown below.\n-///\n-/// Because forgetting a value is allowed, any `unsafe` code you write must\n-/// allow for this possibility. You cannot return a value and expect that the\n-/// caller will necessarily run the value's destructor.\n-///\n-/// [rc]: ../../std/rc/struct.Rc.html\n-/// [exit]: ../../std/process/fn.exit.html\n-///\n-/// # Examples\n-///\n-/// Leak an I/O object, never closing the file:\n-///\n-/// ```no_run\n-/// use std::mem;\n-/// use std::fs::File;\n-///\n-/// let file = File::open(\"foo.txt\").unwrap();\n-/// mem::forget(file);\n-/// ```\n-///\n-/// The practical use cases for `forget` are rather specialized and mainly come\n-/// up in unsafe or FFI code.\n-///\n-/// [drop]: fn.drop.html\n-/// [uninit]: fn.uninitialized.html\n-/// [clone]: ../clone/trait.Clone.html\n-/// [swap]: fn.swap.html\n-/// [box]: ../../std/boxed/struct.Box.html\n-/// [leak]: ../../std/boxed/struct.Box.html#method.leak\n-/// [into_raw]: ../../std/boxed/struct.Box.html#method.into_raw\n-/// [ub]: ../../reference/behavior-considered-undefined.html\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn forget<T>(t: T) {\n-    ManuallyDrop::new(t);\n-}\n-\n-/// Like [`forget`], but also accepts unsized values.\n-///\n-/// This function is just a shim intended to be removed when the `unsized_locals` feature gets\n-/// stabilized.\n-///\n-/// [`forget`]: fn.forget.html\n-#[inline]\n-#[unstable(feature = \"forget_unsized\", issue = \"0\")]\n-pub fn forget_unsized<T: ?Sized>(t: T) {\n-    unsafe { intrinsics::forget(t) }\n-}\n-\n-/// Returns the size of a type in bytes.\n-///\n-/// More specifically, this is the offset in bytes between successive elements\n-/// in an array with that item type including alignment padding. Thus, for any\n-/// type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n-///\n-/// In general, the size of a type is not stable across compilations, but\n-/// specific types such as primitives are.\n-///\n-/// The following table gives the size for primitives.\n-///\n-/// Type | size_of::\\<Type>()\n-/// ---- | ---------------\n-/// () | 0\n-/// bool | 1\n-/// u8 | 1\n-/// u16 | 2\n-/// u32 | 4\n-/// u64 | 8\n-/// u128 | 16\n-/// i8 | 1\n-/// i16 | 2\n-/// i32 | 4\n-/// i64 | 8\n-/// i128 | 16\n-/// f32 | 4\n-/// f64 | 8\n-/// char | 4\n-///\n-/// Furthermore, `usize` and `isize` have the same size.\n-///\n-/// The types `*const T`, `&T`, `Box<T>`, `Option<&T>`, and `Option<Box<T>>` all have\n-/// the same size. If `T` is Sized, all of those types have the same size as `usize`.\n-///\n-/// The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n-/// have the same size. Likewise for `*const T` and `*mut T`.\n-///\n-/// # Size of `#[repr(C)]` items\n-///\n-/// The `C` representation for items has a defined layout. With this layout,\n-/// the size of items is also stable as long as all fields have a stable size.\n-///\n-/// ## Size of Structs\n-///\n-/// For `structs`, the size is determined by the following algorithm.\n-///\n-/// For each field in the struct ordered by declaration order:\n-///\n-/// 1. Add the size of the field.\n-/// 2. Round up the current size to the nearest multiple of the next field's [alignment].\n-///\n-/// Finally, round the size of the struct to the nearest multiple of its [alignment].\n-/// The alignment of the struct is usually the largest alignment of all its\n-/// fields; this can be changed with the use of `repr(align(N))`.\n-///\n-/// Unlike `C`, zero sized structs are not rounded up to one byte in size.\n-///\n-/// ## Size of Enums\n-///\n-/// Enums that carry no data other than the discriminant have the same size as C enums\n-/// on the platform they are compiled for.\n-///\n-/// ## Size of Unions\n-///\n-/// The size of a union is the size of its largest field.\n-///\n-/// Unlike `C`, zero sized unions are not rounded up to one byte in size.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// // Some primitives\n-/// assert_eq!(4, mem::size_of::<i32>());\n-/// assert_eq!(8, mem::size_of::<f64>());\n-/// assert_eq!(0, mem::size_of::<()>());\n-///\n-/// // Some arrays\n-/// assert_eq!(8, mem::size_of::<[i32; 2]>());\n-/// assert_eq!(12, mem::size_of::<[i32; 3]>());\n-/// assert_eq!(0, mem::size_of::<[i32; 0]>());\n-///\n-///\n-/// // Pointer size equality\n-/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<*const i32>());\n-/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<Box<i32>>());\n-/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<Option<&i32>>());\n-/// assert_eq!(mem::size_of::<Box<i32>>(), mem::size_of::<Option<Box<i32>>>());\n-/// ```\n-///\n-/// Using `#[repr(C)]`.\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// #[repr(C)]\n-/// struct FieldStruct {\n-///     first: u8,\n-///     second: u16,\n-///     third: u8\n-/// }\n-///\n-/// // The size of the first field is 1, so add 1 to the size. Size is 1.\n-/// // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n-/// // The size of the second field is 2, so add 2 to the size. Size is 4.\n-/// // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n-/// // The size of the third field is 1, so add 1 to the size. Size is 5.\n-/// // Finally, the alignment of the struct is 2 (because the largest alignment amongst its\n-/// // fields is 2), so add 1 to the size for padding. Size is 6.\n-/// assert_eq!(6, mem::size_of::<FieldStruct>());\n-///\n-/// #[repr(C)]\n-/// struct TupleStruct(u8, u16, u8);\n-///\n-/// // Tuple structs follow the same rules.\n-/// assert_eq!(6, mem::size_of::<TupleStruct>());\n-///\n-/// // Note that reordering the fields can lower the size. We can remove both padding bytes\n-/// // by putting `third` before `second`.\n-/// #[repr(C)]\n-/// struct FieldStructOptimized {\n-///     first: u8,\n-///     third: u8,\n-///     second: u16\n-/// }\n-///\n-/// assert_eq!(4, mem::size_of::<FieldStructOptimized>());\n-///\n-/// // Union size is the size of the largest field.\n-/// #[repr(C)]\n-/// union ExampleUnion {\n-///     smaller: u8,\n-///     larger: u16\n-/// }\n-///\n-/// assert_eq!(2, mem::size_of::<ExampleUnion>());\n-/// ```\n-///\n-/// [alignment]: ./fn.align_of.html\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_promotable]\n-pub const fn size_of<T>() -> usize {\n-    intrinsics::size_of::<T>()\n-}\n-\n-/// Returns the size of the pointed-to value in bytes.\n-///\n-/// This is usually the same as `size_of::<T>()`. However, when `T` *has* no\n-/// statically-known size, e.g., a slice [`[T]`][slice] or a [trait object],\n-/// then `size_of_val` can be used to get the dynamically-known size.\n-///\n-/// [slice]: ../../std/primitive.slice.html\n-/// [trait object]: ../../book/ch17-02-trait-objects.html\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// assert_eq!(4, mem::size_of_val(&5i32));\n-///\n-/// let x: [u8; 13] = [0; 13];\n-/// let y: &[u8] = &x;\n-/// assert_eq!(13, mem::size_of_val(y));\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn size_of_val<T: ?Sized>(val: &T) -> usize {\n-    unsafe { intrinsics::size_of_val(val) }\n-}\n-\n-/// Returns the [ABI]-required minimum alignment of a type.\n-///\n-/// Every reference to a value of the type `T` must be a multiple of this number.\n-///\n-/// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n-///\n-/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![allow(deprecated)]\n-/// use std::mem;\n-///\n-/// assert_eq!(4, mem::min_align_of::<i32>());\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_deprecated(reason = \"use `align_of` instead\", since = \"1.2.0\")]\n-pub fn min_align_of<T>() -> usize {\n-    intrinsics::min_align_of::<T>()\n-}\n-\n-/// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n-///\n-/// Every reference to a value of the type `T` must be a multiple of this number.\n-///\n-/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![allow(deprecated)]\n-/// use std::mem;\n-///\n-/// assert_eq!(4, mem::min_align_of_val(&5i32));\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_deprecated(reason = \"use `align_of_val` instead\", since = \"1.2.0\")]\n-pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n-    unsafe { intrinsics::min_align_of_val(val) }\n-}\n-\n-/// Returns the [ABI]-required minimum alignment of a type.\n-///\n-/// Every reference to a value of the type `T` must be a multiple of this number.\n-///\n-/// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n-///\n-/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// assert_eq!(4, mem::align_of::<i32>());\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_promotable]\n-pub const fn align_of<T>() -> usize {\n-    intrinsics::min_align_of::<T>()\n-}\n-\n-/// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n-///\n-/// Every reference to a value of the type `T` must be a multiple of this number.\n-///\n-/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// assert_eq!(4, mem::align_of_val(&5i32));\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n-    unsafe { intrinsics::min_align_of_val(val) }\n-}\n-\n-/// Returns `true` if dropping values of type `T` matters.\n-///\n-/// This is purely an optimization hint, and may be implemented conservatively:\n-/// it may return `true` for types that don't actually need to be dropped.\n-/// As such always returning `true` would be a valid implementation of\n-/// this function. However if this function actually returns `false`, then you\n-/// can be certain dropping `T` has no side effect.\n-///\n-/// Low level implementations of things like collections, which need to manually\n-/// drop their data, should use this function to avoid unnecessarily\n-/// trying to drop all their contents when they are destroyed. This might not\n-/// make a difference in release builds (where a loop that has no side-effects\n-/// is easily detected and eliminated), but is often a big win for debug builds.\n-///\n-/// Note that `ptr::drop_in_place` already performs this check, so if your workload\n-/// can be reduced to some small number of drop_in_place calls, using this is\n-/// unnecessary. In particular note that you can drop_in_place a slice, and that\n-/// will do a single needs_drop check for all the values.\n-///\n-/// Types like Vec therefore just `drop_in_place(&mut self[..])` without using\n-/// needs_drop explicitly. Types like HashMap, on the other hand, have to drop\n-/// values one at a time and should use this API.\n-///\n-///\n-/// # Examples\n-///\n-/// Here's an example of how a collection might make use of needs_drop:\n-///\n-/// ```\n-/// use std::{mem, ptr};\n-///\n-/// pub struct MyCollection<T> {\n-/// #   data: [T; 1],\n-///     /* ... */\n-/// }\n-/// # impl<T> MyCollection<T> {\n-/// #   fn iter_mut(&mut self) -> &mut [T] { &mut self.data }\n-/// #   fn free_buffer(&mut self) {}\n-/// # }\n-///\n-/// impl<T> Drop for MyCollection<T> {\n-///     fn drop(&mut self) {\n-///         unsafe {\n-///             // drop the data\n-///             if mem::needs_drop::<T>() {\n-///                 for x in self.iter_mut() {\n-///                     ptr::drop_in_place(x);\n-///                 }\n-///             }\n-///             self.free_buffer();\n-///         }\n-///     }\n-/// }\n-/// ```\n-#[inline]\n-#[stable(feature = \"needs_drop\", since = \"1.21.0\")]\n-pub const fn needs_drop<T>() -> bool {\n-    intrinsics::needs_drop::<T>()\n-}\n-\n-/// Creates a value whose bytes are all zero.\n-///\n-/// This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].\n-/// It is useful for FFI sometimes, but should generally be avoided.\n-///\n-/// There is no guarantee that an all-zero byte-pattern represents a valid value of\n-/// some type `T`. For example, the all-zero byte-pattern is not a valid value\n-/// for reference types (`&T` and `&mut T`). Using `zeroed` on such types\n-/// causes immediate [undefined behavior][ub] because [the Rust compiler assumes][inv]\n-/// that there always is a valid value in a variable it considers initialized.\n-///\n-/// [zeroed]: union.MaybeUninit.html#method.zeroed\n-/// [ub]: ../../reference/behavior-considered-undefined.html\n-/// [inv]: union.MaybeUninit.html#initialization-invariant\n-///\n-/// # Examples\n-///\n-/// Correct usage of this function: initializing an integer with zero.\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// let x: i32 = unsafe { mem::zeroed() };\n-/// assert_eq!(0, x);\n-/// ```\n-///\n-/// *Incorrect* usage of this function: initializing a reference with zero.\n-///\n-/// ```no_run\n-/// use std::mem;\n-///\n-/// let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub unsafe fn zeroed<T>() -> T {\n-    intrinsics::panic_if_uninhabited::<T>();\n-    intrinsics::init()\n-}\n-\n-/// Bypasses Rust's normal memory-initialization checks by pretending to\n-/// produce a value of type `T`, while doing nothing at all.\n-///\n-/// **This functon is deprecated.** Use [`MaybeUninit<T>`] instead.\n-///\n-/// The reason for deprecation is that the function basically cannot be used\n-/// correctly: [the Rust compiler assumes][inv] that values are properly initialized.\n-/// As a consequence, calling e.g. `mem::uninitialized::<bool>()` causes immediate\n-/// undefined behavior for returning a `bool` that is not definitely either `true`\n-/// or `false`. Worse, truly uninitialized memory like what gets returned here\n-/// is special in that the compiler knows that it does not have a fixed value.\n-/// This makes it undefined behavior to have uninitialized data in a variable even\n-/// if that variable has an integer type.\n-/// (Notice that the rules around uninitialized integers are not finalized yet, but\n-/// until they are, it is advisable to avoid them.)\n-///\n-/// [`MaybeUninit<T>`]: union.MaybeUninit.html\n-/// [inv]: union.MaybeUninit.html#initialization-invariant\n-#[inline]\n-#[rustc_deprecated(since = \"1.38.0\", reason = \"use `mem::MaybeUninit` instead\")]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub unsafe fn uninitialized<T>() -> T {\n-    intrinsics::panic_if_uninhabited::<T>();\n-    intrinsics::uninit()\n-}\n-\n-/// Swaps the values at two mutable locations, without deinitializing either one.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// let mut x = 5;\n-/// let mut y = 42;\n-///\n-/// mem::swap(&mut x, &mut y);\n-///\n-/// assert_eq!(42, x);\n-/// assert_eq!(5, y);\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn swap<T>(x: &mut T, y: &mut T) {\n-    unsafe {\n-        ptr::swap_nonoverlapping_one(x, y);\n-    }\n-}\n-\n-/// Moves `src` into the referenced `dest`, returning the previous `dest` value.\n-///\n-/// Neither value is dropped.\n-///\n-/// # Examples\n-///\n-/// A simple example:\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// let mut v: Vec<i32> = vec![1, 2];\n-///\n-/// let old_v = mem::replace(&mut v, vec![3, 4, 5]);\n-/// assert_eq!(vec![1, 2], old_v);\n-/// assert_eq!(vec![3, 4, 5], v);\n-/// ```\n-///\n-/// `replace` allows consumption of a struct field by replacing it with another value.\n-/// Without `replace` you can run into issues like these:\n-///\n-/// ```compile_fail,E0507\n-/// struct Buffer<T> { buf: Vec<T> }\n-///\n-/// impl<T> Buffer<T> {\n-///     fn get_and_reset(&mut self) -> Vec<T> {\n-///         // error: cannot move out of dereference of `&mut`-pointer\n-///         let buf = self.buf;\n-///         self.buf = Vec::new();\n-///         buf\n-///     }\n-/// }\n-/// ```\n-///\n-/// Note that `T` does not necessarily implement [`Clone`], so it can't even clone and reset\n-/// `self.buf`. But `replace` can be used to disassociate the original value of `self.buf` from\n-/// `self`, allowing it to be returned:\n-///\n-/// ```\n-/// # #![allow(dead_code)]\n-/// use std::mem;\n-///\n-/// # struct Buffer<T> { buf: Vec<T> }\n-/// impl<T> Buffer<T> {\n-///     fn get_and_reset(&mut self) -> Vec<T> {\n-///         mem::replace(&mut self.buf, Vec::new())\n-///     }\n-/// }\n-/// ```\n-///\n-/// [`Clone`]: ../../std/clone/trait.Clone.html\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n-    swap(dest, &mut src);\n-    src\n-}\n-\n-/// Disposes of a value.\n-///\n-/// This does call the argument's implementation of [`Drop`][drop].\n-///\n-/// This effectively does nothing for types which implement `Copy`, e.g.\n-/// integers. Such values are copied and _then_ moved into the function, so the\n-/// value persists after this function call.\n-///\n-/// This function is not magic; it is literally defined as\n-///\n-/// ```\n-/// pub fn drop<T>(_x: T) { }\n-/// ```\n-///\n-/// Because `_x` is moved into the function, it is automatically dropped before\n-/// the function returns.\n-///\n-/// [drop]: ../ops/trait.Drop.html\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// let v = vec![1, 2, 3];\n-///\n-/// drop(v); // explicitly drop the vector\n-/// ```\n-///\n-/// Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n-/// release a [`RefCell`] borrow:\n-///\n-/// ```\n-/// use std::cell::RefCell;\n-///\n-/// let x = RefCell::new(1);\n-///\n-/// let mut mutable_borrow = x.borrow_mut();\n-/// *mutable_borrow = 1;\n-///\n-/// drop(mutable_borrow); // relinquish the mutable borrow on this slot\n-///\n-/// let borrow = x.borrow();\n-/// println!(\"{}\", *borrow);\n-/// ```\n-///\n-/// Integers and other types implementing [`Copy`] are unaffected by `drop`.\n-///\n-/// ```\n-/// #[derive(Copy, Clone)]\n-/// struct Foo(u8);\n-///\n-/// let x = 1;\n-/// let y = Foo(2);\n-/// drop(x); // a copy of `x` is moved and dropped\n-/// drop(y); // a copy of `y` is moved and dropped\n-///\n-/// println!(\"x: {}, y: {}\", x, y.0); // still available\n-/// ```\n-///\n-/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n-/// [`Copy`]: ../../std/marker/trait.Copy.html\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn drop<T>(_x: T) { }\n-\n-/// Interprets `src` as having type `&U`, and then reads `src` without moving\n-/// the contained value.\n-///\n-/// This function will unsafely assume the pointer `src` is valid for\n-/// [`size_of::<U>`][size_of] bytes by transmuting `&T` to `&U` and then reading\n-/// the `&U`. It will also unsafely create a copy of the contained value instead of\n-/// moving out of `src`.\n-///\n-/// It is not a compile-time error if `T` and `U` have different sizes, but it\n-/// is highly encouraged to only invoke this function where `T` and `U` have the\n-/// same size. This function triggers [undefined behavior][ub] if `U` is larger than\n-/// `T`.\n-///\n-/// [ub]: ../../reference/behavior-considered-undefined.html\n-/// [size_of]: fn.size_of.html\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// #[repr(packed)]\n-/// struct Foo {\n-///     bar: u8,\n-/// }\n-///\n-/// let foo_slice = [10u8];\n-///\n-/// unsafe {\n-///     // Copy the data from 'foo_slice' and treat it as a 'Foo'\n-///     let mut foo_struct: Foo = mem::transmute_copy(&foo_slice);\n-///     assert_eq!(foo_struct.bar, 10);\n-///\n-///     // Modify the copied data\n-///     foo_struct.bar = 20;\n-///     assert_eq!(foo_struct.bar, 20);\n-/// }\n-///\n-/// // The contents of 'foo_slice' should not have changed\n-/// assert_eq!(foo_slice, [10]);\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n-    ptr::read_unaligned(src as *const T as *const U)\n-}\n-\n-/// Opaque type representing the discriminant of an enum.\n-///\n-/// See the [`discriminant`] function in this module for more information.\n-///\n-/// [`discriminant`]: fn.discriminant.html\n-#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-pub struct Discriminant<T>(u64, PhantomData<fn() -> T>);\n-\n-// N.B. These trait implementations cannot be derived because we don't want any bounds on T.\n-\n-#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-impl<T> Copy for Discriminant<T> {}\n-\n-#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-impl<T> clone::Clone for Discriminant<T> {\n-    fn clone(&self) -> Self {\n-        *self\n-    }\n-}\n-\n-#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-impl<T> cmp::PartialEq for Discriminant<T> {\n-    fn eq(&self, rhs: &Self) -> bool {\n-        self.0 == rhs.0\n-    }\n-}\n-\n-#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-impl<T> cmp::Eq for Discriminant<T> {}\n-\n-#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-impl<T> hash::Hash for Discriminant<T> {\n-    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n-        self.0.hash(state);\n-    }\n-}\n-\n-#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-impl<T> fmt::Debug for Discriminant<T> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt.debug_tuple(\"Discriminant\")\n-           .field(&self.0)\n-           .finish()\n-    }\n-}\n-\n-/// Returns a value uniquely identifying the enum variant in `v`.\n-///\n-/// If `T` is not an enum, calling this function will not result in undefined behavior, but the\n-/// return value is unspecified.\n-///\n-/// # Stability\n-///\n-/// The discriminant of an enum variant may change if the enum definition changes. A discriminant\n-/// of some variant will not change between compilations with the same compiler.\n-///\n-/// # Examples\n-///\n-/// This can be used to compare enums that carry data, while disregarding\n-/// the actual data:\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// enum Foo { A(&'static str), B(i32), C(i32) }\n-///\n-/// assert!(mem::discriminant(&Foo::A(\"bar\")) == mem::discriminant(&Foo::A(\"baz\")));\n-/// assert!(mem::discriminant(&Foo::B(1))     == mem::discriminant(&Foo::B(2)));\n-/// assert!(mem::discriminant(&Foo::B(3))     != mem::discriminant(&Foo::C(3)));\n-/// ```\n-#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-pub fn discriminant<T>(v: &T) -> Discriminant<T> {\n-    unsafe {\n-        Discriminant(intrinsics::discriminant_value(v), PhantomData)\n-    }\n-}\n-\n-/// A wrapper to inhibit compiler from automatically calling `T`\u2019s destructor.\n-///\n-/// This wrapper is 0-cost.\n-///\n-/// `ManuallyDrop<T>` is subject to the same layout optimizations as `T`.\n-/// As a consequence, it has *no effect* on the assumptions that the compiler makes\n-/// about all values being initialized at their type.  In particular, initializing\n-/// a `ManuallyDrop<&mut T>` with [`mem::zeroed`] is undefined behavior.\n-/// If you need to handle uninitialized data, use [`MaybeUninit<T>`] instead.\n-///\n-/// # Examples\n-///\n-/// This wrapper helps with explicitly documenting the drop order dependencies between fields of\n-/// the type:\n-///\n-/// ```rust\n-/// use std::mem::ManuallyDrop;\n-/// struct Peach;\n-/// struct Banana;\n-/// struct Melon;\n-/// struct FruitBox {\n-///     // Immediately clear there\u2019s something non-trivial going on with these fields.\n-///     peach: ManuallyDrop<Peach>,\n-///     melon: Melon, // Field that\u2019s independent of the other two.\n-///     banana: ManuallyDrop<Banana>,\n-/// }\n-///\n-/// impl Drop for FruitBox {\n-///     fn drop(&mut self) {\n-///         unsafe {\n-///             // Explicit ordering in which field destructors are run specified in the intuitive\n-///             // location \u2013 the destructor of the structure containing the fields.\n-///             // Moreover, one can now reorder fields within the struct however much they want.\n-///             ManuallyDrop::drop(&mut self.peach);\n-///             ManuallyDrop::drop(&mut self.banana);\n-///         }\n-///         // After destructor for `FruitBox` runs (this function), the destructor for Melon gets\n-///         // invoked in the usual manner, as it is not wrapped in `ManuallyDrop`.\n-///     }\n-/// }\n-/// ```\n-///\n-/// [`mem::zeroed`]: fn.zeroed.html\n-/// [`MaybeUninit<T>`]: union.MaybeUninit.html\n-#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-#[lang = \"manually_drop\"]\n-#[derive(Copy, Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-#[repr(transparent)]\n-pub struct ManuallyDrop<T: ?Sized> {\n-    value: T,\n-}\n-\n-impl<T> ManuallyDrop<T> {\n-    /// Wrap a value to be manually dropped.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// use std::mem::ManuallyDrop;\n-    /// ManuallyDrop::new(Box::new(()));\n-    /// ```\n-    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-    #[inline(always)]\n-    pub const fn new(value: T) -> ManuallyDrop<T> {\n-        ManuallyDrop { value }\n-    }\n-\n-    /// Extracts the value from the `ManuallyDrop` container.\n-    ///\n-    /// This allows the value to be dropped again.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// use std::mem::ManuallyDrop;\n-    /// let x = ManuallyDrop::new(Box::new(()));\n-    /// let _: Box<()> = ManuallyDrop::into_inner(x); // This drops the `Box`.\n-    /// ```\n-    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-    #[inline(always)]\n-    pub const fn into_inner(slot: ManuallyDrop<T>) -> T {\n-        slot.value\n-    }\n-\n-    /// Takes the contained value out.\n-    ///\n-    /// This method is primarily intended for moving out values in drop.\n-    /// Instead of using [`ManuallyDrop::drop`] to manually drop the value,\n-    /// you can use this method to take the value and use it however desired.\n-    /// `Drop` will be invoked on the returned value following normal end-of-scope rules.\n-    ///\n-    /// If you have ownership of the container, you can use [`ManuallyDrop::into_inner`] instead.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function semantically moves out the contained value without preventing further usage.\n-    /// It is up to the user of this method to ensure that this container is not used again.\n-    ///\n-    /// [`ManuallyDrop::drop`]: #method.drop\n-    /// [`ManuallyDrop::into_inner`]: #method.into_inner\n-    #[must_use = \"if you don't need the value, you can use `ManuallyDrop::drop` instead\"]\n-    #[unstable(feature = \"manually_drop_take\", issue = \"55422\")]\n-    #[inline]\n-    pub unsafe fn take(slot: &mut ManuallyDrop<T>) -> T {\n-        ManuallyDrop::into_inner(ptr::read(slot))\n-    }\n-}\n-\n-impl<T: ?Sized> ManuallyDrop<T> {\n-    /// Manually drops the contained value.\n-    ///\n-    /// If you have ownership of the value, you can use [`ManuallyDrop::into_inner`] instead.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function runs the destructor of the contained value and thus the wrapped value\n-    /// now represents uninitialized data. It is up to the user of this method to ensure the\n-    /// uninitialized data is not actually used.\n-    ///\n-    /// [`ManuallyDrop::into_inner`]: #method.into_inner\n-    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-    #[inline]\n-    pub unsafe fn drop(slot: &mut ManuallyDrop<T>) {\n-        ptr::drop_in_place(&mut slot.value)\n-    }\n-}\n-\n-#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-impl<T: ?Sized> Deref for ManuallyDrop<T> {\n-    type Target = T;\n-    #[inline(always)]\n-    fn deref(&self) -> &T {\n-        &self.value\n-    }\n-}\n-\n-#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n-    #[inline(always)]\n-    fn deref_mut(&mut self) -> &mut T {\n-        &mut self.value\n-    }\n-}\n-\n-/// A wrapper type to construct uninitialized instances of `T`.\n-///\n-/// # Initialization invariant\n-///\n-/// The compiler, in general, assumes that variables are properly initialized\n-/// at their respective type. For example, a variable of reference type must\n-/// be aligned and non-NULL. This is an invariant that must *always* be upheld,\n-/// even in unsafe code. As a consequence, zero-initializing a variable of reference\n-/// type causes instantaneous [undefined behavior][ub], no matter whether that reference\n-/// ever gets used to access memory:\n-///\n-/// ```rust,no_run\n-/// use std::mem::{self, MaybeUninit};\n-///\n-/// let x: &i32 = unsafe { mem::zeroed() }; // undefined behavior!\n-/// // The equivalent code with `MaybeUninit<&i32>`:\n-/// let x: &i32 = unsafe { MaybeUninit::zeroed().assume_init() }; // undefined behavior!\n-/// ```\n-///\n-/// This is exploited by the compiler for various optimizations, such as eliding\n-/// run-time checks and optimizing `enum` layout.\n-///\n-/// Similarly, entirely uninitialized memory may have any content, while a `bool` must\n-/// always be `true` or `false`. Hence, creating an uninitialized `bool` is undefined behavior:\n-///\n-/// ```rust,no_run\n-/// use std::mem::{self, MaybeUninit};\n-///\n-/// let b: bool = unsafe { mem::uninitialized() }; // undefined behavior!\n-/// // The equivalent code with `MaybeUninit<bool>`:\n-/// let b: bool = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior!\n-/// ```\n-///\n-/// Moreover, uninitialized memory is special in that the compiler knows that\n-/// it does not have a fixed value. This makes it undefined behavior to have\n-/// uninitialized data in a variable even if that variable has an integer type,\n-/// which otherwise can hold any *fixed* bit pattern:\n-///\n-/// ```rust,no_run\n-/// use std::mem::{self, MaybeUninit};\n-///\n-/// let x: i32 = unsafe { mem::uninitialized() }; // undefined behavior!\n-/// // The equivalent code with `MaybeUninit<i32>`:\n-/// let x: i32 = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior!\n-/// ```\n-/// (Notice that the rules around uninitialized integers are not finalized yet, but\n-/// until they are, it is advisable to avoid them.)\n-///\n-/// On top of that, remember that most types have additional invariants beyond merely\n-/// being considered initialized at the type level. For example, a `1`-initialized [`Vec<T>`]\n-/// is considered initialized because the only requirement the compiler knows about it\n-/// is that the data pointer must be non-null. Creating such a `Vec<T>` does not cause\n-/// *immediate* undefined behavior, but will cause undefined behavior with most\n-/// safe operations (including dropping it).\n-///\n-/// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n-///\n-/// # Examples\n-///\n-/// `MaybeUninit<T>` serves to enable unsafe code to deal with uninitialized data.\n-/// It is a signal to the compiler indicating that the data here might *not*\n-/// be initialized:\n-///\n-/// ```rust\n-/// use std::mem::MaybeUninit;\n-///\n-/// // Create an explicitly uninitialized reference. The compiler knows that data inside\n-/// // a `MaybeUninit<T>` may be invalid, and hence this is not UB:\n-/// let mut x = MaybeUninit::<&i32>::uninit();\n-/// // Set it to a valid value.\n-/// unsafe { x.as_mut_ptr().write(&0); }\n-/// // Extract the initialized data -- this is only allowed *after* properly\n-/// // initializing `x`!\n-/// let x = unsafe { x.assume_init() };\n-/// ```\n-///\n-/// The compiler then knows to not make any incorrect assumptions or optimizations on this code.\n-///\n-/// You can think of `MaybeUninit<T>` as being a bit like `Option<T>` but without\n-/// any of the run-time tracking and without any of the safety checks.\n-///\n-/// ## out-pointers\n-///\n-/// You can use `MaybeUninit<T>` to implement \"out-pointers\": instead of returning data\n-/// from a function, pass it a pointer to some (uninitialized) memory to put the\n-/// result into. This can be useful when it is important for the caller to control\n-/// how the memory the result is stored in gets allocated, and you want to avoid\n-/// unnecessary moves.\n-///\n-/// ```\n-/// use std::mem::MaybeUninit;\n-///\n-/// unsafe fn make_vec(out: *mut Vec<i32>) {\n-///     // `write` does not drop the old contents, which is important.\n-///     out.write(vec![1, 2, 3]);\n-/// }\n-///\n-/// let mut v = MaybeUninit::uninit();\n-/// unsafe { make_vec(v.as_mut_ptr()); }\n-/// // Now we know `v` is initialized! This also makes sure the vector gets\n-/// // properly dropped.\n-/// let v = unsafe { v.assume_init() };\n-/// assert_eq!(&v, &[1, 2, 3]);\n-/// ```\n-///\n-/// ## Initializing an array element-by-element\n-///\n-/// `MaybeUninit<T>` can be used to initialize a large array element-by-element:\n-///\n-/// ```\n-/// use std::mem::{self, MaybeUninit};\n-/// use std::ptr;\n-///\n-/// let data = {\n-///     // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n-///     // safe because the type we are claiming to have initialized here is a\n-///     // bunch of `MaybeUninit`s, which do not require initialization.\n-///     let mut data: [MaybeUninit<Vec<u32>>; 1000] = unsafe {\n-///         MaybeUninit::uninit().assume_init()\n-///     };\n-///\n-///     // Dropping a `MaybeUninit` does nothing, so if there is a panic during this loop,\n-///     // we have a memory leak, but there is no memory safety issue.\n-///     for elem in &mut data[..] {\n-///         unsafe { ptr::write(elem.as_mut_ptr(), vec![42]); }\n-///     }\n-///\n-///     // Everything is initialized. Transmute the array to the\n-///     // initialized type.\n-///     unsafe { mem::transmute::<_, [Vec<u32>; 1000]>(data) }\n-/// };\n-///\n-/// assert_eq!(&data[0], &[42]);\n-/// ```\n-///\n-/// You can also work with partially initialized arrays, which could\n-/// be found in low-level datastructures.\n-///\n-/// ```\n-/// use std::mem::MaybeUninit;\n-/// use std::ptr;\n-///\n-/// // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n-/// // safe because the type we are claiming to have initialized here is a\n-/// // bunch of `MaybeUninit`s, which do not require initialization.\n-/// let mut data: [MaybeUninit<String>; 1000] = unsafe { MaybeUninit::uninit().assume_init() };\n-/// // Count the number of elements we have assigned.\n-/// let mut data_len: usize = 0;\n-///\n-/// for elem in &mut data[0..500] {\n-///     unsafe { ptr::write(elem.as_mut_ptr(), String::from(\"hello\")); }\n-///     data_len += 1;\n-/// }\n-///\n-/// // For each item in the array, drop if we allocated it.\n-/// for elem in &mut data[0..data_len] {\n-///     unsafe { ptr::drop_in_place(elem.as_mut_ptr()); }\n-/// }\n-/// ```\n-///\n-/// ## Initializing a struct field-by-field\n-///\n-/// There is currently no supported way to create a raw pointer or reference\n-/// to a field of a struct inside `MaybeUninit<Struct>`. That means it is not possible\n-/// to create a struct by calling `MaybeUninit::uninit::<Struct>()` and then writing\n-/// to its fields.\n-///\n-/// [ub]: ../../reference/behavior-considered-undefined.html\n-///\n-/// # Layout\n-///\n-/// `MaybeUninit<T>` is guaranteed to have the same size and alignment as `T`:\n-///\n-/// ```rust\n-/// use std::mem::{MaybeUninit, size_of, align_of};\n-/// assert_eq!(size_of::<MaybeUninit<u64>>(), size_of::<u64>());\n-/// assert_eq!(align_of::<MaybeUninit<u64>>(), align_of::<u64>());\n-/// ```\n-///\n-/// However remember that a type *containing* a `MaybeUninit<T>` is not necessarily the same\n-/// layout; Rust does not in general guarantee that the fields of a `Foo<T>` have the same order as\n-/// a `Foo<U>` even if `T` and `U` have the same size and alignment. Furthermore because any bit\n-/// value is valid for a `MaybeUninit<T>` the compiler can't apply non-zero/niche-filling\n-/// optimizations, potentially resulting in a larger size:\n-///\n-/// ```rust\n-/// # use std::mem::{MaybeUninit, size_of};\n-/// assert_eq!(size_of::<Option<bool>>(), 1);\n-/// assert_eq!(size_of::<Option<MaybeUninit<bool>>>(), 2);\n-/// ```\n-#[allow(missing_debug_implementations)]\n-#[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n-#[derive(Copy)]\n-pub union MaybeUninit<T> {\n-    uninit: (),\n-    value: ManuallyDrop<T>,\n-}\n-\n-#[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n-impl<T: Copy> Clone for MaybeUninit<T> {\n-    #[inline(always)]\n-    fn clone(&self) -> Self {\n-        // Not calling `T::clone()`, we cannot know if we are initialized enough for that.\n-        *self\n-    }\n-}\n-\n-impl<T> MaybeUninit<T> {\n-    /// Creates a new `MaybeUninit<T>` initialized with the given value.\n-    /// It is safe to call [`assume_init`] on the return value of this function.\n-    ///\n-    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n-    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n-    ///\n-    /// [`assume_init`]: #method.assume_init\n-    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n-    #[inline(always)]\n-    pub const fn new(val: T) -> MaybeUninit<T> {\n-        MaybeUninit { value: ManuallyDrop::new(val) }\n-    }\n-\n-    /// Creates a new `MaybeUninit<T>` in an uninitialized state.\n-    ///\n-    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n-    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n-    ///\n-    /// See the [type-level documentation][type] for some examples.\n-    ///\n-    /// [type]: union.MaybeUninit.html\n-    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n-    #[inline(always)]\n-    pub const fn uninit() -> MaybeUninit<T> {\n-        MaybeUninit { uninit: () }\n-    }\n-\n-    /// Creates a new `MaybeUninit<T>` in an uninitialized state, with the memory being\n-    /// filled with `0` bytes. It depends on `T` whether that already makes for\n-    /// proper initialization. For example, `MaybeUninit<usize>::zeroed()` is initialized,\n-    /// but `MaybeUninit<&'static i32>::zeroed()` is not because references must not\n-    /// be null.\n-    ///\n-    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n-    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n-    ///\n-    /// # Example\n-    ///\n-    /// Correct usage of this function: initializing a struct with zero, where all\n-    /// fields of the struct can hold the bit-pattern 0 as a valid value.\n-    ///\n-    /// ```rust\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// let x = MaybeUninit::<(u8, bool)>::zeroed();\n-    /// let x = unsafe { x.assume_init() };\n-    /// assert_eq!(x, (0, false));\n-    /// ```\n-    ///\n-    /// *Incorrect* usage of this function: initializing a struct with zero, where some fields\n-    /// cannot hold 0 as a valid value.\n-    ///\n-    /// ```rust,no_run\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// enum NotZero { One = 1, Two = 2 };\n-    ///\n-    /// let x = MaybeUninit::<(u8, NotZero)>::zeroed();\n-    /// let x = unsafe { x.assume_init() };\n-    /// // Inside a pair, we create a `NotZero` that does not have a valid discriminant.\n-    /// // This is undefined behavior.\n-    /// ```\n-    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n-    #[inline]\n-    pub fn zeroed() -> MaybeUninit<T> {\n-        let mut u = MaybeUninit::<T>::uninit();\n-        unsafe {\n-            u.as_mut_ptr().write_bytes(0u8, 1);\n-        }\n-        u\n-    }\n-\n-    /// Sets the value of the `MaybeUninit<T>`. This overwrites any previous value\n-    /// without dropping it, so be careful not to use this twice unless you want to\n-    /// skip running the destructor. For your convenience, this also returns a mutable\n-    /// reference to the (now safely initialized) contents of `self`.\n-    #[unstable(feature = \"maybe_uninit_extra\", issue = \"53491\")]\n-    #[inline(always)]\n-    pub fn write(&mut self, val: T) -> &mut T {\n-        unsafe {\n-            self.value = ManuallyDrop::new(val);\n-            self.get_mut()\n-        }\n-    }\n-\n-    /// Gets a pointer to the contained value. Reading from this pointer or turning it\n-    /// into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n-    /// Writing to memory that this pointer (non-transitively) points to is undefined behavior\n-    /// (except inside an `UnsafeCell<T>`).\n-    ///\n-    /// # Examples\n-    ///\n-    /// Correct usage of this method:\n-    ///\n-    /// ```rust\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n-    /// unsafe { x.as_mut_ptr().write(vec![0,1,2]); }\n-    /// // Create a reference into the `MaybeUninit<T>`. This is okay because we initialized it.\n-    /// let x_vec = unsafe { &*x.as_ptr() };\n-    /// assert_eq!(x_vec.len(), 3);\n-    /// ```\n-    ///\n-    /// *Incorrect* usage of this method:\n-    ///\n-    /// ```rust,no_run\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// let x = MaybeUninit::<Vec<u32>>::uninit();\n-    /// let x_vec = unsafe { &*x.as_ptr() };\n-    /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n-    /// ```\n-    ///\n-    /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n-    /// until they are, it is advisable to avoid them.)\n-    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n-    #[inline(always)]\n-    pub fn as_ptr(&self) -> *const T {\n-        unsafe { &*self.value as *const T }\n-    }\n-\n-    /// Gets a mutable pointer to the contained value. Reading from this pointer or turning it\n-    /// into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Correct usage of this method:\n-    ///\n-    /// ```rust\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n-    /// unsafe { x.as_mut_ptr().write(vec![0,1,2]); }\n-    /// // Create a reference into the `MaybeUninit<Vec<u32>>`.\n-    /// // This is okay because we initialized it.\n-    /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n-    /// x_vec.push(3);\n-    /// assert_eq!(x_vec.len(), 4);\n-    /// ```\n-    ///\n-    /// *Incorrect* usage of this method:\n-    ///\n-    /// ```rust,no_run\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n-    /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n-    /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n-    /// ```\n-    ///\n-    /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n-    /// until they are, it is advisable to avoid them.)\n-    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n-    #[inline(always)]\n-    pub fn as_mut_ptr(&mut self) -> *mut T {\n-        unsafe { &mut *self.value as *mut T }\n-    }\n-\n-    /// Extracts the value from the `MaybeUninit<T>` container. This is a great way\n-    /// to ensure that the data will get dropped, because the resulting `T` is\n-    /// subject to the usual drop handling.\n-    ///\n-    /// # Safety\n-    ///\n-    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n-    /// state. Calling this when the content is not yet fully initialized causes immediate undefined\n-    /// behavior. The [type-level documentation][inv] contains more information about\n-    /// this initialization invariant.\n-    ///\n-    /// [inv]: #initialization-invariant\n-    ///\n-    /// # Examples\n-    ///\n-    /// Correct usage of this method:\n-    ///\n-    /// ```rust\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// let mut x = MaybeUninit::<bool>::uninit();\n-    /// unsafe { x.as_mut_ptr().write(true); }\n-    /// let x_init = unsafe { x.assume_init() };\n-    /// assert_eq!(x_init, true);\n-    /// ```\n-    ///\n-    /// *Incorrect* usage of this method:\n-    ///\n-    /// ```rust,no_run\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// let x = MaybeUninit::<Vec<u32>>::uninit();\n-    /// let x_init = unsafe { x.assume_init() };\n-    /// // `x` had not been initialized yet, so this last line caused undefined behavior.\n-    /// ```\n-    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n-    #[inline(always)]\n-    pub unsafe fn assume_init(self) -> T {\n-        intrinsics::panic_if_uninhabited::<T>();\n-        ManuallyDrop::into_inner(self.value)\n-    }\n-\n-    /// Reads the value from the `MaybeUninit<T>` container. The resulting `T` is subject\n-    /// to the usual drop handling.\n-    ///\n-    /// Whenever possible, it is preferrable to use [`assume_init`] instead, which\n-    /// prevents duplicating the content of the `MaybeUninit<T>`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n-    /// state. Calling this when the content is not yet fully initialized causes undefined\n-    /// behavior. The [type-level documentation][inv] contains more information about\n-    /// this initialization invariant.\n-    ///\n-    /// Moreover, this leaves a copy of the same data behind in the `MaybeUninit<T>`. When using\n-    /// multiple copies of the data (by calling `read` multiple times, or first\n-    /// calling `read` and then [`assume_init`]), it is your responsibility\n-    /// to ensure that that data may indeed be duplicated.\n-    ///\n-    /// [inv]: #initialization-invariant\n-    /// [`assume_init`]: #method.assume_init\n-    ///\n-    /// # Examples\n-    ///\n-    /// Correct usage of this method:\n-    ///\n-    /// ```rust\n-    /// #![feature(maybe_uninit_extra)]\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// let mut x = MaybeUninit::<u32>::uninit();\n-    /// x.write(13);\n-    /// let x1 = unsafe { x.read() };\n-    /// // `u32` is `Copy`, so we may read multiple times.\n-    /// let x2 = unsafe { x.read() };\n-    /// assert_eq!(x1, x2);\n-    ///\n-    /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n-    /// x.write(None);\n-    /// let x1 = unsafe { x.read() };\n-    /// // Duplicating a `None` value is okay, so we may read multiple times.\n-    /// let x2 = unsafe { x.read() };\n-    /// assert_eq!(x1, x2);\n-    /// ```\n-    ///\n-    /// *Incorrect* usage of this method:\n-    ///\n-    /// ```rust,no_run\n-    /// #![feature(maybe_uninit_extra)]\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n-    /// x.write(Some(vec![0,1,2]));\n-    /// let x1 = unsafe { x.read() };\n-    /// let x2 = unsafe { x.read() };\n-    /// // We now created two copies of the same vector, leading to a double-free when\n-    /// // they both get dropped!\n-    /// ```\n-    #[unstable(feature = \"maybe_uninit_extra\", issue = \"53491\")]\n-    #[inline(always)]\n-    pub unsafe fn read(&self) -> T {\n-        intrinsics::panic_if_uninhabited::<T>();\n-        self.as_ptr().read()\n-    }\n-\n-    /// Gets a reference to the contained value.\n-    ///\n-    /// # Safety\n-    ///\n-    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n-    /// state. Calling this when the content is not yet fully initialized causes undefined\n-    /// behavior.\n-    #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n-    #[inline(always)]\n-    pub unsafe fn get_ref(&self) -> &T {\n-        &*self.value\n-    }\n-\n-    /// Gets a mutable reference to the contained value.\n-    ///\n-    /// # Safety\n-    ///\n-    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n-    /// state. Calling this when the content is not yet fully initialized causes undefined\n-    /// behavior.\n-    // FIXME(#53491): We currently rely on the above being incorrect, i.e., we have references\n-    // to uninitialized data (e.g., in `libcore/fmt/float.rs`).  We should make\n-    // a final decision about the rules before stabilization.\n-    #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n-    #[inline(always)]\n-    pub unsafe fn get_mut(&mut self) -> &mut T {\n-        &mut *self.value\n-    }\n-\n-    /// Gets a pointer to the first element of the array.\n-    #[unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")]\n-    #[inline(always)]\n-    pub fn first_ptr(this: &[MaybeUninit<T>]) -> *const T {\n-        this as *const [MaybeUninit<T>] as *const T\n-    }\n-\n-    /// Gets a mutable pointer to the first element of the array.\n-    #[unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")]\n-    #[inline(always)]\n-    pub fn first_ptr_mut(this: &mut [MaybeUninit<T>]) -> *mut T {\n-        this as *mut [MaybeUninit<T>] as *mut T\n-    }\n-}"}, {"sha": "3ad1223e331ece91ca1b996e2e87bcc94c3e5786", "filename": "src/libcore/mem/manually_drop.rs", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmanually_drop.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -0,0 +1,146 @@\n+use crate::ptr;\n+use crate::ops::{Deref, DerefMut};\n+\n+/// A wrapper to inhibit compiler from automatically calling `T`\u2019s destructor.\n+///\n+/// This wrapper is 0-cost.\n+///\n+/// `ManuallyDrop<T>` is subject to the same layout optimizations as `T`.\n+/// As a consequence, it has *no effect* on the assumptions that the compiler makes\n+/// about all values being initialized at their type.  In particular, initializing\n+/// a `ManuallyDrop<&mut T>` with [`mem::zeroed`] is undefined behavior.\n+/// If you need to handle uninitialized data, use [`MaybeUninit<T>`] instead.\n+///\n+/// # Examples\n+///\n+/// This wrapper helps with explicitly documenting the drop order dependencies between fields of\n+/// the type:\n+///\n+/// ```rust\n+/// use std::mem::ManuallyDrop;\n+/// struct Peach;\n+/// struct Banana;\n+/// struct Melon;\n+/// struct FruitBox {\n+///     // Immediately clear there\u2019s something non-trivial going on with these fields.\n+///     peach: ManuallyDrop<Peach>,\n+///     melon: Melon, // Field that\u2019s independent of the other two.\n+///     banana: ManuallyDrop<Banana>,\n+/// }\n+///\n+/// impl Drop for FruitBox {\n+///     fn drop(&mut self) {\n+///         unsafe {\n+///             // Explicit ordering in which field destructors are run specified in the intuitive\n+///             // location \u2013 the destructor of the structure containing the fields.\n+///             // Moreover, one can now reorder fields within the struct however much they want.\n+///             ManuallyDrop::drop(&mut self.peach);\n+///             ManuallyDrop::drop(&mut self.banana);\n+///         }\n+///         // After destructor for `FruitBox` runs (this function), the destructor for Melon gets\n+///         // invoked in the usual manner, as it is not wrapped in `ManuallyDrop`.\n+///     }\n+/// }\n+/// ```\n+///\n+/// [`mem::zeroed`]: fn.zeroed.html\n+/// [`MaybeUninit<T>`]: union.MaybeUninit.html\n+#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+#[lang = \"manually_drop\"]\n+#[derive(Copy, Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[repr(transparent)]\n+pub struct ManuallyDrop<T: ?Sized> {\n+    value: T,\n+}\n+\n+impl<T> ManuallyDrop<T> {\n+    /// Wrap a value to be manually dropped.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// use std::mem::ManuallyDrop;\n+    /// ManuallyDrop::new(Box::new(()));\n+    /// ```\n+    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+    #[inline(always)]\n+    pub const fn new(value: T) -> ManuallyDrop<T> {\n+        ManuallyDrop { value }\n+    }\n+\n+    /// Extracts the value from the `ManuallyDrop` container.\n+    ///\n+    /// This allows the value to be dropped again.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// use std::mem::ManuallyDrop;\n+    /// let x = ManuallyDrop::new(Box::new(()));\n+    /// let _: Box<()> = ManuallyDrop::into_inner(x); // This drops the `Box`.\n+    /// ```\n+    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+    #[inline(always)]\n+    pub const fn into_inner(slot: ManuallyDrop<T>) -> T {\n+        slot.value\n+    }\n+\n+    /// Takes the contained value out.\n+    ///\n+    /// This method is primarily intended for moving out values in drop.\n+    /// Instead of using [`ManuallyDrop::drop`] to manually drop the value,\n+    /// you can use this method to take the value and use it however desired.\n+    /// `Drop` will be invoked on the returned value following normal end-of-scope rules.\n+    ///\n+    /// If you have ownership of the container, you can use [`ManuallyDrop::into_inner`] instead.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function semantically moves out the contained value without preventing further usage.\n+    /// It is up to the user of this method to ensure that this container is not used again.\n+    ///\n+    /// [`ManuallyDrop::drop`]: #method.drop\n+    /// [`ManuallyDrop::into_inner`]: #method.into_inner\n+    #[must_use = \"if you don't need the value, you can use `ManuallyDrop::drop` instead\"]\n+    #[unstable(feature = \"manually_drop_take\", issue = \"55422\")]\n+    #[inline]\n+    pub unsafe fn take(slot: &mut ManuallyDrop<T>) -> T {\n+        ManuallyDrop::into_inner(ptr::read(slot))\n+    }\n+}\n+\n+impl<T: ?Sized> ManuallyDrop<T> {\n+    /// Manually drops the contained value.\n+    ///\n+    /// If you have ownership of the value, you can use [`ManuallyDrop::into_inner`] instead.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function runs the destructor of the contained value and thus the wrapped value\n+    /// now represents uninitialized data. It is up to the user of this method to ensure the\n+    /// uninitialized data is not actually used.\n+    ///\n+    /// [`ManuallyDrop::into_inner`]: #method.into_inner\n+    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+    #[inline]\n+    pub unsafe fn drop(slot: &mut ManuallyDrop<T>) {\n+        ptr::drop_in_place(&mut slot.value)\n+    }\n+}\n+\n+#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+impl<T: ?Sized> Deref for ManuallyDrop<T> {\n+    type Target = T;\n+    #[inline(always)]\n+    fn deref(&self) -> &T {\n+        &self.value\n+    }\n+}\n+\n+#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n+    #[inline(always)]\n+    fn deref_mut(&mut self) -> &mut T {\n+        &mut self.value\n+    }\n+}"}, {"sha": "eeff9d0303a3b83f8b96e3c10248ae8ea115a45b", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "added", "additions": 519, "deletions": 0, "changes": 519, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -0,0 +1,519 @@\n+use crate::intrinsics;\n+use crate::mem::ManuallyDrop;\n+\n+/// A wrapper type to construct uninitialized instances of `T`.\n+///\n+/// # Initialization invariant\n+///\n+/// The compiler, in general, assumes that variables are properly initialized\n+/// at their respective type. For example, a variable of reference type must\n+/// be aligned and non-NULL. This is an invariant that must *always* be upheld,\n+/// even in unsafe code. As a consequence, zero-initializing a variable of reference\n+/// type causes instantaneous [undefined behavior][ub], no matter whether that reference\n+/// ever gets used to access memory:\n+///\n+/// ```rust,no_run\n+/// use std::mem::{self, MaybeUninit};\n+///\n+/// let x: &i32 = unsafe { mem::zeroed() }; // undefined behavior!\n+/// // The equivalent code with `MaybeUninit<&i32>`:\n+/// let x: &i32 = unsafe { MaybeUninit::zeroed().assume_init() }; // undefined behavior!\n+/// ```\n+///\n+/// This is exploited by the compiler for various optimizations, such as eliding\n+/// run-time checks and optimizing `enum` layout.\n+///\n+/// Similarly, entirely uninitialized memory may have any content, while a `bool` must\n+/// always be `true` or `false`. Hence, creating an uninitialized `bool` is undefined behavior:\n+///\n+/// ```rust,no_run\n+/// use std::mem::{self, MaybeUninit};\n+///\n+/// let b: bool = unsafe { mem::uninitialized() }; // undefined behavior!\n+/// // The equivalent code with `MaybeUninit<bool>`:\n+/// let b: bool = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior!\n+/// ```\n+///\n+/// Moreover, uninitialized memory is special in that the compiler knows that\n+/// it does not have a fixed value. This makes it undefined behavior to have\n+/// uninitialized data in a variable even if that variable has an integer type,\n+/// which otherwise can hold any *fixed* bit pattern:\n+///\n+/// ```rust,no_run\n+/// use std::mem::{self, MaybeUninit};\n+///\n+/// let x: i32 = unsafe { mem::uninitialized() }; // undefined behavior!\n+/// // The equivalent code with `MaybeUninit<i32>`:\n+/// let x: i32 = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior!\n+/// ```\n+/// (Notice that the rules around uninitialized integers are not finalized yet, but\n+/// until they are, it is advisable to avoid them.)\n+///\n+/// On top of that, remember that most types have additional invariants beyond merely\n+/// being considered initialized at the type level. For example, a `1`-initialized [`Vec<T>`]\n+/// is considered initialized because the only requirement the compiler knows about it\n+/// is that the data pointer must be non-null. Creating such a `Vec<T>` does not cause\n+/// *immediate* undefined behavior, but will cause undefined behavior with most\n+/// safe operations (including dropping it).\n+///\n+/// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n+///\n+/// # Examples\n+///\n+/// `MaybeUninit<T>` serves to enable unsafe code to deal with uninitialized data.\n+/// It is a signal to the compiler indicating that the data here might *not*\n+/// be initialized:\n+///\n+/// ```rust\n+/// use std::mem::MaybeUninit;\n+///\n+/// // Create an explicitly uninitialized reference. The compiler knows that data inside\n+/// // a `MaybeUninit<T>` may be invalid, and hence this is not UB:\n+/// let mut x = MaybeUninit::<&i32>::uninit();\n+/// // Set it to a valid value.\n+/// unsafe { x.as_mut_ptr().write(&0); }\n+/// // Extract the initialized data -- this is only allowed *after* properly\n+/// // initializing `x`!\n+/// let x = unsafe { x.assume_init() };\n+/// ```\n+///\n+/// The compiler then knows to not make any incorrect assumptions or optimizations on this code.\n+///\n+/// You can think of `MaybeUninit<T>` as being a bit like `Option<T>` but without\n+/// any of the run-time tracking and without any of the safety checks.\n+///\n+/// ## out-pointers\n+///\n+/// You can use `MaybeUninit<T>` to implement \"out-pointers\": instead of returning data\n+/// from a function, pass it a pointer to some (uninitialized) memory to put the\n+/// result into. This can be useful when it is important for the caller to control\n+/// how the memory the result is stored in gets allocated, and you want to avoid\n+/// unnecessary moves.\n+///\n+/// ```\n+/// use std::mem::MaybeUninit;\n+///\n+/// unsafe fn make_vec(out: *mut Vec<i32>) {\n+///     // `write` does not drop the old contents, which is important.\n+///     out.write(vec![1, 2, 3]);\n+/// }\n+///\n+/// let mut v = MaybeUninit::uninit();\n+/// unsafe { make_vec(v.as_mut_ptr()); }\n+/// // Now we know `v` is initialized! This also makes sure the vector gets\n+/// // properly dropped.\n+/// let v = unsafe { v.assume_init() };\n+/// assert_eq!(&v, &[1, 2, 3]);\n+/// ```\n+///\n+/// ## Initializing an array element-by-element\n+///\n+/// `MaybeUninit<T>` can be used to initialize a large array element-by-element:\n+///\n+/// ```\n+/// use std::mem::{self, MaybeUninit};\n+/// use std::ptr;\n+///\n+/// let data = {\n+///     // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n+///     // safe because the type we are claiming to have initialized here is a\n+///     // bunch of `MaybeUninit`s, which do not require initialization.\n+///     let mut data: [MaybeUninit<Vec<u32>>; 1000] = unsafe {\n+///         MaybeUninit::uninit().assume_init()\n+///     };\n+///\n+///     // Dropping a `MaybeUninit` does nothing, so if there is a panic during this loop,\n+///     // we have a memory leak, but there is no memory safety issue.\n+///     for elem in &mut data[..] {\n+///         unsafe { ptr::write(elem.as_mut_ptr(), vec![42]); }\n+///     }\n+///\n+///     // Everything is initialized. Transmute the array to the\n+///     // initialized type.\n+///     unsafe { mem::transmute::<_, [Vec<u32>; 1000]>(data) }\n+/// };\n+///\n+/// assert_eq!(&data[0], &[42]);\n+/// ```\n+///\n+/// You can also work with partially initialized arrays, which could\n+/// be found in low-level datastructures.\n+///\n+/// ```\n+/// use std::mem::MaybeUninit;\n+/// use std::ptr;\n+///\n+/// // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n+/// // safe because the type we are claiming to have initialized here is a\n+/// // bunch of `MaybeUninit`s, which do not require initialization.\n+/// let mut data: [MaybeUninit<String>; 1000] = unsafe { MaybeUninit::uninit().assume_init() };\n+/// // Count the number of elements we have assigned.\n+/// let mut data_len: usize = 0;\n+///\n+/// for elem in &mut data[0..500] {\n+///     unsafe { ptr::write(elem.as_mut_ptr(), String::from(\"hello\")); }\n+///     data_len += 1;\n+/// }\n+///\n+/// // For each item in the array, drop if we allocated it.\n+/// for elem in &mut data[0..data_len] {\n+///     unsafe { ptr::drop_in_place(elem.as_mut_ptr()); }\n+/// }\n+/// ```\n+///\n+/// ## Initializing a struct field-by-field\n+///\n+/// There is currently no supported way to create a raw pointer or reference\n+/// to a field of a struct inside `MaybeUninit<Struct>`. That means it is not possible\n+/// to create a struct by calling `MaybeUninit::uninit::<Struct>()` and then writing\n+/// to its fields.\n+///\n+/// [ub]: ../../reference/behavior-considered-undefined.html\n+///\n+/// # Layout\n+///\n+/// `MaybeUninit<T>` is guaranteed to have the same size and alignment as `T`:\n+///\n+/// ```rust\n+/// use std::mem::{MaybeUninit, size_of, align_of};\n+/// assert_eq!(size_of::<MaybeUninit<u64>>(), size_of::<u64>());\n+/// assert_eq!(align_of::<MaybeUninit<u64>>(), align_of::<u64>());\n+/// ```\n+///\n+/// However remember that a type *containing* a `MaybeUninit<T>` is not necessarily the same\n+/// layout; Rust does not in general guarantee that the fields of a `Foo<T>` have the same order as\n+/// a `Foo<U>` even if `T` and `U` have the same size and alignment. Furthermore because any bit\n+/// value is valid for a `MaybeUninit<T>` the compiler can't apply non-zero/niche-filling\n+/// optimizations, potentially resulting in a larger size:\n+///\n+/// ```rust\n+/// # use std::mem::{MaybeUninit, size_of};\n+/// assert_eq!(size_of::<Option<bool>>(), 1);\n+/// assert_eq!(size_of::<Option<MaybeUninit<bool>>>(), 2);\n+/// ```\n+#[allow(missing_debug_implementations)]\n+#[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+#[derive(Copy)]\n+pub union MaybeUninit<T> {\n+    uninit: (),\n+    value: ManuallyDrop<T>,\n+}\n+\n+#[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+impl<T: Copy> Clone for MaybeUninit<T> {\n+    #[inline(always)]\n+    fn clone(&self) -> Self {\n+        // Not calling `T::clone()`, we cannot know if we are initialized enough for that.\n+        *self\n+    }\n+}\n+\n+impl<T> MaybeUninit<T> {\n+    /// Creates a new `MaybeUninit<T>` initialized with the given value.\n+    /// It is safe to call [`assume_init`] on the return value of this function.\n+    ///\n+    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n+    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n+    ///\n+    /// [`assume_init`]: #method.assume_init\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+    #[inline(always)]\n+    pub const fn new(val: T) -> MaybeUninit<T> {\n+        MaybeUninit { value: ManuallyDrop::new(val) }\n+    }\n+\n+    /// Creates a new `MaybeUninit<T>` in an uninitialized state.\n+    ///\n+    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n+    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n+    ///\n+    /// See the [type-level documentation][type] for some examples.\n+    ///\n+    /// [type]: union.MaybeUninit.html\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+    #[inline(always)]\n+    pub const fn uninit() -> MaybeUninit<T> {\n+        MaybeUninit { uninit: () }\n+    }\n+\n+    /// Creates a new `MaybeUninit<T>` in an uninitialized state, with the memory being\n+    /// filled with `0` bytes. It depends on `T` whether that already makes for\n+    /// proper initialization. For example, `MaybeUninit<usize>::zeroed()` is initialized,\n+    /// but `MaybeUninit<&'static i32>::zeroed()` is not because references must not\n+    /// be null.\n+    ///\n+    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n+    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n+    ///\n+    /// # Example\n+    ///\n+    /// Correct usage of this function: initializing a struct with zero, where all\n+    /// fields of the struct can hold the bit-pattern 0 as a valid value.\n+    ///\n+    /// ```rust\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let x = MaybeUninit::<(u8, bool)>::zeroed();\n+    /// let x = unsafe { x.assume_init() };\n+    /// assert_eq!(x, (0, false));\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this function: initializing a struct with zero, where some fields\n+    /// cannot hold 0 as a valid value.\n+    ///\n+    /// ```rust,no_run\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// enum NotZero { One = 1, Two = 2 };\n+    ///\n+    /// let x = MaybeUninit::<(u8, NotZero)>::zeroed();\n+    /// let x = unsafe { x.assume_init() };\n+    /// // Inside a pair, we create a `NotZero` that does not have a valid discriminant.\n+    /// // This is undefined behavior.\n+    /// ```\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+    #[inline]\n+    pub fn zeroed() -> MaybeUninit<T> {\n+        let mut u = MaybeUninit::<T>::uninit();\n+        unsafe {\n+            u.as_mut_ptr().write_bytes(0u8, 1);\n+        }\n+        u\n+    }\n+\n+    /// Sets the value of the `MaybeUninit<T>`. This overwrites any previous value\n+    /// without dropping it, so be careful not to use this twice unless you want to\n+    /// skip running the destructor. For your convenience, this also returns a mutable\n+    /// reference to the (now safely initialized) contents of `self`.\n+    #[unstable(feature = \"maybe_uninit_extra\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub fn write(&mut self, val: T) -> &mut T {\n+        unsafe {\n+            self.value = ManuallyDrop::new(val);\n+            self.get_mut()\n+        }\n+    }\n+\n+    /// Gets a pointer to the contained value. Reading from this pointer or turning it\n+    /// into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n+    /// Writing to memory that this pointer (non-transitively) points to is undefined behavior\n+    /// (except inside an `UnsafeCell<T>`).\n+    ///\n+    /// # Examples\n+    ///\n+    /// Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n+    /// unsafe { x.as_mut_ptr().write(vec![0,1,2]); }\n+    /// // Create a reference into the `MaybeUninit<T>`. This is okay because we initialized it.\n+    /// let x_vec = unsafe { &*x.as_ptr() };\n+    /// assert_eq!(x_vec.len(), 3);\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this method:\n+    ///\n+    /// ```rust,no_run\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let x = MaybeUninit::<Vec<u32>>::uninit();\n+    /// let x_vec = unsafe { &*x.as_ptr() };\n+    /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n+    /// ```\n+    ///\n+    /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n+    /// until they are, it is advisable to avoid them.)\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+    #[inline(always)]\n+    pub fn as_ptr(&self) -> *const T {\n+        unsafe { &*self.value as *const T }\n+    }\n+\n+    /// Gets a mutable pointer to the contained value. Reading from this pointer or turning it\n+    /// into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n+    /// unsafe { x.as_mut_ptr().write(vec![0,1,2]); }\n+    /// // Create a reference into the `MaybeUninit<Vec<u32>>`.\n+    /// // This is okay because we initialized it.\n+    /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n+    /// x_vec.push(3);\n+    /// assert_eq!(x_vec.len(), 4);\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this method:\n+    ///\n+    /// ```rust,no_run\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n+    /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n+    /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n+    /// ```\n+    ///\n+    /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n+    /// until they are, it is advisable to avoid them.)\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+    #[inline(always)]\n+    pub fn as_mut_ptr(&mut self) -> *mut T {\n+        unsafe { &mut *self.value as *mut T }\n+    }\n+\n+    /// Extracts the value from the `MaybeUninit<T>` container. This is a great way\n+    /// to ensure that the data will get dropped, because the resulting `T` is\n+    /// subject to the usual drop handling.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n+    /// state. Calling this when the content is not yet fully initialized causes immediate undefined\n+    /// behavior. The [type-level documentation][inv] contains more information about\n+    /// this initialization invariant.\n+    ///\n+    /// [inv]: #initialization-invariant\n+    ///\n+    /// # Examples\n+    ///\n+    /// Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<bool>::uninit();\n+    /// unsafe { x.as_mut_ptr().write(true); }\n+    /// let x_init = unsafe { x.assume_init() };\n+    /// assert_eq!(x_init, true);\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this method:\n+    ///\n+    /// ```rust,no_run\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let x = MaybeUninit::<Vec<u32>>::uninit();\n+    /// let x_init = unsafe { x.assume_init() };\n+    /// // `x` had not been initialized yet, so this last line caused undefined behavior.\n+    /// ```\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+    #[inline(always)]\n+    pub unsafe fn assume_init(self) -> T {\n+        intrinsics::panic_if_uninhabited::<T>();\n+        ManuallyDrop::into_inner(self.value)\n+    }\n+\n+    /// Reads the value from the `MaybeUninit<T>` container. The resulting `T` is subject\n+    /// to the usual drop handling.\n+    ///\n+    /// Whenever possible, it is preferrable to use [`assume_init`] instead, which\n+    /// prevents duplicating the content of the `MaybeUninit<T>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n+    /// state. Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior. The [type-level documentation][inv] contains more information about\n+    /// this initialization invariant.\n+    ///\n+    /// Moreover, this leaves a copy of the same data behind in the `MaybeUninit<T>`. When using\n+    /// multiple copies of the data (by calling `read` multiple times, or first\n+    /// calling `read` and then [`assume_init`]), it is your responsibility\n+    /// to ensure that that data may indeed be duplicated.\n+    ///\n+    /// [inv]: #initialization-invariant\n+    /// [`assume_init`]: #method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit_extra)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<u32>::uninit();\n+    /// x.write(13);\n+    /// let x1 = unsafe { x.read() };\n+    /// // `u32` is `Copy`, so we may read multiple times.\n+    /// let x2 = unsafe { x.read() };\n+    /// assert_eq!(x1, x2);\n+    ///\n+    /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n+    /// x.write(None);\n+    /// let x1 = unsafe { x.read() };\n+    /// // Duplicating a `None` value is okay, so we may read multiple times.\n+    /// let x2 = unsafe { x.read() };\n+    /// assert_eq!(x1, x2);\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this method:\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit_extra)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n+    /// x.write(Some(vec![0,1,2]));\n+    /// let x1 = unsafe { x.read() };\n+    /// let x2 = unsafe { x.read() };\n+    /// // We now created two copies of the same vector, leading to a double-free when\n+    /// // they both get dropped!\n+    /// ```\n+    #[unstable(feature = \"maybe_uninit_extra\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub unsafe fn read(&self) -> T {\n+        intrinsics::panic_if_uninhabited::<T>();\n+        self.as_ptr().read()\n+    }\n+\n+    /// Gets a reference to the contained value.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n+    /// state. Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior.\n+    #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub unsafe fn get_ref(&self) -> &T {\n+        &*self.value\n+    }\n+\n+    /// Gets a mutable reference to the contained value.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n+    /// state. Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior.\n+    // FIXME(#53491): We currently rely on the above being incorrect, i.e., we have references\n+    // to uninitialized data (e.g., in `libcore/fmt/float.rs`).  We should make\n+    // a final decision about the rules before stabilization.\n+    #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub unsafe fn get_mut(&mut self) -> &mut T {\n+        &mut *self.value\n+    }\n+\n+    /// Gets a pointer to the first element of the array.\n+    #[unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub fn first_ptr(this: &[MaybeUninit<T>]) -> *const T {\n+        this as *const [MaybeUninit<T>] as *const T\n+    }\n+\n+    /// Gets a mutable pointer to the first element of the array.\n+    #[unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub fn first_ptr_mut(this: &mut [MaybeUninit<T>]) -> *mut T {\n+        this as *mut [MaybeUninit<T>] as *mut T\n+    }\n+}"}, {"sha": "91449f09936aa2597487e6f5aa10e3cb1893df3b", "filename": "src/libcore/mem/mod.rs", "status": "added", "additions": 752, "deletions": 0, "changes": 752, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -0,0 +1,752 @@\n+//! Basic functions for dealing with memory.\n+//!\n+//! This module contains functions for querying the size and alignment of\n+//! types, initializing and manipulating memory.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use crate::clone;\n+use crate::cmp;\n+use crate::fmt;\n+use crate::hash;\n+use crate::intrinsics;\n+use crate::marker::{Copy, PhantomData, Sized};\n+use crate::ptr;\n+\n+mod manually_drop;\n+#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+pub use manually_drop::ManuallyDrop;\n+\n+mod maybe_uninit;\n+#[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+pub use maybe_uninit::MaybeUninit;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(inline)]\n+pub use crate::intrinsics::transmute;\n+\n+/// Takes ownership and \"forgets\" about the value **without running its destructor**.\n+///\n+/// Any resources the value manages, such as heap memory or a file handle, will linger\n+/// forever in an unreachable state. However, it does not guarantee that pointers\n+/// to this memory will remain valid.\n+///\n+/// * If you want to leak memory, see [`Box::leak`][leak].\n+/// * If you want to obtain a raw pointer to the memory, see [`Box::into_raw`][into_raw].\n+/// * If you want to dispose of a value properly, running its destructor, see\n+/// [`mem::drop`][drop].\n+///\n+/// # Safety\n+///\n+/// `forget` is not marked as `unsafe`, because Rust's safety guarantees\n+/// do not include a guarantee that destructors will always run. For example,\n+/// a program can create a reference cycle using [`Rc`][rc], or call\n+/// [`process::exit`][exit] to exit without running destructors. Thus, allowing\n+/// `mem::forget` from safe code does not fundamentally change Rust's safety\n+/// guarantees.\n+///\n+/// That said, leaking resources such as memory or I/O objects is usually undesirable,\n+/// so `forget` is only recommended for specialized use cases like those shown below.\n+///\n+/// Because forgetting a value is allowed, any `unsafe` code you write must\n+/// allow for this possibility. You cannot return a value and expect that the\n+/// caller will necessarily run the value's destructor.\n+///\n+/// [rc]: ../../std/rc/struct.Rc.html\n+/// [exit]: ../../std/process/fn.exit.html\n+///\n+/// # Examples\n+///\n+/// Leak an I/O object, never closing the file:\n+///\n+/// ```no_run\n+/// use std::mem;\n+/// use std::fs::File;\n+///\n+/// let file = File::open(\"foo.txt\").unwrap();\n+/// mem::forget(file);\n+/// ```\n+///\n+/// The practical use cases for `forget` are rather specialized and mainly come\n+/// up in unsafe or FFI code.\n+///\n+/// [drop]: fn.drop.html\n+/// [uninit]: fn.uninitialized.html\n+/// [clone]: ../clone/trait.Clone.html\n+/// [swap]: fn.swap.html\n+/// [box]: ../../std/boxed/struct.Box.html\n+/// [leak]: ../../std/boxed/struct.Box.html#method.leak\n+/// [into_raw]: ../../std/boxed/struct.Box.html#method.into_raw\n+/// [ub]: ../../reference/behavior-considered-undefined.html\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn forget<T>(t: T) {\n+    ManuallyDrop::new(t);\n+}\n+\n+/// Like [`forget`], but also accepts unsized values.\n+///\n+/// This function is just a shim intended to be removed when the `unsized_locals` feature gets\n+/// stabilized.\n+///\n+/// [`forget`]: fn.forget.html\n+#[inline]\n+#[unstable(feature = \"forget_unsized\", issue = \"0\")]\n+pub fn forget_unsized<T: ?Sized>(t: T) {\n+    unsafe { intrinsics::forget(t) }\n+}\n+\n+/// Returns the size of a type in bytes.\n+///\n+/// More specifically, this is the offset in bytes between successive elements\n+/// in an array with that item type including alignment padding. Thus, for any\n+/// type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n+///\n+/// In general, the size of a type is not stable across compilations, but\n+/// specific types such as primitives are.\n+///\n+/// The following table gives the size for primitives.\n+///\n+/// Type | size_of::\\<Type>()\n+/// ---- | ---------------\n+/// () | 0\n+/// bool | 1\n+/// u8 | 1\n+/// u16 | 2\n+/// u32 | 4\n+/// u64 | 8\n+/// u128 | 16\n+/// i8 | 1\n+/// i16 | 2\n+/// i32 | 4\n+/// i64 | 8\n+/// i128 | 16\n+/// f32 | 4\n+/// f64 | 8\n+/// char | 4\n+///\n+/// Furthermore, `usize` and `isize` have the same size.\n+///\n+/// The types `*const T`, `&T`, `Box<T>`, `Option<&T>`, and `Option<Box<T>>` all have\n+/// the same size. If `T` is Sized, all of those types have the same size as `usize`.\n+///\n+/// The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n+/// have the same size. Likewise for `*const T` and `*mut T`.\n+///\n+/// # Size of `#[repr(C)]` items\n+///\n+/// The `C` representation for items has a defined layout. With this layout,\n+/// the size of items is also stable as long as all fields have a stable size.\n+///\n+/// ## Size of Structs\n+///\n+/// For `structs`, the size is determined by the following algorithm.\n+///\n+/// For each field in the struct ordered by declaration order:\n+///\n+/// 1. Add the size of the field.\n+/// 2. Round up the current size to the nearest multiple of the next field's [alignment].\n+///\n+/// Finally, round the size of the struct to the nearest multiple of its [alignment].\n+/// The alignment of the struct is usually the largest alignment of all its\n+/// fields; this can be changed with the use of `repr(align(N))`.\n+///\n+/// Unlike `C`, zero sized structs are not rounded up to one byte in size.\n+///\n+/// ## Size of Enums\n+///\n+/// Enums that carry no data other than the discriminant have the same size as C enums\n+/// on the platform they are compiled for.\n+///\n+/// ## Size of Unions\n+///\n+/// The size of a union is the size of its largest field.\n+///\n+/// Unlike `C`, zero sized unions are not rounded up to one byte in size.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// // Some primitives\n+/// assert_eq!(4, mem::size_of::<i32>());\n+/// assert_eq!(8, mem::size_of::<f64>());\n+/// assert_eq!(0, mem::size_of::<()>());\n+///\n+/// // Some arrays\n+/// assert_eq!(8, mem::size_of::<[i32; 2]>());\n+/// assert_eq!(12, mem::size_of::<[i32; 3]>());\n+/// assert_eq!(0, mem::size_of::<[i32; 0]>());\n+///\n+///\n+/// // Pointer size equality\n+/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<*const i32>());\n+/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<Box<i32>>());\n+/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<Option<&i32>>());\n+/// assert_eq!(mem::size_of::<Box<i32>>(), mem::size_of::<Option<Box<i32>>>());\n+/// ```\n+///\n+/// Using `#[repr(C)]`.\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// #[repr(C)]\n+/// struct FieldStruct {\n+///     first: u8,\n+///     second: u16,\n+///     third: u8\n+/// }\n+///\n+/// // The size of the first field is 1, so add 1 to the size. Size is 1.\n+/// // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n+/// // The size of the second field is 2, so add 2 to the size. Size is 4.\n+/// // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n+/// // The size of the third field is 1, so add 1 to the size. Size is 5.\n+/// // Finally, the alignment of the struct is 2 (because the largest alignment amongst its\n+/// // fields is 2), so add 1 to the size for padding. Size is 6.\n+/// assert_eq!(6, mem::size_of::<FieldStruct>());\n+///\n+/// #[repr(C)]\n+/// struct TupleStruct(u8, u16, u8);\n+///\n+/// // Tuple structs follow the same rules.\n+/// assert_eq!(6, mem::size_of::<TupleStruct>());\n+///\n+/// // Note that reordering the fields can lower the size. We can remove both padding bytes\n+/// // by putting `third` before `second`.\n+/// #[repr(C)]\n+/// struct FieldStructOptimized {\n+///     first: u8,\n+///     third: u8,\n+///     second: u16\n+/// }\n+///\n+/// assert_eq!(4, mem::size_of::<FieldStructOptimized>());\n+///\n+/// // Union size is the size of the largest field.\n+/// #[repr(C)]\n+/// union ExampleUnion {\n+///     smaller: u8,\n+///     larger: u16\n+/// }\n+///\n+/// assert_eq!(2, mem::size_of::<ExampleUnion>());\n+/// ```\n+///\n+/// [alignment]: ./fn.align_of.html\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_promotable]\n+pub const fn size_of<T>() -> usize {\n+    intrinsics::size_of::<T>()\n+}\n+\n+/// Returns the size of the pointed-to value in bytes.\n+///\n+/// This is usually the same as `size_of::<T>()`. However, when `T` *has* no\n+/// statically-known size, e.g., a slice [`[T]`][slice] or a [trait object],\n+/// then `size_of_val` can be used to get the dynamically-known size.\n+///\n+/// [slice]: ../../std/primitive.slice.html\n+/// [trait object]: ../../book/ch17-02-trait-objects.html\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::size_of_val(&5i32));\n+///\n+/// let x: [u8; 13] = [0; 13];\n+/// let y: &[u8] = &x;\n+/// assert_eq!(13, mem::size_of_val(y));\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn size_of_val<T: ?Sized>(val: &T) -> usize {\n+    unsafe { intrinsics::size_of_val(val) }\n+}\n+\n+/// Returns the [ABI]-required minimum alignment of a type.\n+///\n+/// Every reference to a value of the type `T` must be a multiple of this number.\n+///\n+/// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n+///\n+/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n+///\n+/// # Examples\n+///\n+/// ```\n+/// # #![allow(deprecated)]\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::min_align_of::<i32>());\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_deprecated(reason = \"use `align_of` instead\", since = \"1.2.0\")]\n+pub fn min_align_of<T>() -> usize {\n+    intrinsics::min_align_of::<T>()\n+}\n+\n+/// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n+///\n+/// Every reference to a value of the type `T` must be a multiple of this number.\n+///\n+/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n+///\n+/// # Examples\n+///\n+/// ```\n+/// # #![allow(deprecated)]\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::min_align_of_val(&5i32));\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_deprecated(reason = \"use `align_of_val` instead\", since = \"1.2.0\")]\n+pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n+    unsafe { intrinsics::min_align_of_val(val) }\n+}\n+\n+/// Returns the [ABI]-required minimum alignment of a type.\n+///\n+/// Every reference to a value of the type `T` must be a multiple of this number.\n+///\n+/// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n+///\n+/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::align_of::<i32>());\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_promotable]\n+pub const fn align_of<T>() -> usize {\n+    intrinsics::min_align_of::<T>()\n+}\n+\n+/// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n+///\n+/// Every reference to a value of the type `T` must be a multiple of this number.\n+///\n+/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::align_of_val(&5i32));\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n+    unsafe { intrinsics::min_align_of_val(val) }\n+}\n+\n+/// Returns `true` if dropping values of type `T` matters.\n+///\n+/// This is purely an optimization hint, and may be implemented conservatively:\n+/// it may return `true` for types that don't actually need to be dropped.\n+/// As such always returning `true` would be a valid implementation of\n+/// this function. However if this function actually returns `false`, then you\n+/// can be certain dropping `T` has no side effect.\n+///\n+/// Low level implementations of things like collections, which need to manually\n+/// drop their data, should use this function to avoid unnecessarily\n+/// trying to drop all their contents when they are destroyed. This might not\n+/// make a difference in release builds (where a loop that has no side-effects\n+/// is easily detected and eliminated), but is often a big win for debug builds.\n+///\n+/// Note that `ptr::drop_in_place` already performs this check, so if your workload\n+/// can be reduced to some small number of drop_in_place calls, using this is\n+/// unnecessary. In particular note that you can drop_in_place a slice, and that\n+/// will do a single needs_drop check for all the values.\n+///\n+/// Types like Vec therefore just `drop_in_place(&mut self[..])` without using\n+/// needs_drop explicitly. Types like HashMap, on the other hand, have to drop\n+/// values one at a time and should use this API.\n+///\n+///\n+/// # Examples\n+///\n+/// Here's an example of how a collection might make use of needs_drop:\n+///\n+/// ```\n+/// use std::{mem, ptr};\n+///\n+/// pub struct MyCollection<T> {\n+/// #   data: [T; 1],\n+///     /* ... */\n+/// }\n+/// # impl<T> MyCollection<T> {\n+/// #   fn iter_mut(&mut self) -> &mut [T] { &mut self.data }\n+/// #   fn free_buffer(&mut self) {}\n+/// # }\n+///\n+/// impl<T> Drop for MyCollection<T> {\n+///     fn drop(&mut self) {\n+///         unsafe {\n+///             // drop the data\n+///             if mem::needs_drop::<T>() {\n+///                 for x in self.iter_mut() {\n+///                     ptr::drop_in_place(x);\n+///                 }\n+///             }\n+///             self.free_buffer();\n+///         }\n+///     }\n+/// }\n+/// ```\n+#[inline]\n+#[stable(feature = \"needs_drop\", since = \"1.21.0\")]\n+pub const fn needs_drop<T>() -> bool {\n+    intrinsics::needs_drop::<T>()\n+}\n+\n+/// Creates a value whose bytes are all zero.\n+///\n+/// This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].\n+/// It is useful for FFI sometimes, but should generally be avoided.\n+///\n+/// There is no guarantee that an all-zero byte-pattern represents a valid value of\n+/// some type `T`. For example, the all-zero byte-pattern is not a valid value\n+/// for reference types (`&T` and `&mut T`). Using `zeroed` on such types\n+/// causes immediate [undefined behavior][ub] because [the Rust compiler assumes][inv]\n+/// that there always is a valid value in a variable it considers initialized.\n+///\n+/// [zeroed]: union.MaybeUninit.html#method.zeroed\n+/// [ub]: ../../reference/behavior-considered-undefined.html\n+/// [inv]: union.MaybeUninit.html#initialization-invariant\n+///\n+/// # Examples\n+///\n+/// Correct usage of this function: initializing an integer with zero.\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// let x: i32 = unsafe { mem::zeroed() };\n+/// assert_eq!(0, x);\n+/// ```\n+///\n+/// *Incorrect* usage of this function: initializing a reference with zero.\n+///\n+/// ```no_run\n+/// use std::mem;\n+///\n+/// let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub unsafe fn zeroed<T>() -> T {\n+    intrinsics::panic_if_uninhabited::<T>();\n+    intrinsics::init()\n+}\n+\n+/// Bypasses Rust's normal memory-initialization checks by pretending to\n+/// produce a value of type `T`, while doing nothing at all.\n+///\n+/// **This functon is deprecated.** Use [`MaybeUninit<T>`] instead.\n+///\n+/// The reason for deprecation is that the function basically cannot be used\n+/// correctly: [the Rust compiler assumes][inv] that values are properly initialized.\n+/// As a consequence, calling e.g. `mem::uninitialized::<bool>()` causes immediate\n+/// undefined behavior for returning a `bool` that is not definitely either `true`\n+/// or `false`. Worse, truly uninitialized memory like what gets returned here\n+/// is special in that the compiler knows that it does not have a fixed value.\n+/// This makes it undefined behavior to have uninitialized data in a variable even\n+/// if that variable has an integer type.\n+/// (Notice that the rules around uninitialized integers are not finalized yet, but\n+/// until they are, it is advisable to avoid them.)\n+///\n+/// [`MaybeUninit<T>`]: union.MaybeUninit.html\n+/// [inv]: union.MaybeUninit.html#initialization-invariant\n+#[inline]\n+#[rustc_deprecated(since = \"1.38.0\", reason = \"use `mem::MaybeUninit` instead\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub unsafe fn uninitialized<T>() -> T {\n+    intrinsics::panic_if_uninhabited::<T>();\n+    intrinsics::uninit()\n+}\n+\n+/// Swaps the values at two mutable locations, without deinitializing either one.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// let mut x = 5;\n+/// let mut y = 42;\n+///\n+/// mem::swap(&mut x, &mut y);\n+///\n+/// assert_eq!(42, x);\n+/// assert_eq!(5, y);\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn swap<T>(x: &mut T, y: &mut T) {\n+    unsafe {\n+        ptr::swap_nonoverlapping_one(x, y);\n+    }\n+}\n+\n+/// Moves `src` into the referenced `dest`, returning the previous `dest` value.\n+///\n+/// Neither value is dropped.\n+///\n+/// # Examples\n+///\n+/// A simple example:\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// let mut v: Vec<i32> = vec![1, 2];\n+///\n+/// let old_v = mem::replace(&mut v, vec![3, 4, 5]);\n+/// assert_eq!(vec![1, 2], old_v);\n+/// assert_eq!(vec![3, 4, 5], v);\n+/// ```\n+///\n+/// `replace` allows consumption of a struct field by replacing it with another value.\n+/// Without `replace` you can run into issues like these:\n+///\n+/// ```compile_fail,E0507\n+/// struct Buffer<T> { buf: Vec<T> }\n+///\n+/// impl<T> Buffer<T> {\n+///     fn get_and_reset(&mut self) -> Vec<T> {\n+///         // error: cannot move out of dereference of `&mut`-pointer\n+///         let buf = self.buf;\n+///         self.buf = Vec::new();\n+///         buf\n+///     }\n+/// }\n+/// ```\n+///\n+/// Note that `T` does not necessarily implement [`Clone`], so it can't even clone and reset\n+/// `self.buf`. But `replace` can be used to disassociate the original value of `self.buf` from\n+/// `self`, allowing it to be returned:\n+///\n+/// ```\n+/// # #![allow(dead_code)]\n+/// use std::mem;\n+///\n+/// # struct Buffer<T> { buf: Vec<T> }\n+/// impl<T> Buffer<T> {\n+///     fn get_and_reset(&mut self) -> Vec<T> {\n+///         mem::replace(&mut self.buf, Vec::new())\n+///     }\n+/// }\n+/// ```\n+///\n+/// [`Clone`]: ../../std/clone/trait.Clone.html\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n+    swap(dest, &mut src);\n+    src\n+}\n+\n+/// Disposes of a value.\n+///\n+/// This does call the argument's implementation of [`Drop`][drop].\n+///\n+/// This effectively does nothing for types which implement `Copy`, e.g.\n+/// integers. Such values are copied and _then_ moved into the function, so the\n+/// value persists after this function call.\n+///\n+/// This function is not magic; it is literally defined as\n+///\n+/// ```\n+/// pub fn drop<T>(_x: T) { }\n+/// ```\n+///\n+/// Because `_x` is moved into the function, it is automatically dropped before\n+/// the function returns.\n+///\n+/// [drop]: ../ops/trait.Drop.html\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// let v = vec![1, 2, 3];\n+///\n+/// drop(v); // explicitly drop the vector\n+/// ```\n+///\n+/// Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n+/// release a [`RefCell`] borrow:\n+///\n+/// ```\n+/// use std::cell::RefCell;\n+///\n+/// let x = RefCell::new(1);\n+///\n+/// let mut mutable_borrow = x.borrow_mut();\n+/// *mutable_borrow = 1;\n+///\n+/// drop(mutable_borrow); // relinquish the mutable borrow on this slot\n+///\n+/// let borrow = x.borrow();\n+/// println!(\"{}\", *borrow);\n+/// ```\n+///\n+/// Integers and other types implementing [`Copy`] are unaffected by `drop`.\n+///\n+/// ```\n+/// #[derive(Copy, Clone)]\n+/// struct Foo(u8);\n+///\n+/// let x = 1;\n+/// let y = Foo(2);\n+/// drop(x); // a copy of `x` is moved and dropped\n+/// drop(y); // a copy of `y` is moved and dropped\n+///\n+/// println!(\"x: {}, y: {}\", x, y.0); // still available\n+/// ```\n+///\n+/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n+/// [`Copy`]: ../../std/marker/trait.Copy.html\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn drop<T>(_x: T) { }\n+\n+/// Interprets `src` as having type `&U`, and then reads `src` without moving\n+/// the contained value.\n+///\n+/// This function will unsafely assume the pointer `src` is valid for\n+/// [`size_of::<U>`][size_of] bytes by transmuting `&T` to `&U` and then reading\n+/// the `&U`. It will also unsafely create a copy of the contained value instead of\n+/// moving out of `src`.\n+///\n+/// It is not a compile-time error if `T` and `U` have different sizes, but it\n+/// is highly encouraged to only invoke this function where `T` and `U` have the\n+/// same size. This function triggers [undefined behavior][ub] if `U` is larger than\n+/// `T`.\n+///\n+/// [ub]: ../../reference/behavior-considered-undefined.html\n+/// [size_of]: fn.size_of.html\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// #[repr(packed)]\n+/// struct Foo {\n+///     bar: u8,\n+/// }\n+///\n+/// let foo_slice = [10u8];\n+///\n+/// unsafe {\n+///     // Copy the data from 'foo_slice' and treat it as a 'Foo'\n+///     let mut foo_struct: Foo = mem::transmute_copy(&foo_slice);\n+///     assert_eq!(foo_struct.bar, 10);\n+///\n+///     // Modify the copied data\n+///     foo_struct.bar = 20;\n+///     assert_eq!(foo_struct.bar, 20);\n+/// }\n+///\n+/// // The contents of 'foo_slice' should not have changed\n+/// assert_eq!(foo_slice, [10]);\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n+    ptr::read_unaligned(src as *const T as *const U)\n+}\n+\n+/// Opaque type representing the discriminant of an enum.\n+///\n+/// See the [`discriminant`] function in this module for more information.\n+///\n+/// [`discriminant`]: fn.discriminant.html\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n+pub struct Discriminant<T>(u64, PhantomData<fn() -> T>);\n+\n+// N.B. These trait implementations cannot be derived because we don't want any bounds on T.\n+\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n+impl<T> Copy for Discriminant<T> {}\n+\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n+impl<T> clone::Clone for Discriminant<T> {\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n+impl<T> cmp::PartialEq for Discriminant<T> {\n+    fn eq(&self, rhs: &Self) -> bool {\n+        self.0 == rhs.0\n+    }\n+}\n+\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n+impl<T> cmp::Eq for Discriminant<T> {}\n+\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n+impl<T> hash::Hash for Discriminant<T> {\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        self.0.hash(state);\n+    }\n+}\n+\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n+impl<T> fmt::Debug for Discriminant<T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt.debug_tuple(\"Discriminant\")\n+           .field(&self.0)\n+           .finish()\n+    }\n+}\n+\n+/// Returns a value uniquely identifying the enum variant in `v`.\n+///\n+/// If `T` is not an enum, calling this function will not result in undefined behavior, but the\n+/// return value is unspecified.\n+///\n+/// # Stability\n+///\n+/// The discriminant of an enum variant may change if the enum definition changes. A discriminant\n+/// of some variant will not change between compilations with the same compiler.\n+///\n+/// # Examples\n+///\n+/// This can be used to compare enums that carry data, while disregarding\n+/// the actual data:\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// enum Foo { A(&'static str), B(i32), C(i32) }\n+///\n+/// assert!(mem::discriminant(&Foo::A(\"bar\")) == mem::discriminant(&Foo::A(\"baz\")));\n+/// assert!(mem::discriminant(&Foo::B(1))     == mem::discriminant(&Foo::B(2)));\n+/// assert!(mem::discriminant(&Foo::B(3))     != mem::discriminant(&Foo::C(3)));\n+/// ```\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n+pub fn discriminant<T>(v: &T) -> Discriminant<T> {\n+    unsafe {\n+        Discriminant(intrinsics::discriminant_value(v), PhantomData)\n+    }\n+}"}, {"sha": "0e782bef39dd8ee6b4dd011f6df94da6369dee3a", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -4158,6 +4158,24 @@ impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n             Some(snd)\n         }\n     }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.len();\n+        if n >= len {\n+            self.v = &[];\n+            None\n+        } else {\n+            let start = (len - 1 - n) * self.chunk_size;\n+            let end = match start.checked_add(self.chunk_size) {\n+                Some(res) => cmp::min(res, self.v.len()),\n+                None => self.v.len(),\n+            };\n+            let nth_back = &self.v[start..end];\n+            self.v = &self.v[..start];\n+            Some(nth_back)\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -4649,6 +4667,23 @@ impl<'a, T> DoubleEndedIterator for RChunks<'a, T> {\n             Some(fst)\n         }\n     }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.len();\n+        if n >= len {\n+            self.v = &[];\n+            None\n+        } else {\n+            // can't underflow because `n < len`\n+            let offset_from_end = (len - 1 - n) * self.chunk_size;\n+            let end = self.v.len() - offset_from_end;\n+            let start = end.saturating_sub(self.chunk_size);\n+            let nth_back = &self.v[start..end];\n+            self.v = &self.v[end..];\n+            Some(nth_back)\n+        }\n+    }\n }\n \n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n@@ -4774,6 +4809,24 @@ impl<'a, T> DoubleEndedIterator for RChunksMut<'a, T> {\n             Some(head)\n         }\n     }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.len();\n+        if n >= len {\n+            self.v = &mut [];\n+            None\n+        } else {\n+            // can't underflow because `n < len`\n+            let offset_from_end = (len - 1 - n) * self.chunk_size;\n+            let end = self.v.len() - offset_from_end;\n+            let start = end.saturating_sub(self.chunk_size);\n+            let (tmp, tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n+            let (_, nth_back) = tmp.split_at_mut(start);\n+            self.v = tail;\n+            Some(nth_back)\n+        }\n+    }\n }\n \n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n@@ -4898,6 +4951,24 @@ impl<'a, T> DoubleEndedIterator for RChunksExact<'a, T> {\n             Some(fst)\n         }\n     }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.len();\n+        if n >= len {\n+            self.v = &[];\n+            None\n+        } else {\n+            // now that we know that `n` corresponds to a chunk,\n+            // none of these operations can underflow/overflow\n+            let offset = (len - n) * self.chunk_size;\n+            let start = self.v.len() - offset;\n+            let end = start + self.chunk_size;\n+            let nth_back = &self.v[start..end];\n+            self.v = &self.v[end..];\n+            Some(nth_back)\n+        }\n+    }\n }\n \n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n@@ -5016,6 +5087,25 @@ impl<'a, T> DoubleEndedIterator for RChunksExactMut<'a, T> {\n             Some(head)\n         }\n     }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.len();\n+        if n >= len {\n+            self.v = &mut [];\n+            None\n+        } else {\n+            // now that we know that `n` corresponds to a chunk,\n+            // none of these operations can underflow/overflow\n+            let offset = (len - n) * self.chunk_size;\n+            let start = self.v.len() - offset;\n+            let end = start + self.chunk_size;\n+            let (tmp, tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n+            let (_, nth_back) = tmp.split_at_mut(start);\n+            self.v = tail;\n+            Some(nth_back)\n+        }\n+    }\n }\n \n #[stable(feature = \"rchunks\", since = \"1.31.0\")]"}, {"sha": "bedb9e756129c5a0322e3dbe22bbbbeb74992950", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -1084,6 +1084,14 @@ fn test_iterator_sum_result() {\n     assert_eq!(v.iter().cloned().sum::<Result<i32, _>>(), Err(()));\n }\n \n+#[test]\n+fn test_iterator_sum_option() {\n+    let v: &[Option<i32>] = &[Some(1), Some(2), Some(3), Some(4)];\n+    assert_eq!(v.iter().cloned().sum::<Option<i32>>(), Some(10));\n+    let v: &[Option<i32>] = &[Some(1), None, Some(3), Some(4)];\n+    assert_eq!(v.iter().cloned().sum::<Option<i32>>(), None);\n+}\n+\n #[test]\n fn test_iterator_product() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n@@ -1126,6 +1134,14 @@ impl Ord for Mod3 {\n     }\n }\n \n+#[test]\n+fn test_iterator_product_option() {\n+    let v: &[Option<i32>] = &[Some(1), Some(2), Some(3), Some(4)];\n+    assert_eq!(v.iter().cloned().product::<Option<i32>>(), Some(24));\n+    let v: &[Option<i32>] = &[Some(1), None, Some(3), Some(4)];\n+    assert_eq!(v.iter().cloned().product::<Option<i32>>(), None);\n+}\n+\n #[test]\n fn test_iterator_max() {\n     let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];"}, {"sha": "9710f019f4e4df0ba630cfd6c4a0c0e6bd246345", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -134,6 +134,30 @@ fn test_chunks_nth() {\n     assert_eq!(c2.next(), None);\n }\n \n+#[test]\n+fn test_chunks_nth_back() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let mut c = v.chunks(2);\n+    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next().unwrap(), &[0, 1]);\n+    assert_eq!(c.next(), None);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4];\n+    let mut c2 = v2.chunks(3);\n+    assert_eq!(c2.nth_back(1).unwrap(), &[0, 1, 2]);\n+    assert_eq!(c2.next(), None);\n+    assert_eq!(c2.next_back(), None);\n+\n+    let v3: &[i32] = &[0, 1, 2, 3, 4];\n+    let mut c3 = v3.chunks(10);\n+    assert_eq!(c3.nth_back(0).unwrap(), &[0, 1, 2, 3, 4]);\n+    assert_eq!(c3.next(), None);\n+\n+    let v4: &[i32] = &[0, 1, 2];\n+    let mut c4 = v4.chunks(10);\n+    assert_eq!(c4.nth_back(1_000_000_000usize), None);\n+}\n+\n #[test]\n fn test_chunks_last() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n@@ -356,6 +380,19 @@ fn test_rchunks_nth() {\n     assert_eq!(c2.next(), None);\n }\n \n+#[test]\n+fn test_rchunks_nth_back() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let mut c = v.rchunks(2);\n+    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next_back().unwrap(), &[4, 5]);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4];\n+    let mut c2 = v2.rchunks(3);\n+    assert_eq!(c2.nth_back(1).unwrap(), &[2, 3, 4]);\n+    assert_eq!(c2.next_back(), None);\n+}\n+\n #[test]\n fn test_rchunks_last() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n@@ -407,6 +444,19 @@ fn test_rchunks_mut_nth() {\n     assert_eq!(c2.next(), None);\n }\n \n+#[test]\n+fn test_rchunks_mut_nth_back() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let mut c = v.rchunks_mut(2);\n+    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next_back().unwrap(), &[4, 5]);\n+\n+    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let mut c2 = v2.rchunks_mut(3);\n+    assert_eq!(c2.nth_back(1).unwrap(), &[2, 3, 4]);\n+    assert_eq!(c2.next_back(), None);\n+}\n+\n #[test]\n fn test_rchunks_mut_last() {\n     let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n@@ -460,6 +510,19 @@ fn test_rchunks_exact_nth() {\n     assert_eq!(c2.next(), None);\n }\n \n+#[test]\n+fn test_rchunks_exact_nth_back() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let mut c = v.rchunks_exact(2);\n+    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next_back().unwrap(), &[4, 5]);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4, 5, 6];\n+    let mut c2 = v2.rchunks_exact(3);\n+    assert_eq!(c2.nth_back(1).unwrap(), &[4, 5, 6]);\n+    assert_eq!(c2.next(), None);\n+}\n+\n #[test]\n fn test_rchunks_exact_last() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n@@ -518,6 +581,19 @@ fn test_rchunks_exact_mut_nth() {\n     assert_eq!(c2.next(), None);\n }\n \n+#[test]\n+fn test_rchunks_exact_mut_nth_back() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let mut c = v.rchunks_exact_mut(2);\n+    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next_back().unwrap(), &[4, 5]);\n+\n+    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4, 5, 6];\n+    let mut c2 = v2.rchunks_exact_mut(3);\n+    assert_eq!(c2.nth_back(1).unwrap(), &[4, 5, 6]);\n+    assert_eq!(c2.next(), None);\n+}\n+\n #[test]\n fn test_rchunks_exact_mut_last() {\n     let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];"}, {"sha": "08fbd0d20d74dac3a23818ad7ee4cf5e4fc187aa", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -1083,6 +1083,18 @@ impl<'a> LoweringContext<'a> {\n             .chain(in_band_defs)\n             .collect();\n \n+        // FIXME(const_generics): the compiler doesn't always cope with\n+        // unsorted generic parameters at the moment, so we make sure\n+        // that they're ordered correctly here for now. (When we chain\n+        // the `in_band_defs`, we might make the order unsorted.)\n+        lowered_generics.params.sort_by_key(|param| {\n+            match param.kind {\n+                hir::GenericParamKind::Lifetime { .. } => ParamKindOrd::Lifetime,\n+                hir::GenericParamKind::Type { .. } => ParamKindOrd::Type,\n+                hir::GenericParamKind::Const { .. } => ParamKindOrd::Const,\n+            }\n+        });\n+\n         (lowered_generics, res)\n     }\n "}, {"sha": "f03a8ddc90825a7a23086878d2150da9d2bb744d", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -425,6 +425,13 @@ impl GenericArg {\n             GenericArg::Const(c) => c.value.hir_id,\n         }\n     }\n+\n+    pub fn is_const(&self) -> bool {\n+        match self {\n+            GenericArg::Const(_) => true,\n+            _ => false,\n+        }\n+    }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]"}, {"sha": "f7af51e47526cd38392ec0340db3660425a7f05b", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -255,7 +255,7 @@ declare_lint! {\n \n declare_lint! {\n     pub BARE_TRAIT_OBJECTS,\n-    Allow,\n+    Warn,\n     \"suggest using `dyn Trait` for trait objects\"\n }\n "}, {"sha": "593a09b6866dbb8335b58c42b5be149941b1bf64", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -170,16 +170,11 @@ pub enum Set1<T> {\n \n impl<T: PartialEq> Set1<T> {\n     pub fn insert(&mut self, value: T) {\n-        if let Set1::Empty = *self {\n-            *self = Set1::One(value);\n-            return;\n-        }\n-        if let Set1::One(ref old) = *self {\n-            if *old == value {\n-                return;\n-            }\n-        }\n-        *self = Set1::Many;\n+        *self = match self {\n+            Set1::Empty => Set1::One(value),\n+            Set1::One(old) if *old == value => return,\n+            _ => Set1::Many,\n+        };\n     }\n }\n "}, {"sha": "d4ef134728eafe5b6514557a6c570b75aa5603f9", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -2037,7 +2037,7 @@ impl<'tcx> Place<'tcx> {\n     /// a single deref of a local.\n     //\n     // FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n-    pub fn local(&self) -> Option<Local> {\n+    pub fn local_or_deref_local(&self) -> Option<Local> {\n         match self {\n             Place::Base(PlaceBase::Local(local)) |\n             Place::Projection(box Projection {"}, {"sha": "ca79bc15358c500fb6f3216af3933ddf43af2e87", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -188,49 +188,6 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for CodegenUnit<'tcx> {\n     }\n }\n \n-#[derive(Clone, Default)]\n-pub struct Stats {\n-    pub n_glues_created: usize,\n-    pub n_null_glues: usize,\n-    pub n_real_glues: usize,\n-    pub n_fns: usize,\n-    pub n_inlines: usize,\n-    pub n_closures: usize,\n-    pub n_llvm_insns: usize,\n-    pub llvm_insns: FxHashMap<String, usize>,\n-    // (ident, llvm-instructions)\n-    pub fn_stats: Vec<(String, usize)>,\n-}\n-\n-impl_stable_hash_for!(struct self::Stats {\n-    n_glues_created,\n-    n_null_glues,\n-    n_real_glues,\n-    n_fns,\n-    n_inlines,\n-    n_closures,\n-    n_llvm_insns,\n-    llvm_insns,\n-    fn_stats\n-});\n-\n-impl Stats {\n-    pub fn extend(&mut self, stats: Stats) {\n-        self.n_glues_created += stats.n_glues_created;\n-        self.n_null_glues += stats.n_null_glues;\n-        self.n_real_glues += stats.n_real_glues;\n-        self.n_fns += stats.n_fns;\n-        self.n_inlines += stats.n_inlines;\n-        self.n_closures += stats.n_closures;\n-        self.n_llvm_insns += stats.n_llvm_insns;\n-\n-        for (k, v) in stats.llvm_insns {\n-            *self.llvm_insns.entry(k).or_insert(0) += v;\n-        }\n-        self.fn_stats.extend(stats.fn_stats);\n-    }\n-}\n-\n pub struct CodegenUnitNameBuilder<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     cache: FxHashMap<CrateNum, String>,"}, {"sha": "300d0cbfba55bd3e3f10a1f02bdfa06c2b5b2030", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -1216,21 +1216,12 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"measure time of each rustc pass\"),\n     time: bool = (false, parse_bool, [UNTRACKED],\n         \"measure time of rustc processes\"),\n-    count_llvm_insns: bool = (false, parse_bool,\n-        [UNTRACKED_WITH_WARNING(true,\n-        \"The output generated by `-Z count_llvm_insns` might not be reliable \\\n-         when used with incremental compilation\")],\n-        \"count where LLVM instrs originate\"),\n     time_llvm_passes: bool = (false, parse_bool, [UNTRACKED_WITH_WARNING(true,\n         \"The output of `-Z time-llvm-passes` will only reflect timings of \\\n          re-codegened modules when used with incremental compilation\" )],\n         \"measure time of each LLVM pass\"),\n     input_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"gather statistics about the input\"),\n-    codegen_stats: bool = (false, parse_bool, [UNTRACKED_WITH_WARNING(true,\n-        \"The output of `-Z codegen-stats` might not be accurate when incremental \\\n-         compilation is enabled\")],\n-        \"gather codegen statistics\"),\n     asm_comments: bool = (false, parse_bool, [TRACKED],\n         \"generate comments into the assembly (may change behavior)\"),\n     verify_llvm_ir: bool = (false, parse_bool, [TRACKED],\n@@ -3259,14 +3250,10 @@ mod tests {\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.time_passes = true;\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.count_llvm_insns = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.time_llvm_passes = true;\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.input_stats = true;\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.codegen_stats = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.borrowck_stats = true;\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.meta_stats = true;"}, {"sha": "40af5b45f9c35ebc1a00727022a5d7240d6757bd", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -519,15 +519,9 @@ impl Session {\n     pub fn instrument_mcount(&self) -> bool {\n         self.opts.debugging_opts.instrument_mcount\n     }\n-    pub fn count_llvm_insns(&self) -> bool {\n-        self.opts.debugging_opts.count_llvm_insns\n-    }\n     pub fn time_llvm_passes(&self) -> bool {\n         self.opts.debugging_opts.time_llvm_passes\n     }\n-    pub fn codegen_stats(&self) -> bool {\n-        self.opts.debugging_opts.codegen_stats\n-    }\n     pub fn meta_stats(&self) -> bool {\n         self.opts.debugging_opts.meta_stats\n     }\n@@ -1291,6 +1285,18 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n                               path.display()));\n         }\n     }\n+\n+    // PGO does not work reliably with panic=unwind on Windows. Let's make it\n+    // an error to combine the two for now. It always runs into an assertions\n+    // if LLVM is built with assertions, but without assertions it sometimes\n+    // does not crash and will probably generate a corrupted binary.\n+    if sess.opts.debugging_opts.pgo_gen.enabled() &&\n+       sess.target.target.options.is_like_msvc &&\n+       sess.panic_strategy() == PanicStrategy::Unwind {\n+        sess.err(\"Profile-guided optimization does not yet work in conjunction \\\n+                  with `-Cpanic=unwind` on Windows when targeting MSVC. \\\n+                  See https://github.com/rust-lang/rust/issues/61002 for details.\");\n+    }\n }\n \n /// Hash value constructed out of all the `-C metadata` arguments passed to the"}, {"sha": "f8c6087373f1eb9218bd24c475e22bb6a8d417b6", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -24,7 +24,7 @@ use crate::common;\n use crate::context::CodegenCx;\n use crate::monomorphize::partitioning::CodegenUnitExt;\n use rustc::dep_graph;\n-use rustc::mir::mono::{Linkage, Visibility, Stats};\n+use rustc::mir::mono::{Linkage, Visibility};\n use rustc::middle::cstore::{EncodedMetadata};\n use rustc::ty::TyCtxt;\n use rustc::middle::exported_symbols;\n@@ -104,17 +104,17 @@ pub fn iter_globals(llmod: &'ll llvm::Module) -> ValueIter<'ll> {\n     }\n }\n \n-pub fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  cgu_name: InternedString)\n-                                  -> Stats {\n+pub fn compile_codegen_unit(tcx: TyCtxt<'a, 'tcx, 'tcx>, cgu_name: InternedString) {\n     let start_time = Instant::now();\n \n     let dep_node = tcx.codegen_unit(cgu_name).codegen_dep_node(tcx);\n-    let ((stats, module), _) = tcx.dep_graph.with_task(dep_node,\n-                                                       tcx,\n-                                                       cgu_name,\n-                                                       module_codegen,\n-                                                       dep_graph::hash_result);\n+    let (module, _) = tcx.dep_graph.with_task(\n+        dep_node,\n+        tcx,\n+        cgu_name,\n+        module_codegen,\n+        dep_graph::hash_result,\n+    );\n     let time_to_codegen = start_time.elapsed();\n \n     // We assume that the cost to run LLVM on a CGU is proportional to\n@@ -123,17 +123,15 @@ pub fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                time_to_codegen.subsec_nanos() as u64;\n \n     submit_codegened_module_to_llvm(&LlvmCodegenBackend(()), tcx, module, cost);\n-    return stats;\n \n     fn module_codegen<'ll, 'tcx>(\n         tcx: TyCtxt<'ll, 'tcx, 'tcx>,\n-        cgu_name: InternedString)\n-        -> (Stats, ModuleCodegen<ModuleLlvm>)\n-    {\n+        cgu_name: InternedString,\n+    ) -> ModuleCodegen<ModuleLlvm> {\n         let cgu = tcx.codegen_unit(cgu_name);\n         // Instantiate monomorphizations without filling out definitions yet...\n         let llvm_module = ModuleLlvm::new(tcx, &cgu_name.as_str());\n-        let stats = {\n+        {\n             let cx = CodegenCx::new(tcx, cgu, &llvm_module);\n             let mono_items = cx.codegen_unit\n                                .items_in_deterministic_order(cx.tcx);\n@@ -169,15 +167,13 @@ pub fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             if cx.sess().opts.debuginfo != DebugInfo::None {\n                 cx.debuginfo_finalize();\n             }\n+        }\n \n-            cx.consume_stats().into_inner()\n-        };\n-\n-        (stats, ModuleCodegen {\n+        ModuleCodegen {\n             name: cgu_name.to_string(),\n             module_llvm: llvm_module,\n             kind: ModuleKind::Regular,\n-        })\n+        }\n     }\n }\n "}, {"sha": "42e7a72c43b217cffdcd9615347bd7a3f0772722", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 3, "deletions": 110, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -147,21 +147,18 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn ret_void(&mut self) {\n-        self.count_insn(\"retvoid\");\n         unsafe {\n             llvm::LLVMBuildRetVoid(self.llbuilder);\n         }\n     }\n \n     fn ret(&mut self, v: &'ll Value) {\n-        self.count_insn(\"ret\");\n         unsafe {\n             llvm::LLVMBuildRet(self.llbuilder, v);\n         }\n     }\n \n     fn br(&mut self, dest: &'ll BasicBlock) {\n-        self.count_insn(\"br\");\n         unsafe {\n             llvm::LLVMBuildBr(self.llbuilder, dest);\n         }\n@@ -173,7 +170,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         then_llbb: &'ll BasicBlock,\n         else_llbb: &'ll BasicBlock,\n     ) {\n-        self.count_insn(\"condbr\");\n         unsafe {\n             llvm::LLVMBuildCondBr(self.llbuilder, cond, then_llbb, else_llbb);\n         }\n@@ -204,7 +200,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         catch: &'ll BasicBlock,\n         funclet: Option<&Funclet<'ll>>,\n     ) -> &'ll Value {\n-        self.count_insn(\"invoke\");\n \n         debug!(\"Invoke {:?} with args ({:?})\",\n                llfn,\n@@ -227,29 +222,25 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn unreachable(&mut self) {\n-        self.count_insn(\"unreachable\");\n         unsafe {\n             llvm::LLVMBuildUnreachable(self.llbuilder);\n         }\n     }\n \n     /* Arithmetic */\n     fn add(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"add\");\n         unsafe {\n             llvm::LLVMBuildAdd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn fadd(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fadd\");\n         unsafe {\n             llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn fadd_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fadd\");\n         unsafe {\n             let instr = llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, noname());\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n@@ -258,21 +249,18 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn sub(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"sub\");\n         unsafe {\n             llvm::LLVMBuildSub(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn fsub(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fsub\");\n         unsafe {\n             llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn fsub_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fsub\");\n         unsafe {\n             let instr = llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, noname());\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n@@ -281,21 +269,18 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn mul(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"mul\");\n         unsafe {\n             llvm::LLVMBuildMul(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn fmul(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fmul\");\n         unsafe {\n             llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn fmul_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fmul\");\n         unsafe {\n             let instr = llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, noname());\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n@@ -305,42 +290,36 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n \n     fn udiv(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"udiv\");\n         unsafe {\n             llvm::LLVMBuildUDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn exactudiv(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"exactudiv\");\n         unsafe {\n             llvm::LLVMBuildExactUDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn sdiv(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"sdiv\");\n         unsafe {\n             llvm::LLVMBuildSDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn exactsdiv(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"exactsdiv\");\n         unsafe {\n             llvm::LLVMBuildExactSDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn fdiv(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fdiv\");\n         unsafe {\n             llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn fdiv_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fdiv\");\n         unsafe {\n             let instr = llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, noname());\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n@@ -349,28 +328,24 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn urem(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"urem\");\n         unsafe {\n             llvm::LLVMBuildURem(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn srem(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"srem\");\n         unsafe {\n             llvm::LLVMBuildSRem(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn frem(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"frem\");\n         unsafe {\n             llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn frem_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"frem\");\n         unsafe {\n             let instr = llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, noname());\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n@@ -379,63 +354,54 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn shl(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"shl\");\n         unsafe {\n             llvm::LLVMBuildShl(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn lshr(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"lshr\");\n         unsafe {\n             llvm::LLVMBuildLShr(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn ashr(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"ashr\");\n         unsafe {\n             llvm::LLVMBuildAShr(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn and(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"and\");\n         unsafe {\n             llvm::LLVMBuildAnd(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn or(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"or\");\n         unsafe {\n             llvm::LLVMBuildOr(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn xor(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"xor\");\n         unsafe {\n             llvm::LLVMBuildXor(self.llbuilder, lhs, rhs, noname())\n         }\n     }\n \n     fn neg(&mut self, v: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"neg\");\n         unsafe {\n             llvm::LLVMBuildNeg(self.llbuilder, v, noname())\n         }\n     }\n \n     fn fneg(&mut self, v: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fneg\");\n         unsafe {\n             llvm::LLVMBuildFNeg(self.llbuilder, v, noname())\n         }\n     }\n \n     fn not(&mut self, v: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"not\");\n         unsafe {\n             llvm::LLVMBuildNot(self.llbuilder, v, noname())\n         }\n@@ -524,7 +490,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn dynamic_alloca(&mut self, ty: &'ll Type, name: &str, align: Align) -> &'ll Value {\n-        self.count_insn(\"alloca\");\n         unsafe {\n             let alloca = if name.is_empty() {\n                 llvm::LLVMBuildAlloca(self.llbuilder, ty, noname())\n@@ -543,7 +508,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                         len: &'ll Value,\n                         name: &str,\n                         align: Align) -> &'ll Value {\n-        self.count_insn(\"alloca\");\n         unsafe {\n             let alloca = if name.is_empty() {\n                 llvm::LLVMBuildArrayAlloca(self.llbuilder, ty, len, noname())\n@@ -558,7 +522,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn load(&mut self, ptr: &'ll Value, align: Align) -> &'ll Value {\n-        self.count_insn(\"load\");\n         unsafe {\n             let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n             llvm::LLVMSetAlignment(load, align.bytes() as c_uint);\n@@ -567,11 +530,10 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn volatile_load(&mut self, ptr: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"load.volatile\");\n         unsafe {\n-            let insn = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n-            llvm::LLVMSetVolatile(insn, llvm::True);\n-            insn\n+            let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, noname());\n+            llvm::LLVMSetVolatile(load, llvm::True);\n+            load\n         }\n     }\n \n@@ -581,7 +543,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         order: rustc_codegen_ssa::common::AtomicOrdering,\n         size: Size,\n     ) -> &'ll Value {\n-        self.count_insn(\"load.atomic\");\n         unsafe {\n             let load = llvm::LLVMRustBuildAtomicLoad(\n                 self.llbuilder,\n@@ -745,7 +706,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         flags: MemFlags,\n     ) -> &'ll Value {\n         debug!(\"Store {:?} -> {:?} ({:?})\", val, ptr, flags);\n-        self.count_insn(\"store\");\n         let ptr = self.check_store(val, ptr);\n         unsafe {\n             let store = llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n@@ -774,7 +734,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n    fn atomic_store(&mut self, val: &'ll Value, ptr: &'ll Value,\n                    order: rustc_codegen_ssa::common::AtomicOrdering, size: Size) {\n         debug!(\"Store {:?} -> {:?}\", val, ptr);\n-        self.count_insn(\"store.atomic\");\n         let ptr = self.check_store(val, ptr);\n         unsafe {\n             let store = llvm::LLVMRustBuildAtomicStore(\n@@ -789,23 +748,20 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn gep(&mut self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n-        self.count_insn(\"gep\");\n         unsafe {\n             llvm::LLVMBuildGEP(self.llbuilder, ptr, indices.as_ptr(),\n                                indices.len() as c_uint, noname())\n         }\n     }\n \n     fn inbounds_gep(&mut self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n-        self.count_insn(\"inboundsgep\");\n         unsafe {\n             llvm::LLVMBuildInBoundsGEP(\n                 self.llbuilder, ptr, indices.as_ptr(), indices.len() as c_uint, noname())\n         }\n     }\n \n     fn struct_gep(&mut self, ptr: &'ll Value, idx: u64) -> &'ll Value {\n-        self.count_insn(\"structgep\");\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n             llvm::LLVMBuildStructGEP(self.llbuilder, ptr, idx as c_uint, noname())\n@@ -814,108 +770,93 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     /* Casts */\n     fn trunc(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"trunc\");\n         unsafe {\n             llvm::LLVMBuildTrunc(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     fn sext(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"sext\");\n         unsafe {\n             llvm::LLVMBuildSExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     fn fptoui(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"fptoui\");\n         unsafe {\n             llvm::LLVMBuildFPToUI(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     fn fptosi(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"fptosi\");\n         unsafe {\n             llvm::LLVMBuildFPToSI(self.llbuilder, val, dest_ty,noname())\n         }\n     }\n \n     fn uitofp(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"uitofp\");\n         unsafe {\n             llvm::LLVMBuildUIToFP(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     fn sitofp(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"sitofp\");\n         unsafe {\n             llvm::LLVMBuildSIToFP(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     fn fptrunc(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"fptrunc\");\n         unsafe {\n             llvm::LLVMBuildFPTrunc(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     fn fpext(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"fpext\");\n         unsafe {\n             llvm::LLVMBuildFPExt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     fn ptrtoint(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"ptrtoint\");\n         unsafe {\n             llvm::LLVMBuildPtrToInt(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     fn inttoptr(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"inttoptr\");\n         unsafe {\n             llvm::LLVMBuildIntToPtr(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     fn bitcast(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"bitcast\");\n         unsafe {\n             llvm::LLVMBuildBitCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n \n     fn intcast(&mut self, val: &'ll Value, dest_ty: &'ll Type, is_signed: bool) -> &'ll Value {\n-        self.count_insn(\"intcast\");\n         unsafe {\n             llvm::LLVMRustBuildIntCast(self.llbuilder, val, dest_ty, is_signed)\n         }\n     }\n \n     fn pointercast(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"pointercast\");\n         unsafe {\n             llvm::LLVMBuildPointerCast(self.llbuilder, val, dest_ty, noname())\n         }\n     }\n \n     /* Comparisons */\n     fn icmp(&mut self, op: IntPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"icmp\");\n         let op = llvm::IntPredicate::from_generic(op);\n         unsafe {\n             llvm::LLVMBuildICmp(self.llbuilder, op as c_uint, lhs, rhs, noname())\n         }\n     }\n \n     fn fcmp(&mut self, op: RealPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"fcmp\");\n         unsafe {\n             llvm::LLVMBuildFCmp(self.llbuilder, op as c_uint, lhs, rhs, noname())\n         }\n@@ -984,22 +925,19 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         then_val: &'ll Value,\n         else_val: &'ll Value,\n     ) -> &'ll Value {\n-        self.count_insn(\"select\");\n         unsafe {\n             llvm::LLVMBuildSelect(self.llbuilder, cond, then_val, else_val, noname())\n         }\n     }\n \n     #[allow(dead_code)]\n     fn va_arg(&mut self, list: &'ll Value, ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"vaarg\");\n         unsafe {\n             llvm::LLVMBuildVAArg(self.llbuilder, list, ty, noname())\n         }\n     }\n \n     fn extract_element(&mut self, vec: &'ll Value, idx: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"extractelement\");\n         unsafe {\n             llvm::LLVMBuildExtractElement(self.llbuilder, vec, idx, noname())\n         }\n@@ -1016,7 +954,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn extract_value(&mut self, agg_val: &'ll Value, idx: u64) -> &'ll Value {\n-        self.count_insn(\"extractvalue\");\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n             llvm::LLVMBuildExtractValue(self.llbuilder, agg_val, idx as c_uint, noname())\n@@ -1025,7 +962,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn insert_value(&mut self, agg_val: &'ll Value, elt: &'ll Value,\n                        idx: u64) -> &'ll Value {\n-        self.count_insn(\"insertvalue\");\n         assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n             llvm::LLVMBuildInsertValue(self.llbuilder, agg_val, elt, idx as c_uint,\n@@ -1035,22 +971,19 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn landing_pad(&mut self, ty: &'ll Type, pers_fn: &'ll Value,\n                        num_clauses: usize) -> &'ll Value {\n-        self.count_insn(\"landingpad\");\n         unsafe {\n             llvm::LLVMBuildLandingPad(self.llbuilder, ty, pers_fn,\n                                       num_clauses as c_uint, noname())\n         }\n     }\n \n     fn set_cleanup(&mut self, landing_pad: &'ll Value) {\n-        self.count_insn(\"setcleanup\");\n         unsafe {\n             llvm::LLVMSetCleanup(landing_pad, llvm::True);\n         }\n     }\n \n     fn resume(&mut self, exn: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"resume\");\n         unsafe {\n             llvm::LLVMBuildResume(self.llbuilder, exn)\n         }\n@@ -1059,7 +992,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn cleanup_pad(&mut self,\n                        parent: Option<&'ll Value>,\n                        args: &[&'ll Value]) -> Funclet<'ll> {\n-        self.count_insn(\"cleanuppad\");\n         let name = const_cstr!(\"cleanuppad\");\n         let ret = unsafe {\n             llvm::LLVMRustBuildCleanupPad(self.llbuilder,\n@@ -1075,7 +1007,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         &mut self, funclet: &Funclet<'ll>,\n         unwind: Option<&'ll BasicBlock>,\n     ) -> &'ll Value {\n-        self.count_insn(\"cleanupret\");\n         let ret = unsafe {\n             llvm::LLVMRustBuildCleanupRet(self.llbuilder, funclet.cleanuppad(), unwind)\n         };\n@@ -1085,7 +1016,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn catch_pad(&mut self,\n                      parent: &'ll Value,\n                      args: &[&'ll Value]) -> Funclet<'ll> {\n-        self.count_insn(\"catchpad\");\n         let name = const_cstr!(\"catchpad\");\n         let ret = unsafe {\n             llvm::LLVMRustBuildCatchPad(self.llbuilder, parent,\n@@ -1101,7 +1031,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         unwind: Option<&'ll BasicBlock>,\n         num_handlers: usize,\n     ) -> &'ll Value {\n-        self.count_insn(\"catchswitch\");\n         let name = const_cstr!(\"catchswitch\");\n         let ret = unsafe {\n             llvm::LLVMRustBuildCatchSwitch(self.llbuilder, parent, unwind,\n@@ -1199,7 +1128,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         args: &[&'ll Value],\n         funclet: Option<&Funclet<'ll>>,\n     ) -> &'ll Value {\n-        self.count_insn(\"call\");\n \n         debug!(\"Call {:?} with args ({:?})\",\n                llfn,\n@@ -1221,7 +1149,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn zext(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"zext\");\n         unsafe {\n             llvm::LLVMBuildZExt(self.llbuilder, val, dest_ty, noname())\n         }\n@@ -1285,32 +1212,17 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn count_insn(&self, category: &str) {\n-        if self.sess().codegen_stats() {\n-            self.stats.borrow_mut().n_llvm_insns += 1;\n-        }\n-        if self.sess().count_llvm_insns() {\n-            *self.stats\n-                      .borrow_mut()\n-                      .llvm_insns\n-                      .entry(category.to_string())\n-                      .or_insert(0) += 1;\n-        }\n-    }\n-\n     fn position_at_start(&mut self, llbb: &'ll BasicBlock) {\n         unsafe {\n             llvm::LLVMRustPositionBuilderAtStart(self.llbuilder, llbb);\n         }\n     }\n \n     pub fn minnum(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"minnum\");\n         unsafe { llvm::LLVMRustBuildMinNum(self.llbuilder, lhs, rhs) }\n     }\n \n     pub fn maxnum(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"maxnum\");\n         unsafe { llvm::LLVMRustBuildMaxNum(self.llbuilder, lhs, rhs) }\n     }\n \n@@ -1319,7 +1231,6 @@ impl Builder<'a, 'll, 'tcx> {\n         elt: &'ll Value,\n         idx: &'ll Value,\n     ) -> &'ll Value {\n-        self.count_insn(\"insertelement\");\n         unsafe {\n             llvm::LLVMBuildInsertElement(self.llbuilder, vec, elt, idx, noname())\n         }\n@@ -1331,14 +1242,12 @@ impl Builder<'a, 'll, 'tcx> {\n         v2: &'ll Value,\n         mask: &'ll Value,\n     ) -> &'ll Value {\n-        self.count_insn(\"shufflevector\");\n         unsafe {\n             llvm::LLVMBuildShuffleVector(self.llbuilder, v1, v2, mask, noname())\n         }\n     }\n \n     pub fn vector_reduce_fadd_fast(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fadd_fast\");\n         unsafe {\n             // FIXME: add a non-fast math version once\n             // https://bugs.llvm.org/show_bug.cgi?id=36732\n@@ -1349,7 +1258,6 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n     pub fn vector_reduce_fmul_fast(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fmul_fast\");\n         unsafe {\n             // FIXME: add a non-fast math version once\n             // https://bugs.llvm.org/show_bug.cgi?id=36732\n@@ -1360,55 +1268,44 @@ impl Builder<'a, 'll, 'tcx> {\n         }\n     }\n     pub fn vector_reduce_add(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.add\");\n         unsafe { llvm::LLVMRustBuildVectorReduceAdd(self.llbuilder, src) }\n     }\n     pub fn vector_reduce_mul(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.mul\");\n         unsafe { llvm::LLVMRustBuildVectorReduceMul(self.llbuilder, src) }\n     }\n     pub fn vector_reduce_and(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.and\");\n         unsafe { llvm::LLVMRustBuildVectorReduceAnd(self.llbuilder, src) }\n     }\n     pub fn vector_reduce_or(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.or\");\n         unsafe { llvm::LLVMRustBuildVectorReduceOr(self.llbuilder, src) }\n     }\n     pub fn vector_reduce_xor(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.xor\");\n         unsafe { llvm::LLVMRustBuildVectorReduceXor(self.llbuilder, src) }\n     }\n     pub fn vector_reduce_fmin(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fmin\");\n         unsafe { llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ false) }\n     }\n     pub fn vector_reduce_fmax(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fmax\");\n         unsafe { llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ false) }\n     }\n     pub fn vector_reduce_fmin_fast(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fmin_fast\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ true);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n     pub fn vector_reduce_fmax_fast(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fmax_fast\");\n         unsafe {\n             let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ true);\n             llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n             instr\n         }\n     }\n     pub fn vector_reduce_min(&mut self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.min\");\n         unsafe { llvm::LLVMRustBuildVectorReduceMin(self.llbuilder, src, is_signed) }\n     }\n     pub fn vector_reduce_max(&mut self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.max\");\n         unsafe { llvm::LLVMRustBuildVectorReduceMax(self.llbuilder, src, is_signed) }\n     }\n \n@@ -1419,7 +1316,6 @@ impl Builder<'a, 'll, 'tcx> {\n     }\n \n     pub fn catch_ret(&mut self, funclet: &Funclet<'ll>, unwind: &'ll BasicBlock) -> &'ll Value {\n-        self.count_insn(\"catchret\");\n         let ret = unsafe {\n             llvm::LLVMRustBuildCatchRet(self.llbuilder, funclet.cleanuppad(), unwind)\n         };\n@@ -1488,7 +1384,6 @@ impl Builder<'a, 'll, 'tcx> {\n     }\n \n     pub fn va_arg(&mut self, list: &'ll Value, ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"vaarg\");\n         unsafe {\n             llvm::LLVMBuildVAArg(self.llbuilder, list, ty, noname())\n         }\n@@ -1511,7 +1406,6 @@ impl Builder<'a, 'll, 'tcx> {\n     }\n \n     fn phi(&mut self, ty: &'ll Type, vals: &[&'ll Value], bbs: &[&'ll BasicBlock]) -> &'ll Value {\n-        self.count_insn(\"addincoming\");\n         assert_eq!(vals.len(), bbs.len());\n         let phi = unsafe {\n             llvm::LLVMBuildPhi(self.llbuilder, ty, noname())\n@@ -1525,7 +1419,6 @@ impl Builder<'a, 'll, 'tcx> {\n     }\n \n     fn add_incoming_to_phi(&mut self, phi: &'ll Value, val: &'ll Value, bb: &'ll BasicBlock) {\n-        self.count_insn(\"addincoming\");\n         unsafe {\n             llvm::LLVMAddIncoming(phi, &val, &bb, 1 as c_uint);\n         }"}, {"sha": "99b5cf42551faff6d56c991e7174c3180c905d7d", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -102,7 +102,7 @@ fn check_and_apply_linkage(\n     attrs: &CodegenFnAttrs,\n     ty: Ty<'tcx>,\n     sym: LocalInternedString,\n-    span: Option<Span>\n+    span: Span\n ) -> &'ll Value {\n     let llty = cx.layout_of(ty).llvm_type(cx);\n     if let Some(linkage) = attrs.linkage {\n@@ -116,11 +116,8 @@ fn check_and_apply_linkage(\n         let llty2 = if let ty::RawPtr(ref mt) = ty.sty {\n             cx.layout_of(mt.ty).llvm_type(cx)\n         } else {\n-            if let Some(span) = span {\n-                cx.sess().span_fatal(span, \"must have type `*const T` or `*mut T`\")\n-            } else {\n-                bug!(\"must have type `*const T` or `*mut T`\")\n-            }\n+            cx.sess().span_fatal(\n+                span, \"must have type `*const T` or `*mut T` due to `#[linkage]` attribute\")\n         };\n         unsafe {\n             // Declare a symbol `foo` with the desired linkage.\n@@ -136,14 +133,7 @@ fn check_and_apply_linkage(\n             let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n             real_name.push_str(&sym);\n             let g2 = cx.define_global(&real_name, llty).unwrap_or_else(||{\n-                if let Some(span) = span {\n-                    cx.sess().span_fatal(\n-                        span,\n-                        &format!(\"symbol `{}` is already defined\", &sym)\n-                    )\n-                } else {\n-                    bug!(\"symbol `{}` is already defined\", &sym)\n-                }\n+                cx.sess().span_fatal(span, &format!(\"symbol `{}` is already defined\", &sym))\n             });\n             llvm::LLVMRustSetLinkage(g2, llvm::Linkage::InternalLinkage);\n             llvm::LLVMSetInitializer(g2, g1);\n@@ -240,7 +230,7 @@ impl CodegenCx<'ll, 'tcx> {\n                     ref attrs, span, node: hir::ForeignItemKind::Static(..), ..\n                 }) => {\n                     let fn_attrs = self.tcx.codegen_fn_attrs(def_id);\n-                    (check_and_apply_linkage(&self, &fn_attrs, ty, sym, Some(span)), attrs)\n+                    (check_and_apply_linkage(&self, &fn_attrs, ty, sym, span), attrs)\n                 }\n \n                 item => bug!(\"get_static: expected static, found {:?}\", item)\n@@ -260,7 +250,8 @@ impl CodegenCx<'ll, 'tcx> {\n             debug!(\"get_static: sym={} item_attr={:?}\", sym, self.tcx.item_attrs(def_id));\n \n             let attrs = self.tcx.codegen_fn_attrs(def_id);\n-            let g = check_and_apply_linkage(&self, &attrs, ty, sym, None);\n+            let span = self.tcx.def_span(def_id);\n+            let g = check_and_apply_linkage(&self, &attrs, ty, sym, span);\n \n             // Thread-local statics in some other crate need to *always* be linked\n             // against in a thread-local fashion, so we need to be sure to apply the"}, {"sha": "b6b47d047c8b1023e8c7ef843167ff0b3d502257", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -12,7 +12,6 @@ use rustc_codegen_ssa::traits::*;\n \n use rustc_data_structures::base_n;\n use rustc_data_structures::small_c_str::SmallCStr;\n-use rustc::mir::mono::Stats;\n use rustc::session::config::{self, DebugInfo};\n use rustc::session::Session;\n use rustc::ty::layout::{\n@@ -44,7 +43,6 @@ pub struct CodegenCx<'ll, 'tcx: 'll> {\n \n     pub llmod: &'ll llvm::Module,\n     pub llcx: &'ll llvm::Context,\n-    pub stats: RefCell<Stats>,\n     pub codegen_unit: Arc<CodegenUnit<'tcx>>,\n \n     /// Cache instances of monomorphic and polymorphic items\n@@ -284,7 +282,6 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n             tls_model,\n             llmod,\n             llcx,\n-            stats: RefCell::new(Stats::default()),\n             codegen_unit,\n             instances: Default::default(),\n             vtables: Default::default(),\n@@ -408,14 +405,6 @@ impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         self.check_overflow\n     }\n \n-    fn stats(&self) -> &RefCell<Stats> {\n-        &self.stats\n-    }\n-\n-    fn consume_stats(self) -> RefCell<Stats> {\n-        self.stats\n-    }\n-\n     fn codegen_unit(&self) -> &Arc<CodegenUnit<'tcx>> {\n         &self.codegen_unit\n     }"}, {"sha": "57cffa48163e1d6506a857c38776cb9b4d87d21a", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -52,7 +52,6 @@ use rustc_codegen_ssa::CompiledModule;\n use errors::{FatalError, Handler};\n use rustc::dep_graph::WorkProduct;\n use syntax_pos::symbol::InternedString;\n-use rustc::mir::mono::Stats;\n pub use llvm_util::target_features;\n use std::any::Any;\n use std::sync::{mpsc, Arc};\n@@ -130,8 +129,8 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n         &self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         cgu_name: InternedString,\n-    ) -> Stats {\n-        base::compile_codegen_unit(tcx, cgu_name)\n+    ) {\n+        base::compile_codegen_unit(tcx, cgu_name);\n     }\n     fn target_machine_factory(\n         &self,"}, {"sha": "172b5b39987d43247f137f5039361318c3ebe749", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 2, "deletions": 72, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -20,15 +20,14 @@ use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::cstore::EncodedMetadata;\n use rustc::middle::lang_items::StartFnLangItem;\n use rustc::middle::weak_lang_items;\n-use rustc::mir::mono::{Stats, CodegenUnitNameBuilder};\n+use rustc::mir::mono::CodegenUnitNameBuilder;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n use rustc::ty::query::Providers;\n use rustc::middle::cstore::{self, LinkagePreference};\n use rustc::util::common::{time, print_time_passes_entry};\n use rustc::session::config::{self, EntryFnType, Lto};\n use rustc::session::Session;\n-use rustc_mir::monomorphize::item::DefPathBasedNames;\n use rustc_mir::monomorphize::Instance;\n use rustc_mir::monomorphize::partitioning::{CodegenUnit, CodegenUnitExt};\n use rustc::util::nodemap::FxHashMap;\n@@ -58,40 +57,6 @@ use rustc::hir;\n \n use crate::mir::operand::OperandValue;\n \n-use std::marker::PhantomData;\n-\n-pub struct StatRecorder<'a, 'tcx, Cx: 'a + CodegenMethods<'tcx>> {\n-    cx: &'a Cx,\n-    name: Option<String>,\n-    istart: usize,\n-    _marker: PhantomData<&'tcx ()>,\n-}\n-\n-impl<'a, 'tcx, Cx: CodegenMethods<'tcx>> StatRecorder<'a, 'tcx, Cx> {\n-    pub fn new(cx: &'a Cx, name: String) -> Self {\n-        let istart = cx.stats().borrow().n_llvm_insns;\n-        StatRecorder {\n-            cx,\n-            name: Some(name),\n-            istart,\n-            _marker: PhantomData,\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx, Cx: CodegenMethods<'tcx>> Drop for StatRecorder<'a, 'tcx, Cx> {\n-    fn drop(&mut self) {\n-        if self.cx.sess().codegen_stats() {\n-            let mut stats = self.cx.stats().borrow_mut();\n-            let iend = stats.n_llvm_insns;\n-            stats.fn_stats.push((self.name.take().unwrap(), iend - self.istart));\n-            stats.n_fns += 1;\n-            // Reset LLVM insn count to avoid compound costs.\n-            stats.n_llvm_insns = self.istart;\n-        }\n-    }\n-}\n-\n pub fn bin_op_to_icmp_predicate(op: hir::BinOpKind,\n                                 signed: bool)\n                                 -> IntPredicate {\n@@ -408,15 +373,6 @@ pub fn codegen_instance<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     cx: &'a Bx::CodegenCx,\n     instance: Instance<'tcx>,\n ) {\n-    let _s = if cx.sess().codegen_stats() {\n-        let mut instance_name = String::new();\n-        DefPathBasedNames::new(cx.tcx(), true, true)\n-            .push_def_path(instance.def_id(), &mut instance_name);\n-        Some(StatRecorder::new(cx, instance_name))\n-    } else {\n-        None\n-    };\n-\n     // this is an info! to allow collecting monomorphization statistics\n     // and to allow finding the last function before LLVM aborts from\n     // release builds.\n@@ -428,8 +384,6 @@ pub fn codegen_instance<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     let lldecl = cx.instances().borrow().get(&instance).cloned().unwrap_or_else(||\n         bug!(\"Instance `{:?}` not already declared\", instance));\n \n-    cx.stats().borrow_mut().n_closures += 1;\n-\n     let mir = cx.tcx().instance_mir(instance.def);\n     mir::codegen_mir::<Bx>(cx, lldecl, &mir, instance, sig);\n }\n@@ -653,7 +607,6 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     };\n \n     let mut total_codegen_time = Duration::new(0, 0);\n-    let mut all_stats = Stats::default();\n \n     for cgu in codegen_units.into_iter() {\n         ongoing_codegen.wait_for_signal_to_codegen_item();\n@@ -666,8 +619,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n             CguReuse::No => {\n                 tcx.sess.profiler(|p| p.start_activity(format!(\"codegen {}\", cgu.name())));\n                 let start_time = Instant::now();\n-                let stats = backend.compile_codegen_unit(tcx, *cgu.name());\n-                all_stats.extend(stats);\n+                backend.compile_codegen_unit(tcx, *cgu.name());\n                 total_codegen_time += start_time.elapsed();\n                 tcx.sess.profiler(|p| p.end_activity(format!(\"codegen {}\", cgu.name())));\n                 false\n@@ -701,28 +653,6 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n \n     symbol_names_test::report_symbol_names(tcx);\n \n-    if tcx.sess.codegen_stats() {\n-        println!(\"--- codegen stats ---\");\n-        println!(\"n_glues_created: {}\", all_stats.n_glues_created);\n-        println!(\"n_null_glues: {}\", all_stats.n_null_glues);\n-        println!(\"n_real_glues: {}\", all_stats.n_real_glues);\n-\n-        println!(\"n_fns: {}\", all_stats.n_fns);\n-        println!(\"n_inlines: {}\", all_stats.n_inlines);\n-        println!(\"n_closures: {}\", all_stats.n_closures);\n-        println!(\"fn stats:\");\n-        all_stats.fn_stats.sort_by_key(|&(_, insns)| insns);\n-        for &(ref name, insns) in all_stats.fn_stats.iter() {\n-            println!(\"{} insns, {}\", insns, *name);\n-        }\n-    }\n-\n-    if tcx.sess.count_llvm_insns() {\n-        for (k, v) in all_stats.llvm_insns.iter() {\n-            println!(\"{:7} {}\", *v, *k);\n-        }\n-    }\n-\n     ongoing_codegen.check_for_errors(tcx.sess);\n \n     assert_and_save_dep_graph(tcx);"}, {"sha": "cd32d6f484d730f671a650f06edb4c284954db8a", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -396,22 +396,20 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let cx = self.cx;\n         let tcx = self.cx.tcx();\n \n-        if let mir::Place::Base(mir::PlaceBase::Local(index)) = *place {\n-            match self.locals[index] {\n-                LocalRef::Place(place) => {\n-                    return place;\n-                }\n-                LocalRef::UnsizedPlace(place) => {\n-                    return bx.load_operand(place).deref(cx);\n-                }\n-                LocalRef::Operand(..) => {\n-                    bug!(\"using operand local {:?} as place\", place);\n+        let result = match *place {\n+            mir::Place::Base(mir::PlaceBase::Local(index)) => {\n+                match self.locals[index] {\n+                    LocalRef::Place(place) => {\n+                        return place;\n+                    }\n+                    LocalRef::UnsizedPlace(place) => {\n+                        return bx.load_operand(place).deref(cx);\n+                    }\n+                    LocalRef::Operand(..) => {\n+                        bug!(\"using operand local {:?} as place\", place);\n+                    }\n                 }\n             }\n-        }\n-\n-        let result = match *place {\n-            mir::Place::Base(mir::PlaceBase::Local(_)) => bug!(), // handled above\n             mir::Place::Base(\n                 mir::PlaceBase::Static(\n                     box mir::Static { ty, kind: mir::StaticKind::Promoted(promoted) }"}, {"sha": "0466b47cf148f8c680d49563ca8948ce58921207", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -5,7 +5,6 @@ use super::write::WriteBackendMethods;\n use super::CodegenObject;\n use rustc::middle::allocator::AllocatorKind;\n use rustc::middle::cstore::EncodedMetadata;\n-use rustc::mir::mono::Stats;\n use rustc::session::{Session, config};\n use rustc::ty::TyCtxt;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n@@ -49,7 +48,7 @@ pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Se\n         &self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         cgu_name: InternedString,\n-    ) -> Stats;\n+    );\n     // If find_features is true this won't access `sess.crate_types` by assuming\n     // that `is_pie_binary` is false. When we discover LLVM target features\n     // `sess.crate_types` is uninitialized so we cannot access it."}, {"sha": "5ea86df6e9459cc76fcb3e0c5dfb007b65003b84", "filename": "src/librustc_codegen_ssa/traits/misc.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmisc.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -1,5 +1,4 @@\n use super::BackendTypes;\n-use rustc::mir::mono::Stats;\n use rustc::session::Session;\n use rustc::ty::{self, Instance, Ty};\n use rustc::util::nodemap::FxHashMap;\n@@ -17,8 +16,6 @@ pub trait MiscMethods<'tcx>: BackendTypes {\n     fn eh_personality(&self) -> Self::Value;\n     fn eh_unwind_resume(&self) -> Self::Value;\n     fn sess(&self) -> &Session;\n-    fn stats(&self) -> &RefCell<Stats>;\n-    fn consume_stats(self) -> RefCell<Stats>;\n     fn codegen_unit(&self) -> &Arc<CodegenUnit<'tcx>>;\n     fn used_statics(&self) -> &RefCell<Vec<Self::Value>>;\n     fn set_frame_pointer_elimination(&self, llfn: Self::Value);"}, {"sha": "c7f6e54c3d56b1dd713af054614859256a7721bb", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -212,6 +212,11 @@ macro_rules! newtype_index {\n             fn add_usize(&self, u: usize) -> Option<Self> {\n                 Idx::index(*self).checked_add(u).map(Self::new)\n             }\n+\n+            #[inline]\n+            fn sub_usize(&self, u: usize) -> Option<Self> {\n+                Idx::index(*self).checked_sub(u).map(Self::new)\n+            }\n         }\n \n         impl From<$type> for u32 {"}, {"sha": "e1112a1557771c7e4b7f6fa4c34ba452801ec52f", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 174, "deletions": 167, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -162,6 +162,7 @@ impl ColorConfig {\n     }\n }\n \n+/// Handles the writing of `HumanReadableErrorType::Default` and `HumanReadableErrorType::Short`\n pub struct EmitterWriter {\n     dst: Destination,\n     sm: Option<Lrc<SourceMapperDyn>>,\n@@ -170,7 +171,8 @@ pub struct EmitterWriter {\n     ui_testing: bool,\n }\n \n-struct FileWithAnnotatedLines {\n+#[derive(Debug)]\n+pub struct FileWithAnnotatedLines {\n     file: Lrc<SourceFile>,\n     lines: Vec<Line>,\n     multiline_depth: usize,\n@@ -221,169 +223,6 @@ impl EmitterWriter {\n         }\n     }\n \n-    fn preprocess_annotations(&mut self, msp: &MultiSpan) -> Vec<FileWithAnnotatedLines> {\n-        fn add_annotation_to_file(file_vec: &mut Vec<FileWithAnnotatedLines>,\n-                                  file: Lrc<SourceFile>,\n-                                  line_index: usize,\n-                                  ann: Annotation) {\n-\n-            for slot in file_vec.iter_mut() {\n-                // Look through each of our files for the one we're adding to\n-                if slot.file.name == file.name {\n-                    // See if we already have a line for it\n-                    for line_slot in &mut slot.lines {\n-                        if line_slot.line_index == line_index {\n-                            line_slot.annotations.push(ann);\n-                            return;\n-                        }\n-                    }\n-                    // We don't have a line yet, create one\n-                    slot.lines.push(Line {\n-                        line_index,\n-                        annotations: vec![ann],\n-                    });\n-                    slot.lines.sort();\n-                    return;\n-                }\n-            }\n-            // This is the first time we're seeing the file\n-            file_vec.push(FileWithAnnotatedLines {\n-                file,\n-                lines: vec![Line {\n-                                line_index,\n-                                annotations: vec![ann],\n-                            }],\n-                multiline_depth: 0,\n-            });\n-        }\n-\n-        let mut output = vec![];\n-        let mut multiline_annotations = vec![];\n-\n-        if let Some(ref sm) = self.sm {\n-            for span_label in msp.span_labels() {\n-                if span_label.span.is_dummy() {\n-                    continue;\n-                }\n-\n-                let lo = sm.lookup_char_pos(span_label.span.lo());\n-                let mut hi = sm.lookup_char_pos(span_label.span.hi());\n-\n-                // Watch out for \"empty spans\". If we get a span like 6..6, we\n-                // want to just display a `^` at 6, so convert that to\n-                // 6..7. This is degenerate input, but it's best to degrade\n-                // gracefully -- and the parser likes to supply a span like\n-                // that for EOF, in particular.\n-\n-                if lo.col_display == hi.col_display && lo.line == hi.line {\n-                    hi.col_display += 1;\n-                }\n-\n-                let ann_type = if lo.line != hi.line {\n-                    let ml = MultilineAnnotation {\n-                        depth: 1,\n-                        line_start: lo.line,\n-                        line_end: hi.line,\n-                        start_col: lo.col_display,\n-                        end_col: hi.col_display,\n-                        is_primary: span_label.is_primary,\n-                        label: span_label.label.clone(),\n-                        overlaps_exactly: false,\n-                    };\n-                    multiline_annotations.push((lo.file.clone(), ml.clone()));\n-                    AnnotationType::Multiline(ml)\n-                } else {\n-                    AnnotationType::Singleline\n-                };\n-                let ann = Annotation {\n-                    start_col: lo.col_display,\n-                    end_col: hi.col_display,\n-                    is_primary: span_label.is_primary,\n-                    label: span_label.label.clone(),\n-                    annotation_type: ann_type,\n-                };\n-\n-                if !ann.is_multiline() {\n-                    add_annotation_to_file(&mut output, lo.file, lo.line, ann);\n-                }\n-            }\n-        }\n-\n-        // Find overlapping multiline annotations, put them at different depths\n-        multiline_annotations.sort_by_key(|&(_, ref ml)| (ml.line_start, ml.line_end));\n-        for item in multiline_annotations.clone() {\n-            let ann = item.1;\n-            for item in multiline_annotations.iter_mut() {\n-                let ref mut a = item.1;\n-                // Move all other multiline annotations overlapping with this one\n-                // one level to the right.\n-                if !(ann.same_span(a)) &&\n-                    num_overlap(ann.line_start, ann.line_end, a.line_start, a.line_end, true)\n-                {\n-                    a.increase_depth();\n-                } else if ann.same_span(a) && &ann != a {\n-                    a.overlaps_exactly = true;\n-                } else {\n-                    break;\n-                }\n-            }\n-        }\n-\n-        let mut max_depth = 0;  // max overlapping multiline spans\n-        for (file, ann) in multiline_annotations {\n-            if ann.depth > max_depth {\n-                max_depth = ann.depth;\n-            }\n-            let mut end_ann = ann.as_end();\n-            if !ann.overlaps_exactly {\n-                // avoid output like\n-                //\n-                //  |        foo(\n-                //  |   _____^\n-                //  |  |_____|\n-                //  | ||         bar,\n-                //  | ||     );\n-                //  | ||      ^\n-                //  | ||______|\n-                //  |  |______foo\n-                //  |         baz\n-                //\n-                // and instead get\n-                //\n-                //  |       foo(\n-                //  |  _____^\n-                //  | |         bar,\n-                //  | |     );\n-                //  | |      ^\n-                //  | |      |\n-                //  | |______foo\n-                //  |        baz\n-                add_annotation_to_file(&mut output, file.clone(), ann.line_start, ann.as_start());\n-                // 4 is the minimum vertical length of a multiline span when presented: two lines\n-                // of code and two lines of underline. This is not true for the special case where\n-                // the beginning doesn't have an underline, but the current logic seems to be\n-                // working correctly.\n-                let middle = min(ann.line_start + 4, ann.line_end);\n-                for line in ann.line_start + 1..middle {\n-                    // Every `|` that joins the beginning of the span (`___^`) to the end (`|__^`).\n-                    add_annotation_to_file(&mut output, file.clone(), line, ann.as_line());\n-                }\n-                if middle < ann.line_end - 1 {\n-                    for line in ann.line_end - 1..ann.line_end {\n-                        add_annotation_to_file(&mut output, file.clone(), line, ann.as_line());\n-                    }\n-                }\n-            } else {\n-                end_ann.annotation_type = AnnotationType::Singleline;\n-            }\n-            add_annotation_to_file(&mut output, file, ann.line_end, end_ann);\n-        }\n-        for file_vec in output.iter_mut() {\n-            file_vec.multiline_depth = max_depth;\n-        }\n-        output\n-    }\n-\n     fn render_source_line(&self,\n                           buffer: &mut StyledBuffer,\n                           file: Lrc<SourceFile>,\n@@ -1093,9 +932,7 @@ impl EmitterWriter {\n             }\n         }\n \n-        // Preprocess all the annotations so that they are grouped by file and by line number\n-        // This helps us quickly iterate over the whole message (including secondary file spans)\n-        let mut annotated_files = self.preprocess_annotations(msp);\n+        let mut annotated_files = FileWithAnnotatedLines::collect_annotations(msp, &self.sm);\n \n         // Make sure our primary file comes first\n         let (primary_lo, sm) = if let (Some(sm), Some(ref primary_span)) =\n@@ -1503,6 +1340,176 @@ impl EmitterWriter {\n     }\n }\n \n+impl FileWithAnnotatedLines {\n+    /// Preprocess all the annotations so that they are grouped by file and by line number\n+    /// This helps us quickly iterate over the whole message (including secondary file spans)\n+    pub fn collect_annotations(\n+        msp: &MultiSpan,\n+        source_map: &Option<Lrc<SourceMapperDyn>>\n+    ) -> Vec<FileWithAnnotatedLines> {\n+        fn add_annotation_to_file(file_vec: &mut Vec<FileWithAnnotatedLines>,\n+                                  file: Lrc<SourceFile>,\n+                                  line_index: usize,\n+                                  ann: Annotation) {\n+\n+            for slot in file_vec.iter_mut() {\n+                // Look through each of our files for the one we're adding to\n+                if slot.file.name == file.name {\n+                    // See if we already have a line for it\n+                    for line_slot in &mut slot.lines {\n+                        if line_slot.line_index == line_index {\n+                            line_slot.annotations.push(ann);\n+                            return;\n+                        }\n+                    }\n+                    // We don't have a line yet, create one\n+                    slot.lines.push(Line {\n+                        line_index,\n+                        annotations: vec![ann],\n+                    });\n+                    slot.lines.sort();\n+                    return;\n+                }\n+            }\n+            // This is the first time we're seeing the file\n+            file_vec.push(FileWithAnnotatedLines {\n+                file,\n+                lines: vec![Line {\n+                                line_index,\n+                                annotations: vec![ann],\n+                            }],\n+                multiline_depth: 0,\n+            });\n+        }\n+\n+        let mut output = vec![];\n+        let mut multiline_annotations = vec![];\n+\n+        if let Some(ref sm) = source_map {\n+            for span_label in msp.span_labels() {\n+                if span_label.span.is_dummy() {\n+                    continue;\n+                }\n+\n+                let lo = sm.lookup_char_pos(span_label.span.lo());\n+                let mut hi = sm.lookup_char_pos(span_label.span.hi());\n+\n+                // Watch out for \"empty spans\". If we get a span like 6..6, we\n+                // want to just display a `^` at 6, so convert that to\n+                // 6..7. This is degenerate input, but it's best to degrade\n+                // gracefully -- and the parser likes to supply a span like\n+                // that for EOF, in particular.\n+\n+                if lo.col_display == hi.col_display && lo.line == hi.line {\n+                    hi.col_display += 1;\n+                }\n+\n+                let ann_type = if lo.line != hi.line {\n+                    let ml = MultilineAnnotation {\n+                        depth: 1,\n+                        line_start: lo.line,\n+                        line_end: hi.line,\n+                        start_col: lo.col_display,\n+                        end_col: hi.col_display,\n+                        is_primary: span_label.is_primary,\n+                        label: span_label.label.clone(),\n+                        overlaps_exactly: false,\n+                    };\n+                    multiline_annotations.push((lo.file.clone(), ml.clone()));\n+                    AnnotationType::Multiline(ml)\n+                } else {\n+                    AnnotationType::Singleline\n+                };\n+                let ann = Annotation {\n+                    start_col: lo.col_display,\n+                    end_col: hi.col_display,\n+                    is_primary: span_label.is_primary,\n+                    label: span_label.label.clone(),\n+                    annotation_type: ann_type,\n+                };\n+\n+                if !ann.is_multiline() {\n+                    add_annotation_to_file(&mut output, lo.file, lo.line, ann);\n+                }\n+            }\n+        }\n+\n+        // Find overlapping multiline annotations, put them at different depths\n+        multiline_annotations.sort_by_key(|&(_, ref ml)| (ml.line_start, ml.line_end));\n+        for item in multiline_annotations.clone() {\n+            let ann = item.1;\n+            for item in multiline_annotations.iter_mut() {\n+                let ref mut a = item.1;\n+                // Move all other multiline annotations overlapping with this one\n+                // one level to the right.\n+                if !(ann.same_span(a)) &&\n+                    num_overlap(ann.line_start, ann.line_end, a.line_start, a.line_end, true)\n+                {\n+                    a.increase_depth();\n+                } else if ann.same_span(a) && &ann != a {\n+                    a.overlaps_exactly = true;\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        let mut max_depth = 0;  // max overlapping multiline spans\n+        for (file, ann) in multiline_annotations {\n+            if ann.depth > max_depth {\n+                max_depth = ann.depth;\n+            }\n+            let mut end_ann = ann.as_end();\n+            if !ann.overlaps_exactly {\n+                // avoid output like\n+                //\n+                //  |        foo(\n+                //  |   _____^\n+                //  |  |_____|\n+                //  | ||         bar,\n+                //  | ||     );\n+                //  | ||      ^\n+                //  | ||______|\n+                //  |  |______foo\n+                //  |         baz\n+                //\n+                // and instead get\n+                //\n+                //  |       foo(\n+                //  |  _____^\n+                //  | |         bar,\n+                //  | |     );\n+                //  | |      ^\n+                //  | |      |\n+                //  | |______foo\n+                //  |        baz\n+                add_annotation_to_file(&mut output, file.clone(), ann.line_start, ann.as_start());\n+                // 4 is the minimum vertical length of a multiline span when presented: two lines\n+                // of code and two lines of underline. This is not true for the special case where\n+                // the beginning doesn't have an underline, but the current logic seems to be\n+                // working correctly.\n+                let middle = min(ann.line_start + 4, ann.line_end);\n+                for line in ann.line_start + 1..middle {\n+                    // Every `|` that joins the beginning of the span (`___^`) to the end (`|__^`).\n+                    add_annotation_to_file(&mut output, file.clone(), line, ann.as_line());\n+                }\n+                if middle < ann.line_end - 1 {\n+                    for line in ann.line_end - 1..ann.line_end {\n+                        add_annotation_to_file(&mut output, file.clone(), line, ann.as_line());\n+                    }\n+                }\n+            } else {\n+                end_ann.annotation_type = AnnotationType::Singleline;\n+            }\n+            add_annotation_to_file(&mut output, file, ann.line_end, end_ann);\n+        }\n+        for file_vec in output.iter_mut() {\n+            file_vec.multiline_depth = max_depth;\n+        }\n+        output\n+    }\n+}\n+\n fn draw_col_separator(buffer: &mut StyledBuffer, line: usize, col: usize) {\n     buffer.puts(line, col, \"| \", Style::LineNumber);\n }"}, {"sha": "f989ebc6dfd8e0210c707e4523b7a550f176b64f", "filename": "src/librustc_macros/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2FCargo.toml?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -8,7 +8,7 @@ edition = \"2018\"\n proc-macro = true\n \n [dependencies]\n-synstructure = \"0.10.1\"\n+synstructure = \"0.10.2\"\n syn = { version = \"0.15.22\", features = [\"full\"] }\n proc-macro2 = \"0.4.24\"\n quote = \"0.6.10\""}, {"sha": "e3a79b24cabe8c5cfebe606fa5fa107d60e89a38", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -595,12 +595,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     ) -> (String, String, String, String) {\n         // Define a small closure that we can use to check if the type of a place\n         // is a union.\n-        let is_union = |place: &Place<'tcx>| -> bool {\n-            place.ty(self.mir, self.infcx.tcx).ty\n-                .ty_adt_def()\n-                .map(|adt| adt.is_union())\n-                .unwrap_or(false)\n+        let union_ty = |place: &Place<'tcx>| -> Option<Ty<'tcx>> {\n+            let ty = place.ty(self.mir, self.infcx.tcx).ty;\n+            ty.ty_adt_def().filter(|adt| adt.is_union()).map(|_| ty)\n         };\n+        let describe_place = |place| self.describe_place(place).unwrap_or_else(|| \"_\".to_owned());\n \n         // Start with an empty tuple, so we can use the functions on `Option` to reduce some\n         // code duplication (particularly around returning an empty description in the failure\n@@ -619,7 +618,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let mut current = first_borrowed_place;\n                 while let Place::Projection(box Projection { base, elem }) = current {\n                     match elem {\n-                        ProjectionElem::Field(field, _) if is_union(base) => {\n+                        ProjectionElem::Field(field, _) if union_ty(base).is_some() => {\n                             return Some((base, field));\n                         },\n                         _ => current = base,\n@@ -632,34 +631,32 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 // borrowed place and look for a access to a different field of the same union.\n                 let mut current = second_borrowed_place;\n                 while let Place::Projection(box Projection { base, elem }) = current {\n-                    match elem {\n-                        ProjectionElem::Field(field, _) if {\n-                            is_union(base) && field != target_field && base == target_base\n-                        } => {\n-                            let desc_base = self.describe_place(base)\n-                                .unwrap_or_else(|| \"_\".to_owned());\n-                            let desc_first = self.describe_place(first_borrowed_place)\n-                                .unwrap_or_else(|| \"_\".to_owned());\n-                            let desc_second = self.describe_place(second_borrowed_place)\n-                                .unwrap_or_else(|| \"_\".to_owned());\n-\n-                            // Also compute the name of the union type, eg. `Foo` so we\n-                            // can add a helpful note with it.\n-                            let ty = base.ty(self.mir, self.infcx.tcx).ty;\n-\n-                            return Some((desc_base, desc_first, desc_second, ty.to_string()));\n-                        },\n-                        _ => current = base,\n+                    if let ProjectionElem::Field(field, _) = elem {\n+                        if let Some(union_ty) = union_ty(base) {\n+                            if field != target_field && base == target_base {\n+                                return Some((\n+                                    describe_place(base),\n+                                    describe_place(first_borrowed_place),\n+                                    describe_place(second_borrowed_place),\n+                                    union_ty.to_string(),\n+                                ));\n+                            }\n+                        }\n                     }\n+\n+                    current = base;\n                 }\n                 None\n             })\n             .unwrap_or_else(|| {\n                 // If we didn't find a field access into a union, or both places match, then\n                 // only return the description of the first place.\n-                let desc_place = self.describe_place(first_borrowed_place)\n-                    .unwrap_or_else(|| \"_\".to_owned());\n-                (desc_place, \"\".to_string(), \"\".to_string(), \"\".to_string())\n+                (\n+                    describe_place(first_borrowed_place),\n+                    \"\".to_string(),\n+                    \"\".to_string(),\n+                    \"\".to_string(),\n+                )\n             })\n     }\n \n@@ -1616,7 +1613,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             );\n \n                             // Find the local from the operand.\n-                            let assigned_from_local = match assigned_from.local() {\n+                            let assigned_from_local = match assigned_from.local_or_deref_local() {\n                                 Some(local) => local,\n                                 None => continue,\n                             };\n@@ -1672,7 +1669,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     );\n \n                     // Find the local from the rvalue.\n-                    let assigned_from_local = match assigned_from.local() {\n+                    let assigned_from_local = match assigned_from.local_or_deref_local() {\n                         Some(local) => local,\n                         None => continue,\n                     };\n@@ -1735,7 +1732,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         assigned_from,\n                     );\n \n-                    if let Some(assigned_from_local) = assigned_from.local() {\n+                    if let Some(assigned_from_local) = assigned_from.local_or_deref_local() {\n                         debug!(\n                             \"annotate_argument_and_return_for_borrow: assigned_from_local={:?}\",\n                             assigned_from_local,"}, {"sha": "5a22c81a5d0578f1d83b52458e1c9b279f73b2f0", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -37,15 +37,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         diag: &mut DiagnosticBuilder<'_>,\n     ) {\n         debug!(\"add_moved_or_invoked_closure_note: location={:?} place={:?}\", location, place);\n-        let mut target = place.local();\n+        let mut target = place.local_or_deref_local();\n         for stmt in &self.mir[location.block].statements[location.statement_index..] {\n             debug!(\"add_moved_or_invoked_closure_note: stmt={:?} target={:?}\", stmt, target);\n             if let StatementKind::Assign(into, box Rvalue::Use(from)) = &stmt.kind {\n                 debug!(\"add_fnonce_closure_note: into={:?} from={:?}\", into, from);\n                 match from {\n                     Operand::Copy(ref place) |\n-                    Operand::Move(ref place) if target == place.local() =>\n-                        target = into.local(),\n+                    Operand::Move(ref place) if target == place.local_or_deref_local() =>\n+                        target = into.local_or_deref_local(),\n                     _ => {},\n                 }\n             }\n@@ -69,8 +69,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             if self.infcx.tcx.parent(id) == self.infcx.tcx.lang_items().fn_once_trait() {\n                 let closure = match args.first() {\n                     Some(Operand::Copy(ref place)) |\n-                    Some(Operand::Move(ref place)) if target == place.local() =>\n-                        place.local().unwrap(),\n+                    Some(Operand::Move(ref place)) if target == place.local_or_deref_local() =>\n+                        place.local_or_deref_local().unwrap(),\n                     _ => return,\n                 };\n "}, {"sha": "685db7713cac16dd5f3e713e3b5db6e44d02e74e", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -528,7 +528,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }) => {\n                 // Not projected from the implicit `self` in a closure.\n                 debug_assert!(\n-                    match base.local() {\n+                    match base.local_or_deref_local() {\n                         Some(local) => local == Local::new(1),\n                         None => false,\n                     },"}, {"sha": "0fb66032a171dd085f299a8e860c138289d4083e", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -46,8 +46,10 @@ impl<'a, 'tcx> BitDenotation<'tcx> for MaybeStorageLive<'a, 'tcx> {\n                          sets: &mut BlockSets<'_, Local>,\n                          loc: Location) {\n         match &self.mir[loc.block].terminator().kind {\n-            TerminatorKind::Drop { location, .. } => if let Some(l) = location.local() {\n-                sets.kill(l);\n+            TerminatorKind::Drop { location, .. } => {\n+                if let Some(l) = location.local_or_deref_local() {\n+                    sets.kill(l);\n+                }\n             }\n             _ => (),\n         }"}, {"sha": "a08c028390bf7a86b1184a5a118b8b47ed882111", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -1703,8 +1703,13 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn check_trait_or_impl_item(&self, hir_id: hir::HirId, assoc_item_kind: AssocItemKind,\n-                                defaultness: hir::Defaultness, vis: ty::Visibility) {\n+    fn check_assoc_item(\n+        &self,\n+        hir_id: hir::HirId,\n+        assoc_item_kind: AssocItemKind,\n+        defaultness: hir::Defaultness,\n+        vis: ty::Visibility,\n+    ) {\n         let mut check = self.check(hir_id, vis);\n \n         let (check_ty, is_assoc_ty) = match assoc_item_kind {\n@@ -1754,8 +1759,12 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                 self.check(item.hir_id, item_visibility).generics().predicates();\n \n                 for trait_item_ref in trait_item_refs {\n-                    self.check_trait_or_impl_item(trait_item_ref.id.hir_id, trait_item_ref.kind,\n-                                                  trait_item_ref.defaultness, item_visibility);\n+                    self.check_assoc_item(\n+                        trait_item_ref.id.hir_id,\n+                        trait_item_ref.kind,\n+                        trait_item_ref.defaultness,\n+                        item_visibility,\n+                    );\n                 }\n             }\n             hir::ItemKind::TraitAlias(..) => {\n@@ -1803,8 +1812,12 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                     } else {\n                         impl_vis\n                     };\n-                    self.check_trait_or_impl_item(impl_item_ref.id.hir_id, impl_item_ref.kind,\n-                                                  impl_item_ref.defaultness, impl_item_vis);\n+                    self.check_assoc_item(\n+                        impl_item_ref.id.hir_id,\n+                        impl_item_ref.kind,\n+                        impl_item_ref.defaultness,\n+                        impl_item_vis,\n+                    );\n                 }\n             }\n         }"}, {"sha": "9b7b44025c13f73043590e2edca2d2dddbeea68a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -860,7 +860,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n             FnKind::ItemFn(_, ref header, ..) =>\n                 (FnItemRibKind, &header.asyncness.node),\n             FnKind::Method(_, ref sig, _, _) =>\n-                (TraitOrImplItemRibKind, &sig.header.asyncness.node),\n+                (AssocItemRibKind, &sig.header.asyncness.node),\n             FnKind::Closure(_) =>\n                 // Async closures aren't resolved through `visit_fn`-- they're\n                 // processed separately\n@@ -1033,7 +1033,7 @@ enum RibKind<'a> {\n     /// methods or associated types. Allow references to ty params that impl or trait\n     /// binds. Disallow any other upvars (including other ty params that are\n     /// upvars).\n-    TraitOrImplItemRibKind,\n+    AssocItemRibKind,\n \n     /// We passed through a function definition. Disallow upvars.\n     /// Permit only those const parameters that are specified in the function's generics.\n@@ -2612,7 +2612,7 @@ impl<'a> Resolver<'a> {\n \n                         for trait_item in trait_items {\n                             let generic_params = HasGenericParams(&trait_item.generics,\n-                                                                    TraitOrImplItemRibKind);\n+                                                                    AssocItemRibKind);\n                             this.with_generic_param_rib(generic_params, |this| {\n                                 match trait_item.node {\n                                     TraitItemKind::Const(ref ty, ref default) => {\n@@ -2899,7 +2899,7 @@ impl<'a> Resolver<'a> {\n \n                                     // We also need a new scope for the impl item type parameters.\n                                     let generic_params = HasGenericParams(&impl_item.generics,\n-                                                                          TraitOrImplItemRibKind);\n+                                                                          AssocItemRibKind);\n                                     this.with_generic_param_rib(generic_params, |this| {\n                                         use self::ResolutionError::*;\n                                         match impl_item.node {\n@@ -4074,7 +4074,7 @@ impl<'a> Resolver<'a> {\n                                 seen.insert(node_id, depth);\n                             }\n                         }\n-                        ItemRibKind | FnItemRibKind | TraitOrImplItemRibKind => {\n+                        ItemRibKind | FnItemRibKind | AssocItemRibKind => {\n                             // This was an attempt to access an upvar inside a\n                             // named function item. This is not allowed, so we\n                             // report an error.\n@@ -4103,7 +4103,7 @@ impl<'a> Resolver<'a> {\n             Res::Def(DefKind::TyParam, _) | Res::SelfTy(..) => {\n                 for rib in ribs {\n                     match rib.kind {\n-                        NormalRibKind | TraitOrImplItemRibKind | ClosureRibKind(..) |\n+                        NormalRibKind | AssocItemRibKind | ClosureRibKind(..) |\n                         ModuleRibKind(..) | MacroDefinition(..) | ForwardTyParamBanRibKind |\n                         ConstantItemRibKind | TyParamAsConstParamTy => {\n                             // Nothing to do. Continue."}, {"sha": "c3ea9ff40a84341b6dafd36ee91dd44a58b157a8", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -270,7 +270,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         None\n     }\n \n-    fn is_hir_id_from_struct_pattern_shorthand_field(&self, hir_id: hir::HirId, sp: Span) -> bool {\n+    crate fn is_hir_id_from_struct_pattern_shorthand_field(\n+        &self,\n+        hir_id: hir::HirId,\n+        sp: Span,\n+    ) -> bool {\n         let cm = self.sess().source_map();\n         let parent_id = self.tcx.hir().get_parent_node_by_hir_id(hir_id);\n         if let Some(parent) = self.tcx.hir().find_by_hir_id(parent_id) {"}, {"sha": "c5b85d52566d3ea2a767e468fcaef4c5cf2b6b0f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -5010,6 +5010,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 Applicability::MachineApplicable,\n             );\n         } else if !self.check_for_cast(err, expr, found, expected) {\n+            let is_struct_pat_shorthand_field = self.is_hir_id_from_struct_pattern_shorthand_field(\n+                expr.hir_id,\n+                expr.span,\n+            );\n             let methods = self.get_conversion_methods(expr.span, expected, found);\n             if let Ok(expr_text) = self.sess().source_map().span_to_snippet(expr.span) {\n                 let mut suggestions = iter::repeat(&expr_text).zip(methods.iter())\n@@ -5019,14 +5023,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             None  // do not suggest code that is already there (#53348)\n                         } else {\n                             let method_call_list = [\".to_vec()\", \".to_string()\"];\n-                            if receiver.ends_with(\".clone()\")\n+                            let sugg = if receiver.ends_with(\".clone()\")\n                                     && method_call_list.contains(&method_call.as_str()) {\n                                 let max_len = receiver.rfind(\".\").unwrap();\n-                                Some(format!(\"{}{}\", &receiver[..max_len], method_call))\n-                            }\n-                            else {\n-                                Some(format!(\"{}{}\", receiver, method_call))\n-                            }\n+                                format!(\"{}{}\", &receiver[..max_len], method_call)\n+                            } else {\n+                                format!(\"{}{}\", receiver, method_call)\n+                            };\n+                            Some(if is_struct_pat_shorthand_field {\n+                                format!(\"{}: {}\", receiver, sugg)\n+                            } else {\n+                                sugg\n+                            })\n                         }\n                     }).peekable();\n                 if suggestions.peek().is_some() {"}, {"sha": "3806fd0998b5e8785c16f3b1c77d44a61d4c14f4", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 47, "deletions": 51, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -27,7 +27,7 @@ use rustc::ty::subst::{Subst, InternalSubsts};\n use rustc::ty::util::Discr;\n use rustc::ty::util::IntTypeExt;\n use rustc::ty::subst::UnpackedKind;\n-use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt};\n+use rustc::ty::{self, AdtKind, DefIdTree, ToPolyTraitRef, Ty, TyCtxt};\n use rustc::ty::{ReprOptions, ToPredicate};\n use rustc::util::captures::Captures;\n use rustc::util::nodemap::FxHashMap;\n@@ -1349,65 +1349,61 @@ pub fn checked_type_of<'a, 'tcx>(\n \n                     match path {\n                         QPath::Resolved(_, ref path) => {\n-                            let mut arg_index = 0;\n-                            let mut found_const = false;\n-                            for seg in &path.segments {\n-                                if let Some(generic_args) = &seg.args {\n-                                    let args = &generic_args.args;\n-                                    for arg in args {\n-                                        if let GenericArg::Const(ct) = arg {\n-                                            if ct.value.hir_id == hir_id {\n-                                                found_const = true;\n-                                                break;\n-                                            }\n-                                            arg_index += 1;\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                            // Sanity check to make sure everything is as expected.\n-                            if !found_const {\n-                                if !fail {\n-                                    return None;\n-                                }\n-                                bug!(\"no arg matching AnonConst in path\")\n-                            }\n-                            match path.res {\n-                                // We've encountered an `AnonConst` in some path, so we need to\n-                                // figure out which generic parameter it corresponds to and return\n-                                // the relevant type.\n-                                Res::Def(DefKind::Struct, def_id)\n-                                | Res::Def(DefKind::Union, def_id)\n-                                | Res::Def(DefKind::Enum, def_id)\n-                                | Res::Def(DefKind::Fn, def_id) => {\n-                                    let generics = tcx.generics_of(def_id);\n-                                    let mut param_index = 0;\n-                                    for param in &generics.params {\n-                                        if let ty::GenericParamDefKind::Const = param.kind {\n-                                            if param_index == arg_index {\n-                                                return Some(tcx.type_of(param.def_id));\n-                                            }\n-                                            param_index += 1;\n-                                        }\n-                                    }\n-                                    // This is no generic parameter associated with the arg. This is\n-                                    // probably from an extra arg where one is not needed.\n-                                    return Some(tcx.types.err);\n-                                }\n-                                Res::Err => tcx.types.err,\n-                                x => {\n+                            let arg_index = path.segments.iter()\n+                                .filter_map(|seg| seg.args.as_ref())\n+                                .map(|generic_args| generic_args.args.as_ref())\n+                                .find_map(|args| {\n+                                    args.iter()\n+                                        .filter(|arg| arg.is_const())\n+                                        .enumerate()\n+                                        .filter(|(_, arg)| arg.id() == hir_id)\n+                                        .map(|(index, _)| index)\n+                                        .next()\n+                                })\n+                                .or_else(|| {\n                                     if !fail {\n-                                        return None;\n+                                        None\n+                                    } else {\n+                                        bug!(\"no arg matching AnonConst in path\")\n                                     }\n+                                })?;\n+\n+                            // We've encountered an `AnonConst` in some path, so we need to\n+                            // figure out which generic parameter it corresponds to and return\n+                            // the relevant type.\n+                            let generics = match path.res {\n+                                Res::Def(DefKind::Ctor(..), def_id) =>\n+                                    tcx.generics_of(tcx.parent(def_id).unwrap()),\n+                                Res::Def(_, def_id) =>\n+                                    tcx.generics_of(def_id),\n+                                Res::Err =>\n+                                    return Some(tcx.types.err),\n+                                _ if !fail =>\n+                                    return None,\n+                                x => {\n                                     tcx.sess.delay_span_bug(\n                                         DUMMY_SP,\n                                         &format!(\n                                             \"unexpected const parent path def {:?}\", x\n                                         ),\n                                     );\n-                                    tcx.types.err\n+                                    return Some(tcx.types.err);\n                                 }\n-                            }\n+                            };\n+\n+                            generics.params.iter()\n+                                .filter(|param| {\n+                                    if let ty::GenericParamDefKind::Const = param.kind {\n+                                        true\n+                                    } else {\n+                                        false\n+                                    }\n+                                })\n+                                .nth(arg_index)\n+                                .map(|param| tcx.type_of(param.def_id))\n+                                // This is no generic parameter associated with the arg. This is\n+                                // probably from an extra arg where one is not needed.\n+                                .unwrap_or(tcx.types.err)\n                         }\n                         x => {\n                             if !fail {"}, {"sha": "b75212d606fa5a63894b23c5d542dea00fe2e0c5", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -9,7 +9,7 @@ name = \"rustdoc\"\n path = \"lib.rs\"\n \n [dependencies]\n-pulldown-cmark = { version = \"0.4.1\", default-features = false }\n+pulldown-cmark = { version = \"0.5.2\", default-features = false }\n minifier = \"0.0.30\"\n tempfile = \"3\"\n parking_lot = \"0.7\""}, {"sha": "e68ad6a7c3b4bc375c6e5a8f7db6c0298cd67aaa", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -3145,10 +3145,7 @@ impl<'tcx> Clean<Constant> for ty::Const<'tcx> {\n     fn clean(&self, cx: &DocContext<'_>) -> Constant {\n         Constant {\n             type_: self.ty.clean(cx),\n-            expr: match self.val {\n-                ConstValue::Param(ty::ParamConst { name, .. }) => format!(\"{}\", name),\n-                e => format!(\"{:?}\", e), // FIXME generic consts with expressions\n-            },\n+            expr: format!(\"{}\", self),\n         }\n     }\n }"}, {"sha": "334b83156507654dc638765b652ff1d942cb3a42", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -351,9 +351,11 @@ impl<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> Iterator for HeadingLinks<'a,\n         if let Some(Event::Start(Tag::Header(level))) = event {\n             let mut id = String::new();\n             for event in &mut self.inner {\n-                match event {\n+                match &event {\n                     Event::End(Tag::Header(..)) => break,\n-                    Event::Text(ref text) => id.extend(text.chars().filter_map(slugify)),\n+                    Event::Text(text) | Event::Code(text) => {\n+                        id.extend(text.chars().filter_map(slugify));\n+                    }\n                     _ => {},\n                 }\n                 self.buf.push_back(event);\n@@ -402,7 +404,6 @@ fn check_if_allowed_tag(t: &Tag<'_>) -> bool {\n         | Tag::Item\n         | Tag::Emphasis\n         | Tag::Strong\n-        | Tag::Code\n         | Tag::Link(..)\n         | Tag::BlockQuote => true,\n         _ => false,\n@@ -790,9 +791,8 @@ pub fn plain_summary_line_full(md: &str, limit_length: bool) -> String {\n             let next_event = next_event.unwrap();\n             let (ret, is_in) = match next_event {\n                 Event::Start(Tag::Paragraph) => (None, 1),\n-                Event::Start(Tag::Code) => (Some(\"`\".to_owned()), 1),\n-                Event::End(Tag::Code) => (Some(\"`\".to_owned()), -1),\n                 Event::Start(Tag::Header(_)) => (None, 1),\n+                Event::Code(code) => (Some(format!(\"`{}`\", code)), 0),\n                 Event::Text(ref s) if self.is_in > 0 => (Some(s.as_ref().to_owned()), 0),\n                 Event::End(Tag::Paragraph) | Event::End(Tag::Header(_)) => (None, -1),\n                 _ => (None, 0),"}, {"sha": "5bce5d6ba5de1b264289dda9f60fa77cc50d22fb", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 120, "deletions": 26, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -17,7 +17,7 @@ use std::io::prelude::*;\n use std::io;\n use std::panic::{self, AssertUnwindSafe};\n use std::path::PathBuf;\n-use std::process::Command;\n+use std::process::{self, Command};\n use std::str;\n use std::sync::{Arc, Mutex};\n use syntax::symbol::sym;\n@@ -160,13 +160,45 @@ fn scrape_test_config(krate: &::rustc::hir::Crate) -> TestOptions {\n     opts\n }\n \n-fn run_test(test: &str, cratename: &str, filename: &FileName, line: usize,\n-            cfgs: Vec<String>, libs: Vec<SearchPath>,\n-            cg: CodegenOptions, externs: Externs,\n-            should_panic: bool, no_run: bool, as_test_harness: bool,\n-            compile_fail: bool, mut error_codes: Vec<String>, opts: &TestOptions,\n-            maybe_sysroot: Option<PathBuf>, linker: Option<PathBuf>, edition: Edition,\n-            persist_doctests: Option<PathBuf>) {\n+/// Documentation test failure modes.\n+enum TestFailure {\n+    /// The test failed to compile.\n+    CompileError,\n+    /// The test is marked `compile_fail` but compiled successfully.\n+    UnexpectedCompilePass,\n+    /// The test failed to compile (as expected) but the compiler output did not contain all\n+    /// expected error codes.\n+    MissingErrorCodes(Vec<String>),\n+    /// The test binary was unable to be executed.\n+    ExecutionError(io::Error),\n+    /// The test binary exited with a non-zero exit code.\n+    ///\n+    /// This typically means an assertion in the test failed or another form of panic occurred.\n+    ExecutionFailure(process::Output),\n+    /// The test is marked `should_panic` but the test binary executed successfully.\n+    UnexpectedRunPass,\n+}\n+\n+fn run_test(\n+    test: &str,\n+    cratename: &str,\n+    filename: &FileName,\n+    line: usize,\n+    cfgs: Vec<String>,\n+    libs: Vec<SearchPath>,\n+    cg: CodegenOptions,\n+    externs: Externs,\n+    should_panic: bool,\n+    no_run: bool,\n+    as_test_harness: bool,\n+    compile_fail: bool,\n+    mut error_codes: Vec<String>,\n+    opts: &TestOptions,\n+    maybe_sysroot: Option<PathBuf>,\n+    linker: Option<PathBuf>,\n+    edition: Edition,\n+    persist_doctests: Option<PathBuf>,\n+) -> Result<(), TestFailure> {\n     let (test, line_offset) = match panic::catch_unwind(|| {\n         make_test(test, Some(cratename), as_test_harness, opts, edition)\n     }) {\n@@ -307,44 +339,43 @@ fn run_test(test: &str, cratename: &str, filename: &FileName, line: usize,\n \n     match (compile_result, compile_fail) {\n         (Ok(()), true) => {\n-            panic!(\"test compiled while it wasn't supposed to\")\n+            return Err(TestFailure::UnexpectedCompilePass);\n         }\n         (Ok(()), false) => {}\n         (Err(_), true) => {\n-            if error_codes.len() > 0 {\n+            if !error_codes.is_empty() {\n                 let out = String::from_utf8(data.lock().unwrap().to_vec()).unwrap();\n                 error_codes.retain(|err| !out.contains(err));\n+\n+                if !error_codes.is_empty() {\n+                    return Err(TestFailure::MissingErrorCodes(error_codes));\n+                }\n             }\n         }\n         (Err(_), false) => {\n-            panic!(\"couldn't compile the test\")\n+            return Err(TestFailure::CompileError);\n         }\n     }\n \n-    if error_codes.len() > 0 {\n-        panic!(\"Some expected error codes were not found: {:?}\", error_codes);\n+    if no_run {\n+        return Ok(());\n     }\n \n-    if no_run { return }\n-\n     // Run the code!\n     let mut cmd = Command::new(output_file);\n \n     match cmd.output() {\n-        Err(e) => panic!(\"couldn't run the test: {}{}\", e,\n-                        if e.kind() == io::ErrorKind::PermissionDenied {\n-                            \" - maybe your tempdir is mounted with noexec?\"\n-                        } else { \"\" }),\n+        Err(e) => return Err(TestFailure::ExecutionError(e)),\n         Ok(out) => {\n             if should_panic && out.status.success() {\n-                panic!(\"test executable succeeded when it should have failed\");\n+                return Err(TestFailure::UnexpectedRunPass);\n             } else if !should_panic && !out.status.success() {\n-                panic!(\"test executable failed:\\n{}\\n{}\\n\",\n-                       str::from_utf8(&out.stdout).unwrap_or(\"\"),\n-                       str::from_utf8(&out.stderr).unwrap_or(\"\"));\n+                return Err(TestFailure::ExecutionFailure(out));\n             }\n         }\n     }\n+\n+    Ok(())\n }\n \n /// Transforms a test into code that can be compiled into a Rust binary, and returns the number of\n@@ -499,8 +530,13 @@ pub fn make_test(s: &str,\n         prog.push_str(everything_else);\n     } else {\n         let returns_result = everything_else.trim_end().ends_with(\"(())\");\n+        let returns_option = everything_else.trim_end().ends_with(\"Some(())\");\n         let (main_pre, main_post) = if returns_result {\n-            (\"fn main() { fn _inner() -> Result<(), impl core::fmt::Debug> {\",\n+            (if returns_option {\n+                \"fn main() { fn _inner() -> Option<()> {\"\n+            } else {\n+                \"fn main() { fn _inner() -> Result<(), impl core::fmt::Debug> {\"\n+            },\n              \"}\\n_inner().unwrap() }\")\n         } else {\n             (\"fn main() {\\n\", \"\\n}\")\n@@ -711,7 +747,7 @@ impl Tester for Collector {\n                 allow_fail: config.allow_fail,\n             },\n             testfn: testing::DynTestFn(box move || {\n-                run_test(\n+                let res = run_test(\n                     &test,\n                     &cratename,\n                     &filename,\n@@ -730,7 +766,65 @@ impl Tester for Collector {\n                     linker,\n                     edition,\n                     persist_doctests\n-                )\n+                );\n+\n+                if let Err(err) = res {\n+                    match err {\n+                        TestFailure::CompileError => {\n+                            eprint!(\"Couldn't compile the test.\");\n+                        }\n+                        TestFailure::UnexpectedCompilePass => {\n+                            eprint!(\"Test compiled successfully, but it's marked `compile_fail`.\");\n+                        }\n+                        TestFailure::UnexpectedRunPass => {\n+                            eprint!(\"Test executable succeeded, but it's marked `should_panic`.\");\n+                        }\n+                        TestFailure::MissingErrorCodes(codes) => {\n+                            eprint!(\"Some expected error codes were not found: {:?}\", codes);\n+                        }\n+                        TestFailure::ExecutionError(err) => {\n+                            eprint!(\"Couldn't run the test: {}\", err);\n+                            if err.kind() == io::ErrorKind::PermissionDenied {\n+                                eprint!(\" - maybe your tempdir is mounted with noexec?\");\n+                            }\n+                        }\n+                        TestFailure::ExecutionFailure(out) => {\n+                            let reason = if let Some(code) = out.status.code() {\n+                                format!(\"exit code {}\", code)\n+                            } else {\n+                                String::from(\"terminated by signal\")\n+                            };\n+\n+                            eprintln!(\"Test executable failed ({}).\", reason);\n+\n+                            // FIXME(#12309): An unfortunate side-effect of capturing the test\n+                            // executable's output is that the relative ordering between the test's\n+                            // stdout and stderr is lost. However, this is better than the\n+                            // alternative: if the test executable inherited the parent's I/O\n+                            // handles the output wouldn't be captured at all, even on success.\n+                            //\n+                            // The ordering could be preserved if the test process' stderr was\n+                            // redirected to stdout, but that functionality does not exist in the\n+                            // standard library, so it may not be portable enough.\n+                            let stdout = str::from_utf8(&out.stdout).unwrap_or_default();\n+                            let stderr = str::from_utf8(&out.stderr).unwrap_or_default();\n+\n+                            if !stdout.is_empty() || !stderr.is_empty() {\n+                                eprintln!();\n+\n+                                if !stdout.is_empty() {\n+                                    eprintln!(\"stdout:\\n{}\", stdout);\n+                                }\n+\n+                                if !stderr.is_empty() {\n+                                    eprintln!(\"stderr:\\n{}\", stderr);\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    panic::resume_unwind(box ());\n+                }\n             }),\n         });\n     }"}, {"sha": "c8978a94fcda46507e007c3cdf58fc0bfaadc453", "filename": "src/libstd/error.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -94,7 +94,7 @@ pub trait Error: Debug + Display {\n     ///         \"I'm the superhero of errors\"\n     ///     }\n     ///\n-    ///     fn cause(&self) -> Option<&Error> {\n+    ///     fn cause(&self) -> Option<&dyn Error> {\n     ///         Some(&self.side)\n     ///     }\n     /// }\n@@ -244,7 +244,7 @@ impl<'a, E: Error + 'a> From<E> for Box<dyn Error + 'a> {\n     ///\n     /// let an_error = AnError;\n     /// assert!(0 == mem::size_of_val(&an_error));\n-    /// let a_boxed_error = Box::<Error>::from(an_error);\n+    /// let a_boxed_error = Box::<dyn Error>::from(an_error);\n     /// assert!(mem::size_of::<Box<dyn Error>>() == mem::size_of_val(&a_boxed_error))\n     /// ```\n     fn from(err: E) -> Box<dyn Error + 'a> {\n@@ -287,7 +287,7 @@ impl<'a, E: Error + Send + Sync + 'a> From<E> for Box<dyn Error + Send + Sync +\n     ///\n     /// let an_error = AnError;\n     /// assert!(0 == mem::size_of_val(&an_error));\n-    /// let a_boxed_error = Box::<Error + Send + Sync>::from(an_error);\n+    /// let a_boxed_error = Box::<dyn Error + Send + Sync>::from(an_error);\n     /// assert!(\n     ///     mem::size_of::<Box<dyn Error + Send + Sync>>() == mem::size_of_val(&a_boxed_error))\n     /// ```\n@@ -309,7 +309,7 @@ impl From<String> for Box<dyn Error + Send + Sync> {\n     /// use std::mem;\n     ///\n     /// let a_string_error = \"a string error\".to_string();\n-    /// let a_boxed_error = Box::<Error + Send + Sync>::from(a_string_error);\n+    /// let a_boxed_error = Box::<dyn Error + Send + Sync>::from(a_string_error);\n     /// assert!(\n     ///     mem::size_of::<Box<dyn Error + Send + Sync>>() == mem::size_of_val(&a_boxed_error))\n     /// ```\n@@ -344,7 +344,7 @@ impl From<String> for Box<dyn Error> {\n     /// use std::mem;\n     ///\n     /// let a_string_error = \"a string error\".to_string();\n-    /// let a_boxed_error = Box::<Error>::from(a_string_error);\n+    /// let a_boxed_error = Box::<dyn Error>::from(a_string_error);\n     /// assert!(mem::size_of::<Box<dyn Error>>() == mem::size_of_val(&a_boxed_error))\n     /// ```\n     fn from(str_err: String) -> Box<dyn Error> {\n@@ -367,7 +367,7 @@ impl<'a> From<&str> for Box<dyn Error + Send + Sync + 'a> {\n     /// use std::mem;\n     ///\n     /// let a_str_error = \"a str error\";\n-    /// let a_boxed_error = Box::<Error + Send + Sync>::from(a_str_error);\n+    /// let a_boxed_error = Box::<dyn Error + Send + Sync>::from(a_str_error);\n     /// assert!(\n     ///     mem::size_of::<Box<dyn Error + Send + Sync>>() == mem::size_of_val(&a_boxed_error))\n     /// ```\n@@ -389,7 +389,7 @@ impl From<&str> for Box<dyn Error> {\n     /// use std::mem;\n     ///\n     /// let a_str_error = \"a str error\";\n-    /// let a_boxed_error = Box::<Error>::from(a_str_error);\n+    /// let a_boxed_error = Box::<dyn Error>::from(a_str_error);\n     /// assert!(mem::size_of::<Box<dyn Error>>() == mem::size_of_val(&a_boxed_error))\n     /// ```\n     fn from(err: &str) -> Box<dyn Error> {\n@@ -412,7 +412,7 @@ impl<'a, 'b> From<Cow<'b, str>> for Box<dyn Error + Send + Sync + 'a> {\n     /// use std::borrow::Cow;\n     ///\n     /// let a_cow_str_error = Cow::from(\"a str error\");\n-    /// let a_boxed_error = Box::<Error + Send + Sync>::from(a_cow_str_error);\n+    /// let a_boxed_error = Box::<dyn Error + Send + Sync>::from(a_cow_str_error);\n     /// assert!(\n     ///     mem::size_of::<Box<dyn Error + Send + Sync>>() == mem::size_of_val(&a_boxed_error))\n     /// ```\n@@ -436,7 +436,7 @@ impl<'a> From<Cow<'a, str>> for Box<dyn Error> {\n     /// use std::borrow::Cow;\n     ///\n     /// let a_cow_str_error = Cow::from(\"a str error\");\n-    /// let a_boxed_error = Box::<Error>::from(a_cow_str_error);\n+    /// let a_boxed_error = Box::<dyn Error>::from(a_cow_str_error);\n     /// assert!(mem::size_of::<Box<dyn Error>>() == mem::size_of_val(&a_boxed_error))\n     /// ```\n     fn from(err: Cow<'a, str>) -> Box<dyn Error> {"}, {"sha": "d41b3a3a1233f563a097edf4775a1858f0ab43b8", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -1976,7 +1976,7 @@ pub fn remove_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n /// use std::path::Path;\n ///\n /// // one possible implementation of walking a directory only visiting files\n-/// fn visit_dirs(dir: &Path, cb: &Fn(&DirEntry)) -> io::Result<()> {\n+/// fn visit_dirs(dir: &Path, cb: &dyn Fn(&DirEntry)) -> io::Result<()> {\n ///     if dir.is_dir() {\n ///         for entry in fs::read_dir(dir)? {\n ///             let entry = entry?;"}, {"sha": "aaf628e6c260fea2ec16fcbe7cc948d20fa00a2b", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -158,7 +158,6 @@ impl<R> BufReader<R> {\n     /// # Examples\n     ///\n     /// ```no_run\n-    /// # #![feature(bufreader_buffer)]\n     /// use std::io::{BufReader, BufRead};\n     /// use std::fs::File;\n     ///\n@@ -173,7 +172,7 @@ impl<R> BufReader<R> {\n     ///     Ok(())\n     /// }\n     /// ```\n-    #[unstable(feature = \"bufreader_buffer\", issue = \"45323\")]\n+    #[stable(feature = \"bufreader_buffer\", since = \"1.37.0\")]\n     pub fn buffer(&self) -> &[u8] {\n         &self.buf[self.pos..self.cap]\n     }\n@@ -552,7 +551,6 @@ impl<W: Write> BufWriter<W> {\n     /// # Examples\n     ///\n     /// ```no_run\n-    /// # #![feature(bufreader_buffer)]\n     /// use std::io::BufWriter;\n     /// use std::net::TcpStream;\n     ///\n@@ -561,7 +559,7 @@ impl<W: Write> BufWriter<W> {\n     /// // See how many bytes are currently buffered\n     /// let bytes_buffered = buf_writer.buffer().len();\n     /// ```\n-    #[unstable(feature = \"bufreader_buffer\", issue = \"45323\")]\n+    #[stable(feature = \"bufreader_buffer\", since = \"1.37.0\")]\n     pub fn buffer(&self) -> &[u8] {\n         &self.buf\n     }"}, {"sha": "746e9cad4962ca4057e9214ef433aedaedade7f2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 38, "deletions": 35, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -1087,6 +1087,11 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Returns whether any of the given keywords are `dist` tokens ahead of the current one.\n+    fn is_keyword_ahead(&self, dist: usize, kws: &[Symbol]) -> bool {\n+        self.look_ahead(dist, |t| kws.iter().any(|&kw| t.is_keyword(kw)))\n+    }\n+\n     /// Is the current token one of the keywords that signals a bare function type?\n     fn token_is_bare_fn_keyword(&mut self) -> bool {\n         self.check_keyword(kw::Fn) ||\n@@ -4270,7 +4275,7 @@ impl<'a> Parser<'a> {\n         self.token.is_keyword(kw::Async) &&\n         (\n             ( // `async move {`\n-                self.look_ahead(1, |t| t.is_keyword(kw::Move)) &&\n+                self.is_keyword_ahead(1, &[kw::Move]) &&\n                 self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))\n             ) || ( // `async {`\n                 self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace))\n@@ -4280,12 +4285,12 @@ impl<'a> Parser<'a> {\n \n     fn is_async_fn(&self) -> bool {\n         self.token.is_keyword(kw::Async) &&\n-            self.look_ahead(1, |t| t.is_keyword(kw::Fn))\n+            self.is_keyword_ahead(1, &[kw::Fn])\n     }\n \n     fn is_do_catch_block(&self) -> bool {\n         self.token.is_keyword(kw::Do) &&\n-        self.look_ahead(1, |t| t.is_keyword(kw::Catch)) &&\n+        self.is_keyword_ahead(1, &[kw::Catch]) &&\n         self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace)) &&\n         !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n     }\n@@ -4309,17 +4314,17 @@ impl<'a> Parser<'a> {\n \n     fn is_existential_type_decl(&self) -> bool {\n         self.token.is_keyword(kw::Existential) &&\n-        self.look_ahead(1, |t| t.is_keyword(kw::Type))\n+        self.is_keyword_ahead(1, &[kw::Type])\n     }\n \n     fn is_auto_trait_item(&self) -> bool {\n         // auto trait\n-        (self.token.is_keyword(kw::Auto)\n-            && self.look_ahead(1, |t| t.is_keyword(kw::Trait)))\n+        (self.token.is_keyword(kw::Auto) &&\n+            self.is_keyword_ahead(1, &[kw::Trait]))\n         || // unsafe auto trait\n         (self.token.is_keyword(kw::Unsafe) &&\n-         self.look_ahead(1, |t| t.is_keyword(kw::Auto)) &&\n-         self.look_ahead(2, |t| t.is_keyword(kw::Trait)))\n+         self.is_keyword_ahead(1, &[kw::Auto]) &&\n+         self.is_keyword_ahead(2, &[kw::Trait]))\n     }\n \n     fn eat_macro_def(&mut self, attrs: &[Attribute], vis: &Visibility, lo: Span)\n@@ -5486,7 +5491,7 @@ impl<'a> Parser<'a> {\n                 (if isolated_self(self, 1) {\n                     self.bump();\n                     SelfKind::Region(None, Mutability::Immutable)\n-                } else if self.look_ahead(1, |t| t.is_keyword(kw::Mut)) &&\n+                } else if self.is_keyword_ahead(1, &[kw::Mut]) &&\n                           isolated_self(self, 2) {\n                     self.bump();\n                     self.bump();\n@@ -5497,7 +5502,7 @@ impl<'a> Parser<'a> {\n                     let lt = self.expect_lifetime();\n                     SelfKind::Region(Some(lt), Mutability::Immutable)\n                 } else if self.look_ahead(1, |t| t.is_lifetime()) &&\n-                          self.look_ahead(2, |t| t.is_keyword(kw::Mut)) &&\n+                          self.is_keyword_ahead(2, &[kw::Mut]) &&\n                           isolated_self(self, 3) {\n                     self.bump();\n                     let lt = self.expect_lifetime();\n@@ -5676,8 +5681,7 @@ impl<'a> Parser<'a> {\n     /// (returns `false` for things like `const fn`, etc.).\n     fn is_const_item(&self) -> bool {\n         self.token.is_keyword(kw::Const) &&\n-            !self.look_ahead(1, |t| t.is_keyword(kw::Fn)) &&\n-            !self.look_ahead(1, |t| t.is_keyword(kw::Unsafe))\n+            !self.is_keyword_ahead(1, &[kw::Fn, kw::Unsafe])\n     }\n \n     /// Parses all the \"front matter\" for a `fn` declaration, up to\n@@ -5955,7 +5959,7 @@ impl<'a> Parser<'a> {\n              self.look_ahead(1, |t| t.is_lifetime() || t.is_ident()) &&\n                 self.look_ahead(2, |t| t == &token::Gt || t == &token::Comma ||\n                                        t == &token::Colon || t == &token::Eq) ||\n-             self.look_ahead(1, |t| t.is_keyword(kw::Const)))\n+            self.is_keyword_ahead(1, &[kw::Const]))\n     }\n \n     fn parse_impl_body(&mut self) -> PResult<'a, (Vec<ImplItem>, Vec<Attribute>)> {\n@@ -6316,7 +6320,7 @@ impl<'a> Parser<'a> {\n             // `()` or a tuple might be allowed. For example, `struct Struct(pub (), pub (usize));`.\n             // Because of this, we only `bump` the `(` if we're assured it is appropriate to do so\n             // by the following tokens.\n-            if self.look_ahead(1, |t| t.is_keyword(kw::Crate)) &&\n+            if self.is_keyword_ahead(1, &[kw::Crate]) &&\n                 self.look_ahead(2, |t| t != &token::ModSep) // account for `pub(crate::foo)`\n             {\n                 // `pub(crate)`\n@@ -6328,7 +6332,7 @@ impl<'a> Parser<'a> {\n                     VisibilityKind::Crate(CrateSugar::PubCrate),\n                 );\n                 return Ok(vis)\n-            } else if self.look_ahead(1, |t| t.is_keyword(kw::In)) {\n+            } else if self.is_keyword_ahead(1, &[kw::In]) {\n                 // `pub(in path)`\n                 self.bump(); // `(`\n                 self.bump(); // `in`\n@@ -6340,8 +6344,7 @@ impl<'a> Parser<'a> {\n                 });\n                 return Ok(vis)\n             } else if self.look_ahead(2, |t| t == &token::CloseDelim(token::Paren)) &&\n-                      self.look_ahead(1, |t| t.is_keyword(kw::Super) ||\n-                                             t.is_keyword(kw::SelfLower))\n+                      self.is_keyword_ahead(1, &[kw::Super, kw::SelfLower])\n             {\n                 // `pub(self)` or `pub(super)`\n                 self.bump(); // `(`\n@@ -6380,13 +6383,16 @@ impl<'a> Parser<'a> {\n     fn parse_defaultness(&mut self) -> Defaultness {\n         // `pub` is included for better error messages\n         if self.check_keyword(kw::Default) &&\n-           self.look_ahead(1, |t| t.is_keyword(kw::Impl) ||\n-                                  t.is_keyword(kw::Const) ||\n-                                  t.is_keyword(kw::Fn) ||\n-                                  t.is_keyword(kw::Unsafe) ||\n-                                  t.is_keyword(kw::Extern) ||\n-                                  t.is_keyword(kw::Type) ||\n-                                  t.is_keyword(kw::Pub)) {\n+            self.is_keyword_ahead(1, &[\n+                kw::Impl,\n+                kw::Const,\n+                kw::Fn,\n+                kw::Unsafe,\n+                kw::Extern,\n+                kw::Type,\n+                kw::Pub,\n+            ])\n+        {\n             self.bump(); // `default`\n             Defaultness::Default\n         } else {\n@@ -6880,7 +6886,7 @@ impl<'a> Parser<'a> {\n         //     Ident [\"<\"...\">\"] [\"where\" ...] (\"=\" | \":\") Ty \";\"\n         if self.check_keyword(kw::Type) ||\n            self.check_keyword(kw::Existential) &&\n-                self.look_ahead(1, |t| t.is_keyword(kw::Type)) {\n+                self.is_keyword_ahead(1, &[kw::Type]) {\n             let existential = self.eat_keyword(kw::Existential);\n             assert!(self.eat_keyword(kw::Type));\n             Some(self.parse_existential_or_alias(existential))\n@@ -7157,7 +7163,7 @@ impl<'a> Parser<'a> {\n             let const_span = self.prev_span;\n             if self.check_keyword(kw::Fn)\n                 || (self.check_keyword(kw::Unsafe)\n-                    && self.look_ahead(1, |t| t.is_keyword(kw::Fn))) {\n+                    && self.is_keyword_ahead(1, &[kw::Fn])) {\n                 // CONST FUNCTION ITEM\n                 let unsafety = self.parse_unsafety();\n                 self.bump();\n@@ -7202,10 +7208,10 @@ impl<'a> Parser<'a> {\n         // `unsafe async fn` or `async fn`\n         if (\n             self.check_keyword(kw::Unsafe) &&\n-            self.look_ahead(1, |t| t.is_keyword(kw::Async))\n+            self.is_keyword_ahead(1, &[kw::Async])\n         ) || (\n             self.check_keyword(kw::Async) &&\n-            self.look_ahead(1, |t| t.is_keyword(kw::Fn))\n+            self.is_keyword_ahead(1, &[kw::Fn])\n         )\n         {\n             // ASYNC FUNCTION ITEM\n@@ -7239,8 +7245,7 @@ impl<'a> Parser<'a> {\n             return Ok(Some(item));\n         }\n         if self.check_keyword(kw::Unsafe) &&\n-            (self.look_ahead(1, |t| t.is_keyword(kw::Trait)) ||\n-            self.look_ahead(1, |t| t.is_keyword(kw::Auto)))\n+            self.is_keyword_ahead(1, &[kw::Trait, kw::Auto])\n         {\n             // UNSAFE TRAIT ITEM\n             self.bump(); // `unsafe`\n@@ -7263,11 +7268,9 @@ impl<'a> Parser<'a> {\n         }\n         if self.check_keyword(kw::Impl) ||\n            self.check_keyword(kw::Unsafe) &&\n-                self.look_ahead(1, |t| t.is_keyword(kw::Impl)) ||\n-           self.check_keyword(kw::Default) &&\n-                self.look_ahead(1, |t| t.is_keyword(kw::Impl)) ||\n+                self.is_keyword_ahead(1, &[kw::Impl]) ||\n            self.check_keyword(kw::Default) &&\n-                self.look_ahead(1, |t| t.is_keyword(kw::Unsafe)) {\n+                self.is_keyword_ahead(1, &[kw::Impl, kw::Unsafe]) {\n             // IMPL ITEM\n             let defaultness = self.parse_defaultness();\n             let unsafety = self.parse_unsafety();\n@@ -7360,7 +7363,7 @@ impl<'a> Parser<'a> {\n         }\n         if self.check_keyword(kw::Trait)\n             || (self.check_keyword(kw::Auto)\n-                && self.look_ahead(1, |t| t.is_keyword(kw::Trait)))\n+                && self.is_keyword_ahead(1, &[kw::Trait]))\n         {\n             let is_auto = if self.eat_keyword(kw::Trait) {\n                 IsAuto::No"}, {"sha": "e94365058862a11b0e874fbc6da91bcf0008c32b", "filename": "src/test/codegen/pgo-instrumentation.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Fcodegen%2Fpgo-instrumentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Fcodegen%2Fpgo-instrumentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fpgo-instrumentation.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -1,20 +1,23 @@\n // Test that `-Zpgo-gen` creates expected instrumentation artifacts in LLVM IR.\n+// Compiling with `-Cpanic=abort` because PGO+unwinding isn't supported on all platforms.\n \n // needs-profiler-support\n-// compile-flags: -Z pgo-gen -Ccodegen-units=1\n+// compile-flags: -Z pgo-gen -Ccodegen-units=1 -Cpanic=abort\n \n // CHECK: @__llvm_profile_raw_version =\n // CHECK: @__profc_{{.*}}pgo_instrumentation{{.*}}some_function{{.*}} = private global\n // CHECK: @__profd_{{.*}}pgo_instrumentation{{.*}}some_function{{.*}} = private global\n-// CHECK: @__profc_{{.*}}pgo_instrumentation{{.*}}main{{.*}} = private global\n-// CHECK: @__profd_{{.*}}pgo_instrumentation{{.*}}main{{.*}} = private global\n+// CHECK: @__profc_{{.*}}pgo_instrumentation{{.*}}some_other_function{{.*}} = private global\n+// CHECK: @__profd_{{.*}}pgo_instrumentation{{.*}}some_other_function{{.*}} = private global\n // CHECK: @__llvm_profile_filename = {{.*}}\"default_%m.profraw\\00\"{{.*}}\n \n+#![crate_type=\"lib\"]\n+\n #[inline(never)]\n fn some_function() {\n \n }\n \n-fn main() {\n+pub fn some_other_function() {\n     some_function();\n }"}, {"sha": "2912c4ead7a0a1cb0d0d10eb6ebe699281203289", "filename": "src/test/compile-fail/issue-23595-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Fcompile-fail%2Fissue-23595-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Fcompile-fail%2Fissue-23595-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23595-1.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -5,7 +5,7 @@ use std::ops::{Index};\n trait Hierarchy {\n     type Value;\n     type ChildKey;\n-    type Children = Index<Self::ChildKey, Output=Hierarchy>;\n+    type Children = dyn Index<Self::ChildKey, Output=dyn Hierarchy>;\n     //~^ ERROR: the value of the associated types `Value` (from the trait `Hierarchy`), `ChildKey`\n \n     fn data(&self) -> Option<(Self::Value, Self::Children)>;"}, {"sha": "56f31434adee4a17845a53459e6d7fa1003abf75", "filename": "src/test/run-make-fulldeps/pgo-gen-lto/Makefile", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-make-fulldeps%2Fpgo-gen-lto%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-make-fulldeps%2Fpgo-gen-lto%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fpgo-gen-lto%2FMakefile?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -2,7 +2,17 @@\n \n -include ../tools.mk\n \n+COMPILE_FLAGS=-Copt-level=3 -Clto=fat -Z pgo-gen=\"$(TMPDIR)\"\n+\n+# LLVM doesn't yet support instrumenting binaries that use unwinding on MSVC:\n+# https://github.com/rust-lang/rust/issues/61002\n+#\n+# Things work fine with -Cpanic=abort though.\n+ifdef IS_MSVC\n+COMPILE_FLAGS+= -Cpanic=abort\n+endif\n+\n all:\n-\t$(RUSTC) -Copt-level=3 -Clto=fat -Z pgo-gen=\"$(TMPDIR)\" test.rs\n+\t$(RUSTC) $(COMPILE_FLAGS) test.rs\n \t$(call RUN,test) || exit 1\n \t[ -e \"$(TMPDIR)\"/default_*.profraw ] || (echo \"No .profraw file\"; exit 1)"}, {"sha": "bb86160d2dfdf76c13081aa0de0c6e66208b29fa", "filename": "src/test/run-make-fulldeps/pgo-gen-no-imp-symbols/Makefile", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-make-fulldeps%2Fpgo-gen-no-imp-symbols%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-make-fulldeps%2Fpgo-gen-no-imp-symbols%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fpgo-gen-no-imp-symbols%2FMakefile?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -2,8 +2,18 @@\n \n -include ../tools.mk\n \n+COMPILE_FLAGS=-O -Ccodegen-units=1 -Z pgo-gen=\"$(TMPDIR)\"\n+\n+# LLVM doesn't yet support instrumenting binaries that use unwinding on MSVC:\n+# https://github.com/rust-lang/rust/issues/61002\n+#\n+# Things work fine with -Cpanic=abort though.\n+ifdef IS_MSVC\n+COMPILE_FLAGS+= -Cpanic=abort\n+endif\n+\n all:\n-\t$(RUSTC) -O -Ccodegen-units=1 -Z pgo-gen=\"$(TMPDIR)\" --emit=llvm-ir test.rs\n+\t$(RUSTC) $(COMPILE_FLAGS) --emit=llvm-ir test.rs\n \t# We expect symbols starting with \"__llvm_profile_\".\n \t$(CGREP) \"__llvm_profile_\" < $(TMPDIR)/test.ll\n \t# We do NOT expect the \"__imp_\" version of these symbols."}, {"sha": "f0ab3b7d13d27444337c7d3ce385fa7828435533", "filename": "src/test/run-make-fulldeps/pgo-gen/Makefile", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-make-fulldeps%2Fpgo-gen%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-make-fulldeps%2Fpgo-gen%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fpgo-gen%2FMakefile?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -2,7 +2,17 @@\n \n -include ../tools.mk\n \n+COMPILE_FLAGS=-g -Z pgo-gen=\"$(TMPDIR)\"\n+\n+# LLVM doesn't yet support instrumenting binaries that use unwinding on MSVC:\n+# https://github.com/rust-lang/rust/issues/61002\n+#\n+# Things work fine with -Cpanic=abort though.\n+ifdef IS_MSVC\n+COMPILE_FLAGS+= -Cpanic=abort\n+endif\n+\n all:\n-\t$(RUSTC) -g -Z pgo-gen=\"$(TMPDIR)\" test.rs\n+\t$(RUSTC) $(COMPILE_FLAGS) test.rs\n \t$(call RUN,test) || exit 1\n \t[ -e \"$(TMPDIR)\"/default_*.profraw ] || (echo \"No .profraw file\"; exit 1)"}, {"sha": "72c3c34ee3741675510c54f0c7cd0b611762e4f7", "filename": "src/test/run-make-fulldeps/pgo-use/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-make-fulldeps%2Fpgo-use%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-make-fulldeps%2Fpgo-use%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fpgo-use%2FMakefile?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -16,7 +16,7 @@\n COMMON_FLAGS=-Copt-level=s -Ccodegen-units=1\n \n # LLVM doesn't support instrumenting binaries that use SEH:\n-# https://bugs.llvm.org/show_bug.cgi?id=41279\n+# https://github.com/rust-lang/rust/issues/61002\n #\n # Things work fine with -Cpanic=abort though.\n ifdef IS_MSVC"}, {"sha": "2e2a77b92ca5379c95d35bfa2bc2cff787c16b26", "filename": "src/test/run-pass-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -62,7 +62,7 @@ fn make_x() -> P<Expr> {\n /// Iterate over exprs of depth up to `depth`. The goal is to explore all \"interesting\"\n /// combinations of expression nesting. For example, we explore combinations using `if`, but not\n /// `while` or `match`, since those should print and parse in much the same way as `if`.\n-fn iter_exprs(depth: usize, f: &mut FnMut(P<Expr>)) {\n+fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n     if depth == 0 {\n         f(make_x());\n         return;"}, {"sha": "7e6ee60e5194cb93ee7450e9d5547ab0785fbf5f", "filename": "src/test/run-pass/alignment-gep-tup-like-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -22,11 +22,11 @@ impl<A:Clone> Invokable<A> for Invoker<A> {\n     }\n }\n \n-fn f<A:Clone + 'static>(a: A, b: u16) -> Box<Invokable<A>+'static> {\n+fn f<A:Clone + 'static>(a: A, b: u16) -> Box<dyn Invokable<A>+'static> {\n     box Invoker {\n         a: a,\n         b: b,\n-    } as (Box<Invokable<A>+'static>)\n+    } as (Box<dyn Invokable<A>+'static>)\n }\n \n pub fn main() {"}, {"sha": "96ba2ee3b62b8c12ffd2875d792a988e67cfd271", "filename": "src/test/run-pass/associated-types/associated-types-doubleendediterator-object.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-doubleendediterator-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-doubleendediterator-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-doubleendediterator-object.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -1,7 +1,7 @@\n // run-pass\n #![feature(box_syntax)]\n \n-fn pairwise_sub(mut t: Box<DoubleEndedIterator<Item=isize>>) -> isize {\n+fn pairwise_sub(mut t: Box<dyn DoubleEndedIterator<Item=isize>>) -> isize {\n     let mut result = 0;\n     loop {\n         let front = t.next();"}, {"sha": "c202c376c5fe600e751a3ece74b110ea78b58517", "filename": "src/test/run-pass/associated-types/associated-types-eq-obj.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-eq-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-eq-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-eq-obj.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -15,7 +15,7 @@ impl Foo for char {\n     fn boo(&self) -> Bar { Bar }\n }\n \n-fn baz(x: &Foo<A=Bar>) -> Bar {\n+fn baz(x: &dyn Foo<A=Bar>) -> Bar {\n     x.boo()\n }\n "}, {"sha": "eec95a141f5cf2e59a09712e582f2a2b1b4a7955", "filename": "src/test/run-pass/associated-types/associated-types-projection-in-object-type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-projection-in-object-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-projection-in-object-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types%2Fassociated-types-projection-in-object-type.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -19,20 +19,20 @@ pub trait Subscriber {\n \n pub trait Publisher<'a> {\n     type Output;\n-    fn subscribe(&mut self, _: Box<Subscriber<Input=Self::Output> + 'a>);\n+    fn subscribe(&mut self, _: Box<dyn Subscriber<Input=Self::Output> + 'a>);\n }\n \n pub trait Processor<'a> : Subscriber + Publisher<'a> { }\n \n impl<'a, P> Processor<'a> for P where P : Subscriber + Publisher<'a> { }\n \n struct MyStruct<'a> {\n-    sub: Box<Subscriber<Input=u64> + 'a>\n+    sub: Box<dyn Subscriber<Input=u64> + 'a>\n }\n \n impl<'a> Publisher<'a> for MyStruct<'a> {\n     type Output = u64;\n-    fn subscribe(&mut self, t : Box<Subscriber<Input=u64> + 'a>) {\n+    fn subscribe(&mut self, t : Box<dyn Subscriber<Input=u64> + 'a>) {\n         self.sub = t;\n     }\n }"}, {"sha": "fadb0784e75257eb35354fe9b7c7885ed67b710b", "filename": "src/test/run-pass/autoref-autoderef/autoderef-method-on-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fautoref-autoderef%2Fautoderef-method-on-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fautoref-autoderef%2Fautoderef-method-on-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoref-autoderef%2Fautoderef-method-on-trait.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -11,6 +11,6 @@ impl double for usize {\n }\n \n pub fn main() {\n-    let x: Box<_> = box (box 3usize as Box<double>);\n+    let x: Box<_> = box (box 3usize as Box<dyn double>);\n     assert_eq!(x.double(), 6);\n }"}, {"sha": "8a6dfe76d6065c9c204c1dc3bfb18522a02d6b16", "filename": "src/test/run-pass/borrowck/borrowck-trait-lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fborrowck%2Fborrowck-trait-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fborrowck%2Fborrowck-trait-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck%2Fborrowck-trait-lifetime.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -12,7 +12,7 @@ use std::marker;\n fn main() {\n     trait T { fn foo(&self) {} }\n \n-    fn f<'a, V: T>(v: &'a V) -> &'a T {\n-        v as &'a T\n+    fn f<'a, V: T>(v: &'a V) -> &'a dyn T {\n+        v as &'a dyn T\n     }\n }"}, {"sha": "a27dd9eef52ec31f351258d92418625ea7150fe5", "filename": "src/test/run-pass/cast-rfc0401-vtable-kinds.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fcast-rfc0401-vtable-kinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fcast-rfc0401-vtable-kinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcast-rfc0401-vtable-kinds.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -15,9 +15,9 @@ impl<T> Foo<T> for () {}\n impl Foo<u32> for u32 { fn foo(&self, _: u32) -> u32 { self+43 } }\n impl Bar for () {}\n \n-unsafe fn round_trip_and_call<'a>(t: *const (Foo<u32>+'a)) -> u32 {\n-    let foo_e : *const Foo<u16> = t as *const _;\n-    let r_1 = foo_e as *mut Foo<u32>;\n+unsafe fn round_trip_and_call<'a>(t: *const (dyn Foo<u32>+'a)) -> u32 {\n+    let foo_e : *const dyn Foo<u16> = t as *const _;\n+    let r_1 = foo_e as *mut dyn Foo<u32>;\n \n     (&*r_1).foo(0)\n }\n@@ -38,8 +38,8 @@ fn tuple_i32_to_u32<T:?Sized>(u: *const (i32, T)) -> *const (u32, T) {\n \n fn main() {\n     let x = 4u32;\n-    let y : &Foo<u32> = &x;\n-    let fl = unsafe { round_trip_and_call(y as *const Foo<u32>) };\n+    let y : &dyn Foo<u32> = &x;\n+    let fl = unsafe { round_trip_and_call(y as *const dyn Foo<u32>) };\n     assert_eq!(fl, (43+4));\n \n     let s = FooS([0,1,2]);"}, {"sha": "017b63c737493d5990e2756be7badd651346a3e3", "filename": "src/test/run-pass/cast-rfc0401.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fcast-rfc0401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fcast-rfc0401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcast-rfc0401.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -25,8 +25,8 @@ fn main()\n     // coercion-cast\n     let mut it = vec![137].into_iter();\n     let itr: &mut vec::IntoIter<u32> = &mut it;\n-    assert_eq!((itr as &mut Iterator<Item=u32>).next(), Some(137));\n-    assert_eq!((itr as &mut Iterator<Item=u32>).next(), None);\n+    assert_eq!((itr as &mut dyn Iterator<Item=u32>).next(), Some(137));\n+    assert_eq!((itr as &mut dyn Iterator<Item=u32>).next(), None);\n \n     assert_eq!(Some(4u32) as Option<u32>, Some(4u32));\n     assert_eq!((1u32,2u32) as (u32,u32), (1,2));"}, {"sha": "0eead0194efa2999a4d5068844b1020dc52fd7f7", "filename": "src/test/run-pass/close-over-big-then-small-data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -24,11 +24,11 @@ impl<A:Clone> Invokable<A> for Invoker<A> {\n     }\n }\n \n-fn f<A:Clone + 'static>(a: A, b: u16) -> Box<Invokable<A>+'static> {\n+fn f<A:Clone + 'static>(a: A, b: u16) -> Box<dyn Invokable<A>+'static> {\n     box Invoker {\n         a: a,\n         b: b,\n-    } as (Box<Invokable<A>+'static>)\n+    } as (Box<dyn Invokable<A>+'static>)\n }\n \n pub fn main() {"}, {"sha": "26f53a9c18213b2f47894fc579632742d0fe956c", "filename": "src/test/run-pass/codegen-object-shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fcodegen-object-shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fcodegen-object-shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcodegen-object-shim.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n-    assert_eq!((ToString::to_string as fn(&(ToString+'static)) -> String)(&\"foo\"),\n+    assert_eq!((ToString::to_string as fn(&(dyn ToString+'static)) -> String)(&\"foo\"),\n         String::from(\"foo\"));\n }"}, {"sha": "b44aa6ab37760dfbd2c6ad529910624325b0c438", "filename": "src/test/run-pass/coerce/coerce-expect-unsized.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fcoerce%2Fcoerce-expect-unsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fcoerce%2Fcoerce-expect-unsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce%2Fcoerce-expect-unsized.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -12,16 +12,16 @@ pub fn main() {\n     let _: Box<[isize]> = Box::new({ [1, 2, 3] });\n     let _: Box<[isize]> = Box::new(if true { [1, 2, 3] } else { [1, 3, 4] });\n     let _: Box<[isize]> = Box::new(match true { true => [1, 2, 3], false => [1, 3, 4] });\n-    let _: Box<Fn(isize) -> _> = Box::new({ |x| (x as u8) });\n-    let _: Box<Debug> = Box::new(if true { false } else { true });\n-    let _: Box<Debug> = Box::new(match true { true => 'a', false => 'b' });\n+    let _: Box<dyn Fn(isize) -> _> = Box::new({ |x| (x as u8) });\n+    let _: Box<dyn Debug> = Box::new(if true { false } else { true });\n+    let _: Box<dyn Debug> = Box::new(match true { true => 'a', false => 'b' });\n \n     let _: &[isize] = &{ [1, 2, 3] };\n     let _: &[isize] = &if true { [1, 2, 3] } else { [1, 3, 4] };\n     let _: &[isize] = &match true { true => [1, 2, 3], false => [1, 3, 4] };\n-    let _: &Fn(isize) -> _ = &{ |x| (x as u8) };\n-    let _: &Debug = &if true { false } else { true };\n-    let _: &Debug = &match true { true => 'a', false => 'b' };\n+    let _: &dyn Fn(isize) -> _ = &{ |x| (x as u8) };\n+    let _: &dyn Debug = &if true { false } else { true };\n+    let _: &dyn Debug = &match true { true => 'a', false => 'b' };\n \n     let _: &str = &{ String::new() };\n     let _: &str = &if true { String::from(\"...\") } else { 5.to_string() };\n@@ -31,12 +31,12 @@ pub fn main() {\n     };\n \n     let _: Box<[isize]> = Box::new([1, 2, 3]);\n-    let _: Box<Fn(isize) -> _> = Box::new(|x| (x as u8));\n+    let _: Box<dyn Fn(isize) -> _> = Box::new(|x| (x as u8));\n \n     let _: Rc<RefCell<[isize]>> = Rc::new(RefCell::new([1, 2, 3]));\n-    let _: Rc<RefCell<FnMut(isize) -> _>> = Rc::new(RefCell::new(|x| (x as u8)));\n+    let _: Rc<RefCell<dyn FnMut(isize) -> _>> = Rc::new(RefCell::new(|x| (x as u8)));\n \n-    let _: Vec<Box<Fn(isize) -> _>> = vec![\n+    let _: Vec<Box<dyn Fn(isize) -> _>> = vec![\n         Box::new(|x| (x as u8)),\n         Box::new(|x| (x as i16 as u8)),\n     ];"}, {"sha": "12a2999d79d479ca00f93e9bcdcc3c0f1e93d8e3", "filename": "src/test/run-pass/consts/const-trait-to-trait.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-trait-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-trait-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-trait-to-trait.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -8,17 +8,17 @@ struct Bar;\n impl Trait for Bar {}\n \n fn main() {\n-    let x: &[&Trait] = &[{ &Bar }];\n+    let x: &[&dyn Trait] = &[{ &Bar }];\n }\n \n // Issue #25748 - the cast causes an &Encoding -> &Encoding coercion:\n pub struct UTF8Encoding;\n pub const UTF_8: &'static UTF8Encoding = &UTF8Encoding;\n pub trait Encoding {}\n impl Encoding for UTF8Encoding {}\n-pub fn f() -> &'static Encoding { UTF_8 as &'static Encoding }\n+pub fn f() -> &'static dyn Encoding { UTF_8 as &'static dyn Encoding }\n \n // Root of the problem: &Trait -> &Trait coercions:\n-const FOO: &'static Trait = &Bar;\n-const BAR: &'static Trait = FOO;\n+const FOO: &'static dyn Trait = &Bar;\n+const BAR: &'static dyn Trait = FOO;\n fn foo() { let _x = BAR; }"}, {"sha": "eb3a8948fc80d7acc70ebe72ce755c223a9dee04", "filename": "src/test/run-pass/deriving/deriving-show.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fderiving%2Fderiving-show.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fderiving%2Fderiving-show.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving%2Fderiving-show.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -17,7 +17,7 @@ enum Enum {\n }\n \n #[derive(Debug)]\n-struct Pointers(*const Send, *mut Sync);\n+struct Pointers(*const dyn Send, *mut dyn Sync);\n \n macro_rules! t {\n     ($x:expr, $expected:expr) => {"}, {"sha": "1bc3b4c157ca8d596e9353cb905d427a5f165756", "filename": "src/test/run-pass/drop/drop-struct-as-object.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fdrop%2Fdrop-struct-as-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fdrop%2Fdrop-struct-as-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop%2Fdrop-struct-as-object.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -30,7 +30,7 @@ impl Drop for Cat {\n pub fn main() {\n     {\n         let x = box Cat {name: 22};\n-        let nyan: Box<Dummy> = x as Box<Dummy>;\n+        let nyan: Box<dyn Dummy> = x as Box<dyn Dummy>;\n     }\n     unsafe {\n         assert_eq!(value, 22);"}, {"sha": "24d83eb5343eccced01c8fafe13b8771b0030f2f", "filename": "src/test/run-pass/dynamically-sized-types/dst-coerce-custom.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fdynamically-sized-types%2Fdst-coerce-custom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fdynamically-sized-types%2Fdst-coerce-custom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdynamically-sized-types%2Fdst-coerce-custom.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -36,7 +36,7 @@ fn main() {\n \n     // Trait objects.\n     let a: Bar<i32> = Bar { x: &42 };\n-    let b: Bar<Baz> = a;\n+    let b: Bar<dyn Baz> = a;\n     unsafe {\n         assert_eq!((*b.x).get(), 42);\n     }"}, {"sha": "683fa6850fd81075ab2ade11d200d1c18ddce41b", "filename": "src/test/run-pass/dynamically-sized-types/dst-coerce-rc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fdynamically-sized-types%2Fdst-coerce-rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fdynamically-sized-types%2Fdst-coerce-rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdynamically-sized-types%2Fdst-coerce-rc.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -26,17 +26,17 @@ fn main() {\n     assert_eq!(b[2], 3);\n \n     let a: Rc<i32> = Rc::new(42);\n-    let b: Rc<Baz> = a.clone();\n+    let b: Rc<dyn Baz> = a.clone();\n     assert_eq!(b.get(), 42);\n \n     let c: Weak<i32> = Rc::downgrade(&a);\n-    let d: Weak<Baz> = c.clone();\n+    let d: Weak<dyn Baz> = c.clone();\n \n     let _c = b.clone();\n \n     let a: Rc<RefCell<i32>> = Rc::new(RefCell::new(42));\n-    let b: Rc<RefCell<Baz>> = a.clone();\n+    let b: Rc<RefCell<dyn Baz>> = a.clone();\n     assert_eq!(b.borrow().get(), 42);\n     // FIXME\n-    let c: Weak<RefCell<Baz>> = Rc::downgrade(&a) as Weak<_>;\n+    let c: Weak<RefCell<dyn Baz>> = Rc::downgrade(&a) as Weak<_>;\n }"}, {"sha": "66688e93fb80d8d00eaa1cf716f159168e65563d", "filename": "src/test/run-pass/dynamically-sized-types/dst-coercions.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fdynamically-sized-types%2Fdst-coercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fdynamically-sized-types%2Fdst-coercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdynamically-sized-types%2Fdst-coercions.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -9,20 +9,20 @@ trait T { fn dummy(&self) { } }\n impl T for S {}\n \n pub fn main() {\n-    let x: &T = &S;\n+    let x: &dyn T = &S;\n     // Test we can convert from &-ptr to *-ptr of trait objects\n-    let x: *const T = &S;\n+    let x: *const dyn T = &S;\n \n     // Test we can convert from &-ptr to *-ptr of struct pointer (not DST)\n     let x: *const S = &S;\n \n     // As above, but mut\n-    let x: &mut T = &mut S;\n-    let x: *mut T = &mut S;\n+    let x: &mut dyn T = &mut S;\n+    let x: *mut dyn T = &mut S;\n \n     let x: *mut S = &mut S;\n \n     // Test we can change the mutability from mut to const.\n-    let x: &T = &mut S;\n-    let x: *const T = &mut S;\n+    let x: &dyn T = &mut S;\n+    let x: *const dyn T = &mut S;\n }"}, {"sha": "6c338e99912ec2eec32edaa156f6d9fc7b9d8523", "filename": "src/test/run-pass/dynamically-sized-types/dst-field-align.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fdynamically-sized-types%2Fdst-field-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fdynamically-sized-types%2Fdst-field-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdynamically-sized-types%2Fdst-field-align.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -26,15 +26,15 @@ fn main() {\n     // Test that zero-offset works properly\n     let b : Baz<usize> = Baz { a: 7 };\n     assert_eq!(b.a.get(), 7);\n-    let b : &Baz<Bar> = &b;\n+    let b : &Baz<dyn Bar> = &b;\n     assert_eq!(b.a.get(), 7);\n \n     // Test that the field is aligned properly\n     let f : Foo<usize> = Foo { a: 0, b: 11 };\n     assert_eq!(f.b.get(), 11);\n     let ptr1 : *const u8 = &f.b as *const _ as *const u8;\n \n-    let f : &Foo<Bar> = &f;\n+    let f : &Foo<dyn Bar> = &f;\n     let ptr2 : *const u8 = &f.b as *const _ as *const u8;\n     assert_eq!(f.b.get(), 11);\n \n@@ -44,13 +44,13 @@ fn main() {\n     // Test that nested DSTs work properly\n     let f : Foo<Foo<usize>> = Foo { a: 0, b: Foo { a: 1, b: 17 }};\n     assert_eq!(f.b.b.get(), 17);\n-    let f : &Foo<Foo<Bar>> = &f;\n+    let f : &Foo<Foo<dyn Bar>> = &f;\n     assert_eq!(f.b.b.get(), 17);\n \n     // Test that get the pointer via destructuring works\n \n     let f : Foo<usize> = Foo { a: 0, b: 11 };\n-    let f : &Foo<Bar> = &f;\n+    let f : &Foo<dyn Bar> = &f;\n     let &Foo { a: _, b: ref bar } = f;\n     assert_eq!(bar.get(), 11);\n "}, {"sha": "980d99a6d6c11170b52e96ebe93845fc6a7bb17c", "filename": "src/test/run-pass/dynamically-sized-types/dst-index.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fdynamically-sized-types%2Fdst-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fdynamically-sized-types%2Fdst-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdynamically-sized-types%2Fdst-index.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -19,11 +19,11 @@ impl Index<usize> for S {\n struct T;\n \n impl Index<usize> for T {\n-    type Output = Debug + 'static;\n+    type Output = dyn Debug + 'static;\n \n-    fn index<'a>(&'a self, idx: usize) -> &'a (Debug + 'static) {\n+    fn index<'a>(&'a self, idx: usize) -> &'a (dyn Debug + 'static) {\n         static X: usize = 42;\n-        &X as &(Debug + 'static)\n+        &X as &(dyn Debug + 'static)\n     }\n }\n "}, {"sha": "0893b02e74e82e97c84710fe7aad6af23879ccf4", "filename": "src/test/run-pass/dynamically-sized-types/dst-raw.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fdynamically-sized-types%2Fdst-raw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fdynamically-sized-types%2Fdst-raw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdynamically-sized-types%2Fdst-raw.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -24,23 +24,23 @@ struct Foo<T: ?Sized> {\n pub fn main() {\n     // raw trait object\n     let x = A { f: 42 };\n-    let z: *const Trait = &x;\n+    let z: *const dyn Trait = &x;\n     let r = unsafe {\n         (&*z).foo()\n     };\n     assert_eq!(r, 42);\n \n     // raw DST struct\n     let p = Foo {f: A { f: 42 }};\n-    let o: *const Foo<Trait> = &p;\n+    let o: *const Foo<dyn Trait> = &p;\n     let r = unsafe {\n         (&*o).f.foo()\n     };\n     assert_eq!(r, 42);\n \n     // raw DST tuple\n     let p = (A { f: 42 },);\n-    let o: *const (Trait,) = &p;\n+    let o: *const (dyn Trait,) = &p;\n     let r = unsafe {\n         (&*o).0.foo()\n     };\n@@ -84,21 +84,21 @@ pub fn main() {\n \n     // all of the above with *mut\n     let mut x = A { f: 42 };\n-    let z: *mut Trait = &mut x;\n+    let z: *mut dyn Trait = &mut x;\n     let r = unsafe {\n         (&*z).foo()\n     };\n     assert_eq!(r, 42);\n \n     let mut p = Foo {f: A { f: 42 }};\n-    let o: *mut Foo<Trait> = &mut p;\n+    let o: *mut Foo<dyn Trait> = &mut p;\n     let r = unsafe {\n         (&*o).f.foo()\n     };\n     assert_eq!(r, 42);\n \n     let mut p = (A { f: 42 },);\n-    let o: *mut (Trait,) = &mut p;\n+    let o: *mut (dyn Trait,) = &mut p;\n     let r = unsafe {\n         (&*o).0.foo()\n     };"}, {"sha": "70bcc3de07d29b279962e8d60e3f32d8b2c3288e", "filename": "src/test/run-pass/dynamically-sized-types/dst-trait-tuple.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fdynamically-sized-types%2Fdst-trait-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fdynamically-sized-types%2Fdst-trait-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdynamically-sized-types%2Fdst-trait-tuple.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -38,7 +38,7 @@ impl ToBar for Bar1 {\n }\n \n // x is a fat pointer\n-fn foo(x: &Fat<ToBar>) {\n+fn foo(x: &Fat<dyn ToBar>) {\n     assert_eq!(x.0, 5);\n     assert_eq!(x.1, \"some str\");\n     assert_eq!(x.2.to_bar(), Bar);\n@@ -49,12 +49,12 @@ fn foo(x: &Fat<ToBar>) {\n     assert_eq!(y.to_val(), 42);\n }\n \n-fn bar(x: &ToBar) {\n+fn bar(x: &dyn ToBar) {\n     assert_eq!(x.to_bar(), Bar);\n     assert_eq!(x.to_val(), 42);\n }\n \n-fn baz(x: &Fat<Fat<ToBar>>) {\n+fn baz(x: &Fat<Fat<dyn ToBar>>) {\n     assert_eq!(x.0, 5);\n     assert_eq!(x.1, \"some str\");\n     assert_eq!((x.2).0, 8);\n@@ -73,31 +73,31 @@ pub fn main() {\n     foo(&f1);\n     let f2 = &f1;\n     foo(f2);\n-    let f3: &Fat<ToBar> = f2;\n+    let f3: &Fat<dyn ToBar> = f2;\n     foo(f3);\n-    let f4: &Fat<ToBar> = &f1;\n+    let f4: &Fat<dyn ToBar> = &f1;\n     foo(f4);\n-    let f5: &Fat<ToBar> = &(5, \"some str\", Bar1 {f :42});\n+    let f5: &Fat<dyn ToBar> = &(5, \"some str\", Bar1 {f :42});\n     foo(f5);\n \n     // Zero size object.\n-    let f6: &Fat<ToBar> = &(5, \"some str\", Bar);\n+    let f6: &Fat<dyn ToBar> = &(5, \"some str\", Bar);\n     assert_eq!(f6.2.to_bar(), Bar);\n \n     // &*\n     //\n-    let f7: Box<ToBar> = Box::new(Bar1 {f :42});\n+    let f7: Box<dyn ToBar> = Box::new(Bar1 {f :42});\n     bar(&*f7);\n \n     // Deep nesting\n     let f1 = (5, \"some str\", (8, \"deep str\", Bar1 {f :42}));\n     baz(&f1);\n     let f2 = &f1;\n     baz(f2);\n-    let f3: &Fat<Fat<ToBar>> = f2;\n+    let f3: &Fat<Fat<dyn ToBar>> = f2;\n     baz(f3);\n-    let f4: &Fat<Fat<ToBar>> = &f1;\n+    let f4: &Fat<Fat<dyn ToBar>> = &f1;\n     baz(f4);\n-    let f5: &Fat<Fat<ToBar>> = &(5, \"some str\", (8, \"deep str\", Bar1 {f :42}));\n+    let f5: &Fat<Fat<dyn ToBar>> = &(5, \"some str\", (8, \"deep str\", Bar1 {f :42}));\n     baz(f5);\n }"}, {"sha": "ec6bc72192d4ffc0e1bb53fcdeba275da23ed433", "filename": "src/test/run-pass/dynamically-sized-types/dst-trait.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fdynamically-sized-types%2Fdst-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fdynamically-sized-types%2Fdst-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdynamically-sized-types%2Fdst-trait.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -38,7 +38,7 @@ impl ToBar for Bar1 {\n }\n \n // x is a fat pointer\n-fn foo(x: &Fat<ToBar>) {\n+fn foo(x: &Fat<dyn ToBar>) {\n     assert_eq!(x.f1, 5);\n     assert_eq!(x.f2, \"some str\");\n     assert_eq!(x.ptr.to_bar(), Bar);\n@@ -49,12 +49,12 @@ fn foo(x: &Fat<ToBar>) {\n     assert_eq!(y.to_val(), 42);\n }\n \n-fn bar(x: &ToBar) {\n+fn bar(x: &dyn ToBar) {\n     assert_eq!(x.to_bar(), Bar);\n     assert_eq!(x.to_val(), 42);\n }\n \n-fn baz(x: &Fat<Fat<ToBar>>) {\n+fn baz(x: &Fat<Fat<dyn ToBar>>) {\n     assert_eq!(x.f1, 5);\n     assert_eq!(x.f2, \"some str\");\n     assert_eq!(x.ptr.f1, 8);\n@@ -73,20 +73,20 @@ pub fn main() {\n     foo(&f1);\n     let f2 = &f1;\n     foo(f2);\n-    let f3: &Fat<ToBar> = f2;\n+    let f3: &Fat<dyn ToBar> = f2;\n     foo(f3);\n-    let f4: &Fat<ToBar> = &f1;\n+    let f4: &Fat<dyn ToBar> = &f1;\n     foo(f4);\n-    let f5: &Fat<ToBar> = &Fat { f1: 5, f2: \"some str\", ptr: Bar1 {f :42} };\n+    let f5: &Fat<dyn ToBar> = &Fat { f1: 5, f2: \"some str\", ptr: Bar1 {f :42} };\n     foo(f5);\n \n     // Zero size object.\n-    let f6: &Fat<ToBar> = &Fat { f1: 5, f2: \"some str\", ptr: Bar };\n+    let f6: &Fat<dyn ToBar> = &Fat { f1: 5, f2: \"some str\", ptr: Bar };\n     assert_eq!(f6.ptr.to_bar(), Bar);\n \n     // &*\n     //\n-    let f7: Box<ToBar> = Box::new(Bar1 {f :42});\n+    let f7: Box<dyn ToBar> = Box::new(Bar1 {f :42});\n     bar(&*f7);\n \n     // Deep nesting\n@@ -95,11 +95,11 @@ pub fn main() {\n     baz(&f1);\n     let f2 = &f1;\n     baz(f2);\n-    let f3: &Fat<Fat<ToBar>> = f2;\n+    let f3: &Fat<Fat<dyn ToBar>> = f2;\n     baz(f3);\n-    let f4: &Fat<Fat<ToBar>> = &f1;\n+    let f4: &Fat<Fat<dyn ToBar>> = &f1;\n     baz(f4);\n-    let f5: &Fat<Fat<ToBar>> =\n+    let f5: &Fat<Fat<dyn ToBar>> =\n         &Fat { f1: 5, f2: \"some str\", ptr: Fat { f1: 8, f2: \"deep str\", ptr: Bar1 {f :42}} };\n     baz(f5);\n }"}, {"sha": "6cce6c723c5a2a4056b6912a8e1d33bca1890efc", "filename": "src/test/run-pass/extern/extern-types-trait-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fextern%2Fextern-types-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fextern%2Fextern-types-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern%2Fextern-types-trait-impl.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -18,7 +18,7 @@ impl Foo for A {\n \n fn assert_foo<T: ?Sized + Foo>() { }\n \n-fn use_foo<T: ?Sized + Foo>(x: &Foo) {\n+fn use_foo<T: ?Sized + Foo>(x: &dyn Foo) {\n     x.foo();\n }\n "}, {"sha": "1943abe9e14da596fc4a015bf327dcfdef7fd9e3", "filename": "src/test/run-pass/fat-ptr-cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ffat-ptr-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ffat-ptr-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffat-ptr-cast.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -25,7 +25,7 @@ fn main() {\n     assert_eq!(a as usize, b as *const () as usize);\n \n     // And conversion to a void pointer/address for trait objects too.\n-    let a: *mut Foo = &mut Bar;\n+    let a: *mut dyn Foo = &mut Bar;\n     let b = a as *mut ();\n     let c = a as *const () as usize;\n     let d = unsafe {"}, {"sha": "e97785b5cacdfbc7ef8ee25378f47a7fc345828f", "filename": "src/test/run-pass/functions-closures/closure-expected-type/issue-38714.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ffunctions-closures%2Fclosure-expected-type%2Fissue-38714.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ffunctions-closures%2Fclosure-expected-type%2Fissue-38714.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffunctions-closures%2Fclosure-expected-type%2Fissue-38714.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -5,7 +5,7 @@ struct UsizeRef<'a> {\n     a: &'a usize\n }\n \n-type RefTo = Box<for<'r> Fn(&'r Vec<usize>) -> UsizeRef<'r>>;\n+type RefTo = Box<dyn for<'r> Fn(&'r Vec<usize>) -> UsizeRef<'r>>;\n \n fn ref_to<'a>(vec: &'a Vec<usize>) -> UsizeRef<'a> {\n     UsizeRef{ a: &vec[0]}"}, {"sha": "870ff980ec64d0ac897d9b475c6896a3816e6881", "filename": "src/test/run-pass/generics/generic-object.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fgenerics%2Fgeneric-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fgenerics%2Fgeneric-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerics%2Fgeneric-object.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -17,6 +17,6 @@ impl Foo<isize> for S {\n \n pub fn main() {\n     let x = box S { x: 1 };\n-    let y = x as Box<Foo<isize>>;\n+    let y = x as Box<dyn Foo<isize>>;\n     assert_eq!(y.get(), 1);\n }"}, {"sha": "987a3e414f5c0dfc2529aff1be1df6586157a204", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -19,7 +19,7 @@ mod map_reduce {\n     use std::str;\n     use std::thread;\n \n-    pub type putter<'a> = Box<FnMut(String, String) + 'a>;\n+    pub type putter<'a> = Box<dyn FnMut(String, String) + 'a>;\n \n     pub type mapper = extern fn(String, putter);\n "}, {"sha": "cc766c0605c9f03e648a2299bba744b01bb6fb2b", "filename": "src/test/run-pass/higher-rank-trait-bounds/hrtb-binder-levels-in-object-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fhigher-rank-trait-bounds%2Fhrtb-binder-levels-in-object-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fhigher-rank-trait-bounds%2Fhrtb-binder-levels-in-object-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhigher-rank-trait-bounds%2Fhrtb-binder-levels-in-object-types.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -19,7 +19,7 @@ struct Tcx<'tcx> {\n impl<'tcx> Typer<'tcx> for Tcx<'tcx> {\n }\n \n-fn g<'tcx>(typer: &Typer<'tcx>) {\n+fn g<'tcx>(typer: &dyn Typer<'tcx>) {\n }\n \n fn check_static_type<'x>(tcx: &Tcx<'x>) {"}, {"sha": "8431226a3ece1205a9dad2c9c292db413bad4751", "filename": "src/test/run-pass/higher-rank-trait-bounds/hrtb-debruijn-object-types-in-closures.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fhigher-rank-trait-bounds%2Fhrtb-debruijn-object-types-in-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fhigher-rank-trait-bounds%2Fhrtb-debruijn-object-types-in-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhigher-rank-trait-bounds%2Fhrtb-debruijn-object-types-in-closures.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -7,7 +7,7 @@ trait Typer<'tcx> {\n     fn dummy(&self) { }\n }\n \n-fn g<F>(_: F) where F: FnOnce(&Typer) {}\n+fn g<F>(_: F) where F: FnOnce(&dyn Typer) {}\n \n fn h() {\n     g(|typer| typer.dummy())"}, {"sha": "ff84ad9d2988e4bb2c5507659b5e4c902469d939", "filename": "src/test/run-pass/higher-rank-trait-bounds/hrtb-fn-like-trait-object.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fhigher-rank-trait-bounds%2Fhrtb-fn-like-trait-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fhigher-rank-trait-bounds%2Fhrtb-fn-like-trait-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhigher-rank-trait-bounds%2Fhrtb-fn-like-trait-object.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -6,7 +6,7 @@ trait FnLike<A,R> {\n     fn call(&self, arg: A) -> R;\n }\n \n-type FnObject<'b> = for<'a> FnLike<&'a isize, &'a isize> + 'b;\n+type FnObject<'b> = dyn for<'a> FnLike<&'a isize, &'a isize> + 'b;\n \n struct Identity;\n "}, {"sha": "1fab9758c5c83bd28adde3df8dee45f3d8a57d11", "filename": "src/test/run-pass/higher-rank-trait-bounds/hrtb-parse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fhigher-rank-trait-bounds%2Fhrtb-parse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fhigher-rank-trait-bounds%2Fhrtb-parse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhigher-rank-trait-bounds%2Fhrtb-parse.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -24,8 +24,8 @@ fn foo01<T: for<'a> Get<&'a i32, &'a i32>>(t: T)\n \n // Parse HRTB with explicit `for` in various sorts of types:\n \n-fn foo10(t: Box<for<'a> Get<i32, i32>>) { }\n-fn foo11(t: Box<for<'a> Fn(i32) -> i32>) { }\n+fn foo10(t: Box<dyn for<'a> Get<i32, i32>>) { }\n+fn foo11(t: Box<dyn for<'a> Fn(i32) -> i32>) { }\n \n fn foo20(t: for<'a> fn(i32) -> i32) { }\n fn foo21(t: for<'a> unsafe fn(i32) -> i32) { }"}, {"sha": "6834c392d4e96634a8791cf071857fec2e9a3925", "filename": "src/test/run-pass/higher-rank-trait-bounds/hrtb-precedence-of-plus.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fhigher-rank-trait-bounds%2Fhrtb-precedence-of-plus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fhigher-rank-trait-bounds%2Fhrtb-precedence-of-plus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhigher-rank-trait-bounds%2Fhrtb-precedence-of-plus.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -6,7 +6,7 @@\n // 'static` and not `Fn(isize) -> (isize + 'static)`. The latter would\n // cause a compilation error. Issue #18772.\n \n-fn adder(y: isize) -> Box<Fn(isize) -> isize + 'static> {\n+fn adder(y: isize) -> Box<dyn Fn(isize) -> isize + 'static> {\n     Box::new(move |x| y + x)\n }\n "}, {"sha": "b97fdf4df508f2160a5e722d97741824190d9e24", "filename": "src/test/run-pass/higher-rank-trait-bounds/hrtb-resolve-lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fhigher-rank-trait-bounds%2Fhrtb-resolve-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fhigher-rank-trait-bounds%2Fhrtb-resolve-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhigher-rank-trait-bounds%2Fhrtb-resolve-lifetime.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -8,7 +8,7 @@ trait FnLike<A,R> {\n     fn call(&self, arg: A) -> R;\n }\n \n-type FnObject<'b> = for<'a> FnLike<&'a isize, &'a isize> + 'b;\n+type FnObject<'b> = dyn for<'a> FnLike<&'a isize, &'a isize> + 'b;\n \n fn main() {\n }"}, {"sha": "d8c726cdd71e50b0bb94b6991fe72f11754194bc", "filename": "src/test/run-pass/higher-rank-trait-bounds/hrtb-trait-object-paren-notation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fhigher-rank-trait-bounds%2Fhrtb-trait-object-paren-notation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fhigher-rank-trait-bounds%2Fhrtb-trait-object-paren-notation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhigher-rank-trait-bounds%2Fhrtb-trait-object-paren-notation.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -5,7 +5,7 @@ trait FnLike<A,R> {\n     fn call(&self, arg: A) -> R;\n }\n \n-type FnObject<'b> = for<'a> FnLike<(&'a i32,), &'a i32> + 'b;\n+type FnObject<'b> = dyn for<'a> FnLike<(&'a i32,), &'a i32> + 'b;\n \n struct Identity;\n "}, {"sha": "41ebb3f5a14ab1ee07b4cf085edf9cf6457198d5", "filename": "src/test/run-pass/higher-rank-trait-bounds/hrtb-trait-object-passed-to-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fhigher-rank-trait-bounds%2Fhrtb-trait-object-passed-to-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fhigher-rank-trait-bounds%2Fhrtb-trait-object-passed-to-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhigher-rank-trait-bounds%2Fhrtb-trait-object-passed-to-closure.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -17,7 +17,7 @@ struct NoAnn<'ast> {\n impl<'ast> PrinterSupport<'ast> for NoAnn<'ast> {\n }\n \n-fn foo<'ast, G>(f: Option<&'ast usize>, g: G) where G: FnOnce(&PrinterSupport) {\n+fn foo<'ast, G>(f: Option<&'ast usize>, g: G) where G: FnOnce(&dyn PrinterSupport) {\n     let annotation = NoAnn { f: f };\n     g(&annotation)\n }"}, {"sha": "6660f393f7dac5f5b1990a43cd4203ace8aab1ec", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -93,7 +93,7 @@ pub fn main() {\n     t!(format!(\"{:#4}\", C), \"\u2603123\");\n     t!(format!(\"{:b}\", D), \"aa\u2603bb\");\n \n-    let a: &fmt::Debug = &1;\n+    let a: &dyn fmt::Debug = &1;\n     t!(format!(\"{:?}\", a), \"1\");\n \n "}, {"sha": "f1b1656745e7c487b8ba1c75c69a3487e34a16db", "filename": "src/test/run-pass/impl-trait/example-calendar.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -180,6 +180,10 @@ impl std::iter::Step for NaiveDate {\n     fn add_usize(&self, _: usize) -> Option<Self> {\n         unimplemented!()\n     }\n+\n+    fn sub_usize(&self, _: usize) -> Option<Self> {\n+        unimplemented!()\n+    }\n }\n \n #[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]"}, {"sha": "f1d6b37a6843f3fff6f98efdb8628b82aaba9f82", "filename": "src/test/run-pass/issues/issue-10802.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-10802.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-10802.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-10802.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -24,23 +24,23 @@ trait MyTrait { fn dummy(&self) { } }\n impl MyTrait for Box<DroppableStruct> {}\n impl MyTrait for Box<DroppableEnum> {}\n \n-struct Whatever { w: Box<MyTrait+'static> }\n+struct Whatever { w: Box<dyn MyTrait+'static> }\n impl  Whatever {\n-    fn new(w: Box<MyTrait+'static>) -> Whatever {\n+    fn new(w: Box<dyn MyTrait+'static>) -> Whatever {\n         Whatever { w: w }\n     }\n }\n \n fn main() {\n     {\n         let f: Box<_> = box DroppableStruct;\n-        let _a = Whatever::new(box f as Box<MyTrait>);\n+        let _a = Whatever::new(box f as Box<dyn MyTrait>);\n     }\n     assert!(unsafe { DROPPED });\n     unsafe { DROPPED = false; }\n     {\n         let f: Box<_> = box DroppableEnum::DroppableVariant1;\n-        let _a = Whatever::new(box f as Box<MyTrait>);\n+        let _a = Whatever::new(box f as Box<dyn MyTrait>);\n     }\n     assert!(unsafe { DROPPED });\n }"}, {"sha": "ce0951eafdd346d46d92c29b1cfb0c9f021821a8", "filename": "src/test/run-pass/issues/issue-11205.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-11205.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-11205.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-11205.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -5,44 +5,44 @@\n \n trait Foo { fn dummy(&self) { } }\n impl Foo for isize {}\n-fn foo(_: [&Foo; 2]) {}\n-fn foos(_: &[&Foo]) {}\n+fn foo(_: [&dyn Foo; 2]) {}\n+fn foos(_: &[&dyn Foo]) {}\n fn foog<T>(_: &[T], _: &[T]) {}\n \n-fn bar(_: [Box<Foo>; 2]) {}\n-fn bars(_: &[Box<Foo+'static>]) {}\n+fn bar(_: [Box<dyn Foo>; 2]) {}\n+fn bars(_: &[Box<dyn Foo+'static>]) {}\n \n fn main() {\n-    let x: [&Foo; 2] = [&1, &2];\n+    let x: [&dyn Foo; 2] = [&1, &2];\n     foo(x);\n     foo([&1, &2]);\n \n     let r = &1;\n-    let x: [&Foo; 2] = [r; 2];\n+    let x: [&dyn Foo; 2] = [r; 2];\n     foo(x);\n     foo([&1; 2]);\n \n-    let x: &[&Foo] = &[&1, &2];\n+    let x: &[&dyn Foo] = &[&1, &2];\n     foos(x);\n     foos(&[&1, &2]);\n \n-    let x: &[&Foo] = &[&1, &2];\n+    let x: &[&dyn Foo] = &[&1, &2];\n     let r = &1;\n     foog(x, &[r]);\n \n-    let x: [Box<Foo>; 2] = [Box::new(1), Box::new(2)];\n+    let x: [Box<dyn Foo>; 2] = [Box::new(1), Box::new(2)];\n     bar(x);\n     bar([Box::new(1), Box::new(2)]);\n \n-    let x: &[Box<Foo+'static>] = &[Box::new(1), Box::new(2)];\n+    let x: &[Box<dyn Foo+'static>] = &[Box::new(1), Box::new(2)];\n     bars(x);\n     bars(&[Box::new(1), Box::new(2)]);\n \n-    let x: &[Box<Foo+'static>] = &[Box::new(1), Box::new(2)];\n+    let x: &[Box<dyn Foo+'static>] = &[Box::new(1), Box::new(2)];\n     foog(x, &[Box::new(1)]);\n \n     struct T<'a> {\n-        t: [&'a (Foo+'a); 2]\n+        t: [&'a (dyn Foo+'a); 2]\n     }\n     let _n = T {\n         t: [&1, &2]\n@@ -51,34 +51,34 @@ fn main() {\n     let _n = T {\n         t: [r; 2]\n     };\n-    let x: [&Foo; 2] = [&1, &2];\n+    let x: [&dyn Foo; 2] = [&1, &2];\n     let _n = T {\n         t: x\n     };\n \n     struct F<'b> {\n-        t: &'b [&'b (Foo+'b)]\n+        t: &'b [&'b (dyn Foo+'b)]\n     }\n     let _n = F {\n         t: &[&1, &2]\n     };\n     let r = &1;\n-    let r: [&Foo; 2] = [r; 2];\n+    let r: [&dyn Foo; 2] = [r; 2];\n     let _n = F {\n         t: &r\n     };\n-    let x: [&Foo; 2] = [&1, &2];\n+    let x: [&dyn Foo; 2] = [&1, &2];\n     let _n = F {\n         t: &x\n     };\n \n     struct M<'a> {\n-        t: &'a [Box<Foo+'static>]\n+        t: &'a [Box<dyn Foo+'static>]\n     }\n     let _n = M {\n         t: &[Box::new(1), Box::new(2)]\n     };\n-    let x: [Box<Foo>; 2] = [Box::new(1), Box::new(2)];\n+    let x: [Box<dyn Foo>; 2] = [Box::new(1), Box::new(2)];\n     let _n = M {\n         t: &x\n     };"}, {"sha": "848ed6ac7a8ff12eb6d6ab113796f5f601dacc0c", "filename": "src/test/run-pass/issues/issue-11267.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-11267.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-11267.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-11267.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -10,7 +10,7 @@ impl T<isize> for Empty {\n     fn next(&mut self) -> Option<isize> { None }\n }\n \n-fn do_something_with(a : &mut T<isize>) {\n+fn do_something_with(a : &mut dyn T<isize>) {\n     println!(\"{:?}\", a.next())\n }\n "}, {"sha": "be18c736f1483fe8ab141709523f2a8f41379ad8", "filename": "src/test/run-pass/issues/issue-11677.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-11677.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-11677.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-11677.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -11,8 +11,8 @@ trait X<T> {\n     fn dummy(&self) -> T { panic!() }\n }\n \n-struct S<T> {f: Box<X<T>+'static>,\n-             g: Box<X<T>+'static>}\n+struct S<T> {f: Box<dyn X<T>+'static>,\n+             g: Box<dyn X<T>+'static>}\n \n struct F;\n impl X<isize> for F {"}, {"sha": "cb5e3dff3b31b395b5c36efeaffc26e9f5cb6aed", "filename": "src/test/run-pass/issues/issue-11709.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-11709.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-11709.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-11709.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -9,7 +9,7 @@\n \n struct S {x:()}\n \n-fn test(slot: &mut Option<Box<FnMut() -> Box<FnMut()>>>) -> () {\n+fn test(slot: &mut Option<Box<dyn FnMut() -> Box<dyn FnMut()>>>) -> () {\n   let a = slot.take();\n   let _a = match a {\n     // `{let .. a(); }` would break"}, {"sha": "e2756ec970c39d7713956ef1b9971f94b83dc4ab", "filename": "src/test/run-pass/issues/issue-12744.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-12744.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-12744.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-12744.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n fn main() {\n-    fn test() -> Box<std::any::Any + 'static> { Box::new(1) }\n+    fn test() -> Box<dyn std::any::Any + 'static> { Box::new(1) }\n     println!(\"{:?}\", test())\n }"}, {"sha": "63f3589c6cc635c8a7563c58d97fc445065988f9", "filename": "src/test/run-pass/issues/issue-13507-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-13507-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-13507-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-13507-2.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -23,7 +23,7 @@ pub fn type_ids() -> Vec<TypeId> {\n         TypeId::of::<FooFnPtr>(),\n         TypeId::of::<FooNil>(),\n         TypeId::of::<FooTuple>(),\n-        TypeId::of::<FooTrait>(),\n+        TypeId::of::<dyn FooTrait>(),\n         TypeId::of::<FooStruct>(),\n         TypeId::of::<FooEnum>()\n     ]"}, {"sha": "9f9db067bf4b5ea8924637d59e785094da61e554", "filename": "src/test/run-pass/issues/issue-13808.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-13808.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-13808.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-13808.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -4,7 +4,7 @@\n // pretty-expanded FIXME #23616\n \n struct Foo<'a> {\n-    listener: Box<FnMut() + 'a>,\n+    listener: Box<dyn FnMut() + 'a>,\n }\n \n impl<'a> Foo<'a> {"}, {"sha": "6bf8a589959c57afa908a31f6f8f686e94880cc1", "filename": "src/test/run-pass/issues/issue-14399.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-14399.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-14399.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-14399.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -16,5 +16,5 @@ impl A for B1 {}\n \n fn main() {\n     let v: Box<_> = box B1;\n-    let _c: Box<A> = v.clone();\n+    let _c: Box<dyn A> = v.clone();\n }"}, {"sha": "5d8aab2ce74ce532fde522ebda3a3989ff44c6cd", "filename": "src/test/run-pass/issues/issue-14589.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-14589.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-14589.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-14589.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -5,9 +5,9 @@\n // pretty-expanded FIXME #23616\n \n fn main() {\n-    send::<Box<Foo>>(Box::new(Output(0)));\n-    Test::<Box<Foo>>::foo(Box::new(Output(0)));\n-    Test::<Box<Foo>>::new().send(Box::new(Output(0)));\n+    send::<Box<dyn Foo>>(Box::new(Output(0)));\n+    Test::<Box<dyn Foo>>::foo(Box::new(Output(0)));\n+    Test::<Box<dyn Foo>>::new().send(Box::new(Output(0)));\n }\n \n fn send<T>(_: T) {}"}, {"sha": "00b2e3607fcba4f872eb9f01f5c18d553a57f17b", "filename": "src/test/run-pass/issues/issue-14821.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-14821.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-14821.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-14821.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -6,16 +6,16 @@ struct Meow;\n impl SomeTrait for Meow {}\n \n struct Foo<'a> {\n-    x: &'a SomeTrait,\n-    y: &'a SomeTrait,\n+    x: &'a dyn SomeTrait,\n+    y: &'a dyn SomeTrait,\n }\n \n impl<'a> Foo<'a> {\n-    pub fn new<'b>(x: &'b SomeTrait, y: &'b SomeTrait) -> Foo<'b> { Foo { x: x, y: y } }\n+    pub fn new<'b>(x: &'b dyn SomeTrait, y: &'b dyn SomeTrait) -> Foo<'b> { Foo { x: x, y: y } }\n }\n \n fn main() {\n     let r = Meow;\n     let s = Meow;\n-    let q = Foo::new(&r as &SomeTrait, &s as &SomeTrait);\n+    let q = Foo::new(&r as &dyn SomeTrait, &s as &dyn SomeTrait);\n }"}, {"sha": "943615433549e2e84e518e4ca494fc192f860536", "filename": "src/test/run-pass/issues/issue-14919.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-14919.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-14919.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-14919.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -9,7 +9,7 @@ trait Matcher {\n \n struct CharPredMatcher<'a, 'b> {\n     str: &'a str,\n-    pred: Box<FnMut(char) -> bool + 'b>,\n+    pred: Box<dyn FnMut(char) -> bool + 'b>,\n }\n \n impl<'a, 'b> Matcher for CharPredMatcher<'a, 'b> {"}, {"sha": "a12564ca9c0ee40a301c2bf91856a0ade73a5040", "filename": "src/test/run-pass/issues/issue-14958.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-14958.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-14958.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-14958.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -7,17 +7,17 @@ trait Foo { fn dummy(&self) { }}\n \n struct Bar;\n \n-impl<'a> std::ops::Fn<(&'a (Foo+'a),)> for Bar {\n-    extern \"rust-call\" fn call(&self, _: (&'a Foo,)) {}\n+impl<'a> std::ops::Fn<(&'a (dyn Foo+'a),)> for Bar {\n+    extern \"rust-call\" fn call(&self, _: (&'a dyn Foo,)) {}\n }\n \n-impl<'a> std::ops::FnMut<(&'a (Foo+'a),)> for Bar {\n-    extern \"rust-call\" fn call_mut(&mut self, a: (&'a Foo,)) { self.call(a) }\n+impl<'a> std::ops::FnMut<(&'a (dyn Foo+'a),)> for Bar {\n+    extern \"rust-call\" fn call_mut(&mut self, a: (&'a dyn Foo,)) { self.call(a) }\n }\n \n-impl<'a> std::ops::FnOnce<(&'a (Foo+'a),)> for Bar {\n+impl<'a> std::ops::FnOnce<(&'a (dyn Foo+'a),)> for Bar {\n     type Output = ();\n-    extern \"rust-call\" fn call_once(self, a: (&'a Foo,)) { self.call(a) }\n+    extern \"rust-call\" fn call_once(self, a: (&'a dyn Foo,)) { self.call(a) }\n }\n \n struct Baz;"}, {"sha": "7b137b4af56a7d9745f7a9cd91aac7771d91b3db", "filename": "src/test/run-pass/issues/issue-15155.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-15155.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-15155.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-15155.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -4,18 +4,18 @@ trait IndirectTraitWithSend: TraitWithSend {}\n \n // Check struct instantiation (Box<TraitWithSend> will only have Send if TraitWithSend has Send)\n #[allow(dead_code)]\n-struct Blah { x: Box<TraitWithSend> }\n+struct Blah { x: Box<dyn TraitWithSend> }\n impl TraitWithSend for Blah {}\n \n // Struct instantiation 2-levels deep\n #[allow(dead_code)]\n-struct IndirectBlah { x: Box<IndirectTraitWithSend> }\n+struct IndirectBlah { x: Box<dyn IndirectTraitWithSend> }\n impl TraitWithSend for IndirectBlah {}\n impl IndirectTraitWithSend for IndirectBlah {}\n \n fn test_trait<T: Send + ?Sized>() { println!(\"got here!\") }\n \n fn main() {\n-    test_trait::<TraitWithSend>();\n-    test_trait::<IndirectTraitWithSend>();\n+    test_trait::<dyn TraitWithSend>();\n+    test_trait::<dyn IndirectTraitWithSend>();\n }"}, {"sha": "9ceffff2e38066ac903cfe1b37ccdd83025fcb3a", "filename": "src/test/run-pass/issues/issue-15763.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-15763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-15763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-15763.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -78,12 +78,12 @@ fn main() {\n     assert_eq!(cc().unwrap(), 3);\n     assert_eq!(dd().unwrap(), 3);\n \n-    let i = box 32isize as Box<A>;\n+    let i = box 32isize as Box<dyn A>;\n     assert_eq!(i.aaa(), 3);\n-    let i = box 32isize as Box<A>;\n+    let i = box 32isize as Box<dyn A>;\n     assert_eq!(i.bbb(), 3);\n-    let i = box 32isize as Box<A>;\n+    let i = box 32isize as Box<dyn A>;\n     assert_eq!(i.ccc().unwrap(), 3);\n-    let i = box 32isize as Box<A>;\n+    let i = box 32isize as Box<dyn A>;\n     assert_eq!(i.ddd().unwrap(), 3);\n }"}, {"sha": "54ad8fd076e4e871ccf601daa2671551b7018764", "filename": "src/test/run-pass/issues/issue-16739.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-16739.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-16739.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-16739.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -39,12 +39,12 @@ impl FnOnce<(u32,u32)> for Foo {\n }\n \n fn main() {\n-    let mut f = box Foo { foo: 42 } as Box<FnMut() -> u32>;\n+    let mut f = box Foo { foo: 42 } as Box<dyn FnMut() -> u32>;\n     assert_eq!(f.call_mut(()), 42);\n \n-    let mut f = box Foo { foo: 40 } as Box<FnMut(u32) -> u32>;\n+    let mut f = box Foo { foo: 40 } as Box<dyn FnMut(u32) -> u32>;\n     assert_eq!(f.call_mut((2,)), 42);\n \n-    let mut f = box Foo { foo: 40 } as Box<FnMut(u32, u32) -> u32>;\n+    let mut f = box Foo { foo: 40 } as Box<dyn FnMut(u32, u32) -> u32>;\n     assert_eq!(f.call_mut((1, 1)), 42);\n }"}, {"sha": "c3c6ff304888db8c6627a0608e9bb0ba0ad3b8c8", "filename": "src/test/run-pass/issues/issue-16922.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-16922.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-16922.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-16922.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -7,5 +7,5 @@ fn foo(_: &u8) {\n }\n \n fn main() {\n-    let _ = &foo as &Any;\n+    let _ = &foo as &dyn Any;\n }"}, {"sha": "20a8d136124695495b4dbe7e6e798497ffa4e4ff", "filename": "src/test/run-pass/issues/issue-17322.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-17322.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-17322.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-17322.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -5,11 +5,11 @@\n \n use std::io::{self, Write};\n \n-fn f(wr: &mut Write) {\n+fn f(wr: &mut dyn Write) {\n     wr.write_all(b\"hello\").ok().expect(\"failed\");\n }\n \n fn main() {\n-    let mut wr = box io::stdout() as Box<Write>;\n+    let mut wr = box io::stdout() as Box<dyn Write>;\n     f(&mut wr);\n }"}, {"sha": "62f6bcf15e3e74edd6b674d05a8af0a2ce416944", "filename": "src/test/run-pass/issues/issue-17351.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-17351.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-17351.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-17351.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -6,5 +6,5 @@ impl Str for str {}\n impl<'a, S: ?Sized> Str for &'a S where S: Str {}\n \n fn main() {\n-    let _: &Str = &\"x\";\n+    let _: &dyn Str = &\"x\";\n }"}, {"sha": "2f6464668c2ceafd2dde15cccf7dc2318db278e6", "filename": "src/test/run-pass/issues/issue-17771.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-17771.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-17771.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-17771.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -4,13 +4,13 @@\n \n trait Aaa { fn dummy(&self) { } }\n \n-impl<'a> Aaa for &'a mut (Aaa + 'a) {}\n+impl<'a> Aaa for &'a mut (dyn Aaa + 'a) {}\n \n struct Bar<'a> {\n-    writer: &'a mut (Aaa + 'a),\n+    writer: &'a mut (dyn Aaa + 'a),\n }\n \n-fn baz(_: &mut Aaa) {\n+fn baz(_: &mut dyn Aaa) {\n }\n \n fn foo<'a>(mut bar: Bar<'a>) {"}, {"sha": "6873c7ccb7f1c4a06857924633b41354c8db74e3", "filename": "src/test/run-pass/issues/issue-17897.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-17897.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-17897.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-17897.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-fn action(mut cb: Box<FnMut(usize) -> usize>) -> usize {\n+fn action(mut cb: Box<dyn FnMut(usize) -> usize>) -> usize {\n     cb(1)\n }\n "}, {"sha": "772cd9d7eda822acd082934770668c63b7f37baf", "filename": "src/test/run-pass/issues/issue-20055-box-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-20055-box-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-20055-box-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-20055-box-trait.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -22,7 +22,7 @@ pub fn foo(box_1: fn () -> Box<[i8; 1]>,\n            box_4: fn () -> Box<[i8; 4]>,\n             ) {\n     println!(\"Hello World 1\");\n-    let _: Box<Boo> = match 3 {\n+    let _: Box<dyn Boo> = match 3 {\n         1 => box_1(),\n         2 => box_2(),\n         3 => box_3(),"}, {"sha": "0ca67d9dc710e6c421ad4428f762c2b9341ad537", "filename": "src/test/run-pass/issues/issue-20575.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-20575.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-20575.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-20575.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -4,7 +4,7 @@\n // pretty-expanded FIXME #23616\n \n fn main() {\n-    let functions: [Box<Fn() -> Option<()>>; 1] = [Box::new(|| None)];\n+    let functions: [Box<dyn Fn() -> Option<()>>; 1] = [Box::new(|| None)];\n \n     let _: Option<Vec<()>> = functions.iter().map(|f| (*f)()).collect();\n }"}, {"sha": "2bc5034960a1bfdaf9d862ec13878e96577043fd", "filename": "src/test/run-pass/issues/issue-20676.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-20676.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-20676.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-20676.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -7,6 +7,6 @@\n use std::fmt;\n \n fn main() {\n-    let a: &fmt::Debug = &1;\n+    let a: &dyn fmt::Debug = &1;\n     format!(\"{:?}\", a);\n }"}, {"sha": "4ec7e3195ebe05fb1ba39c98fcdbcdb1d8ecf616", "filename": "src/test/run-pass/issues/issue-20953.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-20953.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-20953.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-20953.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -2,11 +2,11 @@\n #![allow(unused_mut)]\n #![allow(unused_variables)]\n fn main() {\n-    let mut shrinker: Box<Iterator<Item=i32>> = Box::new(vec![1].into_iter());\n+    let mut shrinker: Box<dyn Iterator<Item=i32>> = Box::new(vec![1].into_iter());\n     println!(\"{:?}\", shrinker.next());\n     for v in shrinker { assert!(false); }\n \n-    let mut shrinker: &mut Iterator<Item=i32> = &mut vec![1].into_iter();\n+    let mut shrinker: &mut dyn Iterator<Item=i32> = &mut vec![1].into_iter();\n     println!(\"{:?}\", shrinker.next());\n     for v in shrinker { assert!(false); }\n }"}, {"sha": "0483e62fd21213d300c92ce64930bab8c1b77c82", "filename": "src/test/run-pass/issues/issue-21058.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-21058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-21058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-21058.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -13,7 +13,7 @@ fn main() {\n         // str\n         std::intrinsics::type_name::<str>(),\n         // Trait\n-        std::intrinsics::type_name::<Send>(),\n+        std::intrinsics::type_name::<dyn Send>(),\n         // Newtype\n         std::intrinsics::type_name::<NT>(),\n         // DST"}, {"sha": "c970e77abb72b5b50fe7eb333a10d82b489e332a", "filename": "src/test/run-pass/issues/issue-21361.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-21361.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-21361.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-21361.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -2,10 +2,10 @@\n \n fn main() {\n     let v = vec![1, 2, 3];\n-    let boxed: Box<Iterator<Item=i32>> = Box::new(v.into_iter());\n+    let boxed: Box<dyn Iterator<Item=i32>> = Box::new(v.into_iter());\n     assert_eq!(boxed.max(), Some(3));\n \n     let v = vec![1, 2, 3];\n-    let boxed: &mut Iterator<Item=i32> = &mut v.into_iter();\n+    let boxed: &mut dyn Iterator<Item=i32> = &mut v.into_iter();\n     assert_eq!(boxed.max(), Some(3));\n }"}, {"sha": "d1cd4ec7b8a01995d1e76c34820e18c2abce14da", "filename": "src/test/run-pass/issues/issue-21655.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-21655.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-21655.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-21655.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -1,6 +1,6 @@\n // run-pass\n \n-fn test(it: &mut Iterator<Item=i32>) {\n+fn test(it: &mut dyn Iterator<Item=i32>) {\n     for x in it {\n         assert_eq!(x, 1)\n     }"}, {"sha": "e67a924b9eedc0ac0363ce725b8b2b891fe4755e", "filename": "src/test/run-pass/issues/issue-2190-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-2190-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-2190-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-2190-1.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -9,11 +9,11 @@ use std::thread::Builder;\n \n static generations: usize = 1024+256+128+49;\n \n-fn spawn(mut f: Box<FnMut() + 'static + Send>) {\n+fn spawn(mut f: Box<dyn FnMut() + 'static + Send>) {\n     Builder::new().stack_size(32 * 1024).spawn(move|| f());\n }\n \n-fn child_no(x: usize) -> Box<FnMut() + 'static + Send> {\n+fn child_no(x: usize) -> Box<dyn FnMut() + 'static + Send> {\n     Box::new(move|| {\n         if x < generations {\n             spawn(child_no(x+1));"}, {"sha": "5f6d9dcc9ae43d90ef0c770d721ce67f3d7b0066", "filename": "src/test/run-pass/issues/issue-22346.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-22346.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-22346.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-22346.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -3,7 +3,7 @@\n // pretty-expanded FIXME #23616\n \n // This used to cause an ICE because the retslot for the \"return\" had the wrong type\n-fn testcase<'a>() -> Box<Iterator<Item=usize> + 'a> {\n+fn testcase<'a>() -> Box<dyn Iterator<Item=usize> + 'a> {\n     return Box::new((0..3).map(|i| { return i; }));\n }\n "}, {"sha": "c74e53fca60fdfac8b07edf7c483277f39c491ff", "filename": "src/test/run-pass/issues/issue-2288.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-2288.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-2288.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-2288.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -23,13 +23,13 @@ fn foo<A>(b: A) -> foo<A> {\n     }\n }\n \n-fn f<A>(x: Box<clam<A>>, a: A) {\n+fn f<A>(x: Box<dyn clam<A>>, a: A) {\n   x.chowder(a);\n }\n \n pub fn main() {\n \n   let c = foo(42);\n-  let d: Box<clam<isize>> = box c as Box<clam<isize>>;\n+  let d: Box<dyn clam<isize>> = box c as Box<dyn clam<isize>>;\n   f(d, c.x);\n }"}, {"sha": "e21f86351eeee130592500b7593953b33331c0e6", "filename": "src/test/run-pass/issues/issue-23261.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-23261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-23261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-23261.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -41,7 +41,7 @@ fn check_both(val: &Foo<[u8]>) {\n     }\n }\n \n-fn check_trait_obj(val: &Foo<Get>) {\n+fn check_trait_obj(val: &Foo<dyn Get>) {\n     match *val {\n         Foo { a, ref inner } => {\n             assert_eq!(a, 32);\n@@ -56,6 +56,6 @@ fn main() {\n     check_dst_val(foo);\n     check_both(foo);\n \n-    let foo: &Foo<Get> = &Foo { a: 32, inner: 32 };\n+    let foo: &Foo<dyn Get> = &Foo { a: 32, inner: 32 };\n     check_trait_obj(foo);\n }"}, {"sha": "1dd3d9293bcc6112b04cded5179522135edba6c5", "filename": "src/test/run-pass/issues/issue-23485.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-23485.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-23485.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-23485.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -45,6 +45,6 @@ impl Iterator for Counter {\n }\n \n fn main() {\n-    let mut x: Box<Iterator<Item=Token>> = Box::new(Counter { value: 22 });\n+    let mut x: Box<dyn Iterator<Item=Token>> = Box::new(Counter { value: 22 });\n     assert_eq!(x.next().unwrap().value, 22);\n }"}, {"sha": "264e1ee22cdda8c70eddee0af9c0650e844a5672", "filename": "src/test/run-pass/issues/issue-24010.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-24010.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-24010.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-24010.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -2,7 +2,7 @@ trait Foo: Fn(i32) -> i32 + Send {}\n \n impl<T: ?Sized + Fn(i32) -> i32 + Send> Foo for T {}\n \n-fn wants_foo(f: Box<Foo>) -> i32 {\n+fn wants_foo(f: Box<dyn Foo>) -> i32 {\n     f(42)\n }\n "}, {"sha": "54622afbcfc1323daabb8d9e56c98ce1f5cb0ea9", "filename": "src/test/run-pass/issues/issue-24086.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-24086.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-24086.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-24086.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -7,8 +7,8 @@ pub struct Registry<'a> {\n }\n \n pub struct Listener<'a> {\n-    pub announce: Option<Box<FnMut(&mut Registry) + 'a>>,\n-    pub remove: Option<Box<FnMut(&mut Registry) + 'a>>,\n+    pub announce: Option<Box<dyn FnMut(&mut Registry) + 'a>>,\n+    pub remove: Option<Box<dyn FnMut(&mut Registry) + 'a>>,\n }\n \n impl<'a> Drop for Registry<'a> {"}, {"sha": "6f8ec700951e25a4cec8c1584e29fea67aed6328", "filename": "src/test/run-pass/issues/issue-25339.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-25339.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-25339.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-25339.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -12,7 +12,7 @@ pub trait Routing<I> {\n \n pub trait ToRouting {\n     type Input;\n-    type Routing : ?Sized = Routing<Self::Input, Output=()>;\n+    type Routing : ?Sized = dyn Routing<Self::Input, Output=()>;\n     fn to_routing(self) -> Self::Routing;\n }\n "}, {"sha": "e7b9ea3acfc01e225263bdeffa68cc7f8de480d4", "filename": "src/test/run-pass/issues/issue-25515.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-25515.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-25515.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-25515.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -13,7 +13,7 @@ fn main() {\n     let mut drops = 0;\n \n     {\n-        let _: Rc<Send> = Rc::new(Foo(&mut drops));\n+        let _: Rc<dyn Send> = Rc::new(Foo(&mut drops));\n     }\n \n     assert_eq!(1, drops);"}, {"sha": "25a2da707dc0f469d422d00e9a4edb725d192e65", "filename": "src/test/run-pass/issues/issue-25549-multiple-drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-25549-multiple-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-25549-multiple-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-25549-multiple-drop.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -25,7 +25,7 @@ fn main() {\n \n     drops = 0;\n     {\n-        let y = &Holder(Foo(&mut drops)) as &Holder<Trait>;\n+        let y = &Holder(Foo(&mut drops)) as &Holder<dyn Trait>;\n         // this used to cause an extra drop of the Foo instance\n         let x = &y.0;\n     }"}, {"sha": "ec1864d7deb589b883aab2fce42d19ed0f9b74fa", "filename": "src/test/run-pass/issues/issue-25757.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-25757.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-25757.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-25757.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -9,7 +9,7 @@ impl Foo {\n     }\n }\n \n-const FUNC: &'static Fn(&mut Foo) -> () = &Foo::x;\n+const FUNC: &'static dyn Fn(&mut Foo) -> () = &Foo::x;\n \n fn main() {\n     let mut foo = Foo { a: 137 };"}, {"sha": "4b6f2c2b3bc7d7d70dbcbef21a934368b6992ee1", "filename": "src/test/run-pass/issues/issue-26641.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26641.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26641.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26641.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-struct Parser<'a>(Box<FnMut(Parser) + 'a>);\n+struct Parser<'a>(Box<dyn FnMut(Parser) + 'a>);\n \n fn main() {\n     let _x = Parser(Box::new(|_|{}));"}, {"sha": "281ae13399dd2590dfc88d358c07f90ece659a41", "filename": "src/test/run-pass/issues/issue-26709.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26709.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26709.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26709.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -11,7 +11,7 @@ fn main() {\n     let mut x = 0;\n     {\n         let wrapper = Box::new(Wrapper(&mut x, 123));\n-        let _: Box<Wrapper<Send>> = wrapper;\n+        let _: Box<Wrapper<dyn Send>> = wrapper;\n     }\n     assert_eq!(432, x)\n }"}, {"sha": "307a67160980db8da67d82f2daa8d9cd6b6ffc6f", "filename": "src/test/run-pass/issues/issue-26802.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26802.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26802.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26802.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -5,7 +5,7 @@ trait Foo<'a> {\n \n pub struct FooBar;\n impl Foo<'static> for FooBar {}\n-fn test(foobar: FooBar) -> Box<Foo<'static>> {\n+fn test(foobar: FooBar) -> Box<dyn Foo<'static>> {\n     Box::new(foobar)\n }\n "}, {"sha": "bcf8a6731910fb006838b666be9b0846ce4a7d3a", "filename": "src/test/run-pass/issues/issue-26805.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26805.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26805.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26805.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -2,5 +2,5 @@\n struct NonOrd;\n \n fn main() {\n-    let _: Box<Iterator<Item = _>> = Box::new(vec![NonOrd].into_iter());\n+    let _: Box<dyn Iterator<Item = _>> = Box::new(vec![NonOrd].into_iter());\n }"}, {"sha": "2d5827f476b9e3c090ef95cd39758b2bf403cb27", "filename": "src/test/run-pass/issues/issue-26905.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26905.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26905.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26905.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -17,5 +17,5 @@ fn main() {\n     let data = [1, 2, 3];\n     let iter = data.iter();\n     let x = MyRc { _ptr: &iter, _boo: PhantomData };\n-    let _y: MyRc<Iterator<Item=&u32>> = x;\n+    let _y: MyRc<dyn Iterator<Item=&u32>> = x;\n }"}, {"sha": "161e2d4d204eb22eaa893cc21c2aea4d3454659a", "filename": "src/test/run-pass/issues/issue-27268.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-27268.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-27268.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-27268.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -1,4 +1,4 @@\n // run-pass\n fn main() {\n-    const _C: &'static Fn() = &||{};\n+    const _C: &'static dyn Fn() = &||{};\n }"}, {"sha": "d449f6449aa091e3a0d42de258bbe4961fd34397", "filename": "src/test/run-pass/issues/issue-2734.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-2734.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-2734.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-2734.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -11,8 +11,8 @@ trait hax {\n }\n impl<A> hax for A { }\n \n-fn perform_hax<T: 'static>(x: Box<T>) -> Box<hax+'static> {\n-    box x as Box<hax+'static>\n+fn perform_hax<T: 'static>(x: Box<T>) -> Box<dyn hax+'static> {\n+    box x as Box<dyn hax+'static>\n }\n \n fn deadcode() {"}, {"sha": "794c7d4edaa113f6e9d9089f7d820b0c988c48a5", "filename": "src/test/run-pass/issues/issue-2735.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-2735.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-2735.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-2735.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -11,8 +11,8 @@ trait hax {\n }\n impl<A> hax for A { }\n \n-fn perform_hax<T: 'static>(x: Box<T>) -> Box<hax+'static> {\n-    box x as Box<hax+'static>\n+fn perform_hax<T: 'static>(x: Box<T>) -> Box<dyn hax+'static> {\n+    box x as Box<dyn hax+'static>\n }\n \n fn deadcode() {"}, {"sha": "9f85473380f828d0a6b400f9539ce4c673c75db8", "filename": "src/test/run-pass/issues/issue-27890.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-27890.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-27890.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-27890.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -1,6 +1,6 @@\n // run-pass\n-static PLUS_ONE: &'static (Fn(i32) -> i32 + Sync) = (&|x: i32| { x + 1 })\n-    as &'static (Fn(i32) -> i32 + Sync);\n+static PLUS_ONE: &'static (dyn Fn(i32) -> i32 + Sync) = (&|x: i32| { x + 1 })\n+    as &'static (dyn Fn(i32) -> i32 + Sync);\n \n fn main() {\n     assert_eq!(PLUS_ONE(2), 3);"}, {"sha": "11641ca738018396765f77182fa3e1d0d70492be", "filename": "src/test/run-pass/issues/issue-2935.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-2935.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-2935.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-2935.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -20,7 +20,7 @@ pub fn main() {\n   //   let y = box ({a: 4});\n   //    let z = box ({a: 4} as it);\n   //    let z = box ({a: true} as it);\n-    let z: Box<_> = box (box true as Box<it>);\n+    let z: Box<_> = box (box true as Box<dyn it>);\n     //  x.f();\n     // y.f();\n     // (*z).f();"}, {"sha": "ee2456da3e2153f035b5df970177b8cf315f7a53", "filename": "src/test/run-pass/issues/issue-3052.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-3052.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-3052.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-3052.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -2,7 +2,7 @@\n #![allow(dead_code)]\n // pretty-expanded FIXME #23616\n \n-type Connection = Box<FnMut(Vec<u8>) + 'static>;\n+type Connection = Box<dyn FnMut(Vec<u8>) + 'static>;\n \n fn f() -> Option<Connection> {\n     let mock_connection: Connection = Box::new(|_| {});"}, {"sha": "e837fc81721a807c7a5166632d0a9263c9243988", "filename": "src/test/run-pass/issues/issue-30530.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-30530.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-30530.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-30530.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -8,15 +8,15 @@\n pub enum Handler {\n     Default,\n     #[allow(dead_code)]\n-    Custom(*mut Box<Fn()>),\n+    Custom(*mut Box<dyn Fn()>),\n }\n \n fn main() {\n     take(Handler::Default, Box::new(main));\n }\n \n #[inline(never)]\n-pub fn take(h: Handler, f: Box<Fn()>) -> Box<Fn()> {\n+pub fn take(h: Handler, f: Box<dyn Fn()>) -> Box<dyn Fn()> {\n     unsafe {\n         match h {\n             Handler::Custom(ptr) => *Box::from_raw(ptr),"}, {"sha": "c718449d84eed48676e61c6eee6cc1963b073a0d", "filename": "src/test/run-pass/issues/issue-30615.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-30615.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-30615.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-30615.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n fn main() {\n-    &0u8 as *const u8 as *const PartialEq<u8>;\n+    &0u8 as *const u8 as *const dyn PartialEq<u8>;\n     &[0u8] as *const [u8; 1] as *const [u8];\n }"}, {"sha": "cc94cc819d6655d047576adf205fc812746e1284", "filename": "src/test/run-pass/issues/issue-32389.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-32389.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-32389.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-32389.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -2,7 +2,7 @@\n fn foo<T>() -> T { loop {} }\n \n fn test() {\n-    let ref mut a: &mut FnMut((i8,), i16) = foo();\n+    let ref mut a: &mut dyn FnMut((i8,), i16) = foo();\n     a((0,), 0);\n }\n "}, {"sha": "499fa7c1f27ac7837432b4bdf3e8b8466dc932d8", "filename": "src/test/run-pass/issues/issue-33387.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-33387.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-33387.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-33387.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -15,18 +15,18 @@ impl Foo for [u8; 2] {\n \n struct Bar<T: ?Sized>(T);\n \n-fn unsize_fat_ptr<'a>(x: &'a Bar<Foo + Send + 'a>) -> &'a Bar<Foo + 'a> {\n+fn unsize_fat_ptr<'a>(x: &'a Bar<dyn Foo + Send + 'a>) -> &'a Bar<dyn Foo + 'a> {\n     x\n }\n \n-fn unsize_nested_fat_ptr(x: Arc<Foo + Send>) -> Arc<Foo> {\n+fn unsize_nested_fat_ptr(x: Arc<dyn Foo + Send>) -> Arc<dyn Foo> {\n     x\n }\n \n fn main() {\n-    let x: Box<Bar<Foo + Send>> = Box::new(Bar([1,2]));\n+    let x: Box<Bar<dyn Foo + Send>> = Box::new(Bar([1,2]));\n     assert_eq!(unsize_fat_ptr(&*x).0.get(), [1, 2]);\n \n-    let x: Arc<Foo + Send> = Arc::new([3, 4]);\n+    let x: Arc<dyn Foo + Send> = Arc::new([3, 4]);\n     assert_eq!(unsize_nested_fat_ptr(x).get(), [3, 4]);\n }"}, {"sha": "4e01d4d3061f93409c5d0df304965424120cd703", "filename": "src/test/run-pass/issues/issue-33461.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-33461.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-33461.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-33461.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -24,5 +24,5 @@ impl<P: TheTrait> Shape<P> for TheType<P::TheAssociatedType> {\n \n fn main() {\n     let ball = TheType { t: PhantomData };\n-    let handle: &Shape<()> = &ball;\n+    let handle: &dyn Shape<()> = &ball;\n }"}, {"sha": "26e7358408f484c10ed78651361b17d10f381b55", "filename": "src/test/run-pass/issues/issue-34503.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-34503.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-34503.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-34503.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -7,5 +7,5 @@ fn main() {\n         where Option<T>: Ord { *x < *x }\n     }\n     impl Foo<X> for () {}\n-    let _ = &() as &Foo<X>;\n+    let _ = &() as &dyn Foo<X>;\n }"}, {"sha": "05fd1b15d43d08179fa395a38ac27a97b72dbc08", "filename": "src/test/run-pass/issues/issue-35815.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-35815.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-35815.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-35815.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -10,6 +10,6 @@ struct Foo<T: ?Sized> {\n \n fn main() {\n     let foo: &Foo<i32> = &Foo { a: 1, b: false, c: 2i32 };\n-    let foo_unsized: &Foo<Send> = foo;\n+    let foo_unsized: &Foo<dyn Send> = foo;\n     assert_eq!(mem::size_of_val(foo), mem::size_of_val(foo_unsized));\n }"}, {"sha": "d96dc80ea719ceec61eda10b76e34164ac7afcc1", "filename": "src/test/run-pass/issues/issue-36260.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-36260.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-36260.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-36260.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -2,7 +2,7 @@\n // Make sure this compiles without getting a linker error because of missing\n // drop-glue because the collector missed adding drop-glue for the closure:\n \n-fn create_fn() -> Box<Fn()> {\n+fn create_fn() -> Box<dyn Fn()> {\n     let text = String::new();\n \n     Box::new(move || { let _ = &text; })"}, {"sha": "e5341ba7dbedde67dc232e703f869b51fe744511", "filename": "src/test/run-pass/issues/issue-36786-resolve-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-36786-resolve-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-36786-resolve-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-36786-resolve-call.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -3,6 +3,6 @@\n // correctly\n \n fn main() {\n-    let x : Vec<Box<Fn()>> = vec![Box::new(|| ())];\n+    let x : Vec<Box<dyn Fn()>> = vec![Box::new(|| ())];\n     x[0]()\n }"}, {"sha": "f48d549b3eb2cc2a386da36c71a7be430d93a7ce", "filename": "src/test/run-pass/issues/issue-3702.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-3702.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-3702.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-3702.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -6,7 +6,7 @@ pub fn main() {\n     fn to_string(&self) -> String;\n   }\n \n-  fn to_string(t: Box<Text>) {\n+  fn to_string(t: Box<dyn Text>) {\n     println!(\"{}\", (*t).to_string());\n   }\n "}, {"sha": "408d8d866d862efdfb7989f471d0be0e00aa6dfb", "filename": "src/test/run-pass/issues/issue-3794.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-3794.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-3794.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-3794.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -16,7 +16,7 @@ impl T for S {\n     }\n }\n \n-fn print_t(t: &T) {\n+fn print_t(t: &dyn T) {\n     t.print();\n }\n \n@@ -27,6 +27,6 @@ fn print_s(s: &S) {\n pub fn main() {\n     let s: Box<S> = box S { s: 5 };\n     print_s(&*s);\n-    let t: Box<T> = s as Box<T>;\n+    let t: Box<dyn T> = s as Box<dyn T>;\n     print_t(&*t);\n }"}, {"sha": "968cf08916fd6dd2bfd840e605fb7c0c715d4df7", "filename": "src/test/run-pass/issues/issue-39292.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-39292.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-39292.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-39292.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -13,5 +13,5 @@ trait Bar: for<'a> Foo<&'a ()> { }\n impl Bar for () {}\n \n fn main() {\n-    (&() as &Bar).print(); // Segfault\n+    (&() as &dyn Bar).print(); // Segfault\n }"}, {"sha": "148cf527e7cb7799dd2b5de6b6827bb113048130", "filename": "src/test/run-pass/issues/issue-39823.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-39823.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-39823.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-39823.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -11,15 +11,15 @@ struct LocalC(u32);\n struct LocalG<T>(T);\n \n fn main() {\n-    let virtual_localc : &Fn(_) -> LocalC = &LocalC;\n+    let virtual_localc : &dyn Fn(_) -> LocalC = &LocalC;\n     assert_eq!(virtual_localc(1), LocalC(1));\n \n-    let virtual_localg : &Fn(_) -> LocalG<u32> = &LocalG;\n+    let virtual_localg : &dyn Fn(_) -> LocalG<u32> = &LocalG;\n     assert_eq!(virtual_localg(1), LocalG(1));\n \n-    let virtual_remotec : &Fn(_) -> RemoteC = &RemoteC;\n+    let virtual_remotec : &dyn Fn(_) -> RemoteC = &RemoteC;\n     assert_eq!(virtual_remotec(1), RemoteC(1));\n \n-    let virtual_remoteg : &Fn(_) -> RemoteG<u32> = &RemoteG;\n+    let virtual_remoteg : &dyn Fn(_) -> RemoteG<u32> = &RemoteG;\n     assert_eq!(virtual_remoteg(1), RemoteG(1));\n }"}, {"sha": "967edfd44157688aa25659d824525b626b019fc5", "filename": "src/test/run-pass/issues/issue-41053.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-41053.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-41053.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-41053.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -6,8 +6,8 @@ pub trait Trait { fn foo(&self) {} }\n pub struct Foo;\n \n impl Iterator for Foo {\n-    type Item = Box<Trait>;\n-    fn next(&mut self) -> Option<Box<Trait>> {\n+    type Item = Box<dyn Trait>;\n+    fn next(&mut self) -> Option<Box<dyn Trait>> {\n         extern crate issue_41053;\n         impl ::Trait for issue_41053::Test {\n             fn foo(&self) {}"}, {"sha": "dcdd1c21ee527b664f591de9564f7bb63473c741", "filename": "src/test/run-pass/issues/issue-41744.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-41744.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-41744.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-41744.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -3,5 +3,5 @@ trait Tc {}\n impl Tc for bool {}\n \n fn main() {\n-    let _: &[&Tc] = &[&true];\n+    let _: &[&dyn Tc] = &[&true];\n }"}, {"sha": "318e3099f98ba4139df86f2dbaf881881d5ed754", "filename": "src/test/run-pass/issues/issue-42210.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-42210.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-42210.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-42210.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -12,9 +12,9 @@ struct Bar;\n trait Baz {\n }\n \n-impl Foo for (Bar, Baz) { }\n+impl Foo for (Bar, dyn Baz) { }\n \n \n fn main() {\n-    <(Bar, Baz) as Foo>::foo()\n+    <(Bar, dyn Baz) as Foo>::foo()\n }"}, {"sha": "c886f4b0a2d6bdadd801bc16f3396a4a8717422b", "filename": "src/test/run-pass/issues/issue-43132.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-43132.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-43132.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-43132.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -6,7 +6,7 @@ fn main() {\n \n fn foo() {\n     let b = mk::<\n-        Forward<(Box<Future<Error = u32>>,)>,\n+        Forward<(Box<dyn Future<Error = u32>>,)>,\n     >();\n     b.map_err(|_| ()).join();\n }"}, {"sha": "3df319b683f47d03ebbc104087c474cecaedad44", "filename": "src/test/run-pass/issues/issue-4333.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-4333.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-4333.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-4333.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -5,6 +5,6 @@\n use std::io;\n \n pub fn main() {\n-    let stdout = &mut io::stdout() as &mut io::Write;\n+    let stdout = &mut io::stdout() as &mut dyn io::Write;\n     stdout.write(b\"Hello!\");\n }"}, {"sha": "a1ed3c36544010f9a176bfe8ba95a888da3c8d53", "filename": "src/test/run-pass/issues/issue-47638.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-47638.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-47638.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-47638.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -1,10 +1,10 @@\n // run-pass\n #![allow(unused_variables)]\n-fn id<'c, 'b>(f: &'c &'b Fn(&i32)) -> &'c &'b Fn(&'static i32) {\n+fn id<'c, 'b>(f: &'c &'b dyn Fn(&i32)) -> &'c &'b dyn Fn(&'static i32) {\n     f\n }\n \n fn main() {\n-    let f: &Fn(&i32) = &|x| {};\n+    let f: &dyn Fn(&i32) = &|x| {};\n     id(&f);\n }"}, {"sha": "fc869ae4fec261fd93cd721a40f456ca12f35f2e", "filename": "src/test/run-pass/issues/issue-5008-borrowed-traitobject-method-call.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-5008-borrowed-traitobject-method-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-5008-borrowed-traitobject-method-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-5008-borrowed-traitobject-method-call.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -23,12 +23,12 @@ impl Debuggable for Thing {\n     fn debug_name(&self) -> String { self.name.clone() }\n }\n \n-fn print_name(x: &Debuggable)\n+fn print_name(x: &dyn Debuggable)\n {\n     println!(\"debug_name = {}\", x.debug_name());\n }\n \n pub fn main() {\n     let thing = Thing::new();\n-    print_name(&thing as &Debuggable);\n+    print_name(&thing as &dyn Debuggable);\n }"}, {"sha": "5a83d1c2ff9fd1b10fb3b989849611e0906374be", "filename": "src/test/run-pass/issues/issue-5192.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-5192.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-5192.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-5192.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -24,18 +24,18 @@ impl EventLoop for UvEventLoop {\n }\n \n pub struct Scheduler {\n-    event_loop: Box<EventLoop+'static>,\n+    event_loop: Box<dyn EventLoop+'static>,\n }\n \n impl Scheduler {\n \n-    pub fn new(event_loop: Box<EventLoop+'static>) -> Scheduler {\n+    pub fn new(event_loop: Box<dyn EventLoop+'static>) -> Scheduler {\n         Scheduler {\n             event_loop: event_loop,\n         }\n     }\n }\n \n pub fn main() {\n-    let _sched = Scheduler::new(box UvEventLoop::new() as Box<EventLoop>);\n+    let _sched = Scheduler::new(box UvEventLoop::new() as Box<dyn EventLoop>);\n }"}, {"sha": "aa513277830128d70f11828117d92aa69fba4ea3", "filename": "src/test/run-pass/issues/issue-5666.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-5666.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-5666.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-5666.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -19,7 +19,7 @@ impl Barks for Dog {\n pub fn main() {\n     let snoopy = box Dog{name: \"snoopy\".to_string()};\n     let bubbles = box Dog{name: \"bubbles\".to_string()};\n-    let barker = [snoopy as Box<Barks>, bubbles as Box<Barks>];\n+    let barker = [snoopy as Box<dyn Barks>, bubbles as Box<dyn Barks>];\n \n     for pup in &barker {\n         println!(\"{}\", pup.bark());"}, {"sha": "6fe9943d3689f7eee49cc37446eb3ef80b61bbd2", "filename": "src/test/run-pass/issues/issue-5708.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-5708.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-5708.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-5708.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -21,11 +21,11 @@ impl Inner for isize {\n }\n \n struct Outer<'a> {\n-    inner: &'a (Inner+'a)\n+    inner: &'a (dyn Inner+'a)\n }\n \n impl<'a> Outer<'a> {\n-    fn new(inner: &Inner) -> Outer {\n+    fn new(inner: &dyn Inner) -> Outer {\n         Outer {\n             inner: inner\n         }\n@@ -34,7 +34,7 @@ impl<'a> Outer<'a> {\n \n pub fn main() {\n     let inner: isize = 5;\n-    let outer = Outer::new(&inner as &Inner);\n+    let outer = Outer::new(&inner as &dyn Inner);\n     outer.inner.print();\n }\n \n@@ -45,11 +45,11 @@ pub trait MyTrait<T> {\n }\n \n pub struct MyContainer<'a, T:'a> {\n-    foos: Vec<&'a (MyTrait<T>+'a)> ,\n+    foos: Vec<&'a (dyn MyTrait<T>+'a)> ,\n }\n \n impl<'a, T> MyContainer<'a, T> {\n-    pub fn add (&mut self, foo: &'a MyTrait<T>) {\n+    pub fn add (&mut self, foo: &'a dyn MyTrait<T>) {\n         self.foos.push(foo);\n     }\n }"}, {"sha": "303fb4fbc94165f64d2d33f60d0b4986fb820435", "filename": "src/test/run-pass/issues/issue-5988.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-5988.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-5988.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-5988.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -19,6 +19,6 @@ impl T for A {\n \n fn main() {\n     let a = A;\n-    let br = &a as &B;\n+    let br = &a as &dyn B;\n     br.f();\n }"}, {"sha": "8859fbe6afb7b4ef01c5a3595d30828d8fe61866", "filename": "src/test/run-pass/issues/issue-6128.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-6128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-6128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-6128.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -20,5 +20,5 @@ impl<E> Graph<isize, E> for HashMap<isize, isize> {\n \n pub fn main() {\n     let g : Box<HashMap<isize,isize>> = box HashMap::new();\n-    let _g2 : Box<Graph<isize,isize>> = g as Box<Graph<isize,isize>>;\n+    let _g2 : Box<dyn Graph<isize,isize>> = g as Box<dyn Graph<isize,isize>>;\n }"}, {"sha": "b7a44ed86239584cca3d8013e72b8024c67a07c3", "filename": "src/test/run-pass/issues/issue-6157.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-6157.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-6157.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-6157.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -9,15 +9,15 @@ impl<F> OpInt for F where F: FnMut(isize, isize) -> isize {\n     }\n }\n \n-fn squarei<'a>(x: isize, op: &'a mut OpInt) -> isize { op.call(x, x) }\n+fn squarei<'a>(x: isize, op: &'a mut dyn OpInt) -> isize { op.call(x, x) }\n \n fn muli(x:isize, y:isize) -> isize { x * y }\n \n pub fn main() {\n     let mut f = |x, y| muli(x, y);\n     {\n         let g = &mut f;\n-        let h = g as &mut OpInt;\n+        let h = g as &mut dyn OpInt;\n         squarei(3, h);\n     }\n }"}, {"sha": "d8bd83f0dc6adfba71918c8eec3f61cf60db59dd", "filename": "src/test/run-pass/issues/issue-6318.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-6318.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-6318.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-6318.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -4,7 +4,7 @@\n #![feature(box_syntax)]\n \n pub enum Thing {\n-    A(Box<Foo+'static>)\n+    A(Box<dyn Foo+'static>)\n }\n \n pub trait Foo {\n@@ -16,7 +16,7 @@ pub struct Struct;\n impl Foo for Struct {}\n \n pub fn main() {\n-    match Thing::A(box Struct as Box<Foo+'static>) {\n+    match Thing::A(box Struct as Box<dyn Foo + 'static>) {\n         Thing::A(_a) => 0,\n     };\n }"}, {"sha": "c62405554b4d1d390b7b385f49a698e3edc0325b", "filename": "src/test/run-pass/issues/issue-7563.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-7563.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-7563.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-7563.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -16,7 +16,7 @@ struct B<'a> { b: isize, pa: &'a A }\n     }\n \n impl<'a> B<'a> {\n-    fn get_pa(&self) -> &'a IDummy { self.pa as &'a IDummy }\n+    fn get_pa(&self) -> &'a dyn IDummy { self.pa as &'a dyn IDummy }\n }\n \n pub fn main() {"}, {"sha": "de833324bd20f4be22b8356ff04c47ca45fc3d71", "filename": "src/test/run-pass/issues/issue-7911.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-7911.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-7911.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-7911.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -12,18 +12,18 @@ struct Foo { bar: Bar }\n impl FooBar for Bar {}\n \n trait Test {\n-    fn get_immut(&self) -> &FooBar;\n-    fn get_mut(&mut self) -> &mut FooBar;\n+    fn get_immut(&self) -> &dyn FooBar;\n+    fn get_mut(&mut self) -> &mut dyn FooBar;\n }\n \n macro_rules! generate_test { ($type_:path, $slf:ident, $field:expr) => (\n     impl Test for $type_ {\n-        fn get_immut(&$slf) -> &FooBar {\n-            &$field as &FooBar\n+        fn get_immut(&$slf) -> &dyn FooBar {\n+            &$field as &dyn FooBar\n         }\n \n-        fn get_mut(&mut $slf) -> &mut FooBar {\n-            &mut $field as &mut FooBar\n+        fn get_mut(&mut $slf) -> &mut dyn FooBar {\n+            &mut $field as &mut dyn FooBar\n         }\n     }\n )}"}, {"sha": "31a305c31bee241058c1a4be6a88f759e858b29a", "filename": "src/test/run-pass/issues/issue-8248.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-8248.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-8248.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-8248.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -7,9 +7,9 @@ trait A {\n struct B;\n impl A for B {}\n \n-fn foo(_: &mut A) {}\n+fn foo(_: &mut dyn A) {}\n \n pub fn main() {\n     let mut b = B;\n-    foo(&mut b as &mut A);\n+    foo(&mut b as &mut dyn A);\n }"}, {"sha": "d09dff3a6970905b972a571a3f53fc809627493c", "filename": "src/test/run-pass/issues/issue-8249.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-8249.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-8249.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-8249.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -9,10 +9,10 @@ struct B;\n impl A for B {}\n \n struct C<'a> {\n-    foo: &'a mut (A+'a),\n+    foo: &'a mut (dyn A+'a),\n }\n \n-fn foo(a: &mut A) {\n+fn foo(a: &mut dyn A) {\n     C{ foo: a };\n }\n "}, {"sha": "3d87e1c203783b1b65787f9526da7900fc6416b5", "filename": "src/test/run-pass/issues/issue-9129.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-9129.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-9129.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-9129.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -20,7 +20,7 @@ fn Ident_new() -> Ident {\n     Ident {name: 0x6789ABCD }\n }\n \n-pub fn light_fuse(fld: Box<bomb>) {\n+pub fn light_fuse(fld: Box<dyn bomb>) {\n     int3!();\n     let f = || {\n         int3!();\n@@ -30,6 +30,6 @@ pub fn light_fuse(fld: Box<bomb>) {\n }\n \n pub fn main() {\n-    let b = box S as Box<bomb>;\n+    let b = box S as Box<dyn bomb>;\n     light_fuse(b);\n }"}, {"sha": "cc0dd4fc14a0dc73ca7ff2425e8d250cc3f309ac", "filename": "src/test/run-pass/issues/issue-9394-inherited-trait-calls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-9394-inherited-trait-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-9394-inherited-trait-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-9394-inherited-trait-calls.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -52,7 +52,7 @@ impl Super for X {\n \n pub fn main() {\n     let n = X;\n-    let s = &n as &Super;\n+    let s = &n as &dyn Super;\n     assert_eq!(s.bar(),\"super bar\".to_string());\n     assert_eq!(s.foo(),\"base foo\".to_string());\n     assert_eq!(s.foo1(),\"base foo1\".to_string());"}, {"sha": "2698a3b17c6c25d4d444f26dc8005c0770a64380", "filename": "src/test/run-pass/issues/issue-9951.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-9951.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fissues%2Fissue-9951.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-9951.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -11,11 +11,11 @@ impl Bar for u8 {\n }\n \n fn main() {\n-    let (a, b) = (&5u8 as &Bar, &9u8 as &Bar);\n-    let (c, d): (&Bar, &Bar) = (a, b);\n+    let (a, b) = (&5u8 as &dyn Bar, &9u8 as &dyn Bar);\n+    let (c, d): (&dyn Bar, &dyn Bar) = (a, b);\n \n-    let (a, b) = (Box::new(5u8) as Box<Bar>, Box::new(9u8) as Box<Bar>);\n-    let (c, d): (&Bar, &Bar) = (&*a, &*b);\n+    let (a, b) = (Box::new(5u8) as Box<dyn Bar>, Box::new(9u8) as Box<dyn Bar>);\n+    let (c, d): (&dyn Bar, &dyn Bar) = (&*a, &*b);\n \n-    let (c, d): (&Bar, &Bar) = (&5, &9);\n+    let (c, d): (&dyn Bar, &dyn Bar) = (&5, &9);\n }"}, {"sha": "42dc6a4b06e1dc30dee6534894fd3e4a7ca45def", "filename": "src/test/run-pass/last-use-in-cap-clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Flast-use-in-cap-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Flast-use-in-cap-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flast-use-in-cap-clause.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -3,7 +3,7 @@\n \n struct A { a: Box<isize> }\n \n-fn foo() -> Box<FnMut() -> isize + 'static> {\n+fn foo() -> Box<dyn FnMut() -> isize + 'static> {\n     let k: Box<_> = Box::new(22);\n     let _u = A {a: k.clone()};\n     let result  = || 22;"}, {"sha": "eb1872cc7f094f72705ee0bbf4442fc906accdb9", "filename": "src/test/run-pass/macros/colorful-write-macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fmacros%2Fcolorful-write-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fmacros%2Fcolorful-write-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacros%2Fcolorful-write-macros.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -4,7 +4,7 @@ use std::io::Write;\n use std::fmt;\n \n struct Foo<'a> {\n-    writer: &'a mut (Write+'a),\n+    writer: &'a mut (dyn Write+'a),\n     other: &'a str,\n }\n \n@@ -22,7 +22,7 @@ fn borrowing_writer_from_struct_and_formatting_struct_field(foo: Foo) {\n \n fn main() {\n     let mut w = Vec::new();\n-    write!(&mut w as &mut Write, \"\").unwrap();\n+    write!(&mut w as &mut dyn Write, \"\").unwrap();\n     write!(&mut w, \"\").unwrap(); // should coerce\n     println!(\"ok\");\n "}, {"sha": "dd3ad2ef0ac0fd90655e7af2228748c0220aa556", "filename": "src/test/run-pass/macros/type-macros-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fmacros%2Ftype-macros-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fmacros%2Ftype-macros-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacros%2Ftype-macros-simple.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -16,7 +16,7 @@ fn issue_36540() {\n \n     let x: m!() = m!();\n     std::cell::Cell::<m!()>::new(m!());\n-    impl<T> std::ops::Index<m!()> for Trait<(m!(), T)>\n+    impl<T> std::ops::Index<m!()> for dyn Trait<(m!(), T)>\n         where T: Trait<m!()>\n     {\n         type Output = m!();"}, {"sha": "acd4a8465b0757dcec4aa982b4b90d93fb11f6ed", "filename": "src/test/run-pass/methods/method-argument-inference-associated-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fmethods%2Fmethod-argument-inference-associated-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fmethods%2Fmethod-argument-inference-associated-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethods%2Fmethod-argument-inference-associated-type.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -10,13 +10,13 @@ pub trait Service {\n pub struct S<T>(T);\n \n impl Service for ClientMap {\n-    type Request = S<Box<Fn(i32)>>;\n+    type Request = S<Box<dyn Fn(i32)>>;\n     fn call(&self, _req: Self::Request) {}\n }\n \n \n impl Service for ClientMap2 {\n-    type Request = (Box<Fn(i32)>,);\n+    type Request = (Box<dyn Fn(i32)>,);\n     fn call(&self, _req: Self::Request) {}\n }\n "}, {"sha": "fc0db03e3a96894350a9611f398c150de1afebe3", "filename": "src/test/run-pass/mir/mir_codegen_calls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fmir%2Fmir_codegen_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fmir%2Fmir_codegen_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir%2Fmir_codegen_calls.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -42,7 +42,7 @@ fn test4(x: &Foo, a: isize) -> isize {\n     x.extension_method(a)\n }\n \n-fn test5(x: &Bar, a: isize) -> isize {\n+fn test5(x: &dyn Bar, a: isize) -> isize {\n     // Test calling method on trait object\n     x.extension_method(a)\n }\n@@ -88,11 +88,11 @@ fn test_closure<F>(f: &F, x: i32, y: i32) -> i32\n     f(x, y)\n }\n \n-fn test_fn_object(f: &Fn(i32, i32) -> i32, x: i32, y: i32) -> i32 {\n+fn test_fn_object(f: &dyn Fn(i32, i32) -> i32, x: i32, y: i32) -> i32 {\n     f(x, y)\n }\n \n-fn test_fn_impl(f: &&Fn(i32, i32) -> i32, x: i32, y: i32) -> i32 {\n+fn test_fn_impl(f: &&dyn Fn(i32, i32) -> i32, x: i32, y: i32) -> i32 {\n     // This call goes through the Fn implementation for &Fn provided in\n     // core::ops::impls. It expands to a static Fn::call() that calls the\n     // Fn::call() implementation of the object shim underneath.\n@@ -174,7 +174,7 @@ fn main() {\n     let closure = |x: i32, y: i32| { r*(x + (y*2)) };\n     assert_eq!(test_fn_const_call(&closure), 294);\n     assert_eq!(test_closure(&closure, 100, 1), 306);\n-    let function_object = &closure as &Fn(i32, i32) -> i32;\n+    let function_object = &closure as &dyn Fn(i32, i32) -> i32;\n     assert_eq!(test_fn_object(function_object, 100, 2), 312);\n     assert_eq!(test_fn_impl(&function_object, 100, 3), 318);\n     assert_eq!(test_fn_direct_call(&closure, 100, 4), 324);"}, {"sha": "5c1f1c3b70135ce17f461780fb7ba32ea74ad958", "filename": "src/test/run-pass/mir/mir_codegen_critical_edge.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fmir%2Fmir_codegen_critical_edge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fmir%2Fmir_codegen_critical_edge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir%2Fmir_codegen_critical_edge.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -37,7 +37,7 @@ where A: Iterator, B: Iterator<Item=A::Item>\n }\n \n // Make sure we actually codegen a version of the function\n-pub fn do_stuff(mut f: Foo<Box<Iterator<Item=u32>>, Box<Iterator<Item=u32>>>) {\n+pub fn do_stuff(mut f: Foo<Box<dyn Iterator<Item=u32>>, Box<dyn Iterator<Item=u32>>>) {\n     let _x = f.next();\n }\n "}, {"sha": "f3dcc6b85fd98a537443a103812d17392b83e7c4", "filename": "src/test/run-pass/mir/mir_coercions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fmir%2Fmir_coercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fmir%2Fmir_coercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir%2Fmir_coercions.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -4,12 +4,12 @@\n use std::ops::CoerceUnsized;\n use std::marker::Unsize;\n \n-fn identity_coercion(x: &(Fn(u32)->u32 + Send)) -> &Fn(u32)->u32 {\n+fn identity_coercion(x: &(dyn Fn(u32)->u32 + Send)) -> &dyn Fn(u32)->u32 {\n     x\n }\n fn fn_coercions(f: &fn(u32) -> u32) ->\n     (unsafe fn(u32) -> u32,\n-     &(Fn(u32) -> u32+Send))\n+     &(dyn Fn(u32) -> u32+Send))\n {\n     (*f, f)\n }\n@@ -35,8 +35,8 @@ fn coerce_triv_ptr_wrapper(p: TrivPtrWrapper<[u8; 3]>) -> TrivPtrWrapper<[u8]> {\n     p\n }\n \n-fn coerce_fat_ptr_wrapper(p: PtrWrapper<Fn(u32) -> u32+Send>)\n-                          -> PtrWrapper<Fn(u32) -> u32> {\n+fn coerce_fat_ptr_wrapper(p: PtrWrapper<dyn Fn(u32) -> u32+Send>)\n+                          -> PtrWrapper<dyn Fn(u32) -> u32> {\n     p\n }\n \n@@ -65,7 +65,7 @@ fn main() {\n     let z = coerce_fat_ptr_wrapper(PtrWrapper(2,3,(),&square_local));\n     assert_eq!((z.3)(6), 36);\n \n-    let z: PtrWrapper<Fn(u32) -> u32> =\n+    let z: PtrWrapper<dyn Fn(u32) -> u32> =\n         coerce_ptr_wrapper_poly(PtrWrapper(2,3,(),&square_local));\n     assert_eq!((z.3)(6), 36);\n }"}, {"sha": "6583852aa9bb64b1c475e7b1df5c4c182d1246f1", "filename": "src/test/run-pass/mir/mir_raw_fat_ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fmir%2Fmir_raw_fat_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fmir%2Fmir_raw_fat_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir%2Fmir_raw_fat_ptr.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -63,7 +63,7 @@ fn compare_au8(a: *const [u8], b: *const [u8]) -> ComparisonResults {\n     }\n }\n \n-fn compare_foo<'a>(a: *const (Foo+'a), b: *const (Foo+'a)) -> ComparisonResults {\n+fn compare_foo<'a>(a: *const (dyn Foo+'a), b: *const (dyn Foo+'a)) -> ComparisonResults {\n     ComparisonResults {\n         lt: a < b,\n         le: a <= b,\n@@ -74,7 +74,7 @@ fn compare_foo<'a>(a: *const (Foo+'a), b: *const (Foo+'a)) -> ComparisonResults\n     }\n }\n \n-fn simple_eq<'a>(a: *const (Foo+'a), b: *const (Foo+'a)) -> bool {\n+fn simple_eq<'a>(a: *const (dyn Foo+'a), b: *const (dyn Foo+'a)) -> bool {\n     let result = a == b;\n     result\n }\n@@ -128,7 +128,7 @@ fn main() {\n     let u32_ = (4u32, 5u32);\n \n     // check ordering for ptrs\n-    let buf: &mut [*const Foo] = &mut [\n+    let buf: &mut [*const dyn Foo] = &mut [\n         &u8_, &u8_.0,\n         &u32_, &u32_.0,\n     ];"}, {"sha": "5539518c37072d26bd8c1c5cb021d887598ff3eb", "filename": "src/test/run-pass/new-box.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fnew-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fnew-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnew-box.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -18,13 +18,13 @@ impl Trait for Struct {\n     }\n }\n \n-fn g(x: Box<Trait>) {\n+fn g(x: Box<dyn Trait>) {\n     x.printme();\n-    let y: &Trait = &*x;\n+    let y: &dyn Trait = &*x;\n     y.printme();\n }\n \n fn main() {\n     f(box 1234);\n-    g(box Struct as Box<Trait>);\n+    g(box Struct as Box<dyn Trait>);\n }"}, {"sha": "79c9f7dc01103cc38f2560622cfbdf15cfbfd256", "filename": "src/test/run-pass/newlambdas-ret-infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -4,7 +4,7 @@\n \n // pretty-expanded FIXME #23616\n \n-fn unique() -> Box<FnMut()+'static> { return Box::new(|| ()); }\n+fn unique() -> Box<dyn FnMut()+'static> { return Box::new(|| ()); }\n \n pub fn main() {\n }"}, {"sha": "104f5be7767d35fc9febece36c1e7770bfc35799", "filename": "src/test/run-pass/newlambdas-ret-infer2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewlambdas-ret-infer2.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -4,7 +4,7 @@\n \n // pretty-expanded FIXME #23616\n \n-fn unique() -> Box<FnMut()+'static> { Box::new(|| ()) }\n+fn unique() -> Box<dyn FnMut()+'static> { Box::new(|| ()) }\n \n pub fn main() {\n }"}, {"sha": "cd61dea03788fa9ab3ae6c2c5db18bf0b7f6ebb1", "filename": "src/test/run-pass/object-lifetime-default-default-to-static.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-default-to-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-default-to-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-default-to-static.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -10,23 +10,23 @@ trait Test {\n }\n \n struct SomeStruct {\n-    t: Box<Test>,\n-    u: Box<Test+'static>,\n+    t: Box<dyn Test>,\n+    u: Box<dyn Test+'static>,\n }\n \n-fn a(t: Box<Test>, mut ss: SomeStruct) {\n+fn a(t: Box<dyn Test>, mut ss: SomeStruct) {\n     ss.t = t;\n }\n \n-fn b(t: Box<Test+'static>, mut ss: SomeStruct) {\n+fn b(t: Box<dyn Test+'static>, mut ss: SomeStruct) {\n     ss.t = t;\n }\n \n-fn c(t: Box<Test>, mut ss: SomeStruct) {\n+fn c(t: Box<dyn Test>, mut ss: SomeStruct) {\n     ss.u = t;\n }\n \n-fn d(t: Box<Test+'static>, mut ss: SomeStruct) {\n+fn d(t: Box<dyn Test+'static>, mut ss: SomeStruct) {\n     ss.u = t;\n }\n "}, {"sha": "9212f2802c0180572f34ae6d25bacfe1b54c93c4", "filename": "src/test/run-pass/object-lifetime-default-from-rptr-box.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-rptr-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-rptr-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-rptr-box.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -10,21 +10,21 @@ trait Test {\n }\n \n struct SomeStruct<'a> {\n-    t: &'a Box<Test>,\n-    u: &'a Box<Test+'a>,\n+    t: &'a Box<dyn Test>,\n+    u: &'a Box<dyn Test+'a>,\n }\n \n-fn a<'a>(t: &'a Box<Test>, mut ss: SomeStruct<'a>) {\n+fn a<'a>(t: &'a Box<dyn Test>, mut ss: SomeStruct<'a>) {\n     ss.t = t;\n }\n \n-fn b<'a>(t: &'a Box<Test>, mut ss: SomeStruct<'a>) {\n+fn b<'a>(t: &'a Box<dyn Test>, mut ss: SomeStruct<'a>) {\n     ss.u = t;\n }\n \n // see also compile-fail/object-lifetime-default-from-rptr-box-error.rs\n \n-fn d<'a>(t: &'a Box<Test+'a>, mut ss: SomeStruct<'a>) {\n+fn d<'a>(t: &'a Box<dyn Test+'a>, mut ss: SomeStruct<'a>) {\n     ss.u = t;\n }\n "}, {"sha": "061f3a116fcbb9dee6c993488cfdec6569a81fa9", "filename": "src/test/run-pass/object-lifetime-default-from-rptr-mut.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-rptr-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-rptr-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-rptr-mut.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -10,23 +10,23 @@ trait Test {\n }\n \n struct SomeStruct<'a> {\n-    t: &'a mut Test,\n-    u: &'a mut (Test+'a),\n+    t: &'a mut dyn Test,\n+    u: &'a mut (dyn Test+'a),\n }\n \n-fn a<'a>(t: &'a mut Test, mut ss: SomeStruct<'a>) {\n+fn a<'a>(t: &'a mut dyn Test, mut ss: SomeStruct<'a>) {\n     ss.t = t;\n }\n \n-fn b<'a>(t: &'a mut Test, mut ss: SomeStruct<'a>) {\n+fn b<'a>(t: &'a mut dyn Test, mut ss: SomeStruct<'a>) {\n     ss.u = t;\n }\n \n-fn c<'a>(t: &'a mut (Test+'a), mut ss: SomeStruct<'a>) {\n+fn c<'a>(t: &'a mut (dyn Test+'a), mut ss: SomeStruct<'a>) {\n     ss.t = t;\n }\n \n-fn d<'a>(t: &'a mut (Test+'a), mut ss: SomeStruct<'a>) {\n+fn d<'a>(t: &'a mut (dyn Test+'a), mut ss: SomeStruct<'a>) {\n     ss.u = t;\n }\n "}, {"sha": "cfa4af0d7a53fb5b0102783e7f34a04e94e4cfb4", "filename": "src/test/run-pass/object-lifetime-default-from-rptr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-rptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-rptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobject-lifetime-default-from-rptr.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -12,30 +12,30 @@ trait Test {\n }\n \n struct SomeStruct<'a> {\n-    t: &'a Test,\n-    u: &'a (Test+'a),\n+    t: &'a dyn Test,\n+    u: &'a (dyn Test+'a),\n }\n \n-fn a<'a>(t: &'a Test, mut ss: SomeStruct<'a>) {\n+fn a<'a>(t: &'a dyn Test, mut ss: SomeStruct<'a>) {\n     ss.t = t;\n }\n \n-fn b<'a>(t: &'a Test, mut ss: SomeStruct<'a>) {\n+fn b<'a>(t: &'a dyn Test, mut ss: SomeStruct<'a>) {\n     ss.u = t;\n }\n \n-fn c<'a>(t: &'a (Test+'a), mut ss: SomeStruct<'a>) {\n+fn c<'a>(t: &'a (dyn Test+'a), mut ss: SomeStruct<'a>) {\n     ss.t = t;\n }\n \n-fn d<'a>(t: &'a (Test+'a), mut ss: SomeStruct<'a>) {\n+fn d<'a>(t: &'a (dyn Test+'a), mut ss: SomeStruct<'a>) {\n     ss.u = t;\n }\n \n-fn e<'a>(_: &'a (Display+'static)) {}\n+fn e<'a>(_: &'a (dyn Display+'static)) {}\n \n fn main() {\n     // Inside a function body, we can just infer both\n     // lifetimes, to allow &'tmp (Display+'static).\n-    e(&0 as &Display);\n+    e(&0 as &dyn Display);\n }"}, {"sha": "7f24ab2cbb5ff7559129449b25d70aef142584de", "filename": "src/test/run-pass/object-method-numbering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fobject-method-numbering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fobject-method-numbering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobject-method-numbering.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -21,7 +21,7 @@ impl SomeTrait for i32 {\n \n fn main() {\n     let x = 22;\n-    let x1: &SomeTrait<SomeType=i32> = &x;\n+    let x1: &dyn SomeTrait<SomeType=i32> = &x;\n     let y = get_int(x1);\n     assert_eq!(x, y);\n }"}, {"sha": "47196f108c02c6831f10205fa64593770aea5ff2", "filename": "src/test/run-pass/objects-coerce-freeze-borrored.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fobjects-coerce-freeze-borrored.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fobjects-coerce-freeze-borrored.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobjects-coerce-freeze-borrored.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -17,22 +17,22 @@ impl Foo for usize {\n     }\n }\n \n-fn do_it_mut(obj: &mut Foo) {\n+fn do_it_mut(obj: &mut dyn Foo) {\n     let x = obj.bar();\n     let y = obj.foo();\n     assert_eq!(x, y);\n \n     do_it_imm(obj, y);\n }\n \n-fn do_it_imm(obj: &Foo, v: usize) {\n+fn do_it_imm(obj: &dyn Foo, v: usize) {\n     let y = obj.foo();\n     assert_eq!(v, y);\n }\n \n pub fn main() {\n     let mut x: usize = 22;\n-    let obj = &mut x as &mut Foo;\n+    let obj = &mut x as &mut dyn Foo;\n     do_it_mut(obj);\n     do_it_imm(obj, 23);\n     do_it_mut(obj);"}, {"sha": "58327237494edba475e68bc9a1d2a728c03e5324", "filename": "src/test/run-pass/objects-owned-object-borrowed-method-headerless.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fobjects-owned-object-borrowed-method-headerless.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fobjects-owned-object-borrowed-method-headerless.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobjects-owned-object-borrowed-method-headerless.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -20,10 +20,10 @@ impl FooTrait for BarStruct {\n }\n \n pub fn main() {\n-    let foos: Vec<Box<FooTrait>> = vec![\n-        box BarStruct{ x: 0 } as Box<FooTrait>,\n-        box BarStruct{ x: 1 } as Box<FooTrait>,\n-        box BarStruct{ x: 2 } as Box<FooTrait>\n+    let foos: Vec<Box<dyn FooTrait>> = vec![\n+        box BarStruct{ x: 0 } as Box<dyn FooTrait>,\n+        box BarStruct{ x: 1 } as Box<dyn FooTrait>,\n+        box BarStruct{ x: 2 } as Box<dyn FooTrait>\n     ];\n \n     for i in 0..foos.len() {"}, {"sha": "69984fbb62f1467bbcc8309bcbb34890db1e3995", "filename": "src/test/run-pass/objects-owned-object-owned-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fobjects-owned-object-owned-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fobjects-owned-object-owned-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobjects-owned-object-owned-method.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -19,6 +19,6 @@ impl FooTrait for BarStruct {\n }\n \n pub fn main() {\n-    let foo = box BarStruct{ x: 22 } as Box<FooTrait>;\n+    let foo = box BarStruct{ x: 22 } as Box<dyn FooTrait>;\n     assert_eq!(22, foo.foo());\n }"}, {"sha": "1afab9a1ffbe7890625230c7ecc32397bbbae58d", "filename": "src/test/run-pass/overloaded/overloaded-calls-object-one-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Foverloaded%2Foverloaded-calls-object-one-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Foverloaded%2Foverloaded-calls-object-one-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded%2Foverloaded-calls-object-one-arg.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -3,7 +3,7 @@\n // This is a bit tricky due to rust-call ABI.\n \n \n-fn foo(f: &mut FnMut(isize) -> isize) -> isize {\n+fn foo(f: &mut dyn FnMut(isize) -> isize) -> isize {\n     f(22)\n }\n "}, {"sha": "38087bc8710fcf4cc63316cdeaac583894ce1734", "filename": "src/test/run-pass/overloaded/overloaded-calls-object-two-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Foverloaded%2Foverloaded-calls-object-two-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Foverloaded%2Foverloaded-calls-object-two-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded%2Foverloaded-calls-object-two-args.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -3,7 +3,7 @@\n // This is a bit tricky due to rust-call ABI.\n \n \n-fn foo(f: &mut FnMut(isize, isize) -> isize) -> isize {\n+fn foo(f: &mut dyn FnMut(isize, isize) -> isize) -> isize {\n     f(1, 2)\n }\n "}, {"sha": "9a7bfaa9bf4f019ea8fa7c920ec3af8e64d2745a", "filename": "src/test/run-pass/overloaded/overloaded-calls-object-zero-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Foverloaded%2Foverloaded-calls-object-zero-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Foverloaded%2Foverloaded-calls-object-zero-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded%2Foverloaded-calls-object-zero-args.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -3,7 +3,7 @@\n // This is a bit tricky due to rust-call ABI.\n \n \n-fn foo(f: &mut FnMut() -> isize) -> isize {\n+fn foo(f: &mut dyn FnMut() -> isize) -> isize {\n     f()\n }\n "}, {"sha": "9867cc56406ef109dd2c4a2fed8c7c9b1c831783", "filename": "src/test/run-pass/panics/panic-safe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fpanics%2Fpanic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fpanics%2Fpanic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanics%2Fpanic-safe.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -33,7 +33,7 @@ fn main() {\n     assert::<Box<[u8]>>();\n \n     trait Trait: UnwindSafe {}\n-    assert::<Box<Trait>>();\n+    assert::<Box<dyn Trait>>();\n \n     fn bar<T>() {\n         assert::<Mutex<T>>();"}, {"sha": "c32e3f17880db13d02562e2fdff72150d0d096de", "filename": "src/test/run-pass/privacy/privacy-ns.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fprivacy%2Fprivacy-ns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fprivacy%2Fprivacy-ns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprivacy%2Fprivacy-ns.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -28,19 +28,19 @@ fn test_unused1() {\n fn test_single1() {\n     use foo1::Bar;\n \n-    let _x: Box<Bar>;\n+    let _x: Box<dyn Bar>;\n }\n \n fn test_list1() {\n     use foo1::{Bar,Baz};\n \n-    let _x: Box<Bar>;\n+    let _x: Box<dyn Bar>;\n }\n \n fn test_glob1() {\n     use foo1::*;\n \n-    let _x: Box<Bar>;\n+    let _x: Box<dyn Bar>;\n }\n \n // private type, public value\n@@ -93,21 +93,21 @@ fn test_single3() {\n     use foo3::Bar;\n \n     Bar();\n-    let _x: Box<Bar>;\n+    let _x: Box<dyn Bar>;\n }\n \n fn test_list3() {\n     use foo3::{Bar,Baz};\n \n     Bar();\n-    let _x: Box<Bar>;\n+    let _x: Box<dyn Bar>;\n }\n \n fn test_glob3() {\n     use foo3::*;\n \n     Bar();\n-    let _x: Box<Bar>;\n+    let _x: Box<dyn Bar>;\n }\n \n fn main() {"}, {"sha": "511a35b25a3e8fc766ad2e3e8ec362ef788f6ec5", "filename": "src/test/run-pass/raw-fat-ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fraw-fat-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fraw-fat-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fraw-fat-ptr.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -78,7 +78,7 @@ fn main() {\n     let mut u32_ = (4u32, 5u32);\n \n     // check ordering for ptrs\n-    let buf: &mut [*const Foo] = &mut [\n+    let buf: &mut [*const dyn Foo] = &mut [\n         &u8_, &u8_.0,\n         &u32_, &u32_.0,\n     ];\n@@ -90,7 +90,7 @@ fn main() {\n     assert_inorder(buf);\n \n     // check ordering for mut ptrs\n-    let buf: &mut [*mut Foo] = &mut [\n+    let buf: &mut [*mut dyn Foo] = &mut [\n         &mut u8_, &mut u8_.0,\n         &mut u32_, &mut u32_.0,\n     ];"}, {"sha": "3815498f86fbb8ee8f227f3cf513f51cefaf3dad", "filename": "src/test/run-pass/regions/regions-bound-lists-feature-gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fregions%2Fregions-bound-lists-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fregions%2Fregions-bound-lists-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions%2Fregions-bound-lists-feature-gate.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -9,7 +9,7 @@ trait Foo {\n     fn dummy(&self) { }\n }\n \n-fn foo<'a>(x: Box<Foo + 'a>) {\n+fn foo<'a>(x: Box<dyn Foo + 'a>) {\n }\n \n fn bar<'a, T: 'a>() {"}, {"sha": "4b47ed8c6aeb7120ed4c56888112208bafa0d365", "filename": "src/test/run-pass/regions/regions-close-over-type-parameter-successfully.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fregions%2Fregions-close-over-type-parameter-successfully.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fregions%2Fregions-close-over-type-parameter-successfully.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions%2Fregions-close-over-type-parameter-successfully.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -12,8 +12,8 @@ impl<'a> SomeTrait for &'a isize {\n     }\n }\n \n-fn make_object<'a,A:SomeTrait+'a>(v: A) -> Box<SomeTrait+'a> {\n-    box v as Box<SomeTrait+'a>\n+fn make_object<'a,A:SomeTrait+'a>(v: A) -> Box<dyn SomeTrait+'a> {\n+    box v as Box<dyn SomeTrait+'a>\n }\n \n fn main() {"}, {"sha": "43640079777a343cf5b81f86b64d3e0c96e6cec1", "filename": "src/test/run-pass/regions/regions-copy-closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fregions%2Fregions-copy-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fregions%2Fregions-copy-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions%2Fregions-copy-closure.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -2,10 +2,10 @@\n #![allow(non_camel_case_types)]\n \n struct closure_box<'a> {\n-    cl: Box<FnMut() + 'a>,\n+    cl: Box<dyn FnMut() + 'a>,\n }\n \n-fn box_it<'a>(x: Box<FnMut() + 'a>) -> closure_box<'a> {\n+fn box_it<'a>(x: Box<dyn FnMut() + 'a>) -> closure_box<'a> {\n     closure_box {cl: x}\n }\n "}, {"sha": "0b5510489fb45a9b4b7beedab337e80cc4abc170", "filename": "src/test/run-pass/regions/regions-debruijn-of-object.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fregions%2Fregions-debruijn-of-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fregions%2Fregions-debruijn-of-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions%2Fregions-debruijn-of-object.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -13,9 +13,9 @@ trait AstConv<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ctxt<'tcx>;\n }\n \n-fn foo(conv: &AstConv) { }\n+fn foo(conv: &dyn AstConv) { }\n \n-fn bar<'tcx>(conv: &AstConv<'tcx>) {\n+fn bar<'tcx>(conv: &dyn AstConv<'tcx>) {\n     foo(conv)\n }\n "}, {"sha": "cc2bde78d8594b3a6d488a9b75acd9d603455398", "filename": "src/test/run-pass/regions/regions-early-bound-trait-param.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fregions%2Fregions-early-bound-trait-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fregions%2Fregions-early-bound-trait-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions%2Fregions-early-bound-trait-param.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -15,14 +15,14 @@ fn poly_invoke<'c, T: Trait<'c>>(x: &'c T) -> (isize, isize) {\n     (l,s)\n }\n \n-fn object_invoke1<'d>(x: &'d Trait<'d>) -> (isize, isize) {\n+fn object_invoke1<'d>(x: &'d dyn Trait<'d>) -> (isize, isize) {\n     let l = x.long();\n     let s = x.short();\n     (l,s)\n }\n \n struct Struct1<'e> {\n-    f: &'e (Trait<'e>+'e)\n+    f: &'e (dyn Trait<'e>+'e)\n }\n \n fn field_invoke1<'f, 'g>(x: &'g Struct1<'f>) -> (isize,isize) {\n@@ -32,10 +32,10 @@ fn field_invoke1<'f, 'g>(x: &'g Struct1<'f>) -> (isize,isize) {\n }\n \n struct Struct2<'h, 'i:'h> {\n-    f: &'h (Trait<'i>+'h)\n+    f: &'h (dyn Trait<'i>+'h)\n }\n \n-fn object_invoke2<'j, 'k>(x: &'k Trait<'j>) -> isize {\n+fn object_invoke2<'j, 'k>(x: &'k dyn Trait<'j>) -> isize {\n     x.short()\n }\n \n@@ -70,10 +70,10 @@ impl<'s> Trait<'s> for (isize,isize) {\n     }\n }\n \n-impl<'t> MakerTrait for Box<Trait<'t>+'static> {\n-    fn mk() -> Box<Trait<'t>+'static> {\n+impl<'t> MakerTrait for Box<dyn Trait<'t>+'static> {\n+    fn mk() -> Box<dyn Trait<'t>+'static> {\n         let tup: Box<(isize, isize)> = box (4,5);\n-        tup as Box<Trait>\n+        tup as Box<dyn Trait>\n     }\n }\n \n@@ -105,7 +105,7 @@ impl<'t> RefMakerTrait<'t> for List<'t> {\n \n pub fn main() {\n     let t = (2,3);\n-    let o = &t as &Trait;\n+    let o = &t as &dyn Trait;\n     let s1 = Struct1 { f: o };\n     let s2 = Struct2 { f: o };\n     assert_eq!(poly_invoke(&t), (2,3));\n@@ -114,7 +114,7 @@ pub fn main() {\n     assert_eq!(object_invoke2(&t), 3);\n     assert_eq!(field_invoke2(&s2), 3);\n \n-    let m : Box<Trait> = make_val();\n+    let m : Box<dyn Trait> = make_val();\n     // assert_eq!(object_invoke1(&*m), (4,5));\n     //            ~~~~~~~~~~~~~~~~~~~\n     // this call yields a compilation error; see compile-fail/dropck-object-cycle.rs"}, {"sha": "83949ddba3d1ee96126c4a983ba1eeb4d216ca8e", "filename": "src/test/run-pass/regions/regions-fn-subtyping-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fregions%2Fregions-fn-subtyping-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fregions%2Fregions-fn-subtyping-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions%2Fregions-fn-subtyping-2.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -7,13 +7,13 @@\n // that `x` is in.\n // pretty-expanded FIXME #23616\n \n-fn has_same_region(f: Box<for<'a> FnMut(&'a isize, Box<FnMut(&'a isize)>)>) {\n+fn has_same_region(f: Box<dyn for<'a> FnMut(&'a isize, Box<dyn FnMut(&'a isize)>)>) {\n     // `f` should be the type that `wants_same_region` wants, but\n     // right now the compiler complains that it isn't.\n     wants_same_region(f);\n }\n \n-fn wants_same_region(_f: Box<for<'b> FnMut(&'b isize, Box<FnMut(&'b isize)>)>) {\n+fn wants_same_region(_f: Box<dyn for<'b> FnMut(&'b isize, Box<dyn FnMut(&'b isize)>)>) {\n }\n \n pub fn main() {"}, {"sha": "9570359c69e315a89a230da74692588e044f4d18", "filename": "src/test/run-pass/regions/regions-fn-subtyping.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fregions%2Fregions-fn-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fregions%2Fregions-fn-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions%2Fregions-fn-subtyping.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -8,21 +8,21 @@\n #![allow(unused_variables)]\n \n // Should pass region checking.\n-fn ok(f: Box<FnMut(&usize)>) {\n+fn ok(f: Box<dyn FnMut(&usize)>) {\n     // Here, g is a function that can accept a usize pointer with\n     // lifetime r, and f is a function that can accept a usize pointer\n     // with any lifetime.  The assignment g = f should be OK (i.e.,\n     // f's type should be a subtype of g's type), because f can be\n     // used in any context that expects g's type.  But this currently\n     // fails.\n-    let mut g: Box<for<'r> FnMut(&'r usize)> = Box::new(|x| { });\n+    let mut g: Box<dyn for<'r> FnMut(&'r usize)> = Box::new(|x| { });\n     g = f;\n }\n \n // This version is the same as above, except that here, g's type is\n // inferred.\n-fn ok_inferred(f: Box<FnMut(&usize)>) {\n-    let mut g: Box<for<'r> FnMut(&'r usize)> = Box::new(|_| {});\n+fn ok_inferred(f: Box<dyn FnMut(&usize)>) {\n+    let mut g: Box<dyn for<'r> FnMut(&'r usize)> = Box::new(|_| {});\n     g = f;\n }\n "}, {"sha": "6aa5d8217a466b496fc82f813e1751f558b9005d", "filename": "src/test/run-pass/regions/regions-infer-region-in-fn-but-not-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fregions%2Fregions-infer-region-in-fn-but-not-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fregions%2Fregions-infer-region-in-fn-but-not-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions%2Fregions-infer-region-in-fn-but-not-type.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -8,7 +8,7 @@\n // contains region pointers\n // pretty-expanded FIXME #23616\n \n-struct foo(Box<FnMut(&isize)+'static>);\n+struct foo(Box<dyn FnMut(&isize)+'static>);\n \n fn take_foo<T:'static>(x: T) {}\n "}, {"sha": "c8106f32c65c257f68071d359c1484d6276d83b4", "filename": "src/test/run-pass/regions/regions-lifetime-nonfree-late-bound.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fregions%2Fregions-lifetime-nonfree-late-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fregions%2Fregions-lifetime-nonfree-late-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions%2Fregions-lifetime-nonfree-late-bound.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -19,15 +19,15 @@\n \n pub fn main() {\n     fn explicit() {\n-        fn test<F>(_x: Option<Box<F>>) where F: FnMut(Box<for<'a> FnMut(&'a isize)>) {}\n-        test(Some(box |_f: Box<for<'a> FnMut(&'a isize)>| {}));\n+        fn test<F>(_x: Option<Box<F>>) where F: FnMut(Box<dyn for<'a> FnMut(&'a isize)>) {}\n+        test(Some(box |_f: Box<dyn for<'a> FnMut(&'a isize)>| {}));\n     }\n \n     // The code below is shorthand for the code above (and more likely\n     // to represent what one encounters in practice).\n     fn implicit() {\n-        fn test<F>(_x: Option<Box<F>>) where F: FnMut(Box<        FnMut(&   isize)>) {}\n-        test(Some(box |_f: Box<        FnMut(&   isize)>| {}));\n+        fn test<F>(_x: Option<Box<F>>) where F: FnMut(Box<dyn        FnMut(&   isize)>) {}\n+        test(Some(box |_f: Box<dyn        FnMut(&   isize)>| {}));\n     }\n \n     explicit();"}, {"sha": "aec05161c1afbca2d57e7fdf7c7836db6136b889", "filename": "src/test/run-pass/regions/regions-relate-bound-regions-on-closures-to-inference-variables.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fregions%2Fregions-relate-bound-regions-on-closures-to-inference-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fregions%2Fregions-relate-bound-regions-on-closures-to-inference-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions%2Fregions-relate-bound-regions-on-closures-to-inference-variables.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -44,7 +44,7 @@ impl<'a,'tcx> Foo<'a,'tcx> {\n \n     fn elaborate_bounds(\n         &mut self,\n-        mut mk_cand: Box<for<'b> FnMut(&mut Foo<'b, 'tcx>) -> isize>)\n+        mut mk_cand: Box<dyn for<'b> FnMut(&mut Foo<'b, 'tcx>) -> isize>)\n         -> isize\n     {\n         mk_cand(self)"}, {"sha": "09cd56220323d84a00756534297b9ff1a7d51c78", "filename": "src/test/run-pass/regions/regions-static-closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fregions%2Fregions-static-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fregions%2Fregions-static-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions%2Fregions-static-closure.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -2,10 +2,10 @@\n #![allow(non_camel_case_types)]\n \n struct closure_box<'a> {\n-    cl: Box<FnMut() + 'a>,\n+    cl: Box<dyn FnMut() + 'a>,\n }\n \n-fn box_it<'a>(x: Box<FnMut() + 'a>) -> closure_box<'a> {\n+fn box_it<'a>(x: Box<dyn FnMut() + 'a>) -> closure_box<'a> {\n     closure_box {cl: x}\n }\n "}, {"sha": "679bf4dd8117c5506b01d43e9873e1e80c0f09b2", "filename": "src/test/run-pass/regions/regions-trait-object-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fregions%2Fregions-trait-object-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fregions%2Fregions-trait-object-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions%2Fregions-trait-object-1.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -21,10 +21,10 @@ impl<'d> M for P<'d> {\n     fn n(&self) -> u8 { *self.g }\n }\n \n-fn extension<'e>(x: &'e E<'e>) -> Box<M+'e> {\n+fn extension<'e>(x: &'e E<'e>) -> Box<dyn M+'e> {\n     loop {\n         let p = P { g: x.m() };\n-        return Box::new(p) as Box<M+'e>;\n+        return Box::new(p) as Box<dyn M+'e>;\n     }\n }\n "}, {"sha": "944157d0b20094cda0d4a2379a465ef3708822a3", "filename": "src/test/run-pass/string-box-error.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fstring-box-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fstring-box-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstring-box-error.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -4,8 +4,8 @@\n use std::error::Error;\n \n fn main() {\n-    let _err1: Box<Error + Send + Sync> = From::from(\"test\".to_string());\n-    let _err2: Box<Error> = From::from(\"test\".to_string());\n-    let _err3: Box<Error + Send + Sync + 'static> = From::from(\"test\");\n-    let _err4: Box<Error> = From::from(\"test\");\n+    let _err1: Box<dyn Error + Send + Sync> = From::from(\"test\".to_string());\n+    let _err2: Box<dyn Error> = From::from(\"test\".to_string());\n+    let _err3: Box<dyn Error + Send + Sync + 'static> = From::from(\"test\");\n+    let _err4: Box<dyn Error> = From::from(\"test\");\n }"}, {"sha": "bf1ba8a643fea8f89950724a933b5d34598552da", "filename": "src/test/run-pass/structs-enums/class-cast-to-trait-cross-crate-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fclass-cast-to-trait-cross-crate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fclass-cast-to-trait-cross-crate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fclass-cast-to-trait-cross-crate-2.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -8,13 +8,13 @@ extern crate cci_class_cast;\n use std::string::ToString;\n use cci_class_cast::kitty::cat;\n \n-fn print_out(thing: Box<ToString>, expected: String) {\n+fn print_out(thing: Box<dyn ToString>, expected: String) {\n   let actual = (*thing).to_string();\n   println!(\"{}\", actual);\n   assert_eq!(actual.to_string(), expected);\n }\n \n pub fn main() {\n-  let nyan: Box<ToString> = box cat(0, 2, \"nyan\".to_string()) as Box<ToString>;\n+  let nyan: Box<dyn ToString> = box cat(0, 2, \"nyan\".to_string()) as Box<dyn ToString>;\n   print_out(nyan, \"nyan\".to_string());\n }"}, {"sha": "55975cbdb5342ee491a78f37fe9d95017b9985f7", "filename": "src/test/run-pass/structs-enums/class-cast-to-trait-multiple-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fclass-cast-to-trait-multiple-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fclass-cast-to-trait-multiple-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fclass-cast-to-trait-multiple-types.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -79,7 +79,7 @@ fn cat(in_x: usize, in_y: isize, in_name: String) -> cat {\n }\n \n \n-fn annoy_neighbors(critter: &mut noisy) {\n+fn annoy_neighbors(critter: &mut dyn noisy) {\n     for _i in 0_usize..10 { critter.speak(); }\n }\n "}, {"sha": "1019bb30015a94302ee12798a005296d1748b1e1", "filename": "src/test/run-pass/structs-enums/class-cast-to-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fclass-cast-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fclass-cast-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fclass-cast-to-trait.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -55,6 +55,6 @@ fn cat(in_x : usize, in_y : isize, in_name: String) -> cat {\n \n pub fn main() {\n     let mut nyan = cat(0, 2, \"nyan\".to_string());\n-    let mut nyan: &mut noisy = &mut nyan;\n+    let mut nyan: &mut dyn noisy = &mut nyan;\n     nyan.speak();\n }"}, {"sha": "947690b51f422ab70ec1bfb46dd4eb83adbb1321", "filename": "src/test/run-pass/structs-enums/class-separate-impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fclass-separate-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fclass-separate-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fclass-separate-impl.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -53,13 +53,13 @@ impl fmt::Display for cat {\n     }\n }\n \n-fn print_out(thing: Box<ToString>, expected: String) {\n+fn print_out(thing: Box<dyn ToString>, expected: String) {\n   let actual = (*thing).to_string();\n   println!(\"{}\", actual);\n   assert_eq!(actual.to_string(), expected);\n }\n \n pub fn main() {\n-  let nyan: Box<ToString> = box cat(0, 2, \"nyan\".to_string()) as Box<ToString>;\n+  let nyan: Box<dyn ToString> = box cat(0, 2, \"nyan\".to_string()) as Box<dyn ToString>;\n   print_out(nyan, \"nyan\".to_string());\n }"}, {"sha": "87629665bc2bd6dc015fb558f3b0eb8599c9dd31", "filename": "src/test/run-pass/structs-enums/enum-null-pointer-opt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fenum-null-pointer-opt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fenum-null-pointer-opt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fenum-null-pointer-opt.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -22,9 +22,9 @@ fn main() {\n     assert_eq!(size_of::<&mut [isize]>(), size_of::<Option<&mut [isize]>>());\n \n     // Traits - Box<Trait> / &Trait / &mut Trait\n-    assert_eq!(size_of::<Box<Trait>>(), size_of::<Option<Box<Trait>>>());\n-    assert_eq!(size_of::<&Trait>(), size_of::<Option<&Trait>>());\n-    assert_eq!(size_of::<&mut Trait>(), size_of::<Option<&mut Trait>>());\n+    assert_eq!(size_of::<Box<dyn Trait>>(), size_of::<Option<Box<dyn Trait>>>());\n+    assert_eq!(size_of::<&dyn Trait>(), size_of::<Option<&dyn Trait>>());\n+    assert_eq!(size_of::<&mut dyn Trait>(), size_of::<Option<&mut dyn Trait>>());\n \n     // Pointers - Box<T>\n     assert_eq!(size_of::<Box<isize>>(), size_of::<Option<Box<isize>>>());"}, {"sha": "e1a865fa5039967666dbd3ccd7f08429dbbf2776", "filename": "src/test/run-pass/structs-enums/object-lifetime-default-from-ref-struct.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fobject-lifetime-default-from-ref-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fobject-lifetime-default-from-ref-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fobject-lifetime-default-from-ref-struct.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -22,37 +22,37 @@ struct Ref2<'a,'b,T:'a+'b+?Sized> {\n }\n \n struct SomeStruct<'a> {\n-    t: Ref<'a,Test>,\n-    u: Ref<'a,Test+'a>,\n+    t: Ref<'a, dyn Test>,\n+    u: Ref<'a, dyn Test+'a>,\n }\n \n-fn a<'a>(t: Ref<'a,Test>, mut ss: SomeStruct<'a>) {\n+fn a<'a>(t: Ref<'a, dyn Test>, mut ss: SomeStruct<'a>) {\n     ss.t = t;\n }\n \n-fn b<'a>(t: Ref<'a,Test>, mut ss: SomeStruct<'a>) {\n+fn b<'a>(t: Ref<'a, dyn Test>, mut ss: SomeStruct<'a>) {\n     ss.u = t;\n }\n \n-fn c<'a>(t: Ref<'a,Test+'a>, mut ss: SomeStruct<'a>) {\n+fn c<'a>(t: Ref<'a, dyn Test+'a>, mut ss: SomeStruct<'a>) {\n     ss.t = t;\n }\n \n-fn d<'a>(t: Ref<'a,Test+'a>, mut ss: SomeStruct<'a>) {\n+fn d<'a>(t: Ref<'a, dyn Test+'a>, mut ss: SomeStruct<'a>) {\n     ss.u = t;\n }\n \n-fn e<'a>(_: Ref<'a, Display+'static>) {}\n-fn g<'a, 'b>(_: Ref2<'a, 'b, Display+'static>) {}\n+fn e<'a>(_: Ref<'a, dyn Display+'static>) {}\n+fn g<'a, 'b>(_: Ref2<'a, 'b, dyn Display+'static>) {}\n \n \n fn main() {\n     // Inside a function body, we can just infer all\n     // lifetimes, to allow Ref<'tmp, Display+'static>\n     // and Ref2<'tmp, 'tmp, Display+'static>.\n-    let x = &0 as &(Display+'static);\n-    let r: Ref<Display> = Ref { r: x };\n-    let r2: Ref2<Display> = Ref2 { a: x, b: x };\n+    let x = &0 as &(dyn Display+'static);\n+    let r: Ref<dyn Display> = Ref { r: x };\n+    let r2: Ref2<dyn Display> = Ref2 { a: x, b: x };\n     e(r);\n     g(r2);\n }"}, {"sha": "1fc52ead48e0e54d421210e9283e444d859c3a37", "filename": "src/test/run-pass/structs-enums/object-lifetime-default-from-rptr-struct.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fobject-lifetime-default-from-rptr-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fobject-lifetime-default-from-rptr-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstructs-enums%2Fobject-lifetime-default-from-rptr-struct.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -11,25 +11,25 @@ trait Test {\n }\n \n struct SomeStruct<'a> {\n-    t: &'a MyBox<Test>,\n-    u: &'a MyBox<Test+'a>,\n+    t: &'a MyBox<dyn Test>,\n+    u: &'a MyBox<dyn Test+'a>,\n }\n \n struct MyBox<T:?Sized> {\n     b: Box<T>\n }\n \n-fn a<'a>(t: &'a MyBox<Test>, mut ss: SomeStruct<'a>) {\n+fn a<'a>(t: &'a MyBox<dyn Test>, mut ss: SomeStruct<'a>) {\n     ss.t = t;\n }\n \n-fn b<'a>(t: &'a MyBox<Test>, mut ss: SomeStruct<'a>) {\n+fn b<'a>(t: &'a MyBox<dyn Test>, mut ss: SomeStruct<'a>) {\n     ss.u = t;\n }\n \n // see also compile-fail/object-lifetime-default-from-rptr-box-error.rs\n \n-fn d<'a>(t: &'a MyBox<Test+'a>, mut ss: SomeStruct<'a>) {\n+fn d<'a>(t: &'a MyBox<dyn Test+'a>, mut ss: SomeStruct<'a>) {\n     ss.u = t;\n }\n "}, {"sha": "c495b97b25bfee31a4b659434aea376d1c0f61c5", "filename": "src/test/run-pass/traits/auto-traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Fauto-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Fauto-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Fauto-traits.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -27,5 +27,5 @@ fn main() {\n     take_auto_unsafe(AutoBool(true));\n \n     /// Auto traits are allowed in trait object bounds.\n-    let _: &(Send + Auto) = &0;\n+    let _: &(dyn Send + Auto) = &0;\n }"}, {"sha": "82760788897a5878a322eeb555c7c2b316f166ad", "filename": "src/test/run-pass/traits/impl-inherent-prefer-over-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Fimpl-inherent-prefer-over-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Fimpl-inherent-prefer-over-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Fimpl-inherent-prefer-over-trait.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -11,7 +11,7 @@ impl Foo {\n     fn bar(&self) {}\n }\n \n-impl Trait {\n+impl dyn Trait {\n     fn baz(_: &Foo) {}\n }\n \n@@ -26,5 +26,5 @@ fn main() {\n \n     // Should work even if Trait::baz doesn't exist.\n     // N.B: `<Trait>::bar` would be ambiguous.\n-    <Trait>::baz(&Foo);\n+    <dyn Trait>::baz(&Foo);\n }"}, {"sha": "ed258dbb24c3f7fcdeb798069ee0e6c9f3475eac", "filename": "src/test/run-pass/traits/infer-from-object-trait-issue-26952.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Finfer-from-object-trait-issue-26952.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Finfer-from-object-trait-issue-26952.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Finfer-from-object-trait-issue-26952.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -14,7 +14,7 @@ trait Trait<A> { fn foo(&self); }\n \n struct Type<A> { a: PhantomData<A> }\n \n-fn as_trait<A>(t: &Type<A>) -> &Trait<A> { loop {  } }\n+fn as_trait<A>(t: &Type<A>) -> &dyn Trait<A> { loop {  } }\n \n fn want<A,T:Trait<A>+?Sized>(t: &T) { }\n "}, {"sha": "23b91f924b553055f6562153a2904bdd66224b63", "filename": "src/test/run-pass/traits/kindck-owned-trait-contains-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Fkindck-owned-trait-contains-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Fkindck-owned-trait-contains-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Fkindck-owned-trait-contains-1.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -12,8 +12,8 @@ impl<A:Clone + 'static> repeat<A> for Box<A> {\n     }\n }\n \n-fn repeater<A:Clone + 'static>(v: Box<A>) -> Box<repeat<A>+'static> {\n-    box v as Box<repeat<A>+'static> // No\n+fn repeater<A:Clone + 'static>(v: Box<A>) -> Box<dyn repeat<A>+'static> {\n+    box v as Box<dyn repeat<A>+'static> // No\n }\n \n pub fn main() {"}, {"sha": "b92a2ab7b4bc2414ab9aaab2517088df6652b372", "filename": "src/test/run-pass/traits/object-one-type-two-traits.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Fobject-one-type-two-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Fobject-one-type-two-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Fobject-one-type-two-traits.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -10,24 +10,24 @@ use std::any::Any;\n \n trait Wrap {\n     fn get(&self) -> isize;\n-    fn wrap(self: Box<Self>) -> Box<Any+'static>;\n+    fn wrap(self: Box<Self>) -> Box<dyn Any+'static>;\n }\n \n impl Wrap for isize {\n     fn get(&self) -> isize {\n         *self\n     }\n-    fn wrap(self: Box<isize>) -> Box<Any+'static> {\n-        self as Box<Any+'static>\n+    fn wrap(self: Box<isize>) -> Box<dyn Any+'static> {\n+        self as Box<dyn Any+'static>\n     }\n }\n \n-fn is<T:Any>(x: &Any) -> bool {\n+fn is<T:Any>(x: &dyn Any) -> bool {\n     x.is::<T>()\n }\n \n fn main() {\n-    let x = box 22isize as Box<Wrap>;\n+    let x = box 22isize as Box<dyn Wrap>;\n     println!(\"x={}\", x.get());\n     let y = x.wrap();\n }"}, {"sha": "832d4f6c89f09c321199554abbef7c5ceb3a738c", "filename": "src/test/run-pass/traits/parameterized-trait-with-bounds.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Fparameterized-trait-with-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Fparameterized-trait-with-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Fparameterized-trait-with-bounds.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -12,10 +12,10 @@ mod foo {\n     pub trait D<'a, T> { fn get(self) -> &'a T; }\n }\n \n-fn foo1<T>(_: &(A<T> + Send)) {}\n-fn foo2<T>(_: Box<A<T> + Send + Sync>) {}\n-fn foo3<T>(_: Box<B<isize, usize> + 'static>) {}\n-fn foo4<'a, T>(_: Box<C<'a, T> + 'static + Send>) {}\n-fn foo5<'a, T>(_: Box<foo::D<'a, T> + 'static + Send>) {}\n+fn foo1<T>(_: &(dyn A<T> + Send)) {}\n+fn foo2<T>(_: Box<dyn A<T> + Send + Sync>) {}\n+fn foo3<T>(_: Box<dyn B<isize, usize> + 'static>) {}\n+fn foo4<'a, T>(_: Box<dyn C<'a, T> + 'static + Send>) {}\n+fn foo5<'a, T>(_: Box<dyn foo::D<'a, T> + 'static + Send>) {}\n \n pub fn main() {}"}, {"sha": "8c8a7eb7d9da1c679ccd107b9e3f27f739896592", "filename": "src/test/run-pass/traits/trait-bounds-basic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-bounds-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-bounds-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-bounds-basic.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -7,18 +7,18 @@\n trait Foo {\n }\n \n-fn b(_x: Box<Foo+Send>) {\n+fn b(_x: Box<dyn Foo+Send>) {\n }\n \n-fn c(x: Box<Foo+Sync+Send>) {\n+fn c(x: Box<dyn Foo+Sync+Send>) {\n     e(x);\n }\n \n-fn d(x: Box<Foo+Send>) {\n+fn d(x: Box<dyn Foo+Send>) {\n     e(x);\n }\n \n-fn e(x: Box<Foo>) {\n+fn e(x: Box<dyn Foo>) {\n     e(x);\n }\n "}, {"sha": "a45d834297eedc0e9325af7611f48b1eacff01ca", "filename": "src/test/run-pass/traits/trait-bounds-in-arc.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-bounds-in-arc.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -12,7 +12,7 @@ use std::sync::mpsc::channel;\n use std::thread;\n \n trait Pet {\n-    fn name(&self, blk: Box<FnMut(&str)>);\n+    fn name(&self, blk: Box<dyn FnMut(&str)>);\n     fn num_legs(&self) -> usize;\n     fn of_good_pedigree(&self) -> bool;\n }\n@@ -34,19 +34,19 @@ struct Goldfyshe {\n }\n \n impl Pet for Catte {\n-    fn name(&self, mut blk: Box<FnMut(&str)>) { blk(&self.name) }\n+    fn name(&self, mut blk: Box<dyn FnMut(&str)>) { blk(&self.name) }\n     fn num_legs(&self) -> usize { 4 }\n     fn of_good_pedigree(&self) -> bool { self.num_whiskers >= 4 }\n }\n impl Pet for Dogge {\n-    fn name(&self, mut blk: Box<FnMut(&str)>) { blk(&self.name) }\n+    fn name(&self, mut blk: Box<dyn FnMut(&str)>) { blk(&self.name) }\n     fn num_legs(&self) -> usize { 4 }\n     fn of_good_pedigree(&self) -> bool {\n         self.bark_decibels < 70 || self.tricks_known > 20\n     }\n }\n impl Pet for Goldfyshe {\n-    fn name(&self, mut blk: Box<FnMut(&str)>) { blk(&self.name) }\n+    fn name(&self, mut blk: Box<dyn FnMut(&str)>) { blk(&self.name) }\n     fn num_legs(&self) -> usize { 0 }\n     fn of_good_pedigree(&self) -> bool { self.swim_speed >= 500 }\n }\n@@ -67,10 +67,10 @@ pub fn main() {\n         swim_speed: 998,\n         name: \"alec_guinness\".to_string(),\n     };\n-    let arc = Arc::new(vec![box catte  as Box<Pet+Sync+Send>,\n-                            box dogge1 as Box<Pet+Sync+Send>,\n-                            box fishe  as Box<Pet+Sync+Send>,\n-                            box dogge2 as Box<Pet+Sync+Send>]);\n+    let arc = Arc::new(vec![box catte  as Box<dyn Pet+Sync+Send>,\n+                            box dogge1 as Box<dyn Pet+Sync+Send>,\n+                            box fishe  as Box<dyn Pet+Sync+Send>,\n+                            box dogge2 as Box<dyn Pet+Sync+Send>]);\n     let (tx1, rx1) = channel();\n     let arc1 = arc.clone();\n     let t1 = thread::spawn(move|| { check_legs(arc1); tx1.send(()); });\n@@ -88,21 +88,21 @@ pub fn main() {\n     t3.join();\n }\n \n-fn check_legs(arc: Arc<Vec<Box<Pet+Sync+Send>>>) {\n+fn check_legs(arc: Arc<Vec<Box<dyn Pet+Sync+Send>>>) {\n     let mut legs = 0;\n     for pet in arc.iter() {\n         legs += pet.num_legs();\n     }\n     assert!(legs == 12);\n }\n-fn check_names(arc: Arc<Vec<Box<Pet+Sync+Send>>>) {\n+fn check_names(arc: Arc<Vec<Box<dyn Pet+Sync+Send>>>) {\n     for pet in arc.iter() {\n         pet.name(Box::new(|name| {\n             assert!(name.as_bytes()[0] == 'a' as u8 && name.as_bytes()[1] == 'l' as u8);\n         }))\n     }\n }\n-fn check_pedigree(arc: Arc<Vec<Box<Pet+Sync+Send>>>) {\n+fn check_pedigree(arc: Arc<Vec<Box<dyn Pet+Sync+Send>>>) {\n     for pet in arc.iter() {\n         assert!(pet.of_good_pedigree());\n     }"}, {"sha": "4dc4fecc91fcfc36da7c098a8e737296bfc54959", "filename": "src/test/run-pass/traits/trait-bounds-on-structs-and-enums.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-bounds-on-structs-and-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-bounds-on-structs-and-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-bounds-on-structs-and-enums.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -7,11 +7,11 @@ trait U {}\n trait T<X: U> { fn get(self) -> X; }\n \n trait S2<Y: U> {\n-    fn m(x: Box<T<Y>+'static>) {}\n+    fn m(x: Box<dyn T<Y>+'static>) {}\n }\n \n struct St<X: U> {\n-    f: Box<T<X>+'static>,\n+    f: Box<dyn T<X>+'static>,\n }\n \n impl<X: U> St<X> {"}, {"sha": "bf4dda49519107cef0b14585479d001d6b9d3f64", "filename": "src/test/run-pass/traits/trait-coercion-generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-coercion-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-coercion-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-coercion-generic.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -18,8 +18,8 @@ impl Trait<&'static str> for Struct {\n \n pub fn main() {\n     let a = Struct { x: 1, y: 2 };\n-    let b: Box<Trait<&'static str>> = Box::new(a);\n+    let b: Box<dyn Trait<&'static str>> = Box::new(a);\n     b.f(\"Mary\");\n-    let c: &Trait<&'static str> = &a;\n+    let c: &dyn Trait<&'static str> = &a;\n     c.f(\"Joe\");\n }"}, {"sha": "cba33af1f1aca1f9b8221b5bdd8c912c630c8ce6", "filename": "src/test/run-pass/traits/trait-coercion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-coercion.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -22,13 +22,13 @@ impl Trait for Struct {\n     }\n }\n \n-fn foo(mut a: Box<Write>) {}\n+fn foo(mut a: Box<dyn Write>) {}\n \n pub fn main() {\n     let a = Struct { x: 1, y: 2 };\n-    let b: Box<Trait> = Box::new(a);\n+    let b: Box<dyn Trait> = Box::new(a);\n     b.f();\n-    let c: &Trait = &a;\n+    let c: &dyn Trait = &a;\n     c.f();\n \n     let out = io::stdout();"}, {"sha": "804ffec12c2bfd61d909f9ca4968abf83f518620", "filename": "src/test/run-pass/traits/trait-impl-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-impl-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-impl-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-impl-2.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -11,7 +11,7 @@ pub mod Foo {\n }\n \n mod Bar {\n-    impl<'a> ::Foo::Trait+'a {\n+    impl<'a> dyn (::Foo::Trait) + 'a {\n         fn bar(&self) { self.foo() }\n     }\n }"}, {"sha": "14796ce19c88ed08b62d726b53e1f674e13405d3", "filename": "src/test/run-pass/traits/trait-impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-impl.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -12,7 +12,7 @@ trait T {\n     fn t(&self) {}\n }\n \n-impl<'a> T+'a {\n+impl<'a> dyn T+'a {\n     fn foo(&self) {\n         unsafe { COUNT *= 2; }\n     }\n@@ -27,7 +27,7 @@ struct Foo;\n impl<'a> Bar<'a> for Foo {}\n \n fn main() {\n-    let x: &T = &42;\n+    let x: &dyn T = &42;\n \n     x.foo();\n     T::foo(x);\n@@ -36,6 +36,6 @@ fn main() {\n     unsafe { assert_eq!(COUNT, 12); }\n \n     // Cross-crait case\n-    let x: &Bar = &Foo;\n+    let x: &dyn Bar = &Foo;\n     x.bar();\n }"}, {"sha": "25159c1adb6f6febdb0316660140be18e04e9e8a", "filename": "src/test/run-pass/traits/trait-inheritance-cast-without-call-to-supertrait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-inheritance-cast-without-call-to-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-inheritance-cast-without-call-to-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-inheritance-cast-without-call-to-supertrait.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -26,8 +26,8 @@ impl Bar for A {\n \n pub fn main() {\n     let a = &A { x: 3 };\n-    let afoo = a as &Foo;\n-    let abar = a as &Bar;\n+    let afoo = a as &dyn Foo;\n+    let abar = a as &dyn Bar;\n     assert_eq!(afoo.f(), 10);\n     assert_eq!(abar.g(), 20);\n }"}, {"sha": "9070b9d1f5606991efceaece5ef1d96ea9870aee", "filename": "src/test/run-pass/traits/trait-inheritance-cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-inheritance-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-inheritance-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-inheritance-cast.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -25,8 +25,8 @@ impl Bar for A {\n \n pub fn main() {\n     let a = &A { x: 3 };\n-    let afoo = a as &Foo;\n-    let abar = a as &Bar;\n+    let afoo = a as &dyn Foo;\n+    let abar = a as &dyn Bar;\n     assert_eq!(afoo.f(), 10);\n     assert_eq!(abar.g(), 20);\n     assert_eq!(abar.f(), 10);"}, {"sha": "0b8b0e2f5ef4d48e24c52495b6269f629f62b908", "filename": "src/test/run-pass/traits/trait-object-exclusion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-object-exclusion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-object-exclusion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-object-exclusion.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -4,7 +4,7 @@ trait Future: 'static {\n     // Future::forget in vtables, otherwise there's an infinite type\n     // recursion through <Map<...> as Future>::forget.\n     fn forget(self) where Self: Sized {\n-        Box::new(Map(self)) as Box<Future>;\n+        Box::new(Map(self)) as Box<dyn Future>;\n     }\n }\n "}, {"sha": "c18754302b75b279af7165e3398a87cfdb5ac3ea", "filename": "src/test/run-pass/traits/trait-object-generics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-object-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-object-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-object-generics.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -16,7 +16,7 @@ pub struct Impl<A1, A2, A3> {\n      * task <unnamed> failed at 'index out of bounds: the len is 1 but the index is 1',\n      * src/librustc/middle/subst.rs:58\n      */\n-    t: Box<Trait2<A2>+'static>\n+    t: Box<dyn Trait2<A2>+'static>\n }\n \n impl<A1, A2, A3> Impl<A1, A2, A3> {\n@@ -38,6 +38,6 @@ impl<V> Trait<u8,V> for () {\n }\n \n pub fn main() {\n-    let a = box () as Box<Trait<u8, u8>>;\n+    let a = box () as Box<dyn Trait<u8, u8>>;\n     assert_eq!(a.method(Type::Constant((1, 2))), 0);\n }"}, {"sha": "33757cb7c0ab1da7efa9d1e5458efb1ce606a8c9", "filename": "src/test/run-pass/traits/trait-object-lifetime-first.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-object-lifetime-first.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-object-lifetime-first.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-object-lifetime-first.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -4,8 +4,8 @@ use std::fmt::Display;\n static BYTE: u8 = 33;\n \n fn main() {\n-    let x: &('static + Display) = &BYTE;\n-    let y: Box<'static + Display> = Box::new(BYTE);\n+    let x: &(dyn 'static + Display) = &BYTE;\n+    let y: Box<dyn 'static + Display> = Box::new(BYTE);\n     let xstr = format!(\"{}\", x);\n     let ystr = format!(\"{}\", y);\n     assert_eq!(xstr, \"33\");"}, {"sha": "05aab5e3b085c0965907a9791d38557056c9c09f", "filename": "src/test/run-pass/traits/trait-object-with-lifetime-bound.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-object-with-lifetime-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-object-with-lifetime-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-object-with-lifetime-bound.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -20,10 +20,10 @@ impl<'d> M for P<'d> {\n     fn n(&self) -> u8 { *self.g }\n }\n \n-fn extension<'e>(x: &'e E<'e>) -> Box<M+'e> {\n+fn extension<'e>(x: &'e E<'e>) -> Box<dyn M+'e> {\n     loop {\n         let p = P { g: x.m() };\n-        return Box::new(p) as Box<M+'e>;\n+        return Box::new(p) as Box<dyn M+'e>;\n     }\n }\n "}, {"sha": "0456ca931156ec5b833c02a69a06c0d63c92504f", "filename": "src/test/run-pass/traits/trait-region-pointer-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-region-pointer-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-region-pointer-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftrait-region-pointer-simple.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -16,6 +16,6 @@ impl Foo for A {\n \n pub fn main() {\n     let a = A { x: 3 };\n-    let b = (&a) as &Foo;\n+    let b = (&a) as &dyn Foo;\n     assert_eq!(b.f(), 3);\n }"}, {"sha": "e490967b690475107a6fed637edd0e574061eab2", "filename": "src/test/run-pass/traits/traits-impl-object-overlap-issue-23853.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftraits-impl-object-overlap-issue-23853.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftraits-impl-object-overlap-issue-23853.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftraits-impl-object-overlap-issue-23853.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -14,5 +14,5 @@ impl<T:?Sized> Foo for T { }\n fn want_foo<B:?Sized+Foo>() { }\n \n fn main() {\n-    want_foo::<Bar>();\n+    want_foo::<dyn Bar>();\n }"}, {"sha": "bedd87cc4cc7977eb031e75d75dff1d806c2ee35", "filename": "src/test/run-pass/traits/traits-issue-26339.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftraits-issue-26339.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftraits-issue-26339.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftraits-issue-26339.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -25,7 +25,7 @@ impl PartialEq<Bar> for Aimpl {\n impl A for Aimpl { }\n \n fn main() {\n-    let a = &Aimpl as &A;\n+    let a = &Aimpl as &dyn A;\n \n     assert!(*a == Foo);\n }"}, {"sha": "391d19c4385586c7277447c8d32eea66e6cfd036", "filename": "src/test/run-pass/traits/traits-repeated-supertrait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftraits-repeated-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Ftraits-repeated-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Ftraits-repeated-supertrait.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -22,7 +22,7 @@ impl CompareTo<u64> for i64 {\n \n impl CompareToInts for i64 { }\n \n-fn with_obj(c: &CompareToInts) -> bool {\n+fn with_obj(c: &dyn CompareToInts) -> bool {\n     c.same_as(22_i64) && c.same_as(22_u64)\n }\n "}, {"sha": "700488c22d6780606207df0103fcb415ce676d30", "filename": "src/test/run-pass/traits/ufcs-trait-object.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Fufcs-trait-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftraits%2Fufcs-trait-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits%2Fufcs-trait-object.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -12,6 +12,6 @@ impl Foo for i32 {\n }\n \n fn main() {\n-    let a: &Foo = &22;\n+    let a: &dyn Foo = &22;\n     assert_eq!(Foo::test(a), 22);\n }"}, {"sha": "f06b0708290bc909063e751e10985a3c35ce10e1", "filename": "src/test/run-pass/trivial_casts.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftrivial_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftrivial_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrivial_casts.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -36,21 +36,21 @@ pub fn main() {\n \n     // unsize trait\n     let x: &Bar = &Bar;\n-    let _ = x as &Foo;\n-    let _ = x as *const Foo;\n+    let _ = x as &dyn Foo;\n+    let _ = x as *const dyn Foo;\n \n     let x: &mut Bar = &mut Bar;\n-    let _ = x as &mut Foo;\n-    let _ = x as *mut Foo;\n+    let _ = x as &mut dyn Foo;\n+    let _ = x as *mut dyn Foo;\n \n     let x: Box<Bar> = Box::new(Bar);\n-    let _ = x as Box<Foo>;\n+    let _ = x as Box<dyn Foo>;\n \n     // functions\n     fn baz(_x: i32) {}\n-    let _ = &baz as &Fn(i32);\n+    let _ = &baz as &dyn Fn(i32);\n     let x = |_x: i32| {};\n-    let _ = &x as &Fn(i32);\n+    let _ = &x as &dyn Fn(i32);\n }\n \n // subtyping"}, {"sha": "469bc8ed7e15309d551ce058f53665337a2ad819", "filename": "src/test/run-pass/type-id-higher-rank-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftype-id-higher-rank-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftype-id-higher-rank-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-id-higher-rank-2.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -7,7 +7,7 @@ struct Foo<'a>(&'a str);\n fn good(s: &String) -> Foo { Foo(s) }\n \n fn bad1(s: String) -> Option<&'static str> {\n-    let a: Box<Any> = Box::new(good as fn(&String) -> Foo);\n+    let a: Box<dyn Any> = Box::new(good as fn(&String) -> Foo);\n     a.downcast_ref::<fn(&String) -> Foo<'static>>().map(|f| f(&s).0)\n }\n \n@@ -20,8 +20,8 @@ impl<'a> AsStr<'a, 'a> for String {\n }\n \n fn bad2(s: String) -> Option<&'static str> {\n-    let a: Box<Any> = Box::new(Box::new(s) as Box<for<'a> AsStr<'a, 'a>>);\n-    a.downcast_ref::<Box<for<'a> AsStr<'a, 'static>>>().map(|x| x.get())\n+    let a: Box<dyn Any> = Box::new(Box::new(s) as Box<dyn for<'a> AsStr<'a, 'a>>);\n+    a.downcast_ref::<Box<dyn for<'a> AsStr<'a, 'static>>>().map(|x| x.get())\n }\n \n fn main() {"}, {"sha": "b98dff0d72b8d5752de9ee1f7722148dfd85affc", "filename": "src/test/run-pass/type-id-higher-rank.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftype-id-higher-rank.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftype-id-higher-rank.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-id-higher-rank.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -26,9 +26,9 @@ fn main() {\n         assert!(e != f);\n \n         // Make sure lifetime parameters of items are not ignored.\n-        let g = TypeId::of::<for<'a> fn(&'a Trait<'a>) -> Struct<'a>>();\n-        let h = TypeId::of::<for<'a> fn(&'a Trait<'a>) -> Struct<'static>>();\n-        let i = TypeId::of::<for<'a, 'b> fn(&'a Trait<'b>) -> Struct<'b>>();\n+        let g = TypeId::of::<for<'a> fn(&'a dyn Trait<'a>) -> Struct<'a>>();\n+        let h = TypeId::of::<for<'a> fn(&'a dyn Trait<'a>) -> Struct<'static>>();\n+        let i = TypeId::of::<for<'a, 'b> fn(&'a dyn Trait<'b>) -> Struct<'b>>();\n         assert!(g != h);\n         assert!(g != i);\n         assert!(h != i);\n@@ -40,10 +40,10 @@ fn main() {\n     }\n     // Boxed unboxed closures\n     {\n-        let a = TypeId::of::<Box<Fn(&'static isize, &'static isize)>>();\n-        let b = TypeId::of::<Box<for<'a> Fn(&'static isize, &'a isize)>>();\n-        let c = TypeId::of::<Box<for<'a, 'b> Fn(&'a isize, &'b isize)>>();\n-        let d = TypeId::of::<Box<for<'a, 'b> Fn(&'b isize, &'a isize)>>();\n+        let a = TypeId::of::<Box<dyn Fn(&'static isize, &'static isize)>>();\n+        let b = TypeId::of::<Box<dyn for<'a> Fn(&'static isize, &'a isize)>>();\n+        let c = TypeId::of::<Box<dyn for<'a, 'b> Fn(&'a isize, &'b isize)>>();\n+        let d = TypeId::of::<Box<dyn for<'a, 'b> Fn(&'b isize, &'a isize)>>();\n         assert!(a != b);\n         assert!(a != c);\n         assert!(a != d);\n@@ -52,8 +52,8 @@ fn main() {\n         assert_eq!(c, d);\n \n         // Make sure De Bruijn indices are handled correctly\n-        let e = TypeId::of::<Box<for<'a> Fn(Box<Fn(&'a isize) -> &'a isize>)>>();\n-        let f = TypeId::of::<Box<Fn(Box<for<'a> Fn(&'a isize) -> &'a isize>)>>();\n+        let e = TypeId::of::<Box<dyn for<'a> Fn(Box<dyn Fn(&'a isize) -> &'a isize>)>>();\n+        let f = TypeId::of::<Box<dyn Fn(Box<dyn for<'a> Fn(&'a isize) -> &'a isize>)>>();\n         assert!(e != f);\n     }\n     // Raw unboxed closures"}, {"sha": "6298156452e49b080054bddc8c458d6bd96c1605", "filename": "src/test/run-pass/type-infer-generalize-ty-var.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftype-infer-generalize-ty-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Ftype-infer-generalize-ty-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-infer-generalize-ty-var.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -23,8 +23,8 @@ trait Get<T: ?Sized> {\n     fn get(&self) -> &T;\n }\n \n-impl Get<MyShow + 'static> for Wrap<T> {\n-    fn get(&self) -> &(MyShow + 'static) {\n+impl Get<dyn MyShow + 'static> for Wrap<T> {\n+    fn get(&self) -> &(dyn MyShow + 'static) {\n         static x: usize = 42;\n         &x\n     }\n@@ -38,9 +38,9 @@ impl Get<usize> for Wrap<U> {\n }\n \n trait MyShow { fn dummy(&self) { } }\n-impl<'a> MyShow for &'a (MyShow + 'a) { }\n+impl<'a> MyShow for &'a (dyn MyShow + 'a) { }\n impl MyShow for usize { }\n-fn constrain<'a>(rc: RefCell<&'a (MyShow + 'a)>) { }\n+fn constrain<'a>(rc: RefCell<&'a (dyn MyShow + 'a)>) { }\n \n fn main() {\n     let mut collection: Wrap<_> = WrapNone;"}, {"sha": "a1001673506f0660c7991ce3b3f6ab4dc32c22f5", "filename": "src/test/run-pass/unboxed-closures/unboxed-closures-blanket-fn-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-blanket-fn-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-blanket-fn-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-blanket-fn-mut.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -8,7 +8,7 @@ fn a<F:FnMut() -> i32>(mut f: F) -> i32 {\n     f()\n }\n \n-fn b(f: &mut FnMut() -> i32) -> i32 {\n+fn b(f: &mut dyn FnMut() -> i32) -> i32 {\n     a(f)\n }\n "}, {"sha": "ca1d31ca54470a0193667e12451c24f92237d677", "filename": "src/test/run-pass/unboxed-closures/unboxed-closures-blanket-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-blanket-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-blanket-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-blanket-fn.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -8,7 +8,7 @@ fn a<F:Fn() -> i32>(f: F) -> i32 {\n     f()\n }\n \n-fn b(f: &Fn() -> i32) -> i32 {\n+fn b(f: &dyn Fn() -> i32) -> i32 {\n     a(f)\n }\n "}, {"sha": "b2596e49aa78eecc8ea2e91f8a93e3e6d8a12aab", "filename": "src/test/run-pass/unboxed-closures/unboxed-closures-boxed.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-boxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-boxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-boxed.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -3,9 +3,9 @@\n \n use std::ops::FnMut;\n \n- fn make_adder(x: i32) -> Box<FnMut(i32)->i32+'static> {\n+ fn make_adder(x: i32) -> Box<dyn FnMut(i32)->i32+'static> {\n     (box move |y: i32| -> i32 { x + y }) as\n-        Box<FnMut(i32)->i32+'static>\n+        Box<dyn FnMut(i32)->i32+'static>\n }\n \n pub fn main() {"}, {"sha": "d47ceea0f4f4d9ca2122d17baa7aee32e75c8a42", "filename": "src/test/run-pass/unboxed-closures/unboxed-closures-call-sugar-object-autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-call-sugar-object-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-call-sugar-object-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-call-sugar-object-autoderef.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -3,7 +3,7 @@\n \n use std::ops::FnMut;\n \n-fn make_adder(x: isize) -> Box<FnMut(isize)->isize + 'static> {\n+fn make_adder(x: isize) -> Box<dyn FnMut(isize)->isize + 'static> {\n     Box::new(move |y| { x + y })\n }\n "}, {"sha": "f77733d106d4f4d6f0e1603140dcb45659f75431", "filename": "src/test/run-pass/unboxed-closures/unboxed-closures-call-sugar-object.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-call-sugar-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-call-sugar-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-call-sugar-object.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -1,7 +1,7 @@\n // run-pass\n use std::ops::FnMut;\n \n-fn make_adder(x: isize) -> Box<FnMut(isize)->isize + 'static> {\n+fn make_adder(x: isize) -> Box<dyn FnMut(isize)->isize + 'static> {\n     Box::new(move |y| { x + y })\n }\n "}, {"sha": "3ee1aeb109b18b5ebd953a91a7e51c1e4b684d08", "filename": "src/test/run-pass/unboxed-closures/unboxed-closures-extern-fn-hr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-extern-fn-hr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-extern-fn-hr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-extern-fn-hr.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -7,7 +7,7 @@ fn call_it<F:Fn(&isize)->isize>(f: &F, x: isize) -> isize {\n     (*f)(&x)\n }\n \n-fn call_it_boxed(f: &Fn(&isize) -> isize, x: isize) -> isize {\n+fn call_it_boxed(f: &dyn Fn(&isize) -> isize, x: isize) -> isize {\n     f(&x)\n }\n "}, {"sha": "d2eaee304104ae7d230f131e918c709062f722aa", "filename": "src/test/run-pass/unboxed-closures/unboxed-closures-infer-arg-types-from-expected-object-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-infer-arg-types-from-expected-object-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-infer-arg-types-from-expected-object-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-infer-arg-types-from-expected-object-type.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -12,7 +12,7 @@ impl ToPrimitive for isize {}\n impl ToPrimitive for i32 {}\n impl ToPrimitive for usize {}\n \n-fn doit<T>(val: T, f: &Fn(T)) { f(val) }\n+fn doit<T>(val: T, f: &dyn Fn(T)) { f(val) }\n \n pub fn main() {\n     doit(0, &|x /*: isize*/ | { x.to_int(); });"}, {"sha": "86834f49407fc74ad8f1d5ce1b76a8ee5a485a22", "filename": "src/test/run-pass/unboxed-closures/unboxed-closures-infer-recursive-fn.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-infer-recursive-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-infer-recursive-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-infer-recursive-fn.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -20,23 +20,23 @@ impl<F,A,R> YCombinator<F,A,R> {\n     }\n }\n \n-impl<A,R,F : Fn(&Fn(A) -> R, A) -> R> Fn<(A,)> for YCombinator<F,A,R> {\n+impl<A,R,F : Fn(&dyn Fn(A) -> R, A) -> R> Fn<(A,)> for YCombinator<F,A,R> {\n     extern \"rust-call\" fn call(&self, (arg,): (A,)) -> R {\n         (self.func)(self, arg)\n     }\n }\n \n-impl<A,R,F : Fn(&Fn(A) -> R, A) -> R> FnMut<(A,)> for YCombinator<F,A,R> {\n+impl<A,R,F : Fn(&dyn Fn(A) -> R, A) -> R> FnMut<(A,)> for YCombinator<F,A,R> {\n     extern \"rust-call\" fn call_mut(&mut self, args: (A,)) -> R { self.call(args) }\n }\n \n-impl<A,R,F : Fn(&Fn(A) -> R, A) -> R> FnOnce<(A,)> for YCombinator<F,A,R> {\n+impl<A,R,F : Fn(&dyn Fn(A) -> R, A) -> R> FnOnce<(A,)> for YCombinator<F,A,R> {\n     type Output = R;\n     extern \"rust-call\" fn call_once(self, args: (A,)) -> R { self.call(args) }\n }\n \n fn main() {\n-    let factorial = |recur: &Fn(u32) -> u32, arg: u32| -> u32 {\n+    let factorial = |recur: &dyn Fn(u32) -> u32, arg: u32| -> u32 {\n         if arg == 0 {1} else {arg * recur(arg-1)}\n     };\n     let factorial: YCombinator<_,u32,u32> = YCombinator::new(factorial);"}, {"sha": "df60b42ab126a550d9215df3b27ef924f62e605b", "filename": "src/test/run-pass/unboxed-closures/unboxed-closures-manual-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-manual-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-manual-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-manual-impl.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -19,7 +19,7 @@ fn call_it<F:FnMut(i32)->i32>(mut f: F, x: i32) -> i32 {\n     f(x) + 3\n }\n \n-fn call_box(f: &mut FnMut(i32) -> i32, x: i32) -> i32 {\n+fn call_box(f: &mut dyn FnMut(i32) -> i32, x: i32) -> i32 {\n     f(x) + 3\n }\n "}, {"sha": "2df360d4a30a4bcbcad40609e9cd4f161e81dd6f", "filename": "src/test/run-pass/unboxed-closures/unboxed-closures-monomorphization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-monomorphization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-monomorphization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-monomorphization.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -3,7 +3,7 @@\n // monomorphize correctly (issue #16791)\n \n fn main(){\n-    fn bar<'a, T:Clone+'a> (t: T) -> Box<FnMut()->T + 'a> {\n+    fn bar<'a, T:Clone+'a> (t: T) -> Box<dyn FnMut()->T + 'a> {\n         Box::new(move || t.clone())\n     }\n "}, {"sha": "89a273b7a43ff26e57c09af4559a1320081b13cf", "filename": "src/test/run-pass/unboxed-closures/unboxed-closures-prelude.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-prelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-prelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-prelude.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -4,10 +4,10 @@\n // pretty-expanded FIXME #23616\n \n fn main() {\n-    let task: Box<Fn(isize) -> isize> = Box::new(|x| x);\n+    let task: Box<dyn Fn(isize) -> isize> = Box::new(|x| x);\n     task(0);\n \n-    let mut task: Box<FnMut(isize) -> isize> = Box::new(|x| x);\n+    let mut task: Box<dyn FnMut(isize) -> isize> = Box::new(|x| x);\n     task(0);\n \n     call(|x| x, 22);"}, {"sha": "1ca25517c3c5fc9e2fff8b8a5a6d4008e8ad646d", "filename": "src/test/run-pass/unboxed-closures/unboxed-closures-sugar-object.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-sugar-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-sugar-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures%2Funboxed-closures-sugar-object.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -19,7 +19,7 @@ impl<X> Getter<X,X> for Identity {\n }\n \n fn main() {\n-    let x: &Getter<(i32,), (i32,)> = &Identity;\n+    let x: &dyn Getter<(i32,), (i32,)> = &Identity;\n     let (y,) = x.get((22,));\n     assert_eq!(y, 22);\n }"}, {"sha": "84e8cdb32b84e588a03ed474451900fa53f1acb3", "filename": "src/test/run-pass/unique/unique-object-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funique%2Funique-object-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funique%2Funique-object-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique%2Funique-object-move.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -15,6 +15,6 @@ pub struct UvEventLoop {\n impl EventLoop for UvEventLoop { }\n \n pub fn main() {\n-    let loop_: Box<EventLoop> = box UvEventLoop { uvio: 0 } as Box<EventLoop>;\n+    let loop_: Box<dyn EventLoop> = box UvEventLoop { uvio: 0 } as Box<dyn EventLoop>;\n     let _loop2_ = loop_;\n }"}, {"sha": "c9a8b2e7c664b6e80784f4a753d731beb6010cbe", "filename": "src/test/run-pass/unsized2.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funsized2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Funsized2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funsized2.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -60,26 +60,26 @@ fn f7<X: ?Sized+T3>(x: &X) {\n \n trait T4<X> {\n     fn dummy(&self) { }\n-    fn m1(&self, x: &T4<X>, y: X);\n-    fn m2(&self, x: &T5<X>, y: X);\n+    fn m1(&self, x: &dyn T4<X>, y: X);\n+    fn m2(&self, x: &dyn T5<X>, y: X);\n }\n trait T5<X: ?Sized> {\n     fn dummy(&self) { }\n     // not an error (for now)\n-    fn m1(&self, x: &T4<X>);\n-    fn m2(&self, x: &T5<X>);\n+    fn m1(&self, x: &dyn T4<X>);\n+    fn m2(&self, x: &dyn T5<X>);\n }\n \n trait T6<X: T> {\n     fn dummy(&self) { }\n-    fn m1(&self, x: &T4<X>);\n-    fn m2(&self, x: &T5<X>);\n+    fn m1(&self, x: &dyn T4<X>);\n+    fn m2(&self, x: &dyn T5<X>);\n }\n trait T7<X: ?Sized+T> {\n     fn dummy(&self) { }\n     // not an error (for now)\n-    fn m1(&self, x: &T4<X>);\n-    fn m2(&self, x: &T5<X>);\n+    fn m1(&self, x: &dyn T4<X>);\n+    fn m2(&self, x: &dyn T5<X>);\n }\n \n // The last field in a struct may be unsized"}, {"sha": "6814e2baab59730eb6f79ec65c4fdb9be363af1d", "filename": "src/test/run-pass/wf-bound-region-in-object-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fwf-bound-region-in-object-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frun-pass%2Fwf-bound-region-in-object-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwf-bound-region-in-object-type.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -12,7 +12,7 @@ pub struct Context<'tcx> {\n pub type Cmd<'a> = &'a isize;\n \n pub type DecodeInlinedItem<'a> =\n-    Box<for<'tcx> FnMut(Cmd, &Context<'tcx>) -> Result<&'tcx isize, ()> + 'a>;\n+    Box<dyn for<'tcx> FnMut(Cmd, &Context<'tcx>) -> Result<&'tcx isize, ()> + 'a>;\n \n fn foo(d: DecodeInlinedItem) {\n }"}, {"sha": "297d6efd45fee44aff913a50a5e85bd178688cfd", "filename": "src/test/rustdoc-ui/failed-doctest-compile-fail.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-compile-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-compile-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-compile-fail.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -0,0 +1,11 @@\n+// FIXME: if/when the output of the test harness can be tested on its own, this test should be\n+// adapted to use that, and that normalize line can go away\n+\n+// compile-flags:--test\n+// normalize-stdout-test: \"src/test/rustdoc-ui\" -> \"$$DIR\"\n+// failure-status: 101\n+\n+/// ```compile_fail\n+/// println!(\"Hello\");\n+/// ```\n+pub struct Foo;"}, {"sha": "74e33d7beebeb66ae72032915f25bd6387b52eaf", "filename": "src/test/rustdoc-ui/failed-doctest-compile-fail.stdout", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-compile-fail.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-compile-fail.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-compile-fail.stdout?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -0,0 +1,14 @@\n+\n+running 1 test\n+test $DIR/failed-doctest-compile-fail.rs - Foo (line 8) ... FAILED\n+\n+failures:\n+\n+---- $DIR/failed-doctest-compile-fail.rs - Foo (line 8) stdout ----\n+Test compiled successfully, but it's marked `compile_fail`.\n+\n+failures:\n+    $DIR/failed-doctest-compile-fail.rs - Foo (line 8)\n+\n+test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out\n+"}, {"sha": "62102062d4991381c1a8d23d43536a03089742e7", "filename": "src/test/rustdoc-ui/failed-doctest-missing-codes.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-missing-codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-missing-codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-missing-codes.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -0,0 +1,11 @@\n+// FIXME: if/when the output of the test harness can be tested on its own, this test should be\n+// adapted to use that, and that normalize line can go away\n+\n+// compile-flags:--test\n+// normalize-stdout-test: \"src/test/rustdoc-ui\" -> \"$$DIR\"\n+// failure-status: 101\n+\n+/// ```compile_fail,E0004\n+/// let x: () = 5i32;\n+/// ```\n+pub struct Foo;"}, {"sha": "d206b721765b2470d7b5b877046fda122fe1a8fc", "filename": "src/test/rustdoc-ui/failed-doctest-missing-codes.stdout", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-missing-codes.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-missing-codes.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-missing-codes.stdout?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -0,0 +1,26 @@\n+\n+running 1 test\n+test $DIR/failed-doctest-missing-codes.rs - Foo (line 8) ... FAILED\n+\n+failures:\n+\n+---- $DIR/failed-doctest-missing-codes.rs - Foo (line 8) stdout ----\n+error[E0308]: mismatched types\n+ --> $DIR/failed-doctest-missing-codes.rs:9:13\n+  |\n+3 | let x: () = 5i32;\n+  |             ^^^^ expected (), found i32\n+  |\n+  = note: expected type `()`\n+             found type `i32`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`.\n+Some expected error codes were not found: [\"E0004\"]\n+\n+failures:\n+    $DIR/failed-doctest-missing-codes.rs - Foo (line 8)\n+\n+test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out\n+"}, {"sha": "d2cdeb8f8f50e8d110b884464e8b15611830bf0e", "filename": "src/test/rustdoc-ui/failed-doctest-output.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -5,10 +5,13 @@\n // compile-flags:--test\n // normalize-stdout-test: \"src/test/rustdoc-ui\" -> \"$$DIR\"\n // failure-status: 101\n-// rustc-env:RUST_BACKTRACE=0\n \n // doctest fails at runtime\n /// ```\n+/// println!(\"stdout 1\");\n+/// eprintln!(\"stderr 1\");\n+/// println!(\"stdout 2\");\n+/// eprintln!(\"stderr 2\");\n /// panic!(\"oh no\");\n /// ```\n pub struct SomeStruct;"}, {"sha": "0c42c652d786c724b1e23dd3afb398e41902d608", "filename": "src/test/rustdoc-ui/failed-doctest-output.stdout", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -1,35 +1,39 @@\n \n running 2 tests\n-test $DIR/failed-doctest-output.rs - OtherStruct (line 17) ... FAILED\n-test $DIR/failed-doctest-output.rs - SomeStruct (line 11) ... FAILED\n+test $DIR/failed-doctest-output.rs - OtherStruct (line 20) ... FAILED\n+test $DIR/failed-doctest-output.rs - SomeStruct (line 10) ... FAILED\n \n failures:\n \n----- $DIR/failed-doctest-output.rs - OtherStruct (line 17) stdout ----\n+---- $DIR/failed-doctest-output.rs - OtherStruct (line 20) stdout ----\n error[E0425]: cannot find value `no` in this scope\n- --> $DIR/failed-doctest-output.rs:18:1\n+ --> $DIR/failed-doctest-output.rs:21:1\n   |\n 3 | no\n   | ^^ not found in this scope\n \n error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0425`.\n-thread '$DIR/failed-doctest-output.rs - OtherStruct (line 17)' panicked at 'couldn't compile the test', src/librustdoc/test.rs:320:13\n+Couldn't compile the test.\n+---- $DIR/failed-doctest-output.rs - SomeStruct (line 10) stdout ----\n+Test executable failed (exit code 101).\n+\n+stdout:\n+stdout 1\n+stdout 2\n+\n+stderr:\n+stderr 1\n+stderr 2\n+thread 'main' panicked at 'oh no', $DIR/failed-doctest-output.rs:7:1\n note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n \n----- $DIR/failed-doctest-output.rs - SomeStruct (line 11) stdout ----\n-thread '$DIR/failed-doctest-output.rs - SomeStruct (line 11)' panicked at 'test executable failed:\n-\n-thread 'main' panicked at 'oh no', $DIR/failed-doctest-output.rs:3:1\n-note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n-\n-', src/librustdoc/test.rs:342:17\n \n \n failures:\n-    $DIR/failed-doctest-output.rs - OtherStruct (line 17)\n-    $DIR/failed-doctest-output.rs - SomeStruct (line 11)\n+    $DIR/failed-doctest-output.rs - OtherStruct (line 20)\n+    $DIR/failed-doctest-output.rs - SomeStruct (line 10)\n \n test result: FAILED. 0 passed; 2 failed; 0 ignored; 0 measured; 0 filtered out\n "}, {"sha": "400fb97804aabcef1e0b1de46bc9983d89ab2828", "filename": "src/test/rustdoc-ui/failed-doctest-should-panic.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-should-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-should-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-should-panic.rs?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -0,0 +1,11 @@\n+// FIXME: if/when the output of the test harness can be tested on its own, this test should be\n+// adapted to use that, and that normalize line can go away\n+\n+// compile-flags:--test\n+// normalize-stdout-test: \"src/test/rustdoc-ui\" -> \"$$DIR\"\n+// failure-status: 101\n+\n+/// ```should_panic\n+/// println!(\"Hello, world!\");\n+/// ```\n+pub struct Foo;"}, {"sha": "081b64b50af9b9aba65269cd2371c117bf865878", "filename": "src/test/rustdoc-ui/failed-doctest-should-panic.stdout", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-should-panic.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/6c534c316fd75f04b128116abdde46f4f036b306/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-should-panic.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-should-panic.stdout?ref=6c534c316fd75f04b128116abdde46f4f036b306", "patch": "@@ -0,0 +1,14 @@\n+\n+running 1 test\n+test $DIR/failed-doctest-should-panic.rs - Foo (line 8) ... FAILED\n+\n+failures:\n+\n+---- $DIR/failed-doctest-should-panic.rs - Foo (line 8) stdout ----\n+Test executable succeeded, but it's marked `should_panic`.\n+\n+failures:\n+    $DIR/failed-doctest-should-panic.rs - Foo (line 8)\n+\n+test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out\n+"}]}