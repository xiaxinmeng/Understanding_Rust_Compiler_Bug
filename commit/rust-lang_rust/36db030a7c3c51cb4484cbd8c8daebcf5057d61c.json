{"sha": "36db030a7c3c51cb4484cbd8c8daebcf5057d61c", "node_id": "C_kwDOAAsO6NoAKDM2ZGIwMzBhN2MzYzUxY2I0NDg0Y2JkOGM4ZGFlYmNmNTA1N2Q2MWM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-17T10:48:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-17T10:48:22Z"}, "message": "Auto merge of #104205 - clubby789:grow-rc, r=thomcc\n\nAttempt to reuse `Vec<T>` backing storage for `Rc/Arc<[T]>`\n\nIf a `Vec<T>` has sufficient capacity to store the inner `RcBox<[T]>`, we can just reuse the existing allocation and shift the elements up, instead of making a new allocation.", "tree": {"sha": "0d083a09dd9b64e2cad9ef236f6345199dbdb74a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d083a09dd9b64e2cad9ef236f6345199dbdb74a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36db030a7c3c51cb4484cbd8c8daebcf5057d61c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36db030a7c3c51cb4484cbd8c8daebcf5057d61c", "html_url": "https://github.com/rust-lang/rust/commit/36db030a7c3c51cb4484cbd8c8daebcf5057d61c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36db030a7c3c51cb4484cbd8c8daebcf5057d61c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c75fe4c8547c276574cacb144919d67fd8ab302", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c75fe4c8547c276574cacb144919d67fd8ab302", "html_url": "https://github.com/rust-lang/rust/commit/7c75fe4c8547c276574cacb144919d67fd8ab302"}, {"sha": "8424c24837fffdb83796c5da52094b296445f08f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8424c24837fffdb83796c5da52094b296445f08f", "html_url": "https://github.com/rust-lang/rust/commit/8424c24837fffdb83796c5da52094b296445f08f"}], "stats": {"total": 199, "additions": 161, "deletions": 38}, "files": [{"sha": "f3cbfe27b3eed620adf88462ecba8e7c0dfdf80e", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 65, "deletions": 19, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/36db030a7c3c51cb4484cbd8c8daebcf5057d61c/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36db030a7c3c51cb4484cbd8c8daebcf5057d61c/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=36db030a7c3c51cb4484cbd8c8daebcf5057d61c", "patch": "@@ -293,6 +293,15 @@ struct RcBox<T: ?Sized> {\n     value: T,\n }\n \n+/// Calculate layout for `RcBox<T>` using the inner value's layout\n+fn rcbox_layout_for_value_layout(layout: Layout) -> Layout {\n+    // Calculate layout using the given value layout.\n+    // Previously, layout was calculated on the expression\n+    // `&*(ptr as *const RcBox<T>)`, but this created a misaligned\n+    // reference (see #54908).\n+    Layout::new::<RcBox<()>>().extend(layout).unwrap().0.pad_to_align()\n+}\n+\n /// A single-threaded reference-counting pointer. 'Rc' stands for 'Reference\n /// Counted'.\n ///\n@@ -1334,11 +1343,7 @@ impl<T: ?Sized> Rc<T> {\n         allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocError>,\n         mem_to_rcbox: impl FnOnce(*mut u8) -> *mut RcBox<T>,\n     ) -> *mut RcBox<T> {\n-        // Calculate layout using the given value layout.\n-        // Previously, layout was calculated on the expression\n-        // `&*(ptr as *const RcBox<T>)`, but this created a misaligned\n-        // reference (see #54908).\n-        let layout = Layout::new::<RcBox<()>>().extend(value_layout).unwrap().0.pad_to_align();\n+        let layout = rcbox_layout_for_value_layout(value_layout);\n         unsafe {\n             Rc::try_allocate_for_layout(value_layout, allocate, mem_to_rcbox)\n                 .unwrap_or_else(|_| handle_alloc_error(layout))\n@@ -1357,11 +1362,7 @@ impl<T: ?Sized> Rc<T> {\n         allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocError>,\n         mem_to_rcbox: impl FnOnce(*mut u8) -> *mut RcBox<T>,\n     ) -> Result<*mut RcBox<T>, AllocError> {\n-        // Calculate layout using the given value layout.\n-        // Previously, layout was calculated on the expression\n-        // `&*(ptr as *const RcBox<T>)`, but this created a misaligned\n-        // reference (see #54908).\n-        let layout = Layout::new::<RcBox<()>>().extend(value_layout).unwrap().0.pad_to_align();\n+        let layout = rcbox_layout_for_value_layout(value_layout);\n \n         // Allocate for the layout.\n         let ptr = allocate(layout)?;\n@@ -1428,7 +1429,7 @@ impl<T> Rc<[T]> {\n         }\n     }\n \n-    /// Copy elements from slice into newly allocated Rc<\\[T\\]>\n+    /// Copy elements from slice into newly allocated `Rc<[T]>`\n     ///\n     /// Unsafe because the caller must either take ownership or bind `T: Copy`\n     #[cfg(not(no_global_oom_handling))]\n@@ -1440,6 +1441,48 @@ impl<T> Rc<[T]> {\n         }\n     }\n \n+    /// Create an `Rc<[T]>` by reusing the underlying memory\n+    /// of a `Vec<T>`. This will return the vector if the existing allocation\n+    /// is not large enough.\n+    #[cfg(not(no_global_oom_handling))]\n+    fn try_from_vec_in_place(mut v: Vec<T>) -> Result<Rc<[T]>, Vec<T>> {\n+        let layout_elements = Layout::array::<T>(v.len()).unwrap();\n+        let layout_allocation = Layout::array::<T>(v.capacity()).unwrap();\n+        let layout_rcbox = rcbox_layout_for_value_layout(layout_elements);\n+        let mut ptr = NonNull::new(v.as_mut_ptr()).expect(\"`Vec<T>` stores `NonNull<T>`\");\n+        if layout_rcbox.size() > layout_allocation.size()\n+            || layout_rcbox.align() > layout_allocation.align()\n+        {\n+            // Can't fit - calling `grow` would involve `realloc`\n+            // (which copies the elements), followed by copying again.\n+            return Err(v);\n+        }\n+        if layout_rcbox.size() < layout_allocation.size()\n+            || layout_rcbox.align() < layout_allocation.align()\n+        {\n+            // We need to shrink the allocation so that it fits\n+            // https://doc.rust-lang.org/nightly/std/alloc/trait.Allocator.html#memory-fitting\n+            // SAFETY:\n+            // - Vec allocates by requesting `Layout::array::<T>(capacity)`, so this capacity matches\n+            // - `layout_rcbox` is smaller\n+            // If this fails, the ownership has not been transferred\n+            if let Ok(p) = unsafe { Global.shrink(ptr.cast(), layout_allocation, layout_rcbox) } {\n+                ptr = p.cast();\n+            } else {\n+                return Err(v);\n+            }\n+        }\n+        // Make sure the vec's memory isn't deallocated now\n+        let v = mem::ManuallyDrop::new(v);\n+        let ptr: *mut RcBox<[T]> = ptr::slice_from_raw_parts_mut(ptr.as_ptr(), v.len()) as _;\n+        unsafe {\n+            ptr::copy(ptr.cast::<T>(), &mut (*ptr).value as *mut [T] as *mut T, v.len());\n+            ptr::write(&mut (*ptr).strong, Cell::new(1));\n+            ptr::write(&mut (*ptr).weak, Cell::new(1));\n+            Ok(Self::from_ptr(ptr))\n+        }\n+    }\n+\n     /// Constructs an `Rc<[T]>` from an iterator known to be of a certain size.\n     ///\n     /// Behavior is undefined should the size be wrong.\n@@ -1965,14 +2008,17 @@ impl<T> From<Vec<T>> for Rc<[T]> {\n     /// assert_eq!(vec![1, 2, 3], *shared);\n     /// ```\n     #[inline]\n-    fn from(mut v: Vec<T>) -> Rc<[T]> {\n-        unsafe {\n-            let rc = Rc::copy_from_slice(&v);\n-\n-            // Allow the Vec to free its memory, but not destroy its contents\n-            v.set_len(0);\n-\n-            rc\n+    fn from(v: Vec<T>) -> Rc<[T]> {\n+        match Rc::try_from_vec_in_place(v) {\n+            Ok(rc) => rc,\n+            Err(mut v) => {\n+                unsafe {\n+                    let rc = Rc::copy_from_slice(&v);\n+                    // Allow the Vec to free its memory, but not destroy its contents\n+                    v.set_len(0);\n+                    rc\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "37e07eb5998b332ffdeb54f4fe675557800e289d", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 66, "deletions": 19, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/36db030a7c3c51cb4484cbd8c8daebcf5057d61c/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36db030a7c3c51cb4484cbd8c8daebcf5057d61c/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=36db030a7c3c51cb4484cbd8c8daebcf5057d61c", "patch": "@@ -333,6 +333,15 @@ struct ArcInner<T: ?Sized> {\n     data: T,\n }\n \n+/// Calculate layout for `ArcInner<T>` using the inner value's layout\n+fn arcinner_layout_for_value_layout(layout: Layout) -> Layout {\n+    // Calculate layout using the given value layout.\n+    // Previously, layout was calculated on the expression\n+    // `&*(ptr as *const ArcInner<T>)`, but this created a misaligned\n+    // reference (see #54908).\n+    Layout::new::<ArcInner<()>>().extend(layout).unwrap().0.pad_to_align()\n+}\n+\n unsafe impl<T: ?Sized + Sync + Send> Send for ArcInner<T> {}\n unsafe impl<T: ?Sized + Sync + Send> Sync for ArcInner<T> {}\n \n@@ -1154,11 +1163,7 @@ impl<T: ?Sized> Arc<T> {\n         allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocError>,\n         mem_to_arcinner: impl FnOnce(*mut u8) -> *mut ArcInner<T>,\n     ) -> *mut ArcInner<T> {\n-        // Calculate layout using the given value layout.\n-        // Previously, layout was calculated on the expression\n-        // `&*(ptr as *const ArcInner<T>)`, but this created a misaligned\n-        // reference (see #54908).\n-        let layout = Layout::new::<ArcInner<()>>().extend(value_layout).unwrap().0.pad_to_align();\n+        let layout = arcinner_layout_for_value_layout(value_layout);\n         unsafe {\n             Arc::try_allocate_for_layout(value_layout, allocate, mem_to_arcinner)\n                 .unwrap_or_else(|_| handle_alloc_error(layout))\n@@ -1176,11 +1181,7 @@ impl<T: ?Sized> Arc<T> {\n         allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocError>,\n         mem_to_arcinner: impl FnOnce(*mut u8) -> *mut ArcInner<T>,\n     ) -> Result<*mut ArcInner<T>, AllocError> {\n-        // Calculate layout using the given value layout.\n-        // Previously, layout was calculated on the expression\n-        // `&*(ptr as *const ArcInner<T>)`, but this created a misaligned\n-        // reference (see #54908).\n-        let layout = Layout::new::<ArcInner<()>>().extend(value_layout).unwrap().0.pad_to_align();\n+        let layout = arcinner_layout_for_value_layout(value_layout);\n \n         let ptr = allocate(layout)?;\n \n@@ -1246,7 +1247,7 @@ impl<T> Arc<[T]> {\n         }\n     }\n \n-    /// Copy elements from slice into newly allocated Arc<\\[T\\]>\n+    /// Copy elements from slice into newly allocated `Arc<[T]>`\n     ///\n     /// Unsafe because the caller must either take ownership or bind `T: Copy`.\n     #[cfg(not(no_global_oom_handling))]\n@@ -1260,6 +1261,49 @@ impl<T> Arc<[T]> {\n         }\n     }\n \n+    /// Create an `Arc<[T]>` by reusing the underlying memory\n+    /// of a `Vec<T>`. This will return the vector if the existing allocation\n+    /// is not large enough.\n+    #[cfg(not(no_global_oom_handling))]\n+    fn try_from_vec_in_place(mut v: Vec<T>) -> Result<Arc<[T]>, Vec<T>> {\n+        let layout_elements = Layout::array::<T>(v.len()).unwrap();\n+        let layout_allocation = Layout::array::<T>(v.capacity()).unwrap();\n+        let layout_arcinner = arcinner_layout_for_value_layout(layout_elements);\n+        let mut ptr = NonNull::new(v.as_mut_ptr()).expect(\"`Vec<T>` stores `NonNull<T>`\");\n+        if layout_arcinner.size() > layout_allocation.size()\n+            || layout_arcinner.align() > layout_allocation.align()\n+        {\n+            // Can't fit - calling `grow` would involve `realloc`\n+            // (which copies the elements), followed by copying again.\n+            return Err(v);\n+        }\n+        if layout_arcinner.size() < layout_allocation.size()\n+            || layout_arcinner.align() < layout_allocation.align()\n+        {\n+            // We need to shrink the allocation so that it fits\n+            // https://doc.rust-lang.org/nightly/std/alloc/trait.Allocator.html#memory-fitting\n+            // SAFETY:\n+            // - Vec allocates by requesting `Layout::array::<T>(capacity)`, so this capacity matches\n+            // - `layout_arcinner` is smaller\n+            // If this fails, the ownership has not been transferred\n+            if let Ok(p) = unsafe { Global.shrink(ptr.cast(), layout_allocation, layout_arcinner) }\n+            {\n+                ptr = p.cast();\n+            } else {\n+                return Err(v);\n+            }\n+        }\n+        // Make sure the vec's memory isn't deallocated now\n+        let v = mem::ManuallyDrop::new(v);\n+        let ptr: *mut ArcInner<[T]> = ptr::slice_from_raw_parts_mut(ptr.as_ptr(), v.len()) as _;\n+        unsafe {\n+            ptr::copy(ptr.cast::<T>(), &mut (*ptr).data as *mut [T] as *mut T, v.len());\n+            ptr::write(&mut (*ptr).strong, atomic::AtomicUsize::new(1));\n+            ptr::write(&mut (*ptr).weak, atomic::AtomicUsize::new(1));\n+            Ok(Self::from_ptr(ptr))\n+        }\n+    }\n+\n     /// Constructs an `Arc<[T]>` from an iterator known to be of a certain size.\n     ///\n     /// Behavior is undefined should the size be wrong.\n@@ -2571,14 +2615,17 @@ impl<T> From<Vec<T>> for Arc<[T]> {\n     /// assert_eq!(&[1, 2, 3], &shared[..]);\n     /// ```\n     #[inline]\n-    fn from(mut v: Vec<T>) -> Arc<[T]> {\n-        unsafe {\n-            let arc = Arc::copy_from_slice(&v);\n-\n-            // Allow the Vec to free its memory, but not destroy its contents\n-            v.set_len(0);\n-\n-            arc\n+    fn from(v: Vec<T>) -> Arc<[T]> {\n+        match Arc::try_from_vec_in_place(v) {\n+            Ok(rc) => rc,\n+            Err(mut v) => {\n+                unsafe {\n+                    let rc = Arc::copy_from_slice(&v);\n+                    // Allow the Vec to free its memory, but not destroy its contents\n+                    v.set_len(0);\n+                    rc\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "eb379e4d6a10f9edfba773e77377f3cd4169a289", "filename": "library/alloc/tests/arc.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/36db030a7c3c51cb4484cbd8c8daebcf5057d61c/library%2Falloc%2Ftests%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36db030a7c3c51cb4484cbd8c8daebcf5057d61c/library%2Falloc%2Ftests%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Farc.rs?ref=36db030a7c3c51cb4484cbd8c8daebcf5057d61c", "patch": "@@ -210,3 +210,18 @@ fn weak_may_dangle() {\n     // `val` dropped here while still borrowed\n     // borrow might be used here, when `val` is dropped and runs the `Drop` code for type `std::sync::Weak`\n }\n+\n+#[test]\n+fn arc_from_vec_opt() {\n+    let mut v = Vec::with_capacity(64);\n+    v.push(0usize);\n+    let addr = v.as_ptr().cast::<u8>();\n+    let arc: Arc<[_]> = v.into();\n+    unsafe {\n+        assert_eq!(\n+            arc.as_ptr().cast::<u8>().offset_from(addr),\n+            (std::mem::size_of::<usize>() * 2) as isize,\n+            \"Vector allocation not reused\"\n+        );\n+    }\n+}"}, {"sha": "1d5f3c52006487bb9517b4fafec882965868c117", "filename": "library/alloc/tests/rc.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/36db030a7c3c51cb4484cbd8c8daebcf5057d61c/library%2Falloc%2Ftests%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36db030a7c3c51cb4484cbd8c8daebcf5057d61c/library%2Falloc%2Ftests%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Frc.rs?ref=36db030a7c3c51cb4484cbd8c8daebcf5057d61c", "patch": "@@ -206,3 +206,18 @@ fn weak_may_dangle() {\n     // `val` dropped here while still borrowed\n     // borrow might be used here, when `val` is dropped and runs the `Drop` code for type `std::rc::Weak`\n }\n+\n+#[test]\n+fn rc_from_vec_opt() {\n+    let mut v = Vec::with_capacity(64);\n+    v.push(0usize);\n+    let addr = v.as_ptr().cast::<u8>();\n+    let rc: Rc<[_]> = v.into();\n+    unsafe {\n+        assert_eq!(\n+            rc.as_ptr().cast::<u8>().offset_from(addr),\n+            (std::mem::size_of::<usize>() * 2) as isize,\n+            \"Vector allocation not reused\"\n+        );\n+    }\n+}"}]}