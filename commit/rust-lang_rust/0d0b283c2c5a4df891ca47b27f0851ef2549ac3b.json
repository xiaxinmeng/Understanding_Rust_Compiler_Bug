{"sha": "0d0b283c2c5a4df891ca47b27f0851ef2549ac3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkMGIyODNjMmM1YTRkZjg5MWNhNDdiMjdmMDg1MWVmMjU0OWFjM2I=", "commit": {"author": {"name": "Bryan Donlan", "email": "bdonlan@amazon.com", "date": "2019-11-21T19:48:39Z"}, "committer": {"name": "Bryan Donlan", "email": "bdonlan@amazon.com", "date": "2019-11-21T19:48:39Z"}, "message": "Make Weak::weak_count() return zero when no strong refs remain", "tree": {"sha": "6eb788268fba8d8a3c99ab56a29e8c0bbe8b8cd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6eb788268fba8d8a3c99ab56a29e8c0bbe8b8cd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d0b283c2c5a4df891ca47b27f0851ef2549ac3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d0b283c2c5a4df891ca47b27f0851ef2549ac3b", "html_url": "https://github.com/rust-lang/rust/commit/0d0b283c2c5a4df891ca47b27f0851ef2549ac3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d0b283c2c5a4df891ca47b27f0851ef2549ac3b/comments", "author": null, "committer": null, "parents": [{"sha": "91ee3d1c31e5d1684e0d2ec5036dc69993b6f992", "url": "https://api.github.com/repos/rust-lang/rust/commits/91ee3d1c31e5d1684e0d2ec5036dc69993b6f992", "html_url": "https://github.com/rust-lang/rust/commit/91ee3d1c31e5d1684e0d2ec5036dc69993b6f992"}], "stats": {"total": 76, "additions": 31, "deletions": 45}, "files": [{"sha": "0dab68b155d873884e7bb19b79348dba2c89f697", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0d0b283c2c5a4df891ca47b27f0851ef2549ac3b/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0b283c2c5a4df891ca47b27f0851ef2549ac3b/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=0d0b283c2c5a4df891ca47b27f0851ef2549ac3b", "patch": "@@ -1814,20 +1814,16 @@ impl<T: ?Sized> Weak<T> {\n \n     /// Gets the number of `Weak` pointers pointing to this allocation.\n     ///\n-    /// If `self` was created using [`Weak::new`], this will return `None`. If\n-    /// not, the returned value is at least 1, since `self` still points to the\n-    /// allocation.\n-    ///\n-    /// [`Weak::new`]: #method.new\n+    /// If no strong pointers remain, this will return zero.\n     #[stable(feature = \"weak_counts\", since = \"1.40.0\")]\n-    pub fn weak_count(&self) -> Option<usize> {\n+    pub fn weak_count(&self) -> usize {\n         self.inner().map(|inner| {\n             if inner.strong() > 0 {\n                 inner.weak() - 1  // subtract the implicit weak ptr\n             } else {\n-                inner.weak()\n+                0\n             }\n-        })\n+        }).unwrap_or(0)\n     }\n \n     /// Returns `None` when the pointer is dangling and there is no allocated `RcBox`"}, {"sha": "bf5c85a5c59601af7a142a7483d419b723c66382", "filename": "src/liballoc/rc/tests.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0d0b283c2c5a4df891ca47b27f0851ef2549ac3b/src%2Fliballoc%2Frc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0b283c2c5a4df891ca47b27f0851ef2549ac3b/src%2Fliballoc%2Frc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc%2Ftests.rs?ref=0d0b283c2c5a4df891ca47b27f0851ef2549ac3b", "patch": "@@ -114,28 +114,28 @@ fn test_weak_count() {\n \n #[test]\n fn weak_counts() {\n-    assert_eq!(Weak::weak_count(&Weak::<u64>::new()), None);\n+    assert_eq!(Weak::weak_count(&Weak::<u64>::new()), 0);\n     assert_eq!(Weak::strong_count(&Weak::<u64>::new()), 0);\n \n     let a = Rc::new(0);\n     let w = Rc::downgrade(&a);\n     assert_eq!(Weak::strong_count(&w), 1);\n-    assert_eq!(Weak::weak_count(&w), Some(1));\n+    assert_eq!(Weak::weak_count(&w), 1);\n     let w2 = w.clone();\n     assert_eq!(Weak::strong_count(&w), 1);\n-    assert_eq!(Weak::weak_count(&w), Some(2));\n+    assert_eq!(Weak::weak_count(&w), 2);\n     assert_eq!(Weak::strong_count(&w2), 1);\n-    assert_eq!(Weak::weak_count(&w2), Some(2));\n+    assert_eq!(Weak::weak_count(&w2), 2);\n     drop(w);\n     assert_eq!(Weak::strong_count(&w2), 1);\n-    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    assert_eq!(Weak::weak_count(&w2), 1);\n     let a2 = a.clone();\n     assert_eq!(Weak::strong_count(&w2), 2);\n-    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    assert_eq!(Weak::weak_count(&w2), 1);\n     drop(a2);\n     drop(a);\n     assert_eq!(Weak::strong_count(&w2), 0);\n-    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    assert_eq!(Weak::weak_count(&w2), 0);\n     drop(w2);\n }\n "}, {"sha": "1bfe3b802496bc7f630e4e4cb0ef640ceea288a2", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0d0b283c2c5a4df891ca47b27f0851ef2549ac3b/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0b283c2c5a4df891ca47b27f0851ef2549ac3b/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=0d0b283c2c5a4df891ca47b27f0851ef2549ac3b", "patch": "@@ -12,7 +12,7 @@ use core::sync::atomic;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n use core::borrow;\n use core::fmt;\n-use core::cmp::{self, Ordering};\n+use core::cmp::Ordering;\n use core::iter;\n use core::intrinsics::abort;\n use core::mem::{self, align_of, align_of_val, size_of_val};\n@@ -1508,9 +1508,8 @@ impl<T: ?Sized> Weak<T> {\n     /// Gets an approximation of the number of `Weak` pointers pointing to this\n     /// allocation.\n     ///\n-    /// If `self` was created using [`Weak::new`], this will return 0. If not,\n-    /// the returned value is at least 1, since `self` still points to the\n-    /// allocation.\n+    /// If `self` was created using [`Weak::new`], or if there are no remaining\n+    /// strong pointers, this will return 0.\n     ///\n     /// # Accuracy\n     ///\n@@ -1520,30 +1519,21 @@ impl<T: ?Sized> Weak<T> {\n     ///\n     /// [`Weak::new`]: #method.new\n     #[stable(feature = \"weak_counts\", since = \"1.40.0\")]\n-    pub fn weak_count(&self) -> Option<usize> {\n-        // Due to the implicit weak pointer added when any strong pointers are\n-        // around, we cannot implement `weak_count` correctly since it\n-        // necessarily requires accessing the strong count and weak count in an\n-        // unsynchronized fashion. So this version is a bit racy.\n+    pub fn weak_count(&self) -> usize {\n         self.inner().map(|inner| {\n-            let strong = inner.strong.load(SeqCst);\n             let weak = inner.weak.load(SeqCst);\n+            let strong = inner.strong.load(SeqCst);\n             if strong == 0 {\n-                // If the last `Arc` has *just* been dropped, it might not yet\n-                // have removed the implicit weak count, so the value we get\n-                // here might be 1 too high.\n-                weak\n+                0\n             } else {\n-                // As long as there's still at least 1 `Arc` around, subtract\n-                // the implicit weak pointer.\n-                // Note that the last `Arc` might get dropped between the 2\n-                // loads we do above, removing the implicit weak pointer. This\n-                // means that the value might be 1 too low here. In order to not\n-                // return 0 here (which would happen if we're the only weak\n-                // pointer), we guard against that specifically.\n-                cmp::max(1, weak - 1)\n+                // Since we observed that there was at least one strong pointer\n+                // after reading the weak count, we know that the implicit weak\n+                // reference (present whenever any strong references are alive)\n+                // was still around when we observed the weak count, and can\n+                // therefore safely subtract it.\n+                weak - 1\n             }\n-        })\n+        }).unwrap_or(0)\n     }\n \n     /// Returns `None` when the pointer is dangling and there is no allocated `ArcInner`,"}, {"sha": "be0200c9a461342f348ed487b84f79a1efcdf374", "filename": "src/liballoc/sync/tests.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0d0b283c2c5a4df891ca47b27f0851ef2549ac3b/src%2Fliballoc%2Fsync%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0b283c2c5a4df891ca47b27f0851ef2549ac3b/src%2Fliballoc%2Fsync%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync%2Ftests.rs?ref=0d0b283c2c5a4df891ca47b27f0851ef2549ac3b", "patch": "@@ -62,28 +62,28 @@ fn test_arc_get_mut() {\n \n #[test]\n fn weak_counts() {\n-    assert_eq!(Weak::weak_count(&Weak::<u64>::new()), None);\n+    assert_eq!(Weak::weak_count(&Weak::<u64>::new()), 0);\n     assert_eq!(Weak::strong_count(&Weak::<u64>::new()), 0);\n \n     let a = Arc::new(0);\n     let w = Arc::downgrade(&a);\n     assert_eq!(Weak::strong_count(&w), 1);\n-    assert_eq!(Weak::weak_count(&w), Some(1));\n+    assert_eq!(Weak::weak_count(&w), 1);\n     let w2 = w.clone();\n     assert_eq!(Weak::strong_count(&w), 1);\n-    assert_eq!(Weak::weak_count(&w), Some(2));\n+    assert_eq!(Weak::weak_count(&w), 2);\n     assert_eq!(Weak::strong_count(&w2), 1);\n-    assert_eq!(Weak::weak_count(&w2), Some(2));\n+    assert_eq!(Weak::weak_count(&w2), 2);\n     drop(w);\n     assert_eq!(Weak::strong_count(&w2), 1);\n-    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    assert_eq!(Weak::weak_count(&w2), 1);\n     let a2 = a.clone();\n     assert_eq!(Weak::strong_count(&w2), 2);\n-    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    assert_eq!(Weak::weak_count(&w2), 1);\n     drop(a2);\n     drop(a);\n     assert_eq!(Weak::strong_count(&w2), 0);\n-    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    assert_eq!(Weak::weak_count(&w2), 0);\n     drop(w2);\n }\n "}]}