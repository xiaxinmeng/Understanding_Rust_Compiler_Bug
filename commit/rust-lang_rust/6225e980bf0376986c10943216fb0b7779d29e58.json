{"sha": "6225e980bf0376986c10943216fb0b7779d29e58", "node_id": "C_kwDOAAsO6NoAKDYyMjVlOTgwYmYwMzc2OTg2YzEwOTQzMjE2ZmIwYjc3NzlkMjllNTg", "commit": {"author": {"name": "Ellen", "email": "supbscripter@gmail.com", "date": "2022-05-05T11:23:42Z"}, "committer": {"name": "Ellen", "email": "supbscripter@gmail.com", "date": "2022-05-05T11:24:05Z"}, "message": " handle mismatched generic parameter kinds", "tree": {"sha": "4be844ea1411d587759f95c3987ef11a692e5054", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4be844ea1411d587759f95c3987ef11a692e5054"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6225e980bf0376986c10943216fb0b7779d29e58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6225e980bf0376986c10943216fb0b7779d29e58", "html_url": "https://github.com/rust-lang/rust/commit/6225e980bf0376986c10943216fb0b7779d29e58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6225e980bf0376986c10943216fb0b7779d29e58/comments", "author": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "committer": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fed2c43bbf4e3955f83cea77c0b1709c0dbcebf3", "url": "https://api.github.com/repos/rust-lang/rust/commits/fed2c43bbf4e3955f83cea77c0b1709c0dbcebf3", "html_url": "https://github.com/rust-lang/rust/commit/fed2c43bbf4e3955f83cea77c0b1709c0dbcebf3"}], "stats": {"total": 319, "additions": 264, "deletions": 55}, "files": [{"sha": "c42280a8208e4d9d1b255e3cb5544fbc94464230", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 160, "deletions": 55, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/6225e980bf0376986c10943216fb0b7779d29e58/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6225e980bf0376986c10943216fb0b7779d29e58/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=6225e980bf0376986c10943216fb0b7779d29e58", "patch": "@@ -48,6 +48,10 @@ crate fn compare_impl_method<'tcx>(\n         return;\n     }\n \n+    if let Err(_) = compare_generic_param_kinds(tcx, impl_m, trait_m, trait_item_span) {\n+        return;\n+    }\n+\n     if let Err(_) =\n         compare_number_of_method_arguments(tcx, impl_m, impl_m_span, trait_m, trait_item_span)\n     {\n@@ -62,10 +66,6 @@ crate fn compare_impl_method<'tcx>(\n     {\n         return;\n     }\n-\n-    if let Err(_) = compare_const_param_types(tcx, impl_m, trait_m, trait_item_span) {\n-        return;\n-    }\n }\n \n fn compare_predicate_entailment<'tcx>(\n@@ -914,62 +914,165 @@ fn compare_synthetic_generics<'tcx>(\n     if let Some(reported) = error_found { Err(reported) } else { Ok(()) }\n }\n \n-fn compare_const_param_types<'tcx>(\n+/// Checks that all parameters in the generics of a given assoc item in a trait impl have\n+/// the same kind as the respective generic parameter in the trait def.\n+///\n+/// For example all 4 errors in the following code are emitted here:\n+/// ```\n+/// trait Foo {\n+///     fn foo<const N: u8>();\n+///     type bar<const N: u8>;\n+///     fn baz<const N: u32>();\n+///     type blah<T>;\n+/// }\n+///\n+/// impl Foo for () {\n+///     fn foo<const N: u64>() {}\n+///     //~^ error\n+///     type bar<const N: u64> {}\n+///     //~^ error\n+///     fn baz<T>() {}\n+///     //~^ error\n+///     type blah<const N: i64> = u32;\n+///     //~^ error\n+/// }\n+/// ```\n+///\n+/// This function does not handle lifetime parameters\n+fn compare_generic_param_kinds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_m: &ty::AssocItem,\n-    trait_m: &ty::AssocItem,\n+    impl_item: &ty::AssocItem,\n+    trait_item: &ty::AssocItem,\n     trait_item_span: Option<Span>,\n ) -> Result<(), ErrorGuaranteed> {\n-    let const_params_of = |def_id| {\n-        tcx.generics_of(def_id).params.iter().filter_map(|param| match param.kind {\n-            GenericParamDefKind::Const { .. } => Some(param.def_id),\n-            _ => None,\n+    assert_eq!(impl_item.kind, trait_item.kind);\n+\n+    let ty_const_params_of = |def_id| {\n+        tcx.generics_of(def_id).params.iter().filter(|param| {\n+            matches!(\n+                param.kind,\n+                GenericParamDefKind::Const { .. } | GenericParamDefKind::Type { .. }\n+            )\n         })\n     };\n-    let const_params_impl = const_params_of(impl_m.def_id);\n-    let const_params_trait = const_params_of(trait_m.def_id);\n-\n-    for (const_param_impl, const_param_trait) in iter::zip(const_params_impl, const_params_trait) {\n-        let impl_ty = tcx.type_of(const_param_impl);\n-        let trait_ty = tcx.type_of(const_param_trait);\n-        if impl_ty != trait_ty {\n-            let (impl_span, impl_ident) = match tcx.hir().get_if_local(const_param_impl) {\n-                Some(hir::Node::GenericParam(hir::GenericParam { span, name, .. })) => (\n-                    span,\n-                    match name {\n-                        hir::ParamName::Plain(ident) => Some(ident),\n-                        _ => None,\n-                    },\n-                ),\n-                other => bug!(\n-                    \"expected GenericParam, found {:?}\",\n-                    other.map_or_else(|| \"nothing\".to_string(), |n| format!(\"{:?}\", n))\n-                ),\n-            };\n-            let trait_span = match tcx.hir().get_if_local(const_param_trait) {\n-                Some(hir::Node::GenericParam(hir::GenericParam { span, .. })) => Some(span),\n-                _ => None,\n-            };\n-            let mut err = struct_span_err!(\n-                tcx.sess,\n-                *impl_span,\n-                E0053,\n-                \"method `{}` has an incompatible const parameter type for trait\",\n-                trait_m.name\n-            );\n-            err.span_note(\n-                trait_span.map_or_else(|| trait_item_span.unwrap_or(*impl_span), |span| *span),\n-                &format!(\n-                    \"the const parameter{} has type `{}`, but the declaration \\\n-                              in trait `{}` has type `{}`\",\n-                    &impl_ident.map_or_else(|| \"\".to_string(), |ident| format!(\" `{ident}`\")),\n-                    impl_ty,\n-                    tcx.def_path_str(trait_m.def_id),\n-                    trait_ty\n-                ),\n-            );\n-            let reported = err.emit();\n-            return Err(reported);\n+\n+    let get_param_span = |param: &ty::GenericParamDef| match tcx.hir().get_if_local(param.def_id) {\n+        Some(hir::Node::GenericParam(hir::GenericParam { span, .. })) => Some(span),\n+        _ => None,\n+    };\n+\n+    let get_param_ident = |param: &ty::GenericParamDef| match tcx.hir().get_if_local(param.def_id) {\n+        Some(hir::Node::GenericParam(hir::GenericParam { name, .. })) => match name {\n+            hir::ParamName::Plain(ident) => Some(ident),\n+            _ => None,\n+        },\n+        other => bug!(\n+            \"expected GenericParam, found {:?}\",\n+            other.map_or_else(|| \"nothing\".to_string(), |n| format!(\"{:?}\", n))\n+        ),\n+    };\n+\n+    let ty_const_params_impl = ty_const_params_of(impl_item.def_id);\n+    let ty_const_params_trait = ty_const_params_of(trait_item.def_id);\n+    let assoc_item_str = assoc_item_kind_str(&impl_item);\n+\n+    for (param_impl, param_trait) in iter::zip(ty_const_params_impl, ty_const_params_trait) {\n+        use GenericParamDefKind::*;\n+        match (&param_impl.kind, &param_trait.kind) {\n+            (Const { .. }, Const { .. }) => {\n+                let impl_ty = tcx.type_of(param_impl.def_id);\n+                let trait_ty = tcx.type_of(param_trait.def_id);\n+                if impl_ty != trait_ty {\n+                    let param_impl_span = get_param_span(param_impl).unwrap();\n+                    let param_impl_ident = get_param_ident(param_impl);\n+                    let param_trait_span = get_param_span(param_trait);\n+\n+                    let mut err = struct_span_err!(\n+                        tcx.sess,\n+                        *param_impl_span,\n+                        E0053,\n+                        \"{} `{}` has an incompatible const parameter type for trait\",\n+                        assoc_item_str,\n+                        trait_item.name,\n+                    );\n+                    err.span_note(\n+                        param_trait_span.map_or_else(\n+                            || trait_item_span.unwrap_or(*param_impl_span),\n+                            |span| *span,\n+                        ),\n+                        &format!(\n+                            \"the const parameter{} has type `{}`, but the declaration \\\n+                                      in trait `{}` has type `{}`\",\n+                            &param_impl_ident\n+                                .map_or_else(|| \"\".to_string(), |ident| format!(\" `{ident}`\")),\n+                            impl_ty,\n+                            tcx.def_path_str(trait_item.def_id),\n+                            trait_ty\n+                        ),\n+                    );\n+                    let reported = err.emit();\n+                    return Err(reported);\n+                }\n+            }\n+            (Const { .. }, Type { .. }) => {\n+                let impl_ty = tcx.type_of(param_impl.def_id);\n+                let param_impl_span = get_param_span(param_impl).unwrap();\n+                let param_impl_ident = get_param_ident(param_impl);\n+                let param_trait_span = get_param_span(param_trait);\n+\n+                let mut err = struct_span_err!(\n+                    tcx.sess,\n+                    *param_impl_span,\n+                    E0053,\n+                    \"{} `{}` has an incompatible generic parameter for trait\",\n+                    assoc_item_str,\n+                    trait_item.name,\n+                );\n+                err.span_note(\n+                    param_trait_span\n+                        .map_or_else(|| trait_item_span.unwrap_or(*param_impl_span), |span| *span),\n+                    &format!(\n+                        \"the trait impl specifies{} a const parameter of type `{}`, but the declaration \\\n+                                       in trait `{}` requires it is a type parameter\",\n+                        &param_impl_ident\n+                            .map_or_else(|| \"\".to_string(), |ident| format!(\" `{ident}` is\")),\n+                        impl_ty,\n+                        tcx.def_path_str(trait_item.def_id),\n+                    ),\n+                );\n+                let reported = err.emit();\n+                return Err(reported);\n+            }\n+            (Type { .. }, Const { .. }) => {\n+                let trait_ty = tcx.type_of(param_trait.def_id);\n+                let param_impl_span = get_param_span(param_impl).unwrap();\n+                let param_impl_ident = get_param_ident(param_impl);\n+                let param_trait_span = get_param_span(param_trait);\n+\n+                let mut err = struct_span_err!(\n+                    tcx.sess,\n+                    *param_impl_span,\n+                    E0053,\n+                    \"{} `{}` has an incompatible generic parameter for trait\",\n+                    assoc_item_str,\n+                    trait_item.name,\n+                );\n+                err.span_note(\n+                    param_trait_span\n+                        .map_or_else(|| trait_item_span.unwrap_or(*param_impl_span), |span| *span),\n+                    &format!(\n+                        \"the trait impl specifies{} a type parameter, but the declaration \\\n+                                       in trait `{}` requires it is a const parameter of type `{}`\",\n+                        &param_impl_ident\n+                            .map_or_else(|| \"\".to_string(), |ident| format!(\" `{ident}` is\")),\n+                        tcx.def_path_str(trait_item.def_id),\n+                        trait_ty,\n+                    ),\n+                );\n+                let reported = err.emit();\n+                return Err(reported);\n+            }\n+            _ => (),\n         }\n     }\n \n@@ -1095,6 +1198,8 @@ crate fn compare_ty_impl<'tcx>(\n     let _: Result<(), ErrorGuaranteed> = (|| {\n         compare_number_of_generics(tcx, impl_ty, impl_ty_span, trait_ty, trait_item_span)?;\n \n+        compare_generic_param_kinds(tcx, impl_ty, trait_ty, trait_item_span)?;\n+\n         let sp = tcx.def_span(impl_ty.def_id);\n         compare_type_predicate_entailment(tcx, impl_ty, sp, trait_ty, impl_trait_ref)?;\n "}, {"sha": "0c6669fa9b6d123b81c1054be596cb5b1209eced", "filename": "src/test/ui/const-generics/defaults/mismatched_ty_const_in_trait_impl.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6225e980bf0376986c10943216fb0b7779d29e58/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fmismatched_ty_const_in_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6225e980bf0376986c10943216fb0b7779d29e58/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fmismatched_ty_const_in_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fmismatched_ty_const_in_trait_impl.rs?ref=6225e980bf0376986c10943216fb0b7779d29e58", "patch": "@@ -0,0 +1,25 @@\n+trait Trait {\n+    fn foo<U>() {}\n+}\n+impl Trait for () {\n+    fn foo<const M: u64>() {}\n+    //~^ error: method `foo` has an incompatble generic parameter for trait\n+}\n+\n+trait Other {\n+    fn bar<const M: u8>() {}\n+}\n+impl Other for () {\n+    fn bar<T>() {}\n+    //~^ error: method `bar` has an incompatible generic parameter for trait\n+}\n+\n+trait Uwu {\n+    fn baz<const N: u32>() {}\n+}\n+impl Uwu for () {\n+    fn baz<const N: i32>() {}\n+    //~^ error: method `baz` has an incompatible generic parameter for trait\n+}\n+\n+fn main() {}"}, {"sha": "d400c2165904bd65cdea6c36fcac9f207e2362ab", "filename": "src/test/ui/const-generics/defaults/mismatched_ty_const_in_trait_impl.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6225e980bf0376986c10943216fb0b7779d29e58/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fmismatched_ty_const_in_trait_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6225e980bf0376986c10943216fb0b7779d29e58/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fmismatched_ty_const_in_trait_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fmismatched_ty_const_in_trait_impl.stderr?ref=6225e980bf0376986c10943216fb0b7779d29e58", "patch": "@@ -0,0 +1,52 @@\n+error[E0049]: method `foo` has 0 type parameters but its trait declaration has 1 type parameter\n+  --> $DIR/mismatched_ty_const_in_trait_impl.rs:5:12\n+   |\n+LL |     fn foo<U>() {}\n+   |            - expected 1 type parameter\n+...\n+LL |     fn foo<const M: u64>() {}\n+   |            ^^^^^^^^^^^^ found 0 type parameters\n+\n+error[E0049]: method `foo` has 1 const parameter but its trait declaration has 0 const parameters\n+  --> $DIR/mismatched_ty_const_in_trait_impl.rs:5:12\n+   |\n+LL |     fn foo<U>() {}\n+   |            - expected 0 const parameters\n+...\n+LL |     fn foo<const M: u64>() {}\n+   |            ^^^^^^^^^^^^ found 1 const parameter\n+\n+error[E0049]: method `bar` has 1 type parameter but its trait declaration has 0 type parameters\n+  --> $DIR/mismatched_ty_const_in_trait_impl.rs:13:12\n+   |\n+LL |     fn bar<const M: u8>() {}\n+   |            ----------- expected 0 type parameters\n+...\n+LL |     fn bar<T>() {}\n+   |            ^ found 1 type parameter\n+\n+error[E0049]: method `bar` has 0 const parameters but its trait declaration has 1 const parameter\n+  --> $DIR/mismatched_ty_const_in_trait_impl.rs:13:12\n+   |\n+LL |     fn bar<const M: u8>() {}\n+   |            ----------- expected 1 const parameter\n+...\n+LL |     fn bar<T>() {}\n+   |            ^ found 0 const parameters\n+\n+error[E0053]: method `baz` has an incompatible const parameter type for trait\n+  --> $DIR/mismatched_ty_const_in_trait_impl.rs:21:12\n+   |\n+LL |     fn baz<const N: i32>() {}\n+   |            ^^^^^^^^^^^^\n+   |\n+note: the const parameter `N` has type `i32`, but the declaration in trait `Uwu::baz` has type `u32`\n+  --> $DIR/mismatched_ty_const_in_trait_impl.rs:18:12\n+   |\n+LL |     fn baz<const N: u32>() {}\n+   |            ^^^^^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n+\n+Some errors have detailed explanations: E0049, E0053.\n+For more information about an error, try `rustc --explain E0049`."}, {"sha": "675132587bfdd5cf8df9442eb3af16f973e4b52c", "filename": "src/test/ui/generic-associated-types/const_params_have_right_type.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6225e980bf0376986c10943216fb0b7779d29e58/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconst_params_have_right_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6225e980bf0376986c10943216fb0b7779d29e58/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconst_params_have_right_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconst_params_have_right_type.rs?ref=6225e980bf0376986c10943216fb0b7779d29e58", "patch": "@@ -0,0 +1,12 @@\n+#![feature(generic_associated_types)]\n+\n+trait Trait {\n+    type Foo<const N: u8>;\n+}\n+\n+impl Trait for () {\n+    type Foo<const N: u64> = u32;\n+    //~^ error: associated type `Foo` has an incompatible const parameter type\n+}\n+\n+fn main() {}"}, {"sha": "62353180c67969015f0997099c65b77ba8cf7b97", "filename": "src/test/ui/generic-associated-types/const_params_have_right_type.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6225e980bf0376986c10943216fb0b7779d29e58/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconst_params_have_right_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6225e980bf0376986c10943216fb0b7779d29e58/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconst_params_have_right_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fconst_params_have_right_type.stderr?ref=6225e980bf0376986c10943216fb0b7779d29e58", "patch": "@@ -0,0 +1,15 @@\n+error[E0053]: associated type `Foo` has an incompatible const parameter type for trait\n+  --> $DIR/const_params_have_right_type.rs:8:14\n+   |\n+LL |     type Foo<const N: u64> = u32;\n+   |              ^^^^^^^^^^^^\n+   |\n+note: the const parameter `N` has type `u64`, but the declaration in trait `Trait::Foo` has type `u8`\n+  --> $DIR/const_params_have_right_type.rs:4:14\n+   |\n+LL |     type Foo<const N: u8>;\n+   |              ^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0053`."}]}