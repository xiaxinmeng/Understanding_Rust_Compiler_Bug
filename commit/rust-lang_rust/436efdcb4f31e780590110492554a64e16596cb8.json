{"sha": "436efdcb4f31e780590110492554a64e16596cb8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzNmVmZGNiNGYzMWU3ODA1OTAxMTA0OTI1NTRhNjRlMTY1OTZjYjg=", "commit": {"author": {"name": "Michael Bebenita", "email": "mbebenita@mozilla.com", "date": "2010-07-28T07:06:04Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-07-29T03:30:29Z"}, "message": "Add C++ wrapper around uthash.", "tree": {"sha": "8b273143cead535242d036cb96c35766d7ebfc49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b273143cead535242d036cb96c35766d7ebfc49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/436efdcb4f31e780590110492554a64e16596cb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/436efdcb4f31e780590110492554a64e16596cb8", "html_url": "https://github.com/rust-lang/rust/commit/436efdcb4f31e780590110492554a64e16596cb8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/436efdcb4f31e780590110492554a64e16596cb8/comments", "author": {"login": "mbebenita", "id": 311082, "node_id": "MDQ6VXNlcjMxMTA4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/311082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbebenita", "html_url": "https://github.com/mbebenita", "followers_url": "https://api.github.com/users/mbebenita/followers", "following_url": "https://api.github.com/users/mbebenita/following{/other_user}", "gists_url": "https://api.github.com/users/mbebenita/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbebenita/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbebenita/subscriptions", "organizations_url": "https://api.github.com/users/mbebenita/orgs", "repos_url": "https://api.github.com/users/mbebenita/repos", "events_url": "https://api.github.com/users/mbebenita/events{/privacy}", "received_events_url": "https://api.github.com/users/mbebenita/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbcc9b36b148857c17ced736cfc93dc8883038db", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbcc9b36b148857c17ced736cfc93dc8883038db", "html_url": "https://github.com/rust-lang/rust/commit/dbcc9b36b148857c17ced736cfc93dc8883038db"}], "stats": {"total": 193, "additions": 193, "deletions": 0}, "files": [{"sha": "08d308370ed81e3d8b3755b04126730236ae6f39", "filename": "src/rt/util/hash_map.h", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/436efdcb4f31e780590110492554a64e16596cb8/src%2Frt%2Futil%2Fhash_map.h", "raw_url": "https://github.com/rust-lang/rust/raw/436efdcb4f31e780590110492554a64e16596cb8/src%2Frt%2Futil%2Fhash_map.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Futil%2Fhash_map.h?ref=436efdcb4f31e780590110492554a64e16596cb8", "patch": "@@ -0,0 +1,193 @@\n+/**\n+ * A C++ wrapper around uthash.\n+ */\n+\n+#ifndef HASH_MAP\n+#define HASH_MAP\n+\n+#include <assert.h>\n+#include \"../uthash/uthash.h\"\n+\n+template<typename K, typename V> class hash_map {\n+    struct map_entry {\n+        K key;\n+        V value;\n+        UT_hash_handle hh;\n+    };\n+    map_entry * _head;\n+public:\n+    hash_map();\n+    ~hash_map();\n+\n+    /**\n+     * Associates a value with the specified key in this hash map.\n+     * If a mapping already exists the old value is replaced.\n+     *\n+     * returns:\n+     * true if the mapping was successfully created and false otherwise.\n+     */\n+    bool put(K key, V value);\n+\n+    /**\n+     * Updates the value associated with the specified key in this hash map.\n+     *\n+     * returns:\n+     * true if the value was updated, or false if the key was not found.\n+     */\n+    bool set(K key, V value);\n+\n+    /**\n+     * Gets the value associated with the specified key in this hash map.\n+     *\n+     * returns:\n+     * true if the value was found and updates the specified *value parameter\n+     * with the associated value, or false otherwise.\n+     */\n+    bool get(K key, V *value);\n+\n+    /**\n+     * Removes a key-value pair from this hash map.\n+     *\n+     * returns:\n+     * true if a key-value pair exists and updates the specified\n+     * *key and *value parameters, or false otherwise.\n+     */\n+    bool pop(K *key, V *value);\n+\n+    /**\n+     * Checks if the specified key exists in this hash map.\n+     *\n+     * returns:\n+     * true if the specified key exists in this hash map, or false otherwise.\n+     */\n+    bool contains(K key);\n+\n+    /**\n+     * Removes the value associated with the specified key from this hash map.\n+     *\n+     * returns:\n+     * true if the specified key exists and updates the specified *old_value\n+     * parameter with the associated value, or false otherwise.\n+     */\n+    bool remove(K key, V *old_value);\n+    bool remove(K key);\n+\n+    /**\n+     * Returns the number of key-value pairs in this hash map.\n+     */\n+    size_t count();\n+\n+    bool is_empty() {\n+        return count() == 0;\n+    }\n+\n+    /**\n+     * Clears all the key-value pairs in this hash map.\n+     *\n+     * returns:\n+     * the number of deleted key-value pairs.\n+     */\n+    size_t clear();\n+};\n+\n+template<typename K, typename V>\n+hash_map<K,V>::hash_map() {\n+    _head = NULL;\n+}\n+\n+template<typename K, typename V>\n+hash_map<K,V>::~hash_map() {\n+    clear();\n+}\n+\n+template<typename K, typename V> bool\n+hash_map<K,V>::put(K key, V value) {\n+    if (contains(key)) {\n+        return set(key, value);\n+    }\n+    map_entry *entry = (map_entry *) malloc(sizeof(map_entry));\n+    entry->key = key;\n+    entry->value = value;\n+    HASH_ADD(hh, _head, key, sizeof(K), entry);\n+    return true;\n+}\n+\n+template<typename K, typename V> bool\n+hash_map<K,V>::get(K key, V *value) {\n+    map_entry *entry = NULL;\n+    HASH_FIND(hh, _head, &key, sizeof(K), entry);\n+    if (entry == NULL) {\n+        return false;\n+    }\n+    *value = entry->value;\n+    return true;\n+}\n+\n+template<typename K, typename V> bool\n+hash_map<K,V>::set(K key, V value) {\n+    map_entry *entry = NULL;\n+    HASH_FIND(hh, _head, &key, sizeof(K), entry);\n+    if (entry == NULL) {\n+        return false;\n+    }\n+    entry->value = value;\n+    return true;\n+}\n+\n+template<typename K, typename V> bool\n+hash_map<K,V>::contains(K key) {\n+    V value;\n+    return get(key, &value);\n+}\n+\n+template<typename K, typename V> bool\n+hash_map<K,V>::remove(K key, V *old_value) {\n+    map_entry *entry = NULL;\n+    HASH_FIND(hh, _head, &key, sizeof(K), entry);\n+    if (entry == NULL) {\n+        return false;\n+    }\n+    *old_value = entry->value;\n+    HASH_DEL(_head, entry);\n+    free(entry);\n+    return true;\n+}\n+\n+template<typename K, typename V> bool\n+hash_map<K,V>::pop(K *key, V *value) {\n+    if (is_empty()) {\n+        return false;\n+    }\n+    map_entry *entry = _head;\n+    HASH_DEL(_head, entry);\n+    *key = entry->key;\n+    *value = entry->value;\n+    free(entry);\n+    return true;\n+}\n+\n+template<typename K, typename V> bool\n+hash_map<K,V>::remove(K key) {\n+    V old_value;\n+    return remove(key, &old_value);\n+}\n+\n+template<typename K, typename V> size_t\n+hash_map<K,V>::count() {\n+    return HASH_CNT(hh, _head);\n+}\n+\n+template<typename K, typename V> size_t\n+hash_map<K,V>::clear() {\n+    size_t deleted_entries = 0;\n+    while (_head != NULL) {\n+        map_entry *entry = _head;\n+        HASH_DEL(_head, entry);\n+        free(entry);\n+        deleted_entries ++;\n+    }\n+    assert(count() == 0);\n+    return deleted_entries;\n+}\n+\n+#endif /* HASH_MAP */"}]}