{"sha": "6fa054df968198eff4513e483dee07e1e3612dad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmYTA1NGRmOTY4MTk4ZWZmNDUxM2U0ODNkZWUwN2UxZTM2MTJkYWQ=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-04-24T12:50:56Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-04-24T22:20:00Z"}, "message": "Use borrowed pointers for Integer methods\n\nThis brings them in line with the quot and rem traits, and is be better for large Integer types like BigInt and BigUint because they don't need to be copied unnecessarily.", "tree": {"sha": "e991e9dc1be2830a3c45feca8792ddfd1c3ca520", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e991e9dc1be2830a3c45feca8792ddfd1c3ca520"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6fa054df968198eff4513e483dee07e1e3612dad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6fa054df968198eff4513e483dee07e1e3612dad", "html_url": "https://github.com/rust-lang/rust/commit/6fa054df968198eff4513e483dee07e1e3612dad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6fa054df968198eff4513e483dee07e1e3612dad/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "024bf2ec72bdc2428d5c58a59bfed7da1bbc4efd", "url": "https://api.github.com/repos/rust-lang/rust/commits/024bf2ec72bdc2428d5c58a59bfed7da1bbc4efd", "html_url": "https://github.com/rust-lang/rust/commit/024bf2ec72bdc2428d5c58a59bfed7da1bbc4efd"}], "stats": {"total": 142, "additions": 71, "deletions": 71}, "files": [{"sha": "f9edf1cefc873f8a99bbe017d55d42c4b8f1c151", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/6fa054df968198eff4513e483dee07e1e3612dad/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fa054df968198eff4513e483dee07e1e3612dad/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=6fa054df968198eff4513e483dee07e1e3612dad", "patch": "@@ -298,13 +298,13 @@ impl Integer for T {\n      * ~~~\n      */\n     #[inline(always)]\n-    fn div(&self, other: T) -> T {\n+    fn div(&self, other: &T) -> T {\n         // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n         // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n         match self.quot_rem(other) {\n-            (q, r) if (r > 0 && other < 0)\n-                   || (r < 0 && other > 0) => q - 1,\n-            (q, _)                         => q,\n+            (q, r) if (r > 0 && *other < 0)\n+                   || (r < 0 && *other > 0) => q - 1,\n+            (q, _)                          => q,\n         }\n     }\n \n@@ -330,32 +330,32 @@ impl Integer for T {\n      * ~~~\n      */\n     #[inline(always)]\n-    fn modulo(&self, other: T) -> T {\n+    fn modulo(&self, other: &T) -> T {\n         // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n         // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n-        match *self % other {\n-            r if (r > 0 && other < 0)\n-              || (r < 0 && other > 0) => r + other,\n-            r                         => r,\n+        match *self % *other {\n+            r if (r > 0 && *other < 0)\n+              || (r < 0 && *other > 0) => r + *other,\n+            r                          => r,\n         }\n     }\n \n     /// Calculates `div` and `modulo` simultaneously\n     #[inline(always)]\n-    fn div_mod(&self, other: T) -> (T,T) {\n+    fn div_mod(&self, other: &T) -> (T,T) {\n         // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n         // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n         match self.quot_rem(other) {\n-            (q, r) if (r > 0 && other < 0)\n-                   || (r < 0 && other > 0) => (q - 1, r + other),\n-            (q, r)                         => (q, r),\n+            (q, r) if (r > 0 && *other < 0)\n+                   || (r < 0 && *other > 0) => (q - 1, r + *other),\n+            (q, r)                          => (q, r),\n         }\n     }\n \n     /// Calculates `quot` (`\\`) and `rem` (`%`) simultaneously\n     #[inline(always)]\n-    fn quot_rem(&self, other: T) -> (T,T) {\n-        (*self / other, *self % other)\n+    fn quot_rem(&self, other: &T) -> (T,T) {\n+        (*self / *other, *self % *other)\n     }\n \n     /**\n@@ -364,9 +364,9 @@ impl Integer for T {\n      * The result is always positive\n      */\n     #[inline(always)]\n-    fn gcd(&self, other: T) -> T {\n+    fn gcd(&self, other: &T) -> T {\n         // Use Euclid's algorithm\n-        let mut m = *self, n = other;\n+        let mut m = *self, n = *other;\n         while m != 0 {\n             let temp = m;\n             m = n % temp;\n@@ -379,17 +379,17 @@ impl Integer for T {\n      * Calculates the Lowest Common Multiple (LCM) of the number and `other`\n      */\n     #[inline(always)]\n-    fn lcm(&self, other: T) -> T {\n-        ((*self * other) / self.gcd(other)).abs() // should not have to recaluculate abs\n+    fn lcm(&self, other: &T) -> T {\n+        ((*self * *other) / self.gcd(other)).abs() // should not have to recaluculate abs\n     }\n \n     /// Returns `true` if the number can be divided by `other` without leaving a remainder\n     #[inline(always)]\n-    fn divisible_by(&self, other: T) -> bool { *self % other == 0 }\n+    fn divisible_by(&self, other: &T) -> bool { *self % *other == 0 }\n \n     /// Returns `true` if the number is divisible by `2`\n     #[inline(always)]\n-    fn is_even(&self) -> bool { self.divisible_by(2) }\n+    fn is_even(&self) -> bool { self.divisible_by(&2) }\n \n     /// Returns `true` if the number is not divisible by `2`\n     #[inline(always)]\n@@ -562,7 +562,7 @@ mod tests {\n         fn test_nd_qr(nd: (T,T), qr: (T,T)) {\n             let (n,d) = nd;\n             let separate_quot_rem = (n / d, n % d);\n-            let combined_quot_rem = n.quot_rem(d);\n+            let combined_quot_rem = n.quot_rem(&d);\n \n             assert_eq!(separate_quot_rem, qr);\n             assert_eq!(combined_quot_rem, qr);\n@@ -586,8 +586,8 @@ mod tests {\n     fn test_div_mod() {\n         fn test_nd_dm(nd: (T,T), dm: (T,T)) {\n             let (n,d) = nd;\n-            let separate_div_mod = (n.div(d), n.modulo(d));\n-            let combined_div_mod = n.div_mod(d);\n+            let separate_div_mod = (n.div(&d), n.modulo(&d));\n+            let combined_div_mod = n.div_mod(&d);\n \n             assert_eq!(separate_div_mod, dm);\n             assert_eq!(combined_div_mod, dm);\n@@ -609,26 +609,26 @@ mod tests {\n \n     #[test]\n     fn test_gcd() {\n-        assert_eq!((10 as T).gcd(2), 2 as T);\n-        assert_eq!((10 as T).gcd(3), 1 as T);\n-        assert_eq!((0 as T).gcd(3), 3 as T);\n-        assert_eq!((3 as T).gcd(3), 3 as T);\n-        assert_eq!((56 as T).gcd(42), 14 as T);\n-        assert_eq!((3 as T).gcd(-3), 3 as T);\n-        assert_eq!((-6 as T).gcd(3), 3 as T);\n-        assert_eq!((-4 as T).gcd(-2), 2 as T);\n+        assert_eq!((10 as T).gcd(&2), 2 as T);\n+        assert_eq!((10 as T).gcd(&3), 1 as T);\n+        assert_eq!((0 as T).gcd(&3), 3 as T);\n+        assert_eq!((3 as T).gcd(&3), 3 as T);\n+        assert_eq!((56 as T).gcd(&42), 14 as T);\n+        assert_eq!((3 as T).gcd(&-3), 3 as T);\n+        assert_eq!((-6 as T).gcd(&3), 3 as T);\n+        assert_eq!((-4 as T).gcd(&-2), 2 as T);\n     }\n \n     #[test]\n     fn test_lcm() {\n-        assert_eq!((1 as T).lcm(0), 0 as T);\n-        assert_eq!((0 as T).lcm(1), 0 as T);\n-        assert_eq!((1 as T).lcm(1), 1 as T);\n-        assert_eq!((-1 as T).lcm(1), 1 as T);\n-        assert_eq!((1 as T).lcm(-1), 1 as T);\n-        assert_eq!((-1 as T).lcm(-1), 1 as T);\n-        assert_eq!((8 as T).lcm(9), 72 as T);\n-        assert_eq!((11 as T).lcm(5), 55 as T);\n+        assert_eq!((1 as T).lcm(&0), 0 as T);\n+        assert_eq!((0 as T).lcm(&1), 0 as T);\n+        assert_eq!((1 as T).lcm(&1), 1 as T);\n+        assert_eq!((-1 as T).lcm(&1), 1 as T);\n+        assert_eq!((1 as T).lcm(&-1), 1 as T);\n+        assert_eq!((-1 as T).lcm(&-1), 1 as T);\n+        assert_eq!((8 as T).lcm(&9), 72 as T);\n+        assert_eq!((11 as T).lcm(&5), 55 as T);\n     }\n \n     #[test]"}, {"sha": "076d90707f62e4fde6c317325772bda6d62adbda", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6fa054df968198eff4513e483dee07e1e3612dad/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fa054df968198eff4513e483dee07e1e3612dad/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=6fa054df968198eff4513e483dee07e1e3612dad", "patch": "@@ -65,14 +65,14 @@ pub trait Integer: Num\n                  + Ord\n                  + Quot<Self,Self>\n                  + Rem<Self,Self> {\n-    fn div(&self, other: Self) -> Self;\n-    fn modulo(&self, other: Self) -> Self;\n-    fn div_mod(&self, other: Self) -> (Self,Self);\n-    fn quot_rem(&self, other: Self) -> (Self,Self);\n-\n-    fn gcd(&self, other: Self) -> Self;\n-    fn lcm(&self, other: Self) -> Self;\n-    fn divisible_by(&self, other: Self) -> bool;\n+    fn div(&self, other: &Self) -> Self;\n+    fn modulo(&self, other: &Self) -> Self;\n+    fn div_mod(&self, other: &Self) -> (Self,Self);\n+    fn quot_rem(&self, other: &Self) -> (Self,Self);\n+\n+    fn gcd(&self, other: &Self) -> Self;\n+    fn lcm(&self, other: &Self) -> Self;\n+    fn divisible_by(&self, other: &Self) -> bool;\n     fn is_even(&self) -> bool;\n     fn is_odd(&self) -> bool;\n }"}, {"sha": "96019ddd564d60c2c2b9416f99b1a7fcaf0e81dc", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6fa054df968198eff4513e483dee07e1e3612dad/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fa054df968198eff4513e483dee07e1e3612dad/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=6fa054df968198eff4513e483dee07e1e3612dad", "patch": "@@ -179,29 +179,29 @@ impl Unsigned for T {}\n impl Integer for T {\n     /// Unsigned integer division. Returns the same result as `quot` (`/`).\n     #[inline(always)]\n-    fn div(&self, other: T) -> T { *self / other }\n+    fn div(&self, other: &T) -> T { *self / *other }\n \n     /// Unsigned integer modulo operation. Returns the same result as `rem` (`%`).\n     #[inline(always)]\n-    fn modulo(&self, other: T) -> T { *self / other }\n+    fn modulo(&self, other: &T) -> T { *self / *other }\n \n     /// Calculates `div` and `modulo` simultaneously\n     #[inline(always)]\n-    fn div_mod(&self, other: T) -> (T,T) {\n-        (*self / other, *self % other)\n+    fn div_mod(&self, other: &T) -> (T,T) {\n+        (*self / *other, *self % *other)\n     }\n \n     /// Calculates `quot` (`\\`) and `rem` (`%`) simultaneously\n     #[inline(always)]\n-    fn quot_rem(&self, other: T) -> (T,T) {\n-        (*self / other, *self % other)\n+    fn quot_rem(&self, other: &T) -> (T,T) {\n+        (*self / *other, *self % *other)\n     }\n \n     /// Calculates the Greatest Common Divisor (GCD) of the number and `other`\n     #[inline(always)]\n-    fn gcd(&self, other: T) -> T {\n+    fn gcd(&self, other: &T) -> T {\n         // Use Euclid's algorithm\n-        let mut m = *self, n = other;\n+        let mut m = *self, n = *other;\n         while m != 0 {\n             let temp = m;\n             m = n % temp;\n@@ -212,17 +212,17 @@ impl Integer for T {\n \n     /// Calculates the Lowest Common Multiple (LCM) of the number and `other`\n     #[inline(always)]\n-    fn lcm(&self, other: T) -> T {\n-        (*self * other) / self.gcd(other)\n+    fn lcm(&self, other: &T) -> T {\n+        (*self * *other) / self.gcd(other)\n     }\n \n     /// Returns `true` if the number can be divided by `other` without leaving a remainder\n     #[inline(always)]\n-    fn divisible_by(&self, other: T) -> bool { *self % other == 0 }\n+    fn divisible_by(&self, other: &T) -> bool { *self % *other == 0 }\n \n     /// Returns `true` if the number is divisible by `2`\n     #[inline(always)]\n-    fn is_even(&self) -> bool { self.divisible_by(2) }\n+    fn is_even(&self) -> bool { self.divisible_by(&2) }\n \n     /// Returns `true` if the number is not divisible by `2`\n     #[inline(always)]\n@@ -355,21 +355,21 @@ mod tests {\n \n     #[test]\n     fn test_gcd() {\n-        assert_eq!((10 as T).gcd(2), 2 as T);\n-        assert_eq!((10 as T).gcd(3), 1 as T);\n-        assert_eq!((0 as T).gcd(3), 3 as T);\n-        assert_eq!((3 as T).gcd(3), 3 as T);\n-        assert_eq!((56 as T).gcd(42), 14 as T);\n+        assert_eq!((10 as T).gcd(&2), 2 as T);\n+        assert_eq!((10 as T).gcd(&3), 1 as T);\n+        assert_eq!((0 as T).gcd(&3), 3 as T);\n+        assert_eq!((3 as T).gcd(&3), 3 as T);\n+        assert_eq!((56 as T).gcd(&42), 14 as T);\n     }\n \n     #[test]\n     fn test_lcm() {\n-        assert_eq!((1 as T).lcm(0), 0 as T);\n-        assert_eq!((0 as T).lcm(1), 0 as T);\n-        assert_eq!((1 as T).lcm(1), 1 as T);\n-        assert_eq!((8 as T).lcm(9), 72 as T);\n-        assert_eq!((11 as T).lcm(5), 55 as T);\n-        assert_eq!((99 as T).lcm(17), 1683 as T);\n+        assert_eq!((1 as T).lcm(&0), 0 as T);\n+        assert_eq!((0 as T).lcm(&1), 0 as T);\n+        assert_eq!((1 as T).lcm(&1), 1 as T);\n+        assert_eq!((8 as T).lcm(&9), 72 as T);\n+        assert_eq!((11 as T).lcm(&5), 55 as T);\n+        assert_eq!((99 as T).lcm(&17), 1683 as T);\n     }\n \n     #[test]"}]}