{"sha": "0b632d553e8c4590ea349a54254d9aacaea0f543", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiNjMyZDU1M2U4YzQ1OTBlYTM0OWE1NDI1NGQ5YWFjYWVhMGY1NDM=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-11-19T06:58:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-19T06:58:59Z"}, "message": "Merge pull request #86 from oli-obk/fast_repeat\n\nabort on huge repeat expressions", "tree": {"sha": "048544ef54976159ce64f5626a7c1c19d479472d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/048544ef54976159ce64f5626a7c1c19d479472d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b632d553e8c4590ea349a54254d9aacaea0f543", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b632d553e8c4590ea349a54254d9aacaea0f543", "html_url": "https://github.com/rust-lang/rust/commit/0b632d553e8c4590ea349a54254d9aacaea0f543", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b632d553e8c4590ea349a54254d9aacaea0f543/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3973b9961e5db2df943045ca455bade450b6d476", "url": "https://api.github.com/repos/rust-lang/rust/commits/3973b9961e5db2df943045ca455bade450b6d476", "html_url": "https://github.com/rust-lang/rust/commit/3973b9961e5db2df943045ca455bade450b6d476"}, {"sha": "e361b63fa052ee9ee09794fa358d56c41c82ed5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e361b63fa052ee9ee09794fa358d56c41c82ed5b", "html_url": "https://github.com/rust-lang/rust/commit/e361b63fa052ee9ee09794fa358d56c41c82ed5b"}], "stats": {"total": 205, "additions": 133, "deletions": 72}, "files": [{"sha": "3725df24cdca7e8d8a8047a241b46342c4823469", "filename": "benches/helpers/miri_helper.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0b632d553e8c4590ea349a54254d9aacaea0f543/benches%2Fhelpers%2Fmiri_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b632d553e8c4590ea349a54254d9aacaea0f543/benches%2Fhelpers%2Fmiri_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fhelpers%2Fmiri_helper.rs?ref=0b632d553e8c4590ea349a54254d9aacaea0f543", "patch": "@@ -33,7 +33,7 @@ pub fn run(filename: &str, bencher: &mut Bencher) {\n         find_sysroot()\n     ];\n     let compiler_calls = &mut MiriCompilerCalls(Rc::new(RefCell::new(bencher)));\n-    rustc_driver::run_compiler(args, compiler_calls);\n+    rustc_driver::run_compiler(args, compiler_calls, None, None);\n }\n \n impl<'a> CompilerCalls<'a> for MiriCompilerCalls<'a> {\n@@ -51,13 +51,15 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls<'a> {\n             state.session.abort_if_errors();\n \n             let tcx = state.tcx.unwrap();\n-            let mir_map = state.mir_map.unwrap();\n-            let (node_id, _) = state.session.entry_fn.borrow()\n+            let (entry_node_id, _) = state.session.entry_fn.borrow()\n                 .expect(\"no main or start function found\");\n+            let entry_def_id = tcx.map.local_def_id(entry_node_id);\n \n-            let mut mir_map = MirMap { map: mir_map.map.clone() };\n-            run_mir_passes(tcx, &mut mir_map);\n-            bencher.borrow_mut().iter(|| { eval_main(tcx, &mir_map, node_id); });\n+            run_mir_passes(tcx);\n+            let memory_size = 100*1024*1024; // 100MB\n+            let step_limit = 1000_000;\n+            let stack_limit = 100;\n+            bencher.borrow_mut().iter(|| { eval_main(tcx, entry_def_id, memory_size, step_limit, stack_limit); });\n \n             state.session.abort_if_errors();\n         });"}, {"sha": "0e8c5980b82bdec0f7072a775997b0837f2d8b14", "filename": "benches/helpers/repeat.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b632d553e8c4590ea349a54254d9aacaea0f543/benches%2Fhelpers%2Frepeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b632d553e8c4590ea349a54254d9aacaea0f543/benches%2Fhelpers%2Frepeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fhelpers%2Frepeat.rs?ref=0b632d553e8c4590ea349a54254d9aacaea0f543", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let data: [u8; 1024] = [42; 1024];\n+    assert_eq!(data.len(), 1024);\n+}"}, {"sha": "6ef6f724efceee8a04d50541dbee22f63c09e45c", "filename": "benches/helpers/repeat_manual.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0b632d553e8c4590ea349a54254d9aacaea0f543/benches%2Fhelpers%2Frepeat_manual.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b632d553e8c4590ea349a54254d9aacaea0f543/benches%2Fhelpers%2Frepeat_manual.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fhelpers%2Frepeat_manual.rs?ref=0b632d553e8c4590ea349a54254d9aacaea0f543", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let mut data: [u8; 1024] = unsafe { std::mem::uninitialized() };\n+    for i in 0..data.len() {\n+        unsafe { std::ptr::write(&mut data[i], 0); }\n+    }\n+    assert_eq!(data.len(), 1024);\n+}"}, {"sha": "f5920e83d9b07b1d2462072c02f67339ecb37375", "filename": "benches/repeat.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0b632d553e8c4590ea349a54254d9aacaea0f543/benches%2Frepeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b632d553e8c4590ea349a54254d9aacaea0f543/benches%2Frepeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Frepeat.rs?ref=0b632d553e8c4590ea349a54254d9aacaea0f543", "patch": "@@ -0,0 +1,16 @@\n+#![feature(test, rustc_private)]\n+\n+extern crate test;\n+use test::Bencher;\n+mod helpers;\n+use helpers::*;\n+\n+#[bench]\n+fn repeat(bencher: &mut Bencher) {\n+    miri_helper::run(\"repeat\", bencher);\n+}\n+\n+#[bench]\n+fn repeat_manual(bencher: &mut Bencher) {\n+    miri_helper::run(\"repeat_manual\", bencher);\n+}"}, {"sha": "65cbcc97015637bedb405a97409309e66e5d09aa", "filename": "src/error.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0b632d553e8c4590ea349a54254d9aacaea0f543/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b632d553e8c4590ea349a54254d9aacaea0f543/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=0b632d553e8c4590ea349a54254d9aacaea0f543", "patch": "@@ -1,13 +1,13 @@\n use std::error::Error;\n use std::fmt;\n use rustc::mir;\n-use rustc::ty::{BareFnTy, Ty, FnSig};\n+use rustc::ty::{BareFnTy, Ty, FnSig, layout};\n use syntax::abi::Abi;\n use memory::Pointer;\n use rustc_const_math::ConstMathErr;\n use syntax::codemap::Span;\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug)]\n pub enum EvalError<'tcx> {\n     FunctionPointerTyMismatch(Abi, &'tcx FnSig<'tcx>, &'tcx BareFnTy<'tcx>),\n     NoMirFor(String),\n@@ -50,6 +50,7 @@ pub enum EvalError<'tcx> {\n     TypeNotPrimitive(Ty<'tcx>),\n     ReallocatedFrozenMemory,\n     DeallocatedFrozenMemory,\n+    Layout(layout::LayoutError<'tcx>),\n }\n \n pub type EvalResult<'tcx, T> = Result<T, EvalError<'tcx>>;\n@@ -116,6 +117,8 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"tried to reallocate frozen memory\",\n             EvalError::DeallocatedFrozenMemory =>\n                 \"tried to deallocate frozen memory\",\n+            EvalError::Layout(_) =>\n+                \"rustc layout computation failed\",\n         }\n     }\n \n@@ -146,6 +149,8 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n                       has, required),\n             EvalError::TypeNotPrimitive(ref ty) =>\n                 write!(f, \"expected primitive type, got {}\", ty),\n+            EvalError::Layout(ref err) =>\n+                write!(f, \"rustc layout computation failed: {:?}\", err),\n             _ => write!(f, \"{}\", self.description()),\n         }\n     }"}, {"sha": "d61ba4ee3f7117a5cddd1c841f8d772b53011c4e", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 42, "deletions": 36, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/0b632d553e8c4590ea349a54254d9aacaea0f543/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b632d553e8c4590ea349a54254d9aacaea0f543/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=0b632d553e8c4590ea349a54254d9aacaea0f543", "patch": "@@ -40,6 +40,11 @@ pub struct EvalContext<'a, 'tcx: 'a> {\n \n     /// The maximum number of stack frames allowed\n     stack_limit: usize,\n+\n+    /// The maximum number of operations that may be executed.\n+    /// This prevents infinite loops and huge computations from freezing up const eval.\n+    /// Remove once halting problem is solved.\n+    steps_remaining: u64,\n }\n \n /// A stack frame.\n@@ -162,13 +167,14 @@ pub enum StackPopCleanup {\n }\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, memory_size: usize, stack_limit: usize) -> Self {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, memory_size: usize, stack_limit: usize, step_limit: u64) -> Self {\n         EvalContext {\n             tcx: tcx,\n             memory: Memory::new(&tcx.data_layout, memory_size),\n             globals: HashMap::new(),\n             stack: Vec::new(),\n             stack_limit: stack_limit,\n+            steps_remaining: step_limit,\n         }\n     }\n \n@@ -182,8 +188,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         ty: Ty<'tcx>,\n         substs: &'tcx Substs<'tcx>\n     ) -> EvalResult<'tcx, Pointer> {\n-        let size = self.type_size_with_substs(ty, substs).expect(\"cannot alloc memory for unsized type\");\n-        let align = self.type_align_with_substs(ty, substs);\n+        let size = self.type_size_with_substs(ty, substs)?.expect(\"cannot alloc memory for unsized type\");\n+        let align = self.type_align_with_substs(ty, substs)?;\n         self.memory.allocate(size, align)\n     }\n \n@@ -286,38 +292,37 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.tcx.normalize_associated_type(&substituted)\n     }\n \n-    fn type_size(&self, ty: Ty<'tcx>) -> Option<usize> {\n+    fn type_size(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<usize>> {\n         self.type_size_with_substs(ty, self.substs())\n     }\n \n-    fn type_align(&self, ty: Ty<'tcx>) -> usize {\n+    fn type_align(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, usize> {\n         self.type_align_with_substs(ty, self.substs())\n     }\n \n-    fn type_size_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> Option<usize> {\n-        let layout = self.type_layout_with_substs(ty, substs);\n+    fn type_size_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, Option<usize>> {\n+        let layout = self.type_layout_with_substs(ty, substs)?;\n         if layout.is_unsized() {\n-            None\n+            Ok(None)\n         } else {\n-            Some(layout.size(&self.tcx.data_layout).bytes() as usize)\n+            Ok(Some(layout.size(&self.tcx.data_layout).bytes() as usize))\n         }\n     }\n \n-    fn type_align_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> usize {\n-        self.type_layout_with_substs(ty, substs).align(&self.tcx.data_layout).abi() as usize\n+    fn type_align_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, usize> {\n+        self.type_layout_with_substs(ty, substs).map(|layout| layout.align(&self.tcx.data_layout).abi() as usize)\n     }\n \n-    fn type_layout(&self, ty: Ty<'tcx>) -> &'tcx Layout {\n+    fn type_layout(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, &'tcx Layout> {\n         self.type_layout_with_substs(ty, self.substs())\n     }\n \n-    fn type_layout_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> &'tcx Layout {\n+    fn type_layout_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, &'tcx Layout> {\n         // TODO(solson): Is this inefficient? Needs investigation.\n         let ty = self.monomorphize(ty, substs);\n \n         self.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n-            // TODO(solson): Report this error properly.\n-            ty.layout(&infcx).unwrap()\n+            ty.layout(&infcx).map_err(EvalError::Layout)\n         })\n     }\n \n@@ -476,7 +481,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     ) -> EvalResult<'tcx, ()> {\n         let dest = self.eval_lvalue(lvalue)?;\n         let dest_ty = self.lvalue_ty(lvalue);\n-        let dest_layout = self.type_layout(dest_ty);\n+        let dest_layout = self.type_layout(dest_ty)?;\n \n         use rustc::mir::Rvalue::*;\n         match *rvalue {\n@@ -500,6 +505,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             Aggregate(ref kind, ref operands) => {\n+                self.inc_step_counter_and_check_limit(operands.len() as u64)?;\n                 use rustc::ty::layout::Layout::*;\n                 match *dest_layout {\n                     Univariant { ref variant, .. } => {\n@@ -509,7 +515,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                     Array { .. } => {\n                         let elem_size = match dest_ty.sty {\n-                            ty::TyArray(elem_ty, _) => self.type_size(elem_ty).expect(\"array elements are sized\") as u64,\n+                            ty::TyArray(elem_ty, _) => self.type_size(elem_ty)?.expect(\"array elements are sized\") as u64,\n                             _ => bug!(\"tried to assign {:?} to non-array type {:?}\", kind, dest_ty),\n                         };\n                         let offsets = (0..).map(|i| i * elem_size);\n@@ -549,9 +555,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 if let Some(operand) = operands.get(0) {\n                                     assert_eq!(operands.len(), 1);\n                                     let operand_ty = self.operand_ty(operand);\n-                                    assert_eq!(self.type_size(operand_ty), Some(0));\n+                                    assert_eq!(self.type_size(operand_ty)?, Some(0));\n                                 }\n-                                let value_size = self.type_size(dest_ty).expect(\"pointer types are sized\");\n+                                let value_size = self.type_size(dest_ty)?.expect(\"pointer types are sized\");\n                                 let zero = PrimVal::from_int_with_size(0, value_size);\n                                 self.write_primval(dest, zero)?;\n                             }\n@@ -568,15 +574,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             } else {\n                                 for operand in operands {\n                                     let operand_ty = self.operand_ty(operand);\n-                                    assert_eq!(self.type_size(operand_ty), Some(0));\n+                                    assert_eq!(self.type_size(operand_ty)?, Some(0));\n                                 }\n                                 let (offset, ty) = self.nonnull_offset_and_ty(dest_ty, nndiscr, discrfield)?;\n \n                                 // FIXME(solson)\n                                 let dest = self.force_allocation(dest)?.to_ptr();\n \n                                 let dest = dest.offset(offset.bytes() as isize);\n-                                let dest_size = self.type_size(ty).expect(\"bad StructWrappedNullablePointer discrfield\");\n+                                let dest_size = self.type_size(ty)?.expect(\"bad StructWrappedNullablePointer discrfield\");\n                                 try!(self.memory.write_int(dest, 0, dest_size));\n                             }\n                         } else {\n@@ -618,7 +624,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     ty::TyArray(elem_ty, n) => (elem_ty, n),\n                     _ => bug!(\"tried to assign array-repeat to non-array type {:?}\", dest_ty),\n                 };\n-                let elem_size = self.type_size(elem_ty).expect(\"repeat element type must be sized\");\n+                self.inc_step_counter_and_check_limit(length as u64)?;\n+                let elem_size = self.type_size(elem_ty)?.expect(\"repeat element type must be sized\");\n                 let value = self.eval_operand(operand)?;\n \n                 // FIXME(solson)\n@@ -789,7 +796,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     fn get_field_offset(&self, ty: Ty<'tcx>, field_index: usize) -> EvalResult<'tcx, Size> {\n-        let layout = self.type_layout(ty);\n+        let layout = self.type_layout(ty)?;\n \n         use rustc::ty::layout::Layout::*;\n         match *layout {\n@@ -808,7 +815,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     fn get_field_count(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, usize> {\n-        let layout = self.type_layout(ty);\n+        let layout = self.type_layout(ty)?;\n \n         use rustc::ty::layout::Layout::*;\n         match *layout {\n@@ -936,7 +943,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     ) -> EvalResult<'tcx, Lvalue<'tcx>> {\n         let base = self.eval_lvalue(&proj.base)?;\n         let base_ty = self.lvalue_ty(&proj.base);\n-        let base_layout = self.type_layout(base_ty);\n+        let base_layout = self.type_layout(base_ty)?;\n \n         use rustc::mir::ProjectionElem::*;\n         let (ptr, extra) = match proj.elem {\n@@ -1035,7 +1042,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let (base_ptr, _) = base.to_ptr_and_extra();\n \n                 let (elem_ty, len) = base.elem_ty_and_len(base_ty);\n-                let elem_size = self.type_size(elem_ty).expect(\"slice element must be sized\");\n+                let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n                 let n_ptr = self.eval_operand(operand)?;\n                 let usize = self.tcx.types.usize;\n                 let n = self.value_to_primval(n_ptr, usize)?\n@@ -1051,7 +1058,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let (base_ptr, _) = base.to_ptr_and_extra();\n \n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n-                let elem_size = self.type_size(elem_ty).expect(\"sequence element must be sized\");\n+                let elem_size = self.type_size(elem_ty)?.expect(\"sequence element must be sized\");\n                 assert!(n >= min_length as u64);\n \n                 let index = if from_end {\n@@ -1070,7 +1077,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let (base_ptr, _) = base.to_ptr_and_extra();\n \n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n-                let elem_size = self.type_size(elem_ty).expect(\"slice element must be sized\");\n+                let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n                 assert!((from as u64) <= n - (to as u64));\n                 let ptr = base_ptr.offset(from as isize * elem_size as isize);\n                 let extra = LvalueExtra::Length(n - to as u64 - from as u64);\n@@ -1090,8 +1097,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     fn copy(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, ()> {\n-        let size = self.type_size(ty).expect(\"cannot copy from an unsized type\");\n-        let align = self.type_align(ty);\n+        let size = self.type_size(ty)?.expect(\"cannot copy from an unsized type\");\n+        let align = self.type_align(ty)?;\n         self.memory.copy(src, dest, size, align)?;\n         Ok(())\n     }\n@@ -1360,7 +1367,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             ty::TyAdt(..) => {\n                 use rustc::ty::layout::Layout::*;\n-                if let CEnum { discr, signed, .. } = *self.type_layout(ty) {\n+                if let CEnum { discr, signed, .. } = *self.type_layout(ty)? {\n                     let size = discr.size().bytes() as usize;\n                     if signed {\n                         PrimValKind::from_int_size(size)\n@@ -1456,7 +1463,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             ty::TyAdt(..) => {\n                 use rustc::ty::layout::Layout::*;\n-                if let CEnum { discr, signed, .. } = *self.type_layout(ty) {\n+                if let CEnum { discr, signed, .. } = *self.type_layout(ty)? {\n                     let size = discr.size().bytes() as usize;\n                     if signed {\n                         let n = self.memory.read_int(ptr, size)?;\n@@ -1556,7 +1563,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 for (i, (src_f, dst_f)) in iter {\n                     let src_fty = monomorphize_field_ty(self.tcx, src_f, substs_a);\n                     let dst_fty = monomorphize_field_ty(self.tcx, dst_f, substs_b);\n-                    if self.type_size(dst_fty) == Some(0) {\n+                    if self.type_size(dst_fty)? == Some(0) {\n                         continue;\n                     }\n                     let src_field_offset = self.get_field_offset(src_ty, i)?.bytes() as isize;\n@@ -1696,7 +1703,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     step_limit: u64,\n     stack_limit: usize,\n ) {\n-    let mut ecx = EvalContext::new(tcx, memory_size, stack_limit);\n+    let mut ecx = EvalContext::new(tcx, memory_size, stack_limit, step_limit);\n     let mir = ecx.load_mir(def_id).expect(\"main function's MIR not found\");\n \n     ecx.push_stack_frame(\n@@ -1708,7 +1715,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n         StackPopCleanup::None,\n     ).expect(\"could not allocate first stack frame\");\n \n-    for _ in 0..step_limit {\n+    loop {\n         match ecx.step() {\n             Ok(true) => {}\n             Ok(false) => return,\n@@ -1718,7 +1725,6 @@ pub fn eval_main<'a, 'tcx: 'a>(\n             }\n         }\n     }\n-    report(tcx, &ecx, EvalError::ExecutionTimeLimitReached);\n }\n \n fn report(tcx: TyCtxt, ecx: &EvalContext, e: EvalError) {"}, {"sha": "1d075fe0e9ed2d3186da52d06f6ad4e152d2e7e7", "filename": "src/interpreter/step.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0b632d553e8c4590ea349a54254d9aacaea0f543/src%2Finterpreter%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b632d553e8c4590ea349a54254d9aacaea0f543/src%2Finterpreter%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstep.rs?ref=0b632d553e8c4590ea349a54254d9aacaea0f543", "patch": "@@ -10,7 +10,7 @@ use super::{\n     Global,\n     MirRef,\n };\n-use error::EvalResult;\n+use error::{EvalResult, EvalError};\n use rustc::mir;\n use rustc::ty::{subst, self};\n use rustc::hir::def_id::DefId;\n@@ -20,8 +20,18 @@ use std::cell::Ref;\n use syntax::codemap::Span;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+    pub fn inc_step_counter_and_check_limit(&mut self, n: u64) -> EvalResult<'tcx, ()> {\n+        self.steps_remaining = self.steps_remaining.saturating_sub(n);\n+        if self.steps_remaining > 0 {\n+            Ok(())\n+        } else {\n+            Err(EvalError::ExecutionTimeLimitReached)\n+        }\n+    }\n+\n     /// Returns true as long as there are more things to do.\n     pub fn step(&mut self) -> EvalResult<'tcx, bool> {\n+        self.inc_step_counter_and_check_limit(1)?;\n         if self.stack.is_empty() {\n             return Ok(false);\n         }"}, {"sha": "013bacc30d2ffd98b1d445857a662a0dc851fc67", "filename": "src/interpreter/terminator/intrinsics.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0b632d553e8c4590ea349a54254d9aacaea0f543/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b632d553e8c4590ea349a54254d9aacaea0f543/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fintrinsics.rs?ref=0b632d553e8c4590ea349a54254d9aacaea0f543", "patch": "@@ -144,8 +144,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"copy_nonoverlapping\" => {\n                 // FIXME: check whether overlapping occurs\n                 let elem_ty = substs.type_at(0);\n-                let elem_size = self.type_size(elem_ty).expect(\"cannot copy unsized value\");\n-                let elem_align = self.type_align(elem_ty);\n+                let elem_size = self.type_size(elem_ty)?.expect(\"cannot copy unsized value\");\n+                let elem_align = self.type_align(elem_ty)?;\n                 let src = arg_vals[0].read_ptr(&self.memory)?;\n                 let dest = arg_vals[1].read_ptr(&self.memory)?;\n                 let count = self.value_to_primval(arg_vals[2], usize)?\n@@ -252,14 +252,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"min_align_of\" => {\n                 let elem_ty = substs.type_at(0);\n-                let elem_align = self.type_align(elem_ty);\n+                let elem_align = self.type_align(elem_ty)?;\n                 let align_val = self.usize_primval(elem_align as u64);\n                 self.write_primval(dest, align_val)?;\n             }\n \n             \"pref_align_of\" => {\n                 let ty = substs.type_at(0);\n-                let layout = self.type_layout(ty);\n+                let layout = self.type_layout(ty)?;\n                 let align = layout.align(&self.tcx.data_layout).pref();\n                 let align_val = self.usize_primval(align);\n                 self.write_primval(dest, align_val)?;\n@@ -280,7 +280,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"offset\" => {\n                 let pointee_ty = substs.type_at(0);\n-                let pointee_size = self.type_size(pointee_ty).expect(\"cannot offset a pointer to an unsized type\") as isize;\n+                let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as isize;\n                 let offset = self.value_to_primval(arg_vals[1], isize)?\n                     .expect_int(\"offset second arg not isize\");\n \n@@ -335,7 +335,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // `size_of_val` intrinsic, then change this back to\n                 // .expect(\"size_of intrinsic called on unsized value\")\n                 // see https://github.com/rust-lang/rust/pull/37708\n-                let size = self.type_size(ty).unwrap_or(!0) as u64;\n+                let size = self.type_size(ty)?.unwrap_or(!0) as u64;\n                 let size_val = self.usize_primval(size);\n                 self.write_primval(dest, size_val)?;\n             }\n@@ -414,8 +414,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         value: Value,\n     ) -> EvalResult<'tcx, (u64, u64)> {\n         let pointer_size = self.memory.pointer_size();\n-        if let Some(size) = self.type_size(ty) {\n-            Ok((size as u64, self.type_align(ty) as u64))\n+        if let Some(size) = self.type_size(ty)? {\n+            Ok((size as u64, self.type_align(ty)? as u64))\n         } else {\n             match ty.sty {\n                 ty::TyAdt(def, substs) => {\n@@ -424,7 +424,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     // and it also rounds up to alignment, which we want to avoid,\n                     // as the unsized field's alignment could be smaller.\n                     assert!(!ty.is_simd());\n-                    let layout = self.type_layout(ty);\n+                    let layout = self.type_layout(ty)?;\n                     debug!(\"DST {} layout: {:?}\", ty, layout);\n \n                     let (sized_size, sized_align) = match *layout {\n@@ -489,9 +489,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 ty::TySlice(_) | ty::TyStr => {\n                     let elem_ty = ty.sequence_element_type(self.tcx);\n-                    let elem_size = self.type_size(elem_ty).expect(\"slice element must be sized\") as u64;\n+                    let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\") as u64;\n                     let (_, len) = value.expect_slice(&self.memory)?;\n-                    let align = self.type_align(elem_ty);\n+                    let align = self.type_align(elem_ty)?;\n                     Ok((len * elem_size, align as u64))\n                 }\n "}, {"sha": "ad0e139e6e1f41cd6a537f4a457c8b112ceb0c8a", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0b632d553e8c4590ea349a54254d9aacaea0f543/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b632d553e8c4590ea349a54254d9aacaea0f543/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=0b632d553e8c4590ea349a54254d9aacaea0f543", "patch": "@@ -183,15 +183,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         match fn_ty.abi {\n             Abi::RustIntrinsic => {\n                 let ty = fn_ty.sig.0.output;\n-                let layout = self.type_layout(ty);\n+                let layout = self.type_layout(ty)?;\n                 let (ret, target) = destination.unwrap();\n                 self.call_intrinsic(def_id, substs, arg_operands, ret, ty, layout, target)?;\n                 Ok(())\n             }\n \n             Abi::C => {\n                 let ty = fn_ty.sig.0.output;\n-                let size = self.type_size(ty).expect(\"function return type cannot be unsized\");\n+                let size = self.type_size(ty)?.expect(\"function return type cannot be unsized\");\n                 let (ret, target) = destination.unwrap();\n                 self.call_c_abi(def_id, arg_operands, ret, size)?;\n                 self.goto_block(target);\n@@ -248,7 +248,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     fn read_discriminant_value(&self, adt_ptr: Pointer, adt_ty: Ty<'tcx>) -> EvalResult<'tcx, u64> {\n         use rustc::ty::layout::Layout::*;\n-        let adt_layout = self.type_layout(adt_ty);\n+        let adt_layout = self.type_layout(adt_ty)?;\n         trace!(\"read_discriminant_value {:?}\", adt_layout);\n \n         let discr_val = match *adt_layout {\n@@ -273,7 +273,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let nonnull = adt_ptr.offset(offset.bytes() as isize);\n                 trace!(\"struct wrapped nullable pointer type: {}\", ty);\n                 // only the pointer part of a fat pointer is used for this space optimization\n-                let discr_size = self.type_size(ty).expect(\"bad StructWrappedNullablePointer discrfield\");\n+                let discr_size = self.type_size(ty)?.expect(\"bad StructWrappedNullablePointer discrfield\");\n                 self.read_nonnull_discriminant_value(nonnull, nndiscr, discr_size)?\n             }\n \n@@ -402,9 +402,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         })\n     }\n \n-    fn unpack_fn_args(&self, args: &mut Vec<(Value, Ty<'tcx>)>) {\n+    fn unpack_fn_args(&self, args: &mut Vec<(Value, Ty<'tcx>)>) -> EvalResult<'tcx, ()> {\n         if let Some((last, last_ty)) = args.pop() {\n-            let last_layout = self.type_layout(last_ty);\n+            let last_layout = self.type_layout(last_ty)?;\n             match (&last_ty.sty, last_layout) {\n                 (&ty::TyTuple(fields),\n                  &Layout::Univariant { ref variant, .. }) => {\n@@ -421,6 +421,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 ty => bug!(\"expected tuple as last argument in function with 'rust-call' ABI, got {:?}\", ty),\n             }\n         }\n+        Ok(())\n     }\n \n     /// Trait method, which has to be resolved to an impl method.\n@@ -452,7 +453,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     .expect(\"The substitutions should have no type parameters remaining after passing through fulfill_obligation\");\n                 let closure_kind = self.tcx.closure_kind(vtable_closure.closure_def_id);\n                 trace!(\"closures {:?}, {:?}\", closure_kind, trait_closure_kind);\n-                self.unpack_fn_args(args);\n+                self.unpack_fn_args(args)?;\n                 match (closure_kind, trait_closure_kind) {\n                     (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n                     (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n@@ -487,7 +488,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             traits::VtableFnPointer(vtable_fn_ptr) => {\n                 if let ty::TyFnDef(did, ref substs, _) = vtable_fn_ptr.fn_ty.sty {\n                     args.remove(0);\n-                    self.unpack_fn_args(args);\n+                    self.unpack_fn_args(args)?;\n                     Ok((did, substs))\n                 } else {\n                     bug!(\"VtableFnPointer did not contain a concrete function: {:?}\", vtable_fn_ptr)\n@@ -583,7 +584,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 if let Some(drop_def_id) = adt_def.destructor() {\n                     drop.push((drop_def_id, Value::ByVal(PrimVal::from_ptr(adt_ptr)), substs));\n                 }\n-                let layout = self.type_layout(ty);\n+                let layout = self.type_layout(ty)?;\n                 let fields = match *layout {\n                     Layout::Univariant { ref variant, .. } => {\n                         adt_def.struct_variant().fields.iter().zip(&variant.offsets)\n@@ -630,7 +631,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 )?;\n             },\n             ty::TyTuple(fields) => {\n-                let offsets = match *self.type_layout(ty) {\n+                let offsets = match *self.type_layout(ty)? {\n                     Layout::Univariant { ref variant, .. } => &variant.offsets,\n                     _ => bug!(\"tuples must be univariant\"),\n                 };\n@@ -658,7 +659,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len) } => (ptr, len as isize),\n                     _ => bug!(\"expected an lvalue with a length\"),\n                 };\n-                let size = self.type_size(elem_ty).expect(\"slice element must be sized\") as isize;\n+                let size = self.type_size(elem_ty)?.expect(\"slice element must be sized\") as isize;\n                 // FIXME: this creates a lot of stack frames if the element type has\n                 // a drop impl\n                 for i in 0..len {\n@@ -671,7 +672,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Lvalue::Ptr { ptr, extra } => (ptr, extra),\n                     _ => bug!(\"expected an lvalue with optional extra data\"),\n                 };\n-                let size = self.type_size(elem_ty).expect(\"array element cannot be unsized\") as isize;\n+                let size = self.type_size(elem_ty)?.expect(\"array element cannot be unsized\") as isize;\n                 // FIXME: this creates a lot of stack frames if the element type has\n                 // a drop impl\n                 for i in 0..len {"}, {"sha": "920e57a1f3413528a352d9af5d27e92e22361e98", "filename": "src/interpreter/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b632d553e8c4590ea349a54254d9aacaea0f543/src%2Finterpreter%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b632d553e8c4590ea349a54254d9aacaea0f543/src%2Finterpreter%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fvtable.rs?ref=0b632d553e8c4590ea349a54254d9aacaea0f543", "patch": "@@ -80,8 +80,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n         }).collect();\n \n-        let size = self.type_size(trait_ref.self_ty()).expect(\"can't create a vtable for an unsized type\");\n-        let align = self.type_align(trait_ref.self_ty());\n+        let size = self.type_size(trait_ref.self_ty())?.expect(\"can't create a vtable for an unsized type\");\n+        let align = self.type_align(trait_ref.self_ty())?;\n \n         let ptr_size = self.memory.pointer_size();\n         let vtable = self.memory.allocate(ptr_size * (3 + methods.len()), ptr_size)?;"}, {"sha": "af10ce4352ccc5244fabbe3fa354efc97b823629", "filename": "src/memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b632d553e8c4590ea349a54254d9aacaea0f543/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b632d553e8c4590ea349a54254d9aacaea0f543/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=0b632d553e8c4590ea349a54254d9aacaea0f543", "patch": "@@ -212,7 +212,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         if ptr.points_to_zst() {\n             return self.allocate(new_size, align);\n         }\n-        if self.get(ptr.alloc_id).map(|alloc| alloc.immutable) == Ok(true) {\n+        if self.get(ptr.alloc_id).map(|alloc| alloc.immutable).ok() == Some(true) {\n             return Err(EvalError::ReallocatedFrozenMemory);\n         }\n \n@@ -245,7 +245,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             // TODO(solson): Report error about non-__rust_allocate'd pointer.\n             return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n         }\n-        if self.get(ptr.alloc_id).map(|alloc| alloc.immutable) == Ok(true) {\n+        if self.get(ptr.alloc_id).map(|alloc| alloc.immutable).ok() == Some(true) {\n             return Err(EvalError::DeallocatedFrozenMemory);\n         }\n "}, {"sha": "70d26a68592201d6f310d576a28f991c351a3553", "filename": "tests/compile-fail/repeat.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b632d553e8c4590ea349a54254d9aacaea0f543/tests%2Fcompile-fail%2Frepeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b632d553e8c4590ea349a54254d9aacaea0f543/tests%2Fcompile-fail%2Frepeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Frepeat.rs?ref=0b632d553e8c4590ea349a54254d9aacaea0f543", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let data: [u8; std::isize::MAX as usize] = [42; std::isize::MAX as usize];\n+    //~^ ERROR: rustc layout computation failed: SizeOverflow([u8;\n+    assert_eq!(data.len(), 1024);\n+}"}, {"sha": "d489342b8599c3a8efa64ab86bb7e1897e9867b7", "filename": "tests/compile-fail/repeat2.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b632d553e8c4590ea349a54254d9aacaea0f543/tests%2Fcompile-fail%2Frepeat2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b632d553e8c4590ea349a54254d9aacaea0f543/tests%2Fcompile-fail%2Frepeat2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Frepeat2.rs?ref=0b632d553e8c4590ea349a54254d9aacaea0f543", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let data: [u8; 1024*1024*1024] = [42; 1024*1024*1024];\n+    //~^ ERROR: reached the configured maximum execution time\n+    assert_eq!(data.len(), 1024*1024*1024);\n+}"}]}