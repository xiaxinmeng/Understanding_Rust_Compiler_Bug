{"sha": "397c235086cfaf5247d971c1867a38640895e014", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5N2MyMzUwODZjZmFmNTI0N2Q5NzFjMTg2N2EzODY0MDg5NWUwMTQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-11-07T18:08:11Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-11-07T18:08:11Z"}, "message": "Use cached module scopes for completion", "tree": {"sha": "b5cc87077735886edc078cd9747fe9bbe3f28768", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5cc87077735886edc078cd9747fe9bbe3f28768"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/397c235086cfaf5247d971c1867a38640895e014", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/397c235086cfaf5247d971c1867a38640895e014", "html_url": "https://github.com/rust-lang/rust/commit/397c235086cfaf5247d971c1867a38640895e014", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/397c235086cfaf5247d971c1867a38640895e014/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b88ec488b3f83ab718c8cb4d7dff95aff0113ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b88ec488b3f83ab718c8cb4d7dff95aff0113ed", "html_url": "https://github.com/rust-lang/rust/commit/9b88ec488b3f83ab718c8cb4d7dff95aff0113ed"}], "stats": {"total": 122, "additions": 71, "deletions": 51}, "files": [{"sha": "2e082705ea62651c676695154487fac5df90d023", "filename": "crates/ra_analysis/src/completion/mod.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/397c235086cfaf5247d971c1867a38640895e014/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397c235086cfaf5247d971c1867a38640895e014/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs?ref=397c235086cfaf5247d971c1867a38640895e014", "patch": "@@ -2,6 +2,7 @@ mod reference_completion;\n \n use ra_editor::find_node_at_offset;\n use ra_syntax::{\n+    algo::find_leaf_at_offset,\n     algo::visit::{visitor_ctx, VisitorCtx},\n     ast,\n     AstNode, AtomEdit,\n@@ -11,6 +12,8 @@ use rustc_hash::{FxHashMap};\n \n use crate::{\n     db::{self, SyntaxDatabase},\n+    descriptors::{DescriptorDatabase, module::ModuleSource},\n+    input::{FilesDatabase},\n     Cancelable, FilePosition\n };\n \n@@ -35,12 +38,32 @@ pub(crate) fn completions(\n         original_file.reparse(&edit)\n     };\n \n+    let leaf = match find_leaf_at_offset(original_file.syntax(), position.offset).left_biased() {\n+        None => return Ok(None),\n+        Some(it) => it,\n+    };\n+    let source_root_id = db.file_source_root(position.file_id);\n+    let module_tree = db.module_tree(source_root_id)?;\n+    let module_source = ModuleSource::for_node(position.file_id, leaf);\n+    let module_id = match module_tree.any_module_for_source(module_source) {\n+        None => return Ok(None),\n+        Some(it) => it,\n+    };\n+\n     let mut res = Vec::new();\n     let mut has_completions = false;\n     // First, let's try to complete a reference to some declaration.\n     if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(file.syntax(), position.offset) {\n         has_completions = true;\n-        reference_completion::completions(&mut res, db, position.file_id, &file, name_ref)?;\n+        reference_completion::completions(\n+            &mut res,\n+            db,\n+            source_root_id,\n+            &module_tree,\n+            module_id,\n+            &file,\n+            name_ref,\n+        )?;\n         // special case, `trait T { fn foo(i_am_a_name_ref) {} }`\n         if is_node::<ast::Param>(name_ref.syntax()) {\n             param_completions(name_ref.syntax(), &mut res);"}, {"sha": "13d4de9d5a707734ca364f87d31614663897de2f", "filename": "crates/ra_analysis/src/completion/reference_completion.rs", "status": "modified", "additions": 30, "deletions": 48, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/397c235086cfaf5247d971c1867a38640895e014/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397c235086cfaf5247d971c1867a38640895e014/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs?ref=397c235086cfaf5247d971c1867a38640895e014", "patch": "@@ -3,39 +3,45 @@ use ra_editor::find_node_at_offset;\n use ra_syntax::{\n     algo::visit::{visitor, Visitor},\n     SourceFileNode, AstNode,\n-    ast::{self, AstChildren, ModuleItemOwner, LoopBodyOwner},\n+    ast::{self, LoopBodyOwner},\n     SyntaxKind::*,\n };\n \n use crate::{\n     db::RootDatabase,\n-    input::FilesDatabase,\n+    input::{SourceRootId},\n     completion::CompletionItem,\n-    descriptors::module::{ModuleId, ModuleScope, ModuleTree, ModuleSource},\n+    descriptors::module::{ModuleId, ModuleScope, ModuleTree},\n     descriptors::function::FnScopes,\n     descriptors::DescriptorDatabase,\n-    FileId, Cancelable\n+    Cancelable\n };\n \n pub(super) fn completions(\n     acc: &mut Vec<CompletionItem>,\n     db: &RootDatabase,\n-    file_id: FileId,\n+    source_root_id: SourceRootId,\n+    module_tree: &ModuleTree,\n+    module_id: ModuleId,\n     file: &SourceFileNode,\n     name_ref: ast::NameRef,\n ) -> Cancelable<()> {\n     let kind = match classify_name_ref(name_ref) {\n         Some(it) => it,\n         None => return Ok(()),\n     };\n+\n     match kind {\n         NameRefKind::LocalRef => {\n-            if let Some(fn_def) = complete_local_name(acc, &file, name_ref) {\n+            let module_scope = db.module_scope(source_root_id, module_id)?;\n+            if let Some(fn_def) = complete_local_name(acc, &module_scope, name_ref) {\n                 complete_expr_keywords(&file, fn_def, name_ref, acc);\n                 complete_expr_snippets(acc);\n             }\n         }\n-        NameRefKind::CratePath(path) => complete_path(acc, db, file_id, path)?,\n+        NameRefKind::CratePath(path) => {\n+            complete_path(acc, db, source_root_id, module_tree, module_id, path)?\n+        }\n         NameRefKind::BareIdentInMod => {\n             let name_range = name_ref.syntax().range();\n             let top_node = name_ref\n@@ -107,52 +113,34 @@ fn crate_path(mut path: ast::Path) -> Option<Vec<ast::NameRef>> {\n \n fn complete_local_name<'a>(\n     acc: &mut Vec<CompletionItem>,\n-    file: &SourceFileNode,\n+    module_scope: &ModuleScope,\n     name_ref: ast::NameRef<'a>,\n ) -> Option<ast::FnDef<'a>> {\n-    let mut enclosing_fn = None;\n-    for node in name_ref.syntax().ancestors() {\n-        if let Some(items) = visitor()\n-            .visit::<ast::SourceFile, _>(|it| Some(it.items()))\n-            .visit::<ast::Module, _>(|it| Some(it.item_list()?.items()))\n-            .accept(node)\n-        {\n-            if let Some(items) = items {\n-                complete_module_items(file, items, Some(name_ref), acc);\n-            }\n-            break;\n-        } else if enclosing_fn.is_none() {\n-            if let Some(fn_def) = ast::FnDef::cast(node) {\n-                enclosing_fn = Some(fn_def);\n-                let scopes = FnScopes::new(fn_def);\n-                complete_fn(name_ref, &scopes, acc);\n-            }\n-        }\n+    let enclosing_fn = name_ref\n+        .syntax()\n+        .ancestors()\n+        .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n+        .find_map(ast::FnDef::cast);\n+    if let Some(fn_def) = enclosing_fn {\n+        let scopes = FnScopes::new(fn_def);\n+        complete_fn(name_ref, &scopes, acc);\n     }\n-    enclosing_fn\n-}\n \n-fn complete_module_items(\n-    file: &SourceFileNode,\n-    items: AstChildren<ast::ModuleItem>,\n-    this_item: Option<ast::NameRef>,\n-    acc: &mut Vec<CompletionItem>,\n-) {\n-    let scope = ModuleScope::new(items); // FIXME\n     acc.extend(\n-        scope\n+        module_scope\n             .entries()\n             .iter()\n             .filter(|entry| {\n-                let syntax = entry.ptr().resolve(file);\n-                Some(syntax.borrowed()) != this_item.map(|it| it.syntax())\n+                // Don't expose this item\n+                !entry.ptr().range().is_subrange(&name_ref.syntax().range())\n             })\n             .map(|entry| CompletionItem {\n                 label: entry.name().to_string(),\n                 lookup: None,\n                 snippet: None,\n             }),\n     );\n+    enclosing_fn\n }\n \n fn complete_fn(name_ref: ast::NameRef, scopes: &FnScopes, acc: &mut Vec<CompletionItem>) {\n@@ -180,16 +168,12 @@ fn complete_fn(name_ref: ast::NameRef, scopes: &FnScopes, acc: &mut Vec<Completi\n fn complete_path(\n     acc: &mut Vec<CompletionItem>,\n     db: &RootDatabase,\n-    file_id: FileId,\n+    source_root_id: SourceRootId,\n+    module_tree: &ModuleTree,\n+    module_id: ModuleId,\n     crate_path: Vec<ast::NameRef>,\n ) -> Cancelable<()> {\n-    let source_root_id = db.file_source_root(file_id);\n-    let module_tree = db.module_tree(source_root_id)?;\n-    let module_id = match module_tree.any_module_for_source(ModuleSource::SourceFile(file_id)) {\n-        None => return Ok(()),\n-        Some(it) => it,\n-    };\n-    let target_module_id = match find_target_module(&module_tree, module_id, crate_path) {\n+    let target_module_id = match find_target_module(module_tree, module_id, crate_path) {\n         None => return Ok(()),\n         Some(it) => it,\n     };\n@@ -327,5 +311,3 @@ fn complete_expr_snippets(acc: &mut Vec<CompletionItem>) {\n         snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\".to_string()),\n     });\n }\n-\n-"}, {"sha": "bc1148b22842c5b6852461f33501c1cec9050658", "filename": "crates/ra_analysis/src/descriptors/module/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/397c235086cfaf5247d971c1867a38640895e014/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397c235086cfaf5247d971c1867a38640895e014/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs?ref=397c235086cfaf5247d971c1867a38640895e014", "patch": "@@ -3,7 +3,7 @@ pub(crate) mod scope;\n \n use ra_syntax::{\n     ast::{self, AstNode, NameOwner},\n-    SmolStr, SyntaxNode,\n+    SmolStr, SyntaxNode, SyntaxNodeRef,\n };\n use relative_path::RelativePathBuf;\n \n@@ -154,6 +154,16 @@ struct ModuleData {\n }\n \n impl ModuleSource {\n+    pub(crate) fn for_node(file_id: FileId, node: SyntaxNodeRef) -> ModuleSource {\n+        for node in node.ancestors() {\n+            if let Some(m) = ast::Module::cast(node) {\n+                if !m.has_semi() {\n+                    return ModuleSource::new_inline(file_id, m);\n+                }\n+            }\n+        }\n+        ModuleSource::SourceFile(file_id)\n+    }\n     pub(crate) fn new_inline(file_id: FileId, module: ast::Module) -> ModuleSource {\n         assert!(!module.has_semi());\n         let ptr = SyntaxPtr::new(file_id, module.syntax());"}, {"sha": "4490228e41aa6ba4ba202a58cb190e6d33e9a78b", "filename": "crates/ra_analysis/src/descriptors/module/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/397c235086cfaf5247d971c1867a38640895e014/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397c235086cfaf5247d971c1867a38640895e014/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fscope.rs?ref=397c235086cfaf5247d971c1867a38640895e014", "patch": "@@ -25,7 +25,7 @@ enum EntryKind {\n }\n \n impl ModuleScope {\n-    pub(crate) fn new<'a>(items: impl Iterator<Item = ast::ModuleItem<'a>>) -> ModuleScope {\n+    pub(super) fn new<'a>(items: impl Iterator<Item = ast::ModuleItem<'a>>) -> ModuleScope {\n         let mut entries = Vec::new();\n         for item in items {\n             let entry = match item {"}, {"sha": "194b94584d11eb70f08684b783f0f0a2d614d19a", "filename": "crates/ra_analysis/src/syntax_ptr.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/397c235086cfaf5247d971c1867a38640895e014/crates%2Fra_analysis%2Fsrc%2Fsyntax_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397c235086cfaf5247d971c1867a38640895e014/crates%2Fra_analysis%2Fsrc%2Fsyntax_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fsyntax_ptr.rs?ref=397c235086cfaf5247d971c1867a38640895e014", "patch": "@@ -62,6 +62,11 @@ impl LocalSyntaxPtr {\n             local: self,\n         }\n     }\n+\n+    // Seems unfortunate to expose\n+    pub(crate) fn range(self) -> TextRange {\n+        self.range\n+    }\n }\n \n #[test]"}]}