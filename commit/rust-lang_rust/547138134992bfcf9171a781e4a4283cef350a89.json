{"sha": "547138134992bfcf9171a781e4a4283cef350a89", "node_id": "C_kwDOAAsO6NoAKDU0NzEzODEzNDk5MmJmY2Y5MTcxYTc4MWU0YTQyODNjZWYzNTBhODk", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-03-22T20:45:32Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-11-29T18:40:59Z"}, "message": "Allow to set a query's result as a side effect.", "tree": {"sha": "7051e08624b1e4c33d7381352eefe9827a60e05f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7051e08624b1e4c33d7381352eefe9827a60e05f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/547138134992bfcf9171a781e4a4283cef350a89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/547138134992bfcf9171a781e4a4283cef350a89", "html_url": "https://github.com/rust-lang/rust/commit/547138134992bfcf9171a781e4a4283cef350a89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/547138134992bfcf9171a781e4a4283cef350a89/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca42dd67167575daa95a9f3c0d084d44f6c2ad2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca42dd67167575daa95a9f3c0d084d44f6c2ad2a", "html_url": "https://github.com/rust-lang/rust/commit/ca42dd67167575daa95a9f3c0d084d44f6c2ad2a"}], "stats": {"total": 172, "additions": 171, "deletions": 1}, "files": [{"sha": "30c42757dbe8c9f5c21d3c6a346c93180d23b6b5", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/547138134992bfcf9171a781e4a4283cef350a89/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/547138134992bfcf9171a781e4a4283cef350a89/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=547138134992bfcf9171a781e4a4283cef350a89", "patch": "@@ -114,6 +114,9 @@ struct QueryModifiers {\n \n     /// Always remap the ParamEnv's constness before hashing.\n     remap_env_constness: Option<Ident>,\n+\n+    /// Generate a `feed` method to set the query's value from another query.\n+    feedable: Option<Ident>,\n }\n \n fn parse_query_modifiers(input: ParseStream<'_>) -> Result<QueryModifiers> {\n@@ -128,6 +131,7 @@ fn parse_query_modifiers(input: ParseStream<'_>) -> Result<QueryModifiers> {\n     let mut depth_limit = None;\n     let mut separate_provide_extern = None;\n     let mut remap_env_constness = None;\n+    let mut feedable = None;\n \n     while !input.is_empty() {\n         let modifier: Ident = input.parse()?;\n@@ -187,6 +191,8 @@ fn parse_query_modifiers(input: ParseStream<'_>) -> Result<QueryModifiers> {\n             try_insert!(separate_provide_extern = modifier);\n         } else if modifier == \"remap_env_constness\" {\n             try_insert!(remap_env_constness = modifier);\n+        } else if modifier == \"feedable\" {\n+            try_insert!(feedable = modifier);\n         } else {\n             return Err(Error::new(modifier.span(), \"unknown query modifier\"));\n         }\n@@ -206,6 +212,7 @@ fn parse_query_modifiers(input: ParseStream<'_>) -> Result<QueryModifiers> {\n         depth_limit,\n         separate_provide_extern,\n         remap_env_constness,\n+        feedable,\n     })\n }\n \n@@ -296,6 +303,7 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n     let mut query_stream = quote! {};\n     let mut query_description_stream = quote! {};\n     let mut query_cached_stream = quote! {};\n+    let mut feedable_queries = quote! {};\n \n     for query in queries.0 {\n         let Query { name, arg, modifiers, .. } = &query;\n@@ -350,6 +358,13 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n             [#attribute_stream] fn #name(#arg) #result,\n         });\n \n+        if modifiers.feedable.is_some() {\n+            feedable_queries.extend(quote! {\n+                #(#doc_comments)*\n+                [#attribute_stream] fn #name(#arg) #result,\n+            });\n+        }\n+\n         add_query_desc_cached_impl(&query, &mut query_description_stream, &mut query_cached_stream);\n     }\n \n@@ -363,7 +378,11 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                 }\n             }\n         }\n-\n+        macro_rules! rustc_feedable_queries {\n+            ( $macro:ident! ) => {\n+                $macro!(#feedable_queries);\n+            }\n+        }\n         pub mod descs {\n             use super::*;\n             #query_description_stream"}, {"sha": "f94fc34ec4786e4c2ee9dae05063c9b78dde736a", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/547138134992bfcf9171a781e4a4283cef350a89/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/547138134992bfcf9171a781e4a4283cef350a89/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=547138134992bfcf9171a781e4a4283cef350a89", "patch": "@@ -165,6 +165,7 @@ rustc_queries! {\n         }\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n+        feedable\n     }\n \n     query collect_trait_impl_trait_tys(key: DefId)"}, {"sha": "f44039879a6132c46901df331b863172b04295dd", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/547138134992bfcf9171a781e4a4283cef350a89/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/547138134992bfcf9171a781e4a4283cef350a89/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=547138134992bfcf9171a781e4a4283cef350a89", "patch": "@@ -85,6 +85,11 @@ pub struct TyCtxtEnsure<'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n }\n \n+#[derive(Copy, Clone)]\n+pub struct TyCtxtFeed<'tcx> {\n+    pub tcx: TyCtxt<'tcx>,\n+}\n+\n impl<'tcx> TyCtxt<'tcx> {\n     /// Returns a transparent wrapper for `TyCtxt`, which ensures queries\n     /// are executed instead of just returning their results.\n@@ -93,6 +98,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         TyCtxtEnsure { tcx: self }\n     }\n \n+    /// Returns a transparent wrapper for `TyCtxt`, for setting a result into a query.\n+    #[inline(always)]\n+    pub fn feed(self) -> TyCtxtFeed<'tcx> {\n+        TyCtxtFeed { tcx: self }\n+    }\n+\n     /// Returns a transparent wrapper for `TyCtxt` which uses\n     /// `span` as the location of queries performed through it.\n     #[inline(always)]\n@@ -175,6 +186,18 @@ macro_rules! opt_remap_env_constness {\n     };\n }\n \n+macro_rules! hash_result {\n+    ([]) => {{\n+        Some(dep_graph::hash_result)\n+    }};\n+    ([(no_hash) $($rest:tt)*]) => {{\n+        None\n+    }};\n+    ([$other:tt $($modifiers:tt)*]) => {\n+        hash_result!([$($modifiers)*])\n+    };\n+}\n+\n macro_rules! define_callbacks {\n     (\n      $($(#[$attr:meta])*\n@@ -327,6 +350,50 @@ macro_rules! define_callbacks {\n     };\n }\n \n+macro_rules! define_feedable {\n+    ($($(#[$attr:meta])* [$($modifiers:tt)*] fn $name:ident($($K:tt)*) -> $V:ty,)*) => {\n+        impl<'tcx> TyCtxtFeed<'tcx> {\n+            $($(#[$attr])*\n+            #[inline(always)]\n+            pub fn $name(\n+                self,\n+                key: query_helper_param_ty!($($K)*),\n+                value: $V,\n+            ) -> query_stored::$name<'tcx> {\n+                let key = key.into_query_param();\n+                opt_remap_env_constness!([$($modifiers)*][key]);\n+\n+                let tcx = self.tcx;\n+                let cache = &tcx.query_caches.$name;\n+\n+                let cached = try_get_cached(tcx, cache, &key, copy);\n+\n+                match cached {\n+                    Ok(old) => {\n+                        assert_eq!(\n+                            value, old,\n+                            \"Trying to feed an already recorded value for query {} key={key:?}\",\n+                            stringify!($name),\n+                        );\n+                        return old;\n+                    }\n+                    Err(()) => (),\n+                }\n+\n+                let dep_node = dep_graph::DepNode::construct(tcx, dep_graph::DepKind::$name, &key);\n+                let dep_node_index = tcx.dep_graph.with_feed_task(\n+                    dep_node,\n+                    tcx,\n+                    key,\n+                    &value,\n+                    hash_result!([$($modifiers)*]).unwrap(),\n+                );\n+                cache.complete(key, value, dep_node_index)\n+            })*\n+        }\n+    }\n+}\n+\n // Each of these queries corresponds to a function pointer field in the\n // `Providers` struct for requesting a value of that type, and a method\n // on `tcx: TyCtxt` (and `tcx.at(span)`) for doing that request in a way\n@@ -340,6 +407,7 @@ macro_rules! define_callbacks {\n // as they will raise an fatal error on query cycles instead.\n \n rustc_query_append! { define_callbacks! }\n+rustc_feedable_queries! { define_feedable! }\n \n mod sealed {\n     use super::{DefId, LocalDefId, OwnerId};"}, {"sha": "d3d2ac256601f22a63405a5c3c9060db08c70649", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/547138134992bfcf9171a781e4a4283cef350a89/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/547138134992bfcf9171a781e4a4283cef350a89/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=547138134992bfcf9171a781e4a4283cef350a89", "patch": "@@ -489,6 +489,88 @@ impl<K: DepKind> DepGraph<K> {\n         }\n     }\n \n+    /// Create a node when we force-feed a value into the query cache.\n+    /// This is used to remove cycles during type-checking const generic parameters.\n+    ///\n+    /// As usual in the query system, we consider the current state of the calling query\n+    /// only depends on the list of dependencies up to now.  As a consequence, the value\n+    /// that this query gives us can only depend on those dependencies too.  Therefore,\n+    /// it is sound to use the current dependency set for the created node.\n+    ///\n+    /// During replay, the order of the nodes is relevant in the dependency graph.\n+    /// So the unchanged replay will mark the caller query before trying to mark this one.\n+    /// If there is a change to report, the caller query will be re-executed before this one.\n+    ///\n+    /// FIXME: If the code is changed enough for this node to be marked before requiring the\n+    /// caller's node, we suppose that those changes will be enough to mark this node red and\n+    /// force a recomputation using the \"normal\" way.\n+    pub fn with_feed_task<Ctxt: DepContext<DepKind = K>, A: Debug, R: Debug>(\n+        &self,\n+        node: DepNode<K>,\n+        cx: Ctxt,\n+        key: A,\n+        result: &R,\n+        hash_result: fn(&mut StableHashingContext<'_>, &R) -> Fingerprint,\n+    ) -> DepNodeIndex {\n+        if let Some(data) = self.data.as_ref() {\n+            if let Some(dep_node_index) = self.dep_node_index_of_opt(&node) {\n+                #[cfg(debug_assertions)]\n+                {\n+                    let hashing_timer = cx.profiler().incr_result_hashing();\n+                    let current_fingerprint =\n+                        cx.with_stable_hashing_context(|mut hcx| hash_result(&mut hcx, result));\n+                    hashing_timer.finish_with_query_invocation_id(dep_node_index.into());\n+                    data.current.record_edge(dep_node_index, node, current_fingerprint);\n+                }\n+\n+                return dep_node_index;\n+            }\n+\n+            let mut edges = SmallVec::new();\n+            K::read_deps(|task_deps| match task_deps {\n+                TaskDepsRef::Allow(deps) => edges.extend(deps.lock().reads.iter().copied()),\n+                TaskDepsRef::Ignore | TaskDepsRef::Forbid => {\n+                    panic!(\"Cannot summarize when dependencies are not recorded.\")\n+                }\n+            });\n+\n+            let hashing_timer = cx.profiler().incr_result_hashing();\n+            let current_fingerprint =\n+                cx.with_stable_hashing_context(|mut hcx| hash_result(&mut hcx, result));\n+\n+            let print_status = cfg!(debug_assertions) && cx.sess().opts.unstable_opts.dep_tasks;\n+\n+            // Intern the new `DepNode` with the dependencies up-to-now.\n+            let (dep_node_index, prev_and_color) = data.current.intern_node(\n+                cx.profiler(),\n+                &data.previous,\n+                node,\n+                edges,\n+                Some(current_fingerprint),\n+                print_status,\n+            );\n+\n+            hashing_timer.finish_with_query_invocation_id(dep_node_index.into());\n+\n+            if let Some((prev_index, color)) = prev_and_color {\n+                debug_assert!(\n+                    data.colors.get(prev_index).is_none(),\n+                    \"DepGraph::with_task() - Duplicate DepNodeColor insertion for {key:?}\",\n+                );\n+\n+                data.colors.insert(prev_index, color);\n+            }\n+\n+            dep_node_index\n+        } else {\n+            // Incremental compilation is turned off. We just execute the task\n+            // without tracking. We still provide a dep-node index that uniquely\n+            // identifies the task so that we have a cheap way of referring to\n+            // the query for self-profiling.\n+            self.next_virtual_depnode_index()\n+        }\n+    }\n+\n     #[inline]\n     pub fn dep_node_index_of(&self, dep_node: &DepNode<K>) -> DepNodeIndex {\n         self.dep_node_index_of_opt(dep_node).unwrap()"}]}