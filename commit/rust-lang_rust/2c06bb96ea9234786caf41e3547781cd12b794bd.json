{"sha": "2c06bb96ea9234786caf41e3547781cd12b794bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjMDZiYjk2ZWE5MjM0Nzg2Y2FmNDFlMzU0Nzc4MWNkMTJiNzk0YmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-20T19:48:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-20T19:48:12Z"}, "message": "Auto merge of #28429 - wesleywiser:split_up_lints, r=alexcrichton\n\nThis breaks out some of the lints defined in `librustc_lint/builtin.rs` into two new modules: `unused` for the `UNUSED_*` lints and `bad_style` for the various style related lints as suggested in #22206. `builtin.rs` could probably get broken up more but this is a start.", "tree": {"sha": "83bdb9006022bef607532f3092732fda7d164065", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83bdb9006022bef607532f3092732fda7d164065"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c06bb96ea9234786caf41e3547781cd12b794bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c06bb96ea9234786caf41e3547781cd12b794bd", "html_url": "https://github.com/rust-lang/rust/commit/2c06bb96ea9234786caf41e3547781cd12b794bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c06bb96ea9234786caf41e3547781cd12b794bd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6602b2f1c777e6e563a7bcc920bbd1ee1c4f7eab", "url": "https://api.github.com/repos/rust-lang/rust/commits/6602b2f1c777e6e563a7bcc920bbd1ee1c4f7eab", "html_url": "https://github.com/rust-lang/rust/commit/6602b2f1c777e6e563a7bcc920bbd1ee1c4f7eab"}, {"sha": "974dfe8e313cf70905ccb54c7b16129372a8e709", "url": "https://api.github.com/repos/rust-lang/rust/commits/974dfe8e313cf70905ccb54c7b16129372a8e709", "html_url": "https://github.com/rust-lang/rust/commit/974dfe8e313cf70905ccb54c7b16129372a8e709"}], "stats": {"total": 1658, "additions": 859, "deletions": 799}, "files": [{"sha": "8f57c67069263e93df0fad7cdce4737e801875cd", "filename": "src/librustc_lint/bad_style.rs", "status": "added", "additions": 372, "deletions": 0, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/2c06bb96ea9234786caf41e3547781cd12b794bd/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c06bb96ea9234786caf41e3547781cd12b794bd/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=2c06bb96ea9234786caf41e3547781cd12b794bd", "patch": "@@ -0,0 +1,372 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::def;\n+use middle::def_id::DefId;\n+use middle::ty;\n+use lint::{LateContext, LintContext, LintArray};\n+use lint::{LintPass, LateLintPass};\n+\n+use syntax::ast;\n+use syntax::attr::{self, AttrMetaMethods};\n+use syntax::codemap::Span;\n+\n+use rustc_front::hir;\n+use rustc_front::visit::FnKind;\n+\n+#[derive(PartialEq)]\n+pub enum MethodLateContext {\n+    TraitDefaultImpl,\n+    TraitImpl,\n+    PlainImpl\n+}\n+\n+pub fn method_context(cx: &LateContext, id: ast::NodeId, span: Span) -> MethodLateContext {\n+    match cx.tcx.impl_or_trait_items.borrow().get(&DefId::local(id)) {\n+        None => cx.sess().span_bug(span, \"missing method descriptor?!\"),\n+        Some(item) => match item.container() {\n+            ty::TraitContainer(..) => MethodLateContext::TraitDefaultImpl,\n+            ty::ImplContainer(cid) => {\n+                match cx.tcx.impl_trait_ref(cid) {\n+                    Some(_) => MethodLateContext::TraitImpl,\n+                    None => MethodLateContext::PlainImpl\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    pub NON_CAMEL_CASE_TYPES,\n+    Warn,\n+    \"types, variants, traits and type parameters should have camel case names\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct NonCamelCaseTypes;\n+\n+impl NonCamelCaseTypes {\n+    fn check_case(&self, cx: &LateContext, sort: &str, ident: ast::Ident, span: Span) {\n+        fn is_camel_case(ident: ast::Ident) -> bool {\n+            let ident = ident.name.as_str();\n+            if ident.is_empty() {\n+                return true;\n+            }\n+            let ident = ident.trim_matches('_');\n+\n+            // start with a non-lowercase letter rather than non-uppercase\n+            // ones (some scripts don't have a concept of upper/lowercase)\n+            !ident.is_empty() && !ident.char_at(0).is_lowercase() && !ident.contains('_')\n+        }\n+\n+        fn to_camel_case(s: &str) -> String {\n+            s.split('_').flat_map(|word| word.chars().enumerate().map(|(i, c)|\n+                if i == 0 {\n+                    c.to_uppercase().collect::<String>()\n+                } else {\n+                    c.to_lowercase().collect()\n+                }\n+            )).collect::<Vec<_>>().concat()\n+        }\n+\n+        let s = ident.name.as_str();\n+\n+        if !is_camel_case(ident) {\n+            let c = to_camel_case(&s);\n+            let m = if c.is_empty() {\n+                format!(\"{} `{}` should have a camel case name such as `CamelCase`\", sort, s)\n+            } else {\n+                format!(\"{} `{}` should have a camel case name such as `{}`\", sort, s, c)\n+            };\n+            cx.span_lint(NON_CAMEL_CASE_TYPES, span, &m[..]);\n+        }\n+    }\n+}\n+\n+impl LintPass for NonCamelCaseTypes {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(NON_CAMEL_CASE_TYPES)\n+    }\n+}\n+\n+impl LateLintPass for NonCamelCaseTypes {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n+        let extern_repr_count = it.attrs.iter().filter(|attr| {\n+            attr::find_repr_attrs(cx.tcx.sess.diagnostic(), attr).iter()\n+                .any(|r| r == &attr::ReprExtern)\n+        }).count();\n+        let has_extern_repr = extern_repr_count > 0;\n+\n+        if has_extern_repr {\n+            return;\n+        }\n+\n+        match it.node {\n+            hir::ItemTy(..) | hir::ItemStruct(..) => {\n+                self.check_case(cx, \"type\", it.ident, it.span)\n+            }\n+            hir::ItemTrait(..) => {\n+                self.check_case(cx, \"trait\", it.ident, it.span)\n+            }\n+            hir::ItemEnum(ref enum_definition, _) => {\n+                if has_extern_repr {\n+                    return;\n+                }\n+                self.check_case(cx, \"type\", it.ident, it.span);\n+                for variant in &enum_definition.variants {\n+                    self.check_case(cx, \"variant\", variant.node.name, variant.span);\n+                }\n+            }\n+            _ => ()\n+        }\n+    }\n+\n+    fn check_generics(&mut self, cx: &LateContext, it: &hir::Generics) {\n+        for gen in it.ty_params.iter() {\n+            self.check_case(cx, \"type parameter\", gen.ident, gen.span);\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    pub NON_SNAKE_CASE,\n+    Warn,\n+    \"methods, functions, lifetime parameters and modules should have snake case names\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct NonSnakeCase;\n+\n+impl NonSnakeCase {\n+    fn to_snake_case(mut str: &str) -> String {\n+        let mut words = vec![];\n+        // Preserve leading underscores\n+        str = str.trim_left_matches(|c: char| {\n+            if c == '_' {\n+                words.push(String::new());\n+                true\n+            } else {\n+                false\n+            }\n+        });\n+        for s in str.split('_') {\n+            let mut last_upper = false;\n+            let mut buf = String::new();\n+            if s.is_empty() {\n+                continue;\n+            }\n+            for ch in s.chars() {\n+                if !buf.is_empty() && buf != \"'\"\n+                                   && ch.is_uppercase()\n+                                   && !last_upper {\n+                    words.push(buf);\n+                    buf = String::new();\n+                }\n+                last_upper = ch.is_uppercase();\n+                buf.extend(ch.to_lowercase());\n+            }\n+            words.push(buf);\n+        }\n+        words.join(\"_\")\n+    }\n+\n+    fn check_snake_case(&self, cx: &LateContext, sort: &str, name: &str, span: Option<Span>) {\n+        fn is_snake_case(ident: &str) -> bool {\n+            if ident.is_empty() {\n+                return true;\n+            }\n+            let ident = ident.trim_left_matches('\\'');\n+            let ident = ident.trim_matches('_');\n+\n+            let mut allow_underscore = true;\n+            ident.chars().all(|c| {\n+                allow_underscore = match c {\n+                    '_' if !allow_underscore => return false,\n+                    '_' => false,\n+                    // It would be more obvious to use `c.is_lowercase()`,\n+                    // but some characters do not have a lowercase form\n+                    c if !c.is_uppercase() => true,\n+                    _ => return false,\n+                };\n+                true\n+            })\n+        }\n+\n+        if !is_snake_case(name) {\n+            let sc = NonSnakeCase::to_snake_case(name);\n+            let msg = if sc != name {\n+                format!(\"{} `{}` should have a snake case name such as `{}`\",\n+                        sort, name, sc)\n+            } else {\n+                format!(\"{} `{}` should have a snake case name\",\n+                        sort, name)\n+            };\n+            match span {\n+                Some(span) => cx.span_lint(NON_SNAKE_CASE, span, &msg),\n+                None => cx.lint(NON_SNAKE_CASE, &msg),\n+            }\n+        }\n+    }\n+}\n+\n+impl LintPass for NonSnakeCase {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(NON_SNAKE_CASE)\n+    }\n+}\n+\n+impl LateLintPass for NonSnakeCase {\n+    fn check_crate(&mut self, cx: &LateContext, cr: &hir::Crate) {\n+        let attr_crate_name = cr.attrs.iter().find(|at| at.check_name(\"crate_name\"))\n+                                      .and_then(|at| at.value_str().map(|s| (at, s)));\n+        if let Some(ref name) = cx.tcx.sess.opts.crate_name {\n+            self.check_snake_case(cx, \"crate\", name, None);\n+        } else if let Some((attr, ref name)) = attr_crate_name {\n+            self.check_snake_case(cx, \"crate\", name, Some(attr.span));\n+        }\n+    }\n+\n+    fn check_fn(&mut self, cx: &LateContext,\n+                fk: FnKind, _: &hir::FnDecl,\n+                _: &hir::Block, span: Span, id: ast::NodeId) {\n+        match fk {\n+            FnKind::Method(ident, _, _) => match method_context(cx, id, span) {\n+                MethodLateContext::PlainImpl => {\n+                    self.check_snake_case(cx, \"method\", &ident.name.as_str(), Some(span))\n+                },\n+                MethodLateContext::TraitDefaultImpl => {\n+                    self.check_snake_case(cx, \"trait method\", &ident.name.as_str(), Some(span))\n+                },\n+                _ => (),\n+            },\n+            FnKind::ItemFn(ident, _, _, _, _, _) => {\n+                self.check_snake_case(cx, \"function\", &ident.name.as_str(), Some(span))\n+            },\n+            _ => (),\n+        }\n+    }\n+\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n+        if let hir::ItemMod(_) = it.node {\n+            self.check_snake_case(cx, \"module\", &it.ident.name.as_str(), Some(it.span));\n+        }\n+    }\n+\n+    fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n+        if let hir::MethodTraitItem(_, None) = trait_item.node {\n+            self.check_snake_case(cx, \"trait method\", &trait_item.ident.name.as_str(),\n+                                  Some(trait_item.span));\n+        }\n+    }\n+\n+    fn check_lifetime_def(&mut self, cx: &LateContext, t: &hir::LifetimeDef) {\n+        self.check_snake_case(cx, \"lifetime\", &t.lifetime.name.as_str(),\n+                              Some(t.lifetime.span));\n+    }\n+\n+    fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n+        if let &hir::PatIdent(_, ref path1, _) = &p.node {\n+            let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n+            if let Some(def::DefLocal(_)) = def {\n+                self.check_snake_case(cx, \"variable\", &path1.node.name.as_str(), Some(p.span));\n+            }\n+        }\n+    }\n+\n+    fn check_struct_def(&mut self, cx: &LateContext, s: &hir::StructDef,\n+                        _: ast::Ident, _: &hir::Generics, _: ast::NodeId) {\n+        for sf in &s.fields {\n+            if let hir::StructField_ { kind: hir::NamedField(ident, _), .. } = sf.node {\n+                self.check_snake_case(cx, \"structure field\", &ident.name.as_str(),\n+                                      Some(sf.span));\n+            }\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    pub NON_UPPER_CASE_GLOBALS,\n+    Warn,\n+    \"static constants should have uppercase identifiers\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct NonUpperCaseGlobals;\n+\n+impl NonUpperCaseGlobals {\n+    fn check_upper_case(cx: &LateContext, sort: &str, ident: ast::Ident, span: Span) {\n+        let s = ident.name.as_str();\n+\n+        if s.chars().any(|c| c.is_lowercase()) {\n+            let uc = NonSnakeCase::to_snake_case(&s).to_uppercase();\n+            if uc != &s[..] {\n+                cx.span_lint(NON_UPPER_CASE_GLOBALS, span,\n+                    &format!(\"{} `{}` should have an upper case name such as `{}`\",\n+                             sort, s, uc));\n+            } else {\n+                cx.span_lint(NON_UPPER_CASE_GLOBALS, span,\n+                    &format!(\"{} `{}` should have an upper case name\",\n+                             sort, s));\n+            }\n+        }\n+    }\n+}\n+\n+impl LintPass for NonUpperCaseGlobals {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(NON_UPPER_CASE_GLOBALS)\n+    }\n+}\n+\n+impl LateLintPass for NonUpperCaseGlobals {\n+    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n+        match it.node {\n+            // only check static constants\n+            hir::ItemStatic(_, hir::MutImmutable, _) => {\n+                NonUpperCaseGlobals::check_upper_case(cx, \"static constant\", it.ident, it.span);\n+            }\n+            hir::ItemConst(..) => {\n+                NonUpperCaseGlobals::check_upper_case(cx, \"constant\", it.ident, it.span);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_trait_item(&mut self, cx: &LateContext, ti: &hir::TraitItem) {\n+        match ti.node {\n+            hir::ConstTraitItem(..) => {\n+                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n+                                                      ti.ident, ti.span);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &LateContext, ii: &hir::ImplItem) {\n+        match ii.node {\n+            hir::ConstImplItem(..) => {\n+                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n+                                                      ii.ident, ii.span);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n+        // Lint for constants that look like binding identifiers (#7526)\n+        match (&p.node, cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def())) {\n+            (&hir::PatIdent(_, ref path1, _), Some(def::DefConst(..))) => {\n+                NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\",\n+                                                      path1.node, p.span);\n+            }\n+            _ => {}\n+        }\n+    }\n+}"}, {"sha": "febf8ef6e472520629964ec4a8ec91e6144595da", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 9, "deletions": 795, "changes": 804, "blob_url": "https://github.com/rust-lang/rust/blob/2c06bb96ea9234786caf41e3547781cd12b794bd/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c06bb96ea9234786caf41e3547781cd12b794bd/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=2c06bb96ea9234786caf41e3547781cd12b794bd", "patch": "@@ -28,35 +28,35 @@\n //! Use the former for unit-like structs and the latter for structs with\n //! a `pub fn new()`.\n \n-use metadata::{csearch, decoder};\n-use middle::{cfg, def, infer, pat_util, stability, traits};\n+use metadata::decoder;\n+use middle::{cfg, def, infer, stability, traits};\n use middle::def_id::DefId;\n use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use middle::ty::adjustment;\n use middle::const_eval::{eval_const_expr_partial, ConstVal};\n use middle::const_eval::EvalHint::ExprTypeChecked;\n use rustc::front::map as hir_map;\n-use util::nodemap::{FnvHashMap, FnvHashSet, NodeSet};\n-use lint::{Level, LateContext, EarlyContext, LintContext, LintArray, Lint};\n-use lint::{LintPass, EarlyLintPass, LateLintPass};\n+use util::nodemap::{FnvHashSet, NodeSet};\n+use lint::{Level, LateContext, LintContext, LintArray, Lint};\n+use lint::{LintPass, LateLintPass};\n \n use std::collections::HashSet;\n-use std::collections::hash_map::Entry::{Occupied, Vacant};\n-use std::{cmp, slice};\n+use std::cmp;\n use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n \n use syntax::{abi, ast};\n use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::{self, Span};\n-use syntax::feature_gate::{KNOWN_ATTRIBUTES, AttributeType, emit_feature_err, GateIssue};\n+use syntax::feature_gate::{emit_feature_err, GateIssue};\n use syntax::ast::{TyIs, TyUs, TyI8, TyU8, TyI16, TyU16, TyI32, TyU32, TyI64, TyU64};\n-use syntax::ptr::P;\n \n use rustc_front::hir;\n use rustc_front::visit::{self, FnKind, Visitor};\n use rustc_front::util::is_shift_binop;\n \n+use bad_style::{MethodLateContext, method_context};\n+\n // hardwired lints from librustc\n pub use lint::builtin::*;\n \n@@ -881,652 +881,6 @@ impl LateLintPass for RawPointerDerive {\n     }\n }\n \n-declare_lint! {\n-    UNUSED_ATTRIBUTES,\n-    Warn,\n-    \"detects attributes that were not used by the compiler\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct UnusedAttributes;\n-\n-impl LintPass for UnusedAttributes {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_ATTRIBUTES)\n-    }\n-}\n-\n-impl LateLintPass for UnusedAttributes {\n-    fn check_attribute(&mut self, cx: &LateContext, attr: &ast::Attribute) {\n-        // Note that check_name() marks the attribute as used if it matches.\n-        for &(ref name, ty, _) in KNOWN_ATTRIBUTES {\n-            match ty {\n-                AttributeType::Whitelisted if attr.check_name(name) => {\n-                    break;\n-                },\n-                _ => ()\n-            }\n-        }\n-\n-        let plugin_attributes = cx.sess().plugin_attributes.borrow_mut();\n-        for &(ref name, ty) in plugin_attributes.iter() {\n-            if ty == AttributeType::Whitelisted && attr.check_name(&*name) {\n-                break;\n-            }\n-        }\n-\n-        if !attr::is_used(attr) {\n-            cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");\n-            // Is it a builtin attribute that must be used at the crate level?\n-            let known_crate = KNOWN_ATTRIBUTES.iter().find(|&&(name, ty, _)| {\n-                attr.name() == name &&\n-                ty == AttributeType::CrateLevel\n-            }).is_some();\n-\n-            // Has a plugin registered this attribute as one which must be used at\n-            // the crate level?\n-            let plugin_crate = plugin_attributes.iter()\n-                                                .find(|&&(ref x, t)| {\n-                                                        &*attr.name() == &*x &&\n-                                                        AttributeType::CrateLevel == t\n-                                                    }).is_some();\n-            if  known_crate || plugin_crate {\n-                let msg = match attr.node.style {\n-                    ast::AttrOuter => \"crate-level attribute should be an inner \\\n-                                       attribute: add an exclamation mark: #![foo]\",\n-                    ast::AttrInner => \"crate-level attribute should be in the \\\n-                                       root module\",\n-                };\n-                cx.span_lint(UNUSED_ATTRIBUTES, attr.span, msg);\n-            }\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    pub PATH_STATEMENTS,\n-    Warn,\n-    \"path statements with no effect\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct PathStatements;\n-\n-impl LintPass for PathStatements {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(PATH_STATEMENTS)\n-    }\n-}\n-\n-impl LateLintPass for PathStatements {\n-    fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n-        match s.node {\n-            hir::StmtSemi(ref expr, _) => {\n-                match expr.node {\n-                    hir::ExprPath(..) => cx.span_lint(PATH_STATEMENTS, s.span,\n-                                                      \"path statement with no effect\"),\n-                    _ => ()\n-                }\n-            }\n-            _ => ()\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    pub UNUSED_MUST_USE,\n-    Warn,\n-    \"unused result of a type flagged as #[must_use]\"\n-}\n-\n-declare_lint! {\n-    pub UNUSED_RESULTS,\n-    Allow,\n-    \"unused result of an expression in a statement\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct UnusedResults;\n-\n-impl LintPass for UnusedResults {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_MUST_USE, UNUSED_RESULTS)\n-    }\n-}\n-\n-impl LateLintPass for UnusedResults {\n-    fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n-        let expr = match s.node {\n-            hir::StmtSemi(ref expr, _) => &**expr,\n-            _ => return\n-        };\n-\n-        if let hir::ExprRet(..) = expr.node {\n-            return;\n-        }\n-\n-        let t = cx.tcx.expr_ty(&expr);\n-        let warned = match t.sty {\n-            ty::TyTuple(ref tys) if tys.is_empty() => return,\n-            ty::TyBool => return,\n-            ty::TyStruct(def, _) |\n-            ty::TyEnum(def, _) => {\n-                if def.did.is_local() {\n-                    if let hir_map::NodeItem(it) = cx.tcx.map.get(def.did.node) {\n-                        check_must_use(cx, &it.attrs, s.span)\n-                    } else {\n-                        false\n-                    }\n-                } else {\n-                    let attrs = csearch::get_item_attrs(&cx.sess().cstore, def.did);\n-                    check_must_use(cx, &attrs[..], s.span)\n-                }\n-            }\n-            _ => false,\n-        };\n-        if !warned {\n-            cx.span_lint(UNUSED_RESULTS, s.span, \"unused result\");\n-        }\n-\n-        fn check_must_use(cx: &LateContext, attrs: &[ast::Attribute], sp: Span) -> bool {\n-            for attr in attrs {\n-                if attr.check_name(\"must_use\") {\n-                    let mut msg = \"unused result which must be used\".to_string();\n-                    // check for #[must_use=\"...\"]\n-                    match attr.value_str() {\n-                        None => {}\n-                        Some(s) => {\n-                            msg.push_str(\": \");\n-                            msg.push_str(&s);\n-                        }\n-                    }\n-                    cx.span_lint(UNUSED_MUST_USE, sp, &msg);\n-                    return true;\n-                }\n-            }\n-            false\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    pub NON_CAMEL_CASE_TYPES,\n-    Warn,\n-    \"types, variants, traits and type parameters should have camel case names\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct NonCamelCaseTypes;\n-\n-impl NonCamelCaseTypes {\n-    fn check_case(&self, cx: &LateContext, sort: &str, ident: ast::Ident, span: Span) {\n-        fn is_camel_case(ident: ast::Ident) -> bool {\n-            let ident = ident.name.as_str();\n-            if ident.is_empty() {\n-                return true;\n-            }\n-            let ident = ident.trim_matches('_');\n-\n-            // start with a non-lowercase letter rather than non-uppercase\n-            // ones (some scripts don't have a concept of upper/lowercase)\n-            !ident.is_empty() && !ident.char_at(0).is_lowercase() && !ident.contains('_')\n-        }\n-\n-        fn to_camel_case(s: &str) -> String {\n-            s.split('_').flat_map(|word| word.chars().enumerate().map(|(i, c)|\n-                if i == 0 {\n-                    c.to_uppercase().collect::<String>()\n-                } else {\n-                    c.to_lowercase().collect()\n-                }\n-            )).collect::<Vec<_>>().concat()\n-        }\n-\n-        let s = ident.name.as_str();\n-\n-        if !is_camel_case(ident) {\n-            let c = to_camel_case(&s);\n-            let m = if c.is_empty() {\n-                format!(\"{} `{}` should have a camel case name such as `CamelCase`\", sort, s)\n-            } else {\n-                format!(\"{} `{}` should have a camel case name such as `{}`\", sort, s, c)\n-            };\n-            cx.span_lint(NON_CAMEL_CASE_TYPES, span, &m[..]);\n-        }\n-    }\n-}\n-\n-impl LintPass for NonCamelCaseTypes {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(NON_CAMEL_CASE_TYPES)\n-    }\n-}\n-\n-impl LateLintPass for NonCamelCaseTypes {\n-    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n-        let extern_repr_count = it.attrs.iter().filter(|attr| {\n-            attr::find_repr_attrs(cx.tcx.sess.diagnostic(), attr).iter()\n-                .any(|r| r == &attr::ReprExtern)\n-        }).count();\n-        let has_extern_repr = extern_repr_count > 0;\n-\n-        if has_extern_repr {\n-            return;\n-        }\n-\n-        match it.node {\n-            hir::ItemTy(..) | hir::ItemStruct(..) => {\n-                self.check_case(cx, \"type\", it.ident, it.span)\n-            }\n-            hir::ItemTrait(..) => {\n-                self.check_case(cx, \"trait\", it.ident, it.span)\n-            }\n-            hir::ItemEnum(ref enum_definition, _) => {\n-                if has_extern_repr {\n-                    return;\n-                }\n-                self.check_case(cx, \"type\", it.ident, it.span);\n-                for variant in &enum_definition.variants {\n-                    self.check_case(cx, \"variant\", variant.node.name, variant.span);\n-                }\n-            }\n-            _ => ()\n-        }\n-    }\n-\n-    fn check_generics(&mut self, cx: &LateContext, it: &hir::Generics) {\n-        for gen in it.ty_params.iter() {\n-            self.check_case(cx, \"type parameter\", gen.ident, gen.span);\n-        }\n-    }\n-}\n-\n-#[derive(PartialEq)]\n-enum MethodLateContext {\n-    TraitDefaultImpl,\n-    TraitImpl,\n-    PlainImpl\n-}\n-\n-fn method_context(cx: &LateContext, id: ast::NodeId, span: Span) -> MethodLateContext {\n-    match cx.tcx.impl_or_trait_items.borrow().get(&DefId::local(id)) {\n-        None => cx.sess().span_bug(span, \"missing method descriptor?!\"),\n-        Some(item) => match item.container() {\n-            ty::TraitContainer(..) => MethodLateContext::TraitDefaultImpl,\n-            ty::ImplContainer(cid) => {\n-                match cx.tcx.impl_trait_ref(cid) {\n-                    Some(_) => MethodLateContext::TraitImpl,\n-                    None => MethodLateContext::PlainImpl\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    pub NON_SNAKE_CASE,\n-    Warn,\n-    \"methods, functions, lifetime parameters and modules should have snake case names\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct NonSnakeCase;\n-\n-impl NonSnakeCase {\n-    fn to_snake_case(mut str: &str) -> String {\n-        let mut words = vec![];\n-        // Preserve leading underscores\n-        str = str.trim_left_matches(|c: char| {\n-            if c == '_' {\n-                words.push(String::new());\n-                true\n-            } else {\n-                false\n-            }\n-        });\n-        for s in str.split('_') {\n-            let mut last_upper = false;\n-            let mut buf = String::new();\n-            if s.is_empty() {\n-                continue;\n-            }\n-            for ch in s.chars() {\n-                if !buf.is_empty() && buf != \"'\"\n-                                   && ch.is_uppercase()\n-                                   && !last_upper {\n-                    words.push(buf);\n-                    buf = String::new();\n-                }\n-                last_upper = ch.is_uppercase();\n-                buf.extend(ch.to_lowercase());\n-            }\n-            words.push(buf);\n-        }\n-        words.join(\"_\")\n-    }\n-\n-    fn check_snake_case(&self, cx: &LateContext, sort: &str, name: &str, span: Option<Span>) {\n-        fn is_snake_case(ident: &str) -> bool {\n-            if ident.is_empty() {\n-                return true;\n-            }\n-            let ident = ident.trim_left_matches('\\'');\n-            let ident = ident.trim_matches('_');\n-\n-            let mut allow_underscore = true;\n-            ident.chars().all(|c| {\n-                allow_underscore = match c {\n-                    '_' if !allow_underscore => return false,\n-                    '_' => false,\n-                    // It would be more obvious to use `c.is_lowercase()`,\n-                    // but some characters do not have a lowercase form\n-                    c if !c.is_uppercase() => true,\n-                    _ => return false,\n-                };\n-                true\n-            })\n-        }\n-\n-        if !is_snake_case(name) {\n-            let sc = NonSnakeCase::to_snake_case(name);\n-            let msg = if sc != name {\n-                format!(\"{} `{}` should have a snake case name such as `{}`\",\n-                        sort, name, sc)\n-            } else {\n-                format!(\"{} `{}` should have a snake case name\",\n-                        sort, name)\n-            };\n-            match span {\n-                Some(span) => cx.span_lint(NON_SNAKE_CASE, span, &msg),\n-                None => cx.lint(NON_SNAKE_CASE, &msg),\n-            }\n-        }\n-    }\n-}\n-\n-impl LintPass for NonSnakeCase {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(NON_SNAKE_CASE)\n-    }\n-}\n-\n-impl LateLintPass for NonSnakeCase {\n-    fn check_crate(&mut self, cx: &LateContext, cr: &hir::Crate) {\n-        let attr_crate_name = cr.attrs.iter().find(|at| at.check_name(\"crate_name\"))\n-                                      .and_then(|at| at.value_str().map(|s| (at, s)));\n-        if let Some(ref name) = cx.tcx.sess.opts.crate_name {\n-            self.check_snake_case(cx, \"crate\", name, None);\n-        } else if let Some((attr, ref name)) = attr_crate_name {\n-            self.check_snake_case(cx, \"crate\", name, Some(attr.span));\n-        }\n-    }\n-\n-    fn check_fn(&mut self, cx: &LateContext,\n-                fk: FnKind, _: &hir::FnDecl,\n-                _: &hir::Block, span: Span, id: ast::NodeId) {\n-        match fk {\n-            FnKind::Method(ident, _, _) => match method_context(cx, id, span) {\n-                MethodLateContext::PlainImpl => {\n-                    self.check_snake_case(cx, \"method\", &ident.name.as_str(), Some(span))\n-                },\n-                MethodLateContext::TraitDefaultImpl => {\n-                    self.check_snake_case(cx, \"trait method\", &ident.name.as_str(), Some(span))\n-                },\n-                _ => (),\n-            },\n-            FnKind::ItemFn(ident, _, _, _, _, _) => {\n-                self.check_snake_case(cx, \"function\", &ident.name.as_str(), Some(span))\n-            },\n-            _ => (),\n-        }\n-    }\n-\n-    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n-        if let hir::ItemMod(_) = it.node {\n-            self.check_snake_case(cx, \"module\", &it.ident.name.as_str(), Some(it.span));\n-        }\n-    }\n-\n-    fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n-        if let hir::MethodTraitItem(_, None) = trait_item.node {\n-            self.check_snake_case(cx, \"trait method\", &trait_item.ident.name.as_str(),\n-                                  Some(trait_item.span));\n-        }\n-    }\n-\n-    fn check_lifetime_def(&mut self, cx: &LateContext, t: &hir::LifetimeDef) {\n-        self.check_snake_case(cx, \"lifetime\", &t.lifetime.name.as_str(),\n-                              Some(t.lifetime.span));\n-    }\n-\n-    fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n-        if let &hir::PatIdent(_, ref path1, _) = &p.node {\n-            let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n-            if let Some(def::DefLocal(_)) = def {\n-                self.check_snake_case(cx, \"variable\", &path1.node.name.as_str(), Some(p.span));\n-            }\n-        }\n-    }\n-\n-    fn check_struct_def(&mut self, cx: &LateContext, s: &hir::StructDef,\n-                        _: ast::Ident, _: &hir::Generics, _: ast::NodeId) {\n-        for sf in &s.fields {\n-            if let hir::StructField_ { kind: hir::NamedField(ident, _), .. } = sf.node {\n-                self.check_snake_case(cx, \"structure field\", &ident.name.as_str(),\n-                                      Some(sf.span));\n-            }\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    pub NON_UPPER_CASE_GLOBALS,\n-    Warn,\n-    \"static constants should have uppercase identifiers\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct NonUpperCaseGlobals;\n-\n-impl NonUpperCaseGlobals {\n-    fn check_upper_case(cx: &LateContext, sort: &str, ident: ast::Ident, span: Span) {\n-        let s = ident.name.as_str();\n-\n-        if s.chars().any(|c| c.is_lowercase()) {\n-            let uc = NonSnakeCase::to_snake_case(&s).to_uppercase();\n-            if uc != &s[..] {\n-                cx.span_lint(NON_UPPER_CASE_GLOBALS, span,\n-                    &format!(\"{} `{}` should have an upper case name such as `{}`\",\n-                             sort, s, uc));\n-            } else {\n-                cx.span_lint(NON_UPPER_CASE_GLOBALS, span,\n-                    &format!(\"{} `{}` should have an upper case name\",\n-                             sort, s));\n-            }\n-        }\n-    }\n-}\n-\n-impl LintPass for NonUpperCaseGlobals {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(NON_UPPER_CASE_GLOBALS)\n-    }\n-}\n-\n-impl LateLintPass for NonUpperCaseGlobals {\n-    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n-        match it.node {\n-            // only check static constants\n-            hir::ItemStatic(_, hir::MutImmutable, _) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"static constant\", it.ident, it.span);\n-            }\n-            hir::ItemConst(..) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"constant\", it.ident, it.span);\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    fn check_trait_item(&mut self, cx: &LateContext, ti: &hir::TraitItem) {\n-        match ti.node {\n-            hir::ConstTraitItem(..) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n-                                                      ti.ident, ti.span);\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    fn check_impl_item(&mut self, cx: &LateContext, ii: &hir::ImplItem) {\n-        match ii.node {\n-            hir::ConstImplItem(..) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n-                                                      ii.ident, ii.span);\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n-        // Lint for constants that look like binding identifiers (#7526)\n-        match (&p.node, cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def())) {\n-            (&hir::PatIdent(_, ref path1, _), Some(def::DefConst(..))) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\",\n-                                                      path1.node, p.span);\n-            }\n-            _ => {}\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    UNUSED_PARENS,\n-    Warn,\n-    \"`if`, `match`, `while` and `return` do not need parentheses\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct UnusedParens;\n-\n-impl UnusedParens {\n-    fn check_unused_parens_core(&self, cx: &EarlyContext, value: &ast::Expr, msg: &str,\n-                                struct_lit_needs_parens: bool) {\n-        if let ast::ExprParen(ref inner) = value.node {\n-            let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&**inner);\n-            if !necessary {\n-                cx.span_lint(UNUSED_PARENS, value.span,\n-                             &format!(\"unnecessary parentheses around {}\", msg))\n-            }\n-        }\n-\n-        /// Expressions that syntactically contain an \"exterior\" struct\n-        /// literal i.e. not surrounded by any parens or other\n-        /// delimiters, e.g. `X { y: 1 }`, `X { y: 1 }.method()`, `foo\n-        /// == X { y: 1 }` and `X { y: 1 } == foo` all do, but `(X {\n-        /// y: 1 }) == foo` does not.\n-        fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n-            match value.node {\n-                ast::ExprStruct(..) => true,\n-\n-                ast::ExprAssign(ref lhs, ref rhs) |\n-                ast::ExprAssignOp(_, ref lhs, ref rhs) |\n-                ast::ExprBinary(_, ref lhs, ref rhs) => {\n-                    // X { y: 1 } + X { y: 2 }\n-                    contains_exterior_struct_lit(&**lhs) ||\n-                        contains_exterior_struct_lit(&**rhs)\n-                }\n-                ast::ExprUnary(_, ref x) |\n-                ast::ExprCast(ref x, _) |\n-                ast::ExprField(ref x, _) |\n-                ast::ExprTupField(ref x, _) |\n-                ast::ExprIndex(ref x, _) => {\n-                    // &X { y: 1 }, X { y: 1 }.y\n-                    contains_exterior_struct_lit(&**x)\n-                }\n-\n-                ast::ExprMethodCall(_, _, ref exprs) => {\n-                    // X { y: 1 }.bar(...)\n-                    contains_exterior_struct_lit(&*exprs[0])\n-                }\n-\n-                _ => false\n-            }\n-        }\n-    }\n-}\n-\n-impl LintPass for UnusedParens {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_PARENS)\n-    }\n-}\n-\n-impl EarlyLintPass for UnusedParens {\n-    fn check_expr(&mut self, cx: &EarlyContext, e: &ast::Expr) {\n-        let (value, msg, struct_lit_needs_parens) = match e.node {\n-            ast::ExprIf(ref cond, _, _) => (cond, \"`if` condition\", true),\n-            ast::ExprWhile(ref cond, _, _) => (cond, \"`while` condition\", true),\n-            ast::ExprMatch(ref head, _, source) => match source {\n-                ast::MatchSource::Normal => (head, \"`match` head expression\", true),\n-                ast::MatchSource::IfLetDesugar { .. } => (head, \"`if let` head expression\", true),\n-                ast::MatchSource::WhileLetDesugar => (head, \"`while let` head expression\", true),\n-                ast::MatchSource::ForLoopDesugar => (head, \"`for` head expression\", true),\n-            },\n-            ast::ExprRet(Some(ref value)) => (value, \"`return` value\", false),\n-            ast::ExprAssign(_, ref value) => (value, \"assigned value\", false),\n-            ast::ExprAssignOp(_, _, ref value) => (value, \"assigned value\", false),\n-            _ => return\n-        };\n-        self.check_unused_parens_core(cx, &**value, msg, struct_lit_needs_parens);\n-    }\n-\n-    fn check_stmt(&mut self, cx: &EarlyContext, s: &ast::Stmt) {\n-        let (value, msg) = match s.node {\n-            ast::StmtDecl(ref decl, _) => match decl.node {\n-                ast::DeclLocal(ref local) => match local.init {\n-                    Some(ref value) => (value, \"assigned value\"),\n-                    None => return\n-                },\n-                _ => return\n-            },\n-            _ => return\n-        };\n-        self.check_unused_parens_core(cx, &**value, msg, false);\n-    }\n-}\n-\n-declare_lint! {\n-    UNUSED_IMPORT_BRACES,\n-    Allow,\n-    \"unnecessary braces around an imported item\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct UnusedImportBraces;\n-\n-impl LintPass for UnusedImportBraces {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_IMPORT_BRACES)\n-    }\n-}\n-\n-impl LateLintPass for UnusedImportBraces {\n-    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n-        if let hir::ItemUse(ref view_path) = item.node {\n-            if let hir::ViewPathList(_, ref items) = view_path.node {\n-                if items.len() == 1 {\n-                    if let hir::PathListIdent {ref name, ..} = items[0].node {\n-                        let m = format!(\"braces around {} is unnecessary\",\n-                                        name);\n-                        cx.span_lint(UNUSED_IMPORT_BRACES, item.span,\n-                                     &m[..]);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n declare_lint! {\n     NON_SHORTHAND_FIELD_PATTERNS,\n     Warn,\n@@ -1568,33 +922,6 @@ impl LateLintPass for NonShorthandFieldPatterns {\n     }\n }\n \n-declare_lint! {\n-    pub UNUSED_UNSAFE,\n-    Warn,\n-    \"unnecessary use of an `unsafe` block\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct UnusedUnsafe;\n-\n-impl LintPass for UnusedUnsafe {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_UNSAFE)\n-    }\n-}\n-\n-impl LateLintPass for UnusedUnsafe {\n-    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n-        if let hir::ExprBlock(ref blk) = e.node {\n-            // Don't warn about generated blocks, that'll just pollute the output.\n-            if blk.rules == hir::UnsafeBlock(hir::UserProvided) &&\n-                !cx.tcx.used_unsafe.borrow().contains(&blk.id) {\n-                    cx.span_lint(UNUSED_UNSAFE, blk.span, \"unnecessary `unsafe` block\");\n-            }\n-        }\n-    }\n-}\n-\n declare_lint! {\n     UNSAFE_CODE,\n     Allow,\n@@ -1658,119 +985,6 @@ impl LateLintPass for UnsafeCode {\n     }\n }\n \n-declare_lint! {\n-    pub UNUSED_MUT,\n-    Warn,\n-    \"detect mut variables which don't need to be mutable\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct UnusedMut;\n-\n-impl UnusedMut {\n-    fn check_unused_mut_pat(&self, cx: &LateContext, pats: &[P<hir::Pat>]) {\n-        // collect all mutable pattern and group their NodeIDs by their Identifier to\n-        // avoid false warnings in match arms with multiple patterns\n-\n-        let mut mutables = FnvHashMap();\n-        for p in pats {\n-            pat_util::pat_bindings(&cx.tcx.def_map, p, |mode, id, _, path1| {\n-                let ident = path1.node;\n-                if let hir::BindByValue(hir::MutMutable) = mode {\n-                    if !ident.name.as_str().starts_with(\"_\") {\n-                        match mutables.entry(ident.name.usize()) {\n-                            Vacant(entry) => { entry.insert(vec![id]); },\n-                            Occupied(mut entry) => { entry.get_mut().push(id); },\n-                        }\n-                    }\n-                }\n-            });\n-        }\n-\n-        let used_mutables = cx.tcx.used_mut_nodes.borrow();\n-        for (_, v) in &mutables {\n-            if !v.iter().any(|e| used_mutables.contains(e)) {\n-                cx.span_lint(UNUSED_MUT, cx.tcx.map.span(v[0]),\n-                             \"variable does not need to be mutable\");\n-            }\n-        }\n-    }\n-}\n-\n-impl LintPass for UnusedMut {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_MUT)\n-    }\n-}\n-\n-impl LateLintPass for UnusedMut {\n-    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n-        if let hir::ExprMatch(_, ref arms, _) = e.node {\n-            for a in arms {\n-                self.check_unused_mut_pat(cx, &a.pats)\n-            }\n-        }\n-    }\n-\n-    fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n-        if let hir::StmtDecl(ref d, _) = s.node {\n-            if let hir::DeclLocal(ref l) = d.node {\n-                self.check_unused_mut_pat(cx, slice::ref_slice(&l.pat));\n-            }\n-        }\n-    }\n-\n-    fn check_fn(&mut self, cx: &LateContext,\n-                _: FnKind, decl: &hir::FnDecl,\n-                _: &hir::Block, _: Span, _: ast::NodeId) {\n-        for a in &decl.inputs {\n-            self.check_unused_mut_pat(cx, slice::ref_slice(&a.pat));\n-        }\n-    }\n-}\n-\n-declare_lint! {\n-    UNUSED_ALLOCATION,\n-    Warn,\n-    \"detects unnecessary allocations that can be eliminated\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct UnusedAllocation;\n-\n-impl LintPass for UnusedAllocation {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_ALLOCATION)\n-    }\n-}\n-\n-impl LateLintPass for UnusedAllocation {\n-    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n-        match e.node {\n-            hir::ExprUnary(hir::UnUniq, _) => (),\n-            _ => return\n-        }\n-\n-        if let Some(adjustment) = cx.tcx.tables.borrow().adjustments.get(&e.id) {\n-            if let adjustment::AdjustDerefRef(adjustment::AutoDerefRef {\n-                ref autoref, ..\n-            }) = *adjustment {\n-                match autoref {\n-                    &Some(adjustment::AutoPtr(_, hir::MutImmutable)) => {\n-                        cx.span_lint(UNUSED_ALLOCATION, e.span,\n-                                     \"unnecessary allocation, use & instead\");\n-                    }\n-                    &Some(adjustment::AutoPtr(_, hir::MutMutable)) => {\n-                        cx.span_lint(UNUSED_ALLOCATION, e.span,\n-                                     \"unnecessary allocation, use &mut instead\");\n-                    }\n-                    _ => ()\n-                }\n-            }\n-        }\n-    }\n-}\n-\n declare_lint! {\n     MISSING_DOCS,\n     Allow,"}, {"sha": "674631cd3a5ee3dcbe3977cbccd9b154240685dc", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2c06bb96ea9234786caf41e3547781cd12b794bd/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c06bb96ea9234786caf41e3547781cd12b794bd/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=2c06bb96ea9234786caf41e3547781cd12b794bd", "patch": "@@ -58,7 +58,13 @@ pub use rustc::util as util;\n use session::Session;\n use lint::LintId;\n \n+mod bad_style;\n mod builtin;\n+mod unused;\n+\n+use bad_style::*;\n+use builtin::*;\n+use unused::*;\n \n /// Tell the `LintStore` about all the built-in lints (the ones\n /// defined in this crate and the ones defined in\n@@ -67,30 +73,30 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n     macro_rules! add_builtin {\n         ($sess:ident, $($name:ident),*,) => (\n             {$(\n-                store.register_late_pass($sess, false, box builtin::$name);\n+                store.register_late_pass($sess, false, box $name);\n                 )*}\n             )\n     }\n \n     macro_rules! add_early_builtin {\n         ($sess:ident, $($name:ident),*,) => (\n             {$(\n-                store.register_early_pass($sess, false, box builtin::$name);\n+                store.register_early_pass($sess, false, box $name);\n                 )*}\n             )\n     }\n \n     macro_rules! add_builtin_with_new {\n         ($sess:ident, $($name:ident),*,) => (\n             {$(\n-                store.register_late_pass($sess, false, box builtin::$name::new());\n+                store.register_late_pass($sess, false, box $name::new());\n                 )*}\n             )\n     }\n \n     macro_rules! add_lint_group {\n         ($sess:ident, $name:expr, $($lint:ident),*) => (\n-            store.register_group($sess, false, $name, vec![$(LintId::of(builtin::$lint)),*]);\n+            store.register_group($sess, false, $name, vec![$(LintId::of($lint)),*]);\n             )\n     }\n "}, {"sha": "6df32f53d81307267a89904e5ae2ae6f2c05b0e2", "filename": "src/librustc_lint/unused.rs", "status": "added", "additions": 468, "deletions": 0, "changes": 468, "blob_url": "https://github.com/rust-lang/rust/blob/2c06bb96ea9234786caf41e3547781cd12b794bd/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c06bb96ea9234786caf41e3547781cd12b794bd/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=2c06bb96ea9234786caf41e3547781cd12b794bd", "patch": "@@ -0,0 +1,468 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use metadata::csearch;\n+use middle::pat_util;\n+use middle::ty;\n+use middle::ty::adjustment;\n+use rustc::front::map as hir_map;\n+use util::nodemap::FnvHashMap;\n+use lint::{LateContext, EarlyContext, LintContext, LintArray};\n+use lint::{LintPass, EarlyLintPass, LateLintPass};\n+\n+use std::collections::hash_map::Entry::{Occupied, Vacant};\n+use std::slice;\n+\n+use syntax::ast;\n+use syntax::attr::{self, AttrMetaMethods};\n+use syntax::codemap::Span;\n+use syntax::feature_gate::{KNOWN_ATTRIBUTES, AttributeType};\n+use syntax::ptr::P;\n+\n+use rustc_front::hir;\n+\n+use rustc_front::visit::FnKind;\n+\n+declare_lint! {\n+    pub UNUSED_MUT,\n+    Warn,\n+    \"detect mut variables which don't need to be mutable\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct UnusedMut;\n+\n+impl UnusedMut {\n+    fn check_unused_mut_pat(&self, cx: &LateContext, pats: &[P<hir::Pat>]) {\n+        // collect all mutable pattern and group their NodeIDs by their Identifier to\n+        // avoid false warnings in match arms with multiple patterns\n+\n+        let mut mutables = FnvHashMap();\n+        for p in pats {\n+            pat_util::pat_bindings(&cx.tcx.def_map, p, |mode, id, _, path1| {\n+                let ident = path1.node;\n+                if let hir::BindByValue(hir::MutMutable) = mode {\n+                    if !ident.name.as_str().starts_with(\"_\") {\n+                        match mutables.entry(ident.name.usize()) {\n+                            Vacant(entry) => { entry.insert(vec![id]); },\n+                            Occupied(mut entry) => { entry.get_mut().push(id); },\n+                        }\n+                    }\n+                }\n+            });\n+        }\n+\n+        let used_mutables = cx.tcx.used_mut_nodes.borrow();\n+        for (_, v) in &mutables {\n+            if !v.iter().any(|e| used_mutables.contains(e)) {\n+                cx.span_lint(UNUSED_MUT, cx.tcx.map.span(v[0]),\n+                             \"variable does not need to be mutable\");\n+            }\n+        }\n+    }\n+}\n+\n+impl LintPass for UnusedMut {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_MUT)\n+    }\n+}\n+\n+impl LateLintPass for UnusedMut {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n+        if let hir::ExprMatch(_, ref arms, _) = e.node {\n+            for a in arms {\n+                self.check_unused_mut_pat(cx, &a.pats)\n+            }\n+        }\n+    }\n+\n+    fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n+        if let hir::StmtDecl(ref d, _) = s.node {\n+            if let hir::DeclLocal(ref l) = d.node {\n+                self.check_unused_mut_pat(cx, slice::ref_slice(&l.pat));\n+            }\n+        }\n+    }\n+\n+    fn check_fn(&mut self, cx: &LateContext,\n+                _: FnKind, decl: &hir::FnDecl,\n+                _: &hir::Block, _: Span, _: ast::NodeId) {\n+        for a in &decl.inputs {\n+            self.check_unused_mut_pat(cx, slice::ref_slice(&a.pat));\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    pub UNUSED_MUST_USE,\n+    Warn,\n+    \"unused result of a type flagged as #[must_use]\"\n+}\n+\n+declare_lint! {\n+    pub UNUSED_RESULTS,\n+    Allow,\n+    \"unused result of an expression in a statement\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct UnusedResults;\n+\n+impl LintPass for UnusedResults {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_MUST_USE, UNUSED_RESULTS)\n+    }\n+}\n+\n+impl LateLintPass for UnusedResults {\n+    fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n+        let expr = match s.node {\n+            hir::StmtSemi(ref expr, _) => &**expr,\n+            _ => return\n+        };\n+\n+        if let hir::ExprRet(..) = expr.node {\n+            return;\n+        }\n+\n+        let t = cx.tcx.expr_ty(&expr);\n+        let warned = match t.sty {\n+            ty::TyTuple(ref tys) if tys.is_empty() => return,\n+            ty::TyBool => return,\n+            ty::TyStruct(def, _) |\n+            ty::TyEnum(def, _) => {\n+                if def.did.is_local() {\n+                    if let hir_map::NodeItem(it) = cx.tcx.map.get(def.did.node) {\n+                        check_must_use(cx, &it.attrs, s.span)\n+                    } else {\n+                        false\n+                    }\n+                } else {\n+                    let attrs = csearch::get_item_attrs(&cx.sess().cstore, def.did);\n+                    check_must_use(cx, &attrs[..], s.span)\n+                }\n+            }\n+            _ => false,\n+        };\n+        if !warned {\n+            cx.span_lint(UNUSED_RESULTS, s.span, \"unused result\");\n+        }\n+\n+        fn check_must_use(cx: &LateContext, attrs: &[ast::Attribute], sp: Span) -> bool {\n+            for attr in attrs {\n+                if attr.check_name(\"must_use\") {\n+                    let mut msg = \"unused result which must be used\".to_string();\n+                    // check for #[must_use=\"...\"]\n+                    match attr.value_str() {\n+                        None => {}\n+                        Some(s) => {\n+                            msg.push_str(\": \");\n+                            msg.push_str(&s);\n+                        }\n+                    }\n+                    cx.span_lint(UNUSED_MUST_USE, sp, &msg);\n+                    return true;\n+                }\n+            }\n+            false\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    pub UNUSED_UNSAFE,\n+    Warn,\n+    \"unnecessary use of an `unsafe` block\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct UnusedUnsafe;\n+\n+impl LintPass for UnusedUnsafe {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_UNSAFE)\n+    }\n+}\n+\n+impl LateLintPass for UnusedUnsafe {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n+        if let hir::ExprBlock(ref blk) = e.node {\n+            // Don't warn about generated blocks, that'll just pollute the output.\n+            if blk.rules == hir::UnsafeBlock(hir::UserProvided) &&\n+                !cx.tcx.used_unsafe.borrow().contains(&blk.id) {\n+                    cx.span_lint(UNUSED_UNSAFE, blk.span, \"unnecessary `unsafe` block\");\n+            }\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    pub PATH_STATEMENTS,\n+    Warn,\n+    \"path statements with no effect\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct PathStatements;\n+\n+impl LintPass for PathStatements {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(PATH_STATEMENTS)\n+    }\n+}\n+\n+impl LateLintPass for PathStatements {\n+    fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n+        match s.node {\n+            hir::StmtSemi(ref expr, _) => {\n+                match expr.node {\n+                    hir::ExprPath(..) => cx.span_lint(PATH_STATEMENTS, s.span,\n+                                                      \"path statement with no effect\"),\n+                    _ => ()\n+                }\n+            }\n+            _ => ()\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    UNUSED_ATTRIBUTES,\n+    Warn,\n+    \"detects attributes that were not used by the compiler\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct UnusedAttributes;\n+\n+impl LintPass for UnusedAttributes {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_ATTRIBUTES)\n+    }\n+}\n+\n+impl LateLintPass for UnusedAttributes {\n+    fn check_attribute(&mut self, cx: &LateContext, attr: &ast::Attribute) {\n+        // Note that check_name() marks the attribute as used if it matches.\n+        for &(ref name, ty, _) in KNOWN_ATTRIBUTES {\n+            match ty {\n+                AttributeType::Whitelisted if attr.check_name(name) => {\n+                    break;\n+                },\n+                _ => ()\n+            }\n+        }\n+\n+        let plugin_attributes = cx.sess().plugin_attributes.borrow_mut();\n+        for &(ref name, ty) in plugin_attributes.iter() {\n+            if ty == AttributeType::Whitelisted && attr.check_name(&*name) {\n+                break;\n+            }\n+        }\n+\n+        if !attr::is_used(attr) {\n+            cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");\n+            // Is it a builtin attribute that must be used at the crate level?\n+            let known_crate = KNOWN_ATTRIBUTES.iter().find(|&&(name, ty, _)| {\n+                attr.name() == name &&\n+                ty == AttributeType::CrateLevel\n+            }).is_some();\n+\n+            // Has a plugin registered this attribute as one which must be used at\n+            // the crate level?\n+            let plugin_crate = plugin_attributes.iter()\n+                                                .find(|&&(ref x, t)| {\n+                                                        &*attr.name() == &*x &&\n+                                                        AttributeType::CrateLevel == t\n+                                                    }).is_some();\n+            if  known_crate || plugin_crate {\n+                let msg = match attr.node.style {\n+                    ast::AttrOuter => \"crate-level attribute should be an inner \\\n+                                       attribute: add an exclamation mark: #![foo]\",\n+                    ast::AttrInner => \"crate-level attribute should be in the \\\n+                                       root module\",\n+                };\n+                cx.span_lint(UNUSED_ATTRIBUTES, attr.span, msg);\n+            }\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    UNUSED_PARENS,\n+    Warn,\n+    \"`if`, `match`, `while` and `return` do not need parentheses\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct UnusedParens;\n+\n+impl UnusedParens {\n+    fn check_unused_parens_core(&self, cx: &EarlyContext, value: &ast::Expr, msg: &str,\n+                                struct_lit_needs_parens: bool) {\n+        if let ast::ExprParen(ref inner) = value.node {\n+            let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&**inner);\n+            if !necessary {\n+                cx.span_lint(UNUSED_PARENS, value.span,\n+                             &format!(\"unnecessary parentheses around {}\", msg))\n+            }\n+        }\n+\n+        /// Expressions that syntactically contain an \"exterior\" struct\n+        /// literal i.e. not surrounded by any parens or other\n+        /// delimiters, e.g. `X { y: 1 }`, `X { y: 1 }.method()`, `foo\n+        /// == X { y: 1 }` and `X { y: 1 } == foo` all do, but `(X {\n+        /// y: 1 }) == foo` does not.\n+        fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n+            match value.node {\n+                ast::ExprStruct(..) => true,\n+\n+                ast::ExprAssign(ref lhs, ref rhs) |\n+                ast::ExprAssignOp(_, ref lhs, ref rhs) |\n+                ast::ExprBinary(_, ref lhs, ref rhs) => {\n+                    // X { y: 1 } + X { y: 2 }\n+                    contains_exterior_struct_lit(&**lhs) ||\n+                        contains_exterior_struct_lit(&**rhs)\n+                }\n+                ast::ExprUnary(_, ref x) |\n+                ast::ExprCast(ref x, _) |\n+                ast::ExprField(ref x, _) |\n+                ast::ExprTupField(ref x, _) |\n+                ast::ExprIndex(ref x, _) => {\n+                    // &X { y: 1 }, X { y: 1 }.y\n+                    contains_exterior_struct_lit(&**x)\n+                }\n+\n+                ast::ExprMethodCall(_, _, ref exprs) => {\n+                    // X { y: 1 }.bar(...)\n+                    contains_exterior_struct_lit(&*exprs[0])\n+                }\n+\n+                _ => false\n+            }\n+        }\n+    }\n+}\n+\n+impl LintPass for UnusedParens {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_PARENS)\n+    }\n+}\n+\n+impl EarlyLintPass for UnusedParens {\n+    fn check_expr(&mut self, cx: &EarlyContext, e: &ast::Expr) {\n+        let (value, msg, struct_lit_needs_parens) = match e.node {\n+            ast::ExprIf(ref cond, _, _) => (cond, \"`if` condition\", true),\n+            ast::ExprWhile(ref cond, _, _) => (cond, \"`while` condition\", true),\n+            ast::ExprMatch(ref head, _, source) => match source {\n+                ast::MatchSource::Normal => (head, \"`match` head expression\", true),\n+                ast::MatchSource::IfLetDesugar { .. } => (head, \"`if let` head expression\", true),\n+                ast::MatchSource::WhileLetDesugar => (head, \"`while let` head expression\", true),\n+                ast::MatchSource::ForLoopDesugar => (head, \"`for` head expression\", true),\n+            },\n+            ast::ExprRet(Some(ref value)) => (value, \"`return` value\", false),\n+            ast::ExprAssign(_, ref value) => (value, \"assigned value\", false),\n+            ast::ExprAssignOp(_, _, ref value) => (value, \"assigned value\", false),\n+            _ => return\n+        };\n+        self.check_unused_parens_core(cx, &**value, msg, struct_lit_needs_parens);\n+    }\n+\n+    fn check_stmt(&mut self, cx: &EarlyContext, s: &ast::Stmt) {\n+        let (value, msg) = match s.node {\n+            ast::StmtDecl(ref decl, _) => match decl.node {\n+                ast::DeclLocal(ref local) => match local.init {\n+                    Some(ref value) => (value, \"assigned value\"),\n+                    None => return\n+                },\n+                _ => return\n+            },\n+            _ => return\n+        };\n+        self.check_unused_parens_core(cx, &**value, msg, false);\n+    }\n+}\n+\n+declare_lint! {\n+    UNUSED_IMPORT_BRACES,\n+    Allow,\n+    \"unnecessary braces around an imported item\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct UnusedImportBraces;\n+\n+impl LintPass for UnusedImportBraces {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_IMPORT_BRACES)\n+    }\n+}\n+\n+impl LateLintPass for UnusedImportBraces {\n+    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n+        if let hir::ItemUse(ref view_path) = item.node {\n+            if let hir::ViewPathList(_, ref items) = view_path.node {\n+                if items.len() == 1 {\n+                    if let hir::PathListIdent {ref name, ..} = items[0].node {\n+                        let m = format!(\"braces around {} is unnecessary\",\n+                                        name);\n+                        cx.span_lint(UNUSED_IMPORT_BRACES, item.span,\n+                                     &m[..]);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    UNUSED_ALLOCATION,\n+    Warn,\n+    \"detects unnecessary allocations that can be eliminated\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct UnusedAllocation;\n+\n+impl LintPass for UnusedAllocation {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNUSED_ALLOCATION)\n+    }\n+}\n+\n+impl LateLintPass for UnusedAllocation {\n+    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n+        match e.node {\n+            hir::ExprUnary(hir::UnUniq, _) => (),\n+            _ => return\n+        }\n+\n+        if let Some(adjustment) = cx.tcx.tables.borrow().adjustments.get(&e.id) {\n+            if let adjustment::AdjustDerefRef(adjustment::AutoDerefRef {\n+                ref autoref, ..\n+            }) = *adjustment {\n+                match autoref {\n+                    &Some(adjustment::AutoPtr(_, hir::MutImmutable)) => {\n+                        cx.span_lint(UNUSED_ALLOCATION, e.span,\n+                                     \"unnecessary allocation, use & instead\");\n+                    }\n+                    &Some(adjustment::AutoPtr(_, hir::MutMutable)) => {\n+                        cx.span_lint(UNUSED_ALLOCATION, e.span,\n+                                     \"unnecessary allocation, use &mut instead\");\n+                    }\n+                    _ => ()\n+                }\n+            }\n+        }\n+    }\n+}\n+"}]}