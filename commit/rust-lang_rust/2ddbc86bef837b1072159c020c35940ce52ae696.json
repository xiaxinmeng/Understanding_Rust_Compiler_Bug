{"sha": "2ddbc86bef837b1072159c020c35940ce52ae696", "node_id": "C_kwDOAAsO6NoAKDJkZGJjODZiZWY4MzdiMTA3MjE1OWMwMjBjMzU5NDBjZTUyYWU2OTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-14T15:58:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-14T15:58:21Z"}, "message": "Auto merge of #8518 - Alexendoo:write-late-pass, r=flip1995\n\nMigrate write.rs to a late pass\n\nchangelog: Migrates write.rs from a pre expansion pass to a late pass\nchangelog: [`positional_named_format_parameters`] is renamed in favour of the rustc lint `named_arguments_used_positionally`\n\n- Macros are now identified by diagnostic items, so will no longer lint user defined macros named, e.g. a custom `print!`\n- `print_literal`/`write_literal` no longer lint no longer lint literals that come from macro expansions, e.g. `env!(\"FOO\")`\n- `print_with_newline`/`write_with_newline` no longer lint strings with any internal `\\r` or `\\n`s\n\n~~A false negative, `print_literal`/`write_literal` don't lint format strings that produce `FormatSpec`s, e.g. ones containing pretty print/width/align specifiers~~\n\nSuggestion changes:\n- ~~`print_literal`/`write_literal` no longer have suggestions, as the spans for the `{}`s were not easily obtainable~~\n-  `print_with_newline`/`write_with_newline` has a better suggestion for a sole literal newline, but no longer has suggestions for len > 1 strings that end in a literal newline\n- ~~`use_debug` spans are less precise, now point to the whole format string~~\n\nThe diff for write.rs is pretty unwieldy, other than for the `declare_clippy_lint!`s I think you'd be better off viewing it as a brand new file rather than looking at the diff, as it's mostly written from scratch\n\ncc #6610, fixes #5721, fixes #7195, fixes #8615", "tree": {"sha": "72e4ae3bf5c333d05e259deae907b63f0e5d6436", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72e4ae3bf5c333d05e259deae907b63f0e5d6436"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ddbc86bef837b1072159c020c35940ce52ae696", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ddbc86bef837b1072159c020c35940ce52ae696", "html_url": "https://github.com/rust-lang/rust/commit/2ddbc86bef837b1072159c020c35940ce52ae696", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ddbc86bef837b1072159c020c35940ce52ae696/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c9aa928980ca651a75801b90d814a8fb598ed0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c9aa928980ca651a75801b90d814a8fb598ed0a", "html_url": "https://github.com/rust-lang/rust/commit/9c9aa928980ca651a75801b90d814a8fb598ed0a"}, {"sha": "6fc6d87fd069470893b6a539a46fa1e2f10ae906", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fc6d87fd069470893b6a539a46fa1e2f10ae906", "html_url": "https://github.com/rust-lang/rust/commit/6fc6d87fd069470893b6a539a46fa1e2f10ae906"}], "stats": {"total": 1862, "additions": 554, "deletions": 1308}, "files": [{"sha": "f10d825695360c39ebcc22a05a1a69a1653680e7", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -71,12 +71,12 @@ impl<'tcx> LateLintPass<'tcx> for UselessFormat {\n             let value = arg.param.value;\n             if_chain! {\n                 if format_args.format_string.parts == [kw::Empty];\n+                if arg.format.is_default();\n                 if match cx.typeck_results().expr_ty(value).peel_refs().kind() {\n                     ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(sym::String, adt.did()),\n                     ty::Str => true,\n                     _ => false,\n                 };\n-                if !arg.format.has_string_formatting();\n                 then {\n                     let is_new_string = match value.kind {\n                         ExprKind::Binary(..) => true,"}, {"sha": "e1c46fd0bfd4f4eeeb8867c4159ff027ab7a182f", "filename": "clippy_lints/src/format_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/clippy_lints%2Fsrc%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/clippy_lints%2Fsrc%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_args.rs?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -77,7 +77,7 @@ impl<'tcx> LateLintPass<'tcx> for FormatArgs {\n             if let ExpnKind::Macro(_, name) = outermost_expn_data.kind;\n             then {\n                 for arg in &format_args.args {\n-                    if arg.format.has_string_formatting() {\n+                    if !arg.format.is_default() {\n                         continue;\n                     }\n                     if is_aliased(&format_args, arg.param.value.hir_id) {"}, {"sha": "39ab175341f41e19ef76a349dac6c97c940d6bc0", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -352,7 +352,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(useless_conversion::USELESS_CONVERSION),\n     LintId::of(vec::USELESS_VEC),\n     LintId::of(vec_init_then_push::VEC_INIT_THEN_PUSH),\n-    LintId::of(write::POSITIONAL_NAMED_FORMAT_PARAMETERS),\n     LintId::of(write::PRINTLN_EMPTY_STRING),\n     LintId::of(write::PRINT_LITERAL),\n     LintId::of(write::PRINT_WITH_NEWLINE),"}, {"sha": "c16f2d86ae0acf85fca4a2c79198e22402e2ef91", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -595,7 +595,6 @@ store.register_lints(&[\n     vec_init_then_push::VEC_INIT_THEN_PUSH,\n     wildcard_imports::ENUM_GLOB_USE,\n     wildcard_imports::WILDCARD_IMPORTS,\n-    write::POSITIONAL_NAMED_FORMAT_PARAMETERS,\n     write::PRINTLN_EMPTY_STRING,\n     write::PRINT_LITERAL,\n     write::PRINT_STDERR,"}, {"sha": "f463ad9f6d2e2c395e5a082695a04ac78124fa8b", "filename": "clippy_lints/src/lib.register_suspicious.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_suspicious.rs?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -36,5 +36,4 @@ store.register_group(true, \"clippy::suspicious\", Some(\"clippy_suspicious\"), vec!\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),\n     LintId::of(swap_ptr_to_ref::SWAP_PTR_TO_REF),\n     LintId::of(unused_peekable::UNUSED_PEEKABLE),\n-    LintId::of(write::POSITIONAL_NAMED_FORMAT_PARAMETERS),\n ])"}, {"sha": "83fdc15c9f02c32198168eeb930864758a7cbf6a", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -40,7 +40,6 @@ extern crate rustc_lint;\n extern crate rustc_middle;\n extern crate rustc_mir_dataflow;\n extern crate rustc_parse;\n-extern crate rustc_parse_format;\n extern crate rustc_session;\n extern crate rustc_span;\n extern crate rustc_target;\n@@ -425,7 +424,6 @@ pub fn register_pre_expansion_lints(store: &mut rustc_lint::LintStore, sess: &Se\n         })\n     });\n \n-    store.register_pre_expansion_pass(|| Box::new(write::Write::default()));\n     store.register_pre_expansion_pass(move || Box::new(attrs::EarlyAttributes { msrv }));\n }\n \n@@ -879,6 +877,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n             ignore_publish: cargo_ignore_publish,\n         })\n     });\n+    store.register_late_pass(|| Box::new(write::Write::default()));\n     store.register_early_pass(|| Box::new(crate_in_macro_def::CrateInMacroDef));\n     store.register_early_pass(|| Box::new(empty_structs_with_brackets::EmptyStructsWithBrackets));\n     store.register_late_pass(|| Box::new(unnecessary_owned_empty_strings::UnnecessaryOwnedEmptyStrings));"}, {"sha": "d320eea1c377d3d9284ee85a1beb49eccb0cbca1", "filename": "clippy_lints/src/renamed_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/clippy_lints%2Fsrc%2Frenamed_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/clippy_lints%2Fsrc%2Frenamed_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Frenamed_lints.rs?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -36,6 +36,7 @@ pub static RENAMED_LINTS: &[(&str, &str)] = &[\n     (\"clippy::invalid_ref\", \"invalid_value\"),\n     (\"clippy::mem_discriminant_non_enum\", \"enum_intrinsics_non_enums\"),\n     (\"clippy::panic_params\", \"non_fmt_panics\"),\n+    (\"clippy::positional_named_format_parameters\", \"named_arguments_used_positionally\"),\n     (\"clippy::temporary_cstring_as_ptr\", \"temporary_cstring_as_ptr\"),\n     (\"clippy::unknown_clippy_lints\", \"unknown_lints\"),\n     (\"clippy::unused_label\", \"unused_labels\"),"}, {"sha": "2be3fa99c811cde98fb4eef4f7342429bdefaacb", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -476,7 +476,7 @@ pub fn format_error(error: Box<dyn Error>) -> String {\n \n             let mut msg = String::from(prefix);\n             for row in 0..rows {\n-                write!(msg, \"\\n\").unwrap();\n+                writeln!(msg).unwrap();\n                 for (column, column_width) in column_widths.iter().copied().enumerate() {\n                     let index = column * rows + row;\n                     let field = fields.get(index).copied().unwrap_or_default();"}, {"sha": "06e7d70170171c97c0ffa5292fd738903407f830", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 254, "deletions": 533, "changes": 787, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -1,20 +1,12 @@\n-use std::borrow::Cow;\n-use std::iter;\n-use std::ops::{Deref, Range};\n-\n-use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::source::{snippet, snippet_opt, snippet_with_applicability};\n-use rustc_ast::ast::{Expr, ExprKind, Impl, Item, ItemKind, MacCall, Path, StrLit, StrStyle};\n-use rustc_ast::ptr::P;\n-use rustc_ast::token::{self, LitKind};\n-use rustc_ast::tokenstream::TokenStream;\n-use rustc_errors::{Applicability, DiagnosticBuilder};\n-use rustc_lexer::unescape::{self, EscapeError};\n-use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n-use rustc_parse::parser;\n+use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n+use clippy_utils::macros::{root_macro_call_first_node, FormatArgsExpn, MacroCall};\n+use clippy_utils::source::snippet_opt;\n+use rustc_ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, HirIdMap, Impl, Item, ItemKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::symbol::{kw, Symbol};\n-use rustc_span::{sym, BytePos, InnerSpan, Span, DUMMY_SP};\n+use rustc_span::{sym, BytePos, Span};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -74,13 +66,7 @@ declare_clippy_lint! {\n     /// application and might forget to remove those prints afterward.\n     ///\n     /// ### Known problems\n-    /// * Only catches `print!` and `println!` calls.\n-    /// * The lint level is unaffected by crate attributes. The level can still\n-    ///   be set for functions, modules and other items. To change the level for\n-    ///   the entire crate, please use command line flags. More information and a\n-    ///   configuration example can be found in [clippy#6610].\n-    ///\n-    /// [clippy#6610]: https://github.com/rust-lang/rust-clippy/issues/6610#issuecomment-977120558\n+    /// Only catches `print!` and `println!` calls.\n     ///\n     /// ### Example\n     /// ```rust\n@@ -102,13 +88,7 @@ declare_clippy_lint! {\n     /// application and might forget to remove those prints afterward.\n     ///\n     /// ### Known problems\n-    /// * Only catches `eprint!` and `eprintln!` calls.\n-    /// * The lint level is unaffected by crate attributes. The level can still\n-    ///   be set for functions, modules and other items. To change the level for\n-    ///   the entire crate, please use command line flags. More information and a\n-    ///   configuration example can be found in [clippy#6610].\n-    ///\n-    /// [clippy#6610]: https://github.com/rust-lang/rust-clippy/issues/6610#issuecomment-977120558\n+    /// Only catches `eprint!` and `eprintln!` calls.\n     ///\n     /// ### Example\n     /// ```rust\n@@ -149,10 +129,6 @@ declare_clippy_lint! {\n     /// (c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary\n     /// (i.e., just put the literal in the format string)\n     ///\n-    /// ### Known problems\n-    /// Will also warn with macro calls as arguments that expand to literals\n-    /// -- e.g., `println!(\"{}\", env!(\"FOO\"))`.\n-    ///\n     /// ### Example\n     /// ```rust\n     /// println!(\"{}\", \"foo\");\n@@ -234,10 +210,6 @@ declare_clippy_lint! {\n     /// (c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary\n     /// (i.e., just put the literal in the format string)\n     ///\n-    /// ### Known problems\n-    /// Will also warn with macro calls as arguments that expand to literals\n-    /// -- e.g., `writeln!(buf, \"{}\", env!(\"FOO\"))`.\n-    ///\n     /// ### Example\n     /// ```rust\n     /// # use std::fmt::Write;\n@@ -257,28 +229,6 @@ declare_clippy_lint! {\n     \"writing a literal with a format string\"\n }\n \n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// This lint warns when a named parameter in a format string is used as a positional one.\n-    ///\n-    /// ### Why is this bad?\n-    /// It may be confused for an assignment and obfuscates which parameter is being used.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// println!(\"{}\", x = 10);\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// println!(\"{x}\", x = 10);\n-    /// ```\n-    #[clippy::version = \"1.63.0\"]\n-    pub POSITIONAL_NAMED_FORMAT_PARAMETERS,\n-    suspicious,\n-    \"named parameter in a format string is used positionally\"\n-}\n-\n #[derive(Default)]\n pub struct Write {\n     in_debug_impl: bool,\n@@ -294,537 +244,308 @@ impl_lint_pass!(Write => [\n     WRITE_WITH_NEWLINE,\n     WRITELN_EMPTY_STRING,\n     WRITE_LITERAL,\n-    POSITIONAL_NAMED_FORMAT_PARAMETERS,\n ]);\n \n-impl EarlyLintPass for Write {\n-    fn check_item(&mut self, _: &EarlyContext<'_>, item: &Item) {\n-        if let ItemKind::Impl(box Impl {\n-            of_trait: Some(trait_ref),\n-            ..\n-        }) = &item.kind\n-        {\n-            let trait_name = trait_ref\n-                .path\n-                .segments\n-                .iter()\n-                .last()\n-                .expect(\"path has at least one segment\")\n-                .ident\n-                .name;\n-            if trait_name == sym::Debug {\n-                self.in_debug_impl = true;\n-            }\n+impl<'tcx> LateLintPass<'tcx> for Write {\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+        if is_debug_impl(cx, item) {\n+            self.in_debug_impl = true;\n         }\n     }\n \n-    fn check_item_post(&mut self, _: &EarlyContext<'_>, _: &Item) {\n-        self.in_debug_impl = false;\n+    fn check_item_post(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+        if is_debug_impl(cx, item) {\n+            self.in_debug_impl = false;\n+        }\n     }\n \n-    fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &MacCall) {\n-        fn is_build_script(cx: &EarlyContext<'_>) -> bool {\n-            // Cargo sets the crate name for build scripts to `build_script_build`\n-            cx.sess()\n-                .opts\n-                .crate_name\n-                .as_ref()\n-                .map_or(false, |crate_name| crate_name == \"build_script_build\")\n-        }\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        let Some(macro_call) = root_macro_call_first_node(cx, expr) else { return };\n+        let Some(diag_name) = cx.tcx.get_diagnostic_name(macro_call.def_id) else { return };\n+        let Some(name) = diag_name.as_str().strip_suffix(\"_macro\") else { return };\n \n-        if mac.path == sym!(print) {\n-            if !is_build_script(cx) {\n-                span_lint(cx, PRINT_STDOUT, mac.span(), \"use of `print!`\");\n-            }\n-            self.lint_print_with_newline(cx, mac);\n-        } else if mac.path == sym!(println) {\n-            if !is_build_script(cx) {\n-                span_lint(cx, PRINT_STDOUT, mac.span(), \"use of `println!`\");\n-            }\n-            self.lint_println_empty_string(cx, mac);\n-        } else if mac.path == sym!(eprint) {\n-            span_lint(cx, PRINT_STDERR, mac.span(), \"use of `eprint!`\");\n-            self.lint_print_with_newline(cx, mac);\n-        } else if mac.path == sym!(eprintln) {\n-            span_lint(cx, PRINT_STDERR, mac.span(), \"use of `eprintln!`\");\n-            self.lint_println_empty_string(cx, mac);\n-        } else if mac.path == sym!(write) {\n-            if let (Some(fmt_str), dest) = self.check_tts(cx, mac.args.inner_tokens(), true) {\n-                if check_newlines(&fmt_str) {\n-                    let (nl_span, only_nl) = newline_span(&fmt_str);\n-                    let nl_span = match (dest, only_nl) {\n-                        // Special case of `write!(buf, \"\\n\")`: Mark everything from the end of\n-                        // `buf` for removal so no trailing comma [`writeln!(buf, )`] remains.\n-                        (Some(dest_expr), true) => nl_span.with_lo(dest_expr.span.hi()),\n-                        _ => nl_span,\n-                    };\n-                    span_lint_and_then(\n-                        cx,\n-                        WRITE_WITH_NEWLINE,\n-                        mac.span(),\n-                        \"using `write!()` with a format string that ends in a single newline\",\n-                        |err| {\n-                            err.multipart_suggestion(\n-                                \"use `writeln!()` instead\",\n-                                vec![(mac.path.span, String::from(\"writeln\")), (nl_span, String::new())],\n-                                Applicability::MachineApplicable,\n-                            );\n-                        },\n-                    );\n-                }\n-            }\n-        } else if mac.path == sym!(writeln) {\n-            if let (Some(fmt_str), expr) = self.check_tts(cx, mac.args.inner_tokens(), true) {\n-                if fmt_str.symbol == kw::Empty {\n-                    let mut applicability = Applicability::MachineApplicable;\n-                    let suggestion = if let Some(e) = expr {\n-                        snippet_with_applicability(cx, e.span, \"v\", &mut applicability)\n-                    } else {\n-                        applicability = Applicability::HasPlaceholders;\n-                        Cow::Borrowed(\"v\")\n-                    };\n-\n-                    span_lint_and_sugg(\n-                        cx,\n-                        WRITELN_EMPTY_STRING,\n-                        mac.span(),\n-                        format!(\"using `writeln!({}, \\\"\\\")`\", suggestion).as_str(),\n-                        \"replace it with\",\n-                        format!(\"writeln!({})\", suggestion),\n-                        applicability,\n-                    );\n+        let is_build_script = cx\n+            .sess()\n+            .opts\n+            .crate_name\n+            .as_ref()\n+            .map_or(false, |crate_name| crate_name == \"build_script_build\");\n+\n+        match diag_name {\n+            sym::print_macro | sym::println_macro => {\n+                if !is_build_script {\n+                    span_lint(cx, PRINT_STDOUT, macro_call.span, &format!(\"use of `{name}!`\"));\n                 }\n-            }\n+            },\n+            sym::eprint_macro | sym::eprintln_macro => {\n+                span_lint(cx, PRINT_STDERR, macro_call.span, &format!(\"use of `{name}!`\"));\n+            },\n+            sym::write_macro | sym::writeln_macro => {},\n+            _ => return,\n         }\n-    }\n-}\n \n-/// Given a format string that ends in a newline and its span, calculates the span of the\n-/// newline, or the format string itself if the format string consists solely of a newline.\n-/// Return this and a boolean indicating whether it only consisted of a newline.\n-fn newline_span(fmtstr: &StrLit) -> (Span, bool) {\n-    let sp = fmtstr.span;\n-    let contents = fmtstr.symbol.as_str();\n+        let Some(format_args) = FormatArgsExpn::find_nested(cx, expr, macro_call.expn) else { return };\n \n-    if contents == r\"\\n\" {\n-        return (sp, true);\n-    }\n-\n-    let newline_sp_hi = sp.hi()\n-        - match fmtstr.style {\n-            StrStyle::Cooked => BytePos(1),\n-            StrStyle::Raw(hashes) => BytePos((1 + hashes).into()),\n-        };\n+        // ignore `writeln!(w)` and `write!(v, some_macro!())`\n+        if format_args.format_string.span.from_expansion() {\n+            return;\n+        }\n \n-    let newline_sp_len = if contents.ends_with('\\n') {\n-        BytePos(1)\n-    } else if contents.ends_with(r\"\\n\") {\n-        BytePos(2)\n-    } else {\n-        panic!(\"expected format string to contain a newline\");\n-    };\n+        match diag_name {\n+            sym::print_macro | sym::eprint_macro | sym::write_macro => {\n+                check_newline(cx, &format_args, &macro_call, name);\n+            },\n+            sym::println_macro | sym::eprintln_macro | sym::writeln_macro => {\n+                check_empty_string(cx, &format_args, &macro_call, name);\n+            },\n+            _ => {},\n+        }\n \n-    (sp.with_lo(newline_sp_hi - newline_sp_len).with_hi(newline_sp_hi), false)\n-}\n+        check_literal(cx, &format_args, name);\n \n-/// Stores a list of replacement spans for each argument, but only if all the replacements used an\n-/// empty format string.\n-#[derive(Default)]\n-struct SimpleFormatArgs {\n-    unnamed: Vec<Vec<Span>>,\n-    complex_unnamed: Vec<Vec<Span>>,\n-    named: Vec<(Symbol, Vec<Span>)>,\n+        if !self.in_debug_impl {\n+            for arg in &format_args.args {\n+                if arg.format.r#trait == sym::Debug {\n+                    span_lint(cx, USE_DEBUG, arg.span, \"use of `Debug`-based formatting\");\n+                }\n+            }\n+        }\n+    }\n }\n-impl SimpleFormatArgs {\n-    fn get_unnamed(&self) -> impl Iterator<Item = &[Span]> {\n-        self.unnamed.iter().map(|x| match x.as_slice() {\n-            // Ignore the dummy span added from out of order format arguments.\n-            [DUMMY_SP] => &[],\n-            x => x,\n-        })\n+fn is_debug_impl(cx: &LateContext<'_>, item: &Item<'_>) -> bool {\n+    if let ItemKind::Impl(Impl { of_trait: Some(trait_ref), .. }) = &item.kind\n+        && let Some(trait_id) = trait_ref.trait_def_id()\n+    {\n+        cx.tcx.is_diagnostic_item(sym::Debug, trait_id)\n+    } else {\n+        false\n     }\n+}\n \n-    fn get_complex_unnamed(&self) -> impl Iterator<Item = &[Span]> {\n-        self.complex_unnamed.iter().map(Vec::as_slice)\n-    }\n+fn check_newline(cx: &LateContext<'_>, format_args: &FormatArgsExpn<'_>, macro_call: &MacroCall, name: &str) {\n+    let format_string_parts = &format_args.format_string.parts;\n+    let mut format_string_span = format_args.format_string.span;\n \n-    fn get_named(&self, n: &Path) -> &[Span] {\n-        self.named.iter().find(|x| *n == x.0).map_or(&[], |x| x.1.as_slice())\n-    }\n+    let Some(last) = format_string_parts.last() else { return };\n \n-    fn push(&mut self, arg: rustc_parse_format::Argument<'_>, span: Span) {\n-        use rustc_parse_format::{\n-            AlignUnknown, ArgumentImplicitlyIs, ArgumentIs, ArgumentNamed, CountImplied, FormatSpec,\n-        };\n+    let count_vertical_whitespace = || {\n+        format_string_parts\n+            .iter()\n+            .flat_map(|part| part.as_str().chars())\n+            .filter(|ch| matches!(ch, '\\r' | '\\n'))\n+            .count()\n+    };\n \n-        const SIMPLE: FormatSpec<'_> = FormatSpec {\n-            fill: None,\n-            align: AlignUnknown,\n-            flags: 0,\n-            precision: CountImplied,\n-            precision_span: None,\n-            width: CountImplied,\n-            width_span: None,\n-            ty: \"\",\n-            ty_span: None,\n-        };\n+    if last.as_str().ends_with('\\n')\n+        // ignore format strings with other internal vertical whitespace\n+        && count_vertical_whitespace() == 1\n \n-        match arg.position {\n-            ArgumentIs(n) | ArgumentImplicitlyIs(n) => {\n-                if self.unnamed.len() <= n {\n-                    // Use a dummy span to mark all unseen arguments.\n-                    self.unnamed.resize_with(n, || vec![DUMMY_SP]);\n-                    if arg.format == SIMPLE {\n-                        self.unnamed.push(vec![span]);\n-                    } else {\n-                        self.unnamed.push(Vec::new());\n-                    }\n-                } else {\n-                    let args = &mut self.unnamed[n];\n-                    match (args.as_mut_slice(), arg.format == SIMPLE) {\n-                        // A non-empty format string has been seen already.\n-                        ([], _) => (),\n-                        // Replace the dummy span, if it exists.\n-                        ([dummy @ DUMMY_SP], true) => *dummy = span,\n-                        ([_, ..], true) => args.push(span),\n-                        ([_, ..], false) => *args = Vec::new(),\n-                    }\n-                }\n-            },\n-            ArgumentNamed(n) => {\n-                let n = Symbol::intern(n);\n-                if let Some(x) = self.named.iter_mut().find(|x| x.0 == n) {\n-                    match x.1.as_slice() {\n-                        // A non-empty format string has been seen already.\n-                        [] => (),\n-                        [_, ..] if arg.format == SIMPLE => x.1.push(span),\n-                        [_, ..] => x.1 = Vec::new(),\n-                    }\n-                } else if arg.format == SIMPLE {\n-                    self.named.push((n, vec![span]));\n-                } else {\n-                    self.named.push((n, Vec::new()));\n-                }\n-            },\n-        };\n-    }\n+        // ignore trailing arguments: `print!(\"Issue\\n{}\", 1265);`\n+        && format_string_parts.len() > format_args.args.len()\n+    {\n+        let lint = if name == \"write\" {\n+            format_string_span = expand_past_previous_comma(cx, format_string_span);\n \n-    fn push_to_complex(&mut self, span: Span, position: usize) {\n-        if self.complex_unnamed.len() <= position {\n-            self.complex_unnamed.resize_with(position, Vec::new);\n-            self.complex_unnamed.push(vec![span]);\n+            WRITE_WITH_NEWLINE\n         } else {\n-            let args: &mut Vec<Span> = &mut self.complex_unnamed[position];\n-            args.push(span);\n-        }\n-    }\n-\n-    fn push_complex(\n-        &mut self,\n-        cx: &EarlyContext<'_>,\n-        arg: rustc_parse_format::Argument<'_>,\n-        str_lit_span: Span,\n-        fmt_span: Span,\n-    ) {\n-        use rustc_parse_format::{ArgumentImplicitlyIs, ArgumentIs, CountIsParam, CountIsStar};\n-\n-        let snippet = snippet_opt(cx, fmt_span);\n-\n-        let end = snippet\n-            .as_ref()\n-            .and_then(|s| s.find(':'))\n-            .or_else(|| fmt_span.hi().0.checked_sub(fmt_span.lo().0 + 1).map(|u| u as usize));\n-\n-        if let (ArgumentIs(n) | ArgumentImplicitlyIs(n), Some(end)) = (arg.position, end) {\n-            let span = fmt_span.from_inner(InnerSpan::new(1, end));\n-            self.push_to_complex(span, n);\n+            PRINT_WITH_NEWLINE\n         };\n \n-        if let (CountIsParam(n) | CountIsStar(n), Some(span)) = (arg.format.precision, arg.format.precision_span) {\n-            // We need to do this hack as precision spans should be converted from .* to .foo$\n-            let hack = if snippet.as_ref().and_then(|s| s.find('*')).is_some() {\n-                0\n-            } else {\n-                1\n-            };\n+        span_lint_and_then(\n+            cx,\n+            lint,\n+            macro_call.span,\n+            &format!(\"using `{name}!()` with a format string that ends in a single newline\"),\n+            |diag| {\n+                let name_span = cx.sess().source_map().span_until_char(macro_call.span, '!');\n+                let Some(format_snippet) = snippet_opt(cx, format_string_span) else { return };\n+\n+                if format_string_parts.len() == 1 && last.as_str() == \"\\n\" {\n+                    // print!(\"\\n\"), write!(f, \"\\n\")\n+\n+                    diag.multipart_suggestion(\n+                        &format!(\"use `{name}ln!` instead\"),\n+                        vec![(name_span, format!(\"{name}ln\")), (format_string_span, String::new())],\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else if format_snippet.ends_with(\"\\\\n\\\"\") {\n+                    // print!(\"...\\n\"), write!(f, \"...\\n\")\n \n-            let span = str_lit_span.from_inner(InnerSpan {\n-                start: span.start + 1,\n-                end: span.end - hack,\n-            });\n-            self.push_to_complex(span, n);\n-        };\n+                    let hi = format_string_span.hi();\n+                    let newline_span = format_string_span.with_lo(hi - BytePos(3)).with_hi(hi - BytePos(1));\n \n-        if let (CountIsParam(n), Some(span)) = (arg.format.width, arg.format.width_span) {\n-            let span = str_lit_span.from_inner(InnerSpan {\n-                start: span.start,\n-                end: span.end - 1,\n-            });\n-            self.push_to_complex(span, n);\n-        };\n+                    diag.multipart_suggestion(\n+                        &format!(\"use `{name}ln!` instead\"),\n+                        vec![(name_span, format!(\"{name}ln\")), (newline_span, String::new())],\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            },\n+        );\n     }\n }\n \n-impl Write {\n-    /// Parses a format string into a collection of spans for each argument. This only keeps track\n-    /// of empty format arguments. Will also lint usages of debug format strings outside of debug\n-    /// impls.\n-    fn parse_fmt_string(&self, cx: &EarlyContext<'_>, str_lit: &StrLit) -> Option<SimpleFormatArgs> {\n-        use rustc_parse_format::{ParseMode, Parser, Piece};\n-\n-        let str_sym = str_lit.symbol_unescaped.as_str();\n-        let style = match str_lit.style {\n-            StrStyle::Cooked => None,\n-            StrStyle::Raw(n) => Some(n as usize),\n-        };\n-\n-        let mut parser = Parser::new(str_sym, style, snippet_opt(cx, str_lit.span), false, ParseMode::Format);\n-        let mut args = SimpleFormatArgs::default();\n+fn check_empty_string(cx: &LateContext<'_>, format_args: &FormatArgsExpn<'_>, macro_call: &MacroCall, name: &str) {\n+    if let [part] = &format_args.format_string.parts[..]\n+        && let mut span = format_args.format_string.span\n+        && part.as_str() == \"\\n\"\n+    {\n+        let lint = if name == \"writeln\" {\n+            span = expand_past_previous_comma(cx, span);\n \n-        while let Some(arg) = parser.next() {\n-            let arg = match arg {\n-                Piece::String(_) => continue,\n-                Piece::NextArgument(arg) => arg,\n-            };\n-            let span = parser\n-                .arg_places\n-                .last()\n-                .map_or(DUMMY_SP, |&x| str_lit.span.from_inner(InnerSpan::new(x.start, x.end)));\n-\n-            if !self.in_debug_impl && arg.format.ty == \"?\" {\n-                // FIXME: modify rustc's fmt string parser to give us the current span\n-                span_lint(cx, USE_DEBUG, span, \"use of `Debug`-based formatting\");\n-            }\n-            args.push(arg, span);\n-            args.push_complex(cx, arg, str_lit.span, span);\n-        }\n-\n-        parser.errors.is_empty().then_some(args)\n-    }\n-\n-    /// Checks the arguments of `print[ln]!` and `write[ln]!` calls. It will return a tuple of two\n-    /// `Option`s. The first `Option` of the tuple is the macro's format string. It includes\n-    /// the contents of the string, whether it's a raw string, and the span of the literal in the\n-    /// source. The second `Option` in the tuple is, in the `write[ln]!` case, the expression the\n-    /// `format_str` should be written to.\n-    ///\n-    /// Example:\n-    ///\n-    /// Calling this function on\n-    /// ```rust\n-    /// # use std::fmt::Write;\n-    /// # let mut buf = String::new();\n-    /// # let something = \"something\";\n-    /// writeln!(buf, \"string to write: {}\", something);\n-    /// ```\n-    /// will return\n-    /// ```rust,ignore\n-    /// (Some(\"string to write: {}\"), Some(buf))\n-    /// ```\n-    fn check_tts<'a>(&self, cx: &EarlyContext<'a>, tts: TokenStream, is_write: bool) -> (Option<StrLit>, Option<Expr>) {\n-        let mut parser = parser::Parser::new(&cx.sess().parse_sess, tts, false, None);\n-        let expr = if is_write {\n-            match parser\n-                .parse_expr()\n-                .map(rustc_ast::ptr::P::into_inner)\n-                .map_err(DiagnosticBuilder::cancel)\n-            {\n-                // write!(e, ...)\n-                Ok(p) if parser.eat(&token::Comma) => Some(p),\n-                // write!(e) or error\n-                e => return (None, e.ok()),\n-            }\n+            WRITELN_EMPTY_STRING\n         } else {\n-            None\n+            PRINTLN_EMPTY_STRING\n         };\n \n-        let fmtstr = match parser.parse_str_lit() {\n-            Ok(fmtstr) => fmtstr,\n-            Err(_) => return (None, expr),\n-        };\n+        span_lint_and_then(\n+            cx,\n+            lint,\n+            macro_call.span,\n+            &format!(\"empty string literal in `{name}!`\"),\n+            |diag| {\n+                diag.span_suggestion(\n+                    span,\n+                    \"remove the empty string\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                );\n+            },\n+        );\n+    }\n+}\n \n-        let args = match self.parse_fmt_string(cx, &fmtstr) {\n-            Some(args) => args,\n-            None => return (Some(fmtstr), expr),\n-        };\n+fn check_literal(cx: &LateContext<'_>, format_args: &FormatArgsExpn<'_>, name: &str) {\n+    let mut counts = HirIdMap::<usize>::default();\n+    for param in format_args.params() {\n+        *counts.entry(param.value.hir_id).or_default() += 1;\n+    }\n \n-        let lint = if is_write { WRITE_LITERAL } else { PRINT_LITERAL };\n-        let mut unnamed_args = args.get_unnamed();\n-        let mut complex_unnamed_args = args.get_complex_unnamed();\n-        loop {\n-            if !parser.eat(&token::Comma) {\n-                return (Some(fmtstr), expr);\n-            }\n+    for arg in &format_args.args {\n+        let value = arg.param.value;\n \n-            let comma_span = parser.prev_token.span;\n-            let token_expr = if let Ok(expr) = parser.parse_expr().map_err(DiagnosticBuilder::cancel) {\n-                expr\n-            } else {\n-                return (Some(fmtstr), None);\n-            };\n-            let complex_unnamed_arg = complex_unnamed_args.next();\n-\n-            let (fmt_spans, lit) = match &token_expr.kind {\n-                ExprKind::Lit(lit) => (unnamed_args.next().unwrap_or(&[]), lit),\n-                ExprKind::Assign(lhs, rhs, _) => {\n-                    if let Some(span) = complex_unnamed_arg {\n-                        for x in span {\n-                            Self::report_positional_named_param(cx, *x, lhs, rhs);\n-                        }\n-                    }\n-                    match (&lhs.kind, &rhs.kind) {\n-                        (ExprKind::Path(_, p), ExprKind::Lit(lit)) => (args.get_named(p), lit),\n-                        _ => continue,\n+        if counts[&value.hir_id] == 1\n+            && arg.format.is_default()\n+            && let ExprKind::Lit(lit) = &value.kind\n+            && !value.span.from_expansion()\n+            && let Some(value_string) = snippet_opt(cx, value.span)\n+        {\n+            let (replacement, replace_raw) = match lit.node {\n+                LitKind::Str(..) => extract_str_literal(&value_string),\n+                LitKind::Char(ch) => (\n+                    match ch {\n+                        '\"' => \"\\\\\\\"\",\n+                        '\\'' => \"'\",\n+                        _ => &value_string[1..value_string.len() - 1],\n                     }\n-                },\n-                _ => {\n-                    unnamed_args.next();\n-                    continue;\n-                },\n+                    .to_string(),\n+                    false,\n+                ),\n+                LitKind::Bool(b) => (b.to_string(), false),\n+                _ => continue,\n+            };\n+\n+            let lint = if name.starts_with(\"write\") {\n+                WRITE_LITERAL\n+            } else {\n+                PRINT_LITERAL\n             };\n \n-            let replacement: String = match lit.token_lit.kind {\n-                LitKind::StrRaw(_) | LitKind::ByteStrRaw(_) if matches!(fmtstr.style, StrStyle::Raw(_)) => {\n-                    lit.token_lit.symbol.as_str().replace('{', \"{{\").replace('}', \"}}\")\n+            let format_string_is_raw = format_args.format_string.style.is_some();\n+            let replacement = match (format_string_is_raw, replace_raw) {\n+                (false, false) => Some(replacement),\n+                (false, true) => Some(replacement.replace('\"', \"\\\\\\\"\").replace('\\\\', \"\\\\\\\\\")),\n+                (true, false) => match conservative_unescape(&replacement) {\n+                    Ok(unescaped) => Some(unescaped),\n+                    Err(UnescapeErr::Lint) => None,\n+                    Err(UnescapeErr::Ignore) => continue,\n                 },\n-                LitKind::Str | LitKind::ByteStr if matches!(fmtstr.style, StrStyle::Cooked) => {\n-                    lit.token_lit.symbol.as_str().replace('{', \"{{\").replace('}', \"}}\")\n+                (true, true) => {\n+                    if replacement.contains(['#', '\"']) {\n+                        None\n+                    } else {\n+                        Some(replacement)\n+                    }\n                 },\n-                LitKind::StrRaw(_)\n-                | LitKind::Str\n-                | LitKind::ByteStrRaw(_)\n-                | LitKind::ByteStr\n-                | LitKind::Integer\n-                | LitKind::Float\n-                | LitKind::Err => continue,\n-                LitKind::Byte | LitKind::Char => match lit.token_lit.symbol.as_str() {\n-                    \"\\\"\" if matches!(fmtstr.style, StrStyle::Cooked) => \"\\\\\\\"\",\n-                    \"\\\"\" if matches!(fmtstr.style, StrStyle::Raw(0)) => continue,\n-                    \"\\\\\\\\\" if matches!(fmtstr.style, StrStyle::Raw(_)) => \"\\\\\",\n-                    \"\\\\'\" => \"'\",\n-                    \"{\" => \"{{\",\n-                    \"}\" => \"}}\",\n-                    x if matches!(fmtstr.style, StrStyle::Raw(_)) && x.starts_with('\\\\') => continue,\n-                    x => x,\n-                }\n-                .into(),\n-                LitKind::Bool => lit.token_lit.symbol.as_str().deref().into(),\n             };\n \n-            if !fmt_spans.is_empty() {\n-                span_lint_and_then(\n-                    cx,\n-                    lint,\n-                    token_expr.span,\n-                    \"literal with an empty format string\",\n-                    |diag| {\n+            span_lint_and_then(\n+                cx,\n+                lint,\n+                value.span,\n+                \"literal with an empty format string\",\n+                |diag| {\n+                    if let Some(replacement) = replacement {\n+                        // `format!(\"{}\", \"a\")`, `format!(\"{named}\", named = \"b\")\n+                        //              ~~~~~                      ~~~~~~~~~~~~~\n+                        let value_span = expand_past_previous_comma(cx, value.span);\n+\n+                        let replacement = replacement.replace('{', \"{{\").replace('}', \"}}\");\n                         diag.multipart_suggestion(\n                             \"try this\",\n-                            iter::once((comma_span.to(token_expr.span), String::new()))\n-                                .chain(fmt_spans.iter().copied().zip(iter::repeat(replacement)))\n-                                .collect(),\n+                            vec![(arg.span, replacement), (value_span, String::new())],\n                             Applicability::MachineApplicable,\n                         );\n-                    },\n-                );\n-            }\n-        }\n-    }\n-\n-    fn report_positional_named_param(cx: &EarlyContext<'_>, span: Span, lhs: &P<Expr>, _rhs: &P<Expr>) {\n-        if let ExprKind::Path(_, _p) = &lhs.kind {\n-            let mut applicability = Applicability::MachineApplicable;\n-            let name = snippet_with_applicability(cx, lhs.span, \"name\", &mut applicability);\n-            // We need to do this hack as precision spans should be converted from .* to .foo$\n-            let hack = snippet(cx, span, \"\").contains('*');\n-\n-            span_lint_and_sugg(\n-                cx,\n-                POSITIONAL_NAMED_FORMAT_PARAMETERS,\n-                span,\n-                &format!(\"named parameter {} is used as a positional parameter\", name),\n-                \"replace it with\",\n-                if hack {\n-                    format!(\"{}$\", name)\n-                } else {\n-                    format!(\"{}\", name)\n+                    }\n                 },\n-                applicability,\n             );\n-        };\n-    }\n-\n-    fn lint_println_empty_string(&self, cx: &EarlyContext<'_>, mac: &MacCall) {\n-        if let (Some(fmt_str), _) = self.check_tts(cx, mac.args.inner_tokens(), false) {\n-            if fmt_str.symbol == kw::Empty {\n-                let name = mac.path.segments[0].ident.name;\n-                span_lint_and_sugg(\n-                    cx,\n-                    PRINTLN_EMPTY_STRING,\n-                    mac.span(),\n-                    &format!(\"using `{}!(\\\"\\\")`\", name),\n-                    \"replace it with\",\n-                    format!(\"{}!()\", name),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-    }\n-\n-    fn lint_print_with_newline(&self, cx: &EarlyContext<'_>, mac: &MacCall) {\n-        if let (Some(fmt_str), _) = self.check_tts(cx, mac.args.inner_tokens(), false) {\n-            if check_newlines(&fmt_str) {\n-                let name = mac.path.segments[0].ident.name;\n-                let suggested = format!(\"{}ln\", name);\n-                span_lint_and_then(\n-                    cx,\n-                    PRINT_WITH_NEWLINE,\n-                    mac.span(),\n-                    &format!(\"using `{}!()` with a format string that ends in a single newline\", name),\n-                    |err| {\n-                        err.multipart_suggestion(\n-                            &format!(\"use `{}!` instead\", suggested),\n-                            vec![(mac.path.span, suggested), (newline_span(&fmt_str).0, String::new())],\n-                            Applicability::MachineApplicable,\n-                        );\n-                    },\n-                );\n-            }\n         }\n     }\n }\n \n-/// Checks if the format string contains a single newline that terminates it.\n+/// Removes the raw marker, `#`s and quotes from a str, and returns if the literal is raw\n ///\n-/// Literal and escaped newlines are both checked (only literal for raw strings).\n-fn check_newlines(fmtstr: &StrLit) -> bool {\n-    let mut has_internal_newline = false;\n-    let mut last_was_cr = false;\n-    let mut should_lint = false;\n-\n-    let contents = fmtstr.symbol.as_str();\n-\n-    let mut cb = |r: Range<usize>, c: Result<char, EscapeError>| {\n-        let c = match c {\n-            Ok(c) => c,\n-            Err(e) if !e.is_fatal() => return,\n-            Err(e) => panic!(\"{:?}\", e),\n-        };\n-\n-        if r.end == contents.len() && c == '\\n' && !last_was_cr && !has_internal_newline {\n-            should_lint = true;\n-        } else {\n-            last_was_cr = c == '\\r';\n-            if c == '\\n' {\n-                has_internal_newline = true;\n-            }\n-        }\n+/// `r#\"a\"#` -> (`a`, true)\n+///\n+/// `\"b\"` -> (`b`, false)\n+fn extract_str_literal(literal: &str) -> (String, bool) {\n+    let (literal, raw) = match literal.strip_prefix('r') {\n+        Some(stripped) => (stripped.trim_matches('#'), true),\n+        None => (literal, false),\n     };\n \n-    match fmtstr.style {\n-        StrStyle::Cooked => unescape::unescape_literal(contents, unescape::Mode::Str, &mut cb),\n-        StrStyle::Raw(_) => unescape::unescape_literal(contents, unescape::Mode::RawStr, &mut cb),\n+    (literal[1..literal.len() - 1].to_string(), raw)\n+}\n+\n+enum UnescapeErr {\n+    /// Should still be linted, can be manually resolved by author, e.g.\n+    ///\n+    /// ```ignore\n+    /// print!(r\"{}\", '\"');\n+    /// ```\n+    Lint,\n+    /// Should not be linted, e.g.\n+    ///\n+    /// ```ignore\n+    /// print!(r\"{}\", '\\r');\n+    /// ```\n+    Ignore,\n+}\n+\n+/// Unescape a normal string into a raw string\n+fn conservative_unescape(literal: &str) -> Result<String, UnescapeErr> {\n+    let mut unescaped = String::with_capacity(literal.len());\n+    let mut chars = literal.chars();\n+    let mut err = false;\n+\n+    while let Some(ch) = chars.next() {\n+        match ch {\n+            '#' => err = true,\n+            '\\\\' => match chars.next() {\n+                Some('\\\\') => unescaped.push('\\\\'),\n+                Some('\"') => err = true,\n+                _ => return Err(UnescapeErr::Ignore),\n+            },\n+            _ => unescaped.push(ch),\n+        }\n     }\n \n-    should_lint\n+    if err { Err(UnescapeErr::Lint) } else { Ok(unescaped) }\n+}\n+\n+// Expand from `writeln!(o, \"\")` to `writeln!(o, \"\")`\n+//                          ^^                 ^^^^\n+fn expand_past_previous_comma(cx: &LateContext<'_>, span: Span) -> Span {\n+    let extended = cx.sess().source_map().span_extend_to_prev_char(span, ',', true);\n+    extended.with_lo(extended.lo() - BytePos(1))\n }"}, {"sha": "a1808c0972009bbe2a147695882e60ded4cdf69b", "filename": "clippy_utils/src/macros.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/clippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/clippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmacros.rs?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -696,9 +696,14 @@ impl<'tcx> FormatSpec<'tcx> {\n         })\n     }\n \n-    /// Returns true if this format spec would change the contents of a string when formatted\n-    pub fn has_string_formatting(&self) -> bool {\n-        self.r#trait != sym::Display || !self.width.is_implied() || !self.precision.is_implied()\n+    /// Returns true if this format spec is unchanged from the default. e.g. returns true for `{}`,\n+    /// `{foo}` and `{2}`, but false for `{:?}`, `{foo:5}` and `{3:.5}`\n+    pub fn is_default(&self) -> bool {\n+        self.r#trait == sym::Display\n+            && self.width.is_implied()\n+            && self.precision.is_implied()\n+            && self.align == Alignment::AlignUnknown\n+            && self.flags == 0\n     }\n }\n "}, {"sha": "9f6f1fb47276f4066781c23c54d787ff64f920c9", "filename": "src/docs.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/src%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/src%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs.rs?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -391,7 +391,6 @@ docs! {\n     \"partialeq_to_none\",\n     \"path_buf_push_overwrite\",\n     \"pattern_type_mismatch\",\n-    \"positional_named_format_parameters\",\n     \"possible_missing_comma\",\n     \"precedence\",\n     \"print_in_format_impl\","}, {"sha": "e391d2406677d5bd66cd6fec02ae92ed85a634e3", "filename": "src/docs/positional_named_format_parameters.txt", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9c9aa928980ca651a75801b90d814a8fb598ed0a/src%2Fdocs%2Fpositional_named_format_parameters.txt", "raw_url": "https://github.com/rust-lang/rust/raw/9c9aa928980ca651a75801b90d814a8fb598ed0a/src%2Fdocs%2Fpositional_named_format_parameters.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fpositional_named_format_parameters.txt?ref=9c9aa928980ca651a75801b90d814a8fb598ed0a", "patch": "@@ -1,15 +0,0 @@\n-### What it does\n-This lint warns when a named parameter in a format string is used as a positional one.\n-\n-### Why is this bad?\n-It may be confused for an assignment and obfuscates which parameter is being used.\n-\n-### Example\n-```\n-println!(\"{}\", x = 10);\n-```\n-\n-Use instead:\n-```\n-println!(\"{x}\", x = 10);\n-```\n\\ No newline at end of file"}, {"sha": "a6252a68780bb3ad37bab5db83808912e84eeb0e", "filename": "src/docs/print_literal.txt", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/src%2Fdocs%2Fprint_literal.txt", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/src%2Fdocs%2Fprint_literal.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fprint_literal.txt?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -6,10 +6,6 @@ Using literals as `println!` args is inefficient\n (c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary\n (i.e., just put the literal in the format string)\n \n-### Known problems\n-Will also warn with macro calls as arguments that expand to literals\n--- e.g., `println!(\"{}\", env!(\"FOO\"))`.\n-\n ### Example\n ```\n println!(\"{}\", \"foo\");"}, {"sha": "9c6edeeef125df630b79474b4ac115f5b980c705", "filename": "src/docs/print_stderr.txt", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/src%2Fdocs%2Fprint_stderr.txt", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/src%2Fdocs%2Fprint_stderr.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fprint_stderr.txt?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -7,13 +7,7 @@ People often print on *stderr* while debugging an\n application and might forget to remove those prints afterward.\n \n ### Known problems\n-* Only catches `eprint!` and `eprintln!` calls.\n-* The lint level is unaffected by crate attributes. The level can still\n-  be set for functions, modules and other items. To change the level for\n-  the entire crate, please use command line flags. More information and a\n-  configuration example can be found in [clippy#6610].\n-\n-[clippy#6610]: https://github.com/rust-lang/rust-clippy/issues/6610#issuecomment-977120558\n+Only catches `eprint!` and `eprintln!` calls.\n \n ### Example\n ```"}, {"sha": "d2cbd811d1b2a507db8b68c469fc6635f380ddeb", "filename": "src/docs/print_stdout.txt", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/src%2Fdocs%2Fprint_stdout.txt", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/src%2Fdocs%2Fprint_stdout.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fprint_stdout.txt?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -7,13 +7,7 @@ People often print on *stdout* while debugging an\n application and might forget to remove those prints afterward.\n \n ### Known problems\n-* Only catches `print!` and `println!` calls.\n-* The lint level is unaffected by crate attributes. The level can still\n-  be set for functions, modules and other items. To change the level for\n-  the entire crate, please use command line flags. More information and a\n-  configuration example can be found in [clippy#6610].\n-\n-[clippy#6610]: https://github.com/rust-lang/rust-clippy/issues/6610#issuecomment-977120558\n+Only catches `print!` and `println!` calls.\n \n ### Example\n ```"}, {"sha": "a7a884d08711508864bd0c769f9a1275e904ea3c", "filename": "src/docs/write_literal.txt", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/src%2Fdocs%2Fwrite_literal.txt", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/src%2Fdocs%2Fwrite_literal.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fwrite_literal.txt?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -6,10 +6,6 @@ Using literals as `writeln!` args is inefficient\n (c.f., https://github.com/matthiaskrgr/rust-str-bench) and unnecessary\n (i.e., just put the literal in the format string)\n \n-### Known problems\n-Will also warn with macro calls as arguments that expand to literals\n--- e.g., `writeln!(buf, \"{}\", env!(\"FOO\"))`.\n-\n ### Example\n ```\n writeln!(buf, \"{}\", \"foo\");"}, {"sha": "de5e121be877460b07e36537f3b6e05ae07fa56d", "filename": "tests/ui/eprint_with_newline.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Feprint_with_newline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Feprint_with_newline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feprint_with_newline.rs?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -45,5 +45,13 @@ fn main() {\n     eprint!(\"\\r\\n\");\n     eprint!(\"foo\\r\\n\");\n     eprint!(\"\\\\r\\n\"); //~ ERROR\n-    eprint!(\"foo\\rbar\\n\") // ~ ERROR\n+    eprint!(\"foo\\rbar\\n\");\n+\n+    // Ignore expanded format strings\n+    macro_rules! newline {\n+        () => {\n+            \"\\n\"\n+        };\n+    }\n+    eprint!(newline!());\n }"}, {"sha": "0eefb9f0ca978bafd91c8d8186321c2f8a37a7d2", "filename": "tests/ui/eprint_with_newline.stderr", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Feprint_with_newline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Feprint_with_newline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feprint_with_newline.stderr?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -83,7 +83,7 @@ LL | |     );\n help: use `eprintln!` instead\n    |\n LL ~     eprintln!(\n-LL ~         \"\"\n+LL ~         \n    |\n \n error: using `eprint!()` with a format string that ends in a single newline\n@@ -98,7 +98,7 @@ LL | |     );\n help: use `eprintln!` instead\n    |\n LL ~     eprintln!(\n-LL ~         r\"\"\n+LL ~         \n    |\n \n error: using `eprint!()` with a format string that ends in a single newline\n@@ -113,17 +113,5 @@ LL -     eprint!(\"/r/n\"); //~ ERROR\n LL +     eprintln!(\"/r\"); //~ ERROR\n    |\n \n-error: using `eprint!()` with a format string that ends in a single newline\n-  --> $DIR/eprint_with_newline.rs:48:5\n-   |\n-LL |     eprint!(\"foo/rbar/n\") // ~ ERROR\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: use `eprintln!` instead\n-   |\n-LL -     eprint!(\"foo/rbar/n\") // ~ ERROR\n-LL +     eprintln!(\"foo/rbar\") // ~ ERROR\n-   |\n-\n-error: aborting due to 10 previous errors\n+error: aborting due to 9 previous errors\n "}, {"sha": "e0c5f692740a1edd0e4c0daecd32aaf3caebe953", "filename": "tests/ui/format.fixed", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fformat.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fformat.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.fixed?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -28,8 +28,6 @@ fn main() {\n     format!(\"{:?}\", \"foo\"); // Don't warn about `Debug`.\n     format!(\"{:8}\", \"foo\");\n     format!(\"{:width$}\", \"foo\", width = 8);\n-    \"foo\".to_string(); // Warn when the format makes no difference.\n-    \"foo\".to_string(); // Warn when the format makes no difference.\n     format!(\"foo {}\", \"bar\");\n     format!(\"{} bar\", \"foo\");\n \n@@ -38,8 +36,6 @@ fn main() {\n     format!(\"{:?}\", arg); // Don't warn about debug.\n     format!(\"{:8}\", arg);\n     format!(\"{:width$}\", arg, width = 8);\n-    arg.to_string(); // Warn when the format makes no difference.\n-    arg.to_string(); // Warn when the format makes no difference.\n     format!(\"foo {}\", arg);\n     format!(\"{} bar\", arg);\n "}, {"sha": "ff83cd64bf09c1dd84f4da82c4505ed43d360e6f", "filename": "tests/ui/format.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.rs?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -30,8 +30,6 @@ fn main() {\n     format!(\"{:?}\", \"foo\"); // Don't warn about `Debug`.\n     format!(\"{:8}\", \"foo\");\n     format!(\"{:width$}\", \"foo\", width = 8);\n-    format!(\"{:+}\", \"foo\"); // Warn when the format makes no difference.\n-    format!(\"{:<}\", \"foo\"); // Warn when the format makes no difference.\n     format!(\"foo {}\", \"bar\");\n     format!(\"{} bar\", \"foo\");\n \n@@ -40,8 +38,6 @@ fn main() {\n     format!(\"{:?}\", arg); // Don't warn about debug.\n     format!(\"{:8}\", arg);\n     format!(\"{:width$}\", arg, width = 8);\n-    format!(\"{:+}\", arg); // Warn when the format makes no difference.\n-    format!(\"{:<}\", arg); // Warn when the format makes no difference.\n     format!(\"foo {}\", arg);\n     format!(\"{} bar\", arg);\n "}, {"sha": "0ef0ac655d3946a1ced143f01dbe9266f5627068", "filename": "tests/ui/format.stderr", "status": "modified", "additions": 10, "deletions": 34, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fformat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fformat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.stderr?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -46,82 +46,58 @@ LL |     format!(\"{}\", \"foo\");\n    |     ^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `\"foo\".to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:33:5\n-   |\n-LL |     format!(\"{:+}\", \"foo\"); // Warn when the format makes no difference.\n-   |     ^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `\"foo\".to_string()`\n-\n-error: useless use of `format!`\n-  --> $DIR/format.rs:34:5\n-   |\n-LL |     format!(\"{:<}\", \"foo\"); // Warn when the format makes no difference.\n-   |     ^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `\"foo\".to_string()`\n-\n-error: useless use of `format!`\n-  --> $DIR/format.rs:39:5\n+  --> $DIR/format.rs:37:5\n    |\n LL |     format!(\"{}\", arg);\n    |     ^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `arg.to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:43:5\n-   |\n-LL |     format!(\"{:+}\", arg); // Warn when the format makes no difference.\n-   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `arg.to_string()`\n-\n-error: useless use of `format!`\n-  --> $DIR/format.rs:44:5\n-   |\n-LL |     format!(\"{:<}\", arg); // Warn when the format makes no difference.\n-   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `arg.to_string()`\n-\n-error: useless use of `format!`\n-  --> $DIR/format.rs:71:5\n+  --> $DIR/format.rs:67:5\n    |\n LL |     format!(\"{}\", 42.to_string());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `42.to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:73:5\n+  --> $DIR/format.rs:69:5\n    |\n LL |     format!(\"{}\", x.display().to_string());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `x.display().to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:77:18\n+  --> $DIR/format.rs:73:18\n    |\n LL |     let _ = Some(format!(\"{}\", a + \"bar\"));\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `a + \"bar\"`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:81:22\n+  --> $DIR/format.rs:77:22\n    |\n LL |     let _s: String = format!(\"{}\", &*v.join(\"/n\"));\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `(&*v.join(\"/n\")).to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:87:13\n+  --> $DIR/format.rs:83:13\n    |\n LL |     let _ = format!(\"{x}\");\n    |             ^^^^^^^^^^^^^^ help: consider using `.to_string()`: `x.to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:89:13\n+  --> $DIR/format.rs:85:13\n    |\n LL |     let _ = format!(\"{y}\", y = x);\n    |             ^^^^^^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `x.to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:93:13\n+  --> $DIR/format.rs:89:13\n    |\n LL |     let _ = format!(\"{abc}\");\n    |             ^^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `abc.to_string()`\n \n error: useless use of `format!`\n-  --> $DIR/format.rs:95:13\n+  --> $DIR/format.rs:91:13\n    |\n LL |     let _ = format!(\"{xx}\");\n    |             ^^^^^^^^^^^^^^^ help: consider using `.to_string()`: `xx.to_string()`\n \n-error: aborting due to 19 previous errors\n+error: aborting due to 15 previous errors\n "}, {"sha": "4170e109820457a5d4c667cc00941e9be3fc1fc0", "filename": "tests/ui/positional_named_format_parameters.fixed", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9c9aa928980ca651a75801b90d814a8fb598ed0a/tests%2Fui%2Fpositional_named_format_parameters.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9c9aa928980ca651a75801b90d814a8fb598ed0a/tests%2Fui%2Fpositional_named_format_parameters.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpositional_named_format_parameters.fixed?ref=9c9aa928980ca651a75801b90d814a8fb598ed0a", "patch": "@@ -1,56 +0,0 @@\n-// run-rustfix\n-#![allow(unused_must_use)]\n-#![allow(named_arguments_used_positionally)] // Unstable at time of writing.\n-#![warn(clippy::positional_named_format_parameters)]\n-\n-use std::io::Write;\n-\n-fn main() {\n-    let mut v = Vec::new();\n-    let hello = \"Hello\";\n-\n-    println!(\"{hello:.foo$}\", foo = 2);\n-    writeln!(v, \"{hello:.foo$}\", foo = 2);\n-\n-    // Warnings\n-    println!(\"{zero} {one:?}\", zero = 0, one = 1);\n-    println!(\"This is a test {zero} {one:?}\", zero = 0, one = 1);\n-    println!(\"Hello {one} is {two:.zero$}\", zero = 5, one = hello, two = 0.01);\n-    println!(\"Hello {one:zero$}!\", zero = 5, one = 1);\n-    println!(\"Hello {zero:one$}!\", zero = 4, one = 1);\n-    println!(\"Hello {zero:0one$}!\", zero = 4, one = 1);\n-    println!(\"Hello is {one:.zero$}\", zero = 5, one = 0.01);\n-    println!(\"Hello is {one:<6.zero$}\", zero = 5, one = 0.01);\n-    println!(\"{zero}, `{two:>8.one$}` has 3\", zero = hello, one = 3, two = hello);\n-    println!(\"Hello {one} is {two:.zero$}\", zero = 5, one = hello, two = 0.01);\n-    println!(\"Hello {world} {world}!\", world = 5);\n-\n-    writeln!(v, \"{zero} {one:?}\", zero = 0, one = 1);\n-    writeln!(v, \"This is a test {zero} {one:?}\", zero = 0, one = 1);\n-    writeln!(v, \"Hello {one} is {two:.zero$}\", zero = 5, one = hello, two = 0.01);\n-    writeln!(v, \"Hello {one:zero$}!\", zero = 4, one = 1);\n-    writeln!(v, \"Hello {zero:one$}!\", zero = 4, one = 1);\n-    writeln!(v, \"Hello {zero:0one$}!\", zero = 4, one = 1);\n-    writeln!(v, \"Hello is {one:.zero$}\", zero = 3, one = 0.01);\n-    writeln!(v, \"Hello is {one:<6.zero$}\", zero = 2, one = 0.01);\n-    writeln!(v, \"{zero}, `{two:>8.one$}` has 3\", zero = hello, one = 3, two = hello);\n-    writeln!(v, \"Hello {one} is {two:.zero$}\", zero = 1, one = hello, two = 0.01);\n-    writeln!(v, \"Hello {world} {world}!\", world = 0);\n-\n-    // Tests from other files\n-    println!(\"{w:w$}\", w = 1);\n-    println!(\"{p:.p$}\", p = 1);\n-    println!(\"{v}\", v = 1);\n-    println!(\"{v:v$}\", v = 1);\n-    println!(\"{v:v$}\", v = 1);\n-    println!(\"{v:v$.v$}\", v = 1);\n-    println!(\"{v:v$.v$}\", v = 1);\n-    println!(\"{v:v$.v$}\", v = 1);\n-    println!(\"{v:v$.v$}\", v = 1);\n-    println!(\"{v:v$.v$}\", v = 1);\n-    println!(\"{v:v$.v$}\", v = 1);\n-    println!(\"{v:v$.v$}\", v = 1);\n-    println!(\"{w:w$}\", w = 1);\n-    println!(\"{p:.p$}\", p = 1);\n-    println!(\"{:p$.w$}\", 1, w = 1, p = 1);\n-}"}, {"sha": "553d8494ecc04303778cb9aa184faef5178e996a", "filename": "tests/ui/positional_named_format_parameters.rs", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9c9aa928980ca651a75801b90d814a8fb598ed0a/tests%2Fui%2Fpositional_named_format_parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9aa928980ca651a75801b90d814a8fb598ed0a/tests%2Fui%2Fpositional_named_format_parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpositional_named_format_parameters.rs?ref=9c9aa928980ca651a75801b90d814a8fb598ed0a", "patch": "@@ -1,56 +0,0 @@\n-// run-rustfix\n-#![allow(unused_must_use)]\n-#![allow(named_arguments_used_positionally)] // Unstable at time of writing.\n-#![warn(clippy::positional_named_format_parameters)]\n-\n-use std::io::Write;\n-\n-fn main() {\n-    let mut v = Vec::new();\n-    let hello = \"Hello\";\n-\n-    println!(\"{hello:.foo$}\", foo = 2);\n-    writeln!(v, \"{hello:.foo$}\", foo = 2);\n-\n-    // Warnings\n-    println!(\"{} {1:?}\", zero = 0, one = 1);\n-    println!(\"This is a test { } {000001:?}\", zero = 0, one = 1);\n-    println!(\"Hello {1} is {2:.0$}\", zero = 5, one = hello, two = 0.01);\n-    println!(\"Hello {1:0$}!\", zero = 5, one = 1);\n-    println!(\"Hello {0:1$}!\", zero = 4, one = 1);\n-    println!(\"Hello {0:01$}!\", zero = 4, one = 1);\n-    println!(\"Hello is {1:.*}\", zero = 5, one = 0.01);\n-    println!(\"Hello is {:<6.*}\", zero = 5, one = 0.01);\n-    println!(\"{}, `{two:>8.*}` has 3\", zero = hello, one = 3, two = hello);\n-    println!(\"Hello {1} is {2:.0$}\", zero = 5, one = hello, two = 0.01);\n-    println!(\"Hello {world} {}!\", world = 5);\n-\n-    writeln!(v, \"{} {1:?}\", zero = 0, one = 1);\n-    writeln!(v, \"This is a test { } {000001:?}\", zero = 0, one = 1);\n-    writeln!(v, \"Hello {1} is {2:.0$}\", zero = 5, one = hello, two = 0.01);\n-    writeln!(v, \"Hello {1:0$}!\", zero = 4, one = 1);\n-    writeln!(v, \"Hello {0:1$}!\", zero = 4, one = 1);\n-    writeln!(v, \"Hello {0:01$}!\", zero = 4, one = 1);\n-    writeln!(v, \"Hello is {1:.*}\", zero = 3, one = 0.01);\n-    writeln!(v, \"Hello is {:<6.*}\", zero = 2, one = 0.01);\n-    writeln!(v, \"{}, `{two:>8.*}` has 3\", zero = hello, one = 3, two = hello);\n-    writeln!(v, \"Hello {1} is {2:.0$}\", zero = 1, one = hello, two = 0.01);\n-    writeln!(v, \"Hello {world} {}!\", world = 0);\n-\n-    // Tests from other files\n-    println!(\"{:w$}\", w = 1);\n-    println!(\"{:.p$}\", p = 1);\n-    println!(\"{}\", v = 1);\n-    println!(\"{:0$}\", v = 1);\n-    println!(\"{0:0$}\", v = 1);\n-    println!(\"{:0$.0$}\", v = 1);\n-    println!(\"{0:0$.0$}\", v = 1);\n-    println!(\"{0:0$.v$}\", v = 1);\n-    println!(\"{0:v$.0$}\", v = 1);\n-    println!(\"{v:0$.0$}\", v = 1);\n-    println!(\"{v:v$.0$}\", v = 1);\n-    println!(\"{v:0$.v$}\", v = 1);\n-    println!(\"{:w$}\", w = 1);\n-    println!(\"{:.p$}\", p = 1);\n-    println!(\"{:p$.w$}\", 1, w = 1, p = 1);\n-}"}, {"sha": "48ddb6d67ad246084bdbb951887d8759969c297d", "filename": "tests/ui/positional_named_format_parameters.stderr", "status": "removed", "additions": 0, "deletions": 418, "changes": 418, "blob_url": "https://github.com/rust-lang/rust/blob/9c9aa928980ca651a75801b90d814a8fb598ed0a/tests%2Fui%2Fpositional_named_format_parameters.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9c9aa928980ca651a75801b90d814a8fb598ed0a/tests%2Fui%2Fpositional_named_format_parameters.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpositional_named_format_parameters.stderr?ref=9c9aa928980ca651a75801b90d814a8fb598ed0a", "patch": "@@ -1,418 +0,0 @@\n-error: named parameter zero is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:16:16\n-   |\n-LL |     println!(\"{} {1:?}\", zero = 0, one = 1);\n-   |                ^ help: replace it with: `zero`\n-   |\n-   = note: `-D clippy::positional-named-format-parameters` implied by `-D warnings`\n-\n-error: named parameter one is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:16:19\n-   |\n-LL |     println!(\"{} {1:?}\", zero = 0, one = 1);\n-   |                   ^ help: replace it with: `one`\n-\n-error: named parameter zero is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:17:31\n-   |\n-LL |     println!(\"This is a test { } {000001:?}\", zero = 0, one = 1);\n-   |                               ^ help: replace it with: `zero`\n-\n-error: named parameter one is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:17:35\n-   |\n-LL |     println!(\"This is a test { } {000001:?}\", zero = 0, one = 1);\n-   |                                   ^^^^^^ help: replace it with: `one`\n-\n-error: named parameter zero is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:18:32\n-   |\n-LL |     println!(\"Hello {1} is {2:.0$}\", zero = 5, one = hello, two = 0.01);\n-   |                                ^ help: replace it with: `zero`\n-\n-error: named parameter one is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:18:22\n-   |\n-LL |     println!(\"Hello {1} is {2:.0$}\", zero = 5, one = hello, two = 0.01);\n-   |                      ^ help: replace it with: `one`\n-\n-error: named parameter two is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:18:29\n-   |\n-LL |     println!(\"Hello {1} is {2:.0$}\", zero = 5, one = hello, two = 0.01);\n-   |                             ^ help: replace it with: `two`\n-\n-error: named parameter zero is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:19:24\n-   |\n-LL |     println!(\"Hello {1:0$}!\", zero = 5, one = 1);\n-   |                        ^ help: replace it with: `zero`\n-\n-error: named parameter one is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:19:22\n-   |\n-LL |     println!(\"Hello {1:0$}!\", zero = 5, one = 1);\n-   |                      ^ help: replace it with: `one`\n-\n-error: named parameter zero is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:20:22\n-   |\n-LL |     println!(\"Hello {0:1$}!\", zero = 4, one = 1);\n-   |                      ^ help: replace it with: `zero`\n-\n-error: named parameter one is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:20:24\n-   |\n-LL |     println!(\"Hello {0:1$}!\", zero = 4, one = 1);\n-   |                        ^ help: replace it with: `one`\n-\n-error: named parameter zero is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:21:22\n-   |\n-LL |     println!(\"Hello {0:01$}!\", zero = 4, one = 1);\n-   |                      ^ help: replace it with: `zero`\n-\n-error: named parameter one is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:21:25\n-   |\n-LL |     println!(\"Hello {0:01$}!\", zero = 4, one = 1);\n-   |                         ^ help: replace it with: `one`\n-\n-error: named parameter zero is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:22:28\n-   |\n-LL |     println!(\"Hello is {1:.*}\", zero = 5, one = 0.01);\n-   |                            ^ help: replace it with: `zero$`\n-\n-error: named parameter one is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:22:25\n-   |\n-LL |     println!(\"Hello is {1:.*}\", zero = 5, one = 0.01);\n-   |                         ^ help: replace it with: `one`\n-\n-error: named parameter zero is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:23:29\n-   |\n-LL |     println!(\"Hello is {:<6.*}\", zero = 5, one = 0.01);\n-   |                             ^ help: replace it with: `zero$`\n-\n-error: named parameter one is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:23:25\n-   |\n-LL |     println!(\"Hello is {:<6.*}\", zero = 5, one = 0.01);\n-   |                         ^ help: replace it with: `one`\n-\n-error: named parameter zero is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:24:16\n-   |\n-LL |     println!(\"{}, `{two:>8.*}` has 3\", zero = hello, one = 3, two = hello);\n-   |                ^ help: replace it with: `zero`\n-\n-error: named parameter one is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:24:28\n-   |\n-LL |     println!(\"{}, `{two:>8.*}` has 3\", zero = hello, one = 3, two = hello);\n-   |                            ^ help: replace it with: `one$`\n-\n-error: named parameter zero is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:25:32\n-   |\n-LL |     println!(\"Hello {1} is {2:.0$}\", zero = 5, one = hello, two = 0.01);\n-   |                                ^ help: replace it with: `zero`\n-\n-error: named parameter one is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:25:22\n-   |\n-LL |     println!(\"Hello {1} is {2:.0$}\", zero = 5, one = hello, two = 0.01);\n-   |                      ^ help: replace it with: `one`\n-\n-error: named parameter two is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:25:29\n-   |\n-LL |     println!(\"Hello {1} is {2:.0$}\", zero = 5, one = hello, two = 0.01);\n-   |                             ^ help: replace it with: `two`\n-\n-error: named parameter world is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:26:30\n-   |\n-LL |     println!(\"Hello {world} {}!\", world = 5);\n-   |                              ^ help: replace it with: `world`\n-\n-error: named parameter zero is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:28:19\n-   |\n-LL |     writeln!(v, \"{} {1:?}\", zero = 0, one = 1);\n-   |                   ^ help: replace it with: `zero`\n-\n-error: named parameter one is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:28:22\n-   |\n-LL |     writeln!(v, \"{} {1:?}\", zero = 0, one = 1);\n-   |                      ^ help: replace it with: `one`\n-\n-error: named parameter zero is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:29:34\n-   |\n-LL |     writeln!(v, \"This is a test { } {000001:?}\", zero = 0, one = 1);\n-   |                                  ^ help: replace it with: `zero`\n-\n-error: named parameter one is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:29:38\n-   |\n-LL |     writeln!(v, \"This is a test { } {000001:?}\", zero = 0, one = 1);\n-   |                                      ^^^^^^ help: replace it with: `one`\n-\n-error: named parameter zero is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:30:35\n-   |\n-LL |     writeln!(v, \"Hello {1} is {2:.0$}\", zero = 5, one = hello, two = 0.01);\n-   |                                   ^ help: replace it with: `zero`\n-\n-error: named parameter one is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:30:25\n-   |\n-LL |     writeln!(v, \"Hello {1} is {2:.0$}\", zero = 5, one = hello, two = 0.01);\n-   |                         ^ help: replace it with: `one`\n-\n-error: named parameter two is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:30:32\n-   |\n-LL |     writeln!(v, \"Hello {1} is {2:.0$}\", zero = 5, one = hello, two = 0.01);\n-   |                                ^ help: replace it with: `two`\n-\n-error: named parameter zero is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:31:27\n-   |\n-LL |     writeln!(v, \"Hello {1:0$}!\", zero = 4, one = 1);\n-   |                           ^ help: replace it with: `zero`\n-\n-error: named parameter one is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:31:25\n-   |\n-LL |     writeln!(v, \"Hello {1:0$}!\", zero = 4, one = 1);\n-   |                         ^ help: replace it with: `one`\n-\n-error: named parameter zero is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:32:25\n-   |\n-LL |     writeln!(v, \"Hello {0:1$}!\", zero = 4, one = 1);\n-   |                         ^ help: replace it with: `zero`\n-\n-error: named parameter one is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:32:27\n-   |\n-LL |     writeln!(v, \"Hello {0:1$}!\", zero = 4, one = 1);\n-   |                           ^ help: replace it with: `one`\n-\n-error: named parameter zero is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:33:25\n-   |\n-LL |     writeln!(v, \"Hello {0:01$}!\", zero = 4, one = 1);\n-   |                         ^ help: replace it with: `zero`\n-\n-error: named parameter one is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:33:28\n-   |\n-LL |     writeln!(v, \"Hello {0:01$}!\", zero = 4, one = 1);\n-   |                            ^ help: replace it with: `one`\n-\n-error: named parameter zero is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:34:31\n-   |\n-LL |     writeln!(v, \"Hello is {1:.*}\", zero = 3, one = 0.01);\n-   |                               ^ help: replace it with: `zero$`\n-\n-error: named parameter one is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:34:28\n-   |\n-LL |     writeln!(v, \"Hello is {1:.*}\", zero = 3, one = 0.01);\n-   |                            ^ help: replace it with: `one`\n-\n-error: named parameter zero is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:35:32\n-   |\n-LL |     writeln!(v, \"Hello is {:<6.*}\", zero = 2, one = 0.01);\n-   |                                ^ help: replace it with: `zero$`\n-\n-error: named parameter one is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:35:28\n-   |\n-LL |     writeln!(v, \"Hello is {:<6.*}\", zero = 2, one = 0.01);\n-   |                            ^ help: replace it with: `one`\n-\n-error: named parameter zero is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:36:19\n-   |\n-LL |     writeln!(v, \"{}, `{two:>8.*}` has 3\", zero = hello, one = 3, two = hello);\n-   |                   ^ help: replace it with: `zero`\n-\n-error: named parameter one is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:36:31\n-   |\n-LL |     writeln!(v, \"{}, `{two:>8.*}` has 3\", zero = hello, one = 3, two = hello);\n-   |                               ^ help: replace it with: `one$`\n-\n-error: named parameter zero is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:37:35\n-   |\n-LL |     writeln!(v, \"Hello {1} is {2:.0$}\", zero = 1, one = hello, two = 0.01);\n-   |                                   ^ help: replace it with: `zero`\n-\n-error: named parameter one is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:37:25\n-   |\n-LL |     writeln!(v, \"Hello {1} is {2:.0$}\", zero = 1, one = hello, two = 0.01);\n-   |                         ^ help: replace it with: `one`\n-\n-error: named parameter two is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:37:32\n-   |\n-LL |     writeln!(v, \"Hello {1} is {2:.0$}\", zero = 1, one = hello, two = 0.01);\n-   |                                ^ help: replace it with: `two`\n-\n-error: named parameter world is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:38:33\n-   |\n-LL |     writeln!(v, \"Hello {world} {}!\", world = 0);\n-   |                                 ^ help: replace it with: `world`\n-\n-error: named parameter w is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:41:16\n-   |\n-LL |     println!(\"{:w$}\", w = 1);\n-   |                ^ help: replace it with: `w`\n-\n-error: named parameter p is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:42:16\n-   |\n-LL |     println!(\"{:.p$}\", p = 1);\n-   |                ^ help: replace it with: `p`\n-\n-error: named parameter v is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:43:16\n-   |\n-LL |     println!(\"{}\", v = 1);\n-   |                ^ help: replace it with: `v`\n-\n-error: named parameter v is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:44:16\n-   |\n-LL |     println!(\"{:0$}\", v = 1);\n-   |                ^ help: replace it with: `v`\n-\n-error: named parameter v is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:44:17\n-   |\n-LL |     println!(\"{:0$}\", v = 1);\n-   |                 ^ help: replace it with: `v`\n-\n-error: named parameter v is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:45:16\n-   |\n-LL |     println!(\"{0:0$}\", v = 1);\n-   |                ^ help: replace it with: `v`\n-\n-error: named parameter v is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:45:18\n-   |\n-LL |     println!(\"{0:0$}\", v = 1);\n-   |                  ^ help: replace it with: `v`\n-\n-error: named parameter v is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:46:16\n-   |\n-LL |     println!(\"{:0$.0$}\", v = 1);\n-   |                ^ help: replace it with: `v`\n-\n-error: named parameter v is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:46:20\n-   |\n-LL |     println!(\"{:0$.0$}\", v = 1);\n-   |                    ^ help: replace it with: `v`\n-\n-error: named parameter v is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:46:17\n-   |\n-LL |     println!(\"{:0$.0$}\", v = 1);\n-   |                 ^ help: replace it with: `v`\n-\n-error: named parameter v is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:47:16\n-   |\n-LL |     println!(\"{0:0$.0$}\", v = 1);\n-   |                ^ help: replace it with: `v`\n-\n-error: named parameter v is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:47:21\n-   |\n-LL |     println!(\"{0:0$.0$}\", v = 1);\n-   |                     ^ help: replace it with: `v`\n-\n-error: named parameter v is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:47:18\n-   |\n-LL |     println!(\"{0:0$.0$}\", v = 1);\n-   |                  ^ help: replace it with: `v`\n-\n-error: named parameter v is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:48:16\n-   |\n-LL |     println!(\"{0:0$.v$}\", v = 1);\n-   |                ^ help: replace it with: `v`\n-\n-error: named parameter v is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:48:18\n-   |\n-LL |     println!(\"{0:0$.v$}\", v = 1);\n-   |                  ^ help: replace it with: `v`\n-\n-error: named parameter v is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:49:16\n-   |\n-LL |     println!(\"{0:v$.0$}\", v = 1);\n-   |                ^ help: replace it with: `v`\n-\n-error: named parameter v is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:49:21\n-   |\n-LL |     println!(\"{0:v$.0$}\", v = 1);\n-   |                     ^ help: replace it with: `v`\n-\n-error: named parameter v is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:50:21\n-   |\n-LL |     println!(\"{v:0$.0$}\", v = 1);\n-   |                     ^ help: replace it with: `v`\n-\n-error: named parameter v is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:50:18\n-   |\n-LL |     println!(\"{v:0$.0$}\", v = 1);\n-   |                  ^ help: replace it with: `v`\n-\n-error: named parameter v is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:51:21\n-   |\n-LL |     println!(\"{v:v$.0$}\", v = 1);\n-   |                     ^ help: replace it with: `v`\n-\n-error: named parameter v is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:52:18\n-   |\n-LL |     println!(\"{v:0$.v$}\", v = 1);\n-   |                  ^ help: replace it with: `v`\n-\n-error: named parameter w is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:53:16\n-   |\n-LL |     println!(\"{:w$}\", w = 1);\n-   |                ^ help: replace it with: `w`\n-\n-error: named parameter p is used as a positional parameter\n-  --> $DIR/positional_named_format_parameters.rs:54:16\n-   |\n-LL |     println!(\"{:.p$}\", p = 1);\n-   |                ^ help: replace it with: `p`\n-\n-error: aborting due to 69 previous errors\n-"}, {"sha": "3f6639c14585ad5aa69d133ba6bd5f70e02ab25d", "filename": "tests/ui/print_literal.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fprint_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fprint_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_literal.rs?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -20,11 +20,13 @@ fn main() {\n     println!(\"{} of {:b} people know binary, the other half doesn't\", 1, 2);\n     println!(\"10 / 4 is {}\", 2.5);\n     println!(\"2 + 1 = {}\", 3);\n+    println!(\"From expansion {}\", stringify!(not a string literal));\n \n     // these should throw warnings\n     print!(\"Hello {}\", \"world\");\n     println!(\"Hello {} {}\", world, \"world\");\n     println!(\"Hello {}\", \"world\");\n+    println!(\"{} {:.4}\", \"a literal\", 5);\n \n     // positional args don't change the fact\n     // that we're using a literal -- this should"}, {"sha": "23e6dbc3e341fdc0476872066594afe264d861f6", "filename": "tests/ui/print_literal.stderr", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fprint_literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fprint_literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_literal.stderr?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -1,5 +1,5 @@\n error: literal with an empty format string\n-  --> $DIR/print_literal.rs:25:24\n+  --> $DIR/print_literal.rs:26:24\n    |\n LL |     print!(\"Hello {}\", \"world\");\n    |                        ^^^^^^^\n@@ -12,7 +12,7 @@ LL +     print!(\"Hello world\");\n    |\n \n error: literal with an empty format string\n-  --> $DIR/print_literal.rs:26:36\n+  --> $DIR/print_literal.rs:27:36\n    |\n LL |     println!(\"Hello {} {}\", world, \"world\");\n    |                                    ^^^^^^^\n@@ -24,7 +24,7 @@ LL +     println!(\"Hello {} world\", world);\n    |\n \n error: literal with an empty format string\n-  --> $DIR/print_literal.rs:27:26\n+  --> $DIR/print_literal.rs:28:26\n    |\n LL |     println!(\"Hello {}\", \"world\");\n    |                          ^^^^^^^\n@@ -36,7 +36,19 @@ LL +     println!(\"Hello world\");\n    |\n \n error: literal with an empty format string\n-  --> $DIR/print_literal.rs:32:25\n+  --> $DIR/print_literal.rs:29:26\n+   |\n+LL |     println!(\"{} {:.4}\", \"a literal\", 5);\n+   |                          ^^^^^^^^^^^\n+   |\n+help: try this\n+   |\n+LL -     println!(\"{} {:.4}\", \"a literal\", 5);\n+LL +     println!(\"a literal {:.4}\", 5);\n+   |\n+\n+error: literal with an empty format string\n+  --> $DIR/print_literal.rs:34:25\n    |\n LL |     println!(\"{0} {1}\", \"hello\", \"world\");\n    |                         ^^^^^^^\n@@ -48,7 +60,7 @@ LL +     println!(\"hello {1}\", \"world\");\n    |\n \n error: literal with an empty format string\n-  --> $DIR/print_literal.rs:32:34\n+  --> $DIR/print_literal.rs:34:34\n    |\n LL |     println!(\"{0} {1}\", \"hello\", \"world\");\n    |                                  ^^^^^^^\n@@ -60,34 +72,34 @@ LL +     println!(\"{0} world\", \"hello\");\n    |\n \n error: literal with an empty format string\n-  --> $DIR/print_literal.rs:33:25\n+  --> $DIR/print_literal.rs:35:34\n    |\n LL |     println!(\"{1} {0}\", \"hello\", \"world\");\n-   |                         ^^^^^^^\n+   |                                  ^^^^^^^\n    |\n help: try this\n    |\n LL -     println!(\"{1} {0}\", \"hello\", \"world\");\n-LL +     println!(\"{1} hello\", \"world\");\n+LL +     println!(\"world {0}\", \"hello\");\n    |\n \n error: literal with an empty format string\n-  --> $DIR/print_literal.rs:33:34\n+  --> $DIR/print_literal.rs:35:25\n    |\n LL |     println!(\"{1} {0}\", \"hello\", \"world\");\n-   |                                  ^^^^^^^\n+   |                         ^^^^^^^\n    |\n help: try this\n    |\n LL -     println!(\"{1} {0}\", \"hello\", \"world\");\n-LL +     println!(\"world {0}\", \"hello\");\n+LL +     println!(\"{1} hello\", \"world\");\n    |\n \n error: literal with an empty format string\n-  --> $DIR/print_literal.rs:36:29\n+  --> $DIR/print_literal.rs:38:35\n    |\n LL |     println!(\"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n-   |                             ^^^^^^^^^^^^^\n+   |                                   ^^^^^^^\n    |\n help: try this\n    |\n@@ -96,10 +108,10 @@ LL +     println!(\"hello {bar}\", bar = \"world\");\n    |\n \n error: literal with an empty format string\n-  --> $DIR/print_literal.rs:36:44\n+  --> $DIR/print_literal.rs:38:50\n    |\n LL |     println!(\"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n-   |                                            ^^^^^^^^^^^^^\n+   |                                                  ^^^^^^^\n    |\n help: try this\n    |\n@@ -108,28 +120,28 @@ LL +     println!(\"{foo} world\", foo = \"hello\");\n    |\n \n error: literal with an empty format string\n-  --> $DIR/print_literal.rs:37:29\n+  --> $DIR/print_literal.rs:39:50\n    |\n LL |     println!(\"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n-   |                             ^^^^^^^^^^^^^\n+   |                                                  ^^^^^^^\n    |\n help: try this\n    |\n LL -     println!(\"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n-LL +     println!(\"{bar} hello\", bar = \"world\");\n+LL +     println!(\"world {foo}\", foo = \"hello\");\n    |\n \n error: literal with an empty format string\n-  --> $DIR/print_literal.rs:37:44\n+  --> $DIR/print_literal.rs:39:35\n    |\n LL |     println!(\"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n-   |                                            ^^^^^^^^^^^^^\n+   |                                   ^^^^^^^\n    |\n help: try this\n    |\n LL -     println!(\"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n-LL +     println!(\"world {foo}\", foo = \"hello\");\n+LL +     println!(\"{bar} hello\", bar = \"world\");\n    |\n \n-error: aborting due to 11 previous errors\n+error: aborting due to 12 previous errors\n "}, {"sha": "b8c29d207adae044e8d9653660dc8f087d7dd193", "filename": "tests/ui/print_with_newline.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fprint_with_newline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fprint_with_newline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_with_newline.rs?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -48,5 +48,13 @@ fn main() {\n     print!(\"\\r\\n\");\n     print!(\"foo\\r\\n\");\n     print!(\"\\\\r\\n\"); //~ ERROR\n-    print!(\"foo\\rbar\\n\") // ~ ERROR\n+    print!(\"foo\\rbar\\n\");\n+\n+    // Ignore expanded format strings\n+    macro_rules! newline {\n+        () => {\n+            \"\\n\"\n+        };\n+    }\n+    print!(newline!());\n }"}, {"sha": "b9f5675faec7389a6f8bfd9212dced7b7525d782", "filename": "tests/ui/print_with_newline.stderr", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fprint_with_newline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fprint_with_newline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_with_newline.stderr?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -83,7 +83,7 @@ LL | |     );\n help: use `println!` instead\n    |\n LL ~     println!(\n-LL ~         \"\"\n+LL ~         \n    |\n \n error: using `print!()` with a format string that ends in a single newline\n@@ -98,7 +98,7 @@ LL | |     );\n help: use `println!` instead\n    |\n LL ~     println!(\n-LL ~         r\"\"\n+LL ~         \n    |\n \n error: using `print!()` with a format string that ends in a single newline\n@@ -113,17 +113,5 @@ LL -     print!(\"/r/n\"); //~ ERROR\n LL +     println!(\"/r\"); //~ ERROR\n    |\n \n-error: using `print!()` with a format string that ends in a single newline\n-  --> $DIR/print_with_newline.rs:51:5\n-   |\n-LL |     print!(\"foo/rbar/n\") // ~ ERROR\n-   |     ^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: use `println!` instead\n-   |\n-LL -     print!(\"foo/rbar/n\") // ~ ERROR\n-LL +     println!(\"foo/rbar\") // ~ ERROR\n-   |\n-\n-error: aborting due to 10 previous errors\n+error: aborting due to 9 previous errors\n "}, {"sha": "3cc8bb947bd352c0e889c2d29d4221f4754eee15", "filename": "tests/ui/println_empty_string.stderr", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fprintln_empty_string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fprintln_empty_string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprintln_empty_string.stderr?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -1,28 +1,36 @@\n-error: using `println!(\"\")`\n+error: empty string literal in `println!`\n   --> $DIR/println_empty_string.rs:6:5\n    |\n LL |     println!(\"\");\n-   |     ^^^^^^^^^^^^ help: replace it with: `println!()`\n+   |     ^^^^^^^^^--^\n+   |              |\n+   |              help: remove the empty string\n    |\n    = note: `-D clippy::println-empty-string` implied by `-D warnings`\n \n-error: using `println!(\"\")`\n+error: empty string literal in `println!`\n   --> $DIR/println_empty_string.rs:9:14\n    |\n LL |         _ => println!(\"\"),\n-   |              ^^^^^^^^^^^^ help: replace it with: `println!()`\n+   |              ^^^^^^^^^--^\n+   |                       |\n+   |                       help: remove the empty string\n \n-error: using `eprintln!(\"\")`\n+error: empty string literal in `eprintln!`\n   --> $DIR/println_empty_string.rs:13:5\n    |\n LL |     eprintln!(\"\");\n-   |     ^^^^^^^^^^^^^ help: replace it with: `eprintln!()`\n+   |     ^^^^^^^^^^--^\n+   |               |\n+   |               help: remove the empty string\n \n-error: using `eprintln!(\"\")`\n+error: empty string literal in `eprintln!`\n   --> $DIR/println_empty_string.rs:16:14\n    |\n LL |         _ => eprintln!(\"\"),\n-   |              ^^^^^^^^^^^^^ help: replace it with: `eprintln!()`\n+   |              ^^^^^^^^^^--^\n+   |                        |\n+   |                        help: remove the empty string\n \n error: aborting due to 4 previous errors\n "}, {"sha": "a6e7bdba77c65f1acac87f5323cf6e3993cb7070", "filename": "tests/ui/rename.fixed", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Frename.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Frename.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frename.fixed?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -32,6 +32,7 @@\n #![allow(invalid_value)]\n #![allow(enum_intrinsics_non_enums)]\n #![allow(non_fmt_panics)]\n+#![allow(named_arguments_used_positionally)]\n #![allow(temporary_cstring_as_ptr)]\n #![allow(unknown_lints)]\n #![allow(unused_labels)]\n@@ -69,6 +70,7 @@\n #![warn(invalid_value)]\n #![warn(enum_intrinsics_non_enums)]\n #![warn(non_fmt_panics)]\n+#![warn(named_arguments_used_positionally)]\n #![warn(temporary_cstring_as_ptr)]\n #![warn(unknown_lints)]\n #![warn(unused_labels)]"}, {"sha": "e8f57597d02b5d8d4a573166f145daa9a670182a", "filename": "tests/ui/rename.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frename.rs?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -32,6 +32,7 @@\n #![allow(invalid_value)]\n #![allow(enum_intrinsics_non_enums)]\n #![allow(non_fmt_panics)]\n+#![allow(named_arguments_used_positionally)]\n #![allow(temporary_cstring_as_ptr)]\n #![allow(unknown_lints)]\n #![allow(unused_labels)]\n@@ -69,6 +70,7 @@\n #![warn(clippy::invalid_ref)]\n #![warn(clippy::mem_discriminant_non_enum)]\n #![warn(clippy::panic_params)]\n+#![warn(clippy::positional_named_format_parameters)]\n #![warn(clippy::temporary_cstring_as_ptr)]\n #![warn(clippy::unknown_clippy_lints)]\n #![warn(clippy::unused_label)]"}, {"sha": "31865a7f66d60901231d84dc9f8c787d97f25736", "filename": "tests/ui/rename.stderr", "status": "modified", "additions": 44, "deletions": 38, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Frename.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Frename.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frename.stderr?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -1,226 +1,232 @@\n error: lint `clippy::blacklisted_name` has been renamed to `clippy::disallowed_names`\n-  --> $DIR/rename.rs:38:9\n+  --> $DIR/rename.rs:39:9\n    |\n LL | #![warn(clippy::blacklisted_name)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::disallowed_names`\n    |\n    = note: `-D renamed-and-removed-lints` implied by `-D warnings`\n \n error: lint `clippy::block_in_if_condition_expr` has been renamed to `clippy::blocks_in_if_conditions`\n-  --> $DIR/rename.rs:39:9\n+  --> $DIR/rename.rs:40:9\n    |\n LL | #![warn(clippy::block_in_if_condition_expr)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::blocks_in_if_conditions`\n \n error: lint `clippy::block_in_if_condition_stmt` has been renamed to `clippy::blocks_in_if_conditions`\n-  --> $DIR/rename.rs:40:9\n+  --> $DIR/rename.rs:41:9\n    |\n LL | #![warn(clippy::block_in_if_condition_stmt)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::blocks_in_if_conditions`\n \n error: lint `clippy::box_vec` has been renamed to `clippy::box_collection`\n-  --> $DIR/rename.rs:41:9\n+  --> $DIR/rename.rs:42:9\n    |\n LL | #![warn(clippy::box_vec)]\n    |         ^^^^^^^^^^^^^^^ help: use the new name: `clippy::box_collection`\n \n error: lint `clippy::const_static_lifetime` has been renamed to `clippy::redundant_static_lifetimes`\n-  --> $DIR/rename.rs:42:9\n+  --> $DIR/rename.rs:43:9\n    |\n LL | #![warn(clippy::const_static_lifetime)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::redundant_static_lifetimes`\n \n error: lint `clippy::cyclomatic_complexity` has been renamed to `clippy::cognitive_complexity`\n-  --> $DIR/rename.rs:43:9\n+  --> $DIR/rename.rs:44:9\n    |\n LL | #![warn(clippy::cyclomatic_complexity)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::cognitive_complexity`\n \n error: lint `clippy::disallowed_method` has been renamed to `clippy::disallowed_methods`\n-  --> $DIR/rename.rs:44:9\n+  --> $DIR/rename.rs:45:9\n    |\n LL | #![warn(clippy::disallowed_method)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::disallowed_methods`\n \n error: lint `clippy::disallowed_type` has been renamed to `clippy::disallowed_types`\n-  --> $DIR/rename.rs:45:9\n+  --> $DIR/rename.rs:46:9\n    |\n LL | #![warn(clippy::disallowed_type)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::disallowed_types`\n \n error: lint `clippy::eval_order_dependence` has been renamed to `clippy::mixed_read_write_in_expression`\n-  --> $DIR/rename.rs:46:9\n+  --> $DIR/rename.rs:47:9\n    |\n LL | #![warn(clippy::eval_order_dependence)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::mixed_read_write_in_expression`\n \n error: lint `clippy::for_loop_over_option` has been renamed to `clippy::for_loops_over_fallibles`\n-  --> $DIR/rename.rs:47:9\n+  --> $DIR/rename.rs:48:9\n    |\n LL | #![warn(clippy::for_loop_over_option)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::for_loops_over_fallibles`\n \n error: lint `clippy::for_loop_over_result` has been renamed to `clippy::for_loops_over_fallibles`\n-  --> $DIR/rename.rs:48:9\n+  --> $DIR/rename.rs:49:9\n    |\n LL | #![warn(clippy::for_loop_over_result)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::for_loops_over_fallibles`\n \n error: lint `clippy::identity_conversion` has been renamed to `clippy::useless_conversion`\n-  --> $DIR/rename.rs:49:9\n+  --> $DIR/rename.rs:50:9\n    |\n LL | #![warn(clippy::identity_conversion)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::useless_conversion`\n \n error: lint `clippy::if_let_some_result` has been renamed to `clippy::match_result_ok`\n-  --> $DIR/rename.rs:50:9\n+  --> $DIR/rename.rs:51:9\n    |\n LL | #![warn(clippy::if_let_some_result)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::match_result_ok`\n \n error: lint `clippy::logic_bug` has been renamed to `clippy::overly_complex_bool_expr`\n-  --> $DIR/rename.rs:51:9\n+  --> $DIR/rename.rs:52:9\n    |\n LL | #![warn(clippy::logic_bug)]\n    |         ^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::overly_complex_bool_expr`\n \n error: lint `clippy::new_without_default_derive` has been renamed to `clippy::new_without_default`\n-  --> $DIR/rename.rs:52:9\n+  --> $DIR/rename.rs:53:9\n    |\n LL | #![warn(clippy::new_without_default_derive)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::new_without_default`\n \n error: lint `clippy::option_and_then_some` has been renamed to `clippy::bind_instead_of_map`\n-  --> $DIR/rename.rs:53:9\n+  --> $DIR/rename.rs:54:9\n    |\n LL | #![warn(clippy::option_and_then_some)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::bind_instead_of_map`\n \n error: lint `clippy::option_expect_used` has been renamed to `clippy::expect_used`\n-  --> $DIR/rename.rs:54:9\n+  --> $DIR/rename.rs:55:9\n    |\n LL | #![warn(clippy::option_expect_used)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::expect_used`\n \n error: lint `clippy::option_map_unwrap_or` has been renamed to `clippy::map_unwrap_or`\n-  --> $DIR/rename.rs:55:9\n+  --> $DIR/rename.rs:56:9\n    |\n LL | #![warn(clippy::option_map_unwrap_or)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::map_unwrap_or`\n \n error: lint `clippy::option_map_unwrap_or_else` has been renamed to `clippy::map_unwrap_or`\n-  --> $DIR/rename.rs:56:9\n+  --> $DIR/rename.rs:57:9\n    |\n LL | #![warn(clippy::option_map_unwrap_or_else)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::map_unwrap_or`\n \n error: lint `clippy::option_unwrap_used` has been renamed to `clippy::unwrap_used`\n-  --> $DIR/rename.rs:57:9\n+  --> $DIR/rename.rs:58:9\n    |\n LL | #![warn(clippy::option_unwrap_used)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::unwrap_used`\n \n error: lint `clippy::ref_in_deref` has been renamed to `clippy::needless_borrow`\n-  --> $DIR/rename.rs:58:9\n+  --> $DIR/rename.rs:59:9\n    |\n LL | #![warn(clippy::ref_in_deref)]\n    |         ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::needless_borrow`\n \n error: lint `clippy::result_expect_used` has been renamed to `clippy::expect_used`\n-  --> $DIR/rename.rs:59:9\n+  --> $DIR/rename.rs:60:9\n    |\n LL | #![warn(clippy::result_expect_used)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::expect_used`\n \n error: lint `clippy::result_map_unwrap_or_else` has been renamed to `clippy::map_unwrap_or`\n-  --> $DIR/rename.rs:60:9\n+  --> $DIR/rename.rs:61:9\n    |\n LL | #![warn(clippy::result_map_unwrap_or_else)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::map_unwrap_or`\n \n error: lint `clippy::result_unwrap_used` has been renamed to `clippy::unwrap_used`\n-  --> $DIR/rename.rs:61:9\n+  --> $DIR/rename.rs:62:9\n    |\n LL | #![warn(clippy::result_unwrap_used)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::unwrap_used`\n \n error: lint `clippy::single_char_push_str` has been renamed to `clippy::single_char_add_str`\n-  --> $DIR/rename.rs:62:9\n+  --> $DIR/rename.rs:63:9\n    |\n LL | #![warn(clippy::single_char_push_str)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::single_char_add_str`\n \n error: lint `clippy::stutter` has been renamed to `clippy::module_name_repetitions`\n-  --> $DIR/rename.rs:63:9\n+  --> $DIR/rename.rs:64:9\n    |\n LL | #![warn(clippy::stutter)]\n    |         ^^^^^^^^^^^^^^^ help: use the new name: `clippy::module_name_repetitions`\n \n error: lint `clippy::to_string_in_display` has been renamed to `clippy::recursive_format_impl`\n-  --> $DIR/rename.rs:64:9\n+  --> $DIR/rename.rs:65:9\n    |\n LL | #![warn(clippy::to_string_in_display)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::recursive_format_impl`\n \n error: lint `clippy::zero_width_space` has been renamed to `clippy::invisible_characters`\n-  --> $DIR/rename.rs:65:9\n+  --> $DIR/rename.rs:66:9\n    |\n LL | #![warn(clippy::zero_width_space)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::invisible_characters`\n \n error: lint `clippy::drop_bounds` has been renamed to `drop_bounds`\n-  --> $DIR/rename.rs:66:9\n+  --> $DIR/rename.rs:67:9\n    |\n LL | #![warn(clippy::drop_bounds)]\n    |         ^^^^^^^^^^^^^^^^^^^ help: use the new name: `drop_bounds`\n \n error: lint `clippy::into_iter_on_array` has been renamed to `array_into_iter`\n-  --> $DIR/rename.rs:67:9\n+  --> $DIR/rename.rs:68:9\n    |\n LL | #![warn(clippy::into_iter_on_array)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `array_into_iter`\n \n error: lint `clippy::invalid_atomic_ordering` has been renamed to `invalid_atomic_ordering`\n-  --> $DIR/rename.rs:68:9\n+  --> $DIR/rename.rs:69:9\n    |\n LL | #![warn(clippy::invalid_atomic_ordering)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `invalid_atomic_ordering`\n \n error: lint `clippy::invalid_ref` has been renamed to `invalid_value`\n-  --> $DIR/rename.rs:69:9\n+  --> $DIR/rename.rs:70:9\n    |\n LL | #![warn(clippy::invalid_ref)]\n    |         ^^^^^^^^^^^^^^^^^^^ help: use the new name: `invalid_value`\n \n error: lint `clippy::mem_discriminant_non_enum` has been renamed to `enum_intrinsics_non_enums`\n-  --> $DIR/rename.rs:70:9\n+  --> $DIR/rename.rs:71:9\n    |\n LL | #![warn(clippy::mem_discriminant_non_enum)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `enum_intrinsics_non_enums`\n \n error: lint `clippy::panic_params` has been renamed to `non_fmt_panics`\n-  --> $DIR/rename.rs:71:9\n+  --> $DIR/rename.rs:72:9\n    |\n LL | #![warn(clippy::panic_params)]\n    |         ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `non_fmt_panics`\n \n+error: lint `clippy::positional_named_format_parameters` has been renamed to `named_arguments_used_positionally`\n+  --> $DIR/rename.rs:73:9\n+   |\n+LL | #![warn(clippy::positional_named_format_parameters)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `named_arguments_used_positionally`\n+\n error: lint `clippy::temporary_cstring_as_ptr` has been renamed to `temporary_cstring_as_ptr`\n-  --> $DIR/rename.rs:72:9\n+  --> $DIR/rename.rs:74:9\n    |\n LL | #![warn(clippy::temporary_cstring_as_ptr)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `temporary_cstring_as_ptr`\n \n error: lint `clippy::unknown_clippy_lints` has been renamed to `unknown_lints`\n-  --> $DIR/rename.rs:73:9\n+  --> $DIR/rename.rs:75:9\n    |\n LL | #![warn(clippy::unknown_clippy_lints)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `unknown_lints`\n \n error: lint `clippy::unused_label` has been renamed to `unused_labels`\n-  --> $DIR/rename.rs:74:9\n+  --> $DIR/rename.rs:76:9\n    |\n LL | #![warn(clippy::unused_label)]\n    |         ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `unused_labels`\n \n-error: aborting due to 37 previous errors\n+error: aborting due to 38 previous errors\n "}, {"sha": "5892818aa9a6173ac77d04968da4dc9c20f8de34", "filename": "tests/ui/write_literal.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fwrite_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fwrite_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_literal.rs?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -25,11 +25,13 @@ fn main() {\n     writeln!(v, \"{} of {:b} people know binary, the other half doesn't\", 1, 2);\n     writeln!(v, \"10 / 4 is {}\", 2.5);\n     writeln!(v, \"2 + 1 = {}\", 3);\n+    writeln!(v, \"From expansion {}\", stringify!(not a string literal));\n \n     // these should throw warnings\n     write!(v, \"Hello {}\", \"world\");\n     writeln!(v, \"Hello {} {}\", world, \"world\");\n     writeln!(v, \"Hello {}\", \"world\");\n+    writeln!(v, \"{} {:.4}\", \"a literal\", 5);\n \n     // positional args don't change the fact\n     // that we're using a literal -- this should"}, {"sha": "1e306ae28a263ca094c30bd57d29decd3fec839e", "filename": "tests/ui/write_literal.stderr", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fwrite_literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fwrite_literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_literal.stderr?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -1,5 +1,5 @@\n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:30:27\n+  --> $DIR/write_literal.rs:31:27\n    |\n LL |     write!(v, \"Hello {}\", \"world\");\n    |                           ^^^^^^^\n@@ -12,7 +12,7 @@ LL +     write!(v, \"Hello world\");\n    |\n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:31:39\n+  --> $DIR/write_literal.rs:32:39\n    |\n LL |     writeln!(v, \"Hello {} {}\", world, \"world\");\n    |                                       ^^^^^^^\n@@ -24,7 +24,7 @@ LL +     writeln!(v, \"Hello {} world\", world);\n    |\n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:32:29\n+  --> $DIR/write_literal.rs:33:29\n    |\n LL |     writeln!(v, \"Hello {}\", \"world\");\n    |                             ^^^^^^^\n@@ -36,7 +36,19 @@ LL +     writeln!(v, \"Hello world\");\n    |\n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:37:28\n+  --> $DIR/write_literal.rs:34:29\n+   |\n+LL |     writeln!(v, \"{} {:.4}\", \"a literal\", 5);\n+   |                             ^^^^^^^^^^^\n+   |\n+help: try this\n+   |\n+LL -     writeln!(v, \"{} {:.4}\", \"a literal\", 5);\n+LL +     writeln!(v, \"a literal {:.4}\", 5);\n+   |\n+\n+error: literal with an empty format string\n+  --> $DIR/write_literal.rs:39:28\n    |\n LL |     writeln!(v, \"{0} {1}\", \"hello\", \"world\");\n    |                            ^^^^^^^\n@@ -48,7 +60,7 @@ LL +     writeln!(v, \"hello {1}\", \"world\");\n    |\n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:37:37\n+  --> $DIR/write_literal.rs:39:37\n    |\n LL |     writeln!(v, \"{0} {1}\", \"hello\", \"world\");\n    |                                     ^^^^^^^\n@@ -60,34 +72,34 @@ LL +     writeln!(v, \"{0} world\", \"hello\");\n    |\n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:38:28\n+  --> $DIR/write_literal.rs:40:37\n    |\n LL |     writeln!(v, \"{1} {0}\", \"hello\", \"world\");\n-   |                            ^^^^^^^\n+   |                                     ^^^^^^^\n    |\n help: try this\n    |\n LL -     writeln!(v, \"{1} {0}\", \"hello\", \"world\");\n-LL +     writeln!(v, \"{1} hello\", \"world\");\n+LL +     writeln!(v, \"world {0}\", \"hello\");\n    |\n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:38:37\n+  --> $DIR/write_literal.rs:40:28\n    |\n LL |     writeln!(v, \"{1} {0}\", \"hello\", \"world\");\n-   |                                     ^^^^^^^\n+   |                            ^^^^^^^\n    |\n help: try this\n    |\n LL -     writeln!(v, \"{1} {0}\", \"hello\", \"world\");\n-LL +     writeln!(v, \"world {0}\", \"hello\");\n+LL +     writeln!(v, \"{1} hello\", \"world\");\n    |\n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:41:32\n+  --> $DIR/write_literal.rs:43:38\n    |\n LL |     writeln!(v, \"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n-   |                                ^^^^^^^^^^^^^\n+   |                                      ^^^^^^^\n    |\n help: try this\n    |\n@@ -96,10 +108,10 @@ LL +     writeln!(v, \"hello {bar}\", bar = \"world\");\n    |\n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:41:47\n+  --> $DIR/write_literal.rs:43:53\n    |\n LL |     writeln!(v, \"{foo} {bar}\", foo = \"hello\", bar = \"world\");\n-   |                                               ^^^^^^^^^^^^^\n+   |                                                     ^^^^^^^\n    |\n help: try this\n    |\n@@ -108,28 +120,28 @@ LL +     writeln!(v, \"{foo} world\", foo = \"hello\");\n    |\n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:42:32\n+  --> $DIR/write_literal.rs:44:53\n    |\n LL |     writeln!(v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n-   |                                ^^^^^^^^^^^^^\n+   |                                                     ^^^^^^^\n    |\n help: try this\n    |\n LL -     writeln!(v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n-LL +     writeln!(v, \"{bar} hello\", bar = \"world\");\n+LL +     writeln!(v, \"world {foo}\", foo = \"hello\");\n    |\n \n error: literal with an empty format string\n-  --> $DIR/write_literal.rs:42:47\n+  --> $DIR/write_literal.rs:44:38\n    |\n LL |     writeln!(v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n-   |                                               ^^^^^^^^^^^^^\n+   |                                      ^^^^^^^\n    |\n help: try this\n    |\n LL -     writeln!(v, \"{bar} {foo}\", foo = \"hello\", bar = \"world\");\n-LL +     writeln!(v, \"world {foo}\", foo = \"hello\");\n+LL +     writeln!(v, \"{bar} hello\", bar = \"world\");\n    |\n \n-error: aborting due to 11 previous errors\n+error: aborting due to 12 previous errors\n "}, {"sha": "55a11daa1d3443a65fd557661c6c9c311a51478d", "filename": "tests/ui/write_literal_2.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fwrite_literal_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fwrite_literal_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_literal_2.rs?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -10,7 +10,7 @@ fn main() {\n     writeln!(v, r\"{}\", r\"{hello}\");\n     writeln!(v, \"{}\", '\\'');\n     writeln!(v, \"{}\", '\"');\n-    writeln!(v, r\"{}\", '\"'); // don't lint\n+    writeln!(v, r\"{}\", '\"');\n     writeln!(v, r\"{}\", '\\'');\n     writeln!(\n         v,\n@@ -24,4 +24,11 @@ fn main() {\n         {} \\\\ {}\",\n         \"1\", \"2\", \"3\",\n     );\n+    writeln!(v, \"{}\", \"\\\\\");\n+    writeln!(v, r\"{}\", \"\\\\\");\n+    writeln!(v, r#\"{}\"#, \"\\\\\");\n+    writeln!(v, \"{}\", r\"\\\");\n+    writeln!(v, \"{}\", \"\\r\");\n+    writeln!(v, r#\"{}{}\"#, '#', '\"'); // hard mode\n+    writeln!(v, r\"{}\", \"\\r\"); // should not lint\n }"}, {"sha": "d5956db9ff0b4450d9c0ee01fb13383f0b879829", "filename": "tests/ui/write_literal_2.stderr", "status": "modified", "additions": 79, "deletions": 1, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fwrite_literal_2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fwrite_literal_2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_literal_2.stderr?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -47,6 +47,12 @@ LL -     writeln!(v, \"{}\", '\"');\n LL +     writeln!(v, \"/\"\");\n    |\n \n+error: literal with an empty format string\n+  --> $DIR/write_literal_2.rs:13:24\n+   |\n+LL |     writeln!(v, r\"{}\", '\"');\n+   |                        ^^^\n+\n error: literal with an empty format string\n   --> $DIR/write_literal_2.rs:14:24\n    |\n@@ -108,5 +114,77 @@ LL ~         {} / 3\",\n LL ~         \"1\", \"2\",\n    |\n \n-error: aborting due to 9 previous errors\n+error: literal with an empty format string\n+  --> $DIR/write_literal_2.rs:27:23\n+   |\n+LL |     writeln!(v, \"{}\", \"/\");\n+   |                       ^^^^\n+   |\n+help: try this\n+   |\n+LL -     writeln!(v, \"{}\", \"/\");\n+LL +     writeln!(v, \"/\");\n+   |\n+\n+error: literal with an empty format string\n+  --> $DIR/write_literal_2.rs:28:24\n+   |\n+LL |     writeln!(v, r\"{}\", \"/\");\n+   |                        ^^^^\n+   |\n+help: try this\n+   |\n+LL -     writeln!(v, r\"{}\", \"/\");\n+LL +     writeln!(v, r\"/\");\n+   |\n+\n+error: literal with an empty format string\n+  --> $DIR/write_literal_2.rs:29:26\n+   |\n+LL |     writeln!(v, r#\"{}\"#, \"/\");\n+   |                          ^^^^\n+   |\n+help: try this\n+   |\n+LL -     writeln!(v, r#\"{}\"#, \"/\");\n+LL +     writeln!(v, r#\"/\"#);\n+   |\n+\n+error: literal with an empty format string\n+  --> $DIR/write_literal_2.rs:30:23\n+   |\n+LL |     writeln!(v, \"{}\", r\"/\");\n+   |                       ^^^^\n+   |\n+help: try this\n+   |\n+LL -     writeln!(v, \"{}\", r\"/\");\n+LL +     writeln!(v, \"/\");\n+   |\n+\n+error: literal with an empty format string\n+  --> $DIR/write_literal_2.rs:31:23\n+   |\n+LL |     writeln!(v, \"{}\", \"/r\");\n+   |                       ^^^^\n+   |\n+help: try this\n+   |\n+LL -     writeln!(v, \"{}\", \"/r\");\n+LL +     writeln!(v, \"/r\");\n+   |\n+\n+error: literal with an empty format string\n+  --> $DIR/write_literal_2.rs:32:28\n+   |\n+LL |     writeln!(v, r#\"{}{}\"#, '#', '\"'); // hard mode\n+   |                            ^^^\n+\n+error: literal with an empty format string\n+  --> $DIR/write_literal_2.rs:32:33\n+   |\n+LL |     writeln!(v, r#\"{}{}\"#, '#', '\"'); // hard mode\n+   |                                 ^^^\n+\n+error: aborting due to 17 previous errors\n "}, {"sha": "b79364c8758c5809c32de86ced02ec9f17c79dc8", "filename": "tests/ui/write_with_newline.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fwrite_with_newline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fwrite_with_newline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_with_newline.rs?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -56,4 +56,12 @@ fn main() {\n     write!(v, \"foo\\r\\n\");\n     write!(v, \"\\\\r\\n\"); //~ ERROR\n     write!(v, \"foo\\rbar\\n\");\n+\n+    // Ignore expanded format strings\n+    macro_rules! newline {\n+        () => {\n+            \"\\n\"\n+        };\n+    }\n+    write!(v, newline!());\n }"}, {"sha": "2baaea166d8ef189c094c195e58a19a63d1e75f3", "filename": "tests/ui/write_with_newline.stderr", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fwrite_with_newline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fwrite_with_newline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_with_newline.stderr?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -5,7 +5,7 @@ LL |     write!(v, \"Hello/n\");\n    |     ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::write-with-newline` implied by `-D warnings`\n-help: use `writeln!()` instead\n+help: use `writeln!` instead\n    |\n LL -     write!(v, \"Hello/n\");\n LL +     writeln!(v, \"Hello\");\n@@ -17,7 +17,7 @@ error: using `write!()` with a format string that ends in a single newline\n LL |     write!(v, \"Hello {}/n\", \"world\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: use `writeln!()` instead\n+help: use `writeln!` instead\n    |\n LL -     write!(v, \"Hello {}/n\", \"world\");\n LL +     writeln!(v, \"Hello {}\", \"world\");\n@@ -29,7 +29,7 @@ error: using `write!()` with a format string that ends in a single newline\n LL |     write!(v, \"Hello {} {}/n\", \"world\", \"#2\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: use `writeln!()` instead\n+help: use `writeln!` instead\n    |\n LL -     write!(v, \"Hello {} {}/n\", \"world\", \"#2\");\n LL +     writeln!(v, \"Hello {} {}\", \"world\", \"#2\");\n@@ -41,7 +41,7 @@ error: using `write!()` with a format string that ends in a single newline\n LL |     write!(v, \"{}/n\", 1265);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: use `writeln!()` instead\n+help: use `writeln!` instead\n    |\n LL -     write!(v, \"{}/n\", 1265);\n LL +     writeln!(v, \"{}\", 1265);\n@@ -53,7 +53,7 @@ error: using `write!()` with a format string that ends in a single newline\n LL |     write!(v, \"/n\");\n    |     ^^^^^^^^^^^^^^^\n    |\n-help: use `writeln!()` instead\n+help: use `writeln!` instead\n    |\n LL -     write!(v, \"/n\");\n LL +     writeln!(v);\n@@ -65,7 +65,7 @@ error: using `write!()` with a format string that ends in a single newline\n LL |     write!(v, \"//n\"); // should fail\n    |     ^^^^^^^^^^^^^^^^^\n    |\n-help: use `writeln!()` instead\n+help: use `writeln!` instead\n    |\n LL -     write!(v, \"//n\"); // should fail\n LL +     writeln!(v, \"/\"); // should fail\n@@ -81,11 +81,10 @@ LL | | \"\n LL | |     );\n    | |_____^\n    |\n-help: use `writeln!()` instead\n+help: use `writeln!` instead\n    |\n LL ~     writeln!(\n-LL |         v,\n-LL ~         \"\"\n+LL ~         v\n    |\n \n error: using `write!()` with a format string that ends in a single newline\n@@ -98,11 +97,10 @@ LL | | \"\n LL | |     );\n    | |_____^\n    |\n-help: use `writeln!()` instead\n+help: use `writeln!` instead\n    |\n LL ~     writeln!(\n-LL |         v,\n-LL ~         r\"\"\n+LL ~         v\n    |\n \n error: using `write!()` with a format string that ends in a single newline\n@@ -111,23 +109,11 @@ error: using `write!()` with a format string that ends in a single newline\n LL |     write!(v, \"/r/n\"); //~ ERROR\n    |     ^^^^^^^^^^^^^^^^^^\n    |\n-help: use `writeln!()` instead\n+help: use `writeln!` instead\n    |\n LL -     write!(v, \"/r/n\"); //~ ERROR\n LL +     writeln!(v, \"/r\"); //~ ERROR\n    |\n \n-error: using `write!()` with a format string that ends in a single newline\n-  --> $DIR/write_with_newline.rs:58:5\n-   |\n-LL |     write!(v, \"foo/rbar/n\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: use `writeln!()` instead\n-   |\n-LL -     write!(v, \"foo/rbar/n\");\n-LL +     writeln!(v, \"foo/rbar\");\n-   |\n-\n-error: aborting due to 10 previous errors\n+error: aborting due to 9 previous errors\n "}, {"sha": "25e69ec48e7e28cb413a8f60a1b3b5969aaa3762", "filename": "tests/ui/writeln_empty_string.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fwriteln_empty_string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ddbc86bef837b1072159c020c35940ce52ae696/tests%2Fui%2Fwriteln_empty_string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwriteln_empty_string.stderr?ref=2ddbc86bef837b1072159c020c35940ce52ae696", "patch": "@@ -1,16 +1,20 @@\n-error: using `writeln!(v, \"\")`\n+error: empty string literal in `writeln!`\n   --> $DIR/writeln_empty_string.rs:11:5\n    |\n LL |     writeln!(v, \"\");\n-   |     ^^^^^^^^^^^^^^^ help: replace it with: `writeln!(v)`\n+   |     ^^^^^^^^^^----^\n+   |               |\n+   |               help: remove the empty string\n    |\n    = note: `-D clippy::writeln-empty-string` implied by `-D warnings`\n \n-error: using `writeln!(suggestion, \"\")`\n+error: empty string literal in `writeln!`\n   --> $DIR/writeln_empty_string.rs:14:5\n    |\n LL |     writeln!(suggestion, \"\");\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `writeln!(suggestion)`\n+   |     ^^^^^^^^^^^^^^^^^^^----^\n+   |                        |\n+   |                        help: remove the empty string\n \n error: aborting due to 2 previous errors\n "}]}