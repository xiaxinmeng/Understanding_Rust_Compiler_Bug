{"sha": "571eec627c63cea40ea9fba16b86cfafb1446c34", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3MWVlYzYyN2M2M2NlYTQwZWE5ZmJhMTZiODZjZmFmYjE0NDZjMzQ=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-07-20T16:30:31Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-07-22T11:49:35Z"}, "message": "Improved closure errors.", "tree": {"sha": "d2c72ef7ef4e6357c3380cf58b1f026d9ddb39ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2c72ef7ef4e6357c3380cf58b1f026d9ddb39ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/571eec627c63cea40ea9fba16b86cfafb1446c34", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAltUb1EACgkQAXYLT59T\n8VQQFhAAogXQZcMQAwTGVoDtQ7+PjfMyLuv2VCZVUNWYQo63yyRHAiOUt3zfqkfr\nl+s6Q5LP6eVD/zG9iyNNkOicP5pNH3kr9pZAoLw5l+rnmXJmkWa3FL+/E0gMDT6b\nXKPG1scGzD9Tb3CiqQNB7sTE8GojYfXUPJJtD9/uk9cZG1NWznbwIcKR3pmprahr\n9ZfPayN5U30QFSOEPvdp02r0aV2ZyjtpiAEszTEqPnD1EQtBdd2r/WDT5TCMF0pv\ne+n+6fEcDPtrNMvZ7/FcK4kBffxn90Ln28++HXxFf3QVx2dgiX772a4O25C1GuFY\nVxgQZvFof6P7ggfafL0Hb6wc2l7Er70eD7WorSB+pqUzvdpq2hvBC48p+l5bQa0a\nqHkydVtTqCZvaKr2TGA1WHl2ko0GzcrHLXDXkI6eLHnXfgF9f2ptWnPVZ2PkHRjW\niUolKre0nBw0q8fhHaBXR+34GYadDPM+yY0DbGHM6ws7+UNrU/NhSLXh0/Q2x2Eo\nV3JuKnbTKlWQmFC70AagsZfTF6cqueFHErM3FWMdjgwDTiaGs6uTeFbAkYiRqRRT\nyhgxlaYqfAJhhqPm9eCOyD95poHrDlvl+lDdr0cUoSK7pA8/12DoM9Ij3ECNCDa4\nHxiZWjww+TD129D4jlVDdmzKdwgAcnmFmrDIWXcw4qbHOsX+w88=\n=pVHK\n-----END PGP SIGNATURE-----", "payload": "tree d2c72ef7ef4e6357c3380cf58b1f026d9ddb39ab\nparent 24c5751197f4971c7f7e387c035cac3565f2f629\nauthor David Wood <david@davidtw.co> 1532104231 +0100\ncommitter David Wood <david@davidtw.co> 1532260175 +0100\n\nImproved closure errors.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/571eec627c63cea40ea9fba16b86cfafb1446c34", "html_url": "https://github.com/rust-lang/rust/commit/571eec627c63cea40ea9fba16b86cfafb1446c34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/571eec627c63cea40ea9fba16b86cfafb1446c34/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24c5751197f4971c7f7e387c035cac3565f2f629", "url": "https://api.github.com/repos/rust-lang/rust/commits/24c5751197f4971c7f7e387c035cac3565f2f629", "html_url": "https://github.com/rust-lang/rust/commit/24c5751197f4971c7f7e387c035cac3565f2f629"}], "stats": {"total": 430, "additions": 299, "deletions": 131}, "files": [{"sha": "c46f561e7b320a768c8bca38430592ca86bfa8d2", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/571eec627c63cea40ea9fba16b86cfafb1446c34/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/571eec627c63cea40ea9fba16b86cfafb1446c34/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=571eec627c63cea40ea9fba16b86cfafb1446c34", "patch": "@@ -119,6 +119,37 @@ impl<'tcx> Place<'tcx> {\n                 proj.base.ty(local_decls, tcx).projection_ty(tcx, &proj.elem),\n         }\n     }\n+\n+    /// If this is a field projection, and the field is being projected from a closure type,\n+    /// then returns the index of the field being projected. Note that this closure will always\n+    /// be `self` in the current MIR, because that is the only time we directly access the fields\n+    /// of a closure type.\n+    pub fn is_upvar_field_projection<'cx, 'gcx>(&self, mir: &'cx Mir<'tcx>,\n+                                                tcx: &TyCtxt<'cx, 'gcx, 'tcx>,\n+                                                recurse: bool) -> Option<Field> {\n+        match *self {\n+            Place::Projection(ref proj) => match proj.elem {\n+                ProjectionElem::Field(field, _ty) => {\n+                    let base_ty = proj.base.ty(mir, *tcx).to_ty(*tcx);\n+\n+                    if  base_ty.is_closure() || base_ty.is_generator() {\n+                        Some(field)\n+                    } else {\n+                        None\n+                    }\n+                },\n+                ProjectionElem::Deref => {\n+                    if recurse {\n+                        proj.base.is_upvar_field_projection(mir, tcx, recurse)\n+                    } else {\n+                        None\n+                    }\n+                },\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    }\n }\n \n pub enum RvalueInitializationState {"}, {"sha": "9f5f1389c66a0bfc36c897cef6d86505cd8faad1", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/571eec627c63cea40ea9fba16b86cfafb1446c34/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/571eec627c63cea40ea9fba16b86cfafb1446c34/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=571eec627c63cea40ea9fba16b86cfafb1446c34", "patch": "@@ -726,7 +726,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n-                        if let Some(field) = self.is_upvar_field_projection(&proj.base) {\n+                        let upvar_field_projection = proj.base.is_upvar_field_projection(\n+                            self.mir, &self.tcx, false);\n+                        if let Some(field) = upvar_field_projection {\n                             let var_index = field.index();\n                             let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n                             if self.mir.upvar_decls[var_index].by_ref {\n@@ -785,7 +787,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     ProjectionElem::Field(field, _ty) => {\n                         autoderef = true;\n \n-                        if let Some(field) = self.is_upvar_field_projection(place) {\n+                        let upvar_field_projection = place.is_upvar_field_projection(\n+                            self.mir, &self.tcx, false);\n+                        if let Some(field) = upvar_field_projection {\n                             let var_index = field.index();\n                             let name = self.mir.upvar_decls[var_index].debug_name.to_string();\n                             buf.push_str(&name);"}, {"sha": "f37052470c8f85b6eb03fe334409606b0818ceb1", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 8, "deletions": 26, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/571eec627c63cea40ea9fba16b86cfafb1446c34/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/571eec627c63cea40ea9fba16b86cfafb1446c34/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=571eec627c63cea40ea9fba16b86cfafb1446c34", "patch": "@@ -1214,7 +1214,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                 }\n                                 Operand::Move(ref place @ Place::Projection(_))\n                                 | Operand::Copy(ref place @ Place::Projection(_)) => {\n-                                    if let Some(field) = self.is_upvar_field_projection(place) {\n+                                    if let Some(field) = place.is_upvar_field_projection(\n+                                            self.mir, &self.tcx, false) {\n                                         self.used_mut_upvars.push(field);\n                                     }\n                                 }\n@@ -1803,7 +1804,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 place: place @ Place::Projection(_),\n                 is_local_mutation_allowed: _,\n             } => {\n-                if let Some(field) = self.is_upvar_field_projection(&place) {\n+                if let Some(field) = place.is_upvar_field_projection(self.mir, &self.tcx, false) {\n                     self.used_mut_upvars.push(field);\n                 }\n             }\n@@ -1866,7 +1867,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // Mutably borrowed data is mutable, but only if we have a\n                                     // unique path to the `&mut`\n                                     hir::MutMutable => {\n-                                        let mode = match self.is_upvar_field_projection(&proj.base)\n+                                        let mode = match proj.base.is_upvar_field_projection(\n+                                            self.mir, &self.tcx, false)\n                                         {\n                                             Some(field)\n                                                 if {\n@@ -1911,7 +1913,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     | ProjectionElem::ConstantIndex { .. }\n                     | ProjectionElem::Subslice { .. }\n                     | ProjectionElem::Downcast(..) => {\n-                        if let Some(field) = self.is_upvar_field_projection(place) {\n+                        let upvar_field_projection = place.is_upvar_field_projection(\n+                            self.mir, &self.tcx, false);\n+                        if let Some(field) = upvar_field_projection {\n                             let decl = &self.mir.upvar_decls[field.index()];\n                             debug!(\n                                 \"decl.mutability={:?} local_mutation_is_allowed={:?} place={:?}\",\n@@ -1965,28 +1969,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n         }\n     }\n-\n-    /// If this is a field projection, and the field is being projected from a closure type,\n-    /// then returns the index of the field being projected. Note that this closure will always\n-    /// be `self` in the current MIR, because that is the only time we directly access the fields\n-    /// of a closure type.\n-    fn is_upvar_field_projection(&self, place: &Place<'tcx>) -> Option<Field> {\n-        match *place {\n-            Place::Projection(ref proj) => match proj.elem {\n-                ProjectionElem::Field(field, _ty) => {\n-                    let base_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n-\n-                    if base_ty.is_closure() || base_ty.is_generator() {\n-                        Some(field)\n-                    } else {\n-                        None\n-                    }\n-                }\n-                _ => None,\n-            },\n-            _ => None,\n-        }\n-    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]"}, {"sha": "93e8f3f86573e84c9e7238e92a09ac684da5ac3e", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 77, "deletions": 21, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/571eec627c63cea40ea9fba16b86cfafb1446c34/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/571eec627c63cea40ea9fba16b86cfafb1446c34/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=571eec627c63cea40ea9fba16b86cfafb1446c34", "patch": "@@ -22,6 +22,7 @@ use std::fmt;\n use syntax_pos::Span;\n \n mod region_name;\n+mod var_name;\n \n /// Constraints that are considered interesting can be categorized to\n /// determine why they are interesting. Order of variants indicates\n@@ -30,6 +31,7 @@ mod region_name;\n enum ConstraintCategory {\n     Cast,\n     Assignment,\n+    AssignmentToUpvar,\n     Return,\n     CallArgument,\n     Other,\n@@ -39,7 +41,8 @@ enum ConstraintCategory {\n impl fmt::Display for ConstraintCategory {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self {\n-            ConstraintCategory::Assignment => write!(f, \"assignment\"),\n+            ConstraintCategory::Assignment |\n+            ConstraintCategory::AssignmentToUpvar => write!(f, \"assignment\"),\n             ConstraintCategory::Return => write!(f, \"return\"),\n             ConstraintCategory::Cast => write!(f, \"cast\"),\n             ConstraintCategory::CallArgument => write!(f, \"argument\"),\n@@ -130,6 +133,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         index: ConstraintIndex,\n         mir: &Mir<'tcx>,\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n     ) -> (ConstraintCategory, Span) {\n         let constraint = self.constraints[index];\n         debug!(\"classify_constraint: constraint={:?}\", constraint);\n@@ -159,7 +163,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             match statement.kind {\n                 StatementKind::Assign(ref place, ref rvalue) => {\n                     debug!(\"classify_constraint: place={:?} rvalue={:?}\", place, rvalue);\n-                    if *place == Place::Local(mir::RETURN_PLACE) {\n+                    let initial_category = if *place == Place::Local(mir::RETURN_PLACE) {\n                         ConstraintCategory::Return\n                     } else {\n                         match rvalue {\n@@ -168,6 +172,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                             Rvalue::Aggregate(..) => ConstraintCategory::Assignment,\n                             _ => ConstraintCategory::Other,\n                         }\n+                    };\n+\n+                    if initial_category == ConstraintCategory::Assignment\n+                            && place.is_upvar_field_projection(mir, &infcx.tcx, true).is_some() {\n+                        ConstraintCategory::AssignmentToUpvar\n+                    } else {\n+                        initial_category\n                     }\n                 }\n                 _ => ConstraintCategory::Other,\n@@ -214,7 +225,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         // Classify each of the constraints along the path.\n         let mut categorized_path: Vec<(ConstraintCategory, Span)> = path.iter()\n-            .map(|&index| self.classify_constraint(index, mir))\n+            .map(|&index| self.classify_constraint(index, mir, infcx))\n             .collect();\n         debug!(\"report_error: categorized_path={:?}\", categorized_path);\n \n@@ -224,30 +235,75 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         // Get a span\n         let (category, span) = categorized_path.first().unwrap();\n+\n+        match category {\n+            ConstraintCategory::AssignmentToUpvar =>\n+                self.report_closure_error(mir, infcx, fr, outlived_fr, span),\n+            _ =>\n+                self.report_general_error(mir, infcx, mir_def_id, fr, outlived_fr, category, span),\n+        }\n+    }\n+\n+    fn report_closure_error(\n+        &self,\n+        mir: &Mir<'tcx>,\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        fr: RegionVid,\n+        outlived_fr: RegionVid,\n+        span: &Span,\n+    ) {\n         let diag = &mut infcx.tcx.sess.struct_span_err(\n-            *span,\n-            &format!(\"unsatisfied lifetime constraints\"), // FIXME\n+            *span, &format!(\"borrowed data escapes outside of closure\"),\n+        );\n+\n+        let (outlived_fr_name, outlived_fr_span) = self.get_var_name_and_span_for_region(\n+            infcx.tcx, mir, outlived_fr);\n+\n+        if let Some(name) = outlived_fr_name {\n+            diag.span_label(\n+                outlived_fr_span,\n+                format!(\"`{}` is declared here, outside of the closure body\", name),\n+            );\n+        }\n+\n+        let (fr_name, fr_span) = self.get_var_name_and_span_for_region(infcx.tcx, mir, fr);\n+\n+        if let Some(name) = fr_name {\n+            diag.span_label(\n+                fr_span,\n+                format!(\"`{}` is a reference that is only valid in the closure body\", name),\n+            );\n+\n+            diag.span_label(*span, format!(\"`{}` escapes the closure body here\", name));\n+        }\n+\n+        diag.emit();\n+    }\n+\n+    fn report_general_error(\n+        &self,\n+        mir: &Mir<'tcx>,\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        mir_def_id: DefId,\n+        fr: RegionVid,\n+        outlived_fr: RegionVid,\n+        category: &ConstraintCategory,\n+        span: &Span,\n+    ) {\n+        let diag = &mut infcx.tcx.sess.struct_span_err(\n+            *span, &format!(\"unsatisfied lifetime constraints\"), // FIXME\n         );\n \n-        // Figure out how we can refer\n         let counter = &mut 1;\n-        let fr_name = self.give_region_a_name(infcx.tcx, mir, mir_def_id, fr, counter, diag);\n+        let fr_name = self.give_region_a_name(\n+            infcx.tcx, mir, mir_def_id, fr, counter, diag);\n         let outlived_fr_name = self.give_region_a_name(\n-            infcx.tcx,\n-            mir,\n-            mir_def_id,\n-            outlived_fr,\n-            counter,\n-            diag,\n-        );\n+            infcx.tcx, mir, mir_def_id, outlived_fr, counter, diag);\n \n-        diag.span_label(\n-            *span,\n-            format!(\n-                \"{} requires that `{}` must outlive `{}`\",\n-                category, fr_name, outlived_fr_name,\n-            ),\n-        );\n+        diag.span_label(*span, format!(\n+            \"{} requires that `{}` must outlive `{}`\",\n+            category, fr_name, outlived_fr_name,\n+        ));\n \n         diag.emit();\n     }"}, {"sha": "756afcdfae081e4b4ee3808a2d953dab1c95955d", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 12, "deletions": 54, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/571eec627c63cea40ea9fba16b86cfafb1446c34/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/571eec627c63cea40ea9fba16b86cfafb1446c34/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=571eec627c63cea40ea9fba16b86cfafb1446c34", "patch": "@@ -12,10 +12,9 @@ use borrow_check::nll::region_infer::RegionInferenceContext;\n use borrow_check::nll::ToRegionVid;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::mir::{Local, Mir};\n+use rustc::mir::Mir;\n use rustc::ty::subst::{Substs, UnpackedKind};\n use rustc::ty::{self, RegionVid, Ty, TyCtxt};\n-use rustc_data_structures::indexed_vec::Idx;\n use rustc_errors::DiagnosticBuilder;\n use syntax::ast::Name;\n use syntax::symbol::keywords;\n@@ -63,11 +62,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.give_name_from_error_region(tcx, mir_def_id, fr, counter, diag)\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_arguments(\n-                    tcx, mir, mir_def_id, fr, counter, diag,\n-                )\n+                    tcx, mir, mir_def_id, fr, counter, diag)\n             })\n             .or_else(|| {\n-                self.give_name_if_anonymous_region_appears_in_upvars(tcx, mir, fr, counter, diag)\n+                self.give_name_if_anonymous_region_appears_in_upvars(\n+                    tcx, mir, fr, counter, diag)\n             })\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_output(tcx, mir, fr, counter, diag)\n@@ -139,24 +138,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         diag: &mut DiagnosticBuilder<'_>,\n     ) -> Option<InternedString> {\n         let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();\n-        let argument_index = self\n-            .universal_regions\n-            .unnormalized_input_tys\n-            .iter()\n-            .skip(implicit_inputs)\n-            .position(|arg_ty| {\n-                debug!(\n-                    \"give_name_if_anonymous_region_appears_in_arguments: arg_ty = {:?}\",\n-                    arg_ty\n-                );\n-                tcx.any_free_region_meets(arg_ty, |r| r.to_region_vid() == fr)\n-            })?;\n-\n-        debug!(\n-            \"give_name_if_anonymous_region_appears_in_arguments: \\\n-             found {:?} in argument {} which has type {:?}\",\n-            fr, argument_index, self.universal_regions.unnormalized_input_tys[argument_index],\n-        );\n+        let argument_index = self.get_argument_index_for_region(tcx, fr)?;\n \n         let arg_ty =\n             self.universal_regions.unnormalized_input_tys[implicit_inputs + argument_index];\n@@ -172,10 +154,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return Some(region_name);\n         }\n \n+        let (_argument_name, argument_span) = self.get_argument_name_and_span_for_region(\n+            mir, argument_index);\n+\n         let region_name = self.synthesize_region_name(counter);\n \n-        let argument_local = Local::new(argument_index + implicit_inputs + 1);\n-        let argument_span = mir.local_decls[argument_local].source_info.span;\n         diag.span_label(\n             argument_span,\n             format!(\"lifetime `{}` appears in this argument\", region_name,),\n@@ -440,41 +423,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         counter: &mut usize,\n         diag: &mut DiagnosticBuilder<'_>,\n     ) -> Option<InternedString> {\n-        let upvar_index = self\n-            .universal_regions\n-            .defining_ty\n-            .upvar_tys(tcx)\n-            .position(|upvar_ty| {\n-                debug!(\n-                    \"give_name_if_anonymous_region_appears_in_upvars: upvar_ty = {:?}\",\n-                    upvar_ty,\n-                );\n-                tcx.any_free_region_meets(&upvar_ty, |r| r.to_region_vid() == fr)\n-            })?;\n-\n-        let upvar_ty = self\n-            .universal_regions\n-            .defining_ty\n-            .upvar_tys(tcx)\n-            .nth(upvar_index);\n-\n-        debug!(\n-            \"give_name_if_anonymous_region_appears_in_upvars: \\\n-             found {:?} in upvar {} which has type {:?}\",\n-            fr, upvar_index, upvar_ty,\n-        );\n-\n+        let upvar_index = self.get_upvar_index_for_region(tcx, fr)?;\n+        let (upvar_name, upvar_span) = self.get_upvar_name_and_span_for_region(tcx, mir,\n+                                                                               upvar_index);\n         let region_name = self.synthesize_region_name(counter);\n \n-        let upvar_hir_id = mir.upvar_decls[upvar_index].var_hir_id.assert_crate_local();\n-        let upvar_node_id = tcx.hir.hir_to_node_id(upvar_hir_id);\n-        let upvar_span = tcx.hir.span(upvar_node_id);\n-        let upvar_name = tcx.hir.name(upvar_node_id);\n         diag.span_label(\n             upvar_span,\n             format!(\n                 \"lifetime `{}` appears in the type of `{}`\",\n-                region_name, upvar_name,\n+                region_name, upvar_name.unwrap(),\n             ),\n         );\n "}, {"sha": "a86ee5a4f91a7f12d16aab92c0b7a22ad94f1b44", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/var_name.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/571eec627c63cea40ea9fba16b86cfafb1446c34/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/571eec627c63cea40ea9fba16b86cfafb1446c34/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs?ref=571eec627c63cea40ea9fba16b86cfafb1446c34", "patch": "@@ -0,0 +1,137 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrow_check::nll::region_infer::RegionInferenceContext;\n+use borrow_check::nll::ToRegionVid;\n+use rustc::mir::{Local, Mir};\n+use rustc::ty::{RegionVid, TyCtxt};\n+use rustc_data_structures::indexed_vec::Idx;\n+use syntax::codemap::Span;\n+use syntax_pos::symbol::Symbol;\n+\n+impl<'tcx> RegionInferenceContext<'tcx> {\n+    crate fn get_var_name_and_span_for_region(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        fr: RegionVid,\n+    ) -> (Option<Symbol>, Span) {\n+        debug!(\"get_var_name_and_span_for_region(fr={:?})\", fr);\n+        assert!(self.universal_regions.is_universal_region(fr));\n+\n+        debug!(\"get_var_name_and_span_for_region: attempting upvar\");\n+        self.get_upvar_index_for_region(tcx, fr)\n+            .map(|index| self.get_upvar_name_and_span_for_region(tcx, mir, index))\n+            .or_else(|| {\n+                debug!(\"get_var_name_and_span_for_region: attempting argument\");\n+                self.get_argument_index_for_region(tcx, fr)\n+                    .map(|index| self.get_argument_name_and_span_for_region(mir, index))\n+            })\n+            .unwrap_or_else(|| span_bug!(mir.span, \"can't find var name for free region {:?}\", fr))\n+    }\n+\n+    /// Get upvar index for a region.\n+    crate fn get_upvar_index_for_region(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        fr: RegionVid,\n+    ) -> Option<usize> {\n+        let upvar_index = self\n+            .universal_regions\n+            .defining_ty\n+            .upvar_tys(tcx)\n+            .position(|upvar_ty| {\n+                debug!(\n+                    \"get_upvar_index_for_region: upvar_ty = {:?}\",\n+                    upvar_ty,\n+                );\n+                tcx.any_free_region_meets(&upvar_ty, |r| r.to_region_vid() == fr)\n+            })?;\n+\n+        let upvar_ty = self\n+            .universal_regions\n+            .defining_ty\n+            .upvar_tys(tcx)\n+            .nth(upvar_index);\n+\n+        debug!(\n+            \"get_upvar_index_for_region: found {:?} in upvar {} which has type {:?}\",\n+            fr, upvar_index, upvar_ty,\n+        );\n+\n+        Some(upvar_index)\n+    }\n+\n+    /// Get upvar name and span for a region.\n+    crate fn get_upvar_name_and_span_for_region(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        upvar_index: usize,\n+    ) -> (Option<Symbol>, Span) {\n+        let upvar_hir_id = mir.upvar_decls[upvar_index].var_hir_id.assert_crate_local();\n+        let upvar_node_id = tcx.hir.hir_to_node_id(upvar_hir_id);\n+        debug!(\"get_upvar_name_and_span_for_region: upvar_node_id={:?}\", upvar_node_id);\n+\n+        let upvar_name = tcx.hir.name(upvar_node_id);\n+        let upvar_span = tcx.hir.span(upvar_node_id);\n+        debug!(\"get_upvar_name_and_span_for_region: upvar_name={:?} upvar_span={:?}\",\n+               upvar_name, upvar_span);\n+\n+        (Some(upvar_name), upvar_span)\n+    }\n+\n+    /// Get argument index for a region.\n+    crate fn get_argument_index_for_region(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        fr: RegionVid,\n+    ) -> Option<usize> {\n+        let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();\n+        let argument_index = self\n+            .universal_regions\n+            .unnormalized_input_tys\n+            .iter()\n+            .skip(implicit_inputs)\n+            .position(|arg_ty| {\n+                debug!(\n+                    \"get_argument_index_for_region: arg_ty = {:?}\",\n+                    arg_ty\n+                );\n+                tcx.any_free_region_meets(arg_ty, |r| r.to_region_vid() == fr)\n+            })?;\n+\n+        debug!(\n+            \"get_argument_index_for_region: found {:?} in argument {} which has type {:?}\",\n+            fr, argument_index, self.universal_regions.unnormalized_input_tys[argument_index],\n+        );\n+\n+        Some(argument_index)\n+    }\n+\n+    /// Get argument name and span for a region.\n+    crate fn get_argument_name_and_span_for_region(\n+        &self,\n+        mir: &Mir<'tcx>,\n+        argument_index: usize,\n+    ) -> (Option<Symbol>, Span) {\n+        let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();\n+        let argument_local = Local::new(implicit_inputs + argument_index + 1);\n+        debug!(\"get_argument_name_and_span_for_region: argument_local={:?}\", argument_local);\n+\n+        let argument_name = mir.local_decls[argument_local].name;\n+        let argument_span = mir.local_decls[argument_local].source_info.span;\n+        debug!(\"get_argument_name_and_span_for_region: argument_name={:?} argument_span={:?}\",\n+               argument_name, argument_span);\n+\n+        (argument_name, argument_span)\n+    }\n+\n+}"}, {"sha": "64086cb07917d81a7141e3984271c47d78f890c9", "filename": "src/test/ui/borrowck/issue-45983.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/571eec627c63cea40ea9fba16b86cfafb1446c34/src%2Ftest%2Fui%2Fborrowck%2Fissue-45983.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/571eec627c63cea40ea9fba16b86cfafb1446c34/src%2Ftest%2Fui%2Fborrowck%2Fissue-45983.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-45983.nll.stderr?ref=571eec627c63cea40ea9fba16b86cfafb1446c34", "patch": "@@ -4,15 +4,15 @@ warning: not reporting region error due to nll\n LL |     give_any(|y| x = Some(y));\n    |                           ^\n \n-error: unsatisfied lifetime constraints\n+error: borrowed data escapes outside of closure\n   --> $DIR/issue-45983.rs:17:18\n    |\n LL |     let x = None;\n-   |         - lifetime `'2` appears in the type of `x`\n+   |         - `x` is declared here, outside of the closure body\n LL |     give_any(|y| x = Some(y));\n-   |               -  ^^^^^^^^^^^ assignment requires that `'1` must outlive `'2`\n+   |               -  ^^^^^^^^^^^ `y` escapes the closure body here\n    |               |\n-   |               lifetime `'1` appears in this argument\n+   |               `y` is a reference that is only valid in the closure body\n \n error[E0594]: cannot assign to `x`, as it is not declared as mutable\n   --> $DIR/issue-45983.rs:17:18"}, {"sha": "1a18817e943655705c715e1c80a7ca952e5da007", "filename": "src/test/ui/borrowck/regions-escape-bound-fn-2.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/571eec627c63cea40ea9fba16b86cfafb1446c34/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/571eec627c63cea40ea9fba16b86cfafb1446c34/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn-2.nll.stderr?ref=571eec627c63cea40ea9fba16b86cfafb1446c34", "patch": "@@ -4,15 +4,15 @@ warning: not reporting region error due to nll\n LL |     with_int(|y| x = Some(y));\n    |                           ^\n \n-error: unsatisfied lifetime constraints\n+error: borrowed data escapes outside of closure\n   --> $DIR/regions-escape-bound-fn-2.rs:18:18\n    |\n LL |     let mut x = None;\n-   |         ----- lifetime `'2` appears in the type of `x`\n+   |         ----- `x` is declared here, outside of the closure body\n LL |     with_int(|y| x = Some(y));\n-   |               -  ^^^^^^^^^^^ assignment requires that `'1` must outlive `'2`\n+   |               -  ^^^^^^^^^^^ `y` escapes the closure body here\n    |               |\n-   |               lifetime `'1` appears in this argument\n+   |               `y` is a reference that is only valid in the closure body\n \n error: aborting due to previous error\n "}, {"sha": "62ea9a0854bde9a1de42dd7b6b6289ae7d3e36ab", "filename": "src/test/ui/borrowck/regions-escape-bound-fn.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/571eec627c63cea40ea9fba16b86cfafb1446c34/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/571eec627c63cea40ea9fba16b86cfafb1446c34/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-bound-fn.nll.stderr?ref=571eec627c63cea40ea9fba16b86cfafb1446c34", "patch": "@@ -4,15 +4,15 @@ warning: not reporting region error due to nll\n LL |     with_int(|y| x = Some(y));\n    |                      ^^^^^^^\n \n-error: unsatisfied lifetime constraints\n+error: borrowed data escapes outside of closure\n   --> $DIR/regions-escape-bound-fn.rs:18:18\n    |\n LL |     let mut x: Option<&isize> = None;\n-   |         ----- lifetime `'2` appears in the type of `x`\n+   |         ----- `x` is declared here, outside of the closure body\n LL |     with_int(|y| x = Some(y));\n-   |               -  ^^^^^^^^^^^ assignment requires that `'1` must outlive `'2`\n+   |               -  ^^^^^^^^^^^ `y` escapes the closure body here\n    |               |\n-   |               lifetime `'1` appears in this argument\n+   |               `y` is a reference that is only valid in the closure body\n \n error: aborting due to previous error\n "}, {"sha": "44eead9fb5a987e98f45469acdc8bafd4c5c522c", "filename": "src/test/ui/borrowck/regions-escape-unboxed-closure.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/571eec627c63cea40ea9fba16b86cfafb1446c34/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-unboxed-closure.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/571eec627c63cea40ea9fba16b86cfafb1446c34/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-unboxed-closure.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fregions-escape-unboxed-closure.nll.stderr?ref=571eec627c63cea40ea9fba16b86cfafb1446c34", "patch": "@@ -4,15 +4,15 @@ warning: not reporting region error due to nll\n LL |     with_int(&mut |y| x = Some(y));\n    |                           ^^^^^^^\n \n-error: unsatisfied lifetime constraints\n+error: borrowed data escapes outside of closure\n   --> $DIR/regions-escape-unboxed-closure.rs:16:23\n    |\n LL |     let mut x: Option<&isize> = None;\n-   |         ----- lifetime `'2` appears in the type of `x`\n+   |         ----- `x` is declared here, outside of the closure body\n LL |     with_int(&mut |y| x = Some(y));\n-   |                    -  ^^^^^^^^^^^ assignment requires that `'1` must outlive `'2`\n+   |                    -  ^^^^^^^^^^^ `y` escapes the closure body here\n    |                    |\n-   |                    lifetime `'1` appears in this argument\n+   |                    `y` is a reference that is only valid in the closure body\n \n error: aborting due to previous error\n "}, {"sha": "8658c618bf24ca6a6b6a31aed66d3e6cc788c7dc", "filename": "src/test/ui/closure-expected-type/expect-region-supply-region.nll.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/571eec627c63cea40ea9fba16b86cfafb1446c34/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-region-supply-region.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/571eec627c63cea40ea9fba16b86cfafb1446c34/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-region-supply-region.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-region-supply-region.nll.stderr?ref=571eec627c63cea40ea9fba16b86cfafb1446c34", "patch": "@@ -22,37 +22,37 @@ warning: not reporting region error due to nll\n LL |         f = Some(x);\n    |             ^^^^^^^\n \n-error: unsatisfied lifetime constraints\n+error: borrowed data escapes outside of closure\n   --> $DIR/expect-region-supply-region.rs:28:9\n    |\n LL |     let mut f: Option<&u32> = None;\n-   |         ----- lifetime `'2` appears in the type of `f`\n+   |         ----- `f` is declared here, outside of the closure body\n LL |     closure_expecting_bound(|x| {\n-   |                              - lifetime `'1` appears in this argument\n+   |                              - `x` is a reference that is only valid in the closure body\n LL |         f = Some(x); //~ ERROR borrowed data cannot be stored outside of its closure\n-   |         ^^^^^^^^^^^ assignment requires that `'1` must outlive `'2`\n+   |         ^^^^^^^^^^^ `x` escapes the closure body here\n \n-error: unsatisfied lifetime constraints\n+error: borrowed data escapes outside of closure\n   --> $DIR/expect-region-supply-region.rs:38:9\n    |\n LL |     let mut f: Option<&u32> = None;\n-   |         ----- lifetime `'2` appears in the type of `f`\n+   |         ----- `f` is declared here, outside of the closure body\n LL |     closure_expecting_bound(|x: &u32| {\n-   |                                 - let's call the lifetime of this reference `'1`\n+   |                              - `x` is a reference that is only valid in the closure body\n LL |         f = Some(x); //~ ERROR borrowed data cannot be stored outside of its closure\n-   |         ^^^^^^^^^^^ assignment requires that `'1` must outlive `'2`\n+   |         ^^^^^^^^^^^ `x` escapes the closure body here\n \n-error: unsatisfied lifetime constraints\n+error: borrowed data escapes outside of closure\n   --> $DIR/expect-region-supply-region.rs:52:9\n    |\n LL |     let mut f: Option<&u32> = None;\n-   |         ----- lifetime `'2` appears in the type of `f`\n+   |         ----- `f` is declared here, outside of the closure body\n ...\n LL |     closure_expecting_bound(|x: &'x u32| {\n-   |                                 - let's call the lifetime of this reference `'1`\n+   |                              - `x` is a reference that is only valid in the closure body\n ...\n LL |         f = Some(x);\n-   |         ^^^^^^^^^^^ assignment requires that `'1` must outlive `'2`\n+   |         ^^^^^^^^^^^ `x` escapes the closure body here\n \n error: aborting due to 3 previous errors\n "}]}