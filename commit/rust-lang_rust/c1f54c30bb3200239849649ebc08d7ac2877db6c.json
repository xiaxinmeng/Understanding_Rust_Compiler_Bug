{"sha": "c1f54c30bb3200239849649ebc08d7ac2877db6c", "node_id": "C_kwDOAAsO6NoAKGMxZjU0YzMwYmIzMjAwMjM5ODQ5NjQ5ZWJjMDhkN2FjMjg3N2RiNmM", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-07-23T23:10:08Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-07-25T03:39:22Z"}, "message": "Get rid of redundant NonStructuralMatchTyKind", "tree": {"sha": "41f5ef869ddcefe0b7843834ec3dda0da54aef8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41f5ef869ddcefe0b7843834ec3dda0da54aef8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1f54c30bb3200239849649ebc08d7ac2877db6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1f54c30bb3200239849649ebc08d7ac2877db6c", "html_url": "https://github.com/rust-lang/rust/commit/c1f54c30bb3200239849649ebc08d7ac2877db6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1f54c30bb3200239849649ebc08d7ac2877db6c/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1152e70363702919a729b9a83eb7550c9392d306", "url": "https://api.github.com/repos/rust-lang/rust/commits/1152e70363702919a729b9a83eb7550c9392d306", "html_url": "https://github.com/rust-lang/rust/commit/1152e70363702919a729b9a83eb7550c9392d306"}], "stats": {"total": 101, "additions": 28, "deletions": 73}, "files": [{"sha": "14133ebc175357cfcbabe64d92005d436eb1ef2d", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c1f54c30bb3200239849649ebc08d7ac2877db6c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1f54c30bb3200239849649ebc08d7ac2877db6c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=c1f54c30bb3200239849649ebc08d7ac2877db6c", "patch": "@@ -122,37 +122,31 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n     fn search_for_structural_match_violation(&self, ty: Ty<'tcx>) -> Option<String> {\n         traits::search_for_structural_match_violation(self.span, self.tcx(), ty, false).map(\n             |non_sm_ty| {\n-                with_no_trimmed_paths!(match non_sm_ty.kind {\n-                    traits::NonStructuralMatchTyKind::Adt(adt) => self.adt_derive_msg(adt),\n-                    traits::NonStructuralMatchTyKind::Dynamic => {\n+                with_no_trimmed_paths!(match non_sm_ty.kind() {\n+                    ty::Adt(adt, _) => self.adt_derive_msg(*adt),\n+                    ty::Dynamic(..) => {\n                         \"trait objects cannot be used in patterns\".to_string()\n                     }\n-                    traits::NonStructuralMatchTyKind::Opaque => {\n+                    ty::Opaque(..) => {\n                         \"opaque types cannot be used in patterns\".to_string()\n                     }\n-                    traits::NonStructuralMatchTyKind::Closure => {\n+                    ty::Closure(..) => {\n                         \"closures cannot be used in patterns\".to_string()\n                     }\n-                    traits::NonStructuralMatchTyKind::Generator => {\n+                    ty::Generator(..) | ty::GeneratorWitness(..) => {\n                         \"generators cannot be used in patterns\".to_string()\n                     }\n-                    traits::NonStructuralMatchTyKind::Float => {\n+                    ty::Float(..) => {\n                         \"floating-point numbers cannot be used in patterns\".to_string()\n                     }\n-                    traits::NonStructuralMatchTyKind::FnPtr => {\n+                    ty::FnPtr(..) => {\n                         \"function pointers cannot be used in patterns\".to_string()\n                     }\n-                    traits::NonStructuralMatchTyKind::RawPtr => {\n+                    ty::RawPtr(..) => {\n                         \"raw pointers cannot be used in patterns\".to_string()\n                     }\n-                    traits::NonStructuralMatchTyKind::Param => {\n-                        bug!(\"use of a constant whose type is a parameter inside a pattern\")\n-                    }\n-                    traits::NonStructuralMatchTyKind::Projection => {\n-                        bug!(\"use of a constant whose type is a projection inside a pattern\")\n-                    }\n-                    traits::NonStructuralMatchTyKind::Foreign => {\n-                        bug!(\"use of a value of a foreign type inside a pattern\")\n+                    _ => {\n+                        bug!(\"use of a value of `{non_sm_ty}` inside a pattern\")\n                     }\n                 })\n             },"}, {"sha": "5397baefb9cf4ac9cbd9e8573dee58a509f6c58d", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c1f54c30bb3200239849649ebc08d7ac2877db6c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1f54c30bb3200239849649ebc08d7ac2877db6c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=c1f54c30bb3200239849649ebc08d7ac2877db6c", "patch": "@@ -61,7 +61,6 @@ pub use self::specialize::specialization_graph::FutureCompatOverlapError;\n pub use self::specialize::specialization_graph::FutureCompatOverlapErrorKind;\n pub use self::specialize::{specialization_graph, translate_substs, OverlapError};\n pub use self::structural_match::search_for_structural_match_violation;\n-pub use self::structural_match::{NonStructuralMatchTy, NonStructuralMatchTyKind};\n pub use self::util::{\n     elaborate_obligations, elaborate_predicates, elaborate_predicates_with_span,\n     elaborate_trait_ref, elaborate_trait_refs,"}, {"sha": "ea11670ee777d814a78dc6a25e7c39bdb0e74364", "filename": "compiler/rustc_trait_selection/src/traits/structural_match.rs", "status": "modified", "additions": 14, "deletions": 52, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/c1f54c30bb3200239849649ebc08d7ac2877db6c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1f54c30bb3200239849649ebc08d7ac2877db6c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs?ref=c1f54c30bb3200239849649ebc08d7ac2877db6c", "patch": "@@ -6,31 +6,10 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::lang_items::LangItem;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor};\n use rustc_span::Span;\n use std::ops::ControlFlow;\n \n-#[derive(Debug)]\n-pub struct NonStructuralMatchTy<'tcx> {\n-    pub ty: Ty<'tcx>,\n-    pub kind: NonStructuralMatchTyKind<'tcx>,\n-}\n-\n-#[derive(Debug)]\n-pub enum NonStructuralMatchTyKind<'tcx> {\n-    Adt(AdtDef<'tcx>),\n-    Param,\n-    Dynamic,\n-    Foreign,\n-    Opaque,\n-    Closure,\n-    Generator,\n-    Projection,\n-    Float,\n-    FnPtr,\n-    RawPtr,\n-}\n-\n /// This method traverses the structure of `ty`, trying to find an\n /// instance of an ADT (i.e. struct or enum) that doesn't implement\n /// the structural-match traits, or a generic type parameter\n@@ -64,7 +43,7 @@ pub fn search_for_structural_match_violation<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n     valtree_semantics: bool,\n-) -> Option<NonStructuralMatchTy<'tcx>> {\n+) -> Option<Ty<'tcx>> {\n     ty.visit_with(&mut Search { tcx, span, seen: FxHashSet::default(), valtree_semantics })\n         .break_value()\n }\n@@ -140,40 +119,33 @@ impl<'tcx> Search<'tcx> {\n }\n \n impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n-    type BreakTy = NonStructuralMatchTy<'tcx>;\n+    type BreakTy = Ty<'tcx>;\n \n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         debug!(\"Search visiting ty: {:?}\", ty);\n \n         let (adt_def, substs) = match *ty.kind() {\n             ty::Adt(adt_def, substs) => (adt_def, substs),\n             ty::Param(_) => {\n-                let kind = NonStructuralMatchTyKind::Param;\n-                return ControlFlow::Break(NonStructuralMatchTy { ty, kind });\n+                return ControlFlow::Break(ty);\n             }\n             ty::Dynamic(..) => {\n-                let kind = NonStructuralMatchTyKind::Dynamic;\n-                return ControlFlow::Break(NonStructuralMatchTy { ty, kind });\n+                return ControlFlow::Break(ty);\n             }\n             ty::Foreign(_) => {\n-                let kind = NonStructuralMatchTyKind::Foreign;\n-                return ControlFlow::Break(NonStructuralMatchTy { ty, kind });\n+                return ControlFlow::Break(ty);\n             }\n             ty::Opaque(..) => {\n-                let kind = NonStructuralMatchTyKind::Opaque;\n-                return ControlFlow::Break(NonStructuralMatchTy { ty, kind });\n+                return ControlFlow::Break(ty);\n             }\n             ty::Projection(..) => {\n-                let kind = NonStructuralMatchTyKind::Projection;\n-                return ControlFlow::Break(NonStructuralMatchTy { ty, kind });\n+                return ControlFlow::Break(ty);\n             }\n             ty::Closure(..) => {\n-                let kind = NonStructuralMatchTyKind::Closure;\n-                return ControlFlow::Break(NonStructuralMatchTy { ty, kind });\n+                return ControlFlow::Break(ty);\n             }\n             ty::Generator(..) | ty::GeneratorWitness(..) => {\n-                let kind = NonStructuralMatchTyKind::Generator;\n-                return ControlFlow::Break(NonStructuralMatchTy { ty, kind });\n+                return ControlFlow::Break(ty);\n             }\n             ty::FnDef(..) => {\n                 // Types of formals and return in `fn(_) -> _` are also irrelevant;\n@@ -198,10 +170,7 @@ impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n                 if !self.valtree_semantics {\n                     return ControlFlow::CONTINUE;\n                 } else {\n-                    return ControlFlow::Break(NonStructuralMatchTy {\n-                        ty,\n-                        kind: NonStructuralMatchTyKind::FnPtr,\n-                    });\n+                    return ControlFlow::Break(ty);\n                 }\n             }\n \n@@ -223,21 +192,15 @@ impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n                     // pointer. Therefore, one can still use `C` in a pattern.\n                     return ControlFlow::CONTINUE;\n                 } else {\n-                    return ControlFlow::Break(NonStructuralMatchTy {\n-                        ty,\n-                        kind: NonStructuralMatchTyKind::FnPtr,\n-                    });\n+                    return ControlFlow::Break(ty);\n                 }\n             }\n \n             ty::Float(_) => {\n                 if !self.valtree_semantics {\n                     return ControlFlow::CONTINUE;\n                 } else {\n-                    return ControlFlow::Break(NonStructuralMatchTy {\n-                        ty,\n-                        kind: NonStructuralMatchTyKind::Float,\n-                    });\n+                    return ControlFlow::Break(ty);\n                 }\n             }\n \n@@ -263,8 +226,7 @@ impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n \n         if !self.type_marked_structural(ty) {\n             debug!(\"Search found ty: {:?}\", ty);\n-            let kind = NonStructuralMatchTyKind::Adt(adt_def);\n-            return ControlFlow::Break(NonStructuralMatchTy { ty, kind });\n+            return ControlFlow::Break(ty);\n         }\n \n         // structural-match does not care about the"}, {"sha": "3bf76ad38ee2b653f5e195c59e6d03db21b19949", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1f54c30bb3200239849649ebc08d7ac2877db6c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1f54c30bb3200239849649ebc08d7ac2877db6c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=c1f54c30bb3200239849649ebc08d7ac2877db6c", "patch": "@@ -854,7 +854,7 @@ fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n                     // We use the same error code in both branches, because this is really the same\n                     // issue: we just special-case the message for type parameters to make it\n                     // clearer.\n-                    match non_structural_match_ty.ty.kind() {\n+                    match non_structural_match_ty.kind() {\n                         ty::Param(_) => {\n                             // Const parameters may not have type parameters as their types,\n                             // because we cannot be sure that the type parameter derives `PartialEq`\n@@ -911,10 +911,10 @@ fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n                                 E0741,\n                                 \"`{}` must be annotated with `#[derive(PartialEq, Eq)]` to be used as \\\n                                 the type of a const parameter\",\n-                                non_structural_match_ty.ty,\n+                                non_structural_match_ty,\n                             );\n \n-                            if ty == non_structural_match_ty.ty {\n+                            if ty == non_structural_match_ty {\n                                 diag.span_label(\n                                     hir_ty.span,\n                                     format!(\"`{ty}` doesn't derive both `PartialEq` and `Eq`\"),"}]}