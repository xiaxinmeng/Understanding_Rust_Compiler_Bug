{"sha": "d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzNGIxYjBjYTliZjVlMGQ3Y2QzMDk1MmY1ZGUwYWIwOWVkNTdiNDE=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-10-10T17:11:49Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-09T04:40:38Z"}, "message": "Runtime removal: refactor pipes and networking\n\nThis patch continues the runtime removal by moving pipe and\nnetworking-related code into `sys`.\n\nBecause this eliminates APIs in `libnative` and `librustrt`, it is a:\n\n[breaking-change]\n\nThis functionality is likely to be available publicly, in some form,\nfrom `std` in the future.", "tree": {"sha": "bdb9af03a1b73d4edc9ae5e6193a010c9b2b4edc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdb9af03a1b73d4edc9ae5e6193a010c9b2b4edc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41", "html_url": "https://github.com/rust-lang/rust/commit/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c1e1ff1e300868a29405a334e65eae690df971d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c1e1ff1e300868a29405a334e65eae690df971d", "html_url": "https://github.com/rust-lang/rust/commit/0c1e1ff1e300868a29405a334e65eae690df971d"}], "stats": {"total": 2472, "additions": 1183, "deletions": 1289}, "files": [{"sha": "2a76bc29f7c37bc03ac1ce6e7903ef382d4f14e0", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41", "patch": "@@ -35,8 +35,6 @@ pub use self::process::Process;\n mod helper_thread;\n \n // Native I/O implementations\n-pub mod addrinfo;\n-pub mod net;\n pub mod process;\n mod util;\n \n@@ -53,14 +51,6 @@ pub mod timer;\n #[path = \"timer_windows.rs\"]\n pub mod timer;\n \n-#[cfg(unix)]\n-#[path = \"pipe_unix.rs\"]\n-pub mod pipe;\n-\n-#[cfg(windows)]\n-#[path = \"pipe_windows.rs\"]\n-pub mod pipe;\n-\n #[cfg(windows)]\n #[path = \"tty_windows.rs\"]\n mod tty;\n@@ -126,52 +116,11 @@ pub struct IoFactory {\n \n impl IoFactory {\n     pub fn new() -> IoFactory {\n-        net::init();\n         IoFactory { _cannot_construct_outside_of_this_module: () }\n     }\n }\n \n impl rtio::IoFactory for IoFactory {\n-    // networking\n-    fn tcp_connect(&mut self, addr: rtio::SocketAddr,\n-                   timeout: Option<u64>)\n-        -> IoResult<Box<rtio::RtioTcpStream + Send>>\n-    {\n-        net::TcpStream::connect(addr, timeout).map(|s| {\n-            box s as Box<rtio::RtioTcpStream + Send>\n-        })\n-    }\n-    fn tcp_bind(&mut self, addr: rtio::SocketAddr)\n-                -> IoResult<Box<rtio::RtioTcpListener + Send>> {\n-        net::TcpListener::bind(addr).map(|s| {\n-            box s as Box<rtio::RtioTcpListener + Send>\n-        })\n-    }\n-    fn udp_bind(&mut self, addr: rtio::SocketAddr)\n-                -> IoResult<Box<rtio::RtioUdpSocket + Send>> {\n-        net::UdpSocket::bind(addr).map(|u| {\n-            box u as Box<rtio::RtioUdpSocket + Send>\n-        })\n-    }\n-    fn unix_bind(&mut self, path: &CString)\n-                 -> IoResult<Box<rtio::RtioUnixListener + Send>> {\n-        pipe::UnixListener::bind(path).map(|s| {\n-            box s as Box<rtio::RtioUnixListener + Send>\n-        })\n-    }\n-    fn unix_connect(&mut self, path: &CString,\n-                    timeout: Option<u64>) -> IoResult<Box<rtio::RtioPipe + Send>> {\n-        pipe::UnixStream::connect(path, timeout).map(|s| {\n-            box s as Box<rtio::RtioPipe + Send>\n-        })\n-    }\n-    fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n-                          hint: Option<rtio::AddrinfoHint>)\n-        -> IoResult<Vec<rtio::AddrinfoInfo>>\n-    {\n-        addrinfo::GetAddrInfoRequest::run(host, servname, hint)\n-    }\n-\n     // misc\n     fn timer_init(&mut self) -> IoResult<Box<rtio::RtioTimer + Send>> {\n         timer::Timer::new().map(|t| box t as Box<rtio::RtioTimer + Send>)\n@@ -189,9 +138,6 @@ impl rtio::IoFactory for IoFactory {\n     fn kill(&mut self, pid: libc::pid_t, signum: int) -> IoResult<()> {\n         process::Process::kill(pid, signum)\n     }\n-    fn pipe_open(&mut self, fd: c_int) -> IoResult<Box<rtio::RtioPipe + Send>> {\n-        Ok(box file::FileDesc::new(fd, true) as Box<rtio::RtioPipe + Send>)\n-    }\n     #[cfg(unix)]\n     fn tty_open(&mut self, fd: c_int, _readable: bool)\n                 -> IoResult<Box<rtio::RtioTTY + Send>> {"}, {"sha": "3ebfcaea687f19f7cb00c8dfd4fe090d9ac42d25", "filename": "src/librustrt/rtio.rs", "status": "modified", "additions": 0, "deletions": 127, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibrustrt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibrustrt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Frtio.rs?ref=d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41", "patch": "@@ -13,13 +13,9 @@\n use core::prelude::*;\n use alloc::boxed::Box;\n use collections::string::String;\n-use collections::vec::Vec;\n-use core::fmt;\n use core::mem;\n use libc::c_int;\n-use libc;\n \n-use c_str::CString;\n use local::Local;\n use task::Task;\n \n@@ -173,87 +169,15 @@ impl<'a> LocalIo<'a> {\n }\n \n pub trait IoFactory {\n-    // networking\n-    fn tcp_connect(&mut self, addr: SocketAddr,\n-                   timeout: Option<u64>) -> IoResult<Box<RtioTcpStream + Send>>;\n-    fn tcp_bind(&mut self, addr: SocketAddr)\n-                -> IoResult<Box<RtioTcpListener + Send>>;\n-    fn udp_bind(&mut self, addr: SocketAddr)\n-                -> IoResult<Box<RtioUdpSocket + Send>>;\n-    fn unix_bind(&mut self, path: &CString)\n-                 -> IoResult<Box<RtioUnixListener + Send>>;\n-    fn unix_connect(&mut self, path: &CString,\n-                    timeout: Option<u64>) -> IoResult<Box<RtioPipe + Send>>;\n-    fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n-                          hint: Option<AddrinfoHint>)\n-                          -> IoResult<Vec<AddrinfoInfo>>;\n-\n-    // misc\n     fn timer_init(&mut self) -> IoResult<Box<RtioTimer + Send>>;\n     fn spawn(&mut self, cfg: ProcessConfig)\n             -> IoResult<(Box<RtioProcess + Send>,\n                          Vec<Option<Box<RtioPipe + Send>>>)>;\n     fn kill(&mut self, pid: libc::pid_t, signal: int) -> IoResult<()>;\n-    fn pipe_open(&mut self, fd: c_int) -> IoResult<Box<RtioPipe + Send>>;\n     fn tty_open(&mut self, fd: c_int, readable: bool)\n             -> IoResult<Box<RtioTTY + Send>>;\n }\n \n-pub trait RtioTcpListener : RtioSocket {\n-    fn listen(self: Box<Self>) -> IoResult<Box<RtioTcpAcceptor + Send>>;\n-}\n-\n-pub trait RtioTcpAcceptor : RtioSocket {\n-    fn accept(&mut self) -> IoResult<Box<RtioTcpStream + Send>>;\n-    fn accept_simultaneously(&mut self) -> IoResult<()>;\n-    fn dont_accept_simultaneously(&mut self) -> IoResult<()>;\n-    fn set_timeout(&mut self, timeout: Option<u64>);\n-    fn clone(&self) -> Box<RtioTcpAcceptor + Send>;\n-    fn close_accept(&mut self) -> IoResult<()>;\n-}\n-\n-pub trait RtioTcpStream : RtioSocket {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint>;\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()>;\n-    fn peer_name(&mut self) -> IoResult<SocketAddr>;\n-    fn control_congestion(&mut self) -> IoResult<()>;\n-    fn nodelay(&mut self) -> IoResult<()>;\n-    fn keepalive(&mut self, delay_in_seconds: uint) -> IoResult<()>;\n-    fn letdie(&mut self) -> IoResult<()>;\n-    fn clone(&self) -> Box<RtioTcpStream + Send>;\n-    fn close_write(&mut self) -> IoResult<()>;\n-    fn close_read(&mut self) -> IoResult<()>;\n-    fn set_timeout(&mut self, timeout_ms: Option<u64>);\n-    fn set_read_timeout(&mut self, timeout_ms: Option<u64>);\n-    fn set_write_timeout(&mut self, timeout_ms: Option<u64>);\n-}\n-\n-pub trait RtioSocket {\n-    fn socket_name(&mut self) -> IoResult<SocketAddr>;\n-}\n-\n-pub trait RtioUdpSocket : RtioSocket {\n-    fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(uint, SocketAddr)>;\n-    fn send_to(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()>;\n-\n-    fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()>;\n-    fn leave_multicast(&mut self, multi: IpAddr) -> IoResult<()>;\n-\n-    fn loop_multicast_locally(&mut self) -> IoResult<()>;\n-    fn dont_loop_multicast_locally(&mut self) -> IoResult<()>;\n-\n-    fn multicast_time_to_live(&mut self, ttl: int) -> IoResult<()>;\n-    fn time_to_live(&mut self, ttl: int) -> IoResult<()>;\n-\n-    fn hear_broadcasts(&mut self) -> IoResult<()>;\n-    fn ignore_broadcasts(&mut self) -> IoResult<()>;\n-\n-    fn clone(&self) -> Box<RtioUdpSocket + Send>;\n-    fn set_timeout(&mut self, timeout_ms: Option<u64>);\n-    fn set_read_timeout(&mut self, timeout_ms: Option<u64>);\n-    fn set_write_timeout(&mut self, timeout_ms: Option<u64>);\n-}\n-\n pub trait RtioTimer {\n     fn sleep(&mut self, msecs: u64);\n     fn oneshot(&mut self, msecs: u64, cb: Box<Callback + Send>);\n@@ -313,54 +237,3 @@ pub struct IoError {\n }\n \n pub type IoResult<T> = Result<T, IoError>;\n-\n-#[deriving(PartialEq, Eq)]\n-pub enum IpAddr {\n-    Ipv4Addr(u8, u8, u8, u8),\n-    Ipv6Addr(u16, u16, u16, u16, u16, u16, u16, u16),\n-}\n-\n-impl fmt::Show for IpAddr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Ipv4Addr(a, b, c, d) => write!(fmt, \"{}.{}.{}.{}\", a, b, c, d),\n-            Ipv6Addr(a, b, c, d, e, f, g, h) => {\n-                write!(fmt,\n-                       \"{:04x}:{:04x}:{:04x}:{:04x}:{:04x}:{:04x}:{:04x}:{:04x}\",\n-                       a, b, c, d, e, f, g, h)\n-            }\n-        }\n-    }\n-}\n-\n-#[deriving(PartialEq, Eq)]\n-pub struct SocketAddr {\n-    pub ip: IpAddr,\n-    pub port: u16,\n-}\n-\n-pub enum StdioContainer {\n-    Ignored,\n-    InheritFd(i32),\n-    CreatePipe(bool, bool),\n-}\n-\n-pub enum ProcessExit {\n-    ExitStatus(int),\n-    ExitSignal(int),\n-}\n-\n-pub struct AddrinfoHint {\n-    pub family: uint,\n-    pub socktype: uint,\n-    pub protocol: uint,\n-    pub flags: uint,\n-}\n-\n-pub struct AddrinfoInfo {\n-    pub address: SocketAddr,\n-    pub family: uint,\n-    pub socktype: uint,\n-    pub protocol: uint,\n-    pub flags: uint,\n-}"}, {"sha": "22775d54eff1bbd1e1f85af789d69206468d29d0", "filename": "src/libstd/io/net/addrinfo.rs", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs?ref=d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41", "patch": "@@ -20,12 +20,10 @@ getaddrinfo()\n #![allow(missing_docs)]\n \n use iter::Iterator;\n-use io::{IoResult, IoError};\n+use io::{IoResult};\n use io::net::ip::{SocketAddr, IpAddr};\n use option::{Option, Some, None};\n-use result::{Ok, Err};\n-use rt::rtio::{IoFactory, LocalIo};\n-use rt::rtio;\n+use sys;\n use vec::Vec;\n \n /// Hints to the types of sockets that are desired when looking up hosts\n@@ -94,31 +92,7 @@ pub fn get_host_addresses(host: &str) -> IoResult<Vec<IpAddr>> {\n #[allow(unused_variables)]\n fn lookup(hostname: Option<&str>, servname: Option<&str>, hint: Option<Hint>)\n           -> IoResult<Vec<Info>> {\n-    let hint = hint.map(|Hint { family, socktype, protocol, flags }| {\n-        rtio::AddrinfoHint {\n-            family: family,\n-            socktype: 0, // FIXME: this should use the above variable\n-            protocol: 0, // FIXME: this should use the above variable\n-            flags: flags,\n-        }\n-    });\n-    match LocalIo::maybe_raise(|io| {\n-        io.get_host_addresses(hostname, servname, hint)\n-    }) {\n-        Ok(v) => Ok(v.into_iter().map(|info| {\n-            Info {\n-                address: SocketAddr {\n-                    ip: super::from_rtio(info.address.ip),\n-                    port: info.address.port,\n-                },\n-                family: info.family,\n-                socktype: None, // FIXME: this should use the above variable\n-                protocol: None, // FIXME: this should use the above variable\n-                flags: info.flags,\n-            }\n-        }).collect()),\n-        Err(e) => Err(IoError::from_rtio_error(e)),\n-    }\n+    sys::addrinfo::get_host_addresses(hostname, servname, hint)\n }\n \n // Ignored on android since we cannot give tcp/ip"}, {"sha": "5b1747876d7e0c537226ad6b5c6db166269a6dbf", "filename": "src/libstd/io/net/mod.rs", "status": "modified", "additions": 2, "deletions": 43, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fio%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fio%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fmod.rs?ref=d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41", "patch": "@@ -12,9 +12,8 @@\n \n use io::{IoError, IoResult, InvalidInput};\n use option::None;\n-use result::{Result, Ok, Err};\n-use rt::rtio;\n-use self::ip::{Ipv4Addr, Ipv6Addr, IpAddr, SocketAddr, ToSocketAddr};\n+use result::{Ok, Err};\n+use self::ip::{SocketAddr, ToSocketAddr};\n \n pub use self::addrinfo::get_host_addresses;\n \n@@ -24,46 +23,6 @@ pub mod udp;\n pub mod ip;\n pub mod pipe;\n \n-fn to_rtio(ip: IpAddr) -> rtio::IpAddr {\n-    match ip {\n-        Ipv4Addr(a, b, c, d) => rtio::Ipv4Addr(a, b, c, d),\n-        Ipv6Addr(a, b, c, d, e, f, g, h) => {\n-            rtio::Ipv6Addr(a, b, c, d, e, f, g, h)\n-        }\n-    }\n-}\n-\n-fn from_rtio(ip: rtio::IpAddr) -> IpAddr {\n-    match ip {\n-        rtio::Ipv4Addr(a, b, c, d) => Ipv4Addr(a, b, c, d),\n-        rtio::Ipv6Addr(a, b, c, d, e, f, g, h) => {\n-            Ipv6Addr(a, b, c, d, e, f, g, h)\n-        }\n-    }\n-}\n-\n-fn with_addresses_io<A: ToSocketAddr, T>(\n-    addr: A,\n-    action: |&mut rtio::IoFactory, rtio::SocketAddr| -> Result<T, rtio::IoError>\n-) -> Result<T, IoError> {\n-    const DEFAULT_ERROR: IoError = IoError {\n-        kind: InvalidInput,\n-        desc: \"no addresses found for hostname\",\n-        detail: None\n-    };\n-\n-    let addresses = try!(addr.to_socket_addr_all());\n-    let mut err = DEFAULT_ERROR;\n-    for addr in addresses.into_iter() {\n-        let addr = rtio::SocketAddr { ip: to_rtio(addr.ip), port: addr.port };\n-        match rtio::LocalIo::maybe_raise(|io| action(io, addr)) {\n-            Ok(r) => return Ok(r),\n-            Err(e) => err = IoError::from_rtio_error(e)\n-        }\n-    }\n-    Err(err)\n-}\n-\n fn with_addresses<A: ToSocketAddr, T>(addr: A, action: |SocketAddr| -> IoResult<T>)\n     -> IoResult<T> {\n     const DEFAULT_ERROR: IoError = IoError {"}, {"sha": "111b0f2b081fc8f4b79cb7beaee75104396d9b40", "filename": "src/libstd/io/net/pipe.rs", "status": "modified", "additions": 31, "deletions": 34, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs?ref=d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41", "patch": "@@ -26,17 +26,20 @@ instances as clients.\n \n use prelude::*;\n \n-use io::{Listener, Acceptor, IoResult, IoError, TimedOut, standard_error};\n-use rt::rtio::{IoFactory, LocalIo, RtioUnixListener};\n-use rt::rtio::{RtioUnixAcceptor, RtioPipe};\n+use io::{Listener, Acceptor, IoResult, TimedOut, standard_error};\n use time::Duration;\n \n+use sys::pipe::UnixStream as UnixStreamImp;\n+use sys::pipe::UnixListener as UnixListenerImp;\n+use sys::pipe::UnixAcceptor as UnixAcceptorImp;\n+\n /// A stream which communicates over a named pipe.\n pub struct UnixStream {\n-    obj: Box<RtioPipe + Send>,\n+    inner: UnixStreamImp,\n }\n \n impl UnixStream {\n+\n     /// Connect to a pipe named by `path`. This will attempt to open a\n     /// connection to the underlying socket.\n     ///\n@@ -53,9 +56,8 @@ impl UnixStream {\n     /// stream.write([1, 2, 3]);\n     /// ```\n     pub fn connect<P: ToCStr>(path: &P) -> IoResult<UnixStream> {\n-        LocalIo::maybe_raise(|io| {\n-            io.unix_connect(&path.to_c_str(), None).map(|p| UnixStream { obj: p })\n-        }).map_err(IoError::from_rtio_error)\n+        UnixStreamImp::connect(&path.to_c_str(), None)\n+            .map(|inner| UnixStream { inner: inner })\n     }\n \n     /// Connect to a pipe named by `path`, timing out if the specified number of\n@@ -73,10 +75,8 @@ impl UnixStream {\n             return Err(standard_error(TimedOut));\n         }\n \n-        LocalIo::maybe_raise(|io| {\n-            let s = io.unix_connect(&path.to_c_str(), Some(timeout.num_milliseconds() as u64));\n-            s.map(|p| UnixStream { obj: p })\n-        }).map_err(IoError::from_rtio_error)\n+        UnixStreamImp::connect(&path.to_c_str(), Some(timeout.num_milliseconds() as u64))\n+            .map(|inner| UnixStream { inner: inner })\n     }\n \n \n@@ -88,7 +88,7 @@ impl UnixStream {\n     /// Note that this method affects all cloned handles associated with this\n     /// stream, not just this one handle.\n     pub fn close_read(&mut self) -> IoResult<()> {\n-        self.obj.close_read().map_err(IoError::from_rtio_error)\n+        self.inner.close_read()\n     }\n \n     /// Closes the writing half of this connection.\n@@ -99,60 +99,59 @@ impl UnixStream {\n     /// Note that this method affects all cloned handles associated with this\n     /// stream, not just this one handle.\n     pub fn close_write(&mut self) -> IoResult<()> {\n-        self.obj.close_write().map_err(IoError::from_rtio_error)\n+        self.inner.close_write()\n     }\n \n     /// Sets the read/write timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n     #[experimental = \"the timeout argument may change in type and value\"]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.obj.set_timeout(timeout_ms)\n+        self.inner.set_timeout(timeout_ms)\n     }\n \n     /// Sets the read timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n     #[experimental = \"the timeout argument may change in type and value\"]\n     pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.obj.set_read_timeout(timeout_ms)\n+        self.inner.set_read_timeout(timeout_ms)\n     }\n \n     /// Sets the write timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n     #[experimental = \"the timeout argument may change in type and value\"]\n     pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.obj.set_write_timeout(timeout_ms)\n+        self.inner.set_write_timeout(timeout_ms)\n     }\n }\n \n impl Clone for UnixStream {\n     fn clone(&self) -> UnixStream {\n-        UnixStream { obj: self.obj.clone() }\n+        UnixStream { inner: self.inner.clone() }\n     }\n }\n \n impl Reader for UnixStream {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        self.obj.read(buf).map_err(IoError::from_rtio_error)\n+        self.inner.read(buf)\n     }\n }\n \n impl Writer for UnixStream {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.obj.write(buf).map_err(IoError::from_rtio_error)\n+        self.inner.write(buf)\n     }\n }\n \n /// A value that can listen for incoming named pipe connection requests.\n pub struct UnixListener {\n     /// The internal, opaque runtime Unix listener.\n-    obj: Box<RtioUnixListener + Send>,\n+    inner: UnixListenerImp,\n }\n \n impl UnixListener {\n-\n     /// Creates a new listener, ready to receive incoming connections on the\n     /// specified socket. The server will be named by `path`.\n     ///\n@@ -175,24 +174,22 @@ impl UnixListener {\n     /// # }\n     /// ```\n     pub fn bind<P: ToCStr>(path: &P) -> IoResult<UnixListener> {\n-        LocalIo::maybe_raise(|io| {\n-            io.unix_bind(&path.to_c_str()).map(|s| UnixListener { obj: s })\n-        }).map_err(IoError::from_rtio_error)\n+        UnixListenerImp::bind(&path.to_c_str())\n+            .map(|inner| UnixListener { inner: inner })\n     }\n }\n \n impl Listener<UnixStream, UnixAcceptor> for UnixListener {\n     fn listen(self) -> IoResult<UnixAcceptor> {\n-        self.obj.listen().map(|obj| {\n-            UnixAcceptor { obj: obj }\n-        }).map_err(IoError::from_rtio_error)\n+        self.inner.listen()\n+            .map(|inner| UnixAcceptor { inner: inner })\n     }\n }\n \n /// A value that can accept named pipe connections, returned from `listen()`.\n pub struct UnixAcceptor {\n     /// The internal, opaque runtime Unix acceptor.\n-    obj: Box<RtioUnixAcceptor + Send>,\n+    inner: UnixAcceptorImp\n }\n \n impl UnixAcceptor {\n@@ -210,7 +207,7 @@ impl UnixAcceptor {\n     #[experimental = \"the name and arguments to this function are likely \\\n                       to change\"]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.obj.set_timeout(timeout_ms)\n+        self.inner.set_timeout(timeout_ms)\n     }\n \n     /// Closes the accepting capabilities of this acceptor.\n@@ -219,15 +216,15 @@ impl UnixAcceptor {\n     /// more information can be found in that documentation.\n     #[experimental]\n     pub fn close_accept(&mut self) -> IoResult<()> {\n-        self.obj.close_accept().map_err(IoError::from_rtio_error)\n+        self.inner.close_accept()\n     }\n }\n \n impl Acceptor<UnixStream> for UnixAcceptor {\n     fn accept(&mut self) -> IoResult<UnixStream> {\n-        self.obj.accept().map(|s| {\n-            UnixStream { obj: s }\n-        }).map_err(IoError::from_rtio_error)\n+        self.inner.accept().map(|s| {\n+            UnixStream { inner: s }\n+        })\n     }\n }\n \n@@ -246,7 +243,7 @@ impl Clone for UnixAcceptor {\n     /// This function is useful for creating a handle to invoke `close_accept`\n     /// on to wake up any other task blocked in `accept`.\n     fn clone(&self) -> UnixAcceptor {\n-        UnixAcceptor { obj: self.obj.clone() }\n+        UnixAcceptor { inner: self.inner.clone() }\n     }\n }\n "}, {"sha": "2545e07cbb5c2bd1dddbbe5a3697502abeb1ffdd", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 39, "deletions": 66, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41", "patch": "@@ -20,19 +20,17 @@\n use clone::Clone;\n use io::IoResult;\n use iter::Iterator;\n-use result::{Ok,Err};\n+use result::Err;\n use io::net::ip::{SocketAddr, ToSocketAddr};\n-use io::IoError;\n use io::{Reader, Writer, Listener, Acceptor};\n use io::{standard_error, TimedOut};\n-use kinds::Send;\n use option::{None, Some, Option};\n-use boxed::Box;\n-use rt::rtio::{IoFactory, RtioSocket, RtioTcpListener};\n-use rt::rtio::{RtioTcpAcceptor, RtioTcpStream};\n-use rt::rtio;\n use time::Duration;\n \n+use sys::tcp::TcpStream as TcpStreamImp;\n+use sys::tcp::TcpListener as TcpListenerImp;\n+use sys::tcp::TcpAcceptor as TcpAcceptorImp;\n+\n /// A structure which represents a TCP stream between a local socket and a\n /// remote socket.\n ///\n@@ -50,12 +48,12 @@ use time::Duration;\n /// drop(stream); // close the connection\n /// ```\n pub struct TcpStream {\n-    obj: Box<RtioTcpStream + Send>,\n+    inner: TcpStreamImp,\n }\n \n impl TcpStream {\n-    fn new(s: Box<RtioTcpStream + Send>) -> TcpStream {\n-        TcpStream { obj: s }\n+    fn new(s: TcpStreamImp) -> TcpStream {\n+        TcpStream { inner: s }\n     }\n \n     /// Open a TCP connection to a remote host.\n@@ -64,7 +62,9 @@ impl TcpStream {\n     /// trait can be supplied for the address; see this trait documentation for\n     /// concrete examples.\n     pub fn connect<A: ToSocketAddr>(addr: A) -> IoResult<TcpStream> {\n-        super::with_addresses_io(addr, |io, addr| io.tcp_connect(addr, None).map(TcpStream::new))\n+        super::with_addresses(addr, |addr| {\n+            TcpStreamImp::connect(addr, None).map(TcpStream::new)\n+        })\n     }\n \n     /// Creates a TCP connection to a remote socket address, timing out after\n@@ -86,39 +86,26 @@ impl TcpStream {\n             return Err(standard_error(TimedOut));\n         }\n \n-        super::with_addresses_io(addr, |io, addr|\n-            io.tcp_connect(addr, Some(timeout.num_milliseconds() as u64)).map(TcpStream::new)\n-        )\n+        super::with_addresses(addr, |addr| {\n+            TcpStreamImp::connect(addr, Some(timeout.num_milliseconds() as u64))\n+                .map(TcpStream::new)\n+        })\n     }\n \n     /// Returns the socket address of the remote peer of this TCP connection.\n     pub fn peer_name(&mut self) -> IoResult<SocketAddr> {\n-        match self.obj.peer_name() {\n-            Ok(rtio::SocketAddr { ip, port }) => {\n-                Ok(SocketAddr { ip: super::from_rtio(ip), port: port })\n-            }\n-            Err(e) => Err(IoError::from_rtio_error(e)),\n-        }\n+        self.inner.peer_name()\n     }\n \n     /// Returns the socket address of the local half of this TCP connection.\n     pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n-        match self.obj.socket_name() {\n-            Ok(rtio::SocketAddr { ip, port }) => {\n-                Ok(SocketAddr { ip: super::from_rtio(ip), port: port })\n-            }\n-            Err(e) => Err(IoError::from_rtio_error(e)),\n-        }\n+        self.inner.socket_name()\n     }\n \n     /// Sets the nodelay flag on this connection to the boolean specified\n     #[experimental]\n     pub fn set_nodelay(&mut self, nodelay: bool) -> IoResult<()> {\n-        if nodelay {\n-            self.obj.nodelay()\n-        } else {\n-            self.obj.control_congestion()\n-        }.map_err(IoError::from_rtio_error)\n+        self.inner.set_nodelay(nodelay)\n     }\n \n     /// Sets the keepalive timeout to the timeout specified.\n@@ -128,10 +115,7 @@ impl TcpStream {\n     /// specified time, in seconds.\n     #[experimental]\n     pub fn set_keepalive(&mut self, delay_in_seconds: Option<uint>) -> IoResult<()> {\n-        match delay_in_seconds {\n-            Some(i) => self.obj.keepalive(i),\n-            None => self.obj.letdie(),\n-        }.map_err(IoError::from_rtio_error)\n+        self.inner.set_keepalive(delay_in_seconds)\n     }\n \n     /// Closes the reading half of this connection.\n@@ -165,7 +149,7 @@ impl TcpStream {\n     /// Note that this method affects all cloned handles associated with this\n     /// stream, not just this one handle.\n     pub fn close_read(&mut self) -> IoResult<()> {\n-        self.obj.close_read().map_err(IoError::from_rtio_error)\n+        self.inner.close_read()\n     }\n \n     /// Closes the writing half of this connection.\n@@ -176,7 +160,7 @@ impl TcpStream {\n     /// Note that this method affects all cloned handles associated with this\n     /// stream, not just this one handle.\n     pub fn close_write(&mut self) -> IoResult<()> {\n-        self.obj.close_write().map_err(IoError::from_rtio_error)\n+        self.inner.close_write()\n     }\n \n     /// Sets a timeout, in milliseconds, for blocking operations on this stream.\n@@ -198,7 +182,7 @@ impl TcpStream {\n     /// take a look at `set_read_timeout` and `set_write_timeout`.\n     #[experimental = \"the timeout argument may change in type and value\"]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.obj.set_timeout(timeout_ms)\n+        self.inner.set_timeout(timeout_ms)\n     }\n \n     /// Sets the timeout for read operations on this stream.\n@@ -215,7 +199,7 @@ impl TcpStream {\n     /// during the timeout period.\n     #[experimental = \"the timeout argument may change in type and value\"]\n     pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.obj.set_read_timeout(timeout_ms)\n+        self.inner.set_read_timeout(timeout_ms)\n     }\n \n     /// Sets the timeout for write operations on this stream.\n@@ -242,7 +226,7 @@ impl TcpStream {\n     /// asynchronous fashion after the call to write returns.\n     #[experimental = \"the timeout argument may change in type and value\"]\n     pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.obj.set_write_timeout(timeout_ms)\n+        self.inner.set_write_timeout(timeout_ms)\n     }\n }\n \n@@ -256,19 +240,19 @@ impl Clone for TcpStream {\n     /// Instead, the first read will receive the first packet received, and the\n     /// second read will receive the second packet.\n     fn clone(&self) -> TcpStream {\n-        TcpStream { obj: self.obj.clone() }\n+        TcpStream { inner: self.inner.clone() }\n     }\n }\n \n impl Reader for TcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        self.obj.read(buf).map_err(IoError::from_rtio_error)\n+        self.inner.read(buf)\n     }\n }\n \n impl Writer for TcpStream {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.obj.write(buf).map_err(IoError::from_rtio_error)\n+        self.inner.write(buf)\n     }\n }\n \n@@ -309,7 +293,7 @@ impl Writer for TcpStream {\n /// # }\n /// ```\n pub struct TcpListener {\n-    obj: Box<RtioTcpListener + Send>,\n+    inner: TcpListenerImp,\n }\n \n impl TcpListener {\n@@ -324,34 +308,28 @@ impl TcpListener {\n     /// The address type can be any implementor of `ToSocketAddr` trait. See its\n     /// documentation for concrete examples.\n     pub fn bind<A: ToSocketAddr>(addr: A) -> IoResult<TcpListener> {\n-        super::with_addresses_io(addr, |io, addr| io.tcp_bind(addr).map(|l| TcpListener { obj: l }))\n+        super::with_addresses(addr, |addr| {\n+            TcpListenerImp::bind(addr).map(|inner| TcpListener { inner: inner })\n+        })\n     }\n \n     /// Returns the local socket address of this listener.\n     pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n-        match self.obj.socket_name() {\n-            Ok(rtio::SocketAddr { ip, port }) => {\n-                Ok(SocketAddr { ip: super::from_rtio(ip), port: port })\n-            }\n-            Err(e) => Err(IoError::from_rtio_error(e)),\n-        }\n+        self.inner.socket_name()\n     }\n }\n \n impl Listener<TcpStream, TcpAcceptor> for TcpListener {\n     fn listen(self) -> IoResult<TcpAcceptor> {\n-        match self.obj.listen() {\n-            Ok(acceptor) => Ok(TcpAcceptor { obj: acceptor }),\n-            Err(e) => Err(IoError::from_rtio_error(e)),\n-        }\n+        self.inner.listen(128).map(|a| TcpAcceptor { inner: a })\n     }\n }\n \n /// The accepting half of a TCP socket server. This structure is created through\n /// a `TcpListener`'s `listen` method, and this object can be used to accept new\n /// `TcpStream` instances.\n pub struct TcpAcceptor {\n-    obj: Box<RtioTcpAcceptor + Send>,\n+    inner: TcpAcceptorImp,\n }\n \n impl TcpAcceptor {\n@@ -399,7 +377,7 @@ impl TcpAcceptor {\n     /// ```\n     #[experimental = \"the type of the argument and name of this function are \\\n                       subject to change\"]\n-    pub fn set_timeout(&mut self, ms: Option<u64>) { self.obj.set_timeout(ms); }\n+    pub fn set_timeout(&mut self, ms: Option<u64>) { self.inner.set_timeout(ms); }\n \n     /// Closes the accepting capabilities of this acceptor.\n     ///\n@@ -445,16 +423,13 @@ impl TcpAcceptor {\n     /// ```\n     #[experimental]\n     pub fn close_accept(&mut self) -> IoResult<()> {\n-        self.obj.close_accept().map_err(IoError::from_rtio_error)\n+        self.inner.close_accept()\n     }\n }\n \n impl Acceptor<TcpStream> for TcpAcceptor {\n     fn accept(&mut self) -> IoResult<TcpStream> {\n-        match self.obj.accept(){\n-            Ok(s) => Ok(TcpStream::new(s)),\n-            Err(e) => Err(IoError::from_rtio_error(e)),\n-        }\n+        self.inner.accept().map(TcpStream::new)\n     }\n }\n \n@@ -473,7 +448,7 @@ impl Clone for TcpAcceptor {\n     /// This function is useful for creating a handle to invoke `close_accept`\n     /// on to wake up any other task blocked in `accept`.\n     fn clone(&self) -> TcpAcceptor {\n-        TcpAcceptor { obj: self.obj.clone() }\n+        TcpAcceptor { inner: self.inner.clone() }\n     }\n }\n \n@@ -1112,8 +1087,6 @@ mod test {\n \n     #[test]\n     fn shutdown_smoke() {\n-        use rt::rtio::RtioTcpStream;\n-\n         let addr = next_test_ip4();\n         let a = TcpListener::bind(addr).unwrap().listen();\n         spawn(proc() {\n@@ -1124,7 +1097,7 @@ mod test {\n         });\n \n         let mut s = TcpStream::connect(addr).unwrap();\n-        assert!(s.obj.close_write().is_ok());\n+        assert!(s.inner.close_write().is_ok());\n         assert!(s.write([1]).is_err());\n         assert_eq!(s.read_to_end(), Ok(vec!(1)));\n     }"}, {"sha": "31b619896479b67e4dc03adb625d93b2b2973e12", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 19, "deletions": 41, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41", "patch": "@@ -17,13 +17,10 @@\n \n use clone::Clone;\n use io::net::ip::{SocketAddr, IpAddr, ToSocketAddr};\n-use io::{Reader, Writer, IoResult, IoError};\n-use kinds::Send;\n-use boxed::Box;\n+use io::{Reader, Writer, IoResult};\n use option::Option;\n use result::{Ok, Err};\n-use rt::rtio::{RtioSocket, RtioUdpSocket, IoFactory};\n-use rt::rtio;\n+use sys::udp::UdpSocket as UdpSocketImp;\n \n /// A User Datagram Protocol socket.\n ///\n@@ -60,7 +57,7 @@ use rt::rtio;\n /// }\n /// ```\n pub struct UdpSocket {\n-    obj: Box<RtioUdpSocket + Send>,\n+    inner: UdpSocketImp,\n }\n \n impl UdpSocket {\n@@ -69,18 +66,15 @@ impl UdpSocket {\n     /// Address type can be any implementor of `ToSocketAddr` trait. See its\n     /// documentation for concrete examples.\n     pub fn bind<A: ToSocketAddr>(addr: A) -> IoResult<UdpSocket> {\n-        super::with_addresses_io(addr, |io, addr| io.udp_bind(addr).map(|s| UdpSocket { obj: s }))\n+        super::with_addresses(addr, |addr| {\n+            UdpSocketImp::bind(addr).map(|s| UdpSocket { inner: s })\n+        })\n     }\n \n     /// Receives data from the socket. On success, returns the number of bytes\n     /// read and the address from whence the data came.\n     pub fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(uint, SocketAddr)> {\n-        match self.obj.recv_from(buf) {\n-            Ok((amt, rtio::SocketAddr { ip, port })) => {\n-                Ok((amt, SocketAddr { ip: super::from_rtio(ip), port: port }))\n-            }\n-            Err(e) => Err(IoError::from_rtio_error(e)),\n-        }\n+        self.inner.recv_from(buf)\n     }\n \n     /// Sends data on the socket to the given address. Returns nothing on\n@@ -89,10 +83,7 @@ impl UdpSocket {\n     /// Address type can be any implementor of `ToSocketAddr` trait. See its\n     /// documentation for concrete examples.\n     pub fn send_to<A: ToSocketAddr>(&mut self, buf: &[u8], addr: A) -> IoResult<()> {\n-        super::with_addresses(addr, |addr| self.obj.send_to(buf, rtio::SocketAddr {\n-            ip: super::to_rtio(addr.ip),\n-            port: addr.port,\n-        }).map_err(IoError::from_rtio_error))\n+        super::with_addresses(addr, |addr| self.inner.send_to(buf, addr))\n     }\n \n     /// Creates a `UdpStream`, which allows use of the `Reader` and `Writer`\n@@ -112,82 +103,69 @@ impl UdpSocket {\n \n     /// Returns the socket address that this socket was created from.\n     pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n-        match self.obj.socket_name() {\n-            Ok(a) => Ok(SocketAddr { ip: super::from_rtio(a.ip), port: a.port }),\n-            Err(e) => Err(IoError::from_rtio_error(e))\n-        }\n+        self.inner.socket_name()\n     }\n \n     /// Joins a multicast IP address (becomes a member of it)\n     #[experimental]\n     pub fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n-        let e = self.obj.join_multicast(super::to_rtio(multi));\n-        e.map_err(IoError::from_rtio_error)\n+        self.inner.join_multicast(multi)\n     }\n \n     /// Leaves a multicast IP address (drops membership from it)\n     #[experimental]\n     pub fn leave_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n-        let e = self.obj.leave_multicast(super::to_rtio(multi));\n-        e.map_err(IoError::from_rtio_error)\n+        self.inner.leave_multicast(multi)\n     }\n \n     /// Set the multicast loop flag to the specified value\n     ///\n     /// This lets multicast packets loop back to local sockets (if enabled)\n     #[experimental]\n     pub fn set_multicast_loop(&mut self, on: bool) -> IoResult<()> {\n-        if on {\n-            self.obj.loop_multicast_locally()\n-        } else {\n-            self.obj.dont_loop_multicast_locally()\n-        }.map_err(IoError::from_rtio_error)\n+        self.inner.set_multicast_loop(on)\n     }\n \n     /// Sets the multicast TTL\n     #[experimental]\n     pub fn set_multicast_ttl(&mut self, ttl: int) -> IoResult<()> {\n-        self.obj.multicast_time_to_live(ttl).map_err(IoError::from_rtio_error)\n+        self.inner.multicast_time_to_live(ttl)\n     }\n \n     /// Sets this socket's TTL\n     #[experimental]\n     pub fn set_ttl(&mut self, ttl: int) -> IoResult<()> {\n-        self.obj.time_to_live(ttl).map_err(IoError::from_rtio_error)\n+        self.inner.time_to_live(ttl)\n     }\n \n     /// Sets the broadcast flag on or off\n     #[experimental]\n     pub fn set_broadcast(&mut self, broadcast: bool) -> IoResult<()> {\n-        if broadcast {\n-            self.obj.hear_broadcasts()\n-        } else {\n-            self.obj.ignore_broadcasts()\n-        }.map_err(IoError::from_rtio_error)\n+        self.inner.set_broadcast(broadcast)\n     }\n \n     /// Sets the read/write timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n     #[experimental = \"the timeout argument may change in type and value\"]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.obj.set_timeout(timeout_ms)\n+        self.inner.set_timeout(timeout_ms)\n     }\n \n     /// Sets the read timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n     #[experimental = \"the timeout argument may change in type and value\"]\n     pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.obj.set_read_timeout(timeout_ms)\n+        self.inner.set_read_timeout(timeout_ms)\n     }\n \n     /// Sets the write timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n     #[experimental = \"the timeout argument may change in type and value\"]\n     pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.obj.set_write_timeout(timeout_ms)\n+        self.inner.set_write_timeout(timeout_ms)\n     }\n }\n \n@@ -201,7 +179,7 @@ impl Clone for UdpSocket {\n     /// received, and the second read will receive the second packet.\n     fn clone(&self) -> UdpSocket {\n         UdpSocket {\n-            obj: self.obj.clone(),\n+            inner: self.inner.clone(),\n         }\n     }\n }"}, {"sha": "64b2518fab1c5a841371c77a569ab99087339912", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 26, "deletions": 32, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41", "patch": "@@ -17,15 +17,17 @@\n \n use prelude::*;\n \n-use io::{IoResult, IoError};\n+use io::IoResult;\n use libc;\n-use os;\n-use rt::rtio::{RtioPipe, LocalIo};\n+use sync::Arc;\n+\n+use sys_common;\n+use sys;\n+use sys::fs::FileDesc as FileDesc;\n \n /// A synchronous, in-memory pipe.\n pub struct PipeStream {\n-    /// The internal, opaque runtime pipe object.\n-    obj: Box<RtioPipe + Send>,\n+    inner: Arc<FileDesc>\n }\n \n pub struct PipePair {\n@@ -55,14 +57,14 @@ impl PipeStream {\n     /// }\n     /// ```\n     pub fn open(fd: libc::c_int) -> IoResult<PipeStream> {\n-        LocalIo::maybe_raise(|io| {\n-            io.pipe_open(fd).map(|obj| PipeStream { obj: obj })\n-        }).map_err(IoError::from_rtio_error)\n+        Ok(PipeStream::from_filedesc(FileDesc::new(fd, true)))\n     }\n \n+    // FIXME: expose this some other way\n+    /// Wrap a FileDesc directly, taking ownership.\n     #[doc(hidden)]\n-    pub fn new(inner: Box<RtioPipe + Send>) -> PipeStream {\n-        PipeStream { obj: inner }\n+    pub fn from_filedesc(fd: FileDesc) -> PipeStream {\n+        PipeStream { inner: Arc::new(fd) }\n     }\n \n     /// Creates a pair of in-memory OS pipes for a unidirectional communication\n@@ -76,43 +78,35 @@ impl PipeStream {\n     /// This function can fail to succeed if the underlying OS has run out of\n     /// available resources to allocate a new pipe.\n     pub fn pair() -> IoResult<PipePair> {\n-        struct Closer { fd: libc::c_int }\n-\n-        let os::Pipe { reader, writer } = try!(unsafe { os::pipe() });\n-        let mut reader = Closer { fd: reader };\n-        let mut writer = Closer { fd: writer };\n-\n-        let io_reader = try!(PipeStream::open(reader.fd));\n-        reader.fd = -1;\n-        let io_writer = try!(PipeStream::open(writer.fd));\n-        writer.fd = -1;\n-        return Ok(PipePair { reader: io_reader, writer: io_writer });\n-\n-        impl Drop for Closer {\n-            fn drop(&mut self) {\n-                if self.fd != -1 {\n-                    let _ = unsafe { libc::close(self.fd) };\n-                }\n-            }\n-        }\n+        let (reader, writer) = try!(unsafe { sys::os::pipe() });\n+        Ok(PipePair {\n+            reader: PipeStream::from_filedesc(reader),\n+            writer: PipeStream::from_filedesc(writer),\n+        })\n+    }\n+}\n+\n+impl sys_common::AsFileDesc for PipeStream {\n+    fn as_fd(&self) -> &sys::fs::FileDesc {\n+        &*self.inner\n     }\n }\n \n impl Clone for PipeStream {\n     fn clone(&self) -> PipeStream {\n-        PipeStream { obj: self.obj.clone() }\n+        PipeStream { inner: self.inner.clone() }\n     }\n }\n \n impl Reader for PipeStream {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        self.obj.read(buf).map_err(IoError::from_rtio_error)\n+        self.inner.read(buf)\n     }\n }\n \n impl Writer for PipeStream {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.obj.write(buf).map_err(IoError::from_rtio_error)\n+        self.inner.write(buf)\n     }\n }\n "}, {"sha": "ea42117bab601f99bb93dc2927a716723a524bcb", "filename": "src/libstd/os.rs", "status": "modified", "additions": 6, "deletions": 29, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41", "patch": "@@ -43,6 +43,7 @@ use ops::Drop;\n use option::{Some, None, Option};\n use os;\n use path::{Path, GenericPath, BytesContainer};\n+use sys;\n use sys::os as os_imp;\n use ptr::RawPtr;\n use ptr;\n@@ -603,35 +604,11 @@ pub struct Pipe {\n /// descriptors to be closed, the file descriptors will leak. For safe handling\n /// of this scenario, use `std::io::PipeStream` instead.\n pub unsafe fn pipe() -> IoResult<Pipe> {\n-    return _pipe();\n-\n-    #[cfg(unix)]\n-    unsafe fn _pipe() -> IoResult<Pipe> {\n-        let mut fds = [0, ..2];\n-        match libc::pipe(fds.as_mut_ptr()) {\n-            0 => Ok(Pipe { reader: fds[0], writer: fds[1] }),\n-            _ => Err(IoError::last_error()),\n-        }\n-    }\n-\n-    #[cfg(windows)]\n-    unsafe fn _pipe() -> IoResult<Pipe> {\n-        // Windows pipes work subtly differently than unix pipes, and their\n-        // inheritance has to be handled in a different way that I do not\n-        // fully understand. Here we explicitly make the pipe non-inheritable,\n-        // which means to pass it to a subprocess they need to be duplicated\n-        // first, as in std::run.\n-        let mut fds = [0, ..2];\n-        match libc::pipe(fds.as_mut_ptr(), 1024 as ::libc::c_uint,\n-                         (libc::O_BINARY | libc::O_NOINHERIT) as c_int) {\n-            0 => {\n-                assert!(fds[0] != -1 && fds[0] != 0);\n-                assert!(fds[1] != -1 && fds[1] != 0);\n-                Ok(Pipe { reader: fds[0], writer: fds[1] })\n-            }\n-            _ => Err(IoError::last_error()),\n-        }\n-    }\n+    let (reader, writer) = try!(sys::os::pipe());\n+    Ok(Pipe {\n+        reader: reader.unwrap(),\n+        writer: writer.unwrap(),\n+    })\n }\n \n /// Returns the proper dll filename for the given basename of a file"}, {"sha": "0559005100f9075963045d9c8df2c5447abae32c", "filename": "src/libstd/sys/common/net.rs", "status": "renamed", "additions": 458, "deletions": 652, "changes": 1110, "blob_url": "https://github.com/rust-lang/rust/blob/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41", "patch": "@@ -9,21 +9,26 @@\n // except according to those terms.\n \n use alloc::arc::Arc;\n-use libc;\n-use std::mem;\n-use std::ptr;\n-use std::rt::mutex;\n-use std::rt::rtio::{mod, IoResult, IoError};\n-use std::sync::atomic;\n-\n-use super::{retry, keep_going};\n-use super::c;\n-use super::util;\n-\n-#[cfg(unix)] use super::process;\n-#[cfg(unix)] use super::file::FileDesc;\n-\n-pub use self::os::{init, sock_t, last_error};\n+use libc::{mod, c_char, c_int};\n+use mem;\n+use ptr::{mod, null, null_mut};\n+use rt::mutex;\n+use io::net::ip::{SocketAddr, IpAddr, Ipv4Addr, Ipv6Addr};\n+use io::net::addrinfo;\n+use io::{IoResult, IoError};\n+use sys::{mod, retry, c, sock_t, last_error, last_net_error, last_gai_error, close_sock,\n+          wrlen, msglen_t, os, wouldblock, set_nonblocking, timer, ms_to_timeval,\n+          decode_error_detailed};\n+use sys_common::{mod, keep_going, short_write, timeout};\n+use prelude::*;\n+use cmp;\n+use io;\n+\n+#[deriving(Show)]\n+pub enum SocketStatus {\n+    Readable,\n+    Writable,\n+}\n \n ////////////////////////////////////////////////////////////////////////////////\n // sockaddr and misc bindings\n@@ -36,14 +41,14 @@ pub fn ntohs(u: u16) -> u16 {\n     Int::from_be(u)\n }\n \n-enum InAddr {\n+pub enum InAddr {\n     In4Addr(libc::in_addr),\n     In6Addr(libc::in6_addr),\n }\n \n-fn ip_to_inaddr(ip: rtio::IpAddr) -> InAddr {\n+pub fn ip_to_inaddr(ip: IpAddr) -> InAddr {\n     match ip {\n-        rtio::Ipv4Addr(a, b, c, d) => {\n+        Ipv4Addr(a, b, c, d) => {\n             let ip = (a as u32 << 24) |\n                      (b as u32 << 16) |\n                      (c as u32 <<  8) |\n@@ -52,7 +57,7 @@ fn ip_to_inaddr(ip: rtio::IpAddr) -> InAddr {\n                 s_addr: Int::from_be(ip)\n             })\n         }\n-        rtio::Ipv6Addr(a, b, c, d, e, f, g, h) => {\n+        Ipv6Addr(a, b, c, d, e, f, g, h) => {\n             In6Addr(libc::in6_addr {\n                 s6_addr: [\n                     htons(a),\n@@ -69,7 +74,7 @@ fn ip_to_inaddr(ip: rtio::IpAddr) -> InAddr {\n     }\n }\n \n-fn addr_to_sockaddr(addr: rtio::SocketAddr,\n+pub fn addr_to_sockaddr(addr: SocketAddr,\n                     storage: &mut libc::sockaddr_storage)\n                     -> libc::socklen_t {\n     unsafe {\n@@ -93,28 +98,28 @@ fn addr_to_sockaddr(addr: rtio::SocketAddr,\n     }\n }\n \n-fn socket(addr: rtio::SocketAddr, ty: libc::c_int) -> IoResult<sock_t> {\n+pub fn socket(addr: SocketAddr, ty: libc::c_int) -> IoResult<sock_t> {\n     unsafe {\n         let fam = match addr.ip {\n-            rtio::Ipv4Addr(..) => libc::AF_INET,\n-            rtio::Ipv6Addr(..) => libc::AF_INET6,\n+            Ipv4Addr(..) => libc::AF_INET,\n+            Ipv6Addr(..) => libc::AF_INET6,\n         };\n         match libc::socket(fam, ty, 0) {\n-            -1 => Err(os::last_error()),\n+            -1 => Err(last_net_error()),\n             fd => Ok(fd),\n         }\n     }\n }\n \n-fn setsockopt<T>(fd: sock_t, opt: libc::c_int, val: libc::c_int,\n+pub fn setsockopt<T>(fd: sock_t, opt: libc::c_int, val: libc::c_int,\n                  payload: T) -> IoResult<()> {\n     unsafe {\n         let payload = &payload as *const T as *const libc::c_void;\n         let ret = libc::setsockopt(fd, opt, val,\n                                    payload,\n                                    mem::size_of::<T>() as libc::socklen_t);\n         if ret != 0 {\n-            Err(os::last_error())\n+            Err(last_net_error())\n         } else {\n             Ok(())\n         }\n@@ -130,18 +135,18 @@ pub fn getsockopt<T: Copy>(fd: sock_t, opt: libc::c_int,\n                                 &mut slot as *mut _ as *mut _,\n                                 &mut len);\n         if ret != 0 {\n-            Err(os::last_error())\n+            Err(last_net_error())\n         } else {\n             assert!(len as uint == mem::size_of::<T>());\n             Ok(slot)\n         }\n     }\n }\n \n-fn sockname(fd: sock_t,\n+pub fn sockname(fd: sock_t,\n             f: unsafe extern \"system\" fn(sock_t, *mut libc::sockaddr,\n                                          *mut libc::socklen_t) -> libc::c_int)\n-    -> IoResult<rtio::SocketAddr>\n+    -> IoResult<SocketAddr>\n {\n     let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n     let mut len = mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n@@ -151,14 +156,14 @@ fn sockname(fd: sock_t,\n                     storage as *mut libc::sockaddr,\n                     &mut len as *mut libc::socklen_t);\n         if ret != 0 {\n-            return Err(os::last_error())\n+            return Err(last_net_error())\n         }\n     }\n     return sockaddr_to_addr(&storage, len as uint);\n }\n \n pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n-                        len: uint) -> IoResult<rtio::SocketAddr> {\n+                        len: uint) -> IoResult<SocketAddr> {\n     match storage.ss_family as libc::c_int {\n         libc::AF_INET => {\n             assert!(len as uint >= mem::size_of::<libc::sockaddr_in>());\n@@ -170,8 +175,8 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n             let b = (ip >> 16) as u8;\n             let c = (ip >>  8) as u8;\n             let d = (ip >>  0) as u8;\n-            Ok(rtio::SocketAddr {\n-                ip: rtio::Ipv4Addr(a, b, c, d),\n+            Ok(SocketAddr {\n+                ip: Ipv4Addr(a, b, c, d),\n                 port: ntohs(storage.sin_port),\n             })\n         }\n@@ -188,33 +193,359 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n             let f = ntohs(storage.sin6_addr.s6_addr[5]);\n             let g = ntohs(storage.sin6_addr.s6_addr[6]);\n             let h = ntohs(storage.sin6_addr.s6_addr[7]);\n-            Ok(rtio::SocketAddr {\n-                ip: rtio::Ipv6Addr(a, b, c, d, e, f, g, h),\n+            Ok(SocketAddr {\n+                ip: Ipv6Addr(a, b, c, d, e, f, g, h),\n                 port: ntohs(storage.sin6_port),\n             })\n         }\n         _ => {\n-            #[cfg(unix)] use libc::EINVAL as ERROR;\n-            #[cfg(windows)] use libc::WSAEINVAL as ERROR;\n             Err(IoError {\n-                code: ERROR as uint,\n-                extra: 0,\n+                kind: io::InvalidInput,\n+                desc: \"invalid argument\",\n                 detail: None,\n             })\n         }\n     }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n-// TCP streams\n+// get_host_addresses\n ////////////////////////////////////////////////////////////////////////////////\n \n-pub struct TcpStream {\n-    inner: Arc<Inner>,\n-    read_deadline: u64,\n-    write_deadline: u64,\n+extern \"system\" {\n+    fn getaddrinfo(node: *const c_char, service: *const c_char,\n+                   hints: *const libc::addrinfo,\n+                   res: *mut *mut libc::addrinfo) -> c_int;\n+    fn freeaddrinfo(res: *mut libc::addrinfo);\n }\n \n+pub fn get_host_addresses(host: Option<&str>, servname: Option<&str>,\n+                          hint: Option<addrinfo::Hint>)\n+                          -> Result<Vec<addrinfo::Info>, IoError>\n+{\n+    sys::init_net();\n+\n+    assert!(host.is_some() || servname.is_some());\n+\n+    let c_host = host.map(|x| x.to_c_str());\n+    let c_host = c_host.as_ref().map(|x| x.as_ptr()).unwrap_or(null());\n+    let c_serv = servname.map(|x| x.to_c_str());\n+    let c_serv = c_serv.as_ref().map(|x| x.as_ptr()).unwrap_or(null());\n+\n+    let hint = hint.map(|hint| {\n+        libc::addrinfo {\n+            ai_flags: hint.flags as c_int,\n+            ai_family: hint.family as c_int,\n+            ai_socktype: 0,\n+            ai_protocol: 0,\n+            ai_addrlen: 0,\n+            ai_canonname: null_mut(),\n+            ai_addr: null_mut(),\n+            ai_next: null_mut()\n+        }\n+    });\n+\n+    let hint_ptr = hint.as_ref().map_or(null(), |x| {\n+        x as *const libc::addrinfo\n+    });\n+    let mut res = null_mut();\n+\n+    // Make the call\n+    let s = unsafe {\n+        getaddrinfo(c_host, c_serv, hint_ptr, &mut res)\n+    };\n+\n+    // Error?\n+    if s != 0 {\n+        return Err(last_gai_error(s));\n+    }\n+\n+    // Collect all the results we found\n+    let mut addrs = Vec::new();\n+    let mut rp = res;\n+    while rp.is_not_null() {\n+        unsafe {\n+            let addr = try!(sockaddr_to_addr(mem::transmute((*rp).ai_addr),\n+                                             (*rp).ai_addrlen as uint));\n+            addrs.push(addrinfo::Info {\n+                address: addr,\n+                family: (*rp).ai_family as uint,\n+                socktype: None,\n+                protocol: None,\n+                flags: (*rp).ai_flags as uint\n+            });\n+\n+            rp = (*rp).ai_next as *mut libc::addrinfo;\n+        }\n+    }\n+\n+    unsafe { freeaddrinfo(res); }\n+\n+    Ok(addrs)\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Timeout helpers\n+//\n+// The read/write functions below are the helpers for reading/writing a socket\n+// with a possible deadline specified. This is generally viewed as a timed out\n+// I/O operation.\n+//\n+// From the application's perspective, timeouts apply to the I/O object, not to\n+// the underlying file descriptor (it's one timeout per object). This means that\n+// we can't use the SO_RCVTIMEO and corresponding send timeout option.\n+//\n+// The next idea to implement timeouts would be to use nonblocking I/O. An\n+// invocation of select() would wait (with a timeout) for a socket to be ready.\n+// Once its ready, we can perform the operation. Note that the operation *must*\n+// be nonblocking, even though select() says the socket is ready. This is\n+// because some other thread could have come and stolen our data (handles can be\n+// cloned).\n+//\n+// To implement nonblocking I/O, the first option we have is to use the\n+// O_NONBLOCK flag. Remember though that this is a global setting, affecting all\n+// I/O objects, so this was initially viewed as unwise.\n+//\n+// It turns out that there's this nifty MSG_DONTWAIT flag which can be passed to\n+// send/recv, but the niftiness wears off once you realize it only works well on\n+// Linux [1] [2]. This means that it's pretty easy to get a nonblocking\n+// operation on Linux (no flag fiddling, no affecting other objects), but not on\n+// other platforms.\n+//\n+// To work around this constraint on other platforms, we end up using the\n+// original strategy of flipping the O_NONBLOCK flag. As mentioned before, this\n+// could cause other objects' blocking operations to suddenly become\n+// nonblocking. To get around this, a \"blocking operation\" which returns EAGAIN\n+// falls back to using the same code path as nonblocking operations, but with an\n+// infinite timeout (select + send/recv). This helps emulate blocking\n+// reads/writes despite the underlying descriptor being nonblocking, as well as\n+// optimizing the fast path of just hitting one syscall in the good case.\n+//\n+// As a final caveat, this implementation uses a mutex so only one thread is\n+// doing a nonblocking operation at at time. This is the operation that comes\n+// after the select() (at which point we think the socket is ready). This is\n+// done for sanity to ensure that the state of the O_NONBLOCK flag is what we\n+// expect (wouldn't want someone turning it on when it should be off!). All\n+// operations performed in the lock are *nonblocking* to avoid holding the mutex\n+// forever.\n+//\n+// So, in summary, Linux uses MSG_DONTWAIT and doesn't need mutexes, everyone\n+// else uses O_NONBLOCK and mutexes with some trickery to make sure blocking\n+// reads/writes are still blocking.\n+//\n+// Fun, fun!\n+//\n+// [1] http://twistedmatrix.com/pipermail/twisted-commits/2012-April/034692.html\n+// [2] http://stackoverflow.com/questions/19819198/does-send-msg-dontwait\n+\n+pub fn read<T>(fd: sock_t,\n+               deadline: u64,\n+               lock: || -> T,\n+               read: |bool| -> libc::c_int) -> IoResult<uint> {\n+    let mut ret = -1;\n+    if deadline == 0 {\n+        ret = retry(|| read(false));\n+    }\n+\n+    if deadline != 0 || (ret == -1 && wouldblock()) {\n+        let deadline = match deadline {\n+            0 => None,\n+            n => Some(n),\n+        };\n+        loop {\n+            // With a timeout, first we wait for the socket to become\n+            // readable using select(), specifying the relevant timeout for\n+            // our previously set deadline.\n+            try!(await([fd], deadline, Readable));\n+\n+            // At this point, we're still within the timeout, and we've\n+            // determined that the socket is readable (as returned by\n+            // select). We must still read the socket in *nonblocking* mode\n+            // because some other thread could come steal our data. If we\n+            // fail to read some data, we retry (hence the outer loop) and\n+            // wait for the socket to become readable again.\n+            let _guard = lock();\n+            match retry(|| read(deadline.is_some())) {\n+                -1 if wouldblock() => {}\n+                -1 => return Err(last_net_error()),\n+               n => { ret = n; break }\n+            }\n+        }\n+    }\n+\n+    match ret {\n+        0 => Err(sys_common::eof()),\n+        n if n < 0 => Err(last_net_error()),\n+        n => Ok(n as uint)\n+    }\n+}\n+\n+pub fn write<T>(fd: sock_t,\n+                deadline: u64,\n+                buf: &[u8],\n+                write_everything: bool,\n+                lock: || -> T,\n+                write: |bool, *const u8, uint| -> i64) -> IoResult<uint> {\n+    let mut ret = -1;\n+    let mut written = 0;\n+    if deadline == 0 {\n+        if write_everything {\n+            ret = keep_going(buf, |inner, len| {\n+                written = buf.len() - len;\n+                write(false, inner, len)\n+            });\n+        } else {\n+            ret = retry(|| { write(false, buf.as_ptr(), buf.len()) });\n+            if ret > 0 { written = ret as uint; }\n+        }\n+    }\n+\n+    if deadline != 0 || (ret == -1 && wouldblock()) {\n+        let deadline = match deadline {\n+            0 => None,\n+            n => Some(n),\n+        };\n+        while written < buf.len() && (write_everything || written == 0) {\n+            // As with read(), first wait for the socket to be ready for\n+            // the I/O operation.\n+            match await([fd], deadline, Writable) {\n+                Err(ref e) if e.kind == io::EndOfFile && written > 0 => {\n+                    assert!(deadline.is_some());\n+                    return Err(short_write(written, \"short write\"))\n+                }\n+                Err(e) => return Err(e),\n+                Ok(()) => {}\n+            }\n+\n+            // Also as with read(), we use MSG_DONTWAIT to guard ourselves\n+            // against unforeseen circumstances.\n+            let _guard = lock();\n+            let ptr = buf[written..].as_ptr();\n+            let len = buf.len() - written;\n+            match retry(|| write(deadline.is_some(), ptr, len)) {\n+                -1 if wouldblock() => {}\n+                -1 => return Err(last_net_error()),\n+                n => { written += n as uint; }\n+            }\n+        }\n+        ret = 0;\n+    }\n+    if ret < 0 {\n+        Err(last_net_error())\n+    } else {\n+        Ok(written)\n+    }\n+}\n+\n+// See http://developerweb.net/viewtopic.php?id=3196 for where this is\n+// derived from.\n+pub fn connect_timeout(fd: sock_t,\n+                       addrp: *const libc::sockaddr,\n+                       len: libc::socklen_t,\n+                       timeout_ms: u64) -> IoResult<()> {\n+    #[cfg(unix)]    use libc::EINPROGRESS as INPROGRESS;\n+    #[cfg(windows)] use libc::WSAEINPROGRESS as INPROGRESS;\n+    #[cfg(unix)]    use libc::EWOULDBLOCK as WOULDBLOCK;\n+    #[cfg(windows)] use libc::WSAEWOULDBLOCK as WOULDBLOCK;\n+\n+    // Make sure the call to connect() doesn't block\n+    try!(set_nonblocking(fd, true));\n+\n+    let ret = match unsafe { libc::connect(fd, addrp, len) } {\n+        // If the connection is in progress, then we need to wait for it to\n+        // finish (with a timeout). The current strategy for doing this is\n+        // to use select() with a timeout.\n+        -1 if os::errno() as int == INPROGRESS as int ||\n+              os::errno() as int == WOULDBLOCK as int => {\n+            let mut set: c::fd_set = unsafe { mem::zeroed() };\n+            c::fd_set(&mut set, fd);\n+            match await(fd, &mut set, timeout_ms) {\n+                0 => Err(timeout(\"connection timed out\")),\n+                -1 => Err(last_net_error()),\n+                _ => {\n+                    let err: libc::c_int = try!(\n+                        getsockopt(fd, libc::SOL_SOCKET, libc::SO_ERROR));\n+                    if err == 0 {\n+                        Ok(())\n+                    } else {\n+                        Err(decode_error_detailed(err))\n+                    }\n+                }\n+            }\n+        }\n+\n+        -1 => Err(last_net_error()),\n+        _ => Ok(()),\n+    };\n+\n+    // be sure to turn blocking I/O back on\n+    try!(set_nonblocking(fd, false));\n+    return ret;\n+\n+    #[cfg(unix)]\n+    fn await(fd: sock_t, set: &mut c::fd_set, timeout: u64) -> libc::c_int {\n+        let start = timer::now();\n+        retry(|| unsafe {\n+            // Recalculate the timeout each iteration (it is generally\n+            // undefined what the value of the 'tv' is after select\n+            // returns EINTR).\n+            let mut tv = ms_to_timeval(timeout - (timer::now() - start));\n+            c::select(fd + 1, ptr::null_mut(), set as *mut _,\n+                      ptr::null_mut(), &mut tv)\n+        })\n+    }\n+    #[cfg(windows)]\n+    fn await(_fd: sock_t, set: &mut c::fd_set, timeout: u64) -> libc::c_int {\n+        let mut tv = ms_to_timeval(timeout);\n+        unsafe { c::select(1, ptr::null_mut(), set, ptr::null_mut(), &mut tv) }\n+    }\n+}\n+\n+pub fn await(fds: &[sock_t], deadline: Option<u64>,\n+             status: SocketStatus) -> IoResult<()> {\n+    let mut set: c::fd_set = unsafe { mem::zeroed() };\n+    let mut max = 0;\n+    for &fd in fds.iter() {\n+        c::fd_set(&mut set, fd);\n+        max = cmp::max(max, fd + 1);\n+    }\n+    if cfg!(windows) {\n+        max = fds.len() as sock_t;\n+    }\n+\n+    let (read, write) = match status {\n+        Readable => (&mut set as *mut _, ptr::null_mut()),\n+        Writable => (ptr::null_mut(), &mut set as *mut _),\n+    };\n+    let mut tv: libc::timeval = unsafe { mem::zeroed() };\n+\n+    match retry(|| {\n+        let now = timer::now();\n+        let tvp = match deadline {\n+            None => ptr::null_mut(),\n+            Some(deadline) => {\n+                // If we're past the deadline, then pass a 0 timeout to\n+                // select() so we can poll the status\n+                let ms = if deadline < now {0} else {deadline - now};\n+                tv = ms_to_timeval(ms);\n+                &mut tv as *mut _\n+            }\n+        };\n+        let r = unsafe {\n+            c::select(max as libc::c_int, read, write, ptr::null_mut(), tvp)\n+        };\n+        r\n+    }) {\n+        -1 => Err(last_net_error()),\n+        0 => Err(timeout(\"timed out\")),\n+        _ => Ok(()),\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Basic socket representation\n+////////////////////////////////////////////////////////////////////////////////\n+\n struct Inner {\n     fd: sock_t,\n \n@@ -223,57 +554,79 @@ struct Inner {\n     lock: mutex::NativeMutex\n }\n \n+impl Inner {\n+    fn new(fd: sock_t) -> Inner {\n+        Inner { fd: fd, lock: unsafe { mutex::NativeMutex::new() } }\n+    }\n+}\n+\n+impl Drop for Inner {\n+    fn drop(&mut self) { unsafe { close_sock(self.fd); } }\n+}\n+\n pub struct Guard<'a> {\n     pub fd: sock_t,\n     pub guard: mutex::LockGuard<'a>,\n }\n \n-impl Inner {\n-    fn new(fd: sock_t) -> Inner {\n-        Inner { fd: fd, lock: unsafe { mutex::NativeMutex::new() } }\n+#[unsafe_destructor]\n+impl<'a> Drop for Guard<'a> {\n+    fn drop(&mut self) {\n+        assert!(set_nonblocking(self.fd, false).is_ok());\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// TCP streams\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct TcpStream {\n+    inner: Arc<Inner>,\n+    read_deadline: u64,\n+    write_deadline: u64,\n+}\n+\n impl TcpStream {\n-    pub fn connect(addr: rtio::SocketAddr,\n-                   timeout: Option<u64>) -> IoResult<TcpStream> {\n+    pub fn connect(addr: SocketAddr, timeout: Option<u64>) -> IoResult<TcpStream> {\n+        sys::init_net();\n+\n         let fd = try!(socket(addr, libc::SOCK_STREAM));\n-        let ret = TcpStream::new(Inner::new(fd));\n+        let ret = TcpStream::new(fd);\n \n         let mut storage = unsafe { mem::zeroed() };\n         let len = addr_to_sockaddr(addr, &mut storage);\n         let addrp = &storage as *const _ as *const libc::sockaddr;\n \n         match timeout {\n             Some(timeout) => {\n-                try!(util::connect_timeout(fd, addrp, len, timeout));\n+                try!(connect_timeout(fd, addrp, len, timeout));\n                 Ok(ret)\n             },\n             None => {\n                 match retry(|| unsafe { libc::connect(fd, addrp, len) }) {\n-                    -1 => Err(os::last_error()),\n+                    -1 => Err(last_error()),\n                     _ => Ok(ret),\n                 }\n             }\n         }\n     }\n \n-    fn new(inner: Inner) -> TcpStream {\n+    pub fn new(fd: sock_t) -> TcpStream {\n         TcpStream {\n-            inner: Arc::new(inner),\n+            inner: Arc::new(Inner::new(fd)),\n             read_deadline: 0,\n             write_deadline: 0,\n         }\n     }\n \n     pub fn fd(&self) -> sock_t { self.inner.fd }\n \n-    fn set_nodelay(&mut self, nodelay: bool) -> IoResult<()> {\n+    pub fn set_nodelay(&mut self, nodelay: bool) -> IoResult<()> {\n         setsockopt(self.fd(), libc::IPPROTO_TCP, libc::TCP_NODELAY,\n                    nodelay as libc::c_int)\n     }\n \n-    fn set_keepalive(&mut self, seconds: Option<uint>) -> IoResult<()> {\n+    pub fn set_keepalive(&mut self, seconds: Option<uint>) -> IoResult<()> {\n         let ret = setsockopt(self.fd(), libc::SOL_SOCKET, libc::SO_KEEPALIVE,\n                              seconds.is_some() as libc::c_int);\n         match seconds {\n@@ -309,16 +662,11 @@ impl TcpStream {\n             fd: self.fd(),\n             guard: unsafe { self.inner.lock.lock() },\n         };\n-        assert!(util::set_nonblocking(self.fd(), true).is_ok());\n+        assert!(set_nonblocking(self.fd(), true).is_ok());\n         ret\n     }\n-}\n \n-#[cfg(windows)] type wrlen = libc::c_int;\n-#[cfg(not(windows))] type wrlen = libc::size_t;\n-\n-impl rtio::RtioTcpStream for TcpStream {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let fd = self.fd();\n         let dolock = || self.lock_nonblocking();\n         let doread = |nb| unsafe {\n@@ -331,7 +679,7 @@ impl rtio::RtioTcpStream for TcpStream {\n         read(fd, self.read_deadline, dolock, doread)\n     }\n \n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    pub fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let fd = self.fd();\n         let dolock = || self.lock_nonblocking();\n         let dowrite = |nb: bool, buf: *const u8, len: uint| unsafe {\n@@ -341,340 +689,42 @@ impl rtio::RtioTcpStream for TcpStream {\n                        len as wrlen,\n                        flags) as i64\n         };\n-        match write(fd, self.write_deadline, buf, true, dolock, dowrite) {\n-            Ok(_) => Ok(()),\n-            Err(e) => Err(e)\n-        }\n+        write(fd, self.write_deadline, buf, true, dolock, dowrite).map(|_| ())\n     }\n-    fn peer_name(&mut self) -> IoResult<rtio::SocketAddr> {\n+    pub fn peer_name(&mut self) -> IoResult<SocketAddr> {\n         sockname(self.fd(), libc::getpeername)\n     }\n-    fn control_congestion(&mut self) -> IoResult<()> {\n-        self.set_nodelay(false)\n-    }\n-    fn nodelay(&mut self) -> IoResult<()> {\n-        self.set_nodelay(true)\n-    }\n-    fn keepalive(&mut self, delay_in_seconds: uint) -> IoResult<()> {\n-        self.set_keepalive(Some(delay_in_seconds))\n-    }\n-    fn letdie(&mut self) -> IoResult<()> {\n-        self.set_keepalive(None)\n-    }\n \n-    fn clone(&self) -> Box<rtio::RtioTcpStream + Send> {\n-        box TcpStream {\n-            inner: self.inner.clone(),\n-            read_deadline: 0,\n-            write_deadline: 0,\n-        } as Box<rtio::RtioTcpStream + Send>\n-    }\n-\n-    fn close_write(&mut self) -> IoResult<()> {\n+    pub fn close_write(&mut self) -> IoResult<()> {\n         super::mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_WR) })\n     }\n-    fn close_read(&mut self) -> IoResult<()> {\n+    pub fn close_read(&mut self) -> IoResult<()> {\n         super::mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_RD) })\n     }\n \n-    fn set_timeout(&mut self, timeout: Option<u64>) {\n-        let deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    pub fn set_timeout(&mut self, timeout: Option<u64>) {\n+        let deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n         self.read_deadline = deadline;\n         self.write_deadline = deadline;\n     }\n-    fn set_read_timeout(&mut self, timeout: Option<u64>) {\n-        self.read_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n-    }\n-    fn set_write_timeout(&mut self, timeout: Option<u64>) {\n-        self.write_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n-    }\n-}\n-\n-impl rtio::RtioSocket for TcpStream {\n-    fn socket_name(&mut self) -> IoResult<rtio::SocketAddr> {\n-        sockname(self.fd(), libc::getsockname)\n-    }\n-}\n-\n-impl Drop for Inner {\n-    fn drop(&mut self) { unsafe { os::close(self.fd); } }\n-}\n-\n-#[unsafe_destructor]\n-impl<'a> Drop for Guard<'a> {\n-    fn drop(&mut self) {\n-        assert!(util::set_nonblocking(self.fd, false).is_ok());\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// TCP listeners\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct TcpListener {\n-    inner: Inner,\n-}\n-\n-impl TcpListener {\n-    pub fn bind(addr: rtio::SocketAddr) -> IoResult<TcpListener> {\n-        let fd = try!(socket(addr, libc::SOCK_STREAM));\n-        let ret = TcpListener { inner: Inner::new(fd) };\n-\n-        let mut storage = unsafe { mem::zeroed() };\n-        let len = addr_to_sockaddr(addr, &mut storage);\n-        let addrp = &storage as *const _ as *const libc::sockaddr;\n-\n-        // On platforms with Berkeley-derived sockets, this allows\n-        // to quickly rebind a socket, without needing to wait for\n-        // the OS to clean up the previous one.\n-        if cfg!(unix) {\n-            try!(setsockopt(fd, libc::SOL_SOCKET, libc::SO_REUSEADDR,\n-                            1 as libc::c_int));\n-        }\n-\n-        match unsafe { libc::bind(fd, addrp, len) } {\n-            -1 => Err(os::last_error()),\n-            _ => Ok(ret),\n-        }\n-    }\n-\n-    pub fn fd(&self) -> sock_t { self.inner.fd }\n-\n-    pub fn native_listen(self, backlog: int) -> IoResult<TcpAcceptor> {\n-        match unsafe { libc::listen(self.fd(), backlog as libc::c_int) } {\n-            -1 => Err(os::last_error()),\n-\n-            #[cfg(unix)]\n-            _ => {\n-                let (reader, writer) = try!(process::pipe());\n-                try!(util::set_nonblocking(reader.fd(), true));\n-                try!(util::set_nonblocking(writer.fd(), true));\n-                try!(util::set_nonblocking(self.fd(), true));\n-                Ok(TcpAcceptor {\n-                    inner: Arc::new(AcceptorInner {\n-                        listener: self,\n-                        reader: reader,\n-                        writer: writer,\n-                        closed: atomic::AtomicBool::new(false),\n-                    }),\n-                    deadline: 0,\n-                })\n-            }\n-\n-            #[cfg(windows)]\n-            _ => {\n-                let accept = try!(os::Event::new());\n-                let ret = unsafe {\n-                    c::WSAEventSelect(self.fd(), accept.handle(), c::FD_ACCEPT)\n-                };\n-                if ret != 0 {\n-                    return Err(os::last_error())\n-                }\n-                Ok(TcpAcceptor {\n-                    inner: Arc::new(AcceptorInner {\n-                        listener: self,\n-                        abort: try!(os::Event::new()),\n-                        accept: accept,\n-                        closed: atomic::AtomicBool::new(false),\n-                    }),\n-                    deadline: 0,\n-                })\n-            }\n-        }\n-    }\n-}\n-\n-impl rtio::RtioTcpListener for TcpListener {\n-    fn listen(self: Box<TcpListener>)\n-              -> IoResult<Box<rtio::RtioTcpAcceptor + Send>> {\n-        self.native_listen(128).map(|a| {\n-            box a as Box<rtio::RtioTcpAcceptor + Send>\n-        })\n-    }\n-}\n-\n-impl rtio::RtioSocket for TcpListener {\n-    fn socket_name(&mut self) -> IoResult<rtio::SocketAddr> {\n-        sockname(self.fd(), libc::getsockname)\n-    }\n-}\n-\n-pub struct TcpAcceptor {\n-    inner: Arc<AcceptorInner>,\n-    deadline: u64,\n-}\n-\n-#[cfg(unix)]\n-struct AcceptorInner {\n-    listener: TcpListener,\n-    reader: FileDesc,\n-    writer: FileDesc,\n-    closed: atomic::AtomicBool,\n-}\n-\n-#[cfg(windows)]\n-struct AcceptorInner {\n-    listener: TcpListener,\n-    abort: os::Event,\n-    accept: os::Event,\n-    closed: atomic::AtomicBool,\n-}\n-\n-impl TcpAcceptor {\n-    pub fn fd(&self) -> sock_t { self.inner.listener.fd() }\n-\n-    #[cfg(unix)]\n-    pub fn native_accept(&mut self) -> IoResult<TcpStream> {\n-        // In implementing accept, the two main concerns are dealing with\n-        // close_accept() and timeouts. The unix implementation is based on a\n-        // nonblocking accept plus a call to select(). Windows ends up having\n-        // an entirely separate implementation than unix, which is explained\n-        // below.\n-        //\n-        // To implement timeouts, all blocking is done via select() instead of\n-        // accept() by putting the socket in non-blocking mode. Because\n-        // select() takes a timeout argument, we just pass through the timeout\n-        // to select().\n-        //\n-        // To implement close_accept(), we have a self-pipe to ourselves which\n-        // is passed to select() along with the socket being accepted on. The\n-        // self-pipe is never written to unless close_accept() is called.\n-        let deadline = if self.deadline == 0 {None} else {Some(self.deadline)};\n-\n-        while !self.inner.closed.load(atomic::SeqCst) {\n-            match retry(|| unsafe {\n-                libc::accept(self.fd(), ptr::null_mut(), ptr::null_mut())\n-            }) {\n-                -1 if util::wouldblock() => {}\n-                -1 => return Err(os::last_error()),\n-                fd => return Ok(TcpStream::new(Inner::new(fd as sock_t))),\n-            }\n-            try!(util::await([self.fd(), self.inner.reader.fd()],\n-                             deadline, util::Readable));\n-        }\n-\n-        Err(util::eof())\n+    pub fn set_read_timeout(&mut self, timeout: Option<u64>) {\n+        self.read_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n     }\n-\n-    #[cfg(windows)]\n-    pub fn native_accept(&mut self) -> IoResult<TcpStream> {\n-        // Unlink unix, windows cannot invoke `select` on arbitrary file\n-        // descriptors like pipes, only sockets. Consequently, windows cannot\n-        // use the same implementation as unix for accept() when close_accept()\n-        // is considered.\n-        //\n-        // In order to implement close_accept() and timeouts, windows uses\n-        // event handles. An acceptor-specific abort event is created which\n-        // will only get set in close_accept(), and it will never be un-set.\n-        // Additionally, another acceptor-specific event is associated with the\n-        // FD_ACCEPT network event.\n-        //\n-        // These two events are then passed to WaitForMultipleEvents to see\n-        // which one triggers first, and the timeout passed to this function is\n-        // the local timeout for the acceptor.\n-        //\n-        // If the wait times out, then the accept timed out. If the wait\n-        // succeeds with the abort event, then we were closed, and if the wait\n-        // succeeds otherwise, then we do a nonblocking poll via `accept` to\n-        // see if we can accept a connection. The connection is candidate to be\n-        // stolen, so we do all of this in a loop as well.\n-        let events = [self.inner.abort.handle(), self.inner.accept.handle()];\n-\n-        while !self.inner.closed.load(atomic::SeqCst) {\n-            let ms = if self.deadline == 0 {\n-                c::WSA_INFINITE as u64\n-            } else {\n-                let now = ::io::timer::now();\n-                if self.deadline < now {0} else {self.deadline - now}\n-            };\n-            let ret = unsafe {\n-                c::WSAWaitForMultipleEvents(2, events.as_ptr(), libc::FALSE,\n-                                            ms as libc::DWORD, libc::FALSE)\n-            };\n-            match ret {\n-                c::WSA_WAIT_TIMEOUT => {\n-                    return Err(util::timeout(\"accept timed out\"))\n-                }\n-                c::WSA_WAIT_FAILED => return Err(os::last_error()),\n-                c::WSA_WAIT_EVENT_0 => break,\n-                n => assert_eq!(n, c::WSA_WAIT_EVENT_0 + 1),\n-            }\n-\n-            let mut wsaevents: c::WSANETWORKEVENTS = unsafe { mem::zeroed() };\n-            let ret = unsafe {\n-                c::WSAEnumNetworkEvents(self.fd(), events[1], &mut wsaevents)\n-            };\n-            if ret != 0 { return Err(os::last_error()) }\n-\n-            if wsaevents.lNetworkEvents & c::FD_ACCEPT == 0 { continue }\n-            match unsafe {\n-                libc::accept(self.fd(), ptr::null_mut(), ptr::null_mut())\n-            } {\n-                -1 if util::wouldblock() => {}\n-                -1 => return Err(os::last_error()),\n-\n-                // Accepted sockets inherit the same properties as the caller,\n-                // so we need to deregister our event and switch the socket back\n-                // to blocking mode\n-                fd => {\n-                    let stream = TcpStream::new(Inner::new(fd));\n-                    let ret = unsafe {\n-                        c::WSAEventSelect(fd, events[1], 0)\n-                    };\n-                    if ret != 0 { return Err(os::last_error()) }\n-                    try!(util::set_nonblocking(fd, false));\n-                    return Ok(stream)\n-                }\n-            }\n-        }\n-\n-        Err(util::eof())\n+    pub fn set_write_timeout(&mut self, timeout: Option<u64>) {\n+        self.write_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n     }\n-}\n \n-impl rtio::RtioSocket for TcpAcceptor {\n-    fn socket_name(&mut self) -> IoResult<rtio::SocketAddr> {\n+    pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n         sockname(self.fd(), libc::getsockname)\n     }\n }\n \n-impl rtio::RtioTcpAcceptor for TcpAcceptor {\n-    fn accept(&mut self) -> IoResult<Box<rtio::RtioTcpStream + Send>> {\n-        self.native_accept().map(|s| box s as Box<rtio::RtioTcpStream + Send>)\n-    }\n-\n-    fn accept_simultaneously(&mut self) -> IoResult<()> { Ok(()) }\n-    fn dont_accept_simultaneously(&mut self) -> IoResult<()> { Ok(()) }\n-    fn set_timeout(&mut self, timeout: Option<u64>) {\n-        self.deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n-    }\n-\n-    fn clone(&self) -> Box<rtio::RtioTcpAcceptor + Send> {\n-        box TcpAcceptor {\n+impl Clone for TcpStream {\n+    fn clone(&self) -> TcpStream {\n+        TcpStream {\n             inner: self.inner.clone(),\n-            deadline: 0,\n-        } as Box<rtio::RtioTcpAcceptor + Send>\n-    }\n-\n-    #[cfg(unix)]\n-    fn close_accept(&mut self) -> IoResult<()> {\n-        self.inner.closed.store(true, atomic::SeqCst);\n-        let mut fd = FileDesc::new(self.inner.writer.fd(), false);\n-        match fd.inner_write([0]) {\n-            Ok(..) => Ok(()),\n-            Err(..) if util::wouldblock() => Ok(()),\n-            Err(e) => Err(e),\n-        }\n-    }\n-\n-    #[cfg(windows)]\n-    fn close_accept(&mut self) -> IoResult<()> {\n-        self.inner.closed.store(true, atomic::SeqCst);\n-        let ret = unsafe { c::WSASetEvent(self.inner.abort.handle()) };\n-        if ret == libc::TRUE {\n-            Ok(())\n-        } else {\n-            Err(os::last_error())\n+            read_deadline: 0,\n+            write_deadline: 0,\n         }\n     }\n }\n@@ -690,7 +740,9 @@ pub struct UdpSocket {\n }\n \n impl UdpSocket {\n-    pub fn bind(addr: rtio::SocketAddr) -> IoResult<UdpSocket> {\n+    pub fn bind(addr: SocketAddr) -> IoResult<UdpSocket> {\n+        sys::init_net();\n+\n         let fd = try!(socket(addr, libc::SOCK_DGRAM));\n         let ret = UdpSocket {\n             inner: Arc::new(Inner::new(fd)),\n@@ -703,7 +755,7 @@ impl UdpSocket {\n         let addrp = &storage as *const _ as *const libc::sockaddr;\n \n         match unsafe { libc::bind(fd, addrp, len) } {\n-            -1 => Err(os::last_error()),\n+            -1 => Err(last_error()),\n             _ => Ok(ret),\n         }\n     }\n@@ -720,8 +772,7 @@ impl UdpSocket {\n                    on as libc::c_int)\n     }\n \n-    pub fn set_membership(&mut self, addr: rtio::IpAddr,\n-                          opt: libc::c_int) -> IoResult<()> {\n+    pub fn set_membership(&mut self, addr: IpAddr, opt: libc::c_int) -> IoResult<()> {\n         match ip_to_inaddr(addr) {\n             In4Addr(addr) => {\n                 let mreq = libc::ip_mreq {\n@@ -750,22 +801,15 @@ impl UdpSocket {\n             fd: self.fd(),\n             guard: unsafe { self.inner.lock.lock() },\n         };\n-        assert!(util::set_nonblocking(self.fd(), true).is_ok());\n+        assert!(set_nonblocking(self.fd(), true).is_ok());\n         ret\n     }\n-}\n \n-impl rtio::RtioSocket for UdpSocket {\n-    fn socket_name(&mut self) -> IoResult<rtio::SocketAddr> {\n+    pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n         sockname(self.fd(), libc::getsockname)\n     }\n-}\n-\n-#[cfg(windows)] type msglen_t = libc::c_int;\n-#[cfg(unix)]    type msglen_t = libc::size_t;\n \n-impl rtio::RtioUdpSocket for UdpSocket {\n-    fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(uint, rtio::SocketAddr)> {\n+    pub fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(uint, SocketAddr)> {\n         let fd = self.fd();\n         let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n         let storagep = &mut storage as *mut _ as *mut libc::sockaddr;\n@@ -787,7 +831,7 @@ impl rtio::RtioUdpSocket for UdpSocket {\n         })\n     }\n \n-    fn send_to(&mut self, buf: &[u8], dst: rtio::SocketAddr) -> IoResult<()> {\n+    pub fn send_to(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()> {\n         let mut storage = unsafe { mem::zeroed() };\n         let dstlen = addr_to_sockaddr(dst, &mut storage);\n         let dstp = &storage as *const _ as *const libc::sockaddr;\n@@ -806,298 +850,60 @@ impl rtio::RtioUdpSocket for UdpSocket {\n \n         let n = try!(write(fd, self.write_deadline, buf, false, dolock, dowrite));\n         if n != buf.len() {\n-            Err(util::short_write(n, \"couldn't send entire packet at once\"))\n+            Err(short_write(n, \"couldn't send entire packet at once\"))\n         } else {\n             Ok(())\n         }\n     }\n \n-    fn join_multicast(&mut self, multi: rtio::IpAddr) -> IoResult<()> {\n+    pub fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n         match multi {\n-            rtio::Ipv4Addr(..) => {\n+            Ipv4Addr(..) => {\n                 self.set_membership(multi, libc::IP_ADD_MEMBERSHIP)\n             }\n-            rtio::Ipv6Addr(..) => {\n+            Ipv6Addr(..) => {\n                 self.set_membership(multi, libc::IPV6_ADD_MEMBERSHIP)\n             }\n         }\n     }\n-    fn leave_multicast(&mut self, multi: rtio::IpAddr) -> IoResult<()> {\n+    pub fn leave_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n         match multi {\n-            rtio::Ipv4Addr(..) => {\n+            Ipv4Addr(..) => {\n                 self.set_membership(multi, libc::IP_DROP_MEMBERSHIP)\n             }\n-            rtio::Ipv6Addr(..) => {\n+            Ipv6Addr(..) => {\n                 self.set_membership(multi, libc::IPV6_DROP_MEMBERSHIP)\n             }\n         }\n     }\n \n-    fn loop_multicast_locally(&mut self) -> IoResult<()> {\n-        self.set_multicast_loop(true)\n-    }\n-    fn dont_loop_multicast_locally(&mut self) -> IoResult<()> {\n-        self.set_multicast_loop(false)\n-    }\n-\n-    fn multicast_time_to_live(&mut self, ttl: int) -> IoResult<()> {\n+    pub fn multicast_time_to_live(&mut self, ttl: int) -> IoResult<()> {\n         setsockopt(self.fd(), libc::IPPROTO_IP, libc::IP_MULTICAST_TTL,\n                    ttl as libc::c_int)\n     }\n-    fn time_to_live(&mut self, ttl: int) -> IoResult<()> {\n+    pub fn time_to_live(&mut self, ttl: int) -> IoResult<()> {\n         setsockopt(self.fd(), libc::IPPROTO_IP, libc::IP_TTL, ttl as libc::c_int)\n     }\n \n-    fn hear_broadcasts(&mut self) -> IoResult<()> {\n-        self.set_broadcast(true)\n-    }\n-    fn ignore_broadcasts(&mut self) -> IoResult<()> {\n-        self.set_broadcast(false)\n-    }\n-\n-    fn clone(&self) -> Box<rtio::RtioUdpSocket + Send> {\n-        box UdpSocket {\n-            inner: self.inner.clone(),\n-            read_deadline: 0,\n-            write_deadline: 0,\n-        } as Box<rtio::RtioUdpSocket + Send>\n-    }\n-\n-    fn set_timeout(&mut self, timeout: Option<u64>) {\n-        let deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    pub fn set_timeout(&mut self, timeout: Option<u64>) {\n+        let deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n         self.read_deadline = deadline;\n         self.write_deadline = deadline;\n     }\n-    fn set_read_timeout(&mut self, timeout: Option<u64>) {\n-        self.read_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    pub fn set_read_timeout(&mut self, timeout: Option<u64>) {\n+        self.read_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n     }\n-    fn set_write_timeout(&mut self, timeout: Option<u64>) {\n-        self.write_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    pub fn set_write_timeout(&mut self, timeout: Option<u64>) {\n+        self.write_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n     }\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n-// Timeout helpers\n-//\n-// The read/write functions below are the helpers for reading/writing a socket\n-// with a possible deadline specified. This is generally viewed as a timed out\n-// I/O operation.\n-//\n-// From the application's perspective, timeouts apply to the I/O object, not to\n-// the underlying file descriptor (it's one timeout per object). This means that\n-// we can't use the SO_RCVTIMEO and corresponding send timeout option.\n-//\n-// The next idea to implement timeouts would be to use nonblocking I/O. An\n-// invocation of select() would wait (with a timeout) for a socket to be ready.\n-// Once its ready, we can perform the operation. Note that the operation *must*\n-// be nonblocking, even though select() says the socket is ready. This is\n-// because some other thread could have come and stolen our data (handles can be\n-// cloned).\n-//\n-// To implement nonblocking I/O, the first option we have is to use the\n-// O_NONBLOCK flag. Remember though that this is a global setting, affecting all\n-// I/O objects, so this was initially viewed as unwise.\n-//\n-// It turns out that there's this nifty MSG_DONTWAIT flag which can be passed to\n-// send/recv, but the niftiness wears off once you realize it only works well on\n-// Linux [1] [2]. This means that it's pretty easy to get a nonblocking\n-// operation on Linux (no flag fiddling, no affecting other objects), but not on\n-// other platforms.\n-//\n-// To work around this constraint on other platforms, we end up using the\n-// original strategy of flipping the O_NONBLOCK flag. As mentioned before, this\n-// could cause other objects' blocking operations to suddenly become\n-// nonblocking. To get around this, a \"blocking operation\" which returns EAGAIN\n-// falls back to using the same code path as nonblocking operations, but with an\n-// infinite timeout (select + send/recv). This helps emulate blocking\n-// reads/writes despite the underlying descriptor being nonblocking, as well as\n-// optimizing the fast path of just hitting one syscall in the good case.\n-//\n-// As a final caveat, this implementation uses a mutex so only one thread is\n-// doing a nonblocking operation at at time. This is the operation that comes\n-// after the select() (at which point we think the socket is ready). This is\n-// done for sanity to ensure that the state of the O_NONBLOCK flag is what we\n-// expect (wouldn't want someone turning it on when it should be off!). All\n-// operations performed in the lock are *nonblocking* to avoid holding the mutex\n-// forever.\n-//\n-// So, in summary, Linux uses MSG_DONTWAIT and doesn't need mutexes, everyone\n-// else uses O_NONBLOCK and mutexes with some trickery to make sure blocking\n-// reads/writes are still blocking.\n-//\n-// Fun, fun!\n-//\n-// [1] http://twistedmatrix.com/pipermail/twisted-commits/2012-April/034692.html\n-// [2] http://stackoverflow.com/questions/19819198/does-send-msg-dontwait\n-\n-pub fn read<T>(fd: sock_t,\n-               deadline: u64,\n-               lock: || -> T,\n-               read: |bool| -> libc::c_int) -> IoResult<uint> {\n-    let mut ret = -1;\n-    if deadline == 0 {\n-        ret = retry(|| read(false));\n-    }\n-\n-    if deadline != 0 || (ret == -1 && util::wouldblock()) {\n-        let deadline = match deadline {\n-            0 => None,\n-            n => Some(n),\n-        };\n-        loop {\n-            // With a timeout, first we wait for the socket to become\n-            // readable using select(), specifying the relevant timeout for\n-            // our previously set deadline.\n-            try!(util::await([fd], deadline, util::Readable));\n-\n-            // At this point, we're still within the timeout, and we've\n-            // determined that the socket is readable (as returned by\n-            // select). We must still read the socket in *nonblocking* mode\n-            // because some other thread could come steal our data. If we\n-            // fail to read some data, we retry (hence the outer loop) and\n-            // wait for the socket to become readable again.\n-            let _guard = lock();\n-            match retry(|| read(deadline.is_some())) {\n-                -1 if util::wouldblock() => {}\n-                -1 => return Err(os::last_error()),\n-               n => { ret = n; break }\n-            }\n-        }\n-    }\n-\n-    match ret {\n-        0 => Err(util::eof()),\n-        n if n < 0 => Err(os::last_error()),\n-        n => Ok(n as uint)\n-    }\n-}\n-\n-pub fn write<T>(fd: sock_t,\n-                deadline: u64,\n-                buf: &[u8],\n-                write_everything: bool,\n-                lock: || -> T,\n-                write: |bool, *const u8, uint| -> i64) -> IoResult<uint> {\n-    let mut ret = -1;\n-    let mut written = 0;\n-    if deadline == 0 {\n-        if write_everything {\n-            ret = keep_going(buf, |inner, len| {\n-                written = buf.len() - len;\n-                write(false, inner, len)\n-            });\n-        } else {\n-            ret = retry(|| { write(false, buf.as_ptr(), buf.len()) });\n-            if ret > 0 { written = ret as uint; }\n-        }\n-    }\n-\n-    if deadline != 0 || (ret == -1 && util::wouldblock()) {\n-        let deadline = match deadline {\n-            0 => None,\n-            n => Some(n),\n-        };\n-        while written < buf.len() && (write_everything || written == 0) {\n-            // As with read(), first wait for the socket to be ready for\n-            // the I/O operation.\n-            match util::await([fd], deadline, util::Writable) {\n-                Err(ref e) if e.code == libc::EOF as uint && written > 0 => {\n-                    assert!(deadline.is_some());\n-                    return Err(util::short_write(written, \"short write\"))\n-                }\n-                Err(e) => return Err(e),\n-                Ok(()) => {}\n-            }\n-\n-            // Also as with read(), we use MSG_DONTWAIT to guard ourselves\n-            // against unforeseen circumstances.\n-            let _guard = lock();\n-            let ptr = buf[written..].as_ptr();\n-            let len = buf.len() - written;\n-            match retry(|| write(deadline.is_some(), ptr, len)) {\n-                -1 if util::wouldblock() => {}\n-                -1 => return Err(os::last_error()),\n-                n => { written += n as uint; }\n-            }\n-        }\n-        ret = 0;\n-    }\n-    if ret < 0 {\n-        Err(os::last_error())\n-    } else {\n-        Ok(written)\n-    }\n-}\n-\n-#[cfg(windows)]\n-mod os {\n-    use libc;\n-    use std::mem;\n-    use std::rt::rtio::{IoError, IoResult};\n-\n-    use io::c;\n-\n-    pub type sock_t = libc::SOCKET;\n-    pub struct Event(c::WSAEVENT);\n-\n-    impl Event {\n-        pub fn new() -> IoResult<Event> {\n-            let event = unsafe { c::WSACreateEvent() };\n-            if event == c::WSA_INVALID_EVENT {\n-                Err(last_error())\n-            } else {\n-                Ok(Event(event))\n-            }\n-        }\n-\n-        pub fn handle(&self) -> c::WSAEVENT { let Event(handle) = *self; handle }\n-    }\n-\n-    impl Drop for Event {\n-        fn drop(&mut self) {\n-            unsafe { let _ = c::WSACloseEvent(self.handle()); }\n-        }\n-    }\n-\n-    pub fn init() {\n-        unsafe {\n-            use std::rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-            static mut INITIALIZED: bool = false;\n-            static LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n-\n-            let _guard = LOCK.lock();\n-            if !INITIALIZED {\n-                let mut data: c::WSADATA = mem::zeroed();\n-                let ret = c::WSAStartup(0x202,      // version 2.2\n-                                        &mut data);\n-                assert_eq!(ret, 0);\n-                INITIALIZED = true;\n-            }\n-        }\n-    }\n-\n-    pub fn last_error() -> IoError {\n-        use std::os;\n-        let code = unsafe { c::WSAGetLastError() as uint };\n-        IoError {\n-            code: code,\n-            extra: 0,\n-            detail: Some(os::error_string(code)),\n+impl Clone for UdpSocket {\n+    fn clone(&self) -> UdpSocket {\n+        UdpSocket {\n+            inner: self.inner.clone(),\n+            read_deadline: 0,\n+            write_deadline: 0,\n         }\n     }\n-\n-    pub unsafe fn close(sock: sock_t) { let _ = libc::closesocket(sock); }\n-}\n-\n-#[cfg(unix)]\n-mod os {\n-    use libc;\n-    use std::rt::rtio::IoError;\n-    use io;\n-\n-    pub type sock_t = io::file::fd_t;\n-\n-    pub fn init() {}\n-    pub fn last_error() -> IoError { io::last_error() }\n-    pub unsafe fn close(sock: sock_t) { let _ = libc::close(sock); }\n }", "previous_filename": "src/libnative/io/net.rs"}, {"sha": "5a43fd08f904729ceea5fca626440892f8edd3d9", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 43, "deletions": 7, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41", "patch": "@@ -8,24 +8,51 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(missing_doc)]\n+\n extern crate libc;\n \n use num;\n use prelude::*;\n use io::{mod, IoResult, IoError};\n+use sys_common::mkerr_libc;\n \n+pub mod c;\n pub mod fs;\n pub mod os;\n-pub mod c;\n+pub mod tcp;\n+pub mod udp;\n+pub mod pipe;\n+\n+pub mod addrinfo {\n+    pub use sys_common::net::get_host_addresses;\n+}\n \n-pub type sock_t = io::file::fd_t;\n+// FIXME: move these to c module\n+pub type sock_t = self::fs::fd_t;\n pub type wrlen = libc::size_t;\n+pub type msglen_t = libc::size_t;\n pub unsafe fn close_sock(sock: sock_t) { let _ = libc::close(sock); }\n \n pub fn last_error() -> IoError {\n-    let errno = os::errno() as i32;\n-    let mut err = decode_error(errno);\n-    err.detail = Some(os::error_string(errno));\n+    decode_error_detailed(os::errno() as i32)\n+}\n+\n+pub fn last_net_error() -> IoError {\n+    last_error()\n+}\n+\n+extern \"system\" {\n+    fn gai_strerror(errcode: libc::c_int) -> *const libc::c_char;\n+}\n+\n+pub fn last_gai_error(s: libc::c_int) -> IoError {\n+    use c_str::CString;\n+\n+    let mut err = decode_error(s);\n+    err.detail = Some(unsafe {\n+        CString::new(gai_strerror(s), false).as_str().unwrap().to_string()\n+    });\n     err\n }\n \n@@ -64,6 +91,12 @@ pub fn decode_error(errno: i32) -> IoError {\n     IoError { kind: kind, desc: desc, detail: None }\n }\n \n+pub fn decode_error_detailed(errno: i32) -> IoError {\n+    let mut err = decode_error(errno);\n+    err.detail = Some(os::error_string(errno));\n+    err\n+}\n+\n #[inline]\n pub fn retry<I: PartialEq + num::One + Neg<I>> (f: || -> I) -> I {\n     let minus_one = -num::one::<I>();\n@@ -86,7 +119,10 @@ pub fn wouldblock() -> bool {\n     err == libc::EWOULDBLOCK as int || err == libc::EAGAIN as int\n }\n \n-pub fn set_nonblocking(fd: net::sock_t, nb: bool) -> IoResult<()> {\n+pub fn set_nonblocking(fd: sock_t, nb: bool) -> IoResult<()> {\n     let set = nb as libc::c_int;\n-    super::mkerr_libc(retry(|| unsafe { c::ioctl(fd, c::FIONBIO, &set) }))\n+    mkerr_libc(retry(|| unsafe { c::ioctl(fd, c::FIONBIO, &set) }))\n }\n+\n+// nothing needed on unix platforms\n+pub fn init_net() {}"}, {"sha": "4e495f043bc63c8a04331b9e42f869946002c6b6", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41", "patch": "@@ -11,6 +11,8 @@\n use libc;\n use libc::{c_int, c_char};\n use prelude::*;\n+use io::IoResult;\n+use sys::fs::FileDesc;\n \n use os::TMPBUF_SZ;\n \n@@ -99,3 +101,12 @@ pub fn error_string(errno: i32) -> String {\n         ::string::raw::from_buf(p as *const u8)\n     }\n }\n+\n+pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> {\n+    let mut fds = [0, ..2];\n+    if libc::pipe(fds.as_mut_ptr()) == 0 {\n+        Ok((FileDesc::new(fds[0], true), FileDesc::new(fds[1], true)))\n+    } else {\n+        Err(super::last_error())\n+    }\n+}"}, {"sha": "67384848a9449af233eb00fee617fbbe2859dbcb", "filename": "src/libstd/sys/unix/pipe.rs", "status": "renamed", "additions": 64, "deletions": 82, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41", "patch": "@@ -10,19 +10,17 @@\n \n use alloc::arc::Arc;\n use libc;\n-use std::c_str::CString;\n-use std::mem;\n-use std::rt::mutex;\n-use std::rt::rtio;\n-use std::rt::rtio::{IoResult, IoError};\n-use std::sync::atomic;\n-\n-use super::retry;\n-use super::net;\n-use super::util;\n-use super::c;\n-use super::process;\n-use super::file::{fd_t, FileDesc};\n+use c_str::CString;\n+use mem;\n+use rt::mutex;\n+use sync::atomic;\n+use io::{mod, IoResult, IoError};\n+use prelude::*;\n+\n+use sys::{mod, timer, retry, c, set_nonblocking, wouldblock};\n+use sys::fs::{fd_t, FileDesc};\n+use sys_common::net::*;\n+use sys_common::{eof, mkerr_libc};\n \n fn unix_socket(ty: libc::c_int) -> IoResult<fd_t> {\n     match unsafe { libc::socket(libc::AF_UNIX, ty, 0) } {\n@@ -41,12 +39,10 @@ fn addr_to_sockaddr_un(addr: &CString,\n \n     let len = addr.len();\n     if len > s.sun_path.len() - 1 {\n-        #[cfg(unix)] use libc::EINVAL as ERROR;\n-        #[cfg(windows)] use libc::WSAEINVAL as ERROR;\n         return Err(IoError {\n-            code: ERROR as uint,\n-            extra: 0,\n-            detail: Some(\"path must be smaller than SUN_LEN\".to_string()),\n+            kind: io::InvalidInput,\n+            desc: \"invalid argument: path must be smaller than SUN_LEN\",\n+            detail: None,\n         })\n     }\n     s.sun_family = libc::AF_UNIX as libc::sa_family_t;\n@@ -92,7 +88,7 @@ fn connect(addr: &CString, ty: libc::c_int,\n             }\n         }\n         Some(timeout_ms) => {\n-            try!(util::connect_timeout(inner.fd, addrp, len, timeout_ms));\n+            try!(connect_timeout(inner.fd, addrp, len, timeout_ms));\n             Ok(inner)\n         }\n     }\n@@ -143,18 +139,16 @@ impl UnixStream {\n     fn lock_nonblocking(&self) {}\n \n     #[cfg(not(target_os = \"linux\"))]\n-    fn lock_nonblocking<'a>(&'a self) -> net::Guard<'a> {\n-        let ret = net::Guard {\n+    fn lock_nonblocking<'a>(&'a self) -> Guard<'a> {\n+        let ret = Guard {\n             fd: self.fd(),\n             guard: unsafe { self.inner.lock.lock() },\n         };\n-        assert!(util::set_nonblocking(self.fd(), true).is_ok());\n+        assert!(set_nonblocking(self.fd(), true).is_ok());\n         ret\n     }\n-}\n \n-impl rtio::RtioPipe for UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let fd = self.fd();\n         let dolock = || self.lock_nonblocking();\n         let doread = |nb| unsafe {\n@@ -164,10 +158,10 @@ impl rtio::RtioPipe for UnixStream {\n                        buf.len() as libc::size_t,\n                        flags) as libc::c_int\n         };\n-        net::read(fd, self.read_deadline, dolock, doread)\n+        read(fd, self.read_deadline, dolock, doread)\n     }\n \n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    pub fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let fd = self.fd();\n         let dolock = || self.lock_nonblocking();\n         let dowrite = |nb: bool, buf: *const u8, len: uint| unsafe {\n@@ -177,32 +171,38 @@ impl rtio::RtioPipe for UnixStream {\n                        len as libc::size_t,\n                        flags) as i64\n         };\n-        match net::write(fd, self.write_deadline, buf, true, dolock, dowrite) {\n+        match write(fd, self.write_deadline, buf, true, dolock, dowrite) {\n             Ok(_) => Ok(()),\n             Err(e) => Err(e)\n         }\n     }\n \n-    fn clone(&self) -> Box<rtio::RtioPipe + Send> {\n-        box UnixStream::new(self.inner.clone()) as Box<rtio::RtioPipe + Send>\n+    pub fn close_write(&mut self) -> IoResult<()> {\n+        mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_WR) })\n     }\n \n-    fn close_write(&mut self) -> IoResult<()> {\n-        super::mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_WR) })\n-    }\n-    fn close_read(&mut self) -> IoResult<()> {\n-        super::mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_RD) })\n+    pub fn close_read(&mut self) -> IoResult<()> {\n+        mkerr_libc(unsafe { libc::shutdown(self.fd(), libc::SHUT_RD) })\n     }\n-    fn set_timeout(&mut self, timeout: Option<u64>) {\n-        let deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+\n+    pub fn set_timeout(&mut self, timeout: Option<u64>) {\n+        let deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n         self.read_deadline = deadline;\n         self.write_deadline = deadline;\n     }\n-    fn set_read_timeout(&mut self, timeout: Option<u64>) {\n-        self.read_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+\n+    pub fn set_read_timeout(&mut self, timeout: Option<u64>) {\n+        self.read_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n+    }\n+\n+    pub fn set_write_timeout(&mut self, timeout: Option<u64>) {\n+        self.write_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n     }\n-    fn set_write_timeout(&mut self, timeout: Option<u64>) {\n-        self.write_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+}\n+\n+impl Clone for UnixStream {\n+    fn clone(&self) -> UnixStream {\n+        UnixStream::new(self.inner.clone())\n     }\n }\n \n@@ -224,16 +224,15 @@ impl UnixListener {\n \n     fn fd(&self) -> fd_t { self.inner.fd }\n \n-    pub fn native_listen(self, backlog: int) -> IoResult<UnixAcceptor> {\n-        match unsafe { libc::listen(self.fd(), backlog as libc::c_int) } {\n+    pub fn listen(self) -> IoResult<UnixAcceptor> {\n+        match unsafe { libc::listen(self.fd(), 128) } {\n             -1 => Err(super::last_error()),\n \n-            #[cfg(unix)]\n             _ => {\n-                let (reader, writer) = try!(process::pipe());\n-                try!(util::set_nonblocking(reader.fd(), true));\n-                try!(util::set_nonblocking(writer.fd(), true));\n-                try!(util::set_nonblocking(self.fd(), true));\n+                let (reader, writer) = try!(unsafe { sys::os::pipe() });\n+                try!(set_nonblocking(reader.fd(), true));\n+                try!(set_nonblocking(writer.fd(), true));\n+                try!(set_nonblocking(self.fd(), true));\n                 Ok(UnixAcceptor {\n                     inner: Arc::new(AcceptorInner {\n                         listener: self,\n@@ -248,21 +247,11 @@ impl UnixListener {\n     }\n }\n \n-impl rtio::RtioUnixListener for UnixListener {\n-    fn listen(self: Box<UnixListener>)\n-              -> IoResult<Box<rtio::RtioUnixAcceptor + Send>> {\n-        self.native_listen(128).map(|a| {\n-            box a as Box<rtio::RtioUnixAcceptor + Send>\n-        })\n-    }\n-}\n-\n pub struct UnixAcceptor {\n     inner: Arc<AcceptorInner>,\n     deadline: u64,\n }\n \n-#[cfg(unix)]\n struct AcceptorInner {\n     listener: UnixListener,\n     reader: FileDesc,\n@@ -273,7 +262,7 @@ struct AcceptorInner {\n impl UnixAcceptor {\n     fn fd(&self) -> fd_t { self.inner.listener.fd() }\n \n-    pub fn native_accept(&mut self) -> IoResult<UnixStream> {\n+    pub fn accept(&mut self) -> IoResult<UnixStream> {\n         let deadline = if self.deadline == 0 {None} else {Some(self.deadline)};\n \n         while !self.inner.closed.load(atomic::SeqCst) {\n@@ -287,46 +276,39 @@ impl UnixAcceptor {\n                                  storagep as *mut libc::sockaddr,\n                                  &mut size as *mut libc::socklen_t) as libc::c_int\n                 }) {\n-                    -1 if util::wouldblock() => {}\n+                    -1 if wouldblock() => {}\n                     -1 => return Err(super::last_error()),\n                     fd => return Ok(UnixStream::new(Arc::new(Inner::new(fd)))),\n                 }\n             }\n-            try!(util::await([self.fd(), self.inner.reader.fd()],\n-                             deadline, util::Readable));\n+            try!(await([self.fd(), self.inner.reader.fd()],\n+                             deadline, Readable));\n         }\n \n-        Err(util::eof())\n+        Err(eof())\n     }\n-}\n \n-impl rtio::RtioUnixAcceptor for UnixAcceptor {\n-    fn accept(&mut self) -> IoResult<Box<rtio::RtioPipe + Send>> {\n-        self.native_accept().map(|s| box s as Box<rtio::RtioPipe + Send>)\n-    }\n-    fn set_timeout(&mut self, timeout: Option<u64>) {\n-        self.deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    pub fn set_timeout(&mut self, timeout: Option<u64>) {\n+        self.deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n     }\n \n-    fn clone(&self) -> Box<rtio::RtioUnixAcceptor + Send> {\n-        box UnixAcceptor {\n-            inner: self.inner.clone(),\n-            deadline: 0,\n-        } as Box<rtio::RtioUnixAcceptor + Send>\n-    }\n-\n-    #[cfg(unix)]\n-    fn close_accept(&mut self) -> IoResult<()> {\n+    pub fn close_accept(&mut self) -> IoResult<()> {\n         self.inner.closed.store(true, atomic::SeqCst);\n-        let mut fd = FileDesc::new(self.inner.writer.fd(), false);\n-        match fd.inner_write([0]) {\n+        let fd = FileDesc::new(self.inner.writer.fd(), false);\n+        match fd.write([0]) {\n             Ok(..) => Ok(()),\n-            Err(..) if util::wouldblock() => Ok(()),\n+            Err(..) if wouldblock() => Ok(()),\n             Err(e) => Err(e),\n         }\n     }\n }\n \n+impl Clone for UnixAcceptor {\n+    fn clone(&self) -> UnixAcceptor {\n+        UnixAcceptor { inner: self.inner.clone(), deadline: 0 }\n+    }\n+}\n+\n impl Drop for UnixListener {\n     fn drop(&mut self) {\n         // Unlink the path to the socket to ensure that it doesn't linger. We're", "previous_filename": "src/libnative/io/pipe_unix.rs"}, {"sha": "962475e417719e05c7b68c1c20c9fe4c6f892676", "filename": "src/libstd/sys/unix/tcp.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs?ref=d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41", "patch": "@@ -0,0 +1,157 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io::net::ip;\n+use io::IoResult;\n+use libc;\n+use mem;\n+use ptr;\n+use prelude::*;\n+use super::{last_error, last_net_error, retry, sock_t};\n+use sync::{Arc, atomic};\n+use sys::fs::FileDesc;\n+use sys::{set_nonblocking, wouldblock};\n+use sys;\n+use sys_common;\n+use sys_common::net::*;\n+\n+pub use sys_common::net::TcpStream;\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// TCP listeners\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct TcpListener {\n+    pub inner: FileDesc,\n+}\n+\n+impl TcpListener {\n+    pub fn bind(addr: ip::SocketAddr) -> IoResult<TcpListener> {\n+        let fd = try!(socket(addr, libc::SOCK_STREAM));\n+        let ret = TcpListener { inner: FileDesc::new(fd, true) };\n+\n+        let mut storage = unsafe { mem::zeroed() };\n+        let len = addr_to_sockaddr(addr, &mut storage);\n+        let addrp = &storage as *const _ as *const libc::sockaddr;\n+\n+        // On platforms with Berkeley-derived sockets, this allows\n+        // to quickly rebind a socket, without needing to wait for\n+        // the OS to clean up the previous one.\n+        try!(setsockopt(fd, libc::SOL_SOCKET, libc::SO_REUSEADDR, 1 as libc::c_int));\n+\n+\n+        match unsafe { libc::bind(fd, addrp, len) } {\n+            -1 => Err(last_error()),\n+            _ => Ok(ret),\n+        }\n+    }\n+\n+    pub fn fd(&self) -> sock_t { self.inner.fd() }\n+\n+    pub fn listen(self, backlog: int) -> IoResult<TcpAcceptor> {\n+        match unsafe { libc::listen(self.fd(), backlog as libc::c_int) } {\n+            -1 => Err(last_net_error()),\n+            _ => {\n+                let (reader, writer) = try!(unsafe { sys::os::pipe() });\n+                try!(set_nonblocking(reader.fd(), true));\n+                try!(set_nonblocking(writer.fd(), true));\n+                try!(set_nonblocking(self.fd(), true));\n+                Ok(TcpAcceptor {\n+                    inner: Arc::new(AcceptorInner {\n+                        listener: self,\n+                        reader: reader,\n+                        writer: writer,\n+                        closed: atomic::AtomicBool::new(false),\n+                    }),\n+                    deadline: 0,\n+                })\n+            }\n+        }\n+    }\n+\n+    pub fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n+        sockname(self.fd(), libc::getsockname)\n+    }\n+}\n+\n+pub struct TcpAcceptor {\n+    inner: Arc<AcceptorInner>,\n+    deadline: u64,\n+}\n+\n+struct AcceptorInner {\n+    listener: TcpListener,\n+    reader: FileDesc,\n+    writer: FileDesc,\n+    closed: atomic::AtomicBool,\n+}\n+\n+impl TcpAcceptor {\n+    pub fn fd(&self) -> sock_t { self.inner.listener.fd() }\n+\n+    pub fn accept(&mut self) -> IoResult<TcpStream> {\n+        // In implementing accept, the two main concerns are dealing with\n+        // close_accept() and timeouts. The unix implementation is based on a\n+        // nonblocking accept plus a call to select(). Windows ends up having\n+        // an entirely separate implementation than unix, which is explained\n+        // below.\n+        //\n+        // To implement timeouts, all blocking is done via select() instead of\n+        // accept() by putting the socket in non-blocking mode. Because\n+        // select() takes a timeout argument, we just pass through the timeout\n+        // to select().\n+        //\n+        // To implement close_accept(), we have a self-pipe to ourselves which\n+        // is passed to select() along with the socket being accepted on. The\n+        // self-pipe is never written to unless close_accept() is called.\n+        let deadline = if self.deadline == 0 {None} else {Some(self.deadline)};\n+\n+        while !self.inner.closed.load(atomic::SeqCst) {\n+            match retry(|| unsafe {\n+                libc::accept(self.fd(), ptr::null_mut(), ptr::null_mut())\n+            }) {\n+                -1 if wouldblock() => {}\n+                -1 => return Err(last_net_error()),\n+                fd => return Ok(TcpStream::new(fd as sock_t)),\n+            }\n+            try!(await([self.fd(), self.inner.reader.fd()],\n+                             deadline, Readable));\n+        }\n+\n+        Err(sys_common::eof())\n+    }\n+\n+    pub fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n+        sockname(self.fd(), libc::getsockname)\n+    }\n+\n+    pub fn set_timeout(&mut self, timeout: Option<u64>) {\n+        self.deadline = timeout.map(|a| sys::timer::now() + a).unwrap_or(0);\n+    }\n+\n+    pub fn close_accept(&mut self) -> IoResult<()> {\n+        self.inner.closed.store(true, atomic::SeqCst);\n+        let fd = FileDesc::new(self.inner.writer.fd(), false);\n+        match fd.write([0]) {\n+            Ok(..) => Ok(()),\n+            Err(..) if wouldblock() => Ok(()),\n+            Err(e) => Err(e),\n+        }\n+    }\n+}\n+\n+impl Clone for TcpAcceptor {\n+    fn clone(&self) -> TcpAcceptor {\n+        TcpAcceptor {\n+            inner: self.inner.clone(),\n+            deadline: 0,\n+        }\n+    }\n+}"}, {"sha": "50f8fb828ad323572f17ef3972cbb0f9d5861996", "filename": "src/libstd/sys/unix/udp.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fsys%2Funix%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fsys%2Funix%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fudp.rs?ref=d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use sys_common::net::UdpSocket;"}, {"sha": "85fbc6b936c30389b86817e03208f371b25fdf38", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41", "patch": "@@ -33,12 +33,21 @@ macro_rules! helper_init( (static $name:ident: Helper<$m:ty>) => (\n     };\n ) )\n \n+pub mod c;\n pub mod fs;\n pub mod os;\n-pub mod c;\n+pub mod tcp;\n+pub mod udp;\n+pub mod pipe;\n+\n+pub mod addrinfo {\n+    pub use sys_common::net::get_host_addresses;\n+}\n \n+// FIXME: move these to c module\n pub type sock_t = libc::SOCKET;\n pub type wrlen = libc::c_int;\n+pub type msglen_t = libc::c_int;\n pub unsafe fn close_sock(sock: sock_t) { let _ = libc::closesocket(sock); }\n \n // windows has zero values as errors\n@@ -140,7 +149,6 @@ pub fn set_nonblocking(fd: sock_t, nb: bool) -> IoResult<()> {\n     }\n }\n \n-// FIXME: call this\n pub fn init_net() {\n     unsafe {\n         static START: Once = ONCE_INIT;"}, {"sha": "f2f7994a0057ca7a06f583d6ef3d2eb7eaf5fb66", "filename": "src/libstd/sys/windows/pipe.rs", "status": "renamed", "additions": 73, "deletions": 91, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41", "patch": "@@ -86,18 +86,17 @@\n \n use alloc::arc::Arc;\n use libc;\n-use std::c_str::CString;\n-use std::mem;\n-use std::os;\n-use std::ptr;\n-use std::rt::rtio;\n-use std::rt::rtio::{IoResult, IoError};\n-use std::sync::atomic;\n-use std::rt::mutex;\n-\n-use super::c;\n-use super::util;\n-use super::file::to_utf16;\n+use c_str::CString;\n+use mem;\n+use ptr;\n+use sync::atomic;\n+use rt::mutex;\n+use io::{mod, IoError, IoResult};\n+use prelude::*;\n+\n+use sys_common::{mod, eof};\n+\n+use super::{c, os, timer, to_utf16, decode_error_detailed};\n \n struct Event(libc::HANDLE);\n \n@@ -177,7 +176,7 @@ pub fn await(handle: libc::HANDLE, deadline: u64,\n     let ms = if deadline == 0 {\n         libc::INFINITE as u64\n     } else {\n-        let now = ::io::timer::now();\n+        let now = timer::now();\n         if deadline < now {0} else {deadline - now}\n     };\n     let ret = unsafe {\n@@ -190,16 +189,16 @@ pub fn await(handle: libc::HANDLE, deadline: u64,\n         WAIT_FAILED => Err(super::last_error()),\n         WAIT_TIMEOUT => unsafe {\n             let _ = c::CancelIo(handle);\n-            Err(util::timeout(\"operation timed out\"))\n+            Err(sys_common::timeout(\"operation timed out\"))\n         },\n         n => Ok((n - WAIT_OBJECT_0) as uint)\n     }\n }\n \n fn epipe() -> IoError {\n     IoError {\n-        code: libc::ERROR_BROKEN_PIPE as uint,\n-        extra: 0,\n+        kind: io::EndOfFile,\n+        desc: \"the pipe has ended\",\n         detail: None,\n     }\n }\n@@ -268,8 +267,8 @@ impl UnixStream {\n     }\n \n     pub fn connect(addr: &CString, timeout: Option<u64>) -> IoResult<UnixStream> {\n-        let addr = try!(to_utf16(addr));\n-        let start = ::io::timer::now();\n+        let addr = try!(to_utf16(addr.as_str()));\n+        let start = timer::now();\n         loop {\n             match UnixStream::try_connect(addr.as_ptr()) {\n                 Some(handle) => {\n@@ -308,13 +307,13 @@ impl UnixStream {\n \n             match timeout {\n                 Some(timeout) => {\n-                    let now = ::io::timer::now();\n+                    let now = timer::now();\n                     let timed_out = (now - start) >= timeout || unsafe {\n                         let ms = (timeout - (now - start)) as libc::DWORD;\n                         libc::WaitNamedPipeW(addr.as_ptr(), ms) == 0\n                     };\n                     if timed_out {\n-                        return Err(util::timeout(\"connect timed out\"))\n+                        return Err(sys_common::timeout(\"connect timed out\"))\n                     }\n                 }\n \n@@ -349,10 +348,8 @@ impl UnixStream {\n             _ => Ok(())\n         }\n     }\n-}\n \n-impl rtio::RtioPipe for UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         if self.read.is_none() {\n             self.read = Some(try!(Event::new(true, false)));\n         }\n@@ -368,7 +365,7 @@ impl rtio::RtioPipe for UnixStream {\n         // See comments in close_read() about why this lock is necessary.\n         let guard = unsafe { self.inner.lock.lock() };\n         if self.read_closed() {\n-            return Err(util::eof())\n+            return Err(eof())\n         }\n \n         // Issue a nonblocking requests, succeeding quickly if it happened to\n@@ -416,15 +413,15 @@ impl rtio::RtioPipe for UnixStream {\n             // If the reading half is now closed, then we're done. If we woke up\n             // because the writing half was closed, keep trying.\n             if wait_succeeded.is_err() {\n-                return Err(util::timeout(\"read timed out\"))\n+                return Err(sys_common::timeout(\"read timed out\"))\n             }\n             if self.read_closed() {\n-                return Err(util::eof())\n+                return Err(eof())\n             }\n         }\n     }\n \n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    pub fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         if self.write.is_none() {\n             self.write = Some(try!(Event::new(true, false)));\n         }\n@@ -458,11 +455,7 @@ impl rtio::RtioPipe for UnixStream {\n \n             if ret == 0 {\n                 if err != libc::ERROR_IO_PENDING as uint {\n-                    return Err(IoError {\n-                        code: err as uint,\n-                        extra: 0,\n-                        detail: Some(os::error_string(err as uint)),\n-                    })\n+                    return Err(decode_error_detailed(err as i32))\n                 }\n                 // Process a timeout if one is pending\n                 let wait_succeeded = await(self.handle(), self.write_deadline,\n@@ -484,12 +477,12 @@ impl rtio::RtioPipe for UnixStream {\n                         let amt = offset + bytes_written as uint;\n                         return if amt > 0 {\n                             Err(IoError {\n-                                code: libc::ERROR_OPERATION_ABORTED as uint,\n-                                extra: amt,\n-                                detail: Some(\"short write during write\".to_string()),\n+                                kind: io::ShortWrite(amt),\n+                                desc: \"short write during write\",\n+                                detail: None,\n                             })\n                         } else {\n-                            Err(util::timeout(\"write timed out\"))\n+                            Err(sys_common::timeout(\"write timed out\"))\n                         }\n                     }\n                     if self.write_closed() {\n@@ -503,17 +496,7 @@ impl rtio::RtioPipe for UnixStream {\n         Ok(())\n     }\n \n-    fn clone(&self) -> Box<rtio::RtioPipe + Send> {\n-        box UnixStream {\n-            inner: self.inner.clone(),\n-            read: None,\n-            write: None,\n-            read_deadline: 0,\n-            write_deadline: 0,\n-        } as Box<rtio::RtioPipe + Send>\n-    }\n-\n-    fn close_read(&mut self) -> IoResult<()> {\n+    pub fn close_read(&mut self) -> IoResult<()> {\n         // On windows, there's no actual shutdown() method for pipes, so we're\n         // forced to emulate the behavior manually at the application level. To\n         // do this, we need to both cancel any pending requests, as well as\n@@ -536,23 +519,35 @@ impl rtio::RtioPipe for UnixStream {\n         self.cancel_io()\n     }\n \n-    fn close_write(&mut self) -> IoResult<()> {\n+    pub fn close_write(&mut self) -> IoResult<()> {\n         // see comments in close_read() for why this lock is necessary\n         let _guard = unsafe { self.inner.lock.lock() };\n         self.inner.write_closed.store(true, atomic::SeqCst);\n         self.cancel_io()\n     }\n \n-    fn set_timeout(&mut self, timeout: Option<u64>) {\n-        let deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    pub fn set_timeout(&mut self, timeout: Option<u64>) {\n+        let deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n         self.read_deadline = deadline;\n         self.write_deadline = deadline;\n     }\n-    fn set_read_timeout(&mut self, timeout: Option<u64>) {\n-        self.read_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    pub fn set_read_timeout(&mut self, timeout: Option<u64>) {\n+        self.read_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n     }\n-    fn set_write_timeout(&mut self, timeout: Option<u64>) {\n-        self.write_deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n+    pub fn set_write_timeout(&mut self, timeout: Option<u64>) {\n+        self.write_deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n+    }\n+}\n+\n+impl Clone for UnixStream {\n+    fn clone(&self) -> UnixStream {\n+        UnixStream {\n+            inner: self.inner.clone(),\n+            read: None,\n+            write: None,\n+            read_deadline: 0,\n+            write_deadline: 0,\n+        }\n     }\n }\n \n@@ -570,7 +565,7 @@ impl UnixListener {\n         // Although we technically don't need the pipe until much later, we\n         // create the initial handle up front to test the validity of the name\n         // and such.\n-        let addr_v = try!(to_utf16(addr));\n+        let addr_v = try!(to_utf16(addr.as_str()));\n         let ret = unsafe { pipe(addr_v.as_ptr(), true) };\n         if ret == libc::INVALID_HANDLE_VALUE {\n             Err(super::last_error())\n@@ -579,7 +574,7 @@ impl UnixListener {\n         }\n     }\n \n-    pub fn native_listen(self) -> IoResult<UnixAcceptor> {\n+    pub fn listen(self) -> IoResult<UnixAcceptor> {\n         Ok(UnixAcceptor {\n             listener: self,\n             event: try!(Event::new(true, false)),\n@@ -598,15 +593,6 @@ impl Drop for UnixListener {\n     }\n }\n \n-impl rtio::RtioUnixListener for UnixListener {\n-    fn listen(self: Box<UnixListener>)\n-              -> IoResult<Box<rtio::RtioUnixAcceptor + Send>> {\n-        self.native_listen().map(|a| {\n-            box a as Box<rtio::RtioUnixAcceptor + Send>\n-        })\n-    }\n-}\n-\n pub struct UnixAcceptor {\n     inner: Arc<AcceptorState>,\n     listener: UnixListener,\n@@ -620,7 +606,7 @@ struct AcceptorState {\n }\n \n impl UnixAcceptor {\n-    pub fn native_accept(&mut self) -> IoResult<UnixStream> {\n+    pub fn accept(&mut self) -> IoResult<UnixStream> {\n         // This function has some funky implementation details when working with\n         // unix pipes. On windows, each server named pipe handle can be\n         // connected to a one or zero clients. To the best of my knowledge, a\n@@ -657,9 +643,9 @@ impl UnixAcceptor {\n \n         // If we've had an artificial call to close_accept, be sure to never\n         // proceed in accepting new clients in the future\n-        if self.inner.closed.load(atomic::SeqCst) { return Err(util::eof()) }\n+        if self.inner.closed.load(atomic::SeqCst) { return Err(eof()) }\n \n-        let name = try!(to_utf16(&self.listener.name));\n+        let name = try!(to_utf16(self.listener.name.as_str()));\n \n         // Once we've got a \"server handle\", we need to wait for a client to\n         // connect. The ConnectNamedPipe function will block this thread until\n@@ -691,7 +677,7 @@ impl UnixAcceptor {\n                     if wait_succeeded.is_ok() {\n                         err = unsafe { libc::GetLastError() };\n                     } else {\n-                        return Err(util::timeout(\"accept timed out\"))\n+                        return Err(sys_common::timeout(\"accept timed out\"))\n                     }\n                 } else {\n                     // we succeeded, bypass the check below\n@@ -727,19 +713,28 @@ impl UnixAcceptor {\n             write_deadline: 0,\n         })\n     }\n-}\n \n-impl rtio::RtioUnixAcceptor for UnixAcceptor {\n-    fn accept(&mut self) -> IoResult<Box<rtio::RtioPipe + Send>> {\n-        self.native_accept().map(|s| box s as Box<rtio::RtioPipe + Send>)\n+    pub fn set_timeout(&mut self, timeout: Option<u64>) {\n+        self.deadline = timeout.map(|i| i + timer::now()).unwrap_or(0);\n     }\n-    fn set_timeout(&mut self, timeout: Option<u64>) {\n-        self.deadline = timeout.map(|i| i + ::io::timer::now()).unwrap_or(0);\n+\n+    pub fn close_accept(&mut self) -> IoResult<()> {\n+        self.inner.closed.store(true, atomic::SeqCst);\n+        let ret = unsafe {\n+            c::SetEvent(self.inner.abort.handle())\n+        };\n+        if ret == 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(())\n+        }\n     }\n+}\n \n-    fn clone(&self) -> Box<rtio::RtioUnixAcceptor + Send> {\n-        let name = to_utf16(&self.listener.name).ok().unwrap();\n-        box UnixAcceptor {\n+impl Clone for UnixAcceptor {\n+    fn clone(&self) -> UnixAcceptor {\n+        let name = to_utf16(self.listener.name.as_str()).ok().unwrap();\n+        UnixAcceptor {\n             inner: self.inner.clone(),\n             event: Event::new(true, false).ok().unwrap(),\n             deadline: 0,\n@@ -751,19 +746,6 @@ impl rtio::RtioUnixAcceptor for UnixAcceptor {\n                     p\n                 },\n             },\n-        } as Box<rtio::RtioUnixAcceptor + Send>\n-    }\n-\n-    fn close_accept(&mut self) -> IoResult<()> {\n-        self.inner.closed.store(true, atomic::SeqCst);\n-        let ret = unsafe {\n-            c::SetEvent(self.inner.abort.handle())\n-        };\n-        if ret == 0 {\n-            Err(super::last_error())\n-        } else {\n-            Ok(())\n         }\n     }\n }\n-", "previous_filename": "src/libnative/io/pipe_windows.rs"}, {"sha": "3baf2be08d238c12c0d4bea96580fbc3252512aa", "filename": "src/libstd/sys/windows/tcp.rs", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs?ref=d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41", "patch": "@@ -0,0 +1,219 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io::net::ip;\n+use io::IoResult;\n+use libc;\n+use mem;\n+use ptr;\n+use prelude::*;\n+use super::{last_error, last_net_error, retry, sock_t};\n+use sync::{Arc, atomic};\n+use sys::fs::FileDesc;\n+use sys::{mod, c, set_nonblocking, wouldblock, timer};\n+use sys_common::{mod, timeout, eof};\n+use sys_common::net::*;\n+\n+pub use sys_common::net::TcpStream;\n+\n+pub struct Event(c::WSAEVENT);\n+\n+impl Event {\n+    pub fn new() -> IoResult<Event> {\n+        let event = unsafe { c::WSACreateEvent() };\n+        if event == c::WSA_INVALID_EVENT {\n+            Err(super::last_error())\n+        } else {\n+            Ok(Event(event))\n+        }\n+    }\n+\n+    pub fn handle(&self) -> c::WSAEVENT { let Event(handle) = *self; handle }\n+}\n+\n+impl Drop for Event {\n+    fn drop(&mut self) {\n+        unsafe { let _ = c::WSACloseEvent(self.handle()); }\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// TCP listeners\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct TcpListener {\n+    inner: FileDesc,\n+}\n+\n+impl TcpListener {\n+    pub fn bind(addr: ip::SocketAddr) -> IoResult<TcpListener> {\n+        sys::init_net();\n+\n+        let fd = try!(socket(addr, libc::SOCK_STREAM));\n+        let ret = TcpListener { inner: FileDesc::new(fd as libc::c_int, true) };\n+\n+        let mut storage = unsafe { mem::zeroed() };\n+        let len = addr_to_sockaddr(addr, &mut storage);\n+        let addrp = &storage as *const _ as *const libc::sockaddr;\n+\n+        match unsafe { libc::bind(fd, addrp, len) } {\n+            -1 => Err(last_net_error()),\n+            _ => Ok(ret),\n+        }\n+    }\n+\n+    pub fn fd(&self) -> sock_t { self.inner.fd as sock_t }\n+\n+    pub fn listen(self, backlog: int) -> IoResult<TcpAcceptor> {\n+        match unsafe { libc::listen(self.fd(), backlog as libc::c_int) } {\n+            -1 => Err(last_net_error()),\n+\n+            _ => {\n+                let accept = try!(Event::new());\n+                let ret = unsafe {\n+                    c::WSAEventSelect(self.fd(), accept.handle(), c::FD_ACCEPT)\n+                };\n+                if ret != 0 {\n+                    return Err(last_net_error())\n+                }\n+                Ok(TcpAcceptor {\n+                    inner: Arc::new(AcceptorInner {\n+                        listener: self,\n+                        abort: try!(Event::new()),\n+                        accept: accept,\n+                        closed: atomic::AtomicBool::new(false),\n+                    }),\n+                    deadline: 0,\n+                })\n+            }\n+        }\n+    }\n+\n+    pub fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n+        sockname(self.fd(), libc::getsockname)\n+    }\n+}\n+\n+pub struct TcpAcceptor {\n+    inner: Arc<AcceptorInner>,\n+    deadline: u64,\n+}\n+\n+struct AcceptorInner {\n+    listener: TcpListener,\n+    abort: Event,\n+    accept: Event,\n+    closed: atomic::AtomicBool,\n+}\n+\n+impl TcpAcceptor {\n+    pub fn fd(&self) -> sock_t { self.inner.listener.fd() }\n+\n+    pub fn accept(&mut self) -> IoResult<TcpStream> {\n+        // Unlink unix, windows cannot invoke `select` on arbitrary file\n+        // descriptors like pipes, only sockets. Consequently, windows cannot\n+        // use the same implementation as unix for accept() when close_accept()\n+        // is considered.\n+        //\n+        // In order to implement close_accept() and timeouts, windows uses\n+        // event handles. An acceptor-specific abort event is created which\n+        // will only get set in close_accept(), and it will never be un-set.\n+        // Additionally, another acceptor-specific event is associated with the\n+        // FD_ACCEPT network event.\n+        //\n+        // These two events are then passed to WaitForMultipleEvents to see\n+        // which one triggers first, and the timeout passed to this function is\n+        // the local timeout for the acceptor.\n+        //\n+        // If the wait times out, then the accept timed out. If the wait\n+        // succeeds with the abort event, then we were closed, and if the wait\n+        // succeeds otherwise, then we do a nonblocking poll via `accept` to\n+        // see if we can accept a connection. The connection is candidate to be\n+        // stolen, so we do all of this in a loop as well.\n+        let events = [self.inner.abort.handle(), self.inner.accept.handle()];\n+\n+        while !self.inner.closed.load(atomic::SeqCst) {\n+            let ms = if self.deadline == 0 {\n+                c::WSA_INFINITE as u64\n+            } else {\n+                let now = timer::now();\n+                if self.deadline < now {0} else {self.deadline - now}\n+            };\n+            let ret = unsafe {\n+                c::WSAWaitForMultipleEvents(2, events.as_ptr(), libc::FALSE,\n+                                            ms as libc::DWORD, libc::FALSE)\n+            };\n+            match ret {\n+                c::WSA_WAIT_TIMEOUT => {\n+                    return Err(timeout(\"accept timed out\"))\n+                }\n+                c::WSA_WAIT_FAILED => return Err(last_net_error()),\n+                c::WSA_WAIT_EVENT_0 => break,\n+                n => assert_eq!(n, c::WSA_WAIT_EVENT_0 + 1),\n+            }\n+\n+            let mut wsaevents: c::WSANETWORKEVENTS = unsafe { mem::zeroed() };\n+            let ret = unsafe {\n+                c::WSAEnumNetworkEvents(self.fd(), events[1], &mut wsaevents)\n+            };\n+            if ret != 0 { return Err(last_net_error()) }\n+\n+            if wsaevents.lNetworkEvents & c::FD_ACCEPT == 0 { continue }\n+            match unsafe {\n+                libc::accept(self.fd(), ptr::null_mut(), ptr::null_mut())\n+            } {\n+                -1 if wouldblock() => {}\n+                -1 => return Err(last_net_error()),\n+\n+                // Accepted sockets inherit the same properties as the caller,\n+                // so we need to deregister our event and switch the socket back\n+                // to blocking mode\n+                fd => {\n+                    let stream = TcpStream::new(fd);\n+                    let ret = unsafe {\n+                        c::WSAEventSelect(fd, events[1], 0)\n+                    };\n+                    if ret != 0 { return Err(last_net_error()) }\n+                    try!(set_nonblocking(fd, false));\n+                    return Ok(stream)\n+                }\n+            }\n+        }\n+\n+        Err(eof())\n+    }\n+\n+    pub fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n+        sockname(self.fd(), libc::getsockname)\n+    }\n+\n+    pub fn set_timeout(&mut self, timeout: Option<u64>) {\n+        self.deadline = timeout.map(|a| timer::now() + a).unwrap_or(0);\n+    }\n+\n+    pub fn close_accept(&mut self) -> IoResult<()> {\n+        self.inner.closed.store(true, atomic::SeqCst);\n+        let ret = unsafe { c::WSASetEvent(self.inner.abort.handle()) };\n+        if ret == libc::TRUE {\n+            Ok(())\n+        } else {\n+            Err(last_net_error())\n+        }\n+    }\n+}\n+\n+impl Clone for TcpAcceptor {\n+    fn clone(&self) -> TcpAcceptor {\n+        TcpAcceptor {\n+            inner: self.inner.clone(),\n+            deadline: 0,\n+        }\n+    }\n+}"}, {"sha": "50f8fb828ad323572f17ef3972cbb0f9d5861996", "filename": "src/libstd/sys/windows/udp.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fsys%2Fwindows%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41/src%2Flibstd%2Fsys%2Fwindows%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fudp.rs?ref=d34b1b0ca9bf5e0d7cd30952f5de0ab09ed57b41", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use sys_common::net::UdpSocket;"}]}