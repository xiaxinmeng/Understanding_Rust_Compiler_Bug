{"sha": "f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0ZGUyZWNlMGRkOWZiYWQ3N2Y5Zjk5ZjA0MmU1MTg4ZWVjYWFmNmE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-07-18T08:29:22Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-07-18T08:29:22Z"}, "message": "internal: simplify handling of the build scripts", "tree": {"sha": "a19fa90e23514bbb3657b424ceca403e14d18d6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a19fa90e23514bbb3657b424ceca403e14d18d6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a", "html_url": "https://github.com/rust-lang/rust/commit/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8da560264e82a47811445cd0daa2617e52fddb9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8da560264e82a47811445cd0daa2617e52fddb9d", "html_url": "https://github.com/rust-lang/rust/commit/8da560264e82a47811445cd0daa2617e52fddb9d"}], "stats": {"total": 895, "additions": 404, "deletions": 491}, "files": [{"sha": "89e48435fbba6e40925c63a35acd1e5a496a175b", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a", "patch": "@@ -1181,6 +1181,7 @@ dependencies = [\n  \"proc_macro_api\",\n  \"profile\",\n  \"rustc-hash\",\n+ \"semver\",\n  \"serde\",\n  \"serde_json\",\n  \"stdx\","}, {"sha": "5c85bc19c310142731f65ede9718b5a487a4dd73", "filename": "crates/project_model/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Fproject_model%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Fproject_model%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2FCargo.toml?ref=f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a", "patch": "@@ -12,6 +12,7 @@ doctest = false\n log = \"0.4.8\"\n rustc-hash = \"1.1.0\"\n cargo_metadata = \"0.14\"\n+semver = \"1\"\n serde = { version = \"1.0.106\", features = [\"derive\"] }\n serde_json = \"1.0.48\"\n anyhow = \"1.0.26\""}, {"sha": "92ead0c43567ba3d88fa8f9930f4ba93f9585b45", "filename": "crates/project_model/src/build_data.rs", "status": "removed", "additions": 0, "deletions": 323, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/8da560264e82a47811445cd0daa2617e52fddb9d/crates%2Fproject_model%2Fsrc%2Fbuild_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da560264e82a47811445cd0daa2617e52fddb9d/crates%2Fproject_model%2Fsrc%2Fbuild_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fbuild_data.rs?ref=8da560264e82a47811445cd0daa2617e52fddb9d", "patch": "@@ -1,323 +0,0 @@\n-//! Handles build script specific information\n-\n-use std::{\n-    path::PathBuf,\n-    process::{Command, Stdio},\n-    sync::Arc,\n-};\n-\n-use anyhow::Result;\n-use base_db::CrateName;\n-use cargo_metadata::camino::Utf8Path;\n-use cargo_metadata::{BuildScript, Message};\n-use paths::{AbsPath, AbsPathBuf};\n-use rustc_hash::FxHashMap;\n-use serde::Deserialize;\n-use stdx::format_to;\n-\n-use crate::{cfg_flag::CfgFlag, CargoConfig};\n-\n-#[derive(Debug, Clone, Default, PartialEq, Eq)]\n-pub(crate) struct PackageBuildData {\n-    /// List of config flags defined by this package's build script\n-    pub(crate) cfgs: Vec<CfgFlag>,\n-    /// List of cargo-related environment variables with their value\n-    ///\n-    /// If the package has a build script which defines environment variables,\n-    /// they can also be found here.\n-    pub(crate) envs: Vec<(String, String)>,\n-    /// Directory where a build script might place its output\n-    pub(crate) out_dir: Option<AbsPathBuf>,\n-    /// Path to the proc-macro library file if this package exposes proc-macros\n-    pub(crate) proc_macro_dylib_path: Option<AbsPathBuf>,\n-}\n-\n-#[derive(Debug, Default, PartialEq, Eq, Clone)]\n-pub(crate) struct WorkspaceBuildData {\n-    per_package: FxHashMap<String, PackageBuildData>,\n-    error: Option<String>,\n-}\n-\n-#[derive(Debug, Default, PartialEq, Eq, Clone)]\n-pub struct BuildDataResult {\n-    per_workspace: FxHashMap<AbsPathBuf, WorkspaceBuildData>,\n-}\n-\n-#[derive(Clone, Debug)]\n-pub(crate) struct BuildDataConfig {\n-    cargo_toml: AbsPathBuf,\n-    cargo_features: CargoConfig,\n-    packages: Arc<Vec<cargo_metadata::Package>>,\n-}\n-\n-impl PartialEq for BuildDataConfig {\n-    fn eq(&self, other: &Self) -> bool {\n-        Arc::ptr_eq(&self.packages, &other.packages)\n-    }\n-}\n-\n-impl Eq for BuildDataConfig {}\n-\n-#[derive(Debug)]\n-pub struct BuildDataCollector {\n-    wrap_rustc: bool,\n-    configs: FxHashMap<AbsPathBuf, BuildDataConfig>,\n-}\n-\n-impl BuildDataCollector {\n-    pub fn new(wrap_rustc: bool) -> Self {\n-        Self { wrap_rustc, configs: FxHashMap::default() }\n-    }\n-\n-    pub(crate) fn add_config(&mut self, workspace_root: &AbsPath, config: BuildDataConfig) {\n-        self.configs.insert(workspace_root.to_path_buf(), config);\n-    }\n-\n-    pub fn collect(&mut self, progress: &dyn Fn(String)) -> Result<BuildDataResult> {\n-        let mut res = BuildDataResult::default();\n-        for (path, config) in self.configs.iter() {\n-            let workspace_build_data = WorkspaceBuildData::collect(\n-                &config.cargo_toml,\n-                &config.cargo_features,\n-                &config.packages,\n-                self.wrap_rustc,\n-                progress,\n-            )?;\n-            res.per_workspace.insert(path.clone(), workspace_build_data);\n-        }\n-        Ok(res)\n-    }\n-}\n-\n-impl WorkspaceBuildData {\n-    pub(crate) fn get(&self, package_id: &str) -> Option<&PackageBuildData> {\n-        self.per_package.get(package_id)\n-    }\n-}\n-\n-impl BuildDataResult {\n-    pub(crate) fn get(&self, workspace_root: &AbsPath) -> Option<&WorkspaceBuildData> {\n-        self.per_workspace.get(workspace_root)\n-    }\n-    pub fn error(&self) -> Option<String> {\n-        let mut buf = String::new();\n-        for (_workspace_root, build_data) in &self.per_workspace {\n-            if let Some(err) = &build_data.error {\n-                format_to!(buf, \"cargo check failed:\\n{}\", err);\n-            }\n-        }\n-        if buf.is_empty() {\n-            return None;\n-        }\n-\n-        Some(buf)\n-    }\n-}\n-\n-impl BuildDataConfig {\n-    pub(crate) fn new(\n-        cargo_toml: AbsPathBuf,\n-        cargo_features: CargoConfig,\n-        packages: Arc<Vec<cargo_metadata::Package>>,\n-    ) -> Self {\n-        Self { cargo_toml, cargo_features, packages }\n-    }\n-}\n-\n-impl WorkspaceBuildData {\n-    fn collect(\n-        cargo_toml: &AbsPath,\n-        cargo_features: &CargoConfig,\n-        packages: &Vec<cargo_metadata::Package>,\n-        wrap_rustc: bool,\n-        progress: &dyn Fn(String),\n-    ) -> Result<WorkspaceBuildData> {\n-        let mut cmd = Command::new(toolchain::cargo());\n-\n-        if wrap_rustc {\n-            // Setup RUSTC_WRAPPER to point to `rust-analyzer` binary itself. We use\n-            // that to compile only proc macros and build scripts during the initial\n-            // `cargo check`.\n-            let myself = std::env::current_exe()?;\n-            cmd.env(\"RUSTC_WRAPPER\", myself);\n-            cmd.env(\"RA_RUSTC_WRAPPER\", \"1\");\n-        }\n-\n-        cmd.current_dir(cargo_toml.parent().unwrap());\n-        cmd.args(&[\"check\", \"--quiet\", \"--workspace\", \"--message-format=json\", \"--manifest-path\"])\n-            .arg(cargo_toml.as_ref());\n-\n-        // --all-targets includes tests, benches and examples in addition to the\n-        // default lib and bins. This is an independent concept from the --targets\n-        // flag below.\n-        cmd.arg(\"--all-targets\");\n-\n-        if let Some(target) = &cargo_features.target {\n-            cmd.args(&[\"--target\", target]);\n-        }\n-\n-        if cargo_features.all_features {\n-            cmd.arg(\"--all-features\");\n-        } else {\n-            if cargo_features.no_default_features {\n-                // FIXME: `NoDefaultFeatures` is mutual exclusive with `SomeFeatures`\n-                // https://github.com/oli-obk/cargo_metadata/issues/79\n-                cmd.arg(\"--no-default-features\");\n-            }\n-            if !cargo_features.features.is_empty() {\n-                cmd.arg(\"--features\");\n-                cmd.arg(cargo_features.features.join(\" \"));\n-            }\n-        }\n-\n-        cmd.stdout(Stdio::piped()).stderr(Stdio::piped()).stdin(Stdio::null());\n-\n-        let mut res = WorkspaceBuildData::default();\n-\n-        let mut callback_err = None;\n-        let output = stdx::process::streaming_output(\n-            cmd,\n-            &mut |line| {\n-                if callback_err.is_some() {\n-                    return;\n-                }\n-\n-                // Copy-pasted from existing cargo_metadata. It seems like we\n-                // should be using sered_stacker here?\n-                let mut deserializer = serde_json::Deserializer::from_str(line);\n-                deserializer.disable_recursion_limit();\n-                let message = Message::deserialize(&mut deserializer)\n-                    .unwrap_or_else(|_| Message::TextLine(line.to_string()));\n-\n-                match message {\n-                    Message::BuildScriptExecuted(BuildScript {\n-                        package_id,\n-                        out_dir,\n-                        cfgs,\n-                        env,\n-                        ..\n-                    }) => {\n-                        let cfgs = {\n-                            let mut acc = Vec::new();\n-                            for cfg in cfgs {\n-                                match cfg.parse::<CfgFlag>() {\n-                                    Ok(it) => acc.push(it),\n-                                    Err(err) => {\n-                                        callback_err = Some(anyhow::format_err!(\n-                                            \"invalid cfg from cargo-metadata: {}\",\n-                                            err\n-                                        ));\n-                                        return;\n-                                    }\n-                                };\n-                            }\n-                            acc\n-                        };\n-                        let package_build_data =\n-                            res.per_package.entry(package_id.repr).or_default();\n-                        // cargo_metadata crate returns default (empty) path for\n-                        // older cargos, which is not absolute, so work around that.\n-                        if !out_dir.as_str().is_empty() {\n-                            let out_dir =\n-                                AbsPathBuf::assert(PathBuf::from(out_dir.into_os_string()));\n-                            package_build_data.out_dir = Some(out_dir);\n-                            package_build_data.cfgs = cfgs;\n-                        }\n-\n-                        package_build_data.envs = env;\n-                    }\n-                    Message::CompilerArtifact(message) => {\n-                        progress(format!(\"metadata {}\", message.target.name));\n-\n-                        if message.target.kind.iter().any(|k| k == \"proc-macro\") {\n-                            let package_id = message.package_id;\n-                            // Skip rmeta file\n-                            if let Some(filename) =\n-                                message.filenames.iter().find(|name| is_dylib(name))\n-                            {\n-                                let filename = AbsPathBuf::assert(PathBuf::from(&filename));\n-                                let package_build_data =\n-                                    res.per_package.entry(package_id.repr).or_default();\n-                                package_build_data.proc_macro_dylib_path = Some(filename);\n-                            }\n-                        }\n-                    }\n-                    Message::CompilerMessage(message) => {\n-                        progress(message.target.name);\n-                    }\n-                    Message::BuildFinished(_) => {}\n-                    Message::TextLine(_) => {}\n-                    _ => {}\n-                }\n-            },\n-            &mut |_| (),\n-        )?;\n-\n-        for package in packages {\n-            let package_build_data = res.per_package.entry(package.id.repr.clone()).or_default();\n-            inject_cargo_env(package, package_build_data);\n-            if let Some(out_dir) = &package_build_data.out_dir {\n-                // NOTE: cargo and rustc seem to hide non-UTF-8 strings from env! and option_env!()\n-                if let Some(out_dir) = out_dir.as_os_str().to_str().map(|s| s.to_owned()) {\n-                    package_build_data.envs.push((\"OUT_DIR\".to_string(), out_dir));\n-                }\n-            }\n-        }\n-\n-        if !output.status.success() {\n-            let mut stderr = String::from_utf8(output.stderr).unwrap_or_default();\n-            if stderr.is_empty() {\n-                stderr = \"cargo check failed\".to_string();\n-            }\n-            res.error = Some(stderr)\n-        }\n-\n-        Ok(res)\n-    }\n-}\n-\n-// FIXME: File a better way to know if it is a dylib\n-fn is_dylib(path: &Utf8Path) -> bool {\n-    match path.extension().map(|e| e.to_string().to_lowercase()) {\n-        None => false,\n-        Some(ext) => matches!(ext.as_str(), \"dll\" | \"dylib\" | \"so\"),\n-    }\n-}\n-\n-/// Recreates the compile-time environment variables that Cargo sets.\n-///\n-/// Should be synced with <https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-crates>\n-fn inject_cargo_env(package: &cargo_metadata::Package, build_data: &mut PackageBuildData) {\n-    let env = &mut build_data.envs;\n-\n-    // FIXME: Missing variables:\n-    // CARGO_BIN_NAME, CARGO_BIN_EXE_<name>\n-\n-    let mut manifest_dir = package.manifest_path.clone();\n-    manifest_dir.pop();\n-    env.push((\"CARGO_MANIFEST_DIR\".into(), manifest_dir.into_string()));\n-\n-    // Not always right, but works for common cases.\n-    env.push((\"CARGO\".into(), \"cargo\".into()));\n-\n-    env.push((\"CARGO_PKG_VERSION\".into(), package.version.to_string()));\n-    env.push((\"CARGO_PKG_VERSION_MAJOR\".into(), package.version.major.to_string()));\n-    env.push((\"CARGO_PKG_VERSION_MINOR\".into(), package.version.minor.to_string()));\n-    env.push((\"CARGO_PKG_VERSION_PATCH\".into(), package.version.patch.to_string()));\n-    env.push((\"CARGO_PKG_VERSION_PRE\".into(), package.version.pre.to_string()));\n-\n-    let authors = package.authors.join(\";\");\n-    env.push((\"CARGO_PKG_AUTHORS\".into(), authors));\n-\n-    env.push((\"CARGO_PKG_NAME\".into(), package.name.clone()));\n-    // FIXME: This isn't really correct (a package can have many crates with different names), but\n-    // it's better than leaving the variable unset.\n-    env.push((\"CARGO_CRATE_NAME\".into(), CrateName::normalize_dashes(&package.name).to_string()));\n-    env.push((\"CARGO_PKG_DESCRIPTION\".into(), package.description.clone().unwrap_or_default()));\n-    env.push((\"CARGO_PKG_HOMEPAGE\".into(), package.homepage.clone().unwrap_or_default()));\n-    env.push((\"CARGO_PKG_REPOSITORY\".into(), package.repository.clone().unwrap_or_default()));\n-    env.push((\"CARGO_PKG_LICENSE\".into(), package.license.clone().unwrap_or_default()));\n-\n-    let license_file = package.license_file.as_ref().map(|buf| buf.to_string()).unwrap_or_default();\n-    env.push((\"CARGO_PKG_LICENSE_FILE\".into(), license_file));\n-}"}, {"sha": "fb8cc271c51f1af1659080adb5c6b466eb6e3628", "filename": "crates/project_model/src/build_scripts.rs", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Fproject_model%2Fsrc%2Fbuild_scripts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Fproject_model%2Fsrc%2Fbuild_scripts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fbuild_scripts.rs?ref=f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a", "patch": "@@ -0,0 +1,207 @@\n+//! Workspace information we get from cargo consists of two pieces. The first is\n+//! the output of `cargo metadata`. The second is the output of running\n+//! `build.rs` files (`OUT_DIR` env var, extra cfg flags) and compiling proc\n+//! macro.\n+//!\n+//! This module implements this second part. We use \"build script\" terminology\n+//! here, but it covers procedural macros as well.\n+\n+use std::{\n+    path::PathBuf,\n+    process::{Command, Stdio},\n+};\n+\n+use anyhow::Result;\n+use cargo_metadata::{camino::Utf8Path, Message};\n+use la_arena::ArenaMap;\n+use paths::AbsPathBuf;\n+use rustc_hash::FxHashMap;\n+use serde::Deserialize;\n+\n+use crate::{cfg_flag::CfgFlag, CargoConfig, CargoWorkspace, Package};\n+\n+#[derive(Debug, Default, Clone, PartialEq, Eq)]\n+pub struct WorkspaceBuildScripts {\n+    pub(crate) outputs: ArenaMap<Package, BuildScriptOutput>,\n+    error: Option<String>,\n+}\n+\n+#[derive(Debug, Clone, Default, PartialEq, Eq)]\n+pub(crate) struct BuildScriptOutput {\n+    /// List of config flags defined by this package's build script.\n+    pub(crate) cfgs: Vec<CfgFlag>,\n+    /// List of cargo-related environment variables with their value.\n+    ///\n+    /// If the package has a build script which defines environment variables,\n+    /// they can also be found here.\n+    pub(crate) envs: Vec<(String, String)>,\n+    /// Directory where a build script might place its output.\n+    pub(crate) out_dir: Option<AbsPathBuf>,\n+    /// Path to the proc-macro library file if this package exposes proc-macros.\n+    pub(crate) proc_macro_dylib_path: Option<AbsPathBuf>,\n+}\n+\n+impl WorkspaceBuildScripts {\n+    pub fn run(\n+        config: &CargoConfig,\n+        workspace: &CargoWorkspace,\n+        progress: &dyn Fn(String),\n+    ) -> Result<WorkspaceBuildScripts> {\n+        let mut cmd = Command::new(toolchain::cargo());\n+\n+        if config.wrap_rustc_in_build_scripts {\n+            // Setup RUSTC_WRAPPER to point to `rust-analyzer` binary itself. We use\n+            // that to compile only proc macros and build scripts during the initial\n+            // `cargo check`.\n+            let myself = std::env::current_exe()?;\n+            cmd.env(\"RUSTC_WRAPPER\", myself);\n+            cmd.env(\"RA_RUSTC_WRAPPER\", \"1\");\n+        }\n+        cmd.current_dir(workspace.workspace_root());\n+        cmd.args(&[\"check\", \"--quiet\", \"--workspace\", \"--message-format=json\"]);\n+\n+        // --all-targets includes tests, benches and examples in addition to the\n+        // default lib and bins. This is an independent concept from the --targets\n+        // flag below.\n+        cmd.arg(\"--all-targets\");\n+\n+        if let Some(target) = &config.target {\n+            cmd.args(&[\"--target\", target]);\n+        }\n+\n+        if config.all_features {\n+            cmd.arg(\"--all-features\");\n+        } else {\n+            if config.no_default_features {\n+                cmd.arg(\"--no-default-features\");\n+            }\n+            if !config.features.is_empty() {\n+                cmd.arg(\"--features\");\n+                cmd.arg(config.features.join(\" \"));\n+            }\n+        }\n+\n+        cmd.stdout(Stdio::piped()).stderr(Stdio::piped()).stdin(Stdio::null());\n+\n+        let mut res = WorkspaceBuildScripts::default();\n+        // NB: Cargo.toml could have been modified between `cargo metadata` and\n+        // `cargo check`. We shouldn't assume that package ids we see here are\n+        // exactly those from `config`.\n+        let mut by_id: FxHashMap<String, Package> = FxHashMap::default();\n+\n+        for package in workspace.packages() {\n+            res.outputs.insert(package, BuildScriptOutput::default());\n+            by_id.insert(workspace[package].id.clone(), package);\n+        }\n+\n+        let mut callback_err = None;\n+        let mut stderr = String::new();\n+        let output = stdx::process::streaming_output(\n+            cmd,\n+            &mut |line| {\n+                if callback_err.is_some() {\n+                    return;\n+                }\n+\n+                // Copy-pasted from existing cargo_metadata. It seems like we\n+                // should be using sered_stacker here?\n+                let mut deserializer = serde_json::Deserializer::from_str(line);\n+                deserializer.disable_recursion_limit();\n+                let message = Message::deserialize(&mut deserializer)\n+                    .unwrap_or_else(|_| Message::TextLine(line.to_string()));\n+\n+                match message {\n+                    Message::BuildScriptExecuted(message) => {\n+                        let package = match by_id.get(&message.package_id.repr) {\n+                            Some(it) => *it,\n+                            None => return,\n+                        };\n+                        let cfgs = {\n+                            let mut acc = Vec::new();\n+                            for cfg in message.cfgs {\n+                                match cfg.parse::<CfgFlag>() {\n+                                    Ok(it) => acc.push(it),\n+                                    Err(err) => {\n+                                        callback_err = Some(anyhow::format_err!(\n+                                            \"invalid cfg from cargo-metadata: {}\",\n+                                            err\n+                                        ));\n+                                        return;\n+                                    }\n+                                };\n+                            }\n+                            acc\n+                        };\n+                        let package_build_data = &mut res.outputs[package];\n+                        // cargo_metadata crate returns default (empty) path for\n+                        // older cargos, which is not absolute, so work around that.\n+                        if !message.out_dir.as_str().is_empty() {\n+                            let out_dir =\n+                                AbsPathBuf::assert(PathBuf::from(message.out_dir.into_os_string()));\n+                            package_build_data.out_dir = Some(out_dir);\n+                            package_build_data.cfgs = cfgs;\n+                        }\n+\n+                        package_build_data.envs = message.env;\n+                    }\n+                    Message::CompilerArtifact(message) => {\n+                        let package = match by_id.get(&message.package_id.repr) {\n+                            Some(it) => *it,\n+                            None => return,\n+                        };\n+\n+                        progress(format!(\"metadata {}\", message.target.name));\n+\n+                        if message.target.kind.iter().any(|k| k == \"proc-macro\") {\n+                            // Skip rmeta file\n+                            if let Some(filename) =\n+                                message.filenames.iter().find(|name| is_dylib(name))\n+                            {\n+                                let filename = AbsPathBuf::assert(PathBuf::from(&filename));\n+                                res.outputs[package].proc_macro_dylib_path = Some(filename);\n+                            }\n+                        }\n+                    }\n+                    Message::CompilerMessage(message) => {\n+                        progress(message.target.name);\n+                    }\n+                    Message::BuildFinished(_) => {}\n+                    Message::TextLine(_) => {}\n+                    _ => {}\n+                }\n+            },\n+            &mut |line| {\n+                stderr.push_str(line);\n+                stderr.push('\\n');\n+            },\n+        )?;\n+\n+        for package in workspace.packages() {\n+            let package_build_data = &mut res.outputs[package];\n+            // inject_cargo_env(package, package_build_data);\n+            if let Some(out_dir) = &package_build_data.out_dir {\n+                // NOTE: cargo and rustc seem to hide non-UTF-8 strings from env! and option_env!()\n+                if let Some(out_dir) = out_dir.as_os_str().to_str().map(|s| s.to_owned()) {\n+                    package_build_data.envs.push((\"OUT_DIR\".to_string(), out_dir));\n+                }\n+            }\n+        }\n+\n+        if !output.status.success() {\n+            if stderr.is_empty() {\n+                stderr = \"cargo check failed\".to_string();\n+            }\n+            res.error = Some(stderr)\n+        }\n+\n+        Ok(res)\n+    }\n+}\n+\n+// FIXME: File a better way to know if it is a dylib.\n+fn is_dylib(path: &Utf8Path) -> bool {\n+    match path.extension().map(|e| e.to_string().to_lowercase()) {\n+        None => false,\n+        Some(ext) => matches!(ext.as_str(), \"dll\" | \"dylib\" | \"so\"),\n+    }\n+}"}, {"sha": "c88bafb0baf2b09a6f35366b5a6d43910932874f", "filename": "crates/project_model/src/cargo_workspace.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Fproject_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Fproject_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fcargo_workspace.rs?ref=f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a", "patch": "@@ -2,7 +2,7 @@\n \n use std::iter;\n use std::path::PathBuf;\n-use std::{convert::TryInto, ops, process::Command, sync::Arc};\n+use std::{convert::TryInto, ops, process::Command};\n \n use anyhow::{Context, Result};\n use base_db::Edition;\n@@ -13,8 +13,8 @@ use rustc_hash::FxHashMap;\n use serde::Deserialize;\n use serde_json::from_value;\n \n+use crate::utf8_stdout;\n use crate::CfgOverrides;\n-use crate::{build_data::BuildDataConfig, utf8_stdout};\n \n /// [`CargoWorkspace`] represents the logical structure of, well, a Cargo\n /// workspace. It pretty closely mirrors `cargo metadata` output.\n@@ -31,7 +31,6 @@ pub struct CargoWorkspace {\n     packages: Arena<PackageData>,\n     targets: Arena<TargetData>,\n     workspace_root: AbsPathBuf,\n-    build_data_config: BuildDataConfig,\n }\n \n impl ops::Index<Package> for CargoWorkspace {\n@@ -81,6 +80,8 @@ pub struct CargoConfig {\n \n     /// crates to disable `#[cfg(test)]` on\n     pub unset_test_crates: Vec<String>,\n+\n+    pub wrap_rustc_in_build_scripts: bool,\n }\n \n impl CargoConfig {\n@@ -103,7 +104,7 @@ pub type Target = Idx<TargetData>;\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct PackageData {\n     /// Version given in the `Cargo.toml`\n-    pub version: String,\n+    pub version: semver::Version,\n     /// Name as given in the `Cargo.toml`\n     pub name: String,\n     /// Path containing the `Cargo.toml`\n@@ -288,11 +289,7 @@ impl CargoWorkspace {\n         Ok(meta)\n     }\n \n-    pub fn new(\n-        cargo_toml: &AbsPath,\n-        config: &CargoConfig,\n-        mut meta: cargo_metadata::Metadata,\n-    ) -> CargoWorkspace {\n+    pub fn new(mut meta: cargo_metadata::Metadata) -> CargoWorkspace {\n         let mut pkg_by_id = FxHashMap::default();\n         let mut packages = Arena::default();\n         let mut targets = Arena::default();\n@@ -314,7 +311,7 @@ impl CargoWorkspace {\n             let pkg = packages.alloc(PackageData {\n                 id: id.repr.clone(),\n                 name: name.clone(),\n-                version: version.to_string(),\n+                version: version.clone(),\n                 manifest: AbsPathBuf::assert(PathBuf::from(&manifest_path)),\n                 targets: Vec::new(),\n                 is_member,\n@@ -374,10 +371,8 @@ impl CargoWorkspace {\n \n         let workspace_root =\n             AbsPathBuf::assert(PathBuf::from(meta.workspace_root.into_os_string()));\n-        let build_data_config =\n-            BuildDataConfig::new(cargo_toml.to_path_buf(), config.clone(), Arc::new(meta.packages));\n \n-        CargoWorkspace { packages, targets, workspace_root, build_data_config }\n+        CargoWorkspace { packages, targets, workspace_root }\n     }\n \n     pub fn from_cargo_metadata3(\n@@ -386,7 +381,7 @@ impl CargoWorkspace {\n         progress: &dyn Fn(String),\n     ) -> Result<CargoWorkspace> {\n         let meta = CargoWorkspace::fetch_metadata(cargo_toml, config, progress)?;\n-        Ok(CargoWorkspace::new(cargo_toml, config, meta))\n+        Ok(CargoWorkspace::new(meta))\n     }\n \n     pub fn packages<'a>(&'a self) -> impl Iterator<Item = Package> + ExactSizeIterator + 'a {\n@@ -412,10 +407,6 @@ impl CargoWorkspace {\n         }\n     }\n \n-    pub(crate) fn build_data_config(&self) -> &BuildDataConfig {\n-        &self.build_data_config\n-    }\n-\n     fn is_unique(&self, name: &str) -> bool {\n         self.packages.iter().filter(|(_, v)| v.name == name).count() == 1\n     }"}, {"sha": "7be4e04907e74f57db8a15922cd4f9815c329c50", "filename": "crates/project_model/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Fproject_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Fproject_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Flib.rs?ref=f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a", "patch": "@@ -21,7 +21,7 @@ mod project_json;\n mod sysroot;\n mod workspace;\n mod rustc_cfg;\n-mod build_data;\n+mod build_scripts;\n \n use std::{\n     fs::{self, read_dir, ReadDir},\n@@ -34,7 +34,7 @@ use paths::{AbsPath, AbsPathBuf};\n use rustc_hash::FxHashSet;\n \n pub use crate::{\n-    build_data::{BuildDataCollector, BuildDataResult},\n+    build_scripts::WorkspaceBuildScripts,\n     cargo_workspace::{\n         CargoConfig, CargoWorkspace, Package, PackageData, PackageDependency, RustcSource, Target,\n         TargetData, TargetKind,"}, {"sha": "7a47fd7a5c0f1e1568aea051393d46333b526186", "filename": "crates/project_model/src/workspace.rs", "status": "modified", "additions": 54, "deletions": 36, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Fproject_model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject_model%2Fsrc%2Fworkspace.rs?ref=f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a", "patch": "@@ -6,20 +6,19 @@ use std::{collections::VecDeque, fmt, fs, process::Command};\n \n use anyhow::{format_err, Context, Result};\n use base_db::{CrateDisplayName, CrateGraph, CrateId, CrateName, Edition, Env, FileId, ProcMacro};\n-use cargo_workspace::DepKind;\n use cfg::{CfgDiff, CfgOptions};\n use paths::{AbsPath, AbsPathBuf};\n use proc_macro_api::ProcMacroClient;\n use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::{\n-    build_data::{BuildDataResult, PackageBuildData, WorkspaceBuildData},\n-    cargo_workspace,\n+    build_scripts::BuildScriptOutput,\n+    cargo_workspace::{DepKind, PackageData, RustcSource},\n     cfg_flag::CfgFlag,\n     rustc_cfg,\n     sysroot::SysrootCrate,\n-    utf8_stdout, BuildDataCollector, CargoConfig, CargoWorkspace, ProjectJson, ProjectManifest,\n-    Sysroot, TargetKind,\n+    utf8_stdout, CargoConfig, CargoWorkspace, ProjectJson, ProjectManifest, Sysroot, TargetKind,\n+    WorkspaceBuildScripts,\n };\n \n pub type CfgOverrides = FxHashMap<String, CfgDiff>;\n@@ -134,7 +133,7 @@ impl ProjectWorkspace {\n                             cargo_version\n                         )\n                     })?;\n-                let cargo = CargoWorkspace::new(&cargo_toml, config, meta);\n+                let cargo = CargoWorkspace::new(meta);\n \n                 let sysroot = if config.no_sysroot {\n                     Sysroot::default()\n@@ -148,7 +147,6 @@ impl ProjectWorkspace {\n                 };\n \n                 let rustc_dir = if let Some(rustc_source) = &config.rustc_source {\n-                    use cargo_workspace::RustcSource;\n                     match rustc_source {\n                         RustcSource::Path(path) => Some(path.clone()),\n                         RustcSource::Discover => Sysroot::discover_rustc(&cargo_toml),\n@@ -163,7 +161,7 @@ impl ProjectWorkspace {\n                             .with_context(|| {\n                                 format!(\"Failed to read Cargo metadata for Rust sources\")\n                             })?;\n-                        CargoWorkspace::new(&rustc_dir, config, meta)\n+                        CargoWorkspace::new(meta)\n                     }),\n                     None => None,\n                 };\n@@ -201,7 +199,7 @@ impl ProjectWorkspace {\n     /// Returns the roots for the current `ProjectWorkspace`\n     /// The return type contains the path and whether or not\n     /// the root is a member of the current workspace\n-    pub fn to_roots(&self, build_data: Option<&BuildDataResult>) -> Vec<PackageRoot> {\n+    pub fn to_roots(&self, build_scripts: &WorkspaceBuildScripts) -> Vec<PackageRoot> {\n         match self {\n             ProjectWorkspace::Json { project, sysroot, rustc_cfg: _ } => project\n                 .crates()\n@@ -229,10 +227,7 @@ impl ProjectWorkspace {\n \n                         let mut include = vec![pkg_root.clone()];\n                         include.extend(\n-                            build_data\n-                                .and_then(|it| it.get(cargo.workspace_root()))\n-                                .and_then(|map| map.get(&cargo[pkg].id))\n-                                .and_then(|it| it.out_dir.clone()),\n+                            build_scripts.outputs.get(pkg).and_then(|it| it.out_dir.clone()),\n                         );\n \n                         // In case target's path is manually set in Cargo.toml to be\n@@ -307,7 +302,7 @@ impl ProjectWorkspace {\n \n     pub fn to_crate_graph(\n         &self,\n-        build_data: Option<&BuildDataResult>,\n+        build_scripts: &WorkspaceBuildScripts,\n         proc_macro_client: Option<&ProcMacroClient>,\n         load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n     ) -> CrateGraph {\n@@ -332,13 +327,9 @@ impl ProjectWorkspace {\n                     &proc_macro_loader,\n                     load,\n                     cargo,\n-                    build_data.and_then(|it| it.get(cargo.workspace_root())),\n+                    build_scripts,\n                     sysroot,\n                     rustc,\n-                    rustc\n-                        .as_ref()\n-                        .zip(build_data)\n-                        .and_then(|(it, map)| map.get(it.workspace_root())),\n                 )\n             }\n             ProjectWorkspace::DetachedFiles { files, sysroot, rustc_cfg } => {\n@@ -352,15 +343,6 @@ impl ProjectWorkspace {\n         }\n         crate_graph\n     }\n-\n-    pub fn collect_build_data_configs(&self, collector: &mut BuildDataCollector) {\n-        match self {\n-            ProjectWorkspace::Cargo { cargo, .. } => {\n-                collector.add_config(cargo.workspace_root(), cargo.build_data_config().clone());\n-            }\n-            _ => {}\n-        }\n-    }\n }\n \n fn project_json_to_crate_graph(\n@@ -435,10 +417,9 @@ fn cargo_to_crate_graph(\n     proc_macro_loader: &dyn Fn(&AbsPath) -> Vec<ProcMacro>,\n     load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n     cargo: &CargoWorkspace,\n-    build_data_map: Option<&WorkspaceBuildData>,\n+    build_scripts: &WorkspaceBuildScripts,\n     sysroot: &Sysroot,\n     rustc: &Option<CargoWorkspace>,\n-    rustc_build_data_map: Option<&WorkspaceBuildData>,\n ) -> CrateGraph {\n     let _p = profile::span(\"cargo_to_crate_graph\");\n     let mut crate_graph = CrateGraph::default();\n@@ -481,7 +462,7 @@ fn cargo_to_crate_graph(\n                 let crate_id = add_target_crate_root(\n                     &mut crate_graph,\n                     &cargo[pkg],\n-                    build_data_map.and_then(|it| it.get(&cargo[pkg].id)),\n+                    build_scripts.outputs.get(pkg),\n                     &cfg_options,\n                     proc_macro_loader,\n                     file_id,\n@@ -555,7 +536,6 @@ fn cargo_to_crate_graph(\n                 rustc_workspace,\n                 load,\n                 &mut crate_graph,\n-                rustc_build_data_map,\n                 &cfg_options,\n                 proc_macro_loader,\n                 &mut pkg_to_lib_crate,\n@@ -615,7 +595,6 @@ fn handle_rustc_crates(\n     rustc_workspace: &CargoWorkspace,\n     load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n     crate_graph: &mut CrateGraph,\n-    rustc_build_data_map: Option<&WorkspaceBuildData>,\n     cfg_options: &CfgOptions,\n     proc_macro_loader: &dyn Fn(&AbsPath) -> Vec<ProcMacro>,\n     pkg_to_lib_crate: &mut FxHashMap<la_arena::Idx<crate::PackageData>, CrateId>,\n@@ -651,7 +630,7 @@ fn handle_rustc_crates(\n                     let crate_id = add_target_crate_root(\n                         crate_graph,\n                         &rustc_workspace[pkg],\n-                        rustc_build_data_map.and_then(|it| it.get(&rustc_workspace[pkg].id)),\n+                        None,\n                         cfg_options,\n                         proc_macro_loader,\n                         file_id,\n@@ -706,8 +685,8 @@ fn handle_rustc_crates(\n \n fn add_target_crate_root(\n     crate_graph: &mut CrateGraph,\n-    pkg: &cargo_workspace::PackageData,\n-    build_data: Option<&PackageBuildData>,\n+    pkg: &PackageData,\n+    build_data: Option<&BuildScriptOutput>,\n     cfg_options: &CfgOptions,\n     proc_macro_loader: &dyn Fn(&AbsPath) -> Vec<ProcMacro>,\n     file_id: FileId,\n@@ -726,6 +705,8 @@ fn add_target_crate_root(\n     };\n \n     let mut env = Env::default();\n+    inject_cargo_env(pkg, &mut env);\n+\n     if let Some(envs) = build_data.map(|it| &it.envs) {\n         for (k, v) in envs {\n             env.set(k, v.clone());\n@@ -812,3 +793,40 @@ fn add_dep(graph: &mut CrateGraph, from: CrateId, name: CrateName, to: CrateId)\n         log::error!(\"{}\", err)\n     }\n }\n+\n+/// Recreates the compile-time environment variables that Cargo sets.\n+///\n+/// Should be synced with\n+/// <https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-crates>\n+///\n+/// FIXME: ask Cargo to provide this data instead of re-deriving.\n+fn inject_cargo_env(package: &PackageData, env: &mut Env) {\n+    // FIXME: Missing variables:\n+    // CARGO_BIN_NAME, CARGO_BIN_EXE_<name>\n+\n+    let mut manifest_dir = package.manifest.clone();\n+    manifest_dir.pop();\n+    env.set(\"CARGO_MANIFEST_DIR\".into(), manifest_dir.as_os_str().to_string_lossy().into_owned());\n+\n+    // Not always right, but works for common cases.\n+    env.set(\"CARGO\".into(), \"cargo\".into());\n+\n+    env.set(\"CARGO_PKG_VERSION\".into(), package.version.to_string());\n+    env.set(\"CARGO_PKG_VERSION_MAJOR\".into(), package.version.major.to_string());\n+    env.set(\"CARGO_PKG_VERSION_MINOR\".into(), package.version.minor.to_string());\n+    env.set(\"CARGO_PKG_VERSION_PATCH\".into(), package.version.patch.to_string());\n+    env.set(\"CARGO_PKG_VERSION_PRE\".into(), package.version.pre.to_string());\n+\n+    env.set(\"CARGO_PKG_AUTHORS\".into(), String::new());\n+\n+    env.set(\"CARGO_PKG_NAME\".into(), package.name.clone());\n+    // FIXME: This isn't really correct (a package can have many crates with different names), but\n+    // it's better than leaving the variable unset.\n+    env.set(\"CARGO_CRATE_NAME\".into(), CrateName::normalize_dashes(&package.name).to_string());\n+    env.set(\"CARGO_PKG_DESCRIPTION\".into(), String::new());\n+    env.set(\"CARGO_PKG_HOMEPAGE\".into(), String::new());\n+    env.set(\"CARGO_PKG_REPOSITORY\".into(), String::new());\n+    env.set(\"CARGO_PKG_LICENSE\".into(), String::new());\n+\n+    env.set(\"CARGO_PKG_LICENSE_FILE\".into(), String::new());\n+}"}, {"sha": "37da24f30e177720a281a7dffb2692eb4c30d3b5", "filename": "crates/rust-analyzer/src/cli/analysis_stats.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs?ref=f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a", "patch": "@@ -68,7 +68,6 @@ impl AnalysisStatsCmd {\n         cargo_config.no_sysroot = self.no_sysroot;\n         let load_cargo_config = LoadCargoConfig {\n             load_out_dirs_from_check: self.enable_build_scripts,\n-            wrap_rustc: false,\n             with_proc_macro: self.enable_proc_macros,\n             prefill_caches: false,\n         };"}, {"sha": "84aaf1d5055eb2f254611ee10f26dd90b2fe600a", "filename": "crates/rust-analyzer/src/cli/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs?ref=f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a", "patch": "@@ -34,12 +34,8 @@ pub fn diagnostics(\n     with_proc_macro: bool,\n ) -> Result<()> {\n     let cargo_config = Default::default();\n-    let load_cargo_config = LoadCargoConfig {\n-        load_out_dirs_from_check,\n-        with_proc_macro,\n-        wrap_rustc: false,\n-        prefill_caches: false,\n-    };\n+    let load_cargo_config =\n+        LoadCargoConfig { load_out_dirs_from_check, with_proc_macro, prefill_caches: false };\n     let (host, _vfs, _proc_macro) =\n         load_workspace_at(path, &cargo_config, &load_cargo_config, &|_| {})?;\n     let db = host.raw_database();"}, {"sha": "c3ab6c107cf5953d6a80b86a9ccba846d21d0bb5", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a", "patch": "@@ -8,15 +8,14 @@ use hir::db::DefDatabase;\n use ide::{AnalysisHost, Change};\n use ide_db::base_db::CrateGraph;\n use project_model::{\n-    BuildDataCollector, CargoConfig, ProcMacroClient, ProjectManifest, ProjectWorkspace,\n+    CargoConfig, ProcMacroClient, ProjectManifest, ProjectWorkspace, WorkspaceBuildScripts,\n };\n use vfs::{loader::Handle, AbsPath, AbsPathBuf};\n \n use crate::reload::{ProjectFolders, SourceRootConfig};\n \n pub(crate) struct LoadCargoConfig {\n     pub(crate) load_out_dirs_from_check: bool,\n-    pub(crate) wrap_rustc: bool,\n     pub(crate) with_proc_macro: bool,\n     pub(crate) prefill_caches: bool,\n }\n@@ -33,12 +32,13 @@ pub(crate) fn load_workspace_at(\n     eprintln!(\"root = {:?}\", root);\n     let workspace = ProjectWorkspace::load(root, cargo_config, progress)?;\n \n-    load_workspace(workspace, load_config, progress)\n+    load_workspace(workspace, cargo_config, load_config, progress)\n }\n \n fn load_workspace(\n     ws: ProjectWorkspace,\n-    config: &LoadCargoConfig,\n+    cargo_config: &CargoConfig,\n+    load_config: &LoadCargoConfig,\n     progress: &dyn Fn(String),\n ) -> Result<(AnalysisHost, vfs::Vfs, Option<ProcMacroClient>)> {\n     let (sender, receiver) = unbounded();\n@@ -49,33 +49,29 @@ fn load_workspace(\n         Box::new(loader)\n     };\n \n-    let proc_macro_client = if config.with_proc_macro {\n+    let proc_macro_client = if load_config.with_proc_macro {\n         let path = AbsPathBuf::assert(std::env::current_exe()?);\n         Some(ProcMacroClient::extern_process(path, &[\"proc-macro\"]).unwrap())\n     } else {\n         None\n     };\n \n-    let build_data = if config.load_out_dirs_from_check {\n-        let mut collector = BuildDataCollector::new(config.wrap_rustc);\n-        ws.collect_build_data_configs(&mut collector);\n-        Some(collector.collect(progress)?)\n-    } else {\n-        None\n+    let build_scripts = match &ws {\n+        ProjectWorkspace::Cargo { cargo, .. } if load_config.load_out_dirs_from_check => {\n+            WorkspaceBuildScripts::run(cargo_config, cargo, progress)?\n+        }\n+        _ => WorkspaceBuildScripts::default(),\n     };\n \n-    let crate_graph = ws.to_crate_graph(\n-        build_data.as_ref(),\n-        proc_macro_client.as_ref(),\n-        &mut |path: &AbsPath| {\n+    let crate_graph =\n+        ws.to_crate_graph(&build_scripts, proc_macro_client.as_ref(), &mut |path: &AbsPath| {\n             let contents = loader.load_sync(path);\n             let path = vfs::VfsPath::from(path.to_path_buf());\n             vfs.set_file_contents(path.clone(), contents);\n             vfs.file_id(&path)\n-        },\n-    );\n+        });\n \n-    let project_folders = ProjectFolders::new(&[ws], &[], build_data.as_ref());\n+    let project_folders = ProjectFolders::new(&[ws], &[build_scripts], &[]);\n     loader.set_config(vfs::loader::Config {\n         load: project_folders.load,\n         watch: vec![],\n@@ -86,7 +82,7 @@ fn load_workspace(\n     let host =\n         load_crate_graph(crate_graph, project_folders.source_root_config, &mut vfs, &receiver);\n \n-    if config.prefill_caches {\n+    if load_config.prefill_caches {\n         host.analysis().prime_caches(|_| {})?;\n     }\n     Ok((host, vfs, proc_macro_client))\n@@ -146,10 +142,9 @@ mod tests {\n     #[test]\n     fn test_loading_rust_analyzer() {\n         let path = Path::new(env!(\"CARGO_MANIFEST_DIR\")).parent().unwrap().parent().unwrap();\n-        let cargo_config = Default::default();\n+        let cargo_config = CargoConfig::default();\n         let load_cargo_config = LoadCargoConfig {\n             load_out_dirs_from_check: false,\n-            wrap_rustc: false,\n             with_proc_macro: false,\n             prefill_caches: false,\n         };"}, {"sha": "60092127d96d1a3626c53006f7c1fe65268b5528", "filename": "crates/rust-analyzer/src/cli/ssr.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fssr.rs?ref=f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a", "patch": "@@ -5,13 +5,13 @@ use crate::cli::{\n     Result,\n };\n use ide_ssr::{MatchFinder, SsrPattern, SsrRule};\n+use project_model::CargoConfig;\n \n pub fn apply_ssr_rules(rules: Vec<SsrRule>) -> Result<()> {\n     use ide_db::base_db::SourceDatabaseExt;\n-    let cargo_config = Default::default();\n+    let cargo_config = CargoConfig::default();\n     let load_cargo_config = LoadCargoConfig {\n         load_out_dirs_from_check: true,\n-        wrap_rustc: false,\n         with_proc_macro: true,\n         prefill_caches: false,\n     };\n@@ -39,10 +39,9 @@ pub fn apply_ssr_rules(rules: Vec<SsrRule>) -> Result<()> {\n pub fn search_for_patterns(patterns: Vec<SsrPattern>, debug_snippet: Option<String>) -> Result<()> {\n     use ide_db::base_db::SourceDatabaseExt;\n     use ide_db::symbol_index::SymbolsDatabase;\n-    let cargo_config = Default::default();\n+    let cargo_config = CargoConfig::default();\n     let load_cargo_config = LoadCargoConfig {\n         load_out_dirs_from_check: true,\n-        wrap_rustc: true,\n         with_proc_macro: true,\n         prefill_caches: false,\n     };"}, {"sha": "2f10f7b6c89083743fd24252b0de55c1b5c47b90", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a", "patch": "@@ -628,9 +628,6 @@ impl Config {\n     pub fn run_build_scripts(&self) -> bool {\n         self.data.cargo_runBuildScripts || self.data.procMacro_enable\n     }\n-    pub fn wrap_rustc(&self) -> bool {\n-        self.data.cargo_useRustcWrapperForBuildScripts\n-    }\n     pub fn cargo(&self) -> CargoConfig {\n         let rustc_source = self.data.rustcSource.as_ref().map(|rustc_src| {\n             if rustc_src == \"discover\" {\n@@ -648,6 +645,7 @@ impl Config {\n             rustc_source,\n             no_sysroot: self.data.cargo_noSysroot,\n             unset_test_crates: self.data.cargo_unsetTest.clone(),\n+            wrap_rustc_in_build_scripts: self.data.cargo_useRustcWrapperForBuildScripts,\n         }\n     }\n "}, {"sha": "c188d26a7960dbd7a17488453f7e9bb6ecfe9b0a", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a", "patch": "@@ -12,7 +12,7 @@ use ide_db::base_db::{CrateId, VfsPath};\n use lsp_types::{SemanticTokens, Url};\n use parking_lot::{Mutex, RwLock};\n use project_model::{\n-    BuildDataCollector, BuildDataResult, CargoWorkspace, ProcMacroClient, ProjectWorkspace, Target,\n+    CargoWorkspace, ProcMacroClient, ProjectWorkspace, Target, WorkspaceBuildScripts,\n };\n use rustc_hash::FxHashMap;\n use vfs::AnchoredPathBuf;\n@@ -79,12 +79,15 @@ pub(crate) struct GlobalState {\n     /// fetch.\n     ///\n     /// If the fetch (partially) fails, we do not update the values.\n+    ///\n+    /// Invariant: workspaces.len() == workspace_build_data\n     pub(crate) workspaces: Arc<Vec<ProjectWorkspace>>,\n-    pub(crate) fetch_workspaces_queue: OpQueue<(), Vec<anyhow::Result<ProjectWorkspace>>>,\n-    pub(crate) workspace_build_data: Option<BuildDataResult>,\n-    pub(crate) fetch_build_data_queue:\n-        OpQueue<BuildDataCollector, Option<anyhow::Result<BuildDataResult>>>,\n-    pub(crate) prime_caches_queue: OpQueue<(), ()>,\n+    pub(crate) fetch_workspaces_queue: OpQueue<Vec<anyhow::Result<ProjectWorkspace>>>,\n+\n+    pub(crate) workspace_build_data: Vec<WorkspaceBuildScripts>,\n+    pub(crate) fetch_build_data_queue: OpQueue<Vec<anyhow::Result<WorkspaceBuildScripts>>>,\n+\n+    pub(crate) prime_caches_queue: OpQueue<()>,\n \n     latest_requests: Arc<RwLock<LatestRequests>>,\n }\n@@ -146,7 +149,7 @@ impl GlobalState {\n \n             workspaces: Arc::new(Vec::new()),\n             fetch_workspaces_queue: OpQueue::default(),\n-            workspace_build_data: None,\n+            workspace_build_data: Vec::new(),\n             prime_caches_queue: OpQueue::default(),\n \n             fetch_build_data_queue: OpQueue::default(),"}, {"sha": "036cfe157b449367299a853c95e759aa51c6c2e5", "filename": "crates/rust-analyzer/src/integrated_benchmarks.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Frust-analyzer%2Fsrc%2Fintegrated_benchmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Frust-analyzer%2Fsrc%2Fintegrated_benchmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fintegrated_benchmarks.rs?ref=f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a", "patch": "@@ -17,6 +17,7 @@ use ide_db::helpers::{\n     insert_use::{ImportGranularity, InsertUseConfig},\n     SnippetCap,\n };\n+use project_model::CargoConfig;\n use test_utils::project_root;\n use vfs::{AbsPathBuf, VfsPath};\n \n@@ -32,10 +33,9 @@ fn integrated_highlighting_benchmark() {\n     let workspace_to_load = project_root();\n     let file = \"./crates/ide_db/src/apply_change.rs\";\n \n-    let cargo_config = Default::default();\n+    let cargo_config = CargoConfig::default();\n     let load_cargo_config = LoadCargoConfig {\n         load_out_dirs_from_check: true,\n-        wrap_rustc: false,\n         with_proc_macro: false,\n         prefill_caches: false,\n     };\n@@ -87,10 +87,9 @@ fn integrated_completion_benchmark() {\n     let workspace_to_load = project_root();\n     let file = \"./crates/hir/src/lib.rs\";\n \n-    let cargo_config = Default::default();\n+    let cargo_config = CargoConfig::default();\n     let load_cargo_config = LoadCargoConfig {\n         load_out_dirs_from_check: true,\n-        wrap_rustc: false,\n         with_proc_macro: false,\n         prefill_caches: true,\n     };"}, {"sha": "3214bbd9e0cc29f26b94b7c7ec209e9150940633", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a", "patch": "@@ -12,7 +12,6 @@ use ide::{FileId, PrimeCachesProgress};\n use ide_db::base_db::VfsPath;\n use lsp_server::{Connection, Notification, Request, Response};\n use lsp_types::notification::Notification as _;\n-use project_model::BuildDataCollector;\n use vfs::ChangeKind;\n \n use crate::{\n@@ -236,12 +235,7 @@ impl GlobalState {\n                                     let workspaces_updated = !Arc::ptr_eq(&old, &self.workspaces);\n \n                                     if self.config.run_build_scripts() && workspaces_updated {\n-                                        let mut collector =\n-                                            BuildDataCollector::new(self.config.wrap_rustc());\n-                                        for ws in self.workspaces.iter() {\n-                                            ws.collect_build_data_configs(&mut collector);\n-                                        }\n-                                        self.fetch_build_data_request(collector)\n+                                        self.fetch_build_data_request()\n                                     }\n \n                                     (Progress::End, None)\n@@ -719,23 +713,21 @@ impl GlobalState {\n         self.maybe_update_diagnostics();\n \n         // Ensure that only one cache priming task can run at a time\n-        self.prime_caches_queue.request_op(());\n-        if self.prime_caches_queue.should_start_op().is_none() {\n-            return;\n-        }\n-\n-        self.task_pool.handle.spawn_with_sender({\n-            let snap = self.snapshot();\n-            move |sender| {\n-                let cb = |progress| {\n-                    sender.send(Task::PrimeCaches(progress)).unwrap();\n-                };\n-                match snap.analysis.prime_caches(cb) {\n-                    Ok(()) => (),\n-                    Err(_canceled) => (),\n+        self.prime_caches_queue.request_op();\n+        if self.prime_caches_queue.should_start_op() {\n+            self.task_pool.handle.spawn_with_sender({\n+                let snap = self.snapshot();\n+                move |sender| {\n+                    let cb = |progress| {\n+                        sender.send(Task::PrimeCaches(progress)).unwrap();\n+                    };\n+                    match snap.analysis.prime_caches(cb) {\n+                        Ok(()) => (),\n+                        Err(_canceled) => (),\n+                    }\n                 }\n-            }\n-        });\n+            });\n+        }\n     }\n     fn maybe_update_diagnostics(&mut self) {\n         let subscriptions = self"}, {"sha": "e2894b3ff2c05710b185f1d74ce58befb99bcef3", "filename": "crates/rust-analyzer/src/op_queue.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Frust-analyzer%2Fsrc%2Fop_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Frust-analyzer%2Fsrc%2Fop_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fop_queue.rs?ref=f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a", "patch": "@@ -1,43 +1,43 @@\n //! Bookkeeping to make sure only one long-running operation is being executed\n //! at a time.\n \n-pub(crate) struct OpQueue<Args, Output> {\n-    op_requested: Option<Args>,\n+pub(crate) struct OpQueue<Output> {\n+    op_requested: bool,\n     op_in_progress: bool,\n     last_op_result: Output,\n }\n \n-impl<Args, Output: Default> Default for OpQueue<Args, Output> {\n+impl<Output: Default> Default for OpQueue<Output> {\n     fn default() -> Self {\n-        Self { op_requested: None, op_in_progress: false, last_op_result: Default::default() }\n+        Self { op_requested: false, op_in_progress: false, last_op_result: Default::default() }\n     }\n }\n \n-impl<Args, Output> OpQueue<Args, Output> {\n-    pub(crate) fn request_op(&mut self, data: Args) {\n-        self.op_requested = Some(data);\n+impl<Output> OpQueue<Output> {\n+    pub(crate) fn request_op(&mut self) {\n+        self.op_requested = true;\n     }\n-    pub(crate) fn should_start_op(&mut self) -> Option<Args> {\n+    pub(crate) fn should_start_op(&mut self) -> bool {\n         if self.op_in_progress {\n-            return None;\n+            return false;\n         }\n-        self.op_in_progress = self.op_requested.is_some();\n-        self.op_requested.take()\n+        self.op_in_progress = self.op_requested;\n+        self.op_requested = false;\n+        self.op_in_progress\n     }\n     pub(crate) fn op_completed(&mut self, result: Output) {\n         assert!(self.op_in_progress);\n         self.op_in_progress = false;\n         self.last_op_result = result;\n     }\n \n-    #[allow(unused)]\n     pub(crate) fn last_op_result(&self) -> &Output {\n         &self.last_op_result\n     }\n     pub(crate) fn op_in_progress(&self) -> bool {\n         self.op_in_progress\n     }\n     pub(crate) fn op_requested(&self) -> bool {\n-        self.op_requested.is_some()\n+        self.op_requested\n     }\n }"}, {"sha": "ce0e79e848fcd05b3baa3c81288f00ea74a5f3e2", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 61, "deletions": 30, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a", "patch": "@@ -1,11 +1,12 @@\n //! Project loading & configuration updates\n use std::{mem, sync::Arc};\n \n+use always_assert::always;\n use flycheck::{FlycheckConfig, FlycheckHandle};\n use hir::db::DefDatabase;\n use ide::Change;\n use ide_db::base_db::{CrateGraph, SourceRoot, VfsPath};\n-use project_model::{BuildDataCollector, BuildDataResult, ProcMacroClient, ProjectWorkspace};\n+use project_model::{ProcMacroClient, ProjectWorkspace, WorkspaceBuildScripts};\n use vfs::{file_set::FileSetConfig, AbsPath, AbsPathBuf, ChangeKind};\n \n use crate::{\n@@ -26,7 +27,7 @@ pub(crate) enum ProjectWorkspaceProgress {\n pub(crate) enum BuildDataProgress {\n     Begin,\n     Report(String),\n-    End(anyhow::Result<BuildDataResult>),\n+    End(Vec<anyhow::Result<WorkspaceBuildScripts>>),\n }\n \n impl GlobalState {\n@@ -144,10 +145,10 @@ impl GlobalState {\n     }\n \n     pub(crate) fn fetch_workspaces_request(&mut self) {\n-        self.fetch_workspaces_queue.request_op(())\n+        self.fetch_workspaces_queue.request_op()\n     }\n     pub(crate) fn fetch_workspaces_if_needed(&mut self) {\n-        if self.fetch_workspaces_queue.should_start_op().is_none() {\n+        if !self.fetch_workspaces_queue.should_start_op() {\n             return;\n         }\n         log::info!(\"will fetch workspaces\");\n@@ -207,14 +208,16 @@ impl GlobalState {\n         self.fetch_workspaces_queue.op_completed(workspaces)\n     }\n \n-    pub(crate) fn fetch_build_data_request(&mut self, build_data_collector: BuildDataCollector) {\n-        self.fetch_build_data_queue.request_op(build_data_collector);\n+    pub(crate) fn fetch_build_data_request(&mut self) {\n+        self.fetch_build_data_queue.request_op();\n     }\n     pub(crate) fn fetch_build_data_if_needed(&mut self) {\n-        let mut build_data_collector = match self.fetch_build_data_queue.should_start_op() {\n-            Some(it) => it,\n-            None => return,\n-        };\n+        if !self.fetch_build_data_queue.should_start_op() {\n+            return;\n+        }\n+\n+        let workspaces = Arc::clone(&self.workspaces);\n+        let config = self.config.cargo();\n         self.task_pool.handle.spawn_with_sender(move |sender| {\n             sender.send(Task::FetchBuildData(BuildDataProgress::Begin)).unwrap();\n \n@@ -224,15 +227,25 @@ impl GlobalState {\n                     sender.send(Task::FetchBuildData(BuildDataProgress::Report(msg))).unwrap()\n                 }\n             };\n-            let res = build_data_collector.collect(&progress);\n+            let mut res = Vec::new();\n+            for ws in workspaces.iter() {\n+                let ws = match ws {\n+                    ProjectWorkspace::Cargo { cargo, .. } => cargo,\n+                    ProjectWorkspace::DetachedFiles { .. } | ProjectWorkspace::Json { .. } => {\n+                        res.push(Ok(WorkspaceBuildScripts::default()));\n+                        continue;\n+                    }\n+                };\n+                res.push(WorkspaceBuildScripts::run(&config, ws, &progress))\n+            }\n             sender.send(Task::FetchBuildData(BuildDataProgress::End(res))).unwrap();\n         });\n     }\n     pub(crate) fn fetch_build_data_completed(\n         &mut self,\n-        build_data: anyhow::Result<BuildDataResult>,\n+        build_data: Vec<anyhow::Result<WorkspaceBuildScripts>>,\n     ) {\n-        self.fetch_build_data_queue.op_completed(Some(build_data))\n+        self.fetch_build_data_queue.op_completed(build_data)\n     }\n \n     pub(crate) fn switch_workspaces(&mut self) {\n@@ -257,12 +270,22 @@ impl GlobalState {\n             .filter_map(|res| res.as_ref().ok().cloned())\n             .collect::<Vec<_>>();\n \n-        let workspace_build_data = match self.fetch_build_data_queue.last_op_result() {\n-            Some(Ok(it)) => Some(it.clone()),\n-            None | Some(Err(_)) => None,\n-        };\n+        let mut build_scripts = self\n+            .fetch_build_data_queue\n+            .last_op_result()\n+            .iter()\n+            .map(|res| res.as_ref().ok().cloned().unwrap_or_default())\n+            .collect::<Vec<_>>();\n+\n+        // FIXME: This is not even remotely correct. I do hope that this is\n+        // eventually consistent though. We need to figure a better way to map\n+        // `cargo metadata` to `cargo check` in the future.\n+        //\n+        // I *think* what we need here is an extra field on `ProjectWorkspace`,\n+        // and a workflow to set it, once build data is ready.\n+        build_scripts.resize_with(workspaces.len(), WorkspaceBuildScripts::default);\n \n-        if *self.workspaces == workspaces && self.workspace_build_data == workspace_build_data {\n+        if *self.workspaces == workspaces && self.workspace_build_data == build_scripts {\n             return;\n         }\n \n@@ -271,7 +294,8 @@ impl GlobalState {\n                 let registration_options = lsp_types::DidChangeWatchedFilesRegistrationOptions {\n                     watchers: workspaces\n                         .iter()\n-                        .flat_map(|it| it.to_roots(workspace_build_data.as_ref()))\n+                        .zip(&build_scripts)\n+                        .flat_map(|(ws, bs)| ws.to_roots(bs))\n                         .filter(|it| it.is_member)\n                         .flat_map(|root| {\n                             root.include.into_iter().flat_map(|it| {\n@@ -304,7 +328,7 @@ impl GlobalState {\n \n         let files_config = self.config.files();\n         let project_folders =\n-            ProjectFolders::new(&workspaces, &files_config.exclude, workspace_build_data.as_ref());\n+            ProjectFolders::new(&workspaces, &build_scripts, &files_config.exclude);\n \n         if self.proc_macro_client.is_none() {\n             self.proc_macro_client = match self.config.proc_macro_srv() {\n@@ -353,9 +377,9 @@ impl GlobalState {\n                 }\n                 res\n             };\n-            for ws in workspaces.iter() {\n+            for (ws, bs) in workspaces.iter().zip(&build_scripts) {\n                 crate_graph.extend(ws.to_crate_graph(\n-                    workspace_build_data.as_ref(),\n+                    bs,\n                     self.proc_macro_client.as_ref(),\n                     &mut load,\n                 ));\n@@ -367,7 +391,7 @@ impl GlobalState {\n \n         self.source_root_config = project_folders.source_root_config;\n         self.workspaces = Arc::new(workspaces);\n-        self.workspace_build_data = workspace_build_data;\n+        self.workspace_build_data = build_scripts;\n \n         self.analysis_host.apply_change(change);\n         self.process_changes();\n@@ -392,13 +416,19 @@ impl GlobalState {\n     }\n \n     fn build_data_error(&self) -> Option<String> {\n-        match self.fetch_build_data_queue.last_op_result() {\n-            Some(Err(err)) => {\n-                Some(format!(\"rust-analyzer failed to fetch build data: {:#}\\n\", err))\n+        let mut buf = String::new();\n+\n+        for ws in self.fetch_build_data_queue.last_op_result() {\n+            if let Err(err) = ws {\n+                stdx::format_to!(buf, \"rust-analyzer failed to run custom build: {:#}\\n\", err);\n             }\n-            Some(Ok(data)) => data.error(),\n-            None => None,\n         }\n+\n+        if buf.is_empty() {\n+            return None;\n+        }\n+\n+        Some(buf)\n     }\n \n     fn reload_flycheck(&mut self) {\n@@ -451,14 +481,15 @@ pub(crate) struct ProjectFolders {\n impl ProjectFolders {\n     pub(crate) fn new(\n         workspaces: &[ProjectWorkspace],\n+        build_scripts: &[WorkspaceBuildScripts],\n         global_excludes: &[AbsPathBuf],\n-        build_data: Option<&BuildDataResult>,\n     ) -> ProjectFolders {\n+        always!(workspaces.len() == build_scripts.len());\n         let mut res = ProjectFolders::default();\n         let mut fsc = FileSetConfig::builder();\n         let mut local_filesets = vec![];\n \n-        for root in workspaces.iter().flat_map(|it| it.to_roots(build_data)) {\n+        for root in workspaces.iter().zip(build_scripts).flat_map(|(ws, bs)| ws.to_roots(bs)) {\n             let file_set_roots: Vec<VfsPath> =\n                 root.include.iter().cloned().map(VfsPath::from).collect();\n "}, {"sha": "d27f086d37bf22350413667bae9b37d8fa88cff2", "filename": "lib/arena/src/map.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/lib%2Farena%2Fsrc%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a/lib%2Farena%2Fsrc%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Farena%2Fsrc%2Fmap.rs?ref=f4de2ece0dd9fbad77f9f99f042e5188eecaaf6a", "patch": "@@ -62,6 +62,12 @@ impl<T, V> std::ops::Index<Idx<V>> for ArenaMap<Idx<V>, T> {\n     }\n }\n \n+impl<T, V> std::ops::IndexMut<Idx<V>> for ArenaMap<Idx<V>, T> {\n+    fn index_mut(&mut self, idx: Idx<V>) -> &mut T {\n+        self.v[Self::to_idx(idx)].as_mut().unwrap()\n+    }\n+}\n+\n impl<T, V> Default for ArenaMap<Idx<V>, T> {\n     fn default() -> Self {\n         ArenaMap { v: Vec::new(), _ty: PhantomData }"}]}