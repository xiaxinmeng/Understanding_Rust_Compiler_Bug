{"sha": "1beac2b774fa7081ad22f9856ebb6bb9d04297fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiZWFjMmI3NzRmYTcwODFhZDIyZjk4NTZlYmI2YmI5ZDA0Mjk3ZmI=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-01-28T23:04:18Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-02-05T18:32:01Z"}, "message": "Move code to `diagnostics.rs`", "tree": {"sha": "5d1588acf07c954f4ede9a19e886327eb0baf9f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d1588acf07c954f4ede9a19e886327eb0baf9f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1beac2b774fa7081ad22f9856ebb6bb9d04297fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1beac2b774fa7081ad22f9856ebb6bb9d04297fb", "html_url": "https://github.com/rust-lang/rust/commit/1beac2b774fa7081ad22f9856ebb6bb9d04297fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1beac2b774fa7081ad22f9856ebb6bb9d04297fb/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49f9bf897b93349464c2046047991b3e77ca0f2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/49f9bf897b93349464c2046047991b3e77ca0f2c", "html_url": "https://github.com/rust-lang/rust/commit/49f9bf897b93349464c2046047991b3e77ca0f2c"}], "stats": {"total": 414, "additions": 214, "deletions": 200}, "files": [{"sha": "2732197f3612567f8b707faa848ae94425bc6a55", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 207, "deletions": 91, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/1beac2b774fa7081ad22f9856ebb6bb9d04297fb/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1beac2b774fa7081ad22f9856ebb6bb9d04297fb/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=1beac2b774fa7081ad22f9856ebb6bb9d04297fb", "patch": "@@ -8,6 +8,7 @@ use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_feature::BUILTIN_ATTRIBUTES;\n+use rustc_hir as hir;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, CtorOf, DefKind, NonMacroAttrKind};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -19,7 +20,7 @@ use syntax::ast::{self, Ident, Path};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use crate::imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n-use crate::lifetimes::{ElisionFailureInfo, MissingLifetimeSpot};\n+use crate::lifetimes::{ElisionFailureInfo, LifetimeContext};\n use crate::path_names_to_string;\n use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind};\n use crate::{BindingError, CrateLint, HasGenericParams, LegacyScope, Module, ModuleOrUniformRoot};\n@@ -48,6 +49,40 @@ crate struct ImportSuggestion {\n     pub path: Path,\n }\n \n+crate enum MissingLifetimeSpot<'tcx> {\n+    Generics(&'tcx hir::Generics<'tcx>),\n+    HigherRanked { span: Span, span_type: ForLifetimeSpanType },\n+}\n+\n+crate enum ForLifetimeSpanType {\n+    BoundEmpty,\n+    BoundTail,\n+    TypeEmpty,\n+    TypeTail,\n+}\n+\n+impl ForLifetimeSpanType {\n+    crate fn descr(&self) -> &'static str {\n+        match self {\n+            Self::BoundEmpty | Self::BoundTail => \"bound\",\n+            Self::TypeEmpty | Self::TypeTail => \"type\",\n+        }\n+    }\n+\n+    crate fn suggestion(&self, sugg: &str) -> String {\n+        match self {\n+            Self::BoundEmpty | Self::TypeEmpty => format!(\"for<{}> \", sugg),\n+            Self::BoundTail | Self::TypeTail => format!(\", {}\", sugg),\n+        }\n+    }\n+}\n+\n+impl<'tcx> Into<MissingLifetimeSpot<'tcx>> for &'tcx hir::Generics<'tcx> {\n+    fn into(self) -> MissingLifetimeSpot<'tcx> {\n+        MissingLifetimeSpot::Generics(self)\n+    }\n+}\n+\n /// Adjust the impl span so that just the `impl` keyword is taken by removing\n /// everything after `<` (`\"impl<T> Iterator for A<T> {}\" -> \"impl\"`) and\n /// everything after the first whitespace (`\"impl Iterator for A\" -> \"impl\"`).\n@@ -1457,104 +1492,185 @@ crate fn show_candidates(\n     }\n }\n \n-crate fn report_missing_lifetime_specifiers(\n-    sess: &Session,\n-    span: Span,\n-    count: usize,\n-) -> DiagnosticBuilder<'_> {\n-    struct_span_err!(sess, span, E0106, \"missing lifetime specifier{}\", pluralize!(count))\n-}\n+impl<'tcx> LifetimeContext<'_, 'tcx> {\n+    crate fn report_missing_lifetime_specifiers(\n+        &self,\n+        span: Span,\n+        count: usize,\n+    ) -> DiagnosticBuilder<'tcx> {\n+        struct_span_err!(\n+            self.tcx.sess,\n+            span,\n+            E0106,\n+            \"missing lifetime specifier{}\",\n+            pluralize!(count)\n+        )\n+    }\n \n-crate fn add_missing_lifetime_specifiers_label(\n-    err: &mut DiagnosticBuilder<'_>,\n-    source_map: &SourceMap,\n-    span: Span,\n-    count: usize,\n-    lifetime_names: &FxHashSet<ast::Ident>,\n-    snippet: Option<&str>,\n-    missing_named_lifetime_spots: &[MissingLifetimeSpot<'_>],\n-    params: &[ElisionFailureInfo],\n-) {\n-    if count > 1 {\n-        err.span_label(span, format!(\"expected {} lifetime parameters\", count));\n-    } else {\n-        let suggest_existing = |err: &mut DiagnosticBuilder<'_>, sugg| {\n-            err.span_suggestion(\n-                span,\n-                \"consider using the named lifetime\",\n-                sugg,\n-                Applicability::MaybeIncorrect,\n-            );\n+    crate fn emit_undeclared_lifetime_error(&self, lifetime_ref: &hir::Lifetime) {\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            lifetime_ref.span,\n+            E0261,\n+            \"use of undeclared lifetime name `{}`\",\n+            lifetime_ref\n+        );\n+        err.span_label(lifetime_ref.span, \"undeclared lifetime\");\n+        for missing in &self.missing_named_lifetime_spots {\n+            match missing {\n+                MissingLifetimeSpot::Generics(generics) => {\n+                    let (span, sugg) = match &generics.params {\n+                        [] => (generics.span, format!(\"<{}>\", lifetime_ref)),\n+                        [param, ..] => (param.span.shrink_to_lo(), format!(\"{}, \", lifetime_ref)),\n+                    };\n+                    err.span_suggestion(\n+                        span,\n+                        &format!(\"consider introducing lifetime `{}` here\", lifetime_ref),\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                MissingLifetimeSpot::HigherRanked { span, span_type } => {\n+                    err.span_suggestion(\n+                        *span,\n+                        &format!(\n+                            \"consider making the {} lifetime-generic with a new `{}` lifetime\",\n+                            span_type.descr(),\n+                            lifetime_ref\n+                        ),\n+                        span_type.suggestion(&lifetime_ref.to_string()),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    err.note(\n+                        \"for more information on higher-ranked polymorphism, visit \\\n+                            https://doc.rust-lang.org/nomicon/hrtb.html\",\n+                    );\n+                }\n+            }\n+        }\n+        err.emit();\n+    }\n+\n+    crate fn is_trait_ref_fn_scope(&mut self, trait_ref: &'tcx hir::PolyTraitRef<'tcx>) -> bool {\n+        if let def::Res::Def(_, did) = trait_ref.trait_ref.path.res {\n+            if [\n+                self.tcx.lang_items().fn_once_trait(),\n+                self.tcx.lang_items().fn_trait(),\n+                self.tcx.lang_items().fn_mut_trait(),\n+            ]\n+            .contains(&Some(did))\n+            {\n+                let (span, span_type) = match &trait_ref.bound_generic_params {\n+                    [] => (trait_ref.span.shrink_to_lo(), ForLifetimeSpanType::BoundEmpty),\n+                    [.., bound] => (bound.span.shrink_to_hi(), ForLifetimeSpanType::BoundTail),\n+                };\n+                self.missing_named_lifetime_spots\n+                    .push(MissingLifetimeSpot::HigherRanked { span, span_type });\n+                return true;\n+            }\n         };\n-        let suggest_new = |err: &mut DiagnosticBuilder<'_>, sugg: &str| {\n-            err.span_label(span, \"expected named lifetime parameter\");\n-\n-            for missing in missing_named_lifetime_spots.iter().rev() {\n-                let mut introduce_suggestion = vec![];\n-                let msg;\n-                let should_break;\n-                introduce_suggestion.push(match missing {\n-                    MissingLifetimeSpot::Generics(generics) => {\n-                        msg = \"consider introducing a named lifetime parameter\".to_string();\n-                        should_break = true;\n-                        match &generics.params {\n-                            [] => (generics.span, \"<'a>\".to_string()),\n-                            [param, ..] => (param.span.shrink_to_lo(), \"'a, \".to_string()),\n+        false\n+    }\n+\n+    crate fn add_missing_lifetime_specifiers_label(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        span: Span,\n+        count: usize,\n+        lifetime_names: &FxHashSet<ast::Ident>,\n+        params: &[ElisionFailureInfo],\n+    ) {\n+        if count > 1 {\n+            err.span_label(span, format!(\"expected {} lifetime parameters\", count));\n+        } else {\n+            let snippet = self.tcx.sess.source_map().span_to_snippet(span).ok();\n+            let suggest_existing = |err: &mut DiagnosticBuilder<'_>, sugg| {\n+                err.span_suggestion(\n+                    span,\n+                    \"consider using the named lifetime\",\n+                    sugg,\n+                    Applicability::MaybeIncorrect,\n+                );\n+            };\n+            let suggest_new = |err: &mut DiagnosticBuilder<'_>, sugg: &str| {\n+                err.span_label(span, \"expected named lifetime parameter\");\n+\n+                for missing in self.missing_named_lifetime_spots.iter().rev() {\n+                    let mut introduce_suggestion = vec![];\n+                    let msg;\n+                    let should_break;\n+                    introduce_suggestion.push(match missing {\n+                        MissingLifetimeSpot::Generics(generics) => {\n+                            msg = \"consider introducing a named lifetime parameter\".to_string();\n+                            should_break = true;\n+                            match &generics.params {\n+                                [] => (generics.span, \"<'a>\".to_string()),\n+                                [param, ..] => (param.span.shrink_to_lo(), \"'a, \".to_string()),\n+                            }\n                         }\n-                    }\n-                    MissingLifetimeSpot::HigherRanked { span, span_type } => {\n-                        msg = format!(\n-                            \"consider making the {} lifetime-generic with a new `'a` lifetime\",\n-                            span_type.descr(),\n-                        );\n-                        should_break = false;\n-                        err.note(\n-                            \"for more information on higher-ranked polymorphism, visit \\\n+                        MissingLifetimeSpot::HigherRanked { span, span_type } => {\n+                            msg = format!(\n+                                \"consider making the {} lifetime-generic with a new `'a` lifetime\",\n+                                span_type.descr(),\n+                            );\n+                            should_break = false;\n+                            err.note(\n+                                \"for more information on higher-ranked polymorphism, visit \\\n                              https://doc.rust-lang.org/nomicon/hrtb.html\",\n-                        );\n-                        (*span, span_type.suggestion(\"'a\"))\n-                    }\n-                });\n-                for param in params {\n-                    if let Ok(snippet) = source_map.span_to_snippet(param.span) {\n-                        if snippet.starts_with(\"&\") && !snippet.starts_with(\"&'\") {\n-                            introduce_suggestion\n-                                .push((param.span, format!(\"&'a {}\", &snippet[1..])));\n-                        } else if snippet.starts_with(\"&'_ \") {\n-                            introduce_suggestion\n-                                .push((param.span, format!(\"&'a {}\", &snippet[4..])));\n+                            );\n+                            (*span, span_type.suggestion(\"'a\"))\n+                        }\n+                    });\n+                    for param in params {\n+                        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(param.span)\n+                        {\n+                            if snippet.starts_with(\"&\") && !snippet.starts_with(\"&'\") {\n+                                introduce_suggestion\n+                                    .push((param.span, format!(\"&'a {}\", &snippet[1..])));\n+                            } else if snippet.starts_with(\"&'_ \") {\n+                                introduce_suggestion\n+                                    .push((param.span, format!(\"&'a {}\", &snippet[4..])));\n+                            }\n                         }\n                     }\n+                    introduce_suggestion.push((span, sugg.to_string()));\n+                    err.multipart_suggestion(\n+                        &msg,\n+                        introduce_suggestion,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    if should_break {\n+                        break;\n+                    }\n                 }\n-                introduce_suggestion.push((span, sugg.to_string()));\n-                err.multipart_suggestion(&msg, introduce_suggestion, Applicability::MaybeIncorrect);\n-                if should_break {\n-                    break;\n-                }\n-            }\n-        };\n+            };\n \n-        match (lifetime_names.len(), lifetime_names.iter().next(), snippet) {\n-            (1, Some(name), Some(\"&\")) => {\n-                suggest_existing(err, format!(\"&{} \", name));\n-            }\n-            (1, Some(name), Some(\"'_\")) => {\n-                suggest_existing(err, name.to_string());\n-            }\n-            (1, Some(name), Some(snippet)) if !snippet.ends_with(\">\") => {\n-                suggest_existing(err, format!(\"{}<{}>\", snippet, name));\n-            }\n-            (0, _, Some(\"&\")) => {\n-                suggest_new(err, \"&'a \");\n-            }\n-            (0, _, Some(\"'_\")) => {\n-                suggest_new(err, \"'a\");\n-            }\n-            (0, _, Some(snippet)) if !snippet.ends_with(\">\") => {\n-                suggest_new(err, &format!(\"{}<'a>\", snippet));\n-            }\n-            _ => {\n-                err.span_label(span, \"expected lifetime parameter\");\n+            match (\n+                lifetime_names.len(),\n+                lifetime_names.iter().next(),\n+                snippet.as_ref().map(|s| s.as_str()),\n+            ) {\n+                (1, Some(name), Some(\"&\")) => {\n+                    suggest_existing(err, format!(\"&{} \", name));\n+                }\n+                (1, Some(name), Some(\"'_\")) => {\n+                    suggest_existing(err, name.to_string());\n+                }\n+                (1, Some(name), Some(snippet)) if !snippet.ends_with(\">\") => {\n+                    suggest_existing(err, format!(\"{}<{}>\", snippet, name));\n+                }\n+                (0, _, Some(\"&\")) => {\n+                    suggest_new(err, \"&'a \");\n+                }\n+                (0, _, Some(\"'_\")) => {\n+                    suggest_new(err, \"'a\");\n+                }\n+                (0, _, Some(snippet)) if !snippet.ends_with(\">\") => {\n+                    suggest_new(err, &format!(\"{}<'a>\", snippet));\n+                }\n+                _ => {\n+                    err.span_label(span, \"expected lifetime parameter\");\n+                }\n             }\n         }\n     }"}, {"sha": "0ba9b4f17068e0fbcc5a047a179133acbc74afcb", "filename": "src/librustc_resolve/lifetimes.rs", "status": "modified", "additions": 7, "deletions": 109, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/1beac2b774fa7081ad22f9856ebb6bb9d04297fb/src%2Flibrustc_resolve%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1beac2b774fa7081ad22f9856ebb6bb9d04297fb/src%2Flibrustc_resolve%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flifetimes.rs?ref=1beac2b774fa7081ad22f9856ebb6bb9d04297fb", "patch": "@@ -5,9 +5,7 @@\n //! used between functions, and they operate in a purely top-down\n //! way. Therefore, we break lifetime name resolution into a separate pass.\n \n-use crate::diagnostics::{\n-    add_missing_lifetime_specifiers_label, report_missing_lifetime_specifiers,\n-};\n+use crate::diagnostics::{ForLifetimeSpanType, MissingLifetimeSpot};\n use rustc::hir::map::Map;\n use rustc::lint;\n use rustc::middle::resolve_lifetime::*;\n@@ -153,42 +151,8 @@ struct NamedRegionMap {\n     object_lifetime_defaults: HirIdMap<Vec<ObjectLifetimeDefault>>,\n }\n \n-crate enum MissingLifetimeSpot<'tcx> {\n-    Generics(&'tcx hir::Generics<'tcx>),\n-    HigherRanked { span: Span, span_type: ForLifetimeSpanType },\n-}\n-\n-crate enum ForLifetimeSpanType {\n-    BoundEmpty,\n-    BoundTail,\n-    TypeEmpty,\n-    TypeTail,\n-}\n-\n-impl ForLifetimeSpanType {\n-    crate fn descr(&self) -> &'static str {\n-        match self {\n-            Self::BoundEmpty | Self::BoundTail => \"bound\",\n-            Self::TypeEmpty | Self::TypeTail => \"type\",\n-        }\n-    }\n-\n-    crate fn suggestion(&self, sugg: &str) -> String {\n-        match self {\n-            Self::BoundEmpty | Self::TypeEmpty => format!(\"for<{}> \", sugg),\n-            Self::BoundTail | Self::TypeTail => format!(\", {}\", sugg),\n-        }\n-    }\n-}\n-\n-impl<'tcx> Into<MissingLifetimeSpot<'tcx>> for &'tcx hir::Generics<'tcx> {\n-    fn into(self) -> MissingLifetimeSpot<'tcx> {\n-        MissingLifetimeSpot::Generics(self)\n-    }\n-}\n-\n-struct LifetimeContext<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n+crate struct LifetimeContext<'a, 'tcx> {\n+    crate tcx: TyCtxt<'tcx>,\n     map: &'a mut NamedRegionMap,\n     scope: ScopeRef<'a>,\n \n@@ -220,7 +184,7 @@ struct LifetimeContext<'a, 'tcx> {\n \n     /// When encountering an undefined named lifetime, we will suggest introducing it in these\n     /// places.\n-    missing_named_lifetime_spots: Vec<MissingLifetimeSpot<'tcx>>,\n+    crate missing_named_lifetime_spots: Vec<MissingLifetimeSpot<'tcx>>,\n }\n \n #[derive(Debug)]\n@@ -1879,49 +1843,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             self.insert_lifetime(lifetime_ref, def);\n         } else {\n-            let mut err = struct_span_err!(\n-                self.tcx.sess,\n-                lifetime_ref.span,\n-                E0261,\n-                \"use of undeclared lifetime name `{}`\",\n-                lifetime_ref\n-            );\n-            err.span_label(lifetime_ref.span, \"undeclared lifetime\");\n-            for missing in &self.missing_named_lifetime_spots {\n-                match missing {\n-                    MissingLifetimeSpot::Generics(generics) => {\n-                        let (span, sugg) = match &generics.params {\n-                            [] => (generics.span, format!(\"<{}>\", lifetime_ref)),\n-                            [param, ..] => {\n-                                (param.span.shrink_to_lo(), format!(\"{}, \", lifetime_ref))\n-                            }\n-                        };\n-                        err.span_suggestion(\n-                            span,\n-                            &format!(\"consider introducing lifetime `{}` here\", lifetime_ref),\n-                            sugg,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                    MissingLifetimeSpot::HigherRanked { span, span_type } => {\n-                        err.span_suggestion(\n-                            *span,\n-                            &format!(\n-                                \"consider making the {} lifetime-generic with a new `{}` lifetime\",\n-                                span_type.descr(),\n-                                lifetime_ref\n-                            ),\n-                            span_type.suggestion(&lifetime_ref.to_string()),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        err.note(\n-                            \"for more information on higher-ranked polymorphism, visit \\\n-                             https://doc.rust-lang.org/nomicon/hrtb.html\",\n-                        );\n-                    }\n-                }\n-            }\n-            err.emit();\n+            self.emit_undeclared_lifetime_error(lifetime_ref);\n         }\n     }\n \n@@ -2461,7 +2383,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         };\n \n-        let mut err = report_missing_lifetime_specifiers(self.tcx.sess, span, lifetime_refs.len());\n+        let mut err = self.report_missing_lifetime_specifiers(span, lifetime_refs.len());\n         let mut add_label = true;\n \n         if let Some(params) = error {\n@@ -2470,14 +2392,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         }\n         if add_label {\n-            add_missing_lifetime_specifiers_label(\n+            self.add_missing_lifetime_specifiers_label(\n                 &mut err,\n-                self.tcx.sess.source_map(),\n                 span,\n                 lifetime_refs.len(),\n                 &lifetime_names,\n-                self.tcx.sess.source_map().span_to_snippet(span).ok().as_ref().map(|s| s.as_str()),\n-                &self.missing_named_lifetime_spots,\n                 error.map(|p| &p[..]).unwrap_or(&[]),\n             );\n         }\n@@ -2827,27 +2746,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let old_value = self.map.defs.remove(&lifetime_ref.hir_id);\n         assert_eq!(old_value, Some(bad_def));\n     }\n-\n-    fn is_trait_ref_fn_scope(&mut self, trait_ref: &'tcx hir::PolyTraitRef<'tcx>) -> bool {\n-        if let Res::Def(_, did) = trait_ref.trait_ref.path.res {\n-            if [\n-                self.tcx.lang_items().fn_once_trait(),\n-                self.tcx.lang_items().fn_trait(),\n-                self.tcx.lang_items().fn_mut_trait(),\n-            ]\n-            .contains(&Some(did))\n-            {\n-                let (span, span_type) = match &trait_ref.bound_generic_params {\n-                    [] => (trait_ref.span.shrink_to_lo(), ForLifetimeSpanType::BoundEmpty),\n-                    [.., bound] => (bound.span.shrink_to_hi(), ForLifetimeSpanType::BoundTail),\n-                };\n-                self.missing_named_lifetime_spots\n-                    .push(MissingLifetimeSpot::HigherRanked { span, span_type });\n-                return true;\n-            }\n-        };\n-        false\n-    }\n }\n \n /// Detects late-bound lifetimes and inserts them into"}]}